{"source": {"path": "ackermann/ackermann.c", "function_name": "ack", "content": "/* Implement Ackermann function as recursive function that remembers its values */\nunsigned\nack(unsigned x, unsigned y)\n{\n\tdepth++;\n\tif (depth > MAX_DEPTH)\n  {\n\t\tlibmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", MAX_DEPTH);\n\t\tlibmin_fail(1);\n\t}\n\tif (x >= MAX_X)\n  {\n\t\tlibmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", MAX_X);\n\t\tlibmin_fail(1);\n\t}\n\tif (y >= MAX_Y)\n  {\n\t\tlibmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", MAX_Y);\n\t\tlibmin_fail(1);\n\t}\n\tif (a[x][y])\n    return a[x][y];\n\tif (y==0)\n    return a[x][0] = x+1;\n\tif (x==0)\n    return a[0][y] = ack(1,y-1);\n  return a[x][y] = ack(ack(x-1,y),y-1);\n}\n"}, "pseudo": {"path": "ackermann/ackermann.host.O0.pseudo", "function_name": "ack", "address": "0x11e9", "label": "ack", "content": "unsigned int __cdecl ack(unsigned int x, unsigned int y)\n{\n  unsigned int v3; // eax\n\n  if ( ++depth > 0xFFFFFF )\n  {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 0xFFFFFF);\n    libmin_fail(1);\n  }\n  if ( x > 0xFFFE )\n  {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 0xFFFF);\n    libmin_fail(1);\n  }\n  if ( y > 0xF )\n  {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  if ( a[x][y] )\n    return a[x][y];\n  if ( y )\n  {\n    if ( x )\n    {\n      v3 = ack(x - 1, y);\n      a[x][y] = ack(v3, y - 1);\n      return a[x][y];\n    }\n    else\n    {\n      a[0][y] = ack(1u, y - 1);\n      return a[0][y];\n    }\n  }\n  else\n  {\n    a[(unsigned __int64)x][0] = x + 1;\n    return a[(unsigned __int64)x][0];\n  }\n}\n"}, "pseudo_normalize": "unsigned int ack(unsigned int x, unsigned int y) {\n  unsigned int v3;\n  if (++depth > 16777215) {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 16777215);\n    libmin_fail(1);\n  }\n  if (x > 65534) {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 65535);\n    libmin_fail(1);\n  }\n  if (y > 15) {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  if (a[x][y]) return a[x][y];\n  if (y) {\n    if (x) {\n      v3 = ack(x - 1, y);\n      a[x][y] = ack(v3, y - 1);\n      return a[x][y];\n    } else {\n      a[0][y] = ack(1u, y - 1);\n      return a[0][y];\n    }\n  } else {\n    a[(unsigned long long)x][0] = x + 1;\n    return a[(unsigned long long)x][0];\n  }\n}", "binary": "ackermann/ackermann.host.O0", "assembly": "<ack>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    0x40503e(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x405035(%rip)\nmov    0x40502f(%rip),%eax\ncmp    $0xffffff,%eax\njbe    123b <ack+0x52>\nmov    $0xffffff,%esi\nlea    0x2de4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3606 <libmin_printf>\nmov    $0x1,%edi\ncall   15da <libmin_fail>\ncmpl   $0xfffe,-0x14(%rbp)\njbe    1267 <ack+0x7e>\nmov    $0xffff,%esi\nlea    0x2de8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3606 <libmin_printf>\nmov    $0x1,%edi\ncall   15da <libmin_fail>\ncmpl   $0xf,-0x18(%rbp)\njbe    1290 <ack+0xa7>\nmov    $0x10,%esi\nlea    0x2de7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3606 <libmin_printf>\nmov    $0x1,%edi\ncall   15da <libmin_fail>\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nshl    $0x4,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4fd4(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ntest   %eax,%eax\nje     12d7 <ack+0xee>\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nshl    $0x4,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4fb1(%rip),%rax\nmov    (%rdx,%rax,1),%eax\njmp    13b3 <ack+0x1ca>\ncmpl   $0x0,-0x18(%rbp)\njne    1310 <ack+0x127>\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%ecx\nmov    -0x14(%rbp),%eax\nshl    $0x6,%rax\nmov    %rax,%rdx\nlea    0x4f8c(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nshl    $0x6,%rax\nmov    %rax,%rdx\nlea    0x4f78(%rip),%rax\nmov    (%rdx,%rax,1),%eax\njmp    13b3 <ack+0x1ca>\ncmpl   $0x0,-0x14(%rbp)\njne    1354 <ack+0x16b>\nmov    -0x18(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,%esi\nmov    $0x1,%edi\ncall   11e9 <ack>\nmov    -0x18(%rbp),%edx\nlea    0x0(,%rdx,4),%rcx\nlea    0x4f46(%rip),%rdx\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f31(%rip),%rax\nmov    (%rdx,%rax,1),%eax\njmp    13b3 <ack+0x1ca>\nmov    -0x18(%rbp),%eax\nlea    -0x1(%rax),%ebx\nmov    -0x14(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x18(%rbp),%eax\nmov    %eax,%esi\nmov    %edx,%edi\ncall   11e9 <ack>\nmov    %ebx,%esi\nmov    %eax,%edi\ncall   11e9 <ack>\nmov    -0x18(%rbp),%ecx\nmov    -0x14(%rbp),%edx\nshl    $0x4,%rdx\nadd    %rcx,%rdx\nlea    0x0(,%rdx,4),%rcx\nlea    0x4eef(%rip),%rdx\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nshl    $0x4,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4ed0(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "ackermann/ackermann.c", "function_name": "main", "content": "\t\n\nint\nmain(void)\n{\n\tunsigned y,k; \n\n  max_depth = 0;\n\tfor(k=0;k<=AMAX;k++)\n  {\n\t\tlibmin_printf(\"\\nx+y=%d:\\n\\n\",k);\n\t\tfor(y=0;y<=k;y++)\n    {\n\t\t  depth = 0;  /* stack guard */\n\t\t\tlibmin_printf(\"A(%d,%d) = %d\\n\",k-y,y,ack(k-y,y));\n      if (depth > max_depth)\n        max_depth = depth;   \n\t\t}\n\t}\n  libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "ackermann/ackermann.host.O0.pseudo", "function_name": "main", "address": "0x13b9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // eax\n  unsigned int y; // [rsp+8h] [rbp-8h]\n  unsigned int k; // [rsp+Ch] [rbp-4h]\n\n  max_depth = 0;\n  for ( k = 0; k <= 5; ++k )\n  {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", k);\n    for ( y = 0; y <= k; ++y )\n    {\n      depth = 0;\n      v3 = ack(k - y, y);\n      libmin_printf(\"A(%d,%d) = %d\\n\", k - y, y, v3);\n      if ( depth > max_depth )\n        max_depth = depth;\n    }\n  }\n  libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  unsigned int y;\n  unsigned int k;\n  max_depth = 0;\n  for (k = 0; k <= 5; ++k) {\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", k);\n    for (y = 0; y <= k; ++y) {\n      depth = 0;\n      v3 = ack(k - y, y);\n      libmin_printf(\"A(%d,%d) = %d\\n\", k - y, y, v3);\n      if (depth > max_depth) max_depth = depth;\n    }\n  }\n  libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n  libmin_success();\n}", "binary": "ackermann/ackermann.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,0x404e75(%rip)\nmovl   $0x0,-0x4(%rbp)\njmp    1466 <main+0xad>\nmov    -0x4(%rbp),%eax\nmov    %eax,%esi\nlea    0x2c9f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3606 <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    145a <main+0xa1>\nmovl   $0x0,0x404e39(%rip)\nmov    -0x4(%rbp),%eax\nsub    -0x8(%rbp),%eax\nmov    -0x8(%rbp),%edx\nmov    %edx,%esi\nmov    %eax,%edi\ncall   11e9 <ack>\nmov    %eax,%ecx\nmov    -0x4(%rbp),%eax\nsub    -0x8(%rbp),%eax\nmov    -0x8(%rbp),%edx\nmov    %eax,%esi\nlea    0x2c64(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3606 <libmin_printf>\nmov    0x404e00(%rip),%edx\nmov    0x404dfe(%rip),%eax\ncmp    %eax,%edx\njbe    1456 <main+0x9d>\nmov    0x404df0(%rip),%eax\nmov    %eax,0x404dee(%rip)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njbe    13fd <main+0x44>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x5,-0x4(%rbp)\njbe    13db <main+0x22>\nmov    0x404dce(%rip),%eax\nmov    %eax,%esi\nlea    0x2c21(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3606 <libmin_printf>\ncall   3873 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "aes/aes.c", "function_name": "add_round_key", "content": "void add_round_key(uint8_t *s, const uint8_t *round_key) {\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] ^= round_key[i];\n}\n"}, "pseudo": {"path": "aes/aes.host.O0.pseudo", "function_name": "add_round_key", "address": "0x11e9", "label": "add_round_key", "content": "void __cdecl add_round_key(uint8_t *s, const uint8_t *round_key)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; i <= 15; ++i )\n    s[i] ^= round_key[i];\n}\n"}, "pseudo_normalize": "", "binary": "aes/aes.host.O0", "assembly": "<add_round_key>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1237 <add_round_key+0x4e>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rsi\nmov    -0x18(%rbp),%rax\nadd    %rsi,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0xf,-0x4(%rbp)\njle    1202 <add_round_key+0x19>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "aes/aes.c", "function_name": "aes_decrypt", "content": "void aes_decrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t round_keys[(ROUNDS + 1) * BLK_SIZE];\n  key_expansion(key, round_keys);\n\n  add_round_key(data, round_keys + ROUNDS * BLK_SIZE);\n  for (int round = 9; round > 0; round--) {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, round_keys + round * BLK_SIZE);\n    inv_mix_columns(data);\n  }\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys + 0 * BLK_SIZE);\n}\n"}, "pseudo": {"path": "aes/aes.host.O0.pseudo", "function_name": "aes_decrypt", "address": "0x1a65", "label": "aes_decrypt", "content": "void __cdecl aes_decrypt(uint8_t *data, const uint8_t *key)\n{\n  int round; // [rsp+1Ch] [rbp-C4h]\n  uint8_t round_keys[184]; // [rsp+20h] [rbp-C0h] BYREF\n  unsigned __int64 v4; // [rsp+D8h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  add_round_key(data, &round_keys[160]);\n  for ( round = 9; round > 0; --round )\n  {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, &round_keys[16 * round]);\n    inv_mix_columns(data);\n  }\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys);\n}\n"}, "pseudo_normalize": "void aes_decrypt(uint8_t *data, const uint8_t *key) {\n  int round;\n  uint8_t round_keys[184];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  add_round_key(data, &round_keys[160]);\n  for (round = 9; round > 0; --round) {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, &round_keys[16 * round]);\n    inv_mix_columns(data);\n  }\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys);\n}", "binary": "aes/aes.host.O0", "assembly": "<aes_decrypt>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xe0,%rsp\nmov    %rdi,-0xd8(%rbp)\nmov    %rsi,-0xe0(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0xc0(%rbp),%rdx\nmov    -0xe0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   179a <key_expansion>\nlea    -0xc0(%rbp),%rax\nadd    $0xa0,%rax\nmov    -0xd8(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   11e9 <add_round_key>\nmovl   $0x9,-0xc4(%rbp)\njmp    1b30 <aes_decrypt+0xcb>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1396 <inv_shift_rows>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1293 <inv_sub_bytes>\nmov    -0xc4(%rbp),%eax\nshl    $0x4,%eax\ncltq\nlea    -0xc0(%rbp),%rdx\nadd    %rax,%rdx\nmov    -0xd8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <add_round_key>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   162a <inv_mix_columns>\nsubl   $0x1,-0xc4(%rbp)\ncmpl   $0x0,-0xc4(%rbp)\njg     1ad5 <aes_decrypt+0x70>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1396 <inv_shift_rows>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1293 <inv_sub_bytes>\nlea    -0xc0(%rbp),%rdx\nmov    -0xd8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <add_round_key>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1b85 <aes_decrypt+0x120>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "aes/aes.c", "function_name": "aes_encrypt", "content": "void aes_encrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t round_keys[(ROUNDS + 1) * BLK_SIZE];\n  key_expansion(key, round_keys);\n\n  add_round_key(data, round_keys);\n  for (int round = 1; round < ROUNDS; round++) {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, round_keys + round * BLK_SIZE);\n  }\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, round_keys + ROUNDS * BLK_SIZE);\n}\n"}, "pseudo": {"path": "aes/aes.host.O0.pseudo", "function_name": "aes_encrypt", "address": "0x1943", "label": "aes_encrypt", "content": "void __cdecl aes_encrypt(uint8_t *data, const uint8_t *key)\n{\n  int round; // [rsp+1Ch] [rbp-C4h]\n  uint8_t round_keys[184]; // [rsp+20h] [rbp-C0h] BYREF\n  unsigned __int64 v4; // [rsp+D8h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  add_round_key(data, round_keys);\n  for ( round = 1; round <= 9; ++round )\n  {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, &round_keys[16 * round]);\n  }\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, &round_keys[160]);\n}\n"}, "pseudo_normalize": "void aes_encrypt(uint8_t *data, const uint8_t *key) {\n  int round;\n  uint8_t round_keys[184];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  add_round_key(data, round_keys);\n  for (round = 1; round <= 9; ++round) {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, &round_keys[16 * round]);\n  }\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, &round_keys[160]);\n}", "binary": "aes/aes.host.O0", "assembly": "<aes_encrypt>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xe0,%rsp\nmov    %rdi,-0xd8(%rbp)\nmov    %rsi,-0xe0(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0xc0(%rbp),%rdx\nmov    -0xe0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   179a <key_expansion>\nlea    -0xc0(%rbp),%rdx\nmov    -0xd8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <add_round_key>\nmovl   $0x1,-0xc4(%rbp)\njmp    1a08 <aes_encrypt+0xc5>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1241 <sub_bytes>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   12e5 <shift_rows>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1474 <mix_columns>\nmov    -0xc4(%rbp),%eax\nshl    $0x4,%eax\ncltq\nlea    -0xc0(%rbp),%rdx\nadd    %rax,%rdx\nmov    -0xd8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <add_round_key>\naddl   $0x1,-0xc4(%rbp)\ncmpl   $0x9,-0xc4(%rbp)\njle    19ad <aes_encrypt+0x6a>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   1241 <sub_bytes>\nmov    -0xd8(%rbp),%rax\nmov    %rax,%rdi\ncall   12e5 <shift_rows>\nlea    -0xc0(%rbp),%rax\nadd    $0xa0,%rax\nmov    -0xd8(%rbp),%rdx\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   11e9 <add_round_key>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1a63 <aes_encrypt+0x120>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "aes/aes.c", "function_name": "gf256_mul2", "content": "/*\n * Multiply by 0x02 in GF(2^8) using the AES irreducible polynomial.\n * If the high bit is set, reduce the result modulo 0x11B by XORing with 0x1B.\n */\nuint8_t gf256_mul2(uint8_t x) { return (x << 1) ^ ((x & 0x80) ? 0x1b : 0x00); }\n"}, "pseudo": {"path": "aes/aes.host.O0.pseudo", "function_name": "gf256_mul2", "address": "0x1447", "label": "gf256_mul2", "content": "uint8_t __cdecl gf256_mul2(uint8_t x)\n{\n  char v1; // al\n\n  if ( (x & 0x80u) == 0 )\n    v1 = 0;\n  else\n    v1 = 27;\n  return (2 * x) ^ v1;\n}\n"}, "pseudo_normalize": "uint8_t gf256_mul2(uint8_t x) {\n  char v1;\n  if ((x & 128u) == 0)\n    v1 = 0;\n  else\n    v1 = 27;\n  return (2 * x) ^ v1;\n}", "binary": "aes/aes.host.O0", "assembly": "<gf256_mul2>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmovzbl -0x4(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,%edx\nmovzbl -0x4(%rbp),%eax\ntest   %al,%al\njns    146b <gf256_mul2+0x24>\nmov    $0x1b,%eax\njmp    1470 <gf256_mul2+0x29>\nmov    $0x0,%eax\nxor    %edx,%eax\npop    %rbp\nret\n"}
{"source": {"path": "aes/aes.c", "function_name": "inv_mix_columns", "content": "void inv_mix_columns(uint8_t *s) {\n  for (int i = 0; i < 4; i++) {\n    int c = i * 4;\n    uint8_t a = s[c];\n    uint8_t b = s[c + 1];\n    uint8_t c1 = s[c + 2];\n    uint8_t d = s[c + 3];\n\n    uint8_t a1 = gf256_mul2(gf256_mul2(a ^ c1));\n    uint8_t b1 = gf256_mul2(gf256_mul2(b ^ d));\n\n    s[c] ^= a1;\n    s[c + 1] ^= b1;\n    s[c + 2] ^= a1;\n    s[c + 3] ^= b1;\n  }\n  mix_columns(s);\n}\n"}, "pseudo": {"path": "aes/aes.host.O0.pseudo", "function_name": "inv_mix_columns", "address": "0x162a", "label": "inv_mix_columns", "content": "void __cdecl inv_mix_columns(uint8_t *s)\n{\n  uint8_t v1; // al\n  uint8_t v2; // al\n  uint8_t b; // [rsp+Bh] [rbp-Dh]\n  uint8_t d; // [rsp+Dh] [rbp-Bh]\n  uint8_t a1; // [rsp+Eh] [rbp-Ah]\n  uint8_t b1; // [rsp+Fh] [rbp-9h]\n  int i; // [rsp+10h] [rbp-8h]\n  int c; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; i <= 3; ++i )\n  {\n    c = 4 * i;\n    b = s[4 * i + 1];\n    d = s[4 * i + 3];\n    v1 = gf256_mul2(s[4 * i + 2] ^ s[4 * i]);\n    a1 = gf256_mul2(v1);\n    v2 = gf256_mul2(d ^ b);\n    b1 = gf256_mul2(v2);\n    s[c] ^= a1;\n    s[c + 1] ^= b1;\n    s[c + 2] ^= a1;\n    s[c + 3] ^= b1;\n  }\n  mix_columns(s);\n}\n"}, "pseudo_normalize": "void inv_mix_columns(uint8_t *s) {\n  uint8_t v1;\n  uint8_t v2;\n  uint8_t b;\n  uint8_t d;\n  uint8_t a1;\n  uint8_t b1;\n  int i;\n  int c;\n  for (i = 0; i <= 3; ++i) {\n    c = 4 * i;\n    b = s[4 * i + 1];\n    d = s[4 * i + 3];\n    v1 = gf256_mul2(s[4 * i + 2] ^ s[4 * i]);\n    a1 = gf256_mul2(v1);\n    v2 = gf256_mul2(d ^ b);\n    b1 = gf256_mul2(v2);\n    s[c] ^= a1;\n    s[c + 1] ^= b1;\n    s[c + 2] ^= a1;\n    s[c + 3] ^= b1;\n  }\n  mix_columns(s);\n}", "binary": "aes/aes.host.O0", "assembly": "<inv_mix_columns>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1781 <inv_mix_columns+0x157>\nmov    -0x8(%rbp),%eax\nshl    $0x2,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xe(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xd(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x2(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x3(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xb(%rbp)\nmovzbl -0xe(%rbp),%eax\nxor    -0xc(%rbp),%al\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmov    %al,-0xa(%rbp)\nmovzbl -0xd(%rbp),%eax\nxor    -0xb(%rbp),%al\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmovzbl %al,%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmov    %al,-0x9(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nxor    -0xa(%rbp),%al\nmov    %al,(%rdx)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x1(%rdx),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nxor    -0x9(%rbp),%al\nmov    %al,(%rdx)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x2(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x2(%rdx),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nxor    -0xa(%rbp),%al\nmov    %al,(%rdx)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x3(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x3(%rdx),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nxor    -0x9(%rbp),%al\nmov    %al,(%rdx)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x3,-0x8(%rbp)\njle    1646 <inv_mix_columns+0x1c>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1474 <mix_columns>\nnop\nleave\nret\n"}
{"source": {"path": "aes/aes.c", "function_name": "inv_shift_rows", "content": "void inv_shift_rows(uint8_t *s) {\n  uint8_t res[BLK_SIZE];\n  uint8_t idx[BLK_SIZE] = {0, 13, 10, 7,  4,  1, 14, 11,\n                           8, 5,  2,  15, 12, 9, 6,  3};\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    res[i] = s[idx[i]];\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = res[i];\n}\n"}, "pseudo": {"path": "aes/aes.host.O0.pseudo", "function_name": "inv_shift_rows", "address": "0x1396", "label": "inv_shift_rows", "content": "void __cdecl inv_shift_rows(uint8_t *s)\n{\n  int i; // [rsp+18h] [rbp-38h]\n  int i_0; // [rsp+1Ch] [rbp-34h]\n  uint8_t res[16]; // [rsp+20h] [rbp-30h]\n  uint8_t idx[16]; // [rsp+30h] [rbp-20h]\n  unsigned __int64 v5; // [rsp+48h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  *(_QWORD *)idx = 0xB0E0104070A0D00LL;\n  *(_QWORD *)&idx[8] = 0x306090C0F020508LL;\n  for ( i = 0; i <= 15; ++i )\n    res[i] = s[idx[i]];\n  for ( i_0 = 0; i_0 <= 15; ++i_0 )\n    s[i_0] = res[i_0];\n}\n"}, "pseudo_normalize": "void inv_shift_rows(uint8_t *s) {\n  int i;\n  int i_0;\n  uint8_t res[16];\n  uint8_t idx[16];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  *(uint64_t *)idx = 796575300900752640LL;\n  *(uint64_t *)&idx[8] = 217871579370095880LL;\n  for (i = 0; i <= 15; ++i) res[i] = s[idx[i]];\n  for (i_0 = 0; i_0 <= 15; ++i_0) s[i_0] = res[i_0];\n}", "binary": "aes/aes.host.O0", "assembly": "<inv_shift_rows>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0xb0e0104070a0d00,%rax\nmovabs $0x306090c0f020508,%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovl   $0x0,-0x38(%rbp)\njmp    13fe <inv_shift_rows+0x68>\nmov    -0x38(%rbp),%eax\ncltq\nmovzbl -0x20(%rbp,%rax,1),%eax\nmovzbl %al,%edx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x38(%rbp),%eax\ncltq\nmov    %dl,-0x30(%rbp,%rax,1)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0xf,-0x38(%rbp)\njle    13da <inv_shift_rows+0x44>\nmovl   $0x0,-0x34(%rbp)\njmp    142a <inv_shift_rows+0x94>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x34(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x34(%rbp)\ncmpl   $0xf,-0x34(%rbp)\njle    140d <inv_shift_rows+0x77>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1445 <inv_shift_rows+0xaf>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "aes/aes.c", "function_name": "inv_sub_bytes", "content": "void inv_sub_bytes(uint8_t *s) {\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = inv_sbox[s[i]];\n}\n"}, "pseudo": {"path": "aes/aes.host.O0.pseudo", "function_name": "inv_sub_bytes", "address": "0x1293", "label": "inv_sub_bytes", "content": "void __cdecl inv_sub_bytes(uint8_t *s)\n{\n  int i; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; i <= 15; ++i )\n    s[i] = inv_sbox[s[i]];\n}\n"}, "pseudo_normalize": "", "binary": "aes/aes.host.O0", "assembly": "<inv_sub_bytes>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    12db <inv_sub_bytes+0x48>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\ncltq\nlea    0x5e4f(%rip),%rcx\nmovzbl (%rax,%rcx,1),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0xf,-0x4(%rbp)\njle    12a8 <inv_sub_bytes+0x15>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "aes/aes.c", "function_name": "key_expansion", "content": "// Simple 128-bit key expansion for 10 rounds\nvoid key_expansion(const uint8_t *key, uint8_t *round_keys) {\n  static const uint8_t rcon[10] = {0x01, 0x02, 0x04, 0x08, 0x10,\n                                   0x20, 0x40, 0x80, 0x1B, 0x36};\n  for (int i = 0; i < BLK_SIZE; i++)\n    round_keys[i] = key[i];\n\n  for (int i = 1; i <= ROUNDS; i++) {\n    uint8_t *prev = &round_keys[BLK_SIZE * (i - 1)];\n    uint8_t *curr = &round_keys[BLK_SIZE * i];\n    curr[0] = prev[0] ^ sbox[prev[13]] ^ rcon[i - 1];\n    curr[1] = prev[1] ^ sbox[prev[14]];\n    curr[2] = prev[2] ^ sbox[prev[15]];\n    curr[3] = prev[3] ^ sbox[prev[12]];\n    for (int j = 4; j < BLK_SIZE; j++)\n      curr[j] = curr[j - 4] ^ prev[j];\n  }\n}\n"}, "pseudo": {"path": "aes/aes.host.O0.pseudo", "function_name": "key_expansion", "address": "0x179a", "label": "key_expansion", "content": "void __cdecl key_expansion(const uint8_t *key, uint8_t *round_keys)\n{\n  int i; // [rsp+14h] [rbp-1Ch]\n  int i_0; // [rsp+18h] [rbp-18h]\n  int j; // [rsp+1Ch] [rbp-14h]\n  uint8_t *prev; // [rsp+20h] [rbp-10h]\n  uint8_t *curr; // [rsp+28h] [rbp-8h]\n\n  for ( i = 0; i <= 15; ++i )\n    round_keys[i] = key[i];\n  for ( i_0 = 1; i_0 <= 10; ++i_0 )\n  {\n    prev = &round_keys[16 * i_0 - 16];\n    curr = &round_keys[16 * i_0];\n    *curr = rcon_0[i_0 - 1] ^ sbox[prev[13]] ^ *prev;\n    curr[1] = prev[1] ^ sbox[prev[14]];\n    curr[2] = prev[2] ^ sbox[prev[15]];\n    curr[3] = prev[3] ^ sbox[prev[12]];\n    for ( j = 4; j <= 15; ++j )\n      curr[j] = curr[j - 4] ^ prev[j];\n  }\n}\n"}, "pseudo_normalize": "void key_expansion(const uint8_t *key, uint8_t *round_keys) {\n  int i;\n  int i_0;\n  int j;\n  uint8_t *prev;\n  uint8_t *curr;\n  for (i = 0; i <= 15; ++i) round_keys[i] = key[i];\n  for (i_0 = 1; i_0 <= 10; ++i_0) {\n    prev = &round_keys[16 * i_0 - 16];\n    curr = &round_keys[16 * i_0];\n    *curr = rcon_0[i_0 - 1] ^ sbox[prev[13]] ^ *prev;\n    curr[1] = prev[1] ^ sbox[prev[14]];\n    curr[2] = prev[2] ^ sbox[prev[15]];\n    curr[3] = prev[3] ^ sbox[prev[12]];\n    for (j = 4; j <= 15; ++j) curr[j] = curr[j - 4] ^ prev[j];\n  }\n}", "binary": "aes/aes.host.O0", "assembly": "<key_expansion>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    17d6 <key_expansion+0x3c>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x30(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0xf,-0x1c(%rbp)\njle    17b3 <key_expansion+0x19>\nmovl   $0x1,-0x18(%rbp)\njmp    1935 <key_expansion+0x19b>\nmov    -0x18(%rbp),%eax\nsub    $0x1,%eax\nshl    $0x4,%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%eax\nshl    $0x4,%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xd,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\ncltq\nlea    0x57ef(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nxor    %eax,%ecx\nmov    -0x18(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x386a(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nxor    %eax,%ecx\nmov    %ecx,%edx\nmov    -0x8(%rbp),%rax\nmov    %dl,(%rax)\nmov    -0x10(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xe,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\ncltq\nlea    0x57aa(%rip),%rdx\nmovzbl (%rax,%rdx,1),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\nmov    -0x10(%rbp),%rax\nadd    $0x2,%rax\nmovzbl (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xf,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\ncltq\nlea    0x5778(%rip),%rdx\nmovzbl (%rax,%rdx,1),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x2,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\nmov    -0x10(%rbp),%rax\nadd    $0x3,%rax\nmovzbl (%rax),%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\ncltq\nlea    0x5746(%rip),%rdx\nmovzbl (%rax,%rdx,1),%edx\nmov    -0x8(%rbp),%rax\nadd    $0x3,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\nmovl   $0x4,-0x14(%rbp)\njmp    192b <key_expansion+0x191>\nmov    -0x14(%rbp),%eax\ncltq\nlea    -0x4(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rsi\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\naddl   $0x1,-0x14(%rbp)\ncmpl   $0xf,-0x14(%rbp)\njle    18f3 <key_expansion+0x159>\naddl   $0x1,-0x18(%rbp)\ncmpl   $0xa,-0x18(%rbp)\njle    17e8 <key_expansion+0x4e>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "aes/aes.c", "function_name": "main", "content": "int main(void) {\n  uint8_t key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,\n                     0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};\n\n  char *plaintext = \"This is a test!!\";\n  if (libmin_strlen(plaintext) != BLK_SIZE) {\n    libmin_fail(1);\n  }\n\n  uint8_t ciphertext[BLK_SIZE];\n  uint8_t decrypted[BLK_SIZE];\n\n  libmin_memcpy(ciphertext, plaintext, BLK_SIZE);\n  aes_encrypt(ciphertext, key);\n\n  uint8_t ref_ciphertext[BLK_SIZE] = {0xf8, 0x6e, 0x9e, 0x4e, 0x8d, 0x38,\n                                      0x05, 0xe9, 0x72, 0x9f, 0xf1, 0x55,\n                                      0xe5, 0x17, 0xbd, 0x65};\n\n  for (int i = 0; i < BLK_SIZE; i++) {\n    if (ref_ciphertext[i] != ciphertext[i]) {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", ref_ciphertext[i],\n                    ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n\n  libmin_memcpy(decrypted, ciphertext, BLK_SIZE);\n  aes_decrypt(decrypted, key);\n\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", plaintext);\n  libmin_printf(\"  ciphertext: \");\n  for (int i = 0; i < BLK_SIZE; i++) {\n    libmin_printf(\"%02x \", ciphertext[i]);\n  }\n\n  libmin_printf(\"\\n\");\n\n  libmin_printf(\"  decrypted:  \");\n  for (int i = 0; i < BLK_SIZE; i++) {\n    libmin_printf(\"%c\", decrypted[i]);\n  }\n  libmin_printf(\"\\n\");\n\n  for (int i = 0; i < BLK_SIZE; i++) {\n    if (decrypted[i] != plaintext[i]) {\n      libmin_fail(3);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "aes/aes.host.O0.pseudo", "function_name": "main", "address": "0x1b87", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+8h] [rbp-68h]\n  int i_0; // [rsp+Ch] [rbp-64h]\n  int i_1; // [rsp+10h] [rbp-60h]\n  int i_2; // [rsp+14h] [rbp-5Ch]\n  uint8_t key[16]; // [rsp+20h] [rbp-50h] BYREF\n  uint8_t ciphertext[16]; // [rsp+30h] [rbp-40h] BYREF\n  uint8_t decrypted[16]; // [rsp+40h] [rbp-30h] BYREF\n  uint8_t ref_ciphertext[16]; // [rsp+50h] [rbp-20h]\n  unsigned __int64 v11; // [rsp+68h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  *(_QWORD *)key = 0xA6D2AE2816157E2BLL;\n  *(_QWORD *)&key[8] = 0x3C4FCF098815F7ABLL;\n  if ( libmin_strlen(\"This is a test!!\") != 16 )\n    libmin_fail(1);\n  libmin_memcpy(ciphertext, \"This is a test!!\", 0x10uLL);\n  aes_encrypt(ciphertext, key);\n  *(_QWORD *)ref_ciphertext = 0xE905388D4E9E6EF8LL;\n  *(_QWORD *)&ref_ciphertext[8] = 0x65BD17E555F19F72LL;\n  for ( i = 0; i <= 15; ++i )\n  {\n    if ( ref_ciphertext[i] != ciphertext[i] )\n    {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", ref_ciphertext[i], ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n  libmin_memcpy(decrypted, ciphertext, 0x10uLL);\n  aes_decrypt(decrypted, key);\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n  libmin_printf(\"  ciphertext: \");\n  for ( i_0 = 0; i_0 <= 15; ++i_0 )\n    libmin_printf(\"%02x \", ciphertext[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"  decrypted:  \");\n  for ( i_1 = 0; i_1 <= 15; ++i_1 )\n    libmin_printf(\"%c\", decrypted[i_1]);\n  libmin_printf(\"\\n\");\n  for ( i_2 = 0; i_2 <= 15; ++i_2 )\n  {\n    if ( decrypted[i_2] != aThisIsATest[i_2] )\n      libmin_fail(3);\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int i_0;\n  int i_1;\n  int i_2;\n  uint8_t key[16];\n  uint8_t ciphertext[16];\n  uint8_t decrypted[16];\n  uint8_t ref_ciphertext[16];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  *(uint64_t *)key = 12020861842597707307LL;\n  *(uint64_t *)&key[8] = 4345919805280614315LL;\n  if (libmin_strlen(\"This is a test!!\") != 16) libmin_fail(1);\n  libmin_memcpy(ciphertext, \"This is a test!!\", 16uLL);\n  aes_encrypt(ciphertext, key);\n  *(uint64_t *)ref_ciphertext = 16790888965281312504LL;\n  *(uint64_t *)&ref_ciphertext[8] = 7331042042185883506LL;\n  for (i = 0; i <= 15; ++i) {\n    if (ref_ciphertext[i] != ciphertext[i]) {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", ref_ciphertext[i],\n                    ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n  libmin_memcpy(decrypted, ciphertext, 16uLL);\n  aes_decrypt(decrypted, key);\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n  libmin_printf(\"  ciphertext: \");\n  for (i_0 = 0; i_0 <= 15; ++i_0) libmin_printf(\"%02x \", ciphertext[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"  decrypted:  \");\n  for (i_1 = 0; i_1 <= 15; ++i_1) libmin_printf(\"%c\", decrypted[i_1]);\n  libmin_printf(\"\\n\");\n  for (i_2 = 0; i_2 <= 15; ++i_2) {\n    if (decrypted[i_2] != aThisIsATest[i_2]) libmin_fail(3);\n  }\n  libmin_success();\n}", "binary": "aes/aes.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0xa6d2ae2816157e2b,%rax\nmovabs $0x3c4fcf098815f7ab,%rdx\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nlea    0x3443(%rip),%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   4213 <libmin_strlen>\ncmp    $0x10,%rax\nje     1be5 <main+0x5e>\nmov    $0x1,%edi\ncall   1f63 <libmin_fail>\nmov    -0x58(%rbp),%rcx\nlea    -0x40(%rbp),%rax\nmov    $0x10,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f95 <libmin_memcpy>\nlea    -0x50(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1943 <aes_encrypt>\nmovabs $0xe905388d4e9e6ef8,%rax\nmovabs $0x65bd17e555f19f72,%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovl   $0x0,-0x68(%rbp)\njmp    1ca4 <main+0x11d>\nmov    -0x68(%rbp),%eax\ncltq\nmovzbl -0x20(%rbp,%rax,1),%edx\nmov    -0x68(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\ncmp    %al,%dl\nje     1ca0 <main+0x119>\nmov    -0x68(%rbp),%eax\nmov    %eax,%esi\nlea    0x33c7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nmov    -0x68(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\nmovzbl %al,%edx\nmov    -0x68(%rbp),%eax\ncltq\nmovzbl -0x20(%rbp,%rax,1),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x33b7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nmov    $0x2,%edi\ncall   1f63 <libmin_fail>\naddl   $0x1,-0x68(%rbp)\ncmpl   $0xf,-0x68(%rbp)\njle    1c35 <main+0xae>\nlea    -0x40(%rbp),%rcx\nlea    -0x30(%rbp),%rax\nmov    $0x10,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f95 <libmin_memcpy>\nlea    -0x50(%rbp),%rdx\nlea    -0x30(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1a65 <aes_decrypt>\nlea    0x337f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3379(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nlea    0x3377(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nmovl   $0x0,-0x64(%rbp)\njmp    1d48 <main+0x1c1>\nmov    -0x64(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x335a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\naddl   $0x1,-0x64(%rbp)\ncmpl   $0xf,-0x64(%rbp)\njle    1d21 <main+0x19a>\nlea    0x3342(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nlea    0x3330(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nmovl   $0x0,-0x60(%rbp)\njmp    1da6 <main+0x21f>\nmov    -0x60(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x3313(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\naddl   $0x1,-0x60(%rbp)\ncmpl   $0xf,-0x60(%rbp)\njle    1d7f <main+0x1f8>\nlea    0x32e4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fe4 <libmin_printf>\nmovl   $0x0,-0x5c(%rbp)\njmp    1dfb <main+0x274>\nmov    -0x5c(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmovzbl %al,%edx\nmov    -0x5c(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x58(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncmp    %eax,%edx\nje     1df7 <main+0x270>\nmov    $0x3,%edi\ncall   1f63 <libmin_fail>\naddl   $0x1,-0x5c(%rbp)\ncmpl   $0xf,-0x5c(%rbp)\njle    1dc9 <main+0x242>\ncall   4251 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1e1f <main+0x298>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "aes/aes.c", "function_name": "mix_columns", "content": "void mix_columns(uint8_t *s) {\n  for (int i = 0; i < 4; i++) {\n    int c = i * 4;\n    uint8_t a = s[c];\n    uint8_t b = s[c + 1];\n    uint8_t c1 = s[c + 2];\n    uint8_t d = s[c + 3];\n    uint8_t r = a ^ b ^ c1 ^ d;\n\n    uint8_t x = a ^ b;\n    x = gf256_mul2(x);\n    s[c] ^= x ^ r;\n\n    x = b ^ c1;\n    x = gf256_mul2(x);\n    s[c + 1] ^= x ^ r;\n\n    x = c1 ^ d;\n    x = gf256_mul2(x);\n    s[c + 2] ^= x ^ r;\n\n    x = d ^ a;\n    x = gf256_mul2(x);\n    s[c + 3] ^= x ^ r;\n  }\n}\n"}, "pseudo": {"path": "aes/aes.host.O0.pseudo", "function_name": "mix_columns", "address": "0x1474", "label": "mix_columns", "content": "void __cdecl mix_columns(uint8_t *s)\n{\n  uint8_t a; // [rsp+Ah] [rbp-Eh]\n  uint8_t b; // [rsp+Bh] [rbp-Dh]\n  uint8_t c1; // [rsp+Ch] [rbp-Ch]\n  uint8_t d; // [rsp+Dh] [rbp-Bh]\n  uint8_t r; // [rsp+Eh] [rbp-Ah]\n  int i; // [rsp+10h] [rbp-8h]\n  int c; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; i <= 3; ++i )\n  {\n    c = 4 * i;\n    a = s[4 * i];\n    b = s[4 * i + 1];\n    c1 = s[4 * i + 2];\n    d = s[4 * i + 3];\n    r = d ^ c1 ^ b ^ a;\n    s[c] ^= r ^ gf256_mul2(b ^ a);\n    s[c + 1] ^= r ^ gf256_mul2(c1 ^ b);\n    s[c + 2] ^= r ^ gf256_mul2(d ^ c1);\n    s[c + 3] ^= r ^ gf256_mul2(a ^ d);\n  }\n}\n"}, "pseudo_normalize": "void mix_columns(uint8_t *s) {\n  uint8_t a;\n  uint8_t b;\n  uint8_t c1;\n  uint8_t d;\n  uint8_t r;\n  int i;\n  int c;\n  for (i = 0; i <= 3; ++i) {\n    c = 4 * i;\n    a = s[4 * i];\n    b = s[4 * i + 1];\n    c1 = s[4 * i + 2];\n    d = s[4 * i + 3];\n    r = d ^ c1 ^ b ^ a;\n    s[c] ^= r ^ gf256_mul2(b ^ a);\n    s[c + 1] ^= r ^ gf256_mul2(c1 ^ b);\n    s[c + 2] ^= r ^ gf256_mul2(d ^ c1);\n    s[c + 3] ^= r ^ gf256_mul2(a ^ d);\n  }\n}", "binary": "aes/aes.host.O0", "assembly": "<mix_columns>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    161c <mix_columns+0x1a8>\nmov    -0x8(%rbp),%eax\nshl    $0x2,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xe(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xd(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x2(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x3(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0xb(%rbp)\nmovzbl -0xe(%rbp),%eax\nxor    -0xd(%rbp),%al\nxor    -0xc(%rbp),%al\nxor    -0xb(%rbp),%al\nmov    %al,-0xa(%rbp)\nmovzbl -0xe(%rbp),%eax\nxor    -0xd(%rbp),%al\nmov    %al,-0x9(%rbp)\nmovzbl -0x9(%rbp),%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmov    %al,-0x9(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmovzbl -0x9(%rbp),%eax\nxor    -0xa(%rbp),%al\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rsi\nmov    -0x18(%rbp),%rax\nadd    %rsi,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\nmovzbl -0xd(%rbp),%eax\nxor    -0xc(%rbp),%al\nmov    %al,-0x9(%rbp)\nmovzbl -0x9(%rbp),%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmov    %al,-0x9(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmovzbl -0x9(%rbp),%eax\nxor    -0xa(%rbp),%al\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x1(%rax),%rsi\nmov    -0x18(%rbp),%rax\nadd    %rsi,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\nmovzbl -0xc(%rbp),%eax\nxor    -0xb(%rbp),%al\nmov    %al,-0x9(%rbp)\nmovzbl -0x9(%rbp),%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmov    %al,-0x9(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x2(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmovzbl -0x9(%rbp),%eax\nxor    -0xa(%rbp),%al\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x2(%rax),%rsi\nmov    -0x18(%rbp),%rax\nadd    %rsi,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\nmovzbl -0xb(%rbp),%eax\nxor    -0xe(%rbp),%al\nmov    %al,-0x9(%rbp)\nmovzbl -0x9(%rbp),%eax\nmov    %eax,%edi\ncall   1447 <gf256_mul2>\nmov    %al,-0x9(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x3(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmovzbl -0x9(%rbp),%eax\nxor    -0xa(%rbp),%al\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x3(%rax),%rsi\nmov    -0x18(%rbp),%rax\nadd    %rsi,%rax\nxor    %ecx,%edx\nmov    %dl,(%rax)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x3,-0x8(%rbp)\njle    1490 <mix_columns+0x1c>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "aes/aes.c", "function_name": "shift_rows", "content": "void shift_rows(uint8_t *s) {\n  uint8_t res[BLK_SIZE];\n  uint8_t idx[BLK_SIZE] = {0, 5,  10, 15, 4,  9, 14, 3,\n                           8, 13, 2,  7,  12, 1, 6,  11};\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    res[i] = s[idx[i]];\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = res[i];\n}\n"}, "pseudo": {"path": "aes/aes.host.O0.pseudo", "function_name": "shift_rows", "address": "0x12e5", "label": "shift_rows", "content": "void __cdecl shift_rows(uint8_t *s)\n{\n  int i; // [rsp+18h] [rbp-38h]\n  int i_0; // [rsp+1Ch] [rbp-34h]\n  uint8_t res[16]; // [rsp+20h] [rbp-30h]\n  uint8_t idx[16]; // [rsp+30h] [rbp-20h]\n  unsigned __int64 v5; // [rsp+48h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  *(_QWORD *)idx = 0x30E09040F0A0500LL;\n  *(_QWORD *)&idx[8] = 0xB06010C07020D08LL;\n  for ( i = 0; i <= 15; ++i )\n    res[i] = s[idx[i]];\n  for ( i_0 = 0; i_0 <= 15; ++i_0 )\n    s[i_0] = res[i_0];\n}\n"}, "pseudo_normalize": "void shift_rows(uint8_t *s) {\n  int i;\n  int i_0;\n  uint8_t res[16];\n  uint8_t idx[16];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  *(uint64_t *)idx = 220123344824567040LL;\n  *(uint64_t *)&idx[8] = 794323535446281480LL;\n  for (i = 0; i <= 15; ++i) res[i] = s[idx[i]];\n  for (i_0 = 0; i_0 <= 15; ++i_0) s[i_0] = res[i_0];\n}", "binary": "aes/aes.host.O0", "assembly": "<shift_rows>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0x30e09040f0a0500,%rax\nmovabs $0xb06010c07020d08,%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovl   $0x0,-0x38(%rbp)\njmp    134d <shift_rows+0x68>\nmov    -0x38(%rbp),%eax\ncltq\nmovzbl -0x20(%rbp,%rax,1),%eax\nmovzbl %al,%edx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x38(%rbp),%eax\ncltq\nmov    %dl,-0x30(%rbp,%rax,1)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0xf,-0x38(%rbp)\njle    1329 <shift_rows+0x44>\nmovl   $0x0,-0x34(%rbp)\njmp    1379 <shift_rows+0x94>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x34(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x34(%rbp)\ncmpl   $0xf,-0x34(%rbp)\njle    135c <shift_rows+0x77>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1394 <shift_rows+0xaf>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "AddWords", "content": "/* AddWords -- build the list of candidates */\nvoid\nAddWords(void) {\n    char * pch = pchDictionary;     /* walk through the dictionary */\n\n    cpwCand = 0;\n\n    while (*pch) {\n        if ((pch[1] >= cchMinLength && pch[1]+cchMinLength <= cchPhraseLength)\n            || pch[1] == cchPhraseLength)\n\t    BuildWord(pch+2);\n        pch += *pch;\n    }\n\n    libmin_printf(\"%d candidates\\n\", cpwCand);\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "AddWords", "address": "0x1a06", "label": "AddWords", "content": "void __cdecl AddWords()\n{\n  char *pch; // [rsp+8h] [rbp-8h]\n\n  pch = pchDictionary;\n  cpwCand = 0;\n  while ( *pch )\n  {\n    if ( pch[1] >= cchMinLength && cchMinLength + pch[1] <= cchPhraseLength || pch[1] == cchPhraseLength )\n      BuildWord(pch + 2);\n    pch += *pch;\n  }\n  libmin_printf(\"%d candidates\\n\", cpwCand);\n}\n"}, "pseudo_normalize": "void AddWords() {\n  char *pch;\n  pch = pchDictionary;\n  cpwCand = 0;\n  while (*pch) {\n    if (pch[1] >= cchMinLength && cchMinLength + pch[1] <= cchPhraseLength ||\n        pch[1] == cchPhraseLength)\n      BuildWord(pch + 2);\n    pch += *pch;\n  }\n  libmin_printf(\"%d candidates\\n\", cpwCand);\n}", "binary": "anagram/anagram.host.O0", "assembly": "<AddWords>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    0x427b7(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,0x42519(%rip)\njmp    1a98 <AddWords+0x92>\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    0x385d3(%rip),%eax\ncmp    %eax,%edx\njl     1a61 <AddWords+0x5b>\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    0x385bb(%rip),%eax\nadd    %eax,%edx\nmov    0x426a3(%rip),%eax\ncmp    %eax,%edx\njle    1a79 <AddWords+0x73>\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    0x4268b(%rip),%eax\ncmp    %eax,%edx\njne    1a89 <AddWords+0x83>\nmov    -0x8(%rbp),%rax\nadd    $0x2,%rax\nmov    %rax,%rdi\ncall   17e5 <BuildWord>\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1a29 <AddWords+0x23>\nmov    0x42497(%rip),%eax\nmov    %eax,%esi\nlea    0x357e2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "BuildMask", "content": "void BuildMask(char * pchPhrase) {\n    int i;\n    int ch;\n    unsigned iq;                        /* which Quad? */\n    int cbtUsed;                        /* bits used in the current Quad */\n    int cbtNeed;                        /* bits needed for current letter */\n    Quad qNeed;                         /* used to build the mask */\n\n    libmin_memset(alPhrase, 0, sizeof(Letter)*ALPHABET);\n    libmin_memset(aqMainMask, 0, sizeof(Quad)*MAX_QUADS);\n    libmin_memset(aqMainSign, 0, sizeof(Quad)*MAX_QUADS);\n/*\n    Zero(alPhrase);\n    Zero(aqMainMask);\n    Zero(aqMainSign);\n*/\n\n    /* Tabulate letter frequencies in the phrase */\n    cchPhraseLength = 0;\n    while ((ch = *pchPhrase++) != '\\0') {\n        if (isalpha(ch)) {\n            ch = tolower(ch);\n            lPhrase(ch).uFrequency++;\n            cchPhraseLength++;\n        }\n    }\n\n    /* Build  masks */\n    iq = 0;                             /* which quad being used */\n    cbtUsed = 0;                        /* bits used so far */\n\n    for (i = 0; i < ALPHABET; i++) {\n        if (alPhrase[i].uFrequency == 0) {\n            auGlobalFrequency[i] = ~0;  /* to make it sort last */\n        } else {\n            auGlobalFrequency[i] = 0;\n            for (cbtNeed = 1, qNeed = 1;\n                 alPhrase[i].uFrequency >= qNeed;\n                 cbtNeed++, qNeed <<= 1);\n            if (cbtUsed + cbtNeed > MASK_BITS) {\n                if (++iq >= MAX_QUADS)\n\t\t    Fatal(\"MAX_QUADS not large enough\\n\", 0);\n                cbtUsed = 0;\n            }\n            alPhrase[i].uBits = qNeed-1;\n            if (cbtUsed)\n\t\tqNeed <<= cbtUsed;\n            aqMainSign[iq] |= qNeed;\n            aqMainMask[iq] |= (Quad)alPhrase[i].uFrequency << cbtUsed;\n            alPhrase[i].uShift = cbtUsed;\n            alPhrase[i].iq = iq;\n            cbtUsed += cbtNeed;\n        }\n    }\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "BuildMask", "address": "0x13e7", "label": "BuildMask", "content": "void __cdecl BuildMask(char *pchPhrase)\n{\n  int v1; // eax\n  char *v2; // rax\n  bool v3; // cf\n  int i; // [rsp+14h] [rbp-1Ch]\n  unsigned int iq; // [rsp+18h] [rbp-18h]\n  unsigned int cbtUsed; // [rsp+1Ch] [rbp-14h]\n  int cbtNeed; // [rsp+20h] [rbp-10h]\n  Quad qNeed; // [rsp+28h] [rbp-8h]\n\n  libmin_memset(alPhrase, 0, 0x1A0uLL);\n  libmin_memset(aqMainMask, 0, 0x10uLL);\n  libmin_memset(aqMainSign, 0, 0x10uLL);\n  cchPhraseLength = 0;\n  while ( 1 )\n  {\n    v2 = pchPhrase++;\n    if ( !*v2 )\n      break;\n    if ( (pctype[*v2] & 3) != 0 )\n    {\n      if ( (pctype[*v2] & 1) != 0 )\n        v1 = *v2 + 32;\n      else\n        v1 = *v2;\n      ++alPhrase[v1 - 97].uFrequency;\n      ++cchPhraseLength;\n    }\n  }\n  iq = 0;\n  cbtUsed = 0;\n  for ( i = 0; i <= 25; ++i )\n  {\n    if ( alPhrase[i].uFrequency )\n    {\n      auGlobalFrequency[i] = 0;\n      cbtNeed = 1;\n      for ( qNeed = 1LL; qNeed <= alPhrase[i].uFrequency; qNeed *= 2LL )\n        ++cbtNeed;\n      if ( (int)(cbtUsed + cbtNeed) > 32 )\n      {\n        v3 = iq++ == -1;\n        if ( !v3 && iq != 1 )\n          Fatal(\"MAX_QUADS not large enough\\n\", 0);\n        cbtUsed = 0;\n      }\n      alPhrase[i].uBits = qNeed - 1;\n      if ( cbtUsed )\n        qNeed <<= cbtUsed;\n      aqMainSign[iq] |= qNeed;\n      aqMainMask[iq] |= (unsigned __int64)alPhrase[i].uFrequency << cbtUsed;\n      alPhrase[i].uShift = cbtUsed;\n      alPhrase[i].iq = iq;\n      cbtUsed += cbtNeed;\n    }\n    else\n    {\n      auGlobalFrequency[i] = -1;\n    }\n  }\n}\n"}, "pseudo_normalize": "void BuildMask(char *pchPhrase) {\n  int v1;\n  char *v2;\n  bool v3;\n  int i;\n  unsigned int iq;\n  unsigned int cbtUsed;\n  int cbtNeed;\n  Quad qNeed;\n  libmin_memset(alPhrase, 0, 416uLL);\n  libmin_memset(aqMainMask, 0, 16uLL);\n  libmin_memset(aqMainSign, 0, 16uLL);\n  cchPhraseLength = 0;\n  while (1) {\n    v2 = pchPhrase++;\n    if (!*v2) break;\n    if ((pctype[*v2] & 3) != 0) {\n      if ((pctype[*v2] & 1) != 0)\n        v1 = *v2 + 32;\n      else\n        v1 = *v2;\n      ++alPhrase[v1 - 97].uFrequency;\n      ++cchPhraseLength;\n    }\n  }\n  iq = 0;\n  cbtUsed = 0;\n  for (i = 0; i <= 25; ++i) {\n    if (alPhrase[i].uFrequency) {\n      auGlobalFrequency[i] = 0;\n      cbtNeed = 1;\n      for (qNeed = 1LL; qNeed <= alPhrase[i].uFrequency; qNeed *= 2LL)\n        ++cbtNeed;\n      if ((int)(cbtUsed + cbtNeed) > 32) {\n        v3 = iq++ == -1;\n        if (!v3 && iq != 1) Fatal(\"MAX_QUADS not large enough\\n\", 0);\n        cbtUsed = 0;\n      }\n      alPhrase[i].uBits = qNeed - 1;\n      if (cbtUsed) qNeed <<= cbtUsed;\n      aqMainSign[iq] |= qNeed;\n      aqMainMask[iq] |= (unsigned long long)alPhrase[i].uFrequency << cbtUsed;\n      alPhrase[i].uShift = cbtUsed;\n      alPhrase[i].iq = iq;\n      cbtUsed += cbtNeed;\n    } else {\n      auGlobalFrequency[i] = -1;\n    }\n  }\n}", "binary": "anagram/anagram.host.O0", "assembly": "<BuildMask>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    $0x1a0,%edx\nmov    $0x0,%esi\nlea    0x42b58(%rip),%rax\nmov    %rax,%rdi\ncall   26b4 <libmin_memset>\nmov    $0x10,%edx\nmov    $0x0,%esi\nlea    0x42cef(%rip),%rax\nmov    %rax,%rdi\ncall   26b4 <libmin_memset>\nmov    $0x10,%edx\nmov    $0x0,%esi\nlea    0x42ce6(%rip),%rax\nmov    %rax,%rdi\ncall   26b4 <libmin_memset>\nmovl   $0x0,0x42cb4(%rip)\njmp    14dc <BuildMask+0xf5>\nmov    0x38e50(%rip),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x3,%eax\ntest   %eax,%eax\nje     14dc <BuildMask+0xf5>\nmov    0x38e31(%rip),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1497 <BuildMask+0xb0>\nmov    -0xc(%rbp),%eax\nadd    $0x20,%eax\njmp    149a <BuildMask+0xb3>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nsub    $0x61,%eax\nmovslq %eax,%rdx\nmov    %rdx,%rcx\nshl    $0x4,%rcx\nlea    0x42aac(%rip),%rdx\nmov    (%rcx,%rdx,1),%edx\nlea    0x1(%rdx),%ecx\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x42a96(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    0x42c2d(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x42c24(%rip)\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x28(%rbp)\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njne    1451 <BuildMask+0x6a>\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    16c1 <BuildMask+0x2da>\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x42a38(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ntest   %eax,%eax\njne    154f <BuildMask+0x168>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x42bfd(%rip),%rax\nmovl   $0xffffffff,(%rdx,%rax,1)\njmp    16bd <BuildMask+0x2d6>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x42bdd(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\nmovl   $0x1,-0x10(%rbp)\nmovq   $0x1,-0x8(%rbp)\njmp    1583 <BuildMask+0x19c>\naddl   $0x1,-0x10(%rbp)\nshlq   -0x8(%rbp)\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x429ca(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%eax\ncmp    %rax,-0x8(%rbp)\njbe    157b <BuildMask+0x194>\nmov    -0x14(%rbp),%edx\nmov    -0x10(%rbp),%eax\nadd    %edx,%eax\ncmp    $0x20,%eax\njle    15d3 <BuildMask+0x1ec>\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x1,-0x18(%rbp)\njbe    15cc <BuildMask+0x1e5>\nmov    $0x0,%esi\nlea    0x35c77(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <Fatal>\nmovl   $0x0,-0x14(%rbp)\nmov    -0x8(%rbp),%rax\nlea    -0x1(%rax),%ecx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x4297b(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\ncmpl   $0x0,-0x14(%rbp)\nje     15ff <BuildMask+0x218>\nmov    -0x14(%rbp),%eax\nmov    %eax,%ecx\nshlq   %cl,-0x8(%rbp)\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nlea    0x42b0f(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nor     -0x8(%rbp),%rax\nmov    -0x18(%rbp),%edx\nlea    0x0(,%rdx,8),%rcx\nlea    0x42af5(%rip),%rdx\nmov    %rax,(%rcx,%rdx,1)\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nlea    0x42acf(%rip),%rax\nmov    (%rdx,%rax,1),%rsi\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x42908(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%edx\nmov    -0x14(%rbp),%eax\nmov    %eax,%ecx\nshl    %cl,%rdx\nmov    %rdx,%rax\nor     %rax,%rsi\nmov    %rsi,%rcx\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nlea    0x42a90(%rip),%rax\nmov    %rcx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nmov    -0x1c(%rbp),%edx\nmovslq %edx,%rdx\nmov    %rdx,%rcx\nshl    $0x4,%rcx\nlea    0x428c9(%rip),%rdx\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rcx\nlea    0x428bb(%rip),%rdx\nmov    -0x18(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x10(%rbp),%eax\nadd    %eax,-0x14(%rbp)\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x19,-0x1c(%rbp)\njle    1515 <BuildMask+0x12e>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "BuildWord", "content": "/* BuildWord -- build a Word structure from an ASCII word\n * If the word does not fit, then do nothing.\n */\nvoid BuildWord(char * pchWord) {\n    unsigned char cchFrequency[ALPHABET];\n    int i;\n    char * pch = pchWord;\n    PWord pw;\n    int cchLength = 0;\n\n    libmin_memset(cchFrequency, 0, sizeof(unsigned char)*ALPHABET);\n    /* Zero(cchFrequency); */\n\n    /* Build frequency table */\n    while ((i = *pch++) != '\\0') {\n        if (!isalpha(i)) continue;\n        i = ch2i(tolower(i));\n        if (++cchFrequency[i] > alPhrase[i].uFrequency)\n\t    return;\n        ++cchLength;\n    }\n\n    Debug(wprint(pchWord);)\n\n    /* Update global count */\n    for (i = 0; i < ALPHABET; i++)\n        auGlobalFrequency[i] += cchFrequency[i];\n\n    /* Create a Word structure and fill it in, including building the\n     * bitfield of frequencies.\n     */\n    pw = NextWord();\n    libmin_memset(pw->aqMask, 0, sizeof(Quad)*MAX_QUADS);\n    /* Zero(pw->aqMask); */\n    pw->pchWord = pchWord;\n    pw->cchLength = cchLength;\n    for (i = 0; i < ALPHABET; i++) {\n        pw->aqMask[alPhrase[i].iq] |=\n            (Quad)cchFrequency[i] << alPhrase[i].uShift;\n    }\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "BuildWord", "address": "0x17e5", "label": "BuildWord", "content": "void __cdecl BuildWord(char *pchWord)\n{\n  int v1; // eax\n  char *v2; // rax\n  int i; // [rsp+18h] [rbp-48h]\n  int ia; // [rsp+18h] [rbp-48h]\n  int ib; // [rsp+18h] [rbp-48h]\n  int cchLength; // [rsp+1Ch] [rbp-44h]\n  char *pch; // [rsp+20h] [rbp-40h]\n  PWord pw; // [rsp+28h] [rbp-38h]\n  unsigned __int8 cchFrequency[40]; // [rsp+30h] [rbp-30h] BYREF\n  unsigned __int64 v10; // [rsp+58h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  pch = pchWord;\n  cchLength = 0;\n  libmin_memset(cchFrequency, 0, 0x1AuLL);\n  while ( 1 )\n  {\n    v2 = pch++;\n    i = *v2;\n    if ( !*v2 )\n      break;\n    if ( (pctype[*v2] & 3) != 0 )\n    {\n      if ( (pctype[*v2] & 1) != 0 )\n        v1 = i - 65;\n      else\n        v1 = i - 97;\n      if ( ++cchFrequency[v1] > alPhrase[v1].uFrequency )\n        return;\n      ++cchLength;\n    }\n  }\n  for ( ia = 0; ia <= 25; ++ia )\n    auGlobalFrequency[ia] += cchFrequency[ia];\n  pw = NextWord();\n  libmin_memset(pw, 0, 0x10uLL);\n  pw->pchWord = pchWord;\n  pw->cchLength = cchLength;\n  for ( ib = 0; ib <= 25; ++ib )\n    pw->aqMask[alPhrase[ib].iq] |= (unsigned __int64)cchFrequency[ib] << alPhrase[ib].uShift;\n}\n"}, "pseudo_normalize": "void BuildWord(char *pchWord) {\n  int v1;\n  char *v2;\n  int i;\n  int ia;\n  int ib;\n  int cchLength;\n  char *pch;\n  PWord pw;\n  unsigned char cchFrequency[40];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  pch = pchWord;\n  cchLength = 0;\n  libmin_memset(cchFrequency, 0, 26uLL);\n  while (1) {\n    v2 = pch++;\n    i = *v2;\n    if (!*v2) break;\n    if ((pctype[*v2] & 3) != 0) {\n      if ((pctype[*v2] & 1) != 0)\n        v1 = i - 65;\n      else\n        v1 = i - 97;\n      if (++cchFrequency[v1] > alPhrase[v1].uFrequency) return;\n      ++cchLength;\n    }\n  }\n  for (ia = 0; ia <= 25; ++ia) auGlobalFrequency[ia] += cchFrequency[ia];\n  pw = NextWord();\n  libmin_memset(pw, 0, 16uLL);\n  pw->pchWord = pchWord;\n  pw->cchLength = cchLength;\n  for (ib = 0; ib <= 25; ++ib)\n    pw->aqMask[alPhrase[ib].iq] |= (unsigned long long)cchFrequency[ib]\n                                   << alPhrase[ib].uShift;\n}", "binary": "anagram/anagram.host.O0", "assembly": "<BuildWord>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x40(%rbp)\nmovl   $0x0,-0x44(%rbp)\nlea    -0x30(%rbp),%rax\nmov    $0x1a,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   26b4 <libmin_memset>\njmp    18c4 <BuildWord+0xdf>\nmov    0x38a73(%rip),%rdx\nmov    -0x48(%rbp),%eax\ncltq\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x3,%eax\ntest   %eax,%eax\njne    184f <BuildWord+0x6a>\njmp    18c4 <BuildWord+0xdf>\nmov    0x38a52(%rip),%rdx\nmov    -0x48(%rbp),%eax\ncltq\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1876 <BuildWord+0x91>\nmov    -0x48(%rbp),%eax\nsub    $0x41,%eax\njmp    187c <BuildWord+0x97>\nmov    -0x48(%rbp),%eax\nsub    $0x61,%eax\nmov    %eax,-0x48(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nlea    0x1(%rax),%edx\nmov    -0x48(%rbp),%eax\ncltq\nmov    %dl,-0x30(%rbp,%rax,1)\nmov    -0x48(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmovzbl %al,%edx\nmov    -0x48(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rcx\nlea    0x426ab(%rip),%rax\nmov    (%rcx,%rax,1),%eax\ncmp    %eax,%edx\nja     19ef <BuildWord+0x20a>\naddl   $0x1,-0x44(%rbp)\nmov    -0x40(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x40(%rbp)\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %eax,-0x48(%rbp)\ncmpl   $0x0,-0x48(%rbp)\njne    182e <BuildWord+0x49>\nmovl   $0x0,-0x48(%rbp)\njmp    192e <BuildWord+0x149>\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x42840(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x48(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmovzbl %al,%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x42819(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x48(%rbp)\ncmpl   $0x19,-0x48(%rbp)\njle    18ec <BuildWord+0x107>\ncall   173b <NextWord>\nmov    %rax,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmov    $0x10,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   26b4 <libmin_memset>\nmov    -0x38(%rbp),%rax\nmov    -0x58(%rbp),%rdx\nmov    %rdx,0x10(%rax)\nmov    -0x44(%rbp),%edx\nmov    -0x38(%rbp),%rax\nmov    %edx,0x18(%rax)\nmovl   $0x0,-0x48(%rbp)\njmp    19e7 <BuildWord+0x202>\nmov    -0x48(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x425e7(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x38(%rbp),%rax\nmov    %edx,%edx\nmov    (%rax,%rdx,8),%rsi\nmov    -0x48(%rbp),%eax\ncltq\nmovzbl -0x30(%rbp,%rax,1),%eax\nmovzbl %al,%edx\nmov    -0x48(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rcx\nlea    0x425b2(%rip),%rax\nmov    (%rcx,%rax,1),%eax\nmov    %rdx,%rdi\nmov    %eax,%ecx\nshl    %cl,%rdi\nmov    -0x48(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x4259c(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nor     %rdi,%rsi\nmov    %rsi,%rdx\nmov    -0x38(%rbp),%rax\nmov    %ecx,%ecx\nmov    %rdx,(%rax,%rcx,8)\naddl   $0x1,-0x48(%rbp)\ncmpl   $0x19,-0x48(%rbp)\njle    1972 <BuildWord+0x18d>\njmp    19f0 <BuildWord+0x20b>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1a04 <BuildWord+0x21f>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "CompareFrequency", "content": "int Cdecl CompareFrequency(char *pch1, char *pch2) {\n    return auGlobalFrequency[(int)(*pch1)] < auGlobalFrequency[(int)(*pch2)]\n        ?  -1 :\n           auGlobalFrequency[(int)(*pch1)] == auGlobalFrequency[(int)(*pch2)]\n        ?   0 : 1;\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "CompareFrequency", "address": "0x1df3", "label": "CompareFrequency", "content": "int __cdecl CompareFrequency(char *pch1, char *pch2)\n{\n  if ( auGlobalFrequency[*pch1] < auGlobalFrequency[*pch2] )\n    return -1;\n  else\n    return auGlobalFrequency[*pch1] != auGlobalFrequency[*pch2];\n}\n"}, "pseudo_normalize": "int CompareFrequency(char *pch1, char *pch2) {\n  if (auGlobalFrequency[*pch1] < auGlobalFrequency[*pch2])\n    return -1;\n  else\n    return auGlobalFrequency[*pch1] != auGlobalFrequency[*pch2];\n}", "binary": "anagram/anagram.host.O0", "assembly": "<CompareFrequency>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x42322(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x42304(%rip),%rax\nmov    (%rcx,%rax,1),%eax\ncmp    %eax,%edx\njb     1e89 <CompareFrequency+0x96>\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x422e2(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x422c4(%rip),%rax\nmov    (%rcx,%rax,1),%eax\ncmp    %eax,%edx\nsetne  %al\nmovzbl %al,%eax\njmp    1e8e <CompareFrequency+0x9b>\nmov    $0xffffffff,%eax\npop    %rbp\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "DumpCandidates", "content": "void DumpCandidates(void) {\n    unsigned u;\n\n    for (u = 0; u < cpwCand; u++)\n        libmin_printf(StringFormat, apwCand[u]->pchWord, (u % 4 == 3) ? '\\n' : ' ');\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "DumpCandidates", "address": "0x1ac2", "label": "DumpCandidates", "content": "void __cdecl DumpCandidates()\n{\n  unsigned int v0; // ecx\n  unsigned int u; // [rsp+Ch] [rbp-4h]\n\n  for ( u = 0; u < cpwCand; ++u )\n  {\n    if ( (u & 3) == 3 )\n      v0 = 10;\n    else\n      v0 = 32;\n    libmin_printf(\"%15s%c\", apwCand[u]->pchWord, v0);\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void DumpCandidates() {\n  unsigned int v0;\n  unsigned int u;\n  for (u = 0; u < cpwCand; ++u) {\n    if ((u & 3) == 3)\n      v0 = 10;\n    else\n      v0 = 32;\n    libmin_printf(\"%15s%c\", apwCand[u]->pchWord, v0);\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "anagram/anagram.host.O0", "assembly": "<DumpCandidates>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x4(%rbp)\njmp    1b25 <DumpCandidates+0x63>\nmov    -0x4(%rbp),%eax\nand    $0x3,%eax\ncmp    $0x3,%eax\njne    1ae9 <DumpCandidates+0x27>\nmov    $0xa,%ecx\njmp    1aee <DumpCandidates+0x2c>\nmov    $0x20,%ecx\nmov    -0x4(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nlea    0x38800(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    0x10(%rax),%rax\nmov    %ecx,%edx\nmov    %rax,%rsi\nlea    0x3578f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\naddl   $0x1,-0x4(%rbp)\nmov    0x42415(%rip),%eax\ncmp    %eax,-0x4(%rbp)\njb     1ad7 <DumpCandidates+0x15>\nlea    0x35773(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "DumpWords", "content": ")                                       /* End of debug code */\n\nvoid DumpWords(void) {\n    int i;\n    for (i = 0; i < cpwLast; i++) wprint(apwSol[i]->pchWord);\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "DumpWords", "address": "0x1b47", "label": "DumpWords", "content": "void __cdecl DumpWords()\n{\n  int i; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i < cpwLast; ++i )\n    wprint(apwSol[i]->pchWord);\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "", "binary": "anagram/anagram.host.O0", "assembly": "<DumpWords>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x4(%rbp)\njmp    1b84 <DumpWords+0x3d>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x42670(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    0x10(%rax),%rax\nmov    %rax,%rdi\ncall   170d <wprint>\naddl   $0x1,-0x4(%rbp)\nmov    0x427ee(%rip),%eax\ncmp    %eax,-0x4(%rbp)\njl     1b5c <DumpWords+0x15>\nlea    0x35714(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "FindAnagram", "content": "void\nFindAnagram(Quad * pqMask, PPWord ppwStart, int iLetter)\n{\n    Quad aqNext[MAX_QUADS];\n    register PWord pw;\n    Quad qMask;\n    unsigned iq;\n    PPWord ppwEnd = &apwCand[0];\n    ppwEnd += cpwCand;\n\n    ;\n\n    Debug(libmin_printf(\"Trying :\"); DumpWord(pqMask); libmin_printf(\":\\n\");)\n\n    for (;;) {\n        iq = alPhrase[(int)achByFrequency[iLetter]].iq;\n        qMask = alPhrase[(int)achByFrequency[iLetter]].uBits <<\n                alPhrase[(int)achByFrequency[iLetter]].uShift;\n        if (pqMask[iq] & qMask) break;\n        iLetter++;\n    }\n\n    Debug(libmin_printf(\"Pivoting on %c\\n\", i2ch(achByFrequency[iLetter]));)\n\n    while (ppwStart < ppwEnd) {          /* Half of the program execution */\n        pw = *ppwStart;                  /* time is spent in these three */\n\n        Stat(if (++ulLowCount == 0) ++ulHighCount;)\n\n#if MAX_QUADS > 0\n        OneStep(0);                     /* lines of code. */\n#endif\n\n#if MAX_QUADS > 1\n        OneStep(1);\n#endif\n\n#if MAX_QUADS > 2\n        OneStep(2);\n#endif\n\n#if MAX_QUADS > 3\n        OneStep(3);\n#endif\n\n#if MAX_QUADS > 4\n            @@\"Add more unrolling steps here, please.\"@@\n#endif\n\n        /* If the pivot letter isn't present, defer this word until later */\n        if ((pw->aqMask[iq] & qMask) == 0) {\n            *ppwStart = *--ppwEnd;\n            *ppwEnd = pw;\n            continue;\n        }\n\n        /* If we get here, this means the word fits. */\n        apwSol[cpwLast++] = pw;\n        if (cchPhraseLength -= pw->cchLength) { /* recurse */\n            Debug(DumpWords();)\n            /* The recursive call scrambles the tail, so we have to be\n             * pessimistic.\n             */\n\t    ppwEnd = &apwCand[0];\n\t    ppwEnd += cpwCand;\n            FindAnagram(&aqNext[0],\n\t\t\tppwStart, iLetter);\n        } else DumpWords();             /* found one */\n        cchPhraseLength += pw->cchLength;\n        --cpwLast;\n        ppwStart++;\n        continue;\n    }\n\n    ;\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "FindAnagram", "address": "0x1ba6", "label": "FindAnagram", "content": "void __cdecl FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter)\n{\n  Word *v3; // rbx\n  int v4; // eax\n  unsigned int iq; // [rsp+2Ch] [rbp-44h]\n  Word **ppwEnd; // [rsp+30h] [rbp-40h]\n  Quad qMask; // [rsp+38h] [rbp-38h]\n  Quad aqNext[3]; // [rsp+40h] [rbp-30h] BYREF\n  unsigned __int64 v11; // [rsp+58h] [rbp-18h]\n\n  v11 = __readfsqword(0x28u);\n  ppwEnd = &apwCand[cpwCand];\n  while ( 1 )\n  {\n    iq = alPhrase[achByFrequency[iLetter]].iq;\n    qMask = alPhrase[achByFrequency[iLetter]].uBits << alPhrase[achByFrequency[iLetter]].uShift;\n    if ( (qMask & pqMask[iq]) != 0 )\n      break;\n    ++iLetter;\n  }\n  while ( ppwStart < ppwEnd )\n  {\n    v3 = *ppwStart;\n    aqNext[0] = *pqMask - (*ppwStart)->aqMask[0];\n    if ( (aqNext[0] & aqMainSign[0]) != 0 )\n    {\n      ++ppwStart;\n    }\n    else\n    {\n      aqNext[1] = pqMask[1] - v3->aqMask[1];\n      if ( (aqNext[1] & aqMainSign[1]) != 0 )\n      {\n        ++ppwStart;\n      }\n      else if ( (qMask & v3->aqMask[iq]) != 0 )\n      {\n        v4 = cpwLast++;\n        apwSol[v4] = v3;\n        cchPhraseLength -= v3->cchLength;\n        if ( cchPhraseLength )\n        {\n          ppwEnd = &apwCand[cpwCand];\n          FindAnagram(aqNext, ppwStart, iLetter);\n        }\n        else\n        {\n          DumpWords();\n        }\n        cchPhraseLength += v3->cchLength;\n        --cpwLast;\n        ++ppwStart;\n      }\n      else\n      {\n        *ppwStart = *--ppwEnd;\n        *ppwEnd = v3;\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter) {\n  Word *v3;\n  int v4;\n  unsigned int iq;\n  Word **ppwEnd;\n  Quad qMask;\n  Quad aqNext[3];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  ppwEnd = &apwCand[cpwCand];\n  while (1) {\n    iq = alPhrase[achByFrequency[iLetter]].iq;\n    qMask = alPhrase[achByFrequency[iLetter]].uBits\n            << alPhrase[achByFrequency[iLetter]].uShift;\n    if ((qMask & pqMask[iq]) != 0) break;\n    ++iLetter;\n  }\n  while (ppwStart < ppwEnd) {\n    v3 = *ppwStart;\n    aqNext[0] = *pqMask - (*ppwStart)->aqMask[0];\n    if ((aqNext[0] & aqMainSign[0]) != 0) {\n      ++ppwStart;\n    } else {\n      aqNext[1] = pqMask[1] - v3->aqMask[1];\n      if ((aqNext[1] & aqMainSign[1]) != 0) {\n        ++ppwStart;\n      } else if ((qMask & v3->aqMask[iq]) != 0) {\n        v4 = cpwLast++;\n        apwSol[v4] = v3;\n        cchPhraseLength -= v3->cchLength;\n        if (cchPhraseLength) {\n          ppwEnd = &apwCand[cpwCand];\n          FindAnagram(aqNext, ppwStart, iLetter);\n        } else {\n          DumpWords();\n        }\n        cchPhraseLength += v3->cchLength;\n        --cpwLast;\n        ++ppwStart;\n      } else {\n        *ppwStart = *--ppwEnd;\n        *ppwEnd = v3;\n      }\n    }\n  }\n}", "binary": "anagram/anagram.host.O0", "assembly": "<FindAnagram>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %rsi,-0x60(%rbp)\nmov    %edx,-0x64(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nlea    0x3872c(%rip),%rax\nmov    %rax,-0x40(%rbp)\nmov    0x42362(%rip),%eax\nmov    %eax,%eax\nshl    $0x3,%rax\nadd    %rax,-0x40(%rbp)\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x425bc(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x42361(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0x44(%rbp)\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x42593(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x42334(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x4256d(%rip),%rcx\nmovzbl (%rax,%rcx,1),%eax\nmovsbl %al,%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rcx\nlea    0x4230a(%rip),%rax\nmov    (%rcx,%rax,1),%eax\nmov    %eax,%ecx\nshl    %cl,%edx\nmov    %edx,%eax\nmov    %eax,%eax\nmov    %rax,-0x38(%rbp)\nmov    -0x44(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nand    -0x38(%rbp),%rax\ntest   %rax,%rax\njne    1c90 <FindAnagram+0xea>\naddl   $0x1,-0x64(%rbp)\njmp    1be8 <FindAnagram+0x42>\nnop\njmp    1dca <FindAnagram+0x224>\nmov    -0x60(%rbp),%rax\nmov    (%rax),%rbx\nmov    -0x58(%rbp),%rax\nmov    (%rax),%rax\nmov    (%rbx),%rdx\nsub    %rdx,%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rdx\nmov    0x42467(%rip),%rax\nand    %rdx,%rax\ntest   %rax,%rax\nje     1ccb <FindAnagram+0x125>\naddq   $0x8,-0x60(%rbp)\njmp    1dca <FindAnagram+0x224>\nmov    -0x58(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    0x8(%rbx),%rdx\nsub    %rdx,%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    0x4243c(%rip),%rax\nand    %rdx,%rax\ntest   %rax,%rax\nje     1cfe <FindAnagram+0x158>\naddq   $0x8,-0x60(%rbp)\njmp    1dca <FindAnagram+0x224>\nmov    -0x44(%rbp),%eax\nmov    (%rbx,%rax,8),%rax\nand    -0x38(%rbp),%rax\ntest   %rax,%rax\njne    1d2d <FindAnagram+0x187>\nsubq   $0x8,-0x40(%rbp)\nmov    -0x40(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x60(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x40(%rbp),%rax\nmov    %rbx,(%rax)\njmp    1dca <FindAnagram+0x224>\nmov    0x42645(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x4263c(%rip)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x42493(%rip),%rax\nmov    %rbx,(%rdx,%rax,1)\nmov    0x423a9(%rip),%eax\nmov    0x18(%rbx),%edx\nsub    %edx,%eax\nmov    %eax,0x4239e(%rip)\nmov    0x42398(%rip),%eax\ntest   %eax,%eax\nje     1d9f <FindAnagram+0x1f9>\nlea    0x3858d(%rip),%rax\nmov    %rax,-0x40(%rbp)\nmov    0x421c3(%rip),%eax\nmov    %eax,%eax\nshl    $0x3,%rax\nadd    %rax,-0x40(%rbp)\nmov    -0x64(%rbp),%edx\nmov    -0x60(%rbp),%rcx\nlea    -0x30(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1ba6 <FindAnagram>\njmp    1da4 <FindAnagram+0x1fe>\ncall   1b47 <DumpWords>\nmov    0x18(%rbx),%edx\nmov    0x42353(%rip),%eax\nadd    %edx,%eax\nmov    %eax,0x4234b(%rip)\nmov    0x425bd(%rip),%eax\nsub    $0x1,%eax\nmov    %eax,0x425b4(%rip)\naddq   $0x8,-0x60(%rbp)\nnop\nmov    -0x60(%rbp),%rax\ncmp    -0x40(%rbp),%rax\njb     1c96 <FindAnagram+0xf0>\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1ded <FindAnagram+0x247>\ncall   10b0 <__stack_chk_fail@plt>\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "GetPhrase", "content": "char * GetPhrase(char * pch) {\n    if (libmin_mgets(pch, 255, minput) == NULL) {\n\t    return NULL;\n    }\n    // libmin_printf(\"Processing: %s...\\n\", pch);\n    return(pch);\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "GetPhrase", "address": "0x1f37", "label": "GetPhrase", "content": "char *__cdecl GetPhrase(char *pch)\n{\n  if ( libmin_mgets(pch, 0xFFuLL, minput) )\n    return pch;\n  else\n    return 0LL;\n}\n"}, "pseudo_normalize": "char *GetPhrase(char *pch) {\n  if (libmin_mgets(pch, 255uLL, minput))\n    return pch;\n  else\n    return 0LL;\n}", "binary": "anagram/anagram.host.O0", "assembly": "<GetPhrase>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    0x38132(%rip),%rdx\nmov    -0x8(%rbp),%rax\nmov    $0xff,%esi\nmov    %rax,%rdi\ncall   2849 <libmin_mgets>\ntest   %rax,%rax\njne    1f6b <GetPhrase+0x34>\nmov    $0x0,%eax\njmp    1f6f <GetPhrase+0x38>\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "NewWord", "content": "PWord\nNewWord(void) {\n    PWord pw;\n\n    pw = (Word *)libmin_malloc(sizeof(Word));\n    if (pw == NULL)\n        Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n    return pw;\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "NewWord", "address": "0x16cf", "label": "NewWord", "content": "PWord __cdecl NewWord()\n{\n  Word *pw; // [rsp+8h] [rbp-8h]\n\n  pw = (Word *)libmin_malloc(0x20uLL);\n  if ( !pw )\n    Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n  return pw;\n}\n"}, "pseudo_normalize": "PWord NewWord() {\n  Word *pw;\n  pw = (Word *)libmin_malloc(32uLL);\n  if (!pw) Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n  return pw;\n}", "binary": "anagram/anagram.host.O0", "assembly": "<NewWord>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x20,%edi\ncall   234e <libmin_malloc>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    1707 <NewWord+0x38>\nmov    0x4284a(%rip),%eax\nmov    %eax,%esi\nlea    0x35b59(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <Fatal>\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "NextWord", "content": "/* NextWord -- get another candidate entry, creating if necessary */\nPWord NextWord(void) {\n    PWord pw;\n    if (cpwCand >= MAXCAND)\n\tFatal(\"Too many candidates\\n\", 0);\n    pw = apwCand[cpwCand++];\n    if (pw != NULL)\n\treturn pw;\n    apwCand[cpwCand-1] = NewWord();\n    return apwCand[cpwCand-1];\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "NextWord", "address": "0x173b", "label": "NextWord", "content": "PWord __cdecl NextWord()\n{\n  unsigned int v0; // eax\n  unsigned int v2; // ebx\n\n  if ( cpwCand > 0x1387 )\n    Fatal(\"Too many candidates\\n\", 0);\n  v0 = cpwCand++;\n  if ( apwCand[v0] )\n    return apwCand[v0];\n  v2 = cpwCand - 1;\n  apwCand[v2] = NewWord();\n  return apwCand[cpwCand - 1];\n}\n"}, "pseudo_normalize": "PWord NextWord() {\n  unsigned int v0;\n  unsigned int v2;\n  if (cpwCand > 4999) Fatal(\"Too many candidates\\n\", 0);\n  v0 = cpwCand++;\n  if (apwCand[v0]) return apwCand[v0];\n  v2 = cpwCand - 1;\n  apwCand[v2] = NewWord();\n  return apwCand[cpwCand - 1];\n}", "binary": "anagram/anagram.host.O0", "assembly": "<NextWord>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    0x427f2(%rip),%eax\ncmp    $0x1387,%eax\njbe    1769 <NextWord+0x2e>\nmov    $0x0,%esi\nlea    0x35b1e(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <Fatal>\nmov    0x427d1(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x427c8(%rip)\nmov    %eax,%eax\nlea    0x0(,%rax,8),%rdx\nlea    0x38b77(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\nje     179e <NextWord+0x63>\nmov    -0x18(%rbp),%rax\njmp    17df <NextWord+0xa4>\nmov    0x4279c(%rip),%eax\nlea    -0x1(%rax),%ebx\ncall   16cf <NewWord>\nmov    %ebx,%edx\nlea    0x0(,%rdx,8),%rcx\nlea    0x38b43(%rip),%rdx\nmov    %rax,(%rcx,%rdx,1)\nmov    0x42779(%rip),%eax\nsub    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,8),%rdx\nlea    0x38b25(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "ReadDict", "content": "/* ReadDict -- read the dictionary file into memory and preprocess it\n *\n * A word of length cch in the dictionary is encoded as follows:\n *\n *    byte 0    = cch + 3\n *    byte 1    = number of letters in the word\n *    byte 2... = the word itself, null-terminated\n *\n * Observe that cch+3 is the length of the total encoding.  These\n * byte streams are concatenated, and terminated with a 0.\n */\n\nvoid ReadDict(char *pchFile) {\n    char * pch;\n    char * pchBase;\n    unsigned long ulLen;\n    unsigned cWords = 0;\n    unsigned cLetters;\n    int ch;\n\n    ulLen = libmin_msize(mwords) + 2 * (unsigned long)MAXWORDS;\n    pchBase = pchDictionary = (char *)libmin_malloc(ulLen);\n\n    if(pchDictionary == NULL)\n\tFatal(\"Unable to allocate memory for dictionary\\n\", 0);\n\n    libmin_mopen(mwords, \"r\");\n\n    while (!libmin_meof(mwords)) {\n        pch = pchBase+2;                /* reserve for length */\n        cLetters = 0;\n        while ((ch = libmin_mgetc(mwords)) != '\\n' && ch != EOF) {\n            if (isalpha(ch)) cLetters++;\n            *pch++ = ch;\n        }\n        *pch++ = '\\0';\n        *pchBase = pch - pchBase;\n        pchBase[1] = cLetters;\n        pchBase = pch;\n        cWords++;\n    }\n    libmin_mclose(mwords);\n\n    *pchBase++ = 0;\n\n    libmin_printf(\"main dictionary has %u entries\\n\", cWords);\n    if (cWords >= MAXWORDS)\n\t    Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n    libmin_printf(\"%lu bytes wasted\\n\", ulLen - (pchBase - pchDictionary));\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "ReadDict", "address": "0x121f", "label": "ReadDict", "content": "void __cdecl ReadDict(char *pchFile)\n{\n  char *v1; // rax\n  char *v2; // rax\n  char *v3; // rax\n  unsigned int cWords; // [rsp+1Ch] [rbp-24h]\n  char cLetters; // [rsp+20h] [rbp-20h]\n  int ch_0; // [rsp+24h] [rbp-1Ch]\n  char *pch; // [rsp+28h] [rbp-18h]\n  char *pcha; // [rsp+28h] [rbp-18h]\n  char *pchBase; // [rsp+30h] [rbp-10h]\n  char *pchBasea; // [rsp+30h] [rbp-10h]\n  size_t ulLen; // [rsp+38h] [rbp-8h]\n\n  cWords = 0;\n  ulLen = libmin_msize(mwords) + 52000;\n  pchDictionary = (char *)libmin_malloc(ulLen);\n  pchBase = pchDictionary;\n  if ( !pchDictionary )\n    Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(mwords, \"r\");\n  while ( !libmin_meof(mwords) )\n  {\n    pch = pchBase + 2;\n    cLetters = 0;\n    while ( 1 )\n    {\n      ch_0 = libmin_mgetc(mwords);\n      if ( ch_0 == 10 || ch_0 == -1 )\n        break;\n      if ( (pctype[ch_0] & 3) != 0 )\n        ++cLetters;\n      v1 = pch++;\n      *v1 = ch_0;\n    }\n    v2 = pch;\n    pcha = pch + 1;\n    *v2 = 0;\n    *pchBase = (_BYTE)pcha - (_BYTE)pchBase;\n    pchBase[1] = cLetters;\n    pchBase = pcha;\n    ++cWords;\n  }\n  libmin_mclose(mwords);\n  v3 = pchBase;\n  pchBasea = pchBase + 1;\n  *v3 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", cWords);\n  if ( cWords > 0x658F )\n    Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", ulLen - (pchBasea - pchDictionary));\n}\n"}, "pseudo_normalize": "void ReadDict(char *pchFile) {\n  char *v1;\n  char *v2;\n  char *v3;\n  unsigned int cWords;\n  char cLetters;\n  int ch_0;\n  char *pch;\n  char *pcha;\n  char *pchBase;\n  char *pchBasea;\n  unsigned int ulLen;\n  cWords = 0;\n  ulLen = libmin_msize(mwords) + 52000;\n  pchDictionary = (char *)libmin_malloc(ulLen);\n  pchBase = pchDictionary;\n  if (!pchDictionary) Fatal(\"Unable to allocate memory for dictionary\\n\", 0);\n  libmin_mopen(mwords, \"r\");\n  while (!libmin_meof(mwords)) {\n    pch = pchBase + 2;\n    cLetters = 0;\n    while (1) {\n      ch_0 = libmin_mgetc(mwords);\n      if (ch_0 == 10 || ch_0 == -1) break;\n      if ((pctype[ch_0] & 3) != 0) ++cLetters;\n      v1 = pch++;\n      *v1 = ch_0;\n    }\n    v2 = pch;\n    pcha = pch + 1;\n    *v2 = 0;\n    *pchBase = (uint8_t)pcha - (uint8_t)pchBase;\n    pchBase[1] = cLetters;\n    pchBase = pcha;\n    ++cWords;\n  }\n  libmin_mclose(mwords);\n  v3 = pchBase;\n  pchBasea = pchBase + 1;\n  *v3 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", cWords);\n  if (cWords > 25999) Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n  libmin_printf(\"%lu bytes wasted\\n\", ulLen - (pchBasea - pchDictionary));\n}", "binary": "anagram/anagram.host.O0", "assembly": "<ReadDict>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmovl   $0x0,-0x24(%rbp)\nmov    0x38e03(%rip),%rax\nmov    %rax,%rdi\ncall   2aca <libmin_msize>\nadd    $0xcb20,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   234e <libmin_malloc>\nmov    %rax,0x42f6e(%rip)\nmov    0x42f67(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    0x42f5c(%rip),%rax\ntest   %rax,%rax\njne    128d <ReadDict+0x6e>\nmov    $0x0,%esi\nlea    0x35f2b(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <Fatal>\nmov    0x38dac(%rip),%rax\nlea    0x35f3f(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   2a70 <libmin_mopen>\njmp    134a <ReadDict+0x12b>\nmov    -0x10(%rbp),%rax\nadd    $0x2,%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmp    12f4 <ReadDict+0xd5>\nmov    0x38fe1(%rip),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x3,%eax\ntest   %eax,%eax\nje     12e3 <ReadDict+0xc4>\naddl   $0x1,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x18(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    %dl,(%rax)\nmov    0x38d45(%rip),%rax\nmov    %rax,%rdi\ncall   27f9 <libmin_mgetc>\nmov    %eax,-0x1c(%rbp)\ncmpl   $0xa,-0x1c(%rbp)\nje     1312 <ReadDict+0xf3>\ncmpl   $0xffffffff,-0x1c(%rbp)\njne    12c0 <ReadDict+0xa1>\nmov    -0x18(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x18(%rbp)\nmovb   $0x0,(%rax)\nmov    -0x18(%rbp),%rax\nsub    -0x10(%rbp),%rax\nmov    %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %dl,(%rax)\nmov    -0x10(%rbp),%rax\nadd    $0x1,%rax\nmov    -0x20(%rbp),%edx\nmov    %dl,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\naddl   $0x1,-0x24(%rbp)\nmov    0x38cef(%rip),%rax\nmov    %rax,%rdi\ncall   27d0 <libmin_meof>\ntest   %eax,%eax\nje     12ab <ReadDict+0x8c>\nmov    0x38cd8(%rip),%rax\nmov    %rax,%rdi\ncall   2645 <libmin_mclose>\nmov    -0x10(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x10(%rbp)\nmovb   $0x0,(%rax)\nmov    -0x24(%rbp),%eax\nmov    %eax,%esi\nlea    0x35e55(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\ncmpl   $0x658f,-0x24(%rbp)\njbe    13b5 <ReadDict+0x196>\nmov    $0x0,%esi\nlea    0x35e53(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <Fatal>\nmov    0x42e14(%rip),%rdx\nmov    -0x10(%rbp),%rax\nsub    %rdx,%rax\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nsub    %rdx,%rax\nmov    %rax,%rsi\nlea    0x35e52(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "SortCandidates", "content": "void SortCandidates(void) {\n    int i;\n\n    /* Sort the letters by frequency */\n    for (i = 0; i < ALPHABET; i++) achByFrequency[i] = i;\n    libmin_qsort(achByFrequency, ALPHABET, sizeof(char),\n          (int (*)(const void *, const void *))CompareFrequency);\n\n    libmin_printf(\"Order of search will be \");\n    for (i = 0; i < ALPHABET; i++)\n\t    libmin_putc(i2ch(achByFrequency[i]));\n    libmin_putc('\\n');\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "SortCandidates", "address": "0x1e90", "label": "SortCandidates", "content": "void __cdecl SortCandidates()\n{\n  int i; // [rsp+Ch] [rbp-4h]\n  int ia; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i <= 25; ++i )\n    achByFrequency[i] = i;\n  libmin_qsort(achByFrequency, 0x1AuLL, 1uLL, (int (*)(const void *, const void *))CompareFrequency);\n  libmin_printf(\"Order of search will be \");\n  for ( ia = 0; ia <= 25; ++ia )\n    libmin_putc(achByFrequency[ia] + 97);\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "void SortCandidates() {\n  int i;\n  int ia;\n  for (i = 0; i <= 25; ++i) achByFrequency[i] = i;\n  libmin_qsort(achByFrequency, 26uLL, 1uLL,\n               (int (*)(const void *, const void *))CompareFrequency);\n  libmin_printf(\"Order of search will be \");\n  for (ia = 0; ia <= 25; ++ia) libmin_putc(achByFrequency[ia] + 97);\n  libmin_putc(10);\n}", "binary": "anagram/anagram.host.O0", "assembly": "<SortCandidates>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x4(%rbp)\njmp    1ebd <SortCandidates+0x2d>\nmov    -0x4(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x422fa(%rip),%rdx\nmov    %cl,(%rax,%rdx,1)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x19,-0x4(%rbp)\njle    1ea5 <SortCandidates+0x15>\nlea    -0xd7(%rip),%rax\nmov    %rax,%rcx\nmov    $0x1,%edx\nmov    $0x1a,%esi\nlea    0x422d2(%rip),%rax\nmov    %rax,%rdi\ncall   4f85 <libmin_qsort>\nlea    0x353bf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\nmovl   $0x0,-0x4(%rbp)\njmp    1f24 <SortCandidates+0x94>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x422a1(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nadd    $0x61,%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   4d09 <libmin_putc>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x19,-0x4(%rbp)\njle    1f03 <SortCandidates+0x73>\nmov    $0xa,%edi\ncall   4d09 <libmin_putc>\nnop\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "main", "content": "int \nmain(int cpchArgc, char **ppchArgv)\n{\n    ReadDict(ppchArgv[1]);\n\n    while (GetPhrase(&achPhrase[0]) != NULL) {\n        if (isdigit(achPhrase[0])) {\n            cchMinLength = libmin_atoi(achPhrase);\n            libmin_printf(\"New length: %d\\n\", cchMinLength);\n        } else if (achPhrase[0] == '?') {\n            DumpCandidates();\n        } else {\n            BuildMask(&achPhrase[0]);\n            AddWords();\n            if (cpwCand == 0 || cchPhraseLength == 0) continue;\n\n            Stat(ulHighCount = ulLowCount = 0;)\n            cpwLast = 0;\n            SortCandidates();\n            FindAnagram(&aqMainMask[0], &apwCand[0], 0);\n            Stat(libmin_printf(\"%lu:%lu probes\\n\", ulHighCount, ulLowCount);)\n        }\n    }\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "main", "address": "0x1f71", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  ReadDict((char *)argv[1]);\n  while ( GetPhrase(achPhrase) )\n  {\n    if ( (pctype[achPhrase[0]] & 4) != 0 )\n    {\n      cchMinLength = libmin_atoi(achPhrase);\n      libmin_printf(\"New length: %d\\n\", cchMinLength);\n    }\n    else if ( achPhrase[0] == 63 )\n    {\n      DumpCandidates();\n    }\n    else\n    {\n      BuildMask(achPhrase);\n      AddWords();\n      if ( cpwCand )\n      {\n        if ( cchPhraseLength )\n        {\n          cpwLast = 0;\n          SortCandidates();\n          FindAnagram(aqMainMask, apwCand, 0);\n        }\n      }\n    }\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  ReadDict((char *)argv[1]);\n  while (GetPhrase(achPhrase)) {\n    if ((pctype[achPhrase[0]] & 4) != 0) {\n      cchMinLength = libmin_atoi(achPhrase);\n      libmin_printf(\"New length: %d\\n\", cchMinLength);\n    } else if (achPhrase[0] == 63) {\n      DumpCandidates();\n    } else {\n      BuildMask(achPhrase);\n      AddWords();\n      if (cpwCand) {\n        if (cchPhraseLength) {\n          cpwLast = 0;\n          SortCandidates();\n          FindAnagram(aqMainMask, apwCand, 0);\n        }\n      }\n    }\n  }\n  libmin_success();\n}", "binary": "anagram/anagram.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   121f <ReadDict>\njmp    205d <main+0xec>\nmov    0x38305(%rip),%rdx\nmovzbl 0x423d6(%rip),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x4,%eax\ntest   %eax,%eax\nje     1ff4 <main+0x83>\nlea    0x423b8(%rip),%rax\nmov    %rax,%rdi\ncall   21c3 <libmin_atoi>\nmov    %eax,0x3803a(%rip)\nmov    0x38034(%rip),%eax\nmov    %eax,%esi\nlea    0x352e0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\njmp    205d <main+0xec>\nmovzbl 0x42385(%rip),%eax\ncmp    $0x3f,%al\njne    2006 <main+0x95>\ncall   1ac2 <DumpCandidates>\njmp    205d <main+0xec>\nlea    0x42373(%rip),%rax\nmov    %rax,%rdi\ncall   13e7 <BuildMask>\ncall   1a06 <AddWords>\nmov    0x41f20(%rip),%eax\ntest   %eax,%eax\nje     205d <main+0xec>\nmov    0x420d6(%rip),%eax\ntest   %eax,%eax\njne    2030 <main+0xbf>\njmp    205d <main+0xec>\nmovl   $0x0,0x4233e(%rip)\ncall   1e90 <SortCandidates>\nmov    $0x0,%edx\nlea    0x382b5(%rip),%rax\nmov    %rax,%rsi\nlea    0x420bb(%rip),%rax\nmov    %rax,%rdi\ncall   1ba6 <FindAnagram>\nlea    0x4231c(%rip),%rax\nmov    %rax,%rdi\ncall   1f37 <GetPhrase>\ntest   %rax,%rax\njne    1f9c <main+0x2b>\ncall   50f3 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "wprint", "content": "/* wprint -- print a word, followed by a space\n *\n * We would normally just use printf, but the string being printed is\n * is a huge pointer (on an IBM PC), so special care must be taken.\n */\nvoid wprint(char * pch) {\n    libmin_printf(\"%s \", pch);\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O0.pseudo", "function_name": "wprint", "address": "0x170d", "label": "wprint", "content": "void __cdecl wprint(char *pch)\n{\n  libmin_printf(\"%s \", pch);\n}\n"}, "pseudo_normalize": "", "binary": "anagram/anagram.host.O0", "assembly": "<wprint>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rsi\nlea    0x35b50(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ada <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "audio-codec/audio-codec.c", "function_name": "decode", "content": "/**\n * @brief 8bit alaw to 16bit pcm\n * @param out signed 16bit pcm array\n * @param in  unsigned 8bit alaw array\n * @param len length of alaw array\n * @returns void\n */\nvoid decode(int16_t *out, uint8_t *in, size_t len)\n{\n    uint8_t alaw = 0;\n    int32_t pcm = 0;\n    int32_t sign = 0;\n    int32_t eee = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        alaw = *in++;\n\n        /* Re-toggle toggled bits */\n        alaw ^= 0xD5;\n\n        /* Get sign bit */\n        sign = alaw & 0x80;\n\n        /* Get eee bits */\n        eee = (alaw & 0x70) >> 4;\n\n        /* Get abcd bits and add 1/2 quantization step */\n        pcm = (alaw & 0x0f) << 4 | 8;\n\n        /* If quantization level > 0, there need `1` bit before abcd bits */\n        pcm += eee ? 0x100 : 0x0;\n\n        /* Left shift according quantization level */\n        pcm <<= eee > 1 ? (eee - 1) : 0;\n\n        /* Use the right sign */\n        *out++ = sign ? -pcm : pcm;\n    }\n}\n"}, "pseudo": {"path": "audio-codec/audio-codec.host.O0.pseudo", "function_name": "decode", "address": "0x12f5", "label": "decode", "content": "void __cdecl decode(int16_t *out, uint8_t *in, size_t len)\n{\n  uint8_t *v3; // rax\n  int v4; // eax\n  char v5; // al\n  int v6; // ecx\n  int16_t *v7; // rax\n  uint8_t alaw; // [rsp+23h] [rbp-15h]\n  int32_t pcm; // [rsp+24h] [rbp-14h]\n  int32_t pcma; // [rsp+24h] [rbp-14h]\n  size_t i; // [rsp+30h] [rbp-8h]\n\n  for ( i = 0LL; i < len; ++i )\n  {\n    v3 = in++;\n    alaw = *v3 ^ 0xD5;\n    if ( (((int)alaw >> 4) & 7) != 0 )\n      v4 = 256;\n    else\n      v4 = 0;\n    pcm = v4 + ((unsigned __int8)(16 * alaw) | 8);\n    v5 = ((int)alaw >> 4) & 7;\n    if ( (((int)alaw >> 4) & 7) == 0 )\n      v5 = 1;\n    pcma = pcm << (v5 - 1);\n    if ( (alaw & 0x80) != 0 )\n      v6 = -pcma;\n    else\n      LOWORD(v6) = pcma;\n    v7 = out++;\n    *v7 = v6;\n  }\n}\n"}, "pseudo_normalize": "void decode(int16_t *out, uint8_t *in, unsigned int len) {\n  uint8_t *v3;\n  int v4;\n  char v5;\n  int v6;\n  int16_t *v7;\n  uint8_t alaw;\n  int32_t pcm;\n  int32_t pcma;\n  unsigned int i;\n  for (i = 0LL; i < len; ++i) {\n    v3 = in++;\n    alaw = *v3 ^ 213;\n    if ((((int)alaw >> 4) & 7) != 0)\n      v4 = 256;\n    else\n      v4 = 0;\n    pcm = v4 + ((unsigned char)(16 * alaw) | 8);\n    v5 = ((int)alaw >> 4) & 7;\n    if ((((int)alaw >> 4) & 7) == 0) v5 = 1;\n    pcma = pcm << (v5 - 1);\n    if ((alaw & 128) != 0)\n      v6 = -pcma;\n    else\n      LOWORD(v6) = pcma;\n    v7 = out++;\n    *v7 = v6;\n  }\n}", "binary": "audio-codec/audio-codec.host.O0", "assembly": "<decode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovb   $0x0,-0x15(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovq   $0x0,-0x8(%rbp)\njmp    13c0 <decode+0xcb>\nmov    -0x30(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmovzbl (%rax),%eax\nmov    %al,-0x15(%rbp)\nxorb   $0xd5,-0x15(%rbp)\nmovzbl -0x15(%rbp),%eax\nand    $0x80,%eax\nmov    %eax,-0x10(%rbp)\nmovzbl -0x15(%rbp),%eax\nsar    $0x4,%eax\nand    $0x7,%eax\nmov    %eax,-0xc(%rbp)\nmovzbl -0x15(%rbp),%eax\nshl    $0x4,%eax\nmovzbl %al,%eax\nor     $0x8,%eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0xc(%rbp)\nje     137b <decode+0x86>\nmov    $0x100,%eax\njmp    1380 <decode+0x8b>\nmov    $0x0,%eax\nadd    %eax,-0x14(%rbp)\nmov    -0xc(%rbp),%eax\nmov    $0x1,%edx\ntest   %eax,%eax\ncmovle %edx,%eax\nsub    $0x1,%eax\nmov    %eax,%ecx\nshll   %cl,-0x14(%rbp)\ncmpl   $0x0,-0x10(%rbp)\nje     13a7 <decode+0xb2>\nmov    -0x14(%rbp),%eax\nneg    %eax\nmov    %eax,%ecx\njmp    13ac <decode+0xb7>\nmov    -0x14(%rbp),%eax\nmov    %eax,%ecx\nmov    -0x28(%rbp),%rax\nlea    0x2(%rax),%rdx\nmov    %rdx,-0x28(%rbp)\nmov    %cx,(%rax)\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x38(%rbp),%rax\njb     132f <decode+0x3a>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "audio-codec/audio-codec.c", "function_name": "encode", "content": "/**\n * @brief 16bit pcm to 8bit alaw\n * @param out unsigned 8bit alaw array\n * @param in  signed 16bit pcm array\n * @param len length of pcm array\n * @returns void\n */\nvoid encode(uint8_t *out, int16_t *in, size_t len)\n{\n    uint8_t alaw = 0;\n    int16_t pcm = 0;\n    int32_t sign = 0;\n    int32_t abcd = 0;\n    int32_t eee = 0;\n    int32_t mask = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        pcm = *in++;\n        /* 0-7 kinds of quantization level from the table above */\n        eee = 7;\n        mask = 0x4000; /* 0x4000: '0b0100 0000 0000 0000' */\n\n        /* Get sign bit */\n        sign = (pcm & 0x8000) >> 8;\n\n        /* Turn negative pcm to positive */\n        /* The absolute value of a negative number may be larger than the size\n         * of the corresponding positive number, so here needs `-pcm -1` after\n         * taking the opposite number. */\n        pcm = sign ? (-pcm - 1) : pcm;\n\n        /* Get eee and abcd bit */\n        /* Use mask to locate the first `1` bit and quantization level at the\n         * same time */\n        while ((pcm & mask) == 0 && eee > 0)\n        {\n            eee--;\n            mask >>= 1;\n        }\n\n        /* The location of abcd bits is related with quantization level. Check\n         * the table above to determine how many bits to `>>` to get abcd */\n        abcd = (pcm >> (eee ? (eee + 3) : 4)) & 0x0f;\n\n        /* Put the quantization level number at right bit location to get eee\n         * bits */\n        eee <<= 4;\n\n        /* Splice results */\n        alaw = (sign | eee | abcd);\n\n        /* The standard specifies that all resulting even bits (LSB\n         * is even) are inverted before the octet is transmitted. This is to\n         * provide plenty of 0/1 transitions to facilitate the clock recovery\n         * process in the PCM receivers. Thus, a silent A-law encoded PCM\n         * channel has the 8 bit samples coded 0xD5 instead of 0x80 in the\n         * octets. (Reference from wiki above) */\n        *out++ = alaw ^ 0xD5;\n    }\n}\n"}, "pseudo": {"path": "audio-codec/audio-codec.host.O0.pseudo", "function_name": "encode", "address": "0x11e9", "label": "encode", "content": "void __cdecl encode(uint8_t *out, int16_t *in, size_t len)\n{\n  int16_t *v3; // rax\n  int16_t v4; // ax\n  char v5; // al\n  uint8_t *v6; // rax\n  uint8_t alaw; // [rsp+1Dh] [rbp-1Bh]\n  int16_t pcm; // [rsp+1Eh] [rbp-1Ah]\n  int32_t eee; // [rsp+20h] [rbp-18h]\n  int32_t mask; // [rsp+24h] [rbp-14h]\n  int32_t sign; // [rsp+28h] [rbp-10h]\n  size_t i; // [rsp+30h] [rbp-8h]\n\n  for ( i = 0LL; i < len; ++i )\n  {\n    v3 = in++;\n    eee = 7;\n    mask = 0x4000;\n    sign = (*v3 >> 8) & 0x80;\n    if ( sign )\n      v4 = ~*v3;\n    else\n      v4 = *v3;\n    pcm = v4;\n    while ( (mask & v4) == 0 && eee > 0 )\n    {\n      --eee;\n      mask >>= 1;\n    }\n    if ( eee )\n      v5 = eee + 3;\n    else\n      v5 = 4;\n    alaw = (16 * eee) | sign | (pcm >> v5) & 0xF;\n    v6 = out++;\n    *v6 = alaw ^ 0xD5;\n  }\n}\n"}, "pseudo_normalize": "void encode(uint8_t *out, int16_t *in, unsigned int len) {\n  int16_t *v3;\n  int16_t v4;\n  char v5;\n  uint8_t *v6;\n  uint8_t alaw;\n  int16_t pcm;\n  int32_t eee;\n  int32_t mask;\n  int32_t sign;\n  unsigned int i;\n  for (i = 0LL; i < len; ++i) {\n    v3 = in++;\n    eee = 7;\n    mask = 16384;\n    sign = (*v3 >> 8) & 128;\n    if (sign)\n      v4 = ~*v3;\n    else\n      v4 = *v3;\n    pcm = v4;\n    while ((mask & v4) == 0 && eee > 0) {\n      --eee;\n      mask >>= 1;\n    }\n    if (eee)\n      v5 = eee + 3;\n    else\n      v5 = 4;\n    alaw = (16 * eee) | sign | (pcm >> v5) & 15;\n    v6 = out++;\n    *v6 = alaw ^ 213;\n  }\n}", "binary": "audio-codec/audio-codec.host.O0", "assembly": "<encode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovb   $0x0,-0x1b(%rbp)\nmovw   $0x0,-0x1a(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovq   $0x0,-0x8(%rbp)\njmp    12e3 <encode+0xfa>\nmov    -0x30(%rbp),%rax\nlea    0x2(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmovzwl (%rax),%eax\nmov    %ax,-0x1a(%rbp)\nmovl   $0x7,-0x18(%rbp)\nmovl   $0x4000,-0x14(%rbp)\nmovswl -0x1a(%rbp),%eax\nsar    $0x8,%eax\nand    $0x80,%eax\nmov    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\nje     126e <encode+0x85>\nmovzwl -0x1a(%rbp),%eax\nnot    %eax\njmp    1272 <encode+0x89>\nmovzwl -0x1a(%rbp),%eax\nmov    %ax,-0x1a(%rbp)\njmp    127f <encode+0x96>\nsubl   $0x1,-0x18(%rbp)\nsarl   -0x14(%rbp)\nmovswl -0x1a(%rbp),%eax\nand    -0x14(%rbp),%eax\ntest   %eax,%eax\njne    1290 <encode+0xa7>\ncmpl   $0x0,-0x18(%rbp)\njg     1278 <encode+0x8f>\nmovswl -0x1a(%rbp),%edx\ncmpl   $0x0,-0x18(%rbp)\nje     12a2 <encode+0xb9>\nmov    -0x18(%rbp),%eax\nadd    $0x3,%eax\njmp    12a7 <encode+0xbe>\nmov    $0x4,%eax\nmov    %eax,%ecx\nsar    %cl,%edx\nmov    %edx,%eax\nand    $0xf,%eax\nmov    %eax,-0xc(%rbp)\nshll   $0x4,-0x18(%rbp)\nmov    -0x10(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%eax\nor     %eax,%edx\nmov    -0xc(%rbp),%eax\nor     %edx,%eax\nmov    %al,-0x1b(%rbp)\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x28(%rbp)\nmovzbl -0x1b(%rbp),%edx\nxor    $0xffffffd5,%edx\nmov    %dl,(%rax)\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x38(%rbp),%rax\njb     1230 <encode+0x47>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "audio-codec/audio-codec.c", "function_name": "main", "content": "/**\n * @brief Main function\n * @param argc commandline argument count (ignored)\n * @param argv commandline array of arguments (ignored)\n * @returns 0 on exit\n */\nint main(int argc, char *argv[])\n{\n    /* output alaw encoded by encode() */\n    uint8_t coded[LEN];\n\n    /* output pcm decoded by decode() from coded[LEN] */\n    int16_t decoded[LEN];\n\n    test(pcm, coded, decoded, LEN);  // run self-test implementations\n\n    /* print test pcm inputs */\n    libmin_printf(\"inputs: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%d \", pcm[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* print encoded alaw */\n    libmin_printf(\"encode: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%u \", coded[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* print decoded pcm */\n    libmin_printf(\"decode: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%d \", decoded[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* It can be seen that the encoded alaw is smaller than the input PCM, so\n     * the purpose of compression is achieved. And the decoded PCM is almost the\n     * same as the original input PCM, which verifies the correctness of the\n     * decoding. The reason why it is not exactly the same is that there is\n     * precision loss during encode / decode.  */\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "audio-codec/audio-codec.host.O0.pseudo", "function_name": "main", "address": "0x14b3", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  size_t i; // [rsp+18h] [rbp-38h]\n  size_t i_0; // [rsp+20h] [rbp-30h]\n  size_t i_1; // [rsp+28h] [rbp-28h]\n  int16_t decoded[8]; // [rsp+30h] [rbp-20h] BYREF\n  uint8_t coded[8]; // [rsp+40h] [rbp-10h] BYREF\n  unsigned __int64 v8; // [rsp+48h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u);\n  test(pcm, coded, decoded, 8uLL);\n  libmin_printf(\"inputs: \");\n  for ( i = 0LL; i <= 7; ++i )\n    libmin_printf(\"%d \", pcm[i]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"encode: \");\n  for ( i_0 = 0LL; i_0 <= 7; ++i_0 )\n    libmin_printf(\"%u \", coded[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"decode: \");\n  for ( i_1 = 0LL; i_1 <= 7; ++i_1 )\n    libmin_printf(\"%d \", decoded[i_1]);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int i_0;\n  unsigned int i_1;\n  int16_t decoded[8];\n  uint8_t coded[8];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  test(pcm, coded, decoded, 8uLL);\n  libmin_printf(\"inputs: \");\n  for (i = 0LL; i <= 7; ++i) libmin_printf(\"%d \", pcm[i]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"encode: \");\n  for (i_0 = 0LL; i_0 <= 7; ++i_0) libmin_printf(\"%u \", coded[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"decode: \");\n  for (i_1 = 0LL; i_1 <= 7; ++i_1) libmin_printf(\"%d \", decoded[i_1]);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}", "binary": "audio-codec/audio-codec.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x20(%rbp),%rdx\nlea    -0x10(%rbp),%rax\nmov    $0x8,%ecx\nmov    %rax,%rsi\nlea    0x4b24(%rip),%rax\nmov    %rax,%rdi\ncall   13d2 <test>\nlea    0x2b09(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\nmovq   $0x0,-0x38(%rbp)\njmp    1541 <main+0x8e>\nmov    -0x38(%rbp),%rax\nlea    (%rax,%rax,1),%rdx\nlea    0x4aef(%rip),%rax\nmovzwl (%rdx,%rax,1),%eax\ncwtl\nmov    %eax,%esi\nlea    0x2ade(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\naddq   $0x1,-0x38(%rbp)\ncmpq   $0x7,-0x38(%rbp)\njbe    1512 <main+0x5f>\nlea    0x2ac2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\nlea    0x2ab0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\nmovq   $0x0,-0x30(%rbp)\njmp    15a6 <main+0xf3>\nlea    -0x10(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x2a88(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\naddq   $0x1,-0x30(%rbp)\ncmpq   $0x7,-0x30(%rbp)\njbe    157a <main+0xc7>\nlea    0x2a5d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\nlea    0x2a58(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\nmovq   $0x0,-0x28(%rbp)\njmp    1604 <main+0x151>\nmov    -0x28(%rbp),%rax\nmovzwl -0x20(%rbp,%rax,2),%eax\ncwtl\nmov    %eax,%esi\nlea    0x2a1b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\naddq   $0x1,-0x28(%rbp)\ncmpq   $0x7,-0x28(%rbp)\njbe    15df <main+0x12c>\nlea    0x29ff(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37ad <libmin_printf>\ncall   3a1a <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     163d <main+0x18a>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "audio-codec/audio-codec.c", "function_name": "test", "content": "/**\n * @brief Self-test implementations\n * @param pcm signed 16bit pcm array\n * @param coded unsigned 8bit alaw array\n * @param decoded signed 16bit pcm array\n * @param len length of test array\n * @returns void\n */\nstatic void test(int16_t *pcm, uint8_t *coded, int16_t *decoded, size_t len)\n{\n    /* run encode */\n    encode(coded, pcm, len);\n\n    /* check encode result */\n    for (size_t i = 0; i < len; i++)\n    {\n        libmin_assert(coded[i] == r_coded[i]);\n    }\n\n    /* run decode */\n    decode(decoded, coded, len);\n\n    /* check decode result */\n    for (size_t i = 0; i < len; i++)\n    {\n        libmin_assert(decoded[i] == r_decoded[i]);\n    }\n}\n"}, "pseudo": {"path": "audio-codec/audio-codec.host.O0.pseudo", "function_name": "test", "address": "0x13d2", "label": "test", "content": "void __cdecl test(int16_t *pcm, uint8_t *coded, int16_t *decoded, size_t len)\n{\n  size_t i; // [rsp+20h] [rbp-10h]\n  size_t i_0; // [rsp+28h] [rbp-8h]\n\n  encode(coded, pcm, len);\n  for ( i = 0LL; i < len; ++i )\n  {\n    if ( coded[i] != r_coded[i] )\n      libmin_fail(1);\n  }\n  decode(decoded, coded, len);\n  for ( i_0 = 0LL; i_0 < len; ++i_0 )\n  {\n    if ( decoded[i_0] != r_decoded[i_0] )\n      libmin_fail(1);\n  }\n}\n"}, "pseudo_normalize": "void test(int16_t *pcm, uint8_t *coded, int16_t *decoded, unsigned int len) {\n  unsigned int i;\n  unsigned int i_0;\n  encode(coded, pcm, len);\n  for (i = 0LL; i < len; ++i) {\n    if (coded[i] != r_coded[i]) libmin_fail(1);\n  }\n  decode(decoded, coded, len);\n  for (i_0 = 0LL; i_0 < len; ++i_0) {\n    if (decoded[i_0] != r_decoded[i_0]) libmin_fail(1);\n  }\n}", "binary": "audio-codec/audio-codec.host.O0", "assembly": "<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmov    -0x30(%rbp),%rdx\nmov    -0x18(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <encode>\nmovq   $0x0,-0x10(%rbp)\njmp    1441 <test+0x6f>\nmov    -0x20(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nlea    0x4bfc(%rip),%rcx\nmov    -0x10(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     143c <test+0x6a>\nmov    $0x1,%edi\ncall   1781 <libmin_fail>\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     140f <test+0x3d>\nmov    -0x30(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   12f5 <decode>\nmovq   $0x0,-0x8(%rbp)\njmp    14a5 <test+0xd3>\nmov    -0x8(%rbp),%rax\nlea    (%rax,%rax,1),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzwl (%rax),%edx\nmov    -0x8(%rbp),%rax\nlea    (%rax,%rax,1),%rcx\nlea    0x4ba3(%rip),%rax\nmovzwl (%rcx,%rax,1),%eax\ncmp    %ax,%dx\nje     14a0 <test+0xce>\nmov    $0x1,%edi\ncall   1781 <libmin_fail>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     146c <test+0x9a>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "CheckTreeNodeRotation", "content": "TreeNode *CheckTreeNodeRotation(TreeNode *tnode,\n                                TreeNode *subtree, short *finished)\n{\n    /* this function will check to see if tnode's Balance factor indicates\n        that a rotation is needed. Subtree is the child link that was either\n        just added or possibly changed */\n    switch(tnode->Balance)  {\n        case 0:\n            /* nothing special, but we have balanced out properly, yay */\n            *finished = 1;\n            break;\n        case 2:\n            /* right heavy */\n            *finished = 1;\n            if(subtree->Balance == -1)   {\n                /* update balance factors */\n                if(subtree->Left->Balance == 1)    {\n                    subtree->Balance = 0;\n                    tnode->Balance = -1;\n                } else if(subtree->Left->Balance == -1)    {\n                    subtree->Balance = 1;\n                    tnode->Balance = 0;\n                } else\n                    subtree->Balance = tnode->Balance = 0;\n                subtree->Left->Balance = 0;\n                tnode = DoubleLeftRotation(tnode);\n            } else if(subtree->Balance == 1)   {\n                /* update balance factors */\n                subtree->Balance = tnode->Balance = 0;\n                tnode = SingleLeftRotation(tnode);\n            }\n            break;\n        case -2:\n            /* left heavy */\n            *finished = 1;\n            if(subtree->Balance == 1)  {\n                /* update balance factors */\n                if(subtree->Right->Balance == -1)    {\n                    subtree->Balance = 0;\n                    tnode->Balance = 1;\n                } else if(subtree->Right->Balance == 1)    {\n                    subtree->Balance = -1;\n                    tnode->Balance = 0;\n                } else\n                    subtree->Balance = tnode->Balance = 0;\n                subtree->Right->Balance = 0;\n                tnode = DoubleRightRotation(tnode);\n            } else if(subtree->Balance == -1)   {\n                /* update balance factors */\n                subtree->Balance = tnode->Balance = 0;\n                tnode = SingleRightRotation(tnode);\n            }\n    }\n    return tnode;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "CheckTreeNodeRotation", "address": "0x1c04", "label": "CheckTreeNodeRotation", "content": "TreeNode *__cdecl CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree, __int16 *finished)\n{\n  int Balance; // eax\n  TreeNode *tnodea; // [rsp+10h] [rbp-8h]\n\n  tnodea = tnode;\n  Balance = tnode->Balance;\n  if ( (__int16)Balance == 2 )\n  {\n    *finished = 1;\n    if ( subtree->Balance == -1 )\n    {\n      if ( subtree->Left->Balance == 1 )\n      {\n        subtree->Balance = 0;\n        tnode->Balance = -1;\n      }\n      else if ( subtree->Left->Balance == -1 )\n      {\n        subtree->Balance = 1;\n        tnode->Balance = 0;\n      }\n      else\n      {\n        tnode->Balance = 0;\n        subtree->Balance = tnode->Balance;\n      }\n      subtree->Left->Balance = 0;\n      return DoubleLeftRotation(tnode);\n    }\n    else if ( subtree->Balance == 1 )\n    {\n      tnode->Balance = 0;\n      subtree->Balance = tnode->Balance;\n      return SingleLeftRotation(tnode);\n    }\n  }\n  else if ( Balance <= 2 )\n  {\n    if ( Balance == -2 )\n    {\n      *finished = 1;\n      if ( subtree->Balance == 1 )\n      {\n        if ( subtree->Right->Balance == -1 )\n        {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        }\n        else if ( subtree->Right->Balance == 1 )\n        {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        }\n        else\n        {\n          tnode->Balance = 0;\n          subtree->Balance = tnode->Balance;\n        }\n        subtree->Right->Balance = 0;\n        return DoubleRightRotation(tnode);\n      }\n      else if ( subtree->Balance == -1 )\n      {\n        tnode->Balance = 0;\n        subtree->Balance = tnode->Balance;\n        return SingleRightRotation(tnode);\n      }\n    }\n    else if ( !tnode->Balance )\n    {\n      *finished = 1;\n    }\n  }\n  return tnodea;\n}\n"}, "pseudo_normalize": "TreeNode *CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree,\n                                short *finished) {\n  int Balance;\n  TreeNode *tnodea;\n  tnodea = tnode;\n  Balance = tnode->Balance;\n  if ((short)Balance == 2) {\n    *finished = 1;\n    if (subtree->Balance == -1) {\n      if (subtree->Left->Balance == 1) {\n        subtree->Balance = 0;\n        tnode->Balance = -1;\n      } else if (subtree->Left->Balance == -1) {\n        subtree->Balance = 1;\n        tnode->Balance = 0;\n      } else {\n        tnode->Balance = 0;\n        subtree->Balance = tnode->Balance;\n      }\n      subtree->Left->Balance = 0;\n      return DoubleLeftRotation(tnode);\n    } else if (subtree->Balance == 1) {\n      tnode->Balance = 0;\n      subtree->Balance = tnode->Balance;\n      return SingleLeftRotation(tnode);\n    }\n  } else if (Balance <= 2) {\n    if (Balance == -2) {\n      *finished = 1;\n      if (subtree->Balance == 1) {\n        if (subtree->Right->Balance == -1) {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        } else if (subtree->Right->Balance == 1) {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        } else {\n          tnode->Balance = 0;\n          subtree->Balance = tnode->Balance;\n        }\n        subtree->Right->Balance = 0;\n        return DoubleRightRotation(tnode);\n      } else if (subtree->Balance == -1) {\n        tnode->Balance = 0;\n        subtree->Balance = tnode->Balance;\n        return SingleRightRotation(tnode);\n      }\n    } else if (!tnode->Balance) {\n      *finished = 1;\n    }\n  }\n  return tnodea;\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<CheckTreeNodeRotation>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovzwl 0x20(%rax),%eax\ncwtl\ncmp    $0x2,%eax\nje     1c52 <CheckTreeNodeRotation+0x4e>\ncmp    $0x2,%eax\njg     1e18 <CheckTreeNodeRotation+0x214>\ncmp    $0xfffffffe,%eax\nje     1d38 <CheckTreeNodeRotation+0x134>\ntest   %eax,%eax\njne    1e18 <CheckTreeNodeRotation+0x214>\nmov    -0x18(%rbp),%rax\nmovw   $0x1,(%rax)\njmp    1e18 <CheckTreeNodeRotation+0x214>\nmov    -0x18(%rbp),%rax\nmovw   $0x1,(%rax)\nmov    -0x10(%rbp),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0xffff,%ax\njne    1cf7 <CheckTreeNodeRotation+0xf3>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0x1,%ax\njne    1c94 <CheckTreeNodeRotation+0x90>\nmov    -0x10(%rbp),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovw   $0xffff,0x20(%rax)\njmp    1cd5 <CheckTreeNodeRotation+0xd1>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0xffff,%ax\njne    1cbb <CheckTreeNodeRotation+0xb7>\nmov    -0x10(%rbp),%rax\nmovw   $0x1,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovw   $0x0,0x20(%rax)\njmp    1cd5 <CheckTreeNodeRotation+0xd1>\nmov    -0x8(%rbp),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1bbe <DoubleLeftRotation>\nmov    %rax,-0x8(%rbp)\njmp    1e17 <CheckTreeNodeRotation+0x213>\nmov    -0x10(%rbp),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0x1,%ax\njne    1e17 <CheckTreeNodeRotation+0x213>\nmov    -0x8(%rbp),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1b3a <SingleLeftRotation>\nmov    %rax,-0x8(%rbp)\njmp    1e17 <CheckTreeNodeRotation+0x213>\nmov    -0x18(%rbp),%rax\nmovw   $0x1,(%rax)\nmov    -0x10(%rbp),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0x1,%ax\njne    1ddd <CheckTreeNodeRotation+0x1d9>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0xffff,%ax\njne    1d7b <CheckTreeNodeRotation+0x177>\nmov    -0x10(%rbp),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovw   $0x1,0x20(%rax)\njmp    1dbd <CheckTreeNodeRotation+0x1b9>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0x1,%ax\njne    1da3 <CheckTreeNodeRotation+0x19f>\nmov    -0x10(%rbp),%rax\nmovw   $0xffff,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovw   $0x0,0x20(%rax)\njmp    1dbd <CheckTreeNodeRotation+0x1b9>\nmov    -0x8(%rbp),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1b7a <DoubleRightRotation>\nmov    %rax,-0x8(%rbp)\njmp    1e18 <CheckTreeNodeRotation+0x214>\nmov    -0x10(%rbp),%rax\nmovzwl 0x20(%rax),%eax\ncmp    $0xffff,%ax\njne    1e18 <CheckTreeNodeRotation+0x214>\nmov    -0x8(%rbp),%rax\nmovw   $0x0,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1afa <SingleRightRotation>\nmov    %rax,-0x8(%rbp)\njmp    1e18 <CheckTreeNodeRotation+0x214>\nnop\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "avl-tree/element.c", "function_name": "Compare", "content": "#include \"libmin.h\"\n#include \"element.h\"\n\nshort Compare(Element Data1, Element Data2)\n{\n    if(*Data1 > *Data2)\n        return 1;\n    else if(*Data1 < *Data2)\n        return -1;\n    return 0;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "Compare", "address": "0x19e2", "label": "Compare", "content": "__int16 __cdecl Compare(Element Data1, Element Data2)\n{\n  if ( *Data1 > *Data2 )\n    return 1;\n  if ( *Data1 >= *Data2 )\n    return 0;\n  return -1;\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<Compare>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    1a09 <Compare+0x27>\nmov    $0x1,%eax\njmp    1a25 <Compare+0x43>\nmov    -0x8(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njge    1a20 <Compare+0x3e>\nmov    $0xffffffff,%eax\njmp    1a25 <Compare+0x43>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DeleteByElement", "content": "TreeNode *DeleteByElement(TreeNode *rootNode, Element Item)\n{\n    short finished = 0;\n    TreeNode *newRoot = NULL;\n    newRoot = DeleteByElementRecursive(rootNode, Item, &finished);\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "DeleteByElement", "address": "0x240f", "label": "DeleteByElement", "content": "TreeNode *__cdecl DeleteByElement(TreeNode *rootNode, Element Item)\n{\n  __int16 finished; // [rsp+1Eh] [rbp-12h] BYREF\n  TreeNode *newRoot; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  finished = 0;\n  newRoot = 0LL;\n  return DeleteByElementRecursive(rootNode, Item, &finished);\n}\n"}, "pseudo_normalize": "TreeNode *DeleteByElement(TreeNode *rootNode, Element Item) {\n  short finished;\n  TreeNode *newRoot;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  finished = 0;\n  newRoot = 0LL;\n  return DeleteByElementRecursive(rootNode, Item, &finished);\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<DeleteByElement>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovw   $0x0,-0x12(%rbp)\nmovq   $0x0,-0x10(%rbp)\nlea    -0x12(%rbp),%rdx\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   21af <DeleteByElementRecursive>\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     2473 <DeleteByElement+0x64>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DeleteByElementRecursive", "content": "TreeNode *DeleteByElementRecursive(TreeNode *rootNode,\n                                   Element Item, short *finished)\n{\n    TreeNode *subtree = NULL;\n    short comp = 0;\n    \n    /* found a leaf */\n    if(rootNode == NULL)\n        return NULL;\n    /* figure out where the node in question is in relation to the current */\n    comp = Compare(rootNode->Item, Item);\n    if(comp > 0)    {\n        /* buried somewhere in the right subtree */\n        subtree = DeleteByElementRecursive(rootNode->Right, Item, finished);\n        rootNode->Right = subtree;\n        if(!*finished && subtree != NULL)  {\n            rootNode->Balance--;\n            rootNode = CheckTreeNodeRotation(rootNode, subtree, finished);\n        }\n    } else if(comp < 0) {\n        subtree = DeleteByElementRecursive(rootNode->Left, Item, finished);\n        rootNode->Left = subtree;\n        if(!*finished && subtree != NULL)  {\n            rootNode->Balance++;\n            rootNode = CheckTreeNodeRotation(rootNode, subtree, finished);\n        }\n    } else {\n        /* found what we were looking for */\n        if(rootNode->Right == NULL) {\n            /* rootNode is replaced by the left child; can be null */\n            subtree = rootNode->Left;\n            libmin_free(rootNode->Name);\n            FreeElement(rootNode->Item);\n            libmin_free(rootNode);\n            rootNode = subtree;\n        } else if(rootNode->Right->Left == NULL)  {\n            /* rootNode is replaced by Right */\n            subtree = rootNode->Right;\n            subtree->Balance = rootNode->Balance;\n            subtree->Left = rootNode->Left;\n            libmin_free(rootNode->Name);\n            FreeElement(rootNode->Item);\n            libmin_free(rootNode);\n            rootNode = subtree;\n        } else {\n            /* rootNode is replaced by inorder successor */\n            /* re-using comp as another flag since it is 0 */\n            rootNode->Right = DeleteLeftMost(&rootNode, rootNode->Right, &comp);\n        }\n    }\n    return rootNode;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "DeleteByElementRecursive", "address": "0x21af", "label": "DeleteByElementRecursive", "content": "TreeNode *__cdecl DeleteByElementRecursive(TreeNode *rootNode, Element Item, __int16 *finished)\n{\n  TreeNode *v4; // rbx\n  TreeNode *rootNodea; // [rsp+18h] [rbp-38h] BYREF\n  __int16 comp; // [rsp+2Eh] [rbp-22h] BYREF\n  TreeNode *subtree; // [rsp+30h] [rbp-20h]\n  unsigned __int64 v9; // [rsp+38h] [rbp-18h]\n\n  rootNodea = rootNode;\n  v9 = __readfsqword(0x28u);\n  subtree = 0LL;\n  comp = 0;\n  if ( !rootNode )\n    return 0LL;\n  comp = Compare(rootNodea->Item, Item);\n  if ( comp <= 0 )\n  {\n    if ( comp >= 0 )\n    {\n      if ( rootNodea->Right )\n      {\n        if ( rootNodea->Right->Left )\n        {\n          v4 = rootNodea;\n          v4->Right = DeleteLeftMost(&rootNodea, rootNodea->Right, &comp);\n        }\n        else\n        {\n          subtree = rootNodea->Right;\n          subtree->Balance = rootNodea->Balance;\n          subtree->Left = rootNodea->Left;\n          libmin_free(rootNodea->Name);\n          FreeElement(rootNodea->Item);\n          libmin_free(rootNodea);\n          return subtree;\n        }\n      }\n      else\n      {\n        subtree = rootNodea->Left;\n        libmin_free(rootNodea->Name);\n        FreeElement(rootNodea->Item);\n        libmin_free(rootNodea);\n        return subtree;\n      }\n    }\n    else\n    {\n      subtree = DeleteByElementRecursive(rootNodea->Left, Item, finished);\n      rootNodea->Left = subtree;\n      if ( !*finished && subtree )\n      {\n        ++rootNodea->Balance;\n        return CheckTreeNodeRotation(rootNodea, subtree, finished);\n      }\n    }\n  }\n  else\n  {\n    subtree = DeleteByElementRecursive(rootNodea->Right, Item, finished);\n    rootNodea->Right = subtree;\n    if ( !*finished )\n    {\n      if ( subtree )\n      {\n        --rootNodea->Balance;\n        return CheckTreeNodeRotation(rootNodea, subtree, finished);\n      }\n    }\n  }\n  return rootNodea;\n}\n"}, "pseudo_normalize": "TreeNode *DeleteByElementRecursive(TreeNode *rootNode, Element Item,\n                                   short *finished) {\n  TreeNode *v4;\n  TreeNode *rootNodea;\n  short comp;\n  TreeNode *subtree;\n  unsigned long long v9;\n  rootNodea = rootNode;\n  v9 = __readfsqword(40u);\n  subtree = 0LL;\n  comp = 0;\n  if (!rootNode) return 0LL;\n  comp = Compare(rootNodea->Item, Item);\n  if (comp <= 0) {\n    if (comp >= 0) {\n      if (rootNodea->Right) {\n        if (rootNodea->Right->Left) {\n          v4 = rootNodea;\n          v4->Right = DeleteLeftMost(&rootNodea, rootNodea->Right, &comp);\n        } else {\n          subtree = rootNodea->Right;\n          subtree->Balance = rootNodea->Balance;\n          subtree->Left = rootNodea->Left;\n          libmin_free(rootNodea->Name);\n          FreeElement(rootNodea->Item);\n          libmin_free(rootNodea);\n          return subtree;\n        }\n      } else {\n        subtree = rootNodea->Left;\n        libmin_free(rootNodea->Name);\n        FreeElement(rootNodea->Item);\n        libmin_free(rootNodea);\n        return subtree;\n      }\n    } else {\n      subtree = DeleteByElementRecursive(rootNodea->Left, Item, finished);\n      rootNodea->Left = subtree;\n      if (!*finished && subtree) {\n        ++rootNodea->Balance;\n        return CheckTreeNodeRotation(rootNodea, subtree, finished);\n      }\n    }\n  } else {\n    subtree = DeleteByElementRecursive(rootNodea->Right, Item, finished);\n    rootNodea->Right = subtree;\n    if (!*finished) {\n      if (subtree) {\n        --rootNodea->Balance;\n        return CheckTreeNodeRotation(rootNodea, subtree, finished);\n      }\n    }\n  }\n  return rootNodea;\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<DeleteByElementRecursive>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x20(%rbp)\nmovw   $0x0,-0x22(%rbp)\nmov    -0x38(%rbp),%rax\ntest   %rax,%rax\njne    21f8 <DeleteByElementRecursive+0x49>\nmov    $0x0,%eax\njmp    23f5 <DeleteByElementRecursive+0x246>\nmov    -0x38(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    -0x40(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   19e2 <Compare>\nmov    %ax,-0x22(%rbp)\nmovzwl -0x22(%rbp),%eax\ntest   %ax,%ax\njle    2291 <DeleteByElementRecursive+0xe2>\nmov    -0x38(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    -0x48(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   21af <DeleteByElementRecursive>\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nmov    -0x48(%rbp),%rax\nmovzwl (%rax),%eax\ntest   %ax,%ax\njne    23f1 <DeleteByElementRecursive+0x242>\ncmpq   $0x0,-0x20(%rbp)\nje     23f1 <DeleteByElementRecursive+0x242>\nmov    -0x38(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nsub    $0x1,%edx\nmov    %dx,0x20(%rax)\nmov    -0x38(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1c04 <CheckTreeNodeRotation>\nmov    %rax,-0x38(%rbp)\njmp    23f1 <DeleteByElementRecursive+0x242>\nmovzwl -0x22(%rbp),%eax\ntest   %ax,%ax\njns    230d <DeleteByElementRecursive+0x15e>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x48(%rbp),%rdx\nmov    -0x40(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   21af <DeleteByElementRecursive>\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x48(%rbp),%rax\nmovzwl (%rax),%eax\ntest   %ax,%ax\njne    23f1 <DeleteByElementRecursive+0x242>\ncmpq   $0x0,-0x20(%rbp)\nje     23f1 <DeleteByElementRecursive+0x242>\nmov    -0x38(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nadd    $0x1,%edx\nmov    %dx,0x20(%rax)\nmov    -0x38(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1c04 <CheckTreeNodeRotation>\nmov    %rax,-0x38(%rbp)\njmp    23f1 <DeleteByElementRecursive+0x242>\nmov    -0x38(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    235e <DeleteByElementRecursive+0x1af>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x38(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    %rax,%rdi\ncall   1a27 <FreeElement>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x38(%rbp)\njmp    23f1 <DeleteByElementRecursive+0x242>\nmov    -0x38(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    23ce <DeleteByElementRecursive+0x21f>\nmov    -0x38(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmovzwl 0x20(%rax),%edx\nmov    -0x20(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x38(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x38(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    %rax,%rdi\ncall   1a27 <FreeElement>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x38(%rbp)\njmp    23f1 <DeleteByElementRecursive+0x242>\nmov    -0x38(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0x38(%rbp),%rbx\nlea    -0x22(%rbp),%rdx\nlea    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   2086 <DeleteLeftMost>\nmov    %rax,0x8(%rbx)\nmov    -0x38(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     2409 <DeleteByElementRecursive+0x25a>\ncall   10b0 <__stack_chk_fail@plt>\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DeleteLeftMost", "content": "TreeNode *DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode,\n                    short *finished)\n{\n    TreeNode *subtree = rootNode->Right;\n    if(rootNode == NULL)    {\n        libmin_printf(\"bailing!\\n\");\n        return NULL;\n    }\n    if(rootNode->Left == NULL)  {\n        libmin_free((*deletedNode)->Name);\n        FreeElement((*deletedNode)->Item);\n        (*deletedNode)->Name = rootNode->Name;\n        (*deletedNode)->Item = rootNode->Item;\n        libmin_free(rootNode);\n        rootNode = subtree;\n    } else {\n        rootNode->Left = DeleteLeftMost(deletedNode, rootNode->Left, finished);\n        if(!*finished)  {\n            rootNode->Balance++;\n            if(rootNode->Left != NULL)\n                rootNode = CheckTreeNodeRotation(rootNode, rootNode->Left,\n                                finished);\n        }\n    }\n    return rootNode;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "DeleteLeftMost", "address": "0x2086", "label": "DeleteLeftMost", "content": "TreeNode *__cdecl DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode, __int16 *finished)\n{\n  TreeNode *rootNodea; // [rsp+10h] [rbp-20h]\n  TreeNodeTag *subtree; // [rsp+28h] [rbp-8h]\n\n  rootNodea = rootNode;\n  subtree = rootNode->Right;\n  if ( rootNode )\n  {\n    if ( rootNode->Left )\n    {\n      rootNode->Left = DeleteLeftMost(deletedNode, rootNode->Left, finished);\n      if ( !*finished )\n      {\n        ++rootNode->Balance;\n        if ( rootNode->Left )\n          return CheckTreeNodeRotation(rootNode, rootNode->Left, finished);\n      }\n    }\n    else\n    {\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      (*deletedNode)->Name = rootNode->Name;\n      (*deletedNode)->Item = rootNode->Item;\n      libmin_free(rootNode);\n      return subtree;\n    }\n    return rootNodea;\n  }\n  else\n  {\n    libmin_printf(\"bailing!\\n\");\n    return 0LL;\n  }\n}\n"}, "pseudo_normalize": "TreeNode *DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode,\n                         short *finished) {\n  TreeNode *rootNodea;\n  TreeNodeTag *subtree;\n  rootNodea = rootNode;\n  subtree = rootNode->Right;\n  if (rootNode) {\n    if (rootNode->Left) {\n      rootNode->Left = DeleteLeftMost(deletedNode, rootNode->Left, finished);\n      if (!*finished) {\n        ++rootNode->Balance;\n        if (rootNode->Left)\n          return CheckTreeNodeRotation(rootNode, rootNode->Left, finished);\n      }\n    } else {\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      (*deletedNode)->Name = rootNode->Name;\n      (*deletedNode)->Item = rootNode->Item;\n      libmin_free(rootNode);\n      return subtree;\n    }\n    return rootNodea;\n  } else {\n    libmin_printf(\"bailing!\\n\");\n    return 0LL;\n  }\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<DeleteLeftMost>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x20(%rbp)\njne    20cf <DeleteLeftMost+0x49>\nlea    0x4150(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    $0x0,%eax\njmp    21ad <DeleteLeftMost+0x127>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    213d <DeleteLeftMost+0xb7>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    0x18(%rax),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    0x10(%rax),%rax\nmov    %rax,%rdi\ncall   1a27 <FreeElement>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x20(%rbp),%rdx\nmov    0x18(%rdx),%rdx\nmov    %rdx,0x18(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x20(%rbp),%rdx\nmov    0x10(%rdx),%rdx\nmov    %rdx,0x10(%rax)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x20(%rbp)\njmp    21a9 <DeleteLeftMost+0x123>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   2086 <DeleteLeftMost>\nmov    -0x20(%rbp),%rdx\nmov    %rax,(%rdx)\nmov    -0x28(%rbp),%rax\nmovzwl (%rax),%eax\ntest   %ax,%ax\njne    21a9 <DeleteLeftMost+0x123>\nmov    -0x20(%rbp),%rax\nmovzwl 0x20(%rax),%eax\nadd    $0x1,%eax\nmov    %eax,%edx\nmov    -0x20(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\nje     21a9 <DeleteLeftMost+0x123>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1c04 <CheckTreeNodeRotation>\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DoubleLeftRotation", "content": "TreeNode *DoubleLeftRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = SingleRightRotation(rootNode->Right);\n    rootNode->Right = newRoot;\n    newRoot = SingleLeftRotation(rootNode);\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "DoubleLeftRotation", "address": "0x1bbe", "label": "DoubleLeftRotation", "content": "TreeNode *__cdecl DoubleLeftRotation(TreeNode *rootNode)\n{\n  rootNode->Right = SingleRightRotation(rootNode->Right);\n  return SingleLeftRotation(rootNode);\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<DoubleLeftRotation>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   1afa <SingleRightRotation>\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1b3a <SingleLeftRotation>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DoubleRightRotation", "content": "TreeNode *DoubleRightRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = SingleLeftRotation(rootNode->Left);\n    rootNode->Left = newRoot;\n    newRoot = SingleRightRotation(rootNode);\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "DoubleRightRotation", "address": "0x1b7a", "label": "DoubleRightRotation", "content": "TreeNode *__cdecl DoubleRightRotation(TreeNode *rootNode)\n{\n  rootNode->Left = SingleLeftRotation(rootNode->Left);\n  return SingleRightRotation(rootNode);\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<DoubleRightRotation>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   1b3a <SingleLeftRotation>\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1afa <SingleRightRotation>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "FindByElement", "content": "/*\n * A free AVLTree implementation written by Andrew Coleman\n * find out more cool things and licensing at http://penguincoder.org\n */\n#include \"libmin.h\"\n#include \"avlcore.h\"\n\nTreeNode *FindByElement(TreeNode *rootNode, Element Data)\n{\n    short comp;\n    TreeNode *Return;\n    \n    /* sanity checks */\n    if(Data == NULL)\n        return NULL;\n    else if(rootNode == NULL || rootNode->Item == NULL)  {\n        /* reached a leaf, and the data was not found */\n        return NULL;\n    }\n    \n    /* non recursive search because it really isn't neccessary right here */\n    Return = rootNode;\n    do    {\n        comp = Compare(Return->Item, Data);\n        if(comp < 0)\n            Return = Return->Left;\n        else if(comp > 0)\n            Return = Return->Right;\n    } while(Return != NULL && comp != 0);\n    return Return;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "FindByElement", "address": "0x1a46", "label": "FindByElement", "content": "TreeNode *__cdecl FindByElement(TreeNode *rootNode, Element Data)\n{\n  __int16 comp; // [rsp+16h] [rbp-Ah]\n  TreeNode *Return; // [rsp+18h] [rbp-8h]\n\n  if ( !Data )\n    return 0LL;\n  if ( !rootNode || !rootNode->Item )\n    return 0LL;\n  Return = rootNode;\n  do\n  {\n    comp = Compare(Return->Item, Data);\n    if ( comp >= 0 )\n    {\n      if ( comp > 0 )\n        Return = Return->Right;\n    }\n    else\n    {\n      Return = Return->Left;\n    }\n  }\n  while ( Return && comp );\n  return Return;\n}\n"}, "pseudo_normalize": "TreeNode *FindByElement(TreeNode *rootNode, Element Data) {\n  short comp;\n  TreeNode *Return;\n  if (!Data) return 0LL;\n  if (!rootNode || !rootNode->Item) return 0LL;\n  Return = rootNode;\n  do {\n    comp = Compare(Return->Item, Data);\n    if (comp >= 0) {\n      if (comp > 0) Return = Return->Right;\n    } else {\n      Return = Return->Left;\n    }\n  } while (Return && comp);\n  return Return;\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<FindByElement>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\ncmpq   $0x0,-0x20(%rbp)\njne    1a68 <FindByElement+0x22>\nmov    $0x0,%eax\njmp    1adf <FindByElement+0x99>\ncmpq   $0x0,-0x18(%rbp)\nje     1a7c <FindByElement+0x36>\nmov    -0x18(%rbp),%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njne    1a83 <FindByElement+0x3d>\nmov    $0x0,%eax\njmp    1adf <FindByElement+0x99>\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   19e2 <Compare>\nmov    %ax,-0xa(%rbp)\ncmpw   $0x0,-0xa(%rbp)\njns    1aba <FindByElement+0x74>\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\njmp    1acd <FindByElement+0x87>\ncmpw   $0x0,-0xa(%rbp)\njle    1acd <FindByElement+0x87>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     1adb <FindByElement+0x95>\ncmpw   $0x0,-0xa(%rbp)\njne    1a8b <FindByElement+0x45>\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "avl-tree/element.c", "function_name": "FreeElement", "content": "void FreeElement(Element Data)\n{\n    libmin_free(Data);\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "FreeElement", "address": "0x1a27", "label": "FreeElement", "content": "void __cdecl FreeElement(Element Data)\n{\n  libmin_free(Data);\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<FreeElement>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nnop\nleave\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "Height", "content": "long Height(TreeNode *rootNode)\n{\n    /* recursive function to determine the height by comparing the height of\n        the left and right child and returning the larger value */\n    long lresult = 0, rresult = 0;\n    /* either the tree is empty or we found a leaf */\n    if(rootNode == NULL)\n        return 0;\n    lresult = Height(rootNode->Left);\n    rresult = Height(rootNode->Right);\n    /* minimum height is 1, but that's probably correct */\n    return (lresult > rresult ? lresult : rresult) + 1;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "Height", "address": "0x2475", "label": "Height", "content": "__int64 __cdecl Height(TreeNode *rootNode)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rax\n  __int64 lresult; // [rsp+10h] [rbp-10h]\n\n  if ( !rootNode )\n    return 0LL;\n  lresult = Height(rootNode->Left);\n  v2 = Height(rootNode->Right);\n  v3 = lresult;\n  if ( v2 >= lresult )\n    v3 = v2;\n  return v3 + 1;\n}\n"}, "pseudo_normalize": "long long Height(TreeNode *rootNode) {\n  long long v2;\n  long long v3;\n  long long lresult;\n  if (!rootNode) return 0LL;\n  lresult = Height(rootNode->Left);\n  v2 = Height(rootNode->Right);\n  v3 = lresult;\n  if (v2 >= lresult) v3 = v2;\n  return v3 + 1;\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<Height>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovq   $0x0,-0x10(%rbp)\nmovq   $0x0,-0x8(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    24a3 <Height+0x2e>\nmov    $0x0,%eax\njmp    24dd <Height+0x68>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   2475 <Height>\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   2475 <Height>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\ncmp    %rax,%rdx\ncmovge %rdx,%rax\nadd    $0x1,%rax\nleave\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "Insert", "content": "TreeNode *Insert(TreeNode *tnode, Element Item, char *Name)\n{\n    /* flag for the recursive function */\n    short done = 0;\n    /* run and return the recursive insert */\n    return InsertNode(tnode, Item, Name, &done);\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "Insert", "address": "0x1fc4", "label": "Insert", "content": "TreeNode *__cdecl Insert(TreeNode *tnode, Element Item, char *Name)\n{\n  __int16 done; // [rsp+26h] [rbp-Ah] BYREF\n  unsigned __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  done = 0;\n  return InsertNode(tnode, Item, Name, &done);\n}\n"}, "pseudo_normalize": "TreeNode *Insert(TreeNode *tnode, Element Item, char *Name) {\n  short done;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  done = 0;\n  return InsertNode(tnode, Item, Name, &done);\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<Insert>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovw   $0x0,-0xa(%rbp)\nlea    -0xa(%rbp),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rsi\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1e1e <InsertNode>\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     201d <Insert+0x59>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "InsertNode", "content": "TreeNode *InsertNode(TreeNode *tnode, Element Item,\n                     char *Name, short *finished)\n{\n    TreeNode *subtree = NULL;\n    short comp = 0;\n    \n    if(tnode == NULL)    {\n        /* found the spot that the TreeNode belongs */\n        tnode = libmin_malloc(sizeof(TreeNode));\n        /* malloc problem, return NULL */\n        if(tnode == NULL)\n            return NULL;\n        else    {\n            /* default settings for a new node */\n            tnode->Left = NULL;\n            tnode->Right = NULL;\n            tnode->Item = Item;\n            tnode->Name = Name;\n            tnode->Balance = 0;\n        }\n    } else {\n        /* need to find the new node, don't check for a 0,\n           cos its already in teh tree, foo */\n        comp = Compare(Item, tnode->Item);\n        if(comp < 0)    {\n            /* go left */\n            subtree = InsertNode(tnode->Left, Item, Name, finished);\n            /* if this is NULL, there is problem. quit now */\n            if(subtree == NULL)\n                return NULL;\n            /* you are not finished until Balance == 0, reached the root\n                or a rotation has occured */\n            if(!*finished)\n                tnode->Balance--;\n            tnode->Left = subtree;\n        } else if(comp > 0)    {\n            /* go right */\n            subtree = InsertNode(tnode->Right, Item, Name, finished);\n            if(subtree == NULL)\n                return NULL;\n            if(!*finished)\n                tnode->Balance++;\n            tnode->Right = subtree;\n        } else\n            /* got a dupe, return NULL */\n            return NULL;\n\n        /* check if a rotation is neccessary */\n        if(!*finished)  {\n            tnode = CheckTreeNodeRotation(tnode, subtree, finished);\n        }\n    }\n    return tnode;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "InsertNode", "address": "0x1e1e", "label": "InsertNode", "content": "TreeNode *__cdecl InsertNode(TreeNode *tnode, Element Item, char *Name, __int16 *finished)\n{\n  TreeNode *tnodea; // [rsp+18h] [rbp-18h]\n  __int16 comp; // [rsp+26h] [rbp-Ah]\n  TreeNode *subtree; // [rsp+28h] [rbp-8h]\n\n  tnodea = tnode;\n  if ( tnode )\n  {\n    comp = Compare(Item, tnode->Item);\n    if ( comp >= 0 )\n    {\n      if ( comp <= 0 )\n        return 0LL;\n      subtree = InsertNode(tnode->Right, Item, Name, finished);\n      if ( !subtree )\n        return 0LL;\n      if ( !*finished )\n        ++tnode->Balance;\n      tnode->Right = subtree;\n    }\n    else\n    {\n      subtree = InsertNode(tnode->Left, Item, Name, finished);\n      if ( !subtree )\n        return 0LL;\n      if ( !*finished )\n        --tnode->Balance;\n      tnode->Left = subtree;\n    }\n    if ( !*finished )\n      return CheckTreeNodeRotation(tnode, subtree, finished);\n  }\n  else\n  {\n    tnodea = (TreeNode *)libmin_malloc(0x28uLL);\n    if ( !tnodea )\n      return 0LL;\n    tnodea->Left = 0LL;\n    tnodea->Right = 0LL;\n    tnodea->Item = Item;\n    tnodea->Name = Name;\n    tnodea->Balance = 0;\n  }\n  return tnodea;\n}\n"}, "pseudo_normalize": "TreeNode *InsertNode(TreeNode *tnode, Element Item, char *Name,\n                     short *finished) {\n  TreeNode *tnodea;\n  short comp;\n  TreeNode *subtree;\n  tnodea = tnode;\n  if (tnode) {\n    comp = Compare(Item, tnode->Item);\n    if (comp >= 0) {\n      if (comp <= 0) return 0LL;\n      subtree = InsertNode(tnode->Right, Item, Name, finished);\n      if (!subtree) return 0LL;\n      if (!*finished) ++tnode->Balance;\n      tnode->Right = subtree;\n    } else {\n      subtree = InsertNode(tnode->Left, Item, Name, finished);\n      if (!subtree) return 0LL;\n      if (!*finished) --tnode->Balance;\n      tnode->Left = subtree;\n    }\n    if (!*finished) return CheckTreeNodeRotation(tnode, subtree, finished);\n  } else {\n    tnodea = (TreeNode *)libmin_malloc(40uLL);\n    if (!tnodea) return 0LL;\n    tnodea->Left = 0LL;\n    tnodea->Right = 0LL;\n    tnodea->Item = Item;\n    tnodea->Name = Name;\n    tnodea->Balance = 0;\n  }\n  return tnodea;\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<InsertNode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmovw   $0x0,-0xa(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1eac <InsertNode+0x8e>\nmov    $0x28,%edi\ncall   2672 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1e6e <InsertNode+0x50>\nmov    $0x0,%eax\njmp    1fc2 <InsertNode+0x1a4>\nmov    -0x18(%rbp),%rax\nmovq   $0x0,(%rax)\nmov    -0x18(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rdx,0x10(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rdx,0x18(%rax)\nmov    -0x18(%rbp),%rax\nmovw   $0x0,0x20(%rax)\njmp    1fbe <InsertNode+0x1a0>\nmov    -0x18(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   19e2 <Compare>\nmov    %ax,-0xa(%rbp)\ncmpw   $0x0,-0xa(%rbp)\njns    1f2c <InsertNode+0x10e>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rsi\nmov    %rax,%rdi\ncall   1e1e <InsertNode>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    1efe <InsertNode+0xe0>\nmov    $0x0,%eax\njmp    1fc2 <InsertNode+0x1a4>\nmov    -0x30(%rbp),%rax\nmovzwl (%rax),%eax\ntest   %ax,%ax\njne    1f1f <InsertNode+0x101>\nmov    -0x18(%rbp),%rax\nmovzwl 0x20(%rax),%eax\nsub    $0x1,%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\njmp    1f97 <InsertNode+0x179>\ncmpw   $0x0,-0xa(%rbp)\njle    1f90 <InsertNode+0x172>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rsi\nmov    %rax,%rdi\ncall   1e1e <InsertNode>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    1f61 <InsertNode+0x143>\nmov    $0x0,%eax\njmp    1fc2 <InsertNode+0x1a4>\nmov    -0x30(%rbp),%rax\nmovzwl (%rax),%eax\ntest   %ax,%ax\njne    1f82 <InsertNode+0x164>\nmov    -0x18(%rbp),%rax\nmovzwl 0x20(%rax),%eax\nadd    $0x1,%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %dx,0x20(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x8(%rax)\njmp    1f97 <InsertNode+0x179>\nmov    $0x0,%eax\njmp    1fc2 <InsertNode+0x1a4>\nmov    -0x30(%rbp),%rax\nmovzwl (%rax),%eax\ntest   %ax,%ax\njne    1fbe <InsertNode+0x1a0>\nmov    -0x30(%rbp),%rdx\nmov    -0x8(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1c04 <CheckTreeNodeRotation>\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "IsEmpty", "content": "short IsEmpty(TreeNode *rootNode)\n{\n    return (rootNode == NULL);\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "IsEmpty", "address": "0x1ae1", "label": "IsEmpty", "content": "__int16 __cdecl IsEmpty(TreeNode *rootNode)\n{\n  return rootNode == 0LL;\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<IsEmpty>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nsete   %al\nmovzbl %al,%eax\npop    %rbp\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "MakeEmpty", "content": "void MakeEmpty(TreeNode *rootNode)\n{\n    /* this function is pretty simple, just traverses the tree and starts\n        free'ing from the bottom up */\n    if(rootNode == NULL)\n        return;\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "MakeEmpty", "address": "0x201f", "label": "MakeEmpty", "content": "void __cdecl MakeEmpty(TreeNode *rootNode)\n{\n  if ( rootNode )\n  {\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}\n"}, "pseudo_normalize": "void MakeEmpty(TreeNode *rootNode) {\n  if (rootNode) {\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<MakeEmpty>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     2083 <MakeEmpty+0x64>\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   201f <MakeEmpty>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   201f <MakeEmpty>\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    %rax,%rdi\ncall   1a27 <FreeElement>\nmov    -0x8(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\njmp    2084 <MakeEmpty+0x65>\nnop\nleave\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "SingleLeftRotation", "content": "TreeNode *SingleLeftRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = NULL;\n    newRoot = rootNode->Right;\n    rootNode->Right = newRoot->Left;\n    newRoot->Left = rootNode;\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "SingleLeftRotation", "address": "0x1b3a", "label": "SingleLeftRotation", "content": "TreeNode *__cdecl SingleLeftRotation(TreeNode *rootNode)\n{\n  TreeNodeTag *newRoot; // [rsp+10h] [rbp-8h]\n\n  newRoot = rootNode->Right;\n  rootNode->Right = newRoot->Left;\n  newRoot->Left = rootNode;\n  return newRoot;\n}\n"}, "pseudo_normalize": "TreeNode *SingleLeftRotation(TreeNode *rootNode) {\n  TreeNodeTag *newRoot;\n  newRoot = rootNode->Right;\n  rootNode->Right = newRoot->Left;\n  newRoot->Left = rootNode;\n  return newRoot;\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<SingleLeftRotation>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "SingleRightRotation", "content": "TreeNode *SingleRightRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = NULL;\n    newRoot = rootNode->Left;\n    rootNode->Left = newRoot->Right;\n    newRoot->Right = rootNode;\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "SingleRightRotation", "address": "0x1afa", "label": "SingleRightRotation", "content": "TreeNode *__cdecl SingleRightRotation(TreeNode *rootNode)\n{\n  TreeNode *newRoot; // [rsp+10h] [rbp-8h]\n\n  newRoot = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  newRoot->Right = rootNode;\n  return newRoot;\n}\n"}, "pseudo_normalize": "TreeNode *SingleRightRotation(TreeNode *rootNode) {\n  TreeNode *newRoot;\n  newRoot = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  newRoot->Right = rootNode;\n  return newRoot;\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<SingleRightRotation>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n"}
{"source": {"path": "avl-tree/avl-tree.c", "function_name": "breadth", "content": "long breadth(TreeNode *start)\n{\n    if(start == NULL)\n        return (long)0;\n    if(start->Left == NULL && start->Right == NULL)\n        return (long)1;\n    return (long)(breadth(start->Left) + breadth(start->Right));\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "breadth", "address": "0x132f", "label": "breadth", "content": "__int64 __cdecl breadth(TreeNode *start)\n{\n  __int64 v2; // rbx\n\n  if ( !start )\n    return 0LL;\n  if ( !start->Left && !start->Right )\n    return 1LL;\n  v2 = breadth(start->Left);\n  return v2 + breadth(start->Right);\n}\n"}, "pseudo_normalize": "long long breadth(TreeNode *start) {\n  long long v2;\n  if (!start) return 0LL;\n  if (!start->Left && !start->Right) return 1LL;\n  v2 = breadth(start->Left);\n  return v2 + breadth(start->Right);\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<breadth>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    134e <breadth+0x1f>\nmov    $0x0,%eax\njmp    1393 <breadth+0x64>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    136e <breadth+0x3f>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    136e <breadth+0x3f>\nmov    $0x1,%eax\njmp    1393 <breadth+0x64>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   132f <breadth>\nmov    %rax,%rbx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   132f <breadth>\nadd    %rbx,%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "avl-tree/avl-tree.c", "function_name": "main", "content": "int main(int argc, char** argv)\n{\n    TreeNode *tree = NULL, *newTree = NULL;\n    Element newItem = NULL;\n    char *itemName = NULL;\n    long i = 0, topsize = 0, tick = 0, last = 0;\n    long height = 0, oldheight = 0;\n    \n    /* get the command argument, used for a custom size parameter */\n    topsize = 25;\n    tick = topsize / 20;\n    \n    libmin_srand(42);\n    libmin_printf(\"Start  -->  Finished\\n\");\n    for(i = 0; i < topsize; i++) {\n        newItem = libmin_malloc(sizeof(Element));\n        itemName = libmin_malloc(sizeof(char) * 11);\n        libmin_snprintf(itemName, 11, \"Name%ld\", i);\n        do  {\n            *newItem = libmin_rand();\n            newTree = Insert(tree, newItem, itemName);\n            if(newTree == NULL) {\n                if(last == *newItem)    {\n                    libmin_free(itemName);\n                    libmin_free(newItem);\n                    libmin_printf(\"going to try and skip: %ld\\n\", *newItem);\n                    break;\n                } else\n                    last = *newItem;\n            }\n        } while(newTree == NULL);\n        if(i % tick == 0)   {\n            libmin_printf(\".\");\n        }\n        tree = newTree;\n    }\n    libmin_printf(\"\\n\");\n    \n    /* test out the delete functionality */\n    libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *tree->Item);\n    newTree = DeleteByElement(tree, tree->Item);\n    if(newTree == NULL)\n        libmin_printf(\"failure!\\n\");\n    else {\n        tree = newTree;\n        libmin_printf(\"success! new root is %ld\\n\", *tree->Item);\n    }\n    libmin_printf(\"\\nGoing to delete leftMost child... \");\n    for(newTree = tree;\n        newTree != NULL && newTree->Left != NULL;\n        newTree = newTree->Left)    {}\n    if(newTree != NULL) {\n        libmin_printf(\"found item: %ld\\n\", *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n    }\n    /* duplicated from left side */\n    libmin_printf(\"\\nGoing to delete rightMost child... \");\n    for(newTree = tree;\n        newTree != NULL && newTree->Right != NULL;\n        newTree = newTree->Right)   {}\n    if(newTree != NULL) {\n        libmin_printf(\"found item: %ld\\n\", *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n    }\n    libmin_printf(\"\\n\");\n\t\n    if(topsize <= 25)\n        printTree(tree, 0);\n    libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\",\n           breadth(tree->Left), breadth(tree->Right));\n    oldheight = Height(tree->Left);\n    libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\",\n           oldheight, Height(tree->Right));\n\n    last = (long)(INT_MAX / 2);\n    for(i = 0; i < 3; i++)  {\n        libmin_printf(\"\\n\");\n        height = libmin_rand() % oldheight;\n        libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\",\n                oldheight, height);\n        newTree = tree;\n        do  {\n            if(newTree->Left == NULL)   {\n                if(newTree->Right == NULL)\n                    break;\n                tick = last + 1;\n            } else if(newTree->Right == NULL)\n                tick = last - 1;\n            else\n                tick = libmin_rand();\n            newTree = (tick >= last ? newTree->Right : newTree->Left);\n            height--;\n        } while(height > 0);\n        libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                newTree->Name, *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n        oldheight = (int)(oldheight * 0.6);\n    }\n    \n    MakeEmpty(tree);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "main", "address": "0x1399", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  __int64 v4; // rax\n  __int64 v5; // rax\n  TreeNode *Left; // rax\n  TreeNode *tree; // [rsp+10h] [rbp-60h]\n  TreeNode *newTree; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreea; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreeb; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreec; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreed; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreee; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreef; // [rsp+18h] [rbp-58h]\n  TreeNode *newTreeg; // [rsp+18h] [rbp-58h]\n  __int64 i; // [rsp+20h] [rbp-50h]\n  __int64 ia; // [rsp+20h] [rbp-50h]\n  __int64 tick; // [rsp+28h] [rbp-48h]\n  __int64 last; // [rsp+30h] [rbp-40h]\n  __int64 height; // [rsp+38h] [rbp-38h]\n  __int64 oldheight; // [rsp+40h] [rbp-30h]\n  Element newItem; // [rsp+48h] [rbp-28h]\n  char *itemName; // [rsp+50h] [rbp-20h]\n\n  tree = 0LL;\n  last = 0LL;\n  libmin_srand(0x2Au);\n  libmin_printf(\"Start  -->  Finished\\n\");\n  for ( i = 0LL; ; ++i )\n  {\n    if ( i >= 25 )\n    {\n      libmin_printf(\"\\n\");\n      libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *(unsigned int *)tree->Item);\n      newTreea = DeleteByElement(tree, tree->Item);\n      if ( newTreea )\n      {\n        tree = newTreea;\n        libmin_printf(\"success! new root is %ld\\n\", *(unsigned int *)newTreea->Item);\n      }\n      else\n      {\n        libmin_printf(\"failure!\\n\");\n      }\n      libmin_printf(\"\\nGoing to delete leftMost child... \");\n      for ( newTreeb = tree; newTreeb && newTreeb->Left; newTreeb = newTreeb->Left )\n        ;\n      if ( newTreeb )\n      {\n        libmin_printf(\"found item: %ld\\n\", *(unsigned int *)newTreeb->Item);\n        newTreec = DeleteByElement(tree, newTreeb->Item);\n        if ( newTreec )\n        {\n          libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)newTreec->Item);\n          tree = newTreec;\n        }\n        else\n        {\n          libmin_printf(\"failure!\\n\");\n        }\n      }\n      libmin_printf(\"\\nGoing to delete rightMost child... \");\n      for ( newTreed = tree; newTreed && newTreed->Right; newTreed = newTreed->Right )\n        ;\n      if ( newTreed )\n      {\n        libmin_printf(\"found item: %ld\\n\", *(unsigned int *)newTreed->Item);\n        newTreee = DeleteByElement(tree, newTreed->Item);\n        if ( newTreee )\n        {\n          libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)newTreee->Item);\n          tree = newTreee;\n        }\n        else\n        {\n          libmin_printf(\"failure!\\n\");\n        }\n      }\n      libmin_printf(\"\\n\");\n      printTree(tree, 0LL);\n      v3 = breadth(tree->Right);\n      v4 = breadth(tree->Left);\n      libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v4, v3);\n      oldheight = Height(tree->Left);\n      v5 = Height(tree->Right);\n      libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", oldheight, v5);\n      for ( ia = 0LL; ; ++ia )\n      {\n        if ( ia > 2 )\n        {\n          MakeEmpty(tree);\n          libmin_success();\n        }\n        libmin_printf(\"\\n\");\n        height = libmin_rand() % oldheight;\n        libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\", oldheight, height);\n        newTreef = tree;\n        do\n        {\n          if ( newTreef->Left )\n          {\n            if ( newTreef->Right )\n              tick = libmin_rand();\n            else\n              tick = 1073741822LL;\n          }\n          else\n          {\n            if ( !newTreef->Right )\n              break;\n            tick = 0x40000000LL;\n          }\n          if ( tick < 0x3FFFFFFF )\n            Left = newTreef->Left;\n          else\n            Left = newTreef->Right;\n          newTreef = Left;\n          --height;\n        }\n        while ( height > 0 );\n        libmin_printf(\n          \"Found a node to delete with Name '%s' and Item %ld\\n\",\n          newTreef->Name,\n          *(unsigned int *)newTreef->Item);\n        newTreeg = DeleteByElement(tree, newTreef->Item);\n        if ( newTreeg )\n        {\n          libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)newTreeg->Item);\n          tree = newTreeg;\n        }\n        else\n        {\n          libmin_printf(\"failure!\\n\");\n        }\n        oldheight = (int)(0.6 * (double)(int)oldheight);\n      }\n    }\n    newItem = (Element)libmin_malloc(8uLL);\n    itemName = (char *)libmin_malloc(0xBuLL);\n    libmin_snprintf(itemName, 0xBuLL, \"Name%ld\", i);\n    while ( 1 )\n    {\n      *newItem = libmin_rand();\n      newTree = Insert(tree, newItem, itemName);\n      if ( !newTree )\n        break;\nLABEL_7:\n      if ( newTree )\n        goto LABEL_8;\n    }\n    if ( last != *newItem )\n      break;\n    libmin_free(itemName);\n    libmin_free(newItem);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*newItem);\nLABEL_8:\n    if ( !(i % ((__int64)((unsigned __int128)(0x6666666666666667LL * (__int128)25LL) >> 64) >> 3)) )\n      libmin_printf(\".\");\n    tree = newTree;\n  }\n  last = *newItem;\n  goto LABEL_7;\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  TreeNode *Left;\n  TreeNode *tree;\n  TreeNode *newTree;\n  TreeNode *newTreea;\n  TreeNode *newTreeb;\n  TreeNode *newTreec;\n  TreeNode *newTreed;\n  TreeNode *newTreee;\n  TreeNode *newTreef;\n  TreeNode *newTreeg;\n  long long i;\n  long long ia;\n  long long tick;\n  long long last;\n  long long height;\n  long long oldheight;\n  Element newItem;\n  char *itemName;\n  tree = 0LL;\n  last = 0LL;\n  libmin_srand(42u);\n  libmin_printf(\"Start  -->  Finished\\n\");\n  for (i = 0LL;; ++i) {\n    if (i >= 25) {\n      libmin_printf(\"\\n\");\n      libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\",\n                    *(unsigned int *)tree->Item);\n      newTreea = DeleteByElement(tree, tree->Item);\n      if (newTreea) {\n        tree = newTreea;\n        libmin_printf(\"success! new root is %ld\\n\",\n                      *(unsigned int *)newTreea->Item);\n      } else {\n        libmin_printf(\"failure!\\n\");\n      }\n      libmin_printf(\"\\nGoing to delete leftMost child... \");\n      for (newTreeb = tree; newTreeb && newTreeb->Left;\n           newTreeb = newTreeb->Left)\n        ;\n      if (newTreeb) {\n        libmin_printf(\"found item: %ld\\n\", *(unsigned int *)newTreeb->Item);\n        newTreec = DeleteByElement(tree, newTreeb->Item);\n        if (newTreec) {\n          libmin_printf(\"success! new root: %ld\\n\",\n                        *(unsigned int *)newTreec->Item);\n          tree = newTreec;\n        } else {\n          libmin_printf(\"failure!\\n\");\n        }\n      }\n      libmin_printf(\"\\nGoing to delete rightMost child... \");\n      for (newTreed = tree; newTreed && newTreed->Right;\n           newTreed = newTreed->Right)\n        ;\n      if (newTreed) {\n        libmin_printf(\"found item: %ld\\n\", *(unsigned int *)newTreed->Item);\n        newTreee = DeleteByElement(tree, newTreed->Item);\n        if (newTreee) {\n          libmin_printf(\"success! new root: %ld\\n\",\n                        *(unsigned int *)newTreee->Item);\n          tree = newTreee;\n        } else {\n          libmin_printf(\"failure!\\n\");\n        }\n      }\n      libmin_printf(\"\\n\");\n      printTree(tree, 0LL);\n      v3 = breadth(tree->Right);\n      v4 = breadth(tree->Left);\n      libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v4, v3);\n      oldheight = Height(tree->Left);\n      v5 = Height(tree->Right);\n      libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\",\n                    oldheight, v5);\n      for (ia = 0LL;; ++ia) {\n        if (ia > 2) {\n          MakeEmpty(tree);\n          libmin_success();\n        }\n        libmin_printf(\"\\n\");\n        height = libmin_rand() % oldheight;\n        libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\",\n                      oldheight, height);\n        newTreef = tree;\n        do {\n          if (newTreef->Left) {\n            if (newTreef->Right)\n              tick = libmin_rand();\n            else\n              tick = 1073741822LL;\n          } else {\n            if (!newTreef->Right) break;\n            tick = 1073741824LL;\n          }\n          if (tick < 1073741823)\n            Left = newTreef->Left;\n          else\n            Left = newTreef->Right;\n          newTreef = Left;\n          --height;\n        } while (height > 0);\n        libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                      newTreef->Name, *(unsigned int *)newTreef->Item);\n        newTreeg = DeleteByElement(tree, newTreef->Item);\n        if (newTreeg) {\n          libmin_printf(\"success! new root: %ld\\n\",\n                        *(unsigned int *)newTreeg->Item);\n          tree = newTreeg;\n        } else {\n          libmin_printf(\"failure!\\n\");\n        }\n        oldheight = (int)(0.6 * (double)(int)oldheight);\n      }\n    }\n    newItem = (Element)libmin_malloc(8uLL);\n    itemName = (char *)libmin_malloc(11uLL);\n    libmin_snprintf(itemName, 11uLL, \"Name%ld\", i);\n    while (1) {\n      *newItem = libmin_rand();\n      newTree = Insert(tree, newItem, itemName);\n      if (!newTree) break;\n    LABEL_7:\n      if (newTree) goto LABEL_8;\n    }\n    if (last != *newItem) break;\n    libmin_free(itemName);\n    libmin_free(newItem);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*newItem);\n  LABEL_8:\n    if (!(i % ((long long)((unsigned __int128)(7378697629483820647LL *\n                                               (__int128)25LL) >>\n                           64) >>\n               3)))\n      libmin_printf(\".\");\n    tree = newTree;\n  }\n  last = *newItem;\n  goto LABEL_7;\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %edi,-0x64(%rbp)\nmov    %rsi,-0x70(%rbp)\nmovq   $0x0,-0x60(%rbp)\nmovq   $0x0,-0x58(%rbp)\nmovq   $0x0,-0x28(%rbp)\nmovq   $0x0,-0x20(%rbp)\nmovq   $0x0,-0x50(%rbp)\nmovq   $0x0,-0x18(%rbp)\nmovq   $0x0,-0x48(%rbp)\nmovq   $0x0,-0x40(%rbp)\nmovq   $0x0,-0x38(%rbp)\nmovq   $0x0,-0x30(%rbp)\nmovq   $0x19,-0x18(%rbp)\nmov    -0x18(%rbp),%rcx\nmovabs $0x6666666666666667,%rdx\nmov    %rcx,%rax\nimul   %rdx\nmov    %rdx,%rax\nsar    $0x3,%rax\nsar    $0x3f,%rcx\nmov    %rcx,%rdx\nsub    %rdx,%rax\nmov    %rax,-0x48(%rbp)\nmov    $0x2a,%edi\ncall   4d03 <libmin_srand>\nlea    0x4bf3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmovq   $0x0,-0x50(%rbp)\njmp    1556 <main+0x1bd>\nmov    $0x8,%edi\ncall   2672 <libmin_malloc>\nmov    %rax,-0x28(%rbp)\nmov    $0xb,%edi\ncall   2672 <libmin_malloc>\nmov    %rax,-0x20(%rbp)\nmov    -0x50(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rcx\nlea    0x4bc1(%rip),%rdx\nmov    $0xb,%esi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4c03 <libmin_snprintf>\ncall   4db5 <libmin_rand>\nmov    %eax,%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rdx\nmov    -0x28(%rbp),%rcx\nmov    -0x60(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1fc4 <Insert>\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\njne    1518 <main+0x17f>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\ncltq\ncmp    %rax,-0x40(%rbp)\njne    150c <main+0x173>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   275d <libmin_free>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x4b53(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\njmp    1523 <main+0x18a>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\ncltq\nmov    %rax,-0x40(%rbp)\ncmpq   $0x0,-0x58(%rbp)\nje     1499 <main+0x100>\nmov    -0x50(%rbp),%rax\ncqto\nidivq  -0x48(%rbp)\nmov    %rdx,%rax\ntest   %rax,%rax\njne    1549 <main+0x1b0>\nlea    0x4b30(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x60(%rbp)\naddq   $0x1,-0x50(%rbp)\nmov    -0x50(%rbp),%rax\ncmp    -0x18(%rbp),%rax\njl     1459 <main+0xc0>\nlea    0x4abd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x60(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x4ae5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x60(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x60(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   240f <DeleteByElement>\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\njne    15d0 <main+0x237>\nlea    0x4ad3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\njmp    15f8 <main+0x25f>\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x4ab3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nlea    0x4ab9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x60(%rbp),%rax\nmov    %rax,-0x58(%rbp)\njmp    1621 <main+0x288>\nmov    -0x58(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\nje     1634 <main+0x29b>\nmov    -0x58(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    1616 <main+0x27d>\ncmpq   $0x0,-0x58(%rbp)\nje     16bf <main+0x326>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x4a8a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x60(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   240f <DeleteByElement>\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\njne    1697 <main+0x2fe>\nlea    0x4a0c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\njmp    16bf <main+0x326>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x4a43(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x60(%rbp)\nlea    0x4a42(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x60(%rbp),%rax\nmov    %rax,-0x58(%rbp)\njmp    16e9 <main+0x350>\nmov    -0x58(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\nje     16fd <main+0x364>\nmov    -0x58(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    16dd <main+0x344>\ncmpq   $0x0,-0x58(%rbp)\nje     1788 <main+0x3ef>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x49c1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x60(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   240f <DeleteByElement>\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\njne    1760 <main+0x3c7>\nlea    0x4943(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\njmp    1788 <main+0x3ef>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x497a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x60(%rbp)\nlea    0x4899(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\ncmpq   $0x19,-0x18(%rbp)\njg     17b4 <main+0x41b>\nmov    -0x60(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   11e9 <printTree>\nmov    -0x60(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   132f <breadth>\nmov    %rax,%rbx\nmov    -0x60(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   132f <breadth>\nmov    %rbx,%rdx\nmov    %rax,%rsi\nlea    0x494d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x60(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   2475 <Height>\nmov    %rax,-0x30(%rbp)\nmov    -0x60(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   2475 <Height>\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nlea    0x493c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmovq   $0x3fffffff,-0x40(%rbp)\nmovq   $0x0,-0x50(%rbp)\njmp    19bb <main+0x622>\nlea    0x47db(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\ncall   4db5 <libmin_rand>\nmov    %eax,%eax\ncqto\nidivq  -0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nlea    0x4913(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x60(%rbp),%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x58(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    18b9 <main+0x520>\nmov    -0x58(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\nje     190c <main+0x573>\nmov    -0x40(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x48(%rbp)\njmp    18df <main+0x546>\nmov    -0x58(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    18d4 <main+0x53b>\nmov    -0x40(%rbp),%rax\nsub    $0x1,%rax\nmov    %rax,-0x48(%rbp)\njmp    18df <main+0x546>\ncall   4db5 <libmin_rand>\nmov    %eax,%eax\nmov    %rax,-0x48(%rbp)\nmov    -0x48(%rbp),%rax\ncmp    -0x40(%rbp),%rax\njl     18f3 <main+0x55a>\nmov    -0x58(%rbp),%rax\nmov    0x8(%rax),%rax\njmp    18fa <main+0x561>\nmov    -0x58(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x58(%rbp)\nsubq   $0x1,-0x38(%rbp)\ncmpq   $0x0,-0x38(%rbp)\njg     1892 <main+0x4f9>\njmp    190d <main+0x574>\nnop\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%edx\nmov    -0x58(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,%rsi\nlea    0x489f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x60(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   240f <DeleteByElement>\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\njne    196e <main+0x5d5>\nlea    0x4735(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\njmp    1996 <main+0x5fd>\nmov    -0x58(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x476c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x60(%rbp)\npxor   %xmm1,%xmm1\ncvtsi2sdq -0x30(%rbp),%xmm1\nmovsd  0x4858(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ncvttsd2si %xmm0,%eax\ncltq\nmov    %rax,-0x30(%rbp)\naddq   $0x1,-0x50(%rbp)\ncmpq   $0x2,-0x50(%rbp)\njle    1846 <main+0x4ad>\nmov    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   201f <MakeEmpty>\ncall   506c <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "avl-tree/avl-tree.c", "function_name": "printTree", "content": "/* A balanced binary search tree(AVLTree) implementation\n * Written by Coleman\n * Released under GNU GPL Version 2 or later(http://www.gnu.org/)\n */\n#include \"libmin.h\"\n#include \"element.h\"\n#include \"avlcore.h\"\n\n#define MAXELEMENTSIZE 500000\n\nvoid printTree(TreeNode *start, long level)\n{\n    long i = 0;\n    if(start == NULL)\n        return;\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name,\n\t\t\t\t*start->Item, start->Balance);\n    for(i = 0; i < level; i++)\n        libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(start->Left, level + 1);\n    libmin_printf(\"\\n\");\n    for(i = 0; i < level; i++)\n        libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(start->Right, level + 1);\n    if(level == 0)\n        libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O0.pseudo", "function_name": "printTree", "address": "0x11e9", "label": "printTree", "content": "void __cdecl printTree(TreeNode *start, __int64 level)\n{\n  __int64 i; // [rsp+18h] [rbp-8h]\n  __int64 ia; // [rsp+18h] [rbp-8h]\n\n  if ( start )\n  {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name, *(unsigned int *)start->Item, start->Balance);\n    for ( i = 0LL; i < level; ++i )\n      libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(start->Left, level + 1);\n    libmin_printf(\"\\n\");\n    for ( ia = 0LL; ia < level; ++ia )\n      libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(start->Right, level + 1);\n    if ( !level )\n      libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo_normalize": "void printTree(TreeNode *start, long long level) {\n  long long i;\n  long long ia;\n  if (start) {\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name,\n                  *(unsigned int *)start->Item, start->Balance);\n    for (i = 0LL; i < level; ++i) libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(start->Left, level + 1);\n    libmin_printf(\"\\n\");\n    for (ia = 0LL; ia < level; ++ia) libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(start->Right, level + 1);\n    if (!level) libmin_printf(\"\\n\");\n  }\n}", "binary": "avl-tree/avl-tree.host.O0", "assembly": "<printTree>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x0,-0x8(%rbp)\ncmpq   $0x0,-0x18(%rbp)\nje     132c <printTree+0x143>\nmov    -0x18(%rbp),%rax\nmovzwl 0x20(%rax),%eax\nmovswl %ax,%ecx\nmov    -0x18(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,%rsi\nlea    0x4dd1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmovq   $0x0,-0x8(%rbp)\njmp    1267 <printTree+0x7e>\nlea    0x4dca(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njl     124e <printTree+0x65>\nlea    0x4da9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <printTree>\nlea    0x4d82(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmovq   $0x0,-0x8(%rbp)\njmp    12d6 <printTree+0xed>\nlea    0x4d5b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njl     12bd <printTree+0xd4>\nlea    0x4d43(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <printTree>\ncmpq   $0x0,-0x20(%rbp)\njne    132d <printTree+0x144>\nlea    0x4d0b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4ad4 <libmin_printf>\njmp    132d <printTree+0x144>\nnop\nleave\nret\n"}
{"source": {"path": "banner/banner.c", "function_name": "main", "content": "int\nmain(void)\n{ \n\tint ch;\n\n\twhile ((ch = libmin_getopt(argc, argv, \"w:tdh\")) != -1)\n\t\tswitch (ch) {\n\t\tcase 'd':\n\t\t\tdebug = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twidth = libmin_atoi(optarg);\n\t\t\tif (width <= 0)\n\t\t\t\tlibmin_printf(\"error: illegal argument for -w option\\n\");\n\t\t\tbreak;\n\t\tcase '?': case 'h':\n\t\tdefault:\n\t\t\tlibmin_printf(\"usage: banner [-w width]\\n\");\n\t\t\tlibmin_fail(1);\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tfor (i = 0; i < width; i++) {\n\t\tj = i * 132 / width;\n\t\tprint[j] = 1;\n\t}\n\n\t/* Have now read in the data. Next get the message to be printed. */\n\tif (*argv) {\n\t\tlibmin_strncpy(message, *argv, sizeof message);\n\t\twhile (*++argv) {\n\t\t\tlibmin_strncat(message, \" \", sizeof message);\n\t\t\tlibmin_strncat(message, *argv, sizeof message);\n\t\t}\n\t\tnchars = libmin_strlen(message);\n\t} else {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n\t}\n\n\t/* some debugging print statements */\n\tif (debug) {\n\t\tlibmin_printf(\"int asc_ptr[128] = {\\n\");\n\t\tfor (i = 0; i < 128; i++) {\n\t\t\tlibmin_printf(\"%4d,   \",asc_ptr[i]);\n\t\t\tif ((i+1) % 8 == 0)\n\t\t\t\tlibmin_printf(\"\\n\");\n\t\t}\n\t\tlibmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n\t\tlibmin_printf(\"  /*   \");\n\t\tfor (i = 0; i < 10; i++) libmin_printf(\" %3d  \",i);\n\t\tlibmin_printf(\"   */\\n\");\n\t\tfor (i = 0; i < NBYTES; i += 10) {\n\t\t\tlibmin_printf(\"/* %4d */  \",i);\n\t\t\tfor (j = i; j < i+10; j++) { \n\t\t\t\tx = data_table[j] & 0377;\n\t\t\t\tlibmin_printf(\" %3d, \",x);\n\t\t\t}\n\t\t\tlibmin_putc('\\n');\n\t\t}\n\t\tlibmin_printf(\"};\\n\");\n\t}\n\n\t/* check message to make sure it's legal */\n\tj = 0;\n\tfor (i = 0; i < nchars; i++)\n\t\tif ((uint8_t) message[i] >= NCHARS ||\n\t\t    asc_ptr[(uint8_t) message[i]] == 0) {\n\t\t\tlibmin_printf(\"The character is not in my character set\\n\");\n\t\t\tj++;\n\t\t}\n\tif (j)\n\t\tlibmin_fail(1);\n\n\t/* Now have message. Print it one character at a time.  */\n\n\tfor (i = 0; i < nchars; i++) {\n\t\tfor (j = 0; j < DWIDTH; j++) line[j] = ' ';\n\t\tpc = asc_ptr[(uint8_t) message[i]];\n\t\tterm = 0;\n\t\tmax = 0;\n\t\tlinen = 0;\n\t\twhile (!term) {\n\t\t\tif (pc < 0 || pc >= NBYTES) {\n\t\t\t\tlibmin_printf(\"bad pc: %d\\n\",pc);\n\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\t\tx = data_table[pc] & 0377;\n\t\t\tif (x >= 128) {\n\t\t\t\tif (x>192) term++;\n\t\t\t\tx = x & 63;\n\t\t\t\twhile (x--) {\n\t\t\t\t\tif (print[linen++]) {\n\t\t\t\t\t\tfor (j=0; j <= max; j++)\n\t\t\t\t\t\t\tif (print[j])\n\t\t\t\t\t\t\t\tlibmin_putc(line[j]);\n\t\t\t\t\t\tlibmin_putc('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < DWIDTH; j++) line[j] = ' ';\n\t\t\t\tpc++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty = data_table[pc+1];\n\t\t\t\t/* compensate for narrow teminals */\n#ifdef notdef\n\t\t\t\tx = (x*width + (DWIDTH/2)) / DWIDTH;\n\t\t\t\ty = (y*width + (DWIDTH/2)) / DWIDTH;\n#endif\n\t\t\t\tmax = x+y;\n\t\t\t\twhile (x < max) line[x++] = '#';\n\t\t\t\tpc += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tlibmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "banner/banner.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int v5; // eax\n  int ch_0; // [rsp+Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    ch_0 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if ( ch_0 == -1 )\n      break;\n    if ( ch_0 == 100 )\n    {\n      debug = 1;\n    }\n    else\n    {\n      if ( ch_0 != 119 )\n      {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if ( width <= 0 )\n        libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  ::argc -= optind;\n  ::argv += optind;\n  for ( i = 0; i < width; ++i )\n  {\n    j = 132 * i / width;\n    print[132 * i / width] = 1;\n  }\n  if ( *::argv )\n  {\n    libmin_strncpy(message, *::argv, 0x400uLL);\n    while ( *++::argv )\n    {\n      libmin_strncat(message, \" \", 0x400uLL);\n      libmin_strncat(message, *::argv, 0x400uLL);\n    }\n    nchars = libmin_strlen(message);\n    if ( debug )\n    {\n      libmin_printf(\"int asc_ptr[128] = {\\n\");\n      for ( i = 0; i <= 127; ++i )\n      {\n        libmin_printf(\"%4d,   \", asc_ptr[i]);\n        if ( (((_BYTE)i + 1) & 7) == 0 )\n          libmin_printf(\"\\n\");\n      }\n      libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n      libmin_printf(\"  /*   \");\n      for ( i = 0; i <= 9; ++i )\n        libmin_printf(\" %3d  \", i);\n      libmin_printf(\"   */\\n\");\n      for ( i = 0; i <= 9270; i += 10 )\n      {\n        libmin_printf(\"/* %4d */  \", i);\n        for ( j = i; i + 9 >= j; ++j )\n        {\n          x = (unsigned __int8)data_table[j];\n          libmin_printf(\" %3d, \", x);\n        }\n        libmin_putc(10);\n      }\n      libmin_printf(\"};\\n\");\n    }\n    j = 0;\n    for ( i = 0; i < nchars; ++i )\n    {\n      if ( message[i] < 0 || !asc_ptr[(unsigned __int8)message[i]] )\n      {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++j;\n      }\n    }\n    if ( j )\n      libmin_fail(1);\n    for ( i = 0; i < nchars; ++i )\n    {\n      for ( j = 0; j <= 131; ++j )\n        line[j] = 32;\n      pc = asc_ptr[(unsigned __int8)message[i]];\n      term = 0;\n      max = 0;\n      linen = 0;\n      while ( !term )\n      {\n        if ( (unsigned int)pc > 0x2436 )\n        {\n          libmin_printf(\"bad pc: %d\\n\", pc);\n          libmin_fail(1);\n        }\n        x = (unsigned __int8)data_table[pc];\n        if ( x <= 127 )\n        {\n          y = data_table[pc + 1];\n          max = x + y;\n          while ( x < max )\n          {\n            v5 = x++;\n            line[v5] = 35;\n          }\n          pc += 2;\n        }\n        else\n        {\n          if ( x > 192 )\n            ++term;\n          x &= 0x3Fu;\n          while ( x-- )\n          {\n            v3 = linen++;\n            if ( print[v3] )\n            {\n              for ( j = 0; j <= max; ++j )\n              {\n                if ( print[j] )\n                  libmin_putc(line[j]);\n              }\n              libmin_putc(10);\n            }\n          }\n          for ( j = 0; j <= 131; ++j )\n            line[j] = 32;\n          ++pc;\n        }\n      }\n    }\n    libmin_success();\n  }\n  libmin_printf(\"No message to print.\\n\");\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v5;\n  int ch_0;\n  while (1) {\n    ch_0 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if (ch_0 == -1) break;\n    if (ch_0 == 100) {\n      debug = 1;\n    } else {\n      if (ch_0 != 119) {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if (width <= 0) libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  ::argc -= optind;\n  ::argv += optind;\n  for (i = 0; i < width; ++i) {\n    j = 132 * i / width;\n    print[132 * i / width] = 1;\n  }\n  if (*::argv) {\n    libmin_strncpy(message, *::argv, 1024uLL);\n    while (*++::argv) {\n      libmin_strncat(message, \" \", 1024uLL);\n      libmin_strncat(message, *::argv, 1024uLL);\n    }\n    nchars = libmin_strlen(message);\n    if (debug) {\n      libmin_printf(\"int asc_ptr[128] = {\\n\");\n      for (i = 0; i <= 127; ++i) {\n        libmin_printf(\"%4d,   \", asc_ptr[i]);\n        if ((((uint8_t)i + 1) & 7) == 0) libmin_printf(\"\\n\");\n      }\n      libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n      libmin_printf(\"  \\n\");\n      for (i = 0; i <= 9270; i += 10) {\n        libmin_printf(\"  \", i);\n        for (j = i; i + 9 >= j; ++j) {\n          x = (unsigned char)data_table[j];\n          libmin_printf(\" %3d, \", x);\n        }\n        libmin_putc(10);\n      }\n      libmin_printf(\"};\\n\");\n    }\n    j = 0;\n    for (i = 0; i < nchars; ++i) {\n      if (message[i] < 0 || !asc_ptr[(unsigned char)message[i]]) {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++j;\n      }\n    }\n    if (j) libmin_fail(1);\n    for (i = 0; i < nchars; ++i) {\n      for (j = 0; j <= 131; ++j) line[j] = 32;\n      pc = asc_ptr[(unsigned char)message[i]];\n      term = 0;\n      max = 0;\n      linen = 0;\n      while (!term) {\n        if ((unsigned int)pc > 9270) {\n          libmin_printf(\"bad pc: %d\\n\", pc);\n          libmin_fail(1);\n        }\n        x = (unsigned char)data_table[pc];\n        if (x <= 127) {\n          y = data_table[pc + 1];\n          max = x + y;\n          while (x < max) {\n            v5 = x++;\n            line[v5] = 35;\n          }\n          pc += 2;\n        } else {\n          if (x > 192) ++term;\n          x &= 63u;\n          while (x--) {\n            v3 = linen++;\n            if (print[v3]) {\n              for (j = 0; j <= max; ++j) {\n                if (print[j]) libmin_putc(line[j]);\n              }\n              libmin_putc(10);\n            }\n          }\n          for (j = 0; j <= 131; ++j) line[j] = 32;\n          ++pc;\n        }\n      }\n    }\n    libmin_success();\n  }\n  libmin_printf(\"No message to print.\\n\");\n  libmin_fail(1);\n}", "binary": "banner/banner.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\njmp    1264 <main+0x7b>\ncmpl   $0x64,-0x4(%rbp)\nje     1205 <main+0x1c>\ncmpl   $0x77,-0x4(%rbp)\nje     1211 <main+0x28>\njmp    1246 <main+0x5d>\nmovl   $0x1,0x95b5(%rip)\njmp    1264 <main+0x7b>\nmov    0x95e0(%rip),%rax\nmov    %rax,%rdi\ncall   1a9a <libmin_atoi>\nmov    %eax,0x8dea(%rip)\nmov    0x8de4(%rip),%eax\ntest   %eax,%eax\njg     1264 <main+0x7b>\nlea    0x6439(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\njmp    1264 <main+0x7b>\nlea    0x644a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    $0x1,%edi\ncall   1ba2 <libmin_fail>\nmov    0x8dcd(%rip),%rcx\nmov    0x8da3(%rip),%eax\nlea    0x6439(%rip),%rdx\nmov    %rcx,%rsi\nmov    %eax,%edi\ncall   1bd4 <libmin_getopt>\nmov    %eax,-0x4(%rbp)\ncmpl   $0xffffffff,-0x4(%rbp)\njne    11f7 <main+0xe>\nmov    0x8d7f(%rip),%eax\nmov    0x8fb5(%rip),%edx\nsub    %edx,%eax\nmov    %eax,0x8d71(%rip)\nmov    0x8d8e(%rip),%rdx\nmov    0x8fa0(%rip),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    %rax,0x8d78(%rip)\nmovl   $0x0,0x94fe(%rip)\njmp    1309 <main+0x120>\nmov    0x94f6(%rip),%eax\nimul   $0x84,%eax,%eax\nmov    0x8d32(%rip),%ecx\ncltd\nidiv   %ecx\nmov    %eax,0x94e5(%rip)\nmov    0x94df(%rip),%eax\ncltq\nlea    0x944a(%rip),%rdx\nmovb   $0x1,(%rax,%rdx,1)\nmov    0x94c8(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x94bf(%rip)\nmov    0x94b9(%rip),%edx\nmov    0x8cfb(%rip),%eax\ncmp    %eax,%edx\njl     12cc <main+0xe3>\nmov    0x8d18(%rip),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\nje     13c6 <main+0x1dd>\nmov    0x8d05(%rip),%rax\nmov    (%rax),%rax\nmov    $0x400,%edx\nmov    %rax,%rsi\nlea    0x8ffb(%rip),%rax\nmov    %rax,%rdi\ncall   42c7 <libmin_strncpy>\njmp    138e <main+0x1a5>\nmov    $0x400,%edx\nlea    0x635c(%rip),%rax\nmov    %rax,%rsi\nlea    0x8fdb(%rip),%rax\nmov    %rax,%rdi\ncall   424c <libmin_strncat>\nmov    0x8cc4(%rip),%rax\nmov    (%rax),%rax\nmov    $0x400,%edx\nmov    %rax,%rsi\nlea    0x8fba(%rip),%rax\nmov    %rax,%rdi\ncall   424c <libmin_strncat>\nmov    0x8ca3(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8c98(%rip)\nmov    0x8c91(%rip),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    134f <main+0x166>\nlea    0x8f8a(%rip),%rax\nmov    %rax,%rdi\ncall   420e <libmin_strlen>\nmov    %eax,0x9414(%rip)\njmp    13e4 <main+0x1fb>\nlea    0x62ec(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    $0x1,%edi\ncall   1ba2 <libmin_fail>\nmov    0x93da(%rip),%eax\ntest   %eax,%eax\nje     15d2 <main+0x3e9>\nlea    0x62d6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmovl   $0x0,0x93b8(%rip)\njmp    1475 <main+0x28c>\nmov    0x93b0(%rip),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x3bf7(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%esi\nlea    0x62b0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    0x9380(%rip),%eax\nadd    $0x1,%eax\nand    $0x7,%eax\ntest   %eax,%eax\njne    1466 <main+0x27d>\nlea    0x6294(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    0x935c(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9353(%rip)\nmov    0x934d(%rip),%eax\ncmp    $0x7f,%eax\njle    1412 <main+0x229>\nlea    0x6269(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nlea    0x6275(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmovl   $0x0,0x9316(%rip)\njmp    14df <main+0x2f6>\nmov    0x930e(%rip),%eax\nmov    %eax,%esi\nlea    0x6255(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    0x92f2(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x92e9(%rip)\nmov    0x92e3(%rip),%eax\ncmp    $0x9,%eax\njle    14b4 <main+0x2cb>\nlea    0x622e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmovl   $0x0,0x92c0(%rip)\njmp    15ad <main+0x3c4>\nmov    0x92b5(%rip),%eax\nmov    %eax,%esi\nlea    0x620a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    0x9299(%rip),%eax\nmov    %eax,0x9297(%rip)\njmp    1581 <main+0x398>\nmov    0x928f(%rip),%eax\ncltq\nlea    0x3cda(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\nmovzbl %al,%eax\nmov    %eax,0x928e(%rip)\nmov    0x9288(%rip),%eax\nmov    %eax,%esi\nlea    0x61cd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    0x9254(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x924b(%rip)\nmov    0x9241(%rip),%eax\nlea    0x9(%rax),%edx\nmov    0x923c(%rip),%eax\ncmp    %eax,%edx\njge    1537 <main+0x34e>\nmov    $0xa,%edi\ncall   41ef <libmin_putc>\nmov    0x9224(%rip),%eax\nadd    $0xa,%eax\nmov    %eax,0x921b(%rip)\nmov    0x9215(%rip),%eax\ncmp    $0x2436,%eax\njle    150d <main+0x324>\nlea    0x6174(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmovl   $0x0,0x91f0(%rip)\nmovl   $0x0,0x91e2(%rip)\njmp    165f <main+0x476>\nmov    0x91da(%rip),%eax\ncltq\nlea    0x8d49(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\ntest   %al,%al\njs     162d <main+0x444>\nmov    0x91c3(%rip),%eax\ncltq\nlea    0x8d32(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovzbl %al,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x39fa(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ntest   %eax,%eax\njne    1650 <main+0x467>\nlea    0x610c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    0x9185(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x917c(%rip)\nmov    0x9172(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9169(%rip)\nmov    0x9163(%rip),%edx\nmov    0x916d(%rip),%eax\ncmp    %eax,%edx\njl     15e8 <main+0x3ff>\nmov    0x9153(%rip),%eax\ntest   %eax,%eax\nje     1687 <main+0x49e>\nmov    $0x1,%edi\ncall   1ba2 <libmin_fail>\nmovl   $0x0,0x9137(%rip)\njmp    1938 <main+0x74f>\nmovl   $0x0,0x912c(%rip)\njmp    16c4 <main+0x4db>\nmov    0x9124(%rip),%eax\ncltq\nlea    0x8bef(%rip),%rdx\nmovb   $0x20,(%rax,%rdx,1)\nmov    0x9111(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9108(%rip)\nmov    0x9102(%rip),%eax\ncmp    $0x83,%eax\njle    16a2 <main+0x4b9>\nmov    0x90f1(%rip),%eax\ncltq\nlea    0x8c60(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovzbl %al,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x3928(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,0x90db(%rip)\nmovl   $0x0,0x90d5(%rip)\nmovl   $0x0,0x90bf(%rip)\nmovl   $0x0,0x90b1(%rip)\njmp    191b <main+0x732>\nmov    0x90b2(%rip),%eax\ntest   %eax,%eax\njs     173b <main+0x552>\nmov    0x90a8(%rip),%eax\ncmp    $0x2436,%eax\njle    1761 <main+0x578>\nmov    0x909b(%rip),%eax\nmov    %eax,%esi\nlea    0x6020(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3fc0 <libmin_printf>\nmov    $0x1,%edi\ncall   1ba2 <libmin_fail>\nmov    0x9075(%rip),%eax\ncltq\nlea    0x3ab0(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\nmovzbl %al,%eax\nmov    %eax,0x9064(%rip)\nmov    0x905e(%rip),%eax\ncmp    $0x7f,%eax\njle    18ab <main+0x6c2>\nmov    0x904f(%rip),%eax\ncmp    $0xc0,%eax\njle    17ab <main+0x5c2>\nmov    0x903e(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9035(%rip)\nmov    0x9033(%rip),%eax\nand    $0x3f,%eax\nmov    %eax,0x902a(%rip)\njmp    1848 <main+0x65f>\nmov    0x900b(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x9002(%rip)\ncltq\nlea    0x8f69(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\ntest   %al,%al\nje     1848 <main+0x65f>\nmovl   $0x0,0x8fe3(%rip)\njmp    182e <main+0x645>\nmov    0x8fdb(%rip),%eax\ncltq\nlea    0x8f46(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\ntest   %al,%al\nje     181f <main+0x636>\nmov    0x8fc4(%rip),%eax\ncltq\nlea    0x8a8f(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   41ef <libmin_putc>\nmov    0x8fa7(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x8f9e(%rip)\nmov    0x8f98(%rip),%edx\nmov    0x8f9a(%rip),%eax\ncmp    %eax,%edx\njle    17eb <main+0x602>\nmov    $0xa,%edi\ncall   41ef <libmin_putc>\nmov    0x8f96(%rip),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,0x8f8d(%rip)\ntest   %eax,%eax\njne    17bf <main+0x5d6>\nmovl   $0x0,0x8f63(%rip)\njmp    188d <main+0x6a4>\nmov    0x8f5b(%rip),%eax\ncltq\nlea    0x8a26(%rip),%rdx\nmovb   $0x20,(%rax,%rdx,1)\nmov    0x8f48(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x8f3f(%rip)\nmov    0x8f39(%rip),%eax\ncmp    $0x83,%eax\njle    186b <main+0x682>\nmov    0x8f3c(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x8f33(%rip)\njmp    191b <main+0x732>\nmov    0x8f2b(%rip),%eax\nadd    $0x1,%eax\ncltq\nlea    0x3963(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\nmov    %eax,0x8f1e(%rip)\nmov    0x8f14(%rip),%edx\nmov    0x8f12(%rip),%eax\nadd    %edx,%eax\nmov    %eax,0x8ef6(%rip)\njmp    18fc <main+0x713>\nmov    0x8efe(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x8ef5(%rip)\ncltq\nlea    0x89a8(%rip),%rdx\nmovb   $0x23,(%rax,%rdx,1)\nmov    0x8ee2(%rip),%edx\nmov    0x8ecc(%rip),%eax\ncmp    %eax,%edx\njl     18e0 <main+0x6f7>\nmov    0x8eca(%rip),%eax\nadd    $0x2,%eax\nmov    %eax,0x8ec1(%rip)\nmov    0x8ebf(%rip),%eax\ntest   %eax,%eax\nje     1724 <main+0x53b>\nmov    0x8e99(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x8e90(%rip)\nmov    0x8e8a(%rip),%edx\nmov    0x8e94(%rip),%eax\ncmp    %eax,%edx\njl     1696 <main+0x4ad>\ncall   4347 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_builtin", "content": "// ------------------------------\n// Bit-counting Kernel 3: Compiler built-in popcount (GCC/Clang)\n// ------------------------------\nunsigned int count_bits_builtin(uint32_t x) {\n    return __builtin_popcount(x);\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O0.pseudo", "function_name": "count_bits_builtin", "address": "0x1240", "label": "count_bits_builtin", "content": "unsigned int __cdecl count_bits_builtin(uint32_t x)\n{\n  return _popcountdi2(x);\n}\n"}, "pseudo_normalize": "", "binary": "bit-kernels/bit-kernels.host.O0", "assembly": "<count_bits_builtin>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %rax,%rdi\ncall   4250 <__popcountdi2>\nleave\nret\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_kernighan", "content": "// ------------------------------\n// Bit-counting Kernel 2: Kernighan's algorithm\n// ------------------------------\nunsigned int count_bits_kernighan(uint32_t x) {\n    unsigned int count = 0;\n    while (x) {\n        x &= (x - 1);\n        count++;\n    }\n    return count;\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O0.pseudo", "function_name": "count_bits_kernighan", "address": "0x1214", "label": "count_bits_kernighan", "content": "unsigned int __cdecl count_bits_kernighan(uint32_t x)\n{\n  unsigned int count; // [rsp+10h] [rbp-4h]\n\n  count = 0;\n  while ( x )\n  {\n    x &= x - 1;\n    ++count;\n  }\n  return count;\n}\n"}, "pseudo_normalize": "unsigned int count_bits_kernighan(uint32_t x) {\n  unsigned int count;\n  count = 0;\n  while (x) {\n    x &= x - 1;\n    ++count;\n  }\n  return count;\n}", "binary": "bit-kernels/bit-kernels.host.O0", "assembly": "<count_bits_kernighan>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1235 <count_bits_kernighan+0x21>\nmov    -0x14(%rbp),%eax\nsub    $0x1,%eax\nand    %eax,-0x14(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    1228 <count_bits_kernighan+0x14>\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_naive", "content": "// ------------------------------\n// Bit-counting Kernel 1: Naive method\n// ------------------------------\nunsigned int count_bits_naive(uint32_t x) {\n    unsigned int count = 0;\n    while (x) {\n        count += (x & 1);\n        x >>= 1;\n    }\n    return count;\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O0.pseudo", "function_name": "count_bits_naive", "address": "0x11e9", "label": "count_bits_naive", "content": "unsigned int __cdecl count_bits_naive(uint32_t x)\n{\n  unsigned int count; // [rsp+10h] [rbp-4h]\n\n  count = 0;\n  while ( x )\n  {\n    count += x & 1;\n    x >>= 1;\n  }\n  return count;\n}\n"}, "pseudo_normalize": "unsigned int count_bits_naive(uint32_t x) {\n  unsigned int count;\n  count = 0;\n  while (x) {\n    count += x & 1;\n    x >>= 1;\n  }\n  return count;\n}", "binary": "bit-kernels/bit-kernels.host.O0", "assembly": "<count_bits_naive>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1209 <count_bits_naive+0x20>\nmov    -0x14(%rbp),%eax\nand    $0x1,%eax\nadd    %eax,-0x4(%rbp)\nshrl   -0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    11fd <count_bits_naive+0x14>\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_parallel", "content": "// ------------------------------\n// Bit-counting Kernel 5: Parallel counting (SWAR algorithm)\n// ------------------------------\nunsigned int count_bits_parallel(uint32_t x) {\n    // Subtract pairs of bits\n    x = x - ((x >> 1) & 0x55555555);\n    // Sum bits in nibble groups\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    // Aggregate counts in bytes\n    x = (x + (x >> 4)) & 0x0F0F0F0F;\n    // Multiply and shift out the sum\n    return (x * 0x01010101) >> 24;\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O0.pseudo", "function_name": "count_bits_parallel", "address": "0x133a", "label": "count_bits_parallel", "content": "unsigned int __cdecl count_bits_parallel(uint32_t x)\n{\n  return (16843009\n        * ((((((x - ((x >> 1) & 0x55555555)) & 0x33333333) + (((x - ((x >> 1) & 0x55555555)) >> 2) & 0x33333333)) >> 4)\n          + ((x - ((x >> 1) & 0x55555555)) & 0x33333333)\n          + (((x - ((x >> 1) & 0x55555555)) >> 2) & 0x33333333)) & 0xF0F0F0F)) >> 24;\n}\n"}, "pseudo_normalize": "unsigned int count_bits_parallel(uint32_t x) {\n  return (16843009 * ((((((x - ((x >> 1) & 1431655765)) & 858993459) +\n                         (((x - ((x >> 1) & 1431655765)) >> 2) & 858993459)) >>\n                        4) +\n                       ((x - ((x >> 1) & 1431655765)) & 858993459) +\n                       (((x - ((x >> 1) & 1431655765)) >> 2) & 858993459)) &\n                      252645135)) >>\n         24;\n}", "binary": "bit-kernels/bit-kernels.host.O0", "assembly": "<count_bits_parallel>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshr    %eax\nand    $0x55555555,%eax\nsub    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nand    $0x33333333,%eax\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nshr    $0x2,%eax\nand    $0x33333333,%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshr    $0x4,%eax\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nadd    %edx,%eax\nand    $0xf0f0f0f,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   $0x1010101,%eax,%eax\nshr    $0x18,%eax\npop    %rbp\nret\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_table", "content": "  \n// Use the table to compute popcount for a 32-bit integer.\nunsigned int count_bits_table(uint32_t x) {\n    return popcount_table[x & 0xFF] +\n           popcount_table[(x >> 8) & 0xFF] +\n           popcount_table[(x >> 16) & 0xFF] +\n           popcount_table[(x >> 24) & 0xFF];\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O0.pseudo", "function_name": "count_bits_table", "address": "0x12b9", "label": "count_bits_table", "content": "unsigned int __cdecl count_bits_table(uint32_t x)\n{\n  return popcount_table[BYTE2(x)]\n       + popcount_table[BYTE1(x)]\n       + popcount_table[(unsigned __int8)x]\n       + popcount_table[HIBYTE(x)];\n}\n"}, "pseudo_normalize": "", "binary": "bit-kernels/bit-kernels.host.O0", "assembly": "<count_bits_table>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x5fa5(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0x4(%rbp),%eax\nshr    $0x8,%eax\nmovzbl %al,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x5f88(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%ecx\nmov    -0x4(%rbp),%eax\nshr    $0x10,%eax\nmovzbl %al,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x5f69(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%ecx\nmov    -0x4(%rbp),%eax\nshr    $0x18,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x5f4d(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\npop    %rbp\nret\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "init_popcount_table", "content": "// ------------------------------\n// Bit-counting Kernel 4: Table lookup\n// ------------------------------\n// Initialize the lookup table for 8-bit popcount.\nvoid init_popcount_table() {\n    for (int i = 0; i < TABLE_SIZE; i++) {\n        unsigned int count = 0;\n        int value = i;\n        while (value) {\n            count += (value & 1);\n            value >>= 1;\n        }\n        popcount_table[i] = count;\n    }\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O0.pseudo", "function_name": "init_popcount_table", "address": "0x125c", "label": "init_popcount_table", "content": "void __cdecl init_popcount_table()\n{\n  int i; // [rsp+0h] [rbp-Ch]\n  unsigned int count; // [rsp+4h] [rbp-8h]\n  int value; // [rsp+8h] [rbp-4h]\n\n  for ( i = 0; i <= 255; ++i )\n  {\n    count = 0;\n    for ( value = i; value; value >>= 1 )\n      count += value & 1;\n    popcount_table[i] = count;\n  }\n}\n"}, "pseudo_normalize": "void init_popcount_table() {\n  int i;\n  unsigned int count;\n  int value;\n  for (i = 0; i <= 255; ++i) {\n    count = 0;\n    for (value = i; value; value >>= 1) count += value & 1;\n    popcount_table[i] = count;\n  }\n}", "binary": "bit-kernels/bit-kernels.host.O0", "assembly": "<init_popcount_table>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x0,-0xc(%rbp)\njmp    12ac <init_popcount_table+0x50>\nmovl   $0x0,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x4(%rbp)\njmp    1288 <init_popcount_table+0x2c>\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\nadd    %eax,-0x8(%rbp)\nsarl   -0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    127c <init_popcount_table+0x20>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x5fde(%rip),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0xff,-0xc(%rbp)\njle    126d <init_popcount_table+0x11>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "main", "content": "// ------------------------------\n// Main testing function\n// ------------------------------\nint main(void) {\n    // Seed random generator\n    libmin_srand(42);\n    \n    // Initialize lookup table for table lookup method.\n    init_popcount_table();\n    \n    // Allocate an array of NUM_ELEMENTS random 32-bit numbers.\n    uint32_t *numbers = libmin_malloc(NUM_ELEMENTS * sizeof(uint32_t));\n    if (numbers == NULL) {\n        libmin_printf(\"ERROR: Memory allocation error!\\n\");\n        return 1;\n    }\n    \n    // Fill the array with random 32-bit numbers.\n    for (size_t i = 0; i < NUM_ELEMENTS; i++) {\n        // Combine two calls to rand() to create a 32-bit number.\n        numbers[i] = ((uint32_t)libmin_rand() << 16) | (libmin_rand() & 0xFFFF);\n    }\n    \n    // Variables to sum total bit counts for each method.\n    unsigned long long total_naive = 0;\n    unsigned long long total_kernighan = 0;\n    unsigned long long total_builtin = 0;\n    unsigned long long total_table = 0;\n    unsigned long long total_parallel = 0;\n    \n    // Process each number.\n    for (size_t i = 0; i < NUM_ELEMENTS; i++) {\n        uint32_t val = numbers[i];\n        unsigned int naive   = count_bits_naive(val);\n        unsigned int kernighan = count_bits_kernighan(val);\n        unsigned int builtin = count_bits_builtin(val);\n        unsigned int table   = count_bits_table(val);\n        unsigned int parallel = count_bits_parallel(val);\n        \n        // Verify that all methods agree.\n        if (naive != kernighan || naive != builtin || naive != table || naive != parallel) {\n            libmin_printf(\"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, table=%u, parallel=%u\\n\",\n                   val, naive, kernighan, builtin, table, parallel);\n        }\n        \n        // Accumulate totals.\n        total_naive   += naive;\n        total_kernighan += kernighan;\n        total_builtin += builtin;\n        total_table   += table;\n        total_parallel += parallel;\n        \n        // For demonstration, print the first 5 numbers with their popcount from each method.\n        if (i < 5) {\n            libmin_printf(\"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, parallel=%2u\\n\",\n                   val, naive, kernighan, builtin, table, parallel);\n        }\n    }\n    \n    // Print overall totals for comparison.\n    libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", NUM_ELEMENTS);\n    libmin_printf(\"Naive         : %llu\\n\", total_naive);\n    libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n    libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n    libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n    libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n    \n    // Clean up\n    libmin_free(numbers);\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O0.pseudo", "function_name": "main", "address": "0x138f", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v4; // ebx\n  uint32_t val; // [rsp+8h] [rbp-68h]\n  unsigned int naive; // [rsp+Ch] [rbp-64h]\n  unsigned int kernighan; // [rsp+10h] [rbp-60h]\n  unsigned int builtin; // [rsp+14h] [rbp-5Ch]\n  unsigned int table; // [rsp+18h] [rbp-58h]\n  unsigned int parallel; // [rsp+1Ch] [rbp-54h]\n  size_t i; // [rsp+20h] [rbp-50h]\n  unsigned __int64 total_naive; // [rsp+28h] [rbp-48h]\n  unsigned __int64 total_kernighan; // [rsp+30h] [rbp-40h]\n  unsigned __int64 total_builtin; // [rsp+38h] [rbp-38h]\n  unsigned __int64 total_table; // [rsp+40h] [rbp-30h]\n  unsigned __int64 total_parallel; // [rsp+48h] [rbp-28h]\n  size_t i_0; // [rsp+50h] [rbp-20h]\n  uint32_t *numbers; // [rsp+58h] [rbp-18h]\n\n  libmin_srand(0x2Au);\n  init_popcount_table();\n  numbers = (uint32_t *)libmin_malloc(0x190uLL);\n  if ( numbers )\n  {\n    for ( i = 0LL; i <= 0x63; ++i )\n    {\n      v4 = libmin_rand() << 16;\n      numbers[i] = v4 | (unsigned __int16)libmin_rand();\n    }\n    total_naive = 0LL;\n    total_kernighan = 0LL;\n    total_builtin = 0LL;\n    total_table = 0LL;\n    total_parallel = 0LL;\n    for ( i_0 = 0LL; i_0 <= 0x63; ++i_0 )\n    {\n      val = numbers[i_0];\n      naive = count_bits_naive(val);\n      kernighan = count_bits_kernighan(val);\n      builtin = count_bits_builtin(val);\n      table = count_bits_table(val);\n      parallel = count_bits_parallel(val);\n      if ( naive != kernighan || naive != builtin || naive != table || naive != parallel )\n        libmin_printf(\n          \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, table=%u, parallel=%u\\n\",\n          val,\n          naive,\n          kernighan,\n          builtin,\n          table,\n          parallel);\n      total_naive += naive;\n      total_kernighan += kernighan;\n      total_builtin += builtin;\n      total_table += table;\n      total_parallel += parallel;\n      if ( i_0 <= 4 )\n        libmin_printf(\n          \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, parallel=%2u\\n\",\n          val,\n          naive,\n          kernighan,\n          builtin,\n          table,\n          parallel);\n    }\n    libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n    libmin_printf(\"Naive         : %llu\\n\", total_naive);\n    libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n    libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n    libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n    libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n    libmin_free(numbers);\n    libmin_success();\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  unsigned int v4;\n  uint32_t val;\n  unsigned int naive;\n  unsigned int kernighan;\n  unsigned int builtin;\n  unsigned int table;\n  unsigned int parallel;\n  unsigned int i;\n  unsigned long long total_naive;\n  unsigned long long total_kernighan;\n  unsigned long long total_builtin;\n  unsigned long long total_table;\n  unsigned long long total_parallel;\n  unsigned int i_0;\n  uint32_t *numbers;\n  libmin_srand(42u);\n  init_popcount_table();\n  numbers = (uint32_t *)libmin_malloc(400uLL);\n  if (numbers) {\n    for (i = 0LL; i <= 99; ++i) {\n      v4 = libmin_rand() << 16;\n      numbers[i] = v4 | (unsigned short)libmin_rand();\n    }\n    total_naive = 0LL;\n    total_kernighan = 0LL;\n    total_builtin = 0LL;\n    total_table = 0LL;\n    total_parallel = 0LL;\n    for (i_0 = 0LL; i_0 <= 99; ++i_0) {\n      val = numbers[i_0];\n      naive = count_bits_naive(val);\n      kernighan = count_bits_kernighan(val);\n      builtin = count_bits_builtin(val);\n      table = count_bits_table(val);\n      parallel = count_bits_parallel(val);\n      if (naive != kernighan || naive != builtin || naive != table ||\n          naive != parallel)\n        libmin_printf(\n            \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, \"\n            \"table=%u, parallel=%u\\n\",\n            val, naive, kernighan, builtin, table, parallel);\n      total_naive += naive;\n      total_kernighan += kernighan;\n      total_builtin += builtin;\n      total_table += table;\n      total_parallel += parallel;\n      if (i_0 <= 4)\n        libmin_printf(\n            \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, \"\n            \"parallel=%2u\\n\",\n            val, naive, kernighan, builtin, table, parallel);\n    }\n    libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n    libmin_printf(\"Naive         : %llu\\n\", total_naive);\n    libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n    libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n    libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n    libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n    libmin_free(numbers);\n    libmin_success();\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}", "binary": "bit-kernels/bit-kernels.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    $0x2a,%edi\ncall   3e5a <libmin_srand>\nmov    $0x0,%eax\ncall   125c <init_popcount_table>\nmov    $0x190,%edi\ncall   17c9 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    13e3 <main+0x54>\nlea    0x3c3c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    $0x1,%eax\njmp    1630 <main+0x2a1>\nmovq   $0x0,-0x50(%rbp)\njmp    141b <main+0x8c>\ncall   3f0c <libmin_rand>\nshl    $0x10,%eax\nmov    %eax,%ebx\ncall   3f0c <libmin_rand>\nmovzwl %ax,%edx\nmov    -0x50(%rbp),%rax\nlea    0x0(,%rax,4),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nor     %ebx,%edx\nmov    %edx,(%rax)\naddq   $0x1,-0x50(%rbp)\ncmpq   $0x63,-0x50(%rbp)\njbe    13ed <main+0x5e>\nmovq   $0x0,-0x48(%rbp)\nmovq   $0x0,-0x40(%rbp)\nmovq   $0x0,-0x38(%rbp)\nmovq   $0x0,-0x30(%rbp)\nmovq   $0x0,-0x28(%rbp)\nmovq   $0x0,-0x20(%rbp)\njmp    156f <main+0x1e0>\nmov    -0x20(%rbp),%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x68(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <count_bits_naive>\nmov    %eax,-0x64(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,%edi\ncall   1214 <count_bits_kernighan>\nmov    %eax,-0x60(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,%edi\ncall   1240 <count_bits_builtin>\nmov    %eax,-0x5c(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,%edi\ncall   12b9 <count_bits_table>\nmov    %eax,-0x58(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,%edi\ncall   133a <count_bits_parallel>\nmov    %eax,-0x54(%rbp)\nmov    -0x64(%rbp),%eax\ncmp    -0x60(%rbp),%eax\njne    14d0 <main+0x141>\nmov    -0x64(%rbp),%eax\ncmp    -0x5c(%rbp),%eax\njne    14d0 <main+0x141>\nmov    -0x64(%rbp),%eax\ncmp    -0x58(%rbp),%eax\njne    14d0 <main+0x141>\nmov    -0x64(%rbp),%eax\ncmp    -0x54(%rbp),%eax\nje     1508 <main+0x179>\nmov    -0x58(%rbp),%r8d\nmov    -0x5c(%rbp),%edi\nmov    -0x60(%rbp),%ecx\nmov    -0x64(%rbp),%edx\nmov    -0x68(%rbp),%eax\nsub    $0x8,%rsp\nmov    -0x54(%rbp),%esi\npush   %rsi\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %eax,%esi\nlea    0x3b39(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nadd    $0x10,%rsp\nmov    -0x64(%rbp),%eax\nadd    %rax,-0x48(%rbp)\nmov    -0x60(%rbp),%eax\nadd    %rax,-0x40(%rbp)\nmov    -0x5c(%rbp),%eax\nadd    %rax,-0x38(%rbp)\nmov    -0x58(%rbp),%eax\nadd    %rax,-0x30(%rbp)\nmov    -0x54(%rbp),%eax\nadd    %rax,-0x28(%rbp)\ncmpq   $0x4,-0x20(%rbp)\nja     156a <main+0x1db>\nmov    -0x58(%rbp),%r8d\nmov    -0x5c(%rbp),%edi\nmov    -0x60(%rbp),%ecx\nmov    -0x64(%rbp),%edx\nmov    -0x68(%rbp),%eax\nsub    $0x8,%rsp\nmov    -0x54(%rbp),%esi\npush   %rsi\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %eax,%esi\nlea    0x3b2f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nadd    $0x10,%rsp\naddq   $0x1,-0x20(%rbp)\ncmpq   $0x63,-0x20(%rbp)\njbe    1457 <main+0xc8>\nmov    $0x64,%esi\nlea    0x3b52(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    -0x48(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3b5a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    -0x40(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3b55(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3b50(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3b4b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3b46(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c2b <libmin_printf>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   18b4 <libmin_free>\ncall   41c3 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "BLAKE2B", "content": "/**\n * @brief driver function to perform the hashing as described in specification\n *\n * pseudocode: (credit to authors of RFC 7693 listed above)\n * FUNCTION BLAKE2( d[0..dd-1], ll, kk, nn )\n * |\n * |     h[0..7] := IV[0..7]          // Initialization Vector.\n * |\n * |     // Parameter block p[0]\n * |     h[0] := h[0] ^ 0x01010000 ^ (kk << 8) ^ nn\n * |\n * |     // Process padded key and data blocks\n * |     IF dd > 1 THEN\n * |     |       FOR i = 0 TO dd - 2 DO\n * |     |       |       h := F( h, d[i], (i + 1) * bb, FALSE )\n * |     |       END FOR.\n * |     END IF.\n * |\n * |     // Final block.\n * |     IF kk = 0 THEN\n * |     |       h := F( h, d[dd - 1], ll, TRUE )\n * |     ELSE\n * |     |       h := F( h, d[dd - 1], ll + bb, TRUE )\n * |     END IF.\n * |\n * |     RETURN first \"nn\" bytes from little-endian word array h[].\n * |\n * END FUNCTION.\n *\n * @param dest destination of hashing digest\n * @param d message blocks\n * @param dd length of d\n * @param ll 128-bit length of message\n * @param kk length of secret key\n * @param nn length of hash digest\n *\n * @returns 0 upon successful hash\n */\nstatic int BLAKE2B(uint8_t *dest, block_t *d, size_t dd, u128 ll, uint8_t kk,\n                   uint8_t nn)\n{\n    uint8_t bytes[8];\n    uint64_t i, j;\n    uint64_t h[8];\n    u128 t = U128_ZERO;\n\n    /* h[0..7] = IV[0..7] */\n    for (i = 0; i < 8; i++)\n    {\n        h[i] = blake2b_iv[i];\n    }\n\n    h[0] ^= 0x01010000 ^ (kk << 8) ^ nn;\n\n    if (dd > 1)\n    {\n        for (i = 0; i < dd - 1; i++)\n        {\n            u128_increment(t, bb);\n            F(h, d[i], t, 0);\n        }\n    }\n\n    if (kk != 0)\n    {\n        u128_increment(ll, bb);\n    }\n    F(h, d[dd - 1], ll, 1);\n\n    /* copy bytes from h to destination buffer */\n    for (i = 0; i < nn; i++)\n    {\n        if (i % sizeof(uint64_t) == 0)\n        {\n            /* copy values from uint64 to 8 u8's */\n            for (j = 0; j < sizeof(uint64_t); j++)\n            {\n                uint16_t offset = 8 * j;\n                uint64_t mask = 0xFF;\n                mask <<= offset;\n\n                bytes[j] = (h[i / 8] & (mask)) >> offset;\n            }\n        }\n\n        dest[i] = bytes[i % 8];\n    }\n\n    return 0;\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O0.pseudo", "function_name": "BLAKE2B", "address": "0x1a9b", "label": "BLAKE2B", "content": "int __cdecl BLAKE2B(uint8_t *dest, block_t *d, size_t dd, uint64_t *ll, uint8_t kk, uint8_t nn)\n{\n  uint64_t i; // [rsp+38h] [rbp-78h]\n  uint64_t ia; // [rsp+38h] [rbp-78h]\n  uint64_t ib; // [rsp+38h] [rbp-78h]\n  uint64_t j; // [rsp+40h] [rbp-70h]\n  u128 t; // [rsp+50h] [rbp-60h] BYREF\n  uint64_t h[8]; // [rsp+60h] [rbp-50h] BYREF\n  uint8_t bytes[8]; // [rsp+A0h] [rbp-10h]\n  unsigned __int64 v18; // [rsp+A8h] [rbp-8h]\n\n  v18 = __readfsqword(0x28u);\n  t[0] = 0LL;\n  t[1] = 0LL;\n  for ( i = 0LL; i <= 7; ++i )\n    h[i] = blake2b_iv[i];\n  h[0] ^= (kk << 8) ^ 0x1010000 ^ (unsigned int)nn;\n  if ( dd > 1 )\n  {\n    for ( ia = 0LL; ia < dd - 1; ++ia )\n    {\n      u128_increment(t, 0x80uLL);\n      F(h, &(*d)[16 * ia], t, 0);\n    }\n  }\n  if ( kk )\n    u128_increment(ll, 0x80uLL);\n  F(h, &(*d)[16 * dd - 16], ll, 1);\n  for ( ib = 0LL; ib < nn; ++ib )\n  {\n    if ( (ib & 7) == 0 )\n    {\n      for ( j = 0LL; j <= 7; ++j )\n        bytes[j] = ((255LL << (8 * (unsigned __int8)j)) & h[ib >> 3]) >> (8 * (unsigned __int8)j);\n    }\n    dest[ib] = bytes[ib & 7];\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int BLAKE2B(uint8_t *dest, block_t *d, unsigned int dd, uint64_t *ll,\n            uint8_t kk, uint8_t nn) {\n  uint64_t i;\n  uint64_t ia;\n  uint64_t ib;\n  uint64_t j;\n  u128 t;\n  uint64_t h[8];\n  uint8_t bytes[8];\n  unsigned long long v18;\n  v18 = __readfsqword(40u);\n  t[0] = 0LL;\n  t[1] = 0LL;\n  for (i = 0LL; i <= 7; ++i) h[i] = blake2b_iv[i];\n  h[0] ^= (kk << 8) ^ 16842752 ^ (unsigned int)nn;\n  if (dd > 1) {\n    for (ia = 0LL; ia < dd - 1; ++ia) {\n      u128_increment(t, 128uLL);\n      F(h, &(*d)[16 * ia], t, 0);\n    }\n  }\n  if (kk) u128_increment(ll, 128uLL);\n  F(h, &(*d)[16 * dd - 16], ll, 1);\n  for (ib = 0LL; ib < nn; ++ib) {\n    if ((ib & 7) == 0) {\n      for (j = 0LL; j <= 7; ++j)\n        bytes[j] = ((255LL << (8 * (unsigned char)j)) & h[ib >> 3]) >>\n                   (8 * (unsigned char)j);\n    }\n    dest[ib] = bytes[ib & 7];\n  }\n  return 0;\n}", "binary": "blake2b/blake2b.host.O0", "assembly": "<BLAKE2B>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb0,%rsp\nmov    %rdi,-0x88(%rbp)\nmov    %rsi,-0x90(%rbp)\nmov    %rdx,-0x98(%rbp)\nmov    %rcx,-0xa0(%rbp)\nmov    %r8d,%eax\nmov    %r9d,%edx\nmov    %al,-0xa4(%rbp)\nmov    %edx,%eax\nmov    %al,-0xa8(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x60(%rbp)\nmovq   $0x0,-0x58(%rbp)\nmovq   $0x0,-0x78(%rbp)\njmp    1b28 <BLAKE2B+0x8d>\nmov    -0x78(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x352a(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x78(%rbp),%rax\nmov    %rdx,-0x50(%rbp,%rax,8)\naddq   $0x1,-0x78(%rbp)\ncmpq   $0x7,-0x78(%rbp)\njbe    1b03 <BLAKE2B+0x68>\nmov    -0x50(%rbp),%rdx\nmovzbl -0xa4(%rbp),%eax\nshl    $0x8,%eax\nxor    $0x1010000,%eax\nmov    %eax,%ecx\nmovzbl -0xa8(%rbp),%eax\nxor    %ecx,%eax\ncltq\nxor    %rdx,%rax\nmov    %rax,-0x50(%rbp)\ncmpq   $0x1,-0x98(%rbp)\njbe    1bbc <BLAKE2B+0x121>\nmovq   $0x0,-0x78(%rbp)\njmp    1bab <BLAKE2B+0x110>\nlea    -0x60(%rbp),%rax\nmov    $0x80,%esi\nmov    %rax,%rdi\ncall   1212 <u128_increment>\nmov    -0x78(%rbp),%rax\nshl    $0x7,%rax\nmov    %rax,%rdx\nmov    -0x90(%rbp),%rax\nlea    (%rdx,%rax,1),%rsi\nlea    -0x60(%rbp),%rdx\nlea    -0x50(%rbp),%rax\nmov    $0x0,%ecx\nmov    %rax,%rdi\ncall   1502 <F>\naddq   $0x1,-0x78(%rbp)\nmov    -0x98(%rbp),%rax\nsub    $0x1,%rax\ncmp    %rax,-0x78(%rbp)\njb     1b6a <BLAKE2B+0xcf>\ncmpb   $0x0,-0xa4(%rbp)\nje     1bd9 <BLAKE2B+0x13e>\nmov    -0xa0(%rbp),%rax\nmov    $0x80,%esi\nmov    %rax,%rdi\ncall   1212 <u128_increment>\nmov    -0x98(%rbp),%rax\nshl    $0x7,%rax\nlea    -0x80(%rax),%rdx\nmov    -0x90(%rbp),%rax\nlea    (%rdx,%rax,1),%rsi\nmov    -0xa0(%rbp),%rdx\nlea    -0x50(%rbp),%rax\nmov    $0x1,%ecx\nmov    %rax,%rdi\ncall   1502 <F>\nmovq   $0x0,-0x78(%rbp)\njmp    1ca7 <BLAKE2B+0x20c>\nmov    -0x78(%rbp),%rax\nand    $0x7,%eax\ntest   %rax,%rax\njne    1c86 <BLAKE2B+0x1eb>\nmovq   $0x0,-0x70(%rbp)\njmp    1c7f <BLAKE2B+0x1e4>\nmov    -0x70(%rbp),%rax\nshl    $0x3,%eax\nmov    %ax,-0x7a(%rbp)\nmovq   $0xff,-0x68(%rbp)\nmovzwl -0x7a(%rbp),%eax\nmov    %eax,%ecx\nshlq   %cl,-0x68(%rbp)\nmov    -0x78(%rbp),%rax\nshr    $0x3,%rax\nmov    -0x50(%rbp,%rax,8),%rax\nand    -0x68(%rbp),%rax\nmov    %rax,%rdx\nmovzwl -0x7a(%rbp),%eax\nmov    %eax,%ecx\nshr    %cl,%rdx\nmov    %rdx,%rax\nmov    %eax,%edx\nlea    -0x10(%rbp),%rcx\nmov    -0x70(%rbp),%rax\nadd    %rcx,%rax\nmov    %dl,(%rax)\naddq   $0x1,-0x70(%rbp)\ncmpq   $0x7,-0x70(%rbp)\njbe    1c2e <BLAKE2B+0x193>\nmov    -0x78(%rbp),%rax\nand    $0x7,%eax\nmov    -0x88(%rbp),%rcx\nmov    -0x78(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl -0x10(%rbp,%rax,1),%eax\nmov    %al,(%rdx)\naddq   $0x1,-0x78(%rbp)\nmovzbl -0xa8(%rbp),%eax\ncmp    %rax,-0x78(%rbp)\njb     1c18 <BLAKE2B+0x17d>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1cd1 <BLAKE2B+0x236>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "F", "content": "/**\n * @brief compression function F\n *\n * Securely mixes the values in block m into\n * the state vector h. Value at v[14] is also\n * inverted if this is the final block to be\n * compressed.\n *\n * @param h the state vector\n * @param m message vector to be compressed into h\n * @param t 128-bit offset counter\n * @param f flag to indicate whether this is the final block\n *\n * @returns void\n */\nstatic void F(uint64_t h[8], block_t m, u128 t, int f)\n{\n    int i;\n    block_t v;\n\n    /* v[0..7] := h[0..7] */\n    for (i = 0; i < 8; i++)\n    {\n        v[i] = h[i];\n    }\n    /* v[8..15] := IV[0..7] */\n    for (; i < 16; i++)\n    {\n        v[i] = blake2b_iv[i - 8];\n    }\n\n    v[12] ^= t[0]; /* v[12] ^ (t mod 2**w) */\n    v[13] ^= t[1]; /* v[13] ^ (t >> w) */\n\n    if (f)\n    {\n        v[14] = ~v[14];\n    }\n\n    for (i = 0; i < 12; i++)\n    {\n        const uint8_t *s = blake2b_sigma[i];\n\n        G(v, 0, 4, 8, 12, m[s[0]], m[s[1]]);\n        G(v, 1, 5, 9, 13, m[s[2]], m[s[3]]);\n        G(v, 2, 6, 10, 14, m[s[4]], m[s[5]]);\n        G(v, 3, 7, 11, 15, m[s[6]], m[s[7]]);\n\n        G(v, 0, 5, 10, 15, m[s[8]], m[s[9]]);\n        G(v, 1, 6, 11, 12, m[s[10]], m[s[11]]);\n        G(v, 2, 7, 8, 13, m[s[12]], m[s[13]]);\n        G(v, 3, 4, 9, 14, m[s[14]], m[s[15]]);\n    }\n\n    for (i = 0; i < 8; i++)\n    {\n        h[i] ^= v[i] ^ v[i + 8];\n    }\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O0.pseudo", "function_name": "F", "address": "0x1502", "label": "F", "content": "void __cdecl F(uint64_t *h, uint64_t *m, uint64_t *t, int f)\n{\n  int i; // [rsp+24h] [rbp-9Ch]\n  int ia; // [rsp+24h] [rbp-9Ch]\n  int ib; // [rsp+24h] [rbp-9Ch]\n  const uint8_t *s; // [rsp+28h] [rbp-98h]\n  uint64_t v[17]; // [rsp+30h] [rbp-90h] BYREF\n  unsigned __int64 v9; // [rsp+B8h] [rbp-8h]\n\n  v9 = __readfsqword(0x28u);\n  for ( i = 0; i <= 7; ++i )\n    v[i] = h[i];\n  while ( i <= 15 )\n  {\n    v[i] = blake2b_iv[i - 8];\n    ++i;\n  }\n  v[12] ^= *t;\n  v[13] ^= t[1];\n  if ( f )\n    v[14] = ~v[14];\n  for ( ia = 0; ia <= 11; ++ia )\n  {\n    s = blake2b_sigma[ia];\n    G(v, 0, 4u, 8u, 0xCu, m[*s], m[s[1]]);\n    G(v, 1u, 5u, 9u, 0xDu, m[s[2]], m[s[3]]);\n    G(v, 2u, 6u, 0xAu, 0xEu, m[s[4]], m[s[5]]);\n    G(v, 3u, 7u, 0xBu, 0xFu, m[s[6]], m[s[7]]);\n    G(v, 0, 5u, 0xAu, 0xFu, m[s[8]], m[s[9]]);\n    G(v, 1u, 6u, 0xBu, 0xCu, m[s[10]], m[s[11]]);\n    G(v, 2u, 7u, 8u, 0xDu, m[s[12]], m[s[13]]);\n    G(v, 3u, 4u, 9u, 0xEu, m[s[14]], m[s[15]]);\n  }\n  for ( ib = 0; ib <= 7; ++ib )\n    h[ib] ^= v[ib + 8] ^ v[ib];\n}\n"}, "pseudo_normalize": "void F(uint64_t *h, uint64_t *m, uint64_t *t, int f) {\n  int i;\n  int ia;\n  int ib;\n  const uint8_t *s;\n  uint64_t v[17];\n  unsigned long long v9;\n  v9 = __readfsqword(40u);\n  for (i = 0; i <= 7; ++i) v[i] = h[i];\n  while (i <= 15) {\n    v[i] = blake2b_iv[i - 8];\n    ++i;\n  }\n  v[12] ^= *t;\n  v[13] ^= t[1];\n  if (f) v[14] = ~v[14];\n  for (ia = 0; ia <= 11; ++ia) {\n    s = blake2b_sigma[ia];\n    G(v, 0, 4u, 8u, 12u, m[*s], m[s[1]]);\n    G(v, 1u, 5u, 9u, 13u, m[s[2]], m[s[3]]);\n    G(v, 2u, 6u, 10u, 14u, m[s[4]], m[s[5]]);\n    G(v, 3u, 7u, 11u, 15u, m[s[6]], m[s[7]]);\n    G(v, 0, 5u, 10u, 15u, m[s[8]], m[s[9]]);\n    G(v, 1u, 6u, 11u, 12u, m[s[10]], m[s[11]]);\n    G(v, 2u, 7u, 8u, 13u, m[s[12]], m[s[13]]);\n    G(v, 3u, 4u, 9u, 14u, m[s[14]], m[s[15]]);\n  }\n  for (ib = 0; ib <= 7; ++ib) h[ib] ^= v[ib + 8] ^ v[ib];\n}", "binary": "blake2b/blake2b.host.O0", "assembly": "<F>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xc0,%rsp\nmov    %rdi,-0xa8(%rbp)\nmov    %rsi,-0xb0(%rbp)\nmov    %rdx,-0xb8(%rbp)\nmov    %ecx,-0xbc(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x9c(%rbp)\njmp    157b <F+0x79>\nmov    -0x9c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x9c(%rbp),%eax\ncltq\nmov    %rdx,-0x90(%rbp,%rax,8)\naddl   $0x1,-0x9c(%rbp)\ncmpl   $0x7,-0x9c(%rbp)\njle    1547 <F+0x45>\njmp    15bb <F+0xb9>\nmov    -0x9c(%rbp),%eax\nsub    $0x8,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x3aa0(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x9c(%rbp),%eax\ncltq\nmov    %rdx,-0x90(%rbp,%rax,8)\naddl   $0x1,-0x9c(%rbp)\ncmpl   $0xf,-0x9c(%rbp)\njle    1586 <F+0x84>\nmov    -0x30(%rbp),%rdx\nmov    -0xb8(%rbp),%rax\nmov    (%rax),%rax\nxor    %rdx,%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0xb8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nxor    %rdx,%rax\nmov    %rax,-0x28(%rbp)\ncmpl   $0x0,-0xbc(%rbp)\nje     1606 <F+0x104>\nmov    -0x20(%rbp),%rax\nnot    %rax\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x9c(%rbp)\njmp    19f8 <F+0x4f6>\nmov    -0x9c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x3a55(%rip),%rax\nadd    %rdx,%rax\nmov    %rax,-0x98(%rbp)\nmov    -0x98(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xc,%r8d\nmov    $0x8,%ecx\nmov    $0x4,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0x3,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0x2,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xd,%r8d\nmov    $0x9,%ecx\nmov    $0x5,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0x5,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0x4,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xe,%r8d\nmov    $0xa,%ecx\nmov    $0x6,%edx\nmov    $0x2,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0x7,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0x6,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xf,%r8d\nmov    $0xb,%ecx\nmov    $0x7,%edx\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0x9,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0x8,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xf,%r8d\nmov    $0xa,%ecx\nmov    $0x5,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0xb,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0xa,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xc,%r8d\nmov    $0xb,%ecx\nmov    $0x6,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0xd,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0xc,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xd,%r8d\nmov    $0x8,%ecx\nmov    $0x7,%edx\nmov    $0x2,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\nmov    -0x98(%rbp),%rax\nadd    $0xf,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0xb0(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x98(%rbp),%rax\nadd    $0xe,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0xb0(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nlea    -0x90(%rbp),%rax\npush   %rdx\nmov    %rcx,%r9\nmov    $0xe,%r8d\nmov    $0x9,%ecx\nmov    $0x4,%edx\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   1258 <G>\nadd    $0x8,%rsp\naddl   $0x1,-0x9c(%rbp)\ncmpl   $0xb,-0x9c(%rbp)\njle    1615 <F+0x113>\nmovl   $0x0,-0x9c(%rbp)\njmp    1a7b <F+0x579>\nmov    -0x9c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x9c(%rbp),%eax\ncltq\nmov    -0x90(%rbp,%rax,8),%rcx\nmov    -0x9c(%rbp),%eax\nadd    $0x8,%eax\ncltq\nmov    -0x90(%rbp,%rax,8),%rax\nxor    %rax,%rcx\nmov    -0x9c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rsi\nmov    -0xa8(%rbp),%rax\nadd    %rsi,%rax\nxor    %rcx,%rdx\nmov    %rdx,(%rax)\naddl   $0x1,-0x9c(%rbp)\ncmpl   $0x7,-0x9c(%rbp)\njle    1a11 <F+0x50f>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1a99 <F+0x597>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "G", "content": "/**\n * @brief blake2b mixing function G\n *\n * Shuffles values in block v depending on\n * provided indeces a, b, c, and d. x and y\n * are also mixed into the block.\n *\n * @param v array of words to be mixed\n * @param a first index\n * @param b second index\n * @param c third index\n * @param d fourth index\n * @param x first word being mixed into v\n * @param y second word being mixed into y\n *\n * @returns void\n */\nstatic void G(block_t v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x,\n              uint64_t y)\n{\n    v[a] += v[b] + x;\n    v[d] = ROTR64(v[d] ^ v[a], R1);\n    v[c] += v[d];\n    v[b] = ROTR64(v[b] ^ v[c], R2);\n    v[a] += v[b] + y;\n    v[d] = ROTR64(v[d] ^ v[a], R3);\n    v[c] += v[d];\n    v[b] = ROTR64(v[b] ^ v[c], R4);\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O0.pseudo", "function_name": "G", "address": "0x1258", "label": "G", "content": "void __cdecl G(uint64_t *v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x, uint64_t y)\n{\n  v[a] += x + v[b];\n  v[d] = __ROR8__(v[a] ^ v[d], 32);\n  v[c] += v[d];\n  v[b] = __ROR8__(v[c] ^ v[b], 24);\n  v[a] += y + v[b];\n  v[d] = __ROR8__(v[a] ^ v[d], 16);\n  v[c] += v[d];\n  v[b] = __ROR8__(v[c] ^ v[b], 63);\n}\n"}, "pseudo_normalize": "void G(uint64_t *v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x,\n       uint64_t y) {\n  v[a] += x + v[b];\n  v[d] = __ROR8__(v[a] ^ v[d], 32);\n  v[c] += v[d];\n  v[b] = __ROR8__(v[c] ^ v[b], 24);\n  v[a] += y + v[b];\n  v[d] = __ROR8__(v[a] ^ v[d], 16);\n  v[c] += v[d];\n  v[b] = __ROR8__(v[c] ^ v[b], 63);\n}", "binary": "blake2b/blake2b.host.O0", "assembly": "<G>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %ecx,%eax\nmov    %r8d,%edi\nmov    %r9,-0x20(%rbp)\nmov    %esi,%ecx\nmov    %cl,-0xc(%rbp)\nmov    %dl,-0x10(%rbp)\nmov    %al,-0x14(%rbp)\nmov    %edi,%eax\nmov    %al,-0x18(%rbp)\nmovzbl -0xc(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0x10(%rbp),%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rcx\nmovzbl -0xc(%rbp),%eax\nlea    0x0(,%rax,8),%rsi\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nadd    %rcx,%rdx\nmov    %rdx,(%rax)\nmovzbl -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0xc(%rbp),%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nxor    %rax,%rsi\nmov    $0x20,%eax\nmovzbl %al,%eax\nmovzbl -0x18(%rbp),%edx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    %eax,%ecx\nror    %cl,%rsi\nmov    %rsi,%rax\nmov    %rax,(%rdx)\nmovzbl -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rcx\nmovzbl -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rsi\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nadd    %rcx,%rdx\nmov    %rdx,(%rax)\nmovzbl -0x10(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nxor    %rax,%rsi\nmov    $0x18,%eax\nmovzbl %al,%eax\nmovzbl -0x10(%rbp),%edx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    %eax,%ecx\nror    %cl,%rsi\nmov    %rsi,%rax\nmov    %rax,(%rdx)\nmovzbl -0xc(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0x10(%rbp),%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rcx\nmov    0x10(%rbp),%rax\nadd    %rax,%rcx\nmovzbl -0xc(%rbp),%eax\nlea    0x0(,%rax,8),%rsi\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nadd    %rcx,%rdx\nmov    %rdx,(%rax)\nmovzbl -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0xc(%rbp),%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nxor    %rax,%rsi\nmov    $0x10,%eax\nmovzbl %al,%eax\nmovzbl -0x18(%rbp),%edx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    %eax,%ecx\nror    %cl,%rsi\nmov    %rsi,%rax\nmov    %rax,(%rdx)\nmovzbl -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rcx\nmovzbl -0x18(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rsi\nmov    -0x8(%rbp),%rax\nadd    %rsi,%rax\nadd    %rcx,%rdx\nmov    %rdx,(%rax)\nmovzbl -0x10(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmovzbl -0x14(%rbp),%eax\nlea    0x0(,%rax,8),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nxor    %rax,%rsi\nmov    $0x3f,%eax\nmovzbl %al,%eax\nmovzbl -0x10(%rbp),%edx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x8(%rbp),%rdx\nadd    %rcx,%rdx\nmov    %eax,%ecx\nror    %cl,%rsi\nmov    %rsi,%rax\nmov    %rax,(%rdx)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "assert_bytes", "content": "static void assert_bytes(const uint8_t *expected, const uint8_t *actual,\n                         uint8_t len)\n{\n    uint8_t i;\n\n    libmin_assert(expected != NULL);\n    libmin_assert(actual != NULL);\n    libmin_assert(len > 0);\n\n    libmin_printf(\"Test #%d:\\n\", testnum++);\n    libmin_printf(\"Expected[] = { \");\n    for (i = 0; i < len; i++)\n    {\n      libmin_printf(\"0x%02x \", actual[i]);\n      libmin_assert(expected[i] == actual[i]);\n    }\n    libmin_printf(\" }\\n\");\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O0.pseudo", "function_name": "assert_bytes", "address": "0x1f6c", "label": "assert_bytes", "content": "void __cdecl assert_bytes(const uint8_t *expected, const uint8_t *actual, uint8_t len)\n{\n  int v3; // eax\n  uint8_t i; // [rsp+2Fh] [rbp-1h]\n\n  if ( !expected )\n    libmin_fail(1);\n  if ( !actual )\n    libmin_fail(1);\n  if ( !len )\n    libmin_fail(1);\n  v3 = testnum++;\n  libmin_printf(\"Test #%d:\\n\", v3);\n  libmin_printf(\"Expected[] = { \");\n  for ( i = 0; i < len; ++i )\n  {\n    libmin_printf(\"0x%02x \", actual[i]);\n    if ( expected[i] != actual[i] )\n      libmin_fail(1);\n  }\n  libmin_printf(\" }\\n\");\n}\n"}, "pseudo_normalize": "void assert_bytes(const uint8_t *expected, const uint8_t *actual, uint8_t len) {\n  int v3;\n  uint8_t i;\n  if (!expected) libmin_fail(1);\n  if (!actual) libmin_fail(1);\n  if (!len) libmin_fail(1);\n  v3 = testnum++;\n  libmin_printf(\"Test #%d:\\n\", v3);\n  libmin_printf(\"Expected[] = { \");\n  for (i = 0; i < len; ++i) {\n    libmin_printf(\"0x%02x \", actual[i]);\n    if (expected[i] != actual[i]) libmin_fail(1);\n  }\n  libmin_printf(\" }\\n\");\n}", "binary": "blake2b/blake2b.host.O0", "assembly": "<assert_bytes>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,%eax\nmov    %al,-0x24(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1f96 <assert_bytes+0x2a>\nmov    $0x1,%edi\ncall   2736 <libmin_fail>\ncmpq   $0x0,-0x20(%rbp)\njne    1fa7 <assert_bytes+0x3b>\nmov    $0x1,%edi\ncall   2736 <libmin_fail>\ncmpb   $0x0,-0x24(%rbp)\njne    1fb7 <assert_bytes+0x4b>\nmov    $0x1,%edi\ncall   2736 <libmin_fail>\nmov    0x52af(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x52a6(%rip)\nmov    %eax,%esi\nlea    0x3171(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4c1b <libmin_printf>\nlea    0x3168(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4c1b <libmin_printf>\nmovb   $0x0,-0x1(%rbp)\njmp    2051 <assert_bytes+0xe5>\nmovzbl -0x1(%rbp),%edx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x314b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4c1b <libmin_printf>\nmovzbl -0x1(%rbp),%edx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmovzbl -0x1(%rbp),%ecx\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     2047 <assert_bytes+0xdb>\nmov    $0x1,%edi\ncall   2736 <libmin_fail>\nmovzbl -0x1(%rbp),%eax\nadd    $0x1,%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\ncmp    -0x24(%rbp),%al\njb     1ff6 <assert_bytes+0x8a>\nlea    0x3102(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4c1b <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "blake2b", "content": "/**\n * @brief blake2b hash function\n *\n * This is the front-end function that sets up the argument for BLAKE2B().\n *\n * @param message the message to be hashed\n * @param len length of message (0 <= len < 2**128) (depends on sizeof(size_t)\n * for this implementation)\n * @param key optional secret key\n * @param kk length of optional secret key (0 <= kk <= 64)\n * @param nn length of output digest (1 <= nn < 64)\n *\n * @returns NULL if heap memory couldn't be allocated. Otherwise heap allocated\n * memory nn bytes large\n */\nuint8_t *blake2b(const uint8_t *message, size_t len, const uint8_t *key,\n                 uint8_t kk, uint8_t nn)\n{\n    uint8_t *dest = NULL;\n    uint64_t long_hold;\n    size_t dd, has_key, i;\n    size_t block_index, word_in_block;\n    u128 ll;\n    block_t *blocks;\n\n    if (message == NULL)\n    {\n        len = 0;\n    }\n    if (key == NULL)\n    {\n        kk = 0;\n    }\n\n    kk = MIN(kk, KK_MAX);\n    nn = MIN(nn, NN_MAX);\n\n    dd = MAX(CEIL(kk, bb) + CEIL(len, bb), 1);\n\n    blocks = libmin_calloc(dd, sizeof(block_t));\n    if (blocks == NULL)\n    {\n        return NULL;\n    }\n\n    dest = libmin_malloc(nn * sizeof(uint8_t));\n    if (dest == NULL)\n    {\n        libmin_free(blocks);\n        return NULL;\n    }\n\n    /* If there is a secret key it occupies the first block */\n    for (i = 0; i < kk; i++)\n    {\n        long_hold = key[i];\n        long_hold <<= 8 * (i % 8);\n\n        word_in_block = (i % bb) / 8;\n        /* block_index will always be 0 because kk <= 64 and bb = 128*/\n        blocks[0][word_in_block] |= long_hold;\n    }\n\n    has_key = kk > 0 ? 1 : 0;\n\n    for (i = 0; i < len; i++)\n    {\n        /* long_hold exists because the bit-shifting will overflow if we don't\n         * store the value */\n        long_hold = message[i];\n        long_hold <<= 8 * (i % 8);\n\n        block_index = has_key + (i / bb);\n        word_in_block = (i % bb) / 8;\n\n        blocks[block_index][word_in_block] |= long_hold;\n    }\n\n    u128_fill(ll, len);\n\n    BLAKE2B(dest, blocks, dd, ll, kk, nn);\n\n    libmin_free(blocks);\n\n    return dest;\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O0.pseudo", "function_name": "blake2b", "address": "0x1cd3", "label": "blake2b", "content": "uint8_t *__cdecl blake2b(const uint8_t *message, size_t len, const uint8_t *key, uint8_t kk, uint8_t nn)\n{\n  uint8_t v5; // al\n  uint8_t v6; // al\n  size_t v7; // rax\n  uint8_t nna; // [rsp+0h] [rbp-80h]\n  uint8_t kkb; // [rsp+4h] [rbp-7Ch]\n  size_t i; // [rsp+20h] [rbp-60h]\n  size_t ia; // [rsp+20h] [rbp-60h]\n  uint8_t *dest; // [rsp+28h] [rbp-58h]\n  size_t dd; // [rsp+30h] [rbp-50h]\n  uint64_t *blocks; // [rsp+38h] [rbp-48h]\n  uint64_t ll[3]; // [rsp+60h] [rbp-20h] BYREF\n  unsigned __int64 v20; // [rsp+78h] [rbp-8h]\n\n  v20 = __readfsqword(0x28u);\n  if ( !message )\n    len = 0LL;\n  if ( !key )\n    kk = 0;\n  v5 = kk;\n  if ( kk > 0x40u )\n    v5 = 64;\n  kkb = v5;\n  v6 = nn;\n  if ( nn > 0x40u )\n    v6 = 64;\n  nna = v6;\n  v7 = (kkb >> 7) + ((kkb & 0x7F) != 0) + (len >> 7) + ((len & 0x7F) != 0);\n  if ( !v7 )\n    v7 = 1LL;\n  dd = v7;\n  blocks = (uint64_t *)libmin_calloc(v7, 0x80uLL);\n  if ( !blocks )\n    return 0LL;\n  dest = (uint8_t *)libmin_malloc(nna);\n  if ( dest )\n  {\n    for ( i = 0LL; i < kkb; ++i )\n      blocks[(i & 0x7F) >> 3] |= (unsigned __int64)key[i] << (8 * ((unsigned __int8)i & 7u));\n    for ( ia = 0LL; ia < len; ++ia )\n      blocks[16 * (ia >> 7) + 16 * (kkb != 0) + ((ia & 0x7F) >> 3)] |= (unsigned __int64)message[ia] << (8 * ((unsigned __int8)ia & 7u));\n    u128_fill(ll, len);\n    BLAKE2B(dest, (block_t *)blocks, dd, ll, kkb, nna);\n    libmin_free(blocks);\n    return dest;\n  }\n  else\n  {\n    libmin_free(blocks);\n    return 0LL;\n  }\n}\n"}, "pseudo_normalize": "uint8_t *blake2b(const uint8_t *message, unsigned int len, const uint8_t *key,\n                 uint8_t kk, uint8_t nn) {\n  uint8_t v5;\n  uint8_t v6;\n  unsigned int v7;\n  uint8_t nna;\n  uint8_t kkb;\n  unsigned int i;\n  unsigned int ia;\n  uint8_t *dest;\n  unsigned int dd;\n  uint64_t *blocks;\n  uint64_t ll[3];\n  unsigned long long v20;\n  v20 = __readfsqword(40u);\n  if (!message) len = 0LL;\n  if (!key) kk = 0;\n  v5 = kk;\n  if (kk > 64u) v5 = 64;\n  kkb = v5;\n  v6 = nn;\n  if (nn > 64u) v6 = 64;\n  nna = v6;\n  v7 = (kkb >> 7) + ((kkb & 127) != 0) + (len >> 7) + ((len & 127) != 0);\n  if (!v7) v7 = 1LL;\n  dd = v7;\n  blocks = (uint64_t *)libmin_calloc(v7, 128uLL);\n  if (!blocks) return 0LL;\n  dest = (uint8_t *)libmin_malloc(nna);\n  if (dest) {\n    for (i = 0LL; i < kkb; ++i)\n      blocks[(i & 127) >> 3] |= (unsigned long long)key[i]\n                                << (8 * ((unsigned char)i & 7u));\n    for (ia = 0LL; ia < len; ++ia)\n      blocks[16 * (ia >> 7) + 16 * (kkb != 0) + ((ia & 127) >> 3)] |=\n          (unsigned long long)message[ia] << (8 * ((unsigned char)ia & 7u));\n    u128_fill(ll, len);\n    BLAKE2B(dest, (block_t *)blocks, dd, ll, kkb, nna);\n    libmin_free(blocks);\n    return dest;\n  } else {\n    libmin_free(blocks);\n    return 0LL;\n  }\n}", "binary": "blake2b/blake2b.host.O0", "assembly": "<blake2b>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x68(%rbp)\nmov    %rsi,-0x70(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    %ecx,%eax\nmov    %r8d,%edx\nmov    %al,-0x7c(%rbp)\nmov    %edx,%eax\nmov    %al,-0x80(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x58(%rbp)\ncmpq   $0x0,-0x68(%rbp)\njne    1d1e <blake2b+0x4b>\nmovq   $0x0,-0x70(%rbp)\ncmpq   $0x0,-0x78(%rbp)\njne    1d29 <blake2b+0x56>\nmovb   $0x0,-0x7c(%rbp)\nmovzbl -0x7c(%rbp),%eax\nmov    $0x40,%edx\ncmp    %dl,%al\ncmova  %edx,%eax\nmov    %al,-0x7c(%rbp)\nmovzbl -0x80(%rbp),%eax\nmov    $0x40,%edx\ncmp    %dl,%al\ncmova  %edx,%eax\nmov    %al,-0x80(%rbp)\nmovzbl -0x7c(%rbp),%eax\nshr    $0x7,%al\nmovzbl %al,%edx\nmovzbl -0x7c(%rbp),%eax\nand    $0x7f,%eax\ntest   %al,%al\nsetne  %al\nmovzbl %al,%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x70(%rbp),%rax\nshr    $0x7,%rax\nmov    %rax,%rcx\nmov    -0x70(%rbp),%rax\nand    $0x7f,%eax\ntest   %rax,%rax\nsetne  %al\nmovzbl %al,%eax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmov    $0x1,%edx\ntest   %rax,%rax\ncmove  %rdx,%rax\nmov    %rax,-0x50(%rbp)\nmov    -0x50(%rbp),%rax\nmov    $0x80,%esi\nmov    %rax,%rdi\ncall   2995 <libmin_calloc>\nmov    %rax,-0x48(%rbp)\ncmpq   $0x0,-0x48(%rbp)\njne    1dc0 <blake2b+0xed>\nmov    $0x0,%eax\njmp    1f56 <blake2b+0x283>\nmovzbl -0x80(%rbp),%eax\nmov    %rax,%rdi\ncall   27b9 <libmin_malloc>\nmov    %rax,-0x58(%rbp)\ncmpq   $0x0,-0x58(%rbp)\njne    1ded <blake2b+0x11a>\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncall   28a4 <libmin_free>\nmov    $0x0,%eax\njmp    1f56 <blake2b+0x283>\nmovq   $0x0,-0x60(%rbp)\njmp    1e4f <blake2b+0x17c>\nmov    -0x78(%rbp),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %rax,-0x38(%rbp)\nmov    -0x60(%rbp),%rax\nand    $0x7,%eax\nshl    $0x3,%eax\nmov    %eax,%ecx\nshlq   %cl,-0x38(%rbp)\nmov    -0x60(%rbp),%rax\nand    $0x7f,%eax\nshr    $0x3,%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x48(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nmov    (%rax,%rdx,8),%rax\nor     -0x38(%rbp),%rax\nmov    %rax,%rcx\nmov    -0x48(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rcx,(%rax,%rdx,8)\naddq   $0x1,-0x60(%rbp)\nmovzbl -0x7c(%rbp),%eax\ncmp    %rax,-0x60(%rbp)\njb     1df7 <blake2b+0x124>\ncmpb   $0x0,-0x7c(%rbp)\nsetne  %al\nmovzbl %al,%eax\nmov    %rax,-0x40(%rbp)\nmovq   $0x0,-0x60(%rbp)\njmp    1efe <blake2b+0x22b>\nmov    -0x68(%rbp),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %rax,-0x38(%rbp)\nmov    -0x60(%rbp),%rax\nand    $0x7,%eax\nshl    $0x3,%eax\nmov    %eax,%ecx\nshlq   %cl,-0x38(%rbp)\nmov    -0x60(%rbp),%rax\nshr    $0x7,%rax\nmov    %rax,%rdx\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x60(%rbp),%rax\nand    $0x7f,%eax\nshr    $0x3,%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x7,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    (%rdx,%rax,8),%rax\nmov    -0x30(%rbp),%rdx\nmov    %rdx,%rcx\nshl    $0x7,%rcx\nmov    -0x48(%rbp),%rdx\nadd    %rdx,%rcx\nor     -0x38(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,(%rcx,%rax,8)\naddq   $0x1,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\ncmp    -0x70(%rbp),%rax\njb     1e74 <blake2b+0x1a1>\nmov    -0x70(%rbp),%rdx\nlea    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <u128_fill>\nmovzbl -0x80(%rbp),%r8d\nmovzbl -0x7c(%rbp),%edi\nlea    -0x20(%rbp),%rcx\nmov    -0x50(%rbp),%rdx\nmov    -0x48(%rbp),%rsi\nmov    -0x58(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1a9b <BLAKE2B>\nmov    -0x48(%rbp),%rax\nmov    %rax,%rdi\ncall   28a4 <libmin_free>\nmov    -0x58(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1f6a <blake2b+0x297>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "main", "content": "/**\n * @brief main function\n *\n * @returns 0 on successful program exit\n */\nint main()\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O0.pseudo", "function_name": "main", "address": "0x25d6", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  test();\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "blake2b/blake2b.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x0,%eax\ncall   2071 <test>\ncall   4e88 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "test", "content": "/**\n * @brief testing function\n *\n * @returns void\n */\nstatic void test()\n{\n    uint8_t *digest = NULL;\n\n    /* \"abc\" example straight out of RFC-7693 */\n    uint8_t abc[3] = {'a', 'b', 'c'};\n    uint8_t abc_answer[64] = {\n        0xBA, 0x80, 0xA5, 0x3F, 0x98, 0x1C, 0x4D, 0x0D, 0x6A, 0x27, 0x97,\n        0xB6, 0x9F, 0x12, 0xF6, 0xE9, 0x4C, 0x21, 0x2F, 0x14, 0x68, 0x5A,\n        0xC4, 0xB7, 0x4B, 0x12, 0xBB, 0x6F, 0xDB, 0xFF, 0xA2, 0xD1, 0x7D,\n        0x87, 0xC5, 0x39, 0x2A, 0xAB, 0x79, 0x2D, 0xC2, 0x52, 0xD5, 0xDE,\n        0x45, 0x33, 0xCC, 0x95, 0x18, 0xD3, 0x8A, 0xA8, 0xDB, 0xF1, 0x92,\n        0x5A, 0xB9, 0x23, 0x86, 0xED, 0xD4, 0x00, 0x99, 0x23};\n\n    digest = blake2b(abc, 3, NULL, 0, 64);\n    assert_bytes(abc_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t key_answer[64] = {\n        0x10, 0xeb, 0xb6, 0x77, 0x00, 0xb1, 0x86, 0x8e, 0xfb, 0x44, 0x17,\n        0x98, 0x7a, 0xcf, 0x46, 0x90, 0xae, 0x9d, 0x97, 0x2f, 0xb7, 0xa5,\n        0x90, 0xc2, 0xf0, 0x28, 0x71, 0x79, 0x9a, 0xaa, 0x47, 0x86, 0xb5,\n        0xe9, 0x96, 0xe8, 0xf0, 0xf4, 0xeb, 0x98, 0x1f, 0xc2, 0x14, 0xb0,\n        0x05, 0xf4, 0x2d, 0x2f, 0xf4, 0x23, 0x34, 0x99, 0x39, 0x16, 0x53,\n        0xdf, 0x7a, 0xef, 0xcb, 0xc1, 0x3f, 0xc5, 0x15, 0x68};\n\n    digest = blake2b(NULL, 0, key, 64, 64);\n    assert_bytes(key_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t zero[1] = {0};\n    uint8_t zero_key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t zero_answer[64] = {\n        0x96, 0x1f, 0x6d, 0xd1, 0xe4, 0xdd, 0x30, 0xf6, 0x39, 0x01, 0x69,\n        0x0c, 0x51, 0x2e, 0x78, 0xe4, 0xb4, 0x5e, 0x47, 0x42, 0xed, 0x19,\n        0x7c, 0x3c, 0x5e, 0x45, 0xc5, 0x49, 0xfd, 0x25, 0xf2, 0xe4, 0x18,\n        0x7b, 0x0b, 0xc9, 0xfe, 0x30, 0x49, 0x2b, 0x16, 0xb0, 0xd0, 0xbc,\n        0x4e, 0xf9, 0xb0, 0xf3, 0x4c, 0x70, 0x03, 0xfa, 0xc0, 0x9a, 0x5e,\n        0xf1, 0x53, 0x2e, 0x69, 0x43, 0x02, 0x34, 0xce, 0xbd};\n\n    digest = blake2b(zero, 1, zero_key, 64, 64);\n    assert_bytes(zero_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t filled[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t filled_key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t filled_answer[64] = {\n        0x65, 0x67, 0x6d, 0x80, 0x06, 0x17, 0x97, 0x2f, 0xbd, 0x87, 0xe4,\n        0xb9, 0x51, 0x4e, 0x1c, 0x67, 0x40, 0x2b, 0x7a, 0x33, 0x10, 0x96,\n        0xd3, 0xbf, 0xac, 0x22, 0xf1, 0xab, 0xb9, 0x53, 0x74, 0xab, 0xc9,\n        0x42, 0xf1, 0x6e, 0x9a, 0xb0, 0xea, 0xd3, 0x3b, 0x87, 0xc9, 0x19,\n        0x68, 0xa6, 0xe5, 0x09, 0xe1, 0x19, 0xff, 0x07, 0x78, 0x7b, 0x3e,\n        0xf4, 0x83, 0xe1, 0xdc, 0xdc, 0xcf, 0x6e, 0x30, 0x22};\n\n    digest = blake2b(filled, 64, filled_key, 64, 64);\n    assert_bytes(filled_answer, digest, 64);\n\n    libmin_free(digest);\n\n    libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O0.pseudo", "function_name": "test", "address": "0x2071", "label": "test", "content": "// local variable allocation has failed, the output may be wrong!\nvoid __cdecl test()\n{\n  uint8_t *v0; // rsi\n  uint8_t *digest; // [rsp+0h] [rbp-240h]\n  uint8_t *digesta; // [rsp+0h] [rbp-240h]\n  uint8_t *digestb; // [rsp+0h] [rbp-240h]\n  uint8_t zero[1]; // [rsp+Ch] [rbp-234h] BYREF\n  uint8_t abc[3]; // [rsp+Dh] [rbp-233h] BYREF\n  uint8_t abc_answer[64]; // [rsp+10h] [rbp-230h] BYREF\n  uint8_t key[64]; // [rsp+50h] [rbp-1F0h] BYREF\n  uint8_t key_answer[64]; // [rsp+90h] [rbp-1B0h] BYREF\n  uint8_t zero_key[64]; // [rsp+D0h] [rbp-170h] BYREF\n  uint8_t zero_answer[64]; // [rsp+110h] [rbp-130h] BYREF\n  _BYTE filled[128]; // [rsp+150h] [rbp-F0h] OVERLAPPED BYREF\n  uint8_t filled_answer[64]; // [rsp+1D0h] [rbp-70h] BYREF\n  unsigned __int64 v13; // [rsp+218h] [rbp-28h]\n\n  v13 = __readfsqword(0x28u);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(_QWORD *)abc_answer = 0xD4D1C983FA580BALL;\n  *(_QWORD *)&abc_answer[8] = 0xE9F6129FB697276ALL;\n  *(_QWORD *)&abc_answer[16] = 0xB7C45A68142F214CLL;\n  *(_QWORD *)&abc_answer[24] = 0xD1A2FFDB6FBB124BLL;\n  *(_QWORD *)&abc_answer[32] = 0x2D79AB2A39C5877DLL;\n  *(_QWORD *)&abc_answer[40] = 0x95CC3345DED552C2LL;\n  *(_QWORD *)&abc_answer[48] = 0x5A92F1DBA88AD318LL;\n  *(_QWORD *)&abc_answer[56] = 0x239900D4ED8623B9LL;\n  digest = blake2b(abc, 3uLL, 0LL, 0, 0x40u);\n  assert_bytes(abc_answer, digest, 0x40u);\n  libmin_free(digest);\n  *(_QWORD *)key = 0x706050403020100LL;\n  *(_QWORD *)&key[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&key[16] = 0x1716151413121110LL;\n  *(_QWORD *)&key[24] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&key[32] = 0x2726252423222120LL;\n  *(_QWORD *)&key[40] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&key[48] = 0x3736353433323130LL;\n  *(_QWORD *)&key[56] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)key_answer = 0x8E86B10077B6EB10LL;\n  *(_QWORD *)&key_answer[8] = 0x9046CF7A981744FBLL;\n  *(_QWORD *)&key_answer[16] = 0xC290A5B72F979DAELL;\n  *(_QWORD *)&key_answer[24] = 0x8647AA9A797128F0LL;\n  *(_QWORD *)&key_answer[32] = 0x98EBF4F0E896E9B5LL;\n  *(_QWORD *)&key_answer[40] = 0x2F2DF405B014C21FLL;\n  *(_QWORD *)&key_answer[48] = 0xDF531639993423F4LL;\n  *(_QWORD *)&key_answer[56] = 0x6815C53FC1CBEF7ALL;\n  digesta = blake2b(0LL, 0LL, key, 0x40u, 0x40u);\n  assert_bytes(key_answer, digesta, 0x40u);\n  libmin_free(digesta);\n  zero[0] = 0;\n  *(_QWORD *)zero_key = 0x706050403020100LL;\n  *(_QWORD *)&zero_key[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&zero_key[16] = 0x1716151413121110LL;\n  *(_QWORD *)&zero_key[24] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&zero_key[32] = 0x2726252423222120LL;\n  *(_QWORD *)&zero_key[40] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&zero_key[48] = 0x3736353433323130LL;\n  *(_QWORD *)&zero_key[56] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)zero_answer = 0xF630DDE4D16D1F96LL;\n  *(_QWORD *)&zero_answer[8] = 0xE4782E510C690139LL;\n  *(_QWORD *)&zero_answer[16] = 0x3C7C19ED42475EB4LL;\n  *(_QWORD *)&zero_answer[24] = 0xE4F225FD49C5455ELL;\n  *(_QWORD *)&zero_answer[32] = 0x2B4930FEC90B7B18LL;\n  *(_QWORD *)&zero_answer[40] = 0xF3B0F94EBCD0B016LL;\n  *(_QWORD *)&zero_answer[48] = 0xF15E9AC0FA03704CLL;\n  *(_QWORD *)&zero_answer[56] = 0xBDCE340243692E53LL;\n  digestb = blake2b(zero, 1uLL, zero_key, 0x40u, 0x40u);\n  assert_bytes(zero_answer, digestb, 0x40u);\n  libmin_free(digestb);\n  *(_QWORD *)filled = 0x706050403020100LL;\n  *(_QWORD *)&filled[8] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&filled[16] = 0x1716151413121110LL;\n  *(_QWORD *)&filled[24] = 0x1F1E1D1C1B1A1918LL;\n  strcpy(&filled[32], \" !\\\"#$%&'()*+,-./0123456789:;<=>?\");\n  filled[65] = 1;\n  *(_WORD *)&filled[66] = 770;\n  *(_DWORD *)&filled[68] = 117835012;\n  *(_QWORD *)&filled[72] = 0xF0E0D0C0B0A0908LL;\n  *(_QWORD *)&filled[80] = 0x1716151413121110LL;\n  *(_QWORD *)&filled[88] = 0x1F1E1D1C1B1A1918LL;\n  *(_QWORD *)&filled[96] = 0x2726252423222120LL;\n  *(_QWORD *)&filled[104] = 0x2F2E2D2C2B2A2928LL;\n  *(_QWORD *)&filled[112] = 0x3736353433323130LL;\n  *(_QWORD *)&filled[120] = 0x3F3E3D3C3B3A3938LL;\n  *(_QWORD *)filled_answer = 0x2F971706806D6765LL;\n  *(_QWORD *)&filled_answer[8] = 0x671C4E51B9E487BDLL;\n  *(_QWORD *)&filled_answer[16] = 0xBFD39610337A2B40LL;\n  *(_QWORD *)&filled_answer[24] = 0xAB7453B9ABF122ACLL;\n  *(_QWORD *)&filled_answer[32] = 0xD3EAB09A6EF142C9LL;\n  *(_QWORD *)&filled_answer[40] = 0x9E5A66819C9873BLL;\n  *(_QWORD *)&filled_answer[48] = 0xF43E7B7807FF19E1LL;\n  *(_QWORD *)&filled_answer[56] = 0x22306ECFDCDCE183LL;\n  v0 = blake2b(filled, 0x40uLL, &filled[64], 0x40u, 0x40u);\n  assert_bytes(filled_answer, v0, 0x40u);\n  libmin_free(v0);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}\n"}, "pseudo_normalize": "void test() {\n  uint8_t *v0;\n  uint8_t *digest;\n  uint8_t *digesta;\n  uint8_t *digestb;\n  uint8_t zero[1];\n  uint8_t abc[3];\n  uint8_t abc_answer[64];\n  uint8_t key[64];\n  uint8_t key_answer[64];\n  uint8_t zero_key[64];\n  uint8_t zero_answer[64];\n  uint8_t filled[128];\n  uint8_t filled_answer[64];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(uint64_t *)abc_answer = 958453735928201402LL;\n  *(uint64_t *)&abc_answer[8] = 16858682732280489834LL;\n  *(uint64_t *)&abc_answer[16] = 13241808207437832524LL;\n  *(uint64_t *)&abc_answer[24] = 15105917418091516491LL;\n  *(uint64_t *)&abc_answer[32] = 3276838401734969213LL;\n  *(uint64_t *)&abc_answer[40] = 10794058782084518594LL;\n  *(uint64_t *)&abc_answer[48] = 6526544735741072152LL;\n  *(uint64_t *)&abc_answer[56] = 2565082377282266041LL;\n  digest = blake2b(abc, 3uLL, 0LL, 0, 64u);\n  assert_bytes(abc_answer, digest, 64u);\n  libmin_free(digest);\n  *(uint64_t *)key = 506097522914230528LL;\n  *(uint64_t *)&key[8] = 1084818905618843912LL;\n  *(uint64_t *)&key[16] = 1663540288323457296LL;\n  *(uint64_t *)&key[24] = 2242261671028070680LL;\n  *(uint64_t *)&key[32] = 2820983053732684064LL;\n  *(uint64_t *)&key[40] = 3399704436437297448LL;\n  *(uint64_t *)&key[48] = 3978425819141910832LL;\n  *(uint64_t *)&key[56] = 4557147201846524216LL;\n  *(uint64_t *)key_answer = 10270090615831587600LL;\n  *(uint64_t *)&key_answer[8] = 10396224915275990267LL;\n  *(uint64_t *)&key_answer[16] = 14019887846200417710LL;\n  *(uint64_t *)&key_answer[24] = 9675889904867944688LL;\n  *(uint64_t *)&key_answer[32] = 11019170228823583157LL;\n  *(uint64_t *)&key_answer[40] = 3399641599000756767LL;\n  *(uint64_t *)&key_answer[48] = 16092230330164192244LL;\n  *(uint64_t *)&key_answer[56] = 7500117632080408442LL;\n  digesta = blake2b(0LL, 0LL, key, 64u, 64u);\n  assert_bytes(key_answer, digesta, 64u);\n  libmin_free(digesta);\n  zero[0] = 0;\n  *(uint64_t *)zero_key = 506097522914230528LL;\n  *(uint64_t *)&zero_key[8] = 1084818905618843912LL;\n  *(uint64_t *)&zero_key[16] = 1663540288323457296LL;\n  *(uint64_t *)&zero_key[24] = 2242261671028070680LL;\n  *(uint64_t *)&zero_key[32] = 2820983053732684064LL;\n  *(uint64_t *)&zero_key[40] = 3399704436437297448LL;\n  *(uint64_t *)&zero_key[48] = 3978425819141910832LL;\n  *(uint64_t *)&zero_key[56] = 4557147201846524216LL;\n  *(uint64_t *)zero_answer = 17739922907048255382LL;\n  *(uint64_t *)&zero_answer[8] = 16462959363488284985LL;\n  *(uint64_t *)&zero_answer[16] = 4358387046197714612LL;\n  *(uint64_t *)&zero_answer[24] = 16497290154806166878LL;\n  *(uint64_t *)&zero_answer[32] = 3119078087783578392LL;\n  *(uint64_t *)&zero_answer[40] = 17559809063688122390LL;\n  *(uint64_t *)&zero_answer[48] = 17392508964570361932LL;\n  *(uint64_t *)&zero_answer[56] = 13676926302696320595LL;\n  digestb = blake2b(zero, 1uLL, zero_key, 64u, 64u);\n  assert_bytes(zero_answer, digestb, 64u);\n  libmin_free(digestb);\n  *(uint64_t *)filled = 506097522914230528LL;\n  *(uint64_t *)&filled[8] = 1084818905618843912LL;\n  *(uint64_t *)&filled[16] = 1663540288323457296LL;\n  *(uint64_t *)&filled[24] = 2242261671028070680LL;\n  strcpy(&filled[32], \" !\\\"#$%&'()*+,-./0123456789:;<=>?\");\n  filled[65] = 1;\n  *(unsigned short *)&filled[66] = 770;\n  *(uint32_t *)&filled[68] = 117835012;\n  *(uint64_t *)&filled[72] = 1084818905618843912LL;\n  *(uint64_t *)&filled[80] = 1663540288323457296LL;\n  *(uint64_t *)&filled[88] = 2242261671028070680LL;\n  *(uint64_t *)&filled[96] = 2820983053732684064LL;\n  *(uint64_t *)&filled[104] = 3399704436437297448LL;\n  *(uint64_t *)&filled[112] = 3978425819141910832LL;\n  *(uint64_t *)&filled[120] = 4557147201846524216LL;\n  *(uint64_t *)filled_answer = 3429234957957818213LL;\n  *(uint64_t *)&filled_answer[8] = 7429899598172555197LL;\n  *(uint64_t *)&filled_answer[16] = 13822556677657471808LL;\n  *(uint64_t *)&filled_answer[24] = 12354591734702875308LL;\n  *(uint64_t *)&filled_answer[32] = 15270211663885845193LL;\n  *(uint64_t *)&filled_answer[40] = 713159082047539003LL;\n  *(uint64_t *)&filled_answer[48] = 17599640149270927841LL;\n  *(uint64_t *)&filled_answer[56] = 2463590835214410115LL;\n  v0 = blake2b(filled, 64uLL, &filled[64], 64u, 64u);\n  assert_bytes(filled_answer, v0, 64u);\n  libmin_free(v0);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}", "binary": "blake2b/blake2b.host.O0", "assembly": "<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nsub    $0x220,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x28(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x240(%rbp)\nmovw   $0x6261,-0x233(%rbp)\nmovb   $0x63,-0x231(%rbp)\nmovabs $0xd4d1c983fa580ba,%rax\nmovabs $0xe9f6129fb697276a,%rdx\nmov    %rax,-0x230(%rbp)\nmov    %rdx,-0x228(%rbp)\nmovabs $0xb7c45a68142f214c,%rax\nmovabs $0xd1a2ffdb6fbb124b,%rdx\nmov    %rax,-0x220(%rbp)\nmov    %rdx,-0x218(%rbp)\nmovabs $0x2d79ab2a39c5877d,%rax\nmovabs $0x95cc3345ded552c2,%rdx\nmov    %rax,-0x210(%rbp)\nmov    %rdx,-0x208(%rbp)\nmovabs $0x5a92f1dba88ad318,%rax\nmovabs $0x239900d4ed8623b9,%rdx\nmov    %rax,-0x200(%rbp)\nmov    %rdx,-0x1f8(%rbp)\nlea    -0x233(%rbp),%rax\nmov    $0x40,%r8d\nmov    $0x0,%ecx\nmov    $0x0,%edx\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   1cd3 <blake2b>\nmov    %rax,-0x240(%rbp)\nmov    -0x240(%rbp),%rcx\nlea    -0x230(%rbp),%rax\nmov    $0x40,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f6c <assert_bytes>\nmov    -0x240(%rbp),%rax\nmov    %rax,%rdi\ncall   28a4 <libmin_free>\nmovabs $0x706050403020100,%r14\nmovabs $0xf0e0d0c0b0a0908,%r15\nmov    %r14,-0x1f0(%rbp)\nmov    %r15,-0x1e8(%rbp)\nmovabs $0x1716151413121110,%r12\nmovabs $0x1f1e1d1c1b1a1918,%r13\nmov    %r12,-0x1e0(%rbp)\nmov    %r13,-0x1d8(%rbp)\nmovabs $0x2726252423222120,%rax\nmovabs $0x2f2e2d2c2b2a2928,%rdx\nmov    %rax,-0x1d0(%rbp)\nmov    %rdx,-0x1c8(%rbp)\nmovabs $0x3736353433323130,%rsi\nmovabs $0x3f3e3d3c3b3a3938,%rdi\nmov    %rsi,-0x1c0(%rbp)\nmov    %rdi,-0x1b8(%rbp)\nmovabs $0x8e86b10077b6eb10,%rdx\nmovabs $0x9046cf7a981744fb,%rcx\nmov    %rdx,-0x1b0(%rbp)\nmov    %rcx,-0x1a8(%rbp)\nmovabs $0xc290a5b72f979dae,%rdx\nmovabs $0x8647aa9a797128f0,%rcx\nmov    %rdx,-0x1a0(%rbp)\nmov    %rcx,-0x198(%rbp)\nmovabs $0x98ebf4f0e896e9b5,%rdx\nmovabs $0x2f2df405b014c21f,%rcx\nmov    %rdx,-0x190(%rbp)\nmov    %rcx,-0x188(%rbp)\nmovabs $0xdf531639993423f4,%rdx\nmovabs $0x6815c53fc1cbef7a,%rcx\nmov    %rdx,-0x180(%rbp)\nmov    %rcx,-0x178(%rbp)\nlea    -0x1f0(%rbp),%rax\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmov    %rax,%rdx\nmov    $0x0,%esi\nmov    $0x0,%edi\ncall   1cd3 <blake2b>\nmov    %rax,-0x240(%rbp)\nmov    -0x240(%rbp),%rcx\nlea    -0x1b0(%rbp),%rax\nmov    $0x40,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f6c <assert_bytes>\nmov    -0x240(%rbp),%rax\nmov    %rax,%rdi\ncall   28a4 <libmin_free>\nmovb   $0x0,-0x234(%rbp)\nmov    %r14,-0x170(%rbp)\nmov    %r15,-0x168(%rbp)\nmov    %r12,-0x160(%rbp)\nmov    %r13,-0x158(%rbp)\nmovabs $0x2726252423222120,%rax\nmovabs $0x2f2e2d2c2b2a2928,%rdx\nmov    %rax,-0x150(%rbp)\nmov    %rdx,-0x148(%rbp)\nmovabs $0x3736353433323130,%rsi\nmovabs $0x3f3e3d3c3b3a3938,%rdi\nmov    %rsi,-0x140(%rbp)\nmov    %rdi,-0x138(%rbp)\nmovabs $0xf630dde4d16d1f96,%rdx\nmovabs $0xe4782e510c690139,%rcx\nmov    %rdx,-0x130(%rbp)\nmov    %rcx,-0x128(%rbp)\nmovabs $0x3c7c19ed42475eb4,%rdx\nmovabs $0xe4f225fd49c5455e,%rcx\nmov    %rdx,-0x120(%rbp)\nmov    %rcx,-0x118(%rbp)\nmovabs $0x2b4930fec90b7b18,%rdx\nmovabs $0xf3b0f94ebcd0b016,%rcx\nmov    %rdx,-0x110(%rbp)\nmov    %rcx,-0x108(%rbp)\nmovabs $0xf15e9ac0fa03704c,%rdx\nmovabs $0xbdce340243692e53,%rcx\nmov    %rdx,-0x100(%rbp)\nmov    %rcx,-0xf8(%rbp)\nlea    -0x170(%rbp),%rdx\nlea    -0x234(%rbp),%rax\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   1cd3 <blake2b>\nmov    %rax,-0x240(%rbp)\nmov    -0x240(%rbp),%rcx\nlea    -0x130(%rbp),%rax\nmov    $0x40,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f6c <assert_bytes>\nmov    -0x240(%rbp),%rax\nmov    %rax,%rdi\ncall   28a4 <libmin_free>\nmov    %r14,-0xf0(%rbp)\nmov    %r15,-0xe8(%rbp)\nmov    %r12,-0xe0(%rbp)\nmov    %r13,-0xd8(%rbp)\nmovabs $0x2726252423222120,%rax\nmovabs $0x2f2e2d2c2b2a2928,%rdx\nmov    %rax,-0xd0(%rbp)\nmov    %rdx,-0xc8(%rbp)\nmovabs $0x3736353433323130,%rsi\nmovabs $0x3f3e3d3c3b3a3938,%rdi\nmov    %rsi,-0xc0(%rbp)\nmov    %rdi,-0xb8(%rbp)\nmov    %r14,-0xb0(%rbp)\nmov    %r15,-0xa8(%rbp)\nmov    %r12,-0xa0(%rbp)\nmov    %r13,-0x98(%rbp)\nmov    %rax,-0x90(%rbp)\nmov    %rdx,-0x88(%rbp)\nmov    %rsi,-0x80(%rbp)\nmov    %rdi,-0x78(%rbp)\nmovabs $0x2f971706806d6765,%rax\nmovabs $0x671c4e51b9e487bd,%rdx\nmov    %rax,-0x70(%rbp)\nmov    %rdx,-0x68(%rbp)\nmovabs $0xbfd39610337a2b40,%rax\nmovabs $0xab7453b9abf122ac,%rdx\nmov    %rax,-0x60(%rbp)\nmov    %rdx,-0x58(%rbp)\nmovabs $0xd3eab09a6ef142c9,%rax\nmovabs $0x9e5a66819c9873b,%rdx\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmovabs $0xf43e7b7807ff19e1,%rax\nmovabs $0x22306ecfdcdce183,%rdx\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nlea    -0xb0(%rbp),%rdx\nlea    -0xf0(%rbp),%rax\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmov    $0x40,%esi\nmov    %rax,%rdi\ncall   1cd3 <blake2b>\nmov    %rax,-0x240(%rbp)\nmov    -0x240(%rbp),%rcx\nlea    -0x70(%rbp),%rax\nmov    $0x40,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f6c <assert_bytes>\nmov    -0x240(%rbp),%rax\nmov    %rax,%rdi\ncall   28a4 <libmin_free>\nlea    0x2bc5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4c1b <libmin_printf>\nnop\nmov    -0x28(%rbp),%rax\nsub    %fs:0x28,%rax\nje     25c5 <test+0x554>\ncall   10b0 <__stack_chk_fail@plt>\nadd    $0x220,%rsp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "u128_fill", "content": "  ///< word schedule permutations for each round of the algorithm\n\n/**\n * @brief put value of n into dest\n *\n * @param dest 128-bit number to get copied from n\n * @param n value put into dest\n *\n * @returns void\n */\nstatic inline void u128_fill(u128 dest, size_t n)\n{\n    dest[0] = n & UINT64_MAX;\n\n    libmin_assert(sizeof(n) <= 8);\n    dest[1] = 0;\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O0.pseudo", "function_name": "u128_fill", "address": "0x11e9", "label": "u128_fill", "content": "void __cdecl u128_fill(uint64_t *dest, size_t n)\n{\n  *dest = n;\n  dest[1] = 0LL;\n}\n"}, "pseudo_normalize": "", "binary": "blake2b/blake2b.host.O0", "assembly": "<u128_fill>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmovq   $0x0,(%rax)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "u128_increment", "content": "/**\n * @brief increment an 128-bit number by a given amount\n *\n * @param dest the value being incremented\n * @param n what dest is being increased by\n *\n * @returns void\n */\nstatic inline void u128_increment(u128 dest, uint64_t n)\n{\n    /* Check for overflow */\n    if (UINT64_MAX - dest[0] <= n)\n    {\n        dest[1]++;\n    }\n\n    dest[0] += n;\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O0.pseudo", "function_name": "u128_increment", "address": "0x1212", "label": "u128_increment", "content": "void __cdecl u128_increment(uint64_t *dest, uint64_t n)\n{\n  if ( n >= ~*dest )\n    ++dest[1];\n  *dest += n;\n}\n"}, "pseudo_normalize": "", "binary": "blake2b/blake2b.host.O0", "assembly": "<u128_increment>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nnot    %rax\ncmp    %rax,-0x10(%rbp)\njb     1240 <u128_increment+0x2e>\nmov    -0x8(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rdx\nadd    $0x1,%rdx\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "bloom-filter/bloom-filter.c", "function_name": "bad_search", "content": "#include \"libmin.h\"\n#include \"tinybloom.h\"\n\n#define NUM_ITEMS 2048\n#define NUM_BUCKETS NUM_ITEMS * 4\n\nint bad_search(const unsigned int* array, unsigned int target, size_t size)\n{\n\tint i;\n\tfor(i = 0; i < size; i++)\n\t\tif(array[i] == target) return 1;\n\n\treturn 0;\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O0.pseudo", "function_name": "bad_search", "address": "0x11e9", "label": "bad_search", "content": "int __cdecl bad_search(const unsigned int *array, unsigned int target, size_t size)\n{\n  int i; // [rsp+24h] [rbp-4h]\n\n  for ( i = 0; size > i; ++i )\n  {\n    if ( target == array[i] )\n      return 1;\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int bad_search(const unsigned int *array, unsigned int target,\n               unsigned int size) {\n  int i;\n  for (i = 0; size > i; ++i) {\n    if (target == array[i]) return 1;\n  }\n  return 0;\n}", "binary": "bloom-filter/bloom-filter.host.O0", "assembly": "<bad_search>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    122b <bad_search+0x42>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x1c(%rbp)\njne    1227 <bad_search+0x3e>\nmov    $0x1,%eax\njmp    123b <bad_search+0x52>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\ncmp    %rax,-0x28(%rbp)\nja     1205 <bad_search+0x1c>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "bloom-filter/tinybloom.c", "function_name": "bfilter_add", "content": "void bfilter_add(const bloom_filter* bFilter, const unsigned* input)\n{\n\tSETBIT(bFilter->filter, *input % bFilter->num_buckets);\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O0.pseudo", "function_name": "bfilter_add", "address": "0x1642", "label": "bfilter_add", "content": "void __cdecl bfilter_add(const bloom_filter *bFilter, const unsigned int *input)\n{\n  bFilter->filter[(*input % bFilter->num_buckets) >> 5] |= 1 << ((*input % bFilter->num_buckets) & 0x1F);\n}\n"}, "pseudo_normalize": "", "binary": "bloom-filter/bloom-filter.host.O0", "assembly": "<bfilter_add>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rsi\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x8(%rbp),%rdx\nmov    0x10(%rdx),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nshr    $0x5,%eax\nmov    %eax,%eax\nshl    $0x2,%rax\nadd    %rsi,%rax\nmov    (%rax),%esi\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x8(%rbp),%rdx\nmov    0x10(%rdx),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nand    $0x1f,%eax\nmov    $0x1,%edx\nmov    %eax,%ecx\nshl    %cl,%edx\nmov    %edx,%eax\nmov    %eax,%r8d\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rdi\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x8(%rbp),%rdx\nmov    0x10(%rdx),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nshr    $0x5,%eax\nmov    %eax,%eax\nshl    $0x2,%rax\nadd    %rdi,%rax\nor     %r8d,%esi\nmov    %esi,%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "bloom-filter/tinybloom.c", "function_name": "bfilter_check", "content": "int bfilter_check(const bloom_filter* bFilter, const unsigned* input)\n{\n\treturn GETBIT(bFilter->filter, *input % bFilter->num_buckets);\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O0.pseudo", "function_name": "bfilter_check", "address": "0x16d9", "label": "bfilter_check", "content": "int __cdecl bfilter_check(const bloom_filter *bFilter, const unsigned int *input)\n{\n  return (bFilter->filter[(*input % bFilter->num_buckets) >> 5] & (1 << ((*input % bFilter->num_buckets) & 0x1F))) != 0;\n}\n"}, "pseudo_normalize": "", "binary": "bloom-filter/bloom-filter.host.O0", "assembly": "<bfilter_check>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rsi\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x8(%rbp),%rdx\nmov    0x10(%rdx),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nshr    $0x5,%eax\nmov    %eax,%eax\nshl    $0x2,%rax\nadd    %rsi,%rax\nmov    (%rax),%esi\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x8(%rbp),%rdx\nmov    0x10(%rdx),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nand    $0x1f,%eax\nmov    $0x1,%edx\nmov    %eax,%ecx\nshl    %cl,%edx\nmov    %edx,%eax\nand    %esi,%eax\ntest   %eax,%eax\nsetne  %al\nmovzbl %al,%eax\npop    %rbp\nret\n"}
{"source": {"path": "bloom-filter/tinybloom.c", "function_name": "bfilter_intersect", "content": "int bfilter_intersect(bloom_filter* a, bloom_filter* b)\n{\n\tif(a->filter_size != b->filter_size) return 1;\n\n\tint i;\n\tfor(i = 0; i < a->filter_size; i++)\n\t\ta->filter[i] |= b->filter[i];\n\n\treturn 0;\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O0.pseudo", "function_name": "bfilter_intersect", "address": "0x1745", "label": "bfilter_intersect", "content": "int __cdecl bfilter_intersect(bloom_filter *a, bloom_filter *b)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  if ( a->filter_size != b->filter_size )\n    return 1;\n  for ( i = 0; i < a->filter_size; ++i )\n    a->filter[i] |= b->filter[i];\n  return 0;\n}\n"}, "pseudo_normalize": "int bfilter_intersect(bloom_filter *a, bloom_filter *b) {\n  int i;\n  if (a->filter_size != b->filter_size) return 1;\n  for (i = 0; i < a->filter_size; ++i) a->filter[i] |= b->filter[i];\n  return 0;\n}", "binary": "bloom-filter/bloom-filter.host.O0", "assembly": "<bfilter_intersect>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\ncmp    %rax,%rdx\nje     176f <bfilter_intersect+0x2a>\nmov    $0x1,%eax\njmp    17d7 <bfilter_intersect+0x92>\nmovl   $0x0,-0x4(%rbp)\njmp    17c0 <bfilter_intersect+0x7b>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rsi\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rsi,%rax\nor     %ecx,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\ncmp    %rax,%rdx\njb     1778 <bfilter_intersect+0x33>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "bloom-filter/tinybloom.c", "function_name": "destroy_bfilter", "content": "void destroy_bfilter(bloom_filter* bFilter)\n{\n\tif(bFilter->filter) libmin_free(bFilter->filter);\n\tif(bFilter) libmin_free(bFilter);\n\n\tbFilter->filter = NULL;\n\tbFilter = NULL;\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O0.pseudo", "function_name": "destroy_bfilter", "address": "0x15eb", "label": "destroy_bfilter", "content": "void __cdecl destroy_bfilter(bloom_filter *bFilter)\n{\n  if ( bFilter->filter )\n    libmin_free(bFilter->filter);\n  if ( bFilter )\n    libmin_free(bFilter);\n  bFilter->filter = 0LL;\n}\n"}, "pseudo_normalize": "", "binary": "bloom-filter/bloom-filter.host.O0", "assembly": "<destroy_bfilter>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\nje     1618 <destroy_bfilter+0x2d>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   1a57 <libmin_free>\ncmpq   $0x0,-0x8(%rbp)\nje     162b <destroy_bfilter+0x40>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1a57 <libmin_free>\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmovq   $0x0,-0x8(%rbp)\nnop\nleave\nret\n"}
{"source": {"path": "bloom-filter/bloom-filter.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tunsigned false_positives = 0, true_positives = 0;\n\tunsigned false_negatives = 0, true_negatives = 0;\n\n\tunsigned* filter_contents = libmin_malloc(sizeof(unsigned) * NUM_ITEMS);\n\tunsigned* test_array = libmin_malloc(sizeof(unsigned) * NUM_ITEMS);\n\n\t// Create a bloom filter with (2 << 13) buckets\n\tbloom_filter* bFilter = create_bfilter(NUM_BUCKETS);\n\n\tlibmin_printf(\"Using %lu kilobytes for filter.\\n\\n\", (bFilter->filter_size * sizeof(unsigned)) / 1024);\n\n\tlibmin_srand(42);\n\n\tint i;\n\tfor(i = 0; i < NUM_ITEMS; i++)\n\t{\n\t\tfilter_contents[i] = libmin_rand();\n\t\tbfilter_add(bFilter, &filter_contents[i]);\n\n\t\t// Fill our test array with a 50/50 mix of numbers that have been entered into the filter, and random numbers\n\t\tif(libmin_rand() & 1)\n\t\t\ttest_array[i] = filter_contents[i];\n\t\telse\n\t\t\ttest_array[i] = libmin_rand();\n\t}\n\n\tfor(i = 0; i < NUM_ITEMS; i++)\n\t{\n\t\tint filter_present = 0;\n\t\tint array_present = 0;\n\n\t\tfilter_present = bfilter_check(bFilter, &test_array[i]);\n\n\t\tarray_present = bad_search(filter_contents, test_array[i], NUM_ITEMS);\n\n\t\tif(array_present && filter_present) \t   true_positives++;\n\t\telse if(!array_present && !filter_present) true_negatives++;\n\t\telse if(!array_present && filter_present)  false_positives++;\n\t\telse if(array_present && !filter_present)  false_negatives++;\n\t}\n\n\tlibmin_printf(\"True positives: %i\\n\"\n\t\t\"True negatives: %i\\n\"\n\t\t\"False positives: %i\\n\"\n\t\t\"False negatives: %i\\n\",\n\t\ttrue_positives, true_negatives, false_positives, false_negatives);\n\n\tfloat success_rate = ((100.0f / NUM_ITEMS) * (true_positives + true_negatives));\n\tlibmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_rate);\n\n\tif(success_rate < 80.0f) libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n\n\tif(false_negatives) libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n\telse libmin_printf(\"Test PASSED.\\n\");\n\n\tlibmin_free(test_array);\n\tlibmin_free(filter_contents);\n\tdestroy_bfilter(bFilter);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O0.pseudo", "function_name": "main", "address": "0x123d", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int false_positives; // [rsp+8h] [rbp-48h]\n  unsigned int true_positives; // [rsp+Ch] [rbp-44h]\n  unsigned int false_negatives; // [rsp+10h] [rbp-40h]\n  unsigned int true_negatives; // [rsp+14h] [rbp-3Ch]\n  int i; // [rsp+18h] [rbp-38h]\n  int ia; // [rsp+18h] [rbp-38h]\n  float success_rate; // [rsp+1Ch] [rbp-34h]\n  int filter_present; // [rsp+20h] [rbp-30h]\n  int array_present; // [rsp+24h] [rbp-2Ch]\n  unsigned int *filter_contents; // [rsp+28h] [rbp-28h]\n  unsigned int *test_array; // [rsp+30h] [rbp-20h]\n  bloom_filter *bFilter; // [rsp+38h] [rbp-18h]\n\n  false_positives = 0;\n  true_positives = 0;\n  false_negatives = 0;\n  true_negatives = 0;\n  filter_contents = (unsigned int *)libmin_malloc(0x2000uLL);\n  test_array = (unsigned int *)libmin_malloc(0x2000uLL);\n  bFilter = create_bfilter(0x2000uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\", (4 * bFilter->filter_size) >> 10);\n  libmin_srand(0x2Au);\n  for ( i = 0; i <= 2047; ++i )\n  {\n    filter_contents[i] = libmin_rand();\n    bfilter_add(bFilter, &filter_contents[i]);\n    if ( (libmin_rand() & 1) != 0 )\n      test_array[i] = filter_contents[i];\n    else\n      test_array[i] = libmin_rand();\n  }\n  for ( ia = 0; ia <= 2047; ++ia )\n  {\n    filter_present = bfilter_check(bFilter, &test_array[ia]);\n    array_present = bad_search(filter_contents, test_array[ia], 0x800uLL);\n    if ( array_present && filter_present )\n    {\n      ++true_positives;\n    }\n    else if ( array_present || filter_present )\n    {\n      if ( array_present || !filter_present )\n      {\n        if ( array_present && !filter_present )\n          ++false_negatives;\n      }\n      else\n      {\n        ++false_positives;\n      }\n    }\n    else\n    {\n      ++true_negatives;\n    }\n  }\n  libmin_printf(\n    \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse negatives: %i\\n\",\n    true_positives,\n    true_negatives,\n    false_positives,\n    false_negatives);\n  success_rate = (float)(int)(true_positives + true_negatives) * 0.048828125;\n  libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_rate);\n  if ( success_rate < 80.0 )\n    libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n  if ( false_negatives )\n    libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n  else\n    libmin_printf(\"Test PASSED.\\n\");\n  libmin_free(test_array);\n  libmin_free(filter_contents);\n  destroy_bfilter(bFilter);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int false_positives;\n  unsigned int true_positives;\n  unsigned int false_negatives;\n  unsigned int true_negatives;\n  int i;\n  int ia;\n  float success_rate;\n  int filter_present;\n  int array_present;\n  unsigned int *filter_contents;\n  unsigned int *test_array;\n  bloom_filter *bFilter;\n  false_positives = 0;\n  true_positives = 0;\n  false_negatives = 0;\n  true_negatives = 0;\n  filter_contents = (unsigned int *)libmin_malloc(8192uLL);\n  test_array = (unsigned int *)libmin_malloc(8192uLL);\n  bFilter = create_bfilter(8192uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\",\n                (4 * bFilter->filter_size) >> 10);\n  libmin_srand(42u);\n  for (i = 0; i <= 2047; ++i) {\n    filter_contents[i] = libmin_rand();\n    bfilter_add(bFilter, &filter_contents[i]);\n    if ((libmin_rand() & 1) != 0)\n      test_array[i] = filter_contents[i];\n    else\n      test_array[i] = libmin_rand();\n  }\n  for (ia = 0; ia <= 2047; ++ia) {\n    filter_present = bfilter_check(bFilter, &test_array[ia]);\n    array_present = bad_search(filter_contents, test_array[ia], 2048uLL);\n    if (array_present && filter_present) {\n      ++true_positives;\n    } else if (array_present || filter_present) {\n      if (array_present || !filter_present) {\n        if (array_present && !filter_present) ++false_negatives;\n      } else {\n        ++false_positives;\n      }\n    } else {\n      ++true_negatives;\n    }\n  }\n  libmin_printf(\n      \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse \"\n      \"negatives: %i\\n\",\n      true_positives, true_negatives, false_positives, false_negatives);\n  success_rate = (float)(int)(true_positives + true_negatives) * 0.048828125;\n  libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_rate);\n  if (success_rate < 80.0)\n    libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n  if (false_negatives)\n    libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n  else\n    libmin_printf(\"Test PASSED.\\n\");\n  libmin_free(test_array);\n  libmin_free(filter_contents);\n  destroy_bfilter(bFilter);\n  libmin_success();\n}", "binary": "bloom-filter/bloom-filter.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmovl   $0x0,-0x48(%rbp)\nmovl   $0x0,-0x44(%rbp)\nmovl   $0x0,-0x40(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmov    $0x2000,%edi\ncall   196c <libmin_malloc>\nmov    %rax,-0x28(%rbp)\nmov    $0x2000,%edi\ncall   196c <libmin_malloc>\nmov    %rax,-0x20(%rbp)\nmov    $0x2000,%edi\ncall   154c <create_bfilter>\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nshl    $0x2,%rax\nshr    $0xa,%rax\nmov    %rax,%rsi\nlea    0x3d5f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dce <libmin_printf>\nmov    $0x2a,%edi\ncall   3ffd <libmin_srand>\nmovl   $0x0,-0x38(%rbp)\njmp    1366 <main+0x129>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\ncall   40af <libmin_rand>\nmov    %eax,(%rbx)\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1642 <bfilter_add>\ncall   40af <libmin_rand>\nand    $0x1,%eax\ntest   %eax,%eax\nje     1346 <main+0x109>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x38(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x20(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\njmp    1362 <main+0x125>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\ncall   40af <libmin_rand>\nmov    %eax,(%rbx)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x7ff,-0x38(%rbp)\njle    12cc <main+0x8f>\nmovl   $0x0,-0x38(%rbp)\njmp    1429 <main+0x1ec>\nmovl   $0x0,-0x30(%rbp)\nmovl   $0x0,-0x2c(%rbp)\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   16d9 <bfilter_check>\nmov    %eax,-0x30(%rbp)\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x28(%rbp),%rax\nmov    $0x800,%edx\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <bad_search>\nmov    %eax,-0x2c(%rbp)\ncmpl   $0x0,-0x2c(%rbp)\nje     13f1 <main+0x1b4>\ncmpl   $0x0,-0x30(%rbp)\nje     13f1 <main+0x1b4>\naddl   $0x1,-0x44(%rbp)\njmp    1425 <main+0x1e8>\ncmpl   $0x0,-0x2c(%rbp)\njne    1403 <main+0x1c6>\ncmpl   $0x0,-0x30(%rbp)\njne    1403 <main+0x1c6>\naddl   $0x1,-0x3c(%rbp)\njmp    1425 <main+0x1e8>\ncmpl   $0x0,-0x2c(%rbp)\njne    1415 <main+0x1d8>\ncmpl   $0x0,-0x30(%rbp)\nje     1415 <main+0x1d8>\naddl   $0x1,-0x48(%rbp)\njmp    1425 <main+0x1e8>\ncmpl   $0x0,-0x2c(%rbp)\nje     1425 <main+0x1e8>\ncmpl   $0x0,-0x30(%rbp)\njne    1425 <main+0x1e8>\naddl   $0x1,-0x40(%rbp)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x7ff,-0x38(%rbp)\njle    137f <main+0x142>\nmov    -0x40(%rbp),%esi\nmov    -0x48(%rbp),%ecx\nmov    -0x3c(%rbp),%edx\nmov    -0x44(%rbp),%eax\nmov    %esi,%r8d\nmov    %eax,%esi\nlea    0x3be2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dce <libmin_printf>\nmov    -0x44(%rbp),%edx\nmov    -0x3c(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,%eax\ntest   %rax,%rax\njs     1475 <main+0x238>\npxor   %xmm0,%xmm0\ncvtsi2ss %rax,%xmm0\njmp    148e <main+0x251>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2ss %rdx,%xmm0\naddss  %xmm0,%xmm0\nmovss  0x3c52(%rip),%xmm1\nmulss  %xmm1,%xmm0\nmovss  %xmm0,-0x34(%rbp)\npxor   %xmm2,%xmm2\ncvtss2sd -0x34(%rbp),%xmm2\nmovq   %xmm2,%rax\nmovq   %rax,%xmm0\nlea    0x3bc6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3dce <libmin_printf>\nmovss  0x3c1e(%rip),%xmm0\ncomiss -0x34(%rbp),%xmm0\njbe    14e8 <main+0x2ab>\nlea    0x3bbd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dce <libmin_printf>\ncmpl   $0x0,-0x40(%rbp)\nje     1504 <main+0x2c7>\nlea    0x3bcb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dce <libmin_printf>\njmp    1518 <main+0x2db>\nlea    0x3bce(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dce <libmin_printf>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1a57 <libmin_free>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1a57 <libmin_free>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   15eb <destroy_bfilter>\ncall   4366 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "boyer-moore-search/boyer-moore-search.c", "function_name": "badCharHeuristic", "content": "#define NO_OF_CHARS 256\n\n// The preprocessing function for Boyer Moore's\n// bad character heuristic\nvoid badCharHeuristic(char *str, int size, int badchar[NO_OF_CHARS])\n{\n\t// Initialize all occurrences as -1\n\tfor(int i = 0; i < NO_OF_CHARS; i++)\n  {\n\t\tbadchar[i] = -1;\n  }\n\n\t// Fill the actual value of last occurrence of a character\n\tfor(int i = 0; i < size; i++)\n  {\n\t\tbadchar[(int)str[i]] = i;\n  }\n}\n"}, "pseudo": {"path": "boyer-moore-search/boyer-moore-search.host.O0.pseudo", "function_name": "badCharHeuristic", "address": "0x11e9", "label": "badCharHeuristic", "content": "void __cdecl badCharHeuristic(char *str, int size, int *badchar)\n{\n  int i; // [rsp+20h] [rbp-8h]\n  int i_0; // [rsp+24h] [rbp-4h]\n\n  for ( i = 0; i <= 255; ++i )\n    badchar[i] = -1;\n  for ( i_0 = 0; i_0 < size; ++i_0 )\n    badchar[str[i_0]] = i_0;\n}\n"}, "pseudo_normalize": "void badCharHeuristic(char *str, int size, int *badchar) {\n  int i;\n  int i_0;\n  for (i = 0; i <= 255; ++i) badchar[i] = -1;\n  for (i_0 = 0; i_0 < size; ++i_0) badchar[str[i_0]] = i_0;\n}", "binary": "boyer-moore-search/boyer-moore-search.host.O0", "assembly": "<badCharHeuristic>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1223 <badCharHeuristic+0x3a>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0xffffffff,(%rax)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0xff,-0x8(%rbp)\njle    1205 <badCharHeuristic+0x1c>\nmovl   $0x0,-0x4(%rbp)\njmp    1261 <badCharHeuristic+0x78>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1235 <badCharHeuristic+0x4c>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "boyer-moore-search/boyer-moore-search.c", "function_name": "main", "content": "int\nmain(void) \n{ \n  int n = libmin_strlen(inp_txt); // String lengths are public\n  int m = libmin_strlen(inp_pat); // String lengths are public\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  \n  char txt[n];\n  for (int k=0; k < n; k++)\n    txt[k] = inp_txt[k];\n\n  char pat[m];\n  for (int k=0; k < m; k++)\n    pat[k] = inp_pat[k];\n\n  // Return vector\n  int ret[n];\n  for(int i=0; i<n; i++) ret[i] = FALSE; \n\t\n\n  // Run search\n  search(txt, n, pat, m, ret);\n\n  // print results\n  for(int i=0; i<n; i++)\n  {\n    if(ret[i]) \n    { \n      libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "boyer-moore-search/boyer-moore-search.host.O0.pseudo", "function_name": "main", "address": "0x146d", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned __int64 v3; // rax\n  void *v4; // rsp\n  unsigned __int64 v5; // rax\n  void *v6; // rsp\n  unsigned __int64 v7; // rax\n  void *v8; // rsp\n  _QWORD v9[8]; // [rsp+8h] [rbp-C0h] BYREF\n  int k; // [rsp+48h] [rbp-80h]\n  int k_0; // [rsp+4Ch] [rbp-7Ch]\n  int i; // [rsp+50h] [rbp-78h]\n  int i_0; // [rsp+54h] [rbp-74h]\n  int n; // [rsp+58h] [rbp-70h]\n  int m; // [rsp+5Ch] [rbp-6Ch]\n  __int64 v16; // [rsp+60h] [rbp-68h]\n  char (*p_txt)[]; // [rsp+68h] [rbp-60h]\n  __int64 v18; // [rsp+70h] [rbp-58h]\n  char (*p_pat)[]; // [rsp+78h] [rbp-50h]\n  __int64 v20; // [rsp+80h] [rbp-48h]\n  int (*p_ret)[]; // [rsp+88h] [rbp-40h]\n  unsigned __int64 v22; // [rsp+90h] [rbp-38h]\n\n  v22 = __readfsqword(0x28u);\n  n = libmin_strlen(inp_txt);\n  m = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  v16 = n - 1LL;\n  v9[6] = n;\n  v9[7] = 0LL;\n  v9[4] = n;\n  v9[5] = 0LL;\n  v3 = 16 * ((n + 15LL) / 0x10uLL);\n  while ( v9 != (_QWORD *)((char *)v9 - (v3 & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v4 = alloca(v3 & 0xFFF);\n  if ( (v3 & 0xFFF) != 0 )\n    *(_QWORD *)((char *)&v9[-1] + (v3 & 0xFFF)) = *(_QWORD *)((char *)&v9[-1] + (v3 & 0xFFF));\n  p_txt = (char (*)[])v9;\n  for ( k = 0; k < n; ++k )\n    *((_BYTE *)p_txt + k) = inp_txt[k];\n  v18 = m - 1LL;\n  v9[2] = m;\n  v9[3] = 0LL;\n  v9[0] = m;\n  v9[1] = 0LL;\n  v5 = 16 * ((m + 15LL) / 0x10uLL);\n  while ( v9 != (_QWORD *)((char *)v9 - (v5 & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v6 = alloca(v5 & 0xFFF);\n  if ( (v5 & 0xFFF) != 0 )\n    *(_QWORD *)((char *)&v9[-1] + (v5 & 0xFFF)) = *(_QWORD *)((char *)&v9[-1] + (v5 & 0xFFF));\n  p_pat = (char (*)[])v9;\n  for ( k_0 = 0; k_0 < m; ++k_0 )\n    *((_BYTE *)p_pat + k_0) = inp_pat[k_0];\n  v20 = n - 1LL;\n  v7 = 16 * ((4LL * n + 15) / 0x10uLL);\n  while ( v9 != (_QWORD *)((char *)v9 - (v7 & 0xFFFFFFFFFFFFF000LL)) )\n    ;\n  v8 = alloca(v7 & 0xFFF);\n  if ( (v7 & 0xFFF) != 0 )\n    *(_QWORD *)((char *)&v9[-1] + (v7 & 0xFFF)) = *(_QWORD *)((char *)&v9[-1] + (v7 & 0xFFF));\n  p_ret = (int (*)[])v9;\n  for ( i = 0; i < n; ++i )\n    *((_DWORD *)p_ret + i) = 0;\n  search((char *)p_txt, n, (char *)p_pat, m, (int *)p_ret);\n  for ( i_0 = 0; i_0 < n; ++i_0 )\n  {\n    if ( *((_DWORD *)p_ret + i_0) )\n      libmin_printf(\"pattern occurs at shift = %d\\n\", i_0);\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned long long v3;\n  void *v4;\n  unsigned long long v5;\n  void *v6;\n  unsigned long long v7;\n  void *v8;\n  uint64_t v9[8];\n  int k;\n  int k_0;\n  int i;\n  int i_0;\n  int n;\n  int m;\n  long long v16;\n  char(*p_txt)[];\n  long long v18;\n  char(*p_pat)[];\n  long long v20;\n  int(*p_ret)[];\n  unsigned long long v22;\n  v22 = __readfsqword(40u);\n  n = libmin_strlen(inp_txt);\n  m = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  v16 = n - 1LL;\n  v9[6] = n;\n  v9[7] = 0LL;\n  v9[4] = n;\n  v9[5] = 0LL;\n  v3 = 16 * ((n + 15LL) / 16uLL);\n  while (v9 != (uint64_t *)((char *)v9 - (v3 & 18446744073709547520LL)))\n    ;\n  v4 = alloca(v3 & 4095);\n  if ((v3 & 4095) != 0)\n    *(uint64_t *)((char *)&v9[-1] + (v3 & 4095)) =\n        *(uint64_t *)((char *)&v9[-1] + (v3 & 4095));\n  p_txt = (char(*)[])v9;\n  for (k = 0; k < n; ++k) *((uint8_t *)p_txt + k) = inp_txt[k];\n  v18 = m - 1LL;\n  v9[2] = m;\n  v9[3] = 0LL;\n  v9[0] = m;\n  v9[1] = 0LL;\n  v5 = 16 * ((m + 15LL) / 16uLL);\n  while (v9 != (uint64_t *)((char *)v9 - (v5 & 18446744073709547520LL)))\n    ;\n  v6 = alloca(v5 & 4095);\n  if ((v5 & 4095) != 0)\n    *(uint64_t *)((char *)&v9[-1] + (v5 & 4095)) =\n        *(uint64_t *)((char *)&v9[-1] + (v5 & 4095));\n  p_pat = (char(*)[])v9;\n  for (k_0 = 0; k_0 < m; ++k_0) *((uint8_t *)p_pat + k_0) = inp_pat[k_0];\n  v20 = n - 1LL;\n  v7 = 16 * ((4LL * n + 15) / 16uLL);\n  while (v9 != (uint64_t *)((char *)v9 - (v7 & 18446744073709547520LL)))\n    ;\n  v8 = alloca(v7 & 4095);\n  if ((v7 & 4095) != 0)\n    *(uint64_t *)((char *)&v9[-1] + (v7 & 4095)) =\n        *(uint64_t *)((char *)&v9[-1] + (v7 & 4095));\n  p_ret = (int(*)[])v9;\n  for (i = 0; i < n; ++i) *((uint32_t *)p_ret + i) = 0;\n  search((char *)p_txt, n, (char *)p_pat, m, (int *)p_ret);\n  for (i_0 = 0; i_0 < n; ++i_0) {\n    if (*((uint32_t *)p_ret + i_0))\n      libmin_printf(\"pattern occurs at shift = %d\\n\", i_0);\n  }\n  libmin_success();\n}", "binary": "boyer-moore-search/boyer-moore-search.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x98,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x38(%rbp)\nxor    %eax,%eax\nmov    %rsp,%rax\nmov    %rax,%rbx\nlea    0x4b9f(%rip),%rax\nmov    %rax,%rdi\ncall   3b73 <libmin_strlen>\nmov    %eax,-0x70(%rbp)\nlea    0x4b6d(%rip),%rax\nmov    %rax,%rdi\ncall   3b73 <libmin_strlen>\nmov    %eax,-0x6c(%rbp)\nmov    -0x6c(%rbp),%eax\nmov    -0x70(%rbp),%ecx\nmov    %eax,%edx\nmov    %ecx,%esi\nlea    0x2b35(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3944 <libmin_printf>\nmov    -0x70(%rbp),%edx\nmovslq %edx,%rax\nsub    $0x1,%rax\nmov    %rax,-0x68(%rbp)\nmovslq %edx,%rax\nmov    %rax,-0x90(%rbp)\nmovq   $0x0,-0x88(%rbp)\nmovslq %edx,%rax\nmov    %rax,-0xa0(%rbp)\nmovq   $0x0,-0x98(%rbp)\nmovslq %edx,%rax\nmov    $0x10,%edx\nsub    $0x1,%rdx\nadd    %rdx,%rax\nmov    $0x10,%esi\nmov    $0x0,%edx\ndiv    %rsi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     155b <main+0xee>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1544 <main+0xd7>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1585 <main+0x118>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x0,%rax\nmov    %rax,-0x60(%rbp)\nmovl   $0x0,-0x80(%rbp)\njmp    15b9 <main+0x14c>\nmov    -0x80(%rbp),%eax\ncltq\nlea    0x4a9b(%rip),%rdx\nmovzbl (%rax,%rdx,1),%ecx\nmov    -0x60(%rbp),%rdx\nmov    -0x80(%rbp),%eax\ncltq\nmov    %cl,(%rdx,%rax,1)\naddl   $0x1,-0x80(%rbp)\nmov    -0x80(%rbp),%eax\ncmp    -0x70(%rbp),%eax\njl     1599 <main+0x12c>\nmov    -0x6c(%rbp),%eax\nmovslq %eax,%rdx\nsub    $0x1,%rdx\nmov    %rdx,-0x58(%rbp)\nmovslq %eax,%rdx\nmov    %rdx,-0xb0(%rbp)\nmovq   $0x0,-0xa8(%rbp)\nmovslq %eax,%rdx\nmov    %rdx,-0xc0(%rbp)\nmovq   $0x0,-0xb8(%rbp)\ncltq\nmov    $0x10,%edx\nsub    $0x1,%rdx\nadd    %rdx,%rax\nmov    $0x10,%esi\nmov    $0x0,%edx\ndiv    %rsi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     163f <main+0x1d2>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1628 <main+0x1bb>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1669 <main+0x1fc>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x0,%rax\nmov    %rax,-0x50(%rbp)\nmovl   $0x0,-0x7c(%rbp)\njmp    169d <main+0x230>\nmov    -0x7c(%rbp),%eax\ncltq\nlea    0x4997(%rip),%rdx\nmovzbl (%rax,%rdx,1),%ecx\nmov    -0x50(%rbp),%rdx\nmov    -0x7c(%rbp),%eax\ncltq\nmov    %cl,(%rdx,%rax,1)\naddl   $0x1,-0x7c(%rbp)\nmov    -0x7c(%rbp),%eax\ncmp    -0x6c(%rbp),%eax\njl     167d <main+0x210>\nmov    -0x70(%rbp),%eax\nmovslq %eax,%rdx\nsub    $0x1,%rdx\nmov    %rdx,-0x48(%rbp)\nmovslq %eax,%rdx\nmov    %rdx,%r14\nmov    $0x0,%r15d\nmovslq %eax,%rdx\nmov    %rdx,%r12\nmov    $0x0,%r13d\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    $0x10,%eax\nsub    $0x1,%rax\nadd    %rdx,%rax\nmov    $0x10,%edi\nmov    $0x0,%edx\ndiv    %rdi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     1719 <main+0x2ac>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1702 <main+0x295>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1743 <main+0x2d6>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x3,%rax\nshr    $0x2,%rax\nshl    $0x2,%rax\nmov    %rax,-0x40(%rbp)\nmovl   $0x0,-0x78(%rbp)\njmp    1774 <main+0x307>\nmov    -0x40(%rbp),%rax\nmov    -0x78(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0x0,(%rax,%rdx,4)\naddl   $0x1,-0x78(%rbp)\nmov    -0x78(%rbp),%eax\ncmp    -0x70(%rbp),%eax\njl     175f <main+0x2f2>\nmov    -0x40(%rbp),%rdi\nmov    -0x6c(%rbp),%ecx\nmov    -0x50(%rbp),%rdx\nmov    -0x70(%rbp),%esi\nmov    -0x60(%rbp),%rax\nmov    %rdi,%r8\nmov    %rax,%rdi\ncall   126d <search>\nmovl   $0x0,-0x74(%rbp)\njmp    17d0 <main+0x363>\nmov    -0x40(%rbp),%rax\nmov    -0x74(%rbp),%edx\nmovslq %edx,%rdx\nmov    (%rax,%rdx,4),%eax\ntest   %eax,%eax\nje     17cc <main+0x35f>\nmov    -0x74(%rbp),%eax\nmov    %eax,%esi\nlea    0x2855(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3944 <libmin_printf>\naddl   $0x1,-0x74(%rbp)\nmov    -0x74(%rbp),%eax\ncmp    -0x70(%rbp),%eax\njl     17a2 <main+0x335>\ncall   3bb1 <libmin_success>\nmov    $0x0,%eax\nmov    %rbx,%rsp\nmov    -0x38(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     17f9 <main+0x38c>\ncall   10b0 <__stack_chk_fail@plt>\nlea    -0x28(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"}
{"source": {"path": "boyer-moore-search/boyer-moore-search.c", "function_name": "search", "content": "/* A pattern searching function that uses Bad\nCharacter Heuristic of Boyer Moore Algorithm */\nvoid search(char *txt, int n, char *pat, int m, int *ret)\n{\n\tint badchar[NO_OF_CHARS];\n\n\t/* Fill the bad character array by calling\n\tthe preprocessing function badCharHeuristic()\n\tfor given pattern */\n\tbadCharHeuristic(pat, m, badchar);\n\n\tint s = 0; // s is shift of the pattern with\n\t\t\t\t     // respect to text\n  \n\tfor(int l=0; l<=(n - m); l++)\n\t{\n    //Early exit if not data-oblivious... \n    if (s > (n-m)) break;\n\n\t\tint idx = m-1;\n\n\t\t/* Keep reducing index idx of pattern while\n\t\tcharacters of pattern and text are\n\t\tmatching at this shift s */\n\t\twhile(idx >= 0 && pat[idx] == txt[s+idx])\n    {\n\t\t\tidx--;\n    }\n\n\t\t/* If the pattern is present at current\n\t\tshift, then index idx will become -1 after\n\t\tthe above loop */\n    int cond = (idx < 0);\n    if(cond)\n    {\n      ret[s] = TRUE; \n\t\t\ts += (s+m < n)? m-badchar[(int)txt[s+m]] : 1;\n    }\n\t\telse \n    {\n      int s_shift = idx - badchar[(int)txt[s+idx]];\n\t\t\ts += 1 > s_shift ? 1 : s_shift;\n    }\n\t}\n}\n"}, "pseudo": {"path": "boyer-moore-search/boyer-moore-search.host.O0.pseudo", "function_name": "search", "address": "0x126d", "label": "search", "content": "void __cdecl search(char *txt, int n, char *pat, int m, int *ret)\n{\n  int v5; // eax\n  int v6; // eax\n  int s; // [rsp+2Ch] [rbp-424h]\n  int l; // [rsp+30h] [rbp-420h]\n  int idx; // [rsp+34h] [rbp-41Ch]\n  int badchar[258]; // [rsp+40h] [rbp-410h] BYREF\n  unsigned __int64 v14; // [rsp+448h] [rbp-8h]\n\n  v14 = __readfsqword(0x28u);\n  badCharHeuristic(pat, m, badchar);\n  s = 0;\n  for ( l = 0; l <= n - m && s <= n - m; ++l )\n  {\n    for ( idx = m - 1; idx >= 0 && pat[idx] == txt[s + idx]; --idx )\n      ;\n    if ( idx >= 0 )\n    {\n      v6 = idx - badchar[txt[s + idx]];\n      if ( v6 <= 0 )\n        v6 = 1;\n      s += v6;\n    }\n    else\n    {\n      ret[s] = 1;\n      if ( n <= s + m )\n        v5 = 1;\n      else\n        v5 = m - badchar[txt[s + m]];\n      s += v5;\n    }\n  }\n}\n"}, "pseudo_normalize": "void search(char *txt, int n, char *pat, int m, int *ret) {\n  int v5;\n  int v6;\n  int s;\n  int l;\n  int idx;\n  int badchar[258];\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  badCharHeuristic(pat, m, badchar);\n  s = 0;\n  for (l = 0; l <= n - m && s <= n - m; ++l) {\n    for (idx = m - 1; idx >= 0 && pat[idx] == txt[s + idx]; --idx)\n      ;\n    if (idx >= 0) {\n      v6 = idx - badchar[txt[s + idx]];\n      if (v6 <= 0) v6 = 1;\n      s += v6;\n    } else {\n      ret[s] = 1;\n      if (n <= s + m)\n        v5 = 1;\n      else\n        v5 = m - badchar[txt[s + m]];\n      s += v5;\n    }\n  }\n}", "binary": "boyer-moore-search/boyer-moore-search.host.O0", "assembly": "<search>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x450,%rsp\nmov    %rdi,-0x438(%rbp)\nmov    %esi,-0x43c(%rbp)\nmov    %rdx,-0x448(%rbp)\nmov    %ecx,-0x440(%rbp)\nmov    %r8,-0x450(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x410(%rbp),%rdx\nmov    -0x440(%rbp),%ecx\nmov    -0x448(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <badCharHeuristic>\nmovl   $0x0,-0x424(%rbp)\nmovl   $0x0,-0x420(%rbp)\njmp    143b <search+0x1ce>\nmov    -0x43c(%rbp),%eax\nsub    -0x440(%rbp),%eax\ncmp    %eax,-0x424(%rbp)\njg     1455 <search+0x1e8>\nmov    -0x440(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x41c(%rbp)\njmp    1313 <search+0xa6>\nsubl   $0x1,-0x41c(%rbp)\ncmpl   $0x0,-0x41c(%rbp)\njs     1354 <search+0xe7>\nmov    -0x41c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x448(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x424(%rbp),%ecx\nmov    -0x41c(%rbp),%eax\nadd    %ecx,%eax\nmovslq %eax,%rcx\nmov    -0x438(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\nje     130c <search+0x9f>\nmov    -0x41c(%rbp),%eax\nshr    $0x1f,%eax\nmovzbl %al,%eax\nmov    %eax,-0x418(%rbp)\ncmpl   $0x0,-0x418(%rbp)\nje     13e6 <search+0x179>\nmov    -0x424(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x450(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\nmov    -0x424(%rbp),%edx\nmov    -0x440(%rbp),%eax\nadd    %edx,%eax\ncmp    %eax,-0x43c(%rbp)\njle    13d9 <search+0x16c>\nmov    -0x424(%rbp),%edx\nmov    -0x440(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x438(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncltq\nmov    -0x410(%rbp,%rax,4),%edx\nmov    -0x440(%rbp),%eax\nsub    %edx,%eax\njmp    13de <search+0x171>\nmov    $0x1,%eax\nadd    %eax,-0x424(%rbp)\njmp    1434 <search+0x1c7>\nmov    -0x424(%rbp),%edx\nmov    -0x41c(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x438(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncltq\nmov    -0x410(%rbp,%rax,4),%edx\nmov    -0x41c(%rbp),%eax\nsub    %edx,%eax\nmov    %eax,-0x414(%rbp)\nmov    -0x414(%rbp),%eax\nmov    $0x1,%edx\ntest   %eax,%eax\ncmovle %edx,%eax\nadd    %eax,-0x424(%rbp)\naddl   $0x1,-0x420(%rbp)\nmov    -0x43c(%rbp),%eax\nsub    -0x440(%rbp),%eax\ncmp    %eax,-0x420(%rbp)\njle    12e3 <search+0x76>\njmp    1456 <search+0x1e9>\nnop\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     146b <search+0x1fe>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "bubble-sort/bubble-sort.c", "function_name": "bubblesort", "content": "void\nbubblesort(int *data, unsigned size)\n{\n  for (unsigned i=0; i < size-1; i++)\n  {\n    int swapped = FALSE;\n    for (unsigned j=0; j < size-1; j++)\n    {\n      if (data[j] > data[j+1])\n      {\n        int tmp = data[j];\n        data[j] = data[j+1];\n        data[j+1] = tmp;\n        swapped = TRUE;\n        swaps++;\n      }\n    }\n    // done?\n    if (!swapped)\n      break;\n  }\n}\n"}, "pseudo": {"path": "bubble-sort/bubble-sort.host.O0.pseudo", "function_name": "bubblesort", "address": "0x1256", "label": "bubblesort", "content": "void __cdecl bubblesort(int *data, unsigned int size)\n{\n  unsigned int i; // [rsp+Ch] [rbp-10h]\n  int swapped; // [rsp+10h] [rbp-Ch]\n  unsigned int j; // [rsp+14h] [rbp-8h]\n  int tmp; // [rsp+18h] [rbp-4h]\n\n  for ( i = 0; i < size - 1; ++i )\n  {\n    swapped = 0;\n    for ( j = 0; j < size - 1; ++j )\n    {\n      if ( data[j] > data[j + 1] )\n      {\n        tmp = data[j];\n        data[j] = data[j + 1];\n        data[j + 1] = tmp;\n        swapped = 1;\n        ++swaps;\n      }\n    }\n    if ( !swapped )\n      break;\n  }\n}\n"}, "pseudo_normalize": "void bubblesort(int *data, unsigned int size) {\n  unsigned int i;\n  int swapped;\n  unsigned int j;\n  int tmp;\n  for (i = 0; i < size - 1; ++i) {\n    swapped = 0;\n    for (j = 0; j < size - 1; ++j) {\n      if (data[j] > data[j + 1]) {\n        tmp = data[j];\n        data[j] = data[j + 1];\n        data[j + 1] = tmp;\n        swapped = 1;\n        ++swaps;\n      }\n    }\n    if (!swapped) break;\n  }\n}", "binary": "bubble-sort/bubble-sort.host.O0", "assembly": "<bubblesort>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    134b <bubblesort+0xf5>\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1332 <bubblesort+0xdc>\nmov    -0x8(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    132e <bubblesort+0xd8>\nmov    -0x8(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x8(%rbp),%edx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\nmovl   $0x1,-0xc(%rbp)\nmov    0x535d(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x5352(%rip)\naddl   $0x1,-0x8(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x8(%rbp)\njb     1284 <bubblesort+0x2e>\ncmpl   $0x0,-0xc(%rbp)\nje     135c <bubblesort+0x106>\naddl   $0x1,-0x10(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x10(%rbp)\njb     1271 <bubblesort+0x1b>\njmp    135d <bubblesort+0x107>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "bubble-sort/bubble-sort.c", "function_name": "main", "content": "int\nmain(void)\n{\n  // initialize the pseudo-RNG\n  libmin_srand(42);\n  // mysrand(time(NULL));\n\n  // initialize the array to sort\n  for (unsigned i=0; i < DATASET_SIZE; i++)\n    data[i] = libmin_rand();\n  print_data(data, DATASET_SIZE);\n\n  {\n    // performance monitoring\n    libtarg_start_perf();\n\n    bubblesort(data, DATASET_SIZE);\n\n    libtarg_stop_perf();\n  }\n  print_data(data, DATASET_SIZE);\n\n  // check the array\n  for (unsigned i=0; i < DATASET_SIZE-1; i++)\n  {\n    if (data[i] > data[i+1])\n    {\n      libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n      return -1;\n    }\n  }\n  libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n  libmin_printf(\"INFO: data is properly sorted.\\n\");\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "bubble-sort/bubble-sort.host.O0.pseudo", "function_name": "main", "address": "0x1360", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  unsigned int i; // [rsp+8h] [rbp-8h]\n  unsigned int i_0; // [rsp+Ch] [rbp-4h]\n\n  libmin_srand(0x2Au);\n  for ( i = 0; i <= 0xFF; ++i )\n    data[i] = libmin_rand();\n  print_data(data, 0x100u);\n  libtarg_start_perf();\n  bubblesort(data, 0x100u);\n  libtarg_stop_perf();\n  print_data(data, 0x100u);\n  for ( i_0 = 0; ; ++i_0 )\n  {\n    if ( i_0 > 0xFE )\n    {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n    if ( data[i_0] > data[i_0 + 1] )\n      break;\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int i_0;\n  libmin_srand(42u);\n  for (i = 0; i <= 255; ++i) data[i] = libmin_rand();\n  print_data(data, 256u);\n  libtarg_start_perf();\n  bubblesort(data, 256u);\n  libtarg_stop_perf();\n  print_data(data, 256u);\n  for (i_0 = 0;; ++i_0) {\n    if (i_0 > 254) {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n    if (data[i_0] > data[i_0 + 1]) break;\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}", "binary": "bubble-sort/bubble-sort.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x2a,%edi\ncall   3805 <libmin_srand>\nmovl   $0x0,-0x8(%rbp)\njmp    139f <main+0x3f>\ncall   38b7 <libmin_rand>\nmov    %eax,%ecx\nmov    -0x8(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x4ee8(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0xff,-0x8(%rbp)\njbe    137f <main+0x1f>\nmov    $0x100,%esi\nlea    0x4ecc(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <print_data>\nmov    $0x0,%eax\ncall   1581 <libtarg_start_perf>\nmov    $0x100,%esi\nlea    0x4eae(%rip),%rax\nmov    %rax,%rdi\ncall   1256 <bubblesort>\nmov    $0x0,%eax\ncall   1598 <libtarg_stop_perf>\nmov    $0x100,%esi\nlea    0x4e90(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <print_data>\nmovl   $0x0,-0x4(%rbp)\njmp    1453 <main+0xf3>\nmov    -0x4(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x4e6d(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x4(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rcx\nlea    0x4e53(%rip),%rax\nmov    (%rcx,%rax,1),%eax\ncmp    %eax,%edx\njle    144f <main+0xef>\nlea    0x2bed(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d6 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    1498 <main+0x138>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0xfe,-0x4(%rbp)\njbe    1401 <main+0xa1>\nmov    0x521d(%rip),%rax\nmov    %rax,%rsi\nlea    0x2be0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d6 <libmin_printf>\nlea    0x2be7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d6 <libmin_printf>\ncall   3b6e <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "bubble-sort/bubble-sort.c", "function_name": "print_data", "content": "void\nprint_data(int *data, unsigned size)\n{\n  libmin_printf(\"DATA DUMP:\\n\");\n  for (unsigned i=0; i < size; i++)\n    libmin_printf(\"  data[%u] = %d\\n\", i, data[i]);\n}\n"}, "pseudo": {"path": "bubble-sort/bubble-sort.host.O0.pseudo", "function_name": "print_data", "address": "0x11e9", "label": "print_data", "content": "void __cdecl print_data(int *data, unsigned int size)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"DATA DUMP:\\n\");\n  for ( i = 0; i < size; ++i )\n    libmin_printf(\"  data[%u] = %d\\n\", i, data[i]);\n}\n"}, "pseudo_normalize": "", "binary": "bubble-sort/bubble-sort.host.O0", "assembly": "<print_data>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nlea    0x2e05(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d6 <libmin_printf>\nmovl   $0x0,-0x4(%rbp)\njmp    124a <print_data+0x61>\nmov    -0x4(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x4(%rbp),%eax\nmov    %eax,%esi\nlea    0x2ddb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d6 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njb     1219 <print_data+0x30>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "enum_declaration", "content": "void enum_declaration() {\n    // parse enum [id] { a = 1, b = 3, ...}\n    long i;\n    i = 0;\n    while (token != '}') {\n        if (token != Id) {\n            libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, token);\n            libmin_fail(-1);\n        }\n        next();\n        if (token == Assign) {\n            // like {a=10}\n            next();\n            if (token != Num) {\n                libmin_printf(\"%ld: bad enum initializer\\n\", line);\n                libmin_fail(-1);\n            }\n            i = token_val;\n            next();\n        }\n\n        current_id[Class] = Num;\n        current_id[Type] = INT;\n        current_id[Value] = i++;\n\n        if (token == ',') {\n            next();\n        }\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O0.pseudo", "function_name": "enum_declaration", "address": "0x3cf0", "label": "enum_declaration", "content": "void __cdecl enum_declaration()\n{\n  __int64 v0; // rax\n  __int64 i; // [rsp+8h] [rbp-8h]\n\n  i = 0LL;\n  while ( token != 125 )\n  {\n    if ( token != 133 )\n    {\n      libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, token);\n      libmin_fail(-1);\n    }\n    next();\n    if ( token == 142 )\n    {\n      next();\n      if ( token != 128 )\n      {\n        libmin_printf(\"%ld: bad enum initializer\\n\", line);\n        libmin_fail(-1);\n      }\n      i = token_val;\n      next();\n    }\n    current_id[4] = 128LL;\n    current_id[3] = 1LL;\n    v0 = i++;\n    current_id[5] = v0;\n    if ( token == 44 )\n      next();\n  }\n}\n"}, "pseudo_normalize": "void enum_declaration() {\n  long long v0;\n  long long i;\n  i = 0LL;\n  while (token != 125) {\n    if (token != 133) {\n      libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, token);\n      libmin_fail(-1);\n    }\n    next();\n    if (token == 142) {\n      next();\n      if (token != 128) {\n        libmin_printf(\"%ld: bad enum initializer\\n\", line);\n        libmin_fail(-1);\n      }\n      i = token_val;\n      next();\n    }\n    current_id[4] = 128LL;\n    current_id[3] = 1LL;\n    v0 = i++;\n    current_id[5] = v0;\n    if (token == 44) next();\n  }\n}", "binary": "c-interp/c-interp.host.O0", "assembly": "<enum_declaration>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovq   $0x0,-0x8(%rbp)\njmp    3e0b <enum_declaration+0x11b>\nmov    0x75b0(%rip),%rax\ncmp    $0x85,%rax\nje     3d47 <enum_declaration+0x57>\nmov    0x75a1(%rip),%rdx\nmov    0x761a(%rip),%rax\nmov    %rax,%rsi\nlea    0x4672(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x7568(%rip),%rax\ncmp    $0x8e,%rax\njne    3db6 <enum_declaration+0xc6>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x754f(%rip),%rax\ncmp    $0x80,%rax\nje     3da1 <enum_declaration+0xb1>\nmov    0x75c0(%rip),%rax\nmov    %rax,%rsi\nlea    0x4636(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x75a0(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x7573(%rip),%rax\nadd    $0x20,%rax\nmovq   $0x80,(%rax)\nmov    0x7561(%rip),%rax\nadd    $0x18,%rax\nmovq   $0x1,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x8(%rbp)\nmov    0x7543(%rip),%rdx\nadd    $0x28,%rdx\nmov    %rax,(%rdx)\nmov    0x74c5(%rip),%rax\ncmp    $0x2c,%rax\njne    3e0b <enum_declaration+0x11b>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x74ae(%rip),%rax\ncmp    $0x7d,%rax\njne    3d09 <enum_declaration+0x19>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "eval", "content": "long eval() {\n    long op, *tmp;\n    cycle = 0;\n    while (1) {\n        cycle ++;\n        op = *pc++; // get next operation code\n\n        // print debug info\n        if (debug) {\n            libmin_printf(\"%ld> %.4s\", cycle,\n                   & \"LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,\"\n                   \"OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\"\n                   \"OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT\"[op * 5]);\n            if (op <= ADJ)\n                libmin_printf(\" %ld\\n\", *pc);\n            else\n                libmin_printf(\"\\n\");\n        }\n        if (op == IMM)       {ax = *pc++;}                                     // load immediate value to ax\n        else if (op == LC)   {ax = *(char *)ax;}                               // load character to ax, address in ax\n        else if (op == LI)   {ax = *(long *)ax;}                                // load integer to ax, address in ax\n        else if (op == SC)   {ax = *(char *)*sp++ = ax;}                       // save character to address, value in ax, address on stack\n        else if (op == SI)   {*(long *)*sp++ = ax;}                             // save integer to address, value in ax, address on stack\n        else if (op == PUSH) {*--sp = ax;}                                     // push the value of ax onto the stack\n        else if (op == JMP)  {pc = (long *)*pc;}                                // jump to the address\n        else if (op == JZ)   {pc = ax ? pc + 1 : (long *)*pc;}                   // jump if ax is zero\n        else if (op == JNZ)  {pc = ax ? (long *)*pc : pc + 1;}                   // jump if ax is not zero\n        else if (op == CALL) {*--sp = (long)(pc+1); pc = (long *)*pc;}           // call subroutine\n        //else if (op == RET)  {pc = (long *)*sp++;}                              // return from subroutine;\n        else if (op == ENT)  {*--sp = (long)bp; bp = sp; sp = sp - *pc++;}      // make new stack frame\n        else if (op == ADJ)  {sp = sp + *pc++;}                                // add esp, <size>\n        else if (op == LEV)  {sp = bp; bp = (long *)*sp++; pc = (long *)*sp++;}  // restore call frame and PC\n        else if (op == LEA)  {ax = (long)(bp + *pc++);}                         // load address for arguments.\n\n        else if (op == OR)  ax = *sp++ | ax;\n        else if (op == XOR) ax = *sp++ ^ ax;\n        else if (op == AND) ax = *sp++ & ax;\n        else if (op == EQ)  ax = *sp++ == ax;\n        else if (op == NE)  ax = *sp++ != ax;\n        else if (op == LT)  ax = *sp++ < ax;\n        else if (op == LE)  ax = *sp++ <= ax;\n        else if (op == GT)  ax = *sp++ >  ax;\n        else if (op == GE)  ax = *sp++ >= ax;\n        else if (op == SHL) ax = *sp++ << ax;\n        else if (op == SHR) ax = *sp++ >> ax;\n        else if (op == ADD) ax = *sp++ + ax;\n        else if (op == SUB) ax = *sp++ - ax;\n        else if (op == MUL) ax = *sp++ * ax;\n        else if (op == DIV) ax = *sp++ / ax;\n        else if (op == MOD) ax = *sp++ % ax;\n\n        else if (op == EXIT) { libmin_printf(\"exit(%ld)\", *sp); return *sp;}\n        // else if (op == OPEN) { ax = open((char *)sp[1], sp[0]); }\n        // else if (op == CLOS) { ax = close(*sp);}\n        // else if (op == READ) { ax = read(sp[2], (char *)sp[1], *sp); }\n        else if (op == PRTF) { tmp = sp + pc[1]; ax = libmin_printf((char *)tmp[-1], tmp[-2], tmp[-3], tmp[-4], tmp[-5], tmp[-6]); }\n        // else if (op == MALC) { ax = (long)malloc(*sp);}\n        else if (op == MSET) { ax = (long)libmin_memset((char *)sp[2], sp[1], *sp);}\n        else if (op == MCMP) { ax = libmin_memcmp((char *)sp[2], (char *)sp[1], *sp);}\n        else {\n            libmin_printf(\"unknown instruction:%ld\\n\", op);\n            return -1;\n        }\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O0.pseudo", "function_name": "eval", "address": "0x457c", "label": "eval", "content": "__int64 __cdecl eval()\n{\n  __int64 *v0; // rax\n  __int64 *v1; // rax\n  __int64 *v2; // rax\n  _BYTE *v3; // rax\n  __int64 *v4; // rax\n  __int64 *v5; // rax\n  __int64 *v6; // rax\n  __int64 *v7; // rax\n  __int64 *v8; // rax\n  __int64 **v9; // rax\n  __int64 *v10; // rax\n  __int64 *v11; // rax\n  __int64 *v12; // rax\n  __int64 *v13; // rax\n  __int64 *v14; // rax\n  __int64 *v15; // rax\n  __int64 *v16; // rax\n  __int64 *v17; // rax\n  __int64 *v18; // rax\n  __int64 *v19; // rax\n  __int64 *v20; // rax\n  __int64 *v21; // rax\n  __int64 *v22; // rax\n  __int64 *v23; // rax\n  __int64 *v24; // rax\n  __int64 *v25; // rax\n  __int64 *v26; // rax\n  __int64 op; // [rsp+0h] [rbp-10h]\n  __int64 *tmp; // [rsp+8h] [rbp-8h]\n\n  cycle = 0LL;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          while ( 1 )\n          {\n            while ( 1 )\n            {\n              while ( 1 )\n              {\n                while ( 1 )\n                {\n                  while ( 1 )\n                  {\n                    while ( 1 )\n                    {\n                      while ( 1 )\n                      {\n                        while ( 1 )\n                        {\n                          while ( 1 )\n                          {\n                            while ( 1 )\n                            {\n                              while ( 1 )\n                              {\n                                while ( 1 )\n                                {\n                                  while ( 1 )\n                                  {\n                                    while ( 1 )\n                                    {\n                                      while ( 1 )\n                                      {\n                                        while ( 1 )\n                                        {\n                                          while ( 1 )\n                                          {\n                                            while ( 1 )\n                                            {\n                                              while ( 1 )\n                                              {\n                                                while ( 1 )\n                                                {\n                                                  while ( 1 )\n                                                  {\n                                                    while ( 1 )\n                                                    {\n                                                      while ( 1 )\n                                                      {\n                                                        while ( 1 )\n                                                        {\n                                                          while ( 1 )\n                                                          {\n                                                            while ( 1 )\n                                                            {\n                                                              while ( 1 )\n                                                              {\n                                                                while ( 1 )\n                                                                {\n                                                                  while ( 1 )\n                                                                  {\n                                                                    ++cycle;\n                                                                    v0 = pc++;\n                                                                    op = *v0;\n                                                                    if ( debug )\n                                                                    {\n                                                                      libmin_printf(\n                                                                        \"%ld> %.4s\",\n                                                                        cycle,\n                                                                        &aLeaImmJmpCallJ[5 * op]);\n                                                                      if ( op > 7 )\n                                                                        libmin_printf(\"\\n\");\n                                                                      else\n                                                                        libmin_printf(\" %ld\\n\", *pc);\n                                                                    }\n                                                                    if ( op != 1 )\n                                                                      break;\n                                                                    v1 = pc++;\n                                                                    qword_B320 = *v1;\n                                                                  }\n                                                                  if ( op != 10 )\n                                                                    break;\n                                                                  qword_B320 = *(char *)qword_B320;\n                                                                }\n                                                                if ( op != 9 )\n                                                                  break;\n                                                                qword_B320 = *(_QWORD *)qword_B320;\n                                                              }\n                                                              if ( op != 12 )\n                                                                break;\n                                                              v2 = qword_B318++;\n                                                              v3 = (_BYTE *)*v2;\n                                                              *v3 = qword_B320;\n                                                              qword_B320 = (char)*v3;\n                                                            }\n                                                            if ( op != 11 )\n                                                              break;\n                                                            v4 = qword_B318++;\n                                                            *(_QWORD *)*v4 = qword_B320;\n                                                          }\n                                                          if ( op != 13 )\n                                                            break;\n                                                          *--qword_B318 = qword_B320;\n                                                        }\n                                                        if ( op != 2 )\n                                                          break;\n                                                        pc = (__int64 *)*pc;\n                                                      }\n                                                      if ( op != 4 )\n                                                        break;\n                                                      if ( qword_B320 )\n                                                        v5 = pc + 1;\n                                                      else\n                                                        v5 = (__int64 *)*pc;\n                                                      pc = v5;\n                                                    }\n                                                    if ( op != 5 )\n                                                      break;\n                                                    if ( qword_B320 )\n                                                      v6 = (__int64 *)*pc;\n                                                    else\n                                                      v6 = pc + 1;\n                                                    pc = v6;\n                                                  }\n                                                  if ( op != 3 )\n                                                    break;\n                                                  *--qword_B318 = (__int64)(pc + 1);\n                                                  pc = (__int64 *)*pc;\n                                                }\n                                                if ( op != 6 )\n                                                  break;\n                                                *--qword_B318 = (__int64)qword_B310;\n                                                qword_B310 = qword_B318;\n                                                v7 = pc++;\n                                                qword_B318 -= *v7;\n                                              }\n                                              if ( op != 7 )\n                                                break;\n                                              v8 = pc++;\n                                              qword_B318 += *v8;\n                                            }\n                                            if ( op != 8 )\n                                              break;\n                                            qword_B318 = qword_B310 + 1;\n                                            qword_B310 = (__int64 *)*qword_B310;\n                                            v9 = (__int64 **)qword_B318++;\n                                            pc = *v9;\n                                          }\n                                          if ( op )\n                                            break;\n                                          v10 = pc++;\n                                          qword_B320 = (__int64)&qword_B310[*v10];\n                                        }\n                                        if ( op != 14 )\n                                          break;\n                                        v11 = qword_B318++;\n                                        qword_B320 |= *v11;\n                                      }\n                                      if ( op != 15 )\n                                        break;\n                                      v12 = qword_B318++;\n                                      qword_B320 ^= *v12;\n                                    }\n                                    if ( op != 16 )\n                                      break;\n                                    v13 = qword_B318++;\n                                    qword_B320 &= *v13;\n                                  }\n                                  if ( op != 17 )\n                                    break;\n                                  v14 = qword_B318++;\n                                  qword_B320 = *v14 == qword_B320;\n                                }\n                                if ( op != 18 )\n                                  break;\n                                v15 = qword_B318++;\n                                qword_B320 = *v15 != qword_B320;\n                              }\n                              if ( op != 19 )\n                                break;\n                              v16 = qword_B318++;\n                              qword_B320 = *v16 < qword_B320;\n                            }\n                            if ( op != 21 )\n                              break;\n                            v17 = qword_B318++;\n                            qword_B320 = *v17 <= qword_B320;\n                          }\n                          if ( op != 20 )\n                            break;\n                          v18 = qword_B318++;\n                          qword_B320 = *v18 > qword_B320;\n                        }\n                        if ( op != 22 )\n                          break;\n                        v19 = qword_B318++;\n                        qword_B320 = *v19 >= qword_B320;\n                      }\n                      if ( op != 23 )\n                        break;\n                      v20 = qword_B318++;\n                      qword_B320 = *v20 << qword_B320;\n                    }\n                    if ( op != 24 )\n                      break;\n                    v21 = qword_B318++;\n                    qword_B320 = *v21 >> qword_B320;\n                  }\n                  if ( op != 25 )\n                    break;\n                  v22 = qword_B318++;\n                  qword_B320 += *v22;\n                }\n                if ( op != 26 )\n                  break;\n                v23 = qword_B318++;\n                qword_B320 = *v23 - qword_B320;\n              }\n              if ( op != 27 )\n                break;\n              v24 = qword_B318++;\n              qword_B320 *= *v24;\n            }\n            if ( op != 28 )\n              break;\n            v25 = qword_B318++;\n            qword_B320 = *v25 / qword_B320;\n          }\n          if ( op != 29 )\n            break;\n          v26 = qword_B318++;\n          qword_B320 = *v26 % qword_B320;\n        }\n        if ( op == 37 )\n        {\n          libmin_printf(\"exit(%ld)\", *qword_B318);\n          return *qword_B318;\n        }\n        if ( op != 33 )\n          break;\n        tmp = &qword_B318[pc[1]];\n        qword_B320 = libmin_printf((char *)*(tmp - 1), *(tmp - 2), *(tmp - 3), *(tmp - 4), *(tmp - 5), *(tmp - 6));\n      }\n      if ( op != 35 )\n        break;\n      qword_B320 = (__int64)libmin_memset((void *)qword_B318[2], qword_B318[1], *qword_B318);\n    }\n    if ( op != 36 )\n      break;\n    qword_B320 = libmin_memcmp((const void *)qword_B318[2], (const void *)qword_B318[1], *qword_B318);\n  }\n  libmin_printf(\"unknown instruction:%ld\\n\", op);\n  return -1LL;\n}\n"}, "pseudo_normalize": "long long eval() {\n  long long *v0;\n  long long *v1;\n  long long *v2;\n  uint8_t *v3;\n  long long *v4;\n  long long *v5;\n  long long *v6;\n  long long *v7;\n  long long *v8;\n  long long **v9;\n  long long *v10;\n  long long *v11;\n  long long *v12;\n  long long *v13;\n  long long *v14;\n  long long *v15;\n  long long *v16;\n  long long *v17;\n  long long *v18;\n  long long *v19;\n  long long *v20;\n  long long *v21;\n  long long *v22;\n  long long *v23;\n  long long *v24;\n  long long *v25;\n  long long *v26;\n  long long op;\n  long long *tmp;\n  cycle = 0LL;\n  while (1) {\n    while (1) {\n      while (1) {\n        while (1) {\n          while (1) {\n            while (1) {\n              while (1) {\n                while (1) {\n                  while (1) {\n                    while (1) {\n                      while (1) {\n                        while (1) {\n                          while (1) {\n                            while (1) {\n                              while (1) {\n                                while (1) {\n                                  while (1) {\n                                    while (1) {\n                                      while (1) {\n                                        while (1) {\n                                          while (1) {\n                                            while (1) {\n                                              while (1) {\n                                                while (1) {\n                                                  while (1) {\n                                                    while (1) {\n                                                      while (1) {\n                                                        while (1) {\n                                                          while (1) {\n                                                            while (1) {\n                                                              while (1) {\n                                                                while (1) {\n                                                                  while (1) {\n                                                                    ++cycle;\n                                                                    v0 = pc++;\n                                                                    op = *v0;\n                                                                    if (debug) {\n                                                                      libmin_printf(\n                                                                          \"%ld>\"\n                                                                          \" %.\"\n                                                                          \"4s\",\n                                                                          cycle,\n                                                                          &aLeaImmJmpCallJ\n                                                                              [5 *\n                                                                               op]);\n                                                                      if (op >\n                                                                          7)\n                                                                        libmin_printf(\n                                                                            \"\\n\");\n                                                                      else\n                                                                        libmin_printf(\n                                                                            \" %\"\n                                                                            \"ld\"\n                                                                            \"\\n\",\n                                                                            *pc);\n                                                                    }\n                                                                    if (op != 1)\n                                                                      break;\n                                                                    v1 = pc++;\n                                                                    qword_B320 =\n                                                                        *v1;\n                                                                  }\n                                                                  if (op != 10)\n                                                                    break;\n                                                                  qword_B320 =\n                                                                      *(char *)\n                                                                          qword_B320;\n                                                                }\n                                                                if (op != 9)\n                                                                  break;\n                                                                qword_B320 =\n                                                                    *(uint64_t\n                                                                          *)\n                                                                        qword_B320;\n                                                              }\n                                                              if (op != 12)\n                                                                break;\n                                                              v2 = qword_B318++;\n                                                              v3 = (uint8_t\n                                                                        *)*v2;\n                                                              *v3 = qword_B320;\n                                                              qword_B320 =\n                                                                  (char)*v3;\n                                                            }\n                                                            if (op != 11) break;\n                                                            v4 = qword_B318++;\n                                                            *(uint64_t *)*v4 =\n                                                                qword_B320;\n                                                          }\n                                                          if (op != 13) break;\n                                                          *--qword_B318 =\n                                                              qword_B320;\n                                                        }\n                                                        if (op != 2) break;\n                                                        pc = (long long *)*pc;\n                                                      }\n                                                      if (op != 4) break;\n                                                      if (qword_B320)\n                                                        v5 = pc + 1;\n                                                      else\n                                                        v5 = (long long *)*pc;\n                                                      pc = v5;\n                                                    }\n                                                    if (op != 5) break;\n                                                    if (qword_B320)\n                                                      v6 = (long long *)*pc;\n                                                    else\n                                                      v6 = pc + 1;\n                                                    pc = v6;\n                                                  }\n                                                  if (op != 3) break;\n                                                  *--qword_B318 =\n                                                      (long long)(pc + 1);\n                                                  pc = (long long *)*pc;\n                                                }\n                                                if (op != 6) break;\n                                                *--qword_B318 =\n                                                    (long long)qword_B310;\n                                                qword_B310 = qword_B318;\n                                                v7 = pc++;\n                                                qword_B318 -= *v7;\n                                              }\n                                              if (op != 7) break;\n                                              v8 = pc++;\n                                              qword_B318 += *v8;\n                                            }\n                                            if (op != 8) break;\n                                            qword_B318 = qword_B310 + 1;\n                                            qword_B310 =\n                                                (long long *)*qword_B310;\n                                            v9 = (long long **)qword_B318++;\n                                            pc = *v9;\n                                          }\n                                          if (op) break;\n                                          v10 = pc++;\n                                          qword_B320 =\n                                              (long long)&qword_B310[*v10];\n                                        }\n                                        if (op != 14) break;\n                                        v11 = qword_B318++;\n                                        qword_B320 |= *v11;\n                                      }\n                                      if (op != 15) break;\n                                      v12 = qword_B318++;\n                                      qword_B320 ^= *v12;\n                                    }\n                                    if (op != 16) break;\n                                    v13 = qword_B318++;\n                                    qword_B320 &= *v13;\n                                  }\n                                  if (op != 17) break;\n                                  v14 = qword_B318++;\n                                  qword_B320 = *v14 == qword_B320;\n                                }\n                                if (op != 18) break;\n                                v15 = qword_B318++;\n                                qword_B320 = *v15 != qword_B320;\n                              }\n                              if (op != 19) break;\n                              v16 = qword_B318++;\n                              qword_B320 = *v16 < qword_B320;\n                            }\n                            if (op != 21) break;\n                            v17 = qword_B318++;\n                            qword_B320 = *v17 <= qword_B320;\n                          }\n                          if (op != 20) break;\n                          v18 = qword_B318++;\n                          qword_B320 = *v18 > qword_B320;\n                        }\n                        if (op != 22) break;\n                        v19 = qword_B318++;\n                        qword_B320 = *v19 >= qword_B320;\n                      }\n                      if (op != 23) break;\n                      v20 = qword_B318++;\n                      qword_B320 = *v20 << qword_B320;\n                    }\n                    if (op != 24) break;\n                    v21 = qword_B318++;\n                    qword_B320 = *v21 >> qword_B320;\n                  }\n                  if (op != 25) break;\n                  v22 = qword_B318++;\n                  qword_B320 += *v22;\n                }\n                if (op != 26) break;\n                v23 = qword_B318++;\n                qword_B320 = *v23 - qword_B320;\n              }\n              if (op != 27) break;\n              v24 = qword_B318++;\n              qword_B320 *= *v24;\n            }\n            if (op != 28) break;\n            v25 = qword_B318++;\n            qword_B320 = *v25 / qword_B320;\n          }\n          if (op != 29) break;\n          v26 = qword_B318++;\n          qword_B320 = *v26 % qword_B320;\n        }\n        if (op == 37) {\n          libmin_printf(\"exit(%ld)\", *qword_B318);\n          return *qword_B318;\n        }\n        if (op != 33) break;\n        tmp = &qword_B318[pc[1]];\n        qword_B320 = libmin_printf((char *)*(tmp - 1), *(tmp - 2), *(tmp - 3),\n                                   *(tmp - 4), *(tmp - 5), *(tmp - 6));\n      }\n      if (op != 35) break;\n      qword_B320 = (long long)libmin_memset((void *)qword_B318[2],\n                                            qword_B318[1], *qword_B318);\n    }\n    if (op != 36) break;\n    qword_B320 = libmin_memcmp((const void *)qword_B318[2],\n                               (const void *)qword_B318[1], *qword_B318);\n  }\n  libmin_printf(\"unknown instruction:%ld\\n\", op);\n  return -1LL;\n}", "binary": "c-interp/c-interp.host.O0", "assembly": "<eval>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovq   $0x0,0x6d95(%rip)\nmov    0x6d8e(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x6d83(%rip)\nmov    0x6d5c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6d51(%rip)\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    0x6ceb(%rip),%rax\ntest   %rax,%rax\nje     463e <eval+0xc2>\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rax,%rdx\nlea    0x3b79(%rip),%rax\nadd    %rax,%rdx\nmov    0x6d3f(%rip),%rax\nmov    %rax,%rsi\nlea    0x3eb8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\ncmpq   $0x7,-0x10(%rbp)\njg     462a <eval+0xae>\nmov    0x6cfa(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x3c01(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\njmp    463e <eval+0xc2>\nlea    0x3bf1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\ncmpq   $0x1,-0x10(%rbp)\njne    4666 <eval+0xea>\nmov    0x6cbc(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6cb1(%rip)\nmov    (%rax),%rax\nmov    %rax,0x6cbf(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0xa,-0x10(%rbp)\njne    4687 <eval+0x10b>\nmov    0x6cac(%rip),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x6c9e(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x9,-0x10(%rbp)\njne    46a4 <eval+0x128>\nmov    0x6c8b(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x6c81(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0xc,-0x10(%rbp)\njne    46de <eval+0x162>\nmov    0x6c6e(%rip),%rcx\nmov    0x6c5f(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6c54(%rip)\nmov    (%rax),%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x6c47(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0xb,-0x10(%rbp)\njne    470c <eval+0x190>\nmov    0x6c2c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6c21(%rip)\nmov    (%rax),%rax\nmov    %rax,%rdx\nmov    0x6c1c(%rip),%rax\nmov    %rax,(%rdx)\njmp    4593 <eval+0x17>\ncmpq   $0xd,-0x10(%rbp)\njne    473b <eval+0x1bf>\nmov    0x6bfe(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x6bf3(%rip)\nmov    0x6bec(%rip),%rax\nmov    0x6bed(%rip),%rdx\nmov    %rdx,(%rax)\njmp    4593 <eval+0x17>\ncmpq   $0x2,-0x10(%rbp)\njne    4758 <eval+0x1dc>\nmov    0x6bbf(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x6bb5(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x4,-0x10(%rbp)\njne    478e <eval+0x212>\nmov    0x6bba(%rip),%rax\ntest   %rax,%rax\nje     4778 <eval+0x1fc>\nmov    0x6b96(%rip),%rax\nadd    $0x8,%rax\njmp    4782 <eval+0x206>\nmov    0x6b89(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x6b7f(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x5,-0x10(%rbp)\njne    47c4 <eval+0x248>\nmov    0x6b84(%rip),%rax\ntest   %rax,%rax\nje     47ad <eval+0x231>\nmov    0x6b60(%rip),%rax\nmov    (%rax),%rax\njmp    47b8 <eval+0x23c>\nmov    0x6b54(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x6b49(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x3,-0x10(%rbp)\njne    4808 <eval+0x28c>\nmov    0x6b36(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    0x6b3b(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x6b30(%rip)\nmov    0x6b29(%rip),%rax\nmov    %rdx,(%rax)\nmov    0x6b0f(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x6b05(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x6,-0x10(%rbp)\njne    4872 <eval+0x2f6>\nmov    0x6afa(%rip),%rdx\nmov    0x6afb(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x6af0(%rip)\nmov    0x6ae9(%rip),%rax\nmov    %rdx,(%rax)\nmov    0x6adf(%rip),%rax\nmov    %rax,0x6ad0(%rip)\nmov    0x6ad1(%rip),%rcx\nmov    0x6aba(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6aaf(%rip)\nmov    (%rax),%rax\nshl    $0x3,%rax\nneg    %rax\nadd    %rcx,%rax\nmov    %rax,0x6aab(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x7,-0x10(%rbp)\njne    48a8 <eval+0x32c>\nmov    0x6a98(%rip),%rcx\nmov    0x6a81(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6a76(%rip)\nmov    (%rax),%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nmov    %rax,0x6a75(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x8,-0x10(%rbp)\njne    48fa <eval+0x37e>\nmov    0x6a5a(%rip),%rax\nmov    %rax,0x6a5b(%rip)\nmov    0x6a54(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6a49(%rip)\nmov    (%rax),%rax\nmov    %rax,0x6a37(%rip)\nmov    0x6a38(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6a2d(%rip)\nmov    (%rax),%rax\nmov    %rax,0x6a13(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x0,-0x10(%rbp)\njne    4930 <eval+0x3b4>\nmov    0x6a08(%rip),%rcx\nmov    0x69f9(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x69ee(%rip)\nmov    (%rax),%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nmov    %rax,0x69f5(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0xe,-0x10(%rbp)\njne    4962 <eval+0x3e6>\nmov    0x69da(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x69cf(%rip)\nmov    (%rax),%rdx\nmov    0x69cd(%rip),%rax\nor     %rdx,%rax\nmov    %rax,0x69c3(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0xf,-0x10(%rbp)\njne    4994 <eval+0x418>\nmov    0x69a8(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x699d(%rip)\nmov    (%rax),%rdx\nmov    0x699b(%rip),%rax\nxor    %rdx,%rax\nmov    %rax,0x6991(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x10,-0x10(%rbp)\njne    49c6 <eval+0x44a>\nmov    0x6976(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x696b(%rip)\nmov    (%rax),%rdx\nmov    0x6969(%rip),%rax\nand    %rdx,%rax\nmov    %rax,0x695f(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x11,-0x10(%rbp)\njne    49fe <eval+0x482>\nmov    0x6944(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6939(%rip)\nmov    (%rax),%rdx\nmov    0x6937(%rip),%rax\ncmp    %rax,%rdx\nsete   %al\nmovzbl %al,%eax\nmov    %rax,0x6927(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x12,-0x10(%rbp)\njne    4a36 <eval+0x4ba>\nmov    0x690c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6901(%rip)\nmov    (%rax),%rdx\nmov    0x68ff(%rip),%rax\ncmp    %rax,%rdx\nsetne  %al\nmovzbl %al,%eax\nmov    %rax,0x68ef(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x13,-0x10(%rbp)\njne    4a6e <eval+0x4f2>\nmov    0x68d4(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x68c9(%rip)\nmov    (%rax),%rdx\nmov    0x68c7(%rip),%rax\ncmp    %rax,%rdx\nsetl   %al\nmovzbl %al,%eax\nmov    %rax,0x68b7(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x15,-0x10(%rbp)\njne    4aa6 <eval+0x52a>\nmov    0x689c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6891(%rip)\nmov    (%rax),%rdx\nmov    0x688f(%rip),%rax\ncmp    %rax,%rdx\nsetle  %al\nmovzbl %al,%eax\nmov    %rax,0x687f(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x14,-0x10(%rbp)\njne    4ade <eval+0x562>\nmov    0x6864(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6859(%rip)\nmov    (%rax),%rdx\nmov    0x6857(%rip),%rax\ncmp    %rax,%rdx\nsetg   %al\nmovzbl %al,%eax\nmov    %rax,0x6847(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x16,-0x10(%rbp)\njne    4b16 <eval+0x59a>\nmov    0x682c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6821(%rip)\nmov    (%rax),%rdx\nmov    0x681f(%rip),%rax\ncmp    %rax,%rdx\nsetge  %al\nmovzbl %al,%eax\nmov    %rax,0x680f(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x17,-0x10(%rbp)\njne    4b4a <eval+0x5ce>\nmov    0x67f4(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x67e9(%rip)\nmov    (%rax),%rax\nmov    0x67e7(%rip),%rdx\nmov    %edx,%ecx\nshl    %cl,%rax\nmov    %rax,0x67db(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x18,-0x10(%rbp)\njne    4b7e <eval+0x602>\nmov    0x67c0(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x67b5(%rip)\nmov    (%rax),%rax\nmov    0x67b3(%rip),%rdx\nmov    %edx,%ecx\nsar    %cl,%rax\nmov    %rax,0x67a7(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x19,-0x10(%rbp)\njne    4bb0 <eval+0x634>\nmov    0x678c(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x6781(%rip)\nmov    (%rax),%rdx\nmov    0x677f(%rip),%rax\nadd    %rdx,%rax\nmov    %rax,0x6775(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x1a,-0x10(%rbp)\njne    4be2 <eval+0x666>\nmov    0x675a(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x674f(%rip)\nmov    (%rax),%rax\nmov    0x674d(%rip),%rdx\nsub    %rdx,%rax\nmov    %rax,0x6743(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x1b,-0x10(%rbp)\njne    4c15 <eval+0x699>\nmov    0x6728(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x671d(%rip)\nmov    (%rax),%rdx\nmov    0x671b(%rip),%rax\nimul   %rdx,%rax\nmov    %rax,0x6710(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x1c,-0x10(%rbp)\njne    4c49 <eval+0x6cd>\nmov    0x66f5(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x66ea(%rip)\nmov    (%rax),%rax\nmov    0x66e8(%rip),%rdi\ncqto\nidiv   %rdi\nmov    %rax,0x66dc(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x1d,-0x10(%rbp)\njne    4c80 <eval+0x704>\nmov    0x66c1(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x66b6(%rip)\nmov    (%rax),%rax\nmov    0x66b4(%rip),%rcx\ncqto\nidiv   %rcx\nmov    %rdx,%rax\nmov    %rax,0x66a5(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x25,-0x10(%rbp)\njne    4cb7 <eval+0x73b>\nmov    0x668a(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x381a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    0x6669(%rip),%rax\nmov    (%rax),%rax\njmp    4e01 <eval+0x885>\ncmpq   $0x21,-0x10(%rbp)\njne    4d4b <eval+0x7cf>\nmov    0x664f(%rip),%rdx\nmov    0x6638(%rip),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nsub    $0x30,%rax\nmov    (%rax),%r8\nmov    -0x8(%rbp),%rax\nsub    $0x28,%rax\nmov    (%rax),%rdi\nmov    -0x8(%rbp),%rax\nsub    $0x20,%rax\nmov    (%rax),%rcx\nmov    -0x8(%rbp),%rax\nsub    $0x18,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nsub    $0x10,%rax\nmov    (%rax),%rax\nmov    -0x8(%rbp),%rsi\nsub    $0x8,%rsi\nmov    (%rsi),%rsi\nmov    %rsi,%r10\nmov    %r8,%r9\nmov    %rdi,%r8\nmov    %rax,%rsi\nmov    %r10,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\ncltq\nmov    %rax,0x65da(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x23,-0x10(%rbp)\njne    4d93 <eval+0x817>\nmov    0x65bf(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,%rdx\nmov    0x65b2(%rip),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %eax,%ecx\nmov    0x65a2(%rip),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   58ba <libmin_memset>\nmov    %rax,0x6592(%rip)\njmp    4593 <eval+0x17>\ncmpq   $0x24,-0x10(%rbp)\njne    4ddf <eval+0x863>\nmov    0x6577(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,%rdx\nmov    0x656a(%rip),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nmov    %rax,%rcx\nmov    0x6559(%rip),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   57ef <libmin_memcmp>\ncltq\nmov    %rax,0x6546(%rip)\njmp    4593 <eval+0x17>\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nlea    0x36d2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffffffffffff,%rax\nleave\nret\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "expression", "content": "void expression(long level) {\n    // expressions have various format.\n    // but majorly can be divided into two parts: unit and operator\n    // for example `(char) *a[10] = (int *) func(b > 0 ? 10 : 20);\n    // `a[10]` is an unit while `*` is an operator.\n    // `func(...)` in total is an unit.\n    // so we should first parse those unit and unary operators\n    // and then the binary ones\n    //\n    // also the expression can be in the following types:\n    //\n    // 1. unit_unary ::= unit | unit unary_op | unary_op unit\n    // 2. expr ::= unit_unary (bin_op unit_unary ...)\n\n    // unit_unary()\n    long *id;\n    long tmp;\n    long *addr;\n    {\n        if (!token) {\n            libmin_printf(\"%ld: unexpected token EOF of expression\\n\", line);\n            libmin_fail(-1);\n        }\n        if (token == Num) {\n            match(Num);\n\n            // emit code\n            *++text = IMM;\n            *++text = token_val;\n            expr_type = INT;\n        }\n        else if (token == '\"') {\n            // continous string \"abc\" \"abc\"\n\n\n            // emit code\n            *++text = IMM;\n            *++text = token_val;\n\n            match('\"');\n            // store the rest strings\n            while (token == '\"') {\n                match('\"');\n            }\n\n            // append the end of string character '\\0', all the data are default\n            // to 0, so just move data one position forward.\n            data = (char *)(((long)data + sizeof(long)) & (-sizeof(long)));\n            expr_type = PTR;\n        }\n        else if (token == Sizeof) {\n            // sizeof is actually an unary operator\n            // now only `sizeof(int)`, `sizeof(char)` and `sizeof(*...)` are\n            // supported.\n            match(Sizeof);\n            match('(');\n            expr_type = INT;\n\n            if (token == Int) {\n                match(Int);\n            } else if (token == Char) {\n                match(Char);\n                expr_type = CHAR;\n            }\n\n            while (token == Mul) {\n                match(Mul);\n                expr_type = expr_type + PTR;\n            }\n\n            match(')');\n\n            // emit code\n            *++text = IMM;\n            *++text = (expr_type == CHAR) ? sizeof(char) : sizeof(long);\n\n            expr_type = INT;\n        }\n        else if (token == Id) {\n            // there are several type when occurs to Id\n            // but this is unit, so it can only be\n            // 1. function call\n            // 2. Enum variable\n            // 3. global/local variable\n            match(Id);\n\n            id = current_id;\n\n            if (token == '(') {\n                // function call\n                match('(');\n\n                // pass in arguments\n                tmp = 0; // number of arguments\n                while (token != ')') {\n                    expression(Assign);\n                    *++text = PUSH;\n                    tmp ++;\n\n                    if (token == ',') {\n                        match(',');\n                    }\n\n                }\n                match(')');\n\n                // emit code\n                if (id[Class] == Sys) {\n                    // system functions\n                    *++text = id[Value];\n                }\n                else if (id[Class] == Fun) {\n                    // function call\n                    *++text = CALL;\n                    *++text = id[Value];\n                }\n                else {\n                    libmin_printf(\"%ld: bad function call\\n\", line);\n                    libmin_fail(-1);\n                }\n\n                // clean the stack for arguments\n                if (tmp > 0) {\n                    *++text = ADJ;\n                    *++text = tmp;\n                }\n                expr_type = id[Type];\n            }\n            else if (id[Class] == Num) {\n                // enum variable\n                *++text = IMM;\n                *++text = id[Value];\n                expr_type = INT;\n            }\n            else {\n                // variable\n                if (id[Class] == Loc) {\n                    *++text = LEA;\n                    *++text = index_of_bp - id[Value];\n                }\n                else if (id[Class] == Glo) {\n                    *++text = IMM;\n                    *++text = id[Value];\n                }\n                else {\n                    libmin_printf(\"%ld: undefined variable\\n\", line);\n                    libmin_fail(-1);\n                }\n\n                // emit code, default behaviour is to load the value of the\n                // address which is stored in `ax`\n                expr_type = id[Type];\n                *++text = (expr_type == CHAR) ? LC : LI;\n            }\n        }\n        else if (token == '(') {\n            // cast or parenthesis\n            match('(');\n            if (token == Int || token == Char) {\n                tmp = (token == Char) ? CHAR : INT; // cast type\n                match(token);\n                while (token == Mul) {\n                    match(Mul);\n                    tmp = tmp + PTR;\n                }\n\n                match(')');\n\n                expression(Inc); // cast has precedence as Inc(++)\n\n                expr_type  = tmp;\n            } else {\n                // normal parenthesis\n                expression(Assign);\n                match(')');\n            }\n        }\n        else if (token == Mul) {\n            // dereference *<addr>\n            match(Mul);\n            expression(Inc); // dereference has the same precedence as Inc(++)\n\n            if (expr_type >= PTR) {\n                expr_type = expr_type - PTR;\n            } else {\n                libmin_printf(\"%ld: bad dereference\\n\", line);\n                libmin_fail(-1);\n            }\n\n            *++text = (expr_type == CHAR) ? LC : LI;\n        }\n        else if (token == And) {\n            // get the address of\n            match(And);\n            expression(Inc); // get the address of\n            if (*text == LC || *text == LI) {\n                text --;\n            } else {\n                libmin_printf(\"%ld: bad address of\\n\", line);\n                libmin_fail(-1);\n            }\n\n            expr_type = expr_type + PTR;\n        }\n        else if (token == '!') {\n            // not\n            match('!');\n            expression(Inc);\n\n            // emit code, use <expr> == 0\n            *++text = PUSH;\n            *++text = IMM;\n            *++text = 0;\n            *++text = EQ;\n\n            expr_type = INT;\n        }\n        else if (token == '~') {\n            // bitwise not\n            match('~');\n            expression(Inc);\n\n            // emit code, use <expr> XOR -1\n            *++text = PUSH;\n            *++text = IMM;\n            *++text = -1;\n            *++text = XOR;\n\n            expr_type = INT;\n        }\n        else if (token == Add) {\n            // +var, do nothing\n            match(Add);\n            expression(Inc);\n\n            expr_type = INT;\n        }\n        else if (token == Sub) {\n            // -var\n            match(Sub);\n\n            if (token == Num) {\n                *++text = IMM;\n                *++text = -token_val;\n                match(Num);\n            } else {\n\n                *++text = IMM;\n                *++text = -1;\n                *++text = PUSH;\n                expression(Inc);\n                *++text = MUL;\n            }\n\n            expr_type = INT;\n        }\n        else if (token == Inc || token == Dec) {\n            tmp = token;\n            match(token);\n            expression(Inc);\n            if (*text == LC) {\n                *text = PUSH;  // to duplicate the address\n                *++text = LC;\n            } else if (*text == LI) {\n                *text = PUSH;\n                *++text = LI;\n            } else {\n                libmin_printf(\"%ld: bad lvalue of pre-increment\\n\", line);\n                libmin_fail(-1);\n            }\n            *++text = PUSH;\n            *++text = IMM;\n            *++text = (expr_type > PTR) ? sizeof(long) : sizeof(char);\n            *++text = (tmp == Inc) ? ADD : SUB;\n            *++text = (expr_type == CHAR) ? SC : SI;\n        }\n        else {\n            libmin_printf(\"%ld: bad expression\\n\", line);\n            libmin_fail(-1);\n        }\n    }\n\n    // binary operator and postfix operators.\n    {\n        while (token >= level) {\n            // handle according to current operator's precedence\n            tmp = expr_type;\n            if (token == Assign) {\n                // var = expr;\n                match(Assign);\n                if (*text == LC || *text == LI) {\n                    *text = PUSH; // save the lvalue's pointer\n                } else {\n                    libmin_printf(\"%ld: bad lvalue in assignment\\n\", line);\n                    libmin_fail(-1);\n                }\n                expression(Assign);\n\n                expr_type = tmp;\n                *++text = (expr_type == CHAR) ? SC : SI;\n            }\n            else if (token == Cond) {\n                // expr ? a : b;\n                match(Cond);\n                *++text = JZ;\n                addr = ++text;\n                expression(Assign);\n                if (token == ':') {\n                    match(':');\n                } else {\n                    libmin_printf(\"%ld: missing colon in conditional\\n\", line);\n                    libmin_fail(-1);\n                }\n                *addr = (long)(text + 3);\n                *++text = JMP;\n                addr = ++text;\n                expression(Cond);\n                *addr = (long)(text + 1);\n            }\n            else if (token == Lor) {\n                // logic or\n                match(Lor);\n                *++text = JNZ;\n                addr = ++text;\n                expression(Lan);\n                *addr = (long)(text + 1);\n                expr_type = INT;\n            }\n            else if (token == Lan) {\n                // logic and\n                match(Lan);\n                *++text = JZ;\n                addr = ++text;\n                expression(Or);\n                *addr = (long)(text + 1);\n                expr_type = INT;\n            }\n            else if (token == Or) {\n                // bitwise or\n                match(Or);\n                *++text = PUSH;\n                expression(Xor);\n                *++text = OR;\n                expr_type = INT;\n            }\n            else if (token == Xor) {\n                // bitwise xor\n                match(Xor);\n                *++text = PUSH;\n                expression(And);\n                *++text = XOR;\n                expr_type = INT;\n            }\n            else if (token == And) {\n                // bitwise and\n                match(And);\n                *++text = PUSH;\n                expression(Eq);\n                *++text = AND;\n                expr_type = INT;\n            }\n            else if (token == Eq) {\n                // equal ==\n                match(Eq);\n                *++text = PUSH;\n                expression(Ne);\n                *++text = EQ;\n                expr_type = INT;\n            }\n            else if (token == Ne) {\n                // not equal !=\n                match(Ne);\n                *++text = PUSH;\n                expression(Lt);\n                *++text = NE;\n                expr_type = INT;\n            }\n            else if (token == Lt) {\n                // less than\n                match(Lt);\n                *++text = PUSH;\n                expression(Shl);\n                *++text = LT;\n                expr_type = INT;\n            }\n            else if (token == Gt) {\n                // greater than\n                match(Gt);\n                *++text = PUSH;\n                expression(Shl);\n                *++text = GT;\n                expr_type = INT;\n            }\n            else if (token == Le) {\n                // less than or equal to\n                match(Le);\n                *++text = PUSH;\n                expression(Shl);\n                *++text = LE;\n                expr_type = INT;\n            }\n            else if (token == Ge) {\n                // greater than or equal to\n                match(Ge);\n                *++text = PUSH;\n                expression(Shl);\n                *++text = GE;\n                expr_type = INT;\n            }\n            else if (token == Shl) {\n                // shift left\n                match(Shl);\n                *++text = PUSH;\n                expression(Add);\n                *++text = SHL;\n                expr_type = INT;\n            }\n            else if (token == Shr) {\n                // shift right\n                match(Shr);\n                *++text = PUSH;\n                expression(Add);\n                *++text = SHR;\n                expr_type = INT;\n            }\n            else if (token == Add) {\n                // add\n                match(Add);\n                *++text = PUSH;\n                expression(Mul);\n\n                expr_type = tmp;\n                if (expr_type > PTR) {\n                    // pointer type, and not `char *`\n                    *++text = PUSH;\n                    *++text = IMM;\n                    *++text = sizeof(long);\n                    *++text = MUL;\n                }\n                *++text = ADD;\n            }\n            else if (token == Sub) {\n                // sub\n                match(Sub);\n                *++text = PUSH;\n                expression(Mul);\n                if (tmp > PTR && tmp == expr_type) {\n                    // pointer subtraction\n                    *++text = SUB;\n                    *++text = PUSH;\n                    *++text = IMM;\n                    *++text = sizeof(long);\n                    *++text = DIV;\n                    expr_type = INT;\n                } else if (tmp > PTR) {\n                    // pointer movement\n                    *++text = PUSH;\n                    *++text = IMM;\n                    *++text = sizeof(long);\n                    *++text = MUL;\n                    *++text = SUB;\n                    expr_type = tmp;\n                } else {\n                    // numeral subtraction\n                    *++text = SUB;\n                    expr_type = tmp;\n                }\n            }\n            else if (token == Mul) {\n                // multiply\n                match(Mul);\n                *++text = PUSH;\n                expression(Inc);\n                *++text = MUL;\n                expr_type = tmp;\n            }\n            else if (token == Div) {\n                // divide\n                match(Div);\n                *++text = PUSH;\n                expression(Inc);\n                *++text = DIV;\n                expr_type = tmp;\n            }\n            else if (token == Mod) {\n                // Modulo\n                match(Mod);\n                *++text = PUSH;\n                expression(Inc);\n                *++text = MOD;\n                expr_type = tmp;\n            }\n            else if (token == Inc || token == Dec) {\n                // postfix inc(++) and dec(--)\n                // we will increase the value to the variable and decrease it\n                // on `ax` to get its original value.\n                if (*text == LI) {\n                    *text = PUSH;\n                    *++text = LI;\n                }\n                else if (*text == LC) {\n                    *text = PUSH;\n                    *++text = LC;\n                }\n                else {\n                    libmin_printf(\"%ld: bad value in increment\\n\", line);\n                    libmin_fail(-1);\n                }\n\n                *++text = PUSH;\n                *++text = IMM;\n                *++text = (expr_type > PTR) ? sizeof(long) : sizeof(char);\n                *++text = (token == Inc) ? ADD : SUB;\n                *++text = (expr_type == CHAR) ? SC : SI;\n                *++text = PUSH;\n                *++text = IMM;\n                *++text = (expr_type > PTR) ? sizeof(long) : sizeof(char);\n                *++text = (token == Inc) ? SUB : ADD;\n                match(token);\n            }\n            else if (token == Brak) {\n                // array access var[xx]\n                match(Brak);\n                *++text = PUSH;\n                expression(Assign);\n                match(']');\n\n                if (tmp > PTR) {\n                    // pointer, `not char *`\n                    *++text = PUSH;\n                    *++text = IMM;\n                    *++text = sizeof(long);\n                    *++text = MUL;\n                }\n                else if (tmp < PTR) {\n                    libmin_printf(\"%ld: pointer type expected\\n\", line);\n                    libmin_fail(-1);\n                }\n                expr_type = tmp - PTR;\n                *++text = ADD;\n                *++text = (expr_type == CHAR) ? LC : LI;\n            }\n            else {\n                libmin_printf(\"%ld: compiler error, token = %ld\\n\", line, token);\n                libmin_fail(-1);\n            }\n        }\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O0.pseudo", "function_name": "expression", "address": "0x1d57", "label": "expression", "content": "void __cdecl expression(__int64 level)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rdx\n  __int64 v4; // rdx\n  __int64 v5; // rdx\n  __int64 v6; // rdx\n  __int64 v7; // rdx\n  __int64 v8; // rdx\n  __int64 v9; // rdx\n  __int64 v10; // rdx\n  __int64 v11; // rdx\n  __int64 v12; // rdx\n  __int64 v13; // rdx\n  __int64 v14; // rdx\n  __int64 tmp; // [rsp+18h] [rbp-18h]\n  __int64 tmpa; // [rsp+18h] [rbp-18h]\n  __int64 tmpb; // [rsp+18h] [rbp-18h]\n  __int64 tmpc; // [rsp+18h] [rbp-18h]\n  __int64 *id; // [rsp+20h] [rbp-10h]\n  __int64 *addr; // [rsp+28h] [rbp-8h]\n  __int64 *addra; // [rsp+28h] [rbp-8h]\n  __int64 *addrb; // [rsp+28h] [rbp-8h]\n  __int64 *addrc; // [rsp+28h] [rbp-8h]\n\n  switch ( token )\n  {\n    case 0LL:\n      libmin_printf(\"%ld: unexpected token EOF of expression\\n\", line);\n      libmin_fail(-1);\n    case 128LL:\n      match(128LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 1LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = token_val;\n      expr_type = 1LL;\n      break;\n    case 34LL:\n      text = (char *)text + 8;\n      *(_QWORD *)text = 1LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = token_val;\n      match(34LL);\n      while ( token == 34 )\n        match(34LL);\n      data = (char *)((unsigned __int64)(data + 8) & 0xFFFFFFFFFFFFFFF8LL);\n      expr_type = 2LL;\n      break;\n    case 140LL:\n      match(140LL);\n      match(40LL);\n      expr_type = 1LL;\n      if ( token == 138 )\n      {\n        match(138LL);\n      }\n      else if ( token == 134 )\n      {\n        match(134LL);\n        expr_type = 0LL;\n      }\n      while ( token == 159 )\n      {\n        match(159LL);\n        expr_type += 2LL;\n      }\n      match(41LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 1LL;\n      if ( expr_type )\n        v1 = 8LL;\n      else\n        v1 = 1LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = v1;\n      expr_type = 1LL;\n      break;\n    case 133LL:\n      match(133LL);\n      id = current_id;\n      if ( token == 40 )\n      {\n        match(40LL);\n        tmp = 0LL;\n        while ( token != 41 )\n        {\n          expression(142LL);\n          text = (char *)text + 8;\n          *(_QWORD *)text = 13LL;\n          ++tmp;\n          if ( token == 44 )\n            match(44LL);\n        }\n        match(41LL);\n        if ( id[4] == 130 )\n        {\n          text = (char *)text + 8;\n          *(_QWORD *)text = id[5];\n        }\n        else\n        {\n          if ( id[4] != 129 )\n          {\n            libmin_printf(\"%ld: bad function call\\n\", line);\n            libmin_fail(-1);\n          }\n          text = (char *)text + 8;\n          *(_QWORD *)text = 3LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = id[5];\n        }\n        if ( tmp > 0 )\n        {\n          text = (char *)text + 8;\n          *(_QWORD *)text = 7LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = tmp;\n        }\n        expr_type = id[3];\n      }\n      else if ( current_id[4] == 128 )\n      {\n        text = (char *)text + 8;\n        *(_QWORD *)text = 1LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = id[5];\n        expr_type = 1LL;\n      }\n      else\n      {\n        if ( current_id[4] == 132 )\n        {\n          text = (char *)text + 8;\n          *(_QWORD *)text = 0LL;\n          v2 = id[5];\n          text = (char *)text + 8;\n          *(_QWORD *)text = index_of_bp - v2;\n        }\n        else\n        {\n          if ( current_id[4] != 131 )\n          {\n            libmin_printf(\"%ld: undefined variable\\n\", line);\n            libmin_fail(-1);\n          }\n          text = (char *)text + 8;\n          *(_QWORD *)text = 1LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = id[5];\n        }\n        expr_type = id[3];\n        if ( expr_type )\n          v3 = 9LL;\n        else\n          v3 = 10LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = v3;\n      }\n      break;\n    case 40LL:\n      match(40LL);\n      if ( token == 138 || token == 134 )\n      {\n        tmpa = token != 134;\n        match(token);\n        while ( token == 159 )\n        {\n          match(159LL);\n          tmpa += 2LL;\n        }\n        match(41LL);\n        expression(162LL);\n        expr_type = tmpa;\n      }\n      else\n      {\n        expression(142LL);\n        match(41LL);\n      }\n      break;\n    case 159LL:\n      match(159LL);\n      expression(162LL);\n      if ( expr_type <= 1 )\n      {\n        libmin_printf(\"%ld: bad dereference\\n\", line);\n        libmin_fail(-1);\n      }\n      expr_type -= 2LL;\n      if ( expr_type )\n        v4 = 9LL;\n      else\n        v4 = 10LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = v4;\n      break;\n    case 148LL:\n      match(148LL);\n      expression(162LL);\n      if ( *(_QWORD *)text != 10LL && *(_QWORD *)text != 9LL )\n      {\n        libmin_printf(\"%ld: bad address of\\n\", line);\n        libmin_fail(-1);\n      }\n      text = (char *)text - 8;\n      expr_type += 2LL;\n      break;\n    case 33LL:\n      match(33LL);\n      expression(162LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 13LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = 1LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = 0LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = 17LL;\n      expr_type = 1LL;\n      break;\n    case 126LL:\n      match(126LL);\n      expression(162LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 13LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = 1LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = -1LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = 15LL;\n      expr_type = 1LL;\n      break;\n    case 157LL:\n      match(157LL);\n      expression(162LL);\n      expr_type = 1LL;\n      break;\n    case 158LL:\n      match(158LL);\n      text = (char *)text + 8;\n      if ( token == 128 )\n      {\n        *(_QWORD *)text = 1LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = -token_val;\n        match(128LL);\n      }\n      else\n      {\n        *(_QWORD *)text = 1LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = -1LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(162LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 27LL;\n      }\n      expr_type = 1LL;\n      break;\n    case 162LL:\n    case 163LL:\n      tmpb = token;\n      match(token);\n      expression(162LL);\n      if ( *(_QWORD *)text == 10LL )\n      {\n        *(_QWORD *)text = 13LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = 10LL;\n      }\n      else\n      {\n        if ( *(_QWORD *)text != 9LL )\n        {\n          libmin_printf(\"%ld: bad lvalue of pre-increment\\n\", line);\n          libmin_fail(-1);\n        }\n        *(_QWORD *)text = 13LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = 9LL;\n      }\n      text = (char *)text + 8;\n      *(_QWORD *)text = 13LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = 1LL;\n      if ( expr_type <= 2 )\n        v5 = 1LL;\n      else\n        v5 = 8LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = v5;\n      if ( tmpb == 162 )\n        v6 = 25LL;\n      else\n        v6 = 26LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = v6;\n      if ( expr_type )\n        v7 = 11LL;\n      else\n        v7 = 12LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = v7;\n      break;\n    default:\n      libmin_printf(\"%ld: bad expression\\n\", line);\n      libmin_fail(-1);\n  }\n  while ( level <= token )\n  {\n    tmpc = expr_type;\n    switch ( token )\n    {\n      case 142LL:\n        match(142LL);\n        if ( *(_QWORD *)text != 10LL && *(_QWORD *)text != 9LL )\n        {\n          libmin_printf(\"%ld: bad lvalue in assignment\\n\", line);\n          libmin_fail(-1);\n        }\n        *(_QWORD *)text = 13LL;\n        expression(142LL);\n        expr_type = tmpc;\n        if ( tmpc )\n          v8 = 11LL;\n        else\n          v8 = 12LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = v8;\n        break;\n      case 143LL:\n        match(143LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 4LL;\n        text = (char *)text + 8;\n        addr = (__int64 *)text;\n        expression(142LL);\n        if ( token != 58 )\n        {\n          libmin_printf(\"%ld: missing colon in conditional\\n\", line);\n          libmin_fail(-1);\n        }\n        match(58LL);\n        *addr = (__int64)text + 24;\n        text = (char *)text + 8;\n        *(_QWORD *)text = 2LL;\n        text = (char *)text + 8;\n        addra = (__int64 *)text;\n        expression(143LL);\n        *addra = (__int64)text + 8;\n        break;\n      case 144LL:\n        match(144LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 5LL;\n        text = (char *)text + 8;\n        addrb = (__int64 *)text;\n        expression(145LL);\n        *addrb = (__int64)text + 8;\n        expr_type = 1LL;\n        break;\n      case 145LL:\n        match(145LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 4LL;\n        text = (char *)text + 8;\n        addrc = (__int64 *)text;\n        expression(146LL);\n        *addrc = (__int64)text + 8;\n        expr_type = 1LL;\n        break;\n      case 146LL:\n        match(146LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(147LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 14LL;\n        expr_type = 1LL;\n        break;\n      case 147LL:\n        match(147LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(148LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 15LL;\n        expr_type = 1LL;\n        break;\n      case 148LL:\n        match(148LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(149LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 16LL;\n        expr_type = 1LL;\n        break;\n      case 149LL:\n        match(149LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(150LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 17LL;\n        expr_type = 1LL;\n        break;\n      case 150LL:\n        match(150LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(151LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 18LL;\n        expr_type = 1LL;\n        break;\n      case 151LL:\n        match(151LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(155LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 19LL;\n        expr_type = 1LL;\n        break;\n      case 152LL:\n        match(152LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(155LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 20LL;\n        expr_type = 1LL;\n        break;\n      case 153LL:\n        match(153LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(155LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 21LL;\n        expr_type = 1LL;\n        break;\n      case 154LL:\n        match(154LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(155LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 22LL;\n        expr_type = 1LL;\n        break;\n      case 155LL:\n        match(155LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(157LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 23LL;\n        expr_type = 1LL;\n        break;\n      case 156LL:\n        match(156LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(157LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 24LL;\n        expr_type = 1LL;\n        break;\n      case 157LL:\n        match(157LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(159LL);\n        expr_type = tmpc;\n        if ( tmpc > 2 )\n        {\n          text = (char *)text + 8;\n          *(_QWORD *)text = 13LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = 1LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = 8LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = 27LL;\n        }\n        text = (char *)text + 8;\n        *(_QWORD *)text = 25LL;\n        break;\n      case 158LL:\n        match(158LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(159LL);\n        if ( tmpc > 2 && tmpc == expr_type )\n        {\n          text = (char *)text + 8;\n          *(_QWORD *)text = 26LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = 13LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = 1LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = 8LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = 28LL;\n          expr_type = 1LL;\n        }\n        else\n        {\n          if ( tmpc > 2 )\n          {\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            text = (char *)text + 8;\n            *(_QWORD *)text = 1LL;\n            text = (char *)text + 8;\n            *(_QWORD *)text = 8LL;\n            text = (char *)text + 8;\n            *(_QWORD *)text = 27LL;\n          }\n          text = (char *)text + 8;\n          *(_QWORD *)text = 26LL;\n          expr_type = tmpc;\n        }\n        break;\n      case 159LL:\n        match(159LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(162LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 27LL;\n        expr_type = tmpc;\n        break;\n      case 160LL:\n        match(160LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(162LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 28LL;\n        expr_type = tmpc;\n        break;\n      case 161LL:\n        match(161LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(162LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 29LL;\n        expr_type = tmpc;\n        break;\n      case 162LL:\n      case 163LL:\n        if ( *(_QWORD *)text == 9LL )\n        {\n          *(_QWORD *)text = 13LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = 9LL;\n        }\n        else\n        {\n          if ( *(_QWORD *)text != 10LL )\n          {\n            libmin_printf(\"%ld: bad value in increment\\n\", line);\n            libmin_fail(-1);\n          }\n          *(_QWORD *)text = 13LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = 10LL;\n        }\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = 1LL;\n        if ( expr_type <= 2 )\n          v9 = 1LL;\n        else\n          v9 = 8LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = v9;\n        if ( token == 162 )\n          v10 = 25LL;\n        else\n          v10 = 26LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = v10;\n        if ( expr_type )\n          v11 = 11LL;\n        else\n          v11 = 12LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = v11;\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = 1LL;\n        if ( expr_type <= 2 )\n          v12 = 1LL;\n        else\n          v12 = 8LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = v12;\n        if ( token == 162 )\n          v13 = 26LL;\n        else\n          v13 = 25LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = v13;\n        match(token);\n        break;\n      case 164LL:\n        match(164LL);\n        text = (char *)text + 8;\n        *(_QWORD *)text = 13LL;\n        expression(142LL);\n        match(93LL);\n        if ( tmpc <= 2 )\n        {\n          if ( tmpc <= 1 )\n          {\n            libmin_printf(\"%ld: pointer type expected\\n\", line);\n            libmin_fail(-1);\n          }\n        }\n        else\n        {\n          text = (char *)text + 8;\n          *(_QWORD *)text = 13LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = 1LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = 8LL;\n          text = (char *)text + 8;\n          *(_QWORD *)text = 27LL;\n        }\n        expr_type = tmpc - 2;\n        text = (char *)text + 8;\n        *(_QWORD *)text = 25LL;\n        if ( expr_type )\n          v14 = 9LL;\n        else\n          v14 = 10LL;\n        text = (char *)text + 8;\n        *(_QWORD *)text = v14;\n        break;\n      default:\n        libmin_printf(\"%ld: compiler error, token = %ld\\n\", line, token);\n        libmin_fail(-1);\n    }\n  }\n}\n"}, "pseudo_normalize": "", "binary": "c-interp/c-interp.host.O0", "assembly": "<expression>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    0x9552(%rip),%rax\ntest   %rax,%rax\njne    1d9b <expression+0x44>\nmov    0x95c6(%rip),%rax\nmov    %rax,%rsi\nlea    0x64bc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x951e(%rip),%rax\ncmp    $0x80,%rax\njne    1e07 <expression+0xb0>\nmov    $0x80,%edi\ncall   1cff <match>\nmov    0x950d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x9502(%rip)\nmov    0x94fb(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x94ed(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x94e2(%rip)\nmov    0x94db(%rip),%rax\nmov    0x9554(%rip),%rdx\nmov    %rdx,(%rax)\nmovq   $0x1,0x9556(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x94b2(%rip),%rax\ncmp    $0x22,%rax\njne    1ea4 <expression+0x14d>\nmov    0x94a9(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x949e(%rip)\nmov    0x9497(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x9489(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x947e(%rip)\nmov    0x9477(%rip),%rax\nmov    0x94f0(%rip),%rdx\nmov    %rdx,(%rax)\nmov    $0x22,%edi\ncall   1cff <match>\njmp    1e71 <expression+0x11a>\nmov    $0x22,%edi\ncall   1cff <match>\nmov    0x9448(%rip),%rax\ncmp    $0x22,%rax\nje     1e67 <expression+0x110>\nmov    0x945b(%rip),%rax\nadd    $0x8,%rax\nand    $0xfffffffffffffff8,%rax\nmov    %rax,0x944c(%rip)\nmovq   $0x2,0x94b9(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x9415(%rip),%rax\ncmp    $0x8c,%rax\njne    1fb0 <expression+0x259>\nmov    $0x8c,%edi\ncall   1cff <match>\nmov    $0x28,%edi\ncall   1cff <match>\nmovq   $0x1,0x9482(%rip)\nmov    0x93e3(%rip),%rax\ncmp    $0x8a,%rax\njne    1ef1 <expression+0x19a>\nmov    $0x8a,%edi\ncall   1cff <match>\njmp    1f33 <expression+0x1dc>\nmov    0x93c8(%rip),%rax\ncmp    $0x86,%rax\njne    1f33 <expression+0x1dc>\nmov    $0x86,%edi\ncall   1cff <match>\nmovq   $0x0,0x9443(%rip)\njmp    1f33 <expression+0x1dc>\nmov    $0x9f,%edi\ncall   1cff <match>\nmov    0x9430(%rip),%rax\nadd    $0x2,%rax\nmov    %rax,0x9425(%rip)\nmov    0x9386(%rip),%rax\ncmp    $0x9f,%rax\nje     1f17 <expression+0x1c0>\nmov    $0x29,%edi\ncall   1cff <match>\nmov    0x9375(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x936a(%rip)\nmov    0x9363(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x93e5(%rip),%rax\ntest   %rax,%rax\njne    1f7f <expression+0x228>\nmov    $0x1,%edx\njmp    1f84 <expression+0x22d>\nmov    $0x8,%edx\nmov    0x933d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x9332(%rip)\nmov    0x932b(%rip),%rax\nmov    %rdx,(%rax)\nmovq   $0x1,0x93ad(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x9309(%rip),%rax\ncmp    $0x85,%rax\njne    230b <expression+0x5b4>\nmov    $0x85,%edi\ncall   1cff <match>\nmov    0x935c(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    0x92e1(%rip),%rax\ncmp    $0x28,%rax\njne    2172 <expression+0x41b>\nmov    $0x28,%edi\ncall   1cff <match>\nmovq   $0x0,-0x18(%rbp)\njmp    2043 <expression+0x2ec>\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    0x92ba(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x92af(%rip)\nmov    0x92a8(%rip),%rax\nmovq   $0xd,(%rax)\naddq   $0x1,-0x18(%rbp)\nmov    0x928d(%rip),%rax\ncmp    $0x2c,%rax\njne    2043 <expression+0x2ec>\nmov    $0x2c,%edi\ncall   1cff <match>\nmov    0x9276(%rip),%rax\ncmp    $0x29,%rax\njne    1ffd <expression+0x2a6>\nmov    $0x29,%edi\ncall   1cff <match>\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ncmp    $0x82,%rax\njne    2096 <expression+0x33f>\nmov    0x9254(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x9249(%rip)\nmov    0x9242(%rip),%rax\nmov    -0x10(%rbp),%rdx\nmov    0x28(%rdx),%rdx\nmov    %rdx,(%rax)\njmp    2117 <expression+0x3c0>\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ncmp    $0x81,%rax\njne    20ef <expression+0x398>\nmov    0x9218(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x920d(%rip)\nmov    0x9206(%rip),%rax\nmovq   $0x3,(%rax)\nmov    0x91f8(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x91ed(%rip)\nmov    0x91e6(%rip),%rax\nmov    -0x10(%rbp),%rdx\nmov    0x28(%rdx),%rdx\nmov    %rdx,(%rax)\njmp    2117 <expression+0x3c0>\nmov    0x924a(%rip),%rax\nmov    %rax,%rsi\nlea    0x6169(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\ncmpq   $0x0,-0x18(%rbp)\njle    215e <expression+0x407>\nmov    0x91a3(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x9198(%rip)\nmov    0x9191(%rip),%rax\nmovq   $0x7,(%rax)\nmov    0x9183(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x9178(%rip)\nmov    0x9171(%rip),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x10(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,0x91eb(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ncmp    $0x80,%rax\njne    21d9 <expression+0x482>\nmov    0x913c(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x9131(%rip)\nmov    0x912a(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x911c(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x9111(%rip)\nmov    0x910a(%rip),%rax\nmov    -0x10(%rbp),%rdx\nmov    0x28(%rdx),%rdx\nmov    %rdx,(%rax)\nmovq   $0x1,0x9184(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ncmp    $0x84,%rax\njne    2242 <expression+0x4eb>\nmov    0x90d5(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x90ca(%rip)\nmov    0x90c3(%rip),%rax\nmovq   $0x0,(%rax)\nmov    0x914d(%rip),%rdx\nmov    -0x10(%rbp),%rax\nadd    $0x28,%rax\nmov    (%rax),%rcx\nmov    0x90a3(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x9098(%rip)\nmov    0x9091(%rip),%rax\nsub    %rcx,%rdx\nmov    %rdx,(%rax)\njmp    22c3 <expression+0x56c>\nmov    -0x10(%rbp),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ncmp    $0x83,%rax\njne    229b <expression+0x544>\nmov    0x906c(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x9061(%rip)\nmov    0x905a(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x904c(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x9041(%rip)\nmov    0x903a(%rip),%rax\nmov    -0x10(%rbp),%rdx\nmov    0x28(%rdx),%rdx\nmov    %rdx,(%rax)\njmp    22c3 <expression+0x56c>\nmov    0x909e(%rip),%rax\nmov    %rax,%rsi\nlea    0x5fd5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    -0x10(%rbp),%rax\nmov    0x18(%rax),%rax\nmov    %rax,0x9086(%rip)\nmov    0x907f(%rip),%rax\ntest   %rax,%rax\njne    22e5 <expression+0x58e>\nmov    $0xa,%edx\njmp    22ea <expression+0x593>\nmov    $0x9,%edx\nmov    0x8fd7(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8fcc(%rip)\nmov    0x8fc5(%rip),%rax\nmov    %rdx,(%rax)\njmp    3a08 <expression+0x1cb1>\nmov    0x8fae(%rip),%rax\ncmp    $0x28,%rax\njne    23c7 <expression+0x670>\nmov    $0x28,%edi\ncall   1cff <match>\nmov    0x8f93(%rip),%rax\ncmp    $0x8a,%rax\nje     2344 <expression+0x5ed>\nmov    0x8f84(%rip),%rax\ncmp    $0x86,%rax\njne    23ae <expression+0x657>\nmov    0x8f75(%rip),%rax\ncmp    $0x86,%rax\nsetne  %al\nmovzbl %al,%eax\nmov    %rax,-0x18(%rbp)\nmov    0x8f5e(%rip),%rax\nmov    %rax,%rdi\ncall   1cff <match>\njmp    237b <expression+0x624>\nmov    $0x9f,%edi\ncall   1cff <match>\naddq   $0x2,-0x18(%rbp)\nmov    0x8f3e(%rip),%rax\ncmp    $0x9f,%rax\nje     236c <expression+0x615>\nmov    $0x29,%edi\ncall   1cff <match>\nmov    $0xa2,%edi\ncall   1d57 <expression>\nmov    -0x18(%rbp),%rax\nmov    %rax,0x8faf(%rip)\njmp    29b5 <expression+0xc5e>\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    $0x29,%edi\ncall   1cff <match>\njmp    3a08 <expression+0x1cb1>\nmov    0x8ef2(%rip),%rax\ncmp    $0x9f,%rax\njne    2470 <expression+0x719>\nmov    $0x9f,%edi\ncall   1cff <match>\nmov    $0xa2,%edi\ncall   1d57 <expression>\nmov    0x8f63(%rip),%rax\ncmp    $0x1,%rax\njle    240f <expression+0x6b8>\nmov    0x8f56(%rip),%rax\nsub    $0x2,%rax\nmov    %rax,0x8f4b(%rip)\njmp    2437 <expression+0x6e0>\nmov    0x8f2a(%rip),%rax\nmov    %rax,%rsi\nlea    0x5e7a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x8f1a(%rip),%rax\ntest   %rax,%rax\njne    244a <expression+0x6f3>\nmov    $0xa,%edx\njmp    244f <expression+0x6f8>\nmov    $0x9,%edx\nmov    0x8e72(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8e67(%rip)\nmov    0x8e60(%rip),%rax\nmov    %rdx,(%rax)\njmp    3a08 <expression+0x1cb1>\nmov    0x8e49(%rip),%rax\ncmp    $0x94,%rax\njne    250a <expression+0x7b3>\nmov    $0x94,%edi\ncall   1cff <match>\nmov    $0xa2,%edi\ncall   1d57 <expression>\nmov    0x8e2a(%rip),%rax\nmov    (%rax),%rax\ncmp    $0xa,%rax\nje     24b7 <expression+0x760>\nmov    0x8e1a(%rip),%rax\nmov    (%rax),%rax\ncmp    $0x9,%rax\njne    24cb <expression+0x774>\nmov    0x8e0a(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x8dff(%rip)\njmp    24f3 <expression+0x79c>\nmov    0x8e6e(%rip),%rax\nmov    %rax,%rsi\nlea    0x5dd4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x8e5e(%rip),%rax\nadd    $0x2,%rax\nmov    %rax,0x8e53(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x8daf(%rip),%rax\ncmp    $0x21,%rax\njne    25bf <expression+0x868>\nmov    $0x21,%edi\ncall   1cff <match>\nmov    $0xa2,%edi\ncall   1d57 <expression>\nmov    0x8d92(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8d87(%rip)\nmov    0x8d80(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x8d72(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8d67(%rip)\nmov    0x8d60(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x8d52(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8d47(%rip)\nmov    0x8d40(%rip),%rax\nmovq   $0x0,(%rax)\nmov    0x8d32(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8d27(%rip)\nmov    0x8d20(%rip),%rax\nmovq   $0x11,(%rax)\nmovq   $0x1,0x8d9e(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x8cfa(%rip),%rax\ncmp    $0x7e,%rax\njne    2674 <expression+0x91d>\nmov    $0x7e,%edi\ncall   1cff <match>\nmov    $0xa2,%edi\ncall   1d57 <expression>\nmov    0x8cdd(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8cd2(%rip)\nmov    0x8ccb(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x8cbd(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8cb2(%rip)\nmov    0x8cab(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x8c9d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8c92(%rip)\nmov    0x8c8b(%rip),%rax\nmovq   $0xffffffffffffffff,(%rax)\nmov    0x8c7d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8c72(%rip)\nmov    0x8c6b(%rip),%rax\nmovq   $0xf,(%rax)\nmovq   $0x1,0x8ce9(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x8c45(%rip),%rax\ncmp    $0x9d,%rax\njne    26a7 <expression+0x950>\nmov    $0x9d,%edi\ncall   1cff <match>\nmov    $0xa2,%edi\ncall   1d57 <expression>\nmovq   $0x1,0x8cb6(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x8c12(%rip),%rax\ncmp    $0x9e,%rax\njne    27c2 <expression+0xa6b>\nmov    $0x9e,%edi\ncall   1cff <match>\nmov    0x8bf5(%rip),%rax\ncmp    $0x80,%rax\njne    2728 <expression+0x9d1>\nmov    0x8bee(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8be3(%rip)\nmov    0x8bdc(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x8c4e(%rip),%rdx\nmov    0x8bc7(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8bbc(%rip)\nmov    0x8bb5(%rip),%rax\nneg    %rdx\nmov    %rdx,(%rax)\nmov    $0x80,%edi\ncall   1cff <match>\njmp    27b2 <expression+0xa5b>\nmov    0x8b99(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8b8e(%rip)\nmov    0x8b87(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x8b79(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8b6e(%rip)\nmov    0x8b67(%rip),%rax\nmovq   $0xffffffffffffffff,(%rax)\nmov    0x8b59(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8b4e(%rip)\nmov    0x8b47(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0xa2,%edi\ncall   1d57 <expression>\nmov    0x8b2f(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8b24(%rip)\nmov    0x8b1d(%rip),%rax\nmovq   $0x1b,(%rax)\nmovq   $0x1,0x8b9b(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x8af7(%rip),%rax\ncmp    $0xa2,%rax\nje     27e4 <expression+0xa8d>\nmov    0x8ae8(%rip),%rax\ncmp    $0xa3,%rax\njne    298d <expression+0xc36>\nmov    0x8ad5(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmov    0x8aca(%rip),%rax\nmov    %rax,%rdi\ncall   1cff <match>\nmov    $0xa2,%edi\ncall   1d57 <expression>\nmov    0x8ab9(%rip),%rax\nmov    (%rax),%rax\ncmp    $0xa,%rax\njne    2848 <expression+0xaf1>\nmov    0x8aa9(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x8a9b(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8a90(%rip)\nmov    0x8a89(%rip),%rax\nmovq   $0xa,(%rax)\njmp    28b0 <expression+0xb59>\nmov    0x8a79(%rip),%rax\nmov    (%rax),%rax\ncmp    $0x9,%rax\njne    2888 <expression+0xb31>\nmov    0x8a69(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x8a5b(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8a50(%rip)\nmov    0x8a49(%rip),%rax\nmovq   $0x9,(%rax)\njmp    28b0 <expression+0xb59>\nmov    0x8ab1(%rip),%rax\nmov    %rax,%rsi\nlea    0x5a2f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x8a11(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8a06(%rip)\nmov    0x89ff(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x89f1(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x89e6(%rip)\nmov    0x89df(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x8a61(%rip),%rax\ncmp    $0x2,%rax\njle    2904 <expression+0xbad>\nmov    $0x8,%edx\njmp    2909 <expression+0xbb2>\nmov    $0x1,%edx\nmov    0x89b8(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x89ad(%rip)\nmov    0x89a6(%rip),%rax\nmov    %rdx,(%rax)\ncmpq   $0xa2,-0x18(%rbp)\njne    2936 <expression+0xbdf>\nmov    $0x19,%edx\njmp    293b <expression+0xbe4>\nmov    $0x1a,%edx\nmov    0x8986(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x897b(%rip)\nmov    0x8974(%rip),%rax\nmov    %rdx,(%rax)\nmov    0x89fa(%rip),%rax\ntest   %rax,%rax\njne    296a <expression+0xc13>\nmov    $0xc,%edx\njmp    296f <expression+0xc18>\nmov    $0xb,%edx\nmov    0x8952(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8947(%rip)\nmov    0x8940(%rip),%rax\nmov    %rdx,(%rax)\njmp    29b5 <expression+0xc5e>\nmov    0x89ac(%rip),%rax\nmov    %rax,%rsi\nlea    0x594c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\njmp    3a08 <expression+0x1cb1>\nmov    0x8997(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmov    0x88f4(%rip),%rax\ncmp    $0x8e,%rax\njne    2a88 <expression+0xd31>\nmov    $0x8e,%edi\ncall   1cff <match>\nmov    0x88df(%rip),%rax\nmov    (%rax),%rax\ncmp    $0xa,%rax\nje     2a02 <expression+0xcab>\nmov    0x88cf(%rip),%rax\nmov    (%rax),%rax\ncmp    $0x9,%rax\njne    2a12 <expression+0xcbb>\nmov    0x88bf(%rip),%rax\nmovq   $0xd,(%rax)\njmp    2a3a <expression+0xce3>\nmov    0x8927(%rip),%rax\nmov    %rax,%rsi\nlea    0x58dd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    -0x18(%rbp),%rax\nmov    %rax,0x8909(%rip)\nmov    0x8902(%rip),%rax\ntest   %rax,%rax\njne    2a62 <expression+0xd0b>\nmov    $0xc,%edx\njmp    2a67 <expression+0xd10>\nmov    $0xb,%edx\nmov    0x885a(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x884f(%rip)\nmov    0x8848(%rip),%rax\nmov    %rdx,(%rax)\njmp    3a08 <expression+0x1cb1>\nmov    0x8831(%rip),%rax\ncmp    $0x8f,%rax\njne    2ba3 <expression+0xe4c>\nmov    $0x8f,%edi\ncall   1cff <match>\nmov    0x881c(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8811(%rip)\nmov    0x880a(%rip),%rax\nmovq   $0x4,(%rax)\nmov    0x87fc(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x87f1(%rip)\nmov    0x87ea(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    0x87cd(%rip),%rax\ncmp    $0x3a,%rax\njne    2b05 <expression+0xdae>\nmov    $0x3a,%edi\ncall   1cff <match>\njmp    2b2d <expression+0xdd6>\nmov    0x8834(%rip),%rax\nmov    %rax,%rsi\nlea    0x580a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x8794(%rip),%rax\nadd    $0x18,%rax\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nmov    0x877f(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8774(%rip)\nmov    0x876d(%rip),%rax\nmovq   $0x2,(%rax)\nmov    0x875f(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8754(%rip)\nmov    0x874d(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x8f,%edi\ncall   1d57 <expression>\nmov    0x8738(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\njmp    3a08 <expression+0x1cb1>\nmov    0x8716(%rip),%rax\ncmp    $0x90,%rax\njne    2c28 <expression+0xed1>\nmov    $0x90,%edi\ncall   1cff <match>\nmov    0x8705(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x86fa(%rip)\nmov    0x86f3(%rip),%rax\nmovq   $0x5,(%rax)\nmov    0x86e5(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x86da(%rip)\nmov    0x86d3(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x91,%edi\ncall   1d57 <expression>\nmov    0x86be(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nmovq   $0x1,0x8735(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x8691(%rip),%rax\ncmp    $0x91,%rax\njne    2cad <expression+0xf56>\nmov    $0x91,%edi\ncall   1cff <match>\nmov    0x8680(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8675(%rip)\nmov    0x866e(%rip),%rax\nmovq   $0x4,(%rax)\nmov    0x8660(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8655(%rip)\nmov    0x864e(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x92,%edi\ncall   1d57 <expression>\nmov    0x8639(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nmovq   $0x1,0x86b0(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x860c(%rip),%rax\ncmp    $0x92,%rax\njne    2d20 <expression+0xfc9>\nmov    $0x92,%edi\ncall   1cff <match>\nmov    0x85fb(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x85f0(%rip)\nmov    0x85e9(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x93,%edi\ncall   1d57 <expression>\nmov    0x85d1(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x85c6(%rip)\nmov    0x85bf(%rip),%rax\nmovq   $0xe,(%rax)\nmovq   $0x1,0x863d(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x8599(%rip),%rax\ncmp    $0x93,%rax\njne    2d93 <expression+0x103c>\nmov    $0x93,%edi\ncall   1cff <match>\nmov    0x8588(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x857d(%rip)\nmov    0x8576(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x94,%edi\ncall   1d57 <expression>\nmov    0x855e(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8553(%rip)\nmov    0x854c(%rip),%rax\nmovq   $0xf,(%rax)\nmovq   $0x1,0x85ca(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x8526(%rip),%rax\ncmp    $0x94,%rax\njne    2e06 <expression+0x10af>\nmov    $0x94,%edi\ncall   1cff <match>\nmov    0x8515(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x850a(%rip)\nmov    0x8503(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x95,%edi\ncall   1d57 <expression>\nmov    0x84eb(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x84e0(%rip)\nmov    0x84d9(%rip),%rax\nmovq   $0x10,(%rax)\nmovq   $0x1,0x8557(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x84b3(%rip),%rax\ncmp    $0x95,%rax\njne    2e79 <expression+0x1122>\nmov    $0x95,%edi\ncall   1cff <match>\nmov    0x84a2(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8497(%rip)\nmov    0x8490(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x96,%edi\ncall   1d57 <expression>\nmov    0x8478(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x846d(%rip)\nmov    0x8466(%rip),%rax\nmovq   $0x11,(%rax)\nmovq   $0x1,0x84e4(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x8440(%rip),%rax\ncmp    $0x96,%rax\njne    2eec <expression+0x1195>\nmov    $0x96,%edi\ncall   1cff <match>\nmov    0x842f(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8424(%rip)\nmov    0x841d(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x97,%edi\ncall   1d57 <expression>\nmov    0x8405(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x83fa(%rip)\nmov    0x83f3(%rip),%rax\nmovq   $0x12,(%rax)\nmovq   $0x1,0x8471(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x83cd(%rip),%rax\ncmp    $0x97,%rax\njne    2f5f <expression+0x1208>\nmov    $0x97,%edi\ncall   1cff <match>\nmov    0x83bc(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x83b1(%rip)\nmov    0x83aa(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x9b,%edi\ncall   1d57 <expression>\nmov    0x8392(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8387(%rip)\nmov    0x8380(%rip),%rax\nmovq   $0x13,(%rax)\nmovq   $0x1,0x83fe(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x835a(%rip),%rax\ncmp    $0x98,%rax\njne    2fd2 <expression+0x127b>\nmov    $0x98,%edi\ncall   1cff <match>\nmov    0x8349(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x833e(%rip)\nmov    0x8337(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x9b,%edi\ncall   1d57 <expression>\nmov    0x831f(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8314(%rip)\nmov    0x830d(%rip),%rax\nmovq   $0x14,(%rax)\nmovq   $0x1,0x838b(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x82e7(%rip),%rax\ncmp    $0x99,%rax\njne    3045 <expression+0x12ee>\nmov    $0x99,%edi\ncall   1cff <match>\nmov    0x82d6(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x82cb(%rip)\nmov    0x82c4(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x9b,%edi\ncall   1d57 <expression>\nmov    0x82ac(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x82a1(%rip)\nmov    0x829a(%rip),%rax\nmovq   $0x15,(%rax)\nmovq   $0x1,0x8318(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x8274(%rip),%rax\ncmp    $0x9a,%rax\njne    30b8 <expression+0x1361>\nmov    $0x9a,%edi\ncall   1cff <match>\nmov    0x8263(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8258(%rip)\nmov    0x8251(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x9b,%edi\ncall   1d57 <expression>\nmov    0x8239(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x822e(%rip)\nmov    0x8227(%rip),%rax\nmovq   $0x16,(%rax)\nmovq   $0x1,0x82a5(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x8201(%rip),%rax\ncmp    $0x9b,%rax\njne    312b <expression+0x13d4>\nmov    $0x9b,%edi\ncall   1cff <match>\nmov    0x81f0(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x81e5(%rip)\nmov    0x81de(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x9d,%edi\ncall   1d57 <expression>\nmov    0x81c6(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x81bb(%rip)\nmov    0x81b4(%rip),%rax\nmovq   $0x17,(%rax)\nmovq   $0x1,0x8232(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x818e(%rip),%rax\ncmp    $0x9c,%rax\njne    319e <expression+0x1447>\nmov    $0x9c,%edi\ncall   1cff <match>\nmov    0x817d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8172(%rip)\nmov    0x816b(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x9d,%edi\ncall   1d57 <expression>\nmov    0x8153(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8148(%rip)\nmov    0x8141(%rip),%rax\nmovq   $0x18,(%rax)\nmovq   $0x1,0x81bf(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x811b(%rip),%rax\ncmp    $0x9d,%rax\njne    32a6 <expression+0x154f>\nmov    $0x9d,%edi\ncall   1cff <match>\nmov    0x8106(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x80fb(%rip)\nmov    0x80f4(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x9f,%edi\ncall   1d57 <expression>\nmov    -0x18(%rbp),%rax\nmov    %rax,0x8168(%rip)\nmov    0x8161(%rip),%rax\ncmp    $0x2,%rax\njle    3281 <expression+0x152a>\nmov    0x80c0(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x80b5(%rip)\nmov    0x80ae(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x80a0(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8095(%rip)\nmov    0x808e(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x8080(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8075(%rip)\nmov    0x806e(%rip),%rax\nmovq   $0x8,(%rax)\nmov    0x8060(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8055(%rip)\nmov    0x804e(%rip),%rax\nmovq   $0x1b,(%rax)\nmov    0x8040(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x8035(%rip)\nmov    0x802e(%rip),%rax\nmovq   $0x19,(%rax)\njmp    3a08 <expression+0x1cb1>\nmov    0x8013(%rip),%rax\ncmp    $0x9e,%rax\njne    34a4 <expression+0x174d>\nmov    $0x9e,%edi\ncall   1cff <match>\nmov    0x7ffe(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7ff3(%rip)\nmov    0x7fec(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x9f,%edi\ncall   1d57 <expression>\ncmpq   $0x2,-0x18(%rbp)\njle    33b9 <expression+0x1662>\nmov    0x8059(%rip),%rax\ncmp    %rax,-0x18(%rbp)\njne    33b9 <expression+0x1662>\nmov    0x7fb8(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7fad(%rip)\nmov    0x7fa6(%rip),%rax\nmovq   $0x1a,(%rax)\nmov    0x7f98(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7f8d(%rip)\nmov    0x7f86(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x7f78(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7f6d(%rip)\nmov    0x7f66(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x7f58(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7f4d(%rip)\nmov    0x7f46(%rip),%rax\nmovq   $0x8,(%rax)\nmov    0x7f38(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7f2d(%rip)\nmov    0x7f26(%rip),%rax\nmovq   $0x1c,(%rax)\nmovq   $0x1,0x7fa4(%rip)\njmp    3a08 <expression+0x1cb1>\ncmpq   $0x2,-0x18(%rbp)\njle    3474 <expression+0x171d>\nmov    0x7efd(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7ef2(%rip)\nmov    0x7eeb(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x7edd(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7ed2(%rip)\nmov    0x7ecb(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x7ebd(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7eb2(%rip)\nmov    0x7eab(%rip),%rax\nmovq   $0x8,(%rax)\nmov    0x7e9d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7e92(%rip)\nmov    0x7e8b(%rip),%rax\nmovq   $0x1b,(%rax)\nmov    0x7e7d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7e72(%rip)\nmov    0x7e6b(%rip),%rax\nmovq   $0x1a,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,0x7ee9(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x7e4d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7e42(%rip)\nmov    0x7e3b(%rip),%rax\nmovq   $0x1a,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,0x7eb9(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x7e15(%rip),%rax\ncmp    $0x9f,%rax\njne    3517 <expression+0x17c0>\nmov    $0x9f,%edi\ncall   1cff <match>\nmov    0x7e04(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7df9(%rip)\nmov    0x7df2(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0xa2,%edi\ncall   1d57 <expression>\nmov    0x7dda(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7dcf(%rip)\nmov    0x7dc8(%rip),%rax\nmovq   $0x1b,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,0x7e46(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x7da2(%rip),%rax\ncmp    $0xa0,%rax\njne    358a <expression+0x1833>\nmov    $0xa0,%edi\ncall   1cff <match>\nmov    0x7d91(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7d86(%rip)\nmov    0x7d7f(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0xa2,%edi\ncall   1d57 <expression>\nmov    0x7d67(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7d5c(%rip)\nmov    0x7d55(%rip),%rax\nmovq   $0x1c,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,0x7dd3(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x7d2f(%rip),%rax\ncmp    $0xa1,%rax\njne    35fd <expression+0x18a6>\nmov    $0xa1,%edi\ncall   1cff <match>\nmov    0x7d1e(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7d13(%rip)\nmov    0x7d0c(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0xa2,%edi\ncall   1d57 <expression>\nmov    0x7cf4(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7ce9(%rip)\nmov    0x7ce2(%rip),%rax\nmovq   $0x1d,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,0x7d60(%rip)\njmp    3a08 <expression+0x1cb1>\nmov    0x7cbc(%rip),%rax\ncmp    $0xa2,%rax\nje     361f <expression+0x18c8>\nmov    0x7cad(%rip),%rax\ncmp    $0xa3,%rax\njne    3867 <expression+0x1b10>\nmov    0x7ca2(%rip),%rax\nmov    (%rax),%rax\ncmp    $0x9,%rax\njne    365f <expression+0x1908>\nmov    0x7c92(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x7c84(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7c79(%rip)\nmov    0x7c72(%rip),%rax\nmovq   $0x9,(%rax)\njmp    36c7 <expression+0x1970>\nmov    0x7c62(%rip),%rax\nmov    (%rax),%rax\ncmp    $0xa,%rax\njne    369f <expression+0x1948>\nmov    0x7c52(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x7c44(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7c39(%rip)\nmov    0x7c32(%rip),%rax\nmovq   $0xa,(%rax)\njmp    36c7 <expression+0x1970>\nmov    0x7c9a(%rip),%rax\nmov    %rax,%rsi\nlea    0x4c93(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x7bfa(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7bef(%rip)\nmov    0x7be8(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x7bda(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7bcf(%rip)\nmov    0x7bc8(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x7c4a(%rip),%rax\ncmp    $0x2,%rax\njle    371b <expression+0x19c4>\nmov    $0x8,%edx\njmp    3720 <expression+0x19c9>\nmov    $0x1,%edx\nmov    0x7ba1(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7b96(%rip)\nmov    0x7b8f(%rip),%rax\nmov    %rdx,(%rax)\nmov    0x7b7d(%rip),%rax\ncmp    $0xa2,%rax\njne    3752 <expression+0x19fb>\nmov    $0x19,%edx\njmp    3757 <expression+0x1a00>\nmov    $0x1a,%edx\nmov    0x7b6a(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7b5f(%rip)\nmov    0x7b58(%rip),%rax\nmov    %rdx,(%rax)\nmov    0x7bde(%rip),%rax\ntest   %rax,%rax\njne    3786 <expression+0x1a2f>\nmov    $0xc,%edx\njmp    378b <expression+0x1a34>\nmov    $0xb,%edx\nmov    0x7b36(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7b2b(%rip)\nmov    0x7b24(%rip),%rax\nmov    %rdx,(%rax)\nmov    0x7b1a(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7b0f(%rip)\nmov    0x7b08(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x7afa(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7aef(%rip)\nmov    0x7ae8(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x7b6a(%rip),%rax\ncmp    $0x2,%rax\njle    37fb <expression+0x1aa4>\nmov    $0x8,%edx\njmp    3800 <expression+0x1aa9>\nmov    $0x1,%edx\nmov    0x7ac1(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7ab6(%rip)\nmov    0x7aaf(%rip),%rax\nmov    %rdx,(%rax)\nmov    0x7a9d(%rip),%rax\ncmp    $0xa2,%rax\njne    3832 <expression+0x1adb>\nmov    $0x1a,%edx\njmp    3837 <expression+0x1ae0>\nmov    $0x19,%edx\nmov    0x7a8a(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7a7f(%rip)\nmov    0x7a78(%rip),%rax\nmov    %rdx,(%rax)\nmov    0x7a66(%rip),%rax\nmov    %rax,%rdi\ncall   1cff <match>\njmp    3a08 <expression+0x1cb1>\nmov    0x7a52(%rip),%rax\ncmp    $0xa4,%rax\njne    39d9 <expression+0x1c82>\nmov    $0xa4,%edi\ncall   1cff <match>\nmov    0x7a3d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7a32(%rip)\nmov    0x7a2b(%rip),%rax\nmovq   $0xd,(%rax)\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    $0x5d,%edi\ncall   1cff <match>\ncmpq   $0x2,-0x18(%rbp)\njle    3945 <expression+0x1bee>\nmov    0x79fe(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x79f3(%rip)\nmov    0x79ec(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x79de(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x79d3(%rip)\nmov    0x79cc(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x79be(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x79b3(%rip)\nmov    0x79ac(%rip),%rax\nmovq   $0x8,(%rax)\nmov    0x799e(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7993(%rip)\nmov    0x798c(%rip),%rax\nmovq   $0x1b,(%rax)\njmp    3974 <expression+0x1c1d>\ncmpq   $0x1,-0x18(%rbp)\njg     3974 <expression+0x1c1d>\nmov    0x79ed(%rip),%rax\nmov    %rax,%rsi\nlea    0x4a03(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    -0x18(%rbp),%rax\nsub    $0x2,%rax\nmov    %rax,0x79d5(%rip)\nmov    0x793e(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7933(%rip)\nmov    0x792c(%rip),%rax\nmovq   $0x19,(%rax)\nmov    0x79ae(%rip),%rax\ntest   %rax,%rax\njne    39b6 <expression+0x1c5f>\nmov    $0xa,%edx\njmp    39bb <expression+0x1c64>\nmov    $0x9,%edx\nmov    0x7906(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x78fb(%rip)\nmov    0x78f4(%rip),%rax\nmov    %rdx,(%rax)\njmp    3a08 <expression+0x1cb1>\nmov    0x78e0(%rip),%rdx\nmov    0x7959(%rip),%rax\nmov    %rax,%rsi\nlea    0x498f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x78b1(%rip),%rax\ncmp    %rax,-0x28(%rbp)\njle    29ba <expression+0xc63>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "function_body", "content": "void function_body() {\n    // type func_name (...) {...}\n    //                   -->|   |<--\n\n    // ... {\n    // 1. local declarations\n    // 2. statements\n    // }\n\n    long pos_local; // position of local variables on the stack.\n    long type;\n    pos_local = index_of_bp;\n\n    while (token == Int || token == Char) {\n        // local variable declaration, just like global ones.\n        basetype = (token == Int) ? INT : CHAR;\n        match(token);\n\n        while (token != ';') {\n            type = basetype;\n            while (token == Mul) {\n                match(Mul);\n                type = type + PTR;\n            }\n\n            if (token != Id) {\n                // invalid declaration\n                libmin_printf(\"%ld: bad local declaration\\n\", line);\n                libmin_fail(-1);\n            }\n            if (current_id[Class] == Loc) {\n                // identifier exists\n                libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n                libmin_fail(-1);\n            }\n            match(Id);\n\n            // store the local variable\n            current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;\n            current_id[BType]  = current_id[Type];  current_id[Type]   = type;\n            current_id[BValue] = current_id[Value]; current_id[Value]  = ++pos_local;   // index of current parameter\n\n            if (token == ',') {\n                match(',');\n            }\n        }\n        match(';');\n    }\n\n    // save the stack size for local variables\n    *++text = ENT;\n    *++text = pos_local - index_of_bp;\n\n    // statements\n    while (token != '}') {\n        statement();\n    }\n\n    // emit code for leaving the sub function\n    *++text = LEV;\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O0.pseudo", "function_name": "function_body", "address": "0x3fdf", "label": "function_body", "content": "void __cdecl function_body()\n{\n  __int64 pos_local; // [rsp+0h] [rbp-10h]\n  __int64 type; // [rsp+8h] [rbp-8h]\n\n  pos_local = index_of_bp;\n  while ( token == 138 || token == 134 )\n  {\n    basetype = token == 138;\n    match(token);\n    while ( token != 59 )\n    {\n      type = basetype;\n      while ( token == 159 )\n      {\n        match(159LL);\n        type += 2LL;\n      }\n      if ( token != 133 )\n      {\n        libmin_printf(\"%ld: bad local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] == 132 )\n      {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      current_id[7] = current_id[4];\n      current_id[4] = 132LL;\n      current_id[6] = current_id[3];\n      current_id[3] = type;\n      current_id[8] = current_id[5];\n      current_id[5] = ++pos_local;\n      if ( token == 44 )\n        match(44LL);\n    }\n    match(59LL);\n  }\n  text = (char *)text + 8;\n  *(_QWORD *)text = 6LL;\n  text = (char *)text + 8;\n  *(_QWORD *)text = pos_local - index_of_bp;\n  while ( token != 125 )\n    statement();\n  text = (char *)text + 8;\n  *(_QWORD *)text = 8LL;\n}\n"}, "pseudo_normalize": "void function_body() {\n  long long pos_local;\n  long long type;\n  pos_local = index_of_bp;\n  while (token == 138 || token == 134) {\n    basetype = token == 138;\n    match(token);\n    while (token != 59) {\n      type = basetype;\n      while (token == 159) {\n        match(159LL);\n        type += 2LL;\n      }\n      if (token != 133) {\n        libmin_printf(\"%ld: bad local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4] == 132) {\n        libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      current_id[7] = current_id[4];\n      current_id[4] = 132LL;\n      current_id[6] = current_id[3];\n      current_id[3] = type;\n      current_id[8] = current_id[5];\n      current_id[5] = ++pos_local;\n      if (token == 44) match(44LL);\n    }\n    match(59LL);\n  }\n  text = (char *)text + 8;\n  *(uint64_t *)text = 6LL;\n  text = (char *)text + 8;\n  *(uint64_t *)text = pos_local - index_of_bp;\n  while (token != 125) statement();\n  text = (char *)text + 8;\n  *(uint64_t *)text = 8LL;\n}", "binary": "c-interp/c-interp.host.O0", "assembly": "<function_body>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    0x736e(%rip),%rax\nmov    %rax,-0x10(%rbp)\njmp    418b <function_body+0x1ac>\nmov    0x72be(%rip),%rax\ncmp    $0x8a,%rax\nsete   %al\nmovzbl %al,%eax\nmov    %rax,0x733b(%rip)\nmov    0x72a4(%rip),%rax\nmov    %rax,%rdi\ncall   1cff <match>\njmp    4170 <function_body+0x191>\nmov    0x7320(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    4045 <function_body+0x66>\nmov    $0x9f,%edi\ncall   1cff <match>\naddq   $0x2,-0x8(%rbp)\nmov    0x7274(%rip),%rax\ncmp    $0x9f,%rax\nje     4036 <function_body+0x57>\nmov    0x7265(%rip),%rax\ncmp    $0x85,%rax\nje     408b <function_body+0xac>\nmov    0x72d6(%rip),%rax\nmov    %rax,%rsi\nlea    0x43b2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x729e(%rip),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ncmp    $0x84,%rax\njne    40c9 <function_body+0xea>\nmov    0x7298(%rip),%rax\nmov    %rax,%rsi\nlea    0x4396(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    $0x85,%edi\ncall   1cff <match>\nmov    0x7256(%rip),%rax\nmov    0x724f(%rip),%rdx\nadd    $0x38,%rdx\nmov    0x20(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x723d(%rip),%rax\nadd    $0x20,%rax\nmovq   $0x84,(%rax)\nmov    0x722b(%rip),%rax\nmov    0x7224(%rip),%rdx\nadd    $0x30,%rdx\nmov    0x18(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x7212(%rip),%rax\nlea    0x18(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\nmov    0x7200(%rip),%rax\nmov    0x71f9(%rip),%rdx\nadd    $0x40,%rdx\nmov    0x28(%rax),%rax\nmov    %rax,(%rdx)\naddq   $0x1,-0x10(%rbp)\nmov    0x71e2(%rip),%rax\nlea    0x28(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,(%rdx)\nmov    0x7160(%rip),%rax\ncmp    $0x2c,%rax\njne    4170 <function_body+0x191>\nmov    $0x2c,%edi\ncall   1cff <match>\nmov    0x7149(%rip),%rax\ncmp    $0x3b,%rax\njne    4029 <function_body+0x4a>\nmov    $0x3b,%edi\ncall   1cff <match>\nmov    0x712e(%rip),%rax\ncmp    $0x8a,%rax\nje     3ffb <function_body+0x1c>\nmov    0x711b(%rip),%rax\ncmp    $0x86,%rax\nje     3ffb <function_body+0x1c>\nmov    0x7110(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7105(%rip)\nmov    0x70fe(%rip),%rax\nmovq   $0x6,(%rax)\nmov    0x7188(%rip),%rcx\nmov    0x70e9(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x70de(%rip)\nmov    0x70d7(%rip),%rax\nmov    -0x10(%rbp),%rdx\nsub    %rcx,%rdx\nmov    %rdx,(%rax)\njmp    4207 <function_body+0x228>\nmov    $0x0,%eax\ncall   3a1d <statement>\nmov    0x70b2(%rip),%rax\ncmp    $0x7d,%rax\njne    41fd <function_body+0x21e>\nmov    0x70ad(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x70a2(%rip)\nmov    0x709b(%rip),%rax\nmovq   $0x8,(%rax)\nnop\nleave\nret\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "function_declaration", "content": "void function_declaration() {\n    // type func_name (...) {...}\n    //               | this part\n\n    match('(');\n    function_parameter();\n    match(')');\n    match('{');\n    function_body();\n    //match('}');\n\n    // unwind local variable declarations for all local variables.\n    current_id = symbols;\n    while (current_id[Token]) {\n        if (current_id[Class] == Loc) {\n            current_id[Class] = current_id[BClass];\n            current_id[Type]  = current_id[BType];\n            current_id[Value] = current_id[BValue];\n        }\n        current_id = current_id + IdSize;\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O0.pseudo", "function_name": "function_declaration", "address": "0x4237", "label": "function_declaration", "content": "void __cdecl function_declaration()\n{\n  match(40LL);\n  function_parameter();\n  match(41LL);\n  match(123LL);\n  function_body();\n  for ( current_id = (__int64 *)symbols; *current_id; current_id += 9 )\n  {\n    if ( current_id[4] == 132 )\n    {\n      current_id[4] = current_id[7];\n      current_id[3] = current_id[6];\n      current_id[5] = current_id[8];\n    }\n  }\n}\n"}, "pseudo_normalize": "void function_declaration() {\n  match(40LL);\n  function_parameter();\n  match(41LL);\n  match(123LL);\n  function_body();\n  for (current_id = (long long *)symbols; *current_id; current_id += 9) {\n    if (current_id[4] == 132) {\n      current_id[4] = current_id[7];\n      current_id[3] = current_id[6];\n      current_id[5] = current_id[8];\n    }\n  }\n}", "binary": "c-interp/c-interp.host.O0", "assembly": "<function_declaration>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x28,%edi\ncall   1cff <match>\nmov    $0x0,%eax\ncall   3e20 <function_parameter>\nmov    $0x29,%edi\ncall   1cff <match>\nmov    $0x7b,%edi\ncall   1cff <match>\nmov    $0x0,%eax\ncall   3fdf <function_body>\nmov    0x70c0(%rip),%rax\nmov    %rax,0x70b1(%rip)\njmp    42f4 <function_declaration+0xbd>\nmov    0x70a8(%rip),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ncmp    $0x84,%rax\njne    42e2 <function_declaration+0xab>\nmov    0x7092(%rip),%rax\nmov    0x708b(%rip),%rdx\nadd    $0x20,%rdx\nmov    0x38(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x7079(%rip),%rax\nmov    0x7072(%rip),%rdx\nadd    $0x18,%rdx\nmov    0x30(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x7060(%rip),%rax\nmov    0x7059(%rip),%rdx\nadd    $0x28,%rdx\nmov    0x40(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x7047(%rip),%rax\nadd    $0x48,%rax\nmov    %rax,0x703c(%rip)\nmov    0x7035(%rip),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    4281 <function_declaration+0x4a>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "function_parameter", "content": "void function_parameter() {\n    long type;\n    long params;\n    params = 0;\n    while (token != ')') {\n        // int name, ...\n        type = INT;\n        if (token == Int) {\n            match(Int);\n        } else if (token == Char) {\n            type = CHAR;\n            match(Char);\n        }\n\n        // pointer type\n        while (token == Mul) {\n            match(Mul);\n            type = type + PTR;\n        }\n\n        // parameter name\n        if (token != Id) {\n            libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        if (current_id[Class] == Loc) {\n            libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n            libmin_fail(-1);\n        }\n\n        match(Id);\n        // store the local variable\n        current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;\n        current_id[BType]  = current_id[Type];  current_id[Type]   = type;\n        current_id[BValue] = current_id[Value]; current_id[Value]  = params++;   // index of current parameter\n\n        if (token == ',') {\n            match(',');\n        }\n    }\n    index_of_bp = params+1;\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O0.pseudo", "function_name": "function_parameter", "address": "0x3e20", "label": "function_parameter", "content": "void __cdecl function_parameter()\n{\n  __int64 v0; // rax\n  __int64 type; // [rsp+0h] [rbp-10h]\n  __int64 params; // [rsp+8h] [rbp-8h]\n\n  params = 0LL;\n  while ( token != 41 )\n  {\n    type = 1LL;\n    if ( token == 138 )\n    {\n      match(138LL);\n    }\n    else if ( token == 134 )\n    {\n      type = 0LL;\n      match(134LL);\n    }\n    while ( token == 159 )\n    {\n      match(159LL);\n      type += 2LL;\n    }\n    if ( token != 133 )\n    {\n      libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    if ( current_id[4] == 132 )\n    {\n      libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    match(133LL);\n    current_id[7] = current_id[4];\n    current_id[4] = 132LL;\n    current_id[6] = current_id[3];\n    current_id[3] = type;\n    current_id[8] = current_id[5];\n    v0 = params++;\n    current_id[5] = v0;\n    if ( token == 44 )\n      match(44LL);\n  }\n  index_of_bp = params + 1;\n}\n"}, "pseudo_normalize": "void function_parameter() {\n  long long v0;\n  long long type;\n  long long params;\n  params = 0LL;\n  while (token != 41) {\n    type = 1LL;\n    if (token == 138) {\n      match(138LL);\n    } else if (token == 134) {\n      type = 0LL;\n      match(134LL);\n    }\n    while (token == 159) {\n      match(159LL);\n      type += 2LL;\n    }\n    if (token != 133) {\n      libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    if (current_id[4] == 132) {\n      libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n      libmin_fail(-1);\n    }\n    match(133LL);\n    current_id[7] = current_id[4];\n    current_id[4] = 132LL;\n    current_id[6] = current_id[3];\n    current_id[3] = type;\n    current_id[8] = current_id[5];\n    v0 = params++;\n    current_id[5] = v0;\n    if (token == 44) match(44LL);\n  }\n  index_of_bp = params + 1;\n}", "binary": "c-interp/c-interp.host.O0", "assembly": "<function_parameter>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovq   $0x0,-0x8(%rbp)\njmp    3fbc <function_parameter+0x19c>\nmovq   $0x1,-0x10(%rbp)\nmov    0x7478(%rip),%rax\ncmp    $0x8a,%rax\njne    3e5c <function_parameter+0x3c>\nmov    $0x8a,%edi\ncall   1cff <match>\njmp    3e8e <function_parameter+0x6e>\nmov    0x745d(%rip),%rax\ncmp    $0x86,%rax\njne    3e8e <function_parameter+0x6e>\nmovq   $0x0,-0x10(%rbp)\nmov    $0x86,%edi\ncall   1cff <match>\njmp    3e8e <function_parameter+0x6e>\nmov    $0x9f,%edi\ncall   1cff <match>\naddq   $0x2,-0x10(%rbp)\nmov    0x742b(%rip),%rax\ncmp    $0x9f,%rax\nje     3e7f <function_parameter+0x5f>\nmov    0x741c(%rip),%rax\ncmp    $0x85,%rax\nje     3ed4 <function_parameter+0xb4>\nmov    0x748d(%rip),%rax\nmov    %rax,%rsi\nlea    0x4523(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x7455(%rip),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ncmp    $0x84,%rax\njne    3f12 <function_parameter+0xf2>\nmov    0x744f(%rip),%rax\nmov    %rax,%rsi\nlea    0x4505(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    $0x85,%edi\ncall   1cff <match>\nmov    0x740d(%rip),%rax\nmov    0x7406(%rip),%rdx\nadd    $0x38,%rdx\nmov    0x20(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x73f4(%rip),%rax\nadd    $0x20,%rax\nmovq   $0x84,(%rax)\nmov    0x73e2(%rip),%rax\nmov    0x73db(%rip),%rdx\nadd    $0x30,%rdx\nmov    0x18(%rax),%rax\nmov    %rax,(%rdx)\nmov    0x73c9(%rip),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,(%rdx)\nmov    0x73b7(%rip),%rax\nmov    0x73b0(%rip),%rdx\nadd    $0x40,%rdx\nmov    0x28(%rax),%rax\nmov    %rax,(%rdx)\nmov    -0x8(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x8(%rbp)\nmov    0x7392(%rip),%rdx\nadd    $0x28,%rdx\nmov    %rax,(%rdx)\nmov    0x7314(%rip),%rax\ncmp    $0x2c,%rax\njne    3fbc <function_parameter+0x19c>\nmov    $0x2c,%edi\ncall   1cff <match>\nmov    0x72fd(%rip),%rax\ncmp    $0x29,%rax\njne    3e39 <function_parameter+0x19>\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,0x7384(%rip)\nnop\nleave\nret\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "global_declaration", "content": "void global_declaration() {\n    // long [*]id [; | (...) {...}]\n\n\n    long type; // tmp, actual type for variable\n\n    basetype = INT;\n\n    // parse enum, this should be treated alone.\n    if (token == Enum) {\n        // enum [id] { a = 10, b = 20, ... }\n        match(Enum);\n        if (token != '{') {\n            match(Id); // skip the [id] part\n        }\n        if (token == '{') {\n            // parse the assign part\n            match('{');\n            enum_declaration();\n            match('}');\n        }\n\n        match(';');\n        return;\n    }\n\n    // parse type information\n    if (token == Int) {\n        match(Int);\n    }\n    else if (token == Char) {\n        match(Char);\n        basetype = CHAR;\n    }\n\n    // parse the comma seperated variable declaration.\n    while (token != ';' && token != '}') {\n        type = basetype;\n        // parse pointer type, note that there may exist `int ****x;`\n        while (token == Mul) {\n            match(Mul);\n            type = type + PTR;\n        }\n\n        if (token != Id) {\n            // invalid declaration\n            libmin_printf(\"%ld: bad global declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        if (current_id[Class]) {\n            // identifier exists\n            libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        match(Id);\n        current_id[Type] = type;\n\n        if (token == '(') {\n            current_id[Class] = Fun;\n            current_id[Value] = (long)(text + 1); // the memory address of function\n            function_declaration();\n        } else {\n            // variable declaration\n            current_id[Class] = Glo; // global variable\n            current_id[Value] = (long)data; // assign memory address\n            data = data + sizeof(long);\n        }\n\n        if (token == ',') {\n            match(',');\n        }\n    }\n    next();\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O0.pseudo", "function_name": "global_declaration", "address": "0x430b", "label": "global_declaration", "content": "void __cdecl global_declaration()\n{\n  __int64 type; // [rsp+8h] [rbp-8h]\n\n  basetype = 1LL;\n  if ( token == 136 )\n  {\n    match(136LL);\n    if ( token != 123 )\n      match(133LL);\n    if ( token == 123 )\n    {\n      match(123LL);\n      enum_declaration();\n      match(125LL);\n    }\n    match(59LL);\n  }\n  else\n  {\n    if ( token == 138 )\n    {\n      match(138LL);\n    }\n    else if ( token == 134 )\n    {\n      match(134LL);\n      basetype = 0LL;\n    }\n    while ( token != 59 && token != 125 )\n    {\n      type = basetype;\n      while ( token == 159 )\n      {\n        match(159LL);\n        type += 2LL;\n      }\n      if ( token != 133 )\n      {\n        libmin_printf(\"%ld: bad global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] )\n      {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      current_id[3] = type;\n      if ( token == 40 )\n      {\n        current_id[4] = 129LL;\n        current_id[5] = (__int64)text + 8;\n        function_declaration();\n      }\n      else\n      {\n        current_id[4] = 131LL;\n        current_id[5] = (__int64)data;\n        data += 8;\n      }\n      if ( token == 44 )\n        match(44LL);\n    }\n    next();\n  }\n}\n"}, "pseudo_normalize": "void global_declaration() {\n  long long type;\n  basetype = 1LL;\n  if (token == 136) {\n    match(136LL);\n    if (token != 123) match(133LL);\n    if (token == 123) {\n      match(123LL);\n      enum_declaration();\n      match(125LL);\n    }\n    match(59LL);\n  } else {\n    if (token == 138) {\n      match(138LL);\n    } else if (token == 134) {\n      match(134LL);\n      basetype = 0LL;\n    }\n    while (token != 59 && token != 125) {\n      type = basetype;\n      while (token == 159) {\n        match(159LL);\n        type += 2LL;\n      }\n      if (token != 133) {\n        libmin_printf(\"%ld: bad global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4]) {\n        libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      match(133LL);\n      current_id[3] = type;\n      if (token == 40) {\n        current_id[4] = 129LL;\n        current_id[5] = (long long)text + 8;\n        function_declaration();\n      } else {\n        current_id[4] = 131LL;\n        current_id[5] = (long long)data;\n        data += 8;\n      }\n      if (token == 44) match(44LL);\n    }\n    next();\n  }\n}", "binary": "c-interp/c-interp.host.O0", "assembly": "<global_declaration>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovq   $0x1,0x702e(%rip)\nmov    0x6f97(%rip),%rax\ncmp    $0x88,%rax\njne    438c <global_declaration+0x81>\nmov    $0x88,%edi\ncall   1cff <match>\nmov    0x6f7e(%rip),%rax\ncmp    $0x7b,%rax\nje     4352 <global_declaration+0x47>\nmov    $0x85,%edi\ncall   1cff <match>\nmov    0x6f67(%rip),%rax\ncmp    $0x7b,%rax\njne    437d <global_declaration+0x72>\nmov    $0x7b,%edi\ncall   1cff <match>\nmov    $0x0,%eax\ncall   3cf0 <enum_declaration>\nmov    $0x7d,%edi\ncall   1cff <match>\nmov    $0x3b,%edi\ncall   1cff <match>\njmp    454c <global_declaration+0x241>\nmov    0x6f2d(%rip),%rax\ncmp    $0x8a,%rax\njne    43aa <global_declaration+0x9f>\nmov    $0x8a,%edi\ncall   1cff <match>\njmp    4524 <global_declaration+0x219>\nmov    0x6f0f(%rip),%rax\ncmp    $0x86,%rax\njne    4524 <global_declaration+0x219>\nmov    $0x86,%edi\ncall   1cff <match>\nmovq   $0x0,0x6f7e(%rip)\njmp    4524 <global_declaration+0x219>\nmov    0x6f72(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    43f3 <global_declaration+0xe8>\nmov    $0x9f,%edi\ncall   1cff <match>\naddq   $0x2,-0x8(%rbp)\nmov    0x6ec6(%rip),%rax\ncmp    $0x9f,%rax\nje     43e4 <global_declaration+0xd9>\nmov    0x6eb7(%rip),%rax\ncmp    $0x85,%rax\nje     4439 <global_declaration+0x12e>\nmov    0x6f28(%rip),%rax\nmov    %rax,%rsi\nlea    0x4048(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    0x6ef0(%rip),%rax\nadd    $0x20,%rax\nmov    (%rax),%rax\ntest   %rax,%rax\nje     4474 <global_declaration+0x169>\nmov    0x6eed(%rip),%rax\nmov    %rax,%rsi\nlea    0x402b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nmov    $0x85,%edi\ncall   1cff <match>\nmov    0x6eab(%rip),%rax\nlea    0x18(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\nmov    0x6e29(%rip),%rax\ncmp    $0x28,%rax\njne    44d4 <global_declaration+0x1c9>\nmov    0x6e8c(%rip),%rax\nadd    $0x20,%rax\nmovq   $0x81,(%rax)\nmov    0x6e12(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    0x6e6f(%rip),%rax\nadd    $0x28,%rax\nmov    %rdx,(%rax)\nmov    $0x0,%eax\ncall   4237 <function_declaration>\njmp    450d <global_declaration+0x202>\nmov    0x6e55(%rip),%rax\nadd    $0x20,%rax\nmovq   $0x83,(%rax)\nmov    0x6df3(%rip),%rdx\nmov    0x6e3c(%rip),%rax\nadd    $0x28,%rax\nmov    %rdx,(%rax)\nmov    0x6dde(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x6dd3(%rip)\nmov    0x6dac(%rip),%rax\ncmp    $0x2c,%rax\njne    4524 <global_declaration+0x219>\nmov    $0x2c,%edi\ncall   1cff <match>\nmov    0x6d95(%rip),%rax\ncmp    $0x3b,%rax\nje     4542 <global_declaration+0x237>\nmov    0x6d88(%rip),%rax\ncmp    $0x7d,%rax\njne    43d7 <global_declaration+0xcc>\nmov    $0x0,%eax\ncall   11e9 <next>\nleave\nret\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "main", "content": "int main(int _argc, char **_argv)\n{\n\n    long i;\n    long *tmp;\n\n    int argc = 2;\n    char *myargv[2] = { \"c-interp\", \"hello.c\" };\n    char **argv = myargv;\n\n    argc--;\n    argv++;\n\n#if 0\n    // parse arguments\n    if (argc > 0 && **argv == '-' && (*argv)[1] == 's') {\n        assembly = 1;\n        --argc;\n        ++argv;\n    }\n    if (argc > 0 && **argv == '-' && (*argv)[1] == 'd') {\n        debug = 1;\n        --argc;\n        ++argv;\n    }\n    if (argc < 1) {\n        libmin_printf(\"usage: xc [-s] [-d] file ...\\n\");\n        return -1;\n    }\n#endif\n\n    libmin_mopen(mhello, \"r\");\n\n    poolsize = 256 * 1024; // arbitrary size\n    line = 1;\n\n    // allocate memory\n    if (!(text = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n        return -1;\n    }\n    if (!(data = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n        return -1;\n    }\n    if (!(stack = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n    }\n    if (!(symbols = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n        return -1;\n    }\n\n    libmin_memset(text, 0, poolsize);\n    libmin_memset(data, 0, poolsize);\n    libmin_memset(stack, 0, poolsize);\n    libmin_memset(symbols, 0, poolsize);\n\n    old_text = text;\n\n    src = \"char else enum if int return sizeof while \"\n          \"open read close printf malloc memset memcmp exit void main\";\n\n     // add keywords to symbol table\n    i = Char;\n    while (i <= While) {\n        next();\n        current_id[Token] = i++;\n    }\n\n    // add library to symbol table\n    i = OPEN;\n    while (i <= EXIT) {\n        next();\n        current_id[Class] = Sys;\n        current_id[Type] = INT;\n        current_id[Value] = i++;\n    }\n\n    next(); current_id[Token] = Char; // handle void type\n    next(); idmain = current_id; // keep track of main\n\n    if (!(src = old_src = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n        return -1;\n    }\n    // read the source file\n    if ((i = libmin_mread(src, poolsize-1, mhello)) <= 0) {\n        libmin_printf(\"read() returned %ld\\n\", i);\n        return -1;\n    }\n    src[i] = 0; // add EOF character\n    libmin_mclose(mhello);\n\n    program();\n\n    if (!(pc = (long *)idmain[Value])) {\n        libmin_printf(\"main() not defined\\n\");\n        return -1;\n    }\n\n    // dump_text();\n    if (assembly) {\n        // only for compile\n        return 0;\n    }\n\n    // setup stack\n    sp = (long *)((long)stack + poolsize);\n    *--sp = EXIT; // call exit if main returns\n    *--sp = PUSH; tmp = sp;\n    *--sp = 1;\n    *--sp = (long)argv;\n    *--sp = (long)tmp;\n\n    (void)eval();\n\n    libmin_success();\n    return 9;\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O0.pseudo", "function_name": "main", "address": "0x4e03", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  __int64 v4; // rax\n  __int64 v5; // rax\n  __int64 i; // [rsp+18h] [rbp-38h]\n  __int64 ia; // [rsp+18h] [rbp-38h]\n  signed __int64 ib; // [rsp+18h] [rbp-38h]\n  __int64 *tmp; // [rsp+28h] [rbp-28h]\n  char *myargv[2]; // [rsp+30h] [rbp-20h] BYREF\n  unsigned __int64 v11; // [rsp+48h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  myargv[1] = \"hello.c\";\n  libmin_mopen(mhello, \"r\");\n  poolsize = 0x40000LL;\n  line = 1LL;\n  text = libmin_malloc(0x40000uLL);\n  if ( text )\n  {\n    data = (char *)libmin_malloc(poolsize);\n    if ( data )\n    {\n      stack = libmin_malloc(poolsize);\n      if ( stack )\n      {\n        symbols = libmin_malloc(poolsize);\n        if ( symbols )\n        {\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (__int64 *)text;\n          src = \"char else enum if int return sizeof while open read close printf malloc memset memcmp exit void main\";\n          for ( i = 134LL; i <= 141; ++i )\n          {\n            next();\n            v4 = i;\n            *current_id = v4;\n          }\n          for ( ia = 30LL; ia <= 37; ++ia )\n          {\n            next();\n            current_id[4] = 130LL;\n            current_id[3] = 1LL;\n            v5 = ia;\n            current_id[5] = v5;\n          }\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          old_src = (char *)libmin_malloc(poolsize);\n          src = old_src;\n          if ( old_src )\n          {\n            ib = libmin_mread(src, poolsize - 1, mhello);\n            if ( ib > 0 )\n            {\n              src[ib] = 0;\n              libmin_mclose(mhello);\n              program();\n              pc = (__int64 *)idmain[5];\n              if ( pc )\n              {\n                if ( !assembly )\n                {\n                  qword_B318 = (__int64 *)((char *)stack + poolsize - 8);\n                  *(_QWORD *)((char *)stack + poolsize - 8) = 37LL;\n                  *--qword_B318 = 13LL;\n                  tmp = qword_B318--;\n                  *qword_B318-- = 1LL;\n                  *qword_B318-- = (__int64)&myargv[1];\n                  *qword_B318 = (__int64)tmp;\n                  eval();\n                  libmin_success();\n                }\n                return 0;\n              }\n              else\n              {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            }\n            else\n            {\n              libmin_printf(\"read() returned %ld\\n\", ib);\n              return -1;\n            }\n          }\n          else\n          {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        }\n        else\n        {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      }\n      else\n      {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    }\n    else\n    {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  }\n  else\n  {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  long long v4;\n  long long v5;\n  long long i;\n  long long ia;\n  signed long long ib;\n  long long *tmp;\n  char *myargv[2];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  myargv[1] = \"hello.c\";\n  libmin_mopen(mhello, \"r\");\n  poolsize = 262144LL;\n  line = 1LL;\n  text = libmin_malloc(262144uLL);\n  if (text) {\n    data = (char *)libmin_malloc(poolsize);\n    if (data) {\n      stack = libmin_malloc(poolsize);\n      if (stack) {\n        symbols = libmin_malloc(poolsize);\n        if (symbols) {\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (long long *)text;\n          src =\n              \"char else enum if int return sizeof while open read close \"\n              \"printf malloc memset memcmp exit void main\";\n          for (i = 134LL; i <= 141; ++i) {\n            next();\n            v4 = i;\n            *current_id = v4;\n          }\n          for (ia = 30LL; ia <= 37; ++ia) {\n            next();\n            current_id[4] = 130LL;\n            current_id[3] = 1LL;\n            v5 = ia;\n            current_id[5] = v5;\n          }\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          old_src = (char *)libmin_malloc(poolsize);\n          src = old_src;\n          if (old_src) {\n            ib = libmin_mread(src, poolsize - 1, mhello);\n            if (ib > 0) {\n              src[ib] = 0;\n              libmin_mclose(mhello);\n              program();\n              pc = (long long *)idmain[5];\n              if (pc) {\n                if (!assembly) {\n                  qword_B318 = (long long *)((char *)stack + poolsize - 8);\n                  *(uint64_t *)((char *)stack + poolsize - 8) = 37LL;\n                  *--qword_B318 = 13LL;\n                  tmp = qword_B318--;\n                  *qword_B318-- = 1LL;\n                  *qword_B318-- = (long long)&myargv[1];\n                  *qword_B318 = (long long)tmp;\n                  eval();\n                  libmin_success();\n                }\n                return 0;\n              } else {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            } else {\n              libmin_printf(\"read() returned %ld\\n\", ib);\n              return -1;\n            }\n          } else {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        } else {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      } else {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    } else {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  } else {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n}", "binary": "c-interp/c-interp.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x2,-0x3c(%rbp)\nlea    0x36a5(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x3302(%rip),%rax\nmov    %rax,-0x18(%rbp)\nlea    -0x20(%rbp),%rax\nmov    %rax,-0x30(%rbp)\nsubl   $0x1,-0x3c(%rbp)\naddq   $0x8,-0x30(%rbp)\nmov    0x61e6(%rip),%rax\nlea    0x3680(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   59d6 <libmin_mopen>\nmovq   $0x40000,0x6489(%rip)\nmovq   $0x1,0x64be(%rip)\nmov    0x6477(%rip),%rax\nmov    %rax,%rdi\ncall   54de <libmin_malloc>\nmov    %rax,0x6430(%rip)\nmov    0x6429(%rip),%rax\ntest   %rax,%rax\njne    4ecc <main+0xc9>\nmov    0x6455(%rip),%rax\nmov    %rax,%rsi\nlea    0x3633(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x642d(%rip),%rax\nmov    %rax,%rdi\ncall   54de <libmin_malloc>\nmov    %rax,0x63fe(%rip)\nmov    0x63f7(%rip),%rax\ntest   %rax,%rax\njne    4f16 <main+0x113>\nmov    0x640b(%rip),%rax\nmov    %rax,%rsi\nlea    0x3611(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x63e3(%rip),%rax\nmov    %rax,%rdi\ncall   54de <libmin_malloc>\nmov    %rax,0x63a4(%rip)\nmov    0x639d(%rip),%rax\ntest   %rax,%rax\njne    4f60 <main+0x15d>\nmov    0x63c1(%rip),%rax\nmov    %rax,%rsi\nlea    0x35ef(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x6399(%rip),%rax\nmov    %rax,%rdi\ncall   54de <libmin_malloc>\nmov    %rax,0x63c2(%rip)\nmov    0x63bb(%rip),%rax\ntest   %rax,%rax\njne    4faa <main+0x1a7>\nmov    0x6377(%rip),%rax\nmov    %rax,%rsi\nlea    0x35cd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x634f(%rip),%rax\nmov    %rax,%rdx\nmov    0x630d(%rip),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   58ba <libmin_memset>\nmov    0x6331(%rip),%rax\nmov    %rax,%rdx\nmov    0x6307(%rip),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   58ba <libmin_memset>\nmov    0x6313(%rip),%rax\nmov    %rax,%rdx\nmov    0x62d9(%rip),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   58ba <libmin_memset>\nmov    0x62f5(%rip),%rax\nmov    %rax,%rdx\nmov    0x6323(%rip),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   58ba <libmin_memset>\nmov    0x629f(%rip),%rax\nmov    %rax,0x62a8(%rip)\nlea    0x3551(%rip),%rax\nmov    %rax,0x62b2(%rip)\nmovq   $0x86,-0x38(%rbp)\njmp    5068 <main+0x265>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    -0x38(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x38(%rbp)\nmov    0x62cb(%rip),%rdx\nmov    %rax,(%rdx)\ncmpq   $0x8d,-0x38(%rbp)\njle    5048 <main+0x245>\nmovq   $0x1e,-0x38(%rbp)\njmp    50c4 <main+0x2c1>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x62a3(%rip),%rax\nadd    $0x20,%rax\nmovq   $0x82,(%rax)\nmov    0x6291(%rip),%rax\nadd    $0x18,%rax\nmovq   $0x1,(%rax)\nmov    -0x38(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x38(%rbp)\nmov    0x6273(%rip),%rdx\nadd    $0x28,%rdx\nmov    %rax,(%rdx)\ncmpq   $0x25,-0x38(%rbp)\njle    507c <main+0x279>\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x6254(%rip),%rax\nmovq   $0x86,(%rax)\nmov    $0x0,%eax\ncall   11e9 <next>\nmov    0x623c(%rip),%rax\nmov    %rax,0x61ed(%rip)\nmov    0x61fe(%rip),%rax\nmov    %rax,%rdi\ncall   54de <libmin_malloc>\nmov    %rax,0x61e7(%rip)\nmov    0x61e0(%rip),%rax\nmov    %rax,0x61d1(%rip)\nmov    0x61ca(%rip),%rax\ntest   %rax,%rax\njne    5153 <main+0x350>\nmov    0x61ce(%rip),%rax\nmov    %rax,%rsi\nlea    0x34b4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x5ee6(%rip),%rdx\nmov    0x619f(%rip),%rax\nsub    $0x1,%rax\nmov    %rax,%rcx\nmov    0x6181(%rip),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   5a30 <libmin_mread>\nmov    %rax,-0x38(%rbp)\ncmpq   $0x0,-0x38(%rbp)\njg     51aa <main+0x3a7>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3484(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x613f(%rip),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    0x5e7e(%rip),%rax\nmov    %rax,%rdi\ncall   57d5 <libmin_mclose>\nmov    $0x0,%eax\ncall   454e <program>\nmov    0x610d(%rip),%rax\nadd    $0x28,%rax\nmov    (%rax),%rax\nmov    %rax,0x611f(%rip)\nmov    0x6118(%rip),%rax\ntest   %rax,%rax\njne    5213 <main+0x410>\nlea    0x3430(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%eax\njmp    5303 <main+0x500>\nmov    0x609e(%rip),%rax\ntest   %rax,%rax\nje     5229 <main+0x426>\nmov    $0x0,%eax\njmp    5303 <main+0x500>\nmov    0x60a0(%rip),%rax\nmov    %rax,%rdx\nmov    0x60c6(%rip),%rax\nadd    %rdx,%rax\nmov    %rax,0x60d4(%rip)\nmov    0x60cd(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x60c2(%rip)\nmov    0x60bb(%rip),%rax\nmovq   $0x25,(%rax)\nmov    0x60ad(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x60a2(%rip)\nmov    0x609b(%rip),%rax\nmovq   $0xd,(%rax)\nmov    0x608d(%rip),%rax\nmov    %rax,-0x28(%rbp)\nmov    0x6082(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x6077(%rip)\nmov    0x6070(%rip),%rax\nmovq   $0x1,(%rax)\nmov    0x6062(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x6057(%rip)\nmov    0x6050(%rip),%rax\nmov    -0x30(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    0x6042(%rip),%rax\nsub    $0x8,%rax\nmov    %rax,0x6037(%rip)\nmov    0x6030(%rip),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    $0x0,%eax\ncall   457c <eval>\ncall   7da3 <libmin_success>\nmov    $0x9,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     5317 <main+0x514>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "match", "content": "void match(long tk) {\n    if (token == tk) {\n        next();\n    } else {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n        libmin_fail(-1);\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O0.pseudo", "function_name": "match", "address": "0x1cff", "label": "match", "content": "void __cdecl match(__int64 tk)\n{\n  if ( tk != token )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}\n"}, "pseudo_normalize": "void match(long long tk) {\n  if (tk != token) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}", "binary": "c-interp/c-interp.host.O0", "assembly": "<match>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    0x95aa(%rip),%rax\ncmp    %rax,-0x8(%rbp)\njne    1d28 <match+0x29>\nmov    $0x0,%eax\ncall   11e9 <next>\njmp    1d54 <match+0x55>\nmov    0x9611(%rip),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rax,%rsi\nlea    0x64e7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   545b <libmin_fail>\nnop\nleave\nret\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "next", "content": " // index of bp pointer on stack\n\nvoid next() {\n    char *last_pos;\n    long hash;\n\n    while ((token = *src) != 0) {\n        ++src;\n\n        if (token == '\\n') {\n            if (assembly) {\n                // print compile info\n                libmin_printf(\"%ld: %.*s\", line, (int)(src-old_src), old_src);\n                old_src = src;\n\n                while (old_text < text) {\n                    libmin_printf(\"%8.4s\", & \"LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,\"\n                                      \"OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\"\n                                      \"OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT\"[*++old_text * 5]);\n\n                    if (*old_text <= ADJ)\n                        libmin_printf(\" %ld\\n\", *++old_text);\n                    else\n                        libmin_printf(\"\\n\");\n                }\n            }\n            ++line;\n        }\n        else if (token == '#') {\n            // skip macro, because we will not support it\n            while (*src != 0 && *src != '\\n') {\n                src++;\n            }\n        }\n        else if ((token >= 'a' && token <= 'z') || (token >= 'A' && token <= 'Z') || (token == '_')) {\n\n            // parse identifier\n            last_pos = src - 1;\n            hash = token;\n\n            while ((*src >= 'a' && *src <= 'z') || (*src >= 'A' && *src <= 'Z') || (*src >= '0' && *src <= '9') || (*src == '_')) {\n                hash = hash * 147 + *src;\n                src++;\n            }\n\n            // look for existing identifier, linear search\n            current_id = symbols;\n            while (current_id[Token]) {\n                if (current_id[Hash] == hash && !libmin_memcmp((char *)current_id[Name], last_pos, src - last_pos)) {\n                    //found one, return\n                    token = current_id[Token];\n                    return;\n                }\n                current_id = current_id + IdSize;\n            }\n\n\n            // store new ID\n            current_id[Name] = (long)last_pos;\n            current_id[Hash] = hash;\n            token = current_id[Token] = Id;\n            return;\n        }\n        else if (token >= '0' && token <= '9') {\n            // parse number, three kinds: dec(123) hex(0x123) oct(017)\n            token_val = token - '0';\n            if (token_val > 0) {\n                // dec, starts with [1-9]\n                while (*src >= '0' && *src <= '9') {\n                    token_val = token_val*10 + *src++ - '0';\n                }\n            } else {\n                // starts with number 0\n                if (*src == 'x' || *src == 'X') {\n                    //hex\n                    token = *++src;\n                    while ((token >= '0' && token <= '9') || (token >= 'a' && token <= 'f') || (token >= 'A' && token <= 'F')) {\n                        token_val = token_val * 16 + (token & 15) + (token >= 'A' ? 9 : 0);\n                        token = *++src;\n                    }\n                } else {\n                    // oct\n                    while (*src >= '0' && *src <= '7') {\n                        token_val = token_val*8 + *src++ - '0';\n                    }\n                }\n            }\n\n            token = Num;\n            return;\n        }\n        else if (token == '/') {\n            if (*src == '/') {\n                // skip comments\n                while (*src != 0 && *src != '\\n') {\n                    ++src;\n                }\n            } else {\n                // divide operator\n                token = Div;\n                return;\n            }\n        }\n        else if (token == '\"' || token == '\\'') {\n            // parse string literal, currently, the only supported escape\n            // character is '\\n', store the string literal into data.\n            last_pos = data;\n            while (*src != 0 && *src != token) {\n                token_val = *src++;\n                if (token_val == '\\\\') {\n                    // escape character\n                    token_val = *src++;\n                    if (token_val == 'n') {\n                        token_val = '\\n';\n                    }\n                }\n\n                if (token == '\"') {\n                    *data++ = token_val;\n                }\n            }\n\n            src++;\n            // if it is a single character, return Num token\n            if (token == '\"') {\n                token_val = (long)last_pos;\n            } else {\n                token = Num;\n            }\n\n            return;\n        }\n        else if (token == '=') {\n            // parse '==' and '='\n            if (*src == '=') {\n                src ++;\n                token = Eq;\n            } else {\n                token = Assign;\n            }\n            return;\n        }\n        else if (token == '+') {\n            // parse '+' and '++'\n            if (*src == '+') {\n                src ++;\n                token = Inc;\n            } else {\n                token = Add;\n            }\n            return;\n        }\n        else if (token == '-') {\n            // parse '-' and '--'\n            if (*src == '-') {\n                src ++;\n                token = Dec;\n            } else {\n                token = Sub;\n            }\n            return;\n        }\n        else if (token == '!') {\n            // parse '!='\n            if (*src == '=') {\n                src++;\n                token = Ne;\n            }\n            return;\n        }\n        else if (token == '<') {\n            // parse '<=', '<<' or '<'\n            if (*src == '=') {\n                src ++;\n                token = Le;\n            } else if (*src == '<') {\n                src ++;\n                token = Shl;\n            } else {\n                token = Lt;\n            }\n            return;\n        }\n        else if (token == '>') {\n            // parse '>=', '>>' or '>'\n            if (*src == '=') {\n                src ++;\n                token = Ge;\n            } else if (*src == '>') {\n                src ++;\n                token = Shr;\n            } else {\n                token = Gt;\n            }\n            return;\n        }\n        else if (token == '|') {\n            // parse '|' or '||'\n            if (*src == '|') {\n                src ++;\n                token = Lor;\n            } else {\n                token = Or;\n            }\n            return;\n        }\n        else if (token == '&') {\n            // parse '&' and '&&'\n            if (*src == '&') {\n                src ++;\n                token = Lan;\n            } else {\n                token = And;\n            }\n            return;\n        }\n        else if (token == '^') {\n            token = Xor;\n            return;\n        }\n        else if (token == '%') {\n            token = Mod;\n            return;\n        }\n        else if (token == '*') {\n            token = Mul;\n            return;\n        }\n        else if (token == '[') {\n            token = Brak;\n            return;\n        }\n        else if (token == '?') {\n            token = Cond;\n            return;\n        }\n        else if (token == '~' || token == ';' || token == '{' || token == '}' || token == '(' || token == ')' || token == ']' || token == ',' || token == ':') {\n            // directly return the character as token;\n            return;\n        }\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O0.pseudo", "function_name": "next", "address": "0x11e9", "label": "next", "content": "void __cdecl next()\n{\n  __int64 *v0; // rax\n  char *v1; // rax\n  __int64 v2; // rax\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  __int64 hash; // [rsp+0h] [rbp-10h]\n  char *last_pos; // [rsp+8h] [rbp-8h]\n  char *last_posa; // [rsp+8h] [rbp-8h]\n\n  while ( 1 )\n  {\n    token = *src;\n    if ( !token )\n      break;\n    ++src;\n    if ( token == 10 )\n    {\n      if ( assembly )\n      {\n        libmin_printf(\"%ld: %.*s\", line, (_DWORD)src - (_DWORD)old_src, old_src);\n        old_src = src;\n        while ( old_text < text )\n        {\n          libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * *++old_text]);\n          if ( *old_text > 7 )\n            libmin_printf(\"\\n\");\n          else\n            libmin_printf(\" %ld\\n\", *++old_text);\n        }\n      }\n      ++line;\n    }\n    else if ( token == 35 )\n    {\n      while ( *src && *src != 10 )\n        ++src;\n    }\n    else\n    {\n      if ( token > 96 && token <= 122 || token > 64 && token <= 90 || token == 95 )\n      {\n        last_pos = src - 1;\n        hash = token;\n        while ( *src > 96 && *src <= 122 || *src > 64 && *src <= 90 || *src > 47 && *src <= 57 || *src == 95 )\n          hash = 147 * hash + *src++;\n        for ( current_id = (__int64 *)symbols; *current_id; current_id += 9 )\n        {\n          if ( hash == current_id[1] && !libmin_memcmp((const void *)current_id[2], last_pos, src - last_pos) )\n          {\n            token = *current_id;\n            return;\n          }\n        }\n        current_id[2] = (__int64)last_pos;\n        current_id[1] = hash;\n        v0 = current_id;\n        *current_id = 133LL;\n        token = *v0;\n        return;\n      }\n      if ( token > 47 && token <= 57 )\n      {\n        token_val = token - 48;\n        if ( token - 48 <= 0 )\n        {\n          if ( *src == 120 || *src == 88 )\n          {\n            for ( token = *++src;\n                  token > 47 && token <= 57 || token > 96 && token <= 102 || token > 64 && token <= 70;\n                  token = *src )\n            {\n              if ( token <= 64 )\n                v2 = 0LL;\n              else\n                v2 = 9LL;\n              token_val = (token & 0xF) + 16 * token_val + v2;\n              ++src;\n            }\n          }\n          else\n          {\n            while ( *src > 47 && *src <= 55 )\n            {\n              v3 = src++;\n              token_val = 8 * token_val + *v3 - 48;\n            }\n          }\n        }\n        else\n        {\n          while ( *src > 47 && *src <= 57 )\n          {\n            v1 = src++;\n            token_val = 10 * token_val + *v1 - 48;\n          }\n        }\n        token = 128LL;\n        return;\n      }\n      switch ( token )\n      {\n        case '/':\n          if ( *src != 47 )\n          {\n            token = 160LL;\n            return;\n          }\n          while ( *src && *src != 10 )\n            ++src;\n          break;\n        case '\"':\n        case '\\'':\n          last_posa = data;\n          while ( *src && *src != token )\n          {\n            v4 = src++;\n            token_val = *v4;\n            if ( token_val == 92 )\n            {\n              v5 = src++;\n              token_val = *v5;\n              if ( token_val == 110 )\n                token_val = 10LL;\n            }\n            if ( token == 34 )\n            {\n              v6 = data++;\n              *v6 = token_val;\n            }\n          }\n          ++src;\n          if ( token == 34 )\n            token_val = (__int64)last_posa;\n          else\n            token = 128LL;\n          return;\n        case '=':\n          if ( *src == 61 )\n          {\n            ++src;\n            token = 149LL;\n          }\n          else\n          {\n            token = 142LL;\n          }\n          return;\n        case '+':\n          if ( *src == 43 )\n          {\n            ++src;\n            token = 162LL;\n          }\n          else\n          {\n            token = 157LL;\n          }\n          return;\n        case '-':\n          if ( *src == 45 )\n          {\n            ++src;\n            token = 163LL;\n          }\n          else\n          {\n            token = 158LL;\n          }\n          return;\n        case '!':\n          if ( *src == 61 )\n          {\n            ++src;\n            token = 150LL;\n          }\n          return;\n        case '<':\n          if ( *src == 61 )\n          {\n            ++src;\n            token = 153LL;\n          }\n          else if ( *src == 60 )\n          {\n            ++src;\n            token = 155LL;\n          }\n          else\n          {\n            token = 151LL;\n          }\n          return;\n        case '>':\n          if ( *src == 61 )\n          {\n            ++src;\n            token = 154LL;\n          }\n          else if ( *src == 62 )\n          {\n            ++src;\n            token = 156LL;\n          }\n          else\n          {\n            token = 152LL;\n          }\n          return;\n        case '|':\n          if ( *src == 124 )\n          {\n            ++src;\n            token = 144LL;\n          }\n          else\n          {\n            token = 146LL;\n          }\n          return;\n        case '&':\n          if ( *src == 38 )\n          {\n            ++src;\n            token = 145LL;\n          }\n          else\n          {\n            token = 148LL;\n          }\n          return;\n        case '^':\n          token = 147LL;\n          return;\n        case '%':\n          token = 161LL;\n          return;\n        case '*':\n          token = 159LL;\n          return;\n        case '[':\n          token = 164LL;\n          return;\n        case '?':\n          token = 143LL;\n          return;\n        case '~':\n        case ';':\n        case '{':\n        case '}':\n        case '(':\n        case ')':\n        case ']':\n        case ',':\n        case ':':\n          return;\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void next() {\n  long long *v0;\n  char *v1;\n  long long v2;\n  char *v3;\n  char *v4;\n  char *v5;\n  char *v6;\n  long long hash;\n  char *last_pos;\n  char *last_posa;\n  while (1) {\n    token = *src;\n    if (!token) break;\n    ++src;\n    if (token == 10) {\n      if (assembly) {\n        libmin_printf(\"%ld: %.*s\", line, (uint32_t)src - (uint32_t)old_src,\n                      old_src);\n        old_src = src;\n        while (old_text < text) {\n          libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * *++old_text]);\n          if (*old_text > 7)\n            libmin_printf(\"\\n\");\n          else\n            libmin_printf(\" %ld\\n\", *++old_text);\n        }\n      }\n      ++line;\n    } else if (token == 35) {\n      while (*src && *src != 10) ++src;\n    } else {\n      if (token > 96 && token <= 122 || token > 64 && token <= 90 ||\n          token == 95) {\n        last_pos = src - 1;\n        hash = token;\n        while (*src > 96 && *src <= 122 || *src > 64 && *src <= 90 ||\n               *src > 47 && *src <= 57 || *src == 95)\n          hash = 147 * hash + *src++;\n        for (current_id = (long long *)symbols; *current_id; current_id += 9) {\n          if (hash == current_id[1] &&\n              !libmin_memcmp((const void *)current_id[2], last_pos,\n                             src - last_pos)) {\n            token = *current_id;\n            return;\n          }\n        }\n        current_id[2] = (long long)last_pos;\n        current_id[1] = hash;\n        v0 = current_id;\n        *current_id = 133LL;\n        token = *v0;\n        return;\n      }\n      if (token > 47 && token <= 57) {\n        token_val = token - 48;\n        if (token - 48 <= 0) {\n          if (*src == 120 || *src == 88) {\n            for (token = *++src;\n                 token > 47 && token <= 57 || token > 96 && token <= 102 ||\n                 token > 64 && token <= 70;\n                 token = *src) {\n              if (token <= 64)\n                v2 = 0LL;\n              else\n                v2 = 9LL;\n              token_val = (token & 15) + 16 * token_val + v2;\n              ++src;\n            }\n          } else {\n            while (*src > 47 && *src <= 55) {\n              v3 = src++;\n              token_val = 8 * token_val + *v3 - 48;\n            }\n          }\n        } else {\n          while (*src > 47 && *src <= 57) {\n            v1 = src++;\n            token_val = 10 * token_val + *v1 - 48;\n          }\n        }\n        token = 128LL;\n        return;\n      }\n      switch (token) {\n        case '/':\n          if (*src != 47) {\n            token = 160LL;\n            return;\n          }\n          while (*src && *src != 10) ++src;\n          break;\n        case '\"':\n        case '\\'':\n          last_posa = data;\n          while (*src && *src != token) {\n            v4 = src++;\n            token_val = *v4;\n            if (token_val == 92) {\n              v5 = src++;\n              token_val = *v5;\n              if (token_val == 110) token_val = 10LL;\n            }\n            if (token == 34) {\n              v6 = data++;\n              *v6 = token_val;\n            }\n          }\n          ++src;\n          if (token == 34)\n            token_val = (long long)last_posa;\n          else\n            token = 128LL;\n          return;\n        case '=':\n          if (*src == 61) {\n            ++src;\n            token = 149LL;\n          } else {\n            token = 142LL;\n          }\n          return;\n        case '+':\n          if (*src == 43) {\n            ++src;\n            token = 162LL;\n          } else {\n            token = 157LL;\n          }\n          return;\n        case '-':\n          if (*src == 45) {\n            ++src;\n            token = 163LL;\n          } else {\n            token = 158LL;\n          }\n          return;\n        case '!':\n          if (*src == 61) {\n            ++src;\n            token = 150LL;\n          }\n          return;\n        case '<':\n          if (*src == 61) {\n            ++src;\n            token = 153LL;\n          } else if (*src == 60) {\n            ++src;\n            token = 155LL;\n          } else {\n            token = 151LL;\n          }\n          return;\n        case '>':\n          if (*src == 61) {\n            ++src;\n            token = 154LL;\n          } else if (*src == 62) {\n            ++src;\n            token = 156LL;\n          } else {\n            token = 152LL;\n          }\n          return;\n        case '|':\n          if (*src == 124) {\n            ++src;\n            token = 144LL;\n          } else {\n            token = 146LL;\n          }\n          return;\n        case '&':\n          if (*src == 38) {\n            ++src;\n            token = 145LL;\n          } else {\n            token = 148LL;\n          }\n          return;\n        case '^':\n          token = 147LL;\n          return;\n        case '%':\n          token = 161LL;\n          return;\n        case '*':\n          token = 159LL;\n          return;\n        case '[':\n          token = 164LL;\n          return;\n        case '?':\n          token = 143LL;\n          return;\n        case '~':\n        case ';':\n        case '{':\n        case '}':\n        case '(':\n        case ')':\n        case ']':\n        case ',':\n        case ':':\n          return;\n      }\n    }\n  }\n}", "binary": "c-interp/c-interp.host.O0", "assembly": "<next>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\njmp    1cd2 <next+0xae9>\nmov    0xa0ef(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0xa0e4(%rip)\nmov    0xa0ad(%rip),%rax\ncmp    $0xa,%rax\njne    134b <next+0x162>\nmov    0xa094(%rip),%rax\ntest   %rax,%rax\nje     1334 <next+0x14b>\nmov    0xa0c4(%rip),%rdx\nmov    0xa0b5(%rip),%rax\nmov    0xa0b6(%rip),%rcx\nsub    %rcx,%rax\nmov    %eax,%esi\nmov    0xa0f2(%rip),%rax\nmov    %rdx,%rcx\nmov    %esi,%edx\nmov    %rax,%rsi\nlea    0x6eeb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    0xa07f(%rip),%rax\nmov    %rax,0xa080(%rip)\njmp    131d <next+0x134>\nmov    0xa054(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0xa049(%rip)\nmov    0xa042(%rip),%rax\nmov    (%rax),%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rax,%rdx\nlea    0x6eae(%rip),%rax\nadd    %rdx,%rax\nmov    %rax,%rsi\nlea    0x6f5f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    0xa00d(%rip),%rax\nmov    (%rax),%rax\ncmp    $0x7,%rax\njg     1309 <next+0x120>\nmov    0x9ffd(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x9ff2(%rip)\nmov    0x9feb(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x6f22(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\njmp    131d <next+0x134>\nlea    0x6f12(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   7ad8 <libmin_printf>\nmov    0x9fb4(%rip),%rdx\nmov    0x9f9d(%rip),%rax\ncmp    %rax,%rdx\njb     127d <next+0x94>\nmov    0xa005(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9ffa(%rip)\njmp    1cd2 <next+0xae9>\nmov    0x9f6e(%rip),%rax\ncmp    $0x23,%rax\njne    1391 <next+0x1a8>\njmp    136c <next+0x183>\nmov    0x9f8f(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9f84(%rip)\nmov    0x9f7d(%rip),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     1cd2 <next+0xae9>\nmov    0x9f6b(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0xa,%al\njne    135a <next+0x171>\njmp    1cd2 <next+0xae9>\nmov    0x9f28(%rip),%rax\ncmp    $0x60,%rax\njle    13ab <next+0x1c2>\nmov    0x9f1b(%rip),%rax\ncmp    $0x7a,%rax\njle    13d6 <next+0x1ed>\nmov    0x9f0e(%rip),%rax\ncmp    $0x40,%rax\njle    13c5 <next+0x1dc>\nmov    0x9f01(%rip),%rax\ncmp    $0x5a,%rax\njle    13d6 <next+0x1ed>\nmov    0x9ef4(%rip),%rax\ncmp    $0x5f,%rax\njne    156c <next+0x383>\nmov    0x9f13(%rip),%rax\nsub    $0x1,%rax\nmov    %rax,-0x8(%rbp)\nmov    0x9ed4(%rip),%rax\nmov    %rax,-0x10(%rbp)\njmp    1434 <next+0x24b>\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rax,%rdx\nmov    0x9edc(%rip),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rdx,%rax\nmov    %rax,-0x10(%rbp)\nmov    0x9ec7(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9ebc(%rip)\nmov    0x9eb5(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x60,%al\njle    1450 <next+0x267>\nmov    0x9ea7(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x7a,%al\njle    13f2 <next+0x209>\nmov    0x9e99(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x40,%al\njle    146c <next+0x283>\nmov    0x9e8b(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x5a,%al\njle    13f2 <next+0x209>\nmov    0x9e7d(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    148c <next+0x2a3>\nmov    0x9e6f(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x39,%al\njle    13f2 <next+0x209>\nmov    0x9e5d(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x5f,%al\nje     13f2 <next+0x209>\nmov    0x9e93(%rip),%rax\nmov    %rax,0x9e84(%rip)\njmp    151c <next+0x333>\nmov    0x9e7b(%rip),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\ncmp    %rax,-0x10(%rbp)\njne    150a <next+0x321>\nmov    0x9e27(%rip),%rax\nsub    -0x8(%rbp),%rax\nmov    %rax,%rdx\nmov    0x9e59(%rip),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nmov    %rax,%rcx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   57ef <libmin_memcmp>\ntest   %eax,%eax\njne    150a <next+0x321>\nmov    0x9e35(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x9dbb(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9e1f(%rip),%rax\nadd    $0x48,%rax\nmov    %rax,0x9e14(%rip)\nmov    0x9e0d(%rip),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    14ae <next+0x2c5>\nmov    0x9dfe(%rip),%rax\nlea    0x10(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\nmov    0x9dec(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,(%rdx)\nmov    0x9dda(%rip),%rax\nmovq   $0x85,(%rax)\nmov    (%rax),%rax\nmov    %rax,0x9d59(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9d4d(%rip),%rax\ncmp    $0x2f,%rax\njle    177c <next+0x593>\nmov    0x9d3c(%rip),%rax\ncmp    $0x39,%rax\njg     177c <next+0x593>\nmov    0x9d2b(%rip),%rax\nsub    $0x30,%rax\nmov    %rax,0x9da8(%rip)\nmov    0x9da1(%rip),%rax\ntest   %rax,%rax\njle    1611 <next+0x428>\njmp    15ec <next+0x403>\nmov    0x9d93(%rip),%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nmov    %rax,%rcx\nmov    0x9d24(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x9d19(%rip)\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rcx,%rax\nsub    $0x30,%rax\nmov    %rax,0x9d5c(%rip)\nmov    0x9cfd(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    176c <next+0x583>\nmov    0x9ceb(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x39,%al\njle    15ae <next+0x3c5>\njmp    176c <next+0x583>\nmov    0x9cd8(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x78,%al\nje     1631 <next+0x448>\nmov    0x9cca(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x58,%al\njne    174d <next+0x564>\nmov    0x9cb8(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9cad(%rip)\nmov    0x9ca6(%rip),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x9c68(%rip)\njmp    16bf <next+0x4d6>\nmov    0x9ce7(%rip),%rax\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    0x9c51(%rip),%rax\nand    $0xf,%eax\nadd    %rax,%rdx\nmov    0x9c44(%rip),%rax\ncmp    $0x40,%rax\njle    1689 <next+0x4a0>\nmov    $0x9,%eax\njmp    168e <next+0x4a5>\nmov    $0x0,%eax\nadd    %rdx,%rax\nmov    %rax,0x9cb0(%rip)\nmov    0x9c51(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9c46(%rip)\nmov    0x9c3f(%rip),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x9c01(%rip)\nmov    0x9bfa(%rip),%rax\ncmp    $0x2f,%rax\njle    16d9 <next+0x4f0>\nmov    0x9bed(%rip),%rax\ncmp    $0x39,%rax\njle    165a <next+0x471>\nmov    0x9be0(%rip),%rax\ncmp    $0x60,%rax\njle    16f7 <next+0x50e>\nmov    0x9bd3(%rip),%rax\ncmp    $0x66,%rax\njle    165a <next+0x471>\nmov    0x9bc2(%rip),%rax\ncmp    $0x40,%rax\njle    176b <next+0x582>\nmov    0x9bb5(%rip),%rax\ncmp    $0x46,%rax\njle    165a <next+0x471>\njmp    176b <next+0x582>\nmov    0x9c2a(%rip),%rax\nlea    0x0(,%rax,8),%rcx\nmov    0x9bc3(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x9bb8(%rip)\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rcx,%rax\nsub    $0x30,%rax\nmov    %rax,0x9bfb(%rip)\nmov    0x9b9c(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njle    176c <next+0x583>\nmov    0x9b8e(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x37,%al\njle    1717 <next+0x52e>\njmp    176c <next+0x583>\nnop\nmovq   $0x80,0x9b49(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9b3d(%rip),%rax\ncmp    $0x2f,%rax\njne    17e0 <next+0x5f7>\nmov    0x9b60(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x2f,%al\njne    17d0 <next+0x5e7>\njmp    17ab <next+0x5c2>\nmov    0x9b50(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9b45(%rip)\nmov    0x9b3e(%rip),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     1cd2 <next+0xae9>\nmov    0x9b2c(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0xa,%al\njne    1799 <next+0x5b0>\njmp    1cd2 <next+0xae9>\nmovq   $0xa0,0x9ae5(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9ad9(%rip),%rax\ncmp    $0x22,%rax\nje     17fe <next+0x615>\nmov    0x9acc(%rip),%rax\ncmp    $0x27,%rax\njne    1908 <next+0x71f>\nmov    0x9adb(%rip),%rax\nmov    %rax,-0x8(%rbp)\njmp    189d <next+0x6b4>\nmov    0x9adb(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x9ad0(%rip)\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x9b1a(%rip)\nmov    0x9b13(%rip),%rax\ncmp    $0x5c,%rax\njne    1873 <next+0x68a>\nmov    0x9aae(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x9aa3(%rip)\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x9aed(%rip)\nmov    0x9ae6(%rip),%rax\ncmp    $0x6e,%rax\njne    1873 <next+0x68a>\nmovq   $0xa,0x9ad5(%rip)\nmov    0x9a46(%rip),%rax\ncmp    $0x22,%rax\njne    189d <next+0x6b4>\nmov    0x9ac1(%rip),%rcx\nmov    0x9a52(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x9a47(%rip)\nmov    %ecx,%edx\nmov    %dl,(%rax)\nmov    0x9a4c(%rip),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     18c9 <next+0x6e0>\nmov    0x9a3e(%rip),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rdx\nmov    0x9a00(%rip),%rax\ncmp    %rax,%rdx\njne    180e <next+0x625>\nmov    0x9a20(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9a15(%rip)\nmov    0x99de(%rip),%rax\ncmp    $0x22,%rax\njne    18f8 <next+0x70f>\nmov    -0x8(%rbp),%rax\nmov    %rax,0x9a55(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x80,0x99bd(%rip)\njmp    1cfd <next+0xb14>\nmov    0x99b1(%rip),%rax\ncmp    $0x3d,%rax\njne    1955 <next+0x76c>\nmov    0x99d4(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x3d,%al\njne    1945 <next+0x75c>\nmov    0x99c6(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x99bb(%rip)\nmovq   $0x95,0x9980(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x8e,0x9970(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9964(%rip),%rax\ncmp    $0x2b,%rax\njne    19a2 <next+0x7b9>\nmov    0x9987(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x2b,%al\njne    1992 <next+0x7a9>\nmov    0x9979(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x996e(%rip)\nmovq   $0xa2,0x9933(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x9d,0x9923(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9917(%rip),%rax\ncmp    $0x2d,%rax\njne    19ef <next+0x806>\nmov    0x993a(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\njne    19df <next+0x7f6>\nmov    0x992c(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9921(%rip)\nmovq   $0xa3,0x98e6(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x9e,0x98d6(%rip)\njmp    1cfd <next+0xb14>\nmov    0x98ca(%rip),%rax\ncmp    $0x21,%rax\njne    1a30 <next+0x847>\nmov    0x98ed(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x3d,%al\njne    1cf9 <next+0xb10>\nmov    0x98db(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x98d0(%rip)\nmovq   $0x96,0x9895(%rip)\njmp    1cf9 <next+0xb10>\nmov    0x9889(%rip),%rax\ncmp    $0x3c,%rax\njne    1aad <next+0x8c4>\nmov    0x98ac(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x3d,%al\njne    1a6d <next+0x884>\nmov    0x989e(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9893(%rip)\nmovq   $0x99,0x9858(%rip)\njmp    1cfd <next+0xb14>\nmov    0x987c(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x3c,%al\njne    1a9d <next+0x8b4>\nmov    0x986e(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9863(%rip)\nmovq   $0x9b,0x9828(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x97,0x9818(%rip)\njmp    1cfd <next+0xb14>\nmov    0x980c(%rip),%rax\ncmp    $0x3e,%rax\njne    1b2a <next+0x941>\nmov    0x982f(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x3d,%al\njne    1aea <next+0x901>\nmov    0x9821(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9816(%rip)\nmovq   $0x9a,0x97db(%rip)\njmp    1cfd <next+0xb14>\nmov    0x97ff(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x3e,%al\njne    1b1a <next+0x931>\nmov    0x97f1(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x97e6(%rip)\nmovq   $0x9c,0x97ab(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x98,0x979b(%rip)\njmp    1cfd <next+0xb14>\nmov    0x978f(%rip),%rax\ncmp    $0x7c,%rax\njne    1b77 <next+0x98e>\nmov    0x97b2(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x7c,%al\njne    1b67 <next+0x97e>\nmov    0x97a4(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x9799(%rip)\nmovq   $0x90,0x975e(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x92,0x974e(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9742(%rip),%rax\ncmp    $0x26,%rax\njne    1bc4 <next+0x9db>\nmov    0x9765(%rip),%rax\nmovzbl (%rax),%eax\ncmp    $0x26,%al\njne    1bb4 <next+0x9cb>\nmov    0x9757(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x974c(%rip)\nmovq   $0x91,0x9711(%rip)\njmp    1cfd <next+0xb14>\nmovq   $0x94,0x9701(%rip)\njmp    1cfd <next+0xb14>\nmov    0x96f5(%rip),%rax\ncmp    $0x5e,%rax\njne    1be1 <next+0x9f8>\nmovq   $0x93,0x96e4(%rip)\njmp    1cfd <next+0xb14>\nmov    0x96d8(%rip),%rax\ncmp    $0x25,%rax\njne    1bfe <next+0xa15>\nmovq   $0xa1,0x96c7(%rip)\njmp    1cfd <next+0xb14>\nmov    0x96bb(%rip),%rax\ncmp    $0x2a,%rax\njne    1c1b <next+0xa32>\nmovq   $0x9f,0x96aa(%rip)\njmp    1cfd <next+0xb14>\nmov    0x969e(%rip),%rax\ncmp    $0x5b,%rax\njne    1c38 <next+0xa4f>\nmovq   $0xa4,0x968d(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9681(%rip),%rax\ncmp    $0x3f,%rax\njne    1c55 <next+0xa6c>\nmovq   $0x8f,0x9670(%rip)\njmp    1cfd <next+0xb14>\nmov    0x9664(%rip),%rax\ncmp    $0x7e,%rax\nje     1cfc <next+0xb13>\nmov    0x9653(%rip),%rax\ncmp    $0x3b,%rax\nje     1cfc <next+0xb13>\nmov    0x9642(%rip),%rax\ncmp    $0x7b,%rax\nje     1cfc <next+0xb13>\nmov    0x9635(%rip),%rax\ncmp    $0x7d,%rax\nje     1cfc <next+0xb13>\nmov    0x9628(%rip),%rax\ncmp    $0x28,%rax\nje     1cfc <next+0xb13>\nmov    0x961b(%rip),%rax\ncmp    $0x29,%rax\nje     1cfc <next+0xb13>\nmov    0x960e(%rip),%rax\ncmp    $0x5d,%rax\nje     1cfc <next+0xb13>\nmov    0x9601(%rip),%rax\ncmp    $0x2c,%rax\nje     1cfc <next+0xb13>\nmov    0x95f4(%rip),%rax\ncmp    $0x3a,%rax\nje     1cfc <next+0xb13>\nmov    0x9617(%rip),%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nmov    %rax,0x95d9(%rip)\nmov    0x95d2(%rip),%rax\ntest   %rax,%rax\njne    11fa <next+0x11>\njmp    1cfd <next+0xb14>\nnop\njmp    1cfd <next+0xb14>\nnop\nleave\nret\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "program", "content": "void program() {\n    // get next token\n    next();\n    while (token > 0) {\n        global_declaration();\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O0.pseudo", "function_name": "program", "address": "0x454e", "label": "program", "content": "void __cdecl program()\n{\n  next();\n  while ( token > 0 )\n    global_declaration();\n}\n"}, "pseudo_normalize": "", "binary": "c-interp/c-interp.host.O0", "assembly": "<program>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x0,%eax\ncall   11e9 <next>\njmp    456c <program+0x1e>\nmov    $0x0,%eax\ncall   430b <global_declaration>\nmov    0x6d4d(%rip),%rax\ntest   %rax,%rax\njg     4562 <program+0x14>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "statement", "content": "void statement() {\n    // there are 8 kinds of statements here:\n    // 1. if (...) <statement> [else <statement>]\n    // 2. while (...) <statement>\n    // 3. { <statement> }\n    // 4. return xxx;\n    // 5. <empty statement>;\n    // 6. expression; (expression end with semicolon)\n\n    long *a, *b; // bess for branch control\n\n    if (token == If) {\n        // if (...) <statement> [else <statement>]\n        //\n        //   if (...)           <cond>\n        //                      JZ a\n        //     <statement>      <statement>\n        //   else:              JMP b\n        // a:\n        //     <statement>      <statement>\n        // b:                   b:\n        //\n        //\n        match(If);\n        match('(');\n        expression(Assign);  // parse condition\n        match(')');\n\n        // emit code for if\n        *++text = JZ;\n        b = ++text;\n\n        statement();         // parse statement\n        if (token == Else) { // parse else\n            match(Else);\n\n            // emit code for JMP B\n            *b = (long)(text + 3);\n            *++text = JMP;\n            b = ++text;\n\n            statement();\n        }\n\n        *b = (long)(text + 1);\n    }\n    else if (token == While) {\n        //\n        // a:                     a:\n        //    while (<cond>)        <cond>\n        //                          JZ b\n        //     <statement>          <statement>\n        //                          JMP a\n        // b:                     b:\n        match(While);\n\n        a = text + 1;\n\n        match('(');\n        expression(Assign);\n        match(')');\n\n        *++text = JZ;\n        b = ++text;\n\n        statement();\n\n        *++text = JMP;\n        *++text = (long)a;\n        *b = (long)(text + 1);\n    }\n    else if (token == '{') {\n        // { <statement> ... }\n        match('{');\n\n        while (token != '}') {\n            statement();\n        }\n\n        match('}');\n    }\n    else if (token == Return) {\n        // return [expression];\n        match(Return);\n\n        if (token != ';') {\n            expression(Assign);\n        }\n\n        match(';');\n\n        // emit code for return\n        *++text = LEV;\n    }\n    else if (token == ';') {\n        // empty statement\n        match(';');\n    }\n    else {\n        // a = b; or function_call();\n        expression(Assign);\n        match(';');\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O0.pseudo", "function_name": "statement", "address": "0x3a1d", "label": "statement", "content": "void __cdecl statement()\n{\n  __int64 *b; // [rsp+0h] [rbp-10h]\n  __int64 *ba; // [rsp+0h] [rbp-10h]\n  __int64 *a; // [rsp+8h] [rbp-8h]\n\n  switch ( token )\n  {\n    case 137LL:\n      match(137LL);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 4LL;\n      text = (char *)text + 8;\n      b = (__int64 *)text;\n      statement();\n      if ( token == 135 )\n      {\n        match(135LL);\n        *b = (__int64)text + 24;\n        text = (char *)text + 8;\n        *(_QWORD *)text = 2LL;\n        text = (char *)text + 8;\n        b = (__int64 *)text;\n        statement();\n      }\n      *b = (__int64)text + 8;\n      break;\n    case 141LL:\n      match(141LL);\n      a = (__int64 *)((char *)text + 8);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 4LL;\n      text = (char *)text + 8;\n      ba = (__int64 *)text;\n      statement();\n      text = (char *)text + 8;\n      *(_QWORD *)text = 2LL;\n      text = (char *)text + 8;\n      *(_QWORD *)text = a;\n      *ba = (__int64)text + 8;\n      break;\n    case 123LL:\n      match(123LL);\n      while ( token != 125 )\n        statement();\n      match(125LL);\n      break;\n    case 139LL:\n      match(139LL);\n      if ( token != 59 )\n        expression(142LL);\n      match(59LL);\n      text = (char *)text + 8;\n      *(_QWORD *)text = 8LL;\n      break;\n    default:\n      if ( token != 59 )\n        expression(142LL);\n      match(59LL);\n      break;\n  }\n}\n"}, "pseudo_normalize": "void statement() {\n  long long *b;\n  long long *ba;\n  long long *a;\n  switch (token) {\n    case 137LL:\n      match(137LL);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      text = (char *)text + 8;\n      *(uint64_t *)text = 4LL;\n      text = (char *)text + 8;\n      b = (long long *)text;\n      statement();\n      if (token == 135) {\n        match(135LL);\n        *b = (long long)text + 24;\n        text = (char *)text + 8;\n        *(uint64_t *)text = 2LL;\n        text = (char *)text + 8;\n        b = (long long *)text;\n        statement();\n      }\n      *b = (long long)text + 8;\n      break;\n    case 141LL:\n      match(141LL);\n      a = (long long *)((char *)text + 8);\n      match(40LL);\n      expression(142LL);\n      match(41LL);\n      text = (char *)text + 8;\n      *(uint64_t *)text = 4LL;\n      text = (char *)text + 8;\n      ba = (long long *)text;\n      statement();\n      text = (char *)text + 8;\n      *(uint64_t *)text = 2LL;\n      text = (char *)text + 8;\n      *(uint64_t *)text = a;\n      *ba = (long long)text + 8;\n      break;\n    case 123LL:\n      match(123LL);\n      while (token != 125) statement();\n      match(125LL);\n      break;\n    case 139LL:\n      match(139LL);\n      if (token != 59) expression(142LL);\n      match(59LL);\n      text = (char *)text + 8;\n      *(uint64_t *)text = 8LL;\n      break;\n    default:\n      if (token != 59) expression(142LL);\n      match(59LL);\n      break;\n  }\n}", "binary": "c-interp/c-interp.host.O0", "assembly": "<statement>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    0x7890(%rip),%rax\ncmp    $0x89,%rax\njne    3b3a <statement+0x11d>\nmov    $0x89,%edi\ncall   1cff <match>\nmov    $0x28,%edi\ncall   1cff <match>\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    $0x29,%edi\ncall   1cff <match>\nmov    0x785d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7852(%rip)\nmov    0x784b(%rip),%rax\nmovq   $0x4,(%rax)\nmov    0x783d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7832(%rip)\nmov    0x782b(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    $0x0,%eax\ncall   3a1d <statement>\nmov    0x780e(%rip),%rax\ncmp    $0x87,%rax\njne    3b20 <statement+0x103>\nmov    $0x87,%edi\ncall   1cff <match>\nmov    0x77fd(%rip),%rax\nadd    $0x18,%rax\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,(%rax)\nmov    0x77e8(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x77dd(%rip)\nmov    0x77d6(%rip),%rax\nmovq   $0x2,(%rax)\nmov    0x77c8(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x77bd(%rip)\nmov    0x77b6(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    $0x0,%eax\ncall   3a1d <statement>\nmov    0x77a1(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,(%rax)\njmp    3ced <statement+0x2d0>\nmov    0x777f(%rip),%rax\ncmp    $0x8d,%rax\njne    3c25 <statement+0x208>\nmov    $0x8d,%edi\ncall   1cff <match>\nmov    0x776a(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,-0x8(%rbp)\nmov    $0x28,%edi\ncall   1cff <match>\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    $0x29,%edi\ncall   1cff <match>\nmov    0x773d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7732(%rip)\nmov    0x772b(%rip),%rax\nmovq   $0x4,(%rax)\nmov    0x771d(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7712(%rip)\nmov    0x770b(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    $0x0,%eax\ncall   3a1d <statement>\nmov    0x76f6(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x76eb(%rip)\nmov    0x76e4(%rip),%rax\nmovq   $0x2,(%rax)\nmov    0x76d6(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x76cb(%rip)\nmov    0x76c4(%rip),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    0x76b6(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,(%rax)\njmp    3ced <statement+0x2d0>\nmov    0x7694(%rip),%rax\ncmp    $0x7b,%rax\njne    3c64 <statement+0x247>\nmov    $0x7b,%edi\ncall   1cff <match>\njmp    3c48 <statement+0x22b>\nmov    $0x0,%eax\ncall   3a1d <statement>\nmov    0x7671(%rip),%rax\ncmp    $0x7d,%rax\njne    3c3e <statement+0x221>\nmov    $0x7d,%edi\ncall   1cff <match>\njmp    3ced <statement+0x2d0>\nmov    0x7655(%rip),%rax\ncmp    $0x8b,%rax\njne    3cc0 <statement+0x2a3>\nmov    $0x8b,%edi\ncall   1cff <match>\nmov    0x763c(%rip),%rax\ncmp    $0x3b,%rax\nje     3c94 <statement+0x277>\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    $0x3b,%edi\ncall   1cff <match>\nmov    0x7623(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x7618(%rip)\nmov    0x7611(%rip),%rax\nmovq   $0x8,(%rax)\njmp    3ced <statement+0x2d0>\nmov    0x75f9(%rip),%rax\ncmp    $0x3b,%rax\njne    3cd9 <statement+0x2bc>\nmov    $0x3b,%edi\ncall   1cff <match>\njmp    3ced <statement+0x2d0>\nmov    $0x8e,%edi\ncall   1d57 <expression>\nmov    $0x3b,%edi\ncall   1cff <match>\nnop\nleave\nret\n"}
{"source": {"path": "ccmac/ccmac.c", "function_name": "main", "content": " // [0,1)\n\nint\nmain(void)\n{\n  const size_t n = (size_t)N_ELEMS, stride = (size_t)STRIDE;\n  rng = (SEED?SEED:1);\n\n  // Inputs and outputs\n  double *x = (double*)libmin_malloc(n*sizeof(double));\n  double *y = (double*)libmin_malloc(n*sizeof(double));\n  if(!x || !y){ libmin_printf(\"alloc failed\\n\"); libmin_fail(1); }\n\n  // Coefficients c[0..DEGREE] in a reasonable range\n  double *c = (double*)libmin_malloc((DEGREE+1)*sizeof(double));\n  if(!c){ libmin_printf(\"alloc failed\\n\"); libmin_fail(1); }\n  for(int k=0;k<=DEGREE;k++){ c[k] = -1.0 + 2.0*urand01(); }\n\n  // Inputs in [-1,1] to keep values bounded\n  for(size_t i=0, idx=0;i<n;i++, idx=(idx+stride)%n){\n    x[idx] = -1.0 + 2.0*urand01();\n    y[idx] = 0.0;\n  }\n\n  volatile double sink = 0.0;\n\n  for(uint64_t it=0; it<(uint64_t)N_ITER; ++it){\n    for(size_t i=0, idx=0;i<n;i++, idx=(idx+stride)%n){\n      double acc = c[DEGREE];\n      // Horner loop: DEGREE FMAs (or mul+add if fma not used)\n      for(int k=DEGREE-1;k>=0;k--)\n        acc = fma(acc, x[idx], c[k]);\n      y[idx] = acc;\n      sink += acc * 1e-16;\n    }\n  }\n\n  // Report\n  const double ops = (double)N_ITER * (double)n * (double)(2*DEGREE); // FMA counted as 2 flops\n  double checksum = 0.0; for(size_t i=0;i<n;i++) checksum += y[i];\n\n  libmin_printf(\"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n         DEGREE, (unsigned)N_ITER, n, stride, ops, checksum);\n\n  libmin_free(c); libmin_free((void*)x); libmin_free((void*)y);\n\n  libmin_success();\n}\n"}, "pseudo": {"path": "ccmac/ccmac.host.O0.pseudo", "function_name": "main", "address": "0x127e", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm0_8\n  double v4; // xmm0_8\n  int k; // [rsp+0h] [rbp-80h]\n  int k_0; // [rsp+4h] [rbp-7Ch]\n  double sink; // [rsp+8h] [rbp-78h]\n  size_t i; // [rsp+10h] [rbp-70h]\n  size_t idx; // [rsp+18h] [rbp-68h]\n  uint64_t it; // [rsp+20h] [rbp-60h]\n  size_t i_0; // [rsp+28h] [rbp-58h]\n  size_t idx_0; // [rsp+30h] [rbp-50h]\n  double acc; // [rsp+38h] [rbp-48h]\n  double checksum; // [rsp+40h] [rbp-40h]\n  size_t i_1; // [rsp+48h] [rbp-38h]\n  double *x; // [rsp+60h] [rbp-20h]\n  double *y; // [rsp+68h] [rbp-18h]\n  double *c; // [rsp+70h] [rbp-10h]\n\n  rng = 1LL;\n  x = (double *)libmin_malloc(0x200uLL);\n  y = (double *)libmin_malloc(0x200uLL);\n  if ( !x || !y )\n  {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  c = (double *)libmin_malloc(0x88uLL);\n  if ( !c )\n  {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  for ( k = 0; k <= 16; ++k )\n  {\n    v3 = urand01();\n    c[k] = v3 + v3 - 1.0;\n  }\n  i = 0LL;\n  idx = 0LL;\n  while ( i < 0x40 )\n  {\n    v4 = urand01();\n    x[idx] = v4 + v4 - 1.0;\n    y[idx] = 0.0;\n    ++i;\n    idx = (idx + 1) % 0x40;\n  }\n  sink = 0.0;\n  for ( it = 0LL; it <= 0x63; ++it )\n  {\n    i_0 = 0LL;\n    idx_0 = 0LL;\n    while ( i_0 < 0x40 )\n    {\n      acc = c[16];\n      for ( k_0 = 15; k_0 >= 0; --k_0 )\n        acc = c[k_0] + x[idx_0] * acc;\n      y[idx_0] = acc;\n      sink = sink + acc * 1.0e-16;\n      ++i_0;\n      idx_0 = (idx_0 + 1) % 0x40;\n    }\n  }\n  checksum = 0.0;\n  for ( i_1 = 0LL; i_1 < 0x40; ++i_1 )\n    checksum = y[i_1] + checksum;\n  libmin_printf(\n    \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n    16,\n    100,\n    64,\n    1,\n    32.0 * (100.0 * (double)64),\n    checksum);\n  libmin_free(c);\n  libmin_free(x);\n  libmin_free(y);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  double v4;\n  int k;\n  int k_0;\n  double sink;\n  unsigned int i;\n  unsigned int idx;\n  uint64_t it;\n  unsigned int i_0;\n  unsigned int idx_0;\n  double acc;\n  double checksum;\n  unsigned int i_1;\n  double *x;\n  double *y;\n  double *c;\n  rng = 1LL;\n  x = (double *)libmin_malloc(512uLL);\n  y = (double *)libmin_malloc(512uLL);\n  if (!x || !y) {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  c = (double *)libmin_malloc(136uLL);\n  if (!c) {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  for (k = 0; k <= 16; ++k) {\n    v3 = urand01();\n    c[k] = v3 + v3 - 1.0;\n  }\n  i = 0LL;\n  idx = 0LL;\n  while (i < 64) {\n    v4 = urand01();\n    x[idx] = v4 + v4 - 1.0;\n    y[idx] = 0.0;\n    ++i;\n    idx = (idx + 1) % 64;\n  }\n  sink = 0.0;\n  for (it = 0LL; it <= 99; ++it) {\n    i_0 = 0LL;\n    idx_0 = 0LL;\n    while (i_0 < 64) {\n      acc = c[16];\n      for (k_0 = 15; k_0 >= 0; --k_0) acc = c[k_0] + x[idx_0] * acc;\n      y[idx_0] = acc;\n      sink = sink + acc * 1.0e-16;\n      ++i_0;\n      idx_0 = (idx_0 + 1) % 64;\n    }\n  }\n  checksum = 0.0;\n  for (i_1 = 0LL; i_1 < 64; ++i_1) checksum = y[i_1] + checksum;\n  libmin_printf(\n      \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\", 16,\n      100, 64, 1, 32.0 * (100.0 * (double)64), checksum);\n  libmin_free(c);\n  libmin_free(x);\n  libmin_free(y);\n  libmin_success();\n}", "binary": "ccmac/ccmac.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmovq   $0x40,-0x30(%rbp)\nmovq   $0x1,-0x28(%rbp)\nmovq   $0x1,0x4fcb(%rip)\nmov    -0x30(%rbp),%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   17b6 <libmin_malloc>\nmov    %rax,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   17b6 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x20(%rbp)\nje     12db <main+0x5d>\ncmpq   $0x0,-0x18(%rbp)\njne    12f9 <main+0x7b>\nlea    0x2d26(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c18 <libmin_printf>\nmov    $0x1,%edi\ncall   1733 <libmin_fail>\nmov    $0x88,%edi\ncall   17b6 <libmin_malloc>\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    132c <main+0xae>\nlea    0x2cf3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c18 <libmin_printf>\nmov    $0x1,%edi\ncall   1733 <libmin_fail>\nmovl   $0x0,-0x80(%rbp)\njmp    1366 <main+0xe8>\ncall   1230 <urand01>\naddsd  %xmm0,%xmm0\nmov    -0x80(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x2d06(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x80(%rbp)\ncmpl   $0x10,-0x80(%rbp)\njle    1335 <main+0xb7>\nmovq   $0x0,-0x70(%rbp)\nmovq   $0x0,-0x68(%rbp)\njmp    13e2 <main+0x164>\ncall   1230 <urand01>\naddsd  %xmm0,%xmm0\nmov    -0x68(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x2cbe(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x68(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\naddq   $0x1,-0x70(%rbp)\nmov    -0x68(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    $0x0,%edx\ndivq   -0x30(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    -0x70(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     137e <main+0x100>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x78(%rbp)\nmovq   $0x0,-0x60(%rbp)\njmp    14e7 <main+0x269>\nmovq   $0x0,-0x58(%rbp)\nmovq   $0x0,-0x50(%rbp)\njmp    14d4 <main+0x256>\nmov    -0x10(%rbp),%rax\nmovsd  0x80(%rax),%xmm0\nmovsd  %xmm0,-0x48(%rbp)\nmovl   $0xf,-0x7c(%rbp)\njmp    1476 <main+0x1f8>\nmov    -0x50(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x48(%rbp),%xmm1\nmov    -0x7c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x48(%rbp)\nsubl   $0x1,-0x7c(%rbp)\ncmpl   $0x0,-0x7c(%rbp)\njns    1431 <main+0x1b3>\nmov    -0x50(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x48(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmovsd  -0x48(%rbp),%xmm1\nmovsd  0x2bc3(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovsd  -0x78(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x78(%rbp)\naddq   $0x1,-0x58(%rbp)\nmov    -0x50(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    $0x0,%edx\ndivq   -0x30(%rbp)\nmov    %rdx,-0x50(%rbp)\nmov    -0x58(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     1417 <main+0x199>\naddq   $0x1,-0x60(%rbp)\ncmpq   $0x63,-0x60(%rbp)\njbe    1402 <main+0x184>\nmov    -0x30(%rbp),%rax\ntest   %rax,%rax\njs     1506 <main+0x288>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    151f <main+0x2a1>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x2b49(%rip),%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x2b45(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovq   $0x0,-0x38(%rbp)\njmp    1579 <main+0x2fb>\nmov    -0x38(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  -0x40(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\naddq   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     154f <main+0x2d1>\nmovsd  -0x40(%rbp),%xmm0\nmov    -0x8(%rbp),%rdx\nmov    -0x28(%rbp),%rcx\nmov    -0x30(%rbp),%rax\nmovapd %xmm0,%xmm1\nmovq   %rdx,%xmm0\nmov    %rcx,%r8\nmov    %rax,%rcx\nmov    $0x64,%edx\nmov    $0x10,%esi\nlea    0x2a64(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   3c18 <libmin_printf>\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   18a1 <libmin_free>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   18a1 <libmin_free>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   18a1 <libmin_free>\ncall   3e85 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "ccmac/ccmac.c", "function_name": "urand01", "content": "static inline double urand01(void){ return (double)((xr()>>11) * (1.0/9007199254740992.0)); }\n"}, "pseudo": {"path": "ccmac/ccmac.host.O0.pseudo", "function_name": "urand01", "address": "0x1230", "label": "urand01", "content": "double __cdecl urand01()\n{\n  return (double)(int)(xr() >> 11) * 1.110223024625157e-16;\n}\n"}, "pseudo_normalize": "", "binary": "ccmac/ccmac.host.O0", "assembly": "<urand01>:\npush   %rbp\nmov    %rsp,%rbp\ncall   11e9 <xr>\nshr    $0xb,%rax\ntest   %rax,%rax\njs     124d <urand01+0x1d>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1266 <urand01+0x36>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x2dea(%rip),%xmm1\nmulsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n"}
{"source": {"path": "ccmac/ccmac.c", "function_name": "xr", "content": " // xorshift64\nstatic inline uint64_t xr(void){ uint64_t x=rng; x^=x<<13; x^=x>>7; x^=x<<17; return rng=x; }\n"}, "pseudo": {"path": "ccmac/ccmac.host.O0.pseudo", "function_name": "xr", "address": "0x11e9", "label": "xr", "content": "uint64_t __cdecl xr()\n{\n  uint64_t x; // [rsp+0h] [rbp-8h]\n\n  x = (((rng << 13) ^ rng) >> 7) ^ (rng << 13) ^ rng;\n  rng = (x << 17) ^ x;\n  return (x << 17) ^ x;\n}\n"}, "pseudo_normalize": "uint64_t xr() {\n  uint64_t x;\n  x = (((rng << 13) ^ rng) >> 7) ^ (rng << 13) ^ rng;\n  rng = (x << 17) ^ x;\n  return (x << 17) ^ x;\n}", "binary": "ccmac/ccmac.host.O0", "assembly": "<xr>:\npush   %rbp\nmov    %rsp,%rbp\nmov    0x507c(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshl    $0xd,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshr    $0x7,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshl    $0x11,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,0x5049(%rip)\nmov    0x5042(%rip),%rax\npop    %rbp\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "all_possible_moves", "content": "// function which returns the number of valid target squares a piece at \n// source defined by col/row can make, given a board_t input. \n// Also writes each into a static variable of type valid_moves_t\n\t// sorry for lack of abstraction, very confusing  with different static \n\t// and local variables when abstracted into a function\n\t// so ultimately deemed better in this format\nint all_possible_moves(board_t board_input, char col, char row, \n\tvalid_moves_t valid_moves, int black_action) {\n\tint num_possibles = 0, is_tower = 0;\n\tif ((piece_at_location(board_input, col, row) == CELL_BTOWER)\n\t\t|| (piece_at_location(board_input, col, row) == CELL_WTOWER)) {\n\t\tis_tower = 1;\n\t}\n\t\n\t// iterate through possible tower movement vectors\n\tif (is_tower) {\n\t\tfor (int i=0; i<NUM_TOWER_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + tower_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + tower_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t// otherwise, if target cell occupied by opposing piece, \n\t\t\t\t// capture move possible\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * tower_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * tower_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// iterate through possible black piece movement vectors\n\tif (piece_at_location(board_input, col, row) == CELL_BPIECE) {\n\t\tfor (int i=0; i<NUM_PIECE_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + black_piece_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + black_piece_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * black_piece_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * black_piece_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// iterate through possible white piece movement vectors\n\tif (piece_at_location(board_input, col, row) == CELL_WPIECE) {\n\t\tfor (int i=0; i<NUM_PIECE_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + white_piece_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + white_piece_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * white_piece_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * white_piece_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn num_possibles;\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "all_possible_moves", "address": "0x1e82", "label": "all_possible_moves", "content": "int __cdecl all_possible_moves(\n        unsigned __int8 (*board_input)[8],\n        char col,\n        char row,\n        square_t *valid_moves,\n        int black_action)\n{\n  char p_col1; // [rsp+2Ch] [rbp-74h]\n  char p_row1; // [rsp+2Dh] [rbp-73h]\n  char p_col2; // [rsp+2Eh] [rbp-72h]\n  char p_row2; // [rsp+2Fh] [rbp-71h]\n  char p_col1_0; // [rsp+30h] [rbp-70h]\n  char p_row1_0; // [rsp+31h] [rbp-6Fh]\n  char p_col2_0; // [rsp+32h] [rbp-6Eh]\n  char p_row2_0; // [rsp+33h] [rbp-6Dh]\n  char p_col1_1; // [rsp+34h] [rbp-6Ch]\n  char p_row1_1; // [rsp+35h] [rbp-6Bh]\n  char p_col2_1; // [rsp+36h] [rbp-6Ah]\n  char p_row2_1; // [rsp+37h] [rbp-69h]\n  int num_possibles; // [rsp+38h] [rbp-68h]\n  int is_tower; // [rsp+3Ch] [rbp-64h]\n  int i; // [rsp+40h] [rbp-60h]\n  int capture_possible; // [rsp+44h] [rbp-5Ch]\n  int i_0; // [rsp+48h] [rbp-58h]\n  int capture_possible_0; // [rsp+4Ch] [rbp-54h]\n  int i_1; // [rsp+50h] [rbp-50h]\n  int capture_possible_1; // [rsp+54h] [rbp-4Ch]\n  int possible_col1; // [rsp+58h] [rbp-48h]\n  int possible_row1; // [rsp+5Ch] [rbp-44h]\n  int error_check; // [rsp+60h] [rbp-40h]\n  int possible_col2; // [rsp+64h] [rbp-3Ch]\n  int possible_row2; // [rsp+68h] [rbp-38h]\n  int possible_col1_0; // [rsp+70h] [rbp-30h]\n  int possible_row1_0; // [rsp+74h] [rbp-2Ch]\n  int error_check_0; // [rsp+78h] [rbp-28h]\n  int possible_col2_0; // [rsp+7Ch] [rbp-24h]\n  int possible_row2_0; // [rsp+80h] [rbp-20h]\n  int possible_col1_1; // [rsp+88h] [rbp-18h]\n  int possible_row1_1; // [rsp+8Ch] [rbp-14h]\n  int error_check_1; // [rsp+90h] [rbp-10h]\n  int possible_col2_1; // [rsp+94h] [rbp-Ch]\n  int possible_row2_1; // [rsp+98h] [rbp-8h]\n\n  num_possibles = 0;\n  is_tower = 0;\n  if ( piece_at_location(board_input, col, row) == 66 || piece_at_location(board_input, col, row) == 87 )\n    is_tower = 1;\n  if ( is_tower )\n  {\n    for ( i = 0; i <= 3; ++i )\n    {\n      possible_col1 = char_to_col(col) + tower_movements[i][0];\n      possible_row1 = char_to_row(row) + tower_movements[i][1];\n      p_col1 = col_to_char(possible_col1);\n      p_row1 = row_to_char(possible_row1);\n      error_check = check_move_error_1_to_5(board_input, col, row, p_col1, p_row1, black_action);\n      if ( !error_check )\n      {\n        (*valid_moves)[2 * num_possibles] = p_col1;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1;\n      }\n      capture_possible = 0;\n      if ( error_check == 4 )\n      {\n        if ( black_action )\n        {\n          if ( piece_at_location(board_input, p_col1, p_row1) == 119\n            || piece_at_location(board_input, p_col1, p_row1) == 87 )\n          {\n            capture_possible = 1;\n          }\n        }\n        else if ( piece_at_location(board_input, p_col1, p_row1) == 98\n               || piece_at_location(board_input, p_col1, p_row1) == 66 )\n        {\n          capture_possible = 1;\n        }\n      }\n      if ( capture_possible )\n      {\n        possible_col2 = char_to_col(col) + 2 * tower_movements[i][0];\n        possible_row2 = char_to_row(row) + 2 * tower_movements[i][1];\n        p_col2 = col_to_char(possible_col2);\n        p_row2 = row_to_char(possible_row2);\n        if ( !check_move_error_1_to_5(board_input, col, row, p_col2, p_row2, black_action) )\n        {\n          (*valid_moves)[2 * num_possibles] = p_col2;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2;\n        }\n      }\n    }\n  }\n  if ( piece_at_location(board_input, col, row) == 98 )\n  {\n    for ( i_0 = 0; i_0 <= 1; ++i_0 )\n    {\n      possible_col1_0 = char_to_col(col) + black_piece_movements[i_0][0];\n      possible_row1_0 = char_to_row(row) + black_piece_movements[i_0][1];\n      p_col1_0 = col_to_char(possible_col1_0);\n      p_row1_0 = row_to_char(possible_row1_0);\n      error_check_0 = check_move_error_1_to_5(board_input, col, row, p_col1_0, p_row1_0, black_action);\n      if ( !error_check_0 )\n      {\n        (*valid_moves)[2 * num_possibles] = p_col1_0;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1_0;\n      }\n      capture_possible_0 = 0;\n      if ( error_check_0 == 4 )\n      {\n        if ( black_action )\n        {\n          if ( piece_at_location(board_input, p_col1_0, p_row1_0) == 119\n            || piece_at_location(board_input, p_col1_0, p_row1_0) == 87 )\n          {\n            capture_possible_0 = 1;\n          }\n        }\n        else if ( piece_at_location(board_input, p_col1_0, p_row1_0) == 98\n               || piece_at_location(board_input, p_col1_0, p_row1_0) == 66 )\n        {\n          capture_possible_0 = 1;\n        }\n      }\n      if ( capture_possible_0 )\n      {\n        possible_col2_0 = char_to_col(col) + 2 * black_piece_movements[i_0][0];\n        possible_row2_0 = char_to_row(row) + 2 * black_piece_movements[i_0][1];\n        p_col2_0 = col_to_char(possible_col2_0);\n        p_row2_0 = row_to_char(possible_row2_0);\n        if ( !check_move_error_1_to_5(board_input, col, row, p_col2_0, p_row2_0, black_action) )\n        {\n          (*valid_moves)[2 * num_possibles] = p_col2_0;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2_0;\n        }\n      }\n    }\n  }\n  if ( piece_at_location(board_input, col, row) == 119 )\n  {\n    for ( i_1 = 0; i_1 <= 1; ++i_1 )\n    {\n      possible_col1_1 = char_to_col(col) + white_piece_movements[i_1][0];\n      possible_row1_1 = char_to_row(row) + white_piece_movements[i_1][1];\n      p_col1_1 = col_to_char(possible_col1_1);\n      p_row1_1 = row_to_char(possible_row1_1);\n      error_check_1 = check_move_error_1_to_5(board_input, col, row, p_col1_1, p_row1_1, black_action);\n      if ( !error_check_1 )\n      {\n        (*valid_moves)[2 * num_possibles] = p_col1_1;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1_1;\n      }\n      capture_possible_1 = 0;\n      if ( error_check_1 == 4 )\n      {\n        if ( black_action )\n        {\n          if ( piece_at_location(board_input, p_col1_1, p_row1_1) == 119\n            || piece_at_location(board_input, p_col1_1, p_row1_1) == 87 )\n          {\n            capture_possible_1 = 1;\n          }\n        }\n        else if ( piece_at_location(board_input, p_col1_1, p_row1_1) == 98\n               || piece_at_location(board_input, p_col1_1, p_row1_1) == 66 )\n        {\n          capture_possible_1 = 1;\n        }\n      }\n      if ( capture_possible_1 )\n      {\n        possible_col2_1 = char_to_col(col) + 2 * white_piece_movements[i_1][0];\n        possible_row2_1 = char_to_row(row) + 2 * white_piece_movements[i_1][1];\n        p_col2_1 = col_to_char(possible_col2_1);\n        p_row2_1 = row_to_char(possible_row2_1);\n        if ( !check_move_error_1_to_5(board_input, col, row, p_col2_1, p_row2_1, black_action) )\n        {\n          (*valid_moves)[2 * num_possibles] = p_col2_1;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2_1;\n        }\n      }\n    }\n  }\n  return num_possibles;\n}\n"}, "pseudo_normalize": "int all_possible_moves(unsigned char (*board_input)[8], char col, char row,\n                       square_t *valid_moves, int black_action) {\n  char p_col1;\n  char p_row1;\n  char p_col2;\n  char p_row2;\n  char p_col1_0;\n  char p_row1_0;\n  char p_col2_0;\n  char p_row2_0;\n  char p_col1_1;\n  char p_row1_1;\n  char p_col2_1;\n  char p_row2_1;\n  int num_possibles;\n  int is_tower;\n  int i;\n  int capture_possible;\n  int i_0;\n  int capture_possible_0;\n  int i_1;\n  int capture_possible_1;\n  int possible_col1;\n  int possible_row1;\n  int error_check;\n  int possible_col2;\n  int possible_row2;\n  int possible_col1_0;\n  int possible_row1_0;\n  int error_check_0;\n  int possible_col2_0;\n  int possible_row2_0;\n  int possible_col1_1;\n  int possible_row1_1;\n  int error_check_1;\n  int possible_col2_1;\n  int possible_row2_1;\n  num_possibles = 0;\n  is_tower = 0;\n  if (piece_at_location(board_input, col, row) == 66 ||\n      piece_at_location(board_input, col, row) == 87)\n    is_tower = 1;\n  if (is_tower) {\n    for (i = 0; i <= 3; ++i) {\n      possible_col1 = char_to_col(col) + tower_movements[i][0];\n      possible_row1 = char_to_row(row) + tower_movements[i][1];\n      p_col1 = col_to_char(possible_col1);\n      p_row1 = row_to_char(possible_row1);\n      error_check = check_move_error_1_to_5(board_input, col, row, p_col1,\n                                            p_row1, black_action);\n      if (!error_check) {\n        (*valid_moves)[2 * num_possibles] = p_col1;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1;\n      }\n      capture_possible = 0;\n      if (error_check == 4) {\n        if (black_action) {\n          if (piece_at_location(board_input, p_col1, p_row1) == 119 ||\n              piece_at_location(board_input, p_col1, p_row1) == 87) {\n            capture_possible = 1;\n          }\n        } else if (piece_at_location(board_input, p_col1, p_row1) == 98 ||\n                   piece_at_location(board_input, p_col1, p_row1) == 66) {\n          capture_possible = 1;\n        }\n      }\n      if (capture_possible) {\n        possible_col2 = char_to_col(col) + 2 * tower_movements[i][0];\n        possible_row2 = char_to_row(row) + 2 * tower_movements[i][1];\n        p_col2 = col_to_char(possible_col2);\n        p_row2 = row_to_char(possible_row2);\n        if (!check_move_error_1_to_5(board_input, col, row, p_col2, p_row2,\n                                     black_action)) {\n          (*valid_moves)[2 * num_possibles] = p_col2;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2;\n        }\n      }\n    }\n  }\n  if (piece_at_location(board_input, col, row) == 98) {\n    for (i_0 = 0; i_0 <= 1; ++i_0) {\n      possible_col1_0 = char_to_col(col) + black_piece_movements[i_0][0];\n      possible_row1_0 = char_to_row(row) + black_piece_movements[i_0][1];\n      p_col1_0 = col_to_char(possible_col1_0);\n      p_row1_0 = row_to_char(possible_row1_0);\n      error_check_0 = check_move_error_1_to_5(board_input, col, row, p_col1_0,\n                                              p_row1_0, black_action);\n      if (!error_check_0) {\n        (*valid_moves)[2 * num_possibles] = p_col1_0;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1_0;\n      }\n      capture_possible_0 = 0;\n      if (error_check_0 == 4) {\n        if (black_action) {\n          if (piece_at_location(board_input, p_col1_0, p_row1_0) == 119 ||\n              piece_at_location(board_input, p_col1_0, p_row1_0) == 87) {\n            capture_possible_0 = 1;\n          }\n        } else if (piece_at_location(board_input, p_col1_0, p_row1_0) == 98 ||\n                   piece_at_location(board_input, p_col1_0, p_row1_0) == 66) {\n          capture_possible_0 = 1;\n        }\n      }\n      if (capture_possible_0) {\n        possible_col2_0 = char_to_col(col) + 2 * black_piece_movements[i_0][0];\n        possible_row2_0 = char_to_row(row) + 2 * black_piece_movements[i_0][1];\n        p_col2_0 = col_to_char(possible_col2_0);\n        p_row2_0 = row_to_char(possible_row2_0);\n        if (!check_move_error_1_to_5(board_input, col, row, p_col2_0, p_row2_0,\n                                     black_action)) {\n          (*valid_moves)[2 * num_possibles] = p_col2_0;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2_0;\n        }\n      }\n    }\n  }\n  if (piece_at_location(board_input, col, row) == 119) {\n    for (i_1 = 0; i_1 <= 1; ++i_1) {\n      possible_col1_1 = char_to_col(col) + white_piece_movements[i_1][0];\n      possible_row1_1 = char_to_row(row) + white_piece_movements[i_1][1];\n      p_col1_1 = col_to_char(possible_col1_1);\n      p_row1_1 = row_to_char(possible_row1_1);\n      error_check_1 = check_move_error_1_to_5(board_input, col, row, p_col1_1,\n                                              p_row1_1, black_action);\n      if (!error_check_1) {\n        (*valid_moves)[2 * num_possibles] = p_col1_1;\n        (*valid_moves)[2 * num_possibles++ + 1] = p_row1_1;\n      }\n      capture_possible_1 = 0;\n      if (error_check_1 == 4) {\n        if (black_action) {\n          if (piece_at_location(board_input, p_col1_1, p_row1_1) == 119 ||\n              piece_at_location(board_input, p_col1_1, p_row1_1) == 87) {\n            capture_possible_1 = 1;\n          }\n        } else if (piece_at_location(board_input, p_col1_1, p_row1_1) == 98 ||\n                   piece_at_location(board_input, p_col1_1, p_row1_1) == 66) {\n          capture_possible_1 = 1;\n        }\n      }\n      if (capture_possible_1) {\n        possible_col2_1 = char_to_col(col) + 2 * white_piece_movements[i_1][0];\n        possible_row2_1 = char_to_row(row) + 2 * white_piece_movements[i_1][1];\n        p_col2_1 = col_to_char(possible_col2_1);\n        p_row2_1 = row_to_char(possible_row2_1);\n        if (!check_move_error_1_to_5(board_input, col, row, p_col2_1, p_row2_1,\n                                     black_action)) {\n          (*valid_moves)[2 * num_possibles] = p_col2_1;\n          (*valid_moves)[2 * num_possibles++ + 1] = p_row2_1;\n        }\n      }\n    }\n  }\n  return num_possibles;\n}", "binary": "checkers/checkers.host.O0", "assembly": "<all_possible_moves>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xa0,%rsp\nmov    %rdi,-0x88(%rbp)\nmov    %edx,%eax\nmov    %rcx,-0x98(%rbp)\nmov    %r8d,-0x9c(%rbp)\nmov    %esi,%edx\nmov    %dl,-0x8c(%rbp)\nmov    %al,-0x90(%rbp)\nmovl   $0x0,-0x68(%rbp)\nmovl   $0x0,-0x64(%rbp)\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x42,%al\nje     1f0a <all_possible_moves+0x88>\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x57,%al\njne    1f11 <all_possible_moves+0x8f>\nmovl   $0x1,-0x64(%rbp)\ncmpl   $0x0,-0x64(%rbp)\nje     21a9 <all_possible_moves+0x327>\nmovl   $0x0,-0x60(%rbp)\njmp    219f <all_possible_moves+0x31d>\nmovsbl -0x8c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ecx\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x8195(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\nmov    %eax,-0x48(%rbp)\nmovsbl -0x90(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ecx\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x816d(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\nmov    %eax,-0x44(%rbp)\nmov    -0x48(%rbp),%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x74(%rbp)\nmov    -0x44(%rbp),%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x73(%rbp)\nmovsbl -0x73(%rbp),%edi\nmovsbl -0x74(%rbp),%ecx\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%esi\nmov    -0x9c(%rbp),%r8d\nmov    -0x88(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x40(%rbp)\ncmpl   $0x0,-0x40(%rbp)\njne    200b <all_possible_moves+0x189>\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x74(%rbp),%eax\nmov    %al,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x73(%rbp),%eax\nmov    %al,0x1(%rdx)\naddl   $0x1,-0x68(%rbp)\nmovl   $0x0,-0x5c(%rbp)\ncmpl   $0x4,-0x40(%rbp)\njne    20a9 <all_possible_moves+0x227>\ncmpl   $0x0,-0x9c(%rbp)\nje     2068 <all_possible_moves+0x1e6>\nmovsbl -0x73(%rbp),%edx\nmovsbl -0x74(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x77,%al\nje     205f <all_possible_moves+0x1dd>\nmovsbl -0x73(%rbp),%edx\nmovsbl -0x74(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x57,%al\njne    20a9 <all_possible_moves+0x227>\nmovl   $0x1,-0x5c(%rbp)\njmp    20a9 <all_possible_moves+0x227>\nmovsbl -0x73(%rbp),%edx\nmovsbl -0x74(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x62,%al\nje     20a2 <all_possible_moves+0x220>\nmovsbl -0x73(%rbp),%edx\nmovsbl -0x74(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x42,%al\njne    20a9 <all_possible_moves+0x227>\nmovl   $0x1,-0x5c(%rbp)\ncmpl   $0x0,-0x5c(%rbp)\nje     219b <all_possible_moves+0x319>\nmovsbl -0x8c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ecx\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x8009(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmov    %eax,-0x3c(%rbp)\nmovsbl -0x90(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ecx\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7fdf(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmov    %eax,-0x38(%rbp)\nmov    -0x3c(%rbp),%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x72(%rbp)\nmov    -0x38(%rbp),%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x71(%rbp)\nmovsbl -0x71(%rbp),%edi\nmovsbl -0x72(%rbp),%ecx\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%esi\nmov    -0x9c(%rbp),%r8d\nmov    -0x88(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x34(%rbp)\ncmpl   $0x0,-0x34(%rbp)\njne    219b <all_possible_moves+0x319>\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x72(%rbp),%eax\nmov    %al,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x71(%rbp),%eax\nmov    %al,0x1(%rdx)\naddl   $0x1,-0x68(%rbp)\naddl   $0x1,-0x60(%rbp)\ncmpl   $0x3,-0x60(%rbp)\njle    1f27 <all_possible_moves+0xa5>\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x62,%al\njne    245e <all_possible_moves+0x5dc>\nmovl   $0x0,-0x58(%rbp)\njmp    2454 <all_possible_moves+0x5d2>\nmovsbl -0x8c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ecx\nmov    -0x58(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7eb0(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\nmov    %eax,-0x30(%rbp)\nmovsbl -0x90(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ecx\nmov    -0x58(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7e88(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x30(%rbp),%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x70(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x6f(%rbp)\nmovsbl -0x6f(%rbp),%edi\nmovsbl -0x70(%rbp),%ecx\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%esi\nmov    -0x9c(%rbp),%r8d\nmov    -0x88(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x28(%rbp)\ncmpl   $0x0,-0x28(%rbp)\njne    22c0 <all_possible_moves+0x43e>\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x70(%rbp),%eax\nmov    %al,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x6f(%rbp),%eax\nmov    %al,0x1(%rdx)\naddl   $0x1,-0x68(%rbp)\nmovl   $0x0,-0x54(%rbp)\ncmpl   $0x4,-0x28(%rbp)\njne    235e <all_possible_moves+0x4dc>\ncmpl   $0x0,-0x9c(%rbp)\nje     231d <all_possible_moves+0x49b>\nmovsbl -0x6f(%rbp),%edx\nmovsbl -0x70(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x77,%al\nje     2314 <all_possible_moves+0x492>\nmovsbl -0x6f(%rbp),%edx\nmovsbl -0x70(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x57,%al\njne    235e <all_possible_moves+0x4dc>\nmovl   $0x1,-0x54(%rbp)\njmp    235e <all_possible_moves+0x4dc>\nmovsbl -0x6f(%rbp),%edx\nmovsbl -0x70(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x62,%al\nje     2357 <all_possible_moves+0x4d5>\nmovsbl -0x6f(%rbp),%edx\nmovsbl -0x70(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x42,%al\njne    235e <all_possible_moves+0x4dc>\nmovl   $0x1,-0x54(%rbp)\ncmpl   $0x0,-0x54(%rbp)\nje     2450 <all_possible_moves+0x5ce>\nmovsbl -0x8c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ecx\nmov    -0x58(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7d24(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmov    %eax,-0x24(%rbp)\nmovsbl -0x90(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ecx\nmov    -0x58(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7cfa(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x6e(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x6d(%rbp)\nmovsbl -0x6d(%rbp),%edi\nmovsbl -0x6e(%rbp),%ecx\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%esi\nmov    -0x9c(%rbp),%r8d\nmov    -0x88(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njne    2450 <all_possible_moves+0x5ce>\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x6e(%rbp),%eax\nmov    %al,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x6d(%rbp),%eax\nmov    %al,0x1(%rdx)\naddl   $0x1,-0x68(%rbp)\naddl   $0x1,-0x58(%rbp)\ncmpl   $0x1,-0x58(%rbp)\njle    21dc <all_possible_moves+0x35a>\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x77,%al\njne    2713 <all_possible_moves+0x891>\nmovl   $0x0,-0x50(%rbp)\njmp    2709 <all_possible_moves+0x887>\nmovsbl -0x8c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ecx\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7c0b(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\nmov    %eax,-0x18(%rbp)\nmovsbl -0x90(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ecx\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7be3(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x6c(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x6b(%rbp)\nmovsbl -0x6b(%rbp),%edi\nmovsbl -0x6c(%rbp),%ecx\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%esi\nmov    -0x9c(%rbp),%r8d\nmov    -0x88(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njne    2575 <all_possible_moves+0x6f3>\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x6c(%rbp),%eax\nmov    %al,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x6b(%rbp),%eax\nmov    %al,0x1(%rdx)\naddl   $0x1,-0x68(%rbp)\nmovl   $0x0,-0x4c(%rbp)\ncmpl   $0x4,-0x10(%rbp)\njne    2613 <all_possible_moves+0x791>\ncmpl   $0x0,-0x9c(%rbp)\nje     25d2 <all_possible_moves+0x750>\nmovsbl -0x6b(%rbp),%edx\nmovsbl -0x6c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x77,%al\nje     25c9 <all_possible_moves+0x747>\nmovsbl -0x6b(%rbp),%edx\nmovsbl -0x6c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x57,%al\njne    2613 <all_possible_moves+0x791>\nmovl   $0x1,-0x4c(%rbp)\njmp    2613 <all_possible_moves+0x791>\nmovsbl -0x6b(%rbp),%edx\nmovsbl -0x6c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x62,%al\nje     260c <all_possible_moves+0x78a>\nmovsbl -0x6b(%rbp),%edx\nmovsbl -0x6c(%rbp),%ecx\nmov    -0x88(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x42,%al\njne    2613 <all_possible_moves+0x791>\nmovl   $0x1,-0x4c(%rbp)\ncmpl   $0x0,-0x4c(%rbp)\nje     2705 <all_possible_moves+0x883>\nmovsbl -0x8c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ecx\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7a7f(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmov    %eax,-0xc(%rbp)\nmovsbl -0x90(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ecx\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x7a55(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%eax\nadd    %ecx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x6a(%rbp)\nmov    -0x8(%rbp),%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x69(%rbp)\nmovsbl -0x69(%rbp),%edi\nmovsbl -0x6a(%rbp),%ecx\nmovsbl -0x90(%rbp),%edx\nmovsbl -0x8c(%rbp),%esi\nmov    -0x9c(%rbp),%r8d\nmov    -0x88(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    2705 <all_possible_moves+0x883>\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x6a(%rbp),%eax\nmov    %al,(%rdx)\nmov    -0x68(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nmov    -0x98(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x69(%rbp),%eax\nmov    %al,0x1(%rdx)\naddl   $0x1,-0x68(%rbp)\naddl   $0x1,-0x50(%rbp)\ncmpl   $0x1,-0x50(%rbp)\njle    2491 <all_possible_moves+0x60f>\nmov    -0x68(%rbp),%eax\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "board_cost", "content": "// function to return board cost for board_t input\nint board_cost(board_t board_input) {\n\tint b_count=0, B_count=0, w_count=0, W_count=0;\n\tfor (int i=0; i<BOARD_SIZE;i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\tif (board_input[i][j] == CELL_BPIECE) {\n\t\t\t\tb_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_BTOWER) {\n\t\t\t\tB_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_WPIECE) {\n\t\t\t\tw_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_WTOWER) {\n\t\t\t\tW_count += 1;\n\t\t\t}\n\t\t}\n\t}\n\tint cost = b_count + (3 * B_count) - w_count - (3 * W_count);\n\treturn cost;\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "board_cost", "address": "0x27e6", "label": "board_cost", "content": "int __cdecl board_cost(unsigned __int8 (*board_input)[8])\n{\n  int b_count; // [rsp+Ch] [rbp-1Ch]\n  int B_count; // [rsp+10h] [rbp-18h]\n  int w_count; // [rsp+14h] [rbp-14h]\n  int W_count; // [rsp+18h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-Ch]\n  int j; // [rsp+20h] [rbp-8h]\n\n  b_count = 0;\n  B_count = 0;\n  w_count = 0;\n  W_count = 0;\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n    {\n      if ( (*board_input)[8 * i + j] == 98 )\n        ++b_count;\n      if ( (*board_input)[8 * i + j] == 66 )\n        ++B_count;\n      if ( (*board_input)[8 * i + j] == 119 )\n        ++w_count;\n      if ( (*board_input)[8 * i + j] == 87 )\n        ++W_count;\n    }\n  }\n  return 3 * B_count + b_count - w_count - 3 * W_count;\n}\n"}, "pseudo_normalize": "int board_cost(unsigned char (*board_input)[8]) {\n  int b_count;\n  int B_count;\n  int w_count;\n  int W_count;\n  int i;\n  int j;\n  b_count = 0;\n  B_count = 0;\n  w_count = 0;\n  W_count = 0;\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j) {\n      if ((*board_input)[8 * i + j] == 98) ++b_count;\n      if ((*board_input)[8 * i + j] == 66) ++B_count;\n      if ((*board_input)[8 * i + j] == 119) ++w_count;\n      if ((*board_input)[8 * i + j] == 87) ++W_count;\n    }\n  }\n  return 3 * B_count + b_count - w_count - 3 * W_count;\n}", "binary": "checkers/checkers.host.O0", "assembly": "<board_cost>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    28cc <board_cost+0xe6>\nmovl   $0x0,-0x8(%rbp)\njmp    28be <board_cost+0xd8>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmovzbl (%rdx,%rax,1),%eax\ncmp    $0x62,%al\njne    284b <board_cost+0x65>\naddl   $0x1,-0x1c(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmovzbl (%rdx,%rax,1),%eax\ncmp    $0x42,%al\njne    2870 <board_cost+0x8a>\naddl   $0x1,-0x18(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmovzbl (%rdx,%rax,1),%eax\ncmp    $0x77,%al\njne    2895 <board_cost+0xaf>\naddl   $0x1,-0x14(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmovzbl (%rdx,%rax,1),%eax\ncmp    $0x57,%al\njne    28ba <board_cost+0xd4>\naddl   $0x1,-0x10(%rbp)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x7,-0x8(%rbp)\njle    2826 <board_cost+0x40>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njle    281a <board_cost+0x34>\nmov    -0x18(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %eax,%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nsub    -0x14(%rbp),%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%eax\nmov    %eax,%esi\nlea    0x0(,%rax,4),%ecx\nmov    %esi,%eax\nsub    %ecx,%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "change_board", "content": "// adjust a board_t variable with a given input move\nvoid change_board(board_t* board, char col1, char row1, char col2, char row2) {\n\tchar being_moved_temp = piece_at_location(*board, col1, row1);\n\t\n\t// make source cell empty\n\t(*board)[char_to_col(col1) - 1][char_to_row(row1) - 1] = CELL_EMPTY;\n\t\n\t// consider, if piece reached end, it must be promoted\n\tif ((being_moved_temp == CELL_BPIECE) && (row2 == END_ROW_BLACK)) {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1]\n\t\t\t= CELL_BTOWER;\n\t}\n\telse if ((being_moved_temp == CELL_WPIECE) && (row2 == END_ROW_WHITE)) {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1]\n\t\t\t= CELL_WTOWER;\n\t}\n\t// otherwise make target cell the piece being moved\n\telse {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1] \n\t\t\t= being_moved_temp;\n\t}\n\t// if capturing, captured middle piece must be removed as well\n\tif (libmin_abs(char_to_col(col2) - char_to_col(col1)) == CAPTURE_JUMP) {\n\t\tint middle_col = min(char_to_col(col1), char_to_col(col2)) + 1;\n\t\tint middle_row = min(char_to_row(row1), char_to_row(row2)) + 1;\n\t\t(*board)[middle_col - 1][middle_row - 1] = CELL_EMPTY;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "change_board", "address": "0x1cb6", "label": "change_board", "content": "void __cdecl change_board(board_t *board, char col1, char row1, char col2, char row2)\n{\n  int v5; // ebx\n  int v6; // ebx\n  int v7; // ebx\n  int v8; // ebx\n  int v9; // ebx\n  int v10; // eax\n  int v11; // ebx\n  int v12; // eax\n  int v13; // ebx\n  int v14; // eax\n  unsigned __int8 being_moved_temp; // [rsp+27h] [rbp-19h]\n  int middle_col; // [rsp+28h] [rbp-18h]\n\n  being_moved_temp = piece_at_location((unsigned __int8 (*)[8])board, col1, row1);\n  v5 = char_to_col(col1) - 1;\n  (*board)[v5 - 1][char_to_row(row1) + 7] = 48;\n  if ( being_moved_temp == 98 && row2 == 49 )\n  {\n    v6 = char_to_col(col2) - 1;\n    (*board)[v6 - 1][char_to_row(49) + 7] = 66;\n  }\n  else if ( being_moved_temp == 119 && row2 == 56 )\n  {\n    v7 = char_to_col(col2) - 1;\n    (*board)[v7 - 1][char_to_row(56) + 7] = 87;\n  }\n  else\n  {\n    v8 = char_to_col(col2) - 1;\n    (*board)[v8 - 1][char_to_row(row2) + 7] = being_moved_temp;\n  }\n  v9 = char_to_col(col2);\n  v10 = char_to_col(col1);\n  if ( libmin_abs(v9 - v10) == 2 )\n  {\n    v11 = char_to_col(col2);\n    v12 = char_to_col(col1);\n    middle_col = min(v12, v11) + 1;\n    v13 = char_to_row(row2);\n    v14 = char_to_row(row1);\n    (*board)[middle_col - 1][min(v14, v13)] = 48;\n  }\n}\n"}, "pseudo_normalize": "void change_board(board_t *board, char col1, char row1, char col2, char row2) {\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  unsigned char being_moved_temp;\n  int middle_col;\n  being_moved_temp = piece_at_location((unsigned char(*)[8])board, col1, row1);\n  v5 = char_to_col(col1) - 1;\n  (*board)[v5 - 1][char_to_row(row1) + 7] = 48;\n  if (being_moved_temp == 98 && row2 == 49) {\n    v6 = char_to_col(col2) - 1;\n    (*board)[v6 - 1][char_to_row(49) + 7] = 66;\n  } else if (being_moved_temp == 119 && row2 == 56) {\n    v7 = char_to_col(col2) - 1;\n    (*board)[v7 - 1][char_to_row(56) + 7] = 87;\n  } else {\n    v8 = char_to_col(col2) - 1;\n    (*board)[v8 - 1][char_to_row(row2) + 7] = being_moved_temp;\n  }\n  v9 = char_to_col(col2);\n  v10 = char_to_col(col1);\n  if (libmin_abs(v9 - v10) == 2) {\n    v11 = char_to_col(col2);\n    v12 = char_to_col(col1);\n    middle_col = min(v12, v11) + 1;\n    v13 = char_to_row(row2);\n    v14 = char_to_row(row1);\n    (*board)[middle_col - 1][min(v14, v13)] = 48;\n  }\n}", "binary": "checkers/checkers.host.O0", "assembly": "<change_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %ecx,%eax\nmov    %r8d,%edi\nmov    %esi,%ecx\nmov    %cl,-0x2c(%rbp)\nmov    %dl,-0x30(%rbp)\nmov    %al,-0x34(%rbp)\nmov    %edi,%eax\nmov    %al,-0x38(%rbp)\nmovsbl -0x30(%rbp),%edx\nmovsbl -0x2c(%rbp),%ecx\nmov    -0x28(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\nmov    %al,-0x19(%rbp)\nmovsbl -0x2c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nlea    -0x1(%rax),%ebx\nmovsbl -0x30(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nsub    $0x1,%eax\nmov    -0x28(%rbp),%rcx\nmovslq %eax,%rdx\nmovslq %ebx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\ncmpb   $0x62,-0x19(%rbp)\njne    1d69 <change_board+0xb3>\ncmpb   $0x31,-0x38(%rbp)\njne    1d69 <change_board+0xb3>\nmovsbl -0x34(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nlea    -0x1(%rax),%ebx\nmovsbl -0x38(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nsub    $0x1,%eax\nmov    -0x28(%rbp),%rcx\nmovslq %eax,%rdx\nmovslq %ebx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovb   $0x42,(%rax)\njmp    1de0 <change_board+0x12a>\ncmpb   $0x77,-0x19(%rbp)\njne    1daa <change_board+0xf4>\ncmpb   $0x38,-0x38(%rbp)\njne    1daa <change_board+0xf4>\nmovsbl -0x34(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nlea    -0x1(%rax),%ebx\nmovsbl -0x38(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nsub    $0x1,%eax\nmov    -0x28(%rbp),%rcx\nmovslq %eax,%rdx\nmovslq %ebx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovb   $0x57,(%rax)\njmp    1de0 <change_board+0x12a>\nmovsbl -0x34(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nlea    -0x1(%rax),%ebx\nmovsbl -0x38(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nsub    $0x1,%eax\nmovzbl -0x19(%rbp),%edx\nmov    -0x28(%rbp),%rsi\nmovslq %eax,%rcx\nmovslq %ebx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nadd    %rcx,%rax\nmov    %dl,(%rax)\nmovsbl -0x34(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ebx\nmovsbl -0x2c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%edx\nmov    %ebx,%eax\nsub    %edx,%eax\nmov    %eax,%edi\ncall   30c4 <libmin_abs>\ncmp    $0x2,%eax\njne    1e7b <change_board+0x1c5>\nmovsbl -0x34(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %eax,%ebx\nmovsbl -0x2c(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    %ebx,%esi\nmov    %eax,%edi\ncall   2718 <min>\nadd    $0x1,%eax\nmov    %eax,-0x18(%rbp)\nmovsbl -0x38(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %eax,%ebx\nmovsbl -0x30(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    %ebx,%esi\nmov    %eax,%edi\ncall   2718 <min>\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x14(%rbp),%eax\nsub    $0x1,%eax\nmov    -0x28(%rbp),%rsi\nmovslq %eax,%rcx\nmovslq %edx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nadd    %rcx,%rax\nmovb   $0x30,(%rax)\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "char_to_col", "content": "// convert column coordinate character position into column number\n// offset from A + 1 to give col number\nint char_to_col(char col) { \n\tint ascii_value = (int) col;\n\treturn ascii_value - ASCII_A + 1;}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "char_to_col", "address": "0x1960", "label": "char_to_col", "content": "int __cdecl char_to_col(char col)\n{\n  return col - 64;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O0", "assembly": "<char_to_col>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x14(%rbp)\nmovsbl -0x14(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nsub    $0x40,%eax\npop    %rbp\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "char_to_row", "content": "// convert row coordinate character position into row number\n// offset from 1 + 1 to give row number\nint char_to_row(char row) { \n\tint ascii_value = (int) row;\n\treturn ascii_value - ASCII_1 + 1;}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "char_to_row", "address": "0x197c", "label": "char_to_row", "content": "int __cdecl char_to_row(char row)\n{\n  return row - 48;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O0", "assembly": "<char_to_row>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x14(%rbp)\nmovsbl -0x14(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nsub    $0x30,%eax\npop    %rbp\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "check_move_error_1_to_5", "content": "// lazy evaluation, systematically check for move errors 1-5\n\t// if any found, print error message and return error code\nint check_move_error_1_to_5(board_t board_input, \n\tchar col1, char row1, char col2, char row2, int black_action) {\n\t// error 1\n\tif (outside_of_board(col1, row1)) {\n\t\treturn 1;\n\t}\n\t// error 2\n\tif (outside_of_board(col2, row2)) {\n\t\treturn 2;\n\t}\n\t// error 3\n\tif (piece_at_location(board_input, col1, row1) == CELL_EMPTY) {\n\t\treturn 3;\n\t}\n\t// error 4\n\tif (piece_at_location(board_input, col2, row2) != CELL_EMPTY) {\n\t\treturn 4;\n\t}\n\t// error 5 \n\tif (black_action) {\n\t\tif ((piece_at_location(board_input, col1, row1) == CELL_WPIECE)\n\t\t\t|| \n\t\t(piece_at_location(board_input, col1, row1) == CELL_WTOWER)) {\n\t\t\treturn 5;\n\t\t}\n\t}\n\telse {\n\t\tif ((piece_at_location(board_input, col1, row1) == CELL_BPIECE)\n\t\t\t|| \n\t\t(piece_at_location(board_input, col1, row1) == CELL_BTOWER)) {\n\t\t\treturn 5;\n\t\t}\n\t}\n\treturn NO_ERRORS_1_TO_5;\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "check_move_error_1_to_5", "address": "0x1ace", "label": "check_move_error_1_to_5", "content": "int __cdecl check_move_error_1_to_5(\n        unsigned __int8 (*board_input)[8],\n        char col1,\n        char row1,\n        char col2,\n        char row2,\n        int black_action)\n{\n  if ( outside_of_board(col1, row1) )\n    return 1;\n  if ( outside_of_board(col2, row2) )\n    return 2;\n  if ( piece_at_location(board_input, col1, row1) == 48 )\n    return 3;\n  if ( piece_at_location(board_input, col2, row2) != 48 )\n    return 4;\n  if ( black_action )\n  {\n    if ( piece_at_location(board_input, col1, row1) == 119 || piece_at_location(board_input, col1, row1) == 87 )\n      return 5;\n  }\n  else if ( piece_at_location(board_input, col1, row1) == 98 || piece_at_location(board_input, col1, row1) == 66 )\n  {\n    return 5;\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int check_move_error_1_to_5(unsigned char (*board_input)[8], char col1,\n                            char row1, char col2, char row2, int black_action) {\n  if (outside_of_board(col1, row1)) return 1;\n  if (outside_of_board(col2, row2)) return 2;\n  if (piece_at_location(board_input, col1, row1) == 48) return 3;\n  if (piece_at_location(board_input, col2, row2) != 48) return 4;\n  if (black_action) {\n    if (piece_at_location(board_input, col1, row1) == 119 ||\n        piece_at_location(board_input, col1, row1) == 87)\n      return 5;\n  } else if (piece_at_location(board_input, col1, row1) == 98 ||\n             piece_at_location(board_input, col1, row1) == 66) {\n    return 5;\n  }\n  return 0;\n}", "binary": "checkers/checkers.host.O0", "assembly": "<check_move_error_1_to_5>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %ecx,%eax\nmov    %r8d,%edi\nmov    %r9d,-0x1c(%rbp)\nmov    %esi,%ecx\nmov    %cl,-0xc(%rbp)\nmov    %dl,-0x10(%rbp)\nmov    %al,-0x14(%rbp)\nmov    %edi,%eax\nmov    %al,-0x18(%rbp)\nmovsbl -0x10(%rbp),%edx\nmovsbl -0xc(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1c00 <outside_of_board>\ntest   %eax,%eax\nje     1b16 <check_move_error_1_to_5+0x48>\nmov    $0x1,%eax\njmp    1bfe <check_move_error_1_to_5+0x130>\nmovsbl -0x18(%rbp),%edx\nmovsbl -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1c00 <outside_of_board>\ntest   %eax,%eax\nje     1b35 <check_move_error_1_to_5+0x67>\nmov    $0x2,%eax\njmp    1bfe <check_move_error_1_to_5+0x130>\nmovsbl -0x10(%rbp),%edx\nmovsbl -0xc(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x30,%al\njne    1b59 <check_move_error_1_to_5+0x8b>\nmov    $0x3,%eax\njmp    1bfe <check_move_error_1_to_5+0x130>\nmovsbl -0x18(%rbp),%edx\nmovsbl -0x14(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x30,%al\nje     1b7d <check_move_error_1_to_5+0xaf>\nmov    $0x4,%eax\njmp    1bfe <check_move_error_1_to_5+0x130>\ncmpl   $0x0,-0x1c(%rbp)\nje     1bbe <check_move_error_1_to_5+0xf0>\nmovsbl -0x10(%rbp),%edx\nmovsbl -0xc(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x77,%al\nje     1bb7 <check_move_error_1_to_5+0xe9>\nmovsbl -0x10(%rbp),%edx\nmovsbl -0xc(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x57,%al\njne    1bf9 <check_move_error_1_to_5+0x12b>\nmov    $0x5,%eax\njmp    1bfe <check_move_error_1_to_5+0x130>\nmovsbl -0x10(%rbp),%edx\nmovsbl -0xc(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x62,%al\nje     1bf2 <check_move_error_1_to_5+0x124>\nmovsbl -0x10(%rbp),%edx\nmovsbl -0xc(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1c62 <piece_at_location>\ncmp    $0x42,%al\njne    1bf9 <check_move_error_1_to_5+0x12b>\nmov    $0x5,%eax\njmp    1bfe <check_move_error_1_to_5+0x130>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "col_to_char", "content": "// reverse char_to_col\nchar col_to_char(int col) {return (char) (ASCII_A + col - 1);}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "col_to_char", "address": "0x1998", "label": "col_to_char", "content": "char __cdecl col_to_char(int col)\n{\n  return col + 64;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O0", "assembly": "<col_to_char>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x40,%eax\npop    %rbp\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "fill_print_initial", "content": "#include \"libmin.h\"\n\n#include \"consttypes.h\"\n#include \"functions.h\"\n\n// fill and print information on the initial board configuration\nvoid fill_print_initial(board_t* board) {\n\t// specify initial setup \n\tlibmin_printf(\"BOARD SIZE: %dx%d\\n\", BOARD_SIZE, BOARD_SIZE);\n\tlibmin_printf(\"#BLACK PIECES: %d\\n\", ORIGINAL_PIECES_COUNT);\n\tlibmin_printf(\"#WHITE PIECES: %d\\n\", ORIGINAL_PIECES_COUNT);\n\t\n\t// fill board with the original board configuration\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\tint filled = 0; \n\t\t\tfor (int k=0; k<ORIGINAL_PIECES_COUNT; k++) {\n\t\t\t\tif ((char_to_col(white_initial_squares[k][0]) == i + 1) && \n\t\t\t\t\t(char_to_row(white_initial_squares[k][1]) == j + 1)) {\n\t\t\t\t\t\t(*board)[i][j] = CELL_WPIECE;\n\t\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k=0; k<ORIGINAL_PIECES_COUNT; k++) {\n\t\t\t\tif ((char_to_col(black_initial_squares[k][0]) == i + 1) && \n\t\t\t\t\t(char_to_row(black_initial_squares[k][1]) == j + 1)) {\n\t\t\t\t\t\t(*board)[i][j] = CELL_BPIECE;\n\t\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (filled == 0) {\n\t\t\t\t(*board)[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "fill_print_initial", "address": "0x1793", "label": "fill_print_initial", "content": "void __cdecl fill_print_initial(board_t *board)\n{\n  int i; // [rsp+1Ch] [rbp-14h]\n  int j; // [rsp+20h] [rbp-10h]\n  int filled; // [rsp+24h] [rbp-Ch]\n  int k; // [rsp+28h] [rbp-8h]\n  int k_0; // [rsp+2Ch] [rbp-4h]\n\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n    {\n      filled = 0;\n      for ( k = 0; k <= 11; ++k )\n      {\n        if ( char_to_col(white_initial_squares[2 * k]) == i + 1\n          && char_to_row(white_initial_squares[2 * k + 1]) == j + 1 )\n        {\n          (*board)[i][j] = 119;\n          filled = 1;\n        }\n      }\n      for ( k_0 = 0; k_0 <= 11; ++k_0 )\n      {\n        if ( char_to_col(black_initial_squares[2 * k_0]) == i + 1\n          && char_to_row(black_initial_squares[2 * k_0 + 1]) == j + 1 )\n        {\n          (*board)[i][j] = 98;\n          filled = 1;\n        }\n      }\n      if ( !filled )\n        (*board)[i][j] = 48;\n    }\n  }\n}\n"}, "pseudo_normalize": "void fill_print_initial(board_t *board) {\n  int i;\n  int j;\n  int filled;\n  int k;\n  int k_0;\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j) {\n      filled = 0;\n      for (k = 0; k <= 11; ++k) {\n        if (char_to_col(white_initial_squares[2 * k]) == i + 1 &&\n            char_to_row(white_initial_squares[2 * k + 1]) == j + 1) {\n          (*board)[i][j] = 119;\n          filled = 1;\n        }\n      }\n      for (k_0 = 0; k_0 <= 11; ++k_0) {\n        if (char_to_col(black_initial_squares[2 * k_0]) == i + 1 &&\n            char_to_row(black_initial_squares[2 * k_0 + 1]) == j + 1) {\n          (*board)[i][j] = 98;\n          filled = 1;\n        }\n      }\n      if (!filled) (*board)[i][j] = 48;\n    }\n  }\n}", "binary": "checkers/checkers.host.O0", "assembly": "<fill_print_initial>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    $0x8,%edx\nmov    $0x8,%esi\nlea    0x58cc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nmov    $0xc,%esi\nlea    0x58c6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nmov    $0xc,%esi\nlea    0x58c0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nmovl   $0x0,-0x14(%rbp)\njmp    1952 <fill_print_initial+0x1bf>\nmovl   $0x0,-0x10(%rbp)\njmp    1944 <fill_print_initial+0x1b1>\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1892 <fill_print_initial+0xff>\nmov    -0x8(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x8835(%rip),%rax\nmovzbl (%rdx,%rax,1),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    -0x14(%rbp),%edx\nadd    $0x1,%edx\ncmp    %edx,%eax\njne    188e <fill_print_initial+0xfb>\nmov    -0x8(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x880e(%rip),%rax\nmovzbl (%rdx,%rax,1),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    -0x10(%rbp),%edx\nadd    $0x1,%edx\ncmp    %edx,%eax\njne    188e <fill_print_initial+0xfb>\nmov    -0x28(%rbp),%rcx\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovb   $0x77,(%rax)\nmovl   $0x1,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0xb,-0x8(%rbp)\njle    181b <fill_print_initial+0x88>\nmovl   $0x0,-0x4(%rbp)\njmp    1918 <fill_print_initial+0x185>\nmov    -0x4(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x87cf(%rip),%rax\nmovzbl (%rdx,%rax,1),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\nmov    -0x14(%rbp),%edx\nadd    $0x1,%edx\ncmp    %edx,%eax\njne    1914 <fill_print_initial+0x181>\nmov    -0x4(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x87a8(%rip),%rax\nmovzbl (%rdx,%rax,1),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nmov    -0x10(%rbp),%edx\nadd    $0x1,%edx\ncmp    %edx,%eax\njne    1914 <fill_print_initial+0x181>\nmov    -0x28(%rbp),%rcx\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovb   $0x62,(%rax)\nmovl   $0x1,-0xc(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0xb,-0x4(%rbp)\njle    18a1 <fill_print_initial+0x10e>\ncmpl   $0x0,-0xc(%rbp)\njne    1940 <fill_print_initial+0x1ad>\nmov    -0x28(%rbp),%rcx\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x7,-0x10(%rbp)\njle    180b <fill_print_initial+0x78>\naddl   $0x1,-0x14(%rbp)\ncmpl   $0x7,-0x14(%rbp)\njle    17ff <fill_print_initial+0x6c>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "free_tree", "content": "// free up the space taken by the tree, and the linked lists in the nodes\n\t// done recursively\nvoid free_tree(tree_node_t* node) {\n\t// base case, node is leaf\n\tif (node->children_count == 0) {\n\t\tlibmin_free(node);\n\t}\n\t// recursive case, have to recurse down to the leaf of the node first\n\telse {\n\t\t// we need to kill each child node...that sounds horrible...\n\t\t\t// 'free' each child node...better...\n\t\tlinked_list_member_t* list_member = (node->children_list).first;\n\t\t\t// list_member is used as an iterating item\n\t\ttree_node_t* child_node;\n\t\tfor (int i=0; i<(node->children_count); i++) {\n\t\t\tchild_node = (tree_node_t*)(list_member->child_node);\n\t\t\tfree_tree(child_node);\n\t\t\t\n\t\t\t// once we free the subtree fathered by the child\n\t\t\t\t// we are free to unlink the list member too\n\t\t\tlinked_list_member_t* redundant_list_member = list_member;\n\t\t\tlist_member = list_member->next;\n\t\t\tlibmin_free(redundant_list_member);\n\t\t}\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "free_tree", "address": "0x2efa", "label": "free_tree", "content": "void __cdecl free_tree(tree_node_t *node)\n{\n  int i; // [rsp+14h] [rbp-1Ch]\n  linked_list_member_t *list_member; // [rsp+18h] [rbp-18h]\n  linked_list_member_t *redundant_list_member; // [rsp+28h] [rbp-8h]\n\n  if ( node->children_count )\n  {\n    list_member = node->children_list.first;\n    for ( i = 0; i < node->children_count; ++i )\n    {\n      free_tree((tree_node_t *)list_member->child_node);\n      redundant_list_member = list_member;\n      list_member = list_member->next;\n      libmin_free(redundant_list_member);\n    }\n  }\n  else\n  {\n    libmin_free(node);\n  }\n}\n"}, "pseudo_normalize": "void free_tree(tree_node_t *node) {\n  int i;\n  linked_list_member_t *list_member;\n  linked_list_member_t *redundant_list_member;\n  if (node->children_count) {\n    list_member = node->children_list.first;\n    for (i = 0; i < node->children_count; ++i) {\n      free_tree((tree_node_t *)list_member->child_node);\n      redundant_list_member = list_member;\n      list_member = list_member->next;\n      libmin_free(redundant_list_member);\n    }\n  } else {\n    libmin_free(node);\n  }\n}", "binary": "checkers/checkers.host.O0", "assembly": "<free_tree>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x4c(%rax),%eax\ntest   %eax,%eax\njne    2f23 <free_tree+0x29>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   3249 <libmin_free>\njmp    2f7f <free_tree+0x85>\nmov    -0x28(%rbp),%rax\nmov    0x50(%rax),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    2f73 <free_tree+0x79>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   2efa <free_tree>\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   3249 <libmin_free>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x4c(%rax),%eax\ncmp    %eax,-0x1c(%rbp)\njl     2f38 <free_tree+0x3e>\nnop\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "generate_node_children", "content": "// find and link node children for a given tree/subtree root \nvoid generate_node_children(tree_node_t* node, int depth) {\n\t// iterate through board to find checkers belonging to the player \n\t\t// note: done in row-major order\n\tint generated_children = 0;\n\tfor (int j=0; j<BOARD_SIZE;j++) {\n\t\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\t\tchar checker = (node->board_state)[i][j];\n\t\t\tif (movable_checker(node->black_action, checker)) {\n\t\t\t\t// if a checker belonging to the colour with action is found\n\t\t\t\t\t// generate all valid moves and create a tree node for each\n\t\t\t\tstatic valid_moves_t valid_moves; \n\t\t\t\tchar col = col_to_char(i+1);\n\t\t\t\tchar row = row_to_char(j+1);\n\t\t\t\tint num_possibles = all_possible_moves((node->board_state), \n\t\t\t\t\tcol, row, valid_moves, (node->black_action));\n\t\t\t\tfor (int k=0; k<num_possibles; k++) {\n\t\t\t\t\t// define the source cell and target cell\n\t\t\t\t\tchar col1 = col;\n\t\t\t\t\tchar row1 = row;\n\t\t\t\t\tchar col2 = valid_moves[k][0];\n\t\t\t\t\tchar row2 = valid_moves[k][1];\n\t\t\t\t\t\n\t\t\t\t\tlink_new_node(node, col1, row1, col2, row2, depth);\n\t\t\t\t\tgenerated_children += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnode->children_count = generated_children;\n\t\t// update children count; useful for accessing tree later\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "generate_node_children", "address": "0x29ff", "label": "generate_node_children", "content": "void __cdecl generate_node_children(tree_node_t *node, int depth)\n{\n  char col; // [rsp+16h] [rbp-1Ah]\n  char row; // [rsp+17h] [rbp-19h]\n  int generated_children; // [rsp+1Ch] [rbp-14h]\n  int j; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  int k; // [rsp+28h] [rbp-8h]\n  int num_possibles; // [rsp+2Ch] [rbp-4h]\n\n  generated_children = 0;\n  for ( j = 0; j <= 7; ++j )\n  {\n    for ( i = 0; i <= 7; ++i )\n    {\n      if ( movable_checker(node->black_action, node->board_state[i][j]) )\n      {\n        col = col_to_char(i + 1);\n        row = row_to_char(j + 1);\n        num_possibles = all_possible_moves(node->board_state, col, row, (square_t *)valid_moves_0_0, node->black_action);\n        for ( k = 0; k < num_possibles; ++k )\n        {\n          link_new_node(node, col, row, valid_moves_0_0[2 * k], valid_moves_0_0[2 * k + 1], depth);\n          ++generated_children;\n        }\n      }\n    }\n  }\n  node->children_count = generated_children;\n}\n"}, "pseudo_normalize": "void generate_node_children(tree_node_t *node, int depth) {\n  char col;\n  char row;\n  int generated_children;\n  int j;\n  int i;\n  int k;\n  int num_possibles;\n  generated_children = 0;\n  for (j = 0; j <= 7; ++j) {\n    for (i = 0; i <= 7; ++i) {\n      if (movable_checker(node->black_action, node->board_state[i][j])) {\n        col = col_to_char(i + 1);\n        row = row_to_char(j + 1);\n        num_possibles =\n            all_possible_moves(node->board_state, col, row,\n                               (square_t *)valid_moves_0_0, node->black_action);\n        for (k = 0; k < num_possibles; ++k) {\n          link_new_node(node, col, row, valid_moves_0_0[2 * k],\n                        valid_moves_0_0[2 * k + 1], depth);\n          ++generated_children;\n        }\n      }\n    }\n  }\n  node->children_count = generated_children;\n}", "binary": "checkers/checkers.host.O0", "assembly": "<generate_node_children>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    2b48 <generate_node_children+0x149>\nmovl   $0x0,-0xc(%rbp)\njmp    2b3a <generate_node_children+0x13b>\nmov    -0x28(%rbp),%rcx\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nadd    $0x8,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1b(%rbp)\nmovsbl -0x1b(%rbp),%edx\nmov    -0x28(%rbp),%rax\nmov    0x48(%rax),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   2b5f <movable_checker>\ntest   %eax,%eax\nje     2b36 <generate_node_children+0x137>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%edi\ncall   1998 <col_to_char>\nmov    %al,-0x1a(%rbp)\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%edi\ncall   19ab <row_to_char>\nmov    %al,-0x19(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x48(%rax),%esi\nmovsbl -0x19(%rbp),%edx\nmovsbl -0x1a(%rbp),%eax\nmov    -0x28(%rbp),%rcx\nlea    0x8(%rcx),%rdi\nmov    %esi,%r8d\nlea    0x78df(%rip),%rcx\nmov    %eax,%esi\ncall   1e82 <all_possible_moves>\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    2b2e <generate_node_children+0x12f>\nmovzbl -0x1a(%rbp),%eax\nmov    %al,-0x18(%rbp)\nmovzbl -0x19(%rbp),%eax\nmov    %al,-0x17(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x78ae(%rip),%rax\nmovzbl (%rdx,%rax,1),%eax\nmov    %al,-0x16(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x7898(%rip),%rax\nmovzbl (%rdx,%rax,1),%eax\nmov    %al,-0x15(%rbp)\nmovsbl -0x15(%rbp),%edi\nmovsbl -0x16(%rbp),%ecx\nmovsbl -0x17(%rbp),%edx\nmovsbl -0x18(%rbp),%esi\nmov    -0x2c(%rbp),%r8d\nmov    -0x28(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   2ba8 <link_new_node>\naddl   $0x1,-0x14(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     2ac4 <generate_node_children+0xc5>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njle    2a31 <generate_node_children+0x32>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x7,-0x10(%rbp)\njle    2a25 <generate_node_children+0x26>\nmov    -0x28(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,0x4c(%rax)\nnop\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "generate_tree_depth_3", "content": "// generate a tree of depth 3 containing the tree_node's \nvoid generate_tree_depth_3(tree_node_t* level_0_node) {\n\t// generate the first generation children\n\tgenerate_node_children(level_0_node, 1);\n\t\n\t// generate second generation children for each first generation child\n\tlinked_list_member_t* list_member_1 = (level_0_node->children_list).first;\n\ttree_node_t* level_1_node;\n\tfor (int i=0; i<(level_0_node->children_count); i++) {\n\t\tlevel_1_node = (tree_node_t*)(list_member_1->child_node);\n\t\tgenerate_node_children(level_1_node, 2);\n\t\t\n\t\t// generate third generation children for each second generation child\n\t\tlinked_list_member_t* list_member_2 \n\t\t\t= (level_1_node->children_list).first;\n\t\ttree_node_t* level_2_node;\n\t\tfor (int j=0; j<(level_1_node->children_count); j++) {\n\t\t\tlevel_2_node = (tree_node_t*)(list_member_2->child_node);\n\t\t\tgenerate_node_children(level_2_node, 3);\n\t\t\tlist_member_2 = list_member_2->next;\n\t\t}\n\t\t\n\t\tlist_member_1 = list_member_1->next;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "generate_tree_depth_3", "address": "0x2d4d", "label": "generate_tree_depth_3", "content": "void __cdecl generate_tree_depth_3(tree_node_t *level_0_node)\n{\n  int i; // [rsp+18h] [rbp-28h]\n  int j; // [rsp+1Ch] [rbp-24h]\n  linked_list_member_t *list_member_1; // [rsp+20h] [rbp-20h]\n  linked_list_member_t *list_member_2; // [rsp+28h] [rbp-18h]\n  tree_node_t *level_1_node; // [rsp+30h] [rbp-10h]\n\n  generate_node_children(level_0_node, 1);\n  list_member_1 = level_0_node->children_list.first;\n  for ( i = 0; i < level_0_node->children_count; ++i )\n  {\n    level_1_node = (tree_node_t *)list_member_1->child_node;\n    generate_node_children((tree_node_t *)list_member_1->child_node, 2);\n    list_member_2 = level_1_node->children_list.first;\n    for ( j = 0; j < level_1_node->children_count; ++j )\n    {\n      generate_node_children((tree_node_t *)list_member_2->child_node, 3);\n      list_member_2 = list_member_2->next;\n    }\n    list_member_1 = list_member_1->next;\n  }\n}\n"}, "pseudo_normalize": "void generate_tree_depth_3(tree_node_t *level_0_node) {\n  int i;\n  int j;\n  linked_list_member_t *list_member_1;\n  linked_list_member_t *list_member_2;\n  tree_node_t *level_1_node;\n  generate_node_children(level_0_node, 1);\n  list_member_1 = level_0_node->children_list.first;\n  for (i = 0; i < level_0_node->children_count; ++i) {\n    level_1_node = (tree_node_t *)list_member_1->child_node;\n    generate_node_children((tree_node_t *)list_member_1->child_node, 2);\n    list_member_2 = level_1_node->children_list.first;\n    for (j = 0; j < level_1_node->children_count; ++j) {\n      generate_node_children((tree_node_t *)list_member_2->child_node, 3);\n      list_member_2 = list_member_2->next;\n    }\n    list_member_1 = list_member_1->next;\n  }\n}", "binary": "checkers/checkers.host.O0", "assembly": "<generate_tree_depth_3>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   29ff <generate_node_children>\nmov    -0x38(%rbp),%rax\nmov    0x50(%rax),%rax\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    2dfc <generate_tree_depth_3+0xaf>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    $0x2,%esi\nmov    %rax,%rdi\ncall   29ff <generate_node_children>\nmov    -0x10(%rbp),%rax\nmov    0x50(%rax),%rax\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    2de0 <generate_tree_depth_3+0x93>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   29ff <generate_node_children>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x18(%rbp)\naddl   $0x1,-0x24(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x4c(%rax),%eax\ncmp    %eax,-0x24(%rbp)\njl     2db4 <generate_tree_depth_3+0x67>\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x20(%rbp)\naddl   $0x1,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x4c(%rax),%eax\ncmp    %eax,-0x28(%rbp)\njl     2d83 <generate_tree_depth_3+0x36>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "link_new_node", "content": "void link_new_node(tree_node_t* parent_node,\n\tchar col1, char row1, char col2, char row2, int depth) {\n\t// create a new tree node ready to link\n\t\t// first copy over new board after move is made\n\ttree_node_t* new_node = (tree_node_t*)libmin_malloc(sizeof(tree_node_t));\n\tnew_node->depth = depth;\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\t(new_node->board_state)[i][j] = (parent_node->board_state)[i][j];\n\t\t}\n\t}\n\tchange_board((board_t*)(&(new_node->board_state)), col1, row1, col2, row2);\n\t\n\tnew_node->move_info[0][0] = col1;\n\tnew_node->move_info[0][1] = row1;\n\tnew_node->move_info[1][0] = col2;\n\tnew_node->move_info[1][1] = row2;\n\tnew_node->black_action = !(parent_node->black_action);\n\t\t// change of turn\n\tnew_node->children_list = initial_children;\n\tnew_node->children_count = 0;\n\t\n\t// create a list member to contain the address of the new node, \n\t\t// which is dynamically linked to children_list of the parent node\n\tlinked_list_member_t* new_list_member\n\t\t= (linked_list_member_t*)libmin_malloc(sizeof(linked_list_member_t));\n\tnew_list_member->child_node = (void*)new_node; // raw address of new node\n\tnew_list_member->next = NULL;\n\t\n\t// link the new list member to the parent node children_list\n\tif ((parent_node->children_list).first == NULL) {\n\t\t(parent_node->children_list).first = new_list_member;\n\t}\n\t\n\tif ((parent_node->children_list).last == NULL) {\n\t\t(parent_node->children_list).last = new_list_member;\n\t}\n\telse {\n\t\t((parent_node->children_list).last)->next = new_list_member;\n\t\t(parent_node->children_list).last = new_list_member;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "link_new_node", "address": "0x2ba8", "label": "link_new_node", "content": "void __cdecl link_new_node(tree_node_t *parent_node, char col1, char row1, char col2, char row2, int depth)\n{\n  linked_list_member_t *last; // rdx\n  int i; // [rsp+28h] [rbp-18h]\n  int j; // [rsp+2Ch] [rbp-14h]\n  tree_node_t *new_node; // [rsp+30h] [rbp-10h]\n  linked_list_member_t *new_list_member; // [rsp+38h] [rbp-8h]\n\n  new_node = (tree_node_t *)libmin_malloc(0x60uLL);\n  new_node->depth = depth;\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n      new_node->board_state[i][j] = parent_node->board_state[i][j];\n  }\n  change_board((board_t *)new_node->board_state, col1, row1, col2, row2);\n  new_node->move_info[0][0] = col1;\n  new_node->move_info[0][1] = row1;\n  new_node->move_info[1][0] = col2;\n  new_node->move_info[1][1] = row2;\n  new_node->black_action = parent_node->black_action == 0;\n  last = initial_children.last;\n  new_node->children_list.first = initial_children.first;\n  new_node->children_list.last = last;\n  new_node->children_count = 0;\n  new_list_member = (linked_list_member_t *)libmin_malloc(0x10uLL);\n  new_list_member->child_node = new_node;\n  new_list_member->next = 0LL;\n  if ( !parent_node->children_list.first )\n    parent_node->children_list.first = new_list_member;\n  if ( parent_node->children_list.last )\n    parent_node->children_list.last->next = new_list_member;\n  parent_node->children_list.last = new_list_member;\n}\n"}, "pseudo_normalize": "void link_new_node(tree_node_t *parent_node, char col1, char row1, char col2,\n                   char row2, int depth) {\n  linked_list_member_t *last;\n  int i;\n  int j;\n  tree_node_t *new_node;\n  linked_list_member_t *new_list_member;\n  new_node = (tree_node_t *)libmin_malloc(96uLL);\n  new_node->depth = depth;\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j)\n      new_node->board_state[i][j] = parent_node->board_state[i][j];\n  }\n  change_board((board_t *)new_node->board_state, col1, row1, col2, row2);\n  new_node->move_info[0][0] = col1;\n  new_node->move_info[0][1] = row1;\n  new_node->move_info[1][0] = col2;\n  new_node->move_info[1][1] = row2;\n  new_node->black_action = parent_node->black_action == 0;\n  last = initial_children.last;\n  new_node->children_list.first = initial_children.first;\n  new_node->children_list.last = last;\n  new_node->children_count = 0;\n  new_list_member = (linked_list_member_t *)libmin_malloc(16uLL);\n  new_list_member->child_node = new_node;\n  new_list_member->next = 0LL;\n  if (!parent_node->children_list.first)\n    parent_node->children_list.first = new_list_member;\n  if (parent_node->children_list.last)\n    parent_node->children_list.last->next = new_list_member;\n  parent_node->children_list.last = new_list_member;\n}", "binary": "checkers/checkers.host.O0", "assembly": "<link_new_node>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %ecx,%eax\nmov    %r8d,%edi\nmov    %r9d,-0x3c(%rbp)\nmov    %esi,%ecx\nmov    %cl,-0x2c(%rbp)\nmov    %dl,-0x30(%rbp)\nmov    %al,-0x34(%rbp)\nmov    %edi,%eax\nmov    %al,-0x38(%rbp)\nmov    $0x60,%edi\ncall   315e <libmin_malloc>\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    -0x3c(%rbp),%edx\nmov    %edx,(%rax)\nmovl   $0x0,-0x18(%rbp)\njmp    2c48 <link_new_node+0xa0>\nmovl   $0x0,-0x14(%rbp)\njmp    2c3e <link_new_node+0x96>\nmov    -0x28(%rbp),%rcx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nadd    $0x8,%rax\nmovzbl (%rax),%eax\nmov    -0x10(%rbp),%rsi\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x18(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x3,%rdx\nadd    %rsi,%rdx\nadd    %rcx,%rdx\nadd    $0x8,%rdx\nmov    %al,(%rdx)\naddl   $0x1,-0x14(%rbp)\ncmpl   $0x7,-0x14(%rbp)\njle    2bfa <link_new_node+0x52>\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x7,-0x18(%rbp)\njle    2bf1 <link_new_node+0x49>\nmovsbl -0x38(%rbp),%r8d\nmovsbl -0x34(%rbp),%ecx\nmovsbl -0x30(%rbp),%edx\nmovsbl -0x2c(%rbp),%eax\nmov    -0x10(%rbp),%rsi\nlea    0x8(%rsi),%rdi\nmov    %eax,%esi\ncall   1cb6 <change_board>\nmov    -0x10(%rbp),%rax\nmovzbl -0x2c(%rbp),%edx\nmov    %dl,0x4(%rax)\nmov    -0x10(%rbp),%rax\nmovzbl -0x30(%rbp),%edx\nmov    %dl,0x5(%rax)\nmov    -0x10(%rbp),%rax\nmovzbl -0x34(%rbp),%edx\nmov    %dl,0x6(%rax)\nmov    -0x10(%rbp),%rax\nmovzbl -0x38(%rbp),%edx\nmov    %dl,0x7(%rax)\nmov    -0x28(%rbp),%rax\nmov    0x48(%rax),%eax\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,0x48(%rax)\nmov    -0x10(%rbp),%rcx\nmov    0x76c5(%rip),%rax\nmov    0x76c6(%rip),%rdx\nmov    %rax,0x50(%rcx)\nmov    %rdx,0x58(%rcx)\nmov    -0x10(%rbp),%rax\nmovl   $0x0,0x4c(%rax)\nmov    $0x10,%edi\ncall   315e <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmov    -0x28(%rbp),%rax\nmov    0x50(%rax),%rax\ntest   %rax,%rax\njne    2d13 <link_new_node+0x16b>\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x50(%rax)\nmov    -0x28(%rbp),%rax\nmov    0x58(%rax),%rax\ntest   %rax,%rax\njne    2d2e <link_new_node+0x186>\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x58(%rax)\njmp    2d4a <link_new_node+0x1a2>\nmov    -0x28(%rbp),%rax\nmov    0x58(%rax),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x58(%rax)\nnop\nleave\nret\n"}
{"source": {"path": "checkers/checkers.c", "function_name": "main", "content": "int\nmain(int argc, char *argv[])\n{\n  libmin_mopen(infile, \"r\");\n\n  board_t* board = (board_t*)libmin_malloc(sizeof(board_t)); // main board pointer\n\n  fill_print_initial(board);\n  print_board(board);\n    \n  int black_action = 1, action = 1, error; //, board_cost;\n  char col1, row1, col2, row2; \n\t// col1/row1 is source cell,  col2/row2 is target cell\n\t// deliberately kept separate, square_t type not used\n\t\n\t// scan input moves\n\tchar buf[64];\n\tlibmin_mgets(buf, 64, infile);\n\twhile (libmin_sscanf(buf, \"%c%c-%c%c\\n\", &col1, &row1, &col2, &row2)==4) {\n\t\t// check errors 1-5, terminate function if any found\n\t\terror = check_move_error_1_to_5(*board, col1, row1, col2, row2, \n\t\t\tblack_action);\n\t\tif (error) {\n\t\t\tprint_error_message(error);\n\t\t\tlibmin_fail(error);\n\t\t}\n\t\t// check error 6\n\t\t\t// all the possible moves of the source cell are generated\n\t\t\t// and the target cell is checked against those\n\t\tstatic valid_moves_t valid_moves;\n\t\tint num_possibles = all_possible_moves(*board, col1, row1, valid_moves, \n\t\t\tblack_action);\n\t\tint illegal = 1;\n\t\tfor (int i=0;i<num_possibles;i++) {\n\t\t\tif ((valid_moves[i][0] == col2) && (valid_moves[i][1] == row2)) {\n\t\t\t\tillegal = 0;\n\t\t\t}\n\t\t}\n\t\t// if target_cell input is not in all legal moves, it must be illegal\n\t\t\t// return main function with error exit code 6\n\t\tif (illegal) {\n\t\t\tprint_error_message(6);\n\t\t\tlibmin_fail(6);\n\t\t}\n\t\t\n\t\tchange_board(board, col1, row1, col2, row2);\n\t\t\n\t\tprint_move_information(0, black_action, *board, col1, row1, col2, row2, \n\t\t\taction);\n\t\t\n\t\tprint_board(board);\n\t\t\n\t\t// change the action to opposite colour, iterate the move counts\n\t\tblack_action = !black_action;\n\t\taction += 1;\n\n    // get the next move\n    libmin_mgets(buf, 64, infile);\n\t}\n\t\n\tchar next_action = col1;\n\t\t// on last scanf call, col1 will pickup any trailing P or A instruction\n\t\t\t// naming isn't great, hence a reassignment to better variable name\n\t\n\t// stages 1 and 2\n\tint repititions=0; \n\tif (next_action == 'A') { // stage 1\n\t\trepititions = 1;\n\t}\n\tif (next_action == 'P') { // stage 2\n\t\trepititions = 100;\n\t}\n\t\t\t\n\tfor (int i=0; i<repititions; i++) {\n\t\t// stage 1\n\t\t\t// create the level 0 node first, and fill with relevent info.\n\t\ttree_node_t* level_0_node = (tree_node_t*)libmin_malloc(sizeof(tree_node_t));\n\t\tlevel_0_node->depth = 0;\n\t\tfor (int i=0; i<BOARD_SIZE;i++) {\n\t\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\t\t(level_0_node->board_state)[i][j] = (*board)[i][j];\n\t\t\t}\n\t\t}\n\t\tlevel_0_node->black_action = black_action;\n\t\tlevel_0_node->children_count = 0;\n\t\tlevel_0_node->children_list = initial_children;\n\t\t\n\t\tgenerate_tree_depth_3(level_0_node);\n\t\t\n\t\t// check if there isn't any possible moves, indicating game over\n\t\tif (level_0_node->children_count == 0) {\n\t\t\tif (black_action) {\n\t\t\t\tlibmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlibmin_printf(\"%s WIN!\\n\", BLACK);\n        libmin_success();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// now we journey into the tree, and implement the minimax decision rule\n\t\tint best_score = move_score_forced(level_0_node); \n\t\t\t// this is the best possible score we can have\n\t\t\n\t\t// find the choice node which yields this score\n\t\tlinked_list_member_t* list_member = (level_0_node->children_list).first;\n\t\ttree_node_t* choice_node = NULL;\n\t\tfor (int i=0; i<(level_0_node->children_count); i++) {\n\t\t\tchoice_node = (tree_node_t*)(list_member->child_node);\n\t\t\tif (move_score_forced(choice_node) == best_score) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_member = list_member->next;\n\t\t}\n\t\t\n\t\tchange_board(board, \n\t\t\t(choice_node->move_info)[0][0], \n\t\t\t(choice_node->move_info)[0][1],\n\t\t\t(choice_node->move_info)[1][0],\n\t\t\t(choice_node->move_info)[1][1]);\n\t\t\n\t\tprint_move_information(1, black_action, *board, \n\t\t\t(choice_node->move_info)[0][0], \n\t\t\t(choice_node->move_info)[0][1], \n\t\t\t(choice_node->move_info)[1][0], \n\t\t\t(choice_node->move_info)[1][1], \n\t\t\taction);\n\t\t\n\t\tprint_board(board);\n\t\t\n\t\tblack_action = !black_action;\n\t\taction += 1;\n\t\t\n\t\tfree_tree(level_0_node); // free space occupied by the tree\n\t\t\t// no need for it anymore\n\t}\n\t\n\tlibmin_free(board);\n  libmin_success(); // exit program with the success code\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  tree_node_t *v3; // rcx\n  linked_list_member_t *last; // rdx\n  int v5; // eax\n  char col1; // [rsp+1Bh] [rbp-A5h] BYREF\n  char row1; // [rsp+1Ch] [rbp-A4h] BYREF\n  char col2; // [rsp+1Dh] [rbp-A3h] BYREF\n  char row2; // [rsp+1Eh] [rbp-A2h] BYREF\n  char next_action; // [rsp+1Fh] [rbp-A1h]\n  int black_action; // [rsp+20h] [rbp-A0h]\n  int action; // [rsp+24h] [rbp-9Ch]\n  int illegal; // [rsp+28h] [rbp-98h]\n  int i; // [rsp+2Ch] [rbp-94h]\n  int repititions; // [rsp+30h] [rbp-90h]\n  int i_0; // [rsp+34h] [rbp-8Ch]\n  int i_1; // [rsp+38h] [rbp-88h]\n  int j; // [rsp+3Ch] [rbp-84h]\n  int i_2; // [rsp+40h] [rbp-80h]\n  int best_score; // [rsp+44h] [rbp-7Ch]\n  int error; // [rsp+48h] [rbp-78h]\n  int num_possibles; // [rsp+4Ch] [rbp-74h]\n  linked_list_member_t *list_member; // [rsp+50h] [rbp-70h]\n  tree_node_t *choice_node; // [rsp+58h] [rbp-68h]\n  board_t *board; // [rsp+60h] [rbp-60h]\n  tree_node_t *level_0_node; // [rsp+68h] [rbp-58h]\n  char buf[72]; // [rsp+70h] [rbp-50h] BYREF\n  unsigned __int64 v28; // [rsp+B8h] [rbp-8h]\n\n  v28 = __readfsqword(0x28u);\n  libmin_mopen(infile, \"r\");\n  board = (board_t *)libmin_malloc(0x40uLL);\n  fill_print_initial(board);\n  print_board(board);\n  black_action = 1;\n  action = 1;\n  libmin_mgets(buf, 0x40uLL, infile);\n  while ( libmin_sscanf(buf, \"%c%c-%c%c\\n\", &col1, &row1, &col2, &row2) == 4 )\n  {\n    error = check_move_error_1_to_5((unsigned __int8 (*)[8])board, col1, row1, col2, row2, black_action);\n    if ( error )\n    {\n      print_error_message(error);\n      libmin_fail(error);\n    }\n    num_possibles = all_possible_moves(\n                      (unsigned __int8 (*)[8])board,\n                      col1,\n                      row1,\n                      (square_t *)valid_moves_0,\n                      black_action);\n    illegal = 1;\n    for ( i = 0; i < num_possibles; ++i )\n    {\n      if ( valid_moves_0[2 * i] == col2 && valid_moves_0[2 * i + 1] == row2 )\n        illegal = 0;\n    }\n    if ( illegal )\n    {\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board(board, col1, row1, col2, row2);\n    print_move_information(0, black_action, (unsigned __int8 (*)[8])board, col1, row1, col2, row2, action);\n    print_board(board);\n    black_action = black_action == 0;\n    ++action;\n    libmin_mgets(buf, 0x40uLL, infile);\n  }\n  next_action = col1;\n  repititions = col1 == 65;\n  if ( col1 == 80 )\n    repititions = 100;\n  for ( i_0 = 0; i_0 < repititions; ++i_0 )\n  {\n    level_0_node = (tree_node_t *)libmin_malloc(0x60uLL);\n    level_0_node->depth = 0;\n    for ( i_1 = 0; i_1 <= 7; ++i_1 )\n    {\n      for ( j = 0; j <= 7; ++j )\n        level_0_node->board_state[i_1][j] = (*board)[i_1][j];\n    }\n    level_0_node->black_action = black_action;\n    level_0_node->children_count = 0;\n    v3 = level_0_node;\n    last = initial_children.last;\n    level_0_node->children_list.first = initial_children.first;\n    v3->children_list.last = last;\n    generate_tree_depth_3(level_0_node);\n    if ( !level_0_node->children_count )\n    {\n      if ( black_action )\n      {\n        libmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", BLACK);\n      libmin_success();\n    }\n    best_score = move_score_forced(level_0_node);\n    list_member = level_0_node->children_list.first;\n    choice_node = 0LL;\n    for ( i_2 = 0; i_2 < level_0_node->children_count; ++i_2 )\n    {\n      choice_node = (tree_node_t *)list_member->child_node;\n      v5 = move_score_forced(choice_node);\n      if ( best_score == v5 )\n        break;\n      list_member = list_member->next;\n    }\n    change_board(\n      board,\n      choice_node->move_info[0][0],\n      choice_node->move_info[0][1],\n      choice_node->move_info[1][0],\n      choice_node->move_info[1][1]);\n    print_move_information(\n      1,\n      black_action,\n      (unsigned __int8 (*)[8])board,\n      choice_node->move_info[0][0],\n      choice_node->move_info[0][1],\n      choice_node->move_info[1][0],\n      choice_node->move_info[1][1],\n      action);\n    print_board(board);\n    black_action = black_action == 0;\n    ++action;\n    free_tree(level_0_node);\n  }\n  libmin_free(board);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  tree_node_t *v3;\n  linked_list_member_t *last;\n  int v5;\n  char col1;\n  char row1;\n  char col2;\n  char row2;\n  char next_action;\n  int black_action;\n  int action;\n  int illegal;\n  int i;\n  int repititions;\n  int i_0;\n  int i_1;\n  int j;\n  int i_2;\n  int best_score;\n  int error;\n  int num_possibles;\n  linked_list_member_t *list_member;\n  tree_node_t *choice_node;\n  board_t *board;\n  tree_node_t *level_0_node;\n  char buf[72];\n  unsigned long long v28;\n  v28 = __readfsqword(40u);\n  libmin_mopen(infile, \"r\");\n  board = (board_t *)libmin_malloc(64uLL);\n  fill_print_initial(board);\n  print_board(board);\n  black_action = 1;\n  action = 1;\n  libmin_mgets(buf, 64uLL, infile);\n  while (libmin_sscanf(buf, \"%c%c-%c%c\\n\", &col1, &row1, &col2, &row2) == 4) {\n    error = check_move_error_1_to_5((unsigned char(*)[8])board, col1, row1,\n                                    col2, row2, black_action);\n    if (error) {\n      print_error_message(error);\n      libmin_fail(error);\n    }\n    num_possibles = all_possible_moves((unsigned char(*)[8])board, col1, row1,\n                                       (square_t *)valid_moves_0, black_action);\n    illegal = 1;\n    for (i = 0; i < num_possibles; ++i) {\n      if (valid_moves_0[2 * i] == col2 && valid_moves_0[2 * i + 1] == row2)\n        illegal = 0;\n    }\n    if (illegal) {\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board(board, col1, row1, col2, row2);\n    print_move_information(0, black_action, (unsigned char(*)[8])board, col1,\n                           row1, col2, row2, action);\n    print_board(board);\n    black_action = black_action == 0;\n    ++action;\n    libmin_mgets(buf, 64uLL, infile);\n  }\n  next_action = col1;\n  repititions = col1 == 65;\n  if (col1 == 80) repititions = 100;\n  for (i_0 = 0; i_0 < repititions; ++i_0) {\n    level_0_node = (tree_node_t *)libmin_malloc(96uLL);\n    level_0_node->depth = 0;\n    for (i_1 = 0; i_1 <= 7; ++i_1) {\n      for (j = 0; j <= 7; ++j)\n        level_0_node->board_state[i_1][j] = (*board)[i_1][j];\n    }\n    level_0_node->black_action = black_action;\n    level_0_node->children_count = 0;\n    v3 = level_0_node;\n    last = initial_children.last;\n    level_0_node->children_list.first = initial_children.first;\n    v3->children_list.last = last;\n    generate_tree_depth_3(level_0_node);\n    if (!level_0_node->children_count) {\n      if (black_action) {\n        libmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", BLACK);\n      libmin_success();\n    }\n    best_score = move_score_forced(level_0_node);\n    list_member = level_0_node->children_list.first;\n    choice_node = 0LL;\n    for (i_2 = 0; i_2 < level_0_node->children_count; ++i_2) {\n      choice_node = (tree_node_t *)list_member->child_node;\n      v5 = move_score_forced(choice_node);\n      if (best_score == v5) break;\n      list_member = list_member->next;\n    }\n    change_board(board, choice_node->move_info[0][0],\n                 choice_node->move_info[0][1], choice_node->move_info[1][0],\n                 choice_node->move_info[1][1]);\n    print_move_information(\n        1, black_action, (unsigned char(*)[8])board,\n        choice_node->move_info[0][0], choice_node->move_info[0][1],\n        choice_node->move_info[1][0], choice_node->move_info[1][1], action);\n    print_board(board);\n    black_action = black_action == 0;\n    ++action;\n    free_tree(level_0_node);\n  }\n  libmin_free(board);\n  libmin_success();\n}", "binary": "checkers/checkers.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xc0,%rsp\nmov    %edi,-0xb4(%rbp)\nmov    %rsi,-0xc0(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    0x8e25(%rip),%rax\nlea    0x5e46(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   37ed <libmin_mopen>\nmov    $0x40,%edi\ncall   315e <libmin_malloc>\nmov    %rax,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   1793 <fill_print_initial>\nmov    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   19be <print_board>\nmovl   $0x1,-0xa0(%rbp)\nmovl   $0x1,-0x9c(%rbp)\nmov    0x8dd2(%rip),%rdx\nlea    -0x50(%rbp),%rax\nmov    $0x40,%esi\nmov    %rax,%rdi\ncall   35c6 <libmin_mgets>\njmp    1469 <main+0x280>\nmovzbl -0xa2(%rbp),%eax\nmovsbl %al,%edi\nmovzbl -0xa3(%rbp),%eax\nmovsbl %al,%ecx\nmovzbl -0xa4(%rbp),%eax\nmovsbl %al,%edx\nmovzbl -0xa5(%rbp),%eax\nmovsbl %al,%esi\nmov    -0xa0(%rbp),%r8d\nmov    -0x60(%rbp),%rax\nmov    %r8d,%r9d\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1ace <check_move_error_1_to_5>\nmov    %eax,-0x78(%rbp)\ncmpl   $0x0,-0x78(%rbp)\nje     12e2 <main+0xf9>\nmov    -0x78(%rbp),%eax\nmov    %eax,%edi\ncall   2738 <print_error_message>\nmov    -0x78(%rbp),%eax\nmov    %eax,%edi\ncall   30db <libmin_fail>\nmovzbl -0xa4(%rbp),%eax\nmovsbl %al,%edx\nmovzbl -0xa5(%rbp),%eax\nmovsbl %al,%esi\nmov    -0xa0(%rbp),%ecx\nmov    -0x60(%rbp),%rax\nmov    %ecx,%r8d\nlea    0x9066(%rip),%rcx\nmov    %rax,%rdi\ncall   1e82 <all_possible_moves>\nmov    %eax,-0x74(%rbp)\nmovl   $0x1,-0x98(%rbp)\nmovl   $0x0,-0x94(%rbp)\njmp    1380 <main+0x197>\nmov    -0x94(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x9032(%rip),%rax\nmovzbl (%rdx,%rax,1),%edx\nmovzbl -0xa3(%rbp),%eax\ncmp    %al,%dl\njne    1379 <main+0x190>\nmov    -0x94(%rbp),%eax\ncltq\nlea    (%rax,%rax,1),%rdx\nlea    0x9011(%rip),%rax\nmovzbl (%rdx,%rax,1),%edx\nmovzbl -0xa2(%rbp),%eax\ncmp    %al,%dl\njne    1379 <main+0x190>\nmovl   $0x0,-0x98(%rbp)\naddl   $0x1,-0x94(%rbp)\nmov    -0x94(%rbp),%eax\ncmp    -0x74(%rbp),%eax\njl     132b <main+0x142>\ncmpl   $0x0,-0x98(%rbp)\nje     13a8 <main+0x1bf>\nmov    $0x6,%edi\ncall   2738 <print_error_message>\nmov    $0x6,%edi\ncall   30db <libmin_fail>\nmovzbl -0xa2(%rbp),%eax\nmovsbl %al,%edi\nmovzbl -0xa3(%rbp),%eax\nmovsbl %al,%ecx\nmovzbl -0xa4(%rbp),%eax\nmovsbl %al,%edx\nmovzbl -0xa5(%rbp),%eax\nmovsbl %al,%esi\nmov    -0x60(%rbp),%rax\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1cb6 <change_board>\nmovzbl -0xa2(%rbp),%eax\nmovsbl %al,%esi\nmovzbl -0xa3(%rbp),%eax\nmovsbl %al,%r9d\nmovzbl -0xa4(%rbp),%eax\nmovsbl %al,%r8d\nmovzbl -0xa5(%rbp),%eax\nmovsbl %al,%ecx\nmov    -0x60(%rbp),%rdx\nmov    -0xa0(%rbp),%eax\nmov    -0x9c(%rbp),%edi\npush   %rdi\npush   %rsi\nmov    %eax,%esi\nmov    $0x0,%edi\ncall   2903 <print_move_information>\nadd    $0x10,%rsp\nmov    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   19be <print_board>\ncmpl   $0x0,-0xa0(%rbp)\nsete   %al\nmovzbl %al,%eax\nmov    %eax,-0xa0(%rbp)\naddl   $0x1,-0x9c(%rbp)\nmov    0x8be8(%rip),%rdx\nlea    -0x50(%rbp),%rax\nmov    $0x40,%esi\nmov    %rax,%rdi\ncall   35c6 <libmin_mgets>\nlea    -0xa2(%rbp),%rdi\nlea    -0xa3(%rbp),%rsi\nlea    -0xa4(%rbp),%rcx\nlea    -0xa5(%rbp),%rdx\nlea    -0x50(%rbp),%rax\nmov    %rdi,%r9\nmov    %rsi,%r8\nlea    0x5bd4(%rip),%rsi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5a70 <libmin_sscanf>\ncmp    $0x4,%eax\nje     1284 <main+0x9b>\nmovzbl -0xa5(%rbp),%eax\nmov    %al,-0xa1(%rbp)\nmovl   $0x0,-0x90(%rbp)\ncmpb   $0x41,-0xa1(%rbp)\njne    14d6 <main+0x2ed>\nmovl   $0x1,-0x90(%rbp)\ncmpb   $0x50,-0xa1(%rbp)\njne    14e9 <main+0x300>\nmovl   $0x64,-0x90(%rbp)\nmovl   $0x0,-0x8c(%rbp)\njmp    1755 <main+0x56c>\nmov    $0x60,%edi\ncall   315e <libmin_malloc>\nmov    %rax,-0x58(%rbp)\nmov    -0x58(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x88(%rbp)\njmp    1587 <main+0x39e>\nmovl   $0x0,-0x84(%rbp)\njmp    1577 <main+0x38e>\nmov    -0x60(%rbp),%rcx\nmov    -0x84(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x88(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    -0x58(%rbp),%rsi\nmov    -0x84(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0x88(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x3,%rdx\nadd    %rsi,%rdx\nadd    %rcx,%rdx\nadd    $0x8,%rdx\nmov    %al,(%rdx)\naddl   $0x1,-0x84(%rbp)\ncmpl   $0x7,-0x84(%rbp)\njle    1528 <main+0x33f>\naddl   $0x1,-0x88(%rbp)\ncmpl   $0x7,-0x88(%rbp)\njle    151c <main+0x333>\nmov    -0x58(%rbp),%rax\nmov    -0xa0(%rbp),%edx\nmov    %edx,0x48(%rax)\nmov    -0x58(%rbp),%rax\nmovl   $0x0,0x4c(%rax)\nmov    -0x58(%rbp),%rcx\nmov    0x8dcd(%rip),%rax\nmov    0x8dce(%rip),%rdx\nmov    %rax,0x50(%rcx)\nmov    %rdx,0x58(%rcx)\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   2d4d <generate_tree_depth_3>\nmov    -0x58(%rbp),%rax\nmov    0x4c(%rax),%eax\ntest   %eax,%eax\njne    162a <main+0x441>\ncmpl   $0x0,-0xa0(%rbp)\nje     1607 <main+0x41e>\nlea    0x8ab5(%rip),%rax\nmov    %rax,%rsi\nlea    0x5a82(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncall   62f6 <libmin_success>\njmp    162a <main+0x441>\nlea    0x8a8a(%rip),%rax\nmov    %rax,%rsi\nlea    0x5a5d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncall   62f6 <libmin_success>\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   2e10 <move_score_forced>\nmov    %eax,-0x7c(%rbp)\nmov    -0x58(%rbp),%rax\nmov    0x50(%rax),%rax\nmov    %rax,-0x70(%rbp)\nmovq   $0x0,-0x68(%rbp)\nmovl   $0x0,-0x80(%rbp)\njmp    1682 <main+0x499>\nmov    -0x70(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\nmov    %rax,%rdi\ncall   2e10 <move_score_forced>\ncmp    %eax,-0x7c(%rbp)\nje     1690 <main+0x4a7>\nmov    -0x70(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x70(%rbp)\naddl   $0x1,-0x80(%rbp)\nmov    -0x58(%rbp),%rax\nmov    0x4c(%rax),%eax\ncmp    %eax,-0x80(%rbp)\njl     1656 <main+0x46d>\njmp    1691 <main+0x4a8>\nnop\nmov    -0x68(%rbp),%rax\nmovzbl 0x7(%rax),%eax\nmovsbl %al,%edi\nmov    -0x68(%rbp),%rax\nmovzbl 0x6(%rax),%eax\nmovsbl %al,%ecx\nmov    -0x68(%rbp),%rax\nmovzbl 0x5(%rax),%eax\nmovsbl %al,%edx\nmov    -0x68(%rbp),%rax\nmovzbl 0x4(%rax),%eax\nmovsbl %al,%esi\nmov    -0x60(%rbp),%rax\nmov    %edi,%r8d\nmov    %rax,%rdi\ncall   1cb6 <change_board>\nmov    -0x68(%rbp),%rax\nmovzbl 0x7(%rax),%eax\nmovsbl %al,%esi\nmov    -0x68(%rbp),%rax\nmovzbl 0x6(%rax),%eax\nmovsbl %al,%r9d\nmov    -0x68(%rbp),%rax\nmovzbl 0x5(%rax),%eax\nmovsbl %al,%r8d\nmov    -0x68(%rbp),%rax\nmovzbl 0x4(%rax),%eax\nmovsbl %al,%ecx\nmov    -0x60(%rbp),%rdx\nmov    -0xa0(%rbp),%eax\nmov    -0x9c(%rbp),%edi\npush   %rdi\npush   %rsi\nmov    %eax,%esi\nmov    $0x1,%edi\ncall   2903 <print_move_information>\nadd    $0x10,%rsp\nmov    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   19be <print_board>\ncmpl   $0x0,-0xa0(%rbp)\nsete   %al\nmovzbl %al,%eax\nmov    %eax,-0xa0(%rbp)\naddl   $0x1,-0x9c(%rbp)\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   2efa <free_tree>\naddl   $0x1,-0x8c(%rbp)\nmov    -0x8c(%rbp),%eax\ncmp    -0x90(%rbp),%eax\njl     14f8 <main+0x30f>\nmov    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   3249 <libmin_free>\ncall   62f6 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1791 <main+0x5a8>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "min", "content": "// simple function to return the smaller of two integers, \n\t// if it is the same, it returns the number\nint min(int a, int b) {\n\tif (a < b) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn b;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "min", "address": "0x2718", "label": "min", "content": "int __cdecl min(int a, int b)\n{\n  if ( a >= b )\n    return b;\n  else\n    return a;\n}\n"}, "pseudo_normalize": "int min(int a, int b) {\n  if (a >= b)\n    return b;\n  else\n    return a;\n}", "binary": "checkers/checkers.host.O0", "assembly": "<min>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    2733 <min+0x1b>\nmov    -0x4(%rbp),%eax\njmp    2736 <min+0x1e>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "movable_checker", "content": "// check whether a given square contains a movable checker depending on the turn\nint movable_checker(int black_action, char checker) {\n\tif ((black_action) && ((checker == CELL_BPIECE) || \n\t\t\t(checker == CELL_BTOWER))) {\n\t\treturn 1;\n\t}\n\telse if ((!black_action) && ((checker == CELL_WPIECE) || \n\t\t\t(checker == CELL_WTOWER))) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "movable_checker", "address": "0x2b5f", "label": "movable_checker", "content": "int __cdecl movable_checker(int black_action, char checker)\n{\n  if ( black_action && (checker == 98 || checker == 66) )\n    return 1;\n  return !black_action && (checker == 119 || checker == 87);\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O0", "assembly": "<movable_checker>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,%eax\nmov    %al,-0x8(%rbp)\ncmpl   $0x0,-0x4(%rbp)\nje     2b88 <movable_checker+0x29>\ncmpb   $0x62,-0x8(%rbp)\nje     2b81 <movable_checker+0x22>\ncmpb   $0x42,-0x8(%rbp)\njne    2b88 <movable_checker+0x29>\nmov    $0x1,%eax\njmp    2ba6 <movable_checker+0x47>\ncmpl   $0x0,-0x4(%rbp)\njne    2ba1 <movable_checker+0x42>\ncmpb   $0x77,-0x8(%rbp)\nje     2b9a <movable_checker+0x3b>\ncmpb   $0x57,-0x8(%rbp)\njne    2ba1 <movable_checker+0x42>\nmov    $0x1,%eax\njmp    2ba6 <movable_checker+0x47>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "move_score_forced", "content": "// recursively find the forced best score of an option branch\n\t// applies the minimax decision rule and assumes player rationality\n\t// according to this rule\nint move_score_forced(tree_node_t* node) {\n\t// base case, we have reached a leaf\n\tif (node->children_count == 0) {\n\t\t// note: if the leaf is less than depth 3, we return int_min/max\n\t\t\t// as specified in the assignment\n\t\tif (node->depth != 3) {\n\t\t\tif (node->black_action) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint leaf_cost = board_cost(node->board_state);\n\t\treturn leaf_cost;\n\t}\n\t\n\t// recursive case\n\telse {\n\t\tint max_score = INT_MIN, min_score = INT_MAX;\n\t\tlinked_list_member_t* list_member = (node->children_list).first;\n\t\ttree_node_t* child_node;\n\t\t// iterate through children to find scores\n\t\tfor (int i=0; i<(node->children_count); i++) {\n\t\t\tchild_node = (tree_node_t*)(list_member->child_node);\n\t\t\tint child_score = move_score_forced(child_node);\n\t\t\tif (child_score > max_score) {\n\t\t\t\tmax_score = child_score;\n\t\t\t}\n\t\t\tif (child_score < min_score) {\n\t\t\t\tmin_score = child_score;\n\t\t\t}\n\t\t\tlist_member = list_member->next;\n\t\t}\n\t\t\n\t\t// black and white make rational actions!!\n\t\tif (node->black_action) {\n\t\t\treturn max_score;\n\t\t}\n\t\telse {\n\t\t\treturn min_score;\n\t\t}\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "move_score_forced", "address": "0x2e10", "label": "move_score_forced", "content": "int __cdecl move_score_forced(tree_node_t *node)\n{\n  signed int max_score; // [rsp+1Ch] [rbp-24h]\n  int min_score; // [rsp+20h] [rbp-20h]\n  int i; // [rsp+24h] [rbp-1Ch]\n  int child_score; // [rsp+28h] [rbp-18h]\n  linked_list_member_t *list_member; // [rsp+30h] [rbp-10h]\n\n  if ( node->children_count )\n  {\n    max_score = 0x80000000;\n    min_score = 0x7FFFFFFF;\n    list_member = node->children_list.first;\n    for ( i = 0; i < node->children_count; ++i )\n    {\n      child_score = move_score_forced((tree_node_t *)list_member->child_node);\n      if ( child_score > max_score )\n        max_score = child_score;\n      if ( child_score < min_score )\n        min_score = child_score;\n      list_member = list_member->next;\n    }\n    if ( node->black_action )\n      return max_score;\n    else\n      return min_score;\n  }\n  else if ( node->depth == 3 )\n  {\n    return board_cost(node->board_state);\n  }\n  else if ( node->black_action )\n  {\n    return 0x80000000;\n  }\n  else\n  {\n    return 0x7FFFFFFF;\n  }\n}\n"}, "pseudo_normalize": "int move_score_forced(tree_node_t *node) {\n  signed int max_score;\n  int min_score;\n  int i;\n  int child_score;\n  linked_list_member_t *list_member;\n  if (node->children_count) {\n    max_score = 2147483648;\n    min_score = 2147483647;\n    list_member = node->children_list.first;\n    for (i = 0; i < node->children_count; ++i) {\n      child_score = move_score_forced((tree_node_t *)list_member->child_node);\n      if (child_score > max_score) max_score = child_score;\n      if (child_score < min_score) min_score = child_score;\n      list_member = list_member->next;\n    }\n    if (node->black_action)\n      return max_score;\n    else\n      return min_score;\n  } else if (node->depth == 3) {\n    return board_cost(node->board_state);\n  } else if (node->black_action) {\n    return 2147483648;\n  } else {\n    return 2147483647;\n  }\n}", "binary": "checkers/checkers.host.O0", "assembly": "<move_score_forced>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x4c(%rax),%eax\ntest   %eax,%eax\njne    2e70 <move_score_forced+0x60>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\ncmp    $0x3,%eax\nje     2e55 <move_score_forced+0x45>\nmov    -0x38(%rbp),%rax\nmov    0x48(%rax),%eax\ntest   %eax,%eax\nje     2e4b <move_score_forced+0x3b>\nmov    $0x80000000,%eax\njmp    2ef8 <move_score_forced+0xe8>\nmov    $0x7fffffff,%eax\njmp    2ef8 <move_score_forced+0xe8>\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    %rax,%rdi\ncall   27e6 <board_cost>\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\njmp    2ef8 <move_score_forced+0xe8>\nmovl   $0x80000000,-0x24(%rbp)\nmovl   $0x7fffffff,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x50(%rax),%rax\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    2ed9 <move_score_forced+0xc9>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   2e10 <move_score_forced>\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njle    2ebb <move_score_forced+0xab>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njge    2ec9 <move_score_forced+0xb9>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x4c(%rax),%eax\ncmp    %eax,-0x1c(%rbp)\njl     2e93 <move_score_forced+0x83>\nmov    -0x38(%rbp),%rax\nmov    0x48(%rax),%eax\ntest   %eax,%eax\nje     2ef5 <move_score_forced+0xe5>\nmov    -0x24(%rbp),%eax\njmp    2ef8 <move_score_forced+0xe8>\nmov    -0x20(%rbp),%eax\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "outside_of_board", "content": "// check if a col/row input is outside of the board\nint outside_of_board(char col, char row) {\n\tif ((char_to_col(col) < 1) || (char_to_col(col) > BOARD_SIZE) \n\t\t|| (char_to_row(row) < 1) || (char_to_row(row) > BOARD_SIZE)) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "outside_of_board", "address": "0x1c00", "label": "outside_of_board", "content": "int __cdecl outside_of_board(char col, char row)\n{\n  return char_to_col(col) <= 0 || char_to_col(col) > 8 || char_to_row(row) <= 0 || char_to_row(row) > 8;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O0", "assembly": "<outside_of_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x8,%rsp\nmov    %edi,%edx\nmov    %esi,%eax\nmov    %dl,-0x4(%rbp)\nmov    %al,-0x8(%rbp)\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\ntest   %eax,%eax\njle    1c54 <outside_of_board+0x54>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\ncmp    $0x8,%eax\njg     1c54 <outside_of_board+0x54>\nmovsbl -0x8(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\ntest   %eax,%eax\njle    1c54 <outside_of_board+0x54>\nmovsbl -0x8(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\ncmp    $0x8,%eax\njle    1c5b <outside_of_board+0x5b>\nmov    $0x1,%eax\njmp    1c60 <outside_of_board+0x60>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "piece_at_location", "content": "// return piece at a given character col/row input for a board_t input\nchar piece_at_location(board_t board_input, char col, char row) {\n\treturn board_input[char_to_col(col) - 1][char_to_row(row) - 1];\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "piece_at_location", "address": "0x1c62", "label": "piece_at_location", "content": "char __cdecl piece_at_location(unsigned __int8 (*board_input)[8], char col, char row)\n{\n  unsigned __int8 *v3; // rbx\n\n  v3 = &(*board_input)[8 * char_to_col(col) - 8];\n  return v3[char_to_row(row) - 1];\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O0", "assembly": "<piece_at_location>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x10,%rsp\nmov    %rdi,-0x10(%rbp)\nmov    %esi,%ecx\nmov    %edx,%eax\nmov    %ecx,%edx\nmov    %dl,-0x14(%rbp)\nmov    %al,-0x18(%rbp)\nmovsbl -0x14(%rbp),%eax\nmov    %eax,%edi\ncall   1960 <char_to_col>\ncltq\nshl    $0x3,%rax\nlea    -0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmovsbl -0x18(%rbp),%eax\nmov    %eax,%edi\ncall   197c <char_to_row>\nsub    $0x1,%eax\ncltq\nmovzbl (%rbx,%rax,1),%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "print_board", "content": "// print a nice visual representation of the board given a board_t input\nvoid print_board(board_t* board_input) {\n\tlibmin_printf(\"     A   B   C   D   E   F   G   H\"); \n\t// note: main loop iterating through board row, sub loop iterates column\n\t\t// hence switched around iterating variables for clarity\n\tfor (int j=0; j<BOARD_SIZE; j++) {//row\n\t\tfor (int i=0; i<BOARD_SIZE; i++) {//column\n\t\t\tif (i==0) { \n\t\t\t\tlibmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n\t\t\t\tlibmin_printf(\" %d |\", j + 1);\n\t\t\t}\n\t\t\tif ((*board_input)[i][j] == CELL_EMPTY) {\n\t\t\t\tlibmin_printf(\" . |\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlibmin_printf(\" %c |\", (*board_input)[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tlibmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "print_board", "address": "0x19be", "label": "print_board", "content": "void __cdecl print_board(board_t *board_input)\n{\n  int j; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for ( j = 0; j <= 7; ++j )\n  {\n    for ( i = 0; i <= 7; ++i )\n    {\n      if ( !i )\n      {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", j + 1);\n      }\n      if ( (*board_input)[i][j] == 48 )\n        libmin_printf(\" . |\");\n      else\n        libmin_printf(\" %c |\", (*board_input)[i][j]);\n    }\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}\n"}, "pseudo_normalize": "void print_board(board_t *board_input) {\n  int j;\n  int i;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  for (j = 0; j <= 7; ++j) {\n    for (i = 0; i <= 7; ++i) {\n      if (!i) {\n        libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n        libmin_printf(\" %d |\", j + 1);\n      }\n      if ((*board_input)[i][j] == 48)\n        libmin_printf(\" . |\");\n      else\n        libmin_printf(\" %c |\", (*board_input)[i][j]);\n    }\n  }\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}", "binary": "checkers/checkers.host.O0", "assembly": "<print_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nlea    0x56eb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    1aad <print_board+0xef>\nmovl   $0x0,-0x4(%rbp)\njmp    1a9f <print_board+0xe1>\ncmpl   $0x0,-0x4(%rbp)\njne    1a30 <print_board+0x72>\nlea    0x56e1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%esi\nlea    0x56ec(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nmov    -0x18(%rbp),%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\njne    1a66 <print_board+0xa8>\nlea    0x56be(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\njmp    1a9b <print_board+0xdd>\nmov    -0x18(%rbp),%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x568c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x7,-0x4(%rbp)\njle    19fa <print_board+0x3c>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x7,-0x8(%rbp)\njle    19ee <print_board+0x30>\nlea    0x562a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "print_error_message", "content": "// simple function to print various error messages\nvoid print_error_message(int error_code) {\n\tif (error_code == 1) {\n\t\tlibmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n\t}\n\tif (error_code == 2) {\n\t\tlibmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n\t}\n\tif (error_code == 3) {\n\t\tlibmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n\t}\n\tif (error_code == 4) {\n\t\tlibmin_printf(\"ERROR: Target cell is not empty.\\n\");\n\t}\n\tif (error_code == 5) {\n\t\tlibmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n\t}\n\tif (error_code == 6) {\n\t\tlibmin_printf(\"ERROR: Illegal action.\\n\");\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "print_error_message", "address": "0x2738", "label": "print_error_message", "content": "void __cdecl print_error_message(int error_code)\n{\n  if ( error_code == 1 )\n    libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n  if ( error_code == 2 )\n    libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n  if ( error_code == 3 )\n    libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n  if ( error_code == 4 )\n    libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n  if ( error_code == 5 )\n    libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n  if ( error_code == 6 )\n    libmin_printf(\"ERROR: Illegal action.\\n\");\n}\n"}, "pseudo_normalize": "void print_error_message(int error_code) {\n  if (error_code == 1)\n    libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n  if (error_code == 2)\n    libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n  if (error_code == 3) libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n  if (error_code == 4) libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n  if (error_code == 5)\n    libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n  if (error_code == 6) libmin_printf(\"ERROR: Illegal action.\\n\");\n}", "binary": "checkers/checkers.host.O0", "assembly": "<print_error_message>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    2761 <print_error_message+0x29>\nlea    0x49cc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x2,-0x4(%rbp)\njne    277b <print_error_message+0x43>\nlea    0x49e2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x3,-0x4(%rbp)\njne    2795 <print_error_message+0x5d>\nlea    0x49f5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x4,-0x4(%rbp)\njne    27af <print_error_message+0x77>\nlea    0x49fe(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x5,-0x4(%rbp)\njne    27c9 <print_error_message+0x91>\nlea    0x4a0c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x6,-0x4(%rbp)\njne    27e3 <print_error_message+0xab>\nlea    0x4a24(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "print_move_information", "content": "//print some headers regarding move information\nvoid print_move_information(int generated_move, int black_action, \n\tboard_t board_input, int col1, int row1, int col2, int row2, int action) {\n\tlibmin_printf(\"=====================================\\n\");\n\tif (generated_move) {\n\t\tlibmin_printf(\"*** \");\n\t}\n\tif (black_action) {\n\t\tlibmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", \n\t\t\tBLACK, action, col1, row1, col2, row2);\n\t}\n\telse {\n\t\tlibmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", \n\t\t\tWHITE, action, col1, row1, col2, row2);\n\t}\n\tlibmin_printf(\"BOARD COST: %d\\n\", board_cost(board_input));\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "print_move_information", "address": "0x2903", "label": "print_move_information", "content": "void __cdecl print_move_information(\n        int generated_move,\n        int black_action,\n        unsigned __int8 (*board_input)[8],\n        int col1,\n        int row1,\n        int col2,\n        int row2,\n        int action)\n{\n  int v8; // eax\n\n  libmin_printf(\"=====================================\\n\");\n  if ( generated_move )\n    libmin_printf(\"*** \");\n  if ( black_action )\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      BLACK,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  else\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      WHITE,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  v8 = board_cost(board_input);\n  libmin_printf(\"BOARD COST: %d\\n\", v8);\n}\n"}, "pseudo_normalize": "void print_move_information(int generated_move, int black_action,\n                            unsigned char (*board_input)[8], int col1, int row1,\n                            int col2, int row2, int action) {\n  int v8;\n  libmin_printf(\"=====================================\\n\");\n  if (generated_move) libmin_printf(\"*** \");\n  if (black_action)\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", BLACK, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  else\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", WHITE, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  v8 = board_cost(board_input);\n  libmin_printf(\"BOARD COST: %d\\n\", v8);\n}", "binary": "checkers/checkers.host.O0", "assembly": "<print_move_information>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %rdx,-0x10(%rbp)\nmov    %ecx,-0x14(%rbp)\nmov    %r8d,-0x18(%rbp)\nmov    %r9d,-0x1c(%rbp)\nlea    0x48ed(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x0,-0x4(%rbp)\nje     2952 <print_move_information+0x4f>\nlea    0x48fa(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\ncmpl   $0x0,-0x8(%rbp)\nje     299a <print_move_information+0x97>\nmov    -0x1c(%rbp),%edi\nmov    -0x18(%rbp),%esi\nmov    -0x14(%rbp),%edx\nmov    0x18(%rbp),%eax\nsub    $0x8,%rsp\nmov    0x10(%rbp),%ecx\npush   %rcx\nmov    %edi,%r9d\nmov    %esi,%r8d\nmov    %edx,%ecx\nmov    %eax,%edx\nlea    0x771b(%rip),%rax\nmov    %rax,%rsi\nlea    0x48bd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nadd    $0x10,%rsp\njmp    29da <print_move_information+0xd7>\nmov    -0x1c(%rbp),%edi\nmov    -0x18(%rbp),%esi\nmov    -0x14(%rbp),%edx\nmov    0x18(%rbp),%eax\nsub    $0x8,%rsp\nmov    0x10(%rbp),%ecx\npush   %rcx\nmov    %edi,%r9d\nmov    %esi,%r8d\nmov    %edx,%ecx\nmov    %eax,%edx\nlea    0x76df(%rip),%rax\nmov    %rax,%rsi\nlea    0x487b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nadd    $0x10,%rsp\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   27e6 <board_cost>\nmov    %eax,%esi\nlea    0x486f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5841 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "row_to_char", "content": "// reverse char_to_row\nchar row_to_char(int row) {return (char) (ASCII_1 + row - 1);}\n"}, "pseudo": {"path": "checkers/checkers.host.O0.pseudo", "function_name": "row_to_char", "address": "0x19ab", "label": "row_to_char", "content": "char __cdecl row_to_char(int row)\n{\n  return row + 48;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O0", "assembly": "<row_to_char>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x30,%eax\npop    %rbp\nret\n"}
{"source": {"path": "cipher/cipher.c", "function_name": "decipher", "content": "void\ndecipher(uint32_t *const in,\n\t uint32_t *const out,\n\t const uint32_t *const key)\n{\n  uint32_t y=in[0], z=in[1], sum=0xC6EF3720, delta=0x9E3779B9;\n  uint32_t a=key[0], b=key[1], c=key[2], d=key[3], n=32;\n\n  /* sum = delta<<5, in general sum = delta * n */\n  while (n-->0)\n    {\n      z -= ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);\n      y -= ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);\n      sum -= delta;\n    }\n  out[0]=y; out[1]=z;\n}\n"}, "pseudo": {"path": "cipher/cipher.host.O0.pseudo", "function_name": "decipher", "address": "0x12db", "label": "decipher", "content": "void __cdecl decipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t y; // [rsp+24h] [rbp-24h]\n  uint32_t z; // [rsp+28h] [rbp-20h]\n  uint32_t sum; // [rsp+2Ch] [rbp-1Ch]\n  uint32_t n; // [rsp+30h] [rbp-18h]\n\n  y = *in;\n  z = in[1];\n  sum = -957401312;\n  n = 32;\n  while ( n-- )\n  {\n    z -= (y + sum) ^ (16 * y + key[2]) ^ ((y >> 5) + key[3]);\n    y -= (z + sum) ^ (16 * z + *key) ^ ((z >> 5) + key[1]);\n    sum += 1640531527;\n  }\n  *out = y;\n  out[1] = z;\n}\n"}, "pseudo_normalize": "void decipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t y;\n  uint32_t z;\n  uint32_t sum;\n  uint32_t n;\n  y = *in;\n  z = in[1];\n  sum = -957401312;\n  n = 32;\n  while (n--) {\n    z -= (y + sum) ^ (16 * y + key[2]) ^ ((y >> 5) + key[3]);\n    y -= (z + sum) ^ (16 * z + *key) ^ ((z >> 5) + key[1]);\n    sum += 1640531527;\n  }\n  *out = y;\n  out[1] = z;\n}", "binary": "cipher/cipher.host.O0", "assembly": "<decipher>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,-0x20(%rbp)\nmovl   $0xc6ef3720,-0x1c(%rbp)\nmovl   $0x9e3779b9,-0x14(%rbp)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x20,-0x18(%rbp)\njmp    13a7 <decipher+0xcc>\nmov    -0x24(%rbp),%eax\nshl    $0x4,%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x24(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nxor    %eax,%ecx\nmov    %ecx,%edx\nmov    -0x24(%rbp),%eax\nshr    $0x5,%eax\nmov    %eax,%ecx\nmov    -0x4(%rbp),%eax\nadd    %ecx,%eax\nxor    %edx,%eax\nsub    %eax,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nshl    $0x4,%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x20(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nxor    %eax,%ecx\nmov    %ecx,%edx\nmov    -0x20(%rbp),%eax\nshr    $0x5,%eax\nmov    %eax,%ecx\nmov    -0xc(%rbp),%eax\nadd    %ecx,%eax\nxor    %edx,%eax\nsub    %eax,-0x24(%rbp)\nmov    -0x14(%rbp),%eax\nsub    %eax,-0x1c(%rbp)\nmov    -0x18(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\ntest   %eax,%eax\njne    1349 <decipher+0x6e>\nmov    -0x40(%rbp),%rax\nmov    -0x24(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x40(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x20(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "cipher/cipher.c", "function_name": "encipher", "content": "#include \"libmin.h\"\n\nvoid\nencipher(uint32_t *const in,\n\t uint32_t *const out,\n\t const uint32_t *const key)\n{\n  uint32_t y=in[0], z=in[1], sum=0, delta=0x9E3779B9;\n  uint32_t a=key[0], b=key[1], c=key[2], d=key[3], n=32;\n\n  while (n-->0)\n    {\n      sum += delta;\n      y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);\n      z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);\n    }\n  out[0]=y; out[1]=z;\n}\n"}, "pseudo": {"path": "cipher/cipher.host.O0.pseudo", "function_name": "encipher", "address": "0x11e9", "label": "encipher", "content": "void __cdecl encipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t y; // [rsp+24h] [rbp-24h]\n  uint32_t z; // [rsp+28h] [rbp-20h]\n  uint32_t sum; // [rsp+2Ch] [rbp-1Ch]\n  uint32_t n; // [rsp+30h] [rbp-18h]\n\n  y = *in;\n  z = in[1];\n  sum = 0;\n  n = 32;\n  while ( n-- )\n  {\n    sum -= 1640531527;\n    y += (z + sum) ^ (16 * z + *key) ^ ((z >> 5) + key[1]);\n    z += (y + sum) ^ (16 * y + key[2]) ^ ((y >> 5) + key[3]);\n  }\n  *out = y;\n  out[1] = z;\n}\n"}, "pseudo_normalize": "void encipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t y;\n  uint32_t z;\n  uint32_t sum;\n  uint32_t n;\n  y = *in;\n  z = in[1];\n  sum = 0;\n  n = 32;\n  while (n--) {\n    sum -= 1640531527;\n    y += (z + sum) ^ (16 * z + *key) ^ ((z >> 5) + key[1]);\n    z += (y + sum) ^ (16 * y + key[2]) ^ ((y >> 5) + key[3]);\n  }\n  *out = y;\n  out[1] = z;\n}", "binary": "cipher/cipher.host.O0", "assembly": "<encipher>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,-0x20(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x9e3779b9,-0x14(%rbp)\nmov    -0x48(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x48(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x20,-0x18(%rbp)\njmp    12b5 <encipher+0xcc>\nmov    -0x14(%rbp),%eax\nadd    %eax,-0x1c(%rbp)\nmov    -0x20(%rbp),%eax\nshl    $0x4,%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x20(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nxor    %eax,%ecx\nmov    %ecx,%edx\nmov    -0x20(%rbp),%eax\nshr    $0x5,%eax\nmov    %eax,%ecx\nmov    -0xc(%rbp),%eax\nadd    %ecx,%eax\nxor    %edx,%eax\nadd    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nshl    $0x4,%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x24(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nxor    %eax,%ecx\nmov    %ecx,%edx\nmov    -0x24(%rbp),%eax\nshr    $0x5,%eax\nmov    %eax,%ecx\nmov    -0x4(%rbp),%eax\nadd    %ecx,%eax\nxor    %edx,%eax\nadd    %eax,-0x20(%rbp)\nmov    -0x18(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x18(%rbp)\ntest   %eax,%eax\njne    1257 <encipher+0x6e>\nmov    -0x40(%rbp),%rax\nmov    -0x24(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x40(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x20(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "cipher/cipher.c", "function_name": "main", "content": "int\nmain(void)\n{\n\n  encipher(plaintext, ciphertext, keytext);\n  if (ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1])\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if (newplain[0] != plaintext[0] || newplain[1] != plaintext[1])\n    libmin_fail(2);\n  \n  libmin_printf(\"TEA Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n  libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0], ciphertext[1]);\n  libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "cipher/cipher.host.O0.pseudo", "function_name": "main", "address": "0x13cd", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  encipher(plaintext, ciphertext, keytext);\n  if ( ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1] )\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if ( newplain[0] == plaintext[0] && newplain[1] == plaintext[1] )\n  {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0], ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  encipher(plaintext, ciphertext, keytext);\n  if (ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1])\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if (newplain[0] == plaintext[0] && newplain[1] == plaintext[1]) {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0],\n                  ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}", "binary": "cipher/cipher.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    0x4c34(%rip),%rax\nmov    %rax,%rdx\nlea    0x4eaa(%rip),%rax\nmov    %rax,%rsi\nlea    0x4c30(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <encipher>\nmov    0x4e92(%rip),%edx\nmov    0x4c24(%rip),%eax\ncmp    %eax,%edx\njne    1418 <main+0x4b>\nmov    0x4e86(%rip),%edx\nmov    0x4c18(%rip),%eax\ncmp    %eax,%edx\nje     1422 <main+0x55>\nmov    $0x1,%edi\ncall   1637 <libmin_fail>\nlea    0x4be7(%rip),%rax\nmov    %rax,%rdx\nlea    0x4e65(%rip),%rax\nmov    %rax,%rsi\nlea    0x4e53(%rip),%rax\nmov    %rax,%rdi\ncall   12db <decipher>\nmov    0x4e4d(%rip),%edx\nmov    0x4bcf(%rip),%eax\ncmp    %eax,%edx\njne    1465 <main+0x98>\nmov    0x4e41(%rip),%edx\nmov    0x4bc3(%rip),%eax\ncmp    %eax,%edx\nje     146f <main+0xa2>\nmov    $0x2,%edi\ncall   1637 <libmin_fail>\nlea    0x2b8e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3663 <libmin_printf>\nmov    0x4b9b(%rip),%edx\nmov    0x4b91(%rip),%eax\nmov    %eax,%esi\nlea    0x2b81(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3663 <libmin_printf>\nmov    0x4de9(%rip),%edx\nmov    0x4ddf(%rip),%eax\nmov    %eax,%esi\nlea    0x2b7c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3663 <libmin_printf>\nmov    0x4dcf(%rip),%edx\nmov    0x4dc5(%rip),%eax\nmov    %eax,%esi\nlea    0x2b77(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3663 <libmin_printf>\ncall   38d0 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "congrad/congrad.c", "function_name": "cg_axpy", "content": "static inline void cg_axpy(CG_FP *y, const CG_FP *x, CG_FP alpha, int N) {\n    for (int i = 0; i < N; i++) y[i] += alpha * x[i];\n}\n"}, "pseudo": {"path": "congrad/congrad.host.O0.pseudo", "function_name": "cg_axpy", "address": "0x15c5", "label": "cg_axpy", "content": "void __cdecl cg_axpy(double *y, const double *x, double alpha, int N)\n{\n  int i; // [rsp+28h] [rbp-4h]\n\n  for ( i = 0; i < N; ++i )\n    y[i] = x[i] * alpha + y[i];\n}\n"}, "pseudo_normalize": "", "binary": "congrad/congrad.host.O0", "assembly": "<cg_axpy>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovsd  %xmm0,-0x28(%rbp)\nmov    %edx,-0x2c(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1637 <cg_axpy+0x72>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  -0x28(%rbp),%xmm0\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     15e2 <cg_axpy+0x1d>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "congrad/congrad.c", "function_name": "cg_build_matrix", "content": "/* ---------------- Sparse Laplacian Matrix ---------------- */\nstatic void cg_build_matrix(int n) {\n    int N = n*n;\n    int nnz = 0;\n    for (int i = 0; i < N; i++) {\n        row_ptr[i] = nnz;\n        int row = i / n;\n        int col = i % n;\n\n        // center\n        col_idx[nnz] = i; val[nnz++] = 4.0;\n\n        // neighbors\n        if (row > 0)    { col_idx[nnz] = i-n; val[nnz++] = -1.0; }\n        if (row < n-1)  { col_idx[nnz] = i+n; val[nnz++] = -1.0; }\n        if (col > 0)    { col_idx[nnz] = i-1; val[nnz++] = -1.0; }\n        if (col < n-1)  { col_idx[nnz] = i+1; val[nnz++] = -1.0; }\n    }\n    row_ptr[N] = nnz;\n}\n"}, "pseudo": {"path": "congrad/congrad.host.O0.pseudo", "function_name": "cg_build_matrix", "address": "0x125d", "label": "cg_build_matrix", "content": "void __cdecl cg_build_matrix(int n)\n{\n  int v1; // eax\n  int v2; // eax\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int nnz; // [rsp+10h] [rbp-14h]\n  int i; // [rsp+14h] [rbp-10h]\n  int N; // [rsp+18h] [rbp-Ch]\n  int col; // [rsp+20h] [rbp-4h]\n\n  N = n * n;\n  nnz = 0;\n  for ( i = 0; i < N; ++i )\n  {\n    row_ptr[i] = nnz;\n    col = i % n;\n    col_idx[nnz] = i;\n    v1 = nnz++;\n    val[v1] = 4.0;\n    if ( i / n > 0 )\n    {\n      col_idx[nnz] = i - n;\n      v2 = nnz++;\n      val[v2] = -1.0;\n    }\n    if ( i / n < n - 1 )\n    {\n      col_idx[nnz] = i + n;\n      v3 = nnz++;\n      val[v3] = -1.0;\n    }\n    if ( col > 0 )\n    {\n      col_idx[nnz] = i - 1;\n      v4 = nnz++;\n      val[v4] = -1.0;\n    }\n    if ( col < n - 1 )\n    {\n      col_idx[nnz] = i + 1;\n      v5 = nnz++;\n      val[v5] = -1.0;\n    }\n  }\n  row_ptr[N] = nnz;\n}\n"}, "pseudo_normalize": "void cg_build_matrix(int n) {\n  int v1;\n  int v2;\n  int v3;\n  int v4;\n  int v5;\n  int nnz;\n  int i;\n  int N;\n  int col;\n  N = n * n;\n  nnz = 0;\n  for (i = 0; i < N; ++i) {\n    row_ptr[i] = nnz;\n    col = i % n;\n    col_idx[nnz] = i;\n    v1 = nnz++;\n    val[v1] = 4.0;\n    if (i / n > 0) {\n      col_idx[nnz] = i - n;\n      v2 = nnz++;\n      val[v2] = -1.0;\n    }\n    if (i / n < n - 1) {\n      col_idx[nnz] = i + n;\n      v3 = nnz++;\n      val[v3] = -1.0;\n    }\n    if (col > 0) {\n      col_idx[nnz] = i - 1;\n      v4 = nnz++;\n      val[v4] = -1.0;\n    }\n    if (col < n - 1) {\n      col_idx[nnz] = i + 1;\n      v5 = nnz++;\n      val[v5] = -1.0;\n    }\n  }\n  row_ptr[N] = nnz;\n}", "binary": "congrad/congrad.host.O0", "assembly": "<cg_build_matrix>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\nimul   %eax,%eax\nmov    %eax,-0xc(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    142d <cg_build_matrix+0x1d0>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x5008(%rip),%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x10(%rbp),%eax\ncltd\nidivl  -0x24(%rbp)\nmov    %eax,-0x8(%rbp)\nmov    -0x10(%rbp),%eax\ncltd\nidivl  -0x24(%rbp)\nmov    %edx,-0x4(%rbp)\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x5ffa(%rip),%rdx\nmov    -0x10(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x14(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0xafda(%rip),%rax\nmovsd  0x2d52(%rip),%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\ncmpl   $0x0,-0x8(%rbp)\njle    133e <cg_build_matrix+0xe1>\nmov    -0x10(%rbp),%eax\nsub    -0x24(%rbp),%eax\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nlea    0x5fac(%rip),%rdx\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x14(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0xaf8f(%rip),%rax\nmovsd  0x2d0f(%rip),%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\nmov    -0x24(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x8(%rbp)\njge    1390 <cg_build_matrix+0x133>\nmov    -0x10(%rbp),%edx\nmov    -0x24(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5f5a(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x14(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0xaf3d(%rip),%rax\nmovsd  0x2cbd(%rip),%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\ncmpl   $0x0,-0x4(%rbp)\njle    13da <cg_build_matrix+0x17d>\nmov    -0x10(%rbp),%eax\nlea    -0x1(%rax),%ecx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5f10(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x14(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0xaef3(%rip),%rax\nmovsd  0x2c73(%rip),%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\nmov    -0x24(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x4(%rbp)\njge    1429 <cg_build_matrix+0x1cc>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%ecx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5ec1(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x14(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0xaea4(%rip),%rax\nmovsd  0x2c24(%rip),%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     1284 <cg_build_matrix+0x27>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x4e53(%rip),%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "congrad/congrad.c", "function_name": "cg_checksum", "content": "/* ---------------- Checksum ---------------- */\nstatic uint64_t cg_checksum(int N) {\n    uint64_t h = 0x9e3779b97f4a7c15ULL;\n    for (int i = 0; i < N; i++) {\n        int64_t xi = (int64_t)(x[i]*1e6);\n        h ^= (uint64_t)xi + (h<<6) + (h>>2);\n    }\n    return h;\n}\n"}, "pseudo": {"path": "congrad/congrad.host.O0.pseudo", "function_name": "cg_checksum", "address": "0x1918", "label": "cg_checksum", "content": "uint64_t __cdecl cg_checksum(int N)\n{\n  int i; // [rsp+10h] [rbp-14h]\n  uint64_t h; // [rsp+14h] [rbp-10h]\n\n  h = 0x9E3779B97F4A7C15LL;\n  for ( i = 0; i < N; ++i )\n    h ^= (unsigned int)(int)(1000000.0 * x[i]) + (h << 6) + (h >> 2);\n  return h;\n}\n"}, "pseudo_normalize": "uint64_t cg_checksum(int N) {\n  int i;\n  uint64_t h;\n  h = 11400714819323198485LL;\n  for (i = 0; i < N; ++i)\n    h ^= (unsigned int)(int)(1000000.0 * x[i]) + (h << 6) + (h >> 2);\n  return h;\n}", "binary": "congrad/congrad.host.O0", "assembly": "<cg_checksum>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmovabs $0x9e3779b97f4a7c15,%rax\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    198d <cg_checksum+0x75>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x14972(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmovsd  0x270d(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ncvttsd2si %xmm0,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%rax\nshl    $0x6,%rax\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%rax\nshr    $0x2,%rax\nadd    %rdx,%rax\nxor    %rax,-0x10(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     193a <cg_checksum+0x22>\nmov    -0x10(%rbp),%rax\npop    %rbp\nret\n"}
{"source": {"path": "congrad/congrad.c", "function_name": "cg_dot", "content": "/* ---------------- Vector ops ---------------- */\nstatic inline CG_FP cg_dot(const CG_FP *a, const CG_FP *b, int N) {\n    CG_FP s = 0;\n    for (int i = 0; i < N; i++) s += a[i]*b[i];\n    return s;\n}\n"}, "pseudo": {"path": "congrad/congrad.host.O0.pseudo", "function_name": "cg_dot", "address": "0x1545", "label": "cg_dot", "content": "double __cdecl cg_dot(const double *a, const double *b, int N)\n{\n  int i; // [rsp+18h] [rbp-Ch]\n  double s; // [rsp+1Ch] [rbp-8h]\n\n  s = 0.0;\n  for ( i = 0; i < N; ++i )\n    s = b[i] * a[i] + s;\n  return s;\n}\n"}, "pseudo_normalize": "double cg_dot(const double *a, const double *b, int N) {\n  int i;\n  double s;\n  s = 0.0;\n  for (i = 0; i < N; ++i) s = b[i] * a[i] + s;\n  return s;\n}", "binary": "congrad/congrad.host.O0", "assembly": "<cg_dot>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    15ac <cg_dot+0x67>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     1566 <cg_dot+0x21>\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n"}
{"source": {"path": "congrad/congrad.c", "function_name": "cg_lcg", "content": "static inline uint32_t cg_lcg(void) {\n    cg_rng = cg_rng * 1664525u + 1013904223u;\n    return cg_rng;\n}\n"}, "pseudo": {"path": "congrad/congrad.host.O0.pseudo", "function_name": "cg_lcg", "address": "0x11e9", "label": "cg_lcg", "content": "uint32_t __cdecl cg_lcg()\n{\n  cg_rng = 1664525 * cg_rng + 1013904223;\n  return cg_rng;\n}\n"}, "pseudo_normalize": "", "binary": "congrad/congrad.host.O0", "assembly": "<cg_lcg>:\npush   %rbp\nmov    %rsp,%rbp\nmov    0x4e1d(%rip),%eax\nimul   $0x19660d,%eax,%eax\nadd    $0x3c6ef35f,%eax\nmov    %eax,0x4e0c(%rip)\nmov    0x4e06(%rip),%eax\npop    %rbp\nret\n"}
{"source": {"path": "congrad/congrad.c", "function_name": "cg_solve", "content": "/* ---------------- Conjugate Gradient ---------------- */\nstatic void cg_solve(int n) {\n    int N = n*n;\n\n    // init vectors\n    for (int i = 0; i < N; i++) {\n        x[i] = 0.0;\n        b[i] = cg_urand();\n    }\n\n    cg_spmv(Ap, x, N);\n    for (int i = 0; i < N; i++) {\n        r[i] = b[i] - Ap[i];\n        p[i] = r[i];\n    }\n\n    CG_FP rsold = cg_dot(r,r,N);\n\n    for (int k = 0; k < CG_ITERS; k++) {\n        cg_spmv(Ap, p, N);\n        CG_FP alpha = rsold / cg_dot(p,Ap,N);\n        cg_axpy(x, p, alpha, N);\n        cg_axpy(r, Ap, -alpha, N);\n\n        CG_FP rsnew = cg_dot(r,r,N);\n        if (rsnew < 1e-12) break;\n\n        CG_FP beta = rsnew / rsold;\n        for (int i = 0; i < N; i++)\n            p[i] = r[i] + beta*p[i];\n\n        rsold = rsnew;\n    }\n}\n"}, "pseudo": {"path": "congrad/congrad.host.O0.pseudo", "function_name": "cg_solve", "address": "0x1643", "label": "cg_solve", "content": "void __cdecl cg_solve(int n)\n{\n  int i; // [rsp+14h] [rbp-34h]\n  int i_0; // [rsp+18h] [rbp-30h]\n  int k; // [rsp+1Ch] [rbp-2Ch]\n  int i_1; // [rsp+20h] [rbp-28h]\n  int N; // [rsp+24h] [rbp-24h]\n  double rsold; // [rsp+28h] [rbp-20h]\n  double alpha; // [rsp+30h] [rbp-18h]\n  double rsnew; // [rsp+38h] [rbp-10h]\n\n  N = n * n;\n  for ( i = 0; i < N; ++i )\n  {\n    x[i] = 0.0;\n    b[i] = cg_urand();\n  }\n  cg_spmv(Ap, x, N);\n  for ( i_0 = 0; i_0 < N; ++i_0 )\n  {\n    r[i_0] = b[i_0] - Ap[i_0];\n    p[i_0] = r[i_0];\n  }\n  rsold = cg_dot(r, r, N);\n  for ( k = 0; k <= 24; ++k )\n  {\n    cg_spmv(Ap, p, N);\n    alpha = rsold / cg_dot(p, Ap, N);\n    cg_axpy(x, p, alpha, N);\n    cg_axpy(r, Ap, COERCE_DOUBLE(*(_QWORD *)&alpha ^ 0x8000000000000000LL), N);\n    rsnew = cg_dot(r, r, N);\n    if ( rsnew < 1.0e-12 )\n      break;\n    for ( i_1 = 0; i_1 < N; ++i_1 )\n      p[i_1] = p[i_1] * (rsnew / rsold) + r[i_1];\n    rsold = rsnew;\n  }\n}\n"}, "pseudo_normalize": "void cg_solve(int n) {\n  int i;\n  int i_0;\n  int k;\n  int i_1;\n  int N;\n  double rsold;\n  double alpha;\n  double rsnew;\n  N = n * n;\n  for (i = 0; i < N; ++i) {\n    x[i] = 0.0;\n    b[i] = cg_urand();\n  }\n  cg_spmv(Ap, x, N);\n  for (i_0 = 0; i_0 < N; ++i_0) {\n    r[i_0] = b[i_0] - Ap[i_0];\n    p[i_0] = r[i_0];\n  }\n  rsold = cg_dot(r, r, N);\n  for (k = 0; k <= 24; ++k) {\n    cg_spmv(Ap, p, N);\n    alpha = rsold / cg_dot(p, Ap, N);\n    cg_axpy(x, p, alpha, N);\n    cg_axpy(r, Ap, COERCE_DOUBLE(*(uint64_t *)&alpha ^ 9223372036854775808LL),\n            N);\n    rsnew = cg_dot(r, r, N);\n    if (rsnew < 1.0e-12) break;\n    for (i_1 = 0; i_1 < N; ++i_1) p[i_1] = p[i_1] * (rsnew / rsold) + r[i_1];\n    rsold = rsnew;\n  }\n}", "binary": "congrad/congrad.host.O0", "assembly": "<cg_solve>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x48,%rsp\nmov    %edi,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\nimul   %eax,%eax\nmov    %eax,-0x24(%rbp)\nmovl   $0x0,-0x34(%rbp)\njmp    16a8 <cg_solve+0x65>\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x14c48(%rip),%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\ncall   120c <cg_urand>\nmovq   %xmm0,%rax\nmov    -0x34(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\nlea    0x16c20(%rip),%rdx\nmov    %rax,(%rcx,%rdx,1)\naddl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     1664 <cg_solve+0x21>\nmov    -0x24(%rbp),%eax\nmov    %eax,%edx\nlea    0x14c04(%rip),%rax\nmov    %rax,%rsi\nlea    0x1cbfa(%rip),%rax\nmov    %rax,%rdi\ncall   1456 <cg_spmv>\nmovl   $0x0,-0x30(%rbp)\njmp    175f <cg_solve+0x11c>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x16bd2(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x1cbb9(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nsubsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x18b9c(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x18b83(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x1ab6a(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     16da <cg_solve+0x97>\nmov    -0x24(%rbp),%eax\nmov    %eax,%edx\nlea    0x18b49(%rip),%rax\nmov    %rax,%rsi\nlea    0x18b3f(%rip),%rax\nmov    %rax,%rdi\ncall   1545 <cg_dot>\nmovq   %xmm0,%rax\nmov    %rax,-0x20(%rbp)\nmovl   $0x0,-0x2c(%rbp)\njmp    1908 <cg_solve+0x2c5>\nmov    -0x24(%rbp),%eax\nmov    %eax,%edx\nlea    0x1ab16(%rip),%rax\nmov    %rax,%rsi\nlea    0x1cb0c(%rip),%rax\nmov    %rax,%rdi\ncall   1456 <cg_spmv>\nmov    -0x24(%rbp),%eax\nmov    %eax,%edx\nlea    0x1caf8(%rip),%rax\nmov    %rax,%rsi\nlea    0x1aaee(%rip),%rax\nmov    %rax,%rdi\ncall   1545 <cg_dot>\nmovapd %xmm0,%xmm1\nmovsd  -0x20(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x24(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x1aac1(%rip),%rax\nmov    %rax,%rsi\nlea    0x14ab7(%rip),%rax\nmov    %rax,%rdi\ncall   15c5 <cg_axpy>\nmovsd  -0x18(%rbp),%xmm0\nmovq   0x2832(%rip),%xmm1\nxorpd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmov    -0x24(%rbp),%edx\nmovq   %rax,%xmm0\nlea    0x1ca8a(%rip),%rax\nmov    %rax,%rsi\nlea    0x18a80(%rip),%rax\nmov    %rax,%rdi\ncall   15c5 <cg_axpy>\nmov    -0x24(%rbp),%eax\nmov    %eax,%edx\nlea    0x18a6c(%rip),%rax\nmov    %rax,%rsi\nlea    0x18a62(%rip),%rax\nmov    %rax,%rdi\ncall   1545 <cg_dot>\nmovq   %xmm0,%rax\nmov    %rax,-0x10(%rbp)\nmovsd  0x27e9(%rip),%xmm0\ncomisd -0x10(%rbp),%xmm0\nja     1914 <cg_solve+0x2d1>\nmovsd  -0x10(%rbp),%xmm0\ndivsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    18f2 <cg_solve+0x2af>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x18a12(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x1a9f9(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmulsd  -0x8(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x1a9d7(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     189a <cg_solve+0x257>\nmovsd  -0x10(%rbp),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\naddl   $0x1,-0x2c(%rbp)\ncmpl   $0x18,-0x2c(%rbp)\njle    179e <cg_solve+0x15b>\njmp    1915 <cg_solve+0x2d2>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "congrad/congrad.c", "function_name": "cg_spmv", "content": "/* ---------------- Sparse MatVec: y = A*x ---------------- */\nstatic void cg_spmv(CG_FP *y, const CG_FP *x, int N) {\n    for (int i = 0; i < N; i++) {\n        CG_FP sum = 0;\n        for (int j = row_ptr[i]; j < row_ptr[i+1]; j++) {\n            sum += val[j] * x[col_idx[j]];\n        }\n        y[i] = sum;\n    }\n}\n"}, "pseudo": {"path": "congrad/congrad.host.O0.pseudo", "function_name": "cg_spmv", "address": "0x1456", "label": "cg_spmv", "content": "void __cdecl cg_spmv(double *y, const double *x, int N)\n{\n  int i; // [rsp+14h] [rbp-10h]\n  _BYTE j[12]; // [rsp+18h] [rbp-Ch]\n\n  for ( i = 0; i < N; ++i )\n  {\n    *(_DWORD *)&j[8] = 0;\n    *(_QWORD *)j = (unsigned int)row_ptr[i];\n    while ( *(int *)j < row_ptr[i + 1] )\n    {\n      *(double *)&j[4] = x[col_idx[*(int *)j]] * val[*(int *)j] + *(double *)&j[4];\n      ++*(_DWORD *)j;\n    }\n    y[i] = *(double *)&j[4];\n  }\n}\n"}, "pseudo_normalize": "void cg_spmv(double *y, const double *x, int N) {\n  int i;\n  uint8_t j[12];\n  for (i = 0; i < N; ++i) {\n    *(uint32_t *)&j[8] = 0;\n    *(uint64_t *)j = (unsigned int)row_ptr[i];\n    while (*(int *)j < row_ptr[i + 1]) {\n      *(double *)&j[4] =\n          x[col_idx[*(int *)j]] * val[*(int *)j] + *(double *)&j[4];\n      ++*(uint32_t *)j;\n    }\n    y[i] = *(double *)&j[4];\n  }\n}", "binary": "congrad/congrad.host.O0", "assembly": "<cg_spmv>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1535 <cg_spmv+0xdf>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4e0e(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0xc(%rbp)\njmp    14f5 <cg_spmv+0x9f>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0xae12(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5df9(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0x10(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4d94(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,-0xc(%rbp)\njl     149a <cg_spmv+0x44>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     1475 <cg_spmv+0x1f>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "congrad/congrad.c", "function_name": "cg_urand", "content": "static inline CG_FP cg_urand(void) {\n    return (CG_FP)(cg_lcg() & 0xFFFFFF) / (CG_FP)16777216.0;\n}\n"}, "pseudo": {"path": "congrad/congrad.host.O0.pseudo", "function_name": "cg_urand", "address": "0x120c", "label": "cg_urand", "content": "double __cdecl cg_urand()\n{\n  return (double)(cg_lcg() & 0xFFFFFF) / 16777216.0;\n}\n"}, "pseudo_normalize": "", "binary": "congrad/congrad.host.O0", "assembly": "<cg_urand>:\npush   %rbp\nmov    %rsp,%rbp\ncall   11e9 <cg_lcg>\nand    $0xffffff,%eax\nmov    %eax,%eax\ntest   %rax,%rax\njs     122c <cg_urand+0x20>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1245 <cg_urand+0x39>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x2deb(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n"}
{"source": {"path": "congrad/congrad.c", "function_name": "main", "content": "int main(void) {\n    cg_build_matrix(CG_N);\n    cg_solve(CG_N);\n    uint64_t sum = cg_checksum(CG_N*CG_N);\n\n    libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\",\n           CG_N, CG_ITERS, (uint32_t)(sum >> 32), (uint32_t)sum);\n\n    libmin_success();\n}\n"}, "pseudo": {"path": "congrad/congrad.host.O0.pseudo", "function_name": "main", "address": "0x199b", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint64_t sum; // [rsp+8h] [rbp-8h]\n\n  cg_build_matrix(32);\n  cg_solve(32);\n  sum = cg_checksum(1024);\n  libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25, HIDWORD(sum), sum);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  uint64_t sum;\n  cg_build_matrix(32);\n  cg_solve(32);\n  sum = cg_checksum(1024);\n  libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25, HIDWORD(sum),\n                sum);\n  libmin_success();\n}", "binary": "congrad/congrad.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x20,%edi\ncall   125d <cg_build_matrix>\nmov    $0x20,%edi\ncall   1643 <cg_solve>\nmov    $0x400,%edi\ncall   1918 <cg_checksum>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nshr    $0x20,%rax\nmov    %edx,%r8d\nmov    %eax,%ecx\nmov    $0x19,%edx\nmov    $0x20,%esi\nlea    0x2623(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b42 <libmin_printf>\ncall   3daf <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "board_full", "content": "// Check if board is full.\nint board_full(int board[ROWS][COLS]) {\n    for (int c = 0; c < COLS; c++)\n        if (valid_move(board, c))\n            return 0;\n    return 1;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "board_full", "address": "0x14ed", "label": "board_full", "content": "int __cdecl board_full(int (*board)[7])\n{\n  int c; // [rsp+14h] [rbp-4h]\n\n  for ( c = 0; c <= 6; ++c )\n  {\n    if ( valid_move(board, c) )\n      return 0;\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int board_full(int (*board)[7]) {\n  int c;\n  for (c = 0; c <= 6; ++c) {\n    if (valid_move(board, c)) return 0;\n  }\n  return 1;\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<board_full>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1526 <board_full+0x39>\nmov    -0x4(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   137e <valid_move>\ntest   %eax,%eax\nje     1522 <board_full+0x35>\nmov    $0x0,%eax\njmp    1531 <board_full+0x44>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x6,-0x4(%rbp)\njle    1506 <board_full+0x19>\nmov    $0x1,%eax\nleave\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "check_win", "content": "// -------------------------------------------------\n// Game Evaluation: Check for win.\n// -------------------------------------------------\n\n// Check horizontal, vertical, and two diagonals for four in a row.\nint check_win(int board[ROWS][COLS], int player) {\n    // Horizontal check\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r][c+1] == player &&\n                board[r][c+2] == player && board[r][c+3] == player)\n                return 1;\n        }\n    }\n    // Vertical check\n    for (int c = 0; c < COLS; c++) {\n        for (int r = 0; r < ROWS - 3; r++) {\n            if (board[r][c] == player && board[r+1][c] == player &&\n                board[r+2][c] == player && board[r+3][c] == player)\n                return 1;\n        }\n    }\n    // Diagonal (positive slope)\n    for (int r = 3; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r-1][c+1] == player &&\n                board[r-2][c+2] == player && board[r-3][c+3] == player)\n                return 1;\n        }\n    }\n    // Diagonal (negative slope)\n    for (int r = 0; r < ROWS - 3; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r+1][c+1] == player &&\n                board[r+2][c+2] == player && board[r+3][c+3] == player)\n                return 1;\n        }\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "check_win", "address": "0x1533", "label": "check_win", "content": "int __cdecl check_win(int (*board)[7], int player)\n{\n  int r; // [rsp+Ch] [rbp-20h]\n  int c; // [rsp+10h] [rbp-1Ch]\n  int c_0; // [rsp+14h] [rbp-18h]\n  int r_0; // [rsp+18h] [rbp-14h]\n  int r_1; // [rsp+1Ch] [rbp-10h]\n  int c_1; // [rsp+20h] [rbp-Ch]\n  int r_2; // [rsp+24h] [rbp-8h]\n  int c_2; // [rsp+28h] [rbp-4h]\n\n  for ( r = 0; r <= 5; ++r )\n  {\n    for ( c = 0; c <= 3; ++c )\n    {\n      if ( player == (*board)[7 * r + c]\n        && player == (*board)[7 * r + 1 + c]\n        && player == (*board)[7 * r + 2 + c]\n        && player == (*board)[7 * r + 3 + c] )\n      {\n        return 1;\n      }\n    }\n  }\n  for ( c_0 = 0; c_0 <= 6; ++c_0 )\n  {\n    for ( r_0 = 0; r_0 <= 2; ++r_0 )\n    {\n      if ( player == (*board)[7 * r_0 + c_0]\n        && player == (*board)[7 * r_0 + 7 + c_0]\n        && player == (*board)[7 * r_0 + 14 + c_0]\n        && player == (*board)[7 * r_0 + 21 + c_0] )\n      {\n        return 1;\n      }\n    }\n  }\n  for ( r_1 = 3; r_1 <= 5; ++r_1 )\n  {\n    for ( c_1 = 0; c_1 <= 3; ++c_1 )\n    {\n      if ( player == (*board)[7 * r_1 + c_1]\n        && player == (*board)[7 * r_1 - 6 + c_1]\n        && player == (*board)[7 * r_1 - 12 + c_1]\n        && player == (*board)[7 * r_1 - 18 + c_1] )\n      {\n        return 1;\n      }\n    }\n  }\n  for ( r_2 = 0; r_2 <= 2; ++r_2 )\n  {\n    for ( c_2 = 0; c_2 <= 3; ++c_2 )\n    {\n      if ( player == (*board)[7 * r_2 + c_2]\n        && player == (*board)[7 * r_2 + 8 + c_2]\n        && player == (*board)[7 * r_2 + 16 + c_2]\n        && player == (*board)[7 * r_2 + 24 + c_2] )\n      {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int check_win(int (*board)[7], int player) {\n  int r;\n  int c;\n  int c_0;\n  int r_0;\n  int r_1;\n  int c_1;\n  int r_2;\n  int c_2;\n  for (r = 0; r <= 5; ++r) {\n    for (c = 0; c <= 3; ++c) {\n      if (player == (*board)[7 * r + c] && player == (*board)[7 * r + 1 + c] &&\n          player == (*board)[7 * r + 2 + c] &&\n          player == (*board)[7 * r + 3 + c]) {\n        return 1;\n      }\n    }\n  }\n  for (c_0 = 0; c_0 <= 6; ++c_0) {\n    for (r_0 = 0; r_0 <= 2; ++r_0) {\n      if (player == (*board)[7 * r_0 + c_0] &&\n          player == (*board)[7 * r_0 + 7 + c_0] &&\n          player == (*board)[7 * r_0 + 14 + c_0] &&\n          player == (*board)[7 * r_0 + 21 + c_0]) {\n        return 1;\n      }\n    }\n  }\n  for (r_1 = 3; r_1 <= 5; ++r_1) {\n    for (c_1 = 0; c_1 <= 3; ++c_1) {\n      if (player == (*board)[7 * r_1 + c_1] &&\n          player == (*board)[7 * r_1 - 6 + c_1] &&\n          player == (*board)[7 * r_1 - 12 + c_1] &&\n          player == (*board)[7 * r_1 - 18 + c_1]) {\n        return 1;\n      }\n    }\n  }\n  for (r_2 = 0; r_2 <= 2; ++r_2) {\n    for (c_2 = 0; c_2 <= 3; ++c_2) {\n      if (player == (*board)[7 * r_2 + c_2] &&\n          player == (*board)[7 * r_2 + 8 + c_2] &&\n          player == (*board)[7 * r_2 + 16 + c_2] &&\n          player == (*board)[7 * r_2 + 24 + c_2]) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<check_win>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmp    162f <check_win+0xfc>\nmovl   $0x0,-0x1c(%rbp)\njmp    1621 <check_win+0xee>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    161d <check_win+0xea>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    161d <check_win+0xea>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\nadd    $0x2,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    161d <check_win+0xea>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\nadd    $0x3,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    161d <check_win+0xea>\nmov    $0x1,%eax\njmp    1924 <check_win+0x3f1>\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x3,-0x1c(%rbp)\njle    155a <check_win+0x27>\naddl   $0x1,-0x20(%rbp)\ncmpl   $0x5,-0x20(%rbp)\njle    154e <check_win+0x1b>\nmovl   $0x0,-0x18(%rbp)\njmp    1722 <check_win+0x1ef>\nmovl   $0x0,-0x14(%rbp)\njmp    1714 <check_win+0x1e1>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1710 <check_win+0x1dd>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1710 <check_win+0x1dd>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    0x38(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1710 <check_win+0x1dd>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    0x54(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1710 <check_win+0x1dd>\nmov    $0x1,%eax\njmp    1924 <check_win+0x3f1>\naddl   $0x1,-0x14(%rbp)\ncmpl   $0x2,-0x14(%rbp)\njle    1651 <check_win+0x11e>\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x6,-0x18(%rbp)\njle    1645 <check_win+0x112>\nmovl   $0x3,-0x10(%rbp)\njmp    181c <check_win+0x2e9>\nmovl   $0x0,-0xc(%rbp)\njmp    180e <check_win+0x2db>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    180a <check_win+0x2d7>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    -0x1c(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    180a <check_win+0x2d7>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    -0x38(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nadd    $0x2,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    180a <check_win+0x2d7>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    -0x54(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\nadd    $0x3,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    180a <check_win+0x2d7>\nmov    $0x1,%eax\njmp    1924 <check_win+0x3f1>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x3,-0xc(%rbp)\njle    1744 <check_win+0x211>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x5,-0x10(%rbp)\njle    1738 <check_win+0x205>\nmovl   $0x0,-0x8(%rbp)\njmp    1915 <check_win+0x3e2>\nmovl   $0x0,-0x4(%rbp)\njmp    1907 <check_win+0x3d4>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1903 <check_win+0x3d0>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1903 <check_win+0x3d0>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    0x38(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nadd    $0x2,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1903 <check_win+0x3d0>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    0x54(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nadd    $0x3,%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1903 <check_win+0x3d0>\nmov    $0x1,%eax\njmp    1924 <check_win+0x3f1>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x3,-0x4(%rbp)\njle    183e <check_win+0x30b>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x2,-0x8(%rbp)\njle    1832 <check_win+0x2ff>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "evaluate_window", "content": "// -------------------------------------------------\n// Heuristic Evaluation Function\n// -------------------------------------------------\n\n// Evaluate a window of 4 cells for scoring.\nint evaluate_window(int window[4], int player) {\n    int score = 0;\n    int opp = (player == 1) ? 2 : 1;\n    int count_player = 0, count_opp = 0, count_empty = 0;\n    for (int i = 0; i < 4; i++) {\n        if (window[i] == player) count_player++;\n        else if (window[i] == opp) count_opp++;\n        else count_empty++;\n    }\n    if (count_player == 4)\n        score += 100;\n    else if (count_player == 3 && count_empty == 1)\n        score += 5;\n    else if (count_player == 2 && count_empty == 2)\n        score += 2;\n    if (count_opp == 3 && count_empty == 1)\n        score -= 4;\n    return score;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "evaluate_window", "address": "0x1926", "label": "evaluate_window", "content": "int __cdecl evaluate_window(int *window, int player)\n{\n  int v2; // eax\n  int score; // [rsp+14h] [rbp-18h]\n  int count_player; // [rsp+18h] [rbp-14h]\n  int count_opp; // [rsp+1Ch] [rbp-10h]\n  int count_empty; // [rsp+20h] [rbp-Ch]\n  int i; // [rsp+24h] [rbp-8h]\n\n  score = 0;\n  if ( player == 1 )\n    v2 = 2;\n  else\n    v2 = 1;\n  count_player = 0;\n  count_opp = 0;\n  count_empty = 0;\n  for ( i = 0; i <= 3; ++i )\n  {\n    if ( player == window[i] )\n    {\n      ++count_player;\n    }\n    else if ( v2 == window[i] )\n    {\n      ++count_opp;\n    }\n    else\n    {\n      ++count_empty;\n    }\n  }\n  if ( count_player == 4 )\n  {\n    score = 100;\n  }\n  else if ( count_player == 3 && count_empty == 1 )\n  {\n    score = 5;\n  }\n  else if ( count_player == 2 && count_empty == 2 )\n  {\n    score = 2;\n  }\n  if ( count_opp == 3 && count_empty == 1 )\n    score -= 4;\n  return score;\n}\n"}, "pseudo_normalize": "int evaluate_window(int *window, int player) {\n  int v2;\n  int score;\n  int count_player;\n  int count_opp;\n  int count_empty;\n  int i;\n  score = 0;\n  if (player == 1)\n    v2 = 2;\n  else\n    v2 = 1;\n  count_player = 0;\n  count_opp = 0;\n  count_empty = 0;\n  for (i = 0; i <= 3; ++i) {\n    if (player == window[i]) {\n      ++count_player;\n    } else if (v2 == window[i]) {\n      ++count_opp;\n    } else {\n      ++count_empty;\n    }\n  }\n  if (count_player == 4) {\n    score = 100;\n  } else if (count_player == 3 && count_empty == 1) {\n    score = 5;\n  } else if (count_player == 2 && count_empty == 2) {\n    score = 2;\n  }\n  if (count_opp == 3 && count_empty == 1) score -= 4;\n  return score;\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<evaluate_window>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmovl   $0x0,-0x18(%rbp)\ncmpl   $0x1,-0x2c(%rbp)\njne    1949 <evaluate_window+0x23>\nmov    $0x2,%eax\njmp    194e <evaluate_window+0x28>\nmov    $0x1,%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    19b9 <evaluate_window+0x93>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x2c(%rbp)\njne    1990 <evaluate_window+0x6a>\naddl   $0x1,-0x14(%rbp)\njmp    19b5 <evaluate_window+0x8f>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x4(%rbp)\njne    19b1 <evaluate_window+0x8b>\naddl   $0x1,-0x10(%rbp)\njmp    19b5 <evaluate_window+0x8f>\naddl   $0x1,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x3,-0x8(%rbp)\njle    196f <evaluate_window+0x49>\ncmpl   $0x4,-0x14(%rbp)\njne    19cb <evaluate_window+0xa5>\naddl   $0x64,-0x18(%rbp)\njmp    19ed <evaluate_window+0xc7>\ncmpl   $0x3,-0x14(%rbp)\njne    19dd <evaluate_window+0xb7>\ncmpl   $0x1,-0xc(%rbp)\njne    19dd <evaluate_window+0xb7>\naddl   $0x5,-0x18(%rbp)\njmp    19ed <evaluate_window+0xc7>\ncmpl   $0x2,-0x14(%rbp)\njne    19ed <evaluate_window+0xc7>\ncmpl   $0x2,-0xc(%rbp)\njne    19ed <evaluate_window+0xc7>\naddl   $0x2,-0x18(%rbp)\ncmpl   $0x3,-0x10(%rbp)\njne    19fd <evaluate_window+0xd7>\ncmpl   $0x1,-0xc(%rbp)\njne    19fd <evaluate_window+0xd7>\nsubl   $0x4,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "get_next_open_row", "content": "// Returns the lowest available row in the given column (or -1 if full).\nint get_next_open_row(int board[ROWS][COLS], int col) {\n    for (int r = ROWS - 1; r >= 0; r--) {\n        if (board[r][col] == EMPTY)\n            return r;\n    }\n    return -1;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "get_next_open_row", "address": "0x13a4", "label": "get_next_open_row", "content": "int __cdecl get_next_open_row(int (*board)[7], int col)\n{\n  int r; // [rsp+18h] [rbp-4h]\n\n  for ( r = 5; r >= 0; --r )\n  {\n    if ( !(*board)[7 * r + col] )\n      return r;\n  }\n  return -1;\n}\n"}, "pseudo_normalize": "int get_next_open_row(int (*board)[7], int col) {\n  int r;\n  for (r = 5; r >= 0; --r) {\n    if (!(*board)[7 * r + col]) return r;\n  }\n  return -1;\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<get_next_open_row>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x5,-0x4(%rbp)\njmp    13ef <get_next_open_row+0x4b>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\njne    13eb <get_next_open_row+0x47>\nmov    -0x4(%rbp),%eax\njmp    13fa <get_next_open_row+0x56>\nsubl   $0x1,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njns    13bc <get_next_open_row+0x18>\nmov    $0xffffffff,%eax\npop    %rbp\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "init_board", "content": "#include \"libmin.h\"\n\n#define ROWS 6\n#define COLS 7\n#define MAX_DEPTH 4\n\n// Players: 1 and 2. Board cells: 0 = empty.\n#define EMPTY 0\n\n// Scoring constants for evaluation\n#define WIN_SCORE 100000\n#define LOSS_SCORE -100000\n\n// -------------------------------------------------\n// Board Helpers\n// -------------------------------------------------\nvoid init_board(int board[ROWS][COLS]) {\n    for (int r = 0; r < ROWS; r++)\n        for (int c = 0; c < COLS; c++)\n            board[r][c] = EMPTY;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "init_board", "address": "0x11e9", "label": "init_board", "content": "void __cdecl init_board(int (*board)[7])\n{\n  int r; // [rsp+10h] [rbp-8h]\n  int c; // [rsp+14h] [rbp-4h]\n\n  for ( r = 0; r <= 5; ++r )\n  {\n    for ( c = 0; c <= 6; ++c )\n      (*board)[7 * r + c] = 0;\n  }\n}\n"}, "pseudo_normalize": "void init_board(int (*board)[7]) {\n  int r;\n  int c;\n  for (r = 0; r <= 5; ++r) {\n    for (c = 0; c <= 6; ++c) (*board)[7 * r + c] = 0;\n  }\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<init_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    123f <init_board+0x56>\nmovl   $0x0,-0x4(%rbp)\njmp    1235 <init_board+0x4c>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmovl   $0x0,(%rdx,%rax,4)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x6,-0x4(%rbp)\njle    1207 <init_board+0x1e>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x5,-0x8(%rbp)\njle    11fe <init_board+0x15>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "main", "content": "int main(void) {\n    libmin_srand(42);\n    libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\");\n    play_game();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "main", "address": "0x2299", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x2a,%edi\ncall   4640 <libmin_srand>\nlea    0x2dbe(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\nmov    $0x0,%eax\ncall   20d1 <play_game>\ncall   49a9 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "make_move", "content": "// Make a move: drop piece for player into col. Returns row where piece lands, or -1 if invalid.\nint make_move(int board[ROWS][COLS], int col, int player) {\n    if (!valid_move(board, col))\n        return -1;\n    int row = get_next_open_row(board, col);\n    board[row][col] = player;\n    return row;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "make_move", "address": "0x13fc", "label": "make_move", "content": "int __cdecl make_move(int (*board)[7], int col, int player)\n{\n  int result; // eax\n\n  if ( !valid_move(board, col) )\n    return -1;\n  result = get_next_open_row(board, col);\n  (*board)[7 * result + col] = player;\n  return result;\n}\n"}, "pseudo_normalize": "int make_move(int (*board)[7], int col, int player) {\n  int result;\n  if (!valid_move(board, col)) return -1;\n  result = get_next_open_row(board, col);\n  (*board)[7 * result + col] = player;\n  return result;\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<make_move>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   137e <valid_move>\ntest   %eax,%eax\njne    142e <make_move+0x32>\nmov    $0xffffffff,%eax\njmp    146f <make_move+0x73>\nmov    -0x1c(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   13a4 <get_next_open_row>\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    -0x20(%rbp),%edx\nmov    %edx,(%rcx,%rax,4)\nmov    -0x4(%rbp),%eax\nleave\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "minimax", "content": "// -------------------------------------------------\n// Minimax with Alpha-Beta Pruning and Random Tie-Breaking\n// -------------------------------------------------\n\n// Returns evaluation score. If at top level, best_move will be set (column index).\nint minimax(int board[ROWS][COLS], int depth, int alpha, int beta, int maximizingPlayer, int player, int *best_move) {\n    int opp = (player == 1) ? 2 : 1;\n    // Check terminal conditions or depth limit\n    if (depth == 0 || board_full(board) || check_win(board, player) || check_win(board, opp)) {\n        int ts = terminal_score(board, player);\n        if (ts == 0) { // non-terminal leaf at depth 0: use heuristic\n            return score_position(board, player);\n        } else {\n            return ts;\n        }\n    }\n    \n    int valid_cols[COLS];\n    int valid_count = 0;\n    for (int c = 0; c < COLS; c++) {\n        if (valid_move(board, c))\n            valid_cols[valid_count++] = c;\n    }\n    \n    int best_score;\n    // For random tie-breaking, we keep an array of moves with best scores.\n    int best_moves[COLS];\n    int best_moves_count = 0;\n    \n    if (maximizingPlayer) {\n        best_score = INT_MIN;\n        for (int i = 0; i < valid_count; i++) {\n            int col = valid_cols[i];\n            make_move(board, col, player);\n            int score = minimax(board, depth - 1, alpha, beta, 0, player, NULL);\n            undo_move(board, col);\n            // Random tie breaking: if equal score, record all such moves.\n            if (score > best_score) {\n                best_score = score;\n                best_moves_count = 0;\n                best_moves[best_moves_count++] = col;\n            } else if (score == best_score) {\n                best_moves[best_moves_count++] = col;\n            }\n            if (best_score > alpha)\n                alpha = best_score;\n            if (alpha >= beta)\n                break;\n        }\n    } else {\n        best_score = INT_MAX;\n        for (int i = 0; i < valid_count; i++) {\n            int col = valid_cols[i];\n            make_move(board, col, opp);\n            int score = minimax(board, depth - 1, alpha, beta, 1, player, NULL);\n            undo_move(board, col);\n            if (score < best_score) {\n                best_score = score;\n                best_moves_count = 0;\n                best_moves[best_moves_count++] = col;\n            } else if (score == best_score) {\n                best_moves[best_moves_count++] = col;\n            }\n            if (best_score < beta)\n                beta = best_score;\n            if (alpha >= beta)\n                break;\n        }\n    }\n    \n    // At top level, choose a random move from the best moves if available.\n    if (depth == MAX_DEPTH && best_moves_count > 0 && best_move != NULL) {\n        int chosen = best_moves[libmin_rand() % best_moves_count];\n        *best_move = chosen;\n    }\n    return best_score;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "minimax", "address": "0x1d07", "label": "minimax", "content": "int __cdecl minimax(int (*board)[7], int depth, int alpha, int beta, int maximizingPlayer, int player, int *best_move)\n{\n  int v7; // eax\n  int v9; // eax\n  int v10; // eax\n  int v11; // eax\n  int valid_count; // [rsp+3Ch] [rbp-84h]\n  int c; // [rsp+40h] [rbp-80h]\n  signed int best_score; // [rsp+44h] [rbp-7Ch]\n  int best_moves_count; // [rsp+48h] [rbp-78h]\n  int i; // [rsp+4Ch] [rbp-74h]\n  int i_0; // [rsp+50h] [rbp-70h]\n  int opp; // [rsp+54h] [rbp-6Ch]\n  int col_0; // [rsp+58h] [rbp-68h]\n  int score_0; // [rsp+5Ch] [rbp-64h]\n  int col; // [rsp+60h] [rbp-60h]\n  int score; // [rsp+64h] [rbp-5Ch]\n  int ts; // [rsp+6Ch] [rbp-54h]\n  int valid_cols[8]; // [rsp+70h] [rbp-50h]\n  int best_moves[10]; // [rsp+90h] [rbp-30h]\n  unsigned __int64 v30; // [rsp+B8h] [rbp-8h]\n\n  v30 = __readfsqword(0x28u);\n  if ( player == 1 )\n    v7 = 2;\n  else\n    v7 = 1;\n  opp = v7;\n  if ( !depth || board_full(board) || check_win(board, player) || check_win(board, opp) )\n  {\n    ts = terminal_score(board, player);\n    if ( ts )\n      return ts;\n    else\n      return score_position(board, player);\n  }\n  else\n  {\n    valid_count = 0;\n    for ( c = 0; c <= 6; ++c )\n    {\n      if ( valid_move(board, c) )\n      {\n        v9 = valid_count++;\n        valid_cols[v9] = c;\n      }\n    }\n    best_moves_count = 0;\n    if ( maximizingPlayer )\n    {\n      best_score = 0x80000000;\n      for ( i = 0; i < valid_count; ++i )\n      {\n        col = valid_cols[i];\n        make_move(board, col, player);\n        score = minimax(board, depth - 1, alpha, beta, 0, player, 0LL);\n        undo_move(board, col);\n        if ( score <= best_score )\n        {\n          if ( score == best_score )\n          {\n            v10 = best_moves_count++;\n            best_moves[v10] = col;\n          }\n        }\n        else\n        {\n          best_score = score;\n          best_moves_count = 1;\n          best_moves[0] = col;\n        }\n        if ( best_score > alpha )\n          alpha = best_score;\n        if ( alpha >= beta )\n          break;\n      }\n    }\n    else\n    {\n      best_score = 0x7FFFFFFF;\n      for ( i_0 = 0; i_0 < valid_count; ++i_0 )\n      {\n        col_0 = valid_cols[i_0];\n        make_move(board, col_0, opp);\n        score_0 = minimax(board, depth - 1, alpha, beta, 1, player, 0LL);\n        undo_move(board, col_0);\n        if ( score_0 >= best_score )\n        {\n          if ( score_0 == best_score )\n          {\n            v11 = best_moves_count++;\n            best_moves[v11] = col_0;\n          }\n        }\n        else\n        {\n          best_score = score_0;\n          best_moves_count = 1;\n          best_moves[0] = col_0;\n        }\n        if ( best_score < beta )\n          beta = best_score;\n        if ( alpha >= beta )\n          break;\n      }\n    }\n    if ( depth == 4 && best_moves_count > 0 && best_move )\n      *best_move = best_moves[libmin_rand() % best_moves_count];\n    return best_score;\n  }\n}\n"}, "pseudo_normalize": "int minimax(int (*board)[7], int depth, int alpha, int beta,\n            int maximizingPlayer, int player, int *best_move) {\n  int v7;\n  int v9;\n  int v10;\n  int v11;\n  int valid_count;\n  int c;\n  signed int best_score;\n  int best_moves_count;\n  int i;\n  int i_0;\n  int opp;\n  int col_0;\n  int score_0;\n  int col;\n  int score;\n  int ts;\n  int valid_cols[8];\n  int best_moves[10];\n  unsigned long long v30;\n  v30 = __readfsqword(40u);\n  if (player == 1)\n    v7 = 2;\n  else\n    v7 = 1;\n  opp = v7;\n  if (!depth || board_full(board) || check_win(board, player) ||\n      check_win(board, opp)) {\n    ts = terminal_score(board, player);\n    if (ts)\n      return ts;\n    else\n      return score_position(board, player);\n  } else {\n    valid_count = 0;\n    for (c = 0; c <= 6; ++c) {\n      if (valid_move(board, c)) {\n        v9 = valid_count++;\n        valid_cols[v9] = c;\n      }\n    }\n    best_moves_count = 0;\n    if (maximizingPlayer) {\n      best_score = 2147483648;\n      for (i = 0; i < valid_count; ++i) {\n        col = valid_cols[i];\n        make_move(board, col, player);\n        score = minimax(board, depth - 1, alpha, beta, 0, player, 0LL);\n        undo_move(board, col);\n        if (score <= best_score) {\n          if (score == best_score) {\n            v10 = best_moves_count++;\n            best_moves[v10] = col;\n          }\n        } else {\n          best_score = score;\n          best_moves_count = 1;\n          best_moves[0] = col;\n        }\n        if (best_score > alpha) alpha = best_score;\n        if (alpha >= beta) break;\n      }\n    } else {\n      best_score = 2147483647;\n      for (i_0 = 0; i_0 < valid_count; ++i_0) {\n        col_0 = valid_cols[i_0];\n        make_move(board, col_0, opp);\n        score_0 = minimax(board, depth - 1, alpha, beta, 1, player, 0LL);\n        undo_move(board, col_0);\n        if (score_0 >= best_score) {\n          if (score_0 == best_score) {\n            v11 = best_moves_count++;\n            best_moves[v11] = col_0;\n          }\n        } else {\n          best_score = score_0;\n          best_moves_count = 1;\n          best_moves[0] = col_0;\n        }\n        if (best_score < beta) beta = best_score;\n        if (alpha >= beta) break;\n      }\n    }\n    if (depth == 4 && best_moves_count > 0 && best_move)\n      *best_move = best_moves[libmin_rand() % best_moves_count];\n    return best_score;\n  }\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<minimax>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xc0,%rsp\nmov    %rdi,-0x98(%rbp)\nmov    %esi,-0x9c(%rbp)\nmov    %edx,-0xa0(%rbp)\nmov    %ecx,-0xa4(%rbp)\nmov    %r8d,-0xa8(%rbp)\nmov    %r9d,-0xac(%rbp)\nmov    0x10(%rbp),%rax\nmov    %rax,-0xb8(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\ncmpl   $0x1,-0xac(%rbp)\njne    1d67 <minimax+0x60>\nmov    $0x2,%eax\njmp    1d6c <minimax+0x65>\nmov    $0x1,%eax\nmov    %eax,-0x6c(%rbp)\ncmpl   $0x0,-0x9c(%rbp)\nje     1dbe <minimax+0xb7>\nmov    -0x98(%rbp),%rax\nmov    %rax,%rdi\ncall   14ed <board_full>\ntest   %eax,%eax\njne    1dbe <minimax+0xb7>\nmov    -0xac(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1533 <check_win>\ntest   %eax,%eax\njne    1dbe <minimax+0xb7>\nmov    -0x6c(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1533 <check_win>\ntest   %eax,%eax\nje     1e02 <minimax+0xfb>\nmov    -0xac(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1ca0 <terminal_score>\nmov    %eax,-0x54(%rbp)\ncmpl   $0x0,-0x54(%rbp)\njne    1dfa <minimax+0xf3>\nmov    -0xac(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1a02 <score_position>\njmp    20bb <minimax+0x3b4>\nmov    -0x54(%rbp),%eax\njmp    20bb <minimax+0x3b4>\nmovl   $0x0,-0x84(%rbp)\nmovl   $0x0,-0x80(%rbp)\njmp    1e49 <minimax+0x142>\nmov    -0x80(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   137e <valid_move>\ntest   %eax,%eax\nje     1e45 <minimax+0x13e>\nmov    -0x84(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x84(%rbp)\ncltq\nmov    -0x80(%rbp),%edx\nmov    %edx,-0x50(%rbp,%rax,4)\naddl   $0x1,-0x80(%rbp)\ncmpl   $0x6,-0x80(%rbp)\njle    1e15 <minimax+0x10e>\nmovl   $0x0,-0x78(%rbp)\ncmpl   $0x0,-0xa8(%rbp)\nje     1f71 <minimax+0x26a>\nmovl   $0x80000000,-0x7c(%rbp)\nmovl   $0x0,-0x74(%rbp)\njmp    1f5d <minimax+0x256>\nmov    -0x74(%rbp),%eax\ncltq\nmov    -0x50(%rbp,%rax,4),%eax\nmov    %eax,-0x60(%rbp)\nmov    -0xac(%rbp),%edx\nmov    -0x60(%rbp),%ecx\nmov    -0x98(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   13fc <make_move>\nmov    -0x9c(%rbp),%eax\nlea    -0x1(%rax),%esi\nmov    -0xac(%rbp),%edi\nmov    -0xa4(%rbp),%ecx\nmov    -0xa0(%rbp),%edx\nmov    -0x98(%rbp),%rax\nsub    $0x8,%rsp\npush   $0x0\nmov    %edi,%r9d\nmov    $0x0,%r8d\nmov    %rax,%rdi\ncall   1d07 <minimax>\nadd    $0x10,%rsp\nmov    %eax,-0x5c(%rbp)\nmov    -0x60(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1471 <undo_move>\nmov    -0x5c(%rbp),%eax\ncmp    -0x7c(%rbp),%eax\njle    1f19 <minimax+0x212>\nmov    -0x5c(%rbp),%eax\nmov    %eax,-0x7c(%rbp)\nmovl   $0x0,-0x78(%rbp)\nmov    -0x78(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x78(%rbp)\ncltq\nmov    -0x60(%rbp),%edx\nmov    %edx,-0x30(%rbp,%rax,4)\njmp    1f33 <minimax+0x22c>\nmov    -0x5c(%rbp),%eax\ncmp    -0x7c(%rbp),%eax\njne    1f33 <minimax+0x22c>\nmov    -0x78(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x78(%rbp)\ncltq\nmov    -0x60(%rbp),%edx\nmov    %edx,-0x30(%rbp,%rax,4)\nmov    -0x7c(%rbp),%eax\ncmp    -0xa0(%rbp),%eax\njle    1f47 <minimax+0x240>\nmov    -0x7c(%rbp),%eax\nmov    %eax,-0xa0(%rbp)\nmov    -0xa0(%rbp),%eax\ncmp    -0xa4(%rbp),%eax\njge    2075 <minimax+0x36e>\naddl   $0x1,-0x74(%rbp)\nmov    -0x74(%rbp),%eax\ncmp    -0x84(%rbp),%eax\njl     1e76 <minimax+0x16f>\njmp    2079 <minimax+0x372>\nmovl   $0x7fffffff,-0x7c(%rbp)\nmovl   $0x0,-0x70(%rbp)\njmp    2064 <minimax+0x35d>\nmov    -0x70(%rbp),%eax\ncltq\nmov    -0x50(%rbp,%rax,4),%eax\nmov    %eax,-0x68(%rbp)\nmov    -0x6c(%rbp),%edx\nmov    -0x68(%rbp),%ecx\nmov    -0x98(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   13fc <make_move>\nmov    -0x9c(%rbp),%eax\nlea    -0x1(%rax),%esi\nmov    -0xac(%rbp),%edi\nmov    -0xa4(%rbp),%ecx\nmov    -0xa0(%rbp),%edx\nmov    -0x98(%rbp),%rax\nsub    $0x8,%rsp\npush   $0x0\nmov    %edi,%r9d\nmov    $0x1,%r8d\nmov    %rax,%rdi\ncall   1d07 <minimax>\nadd    $0x10,%rsp\nmov    %eax,-0x64(%rbp)\nmov    -0x68(%rbp),%edx\nmov    -0x98(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1471 <undo_move>\nmov    -0x64(%rbp),%eax\ncmp    -0x7c(%rbp),%eax\njge    2024 <minimax+0x31d>\nmov    -0x64(%rbp),%eax\nmov    %eax,-0x7c(%rbp)\nmovl   $0x0,-0x78(%rbp)\nmov    -0x78(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x78(%rbp)\ncltq\nmov    -0x68(%rbp),%edx\nmov    %edx,-0x30(%rbp,%rax,4)\njmp    203e <minimax+0x337>\nmov    -0x64(%rbp),%eax\ncmp    -0x7c(%rbp),%eax\njne    203e <minimax+0x337>\nmov    -0x78(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x78(%rbp)\ncltq\nmov    -0x68(%rbp),%edx\nmov    %edx,-0x30(%rbp,%rax,4)\nmov    -0x7c(%rbp),%eax\ncmp    -0xa4(%rbp),%eax\njge    2052 <minimax+0x34b>\nmov    -0x7c(%rbp),%eax\nmov    %eax,-0xa4(%rbp)\nmov    -0xa0(%rbp),%eax\ncmp    -0xa4(%rbp),%eax\njge    2078 <minimax+0x371>\naddl   $0x1,-0x70(%rbp)\nmov    -0x70(%rbp),%eax\ncmp    -0x84(%rbp),%eax\njl     1f84 <minimax+0x27d>\njmp    2079 <minimax+0x372>\nnop\njmp    2079 <minimax+0x372>\nnop\ncmpl   $0x4,-0x9c(%rbp)\njne    20b8 <minimax+0x3b1>\ncmpl   $0x0,-0x78(%rbp)\njle    20b8 <minimax+0x3b1>\ncmpq   $0x0,-0xb8(%rbp)\nje     20b8 <minimax+0x3b1>\ncall   46f2 <libmin_rand>\nmov    -0x78(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nmov    %eax,%eax\nmov    -0x30(%rbp,%rax,4),%eax\nmov    %eax,-0x58(%rbp)\nmov    -0xb8(%rbp),%rax\nmov    -0x58(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x7c(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     20cf <minimax+0x3c8>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "play_game", "content": "// -------------------------------------------------\n// Main Simulation Loop: Self-play game using minimax\n// -------------------------------------------------\nvoid play_game() {\n    int board[ROWS][COLS];\n    init_board(board);\n    \n    int current_player = 1; // Player 1 starts.\n    int move_number = 0;\n    \n    print_board(board);\n    \n    while (1) {\n        move_number++;\n        int best_move = -1;\n        // For both players, we use minimax to choose a move.\n        int score = minimax(board, MAX_DEPTH, INT_MIN, INT_MAX, 1, current_player, &best_move);\n        if (best_move == -1 || !valid_move(board, best_move)) {\n            // No valid move found => game over.\n            break;\n        }\n        make_move(board, best_move, current_player);\n        libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", move_number, current_player, best_move, score);\n        print_board(board);\n        \n        if (check_win(board, current_player)) {\n            libmin_printf(\"Player %d wins!\\n\", current_player);\n            break;\n        }\n        if (board_full(board)) {\n            libmin_printf(\"Game is a draw.\\n\");\n            break;\n        }\n        // Switch players.\n        current_player = (current_player == 1) ? 2 : 1;\n    }\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "play_game", "address": "0x20d1", "label": "play_game", "content": "void __cdecl play_game()\n{\n  int v0; // eax\n  int best_move; // [rsp+0h] [rbp-C0h] BYREF\n  int current_player; // [rsp+4h] [rbp-BCh]\n  int move_number; // [rsp+8h] [rbp-B8h]\n  int score; // [rsp+Ch] [rbp-B4h]\n  int board[6][7]; // [rsp+10h] [rbp-B0h] BYREF\n  unsigned __int64 v6; // [rsp+B8h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  init_board(board);\n  current_player = 1;\n  move_number = 0;\n  print_board(board);\n  while ( 1 )\n  {\n    ++move_number;\n    best_move = -1;\n    score = minimax(board, 4, 0x80000000, 0x7FFFFFFF, 1, current_player, &best_move);\n    if ( best_move == -1 || !valid_move(board, best_move) )\n      break;\n    make_move(board, best_move, current_player);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", move_number, current_player, best_move, score);\n    print_board(board);\n    if ( check_win(board, current_player) )\n    {\n      libmin_printf(\"Player %d wins!\\n\", current_player);\n      return;\n    }\n    if ( board_full(board) )\n    {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n    if ( current_player == 1 )\n      v0 = 2;\n    else\n      v0 = 1;\n    current_player = v0;\n  }\n}\n"}, "pseudo_normalize": "void play_game() {\n  int v0;\n  int best_move;\n  int current_player;\n  int move_number;\n  int score;\n  int board[6][7];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  init_board(board);\n  current_player = 1;\n  move_number = 0;\n  print_board(board);\n  while (1) {\n    ++move_number;\n    best_move = -1;\n    score = minimax(board, 4, 2147483648, 2147483647, 1, current_player,\n                    &best_move);\n    if (best_move == -1 || !valid_move(board, best_move)) break;\n    make_move(board, best_move, current_player);\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\",\n                  move_number, current_player, best_move, score);\n    print_board(board);\n    if (check_win(board, current_player)) {\n      libmin_printf(\"Player %d wins!\\n\", current_player);\n      return;\n    }\n    if (board_full(board)) {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n    if (current_player == 1)\n      v0 = 2;\n    else\n      v0 = 1;\n    current_player = v0;\n  }\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<play_game>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xc0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0xb0(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <init_board>\nmovl   $0x1,-0xbc(%rbp)\nmovl   $0x0,-0xb8(%rbp)\nlea    -0xb0(%rbp),%rax\nmov    %rax,%rdi\ncall   1249 <print_board>\naddl   $0x1,-0xb8(%rbp)\nmovl   $0xffffffff,-0xc0(%rbp)\nmov    -0xbc(%rbp),%ecx\nlea    -0xb0(%rbp),%rax\nsub    $0x8,%rsp\nlea    -0xc0(%rbp),%rdx\npush   %rdx\nmov    %ecx,%r9d\nmov    $0x1,%r8d\nmov    $0x7fffffff,%ecx\nmov    $0x80000000,%edx\nmov    $0x4,%esi\nmov    %rax,%rdi\ncall   1d07 <minimax>\nadd    $0x10,%rsp\nmov    %eax,-0xb4(%rbp)\nmov    -0xc0(%rbp),%eax\ncmp    $0xffffffff,%eax\nje     2282 <play_game+0x1b1>\nmov    -0xc0(%rbp),%edx\nlea    -0xb0(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   137e <valid_move>\ntest   %eax,%eax\nje     2282 <play_game+0x1b1>\nmov    -0xc0(%rbp),%ecx\nmov    -0xbc(%rbp),%edx\nlea    -0xb0(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   13fc <make_move>\nmov    -0xc0(%rbp),%ecx\nmov    -0xb4(%rbp),%esi\nmov    -0xbc(%rbp),%edx\nmov    -0xb8(%rbp),%eax\nmov    %esi,%r8d\nmov    %eax,%esi\nlea    0x2e34(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\nlea    -0xb0(%rbp),%rax\nmov    %rax,%rdi\ncall   1249 <print_board>\nmov    -0xbc(%rbp),%edx\nlea    -0xb0(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1533 <check_win>\ntest   %eax,%eax\nje     2239 <play_game+0x168>\nmov    -0xbc(%rbp),%eax\nmov    %eax,%esi\nlea    0x2e20(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\njmp    2282 <play_game+0x1b1>\nlea    -0xb0(%rbp),%rax\nmov    %rax,%rdi\ncall   14ed <board_full>\ntest   %eax,%eax\nje     2262 <play_game+0x191>\nlea    0x2e08(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\njmp    2282 <play_game+0x1b1>\ncmpl   $0x1,-0xbc(%rbp)\njne    2272 <play_game+0x1a1>\nmov    $0x2,%eax\njmp    2277 <play_game+0x1a6>\nmov    $0x1,%eax\nmov    %eax,-0xbc(%rbp)\njmp    2121 <play_game+0x50>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     2297 <play_game+0x1c6>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "print_board", "content": "void print_board(int board[ROWS][COLS]) {\n    libmin_printf(\"\\n\");\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS; c++) {\n            char ch = board[r][c] == 1 ? 'X' : (board[r][c] == 2 ? 'O' : '.');\n            libmin_printf(\"%c \", ch);\n        }\n        libmin_printf(\"\\n\");\n    }\n    for (int c = 0; c < COLS; c++) {\n        libmin_printf(\"%d \", c);\n    }\n    libmin_printf(\"\\n\\n\");\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "print_board", "address": "0x1249", "label": "print_board", "content": "void __cdecl print_board(int (*board)[7])\n{\n  char v1; // al\n  int r; // [rsp+14h] [rbp-Ch]\n  int c; // [rsp+18h] [rbp-8h]\n  int c_0; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"\\n\");\n  for ( r = 0; r <= 5; ++r )\n  {\n    for ( c = 0; c <= 6; ++c )\n    {\n      if ( (*board)[7 * r + c] == 1 )\n      {\n        v1 = 88;\n      }\n      else if ( (*board)[7 * r + c] == 2 )\n      {\n        v1 = 79;\n      }\n      else\n      {\n        v1 = 46;\n      }\n      libmin_printf(\"%c \", (unsigned int)v1);\n    }\n    libmin_printf(\"\\n\");\n  }\n  for ( c_0 = 0; c_0 <= 6; ++c_0 )\n    libmin_printf(\"%d \", c_0);\n  libmin_printf(\"\\n\\n\");\n}\n"}, "pseudo_normalize": "void print_board(int (*board)[7]) {\n  char v1;\n  int r;\n  int c;\n  int c_0;\n  libmin_printf(\"\\n\");\n  for (r = 0; r <= 5; ++r) {\n    for (c = 0; c <= 6; ++c) {\n      if ((*board)[7 * r + c] == 1) {\n        v1 = 88;\n      } else if ((*board)[7 * r + c] == 2) {\n        v1 = 79;\n      } else {\n        v1 = 46;\n      }\n      libmin_printf(\"%c \", (unsigned int)v1);\n    }\n    libmin_printf(\"\\n\");\n  }\n  for (c_0 = 0; c_0 <= 6; ++c_0) libmin_printf(\"%d \", c_0);\n  libmin_printf(\"\\n\\n\");\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<print_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nlea    0x3da8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\nmovl   $0x0,-0xc(%rbp)\njmp    1331 <print_board+0xe8>\nmovl   $0x0,-0x8(%rbp)\njmp    130f <print_board+0xc6>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    $0x1,%eax\nje     12e9 <print_board+0xa0>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    $0x2,%eax\njne    12e2 <print_board+0x99>\nmov    $0x4f,%eax\njmp    12ee <print_board+0xa5>\nmov    $0x2e,%eax\njmp    12ee <print_board+0xa5>\nmov    $0x58,%eax\nmov    %al,-0xd(%rbp)\nmovsbl -0xd(%rbp),%eax\nmov    %eax,%esi\nlea    0x3d0c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x6,-0x8(%rbp)\njle    1285 <print_board+0x3c>\nlea    0x3ce8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x5,-0xc(%rbp)\njle    1279 <print_board+0x30>\nmovl   $0x0,-0x4(%rbp)\njmp    1361 <print_board+0x118>\nmov    -0x4(%rbp),%eax\nmov    %eax,%esi\nlea    0x3cbe(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x6,-0x4(%rbp)\njle    1344 <print_board+0xfb>\nlea    0x3ca4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4411 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "score_position", "content": "// Score the board from the perspective of \"player\".\nint score_position(int board[ROWS][COLS], int player) {\n    int score = 0;\n    int window[4];\n    int center_count = 0;\n    // Score center column: pieces in the center are more valuable.\n    for (int r = 0; r < ROWS; r++) {\n        if (board[r][COLS/2] == player)\n            center_count++;\n    }\n    score += center_count * 3;\n\n    // Horizontal\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Vertical\n    for (int c = 0; c < COLS; c++) {\n        for (int r = 0; r < ROWS - 3; r++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r+i][c];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Positive diagonal\n    for (int r = 3; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r-i][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Negative diagonal\n    for (int r = 0; r < ROWS - 3; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r+i][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    return score;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "score_position", "address": "0x1a02", "label": "score_position", "content": "int __cdecl score_position(int (*board)[7], int player)\n{\n  int score; // [rsp+14h] [rbp-5Ch]\n  int center_count; // [rsp+18h] [rbp-58h]\n  int r; // [rsp+1Ch] [rbp-54h]\n  int r_0; // [rsp+20h] [rbp-50h]\n  int c; // [rsp+24h] [rbp-4Ch]\n  int i; // [rsp+28h] [rbp-48h]\n  int c_0; // [rsp+2Ch] [rbp-44h]\n  int r_1; // [rsp+30h] [rbp-40h]\n  int i_0; // [rsp+34h] [rbp-3Ch]\n  int r_2; // [rsp+38h] [rbp-38h]\n  int c_1; // [rsp+3Ch] [rbp-34h]\n  int i_1; // [rsp+40h] [rbp-30h]\n  int r_3; // [rsp+44h] [rbp-2Ch]\n  int c_2; // [rsp+48h] [rbp-28h]\n  int i_2; // [rsp+4Ch] [rbp-24h]\n  int window[6]; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v19; // [rsp+68h] [rbp-8h]\n\n  v19 = __readfsqword(0x28u);\n  center_count = 0;\n  for ( r = 0; r <= 5; ++r )\n  {\n    if ( player == (*board)[7 * r + 3] )\n      ++center_count;\n  }\n  score = 3 * center_count;\n  for ( r_0 = 0; r_0 <= 5; ++r_0 )\n  {\n    for ( c = 0; c <= 3; ++c )\n    {\n      for ( i = 0; i <= 3; ++i )\n        window[i] = (*board)[7 * r_0 + c + i];\n      score += evaluate_window(window, player);\n    }\n  }\n  for ( c_0 = 0; c_0 <= 6; ++c_0 )\n  {\n    for ( r_1 = 0; r_1 <= 2; ++r_1 )\n    {\n      for ( i_0 = 0; i_0 <= 3; ++i_0 )\n        window[i_0] = (*board)[7 * r_1 + 7 * i_0 + c_0];\n      score += evaluate_window(window, player);\n    }\n  }\n  for ( r_2 = 3; r_2 <= 5; ++r_2 )\n  {\n    for ( c_1 = 0; c_1 <= 3; ++c_1 )\n    {\n      for ( i_1 = 0; i_1 <= 3; ++i_1 )\n        window[i_1] = (*board)[7 * (r_2 - i_1) + c_1 + i_1];\n      score += evaluate_window(window, player);\n    }\n  }\n  for ( r_3 = 0; r_3 <= 2; ++r_3 )\n  {\n    for ( c_2 = 0; c_2 <= 3; ++c_2 )\n    {\n      for ( i_2 = 0; i_2 <= 3; ++i_2 )\n        window[i_2] = (*board)[7 * r_3 + 7 * i_2 + c_2 + i_2];\n      score += evaluate_window(window, player);\n    }\n  }\n  return score;\n}\n"}, "pseudo_normalize": "int score_position(int (*board)[7], int player) {\n  int score;\n  int center_count;\n  int r;\n  int r_0;\n  int c;\n  int i;\n  int c_0;\n  int r_1;\n  int i_0;\n  int r_2;\n  int c_1;\n  int i_1;\n  int r_3;\n  int c_2;\n  int i_2;\n  int window[6];\n  unsigned long long v19;\n  v19 = __readfsqword(40u);\n  center_count = 0;\n  for (r = 0; r <= 5; ++r) {\n    if (player == (*board)[7 * r + 3]) ++center_count;\n  }\n  score = 3 * center_count;\n  for (r_0 = 0; r_0 <= 5; ++r_0) {\n    for (c = 0; c <= 3; ++c) {\n      for (i = 0; i <= 3; ++i) window[i] = (*board)[7 * r_0 + c + i];\n      score += evaluate_window(window, player);\n    }\n  }\n  for (c_0 = 0; c_0 <= 6; ++c_0) {\n    for (r_1 = 0; r_1 <= 2; ++r_1) {\n      for (i_0 = 0; i_0 <= 3; ++i_0)\n        window[i_0] = (*board)[7 * r_1 + 7 * i_0 + c_0];\n      score += evaluate_window(window, player);\n    }\n  }\n  for (r_2 = 3; r_2 <= 5; ++r_2) {\n    for (c_1 = 0; c_1 <= 3; ++c_1) {\n      for (i_1 = 0; i_1 <= 3; ++i_1)\n        window[i_1] = (*board)[7 * (r_2 - i_1) + c_1 + i_1];\n      score += evaluate_window(window, player);\n    }\n  }\n  for (r_3 = 0; r_3 <= 2; ++r_3) {\n    for (c_2 = 0; c_2 <= 3; ++c_2) {\n      for (i_2 = 0; i_2 <= 3; ++i_2)\n        window[i_2] = (*board)[7 * r_3 + 7 * i_2 + c_2 + i_2];\n      score += evaluate_window(window, player);\n    }\n  }\n  return score;\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<score_position>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %rdi,-0x68(%rbp)\nmov    %esi,-0x6c(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x5c(%rbp)\nmovl   $0x0,-0x58(%rbp)\nmovl   $0x0,-0x54(%rbp)\njmp    1a69 <score_position+0x67>\nmov    -0x54(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmov    0xc(%rax),%eax\ncmp    %eax,-0x6c(%rbp)\njne    1a65 <score_position+0x63>\naddl   $0x1,-0x58(%rbp)\naddl   $0x1,-0x54(%rbp)\ncmpl   $0x5,-0x54(%rbp)\njle    1a3b <score_position+0x39>\nmov    -0x58(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nadd    %eax,-0x5c(%rbp)\nmovl   $0x0,-0x50(%rbp)\njmp    1af6 <score_position+0xf4>\nmovl   $0x0,-0x4c(%rbp)\njmp    1aec <score_position+0xea>\nmovl   $0x0,-0x48(%rbp)\njmp    1ace <score_position+0xcc>\nmov    -0x50(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4c(%rbp),%ecx\nmov    -0x48(%rbp),%eax\nadd    %ecx,%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0x48(%rbp),%eax\ncltq\nmov    %edx,-0x20(%rbp,%rax,4)\naddl   $0x1,-0x48(%rbp)\ncmpl   $0x3,-0x48(%rbp)\njle    1a96 <score_position+0x94>\nmov    -0x6c(%rbp),%edx\nlea    -0x20(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1926 <evaluate_window>\nadd    %eax,-0x5c(%rbp)\naddl   $0x1,-0x4c(%rbp)\ncmpl   $0x3,-0x4c(%rbp)\njle    1a8d <score_position+0x8b>\naddl   $0x1,-0x50(%rbp)\ncmpl   $0x5,-0x50(%rbp)\njle    1a84 <score_position+0x82>\nmovl   $0x0,-0x44(%rbp)\njmp    1b77 <score_position+0x175>\nmovl   $0x0,-0x40(%rbp)\njmp    1b6d <score_position+0x16b>\nmovl   $0x0,-0x3c(%rbp)\njmp    1b4f <score_position+0x14d>\nmov    -0x40(%rbp),%edx\nmov    -0x3c(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x44(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0x3c(%rbp),%eax\ncltq\nmov    %edx,-0x20(%rbp,%rax,4)\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x3,-0x3c(%rbp)\njle    1b17 <score_position+0x115>\nmov    -0x6c(%rbp),%edx\nlea    -0x20(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1926 <evaluate_window>\nadd    %eax,-0x5c(%rbp)\naddl   $0x1,-0x40(%rbp)\ncmpl   $0x2,-0x40(%rbp)\njle    1b0e <score_position+0x10c>\naddl   $0x1,-0x44(%rbp)\ncmpl   $0x6,-0x44(%rbp)\njle    1b05 <score_position+0x103>\nmovl   $0x3,-0x38(%rbp)\njmp    1bfb <score_position+0x1f9>\nmovl   $0x0,-0x34(%rbp)\njmp    1bf1 <score_position+0x1ef>\nmovl   $0x0,-0x30(%rbp)\njmp    1bd3 <score_position+0x1d1>\nmov    -0x38(%rbp),%eax\nsub    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x34(%rbp),%ecx\nmov    -0x30(%rbp),%eax\nadd    %ecx,%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0x30(%rbp),%eax\ncltq\nmov    %edx,-0x20(%rbp,%rax,4)\naddl   $0x1,-0x30(%rbp)\ncmpl   $0x3,-0x30(%rbp)\njle    1b98 <score_position+0x196>\nmov    -0x6c(%rbp),%edx\nlea    -0x20(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1926 <evaluate_window>\nadd    %eax,-0x5c(%rbp)\naddl   $0x1,-0x34(%rbp)\ncmpl   $0x3,-0x34(%rbp)\njle    1b8f <score_position+0x18d>\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x5,-0x38(%rbp)\njle    1b86 <score_position+0x184>\nmovl   $0x0,-0x2c(%rbp)\njmp    1c81 <score_position+0x27f>\nmovl   $0x0,-0x28(%rbp)\njmp    1c77 <score_position+0x275>\nmovl   $0x0,-0x24(%rbp)\njmp    1c59 <score_position+0x257>\nmov    -0x2c(%rbp),%edx\nmov    -0x24(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%ecx\nmov    -0x24(%rbp),%eax\nadd    %ecx,%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0x24(%rbp),%eax\ncltq\nmov    %edx,-0x20(%rbp,%rax,4)\naddl   $0x1,-0x24(%rbp)\ncmpl   $0x3,-0x24(%rbp)\njle    1c1c <score_position+0x21a>\nmov    -0x6c(%rbp),%edx\nlea    -0x20(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1926 <evaluate_window>\nadd    %eax,-0x5c(%rbp)\naddl   $0x1,-0x28(%rbp)\ncmpl   $0x3,-0x28(%rbp)\njle    1c13 <score_position+0x211>\naddl   $0x1,-0x2c(%rbp)\ncmpl   $0x2,-0x2c(%rbp)\njle    1c0a <score_position+0x208>\nmov    -0x5c(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1c9e <score_position+0x29c>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "terminal_score", "content": "// Check if terminal state has been reached and return a score.\n// If player wins, return WIN_SCORE; if opponent wins, return LOSS_SCORE; if draw return 0.\nint terminal_score(int board[ROWS][COLS], int player) {\n    int opp = (player == 1) ? 2 : 1;\n    if (check_win(board, player))\n        return WIN_SCORE;\n    if (check_win(board, opp))\n        return LOSS_SCORE;\n    return 0;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "terminal_score", "address": "0x1ca0", "label": "terminal_score", "content": "int __cdecl terminal_score(int (*board)[7], int player)\n{\n  int v2; // eax\n  int opp; // [rsp+1Ch] [rbp-4h]\n\n  if ( player == 1 )\n    v2 = 2;\n  else\n    v2 = 1;\n  opp = v2;\n  if ( check_win(board, player) )\n    return 100000;\n  if ( check_win(board, opp) )\n    return -100000;\n  return 0;\n}\n"}, "pseudo_normalize": "int terminal_score(int (*board)[7], int player) {\n  int v2;\n  int opp;\n  if (player == 1)\n    v2 = 2;\n  else\n    v2 = 1;\n  opp = v2;\n  if (check_win(board, player)) return 100000;\n  if (check_win(board, opp)) return -100000;\n  return 0;\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<terminal_score>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0x1,-0x1c(%rbp)\njne    1cc0 <terminal_score+0x20>\nmov    $0x2,%eax\njmp    1cc5 <terminal_score+0x25>\nmov    $0x1,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1533 <check_win>\ntest   %eax,%eax\nje     1ce4 <terminal_score+0x44>\nmov    $0x186a0,%eax\njmp    1d05 <terminal_score+0x65>\nmov    -0x4(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1533 <check_win>\ntest   %eax,%eax\nje     1d00 <terminal_score+0x60>\nmov    $0xfffe7960,%eax\njmp    1d05 <terminal_score+0x65>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "undo_move", "content": "// Undo a move in the given column (remove the top piece).\nvoid undo_move(int board[ROWS][COLS], int col) {\n    for (int r = 0; r < ROWS; r++) {\n        if (board[r][col] != EMPTY) {\n            board[r][col] = EMPTY;\n            break;\n        }\n    }\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "undo_move", "address": "0x1471", "label": "undo_move", "content": "void __cdecl undo_move(int (*board)[7], int col)\n{\n  int r; // [rsp+18h] [rbp-4h]\n\n  for ( r = 0; r <= 5; ++r )\n  {\n    if ( (*board)[7 * r + col] )\n    {\n      (*board)[7 * r + col] = 0;\n      return;\n    }\n  }\n}\n"}, "pseudo_normalize": "void undo_move(int (*board)[7], int col) {\n  int r;\n  for (r = 0; r <= 5; ++r) {\n    if ((*board)[7 * r + col]) {\n      (*board)[7 * r + col] = 0;\n      return;\n    }\n  }\n}", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<undo_move>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    14e3 <undo_move+0x72>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\nje     14df <undo_move+0x6e>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmovl   $0x0,(%rdx,%rax,4)\njmp    14ea <undo_move+0x79>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x5,-0x4(%rbp)\njle    1489 <undo_move+0x18>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "valid_move", "content": "// Returns 1 if the column is not full.\nint valid_move(int board[ROWS][COLS], int col) {\n    return board[0][col] == EMPTY;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O0.pseudo", "function_name": "valid_move", "address": "0x137e", "label": "valid_move", "content": "int __cdecl valid_move(int (*board)[7], int col)\n{\n  return (*board)[col] == 0;\n}\n"}, "pseudo_normalize": "", "binary": "connect4-minimax/connect4-minimax.host.O0", "assembly": "<valid_move>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    (%rax,%rdx,4),%eax\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\npop    %rbp\nret\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "comparePoints", "content": "// Comparator for sorting points with respect to global pivot p0.\n// Returns a negative number if a comes before b (i.e. a has a smaller polar angle),\n// zero if they are collinear (in which case the closer one comes first),\n// and a positive number otherwise.\nint comparePoints(Point a, Point b) {\n    int o = orientation(p0, a, b);\n    if (o == 0) {\n        // Collinear; sort by distance to p0.\n        return distanceSq(p0, a) - distanceSq(p0, b);\n    }\n    // If a is counterclockwise to b then a comes first.\n    return (o < 0) ? -1 : 1;\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O0.pseudo", "function_name": "comparePoints", "address": "0x1285", "label": "comparePoints", "content": "int __cdecl comparePoints(Point a, Point b)\n{\n  Point v4; // rdi\n  Point v5; // rsi\n  Point v6; // rdi\n  int v7; // ebx\n  Point v8; // rsi\n  Point v9; // rdi\n  int o; // [rsp+1Ch] [rbp-Ch]\n\n  v4 = p0;\n  o = orientation(v4, a, b);\n  if ( o )\n  {\n    if ( o >= 0 )\n      return 1;\n    else\n      return -1;\n  }\n  else\n  {\n    v5 = a;\n    v6 = p0;\n    v7 = distanceSq(v6, v5);\n    v8 = b;\n    v9 = p0;\n    return v7 - distanceSq(v9, v8);\n  }\n}\n"}, "pseudo_normalize": "int comparePoints(Point a, Point b) {\n  Point v4;\n  Point v5;\n  Point v6;\n  int v7;\n  Point v8;\n  Point v9;\n  int o;\n  v4 = p0;\n  o = orientation(v4, a, b);\n  if (o) {\n    if (o >= 0)\n      return 1;\n    else\n      return -1;\n  } else {\n    v5 = a;\n    v6 = p0;\n    v7 = distanceSq(v6, v5);\n    v8 = b;\n    v9 = p0;\n    return v7 - distanceSq(v9, v8);\n  }\n}", "binary": "convex-hull/convex-hull.host.O0", "assembly": "<comparePoints>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x20,%rsp\nmov    %rdi,-0x20(%rbp)\nmov    %rsi,-0x28(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    0x4fc7(%rip),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <orientation>\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njne    12f3 <comparePoints+0x6e>\nmov    -0x20(%rbp),%rdx\nmov    0x4fa8(%rip),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   124d <distanceSq>\nmov    %eax,%ebx\nmov    -0x28(%rbp),%rdx\nmov    0x4f90(%rip),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   124d <distanceSq>\nmov    %eax,%edx\nmov    %ebx,%eax\nsub    %edx,%eax\njmp    1305 <comparePoints+0x80>\ncmpl   $0x0,-0xc(%rbp)\njns    1300 <comparePoints+0x7b>\nmov    $0xffffffff,%eax\njmp    1305 <comparePoints+0x80>\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "distanceSq", "content": "// Computes the squared Euclidean distance between points p and q.\nint distanceSq(Point p, Point q) {\n    int dx = q.x - p.x;\n    int dy = q.y - p.y;\n    return dx * dx + dy * dy;\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O0.pseudo", "function_name": "distanceSq", "address": "0x124d", "label": "distanceSq", "content": "int __cdecl distanceSq(Point p, Point q)\n{\n  return (q.x - p.x) * (q.x - p.x) + (q.y - p.y) * (q.y - p.y);\n}\n"}, "pseudo_normalize": "", "binary": "convex-hull/convex-hull.host.O0", "assembly": "<distanceSq>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmov    -0x18(%rbp),%edx\nsub    %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    -0x14(%rbp),%edx\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\nimul   %eax,%eax\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\nadd    %edx,%eax\npop    %rbp\nret\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "main", "content": "int main() {\n    // Seed the random number generator with a fixed value for reproducibility.\n    libmin_srand(42);\n\n    // Generate a set of random points.\n    Point points[NUM_POINTS];\n    for (int i = 0; i < NUM_POINTS; i++) {\n        points[i].x = libmin_rand() % 101;  // x in range [0, 100]\n        points[i].y = libmin_rand() % 101;  // y in range [0, 100]\n    }\n\n    // Find the pivot: the point with the lowest y-coordinate.\n    // On a tie, choose the point with the lowest x-coordinate.\n    int minIdx = 0;\n    for (int i = 1; i < NUM_POINTS; i++) {\n        if (points[i].y < points[minIdx].y ||\n           (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {\n            minIdx = i;\n        }\n    }\n    // Swap the pivot with the first element.\n    Point temp = points[0];\n    points[0] = points[minIdx];\n    points[minIdx] = temp;\n    p0 = points[0];  // Set the global pivot.\n\n    // Sort the remaining points according to the polar angle relative to p0.\n    sortPoints(points, NUM_POINTS);\n\n    // Allocate an array to store the convex hull points.\n    Point hull[NUM_POINTS];\n    int hullSize = 0;\n\n    // Apply the Graham scan: iterate through all points.\n    for (int i = 0; i < NUM_POINTS; i++) {\n        // While the last two points in the hull and the current point do not make\n        // a counterclockwise turn, remove the top of the hull.\n        while (hullSize >= 2 &&\n               orientation(hull[hullSize - 2], hull[hullSize - 1], points[i]) <= 0) {\n            hullSize--;  // Pop the last point.\n        }\n        hull[hullSize++] = points[i];  // Push the current point.\n    }\n\n    // Print the convex hull result.\n    libmin_printf(\"Convex Hull Points (in order):\\n\");\n    for (int i = 0; i < hullSize; i++) {\n        libmin_printf(\"(%d, %d)\\n\", hull[i].x, hull[i].y);\n    }\n\n    // Optionally, compute a checksum (sum of coordinates) and print hull size.\n    int checksum = 0;\n    for (int i = 0; i < hullSize; i++) {\n        checksum += hull[i].x + hull[i].y;\n    }\n    libmin_printf(\"Hull size: %d, Checksum: %d\\n\", hullSize, checksum);\n\n    libtarg_success();\n    return 0;\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O0.pseudo", "function_name": "main", "address": "0x13e7", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  Point v3; // rdx\n  Point v4; // rsi\n  Point v5; // rdi\n  int v6; // eax\n  int i; // [rsp+8h] [rbp-358h]\n  int minIdx; // [rsp+Ch] [rbp-354h]\n  int i_0; // [rsp+10h] [rbp-350h]\n  int hullSize; // [rsp+14h] [rbp-34Ch]\n  int i_1; // [rsp+18h] [rbp-348h]\n  int i_2; // [rsp+1Ch] [rbp-344h]\n  int checksum; // [rsp+20h] [rbp-340h]\n  int i_3; // [rsp+24h] [rbp-33Ch]\n  Point temp; // [rsp+28h] [rbp-338h]\n  Point points[50]; // [rsp+30h] [rbp-330h] BYREF\n  Point hull[50]; // [rsp+1C0h] [rbp-1A0h]\n  unsigned __int64 v19; // [rsp+358h] [rbp-8h]\n\n  v19 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  for ( i = 0; i <= 49; ++i )\n  {\n    points[i].x = libmin_rand() % 0x65;\n    points[i].y = libmin_rand() % 0x65;\n  }\n  minIdx = 0;\n  for ( i_0 = 1; i_0 <= 49; ++i_0 )\n  {\n    if ( points[i_0].y < points[minIdx].y || points[i_0].y == points[minIdx].y && points[i_0].x < points[minIdx].x )\n      minIdx = i_0;\n  }\n  temp = points[0];\n  points[0] = points[minIdx];\n  points[minIdx] = temp;\n  p0 = points[0];\n  sortPoints(points, 50);\n  hullSize = 0;\n  for ( i_1 = 0; i_1 <= 49; ++i_1 )\n  {\n    while ( hullSize > 1 )\n    {\n      v3 = points[i_1];\n      v4 = hull[hullSize - 1];\n      v5 = hull[hullSize - 2];\n      if ( orientation(v5, v4, v3) > 0 )\n        break;\n      --hullSize;\n    }\n    v6 = hullSize++;\n    hull[v6] = points[i_1];\n  }\n  libmin_printf(\"Convex Hull Points (in order):\\n\");\n  for ( i_2 = 0; i_2 < hullSize; ++i_2 )\n    libmin_printf(\"(%d, %d)\\n\", hull[i_2].x, hull[i_2].y);\n  checksum = 0;\n  for ( i_3 = 0; i_3 < hullSize; ++i_3 )\n    checksum += hull[i_3].x + hull[i_3].y;\n  libmin_printf(\"Hull size: %d, Checksum: %d\\n\", hullSize, checksum);\n  libtarg_success();\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  Point v3;\n  Point v4;\n  Point v5;\n  int v6;\n  int i;\n  int minIdx;\n  int i_0;\n  int hullSize;\n  int i_1;\n  int i_2;\n  int checksum;\n  int i_3;\n  Point temp;\n  Point points[50];\n  Point hull[50];\n  unsigned long long v19;\n  v19 = __readfsqword(40u);\n  libmin_srand(42u);\n  for (i = 0; i <= 49; ++i) {\n    points[i].x = libmin_rand() % 101;\n    points[i].y = libmin_rand() % 101;\n  }\n  minIdx = 0;\n  for (i_0 = 1; i_0 <= 49; ++i_0) {\n    if (points[i_0].y < points[minIdx].y ||\n        points[i_0].y == points[minIdx].y && points[i_0].x < points[minIdx].x)\n      minIdx = i_0;\n  }\n  temp = points[0];\n  points[0] = points[minIdx];\n  points[minIdx] = temp;\n  p0 = points[0];\n  sortPoints(points, 50);\n  hullSize = 0;\n  for (i_1 = 0; i_1 <= 49; ++i_1) {\n    while (hullSize > 1) {\n      v3 = points[i_1];\n      v4 = hull[hullSize - 1];\n      v5 = hull[hullSize - 2];\n      if (orientation(v5, v4, v3) > 0) break;\n      --hullSize;\n    }\n    v6 = hullSize++;\n    hull[v6] = points[i_1];\n  }\n  libmin_printf(\"Convex Hull Points (in order):\\n\");\n  for (i_2 = 0; i_2 < hullSize; ++i_2)\n    libmin_printf(\"(%d, %d)\\n\", hull[i_2].x, hull[i_2].y);\n  checksum = 0;\n  for (i_3 = 0; i_3 < hullSize; ++i_3) checksum += hull[i_3].x + hull[i_3].y;\n  libmin_printf(\"Hull size: %d, Checksum: %d\\n\", hullSize, checksum);\n  libtarg_success();\n}", "binary": "convex-hull/convex-hull.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x360,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x2a,%edi\ncall   3a97 <libmin_srand>\nmovl   $0x0,-0x358(%rbp)\njmp    1496 <main+0xaf>\ncall   3b49 <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x446f8657,%rax,%rax\nshr    $0x20,%rax\nmov    %rax,%rcx\nmov    %edx,%eax\nsub    %ecx,%eax\nshr    %eax\nadd    %ecx,%eax\nshr    $0x6,%eax\nimul   $0x65,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    -0x358(%rbp),%eax\ncltq\nmov    %edx,-0x330(%rbp,%rax,8)\ncall   3b49 <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x446f8657,%rax,%rax\nshr    $0x20,%rax\nmov    %rax,%rcx\nmov    %edx,%eax\nsub    %ecx,%eax\nshr    %eax\nadd    %ecx,%eax\nshr    $0x6,%eax\nimul   $0x65,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    -0x358(%rbp),%eax\ncltq\nmov    %edx,-0x32c(%rbp,%rax,8)\naddl   $0x1,-0x358(%rbp)\ncmpl   $0x31,-0x358(%rbp)\njle    141b <main+0x34>\nmovl   $0x0,-0x354(%rbp)\nmovl   $0x1,-0x350(%rbp)\njmp    1532 <main+0x14b>\nmov    -0x350(%rbp),%eax\ncltq\nmov    -0x32c(%rbp,%rax,8),%edx\nmov    -0x354(%rbp),%eax\ncltq\nmov    -0x32c(%rbp,%rax,8),%eax\ncmp    %eax,%edx\njl     151f <main+0x138>\nmov    -0x350(%rbp),%eax\ncltq\nmov    -0x32c(%rbp,%rax,8),%edx\nmov    -0x354(%rbp),%eax\ncltq\nmov    -0x32c(%rbp,%rax,8),%eax\ncmp    %eax,%edx\njne    152b <main+0x144>\nmov    -0x350(%rbp),%eax\ncltq\nmov    -0x330(%rbp,%rax,8),%edx\nmov    -0x354(%rbp),%eax\ncltq\nmov    -0x330(%rbp,%rax,8),%eax\ncmp    %eax,%edx\njge    152b <main+0x144>\nmov    -0x350(%rbp),%eax\nmov    %eax,-0x354(%rbp)\naddl   $0x1,-0x350(%rbp)\ncmpl   $0x31,-0x350(%rbp)\njle    14b9 <main+0xd2>\nmov    -0x330(%rbp),%rax\nmov    %rax,-0x338(%rbp)\nmov    -0x354(%rbp),%eax\ncltq\nmov    -0x330(%rbp,%rax,8),%rax\nmov    %rax,-0x330(%rbp)\nmov    -0x354(%rbp),%eax\ncltq\nmov    -0x338(%rbp),%rdx\nmov    %rdx,-0x330(%rbp,%rax,8)\nmov    -0x330(%rbp),%rax\nmov    %rax,0x4ce7(%rip)\nlea    -0x330(%rbp),%rax\nmov    $0x32,%esi\nmov    %rax,%rdi\ncall   130b <sortPoints>\nmovl   $0x0,-0x34c(%rbp)\nmovl   $0x0,-0x348(%rbp)\njmp    163e <main+0x257>\nsubl   $0x1,-0x34c(%rbp)\ncmpl   $0x1,-0x34c(%rbp)\njle    160d <main+0x226>\nmov    -0x34c(%rbp),%eax\nlea    -0x1(%rax),%ecx\nmov    -0x34c(%rbp),%eax\nlea    -0x2(%rax),%esi\nmov    -0x348(%rbp),%eax\ncltq\nmov    -0x330(%rbp,%rax,8),%rdx\nmovslq %ecx,%rax\nmov    -0x1a0(%rbp,%rax,8),%rcx\nmovslq %esi,%rax\nmov    -0x1a0(%rbp,%rax,8),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <orientation>\ntest   %eax,%eax\njle    15b6 <main+0x1cf>\nmov    -0x34c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x34c(%rbp)\ncltq\nmov    -0x348(%rbp),%edx\nmovslq %edx,%rdx\nmov    -0x330(%rbp,%rdx,8),%rdx\nmov    %rdx,-0x1a0(%rbp,%rax,8)\naddl   $0x1,-0x348(%rbp)\ncmpl   $0x31,-0x348(%rbp)\njle    15bd <main+0x1d6>\nlea    0x29b6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3868 <libmin_printf>\nmovl   $0x0,-0x344(%rbp)\njmp    16a6 <main+0x2bf>\nmov    -0x344(%rbp),%eax\ncltq\nmov    -0x19c(%rbp,%rax,8),%edx\nmov    -0x344(%rbp),%eax\ncltq\nmov    -0x1a0(%rbp,%rax,8),%eax\nmov    %eax,%esi\nlea    0x2996(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3868 <libmin_printf>\naddl   $0x1,-0x344(%rbp)\nmov    -0x344(%rbp),%eax\ncmp    -0x34c(%rbp),%eax\njl     166b <main+0x284>\nmovl   $0x0,-0x340(%rbp)\nmovl   $0x0,-0x33c(%rbp)\njmp    16f7 <main+0x310>\nmov    -0x33c(%rbp),%eax\ncltq\nmov    -0x1a0(%rbp,%rax,8),%edx\nmov    -0x33c(%rbp),%eax\ncltq\nmov    -0x19c(%rbp,%rax,8),%eax\nadd    %edx,%eax\nadd    %eax,-0x340(%rbp)\naddl   $0x1,-0x33c(%rbp)\nmov    -0x33c(%rbp),%eax\ncmp    -0x34c(%rbp),%eax\njl     16ca <main+0x2e3>\nmov    -0x340(%rbp),%edx\nmov    -0x34c(%rbp),%eax\nmov    %eax,%esi\nlea    0x2918(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3868 <libmin_printf>\ncall   172c <libtarg_success>\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "orientation", "content": "// Returns the orientation of the triplet (p, q, r).\n//  0  : p, q, r are collinear\n// -1  : counterclockwise turn (left turn)\n//  1  : clockwise turn (right turn)\nint orientation(Point p, Point q, Point r) {\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0)\n        return 0;\n    return (val > 0) ? 1 : -1;\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O0.pseudo", "function_name": "orientation", "address": "0x11e9", "label": "orientation", "content": "int __cdecl orientation(Point p, Point q, Point r)\n{\n  int val; // [rsp+24h] [rbp-4h]\n\n  val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n  if ( !val )\n    return 0;\n  if ( val <= 0 )\n    return -1;\n  return 1;\n}\n"}, "pseudo_normalize": "int orientation(Point p, Point q, Point r) {\n  int val;\n  val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n  if (!val) return 0;\n  if (val <= 0) return -1;\n  return 1;\n}", "binary": "convex-hull/convex-hull.host.O0", "assembly": "<orientation>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    -0x14(%rbp),%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    -0x28(%rbp),%eax\nmov    -0x20(%rbp),%ecx\nsub    %ecx,%eax\nimul   %edx,%eax\nmov    -0x20(%rbp),%edx\nmov    -0x18(%rbp),%esi\nmov    %edx,%ecx\nsub    %esi,%ecx\nmov    -0x24(%rbp),%edx\nmov    -0x1c(%rbp),%esi\nsub    %esi,%edx\nimul   %ecx,%edx\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    1239 <orientation+0x50>\nmov    $0x0,%eax\njmp    124b <orientation+0x62>\ncmpl   $0x0,-0x4(%rbp)\njle    1246 <orientation+0x5d>\nmov    $0x1,%eax\njmp    124b <orientation+0x62>\nmov    $0xffffffff,%eax\npop    %rbp\nret\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "sortPoints", "content": "// A simple insertion sort for an array of Points.\nvoid sortPoints(Point points[], int n) {\n    for (int i = 1; i < n; i++) {\n        Point key = points[i];\n        int j = i - 1;\n        while (j >= 0 && comparePoints(points[j], key) > 0) {\n            points[j + 1] = points[j];\n            j--;\n        }\n        points[j + 1] = key;\n    }\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O0.pseudo", "function_name": "sortPoints", "address": "0x130b", "label": "sortPoints", "content": "void __cdecl sortPoints(Point *points, int n)\n{\n  Point v2; // rsi\n  Point v3; // rdi\n  int i; // [rsp+10h] [rbp-10h]\n  int j; // [rsp+14h] [rbp-Ch]\n  Point key; // [rsp+18h] [rbp-8h]\n\n  for ( i = 1; i < n; ++i )\n  {\n    key = points[i];\n    for ( j = i - 1; j >= 0; --j )\n    {\n      v2 = key;\n      v3 = points[j];\n      if ( comparePoints(v3, v2) <= 0 )\n        break;\n      points[j + 1] = points[j];\n    }\n    points[j + 1] = key;\n  }\n}\n"}, "pseudo_normalize": "void sortPoints(Point *points, int n) {\n  Point v2;\n  Point v3;\n  int i;\n  int j;\n  Point key;\n  for (i = 1; i < n; ++i) {\n    key = points[i];\n    for (j = i - 1; j >= 0; --j) {\n      v2 = key;\n      v3 = points[j];\n      if (comparePoints(v3, v2) <= 0) break;\n      points[j + 1] = points[j];\n    }\n    points[j + 1] = key;\n  }\n}", "binary": "convex-hull/convex-hull.host.O0", "assembly": "<sortPoints>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x1,-0x10(%rbp)\njmp    13d7 <sortPoints+0xcc>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmp    1387 <sortPoints+0x7c>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\nsubl   $0x1,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njs     13b4 <sortPoints+0xa9>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rsi\nmov    (%rdx),%rdi\ncall   1285 <comparePoints>\ntest   %eax,%eax\njg     1350 <sortPoints+0x45>\nmov    -0xc(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     132a <sortPoints+0x1f>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PFunc_1", "content": " /* PProc_8 */\n\n\nEnumeration PFunc_1 (Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val)\n/*************************************************/\n    /* executed three times                                         */\n    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */\n    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */\n    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */\n{\n  Capital_Letter        Ch_1_Loc;\n  Capital_Letter        Ch_2_Loc;\n\n  Ch_1_Loc = Ch_1_Par_Val;\n  Ch_2_Loc = Ch_1_Loc;\n  if (Ch_2_Loc != Ch_2_Par_Val)\n    /* then, executed */\n    return (Ident_1);\n  else  /* not executed */\n     {\n     Ch_1_Glob = Ch_1_Loc;\n     return (Ident_2);\n     }\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O0.pseudo", "function_name": "PFunc_1", "address": "0x1e50", "label": "PFunc_1", "content": "Enumeration __cdecl PFunc_1(Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val)\n{\n  if ( Ch_1_Par_Val != Ch_2_Par_Val )\n    return 0;\n  Ch_1_Glob[0] = Ch_1_Par_Val;\n  return 1;\n}\n"}, "pseudo_normalize": "", "binary": "dhrystone/dhrystone.host.O0", "assembly": "<PFunc_1>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%edx\nmov    %esi,%eax\nmov    %dl,-0x14(%rbp)\nmov    %al,-0x18(%rbp)\nmovzbl -0x14(%rbp),%eax\nmov    %al,-0x2(%rbp)\nmovzbl -0x2(%rbp),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\ncmp    -0x18(%rbp),%al\nje     1e80 <PFunc_1+0x30>\nmov    $0x0,%eax\njmp    1e8f <PFunc_1+0x3f>\nmovzbl -0x2(%rbp),%eax\nmov    %al,0x53fa(%rip)\nmov    $0x1,%eax\npop    %rbp\nret\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PFunc_2", "content": " /* PFunc_1 */\n\n\nBoolean PFunc_2 (Str_30 Str_1_Par_Ref, Str_30 Str_2_Par_Ref)\n/*************************************************/\n    /* executed once */\n    /* Str_1_Par_Ref == \"DHRYSTONE PROGRAM, 1'ST STRING\" */\n    /* Str_2_Par_Ref == \"DHRYSTONE PROGRAM, 2'ND STRING\" */\n{\n  REG One_Thirty        Int_Loc;\n      Capital_Letter    Ch_Loc = 0;\n\n  Int_Loc = 2;\n  while (Int_Loc <= 2) /* loop body executed once */\n    if (PFunc_1 (Str_1_Par_Ref[Int_Loc], Str_2_Par_Ref[Int_Loc+1]) == Ident_1)\n      /* then, executed */\n       {\n       Ch_Loc = 'A';\n       Int_Loc += 1;\n       } /* if, while */\n  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')\n    /* then, not executed */\n    Int_Loc = 7;\n  if (Ch_Loc == 'R')\n    /* then, not executed */\n    return (true);\n  else /* executed */\n     {\n     if (libmin_strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)\n      /* then, not executed */\n        {\n        Int_Loc += 7;\n        Int_Glob = Int_Loc;\n        return (true);\n        }\n     else /* executed */\n        return (false);\n     } /* if Ch_Loc */\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O0.pseudo", "function_name": "PFunc_2", "address": "0x1e91", "label": "PFunc_2", "content": "Boolean __cdecl PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref)\n{\n  One_Thirty Int_Loc; // [rsp+1Ch] [rbp-4h]\n\n  Int_Loc = 2;\n  while ( Int_Loc <= 2 )\n  {\n    if ( PFunc_1(Str_1_Par_Ref[Int_Loc], Str_2_Par_Ref[Int_Loc + 1]) == Ident_1 )\n      ++Int_Loc;\n  }\n  if ( libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref) <= 0 )\n    return 0;\n  Int_Glob = Int_Loc + 7;\n  return 1;\n}\n"}, "pseudo_normalize": "Boolean PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref) {\n  One_Thirty Int_Loc;\n  Int_Loc = 2;\n  while (Int_Loc <= 2) {\n    if (PFunc_1(Str_1_Par_Ref[Int_Loc], Str_2_Par_Ref[Int_Loc + 1]) == Ident_1)\n      ++Int_Loc;\n  }\n  if (libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref) <= 0) return 0;\n  Int_Glob = Int_Loc + 7;\n  return 1;\n}", "binary": "dhrystone/dhrystone.host.O0", "assembly": "<PFunc_2>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovb   $0x0,-0x5(%rbp)\nmovl   $0x2,-0x4(%rbp)\njmp    1ef0 <PFunc_2+0x5f>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1e50 <PFunc_1>\ntest   %eax,%eax\njne    1ef0 <PFunc_2+0x5f>\nmovb   $0x41,-0x5(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x2,-0x4(%rbp)\njle    1eb2 <PFunc_2+0x21>\ncmpb   $0x56,-0x5(%rbp)\njle    1f09 <PFunc_2+0x78>\ncmpb   $0x59,-0x5(%rbp)\njg     1f09 <PFunc_2+0x78>\nmovl   $0x7,-0x4(%rbp)\ncmpb   $0x52,-0x5(%rbp)\njne    1f16 <PFunc_2+0x85>\nmov    $0x1,%eax\njmp    1f46 <PFunc_2+0xb5>\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   42d8 <libmin_strcmp>\ntest   %eax,%eax\njle    1f41 <PFunc_2+0xb0>\naddl   $0x7,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,0x5346(%rip)\nmov    $0x1,%eax\njmp    1f46 <PFunc_2+0xb5>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PFunc_3", "content": " /* PFunc_2 */\n\n\nBoolean PFunc_3 (Enumeration Enum_Par_Val)\n/***************************/\n    /* executed once        */\n    /* Enum_Par_Val == Ident_3 */\n{\n  Enumeration Enum_Loc;\n\n  Enum_Loc = Enum_Par_Val;\n  if (Enum_Loc == Ident_3)\n    /* then, executed */\n    return (true);\n  else /* not executed */\n    return (false);\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O0.pseudo", "function_name": "PFunc_3", "address": "0x1f48", "label": "PFunc_3", "content": "Boolean __cdecl PFunc_3(Enumeration Enum_Par_Val)\n{\n  return Enum_Par_Val == Ident_3;\n}\n"}, "pseudo_normalize": "", "binary": "dhrystone/dhrystone.host.O0", "assembly": "<PFunc_3>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x2,-0x4(%rbp)\njne    1f66 <PFunc_3+0x1e>\nmov    $0x1,%eax\njmp    1f6b <PFunc_3+0x23>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PProc_6", "content": "int\nPProc_6 (Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par)\n/*********************************/\n    /* executed once */\n    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */\n{\n  *Enum_Ref_Par = Enum_Val_Par;\n  if (! PFunc_3 (Enum_Val_Par))\n    /* then, not executed */\n    *Enum_Ref_Par = Ident_4;\n  switch (Enum_Val_Par)\n     {\n     case Ident_1:\n        *Enum_Ref_Par = Ident_1;\n        break;\n     case Ident_2:\n        if (Int_Glob > 100)\n           /* then */\n           *Enum_Ref_Par = Ident_1;\n        else\n           *Enum_Ref_Par = Ident_4;\n        break;\n     case Ident_3: /* executed */\n        *Enum_Ref_Par = Ident_2;\n        break;\n     case Ident_4:\n        break;\n     case Ident_5:\n        *Enum_Ref_Par = Ident_3;\n        break;\n     } /* switch */\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O0.pseudo", "function_name": "PProc_6", "address": "0x1bd8", "label": "PProc_6", "content": "int __cdecl PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par)\n{\n  *Enum_Ref_Par = Enum_Val_Par;\n  if ( !PFunc_3(Enum_Val_Par) )\n    *Enum_Ref_Par = Ident_4;\n  switch ( Enum_Val_Par )\n  {\n    case Ident_1:\n      *Enum_Ref_Par = Ident_1;\n      break;\n    case Ident_2:\n      if ( Int_Glob <= 100 )\n        *Enum_Ref_Par = Ident_4;\n      else\n        *Enum_Ref_Par = Ident_1;\n      break;\n    case Ident_3:\n      *Enum_Ref_Par = Ident_2;\n      break;\n    case Ident_5:\n      *Enum_Ref_Par = Ident_3;\n      break;\n    default:\n      return 0;\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par) {\n  *Enum_Ref_Par = Enum_Val_Par;\n  if (!PFunc_3(Enum_Val_Par)) *Enum_Ref_Par = Ident_4;\n  switch (Enum_Val_Par) {\n    case Ident_1:\n      *Enum_Ref_Par = Ident_1;\n      break;\n    case Ident_2:\n      if (Int_Glob <= 100)\n        *Enum_Ref_Par = Ident_4;\n      else\n        *Enum_Ref_Par = Ident_1;\n      break;\n    case Ident_3:\n      *Enum_Ref_Par = Ident_2;\n      break;\n    case Ident_5:\n      *Enum_Ref_Par = Ident_3;\n      break;\n    default:\n      return 0;\n  }\n  return 0;\n}", "binary": "dhrystone/dhrystone.host.O0", "assembly": "<PProc_6>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   1f48 <PFunc_3>\ntest   %eax,%eax\njne    1c0c <PProc_6+0x34>\nmov    -0x10(%rbp),%rax\nmovl   $0x3,(%rax)\ncmpl   $0x4,-0x4(%rbp)\nja     1c7e <PProc_6+0xa6>\nmov    -0x4(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x3874(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x3868(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x10(%rbp),%rax\nmovl   $0x0,(%rax)\njmp    1c7e <PProc_6+0xa6>\nmov    0x5638(%rip),%eax\ncmp    $0x64,%eax\njle    1c59 <PProc_6+0x81>\nmov    -0x10(%rbp),%rax\nmovl   $0x0,(%rax)\njmp    1c7e <PProc_6+0xa6>\nmov    -0x10(%rbp),%rax\nmovl   $0x3,(%rax)\njmp    1c7e <PProc_6+0xa6>\nmov    -0x10(%rbp),%rax\nmovl   $0x1,(%rax)\njmp    1c7e <PProc_6+0xa6>\nmov    -0x10(%rbp),%rax\nmovl   $0x2,(%rax)\njmp    1c7e <PProc_6+0xa6>\nnop\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PProc_7", "content": " /* PProc_6 */\n\n\nint\nPProc_7 (int Int_1_Par_Val, int Int_2_Par_Val, int *Int_Par_Ref)\n/**********************************************/\n    /* executed three times                                      */\n    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */\n    /*                  Int_Par_Ref becomes 7                    */\n    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */\n    /*                  Int_Par_Ref becomes 17                   */\n    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */\n    /*                  Int_Par_Ref becomes 18                   */\n{\n  One_Fifty Int_Loc;\n\n  Int_Loc = Int_1_Par_Val + 2;\n  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O0.pseudo", "function_name": "PProc_7", "address": "0x1c85", "label": "PProc_7", "content": "int __cdecl PProc_7(int Int_1_Par_Val, int Int_2_Par_Val, int *Int_Par_Ref)\n{\n  *Int_Par_Ref = Int_1_Par_Val + 2 + Int_2_Par_Val;\n  return 0;\n}\n"}, "pseudo_normalize": "", "binary": "dhrystone/dhrystone.host.O0", "assembly": "<PProc_7>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %rdx,-0x20(%rbp)\nmov    -0x14(%rbp),%eax\nadd    $0x2,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x4(%rbp),%eax\nadd    %eax,%edx\nmov    -0x20(%rbp),%rax\nmov    %edx,(%rax)\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PProc_8", "content": " /* PProc_7 */\n\n\nint PProc_8 (Arr_1_Dim Arr_1_Par_Ref,\n             Arr_2_Dim Arr_2_Par_Ref,\n             int Int_1_Par_Val,\n             int Int_2_Par_Val)\n/*********************************************************************/\n    /* executed once      */\n    /* Int_Par_Val_1 == 3 */\n    /* Int_Par_Val_2 == 7 */\n{\n  REG One_Fifty Int_Index;\n  REG One_Fifty Int_Loc;\n\n  Int_Loc = Int_1_Par_Val + 5;\n  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;\n  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];\n  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;\n  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)\n     Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;\n  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;\n  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];\n  Int_Glob = 5;\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O0.pseudo", "function_name": "PProc_8", "address": "0x1cb5", "label": "PProc_8", "content": "int __cdecl PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val, int Int_2_Par_Val)\n{\n  One_Fifty Int_Index; // [rsp+20h] [rbp-8h]\n  One_Fifty Int_Loc; // [rsp+24h] [rbp-4h]\n\n  Int_Loc = Int_1_Par_Val + 5;\n  Arr_1_Par_Ref[Int_1_Par_Val + 5] = Int_2_Par_Val;\n  Arr_1_Par_Ref[Int_1_Par_Val + 6] = Arr_1_Par_Ref[Int_1_Par_Val + 5];\n  Arr_1_Par_Ref[Int_1_Par_Val + 35] = Int_1_Par_Val + 5;\n  for ( Int_Index = Int_1_Par_Val + 5; Int_Index <= Int_1_Par_Val + 6; ++Int_Index )\n    (*Arr_2_Par_Ref)[50 * Int_Loc + Int_Index] = Int_Loc;\n  ++(*Arr_2_Par_Ref)[50 * Int_1_Par_Val + 254 + Int_1_Par_Val];\n  (*Arr_2_Par_Ref)[50 * Int_Loc + 1000 + Int_Loc] = Arr_1_Par_Ref[Int_Loc];\n  Int_Glob = 5;\n  return 0;\n}\n"}, "pseudo_normalize": "int PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val,\n            int Int_2_Par_Val) {\n  One_Fifty Int_Index;\n  One_Fifty Int_Loc;\n  Int_Loc = Int_1_Par_Val + 5;\n  Arr_1_Par_Ref[Int_1_Par_Val + 5] = Int_2_Par_Val;\n  Arr_1_Par_Ref[Int_1_Par_Val + 6] = Arr_1_Par_Ref[Int_1_Par_Val + 5];\n  Arr_1_Par_Ref[Int_1_Par_Val + 35] = Int_1_Par_Val + 5;\n  for (Int_Index = Int_1_Par_Val + 5; Int_Index <= Int_1_Par_Val + 6;\n       ++Int_Index)\n    (*Arr_2_Par_Ref)[50 * Int_Loc + Int_Index] = Int_Loc;\n  ++(*Arr_2_Par_Ref)[50 * Int_1_Par_Val + 254 + Int_1_Par_Val];\n  (*Arr_2_Par_Ref)[50 * Int_Loc + 1000 + Int_Loc] = Arr_1_Par_Ref[Int_Loc];\n  Int_Glob = 5;\n  return 0;\n}", "binary": "dhrystone/dhrystone.host.O0", "assembly": "<PProc_8>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    %ecx,-0x28(%rbp)\nmov    -0x24(%rbp),%eax\nadd    $0x5,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x4(%rbp),%eax\ncltq\nadd    $0x1e,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x8(%rbp)\njmp    1d7c <PProc_8+0xc7>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\ncltq\nmov    -0x4(%rbp),%edx\nmov    %edx,(%rcx,%rax,4)\naddl   $0x1,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nadd    $0x1,%eax\ncmp    %eax,-0x8(%rbp)\njle    1d43 <PProc_8+0x8e>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    (%rdx,%rax,4),%ecx\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\nadd    $0x1,%ecx\ncltq\nmov    %ecx,(%rdx,%rax,4)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nlea    (%rdx,%rax,1),%rsi\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nadd    %rdx,%rax\nshl    $0x3,%rax\nlea    0xfa0(%rax),%rdx\nmov    -0x20(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    (%rsi),%edx\nmov    -0x4(%rbp),%eax\ncltq\nmov    %edx,(%rcx,%rax,4)\nmovl   $0x5,0x5437(%rip)\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "Proc_1", "content": "static int Proc_1 (Rec_Pointer Ptr_Val_Par)\n    /* executed once */\n{\n  REG Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;\n                                        /* == Ptr_Glob_Next */\n  /* Local variable, initialized with Ptr_Val_Par->Ptr_Comp,    */\n  /* corresponds to \"rename\" in Ada, \"with\" in Pascal           */\n\n  structassign (*Ptr_Val_Par->Ptr_Comp, *Ptr_Glob);\n  Ptr_Val_Par->variant.var_1.Int_Comp = 5;\n  Next_Record->variant.var_1.Int_Comp\n        = Ptr_Val_Par->variant.var_1.Int_Comp;\n  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  Proc_3 (&Next_Record->Ptr_Comp);\n    /* Ptr_Val_Par->Ptr_Comp->Ptr_Comp\n                        == Ptr_Glob->Ptr_Comp */\n  if (Next_Record->Discr == Ident_1)\n    /* then, executed */\n  {\n    Next_Record->variant.var_1.Int_Comp = 6;\n    PProc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp,\n           &Next_Record->variant.var_1.Enum_Comp);\n    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    PProc_7 (Next_Record->variant.var_1.Int_Comp, 10,\n           &Next_Record->variant.var_1.Int_Comp);\n  }\n  else /* not executed */\n    structassign (*Ptr_Val_Par, *Ptr_Val_Par->Ptr_Comp);\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O0.pseudo", "function_name": "Proc_1", "address": "0x199f", "label": "Proc_1", "content": "int __cdecl Proc_1(Rec_Pointer Ptr_Val_Par)\n{\n  Rec_Pointer v1; // rdx\n  record *Ptr_Comp; // rax\n  __int64 v3; // rbx\n  __int64 v4; // rbx\n  __int64 v5; // rbx\n  record *v6; // rdx\n  __int64 v7; // rbx\n  __int64 v8; // rbx\n  __int64 v9; // rbx\n  record *Next_Record; // [rsp+18h] [rbp-18h]\n\n  Next_Record = Ptr_Val_Par->Ptr_Comp;\n  v1 = Ptr_Glob;\n  Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  v3 = *(_QWORD *)&Ptr_Glob->Discr;\n  Ptr_Comp->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n  *(_QWORD *)&Ptr_Comp->Discr = v3;\n  v4 = *(_QWORD *)(&v1->variant.var_3 + 6);\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 2) = *(_QWORD *)(&v1->variant.var_3 + 2);\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 6) = v4;\n  v5 = *(_QWORD *)(&v1->variant.var_3 + 14);\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 10) = *(_QWORD *)(&v1->variant.var_3 + 10);\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 14) = v5;\n  *(_QWORD *)(&Ptr_Comp->variant.var_3 + 18) = *(_QWORD *)(&v1->variant.var_3 + 18);\n  Ptr_Val_Par->variant.var_1.Int_Comp = 5;\n  Next_Record->variant.var_1.Int_Comp = Ptr_Val_Par->variant.var_1.Int_Comp;\n  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  Proc_3(&Next_Record->Ptr_Comp);\n  if ( Next_Record->Discr )\n  {\n    v6 = Ptr_Val_Par->Ptr_Comp;\n    v7 = *(_QWORD *)&Ptr_Val_Par->Ptr_Comp->Discr;\n    Ptr_Val_Par->Ptr_Comp = Ptr_Val_Par->Ptr_Comp->Ptr_Comp;\n    *(_QWORD *)&Ptr_Val_Par->Discr = v7;\n    v8 = *(_QWORD *)(&v6->variant.var_3 + 6);\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 2) = *(_QWORD *)(&v6->variant.var_3 + 2);\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 6) = v8;\n    v9 = *(_QWORD *)(&v6->variant.var_3 + 14);\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 10) = *(_QWORD *)(&v6->variant.var_3 + 10);\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 14) = v9;\n    *(_QWORD *)(&Ptr_Val_Par->variant.var_3 + 18) = *(_QWORD *)(&v6->variant.var_3 + 18);\n  }\n  else\n  {\n    Next_Record->variant.var_1.Int_Comp = 6;\n    PProc_6(Ptr_Val_Par->variant.var_1.Enum_Comp, &Next_Record->variant.var_1.Enum_Comp);\n    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    PProc_7(Next_Record->variant.var_1.Int_Comp, 10, &Next_Record->variant.var_1.Int_Comp);\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int Proc_1(Rec_Pointer Ptr_Val_Par) {\n  Rec_Pointer v1;\n  record *Ptr_Comp;\n  long long v3;\n  long long v4;\n  long long v5;\n  record *v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  record *Next_Record;\n  Next_Record = Ptr_Val_Par->Ptr_Comp;\n  v1 = Ptr_Glob;\n  Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  v3 = *(uint64_t *)&Ptr_Glob->Discr;\n  Ptr_Comp->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n  *(uint64_t *)&Ptr_Comp->Discr = v3;\n  v4 = *(uint64_t *)(&v1->variant.var_3 + 6);\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 2) =\n      *(uint64_t *)(&v1->variant.var_3 + 2);\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 6) = v4;\n  v5 = *(uint64_t *)(&v1->variant.var_3 + 14);\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 10) =\n      *(uint64_t *)(&v1->variant.var_3 + 10);\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 14) = v5;\n  *(uint64_t *)(&Ptr_Comp->variant.var_3 + 18) =\n      *(uint64_t *)(&v1->variant.var_3 + 18);\n  Ptr_Val_Par->variant.var_1.Int_Comp = 5;\n  Next_Record->variant.var_1.Int_Comp = Ptr_Val_Par->variant.var_1.Int_Comp;\n  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;\n  Proc_3(&Next_Record->Ptr_Comp);\n  if (Next_Record->Discr) {\n    v6 = Ptr_Val_Par->Ptr_Comp;\n    v7 = *(uint64_t *)&Ptr_Val_Par->Ptr_Comp->Discr;\n    Ptr_Val_Par->Ptr_Comp = Ptr_Val_Par->Ptr_Comp->Ptr_Comp;\n    *(uint64_t *)&Ptr_Val_Par->Discr = v7;\n    v8 = *(uint64_t *)(&v6->variant.var_3 + 6);\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 2) =\n        *(uint64_t *)(&v6->variant.var_3 + 2);\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 6) = v8;\n    v9 = *(uint64_t *)(&v6->variant.var_3 + 14);\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 10) =\n        *(uint64_t *)(&v6->variant.var_3 + 10);\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 14) = v9;\n    *(uint64_t *)(&Ptr_Val_Par->variant.var_3 + 18) =\n        *(uint64_t *)(&v6->variant.var_3 + 18);\n  } else {\n    Next_Record->variant.var_1.Int_Comp = 6;\n    PProc_6(Ptr_Val_Par->variant.var_1.Enum_Comp,\n            &Next_Record->variant.var_1.Enum_Comp);\n    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    PProc_7(Next_Record->variant.var_1.Int_Comp, 10,\n            &Next_Record->variant.var_1.Int_Comp);\n  }\n  return 0;\n}", "binary": "dhrystone/dhrystone.host.O0", "assembly": "<Proc_1>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x18(%rbp)\nmov    0x58ce(%rip),%rdx\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rax\nmov    (%rdx),%rcx\nmov    0x8(%rdx),%rbx\nmov    %rcx,(%rax)\nmov    %rbx,0x8(%rax)\nmov    0x10(%rdx),%rcx\nmov    0x18(%rdx),%rbx\nmov    %rcx,0x10(%rax)\nmov    %rbx,0x18(%rax)\nmov    0x20(%rdx),%rcx\nmov    0x28(%rdx),%rbx\nmov    %rcx,0x20(%rax)\nmov    %rbx,0x28(%rax)\nmov    0x30(%rdx),%rdx\nmov    %rdx,0x30(%rax)\nmov    -0x28(%rbp),%rax\nmovl   $0x5,0x10(%rax)\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,0x10(%rax)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1b30 <Proc_3>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%eax\ntest   %eax,%eax\njne    1a8f <Proc_1+0xf0>\nmov    -0x18(%rbp),%rax\nmovl   $0x6,0x10(%rax)\nmov    -0x18(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x28(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %rdx,%rsi\nmov    %eax,%edi\ncall   1bd8 <PProc_6>\nmov    0x5828(%rip),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x18(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    0x10(%rax),%eax\nmov    $0xa,%esi\nmov    %eax,%edi\ncall   1c85 <PProc_7>\njmp    1ad0 <Proc_1+0x131>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x28(%rbp),%rax\nmov    (%rdx),%rcx\nmov    0x8(%rdx),%rbx\nmov    %rcx,(%rax)\nmov    %rbx,0x8(%rax)\nmov    0x10(%rdx),%rcx\nmov    0x18(%rdx),%rbx\nmov    %rcx,0x10(%rax)\nmov    %rbx,0x18(%rax)\nmov    0x20(%rdx),%rcx\nmov    0x28(%rdx),%rbx\nmov    %rcx,0x20(%rax)\nmov    %rbx,0x28(%rax)\nmov    0x30(%rdx),%rdx\nmov    %rdx,0x30(%rax)\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "Proc_2", "content": " /* Proc_1 */\n\n\nstatic int Proc_2 (One_Fifty *Int_Par_Ref)\n/******************/\n    /* executed once */\n    /* *Int_Par_Ref == 1, becomes 4 */\n{\n  One_Fifty  Int_Loc;\n  Enumeration   Enum_Loc = 0;\n\n  Int_Loc = *Int_Par_Ref + 10;\n  do /* executed once */\n    if (Ch_1_Glob == 'A')\n      /* then, executed */\n    {\n      Int_Loc -= 1;\n      *Int_Par_Ref = Int_Loc - Int_Glob;\n      Enum_Loc = Ident_1;\n    } /* if */\n  while (Enum_Loc != Ident_1); /* true */\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O0.pseudo", "function_name": "Proc_2", "address": "0x1adb", "label": "Proc_2", "content": "int __cdecl Proc_2(One_Fifty *Int_Par_Ref)\n{\n  if ( Ch_1_Glob[0] == 65 )\n    *Int_Par_Ref = *Int_Par_Ref + 9 - Int_Glob;\n  return 0;\n}\n"}, "pseudo_normalize": "", "binary": "dhrystone/dhrystone.host.O0", "assembly": "<Proc_2>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nadd    $0xa,%eax\nmov    %eax,-0x8(%rbp)\nmovzbl 0x5783(%rip),%eax\ncmp    $0x41,%al\njne    1b23 <Proc_2+0x48>\nsubl   $0x1,-0x8(%rbp)\nmov    0x5771(%rip),%ecx\nmov    -0x8(%rbp),%eax\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmovl   $0x0,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    1afa <Proc_2+0x1f>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "Proc_3", "content": " /* Proc_2 */\n\n\nstatic int Proc_3 (Rec_Pointer *Ptr_Ref_Par)\n/******************/\n    /* executed once */\n    /* Ptr_Ref_Par becomes Ptr_Glob */\n{\n  if (Ptr_Glob != Null)\n    /* then, executed */\n    *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;\n  PProc_7 (10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O0.pseudo", "function_name": "Proc_3", "address": "0x1b30", "label": "Proc_3", "content": "int __cdecl Proc_3(Rec_Pointer *Ptr_Ref_Par)\n{\n  if ( Ptr_Glob )\n    *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;\n  PProc_7(10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);\n  return 0;\n}\n"}, "pseudo_normalize": "", "binary": "dhrystone/dhrystone.host.O0", "assembly": "<Proc_3>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    0x5749(%rip),%rax\ntest   %rax,%rax\nje     1b5d <Proc_3+0x2d>\nmov    0x573d(%rip),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nmov    0x572c(%rip),%rax\nlea    0x10(%rax),%rdx\nmov    0x5712(%rip),%eax\nmov    %eax,%esi\nmov    $0xa,%edi\ncall   1c85 <PProc_7>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "Proc_4", "content": " /* Proc_3 */\n\n\nstatic int Proc_4 (void) /* without parameters */\n/*******/\n    /* executed once */\n{\n  Boolean Bool_Loc;\n\n  Bool_Loc = Ch_1_Glob == 'A';\n  Bool_Glob = Bool_Loc | Bool_Glob;\n  Ch_2_Glob = 'B';\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O0.pseudo", "function_name": "Proc_4", "address": "0x1b81", "label": "Proc_4", "content": "int __cdecl Proc_4()\n{\n  Bool_Glob |= Ch_1_Glob[0] == 65;\n  Ch_2_Glob[0] = 66;\n  return 0;\n}\n"}, "pseudo_normalize": "", "binary": "dhrystone/dhrystone.host.O0", "assembly": "<Proc_4>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovzbl 0x56f4(%rip),%eax\ncmp    $0x41,%al\nsete   %al\nmovzbl %al,%eax\nmov    %eax,-0x4(%rbp)\nmov    0x5777(%rip),%eax\nor     -0x4(%rbp),%eax\nmov    %eax,0x576e(%rip)\nmovb   $0x42,0x576b(%rip)\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "Proc_5", "content": " /* Proc_4 */\n\n\nstatic int Proc_5 (void) /* without parameters */\n/*******/\n    /* executed once */\n{\n  Ch_1_Glob = 'A';\n  Bool_Glob = false;\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O0.pseudo", "function_name": "Proc_5", "address": "0x1bb8", "label": "Proc_5", "content": "int __cdecl Proc_5()\n{\n  Ch_1_Glob[0] = 65;\n  Bool_Glob = 0;\n  return 0;\n}\n"}, "pseudo_normalize": "", "binary": "dhrystone/dhrystone.host.O0", "assembly": "<Proc_5>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovb   $0x41,0x56bd(%rip)\nmovl   $0x0,0x5747(%rip)\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "main", "content": "int\nmain(void)\n/*****/\n\n  /* main program, corresponds to procedures        */\n  /* Main and Proc_0 in the Ada version             */\n{\n  int nofr = 10;\n\n        One_Fifty       Int_1_Loc;\n  REG   One_Fifty       Int_2_Loc;\n        One_Fifty       Int_3_Loc;\n  REG   char            Ch_Index;\n        Enumeration     Enum_Loc;\n        Str_30          Str_1_Loc;\n        Str_30          Str_2_Loc;\n  REG   int             Run_Index;\n  REG   int             Pnumber_of_runs;\n\n  /* Initializations */\n\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n\n  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;\n  Ptr_Glob->Discr                       = Ident_1;\n  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;\n  Ptr_Glob->variant.var_1.Int_Comp      = 40;\n  libmin_strcpy (Ptr_Glob->variant.var_1.Str_Comp,\n          \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy (Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n\n  Arr_2_Glob [8][7] = 10;\n        /* Was missing in published program. Without this statement,    */\n        /* Arr_2_Glob [8][7] would have an undefined value.             */\n        /* Warning: With 16-Bit processors and Pnumber_of_runs > 32000,  */\n        /* overflow may occur for this array element.                   */\n\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n\n  Pnumber_of_runs = nofr; // HCH\n\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\",Pnumber_of_runs);\n\n  /***************/\n  /* Start timer */\n  /***************/\n\n  for (Run_Index = 1; Run_Index <= Pnumber_of_runs; ++Run_Index)\n  {\n\n    Proc_5();\n    Proc_4();\n      /* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */\n    Int_1_Loc = 2;\n    Int_2_Loc = 3;\n    libmin_strcpy (Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = ! PFunc_2 (Str_1_Loc, Str_2_Loc);\n      /* Bool_Glob == 1 */\n    while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */\n    {\n      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;\n        /* Int_3_Loc == 7 */\n      PProc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);\n        /* Int_3_Loc == 7 */\n      Int_1_Loc += 1;\n    } /* while */\n      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */\n    PProc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);\n      /* Int_Glob == 5 */\n    Proc_1 (Ptr_Glob);\n    for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)\n                             /* loop body executed twice */\n    {\n      if (Enum_Loc == PFunc_1 (Ch_Index, 'C'))\n          /* then, not executed */\n        {\n        PProc_6 (Ident_1, &Enum_Loc);\n        libmin_strcpy (Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        Int_2_Loc = Run_Index;\n        Int_Glob = Run_Index;\n        }\n    }\n      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */\n    Int_2_Loc = Int_2_Loc * Int_1_Loc;\n    Int_1_Loc = Int_2_Loc / Int_3_Loc;\n    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;\n      /* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */\n    Proc_2 (&Int_1_Loc);\n      /* Int_1_Loc == 5 */\n\n  } /* loop \"for Run_Index\" */\n\n  /**************/\n  /* Stop timer */\n  /**************/\n\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", Ch_1_Glob);\n  libmin_printf(\"        should be:   %c\\n\", 'A');\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", Ch_2_Glob);\n  libmin_printf(\"        should be:   %c\\n\", 'B');\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\",\n         Next_Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\",\n         Next_Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\",\n                                Next_Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", Int_2_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", Int_3_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Capital_Letter Ch_Index; // [rsp+3h] [rbp-6Dh]\n  One_Fifty Int_1_Loc; // [rsp+4h] [rbp-6Ch] BYREF\n  One_Fifty Int_3_Loc; // [rsp+8h] [rbp-68h] BYREF\n  Enumeration Enum_Loc; // [rsp+Ch] [rbp-64h] BYREF\n  One_Fifty Int_2_Loc; // [rsp+10h] [rbp-60h]\n  int Run_Index; // [rsp+14h] [rbp-5Ch]\n  int nofr; // [rsp+18h] [rbp-58h]\n  int Pnumber_of_runs; // [rsp+1Ch] [rbp-54h]\n  char Str_1_Loc[32]; // [rsp+20h] [rbp-50h] BYREF\n  char Str_2_Loc[40]; // [rsp+40h] [rbp-30h] BYREF\n  unsigned __int64 v13; // [rsp+68h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  nofr = 10;\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n  rec2.Ptr_Comp = &rec1;\n  rec2.Discr = Ident_1;\n  Ptr_Glob->variant.var_1.Enum_Comp = Ident_3;\n  Ptr_Glob->variant.var_1.Int_Comp = 40;\n  libmin_strcpy(Ptr_Glob->variant.var_1.Str_Comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n  Pnumber_of_runs = nofr;\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", nofr);\n  for ( Run_Index = 1; Run_Index <= Pnumber_of_runs; ++Run_Index )\n  {\n    Proc_5();\n    Proc_4();\n    Int_1_Loc = 2;\n    Int_2_Loc = 3;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = PFunc_2(Str_1_Loc, Str_2_Loc) == 0;\n    while ( Int_2_Loc > Int_1_Loc )\n    {\n      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;\n      PProc_7(Int_1_Loc++, Int_2_Loc, &Int_3_Loc);\n    }\n    PProc_8(Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);\n    Proc_1(Ptr_Glob);\n    for ( Ch_Index = 65; Ch_Index <= Ch_2_Glob[0]; ++Ch_Index )\n    {\n      if ( PFunc_1(Ch_Index, 67) == Enum_Loc )\n      {\n        PProc_6(Ident_1, &Enum_Loc);\n        libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        Int_2_Loc = Run_Index;\n        Int_Glob = Run_Index;\n      }\n    }\n    Int_2_Loc *= Int_1_Loc;\n    Int_1_Loc = Int_2_Loc / Int_3_Loc;\n    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_2_Loc / Int_3_Loc;\n    Proc_2(&Int_1_Loc);\n  }\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 65LL);\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 66LL);\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Next_Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Next_Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Next_Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", Int_2_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", Int_3_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  Capital_Letter Ch_Index;\n  One_Fifty Int_1_Loc;\n  One_Fifty Int_3_Loc;\n  Enumeration Enum_Loc;\n  One_Fifty Int_2_Loc;\n  int Run_Index;\n  int nofr;\n  int Pnumber_of_runs;\n  char Str_1_Loc[32];\n  char Str_2_Loc[40];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  nofr = 10;\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n  rec2.Ptr_Comp = &rec1;\n  rec2.Discr = Ident_1;\n  Ptr_Glob->variant.var_1.Enum_Comp = Ident_3;\n  Ptr_Glob->variant.var_1.Int_Comp = 40;\n  libmin_strcpy(Ptr_Glob->variant.var_1.Str_Comp,\n                \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n  Pnumber_of_runs = nofr;\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", nofr);\n  for (Run_Index = 1; Run_Index <= Pnumber_of_runs; ++Run_Index) {\n    Proc_5();\n    Proc_4();\n    Int_1_Loc = 2;\n    Int_2_Loc = 3;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = PFunc_2(Str_1_Loc, Str_2_Loc) == 0;\n    while (Int_2_Loc > Int_1_Loc) {\n      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;\n      PProc_7(Int_1_Loc++, Int_2_Loc, &Int_3_Loc);\n    }\n    PProc_8(Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);\n    Proc_1(Ptr_Glob);\n    for (Ch_Index = 65; Ch_Index <= Ch_2_Glob[0]; ++Ch_Index) {\n      if (PFunc_1(Ch_Index, 67) == Enum_Loc) {\n        PProc_6(Ident_1, &Enum_Loc);\n        libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        Int_2_Loc = Run_Index;\n        Int_Glob = Run_Index;\n      }\n    }\n    Int_2_Loc *= Int_1_Loc;\n    Int_1_Loc = Int_2_Loc / Int_3_Loc;\n    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_2_Loc / Int_3_Loc;\n    Proc_2(&Int_1_Loc);\n  }\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 65LL);\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n  libmin_printf(\"        should be:   %c\\n\", 66LL);\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\n      \"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\",\n                Next_Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\",\n                Next_Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\",\n                Next_Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", Int_2_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", Int_3_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n  libmin_success();\n}", "binary": "dhrystone/dhrystone.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0xa,-0x58(%rbp)\nlea    0x608e(%rip),%rax\nmov    %rax,0x607f(%rip)\nlea    0x60c0(%rip),%rax\nmov    %rax,0x6069(%rip)\nmov    0x6062(%rip),%rax\nmov    0x6063(%rip),%rdx\nmov    %rdx,(%rax)\nmov    0x6051(%rip),%rax\nmovl   $0x0,0x8(%rax)\nmov    0x6043(%rip),%rax\nmovl   $0x2,0xc(%rax)\nmov    0x6035(%rip),%rax\nmovl   $0x28,0x10(%rax)\nmov    0x6027(%rip),%rax\nadd    $0x14,%rax\nlea    0x3d94(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4336 <libmin_strcpy>\nlea    -0x50(%rbp),%rax\nlea    0x3d9e(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4336 <libmin_strcpy>\nmovl   $0xa,0x67bd(%rip)\nlea    0x3da1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3d96(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3d79(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    -0x58(%rbp),%eax\nmov    %eax,-0x54(%rbp)\nmov    -0x54(%rbp),%eax\nmov    %eax,%esi\nlea    0x3d93(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmovl   $0x1,-0x5c(%rbp)\njmp    146e <main+0x285>\ncall   1bb8 <Proc_5>\ncall   1b81 <Proc_4>\nmovl   $0x2,-0x6c(%rbp)\nmovl   $0x3,-0x60(%rbp)\nlea    -0x30(%rbp),%rax\nlea    0x3d87(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4336 <libmin_strcpy>\nmovl   $0x1,-0x64(%rbp)\nlea    -0x30(%rbp),%rdx\nlea    -0x50(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1e91 <PFunc_2>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\nmov    %eax,0x5fbc(%rip)\njmp    138a <main+0x1a1>\nmov    -0x6c(%rbp),%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nsub    -0x60(%rbp),%eax\nmov    %eax,-0x68(%rbp)\nmov    -0x6c(%rbp),%eax\nlea    -0x68(%rbp),%rdx\nmov    -0x60(%rbp),%ecx\nmov    %ecx,%esi\nmov    %eax,%edi\ncall   1c85 <PProc_7>\nmov    -0x6c(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,-0x6c(%rbp)\nmov    -0x6c(%rbp),%eax\ncmp    %eax,-0x60(%rbp)\njg     135e <main+0x175>\nmov    -0x68(%rbp),%edx\nmov    -0x6c(%rbp),%eax\nmov    %edx,%ecx\nmov    %eax,%edx\nlea    0x605d(%rip),%rax\nmov    %rax,%rsi\nlea    0x5f73(%rip),%rax\nmov    %rax,%rdi\ncall   1cb5 <PProc_8>\nmov    0x5ed4(%rip),%rax\nmov    %rax,%rdi\ncall   199f <Proc_1>\nmovb   $0x41,-0x6d(%rbp)\njmp    1421 <main+0x238>\nmovsbl -0x6d(%rbp),%eax\nmov    $0x43,%esi\nmov    %eax,%edi\ncall   1e50 <PFunc_1>\nmov    -0x64(%rbp),%edx\ncmp    %edx,%eax\njne    1417 <main+0x22e>\nlea    -0x64(%rbp),%rax\nmov    %rax,%rsi\nmov    $0x0,%edi\ncall   1bd8 <PProc_6>\nlea    -0x30(%rbp),%rax\nlea    0x3cd3(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4336 <libmin_strcpy>\nmov    -0x5c(%rbp),%eax\nmov    %eax,-0x60(%rbp)\nmov    -0x5c(%rbp),%eax\nmov    %eax,0x5e69(%rip)\nmovzbl -0x6d(%rbp),%eax\nadd    $0x1,%eax\nmov    %al,-0x6d(%rbp)\nmovzbl 0x5ef4(%rip),%eax\ncmp    %al,-0x6d(%rbp)\njle    13ca <main+0x1e1>\nmov    -0x6c(%rbp),%eax\nmov    -0x60(%rbp),%edx\nimul   %edx,%eax\nmov    %eax,-0x60(%rbp)\nmov    -0x68(%rbp),%ecx\nmov    -0x60(%rbp),%eax\ncltd\nidiv   %ecx\nmov    %eax,-0x6c(%rbp)\nmov    -0x68(%rbp),%ecx\nmov    -0x60(%rbp),%eax\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x3,%eax\nsub    %edx,%eax\nmov    -0x6c(%rbp),%edx\nsub    %edx,%eax\nmov    %eax,-0x60(%rbp)\nlea    -0x6c(%rbp),%rax\nmov    %rax,%rdi\ncall   1adb <Proc_2>\naddl   $0x1,-0x5c(%rbp)\nmov    -0x5c(%rbp),%eax\ncmp    -0x54(%rbp),%eax\njle    1306 <main+0x11d>\nlea    0x3c6e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3bb2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3c57(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3b8a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5db0(%rip),%eax\nmov    %eax,%esi\nlea    0x3c5d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x5,%esi\nlea    0x3c5d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5e13(%rip),%eax\nmov    %eax,%esi\nlea    0x3c5a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x1,%esi\nlea    0x3c28(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmovzbl 0x5d49(%rip),%eax\nmovsbl %al,%eax\nmov    %eax,%esi\nlea    0x3c3a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x41,%esi\nlea    0x3c3a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmovzbl 0x5da8(%rip),%eax\nmovsbl %al,%eax\nmov    %eax,%esi\nlea    0x3c33(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x42,%esi\nlea    0x3c01(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5d94(%rip),%eax\nmov    %eax,%esi\nlea    0x3c17(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x7,%esi\nlea    0x3b81(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x647b(%rip),%eax\nmov    %eax,%esi\nlea    0x3bfb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3c02(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3c19(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3c12(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3c36(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5c42(%rip),%rax\nmov    0x8(%rax),%eax\nmov    %eax,%esi\nlea    0x3c47(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x0,%esi\nlea    0x3adc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5c09(%rip),%rax\nmov    0xc(%rax),%eax\nmov    %eax,%esi\nlea    0x3c27(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x2,%esi\nlea    0x3aa3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5bd0(%rip),%rax\nmov    0x10(%rax),%eax\nmov    %eax,%esi\nlea    0x3c07(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x11,%esi\nlea    0x3a6a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5b97(%rip),%rax\nadd    $0x14,%rax\nmov    %rax,%rsi\nlea    0x3be5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3bed(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3c0e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3af5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3bf9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5b2d(%rip),%rax\nmov    0x8(%rax),%eax\nmov    %eax,%esi\nlea    0x3b2a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x0,%esi\nlea    0x39bf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5af4(%rip),%rax\nmov    0xc(%rax),%eax\nmov    %eax,%esi\nlea    0x3b0a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x1,%esi\nlea    0x3986(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5abb(%rip),%rax\nmov    0x10(%rax),%eax\nmov    %eax,%esi\nlea    0x3aea(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x12,%esi\nlea    0x394d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    0x5a82(%rip),%rax\nadd    $0x14,%rax\nmov    %rax,%rsi\nlea    0x3ac8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3ad0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    -0x6c(%rbp),%eax\nmov    %eax,%esi\nlea    0x3b3f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x5,%esi\nlea    0x38e5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    -0x60(%rbp),%eax\nmov    %eax,%esi\nlea    0x3b26(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0xd,%esi\nlea    0x38b3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    -0x68(%rbp),%eax\nmov    %eax,%esi\nlea    0x3b0d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x7,%esi\nlea    0x3881(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    -0x64(%rbp),%eax\nmov    %eax,%esi\nlea    0x3af4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nmov    $0x1,%esi\nlea    0x384f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    -0x50(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3ad9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3ae1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    -0x30(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3afb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x3b02(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\nlea    0x36d5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a9 <libmin_printf>\ncall   43bf <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     199d <main+0x7b4>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "distinctness/distinctness.c", "function_name": "isDistinct", "content": "int\nisDistinct(int elements[], int *pdup)\n{\n  int tree[SIZE][3];\n  *pdup = INT_MAX;\n\n\tfor(int i = 0; i < SIZE;i++){\n\t\ttree[i][0] = INT_MAX;\n\t\ttree[i][1] = INT_MAX;\n\t\ttree[i][2] = INT_MAX;\n\t}\t\n\t\n\ttree[0][0] = elements[0];\n\tint location = 0;\n\n\tfor(int i = 1; i < SIZE; i++){\n\t\tint temp = 0;\n\t\tint value = tree[0][0];\n\t\tint left = tree[0][1];\n\t\tint right = tree[0][2];\n\n\t\twhile(value != INT_MAX){\n\t\t\tif(elements[i] > value){\n\t\t\t\tif(right != INT_MAX){\n\t\t\t\t\tvalue = tree[right][0];\n\t\t\t\t\tleft = tree[right][1];\n\t\t\t\t\ttemp = right;\n\t\t\t\t\tright = tree[right][2];\n\t\t\t\t}else{\n\t\t\t\t\ttree[location+1][0] = elements[i];\n\t\t\t\t\ttree[temp][2] = location + 1;\n\t\t\t\t\tlocation++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(elements[i] < value){\n\t\t\t\tif(left != INT_MAX){\n\t\t\t\t\tvalue = tree[left][0];\n\t\t\t\t\tright = tree[left][2];\n\t\t\t\t\ttemp = left;\n\t\t\t\t\tleft = tree[left][1];\n\t\t\t\t}else{\n\t\t\t\t\ttree[temp][1] = location+1;\n\t\t\t\t\ttree[location+1][0] = elements[i];\n\t\t\t\t\tlocation++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n        *pdup = elements[i];\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n"}, "pseudo": {"path": "distinctness/distinctness.host.O0.pseudo", "function_name": "isDistinct", "address": "0x11e9", "label": "isDistinct", "content": "int __cdecl isDistinct(int *elements, int *pdup)\n{\n  int i; // [rsp+14h] [rbp-62Ch]\n  int location; // [rsp+18h] [rbp-628h]\n  int i_0; // [rsp+1Ch] [rbp-624h]\n  int temp; // [rsp+20h] [rbp-620h]\n  __int64 value; // [rsp+24h] [rbp-61Ch]\n  int right; // [rsp+2Ch] [rbp-614h]\n  int tree[128][3]; // [rsp+30h] [rbp-610h]\n  unsigned __int64 v10; // [rsp+638h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  *pdup = 0x7FFFFFFF;\n  for ( i = 0; i <= 127; ++i )\n  {\n    tree[i][0] = 0x7FFFFFFF;\n    tree[i][1] = 0x7FFFFFFF;\n    tree[i][2] = 0x7FFFFFFF;\n  }\n  tree[0][0] = *elements;\n  location = 0;\n  for ( i_0 = 1; i_0 <= 127; ++i_0 )\n  {\n    temp = 0;\n    value = *(_QWORD *)&tree[0][0];\n    right = tree[0][2];\n    while ( (_DWORD)value != 0x7FFFFFFF )\n    {\n      if ( (int)value >= elements[i_0] )\n      {\n        if ( (int)value <= elements[i_0] )\n        {\n          *pdup = elements[i_0];\n          return 0;\n        }\n        if ( HIDWORD(value) == 0x7FFFFFFF )\n        {\n          tree[temp][1] = location + 1;\n          tree[++location][0] = elements[i_0];\n          break;\n        }\n        LODWORD(value) = tree[SHIDWORD(value)][0];\n        right = tree[SHIDWORD(value)][2];\n        temp = HIDWORD(value);\n        HIDWORD(value) = tree[SHIDWORD(value)][1];\n      }\n      else\n      {\n        if ( right == 0x7FFFFFFF )\n        {\n          tree[location + 1][0] = elements[i_0];\n          tree[temp][2] = ++location;\n          break;\n        }\n        LODWORD(value) = tree[right][0];\n        HIDWORD(value) = tree[right][1];\n        temp = right;\n        right = tree[right][2];\n      }\n    }\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int isDistinct(int *elements, int *pdup) {\n  int i;\n  int location;\n  int i_0;\n  int temp;\n  long long value;\n  int right;\n  int tree[128][3];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  *pdup = 2147483647;\n  for (i = 0; i <= 127; ++i) {\n    tree[i][0] = 2147483647;\n    tree[i][1] = 2147483647;\n    tree[i][2] = 2147483647;\n  }\n  tree[0][0] = *elements;\n  location = 0;\n  for (i_0 = 1; i_0 <= 127; ++i_0) {\n    temp = 0;\n    value = *(uint64_t *)&tree[0][0];\n    right = tree[0][2];\n    while ((uint32_t)value != 2147483647) {\n      if ((int)value >= elements[i_0]) {\n        if ((int)value <= elements[i_0]) {\n          *pdup = elements[i_0];\n          return 0;\n        }\n        if (HIDWORD(value) == 2147483647) {\n          tree[temp][1] = location + 1;\n          tree[++location][0] = elements[i_0];\n          break;\n        }\n        LODWORD(value) = tree[SHIDWORD(value)][0];\n        right = tree[SHIDWORD(value)][2];\n        temp = HIDWORD(value);\n        HIDWORD(value) = tree[SHIDWORD(value)][1];\n      } else {\n        if (right == 2147483647) {\n          tree[location + 1][0] = elements[i_0];\n          tree[temp][2] = ++location;\n          break;\n        }\n        LODWORD(value) = tree[right][0];\n        HIDWORD(value) = tree[right][1];\n        temp = right;\n        right = tree[right][2];\n      }\n    }\n  }\n  return 1;\n}", "binary": "distinctness/distinctness.host.O0", "assembly": "<isDistinct>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x640,%rsp\nmov    %rdi,-0x638(%rbp)\nmov    %rsi,-0x640(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x640(%rbp),%rax\nmovl   $0x7fffffff,(%rax)\nmovl   $0x0,-0x62c(%rbp)\njmp    12a4 <isDistinct+0xbb>\nmov    -0x62c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x610,%rax\nmovl   $0x7fffffff,(%rax)\nmov    -0x62c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x60c,%rax\nmovl   $0x7fffffff,(%rax)\nmov    -0x62c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x608,%rax\nmovl   $0x7fffffff,(%rax)\naddl   $0x1,-0x62c(%rbp)\ncmpl   $0x7f,-0x62c(%rbp)\njle    122e <isDistinct+0x45>\nmov    -0x638(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x610(%rbp)\nmovl   $0x0,-0x628(%rbp)\nmovl   $0x1,-0x624(%rbp)\njmp    15b0 <isDistinct+0x3c7>\nmovl   $0x0,-0x620(%rbp)\nmov    -0x610(%rbp),%eax\nmov    %eax,-0x61c(%rbp)\nmov    -0x60c(%rbp),%eax\nmov    %eax,-0x618(%rbp)\nmov    -0x608(%rbp),%eax\nmov    %eax,-0x614(%rbp)\njmp    1599 <isDistinct+0x3b0>\nmov    -0x624(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x638(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x61c(%rbp)\njge    143c <isDistinct+0x253>\ncmpl   $0x7fffffff,-0x614(%rbp)\nje     13c6 <isDistinct+0x1dd>\nmov    -0x614(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x610,%rax\nmov    (%rax),%eax\nmov    %eax,-0x61c(%rbp)\nmov    -0x614(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x60c,%rax\nmov    (%rax),%eax\nmov    %eax,-0x618(%rbp)\nmov    -0x614(%rbp),%eax\nmov    %eax,-0x620(%rbp)\nmov    -0x614(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x608,%rax\nmov    (%rax),%eax\nmov    %eax,-0x614(%rbp)\njmp    1599 <isDistinct+0x3b0>\nmov    -0x624(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x638(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x628(%rbp),%edx\nlea    0x1(%rdx),%ecx\nmov    (%rax),%edx\nmovslq %ecx,%rcx\nmov    %rcx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x610,%rax\nmov    %edx,(%rax)\nmov    -0x628(%rbp),%eax\nlea    0x1(%rax),%ecx\nmov    -0x620(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x608,%rax\nmov    %ecx,(%rax)\naddl   $0x1,-0x628(%rbp)\njmp    15a9 <isDistinct+0x3c0>\nmov    -0x624(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x638(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x61c(%rbp)\njle    156d <isDistinct+0x384>\ncmpl   $0x7fffffff,-0x618(%rbp)\nje     14fa <isDistinct+0x311>\nmov    -0x618(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x610,%rax\nmov    (%rax),%eax\nmov    %eax,-0x61c(%rbp)\nmov    -0x618(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x608,%rax\nmov    (%rax),%eax\nmov    %eax,-0x614(%rbp)\nmov    -0x618(%rbp),%eax\nmov    %eax,-0x620(%rbp)\nmov    -0x618(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x60c,%rax\nmov    (%rax),%eax\nmov    %eax,-0x618(%rbp)\njmp    1599 <isDistinct+0x3b0>\nmov    -0x628(%rbp),%eax\nlea    0x1(%rax),%ecx\nmov    -0x620(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x60c,%rax\nmov    %ecx,(%rax)\nmov    -0x624(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x638(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x628(%rbp),%edx\nlea    0x1(%rdx),%ecx\nmov    (%rax),%edx\nmovslq %ecx,%rcx\nmov    %rcx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nshl    $0x2,%rax\nadd    %rbp,%rax\nsub    $0x610,%rax\nmov    %edx,(%rax)\naddl   $0x1,-0x628(%rbp)\njmp    15a9 <isDistinct+0x3c0>\nmov    -0x624(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x638(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x640(%rbp),%rax\nmov    %edx,(%rax)\nmov    $0x0,%eax\njmp    15c2 <isDistinct+0x3d9>\ncmpl   $0x7fffffff,-0x61c(%rbp)\njne    1308 <isDistinct+0x11f>\naddl   $0x1,-0x624(%rbp)\ncmpl   $0x7f,-0x624(%rbp)\njle    12d5 <isDistinct+0xec>\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     15d6 <isDistinct+0x3ed>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "distinctness/distinctness.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int dup1, dup2;\n  int res1, res2;\n\n  res1 = isDistinct(elements1, &dup1);\n  res2 = isDistinct(elements2, &dup2);\n\n  if (res1)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n\telse\n\t\tlibmin_printf(\"The elements of `elements1' are not distinct (e.g., %d is duplicated)\\n\", dup1);\n\t\n  if (res2)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n\telse\n\t\tlibmin_printf(\"The elements of `elements2' are not distinct (e.g., %d is duplicated)\\n\", dup2);\n\n\tlibmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "distinctness/distinctness.host.O0.pseudo", "function_name": "main", "address": "0x15d8", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int dup1; // [rsp+8h] [rbp-18h] BYREF\n  int dup2; // [rsp+Ch] [rbp-14h] BYREF\n  int res1; // [rsp+10h] [rbp-10h]\n  int res2; // [rsp+14h] [rbp-Ch]\n  unsigned __int64 v7; // [rsp+18h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  res1 = isDistinct(elements1, &dup1);\n  res2 = isDistinct(elements2, &dup2);\n  if ( res1 )\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements1' are not distinct (e.g., %d is duplicated)\\n\", dup1);\n  if ( res2 )\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements2' are not distinct (e.g., %d is duplicated)\\n\", dup2);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int dup1;\n  int dup2;\n  int res1;\n  int res2;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  res1 = isDistinct(elements1, &dup1);\n  res2 = isDistinct(elements2, &dup2);\n  if (res1)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements1' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup1);\n  if (res2)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements2' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup2);\n  libmin_success();\n}", "binary": "distinctness/distinctness.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x18(%rbp),%rax\nmov    %rax,%rsi\nlea    0x4a1f(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <isDistinct>\nmov    %eax,-0x10(%rbp)\nlea    -0x14(%rbp),%rax\nmov    %rax,%rsi\nlea    0x4c06(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <isDistinct>\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0x10(%rbp)\nje     1641 <main+0x69>\nlea    0x29d6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37eb <libmin_printf>\njmp    165a <main+0x82>\nmov    -0x18(%rbp),%eax\nmov    %eax,%esi\nlea    0x29eb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37eb <libmin_printf>\ncmpl   $0x0,-0xc(%rbp)\nje     1676 <main+0x9e>\nlea    0x2a19(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37eb <libmin_printf>\njmp    168f <main+0xb7>\nmov    -0x14(%rbp),%eax\nmov    %eax,%esi\nlea    0x2a2e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37eb <libmin_printf>\ncall   3a58 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     16ad <main+0xd5>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "db_from_ampl", "content": "/* db_from_ampl() - find loudness (in dB) from\n   the complex amplitude.\n*/\nint db_from_ampl(fixed re, fixed im)\n{\n  static int loud2[N_LOUD] = {0};\n  int v;\n  int i;\n\n  if(loud2[0] == 0) {\n    loud2[0] = (int)Loudampl[0] * (int)Loudampl[0];\n    for(i=1; i<N_LOUD; ++i) {\n      v = (int)Loudampl[i] * (int)Loudampl[i];\n      loud2[i] = v;\n      loud2[i-1] = (loud2[i-1]+v) / 2;\n    }\n  }\n\n  v = (int)re * (int)re + (int)im * (int)im;\n\n  for(i=0; i<N_LOUD; ++i)\n    if(loud2[i] <= v)\n      break;\n\n  return (-i);\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O0.pseudo", "function_name": "db_from_ampl", "address": "0x1807", "label": "db_from_ampl", "content": "int __cdecl db_from_ampl(int re, int im)\n{\n  int i; // [rsp+10h] [rbp-8h]\n  int ia; // [rsp+10h] [rbp-8h]\n  int v; // [rsp+14h] [rbp-4h]\n\n  if ( !loud2_0[0] )\n  {\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    for ( i = 1; i <= 99; ++i )\n    {\n      v = Loudampl[i] * Loudampl[i];\n      loud2_0[i] = v;\n      loud2_0[i - 1] = (loud2_0[i - 1] + v) / 2;\n    }\n  }\n  for ( ia = 0; ia <= 99 && re * re + im * im < loud2_0[ia]; ++ia )\n    ;\n  return -ia;\n}\n"}, "pseudo_normalize": "int db_from_ampl(int re, int im) {\n  int i;\n  int ia;\n  int v;\n  if (!loud2_0[0]) {\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    for (i = 1; i <= 99; ++i) {\n      v = Loudampl[i] * Loudampl[i];\n      loud2_0[i] = v;\n      loud2_0[i - 1] = (loud2_0[i - 1] + v) / 2;\n    }\n  }\n  for (ia = 0; ia <= 99 && re * re + im * im < loud2_0[ia]; ++ia)\n    ;\n  return -ia;\n}", "binary": "fft-int/fft-int.host.O0", "assembly": "<db_from_ampl>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    0x7c05(%rip),%eax\ntest   %eax,%eax\njne    18e5 <db_from_ampl+0xde>\nmov    0x77f7(%rip),%edx\nmov    0x77f1(%rip),%eax\nimul   %edx,%eax\nmov    %eax,0x7be8(%rip)\nmovl   $0x1,-0x8(%rbp)\njmp    18db <db_from_ampl+0xd4>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x77c8(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x77b1(%rip),%rax\nmov    (%rcx,%rax,1),%eax\nimul   %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x7b94(%rip),%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    -0x8(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x7b77(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x4(%rbp),%eax\nadd    %edx,%eax\nmov    -0x8(%rbp),%edx\nsub    $0x1,%edx\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\nmov    %eax,%ecx\nmovslq %edx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x7b4c(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x63,-0x8(%rbp)\njle    1844 <db_from_ampl+0x3d>\nmov    -0x14(%rbp),%eax\nimul   %eax,%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%eax\nimul   %eax,%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1921 <db_from_ampl+0x11a>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x7b0b(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,-0x4(%rbp)\njge    1929 <db_from_ampl+0x122>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x63,-0x8(%rbp)\njle    1901 <db_from_ampl+0xfa>\njmp    192a <db_from_ampl+0x123>\nnop\nmov    -0x8(%rbp),%eax\nneg    %eax\npop    %rbp\nret\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "fix_fft", "content": "/* fix_fft() - perform fast Fourier transform.\n\n   if n>0 FFT is done, if n<0 inverse FFT is done\n   fr[n],fi[n] are real,imaginary arrays, INPUT AND RESULT.\n   size of data = 2**m\n   set inverse to 0=dft, 1=idft\n*/\nint\nfix_fft(fixed fr[], fixed fi[], int m, int inverse)\n{\n  int mr,nn,i,j,l,k,istep, n, scale, shift;\n  fixed qr,qi,tr,ti,wr,wi;\n\n  n = 1<<m;\n\n  if(n > N_WAVE)\n    return -1;\n\n  mr = 0;\n  nn = n - 1;\n  scale = 0;\n\n  /* decimation in time - re-order data */\n  for(m=1; m<=nn; ++m) {\n    l = n;\n    do {\n      l >>= 1;\n    } while(mr+l > nn);\n    mr = (mr & (l-1)) + l;\n\n    if(mr <= m) continue;\n    tr = fr[m];\n    fr[m] = fr[mr];\n    fr[mr] = tr;\n    ti = fi[m];\n    fi[m] = fi[mr];\n    fi[mr] = ti;\n  }\n\n  l = 1;\n  k = LOG2_N_WAVE-1;\n  while(l < n) {\n    if(inverse) {\n      /* variable scaling, depending upon data */\n      shift = 0;\n      for(i=0; i<n; ++i) {\n\tj = fr[i];\n\tif(j < 0)\n\t  j = -j;\n\tm = fi[i];\n\tif(m < 0)\n\t  m = -m;\n\tif(j > 16383 || m > 16383) {\n\t  shift = 1;\n\t  break;\n\t}\n      }\n      if(shift)\n\t++scale;\n    } else {\n      /* fixed scaling, for proper normalization -\n\t there will be log2(n) passes, so this\n\t results in an overall factor of 1/n,\n\t distributed to maximize arithmetic accuracy. */\n      shift = 1;\n    }\n    /* it may not be obvious, but the shift will be performed\n       on each data point exactly once, during this pass. */\n    istep = l << 1;\n    for(m=0; m<l; ++m) {\n      j = m << k;\n      /* 0 <= j < N_WAVE/2 */\n      wr =  Sinewave[j+N_WAVE/4];\n      wi = -Sinewave[j];\n      if(inverse)\n\twi = -wi;\n      if(shift) {\n\twr >>= 1;\n\twi >>= 1;\n      }\n      for(i=m; i<n; i+=istep) {\n\tj = i + l;\n\ttr = fix_mpy(wr,fr[j]) -\n\t  fix_mpy(wi,fi[j]);\n\tti = fix_mpy(wr,fi[j]) +\n\t  fix_mpy(wi,fr[j]);\n\tqr = fr[i];\n\tqi = fi[i];\n\tif(shift) {\n\t  qr >>= 1;\n\t  qi >>= 1;\n\t}\n\tfr[j] = qr - tr;\n\tfi[j] = qi - ti;\n\tfr[i] = qr + tr;\n\tfi[i] = qi + ti;\n      }\n    }\n    --k;\n    l = istep;\n  }\n\n  return scale;\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O0.pseudo", "function_name": "fix_fft", "address": "0x11e9", "label": "fix_fft", "content": "int __cdecl fix_fft(int *fr, int *fi, int m, int inverse)\n{\n  int fixed; // ebx\n  int v6; // ebx\n  int ma; // [rsp+Ch] [rbp-64h]\n  int mb; // [rsp+Ch] [rbp-64h]\n  int mc; // [rsp+Ch] [rbp-64h]\n  int mr; // [rsp+20h] [rbp-50h]\n  int i; // [rsp+24h] [rbp-4Ch]\n  int ia; // [rsp+24h] [rbp-4Ch]\n  int j; // [rsp+28h] [rbp-48h]\n  int ja; // [rsp+28h] [rbp-48h]\n  int l; // [rsp+2Ch] [rbp-44h]\n  int la; // [rsp+2Ch] [rbp-44h]\n  char k; // [rsp+30h] [rbp-40h]\n  int scale; // [rsp+34h] [rbp-3Ch]\n  int shift; // [rsp+38h] [rbp-38h]\n  int qr; // [rsp+3Ch] [rbp-34h]\n  int qi; // [rsp+40h] [rbp-30h]\n  int wr; // [rsp+44h] [rbp-2Ch]\n  int wi; // [rsp+48h] [rbp-28h]\n  int n; // [rsp+4Ch] [rbp-24h]\n  int nn; // [rsp+50h] [rbp-20h]\n  int tra; // [rsp+58h] [rbp-18h]\n  int tr; // [rsp+58h] [rbp-18h]\n  int tia; // [rsp+5Ch] [rbp-14h]\n  int ti; // [rsp+5Ch] [rbp-14h]\n\n  n = 1 << m;\n  if ( 1 << m > 1024 )\n    return -1;\n  mr = 0;\n  nn = n - 1;\n  scale = 0;\n  for ( ma = 1; ma <= nn; ++ma )\n  {\n    l = 1 << m;\n    do\n      l >>= 1;\n    while ( nn < mr + l );\n    mr = (mr & (l - 1)) + l;\n    if ( mr > ma )\n    {\n      tra = fr[ma];\n      fr[ma] = fr[mr];\n      fr[mr] = tra;\n      tia = fi[ma];\n      fi[ma] = fi[mr];\n      fi[mr] = tia;\n    }\n  }\n  la = 1;\n  k = 9;\n  while ( la < n )\n  {\n    if ( inverse )\n    {\n      shift = 0;\n      for ( i = 0; i < n; ++i )\n      {\n        j = fr[i];\n        if ( j < 0 )\n          j = -j;\n        mb = fi[i];\n        if ( mb < 0 )\n          mb = -mb;\n        if ( j > 0x3FFF || mb > 0x3FFF )\n        {\n          shift = 1;\n          break;\n        }\n      }\n      if ( shift )\n        ++scale;\n    }\n    else\n    {\n      shift = 1;\n    }\n    for ( mc = 0; mc < la; ++mc )\n    {\n      wr = Sinewave[(mc << k) + 256];\n      wi = -Sinewave[mc << k];\n      if ( inverse )\n        wi = Sinewave[mc << k];\n      if ( shift )\n      {\n        wr >>= 1;\n        wi >>= 1;\n      }\n      for ( ia = mc; ia < n; ia += 2 * la )\n      {\n        ja = ia + la;\n        fixed = fix_mpy(wr, fr[ia + la]);\n        tr = fixed - fix_mpy(wi, fi[ia + la]);\n        v6 = fix_mpy(wr, fi[ia + la]);\n        ti = v6 + fix_mpy(wi, fr[ia + la]);\n        qr = fr[ia];\n        qi = fi[ia];\n        if ( shift )\n        {\n          qr >>= 1;\n          qi >>= 1;\n        }\n        fr[ja] = qr - tr;\n        fi[ja] = qi - ti;\n        fr[ia] = qr + tr;\n        fi[ia] = qi + ti;\n      }\n    }\n    --k;\n    la *= 2;\n  }\n  return scale;\n}\n"}, "pseudo_normalize": "int fix_fft(int *fr, int *fi, int m, int inverse) {\n  int fixed;\n  int v6;\n  int ma;\n  int mb;\n  int mc;\n  int mr;\n  int i;\n  int ia;\n  int j;\n  int ja;\n  int l;\n  int la;\n  char k;\n  int scale;\n  int shift;\n  int qr;\n  int qi;\n  int wr;\n  int wi;\n  int n;\n  int nn;\n  int tra;\n  int tr;\n  int tia;\n  int ti;\n  n = 1 << m;\n  if (1 << m > 1024) return -1;\n  mr = 0;\n  nn = n - 1;\n  scale = 0;\n  for (ma = 1; ma <= nn; ++ma) {\n    l = 1 << m;\n    do l >>= 1;\n    while (nn < mr + l);\n    mr = (mr & (l - 1)) + l;\n    if (mr > ma) {\n      tra = fr[ma];\n      fr[ma] = fr[mr];\n      fr[mr] = tra;\n      tia = fi[ma];\n      fi[ma] = fi[mr];\n      fi[mr] = tia;\n    }\n  }\n  la = 1;\n  k = 9;\n  while (la < n) {\n    if (inverse) {\n      shift = 0;\n      for (i = 0; i < n; ++i) {\n        j = fr[i];\n        if (j < 0) j = -j;\n        mb = fi[i];\n        if (mb < 0) mb = -mb;\n        if (j > 16383 || mb > 16383) {\n          shift = 1;\n          break;\n        }\n      }\n      if (shift) ++scale;\n    } else {\n      shift = 1;\n    }\n    for (mc = 0; mc < la; ++mc) {\n      wr = Sinewave[(mc << k) + 256];\n      wi = -Sinewave[mc << k];\n      if (inverse) wi = Sinewave[mc << k];\n      if (shift) {\n        wr >>= 1;\n        wi >>= 1;\n      }\n      for (ia = mc; ia < n; ia += 2 * la) {\n        ja = ia + la;\n        fixed = fix_mpy(wr, fr[ia + la]);\n        tr = fixed - fix_mpy(wi, fi[ia + la]);\n        v6 = fix_mpy(wr, fi[ia + la]);\n        ti = v6 + fix_mpy(wi, fr[ia + la]);\n        qr = fr[ia];\n        qi = fi[ia];\n        if (shift) {\n          qr >>= 1;\n          qi >>= 1;\n        }\n        fr[ja] = qr - tr;\n        fi[ja] = qi - ti;\n        fr[ia] = qr + tr;\n        fi[ia] = qi + ti;\n      }\n    }\n    --k;\n    la *= 2;\n  }\n  return scale;\n}", "binary": "fft-int/fft-int.host.O0", "assembly": "<fix_fft>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %rsi,-0x60(%rbp)\nmov    %edx,-0x64(%rbp)\nmov    %ecx,-0x68(%rbp)\nmov    -0x64(%rbp),%eax\nmov    $0x1,%edx\nmov    %eax,%ecx\nshl    %cl,%edx\nmov    %edx,%eax\nmov    %eax,-0x24(%rbp)\ncmpl   $0x400,-0x24(%rbp)\njle    1228 <fix_fft+0x3f>\nmov    $0xffffffff,%eax\njmp    160c <fix_fft+0x423>\nmovl   $0x0,-0x50(%rbp)\nmov    -0x24(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x20(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmovl   $0x1,-0x64(%rbp)\njmp    1345 <fix_fft+0x15c>\nmov    -0x24(%rbp),%eax\nmov    %eax,-0x44(%rbp)\nsarl   -0x44(%rbp)\nmov    -0x50(%rbp),%edx\nmov    -0x44(%rbp),%eax\nadd    %edx,%eax\ncmp    %eax,-0x20(%rbp)\njl     1251 <fix_fft+0x68>\nmov    -0x44(%rbp),%eax\nsub    $0x1,%eax\nand    -0x50(%rbp),%eax\nmov    %eax,%edx\nmov    -0x44(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x50(%rbp)\nmov    -0x50(%rbp),%eax\ncmp    -0x64(%rbp),%eax\njle    1340 <fix_fft+0x157>\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x64(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x58(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x64(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x60(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x50(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\njmp    1341 <fix_fft+0x158>\nnop\naddl   $0x1,-0x64(%rbp)\nmov    -0x64(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njle    124b <fix_fft+0x62>\nmovl   $0x1,-0x44(%rbp)\nmovl   $0x9,-0x40(%rbp)\njmp    15fd <fix_fft+0x414>\ncmpl   $0x0,-0x68(%rbp)\nje     13f5 <fix_fft+0x20c>\nmovl   $0x0,-0x38(%rbp)\nmovl   $0x0,-0x4c(%rbp)\njmp    13e1 <fix_fft+0x1f8>\nmov    -0x4c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x48(%rbp)\ncmpl   $0x0,-0x48(%rbp)\njns    13a0 <fix_fft+0x1b7>\nnegl   -0x48(%rbp)\nmov    -0x4c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x64(%rbp)\ncmpl   $0x0,-0x64(%rbp)\njns    13c2 <fix_fft+0x1d9>\nnegl   -0x64(%rbp)\ncmpl   $0x3fff,-0x48(%rbp)\njg     13d4 <fix_fft+0x1eb>\ncmpl   $0x3fff,-0x64(%rbp)\njle    13dd <fix_fft+0x1f4>\nmovl   $0x1,-0x38(%rbp)\njmp    13e9 <fix_fft+0x200>\naddl   $0x1,-0x4c(%rbp)\nmov    -0x4c(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     137e <fix_fft+0x195>\ncmpl   $0x0,-0x38(%rbp)\nje     13fc <fix_fft+0x213>\naddl   $0x1,-0x3c(%rbp)\njmp    13fc <fix_fft+0x213>\nmovl   $0x1,-0x38(%rbp)\nmov    -0x44(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,-0x1c(%rbp)\nmovl   $0x0,-0x64(%rbp)\njmp    15e7 <fix_fft+0x3fe>\nmov    -0x40(%rbp),%eax\nmov    -0x64(%rbp),%edx\nmov    %eax,%ecx\nshl    %cl,%edx\nmov    %edx,%eax\nmov    %eax,-0x48(%rbp)\nmov    -0x48(%rbp),%eax\nadd    $0x100,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x6be8(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0x2c(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x6bce(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nneg    %eax\nmov    %eax,-0x28(%rbp)\ncmpl   $0x0,-0x68(%rbp)\nje     1463 <fix_fft+0x27a>\nnegl   -0x28(%rbp)\ncmpl   $0x0,-0x38(%rbp)\nje     146f <fix_fft+0x286>\nsarl   -0x2c(%rbp)\nsarl   -0x28(%rbp)\nmov    -0x64(%rbp),%eax\nmov    %eax,-0x4c(%rbp)\njmp    15d7 <fix_fft+0x3ee>\nmov    -0x4c(%rbp),%edx\nmov    -0x44(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x48(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x2c(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1931 <fix_mpy>\nmov    %eax,%ebx\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x28(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1931 <fix_mpy>\nmov    %eax,%edx\nmov    %ebx,%eax\nsub    %edx,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x2c(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1931 <fix_mpy>\nmov    %eax,%ebx\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x28(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1931 <fix_mpy>\nadd    %ebx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x4c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x4c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x30(%rbp)\ncmpl   $0x0,-0x38(%rbp)\nje     155d <fix_fft+0x374>\nsarl   -0x34(%rbp)\nsarl   -0x30(%rbp)\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x34(%rbp),%eax\nsub    -0x18(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x48(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x30(%rbp),%eax\nsub    -0x14(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x4c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x34(%rbp),%ecx\nmov    -0x18(%rbp),%edx\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x4c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x60(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x30(%rbp),%ecx\nmov    -0x14(%rbp),%edx\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x1c(%rbp),%eax\nadd    %eax,-0x4c(%rbp)\nmov    -0x4c(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     147a <fix_fft+0x291>\naddl   $0x1,-0x64(%rbp)\nmov    -0x64(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     1410 <fix_fft+0x227>\nsubl   $0x1,-0x40(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     1364 <fix_fft+0x17b>\nmov    -0x3c(%rbp),%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "fix_loud", "content": "/* fix_loud() - compute loudness of freq-spectrum components.\n   n should be ntot/2, where ntot was passed to fix_fft();\n   6 dB is added to account for the omitted alias components.\n   scale_shift should be the result of fix_fft(), if the time-series\n   was obtained from an inverse FFT, 0 otherwise.\n   loud[] is the loudness, in dB wrt 32767; will be +10 to -N_LOUD.\n*/\nvoid\nfix_loud(fixed loud[], fixed fr[], fixed fi[], int n, int scale_shift)\n{\n  int i, max;\n\n  max = 0;\n  if(scale_shift > 0)\n    max = 10;\n  scale_shift = (scale_shift+1) * 6;\n\n  for(i=0; i<n; ++i) {\n    loud[i] = db_from_ampl(fr[i],fi[i]) + scale_shift;\n    if(loud[i] > max)\n      loud[i] = max;\n  }\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O0.pseudo", "function_name": "fix_loud", "address": "0x171d", "label": "fix_loud", "content": "void __cdecl fix_loud(int *loud, int *fr, int *fi, int n, int scale_shift)\n{\n  int scale_shifta; // [rsp+0h] [rbp-30h]\n  int i; // [rsp+28h] [rbp-8h]\n  int max; // [rsp+2Ch] [rbp-4h]\n\n  max = 0;\n  if ( scale_shift > 0 )\n    max = 10;\n  scale_shifta = 6 * (scale_shift + 1);\n  for ( i = 0; i < n; ++i )\n  {\n    loud[i] = scale_shifta + db_from_ampl(fr[i], fi[i]);\n    if ( max < loud[i] )\n      loud[i] = max;\n  }\n}\n"}, "pseudo_normalize": "void fix_loud(int *loud, int *fr, int *fi, int n, int scale_shift) {\n  int scale_shifta;\n  int i;\n  int max;\n  max = 0;\n  if (scale_shift > 0) max = 10;\n  scale_shifta = 6 * (scale_shift + 1);\n  for (i = 0; i < n; ++i) {\n    loud[i] = scale_shifta + db_from_ampl(fr[i], fi[i]);\n    if (max < loud[i]) loud[i] = max;\n  }\n}", "binary": "fft-int/fft-int.host.O0", "assembly": "<fix_loud>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %ecx,-0x2c(%rbp)\nmov    %r8d,-0x30(%rbp)\nmovl   $0x0,-0x4(%rbp)\ncmpl   $0x0,-0x30(%rbp)\njle    1750 <fix_loud+0x33>\nmovl   $0xa,-0x4(%rbp)\nmov    -0x30(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nmov    %eax,-0x30(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    17f7 <fix_loud+0xda>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1807 <db_from_ampl>\nmov    %eax,%edx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    -0x30(%rbp),%ecx\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x4(%rbp)\njge    17f3 <fix_loud+0xd6>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     176d <fix_loud+0x50>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "fix_mpy", "content": "/* fix_mpy() - fixed-point multiplication */\nfixed\nfix_mpy(fixed a, fixed b)\n{\n  FIX_MPY(a,a,b);\n  return a;\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O0.pseudo", "function_name": "fix_mpy", "address": "0x1931", "label": "fix_mpy", "content": "int __cdecl fix_mpy(int a, int b)\n{\n  return (b * a) >> 15;\n}\n"}, "pseudo_normalize": "", "binary": "fft-int/fft-int.host.O0", "assembly": "<fix_mpy>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nimul   -0x8(%rbp),%eax\nsar    $0xf,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "iscale", "content": "/* iscale() - scale an integer value by (numer/denom) */\nint\niscale(int value, int numer, int denom)\n{\n  return (int) value * (int)numer/(int)denom;\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O0.pseudo", "function_name": "iscale", "address": "0x1951", "label": "iscale", "content": "int __cdecl iscale(int value, int numer, int denom)\n{\n  return numer * value / denom;\n}\n"}, "pseudo_normalize": "", "binary": "fft-int/fft-int.host.O0", "assembly": "<iscale>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %edx,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\nimul   -0x8(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\npop    %rbp\nret\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "window", "content": "/* window() - apply a Hanning window       */\nvoid\nwindow(fixed fr[], int n)\n{\n  int i,j,k;\n\n  j = N_WAVE/n;\n  n >>= 1;\n  for(i=0,k=N_WAVE/4; i<n; ++i,k+=j)\n    FIX_MPY(fr[i],fr[i],16384-(Sinewave[k]>>1));\n  n <<= 1;\n  for(k-=j; i<n; ++i,k-=j)\n    FIX_MPY(fr[i],fr[i],16384-(Sinewave[k]>>1));\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O0.pseudo", "function_name": "window", "address": "0x1612", "label": "window", "content": "void __cdecl window(int *fr, int n)\n{\n  int na; // [rsp+0h] [rbp-1Ch]\n  int nb; // [rsp+0h] [rbp-1Ch]\n  int i; // [rsp+10h] [rbp-Ch]\n  int k; // [rsp+14h] [rbp-8h]\n  int ka; // [rsp+14h] [rbp-8h]\n  int j; // [rsp+18h] [rbp-4h]\n\n  j = 1024 / n;\n  na = n >> 1;\n  i = 0;\n  k = 256;\n  while ( i < na )\n  {\n    fr[i] = (fr[i] * (0x4000 - (Sinewave[k] >> 1))) >> 15;\n    ++i;\n    k += j;\n  }\n  nb = 2 * na;\n  ka = k - j;\n  while ( i < nb )\n  {\n    fr[i] = (fr[i] * (0x4000 - (Sinewave[ka] >> 1))) >> 15;\n    ++i;\n    ka -= j;\n  }\n}\n"}, "pseudo_normalize": "void window(int *fr, int n) {\n  int na;\n  int nb;\n  int i;\n  int k;\n  int ka;\n  int j;\n  j = 1024 / n;\n  na = n >> 1;\n  i = 0;\n  k = 256;\n  while (i < na) {\n    fr[i] = (fr[i] * (16384 - (Sinewave[k] >> 1))) >> 15;\n    ++i;\n    k += j;\n  }\n  nb = 2 * na;\n  ka = k - j;\n  while (i < nb) {\n    fr[i] = (fr[i] * (16384 - (Sinewave[ka] >> 1))) >> 15;\n    ++i;\n    ka -= j;\n  }\n}", "binary": "fft-int/fft-int.host.O0", "assembly": "<window>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    $0x400,%eax\ncltd\nidivl  -0x1c(%rbp)\nmov    %eax,-0x4(%rbp)\nsarl   -0x1c(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x100,-0x8(%rbp)\njmp    169f <window+0x8d>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nlea    0x69b5(%rip),%rdx\nmov    (%rcx,%rdx,1),%edx\nmov    %edx,%ecx\nsar    %ecx\nmov    $0x4000,%edx\nsub    %ecx,%edx\nimul   %eax,%edx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nsar    $0xf,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\nadd    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1640 <window+0x2e>\nshll   -0x1c(%rbp)\nmov    -0x4(%rbp),%eax\nsub    %eax,-0x8(%rbp)\njmp    1711 <window+0xff>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nlea    0x6943(%rip),%rdx\nmov    (%rcx,%rdx,1),%edx\nmov    %edx,%ecx\nsar    %ecx\nmov    $0x4000,%edx\nsub    %ecx,%edx\nimul   %eax,%edx\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nsar    $0xf,%edx\nmov    %edx,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0x4(%rbp),%eax\nsub    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     16b2 <window+0xa0>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "flood-fill/flood-fill.c", "function_name": "main", "content": " \nint\nmain()\n{\n\n  // start node\n  int x = 3, y = 9;    // having a target color `X`\n\n  // replacement color, NOTE: must be a new color!\n  char replacement = 'C';\n\n  // print the colors before replacement\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", replacement, x, y); printMatrix(mat);\n\n  // replace the target color with a replacement color using DFS\n  floodfill(mat, x, y, replacement);\n\n  // print the colors after replacement\n  libmin_printf(\"\\nAFTER:\\n\"); printMatrix(mat);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "flood-fill/flood-fill.host.O0.pseudo", "function_name": "main", "address": "0x144d", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char (*)[10])mat);\n  floodfill((char (*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char (*)[10])mat);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char(*)[10])mat);\n  floodfill((char(*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char(*)[10])mat);\n  libmin_success();\n}", "binary": "flood-fill/flood-fill.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x3,-0x8(%rbp)\nmovl   $0x9,-0x4(%rbp)\nmovb   $0x43,-0x9(%rbp)\nmovsbl -0x9(%rbp),%eax\nmov    -0x4(%rbp),%ecx\nmov    -0x8(%rbp),%edx\nmov    %eax,%esi\nlea    0x2b92(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3626 <libmin_printf>\nlea    0x4b8e(%rip),%rax\nmov    %rax,%rdi\ncall   13c0 <printMatrix>\nmovsbl -0x9(%rbp),%ecx\nmov    -0x4(%rbp),%eax\nmovsbl %al,%edx\nmov    -0x8(%rbp),%eax\nmovsbl %al,%eax\nmov    %eax,%esi\nlea    0x4b6d(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <floodfill>\nlea    0x2b70(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3626 <libmin_printf>\nlea    0x4b4a(%rip),%rax\nmov    %rax,%rdi\ncall   13c0 <printMatrix>\ncall   3893 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "flood-fill/flood-fill.c", "function_name": "printMatrix", "content": " \n// Utility function to print a matrix\nvoid\nprintMatrix(char mat[M][N])\n{\n  for (int i = 0; i < M; i++)\n  {\n    for (int j = 0; j < N; j++)\n      libmin_printf(\"  %c\", mat[i][j]);\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo": {"path": "flood-fill/flood-fill.host.O0.pseudo", "function_name": "printMatrix", "address": "0x13c0", "label": "printMatrix", "content": "void __cdecl printMatrix(char (*mat)[10])\n{\n  int i; // [rsp+18h] [rbp-8h]\n  int j; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; i <= 9; ++i )\n  {\n    for ( j = 0; j <= 9; ++j )\n      libmin_printf(\"  %c\", (unsigned int)(*mat)[10 * i + j]);\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo_normalize": "void printMatrix(char (*mat)[10]) {\n  int i;\n  int j;\n  for (i = 0; i <= 9; ++i) {\n    for (j = 0; j <= 9; ++j)\n      libmin_printf(\"  %c\", (unsigned int)(*mat)[10 * i + j]);\n    libmin_printf(\"\\n\");\n  }\n}", "binary": "flood-fill/flood-fill.host.O0", "assembly": "<printMatrix>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1443 <printMatrix+0x83>\nmovl   $0x0,-0x4(%rbp)\njmp    1425 <printMatrix+0x65>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmovzbl (%rdx,%rax,1),%eax\nmovsbl %al,%eax\nmov    %eax,%esi\nlea    0x2bf4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3626 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njle    13e2 <printMatrix+0x22>\nlea    0x2bdb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3626 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x9,-0x8(%rbp)\njle    13d9 <printMatrix+0x19>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "avaliatokens", "content": "/* ---------------------------------------------------------------------- */\nvoid avaliatokens(char *aux[SBUFF],  int frac[MYMAX], int i) /* analyzes the tokens, to check the fractions */\n{\n    int j, k = 0;\n    char *token2;\n    int mist;\n\n    /* 1 mist first fraction */\n    if(((libmin_strcmp(aux[2], \"+\") == 0) || (libmin_strcmp(aux[2], \"-\") == 0) || (libmin_strcmp(aux[2], \"*\") == 0) || (libmin_strcmp(aux[2], \"/\") == 0)) && i == 4)\n        mist = 1;\n    /* 1 mist second fraction */\n    if(((libmin_strcmp(aux[1], \"+\") == 0) || (libmin_strcmp(aux[1], \"-\") == 0) || (libmin_strcmp(aux[1], \"*\") == 0) || (libmin_strcmp(aux[1], \"/\") == 0)) && i == 4)\n        mist = 2;\n    \n    for(j = 0; j < i; j++)\n    {\n        if((libmin_strcmp(aux[j], \"+\") == 0))\n        {\n            frac[MYMAX - 1] = 1;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"-\") == 0))\n        {\n            frac[MYMAX - 1] = 2;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"*\") == 0))\n        {\n            frac[MYMAX - 1] = 3;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"/\") == 0))\n        {\n            frac[MYMAX - 1] = 4;\n            j++;\n        }\n\n        token2 = libmin_strtok(aux[j], \"/\"); /* divides the equation into tokens */\n        while(token2 != NULL)\n        {\n            frac[k] = libmin_atoi(token2); /* stores tokens in the array */\n            token2 = libmin_strtok(NULL, \"/\");\n            k++;\n        }\n    }\n    misto(mist, frac, i);\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O0.pseudo", "function_name": "avaliatokens", "address": "0x16af", "label": "avaliatokens", "content": "void __cdecl avaliatokens(char **aux, int *frac, int i)\n{\n  int j; // [rsp+2Ch] [rbp-24h]\n  int k; // [rsp+30h] [rbp-20h]\n  int mist; // [rsp+34h] [rbp-1Ch]\n  const char *token2; // [rsp+38h] [rbp-18h]\n\n  k = 0;\n  if ( (!libmin_strcmp(aux[2], \"+\")\n     || !libmin_strcmp(aux[2], \"-\")\n     || !libmin_strcmp(aux[2], \"*\")\n     || !libmin_strcmp(aux[2], \"/\"))\n    && i == 4 )\n  {\n    mist = 1;\n  }\n  if ( (!libmin_strcmp(aux[1], \"+\")\n     || !libmin_strcmp(aux[1], \"-\")\n     || !libmin_strcmp(aux[1], \"*\")\n     || !libmin_strcmp(aux[1], \"/\"))\n    && i == 4 )\n  {\n    mist = 2;\n  }\n  for ( j = 0; j < i; ++j )\n  {\n    if ( !libmin_strcmp(aux[j], \"+\") )\n    {\n      frac[10] = 1;\n      ++j;\n    }\n    if ( !libmin_strcmp(aux[j], \"-\") )\n    {\n      frac[10] = 2;\n      ++j;\n    }\n    if ( !libmin_strcmp(aux[j], \"*\") )\n    {\n      frac[10] = 3;\n      ++j;\n    }\n    if ( !libmin_strcmp(aux[j], \"/\") )\n    {\n      frac[10] = 4;\n      ++j;\n    }\n    token2 = libmin_strtok(aux[j], \"/\");\n    while ( token2 )\n    {\n      frac[k] = libmin_atoi(token2);\n      token2 = libmin_strtok(0LL, \"/\");\n      ++k;\n    }\n  }\n  misto(mist, frac, i);\n}\n"}, "pseudo_normalize": "void avaliatokens(char **aux, int *frac, int i) {\n  int j;\n  int k;\n  int mist;\n  const char *token2;\n  k = 0;\n  if ((!libmin_strcmp(aux[2], \"+\") || !libmin_strcmp(aux[2], \"-\") ||\n       !libmin_strcmp(aux[2], \"*\") || !libmin_strcmp(aux[2], \"/\")) &&\n      i == 4) {\n    mist = 1;\n  }\n  if ((!libmin_strcmp(aux[1], \"+\") || !libmin_strcmp(aux[1], \"-\") ||\n       !libmin_strcmp(aux[1], \"*\") || !libmin_strcmp(aux[1], \"/\")) &&\n      i == 4) {\n    mist = 2;\n  }\n  for (j = 0; j < i; ++j) {\n    if (!libmin_strcmp(aux[j], \"+\")) {\n      frac[10] = 1;\n      ++j;\n    }\n    if (!libmin_strcmp(aux[j], \"-\")) {\n      frac[10] = 2;\n      ++j;\n    }\n    if (!libmin_strcmp(aux[j], \"*\")) {\n      frac[10] = 3;\n      ++j;\n    }\n    if (!libmin_strcmp(aux[j], \"/\")) {\n      frac[10] = 4;\n      ++j;\n    }\n    token2 = libmin_strtok(aux[j], \"/\");\n    while (token2) {\n      frac[k] = libmin_atoi(token2);\n      token2 = libmin_strtok(0LL, \"/\");\n      ++k;\n    }\n  }\n  misto(mist, frac, i);\n}", "binary": "frac-calc/frac-calc.host.O0", "assembly": "<avaliatokens>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %edx,-0x44(%rbp)\nmovl   $0x0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nlea    0x4d75(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\nje     1752 <avaliatokens+0xa3>\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nlea    0x4d56(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\nje     1752 <avaliatokens+0xa3>\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nlea    0x4d37(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\nje     1752 <avaliatokens+0xa3>\nmov    -0x38(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%rax\nlea    0x4d18(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\njne    175f <avaliatokens+0xb0>\ncmpl   $0x4,-0x44(%rbp)\njne    175f <avaliatokens+0xb0>\nmovl   $0x1,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nlea    0x4ce4(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\nje     17e3 <avaliatokens+0x134>\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nlea    0x4cc5(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\nje     17e3 <avaliatokens+0x134>\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nlea    0x4ca6(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\nje     17e3 <avaliatokens+0x134>\nmov    -0x38(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%rax\nlea    0x4c87(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\njne    17f0 <avaliatokens+0x141>\ncmpl   $0x4,-0x44(%rbp)\njne    17f0 <avaliatokens+0x141>\nmovl   $0x2,-0x1c(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    1971 <avaliatokens+0x2c2>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x4c3b(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\njne    183b <avaliatokens+0x18c>\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmovl   $0x1,(%rax)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x4bfe(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\njne    187a <avaliatokens+0x1cb>\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmovl   $0x2,(%rax)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x4bc1(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\njne    18b9 <avaliatokens+0x20a>\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmovl   $0x3,(%rax)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x4b84(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4ae4 <libmin_strcmp>\ntest   %eax,%eax\njne    18f8 <avaliatokens+0x249>\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmovl   $0x4,(%rax)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nlea    0x4b45(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c4b <libmin_strtok>\nmov    %rax,-0x18(%rbp)\njmp    1966 <avaliatokens+0x2b7>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x40(%rbp),%rax\nlea    (%rdx,%rax,1),%rbx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   2168 <libmin_atoi>\nmov    %eax,(%rbx)\nlea    0x4b0a(%rip),%rax\nmov    %rax,%rsi\nmov    $0x0,%edi\ncall   4c4b <libmin_strtok>\nmov    %rax,-0x18(%rbp)\naddl   $0x1,-0x20(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1927 <avaliatokens+0x278>\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njl     17fc <avaliatokens+0x14d>\nmov    -0x44(%rbp),%edx\nmov    -0x40(%rbp),%rcx\nmov    -0x1c(%rbp),%eax\nmov    %rcx,%rsi\nmov    %eax,%edi\ncall   1998 <misto>\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "calcula", "content": "/* ---------------------------------------------------------------------- */\nfloat calcula(int frac[MYMAX], int r[MYMAX]) /* computes the fraction */\n{\n    float dec = 0, a, b;\n\n    r[0] = frac[1] * frac[3]; /* mmc */\n    switch(frac[MYMAX - 1]) /* operation */\n    {\n        case 1: /* + */\n            r[1] = (r[0] / frac[1]) * frac[0] + (r[0] / frac[3]) * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 2: /* - */\n            r[1] = (r[0] / frac[1]) * frac[0] - (r[0] / frac[3]) * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 3: /* * */\n            r[1] = frac[0] * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 4: /* / */\n            r[0] = frac[1] * frac[2];\n            r[1] = frac[0] * frac[3];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n    }\n\n    return dec;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O0.pseudo", "function_name": "calcula", "address": "0x1bfc", "label": "calcula", "content": "float __cdecl calcula(int *frac, int *r)\n{\n  int v2; // eax\n  float dec; // [rsp+14h] [rbp-Ch]\n\n  dec = 0.0;\n  *r = frac[3] * frac[1];\n  v2 = frac[10];\n  if ( v2 == 4 )\n  {\n    *r = frac[2] * frac[1];\n    r[1] = *frac * frac[3];\n    dec = (float)r[1] / (float)*r;\n    simplifica(r);\n  }\n  else if ( v2 <= 4 )\n  {\n    switch ( v2 )\n    {\n      case 3:\n        r[1] = *frac * frac[2];\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n      case 1:\n        r[1] = *frac * (*r / frac[1]) + frac[2] * (*r / frac[3]);\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n      case 2:\n        r[1] = *frac * (*r / frac[1]) - frac[2] * (*r / frac[3]);\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n    }\n  }\n  return dec;\n}\n"}, "pseudo_normalize": "float calcula(int *frac, int *r) {\n  int v2;\n  float dec;\n  dec = 0.0;\n  *r = frac[3] * frac[1];\n  v2 = frac[10];\n  if (v2 == 4) {\n    *r = frac[2] * frac[1];\n    r[1] = *frac * frac[3];\n    dec = (float)r[1] / (float)*r;\n    simplifica(r);\n  } else if (v2 <= 4) {\n    switch (v2) {\n      case 3:\n        r[1] = *frac * frac[2];\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n      case 1:\n        r[1] = *frac * (*r / frac[1]) + frac[2] * (*r / frac[3]);\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n      case 2:\n        r[1] = *frac * (*r / frac[1]) - frac[2] * (*r / frac[3]);\n        dec = (float)r[1] / (float)*r;\n        simplifica(r);\n        break;\n    }\n  }\n  return dec;\n}", "binary": "frac-calc/frac-calc.host.O0", "assembly": "<calcula>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x20(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nadd    $0x28,%rax\nmov    (%rax),%eax\ncmp    $0x4,%eax\nje     1e12 <calcula+0x216>\ncmp    $0x4,%eax\njg     1e92 <calcula+0x296>\ncmp    $0x3,%eax\nje     1dab <calcula+0x1af>\ncmp    $0x3,%eax\njg     1e92 <calcula+0x296>\ncmp    $0x1,%eax\nje     1c77 <calcula+0x7b>\ncmp    $0x2,%eax\nje     1d0f <calcula+0x113>\njmp    1e92 <calcula+0x296>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%edi\ncltd\nidiv   %edi\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %edx,%ecx\nimul   %eax,%ecx\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0xc,%rdx\nmov    (%rdx),%esi\ncltd\nidiv   %esi\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1e99 <simplifica>\njmp    1e92 <calcula+0x296>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0x4,%rdx\nmov    (%rdx),%edi\ncltd\nidiv   %edi\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %edx,%ecx\nimul   %eax,%ecx\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    -0x18(%rbp),%rdx\nadd    $0xc,%rdx\nmov    (%rdx),%esi\ncltd\nidiv   %esi\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    %edx,%esi\nimul   %eax,%esi\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nsub    %esi,%ecx\nmov    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1e99 <simplifica>\njmp    1e92 <calcula+0x296>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nadd    $0x4,%rdx\nimul   %ecx,%eax\nmov    %eax,(%rdx)\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1e99 <simplifica>\njmp    1e92 <calcula+0x296>\nmov    -0x18(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x20(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%ecx\nmov    -0x18(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    -0x20(%rbp),%rdx\nadd    $0x4,%rdx\nimul   %ecx,%eax\nmov    %eax,(%rdx)\nmov    -0x20(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\npxor   %xmm0,%xmm0\ncvtsi2ss %eax,%xmm0\nmovss  %xmm0,-0x4(%rbp)\nmovss  -0x8(%rbp),%xmm0\ndivss  -0x4(%rbp),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1e99 <simplifica>\nnop\nmovss  -0xc(%rbp),%xmm0\nleave\nret\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "copyr", "content": "/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief Prints version and copyright information and exit\n * @details Prints version and copyright information (usually called by opt -V)\n * @return Void\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nvoid copyr(void)\n{\n    IFDEBUG(\"copyr()\");\n    libmin_printf(\"%s - Version %s\\n\", \"frac\", VERSION);\n    libmin_printf(\"\\nCopyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author takes no responsability to any damage this software may inflige in your data.\\n\\n\", 2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n    if(verb > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", verb); /* -vvvv */\n    libmin_fail(1);\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O0.pseudo", "function_name": "copyr", "address": "0x14d4", "label": "copyr", "content": "void __cdecl __noreturn copyr()\n{\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n    \"\\n\"\n    \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are fr\"\n    \"ee to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author \"\n    \"takes no responsability to any damage this software may inflige in your data.\\n\"\n    \"\\n\",\n    2018,\n    \"Iago Gade Gusmao Carrazzoni\",\n    \"iagocarrazzoni@gmail.com\");\n  if ( verb > 3 )\n    libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "void __noreturn copyr() {\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n      \"\\n\"\n      \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http:\n      \"ee to change and redistribute it. There is NO WARRANTY, to the extent \"\n      \"permitted by law. USE IT AS IT IS. The author \"\n      \"takes no responsability to any damage this software may inflige in your \"\n      \"data.\\n\"\n      \"\\n\",\n      2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  if (verb > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}", "binary": "frac-calc/frac-calc.host.O0", "assembly": "<copyr>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    0x4d64(%rip),%rax\nmov    %rax,%rdx\nlea    0x4bde(%rip),%rax\nmov    %rax,%rsi\nlea    0x4d60(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4ce8(%rip),%rax\nmov    %rax,%rcx\nlea    0x4cf7(%rip),%rax\nmov    %rax,%rdx\nmov    $0x7e2,%esi\nlea    0x4d44(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nmov    0x7d75(%rip),%eax\ncmp    $0x3,%eax\njle    1558 <copyr+0x84>\nmov    0x7d6a(%rip),%eax\nmov    %eax,%esi\nlea    0x4e56(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nmov    $0x1,%edi\ncall   2270 <libmin_fail>\nnop\npop    %rbp\nret\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "divtokens", "content": "/* ---------------------------------------------------------------------- */\nvoid divtokens(char exp[SBUFF],  int frac[MYMAX]) /* break the string in tokens */\n{\n    char *token; /* token pointer */\n    char exp2[SBUFF];\n    char *aux[SBUFF];\n    int i = 0;\n\n    libmin_strcpy(exp2, exp); /* to maintain the original expression untouched */\n\n    token = libmin_strtok(exp2, \" \"); /* divides the equation into tokens */\n    while(token != NULL)\n    {\n        aux[i] = token;\n        token = libmin_strtok(NULL, \" \");\n        i++;\n    }\n\n    frac[MYMAX - 2] = i; /* number of elements of the expression */\n\n    avaliatokens(aux, frac, i);\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O0.pseudo", "function_name": "divtokens", "address": "0x15b8", "label": "divtokens", "content": "void __cdecl divtokens(char *exp, int *frac)\n{\n  int i; // [rsp+14h] [rbp-23Ch]\n  char *token; // [rsp+18h] [rbp-238h]\n  char *aux[60]; // [rsp+20h] [rbp-230h] BYREF\n  char exp2[72]; // [rsp+200h] [rbp-50h] BYREF\n  unsigned __int64 v6; // [rsp+248h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  i = 0;\n  libmin_strcpy(exp2, exp);\n  token = libmin_strtok(exp2, \" \");\n  while ( token )\n  {\n    aux[i] = token;\n    token = libmin_strtok(0LL, \" \");\n    ++i;\n  }\n  frac[9] = i;\n  avaliatokens(aux, frac, i);\n}\n"}, "pseudo_normalize": "void divtokens(char *exp, int *frac) {\n  int i;\n  char *token;\n  char *aux[60];\n  char exp2[72];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  i = 0;\n  libmin_strcpy(exp2, exp);\n  token = libmin_strtok(exp2, \" \");\n  while (token) {\n    aux[i] = token;\n    token = libmin_strtok(0LL, \" \");\n    ++i;\n  }\n  frac[9] = i;\n  avaliatokens(aux, frac, i);\n}", "binary": "frac-calc/frac-calc.host.O0", "assembly": "<divtokens>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x250,%rsp\nmov    %rdi,-0x248(%rbp)\nmov    %rsi,-0x250(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x23c(%rbp)\nmov    -0x248(%rbp),%rdx\nlea    -0x50(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4b42 <libmin_strcpy>\nlea    -0x50(%rbp),%rax\nlea    0x4e44(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c4b <libmin_strtok>\nmov    %rax,-0x238(%rbp)\njmp    165c <divtokens+0xa4>\nmov    -0x23c(%rbp),%eax\ncltq\nmov    -0x238(%rbp),%rdx\nmov    %rdx,-0x230(%rbp,%rax,8)\nlea    0x4e12(%rip),%rax\nmov    %rax,%rsi\nmov    $0x0,%edi\ncall   4c4b <libmin_strtok>\nmov    %rax,-0x238(%rbp)\naddl   $0x1,-0x23c(%rbp)\ncmpq   $0x0,-0x238(%rbp)\njne    1623 <divtokens+0x6b>\nmov    -0x250(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x23c(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x23c(%rbp),%edx\nmov    -0x250(%rbp),%rcx\nlea    -0x230(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   16af <avaliatokens>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     16ad <divtokens+0xf5>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "frac_init", "content": "/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief This function initializes some operations before start\n * @details Details to be written in\n * multiple lines\n *\n * @pre You need to call foo() before calling this function\n *\n * @param[in] i Input parameter that does bla\n * @param[out] o Parameter that outputs ble\n * @param[in,out] z The @a z variable is used as input and output\n *\n * @retval 0 Returned when bli\n * @retval 1 Error code: function returned blo\n *\n * @par Example\n * @code\n *    if(x == funcexample(i, o, z))\n *       printf(\"And that is it\\n\");\n * @endcode\n *\n * @return Void\n *\n * @warning Be carefull with blu\n * @todo Need to implement it. Its empty now. This doxygen tags are overwhelming.\n * Mandatory tags are: ingroup, brief, details, param, return, author and date.\n * The others are optional.\n *\n * @deprecated This function will be deactivated in version +11\n * @see help()\n * @see copyr()\n * @bug There is a bug with x greater than y\n * @note You can read more about it at <<a href=\"http://www.upe.br\">www.upe.br</a>>\n *\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n * @copyright Use this tag only if not the same as the whole file\n *\n */\nvoid frac_init(char exp[SBUFF])\n{\n    /* IFDEBUG(\"frac_init()\"); */\n    libmin_printf(\"-------------------\\n\");\n    libmin_printf(\"FRACTION CALCULATOR\\nPlease entry the desired operation:\\n(It is necessary to add a space between the fractions, like a/b + c/d)\\n-> \");\n    libmin_mgets(exp, SBUFF, minput); /* expression input */\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O0.pseudo", "function_name": "frac_init", "address": "0x1565", "label": "frac_init", "content": "void __cdecl frac_init(char *exp)\n{\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\"FRACTION CALCULATOR\\n\"\n                \"Please entry the desired operation:\\n\"\n                \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n                \"-> \");\n  libmin_mgets(exp, 0x3CuLL, minput);\n}\n"}, "pseudo_normalize": "void frac_init(char *exp) {\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\n      \"FRACTION CALCULATOR\\n\"\n      \"Please entry the desired operation:\\n\"\n      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n      \"-> \");\n  libmin_mgets(exp, 60uLL, minput);\n}", "binary": "frac-calc/frac-calc.host.O0", "assembly": "<frac_init>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nlea    0x4e3b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4e40(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nmov    0x7a9c(%rip),%rdx\nmov    -0x8(%rbp),%rax\nmov    $0x3c,%esi\nmov    %rax,%rdi\ncall   2694 <libmin_mgets>\nnop\nleave\nret\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "help", "content": "/* functions */\n/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief Prints help information and exit\n * @details Prints help information (usually called by opt -h)\n * @return Void\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nvoid help(void)\n{\n    IFDEBUG(\"help()\");\n    libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n    libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n    libmin_printf(\"\\nOptions:\\n\");\n    libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n    libmin_printf(\"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n    libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n    /* add more options here */\n    libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n    libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n    libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\", \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n    libmin_fail(1);\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O0.pseudo", "function_name": "help", "address": "0x13d9", "label": "help", "content": "void __cdecl __noreturn help()\n{\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\", \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "void __noreturn help() {\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\n      \"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\",\n                \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}", "binary": "frac-calc/frac-calc.host.O0", "assembly": "<help>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    0x4ccf(%rip),%rax\nmov    %rax,%rdx\nlea    0x4cd9(%rip),%rax\nmov    %rax,%rsi\nlea    0x4cd4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4cbb(%rip),%rax\nmov    %rax,%rsi\nlea    0x4cbf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4cbf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4cb6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4cc2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4cee(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4d12(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4d36(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    0x4d4d(%rip),%rax\nmov    %rax,%rdx\nlea    0x4d5c(%rip),%rax\nmov    %rax,%rsi\nlea    0x4d6e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nmov    $0x1,%edi\ncall   2270 <libmin_fail>\nnop\npop    %rbp\nret\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "main", "content": " /* print the results */\n\n/* main */\n/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief This is the main event of the evening\n * @details Ladies and Gentleman... It's tiiiime!\n * Fightiiiiing at the blue corner,\n * he, who has compiled more C code than any other adversary in the history,\n * he, who has developed UNIX and Linux, and is an inspiration to maaany languages\n * and compilers, the GNU C Compiler, GCC!\n * Fightiiiiing at the red corner, the challenger, in his first fight, lacking of any\n * valid experience but angrily, blindly, and no doubtfully, will try to\n * compile this program without errors. He, the student, the apprentice,\n * the developer, iggc!!\n *\n * @param[in] argc Argument counter\n * @param[in] argv Argument strings (argument values)\n *\n * @retval 0 If succeed (EXIT_SUCCESS).\n * @retval 1 Or another error code if failed.\n *\n * @par Example\n * @code\n *    $./frac -h\n * @endcode\n *\n * @warning   Be carefull with...\n * @bug There is a bug with...\n * @todo Need to do...\n * @note You can read more about it at <<a href=\"http://www.upe.br\">www.upe.br</a>>\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nint main(int argc, char *argv[])\n{\n    int opt; /* return from getopt() */\n    char exp[SBUFF]; /* expression */\n    int frac[MYMAX];\n    int r[MYMAX];\n    float dec;\n    char rep[SBUFF];\n    int repi = 1;\n\n    /* IFDEBUG(\"Starting optarg loop...\"); */\n\n    /* getopt() configured options:\n     *        -h  help\n     *        -V  version\n     *        -v  verbose\n     */\n    opterr = 0;\n    while((opt = libmin_getopt(argc, argv, \"vhV\")) != EOF)\n        switch(opt)\n        {\n            case 'h':\n                help();\n                break;\n            case 'V':\n                copyr();\n                break;\n            case 'v':\n                verb++;\n                break;\n            case '?':\n            default:\n                libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", argv[0], argv[0]);\n                return 1;\n        }\n\n    if(verb)\n        libmin_printf(\"Verbose level set at: %d\\n\", verb);\n\n    do\n    {\n        frac_init(exp); /* initialization function */\n        divtokens(exp, frac); /* break the string in tokens */\n        dec = calcula(frac, r); /* computes the fraction */\n        print(exp, r, dec, frac); /* prints the results */\n        libmin_printf(\"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, SBUFF, minput);\n        repi = libmin_atoi(rep);\n    }while(repi == 1);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  __m128i v3; // xmm0\n  int opt; // [rsp+18h] [rbp-F8h]\n  int frac[12]; // [rsp+20h] [rbp-F0h] BYREF\n  int r[12]; // [rsp+50h] [rbp-C0h] BYREF\n  char exp[64]; // [rsp+80h] [rbp-90h] BYREF\n  char rep[72]; // [rsp+C0h] [rbp-50h] BYREF\n  unsigned __int64 v10; // [rsp+108h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  opterr = 0;\n  while ( 1 )\n  {\n    opt = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if ( opt == -1 )\n    {\n      if ( verb )\n        libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      do\n      {\n        frac_init(exp);\n        divtokens(exp, frac);\n        *(float *)v3.m128i_i32 = calcula(frac, r);\n        v3 = _mm_cvtsi32_si128(_mm_cvtsi128_si32(v3));\n        print(exp, r, *(float *)v3.m128i_i32, frac);\n        libmin_printf(\"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 0x3CuLL, minput);\n      }\n      while ( libmin_atoi(rep) == 1 );\n      libmin_success();\n    }\n    if ( opt != 118 )\n      break;\n    ++verb;\n  }\n  if ( opt <= 118 )\n  {\n    if ( opt == 86 )\n      copyr();\n    if ( opt == 104 )\n      help();\n  }\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  __m128i v3;\n  int opt;\n  int frac[12];\n  int r[12];\n  char exp[64];\n  char rep[72];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  opterr = 0;\n  while (1) {\n    opt = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if (opt == -1) {\n      if (verb) libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      do {\n        frac_init(exp);\n        divtokens(exp, frac);\n        *(float *)v3.m128i_i32 = calcula(frac, r);\n        v3 = _mm_cvtsi32_si128(_mm_cvtsi128_si32(v3));\n        print(exp, r, *(float *)v3.m128i_i32, frac);\n        libmin_printf(\n            \"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 60uLL, minput);\n      } while (libmin_atoi(rep) == 1);\n      libmin_success();\n    }\n    if (opt != 118) break;\n    ++verb;\n  }\n  if (opt <= 118) {\n    if (opt == 86) copyr();\n    if (opt == 104) help();\n  }\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}", "binary": "frac-calc/frac-calc.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x110,%rsp\nmov    %edi,-0x104(%rbp)\nmov    %rsi,-0x110(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x1,-0xfc(%rbp)\nmovl   $0x0,0x804c(%rip)\njmp    12a2 <main+0xb9>\ncmpl   $0x76,-0xf8(%rbp)\nje     125c <main+0x73>\ncmpl   $0x76,-0xf8(%rbp)\njg     126d <main+0x84>\ncmpl   $0x56,-0xf8(%rbp)\nje     1255 <main+0x6c>\ncmpl   $0x68,-0xf8(%rbp)\njne    126d <main+0x84>\ncall   13d9 <help>\njmp    12a2 <main+0xb9>\ncall   14d4 <copyr>\njmp    12a2 <main+0xb9>\nmov    0x804a(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x8041(%rip)\njmp    12a2 <main+0xb9>\nmov    -0x110(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x110(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x4dad(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nmov    $0x1,%eax\njmp    13c3 <main+0x1da>\nmov    -0x110(%rbp),%rcx\nmov    -0x104(%rbp),%eax\nlea    0x4da7(%rip),%rdx\nmov    %rcx,%rsi\nmov    %eax,%edi\ncall   22a2 <libmin_getopt>\nmov    %eax,-0xf8(%rbp)\ncmpl   $0xffffffff,-0xf8(%rbp)\njne    122a <main+0x41>\nmov    0x7fd3(%rip),%eax\ntest   %eax,%eax\nje     12f9 <main+0x110>\nmov    0x7fc9(%rip),%eax\nmov    %eax,%esi\nlea    0x4d75(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nlea    -0x90(%rbp),%rax\nmov    %rax,%rdi\ncall   1565 <frac_init>\nlea    -0xf0(%rbp),%rdx\nlea    -0x90(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   15b8 <divtokens>\nlea    -0xc0(%rbp),%rdx\nlea    -0xf0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1bfc <calcula>\nmovd   %xmm0,%eax\nmov    %eax,-0xf4(%rbp)\nlea    -0xf0(%rbp),%rdx\nmov    -0xf4(%rbp),%esi\nlea    -0xc0(%rbp),%rcx\nlea    -0x90(%rbp),%rax\nmovd   %esi,%xmm0\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1f16 <print>\nlea    0x4d0b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48b5 <libmin_printf>\nmov    0x7cb7(%rip),%rdx\nlea    -0x50(%rbp),%rax\nmov    $0x3c,%esi\nmov    %rax,%rdi\ncall   2694 <libmin_mgets>\nlea    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   2168 <libmin_atoi>\nmov    %eax,-0xfc(%rbp)\ncmpl   $0x1,-0xfc(%rbp)\nje     12f9 <main+0x110>\ncall   4d0f <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     13d7 <main+0x1ee>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "misto", "content": "/* ---------------------------------------------------------------------- */\nvoid misto(int mist, int frac[MYMAX], int i) /* fraction to mixed number */\n{\n    /* 2 fractions no mist */\n    if(i == 3)\n    {\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    /* 1 mist first fraction */\n    if(mist == 1)\n    {\n        frac[0] = frac[2] * frac[0] + frac[1]; /* num */\n        frac[1] = frac[2]; /* den */\n        frac[2] = frac[3]; /* num */\n        frac[3] = frac[4]; /* den */\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n\n        return;\n    }\n    /* 1 mist second fraction */\n    if(mist == 2)\n    {\n        frac[2] = frac[4] * frac[2] + frac[3];\n        frac[3] = frac[4];\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    /* 2 mist */\n    if(i == 5)\n    {\n        frac[0] = frac[2] * frac[0] + frac[1]; /* num */\n        frac[1] = frac[2]; /* den */\n        frac[2] = frac[5] * frac[3] + frac[4]; /* num */\n        frac[3] = frac[5]; /* den */\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O0.pseudo", "function_name": "misto", "address": "0x1998", "label": "misto", "content": "void __cdecl misto(int mist, int *frac, int i)\n{\n  if ( i == 3 )\n  {\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n  else if ( mist == 1 )\n  {\n    *frac = frac[1] + *frac * frac[2];\n    frac[1] = frac[2];\n    frac[2] = frac[3];\n    frac[3] = frac[4];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n  else if ( mist == 2 )\n  {\n    frac[2] = frac[2] * frac[4] + frac[3];\n    frac[3] = frac[4];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n  else if ( i == 5 )\n  {\n    *frac = frac[1] + *frac * frac[2];\n    frac[1] = frac[2];\n    frac[2] = frac[3] * frac[5] + frac[4];\n    frac[3] = frac[5];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n}\n"}, "pseudo_normalize": "void misto(int mist, int *frac, int i) {\n  if (i == 3) {\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  } else if (mist == 1) {\n    *frac = frac[1] + *frac * frac[2];\n    frac[1] = frac[2];\n    frac[2] = frac[3];\n    frac[3] = frac[4];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  } else if (mist == 2) {\n    frac[2] = frac[2] * frac[4] + frac[3];\n    frac[3] = frac[4];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  } else if (i == 5) {\n    *frac = frac[1] + *frac * frac[2];\n    frac[1] = frac[2];\n    frac[2] = frac[3] * frac[5] + frac[4];\n    frac[3] = frac[5];\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n}", "binary": "frac-calc/frac-calc.host.O0", "assembly": "<misto>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x8(%rbp)\ncmpl   $0x3,-0x8(%rbp)\njne    19f8 <misto+0x60>\nmov    -0x10(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %eax,(%rdx)\njmp    1bfa <misto+0x262>\ncmpl   $0x1,-0x4(%rbp)\njne    1aa2 <misto+0x10a>\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nadd    %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x10(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %eax,(%rdx)\njmp    1bfa <misto+0x262>\ncmpl   $0x2,-0x4(%rbp)\njne    1b34 <misto+0x19c>\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%eax\nmov    %edx,%ecx\nimul   %eax,%ecx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x10(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %eax,(%rdx)\njmp    1bfa <misto+0x262>\ncmpl   $0x5,-0x8(%rbp)\njne    1bf9 <misto+0x261>\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nimul   %eax,%edx\nmov    -0x10(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%eax\nadd    %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0x4(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nadd    $0x14,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%eax\nmov    %edx,%ecx\nimul   %eax,%ecx\nmov    -0x10(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nadd    $0x8,%rax\nadd    %ecx,%edx\nmov    %edx,(%rax)\nmov    -0x10(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x14(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x24(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x20(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x1c(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%eax\nmov    %eax,(%rdx)\nmov    -0x10(%rbp),%rax\nlea    0x18(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    0xc(%rax),%eax\nmov    %eax,(%rdx)\njmp    1bfa <misto+0x262>\nnop\npop    %rbp\nret\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "print", "content": "/* ---------------------------------------------------------------------- */\nvoid print(char exp[SBUFF], int r[MYMAX], float dec, int frac[MYMAX]) /* print the results */\n{\n    char op;\n\n    if(frac[MYMAX - 1] == 1)\n        op = '+';\n    if(frac[MYMAX - 1] == 2)\n        op = '-';\n    if(frac[MYMAX - 1] == 3)\n        op = '*';\n    if(frac[MYMAX - 1] == 4)\n        op = '/';\n    \n    libmin_printf(\"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\", exp, frac[MYMAX - 2], frac[MYMAX - 3], op, frac[MYMAX - 4], frac[MYMAX - 5], r[1], r[0], r[3], r[4], dec);\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O0.pseudo", "function_name": "print", "address": "0x1f16", "label": "print", "content": "void __cdecl print(char *exp, int *r, float dec, int *frac)\n{\n  char op; // [rsp+2Fh] [rbp-11h]\n\n  if ( frac[10] == 1 )\n    op = 43;\n  if ( frac[10] == 2 )\n    op = 45;\n  if ( frac[10] == 3 )\n    op = 42;\n  if ( frac[10] == 4 )\n    op = 47;\n  libmin_printf(\n    \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\",\n    exp,\n    frac[9],\n    frac[8],\n    (unsigned int)op,\n    frac[7],\n    frac[6],\n    r[1],\n    *r,\n    r[3],\n    r[4],\n    dec);\n}\n"}, "pseudo_normalize": "void print(char *exp, int *r, float dec, int *frac) {\n  char op;\n  if (frac[10] == 1) op = 43;\n  if (frac[10] == 2) op = 45;\n  if (frac[10] == 3) op = 42;\n  if (frac[10] == 4) op = 47;\n  libmin_printf(\n      \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: \"\n      \"%d/%d\\nDECIMAL: %.3f\\n\",\n      exp, frac[9], frac[8], (unsigned int)op, frac[7], frac[6], r[1], *r, r[3],\n      r[4], dec);\n}", "binary": "frac-calc/frac-calc.host.O0", "assembly": "<print>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovss  %xmm0,-0x34(%rbp)\nmov    %rdx,-0x40(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmov    (%rax),%eax\ncmp    $0x1,%eax\njne    1f49 <print+0x33>\nmovb   $0x2b,-0x11(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmov    (%rax),%eax\ncmp    $0x2,%eax\njne    1f5c <print+0x46>\nmovb   $0x2d,-0x11(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmov    (%rax),%eax\ncmp    $0x3,%eax\njne    1f6f <print+0x59>\nmovb   $0x2a,-0x11(%rbp)\nmov    -0x40(%rbp),%rax\nadd    $0x28,%rax\nmov    (%rax),%eax\ncmp    $0x4,%eax\njne    1f82 <print+0x6c>\nmovb   $0x2f,-0x11(%rbp)\npxor   %xmm1,%xmm1\ncvtss2sd -0x34(%rbp),%xmm1\nmovq   %xmm1,%rsi\nmov    -0x30(%rbp),%rax\nadd    $0x10,%rax\nmov    (%rax),%r11d\nmov    -0x30(%rbp),%rax\nadd    $0xc,%rax\nmov    (%rax),%r10d\nmov    -0x30(%rbp),%rax\nmov    (%rax),%r9d\nmov    -0x30(%rbp),%rax\nadd    $0x4,%rax\nmov    (%rax),%r8d\nmov    -0x40(%rbp),%rax\nadd    $0x18,%rax\nmov    (%rax),%edi\nmov    -0x40(%rbp),%rax\nadd    $0x1c,%rax\nmov    (%rax),%r12d\nmovsbl -0x11(%rbp),%ebx\nmov    -0x40(%rbp),%rax\nadd    $0x20,%rax\nmov    (%rax),%ecx\nmov    -0x40(%rbp),%rax\nadd    $0x24,%rax\nmov    (%rax),%edx\nmov    -0x28(%rbp),%rax\nsub    $0x8,%rsp\npush   %r11\npush   %r10\npush   %r9\npush   %r8\npush   %rdi\nmovq   %rsi,%xmm0\nmov    %r12d,%r9d\nmov    %ebx,%r8d\nmov    %rax,%rsi\nlea    0x4455(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   48b5 <libmin_printf>\nadd    $0x30,%rsp\nnop\nlea    -0x10(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "simplifica", "content": "/* ---------------------------------------------------------------------- */\nvoid simplifica(int r[MYMAX]) /* simplifies the result */\n{\n    int i;\n    int aux1, aux2;\n\n    aux1 = r[1];\n    aux2 = r[0];\n\n    for(i = 1; i < MYMAX + 2; i++)\n    {\n        if(aux1%i == 0 && aux2%i == 0) /* simplified */\n        {\n            aux1 /= i;\n            aux2 /= i;\n        }\n    }\n    r[3] = aux1;\n    r[4] = aux2;\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O0.pseudo", "function_name": "simplifica", "address": "0x1e99", "label": "simplifica", "content": "void __cdecl simplifica(int *r)\n{\n  int i; // [rsp+Ch] [rbp-Ch]\n  int aux1; // [rsp+10h] [rbp-8h]\n  int aux2; // [rsp+14h] [rbp-4h]\n\n  aux1 = r[1];\n  aux2 = *r;\n  for ( i = 1; i <= 12; ++i )\n  {\n    if ( !(aux1 % i) && !(aux2 % i) )\n    {\n      aux1 /= i;\n      aux2 /= i;\n    }\n  }\n  r[3] = aux1;\n  r[4] = aux2;\n}\n"}, "pseudo_normalize": "void simplifica(int *r) {\n  int i;\n  int aux1;\n  int aux2;\n  aux1 = r[1];\n  aux2 = *r;\n  for (i = 1; i <= 12; ++i) {\n    if (!(aux1 % i) && !(aux2 % i)) {\n      aux1 /= i;\n      aux2 /= i;\n    }\n  }\n  r[3] = aux1;\n  r[4] = aux2;\n}", "binary": "frac-calc/frac-calc.host.O0", "assembly": "<simplifica>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x4(%rax),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x1,-0xc(%rbp)\njmp    1ef3 <simplifica+0x5a>\nmov    -0x8(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    1eef <simplifica+0x56>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    1eef <simplifica+0x56>\nmov    -0x8(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %eax,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0xc(%rbp)\nmov    %eax,-0x4(%rbp)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0xc,-0xc(%rbp)\njle    1ec1 <simplifica+0x28>\nmov    -0x18(%rbp),%rax\nlea    0xc(%rax),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x18(%rbp),%rax\nlea    0x10(%rax),%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "fuzzy-match/fuzzy-match.c", "function_name": "compute_score", "content": "/*\n * Calculate the score for a single matching letter.\n * The scoring system is taken from fts_fuzzy_match v0.2.0 by Forrest Smith,\n * which is licensed to the public domain.\n *\n * The factors affecting score are:\n *   - Bonuses:\n *     - If there are multiple adjacent matches.\n *     - If a match occurs after a separator character.\n *     - If a match is uppercase, and the previous character is lowercase.\n *\n *   - Penalties:\n *     - If there are letters before the first match.\n *     - If there are superfluous characters in str (already accounted for).\n */\nint32_t compute_score(int32_t jump, int first_char, const char *restrict match)\n{\n\tconst int adjacency_bonus = 15;\n\tconst int separator_bonus = 30;\n\tconst int camel_bonus = 30;\n\tconst int first_letter_bonus = 15;\n\n\tconst int leading_letter_penalty = -5;\n\tconst int max_leading_letter_penalty = -15;\n\n\tint32_t score = 0;\n\n\t/* Apply bonuses. */\n\tif (!first_char && jump == 0) {\n\t\tscore += adjacency_bonus;\n\t}\n\tif (!first_char || jump > 0) {\n\t\tif (isupper((unsigned char)*match)\n\t\t\t\t&& islower((unsigned char)*(match - 1))) {\n\t\t\tscore += camel_bonus;\n\t\t}\n\t\tif (isalnum((unsigned char)*match)\n\t\t\t\t&& !isalnum((unsigned char)*(match - 1))) {\n\t\t\tscore += separator_bonus;\n\t\t}\n\t}\n\tif (first_char && jump == 0) {\n\t\t/* Match at start of string gets separator bonus. */\n\t\tscore += first_letter_bonus;\n\t}\n\n\t/* Apply penalties. */\n\tif (first_char) {\n\t\tscore += MAX(leading_letter_penalty * jump,\n\t\t\t\tmax_leading_letter_penalty);\n\t}\n\n\treturn score;\n}\n"}, "pseudo": {"path": "fuzzy-match/fuzzy-match.host.O0.pseudo", "function_name": "compute_score", "address": "0x2379", "label": "compute_score", "content": "int32_t __cdecl compute_score(int32_t jump, int first_char, const char *match)\n{\n  int v3; // eax\n  int32_t score; // [rsp+14h] [rbp-1Ch]\n\n  score = 0;\n  if ( !first_char && !jump )\n    score = 15;\n  if ( !first_char || jump > 0 )\n  {\n    if ( (pctype[*(unsigned __int8 *)match] & 1) != 0 && (pctype[*((unsigned __int8 *)match - 1)] & 2) != 0 )\n      score += 30;\n    if ( (pctype[*(unsigned __int8 *)match] & 7) != 0 && (pctype[*((unsigned __int8 *)match - 1)] & 7) == 0 )\n      score += 30;\n  }\n  if ( first_char && !jump )\n    score += 15;\n  if ( first_char )\n  {\n    v3 = -15;\n    if ( -5 * jump >= -15 )\n      v3 = -5 * jump;\n    score += v3;\n  }\n  return score;\n}\n"}, "pseudo_normalize": "int32_t compute_score(int32_t jump, int first_char, const char *match) {\n  int v3;\n  int32_t score;\n  score = 0;\n  if (!first_char && !jump) score = 15;\n  if (!first_char || jump > 0) {\n    if ((pctype[*(unsigned char *)match] & 1) != 0 &&\n        (pctype[*((unsigned char *)match - 1)] & 2) != 0)\n      score += 30;\n    if ((pctype[*(unsigned char *)match] & 7) != 0 &&\n        (pctype[*((unsigned char *)match - 1)] & 7) == 0)\n      score += 30;\n  }\n  if (first_char && !jump) score += 15;\n  if (first_char) {\n    v3 = -15;\n    if (-5 * jump >= -15) v3 = -5 * jump;\n    score += v3;\n  }\n  return score;\n}", "binary": "fuzzy-match/fuzzy-match.host.O0", "assembly": "<compute_score>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmov    %esi,-0x28(%rbp)\nmov    %rdx,-0x30(%rbp)\nmovl   $0xf,-0x18(%rbp)\nmovl   $0x1e,-0x14(%rbp)\nmovl   $0x1e,-0x10(%rbp)\nmovl   $0xf,-0xc(%rbp)\nmovl   $0xfffffffb,-0x8(%rbp)\nmovl   $0xfffffff1,-0x4(%rbp)\nmovl   $0x0,-0x1c(%rbp)\ncmpl   $0x0,-0x28(%rbp)\njne    23ce <compute_score+0x55>\ncmpl   $0x0,-0x24(%rbp)\njne    23ce <compute_score+0x55>\nmov    -0x18(%rbp),%eax\nadd    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x28(%rbp)\nje     23de <compute_score+0x65>\ncmpl   $0x0,-0x24(%rbp)\njle    2482 <compute_score+0x109>\nmov    0x6323(%rip),%rdx\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     2430 <compute_score+0xb7>\nmov    0x62ff(%rip),%rdx\nmov    -0x30(%rbp),%rax\nsub    $0x1,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x2,%eax\ntest   %eax,%eax\nje     2430 <compute_score+0xb7>\nmov    -0x10(%rbp),%eax\nadd    %eax,-0x1c(%rbp)\nmov    0x62d1(%rip),%rdx\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x7,%eax\ntest   %eax,%eax\nje     2482 <compute_score+0x109>\nmov    0x62ad(%rip),%rdx\nmov    -0x30(%rbp),%rax\nsub    $0x1,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x7,%eax\ntest   %eax,%eax\njne    2482 <compute_score+0x109>\nmov    -0x14(%rbp),%eax\nadd    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x28(%rbp)\nje     2494 <compute_score+0x11b>\ncmpl   $0x0,-0x24(%rbp)\njne    2494 <compute_score+0x11b>\nmov    -0xc(%rbp),%eax\nadd    %eax,-0x1c(%rbp)\ncmpl   $0x0,-0x28(%rbp)\nje     24ae <compute_score+0x135>\nmov    -0x8(%rbp),%eax\nimul   -0x24(%rbp),%eax\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\ncmp    %eax,%edx\ncmovge %edx,%eax\nadd    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "fuzzy-match/fuzzy-match.c", "function_name": "fuzzy_match", "content": "/*\n * Returns score if each character in pattern is found sequentially within str.\n * Returns INT32_MIN otherwise.\n */\nint32_t fuzzy_match(const char *restrict pattern, const char *restrict str)\n{\n\tconst int unmatched_letter_penalty = -1;\n\tconst size_t slen = libmin_strlen(str);\n\tconst size_t plen = libmin_strlen(pattern);\n\tint32_t score = 100;\n\n\tif (*pattern == '\\0') {\n\t\treturn score;\n\t}\n\tif (slen < plen) {\n\t\treturn INT32_MIN;\n\t}\n\n\t/* We can already penalise any unused letters. */\n\tscore += unmatched_letter_penalty * (int32_t)(slen - plen);\n\n\t/* Perform the match. */\n\tscore = fuzzy_match_recurse(pattern, str, score, TRUE);\n\n\treturn score;\n}\n"}, "pseudo": {"path": "fuzzy-match/fuzzy-match.host.O0.pseudo", "function_name": "fuzzy_match", "address": "0x21e9", "label": "fuzzy_match", "content": "int32_t __cdecl fuzzy_match(const char *pattern, const char *str)\n{\n  size_t slen; // [rsp+20h] [rbp-10h]\n  size_t plen; // [rsp+28h] [rbp-8h]\n\n  slen = libmin_strlen(str);\n  plen = libmin_strlen(pattern);\n  if ( !*pattern )\n    return 100;\n  if ( slen >= plen )\n    return fuzzy_match_recurse(pattern, str, plen - slen + 100, 1);\n  return 0x80000000;\n}\n"}, "pseudo_normalize": "int32_t fuzzy_match(const char *pattern, const char *str) {\n  unsigned int slen;\n  unsigned int plen;\n  slen = libmin_strlen(str);\n  plen = libmin_strlen(pattern);\n  if (!*pattern) return 100;\n  if (slen >= plen)\n    return fuzzy_match_recurse(pattern, str, plen - slen + 100, 1);\n  return 2147483648;\n}", "binary": "fuzzy-match/fuzzy-match.host.O0", "assembly": "<fuzzy_match>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0xffffffff,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   4ad9 <libmin_strlen>\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   4ad9 <libmin_strlen>\nmov    %rax,-0x8(%rbp)\nmovl   $0x64,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    223b <fuzzy_match+0x52>\nmov    -0x14(%rbp),%eax\njmp    2281 <fuzzy_match+0x98>\nmov    -0x10(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njae    224c <fuzzy_match+0x63>\nmov    $0x80000000,%eax\njmp    2281 <fuzzy_match+0x98>\nmov    -0x10(%rbp),%rax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nimul   -0x18(%rbp),%eax\nadd    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%edx\nmov    -0x30(%rbp),%rsi\nmov    -0x28(%rbp),%rax\nmov    $0x1,%ecx\nmov    %rax,%rdi\ncall   2283 <fuzzy_match_recurse>\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nleave\nret\n"}
{"source": {"path": "fuzzy-match/fuzzy-match.c", "function_name": "fuzzy_match_recurse", "content": "/*\n * Recursively match the whole of pattern against str.\n * The score parameter is the score of the previously matched character.\n *\n * This reaches a maximum recursion depth of strlen(pattern) + 1. However, the\n * stack usage is small (the maximum I've seen on x86_64 is 144 bytes with\n * gcc -O3), so this shouldn't matter unless pattern contains thousands of\n * characters.\n */\nint32_t fuzzy_match_recurse(\n\t\tconst char *restrict pattern,\n\t\tconst char *restrict str,\n\t\tint32_t score,\n\t\tint first_char)\n{\n\tif (*pattern == '\\0') {\n\t\t/* We've matched the full pattern. */\n\t\treturn score;\n\t}\n\n\tconst char *match = str;\n\tconst char search[2] = { *pattern, '\\0' };\n\n\tint32_t best_score = INT32_MIN;\n\n\t/*\n\t * Find all occurrences of the next pattern character in str, and\n\t * recurse on them.\n\t */\n\twhile ((match = libmin_strcasestr(match, search)) != NULL) {\n\t\tint32_t subscore = fuzzy_match_recurse(\n\t\t\t\tpattern + 1,\n\t\t\t\tmatch + 1,\n\t\t\t\tcompute_score(match - str, first_char, match),\n\t\t\t\tFALSE);\n\t\tbest_score = MAX(best_score, subscore);\n\t\tmatch++;\n\t}\n\n\tif (best_score == INT32_MIN) {\n\t\t/* We couldn't match the rest of the pattern. */\n\t\treturn INT32_MIN;\n\t} else {\n\t\treturn score + best_score;\n\t}\n}\n"}, "pseudo": {"path": "fuzzy-match/fuzzy-match.host.O0.pseudo", "function_name": "fuzzy_match_recurse", "address": "0x2283", "label": "fuzzy_match_recurse", "content": "int32_t __cdecl fuzzy_match_recurse(const char *pattern, const char *str, int32_t score, int first_char)\n{\n  int32_t v5; // eax\n  int32_t matched; // eax\n  int32_t best_score; // [rsp+20h] [rbp-20h]\n  const char *match; // [rsp+28h] [rbp-18h]\n  char *matcha; // [rsp+28h] [rbp-18h]\n  char search[2]; // [rsp+36h] [rbp-Ah] BYREF\n  unsigned __int64 v13; // [rsp+38h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  if ( !*pattern )\n    return score;\n  match = str;\n  search[0] = *pattern;\n  search[1] = 0;\n  best_score = 0x80000000;\n  while ( 1 )\n  {\n    matcha = libmin_strcasestr(match, search);\n    if ( !matcha )\n      break;\n    v5 = compute_score((_DWORD)matcha - (_DWORD)str, first_char, matcha);\n    matched = fuzzy_match_recurse(pattern + 1, matcha + 1, v5, 0);\n    if ( best_score >= matched )\n      matched = best_score;\n    best_score = matched;\n    match = matcha + 1;\n  }\n  if ( best_score == 0x80000000 )\n    return 0x80000000;\n  else\n    return score + best_score;\n}\n"}, "pseudo_normalize": "int32_t fuzzy_match_recurse(const char *pattern, const char *str, int32_t score,\n                            int first_char) {\n  int32_t v5;\n  int32_t matched;\n  int32_t best_score;\n  const char *match;\n  char *matcha;\n  char search[2];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  if (!*pattern) return score;\n  match = str;\n  search[0] = *pattern;\n  search[1] = 0;\n  best_score = 2147483648;\n  while (1) {\n    matcha = libmin_strcasestr(match, search);\n    if (!matcha) break;\n    v5 = compute_score((uint32_t)matcha - (uint32_t)str, first_char, matcha);\n    matched = fuzzy_match_recurse(pattern + 1, matcha + 1, v5, 0);\n    if (best_score >= matched) matched = best_score;\n    best_score = matched;\n    match = matcha + 1;\n  }\n  if (best_score == 2147483648)\n    return 2147483648;\n  else\n    return score + best_score;\n}", "binary": "fuzzy-match/fuzzy-match.host.O0", "assembly": "<fuzzy_match_recurse>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %edx,-0x34(%rbp)\nmov    %ecx,-0x38(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x28(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    22bf <fuzzy_match_recurse+0x3c>\nmov    -0x34(%rbp),%eax\njmp    2363 <fuzzy_match_recurse+0xe0>\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,-0xa(%rbp)\nmovb   $0x0,-0x9(%rbp)\nmovl   $0x80000000,-0x20(%rbp)\njmp    232d <fuzzy_match_recurse+0xaa>\nmov    -0x18(%rbp),%rax\nsub    -0x30(%rbp),%rax\nmov    %eax,%ecx\nmov    -0x18(%rbp),%rdx\nmov    -0x38(%rbp),%eax\nmov    %eax,%esi\nmov    %ecx,%edi\ncall   2379 <compute_score>\nmov    %eax,%edx\nmov    -0x18(%rbp),%rax\nlea    0x1(%rax),%rsi\nmov    -0x28(%rbp),%rax\nadd    $0x1,%rax\nmov    $0x0,%ecx\nmov    %rax,%rdi\ncall   2283 <fuzzy_match_recurse>\nmov    %eax,-0x1c(%rbp)\nmov    -0x20(%rbp),%edx\nmov    -0x1c(%rbp),%eax\ncmp    %eax,%edx\ncmovge %edx,%eax\nmov    %eax,-0x20(%rbp)\naddq   $0x1,-0x18(%rbp)\nlea    -0xa(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4b17 <libmin_strcasestr>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    22de <fuzzy_match_recurse+0x5b>\ncmpl   $0x80000000,-0x20(%rbp)\njne    235b <fuzzy_match_recurse+0xd8>\nmov    $0x80000000,%eax\njmp    2363 <fuzzy_match_recurse+0xe0>\nmov    -0x34(%rbp),%edx\nmov    -0x20(%rbp),%eax\nadd    %edx,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     2377 <fuzzy_match_recurse+0xf4>\ncall   20b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "fuzzy-match/fuzzy-match.c", "function_name": "main", "content": "int\nmain(void)\n{\n  {\n\t  const char *pattern = \"core\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  {\n\t  const char *pattern = \"work\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  {\n\t  const char *pattern = \"sam\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  libmin_success();\t\n  return 0;\n}\n"}, "pseudo": {"path": "fuzzy-match/fuzzy-match.host.O0.pseudo", "function_name": "main", "address": "0x24b3", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-30h]\n  int i_0; // [rsp+4h] [rbp-2Ch]\n  int i_1; // [rsp+8h] [rbp-28h]\n  int32_t score_1; // [rsp+Ch] [rbp-24h]\n  int32_t score_0; // [rsp+10h] [rbp-20h]\n  int32_t score; // [rsp+14h] [rbp-1Ch]\n\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  for ( i = 0; entries[i]; ++i )\n  {\n    score = fuzzy_match(\"core\", entries[i]);\n    if ( score != 0x80000000 )\n      libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  for ( i_0 = 0; entries[i_0]; ++i_0 )\n  {\n    score_0 = fuzzy_match(\"work\", entries[i_0]);\n    if ( score_0 != 0x80000000 )\n      libmin_printf(\"  %3d|%s\\n\", score_0, entries[i_0]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  for ( i_1 = 0; entries[i_1]; ++i_1 )\n  {\n    score_1 = fuzzy_match(\"sam\", entries[i_1]);\n    if ( score_1 != 0x80000000 )\n      libmin_printf(\"  %3d|%s\\n\", score_1, entries[i_1]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int i_0;\n  int i_1;\n  int32_t score_1;\n  int32_t score_0;\n  int32_t score;\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  for (i = 0; entries[i]; ++i) {\n    score = fuzzy_match(\"core\", entries[i]);\n    if (score != 2147483648) libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  for (i_0 = 0; entries[i_0]; ++i_0) {\n    score_0 = fuzzy_match(\"work\", entries[i_0]);\n    if (score_0 != 2147483648)\n      libmin_printf(\"  %3d|%s\\n\", score_0, entries[i_0]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  for (i_1 = 0; entries[i_1]; ++i_1) {\n    score_1 = fuzzy_match(\"sam\", entries[i_1]);\n    if (score_1 != 2147483648)\n      libmin_printf(\"  %3d|%s\\n\", score_1, entries[i_1]);\n  }\n  libmin_printf(\"\\n\");\n  libmin_success();\n}", "binary": "fuzzy-match/fuzzy-match.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nlea    0x33e6(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nlea    0x33d9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\nmovl   $0x0,-0x30(%rbp)\njmp    2556 <main+0xa3>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5b1e(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   21e9 <fuzzy_match>\nmov    %eax,-0x1c(%rbp)\ncmpl   $0x80000000,-0x1c(%rbp)\nje     2552 <main+0x9f>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5aeb(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x1c(%rbp),%eax\nmov    %eax,%esi\nlea    0x337f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5ab6(%rip),%rax\nmov    (%rdx,%rax,1),%rax\ntest   %rax,%rax\njne    24ee <main+0x3b>\nlea    0x3350(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\nlea    0x333e(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nlea    0x330d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\nmovl   $0x0,-0x2c(%rbp)\njmp    2622 <main+0x16f>\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5a52(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   21e9 <fuzzy_match>\nmov    %eax,-0x20(%rbp)\ncmpl   $0x80000000,-0x20(%rbp)\nje     261e <main+0x16b>\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5a1f(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x20(%rbp),%eax\nmov    %eax,%esi\nlea    0x32b3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\naddl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x59ea(%rip),%rax\nmov    (%rdx,%rax,1),%rax\ntest   %rax,%rax\njne    25ba <main+0x107>\nlea    0x3284(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\nlea    0x3277(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3241(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\nmovl   $0x0,-0x28(%rbp)\njmp    26ee <main+0x23b>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5986(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   21e9 <fuzzy_match>\nmov    %eax,-0x24(%rbp)\ncmpl   $0x80000000,-0x24(%rbp)\nje     26ea <main+0x237>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5953(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x24(%rbp),%eax\nmov    %eax,%esi\nlea    0x31e7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x591e(%rip),%rax\nmov    (%rdx,%rax,1),%rax\ntest   %rax,%rax\njne    2686 <main+0x1d3>\nlea    0x31b8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   48aa <libmin_printf>\ncall   4b75 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "fy-shuffle/fy-shuffle.c", "function_name": "fy_shuffle", "content": "void\nfy_shuffle(int *array, int n)\n{\n  int i, j, tmp;\n\n  for (i = n - 1; i > 0; i--)\n  {\n    j = rand_int(i + 1);\n    libmin_assert(i >= 0 && i < n && j >= 0 && j < n);\n    tmp = array[j];\n    array[j] = array[i];\n    array[i] = tmp;\n  }\n}\n"}, "pseudo": {"path": "fy-shuffle/fy-shuffle.host.O0.pseudo", "function_name": "fy_shuffle", "address": "0x1226", "label": "fy_shuffle", "content": "void __cdecl fy_shuffle(int *array, int n)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  int j; // [rsp+18h] [rbp-8h]\n  int tmp; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = n - 1; i > 0; --i )\n  {\n    j = rand_int(i + 1);\n    if ( i >= n || j < 0 || j >= n )\n      libmin_fail(1);\n    tmp = array[j];\n    array[j] = array[i];\n    array[i] = tmp;\n  }\n}\n"}, "pseudo_normalize": "void fy_shuffle(int *array, int n) {\n  int i;\n  int j;\n  int tmp;\n  for (i = n - 1; i > 0; --i) {\n    j = rand_int(i + 1);\n    if (i >= n || j < 0 || j >= n) libmin_fail(1);\n    tmp = array[j];\n    array[j] = array[i];\n    array[i] = tmp;\n  }\n}", "binary": "fy-shuffle/fy-shuffle.host.O0", "assembly": "<fy_shuffle>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0xc(%rbp)\njmp    12e0 <fy_shuffle+0xba>\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%edi\ncall   11e9 <rand_int>\nmov    %eax,-0x8(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njs     1273 <fy_shuffle+0x4d>\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njge    1273 <fy_shuffle+0x4d>\ncmpl   $0x0,-0x8(%rbp)\njs     1273 <fy_shuffle+0x4d>\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     127d <fy_shuffle+0x57>\nmov    $0x1,%edi\ncall   1596 <libmin_fail>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%eax\nmov    %eax,(%rdx)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\nsubl   $0x1,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njg     1247 <fy_shuffle+0x21>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "fy-shuffle/fy-shuffle.c", "function_name": "main", "content": "int\nmain(void)\n{\n  /* initialize random seed: */\n  libmin_srand(42);\n\n  for (int k = 0; k < 8; k++)\n  {\n    print(\"A (before): \", a, SZ_A);\n    fy_shuffle(a, SZ_A);\n    print(\"A (after):  \", a, SZ_A);\n\n    print(\"B (before): \", b, SZ_B);\n    fy_shuffle(b, SZ_B);\n    print(\"B (after):  \", b, SZ_B);\n  }\n  \n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "fy-shuffle/fy-shuffle.host.O0.pseudo", "function_name": "main", "address": "0x1378", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int k; // [rsp+Ch] [rbp-4h]\n\n  libmin_srand(0x2Au);\n  for ( k = 0; k <= 7; ++k )\n  {\n    print(\"A (before): \", a, 11);\n    fy_shuffle(a, 11);\n    print(\"A (after):  \", a, 11);\n    print(\"B (before): \", b, 19);\n    fy_shuffle(b, 19);\n    print(\"B (after):  \", b, 19);\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int k;\n  libmin_srand(42u);\n  for (k = 0; k <= 7; ++k) {\n    print(\"A (before): \", a, 11);\n    fy_shuffle(a, 11);\n    print(\"A (after):  \", a, 11);\n    print(\"B (before): \", b, 19);\n    fy_shuffle(b, 19);\n    print(\"B (after):  \", b, 19);\n  }\n  libmin_success();\n}", "binary": "fy-shuffle/fy-shuffle.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x2a,%edi\ncall   37f1 <libmin_srand>\nmovl   $0x0,-0x4(%rbp)\njmp    143e <main+0xc6>\nmov    $0xb,%edx\nlea    0x4c7a(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c5e(%rip),%rax\nmov    %rax,%rdi\ncall   12ee <print>\nmov    $0xb,%esi\nlea    0x4c5c(%rip),%rax\nmov    %rax,%rdi\ncall   1226 <fy_shuffle>\nmov    $0xb,%edx\nlea    0x4c48(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c39(%rip),%rax\nmov    %rax,%rdi\ncall   12ee <print>\nmov    $0x13,%edx\nlea    0x4c6a(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c28(%rip),%rax\nmov    %rax,%rdi\ncall   12ee <print>\nmov    $0x13,%esi\nlea    0x4c4c(%rip),%rax\nmov    %rax,%rdi\ncall   1226 <fy_shuffle>\nmov    $0x13,%edx\nlea    0x4c38(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c03(%rip),%rax\nmov    %rax,%rdi\ncall   12ee <print>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x7,-0x4(%rbp)\njle    139a <main+0x22>\ncall   3b5a <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "fy-shuffle/fy-shuffle.c", "function_name": "print", "content": "void\nprint(const char *prefix, int *array, int n)\n{\n  libmin_printf(\"%s\", prefix);\n  for (int i = 0; i < n; i++)\n    libmin_printf(\"%2d \", array[i]);\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "fy-shuffle/fy-shuffle.host.O0.pseudo", "function_name": "print", "address": "0x12ee", "label": "print", "content": "void __cdecl print(const char *prefix, int *array, int n)\n{\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  libmin_printf(\"%s\", prefix);\n  for ( i = 0; i < n; ++i )\n    libmin_printf(\"%2d \", array[i]);\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void print(const char *prefix, int *array, int n) {\n  int i;\n  libmin_printf(\"%s\", prefix);\n  for (i = 0; i < n; ++i) libmin_printf(\"%2d \", array[i]);\n  libmin_printf(\"\\n\");\n}", "binary": "fy-shuffle/fy-shuffle.host.O0", "assembly": "<print>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2cf1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35c2 <libmin_printf>\nmovl   $0x0,-0x4(%rbp)\njmp    1359 <print+0x6b>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x2cbf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35c2 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     1329 <print+0x3b>\nlea    0x2ca4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35c2 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "fy-shuffle/fy-shuffle.c", "function_name": "rand_int", "content": "#include \"libmin.h\"\n\n/* BUILD : g++ FisherYatesShuffle.cpp -std=c++11*/\n\nstatic int\nrand_int(int n)\n{\n  int limit = RAND_MAX - RAND_MAX % n;\n  int rnd;\n\n  do {\n    rnd = libmin_rand();\n  } \n  while (rnd >= limit);\n  return rnd % n;\n}\n"}, "pseudo": {"path": "fy-shuffle/fy-shuffle.host.O0.pseudo", "function_name": "rand_int", "address": "0x11e9", "label": "rand_int", "content": "int __cdecl rand_int(int n)\n{\n  signed int rnd; // [rsp+1Ch] [rbp-4h]\n\n  do\n    rnd = libmin_rand();\n  while ( rnd >= 0x7FFFFFFF - 0x7FFFFFFF % n );\n  return rnd % n;\n}\n"}, "pseudo_normalize": "int rand_int(int n) {\n  signed int rnd;\n  do rnd = libmin_rand();\n  while (rnd >= 2147483647 - 2147483647 % n);\n  return rnd % n;\n}", "binary": "fy-shuffle/fy-shuffle.host.O0", "assembly": "<rand_int>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x7fffffff,%eax\ncltd\nidivl  -0x14(%rbp)\nmov    $0x7fffffff,%eax\nsub    %edx,%eax\nmov    %eax,-0x8(%rbp)\ncall   38a3 <libmin_rand>\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    120b <rand_int+0x22>\nmov    -0x4(%rbp),%eax\ncltd\nidivl  -0x14(%rbp)\nmov    %edx,%eax\nleave\nret\n"}
{"source": {"path": "gcd-list/gcd-list.c", "function_name": "gcd", "content": "/**\n * @file\n * @brief This program aims at calculating the GCD of n numbers by division\n * method\n *\n * @see gcd_iterative_euclidean.cpp, gcd_recursive_euclidean.cpp\n */\n#include \"libmin.h\"\n\n/** Compute GCD using division algorithm\n *\n * @param[in] a array of integers to compute GCD for\n * @param[in] n number of integers in array `a`\n */\nuint32_t\ngcd(uint32_t *a, unsigned n)\n{\n  unsigned j = 1;  // to access all elements of the array starting from 1\n  uint32_t gcd = a[0];\n  while (j < n)\n  {\n    if (a[j] % gcd == 0)  // value of gcd is as needed so far\n      j++;              // so we check for next element\n    else\n      gcd = a[j] % gcd;  // calculating GCD by division method\n  }\n  return gcd;\n}\n"}, "pseudo": {"path": "gcd-list/gcd-list.host.O0.pseudo", "function_name": "gcd", "address": "0x11e9", "label": "gcd", "content": "uint32_t __cdecl gcd(uint32_t *a, unsigned int n)\n{\n  unsigned int j; // [rsp+14h] [rbp-8h]\n  uint32_t v4; // [rsp+18h] [rbp-4h]\n\n  j = 1;\n  v4 = *a;\n  while ( j < n )\n  {\n    if ( a[j] % v4 )\n      v4 = a[j] % v4;\n    else\n      ++j;\n  }\n  return v4;\n}\n"}, "pseudo_normalize": "uint32_t gcd(uint32_t *a, unsigned int n) {\n  unsigned int j;\n  uint32_t v4;\n  j = 1;\n  v4 = *a;\n  while (j < n) {\n    if (a[j] % v4)\n      v4 = a[j] % v4;\n    else\n      ++j;\n  }\n  return v4;\n}", "binary": "gcd-list/gcd-list.host.O0", "assembly": "<gcd>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x1,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\njmp    1251 <gcd+0x68>\nmov    -0x8(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    $0x0,%edx\ndivl   -0x4(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    1232 <gcd+0x49>\naddl   $0x1,-0x8(%rbp)\njmp    1251 <gcd+0x68>\nmov    -0x8(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    $0x0,%edx\ndivl   -0x4(%rbp)\nmov    %edx,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njb     120a <gcd+0x21>\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "gcd-list/gcd-list.c", "function_name": "main", "content": "/** Main function */\nint\nmain(void)\n{\n  // initialize RNG\n  libmin_srand(42);\n\n  unsigned n = 64;\n  uint32_t *a = (uint32_t *)libmin_malloc(sizeof(uint32_t)*n);\n  for (unsigned i = 0; i < n; i++)\n    a[i] = (libmin_rand() % 10000000) * 37;\n\n  libmin_printf(\"INFO: a[%d] = { \", n);\n  for (unsigned i = 0; i < n; i++)\n    libmin_printf(\"%d, \", a[i]);\n  libmin_printf(\" }\\n\");\n\n  uint32_t gcd_of_n;\n  gcd_of_n = gcd(a, n);\n  libmin_printf(\"GCD of list: %u\\n\", gcd_of_n);\n\n  libmin_free(a);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "gcd-list/gcd-list.host.O0.pseudo", "function_name": "main", "address": "0x125e", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int i; // [rsp+8h] [rbp-18h]\n  unsigned int i_0; // [rsp+Ch] [rbp-14h]\n  uint32_t gcd_of_n; // [rsp+14h] [rbp-Ch]\n  uint32_t *a; // [rsp+18h] [rbp-8h]\n\n  libmin_srand(0x2Au);\n  a = (uint32_t *)libmin_malloc(0x100uLL);\n  for ( i = 0; i < 0x40; ++i )\n    a[i] = 37 * (libmin_rand() % 0x989680);\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  for ( i_0 = 0; i_0 < 0x40; ++i_0 )\n    libmin_printf(\"%d, \", a[i_0]);\n  libmin_printf(\" }\\n\");\n  gcd_of_n = gcd(a, 0x40u);\n  libmin_printf(\"GCD of list: %u\\n\", gcd_of_n);\n  libmin_free(a);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int i_0;\n  uint32_t gcd_of_n;\n  uint32_t *a;\n  libmin_srand(42u);\n  a = (uint32_t *)libmin_malloc(256uLL);\n  for (i = 0; i < 64; ++i) a[i] = 37 * (libmin_rand() % 10000000);\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  for (i_0 = 0; i_0 < 64; ++i_0) libmin_printf(\"%d, \", a[i_0]);\n  libmin_printf(\" }\\n\");\n  gcd_of_n = gcd(a, 64u);\n  libmin_printf(\"GCD of list: %u\\n\", gcd_of_n);\n  libmin_free(a);\n  libmin_success();\n}", "binary": "gcd-list/gcd-list.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    $0x2a,%edi\ncall   3bb7 <libmin_srand>\nmovl   $0x40,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   1526 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    12da <main+0x7c>\ncall   3c69 <libmin_rand>\nmov    %eax,%edx\nimul   $0x6b5fca6b,%rdx,%rdx\nshr    $0x20,%rdx\nshr    $0x16,%edx\nimul   $0x989680,%edx,%ecx\nsub    %ecx,%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%eax\nlea    0x0(,%rax,4),%rcx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rcx\nmov    %edx,%eax\nshl    $0x3,%eax\nadd    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nmov    %eax,(%rcx)\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njb     1297 <main+0x39>\nmov    -0x10(%rbp),%eax\nmov    %eax,%esi\nlea    0x2d16(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3988 <libmin_printf>\nmovl   $0x0,-0x14(%rbp)\njmp    1332 <main+0xd4>\nmov    -0x14(%rbp),%eax\nlea    0x0(,%rax,4),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x2cf4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3988 <libmin_printf>\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njb     1304 <main+0xa6>\nlea    0x2cd9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3988 <libmin_printf>\nmov    -0x10(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   11e9 <gcd>\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,%esi\nlea    0x2cb0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3988 <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   1611 <libmin_free>\ncall   3f20 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "grad-descent/grad-descent.c", "function_name": "derivateWRTBias", "content": "double\nderivateWRTBias(double weight, double bias)\n{\n\tdouble sum = 0;\n\t\n\tfor(int i = 0; i<M; i++){\n\t\tsum = (double)(sum + (Y[i] - (weight * X[i] + bias)));\n\t}\n\t\n\treturn ((double)-2.0 * sum)/M;\n}\n"}, "pseudo": {"path": "grad-descent/grad-descent.host.O0.pseudo", "function_name": "derivateWRTBias", "address": "0x12ab", "label": "derivateWRTBias", "content": "double __cdecl derivateWRTBias(double weight, double bias)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  double sum; // [rsp+18h] [rbp-8h]\n\n  sum = 0.0;\n  for ( i = 0; i <= 49; ++i )\n    sum = Y[i] - (X[i] * weight + bias) + sum;\n  return -2.0 * sum / 50.0;\n}\n"}, "pseudo_normalize": "double derivateWRTBias(double weight, double bias) {\n  int i;\n  double sum;\n  sum = 0.0;\n  for (i = 0; i <= 49; ++i) sum = Y[i] - (X[i] * weight + bias) + sum;\n  return -2.0 * sum / 50.0;\n}", "binary": "grad-descent/grad-descent.host.O0", "assembly": "<derivateWRTBias>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  %xmm1,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1321 <derivateWRTBias+0x76>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4d5d(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4ee4(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmulsd  -0x18(%rbp),%xmm1\naddsd  -0x20(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x31,-0xc(%rbp)\njle    12cf <derivateWRTBias+0x24>\nmovsd  -0x8(%rbp),%xmm1\nmovsd  0x2cfc(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  0x2cf8(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n"}
{"source": {"path": "grad-descent/grad-descent.c", "function_name": "derivateWRTWeight", "content": "double\nderivateWRTWeight(double weight, double bias)\n{\n\tdouble sum = 0;\n\t\n\tfor(int i = 0; i<M; i++){\n\t\tsum = (double)(sum + (X[i]*(Y[i] - (weight * X[i] + bias))));\n\t}\n\t\n\treturn ((double)-2.0 * sum)/M;\n}\n"}, "pseudo": {"path": "grad-descent/grad-descent.host.O0.pseudo", "function_name": "derivateWRTWeight", "address": "0x11e9", "label": "derivateWRTWeight", "content": "double __cdecl derivateWRTWeight(double weight, double bias)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  double sum; // [rsp+18h] [rbp-8h]\n\n  sum = 0.0;\n  for ( i = 0; i <= 49; ++i )\n    sum = (Y[i] - (X[i] * weight + bias)) * X[i] + sum;\n  return -2.0 * sum / 50.0;\n}\n"}, "pseudo_normalize": "double derivateWRTWeight(double weight, double bias) {\n  int i;\n  double sum;\n  sum = 0.0;\n  for (i = 0; i <= 49; ++i) sum = (Y[i] - (X[i] * weight + bias)) * X[i] + sum;\n  return -2.0 * sum / 50.0;\n}", "binary": "grad-descent/grad-descent.host.O0", "assembly": "<derivateWRTWeight>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  %xmm1,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    127c <derivateWRTWeight+0x93>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4fbf(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm2\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4e06(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4f8d(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmulsd  -0x18(%rbp),%xmm1\naddsd  -0x20(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmulsd  %xmm2,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x31,-0xc(%rbp)\njle    120d <derivateWRTWeight+0x24>\nmovsd  -0x8(%rbp),%xmm1\nmovsd  0x2da1(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  0x2d9d(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n"}
{"source": {"path": "grad-descent/grad-descent.c", "function_name": "gradientDescent", "content": "void\ngradientDescent(double *pweight, double *pbias)\n{\n\tfor (unsigned i = 0; i<200; i++)\n  {\n\t\t*pweight = (double)(*pweight - (L*derivateWRTWeight(*pweight, *pbias)));\n\t\t*pbias =(double)(*pbias - (L*derivateWRTBias(*pweight, *pbias)));\t\t\n\t}\n}\n"}, "pseudo": {"path": "grad-descent/grad-descent.host.O0.pseudo", "function_name": "gradientDescent", "address": "0x1350", "label": "gradientDescent", "content": "void __cdecl gradientDescent(double *pweight, double *pbias)\n{\n  double v2; // [rsp+0h] [rbp-28h]\n  double v3; // [rsp+0h] [rbp-28h]\n  unsigned int i; // [rsp+24h] [rbp-4h]\n\n  for ( i = 0; i <= 0xC7; ++i )\n  {\n    v2 = *pweight;\n    *pweight = v2 - L * derivateWRTWeight(*pweight, *pbias);\n    v3 = *pbias;\n    *pbias = v3 - L * derivateWRTBias(*pweight, *pbias);\n  }\n}\n"}, "pseudo_normalize": "void gradientDescent(double *pweight, double *pbias) {\n  double v2;\n  double v3;\n  unsigned int i;\n  for (i = 0; i <= 199; ++i) {\n    v2 = *pweight;\n    *pweight = v2 - L * derivateWRTWeight(*pweight, *pbias);\n    v3 = *pbias;\n    *pbias = v3 - L * derivateWRTBias(*pweight, *pbias);\n  }\n}", "binary": "grad-descent/grad-descent.host.O0", "assembly": "<gradientDescent>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x28,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1402 <gradientDescent+0xb2>\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm2\nmovsd  %xmm2,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmovsd  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   11e9 <derivateWRTWeight>\nmovsd  0x4c7e(%rip),%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x28(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nmovsd  %xmm0,(%rax)\nmov    -0x20(%rbp),%rax\nmovsd  (%rax),%xmm3\nmovsd  %xmm3,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\nmovsd  (%rax),%xmm0\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   12ab <derivateWRTBias>\nmovsd  0x4c37(%rip),%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x28(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0xc7,-0x4(%rbp)\njbe    1370 <gradientDescent+0x20>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "grad-descent/grad-descent.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tdouble weight = 0;\n\tdouble bias = 0;\n\n\tgradientDescent(&weight, &bias);\n\tlibmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "grad-descent/grad-descent.host.O0.pseudo", "function_name": "main", "address": "0x1413", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double weight; // [rsp+8h] [rbp-18h] BYREF\n  double bias[2]; // [rsp+10h] [rbp-10h] BYREF\n\n  *(_QWORD *)&bias[1] = __readfsqword(0x28u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double weight;\n  double bias[2];\n  *(uint64_t *)&bias[1] = __readfsqword(40u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}", "binary": "grad-descent/grad-descent.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nlea    -0x10(%rbp),%rdx\nlea    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1350 <gradientDescent>\nmovsd  -0x10(%rbp),%xmm0\nmov    -0x18(%rbp),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x2b9c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   35d5 <libmin_printf>\ncall   3842 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1497 <main+0x84>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "DFS_test", "content": "void DFS_test() {\n   int i, j;\n\n   for(i = 0; i < 5; i++) {   // set adjacency {\n      for(j = 0; j < 5; j++) // matrix to 0\n         adjMatrix[i][j] = 0;\n   }\n\n   addVertex();   // 0\n   addVertex();   // 1\n   addVertex();   // 2\n   addVertex();   // 3\n   addVertex();   // 4\n\n   addEdge_DFS(0, 1);    // S - A\n   addEdge_DFS(0, 2);    // S - B\n   addEdge_DFS(0, 3);    // S - C\n   addEdge_DFS(1, 4);    // A - D\n   addEdge_DFS(2, 4);    // B - D\n   addEdge_DFS(3, 4);    // C - D\n\n   depthFirstSearch();\n\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "DFS_test", "address": "0x1bec", "label": "DFS_test", "content": "void __cdecl DFS_test()\n{\n  int i; // [rsp+8h] [rbp-8h]\n  int j; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i <= 4; ++i )\n  {\n    for ( j = 0; j <= 4; ++j )\n      adjMatrix[i][j] = 0;\n  }\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addEdge_DFS(0, 1);\n  addEdge_DFS(0, 2);\n  addEdge_DFS(0, 3);\n  addEdge_DFS(1, 4);\n  addEdge_DFS(2, 4);\n  addEdge_DFS(3, 4);\n  depthFirstSearch();\n}\n"}, "pseudo_normalize": "void DFS_test() {\n  int i;\n  int j;\n  for (i = 0; i <= 4; ++i) {\n    for (j = 0; j <= 4; ++j) adjMatrix[i][j] = 0;\n  }\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addVertex();\n  addEdge_DFS(0, 1);\n  addEdge_DFS(0, 2);\n  addEdge_DFS(0, 3);\n  addEdge_DFS(1, 4);\n  addEdge_DFS(2, 4);\n  addEdge_DFS(3, 4);\n  depthFirstSearch();\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<DFS_test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x8(%rbp)\njmp    1c47 <DFS_test+0x5b>\nmovl   $0x0,-0x4(%rbp)\njmp    1c3d <DFS_test+0x51>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x56ae(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x4,-0x4(%rbp)\njle    1c0a <DFS_test+0x1e>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x4,-0x8(%rbp)\njle    1c01 <DFS_test+0x15>\nmov    $0x0,%eax\ncall   19f6 <addVertex>\nmov    $0x0,%eax\ncall   19f6 <addVertex>\nmov    $0x0,%eax\ncall   19f6 <addVertex>\nmov    $0x0,%eax\ncall   19f6 <addVertex>\nmov    $0x0,%eax\ncall   19f6 <addVertex>\nmov    $0x1,%esi\nmov    $0x0,%edi\ncall   1a45 <addEdge_DFS>\nmov    $0x2,%esi\nmov    $0x0,%edi\ncall   1a45 <addEdge_DFS>\nmov    $0x3,%esi\nmov    $0x0,%edi\ncall   1a45 <addEdge_DFS>\nmov    $0x4,%esi\nmov    $0x1,%edi\ncall   1a45 <addEdge_DFS>\nmov    $0x4,%esi\nmov    $0x2,%edi\ncall   1a45 <addEdge_DFS>\nmov    $0x4,%esi\nmov    $0x3,%edi\ncall   1a45 <addEdge_DFS>\nmov    $0x0,%eax\ncall   1b31 <depthFirstSearch>\nnop\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "addEdge", "content": "void addEdge(struct Graph* graph, int src, int dest) {\n    // Add edge from src to dest\n    struct node* newNode = createNode(dest);\n    newNode->next = graph->adjLists[src];\n    graph->adjLists[src] = newNode;\n\n    // Add edge from dest to src\n    newNode = createNode(src);\n    newNode->next = graph->adjLists[dest];\n    graph->adjLists[dest] = newNode;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "addEdge", "address": "0x12c9", "label": "addEdge", "content": "void __cdecl addEdge(Graph *graph, int src, int dest)\n{\n  node *Node; // rax\n  node *newNode; // [rsp+18h] [rbp-8h]\n\n  Node = createNode(dest);\n  Node->next = graph->adjLists[src];\n  graph->adjLists[src] = Node;\n  newNode = createNode(src);\n  newNode->next = graph->adjLists[dest];\n  graph->adjLists[dest] = newNode;\n}\n"}, "pseudo_normalize": "void addEdge(Graph *graph, int src, int dest) {\n  node *Node;\n  node *newNode;\n  Node = createNode(dest);\n  Node->next = graph->adjLists[src];\n  graph->adjLists[src] = Node;\n  newNode = createNode(src);\n  newNode->next = graph->adjLists[dest];\n  graph->adjLists[dest] = newNode;\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<addEdge>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <createNode>\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\nmov    -0x1c(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <createNode>\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x20(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x20(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rdx)\nnop\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "addEdge_DFS", "content": "void addEdge_DFS(int start,int end) {\n   adjMatrix[start][end] = 1;\n   adjMatrix[end][start] = 1;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "addEdge_DFS", "address": "0x1a45", "label": "addEdge_DFS", "content": "void __cdecl addEdge_DFS(int start, int end)\n{\n  adjMatrix[start][end] = 1;\n  adjMatrix[end][start] = 1;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<addEdge_DFS>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x5865(%rip),%rax\nmovl   $0x1,(%rdx,%rax,1)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x5836(%rip),%rax\nmovl   $0x1,(%rdx,%rax,1)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "addVertex", "content": "void addVertex() {\n   struct Vertex* vertex = (struct Vertex*)libmin_malloc(sizeof(struct Vertex));\n   vertex->visited = FALSE;\n   lstVertices[vertexCount++] = vertex;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "addVertex", "address": "0x19f6", "label": "addVertex", "content": "void __cdecl addVertex()\n{\n  int v0; // eax\n  Vertex *vertex; // [rsp+8h] [rbp-8h]\n\n  vertex = (Vertex *)libmin_malloc(4uLL);\n  vertex->visited = 0;\n  v0 = vertexCount++;\n  lstVertices[v0] = vertex;\n}\n"}, "pseudo_normalize": "void addVertex() {\n  int v0;\n  Vertex *vertex;\n  vertex = (Vertex *)libmin_malloc(4uLL);\n  vertex->visited = 0;\n  v0 = vertexCount++;\n  lstVertices[v0] = vertex;\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<addVertex>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x4,%edi\ncall   1f36 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    0x5924(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x591b(%rip)\ncltq\nlea    0x0(,%rax,8),%rcx\nlea    0x5866(%rip),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,(%rcx,%rdx,1)\nnop\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "bfs", "content": "void bfs(struct Graph* graph, int startVertex) {\n    struct queue* q = createQueue();\n\n    graph->visited[startVertex] = 1;\n    enqueue(q, startVertex);\n\n    while(!isEmpty(q)){\n        printQueue(q);\n        int currentVertex = dequeue(q);\n        libmin_printf(\"Visited %d\\n\", currentVertex);\n       struct node* temp = graph->adjLists[currentVertex];\n\n       while(temp) {\n            int adjVertex = temp->vertex;\n            if(graph->visited[adjVertex] == 0){\n                graph->visited[adjVertex] = 1;\n                enqueue(q, adjVertex);\n            }\n            temp = temp->next;\n       }\n    }\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "bfs", "address": "0x15ce", "label": "bfs", "content": "void __cdecl bfs(Graph *graph, int startVertex)\n{\n  int currentVertex; // [rsp+18h] [rbp-18h]\n  int adjVertex; // [rsp+1Ch] [rbp-14h]\n  node *temp; // [rsp+20h] [rbp-10h]\n  queue *q; // [rsp+28h] [rbp-8h]\n\n  q = createQueue();\n  graph->visited[startVertex] = 1;\n  enqueue(q, startVertex);\n  while ( !isEmpty(q) )\n  {\n    printQueue(q);\n    currentVertex = dequeue(q);\n    libmin_printf(\"Visited %d\\n\", currentVertex);\n    for ( temp = graph->adjLists[currentVertex]; temp; temp = temp->next )\n    {\n      adjVertex = temp->vertex;\n      if ( !graph->visited[temp->vertex] )\n      {\n        graph->visited[adjVertex] = 1;\n        enqueue(q, adjVertex);\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void bfs(Graph *graph, int startVertex) {\n  int currentVertex;\n  int adjVertex;\n  node *temp;\n  queue *q;\n  q = createQueue();\n  graph->visited[startVertex] = 1;\n  enqueue(q, startVertex);\n  while (!isEmpty(q)) {\n    printQueue(q);\n    currentVertex = dequeue(q);\n    libmin_printf(\"Visited %d\\n\", currentVertex);\n    for (temp = graph->adjLists[currentVertex]; temp; temp = temp->next) {\n      adjVertex = temp->vertex;\n      if (!graph->visited[temp->vertex]) {\n        graph->visited[adjVertex] = 1;\n        enqueue(q, adjVertex);\n      }\n    }\n  }\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<bfs>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    $0x0,%eax\ncall   1372 <createQueue>\nmov    %rax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\nmov    -0x2c(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   13d7 <enqueue>\njmp    16d1 <bfs+0x103>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   151b <printQueue>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   145d <dequeue>\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,%esi\nlea    0x3a0a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\nmov    -0x28(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\njmp    16ca <bfs+0xfc>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    16be <bfs+0xf0>\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\nmov    -0x14(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   13d7 <enqueue>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    1670 <bfs+0xa2>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   13ae <isEmpty>\ntest   %eax,%eax\nje     161f <bfs+0x51>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "bfs_test", "content": "void bfs_test(){\n    struct Graph* graph = createGraph(6);\n    addEdge(graph, 0, 1);\n    addEdge(graph, 0, 2);\n    addEdge(graph, 1, 2);\n    addEdge(graph, 1, 4);\n    addEdge(graph, 1, 3);\n    addEdge(graph, 2, 4);\n    addEdge(graph, 3, 4);\n\n    bfs(graph, 0);\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "bfs_test", "address": "0x16e9", "label": "bfs_test", "content": "void __cdecl bfs_test()\n{\n  Graph *graph; // [rsp+8h] [rbp-8h]\n\n  graph = createGraph(6);\n  addEdge(graph, 0, 1);\n  addEdge(graph, 0, 2);\n  addEdge(graph, 1, 2);\n  addEdge(graph, 1, 4);\n  addEdge(graph, 1, 3);\n  addEdge(graph, 2, 4);\n  addEdge(graph, 3, 4);\n  bfs(graph, 0);\n}\n"}, "pseudo_normalize": "void bfs_test() {\n  Graph *graph;\n  graph = createGraph(6);\n  addEdge(graph, 0, 1);\n  addEdge(graph, 0, 2);\n  addEdge(graph, 1, 2);\n  addEdge(graph, 1, 4);\n  addEdge(graph, 1, 3);\n  addEdge(graph, 2, 4);\n  addEdge(graph, 3, 4);\n  bfs(graph, 0);\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<bfs_test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x6,%edi\ncall   1221 <createGraph>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x1,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x2,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x2,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x4,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x3,%edx\nmov    $0x1,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x4,%edx\nmov    $0x2,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x4,%edx\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   12c9 <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   15ce <bfs>\nnop\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "bubbleSort", "content": "void bubbleSort(struct Node *start) {\n    int swapped;\n    struct Node *ptr1;\n    struct Node *lptr = NULL;\n\n    if (start == NULL)\n        return;\n\n    do{\n        swapped = 0;\n        ptr1 = start;\n\n        while (ptr1->next != lptr){\n            if (ptr1->data > ptr1->next->data){\n                swap(ptr1, ptr1->next);\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    }\n    while (swapped);\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "bubbleSort", "address": "0x1829", "label": "bubbleSort", "content": "void __cdecl bubbleSort(Node *start)\n{\n  int swapped; // [rsp+14h] [rbp-14h]\n  Node *ptr1; // [rsp+18h] [rbp-10h]\n  Node *lptr; // [rsp+20h] [rbp-8h]\n\n  lptr = 0LL;\n  if ( start )\n  {\n    do\n    {\n      swapped = 0;\n      for ( ptr1 = start; lptr != ptr1->next; ptr1 = ptr1->next )\n      {\n        if ( ptr1->data > ptr1->next->data )\n        {\n          swap(ptr1, ptr1->next);\n          swapped = 1;\n        }\n      }\n      lptr = ptr1;\n    }\n    while ( swapped );\n  }\n}\n"}, "pseudo_normalize": "void bubbleSort(Node *start) {\n  int swapped;\n  Node *ptr1;\n  Node *lptr;\n  lptr = 0LL;\n  if (start) {\n    do {\n      swapped = 0;\n      for (ptr1 = start; lptr != ptr1->next; ptr1 = ptr1->next) {\n        if (ptr1->data > ptr1->next->data) {\n          swap(ptr1, ptr1->next);\n          swapped = 1;\n        }\n      }\n      lptr = ptr1;\n    } while (swapped);\n  }\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<bubbleSort>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmovq   $0x0,-0x8(%rbp)\ncmpq   $0x0,-0x28(%rbp)\nje     18b5 <bubbleSort+0x8c>\nmovl   $0x0,-0x14(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x10(%rbp)\njmp    1897 <bubbleSort+0x6e>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    188b <bubbleSort+0x62>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   17f8 <swap>\nmovl   $0x1,-0x14(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\ncmp    %rax,-0x8(%rbp)\njne    1859 <bubbleSort+0x30>\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x8(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    1848 <bubbleSort+0x1f>\njmp    18b6 <bubbleSort+0x8d>\nnop\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "createGraph", "content": "struct Graph* createGraph(int vertices) {\n    int i;\n    struct Graph* graph = (struct Graph*)libmin_malloc(sizeof(struct Graph));\n    graph->numVertices = vertices;\n\n    graph->adjLists = (struct node**)libmin_malloc(vertices * sizeof(struct node*));\n    graph->visited = (int*)libmin_malloc(vertices * sizeof(int));\n\n    for (i = 0; i < vertices; i++) {\n        graph->adjLists[i] = NULL;\n        graph->visited[i] = 0;\n    }\n\n    return graph;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "createGraph", "address": "0x1221", "label": "createGraph", "content": "Graph *__cdecl createGraph(int vertices)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  Graph *graph; // [rsp+18h] [rbp-8h]\n\n  graph = (Graph *)libmin_malloc(0x18uLL);\n  graph->numVertices = vertices;\n  graph->adjLists = (node **)libmin_malloc(8LL * vertices);\n  graph->visited = (int *)libmin_malloc(4LL * vertices);\n  for ( i = 0; i < vertices; ++i )\n  {\n    graph->adjLists[i] = 0LL;\n    graph->visited[i] = 0;\n  }\n  return graph;\n}\n"}, "pseudo_normalize": "Graph *createGraph(int vertices) {\n  int i;\n  Graph *graph;\n  graph = (Graph *)libmin_malloc(24uLL);\n  graph->numVertices = vertices;\n  graph->adjLists = (node **)libmin_malloc(8LL * vertices);\n  graph->visited = (int *)libmin_malloc(4LL * vertices);\n  for (i = 0; i < vertices; ++i) {\n    graph->adjLists[i] = 0LL;\n    graph->visited[i] = 0;\n  }\n  return graph;\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<createGraph>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x18,%edi\ncall   1f36 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1f36 <libmin_malloc>\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x8(%rdx)\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   1f36 <libmin_malloc>\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x10(%rdx)\nmovl   $0x0,-0xc(%rbp)\njmp    12bb <createGraph+0x9a>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmovq   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nmovl   $0x0,(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     1282 <createGraph+0x61>\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "createNode", "content": "struct node* createNode(int v) {\n    struct node* newNode = (struct node*)libmin_malloc(sizeof(struct node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "createNode", "address": "0x11e9", "label": "createNode", "content": "node *__cdecl createNode(int v)\n{\n  node *result; // rax\n\n  result = (node *)libmin_malloc(0x10uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "node *createNode(int v) {\n  node *result;\n  result = (node *)libmin_malloc(16uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<createNode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x10,%edi\ncall   1f36 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "createQueue", "content": "struct queue* createQueue() {\n    struct queue* q = (struct queue*)libmin_malloc(sizeof(struct queue));\n    q->front = -1;\n    q->rear = -1;\n    return q;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "createQueue", "address": "0x1372", "label": "createQueue", "content": "queue *__cdecl createQueue()\n{\n  queue *result; // rax\n\n  result = (queue *)libmin_malloc(0xA8uLL);\n  result->front = -1;\n  result->rear = -1;\n  return result;\n}\n"}, "pseudo_normalize": "queue *createQueue() {\n  queue *result;\n  result = (queue *)libmin_malloc(168uLL);\n  result->front = -1;\n  result->rear = -1;\n  return result;\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<createQueue>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0xa8,%edi\ncall   1f36 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovl   $0xffffffff,0xa0(%rax)\nmov    -0x8(%rbp),%rax\nmovl   $0xffffffff,0xa4(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "depthFirstSearch", "content": "void depthFirstSearch() {\n   int i;\n\n   lstVertices[0]->visited = TRUE;\n\n\n   push(0);\n\n   while(!isStackEmpty()) {\n      int unvisitedVertex = getAdjUnvisitedVertex(peek());\n\n      if(unvisitedVertex == -1) {\n         pop();\n      } else {\n         lstVertices[unvisitedVertex]->visited = TRUE;\n         push(unvisitedVertex);\n      }\n   }\n\n   for(i = 0;i < vertexCount;i++) {\n      lstVertices[i]->visited = FALSE;\n   }\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "depthFirstSearch", "address": "0x1b31", "label": "depthFirstSearch", "content": "void __cdecl depthFirstSearch()\n{\n  int v0; // eax\n  int i; // [rsp+8h] [rbp-8h]\n  int unvisitedVertex; // [rsp+Ch] [rbp-4h]\n\n  lstVertices[0]->visited = 1;\n  push(0);\n  while ( !isStackEmpty() )\n  {\n    v0 = peek();\n    unvisitedVertex = getAdjUnvisitedVertex(v0);\n    if ( unvisitedVertex == -1 )\n    {\n      pop();\n    }\n    else\n    {\n      lstVertices[unvisitedVertex]->visited = 1;\n      push(unvisitedVertex);\n    }\n  }\n  for ( i = 0; i < vertexCount; ++i )\n    lstVertices[i]->visited = 0;\n}\n"}, "pseudo_normalize": "void depthFirstSearch() {\n  int v0;\n  int i;\n  int unvisitedVertex;\n  lstVertices[0]->visited = 1;\n  push(0);\n  while (!isStackEmpty()) {\n    v0 = peek();\n    unvisitedVertex = getAdjUnvisitedVertex(v0);\n    if (unvisitedVertex == -1) {\n      pop();\n    } else {\n      lstVertices[unvisitedVertex]->visited = 1;\n      push(unvisitedVertex);\n    }\n  }\n  for (i = 0; i < vertexCount; ++i) lstVertices[i]->visited = 0;\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<depthFirstSearch>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    0x575c(%rip),%rax\nmovl   $0x1,(%rax)\nmov    $0x0,%edi\ncall   1952 <push>\njmp    1ba4 <depthFirstSearch+0x73>\nmov    $0x0,%eax\ncall   19b9 <peek>\nmov    %eax,%edi\ncall   1ab4 <getAdjUnvisitedVertex>\nmov    %eax,-0x4(%rbp)\ncmpl   $0xffffffff,-0x4(%rbp)\njne    1b7c <depthFirstSearch+0x4b>\nmov    $0x0,%eax\ncall   198c <pop>\njmp    1ba4 <depthFirstSearch+0x73>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5710(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmovl   $0x1,(%rax)\nmov    -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   1952 <push>\nmov    $0x0,%eax\ncall   19dd <isStackEmpty>\ntest   %eax,%eax\nje     1b56 <depthFirstSearch+0x25>\nmovl   $0x0,-0x8(%rbp)\njmp    1bdd <depthFirstSearch+0xac>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x56d1(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmovl   $0x0,(%rax)\naddl   $0x1,-0x8(%rbp)\nmov    0x5761(%rip),%eax\ncmp    %eax,-0x8(%rbp)\njl     1bbb <depthFirstSearch+0x8a>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "dequeue", "content": "int dequeue(struct queue* q){\n    int item;\n    if(isEmpty(q)){\n        libmin_printf(\"Queue is empty\\n\");\n        item = -1;\n    }\n    else{\n        item = q->items[q->front];\n        q->front++;\n        if(q->front > q->rear){\n            libmin_printf(\"Resetting queue...\\n\");\n            q->front = q->rear = -1;\n        }\n    }\n    return item;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "dequeue", "address": "0x145d", "label": "dequeue", "content": "int __cdecl dequeue(queue *q)\n{\n  int item; // [rsp+1Ch] [rbp-4h]\n\n  if ( isEmpty(q) )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  }\n  else\n  {\n    item = q->items[q->front++];\n    if ( q->front > q->rear )\n    {\n      libmin_printf(\"Resetting queue...\\n\");\n      q->rear = -1;\n      q->front = q->rear;\n    }\n  }\n  return item;\n}\n"}, "pseudo_normalize": "int dequeue(queue *q) {\n  int item;\n  if (isEmpty(q)) {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  } else {\n    item = q->items[q->front++];\n    if (q->front > q->rear) {\n      libmin_printf(\"Resetting queue...\\n\");\n      q->rear = -1;\n      q->front = q->rear;\n    }\n  }\n  return item;\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<dequeue>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   13ae <isEmpty>\ntest   %eax,%eax\nje     149a <dequeue+0x3d>\nlea    0x3b91(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\nmovl   $0xffffffff,-0x4(%rbp)\njmp    1516 <dequeue+0xb9>\nmov    -0x18(%rbp),%rax\nmov    0xa0(%rax),%edx\nmov    -0x18(%rbp),%rax\nmovslq %edx,%rdx\nmov    (%rax,%rdx,4),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0xa0(%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,0xa0(%rax)\nmov    -0x18(%rbp),%rax\nmov    0xa0(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0xa4(%rax),%eax\ncmp    %eax,%edx\njle    1516 <dequeue+0xb9>\nlea    0x3b3e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\nmov    -0x18(%rbp),%rax\nmovl   $0xffffffff,0xa4(%rax)\nmov    -0x18(%rbp),%rax\nmov    0xa4(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,0xa0(%rax)\nmov    -0x4(%rbp),%eax\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "enqueue", "content": "void enqueue(struct queue* q, int value){\n    if(q->rear == 40-1){\n        libmin_printf(\"Queue is Full!!\\n\");\n    } else {\n        if(q->front == -1)\n            q->front = 0;\n        q->rear++;\n        q->items[q->rear] = value;\n    }\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "enqueue", "address": "0x13d7", "label": "enqueue", "content": "void __cdecl enqueue(queue *q, int value)\n{\n  if ( q->rear == 39 )\n  {\n    libmin_printf(\"Queue is Full!!\\n\");\n  }\n  else\n  {\n    if ( q->front == -1 )\n      q->front = 0;\n    q->items[++q->rear] = value;\n  }\n}\n"}, "pseudo_normalize": "void enqueue(queue *q, int value) {\n  if (q->rear == 39) {\n    libmin_printf(\"Queue is Full!!\\n\");\n  } else {\n    if (q->front == -1) q->front = 0;\n    q->items[++q->rear] = value;\n  }\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<enqueue>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %esi,-0xc(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0xa4(%rax),%eax\ncmp    $0x27,%eax\njne    140f <enqueue+0x38>\nlea    0x3c04(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\njmp    145a <enqueue+0x83>\nmov    -0x8(%rbp),%rax\nmov    0xa0(%rax),%eax\ncmp    $0xffffffff,%eax\njne    142c <enqueue+0x55>\nmov    -0x8(%rbp),%rax\nmovl   $0x0,0xa0(%rax)\nmov    -0x8(%rbp),%rax\nmov    0xa4(%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,0xa4(%rax)\nmov    -0x8(%rbp),%rax\nmov    0xa4(%rax),%edx\nmov    -0x8(%rbp),%rax\nmovslq %edx,%rdx\nmov    -0xc(%rbp),%ecx\nmov    %ecx,(%rax,%rdx,4)\nnop\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "getAdjUnvisitedVertex", "content": "int getAdjUnvisitedVertex(int vertexIndex) {\n   int i;\n\n   for(i = 0; i < vertexCount; i++) {\n      if(adjMatrix[vertexIndex][i] == 1 && lstVertices[i]->visited == FALSE) {\n         return i;\n      }\n   }\n\n   return -1;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "getAdjUnvisitedVertex", "address": "0x1ab4", "label": "getAdjUnvisitedVertex", "content": "int __cdecl getAdjUnvisitedVertex(int vertexIndex)\n{\n  int i; // [rsp+10h] [rbp-4h]\n\n  for ( i = 0; i < vertexCount; ++i )\n  {\n    if ( adjMatrix[vertexIndex][i] == 1 && !lstVertices[i]->visited )\n      return i;\n  }\n  return -1;\n}\n"}, "pseudo_normalize": "int getAdjUnvisitedVertex(int vertexIndex) {\n  int i;\n  for (i = 0; i < vertexCount; ++i) {\n    if (adjMatrix[vertexIndex][i] == 1 && !lstVertices[i]->visited) return i;\n  }\n  return -1;\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<getAdjUnvisitedVertex>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1b1f <getAdjUnvisitedVertex+0x6b>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x57f0(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    $0x1,%eax\njne    1b1b <getAdjUnvisitedVertex+0x67>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5794(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    1b1b <getAdjUnvisitedVertex+0x67>\nmov    -0x4(%rbp),%eax\njmp    1b2f <getAdjUnvisitedVertex+0x7b>\naddl   $0x1,-0x4(%rbp)\nmov    0x581f(%rip),%eax\ncmp    %eax,-0x4(%rbp)\njl     1ac8 <getAdjUnvisitedVertex+0x14>\nmov    $0xffffffff,%eax\npop    %rbp\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "insertAtTheBegin", "content": "void insertAtTheBegin(struct Node **start_ref, int data) {\n    struct Node *ptr1 = (struct Node*)libmin_malloc(sizeof(struct Node));\n    ptr1->data = data;\n    ptr1->next = *start_ref;\n    *start_ref = ptr1;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "insertAtTheBegin", "address": "0x17b1", "label": "insertAtTheBegin", "content": "void __cdecl insertAtTheBegin(Node **start_ref, int data)\n{\n  Node *ptr1; // [rsp+18h] [rbp-8h]\n\n  ptr1 = (Node *)libmin_malloc(0x10uLL);\n  ptr1->data = data;\n  ptr1->next = *start_ref;\n  *start_ref = ptr1;\n}\n"}, "pseudo_normalize": "void insertAtTheBegin(Node **start_ref, int data) {\n  Node *ptr1;\n  ptr1 = (Node *)libmin_malloc(16uLL);\n  ptr1->data = data;\n  ptr1->next = *start_ref;\n  *start_ref = ptr1;\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<insertAtTheBegin>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    $0x10,%edi\ncall   1f36 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x1c(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\nnop\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "isEmpty", "content": "int isEmpty(struct queue* q) {\n    if(q->rear == -1)\n        return 1;\n    else\n        return 0;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "isEmpty", "address": "0x13ae", "label": "isEmpty", "content": "int __cdecl isEmpty(queue *q)\n{\n  return q->rear == -1;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<isEmpty>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0xa4(%rax),%eax\ncmp    $0xffffffff,%eax\njne    13d0 <isEmpty+0x22>\nmov    $0x1,%eax\njmp    13d5 <isEmpty+0x27>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "isStackEmpty", "content": "int isStackEmpty() {\n   return top == -1;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "isStackEmpty", "address": "0x19dd", "label": "isStackEmpty", "content": "int __cdecl isStackEmpty()\n{\n  return top == -1;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<isStackEmpty>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    0x5625(%rip),%eax\ncmp    $0xffffffff,%eax\nsete   %al\nmovzbl %al,%eax\npop    %rbp\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "link_list", "content": "void link_list() {\n    int arr[] = {12, 56, 2, 11, 1, 90};\n    int i;\n\n    struct Node *start = NULL;\n\n    for (i = 0; i< 6; i++)\n        insertAtTheBegin(&start, arr[i]);\n\n    bubbleSort(start);\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "link_list", "address": "0x18b8", "label": "link_list", "content": "void __cdecl link_list()\n{\n  int i; // [rsp+4h] [rbp-2Ch]\n  Node *start; // [rsp+8h] [rbp-28h] BYREF\n  int arr[6]; // [rsp+10h] [rbp-20h]\n  unsigned __int64 v3; // [rsp+28h] [rbp-8h]\n\n  v3 = __readfsqword(0x28u);\n  arr[0] = 12;\n  arr[1] = 56;\n  arr[2] = 2;\n  arr[3] = 11;\n  arr[4] = 1;\n  arr[5] = 90;\n  start = 0LL;\n  for ( i = 0; i <= 5; ++i )\n    insertAtTheBegin(&start, arr[i]);\n  bubbleSort(start);\n}\n"}, "pseudo_normalize": "void link_list() {\n  int i;\n  Node *start;\n  int arr[6];\n  unsigned long long v3;\n  v3 = __readfsqword(40u);\n  arr[0] = 12;\n  arr[1] = 56;\n  arr[2] = 2;\n  arr[3] = 11;\n  arr[4] = 1;\n  arr[5] = 90;\n  start = 0LL;\n  for (i = 0; i <= 5; ++i) insertAtTheBegin(&start, arr[i]);\n  bubbleSort(start);\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<link_list>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0xc,-0x20(%rbp)\nmovl   $0x38,-0x1c(%rbp)\nmovl   $0x2,-0x18(%rbp)\nmovl   $0xb,-0x14(%rbp)\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x5a,-0xc(%rbp)\nmovq   $0x0,-0x28(%rbp)\nmovl   $0x0,-0x2c(%rbp)\njmp    1929 <link_list+0x71>\nmov    -0x2c(%rbp),%eax\ncltq\nmov    -0x20(%rbp,%rax,4),%edx\nlea    -0x28(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   17b1 <insertAtTheBegin>\naddl   $0x1,-0x2c(%rbp)\ncmpl   $0x5,-0x2c(%rbp)\njle    190e <link_list+0x56>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1829 <bubbleSort>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1950 <link_list+0x98>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "main", "content": "int\nmain(void)\n{\n\n    bfs_test();\n\n    link_list();\n\n    DFS_test();\n\n    towers_test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "main", "address": "0x1d6c", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x0,%eax\ncall   16e9 <bfs_test>\nmov    $0x0,%eax\ncall   18b8 <link_list>\nmov    $0x0,%eax\ncall   1bec <DFS_test>\ncall   1d48 <towers_test>\ncall   4605 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "peek", "content": "int peek() {\n   return stack[top];\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "peek", "address": "0x19b9", "label": "peek", "content": "int __cdecl peek()\n{\n  return stack[top];\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<peek>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    0x5649(%rip),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x58a8(%rip),%rax\nmov    (%rdx,%rax,1),%eax\npop    %rbp\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "pop", "content": "int pop() {\n   return stack[top--];\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "pop", "address": "0x198c", "label": "pop", "content": "int __cdecl pop()\n{\n  int v0; // eax\n\n  v0 = top--;\n  return stack[v0];\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<pop>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    0x5676(%rip),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,0x566d(%rip)\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x58cc(%rip),%rax\nmov    (%rdx,%rax,1),%eax\npop    %rbp\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "printQueue", "content": "void printQueue(struct queue *q) {\n    int i = q->front;\n    if(isEmpty(q)) {\n        libmin_printf(\"Queue is empty\\n\");\n    } else {\n        libmin_printf(\"Queue contains: \");\n        for(i = q->front; i < q->rear + 1; i++) {\n            libmin_printf(\"%d \", q->items[i]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "printQueue", "address": "0x151b", "label": "printQueue", "content": "void __cdecl printQueue(queue *q)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  if ( isEmpty(q) )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n  }\n  else\n  {\n    libmin_printf(\"Queue contains: \");\n    for ( i = q->front; i <= q->rear; ++i )\n      libmin_printf(\"%d \", q->items[i]);\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo_normalize": "void printQueue(queue *q) {\n  int i;\n  if (isEmpty(q)) {\n    libmin_printf(\"Queue is empty\\n\");\n  } else {\n    libmin_printf(\"Queue contains: \");\n    for (i = q->front; i <= q->rear; ++i) libmin_printf(\"%d \", q->items[i]);\n    libmin_printf(\"\\n\");\n  }\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<printQueue>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0xa0(%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   13ae <isEmpty>\ntest   %eax,%eax\nje     155e <printQueue+0x43>\nlea    0x3ac6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\njmp    15cb <printQueue+0xb0>\nlea    0x3ad4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\nmov    -0x18(%rbp),%rax\nmov    0xa0(%rax),%eax\nmov    %eax,-0x4(%rbp)\njmp    15a8 <printQueue+0x8d>\nmov    -0x18(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nmov    (%rax,%rdx,4),%eax\nmov    %eax,%esi\nlea    0x3ab3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0xa4(%rax),%eax\ncmp    %eax,-0x4(%rbp)\njle    1581 <printQueue+0x66>\nlea    0x3a90(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4398 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "push", "content": "void push(int item) {\n   stack[++top] = item;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "push", "address": "0x1952", "label": "push", "content": "void __cdecl push(int item)\n{\n  stack[++top] = item;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<push>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    0x56ad(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x56a4(%rip)\nmov    0x569e(%rip),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x58fd(%rip),%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "swap", "content": "void swap(struct Node *a, struct Node *b) {\n    int temp = a->data;\n    a->data = b->data;\n    b->data = temp;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "swap", "address": "0x17f8", "label": "swap", "content": "void __cdecl swap(Node *a, Node *b)\n{\n  int temp; // [rsp+1Ch] [rbp-4h]\n\n  temp = a->data;\n  a->data = b->data;\n  b->data = temp;\n}\n"}, "pseudo_normalize": "void swap(Node *a, Node *b) {\n  int temp;\n  temp = a->data;\n  a->data = b->data;\n  b->data = temp;\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<swap>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmov    %edx,(%rax)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "towers", "content": "int\ntowers(int num, char frompeg, char topeg, char auxpeg)\n{\n    if (num == 1){\n        return 0;\n    }\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n    return 0;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "towers", "address": "0x1ce6", "label": "towers", "content": "int __cdecl towers(int num, char frompeg, char topeg, char auxpeg)\n{\n  if ( num != 1 )\n  {\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int towers(int num, char frompeg, char topeg, char auxpeg) {\n  if (num != 1) {\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n  }\n  return 0;\n}", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<towers>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %ecx,%eax\nmov    %esi,%ecx\nmov    %cl,-0x8(%rbp)\nmov    %dl,-0xc(%rbp)\nmov    %al,-0x10(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njne    1d0f <towers+0x29>\nmov    $0x0,%eax\njmp    1d46 <towers+0x60>\nmovsbl -0xc(%rbp),%ecx\nmovsbl -0x10(%rbp),%edx\nmovsbl -0x8(%rbp),%eax\nmov    -0x4(%rbp),%esi\nlea    -0x1(%rsi),%edi\nmov    %eax,%esi\ncall   1ce6 <towers>\nmovsbl -0x8(%rbp),%ecx\nmovsbl -0xc(%rbp),%edx\nmovsbl -0x10(%rbp),%eax\nmov    -0x4(%rbp),%esi\nlea    -0x1(%rsi),%edi\nmov    %eax,%esi\ncall   1ce6 <towers>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "towers_test", "content": "void\ntowers_test(void)\n{\n    towers(5, 'A', 'C', 'B');\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O0.pseudo", "function_name": "towers_test", "address": "0x1d48", "label": "towers_test", "content": "void __cdecl towers_test()\n{\n  towers(5, 65, 67, 66);\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O0", "assembly": "<towers_test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x42,%ecx\nmov    $0x43,%edx\nmov    $0x41,%esi\nmov    $0x5,%edi\ncall   1ce6 <towers>\nnop\npop    %rbp\nret\n"}
{"source": {"path": "hanoi/hanoi.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int disk, Loops = 0;\n\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\");\n  libmin_printf(\"Disks     Moves\\n\");\n\n  disk = 0;\n\n  while (1)\n    {\n      disk++;\n      num[0] = 0;\n      num[1] = disk;\n      num[2] = 0;\n      num[3] = 0;\n      count  = 0;\n\n      mov(disk,1,3);\n\n      Loops = Loops + 1;\n      libmin_printf(\"%3d  %10ld\\n\",disk,count);\n\n      if (disk == 10) break;\n    }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "hanoi/hanoi.host.O0.pseudo", "function_name": "main", "address": "0x12d4", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int disk; // [rsp+8h] [rbp-8h]\n  int Loops; // [rsp+Ch] [rbp-4h]\n\n  Loops = 0;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  for ( disk = 0; disk != 10; libmin_printf(\"%3d  %10ld\\n\", disk, count) )\n  {\n    ++disk;\n    num[0] = 0;\n    num[1] = disk;\n    num[2] = 0;\n    num[3] = 0;\n    count = 0LL;\n    mov(disk, 1, 3);\n    ++Loops;\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int disk;\n  int Loops;\n  Loops = 0;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  for (disk = 0; disk != 10; libmin_printf(\"%3d  %10ld\\n\", disk, count)) {\n    ++disk;\n    num[0] = 0;\n    num[1] = disk;\n    num[2] = 0;\n    num[3] = 0;\n    count = 0LL;\n    mov(disk, 1, 3);\n    ++Loops;\n  }\n  libmin_success();\n}", "binary": "hanoi/hanoi.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x4(%rbp)\nlea    0x2d1a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34d5 <libmin_printf>\nlea    0x2d2b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34d5 <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\naddl   $0x1,-0x8(%rbp)\nmovl   $0x0,0x4f4c(%rip)\nmov    -0x8(%rbp),%eax\nmov    %eax,0x4f47(%rip)\nmovl   $0x0,0x4f41(%rip)\nmovl   $0x0,0x4f3b(%rip)\nmovq   $0x0,0x4f34(%rip)\nmov    -0x8(%rbp),%eax\nmov    $0x3,%edx\nmov    $0x1,%esi\nmov    %eax,%edi\ncall   11e9 <mov>\naddl   $0x1,-0x4(%rbp)\nmov    0x4f15(%rip),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,%esi\nlea    0x2cc7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34d5 <libmin_printf>\ncmpl   $0xa,-0x8(%rbp)\nje     138c <main+0xb8>\njmp    1316 <main+0x42>\nnop\ncall   3742 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "hanoi/hanoi.c", "function_name": "mov", "content": "static int\nmov(int n, int f, int t)\n{\n  int o;\n\n  if (n == 1)\n    {\n      num[f]--;\n      num[t]++;\n      count++;\n      return 0;\n    }\n  o = other(f, t);\n  mov(n-1, f, o);\n  mov(1, f, t);\n  mov(n-1, o, t);\n  return 0;\n}\n"}, "pseudo": {"path": "hanoi/hanoi.host.O0.pseudo", "function_name": "mov", "address": "0x11e9", "label": "mov", "content": "int __cdecl mov(int n, int f, int t)\n{\n  if ( n == 1 )\n  {\n    --num[f];\n    ++num[t];\n    ++count;\n  }\n  else\n  {\n    mov(n - 1, f, 6 - (t + f));\n    mov(1, f, t);\n    mov(n - 1, 6 - (t + f), t);\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int mov(int n, int f, int t) {\n  if (n == 1) {\n    --num[f];\n    ++num[t];\n    ++count;\n  } else {\n    mov(n - 1, f, 6 - (t + f));\n    mov(1, f, t);\n    mov(n - 1, 6 - (t + f), t);\n  }\n  return 0;\n}", "binary": "hanoi/hanoi.host.O0", "assembly": "<mov>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %edx,-0x1c(%rbp)\ncmpl   $0x1,-0x14(%rbp)\njne    127f <mov+0x96>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5058(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nlea    -0x1(%rax),%ecx\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x503e(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5027(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nlea    0x1(%rax),%ecx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x500d(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    0x5013(%rip),%rax\nadd    $0x1,%rax\nmov    %rax,0x5008(%rip)\nmov    $0x0,%eax\njmp    12d2 <mov+0xe9>\nmov    -0x18(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nadd    %eax,%edx\nmov    $0x6,%eax\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x14(%rbp),%eax\nlea    -0x1(%rax),%ecx\nmov    -0x4(%rbp),%edx\nmov    -0x18(%rbp),%eax\nmov    %eax,%esi\nmov    %ecx,%edi\ncall   11e9 <mov>\nmov    -0x1c(%rbp),%edx\nmov    -0x18(%rbp),%eax\nmov    %eax,%esi\nmov    $0x1,%edi\ncall   11e9 <mov>\nmov    -0x14(%rbp),%eax\nlea    -0x1(%rax),%ecx\nmov    -0x1c(%rbp),%edx\nmov    -0x4(%rbp),%eax\nmov    %eax,%esi\nmov    %ecx,%edi\ncall   11e9 <mov>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "heapsort/heapsort.c", "function_name": "HSORT", "content": "/*************************/\n/*  Heap Sort Program    */\n/*************************/\n\nint\nHSORT(int64_t m, int64_t p)\n{\n  int64_t i,j,k,l;\n  int64_t size;\n\n  int64_t  msize, iran, ia, ic, im, ih, ir;\n  int64_t  count, ca;\n\n  msize = m * bplong;\n  size  = m - 1;\n\n  if (m >= 2048)\n    {\n      libmin_printf(\"base buffer overflow!\\n\");\n      libmin_fail(1);\n    }\n\n  ia = 106;\n  ic = 1283;\n  im = 6075;\n  ih = 1001;\n\n  count = 0;\n\n  iran = 47;                        /* Fill with 'random' numbers */\n  for(i=1 ; i<=size ; i++)\n    {\n      iran = (iran * ia + ic) % im;\n      *(base+i) = 1 + (ih * iran) / im;\n    }\n\n  k = (size >> 1) + 1;              /* Heap sort the array */\n  l = size;\n  ca = 0;\n\n  for (;;)\n    {\n      if (k > 1)\n\t{\n\t  ir = *(base+(--k));\n\t}\n      else\n\t{\n\t  ir = *(base+l);\n\t  *(base+l) = *(base+1);\n\t  if (--l == 1)\n\t    {\n\t      *(base+1) = ir;\n\t      goto Done;\n\t    }\n\t}\n\n      i = k;\n      j = k << 1;\n\n      while (j <= l)\n\t{\n\t  if ( (j < l) && (*(base+j) < *(base+j+1)) ) ++j;\n\t  if (ir < *(base+j))\n\t    {\n\t      *(base+i) = *(base+j);\n\t      j += (i=j);\n\t    }\n\t  else\n\t    {\n\t      j = l + 1;\n\t    }\n\t}\n      *(base+i) = ir;\n    }\n Done:\n  count = count + ca;\n\n  /* Scale runtime per iteration */\n  ir = count;\n  ir = (ir + ca) / 2;\n\n  if ( p != 0L )\n    libmin_printf(\"   %10ld\\n\", (int)msize);\n\n  /* check the array */\n  for(i = 0; i < size-1; i++)\n    {\n      if (base[i] > base[i+1])\n      {\n        libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n        libmin_fail(1);\n      }\n    }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n\n  return 0;\n}\n"}, "pseudo": {"path": "heapsort/heapsort.host.O0.pseudo", "function_name": "HSORT", "address": "0x11e9", "label": "HSORT", "content": "int __cdecl HSORT(int64_t m, int64_t p)\n{\n  int64_t i; // [rsp+10h] [rbp-70h]\n  int64_t ia; // [rsp+10h] [rbp-70h]\n  int64_t ib; // [rsp+10h] [rbp-70h]\n  int64_t j; // [rsp+18h] [rbp-68h]\n  int64_t k; // [rsp+20h] [rbp-60h]\n  int64_t l; // [rsp+28h] [rbp-58h]\n  int64_t iran; // [rsp+30h] [rbp-50h]\n  int64_t ir; // [rsp+38h] [rbp-48h]\n  unsigned int msize; // [rsp+40h] [rbp-40h]\n  int64_t size; // [rsp+48h] [rbp-38h]\n\n  msize = m * bplong;\n  size = m - 1;\n  if ( m > 2047 )\n  {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  iran = 47LL;\n  for ( i = 1LL; i <= size; ++i )\n  {\n    iran = (106 * iran + 1283) % 6075;\n    base[i] = 1001 * iran / 6075 + 1;\n  }\n  k = (size >> 1) + 1;\n  l = m - 1;\n  while ( k > 1 )\n  {\n    ir = base[--k];\nLABEL_12:\n    ia = k;\n    j = 2 * k;\n    while ( j <= l )\n    {\n      if ( j < l && base[j] < base[j + 1] )\n        ++j;\n      if ( ir >= base[j] )\n      {\n        j = l + 1;\n      }\n      else\n      {\n        base[ia] = base[j];\n        ia = j;\n        j *= 2LL;\n      }\n    }\n    base[ia] = ir;\n  }\n  ir = base[l];\n  base[l--] = base[1];\n  if ( l != 1 )\n    goto LABEL_12;\n  base[1] = ir;\n  if ( p )\n    libmin_printf(\"   %10ld\\n\", msize);\n  for ( ib = 0LL; ib < m - 2; ++ib )\n  {\n    if ( base[ib] > base[ib + 1] )\n    {\n      libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n      libmin_fail(1);\n    }\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  return 0;\n}\n"}, "pseudo_normalize": "int HSORT(int64_t m, int64_t p) {\n  int64_t i;\n  int64_t ia;\n  int64_t ib;\n  int64_t j;\n  int64_t k;\n  int64_t l;\n  int64_t iran;\n  int64_t ir;\n  unsigned int msize;\n  int64_t size;\n  msize = m * bplong;\n  size = m - 1;\n  if (m > 2047) {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  iran = 47LL;\n  for (i = 1LL; i <= size; ++i) {\n    iran = (106 * iran + 1283) % 6075;\n    base[i] = 1001 * iran / 6075 + 1;\n  }\n  k = (size >> 1) + 1;\n  l = m - 1;\n  while (k > 1) {\n    ir = base[--k];\n  LABEL_12:\n    ia = k;\n    j = 2 * k;\n    while (j <= l) {\n      if (j < l && base[j] < base[j + 1]) ++j;\n      if (ir >= base[j]) {\n        j = l + 1;\n      } else {\n        base[ia] = base[j];\n        ia = j;\n        j *= 2LL;\n      }\n    }\n    base[ia] = ir;\n  }\n  ir = base[l];\n  base[l--] = base[1];\n  if (l != 1) goto LABEL_12;\n  base[1] = ir;\n  if (p) libmin_printf(\"   %10ld\\n\", msize);\n  for (ib = 0LL; ib < m - 2; ++ib) {\n    if (base[ib] > base[ib + 1]) {\n      libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n      libmin_fail(1);\n    }\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  return 0;\n}", "binary": "heapsort/heapsort.host.O0", "assembly": "<HSORT>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\nmov    0x507c(%rip),%rax\nmov    -0x78(%rbp),%rdx\nimul   %rdx,%rax\nmov    %rax,-0x40(%rbp)\nmov    -0x78(%rbp),%rax\nsub    $0x1,%rax\nmov    %rax,-0x38(%rbp)\ncmpq   $0x7ff,-0x78(%rbp)\njle    1244 <HSORT+0x5b>\nlea    0x2ddb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nmov    $0x1,%edi\ncall   172d <libmin_fail>\nmovq   $0x6a,-0x30(%rbp)\nmovq   $0x503,-0x28(%rbp)\nmovq   $0x17bb,-0x20(%rbp)\nmovq   $0x3e9,-0x18(%rbp)\nmovq   $0x0,-0x10(%rbp)\nmovq   $0x2f,-0x50(%rbp)\nmovq   $0x1,-0x70(%rbp)\njmp    12cf <HSORT+0xe6>\nmov    -0x50(%rbp),%rax\nimul   -0x30(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\ncqto\nidivq  -0x20(%rbp)\nmov    %rdx,-0x50(%rbp)\nmov    -0x18(%rbp),%rax\nimul   -0x50(%rbp),%rax\ncqto\nidivq  -0x20(%rbp)\nmov    %rax,%rdx\nmov    -0x70(%rbp),%rax\nlea    0x0(,%rax,8),%rcx\nlea    0x4fe0(%rip),%rax\nadd    %rcx,%rax\nadd    $0x1,%rdx\nmov    %rdx,(%rax)\naddq   $0x1,-0x70(%rbp)\nmov    -0x70(%rbp),%rax\ncmp    -0x38(%rbp),%rax\njle    127e <HSORT+0x95>\nmov    -0x38(%rbp),%rax\nsar    %rax\nadd    $0x1,%rax\nmov    %rax,-0x60(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,-0x58(%rbp)\nmovq   $0x0,-0x8(%rbp)\ncmpq   $0x1,-0x60(%rbp)\njle    1326 <HSORT+0x13d>\nsubq   $0x1,-0x60(%rbp)\nmov    -0x60(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4f89(%rip),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x48(%rbp)\njmp    13b7 <HSORT+0x1ce>\nmov    -0x58(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4f67(%rip),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,-0x48(%rbp)\nmov    -0x58(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4f4a(%rip),%rax\nadd    %rax,%rdx\nmov    0x4f48(%rip),%rax\nmov    %rax,(%rdx)\nsubq   $0x1,-0x58(%rbp)\ncmpq   $0x1,-0x58(%rbp)\njne    13b7 <HSORT+0x1ce>\nmov    -0x48(%rbp),%rax\nmov    %rax,0x4f2e(%rip)\nnop\nmov    -0x8(%rbp),%rax\nadd    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x48(%rbp)\nmov    -0x48(%rbp),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,%rdx\nshr    $0x3f,%rdx\nadd    %rdx,%rax\nsar    %rax\nmov    %rax,-0x48(%rbp)\ncmpq   $0x0,-0x80(%rbp)\nje     14d2 <HSORT+0x2e9>\njmp    14b8 <HSORT+0x2cf>\nmov    -0x60(%rbp),%rax\nmov    %rax,-0x70(%rbp)\nmov    -0x60(%rbp),%rax\nadd    %rax,%rax\nmov    %rax,-0x68(%rbp)\njmp    1488 <HSORT+0x29f>\nmov    -0x68(%rbp),%rax\ncmp    -0x58(%rbp),%rax\njge    1419 <HSORT+0x230>\nmov    -0x68(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4eb4(%rip),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x68(%rbp),%rax\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rcx\nlea    0x4e97(%rip),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\ncmp    %rax,%rdx\njge    1419 <HSORT+0x230>\naddq   $0x1,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4e74(%rip),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\ncmp    %rax,-0x48(%rbp)\njge    147c <HSORT+0x293>\nmov    -0x68(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4e55(%rip),%rax\nadd    %rdx,%rax\nmov    -0x70(%rbp),%rdx\nlea    0x0(,%rdx,8),%rcx\nlea    0x4e3f(%rip),%rdx\nadd    %rcx,%rdx\nmov    (%rax),%rax\nmov    %rax,(%rdx)\nmov    -0x68(%rbp),%rax\nmov    %rax,-0x70(%rbp)\nmov    -0x70(%rbp),%rax\nadd    %rax,-0x68(%rbp)\njmp    1488 <HSORT+0x29f>\nmov    -0x58(%rbp),%rax\nadd    $0x1,%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\ncmp    -0x58(%rbp),%rax\njle    13cf <HSORT+0x1e6>\nmov    -0x70(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4df7(%rip),%rax\nadd    %rax,%rdx\nmov    -0x48(%rbp),%rax\nmov    %rax,(%rdx)\njmp    12f8 <HSORT+0x10f>\nmov    -0x40(%rbp),%rax\nmov    %eax,%esi\nlea    0x2b5a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nmovq   $0x0,-0x70(%rbp)\njmp    1536 <HSORT+0x34d>\nmov    -0x70(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nlea    0x4db1(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x70(%rbp),%rax\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rcx\nlea    0x4d96(%rip),%rax\nmov    (%rcx,%rax,1),%rax\ncmp    %rax,%rdx\njle    1531 <HSORT+0x348>\nlea    0x2b16(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nmov    $0x1,%edi\ncall   172d <libmin_fail>\naddq   $0x1,-0x70(%rbp)\nmov    -0x38(%rbp),%rax\nsub    $0x1,%rax\ncmp    %rax,-0x70(%rbp)\njl     14dc <HSORT+0x2f3>\nlea    0x2b15(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "heapsort/heapsort.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int64_t  j, p;\n\n  bplong = sizeof(int64_t);\n\n  libmin_printf(\"\\n   Heap Sort C Program\\n\");\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", (long)bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n\n\t\t\t\t   /* Predetermine runtime (sec) for  */\n\t\t\t\t   /* memory size 2000 * sizeof(long),*/\n\t\t\t\t   /* and 256 iterations. p = 0 means */\n\t\t\t\t   /* don't print the result.         */\n  j = 1024;\n  p = 1;\n  HSORT(j,p);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "heapsort/heapsort.host.O0.pseudo", "function_name": "main", "address": "0x155f", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}", "binary": "heapsort/heapsort.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovq   $0x8,0x4d0a(%rip)\nlea    0x2b09(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nmov    0x4cef(%rip),%rax\nmov    %rax,%rsi\nlea    0x2b05(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nlea    0x2b10(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3759 <libmin_printf>\nmovq   $0x400,-0x10(%rbp)\nmovq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <HSORT>\ncall   39c6 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "heat-calc/heat-calc.c", "function_name": "main", "content": "#include \"libmin.h\"\n\n#define N      100    // Number of grid points along the rod.\n#define STEPS  500   // Number of time steps for the simulation.\n#define ALPHA  1.0    // Thermal diffusivity constant.\n#define DX     1.0    // Spatial step (distance between grid points).\n#define DT     0.1    // Time step (should be small enough for stability).\n\nint main() {\n    double u[N];      // Temperature distribution at current time.\n    double u_new[N];  // Temperature distribution for the next time step.\n    int i, step;\n\n    // Initialize the rod:\n    // Set an initial temperature distribution with a single \"hot spot\" at the center.\n    // Boundary conditions: fixed at 0.0 at both ends.\n    for (i = 0; i < N; i++) {\n        if (i == N / 2)\n            u[i] = 100.0;\n        else\n            u[i] = 0.0;\n    }\n\n    // Main time-stepping loop: simulate STEPS time steps.\n    for (step = 0; step < STEPS; step++) {\n        // Update interior points using the explicit finite difference scheme:\n        // u_new[i] = u[i] + DT * ALPHA * (u[i-1] - 2*u[i] + u[i+1]) / (DX*DX)\n        for (i = 1; i < N - 1; i++) {\n            u_new[i] = u[i] + DT * ALPHA * (u[i - 1] - 2 * u[i] + u[i + 1]) / (DX * DX);\n        }\n        \n        // Copy boundary values (Dirichlet boundary conditions; they remain constant).\n        u_new[0] = u[0];\n        u_new[N - 1] = u[N - 1];\n        \n        // Update the current temperature distribution from the newly computed values.\n        for (i = 0; i < N; i++) {\n            u[i] = u_new[i];\n        }\n    }\n\n    // Output the final temperature distribution.\n    libmin_printf(\"Final temperature distribution along the rod:\\n\");\n    for (i = 0; i < N; i++) {\n        libmin_printf(\"u[%d] = %.2f\\n\", i, u[i]);\n    }\n\n    // Compute a simple checksum (sum of all temperatures) for validation.\n    double checksum = 0.0;\n    for (i = 0; i < N; i++) {\n        checksum += u[i];\n    }\n    libmin_printf(\"Checksum: %.2f\\n\", checksum);\n\n    libtarg_success();\n    return 0;\n}\n"}, "pseudo": {"path": "heat-calc/heat-calc.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-660h]\n  int ia; // [rsp+0h] [rbp-660h]\n  int ib; // [rsp+0h] [rbp-660h]\n  int ic; // [rsp+0h] [rbp-660h]\n  int id; // [rsp+0h] [rbp-660h]\n  int step; // [rsp+4h] [rbp-65Ch]\n  double checksum; // [rsp+8h] [rbp-658h]\n  double u[100]; // [rsp+10h] [rbp-650h]\n  double u_new[102]; // [rsp+330h] [rbp-330h]\n\n  *(_QWORD *)&u_new[101] = __readfsqword(0x28u);\n  for ( i = 0; i <= 99; ++i )\n  {\n    if ( i == 50 )\n      u[50] = 100.0;\n    else\n      u[i] = 0.0;\n  }\n  for ( step = 0; step <= 499; ++step )\n  {\n    for ( ia = 1; ia <= 98; ++ia )\n      u_new[ia] = 0.1 * (u[ia - 1] - (u[ia] + u[ia]) + u[ia + 1]) + u[ia];\n    u_new[0] = u[0];\n    u_new[99] = u[99];\n    for ( ib = 0; ib <= 99; ++ib )\n      u[ib] = u_new[ib];\n  }\n  libmin_printf(\"Final temperature distribution along the rod:\\n\", argv, envp);\n  for ( ic = 0; ic <= 99; ++ic )\n    libmin_printf(\"u[%d] = %.2f\\n\", ic, u[ic]);\n  checksum = 0.0;\n  for ( id = 0; id <= 99; ++id )\n    checksum = u[id] + checksum;\n  libmin_printf(\"Checksum: %.2f\\n\", checksum);\n  libtarg_success();\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  int i;\n  int ia;\n  int ib;\n  int ic;\n  int id;\n  int step;\n  double checksum;\n  double u[100];\n  double u_new[102];\n  *(uint64_t *)&u_new[101] = __readfsqword(40u);\n  for (i = 0; i <= 99; ++i) {\n    if (i == 50)\n      u[50] = 100.0;\n    else\n      u[i] = 0.0;\n  }\n  for (step = 0; step <= 499; ++step) {\n    for (ia = 1; ia <= 98; ++ia)\n      u_new[ia] = 0.1 * (u[ia - 1] - (u[ia] + u[ia]) + u[ia + 1]) + u[ia];\n    u_new[0] = u[0];\n    u_new[99] = u[99];\n    for (ib = 0; ib <= 99; ++ib) u[ib] = u_new[ib];\n  }\n  libmin_printf(\"Final temperature distribution along the rod:\\n\", argv, envp);\n  for (ic = 0; ic <= 99; ++ic) libmin_printf(\"u[%d] = %.2f\\n\", ic, u[ic]);\n  checksum = 0.0;\n  for (id = 0; id <= 99; ++id) checksum = u[id] + checksum;\n  libmin_printf(\"Checksum: %.2f\\n\", checksum);\n  libtarg_success();\n}", "binary": "heat-calc/heat-calc.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x660,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x660(%rbp)\njmp    1253 <main+0x6a>\ncmpl   $0x32,-0x660(%rbp)\njne    1237 <main+0x4e>\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  0x2e2c(%rip),%xmm0\nmovsd  %xmm0,-0x650(%rbp,%rax,8)\njmp    124c <main+0x63>\nmov    -0x660(%rbp),%eax\ncltq\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x650(%rbp,%rax,8)\naddl   $0x1,-0x660(%rbp)\ncmpl   $0x63,-0x660(%rbp)\njle    1213 <main+0x2a>\nmovl   $0x0,-0x65c(%rbp)\njmp    1364 <main+0x17b>\nmovl   $0x1,-0x660(%rbp)\njmp    12f5 <main+0x10c>\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  -0x650(%rbp,%rax,8),%xmm2\nmov    -0x660(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmovsd  -0x650(%rbp,%rax,8),%xmm1\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  -0x650(%rbp,%rax,8),%xmm0\naddsd  %xmm0,%xmm0\nsubsd  %xmm0,%xmm1\nmov    -0x660(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmovsd  -0x650(%rbp,%rax,8),%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x2d8b(%rip),%xmm0\nmulsd  %xmm1,%xmm0\naddsd  %xmm2,%xmm0\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  %xmm0,-0x330(%rbp,%rax,8)\naddl   $0x1,-0x660(%rbp)\ncmpl   $0x62,-0x660(%rbp)\njle    1277 <main+0x8e>\nmovsd  -0x650(%rbp),%xmm0\nmovsd  %xmm0,-0x330(%rbp)\nmovsd  -0x338(%rbp),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovl   $0x0,-0x660(%rbp)\njmp    1354 <main+0x16b>\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  -0x330(%rbp,%rax,8),%xmm0\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  %xmm0,-0x650(%rbp,%rax,8)\naddl   $0x1,-0x660(%rbp)\ncmpl   $0x63,-0x660(%rbp)\njle    132b <main+0x142>\naddl   $0x1,-0x65c(%rbp)\ncmpl   $0x1f3,-0x65c(%rbp)\njle    126b <main+0x82>\nlea    0x2c8d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3583 <libmin_printf>\nmovl   $0x0,-0x660(%rbp)\njmp    13cc <main+0x1e3>\nmov    -0x660(%rbp),%eax\ncltq\nmov    -0x650(%rbp,%rax,8),%rdx\nmov    -0x660(%rbp),%eax\nmovq   %rdx,%xmm0\nmov    %eax,%esi\nlea    0x2c7f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3583 <libmin_printf>\naddl   $0x1,-0x660(%rbp)\ncmpl   $0x63,-0x660(%rbp)\njle    1394 <main+0x1ab>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x658(%rbp)\nmovl   $0x0,-0x660(%rbp)\njmp    1419 <main+0x230>\nmov    -0x660(%rbp),%eax\ncltq\nmovsd  -0x650(%rbp,%rax,8),%xmm0\nmovsd  -0x658(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x658(%rbp)\naddl   $0x1,-0x660(%rbp)\ncmpl   $0x63,-0x660(%rbp)\njle    13ed <main+0x204>\nmov    -0x658(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x2c10(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3583 <libmin_printf>\ncall   1447 <libtarg_success>\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "buildHuffmanTree", "content": "// Build Huffman Tree and return its root\nHuffmanNode* buildHuffmanTree(char data[], int freq[], int size) {\n    HuffmanNode *left, *right, *top;\n    MinHeap* minHeap = createAndBuildMinHeap(data, freq, size);\n    \n    while (!isSizeOne(minHeap)) {\n        left = extractMin(minHeap);\n        right = extractMin(minHeap);\n        \n        top = createNode('$', left->freq + right->freq);\n        top->left = left;\n        top->right = right;\n        \n        insertMinHeap(minHeap, top);\n    }\n    return extractMin(minHeap);\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "buildHuffmanTree", "address": "0x1647", "label": "buildHuffmanTree", "content": "HuffmanNode *__cdecl buildHuffmanTree(char *data, int *freq, int size)\n{\n  MinHeap *minHeap; // [rsp+20h] [rbp-20h]\n  HuffmanNode *left; // [rsp+28h] [rbp-18h]\n  HuffmanNode *right; // [rsp+30h] [rbp-10h]\n  HuffmanNode *top; // [rsp+38h] [rbp-8h]\n\n  for ( minHeap = createAndBuildMinHeap(data, freq, size); !isSizeOne(minHeap); insertMinHeap(minHeap, top) )\n  {\n    left = extractMin(minHeap);\n    right = extractMin(minHeap);\n    top = createNode(36, left->freq + right->freq);\n    top->left = left;\n    top->right = right;\n  }\n  return extractMin(minHeap);\n}\n"}, "pseudo_normalize": "HuffmanNode *buildHuffmanTree(char *data, int *freq, int size) {\n  MinHeap *minHeap;\n  HuffmanNode *left;\n  HuffmanNode *right;\n  HuffmanNode *top;\n  for (minHeap = createAndBuildMinHeap(data, freq, size); !isSizeOne(minHeap);\n       insertMinHeap(minHeap, top)) {\n    left = extractMin(minHeap);\n    right = extractMin(minHeap);\n    top = createNode(36, left->freq + right->freq);\n    top->left = left;\n    top->right = right;\n  }\n  return extractMin(minHeap);\n}", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<buildHuffmanTree>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %edx,-0x34(%rbp)\nmov    -0x34(%rbp),%edx\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   15a2 <createAndBuildMinHeap>\nmov    %rax,-0x20(%rbp)\njmp    16e5 <buildHuffmanTree+0x9e>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1415 <extractMin>\nmov    %rax,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1415 <extractMin>\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x4(%rax),%edx\nmov    -0x10(%rbp),%rax\nmov    0x4(%rax),%eax\nadd    %edx,%eax\nmov    %eax,%esi\nmov    $0x24,%edi\ncall   1209 <createNode>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,0x10(%rax)\nmov    -0x8(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1483 <insertMinHeap>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   13f8 <isSizeOne>\ntest   %eax,%eax\nje     167a <buildHuffmanTree+0x33>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1415 <extractMin>\nleave\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "buildMinHeap", "content": "// Build the min-heap\nvoid buildMinHeap(MinHeap* minHeap) {\n    int n = minHeap->size;\n    for (int i = (n - 1) / 2; i >= 0; i--)\n        minHeapify(minHeap, i);\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "buildMinHeap", "address": "0x1556", "label": "buildMinHeap", "content": "void __cdecl buildMinHeap(MinHeap *minHeap)\n{\n  int i; // [rsp+18h] [rbp-8h]\n\n  for ( i = (minHeap->size - 1) / 2; i >= 0; --i )\n    minHeapify(minHeap, i);\n}\n"}, "pseudo_normalize": "", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<buildMinHeap>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x8(%rbp)\njmp    1598 <buildMinHeap+0x42>\nmov    -0x8(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   12e8 <minHeapify>\nsubl   $0x1,-0x8(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njns    1583 <buildMinHeap+0x2d>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "createAndBuildMinHeap", "content": "// Create and build min-heap from given characters and their frequencies\nMinHeap* createAndBuildMinHeap(char data[], int freq[], int size) {\n    MinHeap* minHeap = createMinHeap(size);\n    for (int i = 0; i < size; i++) {\n        minHeap->array[i] = createNode(data[i], freq[i]);\n    }\n    minHeap->size = size;\n    buildMinHeap(minHeap);\n    return minHeap;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "createAndBuildMinHeap", "address": "0x15a2", "label": "createAndBuildMinHeap", "content": "MinHeap *__cdecl createAndBuildMinHeap(char *data, int *freq, int size)\n{\n  HuffmanNode **v3; // rbx\n  int i; // [rsp+24h] [rbp-1Ch]\n  MinHeap *minHeap; // [rsp+28h] [rbp-18h]\n\n  minHeap = createMinHeap(size);\n  for ( i = 0; i < size; ++i )\n  {\n    v3 = &minHeap->array[i];\n    *v3 = createNode(data[i], freq[i]);\n  }\n  minHeap->size = size;\n  buildMinHeap(minHeap);\n  return minHeap;\n}\n"}, "pseudo_normalize": "MinHeap *createAndBuildMinHeap(char *data, int *freq, int size) {\n  HuffmanNode **v3;\n  int i;\n  MinHeap *minHeap;\n  minHeap = createMinHeap(size);\n  for (i = 0; i < size; ++i) {\n    v3 = &minHeap->array[i];\n    *v3 = createNode(data[i], freq[i]);\n  }\n  minHeap->size = size;\n  buildMinHeap(minHeap);\n  return minHeap;\n}", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<createAndBuildMinHeap>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %edx,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\nmov    %eax,%edi\ncall   1261 <createMinHeap>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    1620 <createAndBuildMinHeap+0x7e>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    -0x18(%rbp),%rcx\nmov    0x8(%rcx),%rsi\nmov    -0x1c(%rbp),%ecx\nmovslq %ecx,%rcx\nshl    $0x3,%rcx\nlea    (%rsi,%rcx,1),%rbx\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1209 <createNode>\nmov    %rax,(%rbx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njl     15d1 <createAndBuildMinHeap+0x2f>\nmov    -0x18(%rbp),%rax\nmov    -0x34(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1556 <buildMinHeap>\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "createMinHeap", "content": "// Function to create a min-heap of given capacity\nMinHeap* createMinHeap(int capacity) {\n    MinHeap* minHeap = (MinHeap*)libmin_malloc(sizeof(MinHeap));\n    minHeap->size = 0;\n    minHeap->capacity = capacity;\n    minHeap->array = (HuffmanNode**)libmin_malloc(capacity * sizeof(HuffmanNode*));\n    return minHeap;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "createMinHeap", "address": "0x1261", "label": "createMinHeap", "content": "MinHeap *__cdecl createMinHeap(int capacity)\n{\n  MinHeap *minHeap; // [rsp+18h] [rbp-8h]\n\n  minHeap = (MinHeap *)libmin_malloc(0x10uLL);\n  minHeap->size = 0;\n  minHeap->capacity = capacity;\n  minHeap->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return minHeap;\n}\n"}, "pseudo_normalize": "MinHeap *createMinHeap(int capacity) {\n  MinHeap *minHeap;\n  minHeap = (MinHeap *)libmin_malloc(16uLL);\n  minHeap->size = 0;\n  minHeap->capacity = capacity;\n  minHeap->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return minHeap;\n}", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<createMinHeap>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x10,%edi\ncall   1fab <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovl   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,0x4(%rax)\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1fab <libmin_malloc>\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x8(%rdx)\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "createNode", "content": "// Function to create a new Huffman node\nHuffmanNode* createNode(char data, int freq) {\n    HuffmanNode* node = (HuffmanNode*)libmin_malloc(sizeof(HuffmanNode));\n    node->data = data;\n    node->freq = freq;\n    node->left = node->right = NULL;\n    return node;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "createNode", "address": "0x1209", "label": "createNode", "content": "HuffmanNode *__cdecl createNode(char data, int freq)\n{\n  HuffmanNode *result; // rax\n\n  result = (HuffmanNode *)libmin_malloc(0x18uLL);\n  result->data = data;\n  result->freq = freq;\n  result->right = 0LL;\n  result->left = result->right;\n  return result;\n}\n"}, "pseudo_normalize": "HuffmanNode *createNode(char data, int freq) {\n  HuffmanNode *result;\n  result = (HuffmanNode *)libmin_malloc(24uLL);\n  result->data = data;\n  result->freq = freq;\n  result->right = 0LL;\n  result->left = result->right;\n  return result;\n}", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<createNode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,%eax\nmov    %esi,-0x18(%rbp)\nmov    %al,-0x14(%rbp)\nmov    $0x18,%edi\ncall   1fab <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl -0x14(%rbp),%edx\nmov    %dl,(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%edx\nmov    %edx,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x10(%rax)\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "decodeString", "content": "// Decode the encoded bit string using the Huffman tree\nvoid decodeString(HuffmanNode* root, const char* encoded, char* decoded) {\n    int idx = 0, out_idx = 0;\n    HuffmanNode* curr = root;\n    while (encoded[idx]) {\n        if (encoded[idx] == '0')\n            curr = curr->left;\n        else\n            curr = curr->right;\n        \n        // If leaf node, record the character and restart from tree root\n        if (!curr->left && !curr->right) {\n            decoded[out_idx++] = curr->data;\n            curr = root;\n        }\n        idx++;\n    }\n    decoded[out_idx] = '\\0';\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "decodeString", "address": "0x1866", "label": "decodeString", "content": "void __cdecl decodeString(HuffmanNode *root, const char *encoded, char *decoded)\n{\n  int v3; // eax\n  int idx; // [rsp+18h] [rbp-10h]\n  int out_idx; // [rsp+1Ch] [rbp-Ch]\n  HuffmanNode *curr; // [rsp+20h] [rbp-8h]\n\n  idx = 0;\n  out_idx = 0;\n  curr = root;\n  while ( encoded[idx] )\n  {\n    if ( encoded[idx] == 48 )\n      curr = curr->left;\n    else\n      curr = curr->right;\n    if ( !curr->left && !curr->right )\n    {\n      v3 = out_idx++;\n      decoded[v3] = curr->data;\n      curr = root;\n    }\n    ++idx;\n  }\n  decoded[out_idx] = 0;\n}\n"}, "pseudo_normalize": "void decodeString(HuffmanNode *root, const char *encoded, char *decoded) {\n  int v3;\n  int idx;\n  int out_idx;\n  HuffmanNode *curr;\n  idx = 0;\n  out_idx = 0;\n  curr = root;\n  while (encoded[idx]) {\n    if (encoded[idx] == 48)\n      curr = curr->left;\n    else\n      curr = curr->right;\n    if (!curr->left && !curr->right) {\n      v3 = out_idx++;\n      decoded[v3] = curr->data;\n      curr = root;\n    }\n    ++idx;\n  }\n  decoded[out_idx] = 0;\n}", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<decodeString>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    1902 <decodeString+0x9c>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\njne    18b4 <decodeString+0x4e>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x8(%rbp)\njmp    18c0 <decodeString+0x5a>\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    18fe <decodeString+0x98>\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njne    18fe <decodeString+0x98>\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1892 <decodeString+0x2c>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "encodeString", "content": "// Encode the input string using the generated Huffman codes\nvoid encodeString(const char* input, char codes[][MAX_TREE_HT], char* encoded) {\n    encoded[0] = '\\0';\n    for (int i = 0; input[i]; i++) {\n        libmin_strcat(encoded, codes[(unsigned char)input[i]]);\n    }\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "encodeString", "address": "0x17f2", "label": "encodeString", "content": "void __cdecl encodeString(const char *input, char (*codes)[256], char *encoded)\n{\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  *encoded = 0;\n  for ( i = 0; input[i]; ++i )\n    libmin_strcat(encoded, &(*codes)[256 * (unsigned __int64)(unsigned __int8)input[i]]);\n}\n"}, "pseudo_normalize": "void encodeString(const char *input, char (*codes)[256], char *encoded) {\n  int i;\n  *encoded = 0;\n  for (i = 0; input[i]; ++i)\n    libmin_strcat(encoded,\n                  &(*codes)[256 * (unsigned long long)(unsigned char)input[i]]);\n}", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<encodeString>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0x4(%rbp)\njmp    184e <encodeString+0x5c>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nshl    $0x8,%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   463c <libmin_strcat>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    181a <encodeString+0x28>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "extractMin", "content": "// Extract minimum node from heap\nHuffmanNode* extractMin(MinHeap* minHeap) {\n    HuffmanNode* temp = minHeap->array[0];\n    minHeap->array[0] = minHeap->array[minHeap->size - 1];\n    minHeap->size--;\n    minHeapify(minHeap, 0);\n    return temp;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "extractMin", "address": "0x1415", "label": "extractMin", "content": "HuffmanNode *__cdecl extractMin(MinHeap *minHeap)\n{\n  HuffmanNode *temp; // [rsp+18h] [rbp-8h]\n\n  temp = *minHeap->array;\n  *minHeap->array = minHeap->array[--minHeap->size];\n  minHeapify(minHeap, 0);\n  return temp;\n}\n"}, "pseudo_normalize": "HuffmanNode *extractMin(MinHeap *minHeap) {\n  HuffmanNode *temp;\n  temp = *minHeap->array;\n  *minHeap->array = minHeap->array[--minHeap->size];\n  minHeapify(minHeap, 0);\n  return temp;\n}", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<extractMin>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x3,%rax\nsub    $0x8,%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    (%rdx),%rdx\nmov    %rdx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nlea    -0x1(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   12e8 <minHeapify>\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "generateCodes", "content": "// Recursively generate Huffman codes and store them in codes array\n// codes[c] will store the Huffman code (a string of '0's and '1's) for character c.\nvoid generateCodes(HuffmanNode* root, char arr[], int top, char codes[][MAX_TREE_HT]) {\n    if (root->left) {\n        arr[top] = '0';\n        generateCodes(root->left, arr, top + 1, codes);\n    }\n    if (root->right) {\n        arr[top] = '1';\n        generateCodes(root->right, arr, top + 1, codes);\n    }\n    // If node is a leaf, store the code\n    if (!root->left && !root->right) {\n        arr[top] = '\\0';\n        libmin_strcpy(codes[(unsigned char)root->data], arr);\n    }\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "generateCodes", "address": "0x1703", "label": "generateCodes", "content": "void __cdecl generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256])\n{\n  if ( root->left )\n  {\n    arr[top] = 48;\n    generateCodes(root->left, arr, top + 1, codes);\n  }\n  if ( root->right )\n  {\n    arr[top] = 49;\n    generateCodes(root->right, arr, top + 1, codes);\n  }\n  if ( !root->left && !root->right )\n  {\n    arr[top] = 0;\n    libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)root->data], arr);\n  }\n}\n"}, "pseudo_normalize": "void generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256]) {\n  if (root->left) {\n    arr[top] = 48;\n    generateCodes(root->left, arr, top + 1, codes);\n  }\n  if (root->right) {\n    arr[top] = 49;\n    generateCodes(root->right, arr, top + 1, codes);\n  }\n  if (!root->left && !root->right) {\n    arr[top] = 0;\n    libmin_strcpy(\n        &(*codes)[256 * (unsigned long long)(unsigned char)root->data], arr);\n  }\n}", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<generateCodes>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %edx,-0x14(%rbp)\nmov    %rcx,-0x20(%rbp)\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\nje     175e <generateCodes+0x5b>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edi\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    -0x20(%rbp),%rdx\nmov    -0x10(%rbp),%rsi\nmov    %rdx,%rcx\nmov    %edi,%edx\nmov    %rax,%rdi\ncall   1703 <generateCodes>\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\nje     179e <generateCodes+0x9b>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x31,(%rax)\nmov    -0x14(%rbp),%eax\nlea    0x1(%rax),%edi\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\nmov    -0x20(%rbp),%rdx\nmov    -0x10(%rbp),%rsi\nmov    %rdx,%rcx\nmov    %edi,%edx\nmov    %rax,%rdi\ncall   1703 <generateCodes>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    17ef <generateCodes+0xec>\nmov    -0x8(%rbp),%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njne    17ef <generateCodes+0xec>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nshl    $0x8,%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   46d6 <libmin_strcpy>\nnop\nleave\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "insertMinHeap", "content": "// Insert a node into the min-heap\nvoid insertMinHeap(MinHeap* minHeap, HuffmanNode* node) {\n    ++minHeap->size;\n    int i = minHeap->size - 1;\n    while (i && node->freq < minHeap->array[(i - 1) / 2]->freq) {\n        minHeap->array[i] = minHeap->array[(i - 1) / 2];\n        i = (i - 1) / 2;\n    }\n    minHeap->array[i] = node;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "insertMinHeap", "address": "0x1483", "label": "insertMinHeap", "content": "void __cdecl insertMinHeap(MinHeap *minHeap, HuffmanNode *node)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = minHeap->size++; i && node->freq < minHeap->array[(i - 1) / 2]->freq; i = (i - 1) / 2 )\n    minHeap->array[i] = minHeap->array[(i - 1) / 2];\n  minHeap->array[i] = node;\n}\n"}, "pseudo_normalize": "void insertMinHeap(MinHeap *minHeap, HuffmanNode *node) {\n  int i;\n  for (i = minHeap->size++; i && node->freq < minHeap->array[(i - 1) / 2]->freq;\n       i = (i - 1) / 2)\n    minHeap->array[i] = minHeap->array[(i - 1) / 2];\n  minHeap->array[i] = node;\n}", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<insertMinHeap>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\nsub    $0x1,%eax\nmov    %eax,-0x4(%rbp)\njmp    14fd <insertMinHeap+0x7a>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\ncltq\nshl    $0x3,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rax,%rdx\nmov    (%rcx),%rax\nmov    %rax,(%rdx)\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\nje     1538 <insertMinHeap+0xb5>\nmov    -0x20(%rbp),%rax\nmov    0x4(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0x4(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,%esi\nshr    $0x1f,%esi\nadd    %esi,%eax\nsar    %eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%eax\ncmp    %eax,%edx\njl     14b0 <insertMinHeap+0x2d>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%rax\nmov    %rax,(%rdx)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "isSizeOne", "content": "// Check if heap size is one\nint isSizeOne(MinHeap* minHeap) {\n    return (minHeap->size == 1);\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "isSizeOne", "address": "0x13f8", "label": "isSizeOne", "content": "int __cdecl isSizeOne(MinHeap *minHeap)\n{\n  return minHeap->size == 1;\n}\n"}, "pseudo_normalize": "", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<isSizeOne>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\ncmp    $0x1,%eax\nsete   %al\nmovzbl %al,%eax\npop    %rbp\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "main", "content": "int main() {\n    // Example input string to compress\n    char input[] = \"this is an example for huffman encoding\";\n    \n    // Count frequency of each character in input\n    int freq[256] = {0};\n    for (int i = 0; input[i]; i++) {\n        freq[(unsigned char)input[i]]++;\n    }\n    \n    // Create arrays for characters and their frequencies (for non-zero frequencies)\n    int unique = 0;\n    for (int i = 0; i < 256; i++)\n        if (freq[i])\n            unique++;\n    \n    char* characters = (char*)libmin_malloc(unique * sizeof(char));\n    int* frequencies = (int*)libmin_malloc(unique * sizeof(int));\n    \n    int index = 0;\n    for (int i = 0; i < 256; i++) {\n        if (freq[i]) {\n            characters[index] = (char)i;\n            frequencies[index] = freq[i];\n            index++;\n        }\n    }\n    \n    // Build Huffman Tree\n    HuffmanNode* root = buildHuffmanTree(characters, frequencies, unique);\n    \n    // Generate Huffman codes for characters\n    char codes[256][MAX_TREE_HT] = {{0}};\n    char arr[MAX_TREE_HT];\n    generateCodes(root, arr, 0, codes);\n    \n    // Print generated Huffman codes\n    libmin_printf(\"Huffman Codes:\\n\");\n    for (int i = 0; i < 256; i++) {\n        if (freq[i]) {\n            libmin_printf(\"'%c': %s\\n\", i, codes[i]);\n        }\n    }\n    \n    // Encode input string\n    char encoded[1024] = {0};\n    encodeString(input, codes, encoded);\n    libmin_printf(\"\\nEncoded string:\\n%s\\n\", encoded);\n    \n    // Report compression metrics:\n    int inputBits = libmin_strlen(input) * 8;         // Assuming 8 bits per char originally\n    int encodedBits = libmin_strlen(encoded);         // One character per bit in encoded string representation\n    libmin_printf(\"\\nCompression Metrics:\\n\");\n    libmin_printf(\"Original size: %d bits\\n\", inputBits);\n    libmin_printf(\"Encoded size: %d bits\\n\", encodedBits);\n    libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)encodedBits / inputBits * 100);\n    \n    // Decode the encoded string\n    char decoded[1024] = {0};\n    decodeString(root, encoded, decoded);\n    libmin_printf(\"\\nDecoded string:\\n%s\\n\", decoded);\n    \n    // Check that the decompressed string matches the original input\n    if (libmin_strcmp(input, decoded) == 0)\n        libmin_printf(\"\\nDecompression verified: decoded string matches the original input.\\n\");\n    else\n        libmin_printf(\"\\nError: decoded string does not match the original input.\\n\");\n    \n    // Free allocated memory for characters and frequencies\n    libmin_free(characters);\n    libmin_free(frequencies);\n    \n    // Note: In a complete implementation you should also free the Huffman tree nodes.\n\n    libmin_success();    \n    return 0;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "main", "address": "0x192d", "label": "main", "content": "// bad sp value at call has been detected, the output may be wrong!\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-10D78h]\n  int unique; // [rsp+4h] [rbp-10D74h]\n  int i_0; // [rsp+8h] [rbp-10D70h]\n  int index; // [rsp+Ch] [rbp-10D6Ch]\n  int i_1; // [rsp+10h] [rbp-10D68h]\n  int i_2; // [rsp+14h] [rbp-10D64h]\n  int inputBits; // [rsp+18h] [rbp-10D60h]\n  int encodedBits; // [rsp+1Ch] [rbp-10D5Ch]\n  char *characters; // [rsp+20h] [rbp-10D58h]\n  int *frequencies; // [rsp+28h] [rbp-10D50h]\n  HuffmanNode *root; // [rsp+30h] [rbp-10D48h]\n  int freq[256]; // [rsp+38h] [rbp-10D40h] BYREF\n  char codes[256][256]; // [rsp+438h] [rbp-10940h] BYREF\n  char input[48]; // [rsp+10438h] [rbp-940h] BYREF\n  char arr[256]; // [rsp+10468h] [rbp-910h] BYREF\n  char encoded[1024]; // [rsp+10568h] [rbp-810h] BYREF\n  char decoded[1032]; // [rsp+10968h] [rbp-410h] BYREF\n  unsigned __int64 v20; // [rsp+10D70h] [rbp-8h]\n\n  while ( &codes[249][64] != &codes[9][64] )\n    ;\n  v20 = __readfsqword(0x28u);\n  strcpy(input, \"this is an example for huffman encoding\");\n  memset(freq, 0, sizeof(freq));\n  for ( i = 0; input[i]; ++i )\n    ++freq[(unsigned __int8)input[i]];\n  unique = 0;\n  for ( i_0 = 0; i_0 <= 255; ++i_0 )\n  {\n    if ( freq[i_0] )\n      ++unique;\n  }\n  characters = (char *)libmin_malloc(unique);\n  frequencies = (int *)libmin_malloc(4LL * unique);\n  index = 0;\n  for ( i_1 = 0; i_1 <= 255; ++i_1 )\n  {\n    if ( freq[i_1] )\n    {\n      characters[index] = i_1;\n      frequencies[index++] = freq[i_1];\n    }\n  }\n  root = buildHuffmanTree(characters, frequencies, unique);\n  memset(codes, 0, sizeof(codes));\n  generateCodes(root, arr, 0, codes);\n  libmin_printf(\"Huffman Codes:\\n\");\n  for ( i_2 = 0; i_2 <= 255; ++i_2 )\n  {\n    if ( freq[i_2] )\n      libmin_printf(\"'%c': %s\\n\", (unsigned int)i_2, codes[(__int64)i_2]);\n  }\n  memset(encoded, 0, sizeof(encoded));\n  encodeString(input, codes, encoded);\n  libmin_printf(\"\\nEncoded string:\\n%s\\n\", encoded);\n  inputBits = 8 * libmin_strlen(input);\n  encodedBits = libmin_strlen(encoded);\n  libmin_printf(\"\\nCompression Metrics:\\n\");\n  libmin_printf(\"Original size: %d bits\\n\", inputBits);\n  libmin_printf(\"Encoded size: %d bits\\n\", encodedBits);\n  libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)encodedBits / (double)inputBits * 100.0);\n  memset(decoded, 0, 1024);\n  decodeString(root, encoded, decoded);\n  libmin_printf(\"\\nDecoded string:\\n%s\\n\", decoded);\n  if ( libmin_strcmp(input, decoded) )\n    libmin_printf(\"\\nError: decoded string does not match the original input.\\n\");\n  else\n    libmin_printf(\"\\nDecompression verified: decoded string matches the original input.\\n\");\n  libmin_free(characters);\n  libmin_free(frequencies);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int unique;\n  int i_0;\n  int index;\n  int i_1;\n  int i_2;\n  int inputBits;\n  int encodedBits;\n  char *characters;\n  int *frequencies;\n  HuffmanNode *root;\n  int freq[256];\n  char codes[256][256];\n  char input[48];\n  char arr[256];\n  char encoded[1024];\n  char decoded[1032];\n  unsigned long long v20;\n  while (&codes[249][64] != &codes[9][64])\n    ;\n  v20 = __readfsqword(40u);\n  strcpy(input, \"this is an example for huffman encoding\");\n  memset(freq, 0, sizeof(freq));\n  for (i = 0; input[i]; ++i) ++freq[(unsigned char)input[i]];\n  unique = 0;\n  for (i_0 = 0; i_0 <= 255; ++i_0) {\n    if (freq[i_0]) ++unique;\n  }\n  characters = (char *)libmin_malloc(unique);\n  frequencies = (int *)libmin_malloc(4LL * unique);\n  index = 0;\n  for (i_1 = 0; i_1 <= 255; ++i_1) {\n    if (freq[i_1]) {\n      characters[index] = i_1;\n      frequencies[index++] = freq[i_1];\n    }\n  }\n  root = buildHuffmanTree(characters, frequencies, unique);\n  memset(codes, 0, sizeof(codes));\n  generateCodes(root, arr, 0, codes);\n  libmin_printf(\"Huffman Codes:\\n\");\n  for (i_2 = 0; i_2 <= 255; ++i_2) {\n    if (freq[i_2])\n      libmin_printf(\"'%c': %s\\n\", (unsigned int)i_2, codes[(long long)i_2]);\n  }\n  memset(encoded, 0, sizeof(encoded));\n  encodeString(input, codes, encoded);\n  libmin_printf(\"\\nEncoded string:\\n%s\\n\", encoded);\n  inputBits = 8 * libmin_strlen(input);\n  encodedBits = libmin_strlen(encoded);\n  libmin_printf(\"\\nCompression Metrics:\\n\");\n  libmin_printf(\"Original size: %d bits\\n\", inputBits);\n  libmin_printf(\"Encoded size: %d bits\\n\", encodedBits);\n  libmin_printf(\"Compression ratio: %.2f%%\\n\",\n                (double)encodedBits / (double)inputBits * 100.0);\n  memset(decoded, 0, 1024);\n  decodeString(root, encoded, decoded);\n  libmin_printf(\"\\nDecoded string:\\n%s\\n\", decoded);\n  if (libmin_strcmp(input, decoded))\n    libmin_printf(\n        \"\\nError: decoded string does not match the original input.\\n\");\n  else\n    libmin_printf(\n        \"\\nDecompression verified: decoded string matches the original \"\n        \"input.\\n\");\n  libmin_free(characters);\n  libmin_free(frequencies);\n  libmin_success();\n}", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    -0x10000(%rsp),%r11\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\ncmp    %r11,%rsp\njne    193d <main+0x10>\nsub    $0xd80,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0x2073692073696874,%rax\nmovabs $0x706d617865206e61,%rdx\nmov    %rax,-0x940(%rbp)\nmov    %rdx,-0x938(%rbp)\nmovabs $0x6820726f6620656c,%rax\nmovabs $0x65206e616d666675,%rdx\nmov    %rax,-0x930(%rbp)\nmov    %rdx,-0x928(%rbp)\nmovabs $0x676e69646f636e,%rax\nmov    %rax,-0x920(%rbp)\nlea    -0x10d40(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x80,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovl   $0x0,-0x10d78(%rbp)\njmp    1a0c <main+0xdf>\nmov    -0x10d78(%rbp),%eax\ncltq\nmovzbl -0x940(%rbp,%rax,1),%eax\nmovzbl %al,%eax\nmovslq %eax,%rdx\nmov    -0x10d40(%rbp,%rdx,4),%edx\nadd    $0x1,%edx\ncltq\nmov    %edx,-0x10d40(%rbp,%rax,4)\naddl   $0x1,-0x10d78(%rbp)\nmov    -0x10d78(%rbp),%eax\ncltq\nmovzbl -0x940(%rbp,%rax,1),%eax\ntest   %al,%al\njne    19dc <main+0xaf>\nmovl   $0x0,-0x10d74(%rbp)\nmovl   $0x0,-0x10d70(%rbp)\njmp    1a57 <main+0x12a>\nmov    -0x10d70(%rbp),%eax\ncltq\nmov    -0x10d40(%rbp,%rax,4),%eax\ntest   %eax,%eax\nje     1a50 <main+0x123>\naddl   $0x1,-0x10d74(%rbp)\naddl   $0x1,-0x10d70(%rbp)\ncmpl   $0xff,-0x10d70(%rbp)\njle    1a36 <main+0x109>\nmov    -0x10d74(%rbp),%eax\ncltq\nmov    %rax,%rdi\ncall   1fab <libmin_malloc>\nmov    %rax,-0x10d58(%rbp)\nmov    -0x10d74(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   1fab <libmin_malloc>\nmov    %rax,-0x10d50(%rbp)\nmovl   $0x0,-0x10d6c(%rbp)\nmovl   $0x0,-0x10d68(%rbp)\njmp    1b12 <main+0x1e5>\nmov    -0x10d68(%rbp),%eax\ncltq\nmov    -0x10d40(%rbp,%rax,4),%eax\ntest   %eax,%eax\nje     1b0b <main+0x1de>\nmov    -0x10d6c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10d58(%rbp),%rax\nadd    %rdx,%rax\nmov    -0x10d68(%rbp),%edx\nmov    %dl,(%rax)\nmov    -0x10d6c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x10d50(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10d68(%rbp),%eax\ncltq\nmov    -0x10d40(%rbp,%rax,4),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x10d6c(%rbp)\naddl   $0x1,-0x10d68(%rbp)\ncmpl   $0xff,-0x10d68(%rbp)\njle    1aab <main+0x17e>\nmov    -0x10d74(%rbp),%edx\nmov    -0x10d50(%rbp),%rcx\nmov    -0x10d58(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1647 <buildHuffmanTree>\nmov    %rax,-0x10d48(%rbp)\nlea    -0x10940(%rbp),%rax\nmov    $0x10000,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   10d0 <memset@plt>\nlea    -0x10940(%rbp),%rdx\nlea    -0x910(%rbp),%rsi\nmov    -0x10d48(%rbp),%rax\nmov    %rdx,%rcx\nmov    $0x0,%edx\nmov    %rax,%rdi\ncall   1703 <generateCodes>\nlea    0x347f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\nmovl   $0x0,-0x10d64(%rbp)\njmp    1bee <main+0x2c1>\nmov    -0x10d64(%rbp),%eax\ncltq\nmov    -0x10d40(%rbp,%rax,4),%eax\ntest   %eax,%eax\nje     1be7 <main+0x2ba>\nlea    -0x10940(%rbp),%rdx\nmov    -0x10d64(%rbp),%eax\ncltq\nshl    $0x8,%rax\nadd    %rax,%rdx\nmov    -0x10d64(%rbp),%eax\nmov    %eax,%esi\nlea    0x343e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\naddl   $0x1,-0x10d64(%rbp)\ncmpl   $0xff,-0x10d64(%rbp)\njle    1ba2 <main+0x275>\nmovq   $0x0,-0x810(%rbp)\nmovq   $0x0,-0x808(%rbp)\nlea    -0x800(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x7e,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nlea    -0x810(%rbp),%rdx\nlea    -0x10940(%rbp),%rcx\nlea    -0x940(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   17f2 <encodeString>\nlea    -0x810(%rbp),%rax\nmov    %rax,%rsi\nlea    0x33ca(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\nlea    -0x940(%rbp),%rax\nmov    %rax,%rdi\ncall   4721 <libmin_strlen>\nshl    $0x3,%eax\nmov    %eax,-0x10d60(%rbp)\nlea    -0x810(%rbp),%rax\nmov    %rax,%rdi\ncall   4721 <libmin_strlen>\nmov    %eax,-0x10d5c(%rbp)\nlea    0x339e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\nmov    -0x10d60(%rbp),%eax\nmov    %eax,%esi\nlea    0x3399(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\nmov    -0x10d5c(%rbp),%eax\nmov    %eax,%esi\nlea    0x3395(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x10d5c(%rbp),%xmm0\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x10d60(%rbp),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x3432(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\nlea    0x3362(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   440d <libmin_printf>\nmovq   $0x0,-0x410(%rbp)\nmovq   $0x0,-0x408(%rbp)\nlea    -0x400(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x7e,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nlea    -0x410(%rbp),%rdx\nlea    -0x810(%rbp),%rcx\nmov    -0x10d48(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1866 <decodeString>\nlea    -0x410(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3312(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\nlea    -0x410(%rbp),%rdx\nlea    -0x940(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4678 <libmin_strcmp>\ntest   %eax,%eax\njne    1dc6 <main+0x499>\nlea    0x32f9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\njmp    1dda <main+0x4ad>\nlea    0x332b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   440d <libmin_printf>\nmov    -0x10d58(%rbp),%rax\nmov    %rax,%rdi\ncall   2096 <libmin_free>\nmov    -0x10d50(%rbp),%rax\nmov    %rax,%rdi\ncall   2096 <libmin_free>\ncall   475f <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1e16 <main+0x4e9>\ncall   10c0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "minHeapify", "content": "// Heapify at given index (min-heap)\nvoid minHeapify(MinHeap* minHeap, int idx) {\n    int smallest = idx;\n    int left = 2 * idx + 1;\n    int right = 2 * idx + 2;\n    \n    if (left < minHeap->size && minHeap->array[left]->freq < minHeap->array[smallest]->freq)\n        smallest = left;\n    if (right < minHeap->size && minHeap->array[right]->freq < minHeap->array[smallest]->freq)\n        smallest = right;\n    if (smallest != idx) {\n        swapNodes(&minHeap->array[smallest], &minHeap->array[idx]);\n        minHeapify(minHeap, smallest);\n    }\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "minHeapify", "address": "0x12e8", "label": "minHeapify", "content": "void __cdecl minHeapify(MinHeap *minHeap, int idx)\n{\n  int smallest; // [rsp+14h] [rbp-Ch]\n  int left; // [rsp+18h] [rbp-8h]\n  int right; // [rsp+1Ch] [rbp-4h]\n\n  smallest = idx;\n  left = 2 * idx + 1;\n  right = 2 * (idx + 1);\n  if ( left < minHeap->size && minHeap->array[left]->freq < minHeap->array[idx]->freq )\n    smallest = 2 * idx + 1;\n  if ( right < minHeap->size && minHeap->array[right]->freq < minHeap->array[smallest]->freq )\n    smallest = 2 * (idx + 1);\n  if ( smallest != idx )\n  {\n    swapNodes(&minHeap->array[smallest], &minHeap->array[idx]);\n    minHeapify(minHeap, smallest);\n  }\n}\n"}, "pseudo_normalize": "void minHeapify(MinHeap *minHeap, int idx) {\n  int smallest;\n  int left;\n  int right;\n  smallest = idx;\n  left = 2 * idx + 1;\n  right = 2 * (idx + 1);\n  if (left < minHeap->size &&\n      minHeap->array[left]->freq < minHeap->array[idx]->freq)\n    smallest = 2 * idx + 1;\n  if (right < minHeap->size &&\n      minHeap->array[right]->freq < minHeap->array[smallest]->freq)\n    smallest = 2 * (idx + 1);\n  if (smallest != idx) {\n    swapNodes(&minHeap->array[smallest], &minHeap->array[idx]);\n    minHeapify(minHeap, smallest);\n  }\n}", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<minHeapify>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\nadd    %eax,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x8(%rbp)\njge    1360 <minHeapify+0x78>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%eax\ncmp    %eax,%edx\njge    1360 <minHeapify+0x78>\nmov    -0x8(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x4(%rbp)\njge    13a9 <minHeapify+0xc1>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%eax\ncmp    %eax,%edx\njge    13a9 <minHeapify+0xc1>\nmov    -0x4(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\nje     13f5 <minHeapify+0x10d>\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rax,%rdx\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rcx,%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   12b1 <swapNodes>\nmov    -0xc(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   12e8 <minHeapify>\nnop\nleave\nret\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "swapNodes", "content": "// Swap two Huffman nodes\nvoid swapNodes(HuffmanNode** a, HuffmanNode** b) {\n    HuffmanNode* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O0.pseudo", "function_name": "swapNodes", "address": "0x12b1", "label": "swapNodes", "content": "void __cdecl swapNodes(HuffmanNode **a, HuffmanNode **b)\n{\n  HuffmanNode *temp; // [rsp+18h] [rbp-8h]\n\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}\n"}, "pseudo_normalize": "void swapNodes(HuffmanNode **a, HuffmanNode **b) {\n  HuffmanNode *temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}", "binary": "huff-encode/huff-encode.host.O0", "assembly": "<swapNodes>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x20(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "idct-alg/idct-alg.c", "function_name": "C", "content": "#include \"libmin.h\"\n\n#define N 8\n#define PI 3.14159265358979323846\n\ndouble C(int u) {\n    return (u == 0) ? libmin_sqrt(1.0 / N) : libmin_sqrt(2.0 / N);\n}\n"}, "pseudo": {"path": "idct-alg/idct-alg.host.O0.pseudo", "function_name": "C", "address": "0x11e9", "label": "C", "content": "double __cdecl C(int u)\n{\n  if ( u )\n    return libmin_sqrt(0.25);\n  else\n    return libmin_sqrt(0.125);\n}\n"}, "pseudo_normalize": "double C(int u) {\n  if (u)\n    return libmin_sqrt(0.25);\n  else\n    return libmin_sqrt(0.125);\n}", "binary": "idct-alg/idct-alg.host.O0", "assembly": "<C>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    1216 <C+0x2d>\nmov    0x4e23(%rip),%rax\nmovq   %rax,%xmm0\ncall   3e79 <libmin_sqrt>\nmovq   %xmm0,%rax\njmp    122c <C+0x43>\nmov    0x4e13(%rip),%rax\nmovq   %rax,%xmm0\ncall   3e79 <libmin_sqrt>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "idct-alg/idct-alg.c", "function_name": "idct_2d", "content": "void idct_2d(double input[N][N], double output[N][N]) {\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n            double sum = 0.0;\n            for (int u = 0; u < N; u++) {\n                for (int v = 0; v < N; v++) {\n                    sum += C(u) * C(v) * input[u][v] *\n                        libmin_cos(((2 * x + 1) * u * PI) / (2 * N)) *\n                        libmin_cos(((2 * y + 1) * v * PI) / (2 * N));\n                }\n            }\n            output[x][y] = sum;\n        }\n    }\n}\n"}, "pseudo": {"path": "idct-alg/idct-alg.host.O0.pseudo", "function_name": "idct_2d", "address": "0x1233", "label": "idct_2d", "content": "void __cdecl idct_2d(double (*input)[8], double (*output)[8])\n{\n  double v2; // [rsp+8h] [rbp-38h]\n  double v3; // [rsp+8h] [rbp-38h]\n  double v4; // [rsp+8h] [rbp-38h]\n  int x; // [rsp+28h] [rbp-18h]\n  int y; // [rsp+2Ch] [rbp-14h]\n  int u; // [rsp+30h] [rbp-10h]\n  int v; // [rsp+34h] [rbp-Ch]\n  double sum; // [rsp+38h] [rbp-8h]\n\n  for ( x = 0; x <= 7; ++x )\n  {\n    for ( y = 0; y <= 7; ++y )\n    {\n      sum = 0.0;\n      for ( u = 0; u <= 7; ++u )\n      {\n        for ( v = 0; v <= 7; ++v )\n        {\n          v2 = C(u);\n          v3 = v2 * C(v) * (*input)[8 * (__int64)u + v];\n          v4 = libmin_cos(3.141592653589793 * (double)(u * (2 * x + 1)) / 16.0) * v3;\n          sum = libmin_cos(3.141592653589793 * (double)(v * (2 * y + 1)) / 16.0) * v4 + sum;\n        }\n      }\n      (*output)[8 * (__int64)x + y] = sum;\n    }\n  }\n}\n"}, "pseudo_normalize": "void idct_2d(double (*input)[8], double (*output)[8]) {\n  double v2;\n  double v3;\n  double v4;\n  int x;\n  int y;\n  int u;\n  int v;\n  double sum;\n  for (x = 0; x <= 7; ++x) {\n    for (y = 0; y <= 7; ++y) {\n      sum = 0.0;\n      for (u = 0; u <= 7; ++u) {\n        for (v = 0; v <= 7; ++v) {\n          v2 = C(u);\n          v3 = v2 * C(v) * (*input)[8 * (long long)u + v];\n          v4 =\n              libmin_cos(3.141592653589793 * (double)(u * (2 * x + 1)) / 16.0) *\n              v3;\n          sum =\n              libmin_cos(3.141592653589793 * (double)(v * (2 * y + 1)) / 16.0) *\n                  v4 +\n              sum;\n        }\n      }\n      (*output)[8 * (long long)x + y] = sum;\n    }\n  }\n}", "binary": "idct-alg/idct-alg.host.O0", "assembly": "<idct_2d>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    13af <idct_2d+0x17c>\nmovl   $0x0,-0x14(%rbp)\njmp    13a1 <idct_2d+0x16e>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1371 <idct_2d+0x13e>\nmovl   $0x0,-0xc(%rbp)\njmp    1363 <idct_2d+0x130>\nmov    -0x10(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <C>\nmovsd  %xmm0,-0x38(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <C>\nmovsd  -0x38(%rbp),%xmm1\nmulsd  %xmm0,%xmm1\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x6,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm0\nmulsd  %xmm0,%xmm1\nmovsd  %xmm1,-0x38(%rbp)\nmov    -0x18(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nimul   -0x10(%rbp),%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmovsd  0x4d54(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  0x4d50(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   3b18 <libmin_cos>\nmulsd  -0x38(%rbp),%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmov    -0x14(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nimul   -0xc(%rbp),%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmovsd  0x4d0f(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  0x4d0b(%rip),%xmm1\nmovapd %xmm0,%xmm3\ndivsd  %xmm1,%xmm3\nmovq   %xmm3,%rax\nmovq   %rax,%xmm0\ncall   3b18 <libmin_cos>\nmulsd  -0x38(%rbp),%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njle    1280 <idct_2d+0x4d>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x7,-0x10(%rbp)\njle    1274 <idct_2d+0x41>\nmov    -0x18(%rbp),%eax\ncltq\nshl    $0x6,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\ncltq\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,(%rdx,%rax,8)\naddl   $0x1,-0x14(%rbp)\ncmpl   $0x7,-0x14(%rbp)\njle    125f <idct_2d+0x2c>\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x7,-0x18(%rbp)\njle    1253 <idct_2d+0x20>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "idct-alg/idct-alg.c", "function_name": "main", "content": "int main() {\n    // Example: DCT domain input (can be real JPEG coefficients)\n    double input[N][N] = {\n        {52, 0, 0, 0, 0, 0, 0, 0},\n        {30, 0, 0, 0, 0, 0, 0, 0},\n        {20, 0, 0, 0, 0, 0, 0, 0},\n        {10, 0, 0, 0, 0, 0, 0, 0},\n        { 5, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n    };\n\n    double output[N][N] = {0};\n\n    idct_2d(input, output);\n    print_matrix(output, \"IDCT Output\");\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "idct-alg/idct-alg.host.O0.pseudo", "function_name": "main", "address": "0x1472", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double input[8][8]; // [rsp+0h] [rbp-410h] BYREF\n  double output[8][8]; // [rsp+200h] [rbp-210h] BYREF\n  unsigned __int64 v5; // [rsp+408h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  input[3][0] = 10.0;\n  input[4][0] = 5.0;\n  memset(output, 0, sizeof(output));\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double input[8][8];\n  double output[8][8];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  input[3][0] = 10.0;\n  input[4][0] = 5.0;\n  memset(output, 0, sizeof(output));\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}", "binary": "idct-alg/idct-alg.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x410,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x410(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x40,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovsd  0x4b99(%rip),%xmm0\nmovsd  %xmm0,-0x410(%rbp)\nmovsd  0x4b91(%rip),%xmm0\nmovsd  %xmm0,-0x3d0(%rbp)\nmovsd  0x4b89(%rip),%xmm0\nmovsd  %xmm0,-0x390(%rbp)\nmovsd  0x4b81(%rip),%xmm0\nmovsd  %xmm0,-0x350(%rbp)\nmovsd  0x4b79(%rip),%xmm0\nmovsd  %xmm0,-0x310(%rbp)\nlea    -0x210(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x40,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nlea    -0x210(%rbp),%rdx\nlea    -0x410(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1233 <idct_2d>\nlea    -0x210(%rbp),%rax\nlea    0x4ae1(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   13bd <print_matrix>\ncall   422e <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     155e <main+0xec>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "idct-alg/idct-alg.c", "function_name": "print_matrix", "content": "void print_matrix(double mat[N][N], const char* label) {\n    libmin_printf(\"%s:\\n\", label);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++)\n            libmin_printf(\"%8.2f \", mat[i][j]);\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "idct-alg/idct-alg.host.O0.pseudo", "function_name": "print_matrix", "address": "0x13bd", "label": "print_matrix", "content": "void __cdecl print_matrix(double (*mat)[8], const char *label)\n{\n  int i; // [rsp+18h] [rbp-8h]\n  int j; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"%s:\\n\", label);\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n      libmin_printf(\"%8.2f \", (*mat)[8 * (__int64)i + j]);\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void print_matrix(double (*mat)[8], const char *label) {\n  int i;\n  int j;\n  libmin_printf(\"%s:\\n\", label);\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j)\n      libmin_printf(\"%8.2f \", (*mat)[8 * (long long)i + j]);\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "idct-alg/idct-alg.host.O0", "assembly": "<print_matrix>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,%rsi\nlea    0x4c29(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369c <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    1455 <print_matrix+0x98>\nmovl   $0x0,-0x4(%rbp)\njmp    1437 <print_matrix+0x7a>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x6,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,8),%rax\nmovq   %rax,%xmm0\nlea    0x4be7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   369c <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x7,-0x4(%rbp)\njle    13fe <print_matrix+0x41>\nlea    0x4bd0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369c <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x7,-0x8(%rbp)\njle    13f5 <print_matrix+0x38>\nlea    0x4bb2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369c <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "indirect-test/indirect-test.c", "function_name": "bar", "content": "void\nbar(int (*pfoo)(int x))\n{\n  // call a function through a pointer\n  aglobal = (*pfoo)(aglobal);\n\n  // and implement a switch statement\n  switch (aglobal & 0x7)\n  {\n  case 0:\n    aglobal++;\n    break;\n\n  case 1:\n    aglobal--;\n    break;\n\n  case 2:\n    aglobal *= 2;\n    break;\n\n  case 3:\n    aglobal /= 2;\n    break;\n\n  case 4:\n    aglobal %= 2;\n    break;\n\n  default:\n    aglobal = -aglobal;\n    break;\n  }\n}\n"}, "pseudo": {"path": "indirect-test/indirect-test.host.O0.pseudo", "function_name": "bar", "address": "0x11fc", "label": "bar", "content": "void __cdecl bar(int (*pfoo)(int))\n{\n  aglobal = pfoo(aglobal);\n  switch ( aglobal & 7 )\n  {\n    case 0:\n      ++aglobal;\n      break;\n    case 1:\n      --aglobal;\n      break;\n    case 2:\n      aglobal *= 2;\n      break;\n    case 3:\n      aglobal /= 2;\n      break;\n    case 4:\n      aglobal %= 2;\n      break;\n    default:\n      aglobal = -aglobal;\n      break;\n  }\n}\n"}, "pseudo_normalize": "void bar(int (*pfoo)(int)) {\n  aglobal = pfoo(aglobal);\n  switch (aglobal & 7) {\n    case 0:\n      ++aglobal;\n      break;\n    case 1:\n      --aglobal;\n      break;\n    case 2:\n      aglobal *= 2;\n      break;\n    case 3:\n      aglobal /= 2;\n      break;\n    case 4:\n      aglobal %= 2;\n      break;\n    default:\n      aglobal = -aglobal;\n      break;\n  }\n}", "binary": "indirect-test/indirect-test.host.O0", "assembly": "<bar>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    0x4dfe(%rip),%eax\nmov    -0x8(%rbp),%rdx\nmov    %eax,%edi\ncall   *%rdx\nmov    %eax,0x4df0(%rip)\nmov    0x4dea(%rip),%eax\nand    $0x7,%eax\ncmp    $0x4,%eax\nja     12b7 <bar+0xbb>\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x2dc1(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x2db5(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    0x4db5(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x4dac(%rip)\njmp    12c6 <bar+0xca>\nmov    0x4da4(%rip),%eax\nsub    $0x1,%eax\nmov    %eax,0x4d9b(%rip)\njmp    12c6 <bar+0xca>\nmov    0x4d93(%rip),%eax\nadd    %eax,%eax\nmov    %eax,0x4d8b(%rip)\njmp    12c6 <bar+0xca>\nmov    0x4d83(%rip),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,0x4d74(%rip)\njmp    12c6 <bar+0xca>\nmov    0x4d6c(%rip),%eax\ncltd\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\nmov    %eax,0x4d5b(%rip)\njmp    12c6 <bar+0xca>\nmov    0x4d53(%rip),%eax\nneg    %eax\nmov    %eax,0x4d4b(%rip)\nnop\nnop\nleave\nret\n"}
{"source": {"path": "indirect-test/indirect-test.c", "function_name": "foo", "content": "int\nfoo(int x)\n{\n  return x*x;\n}\n"}, "pseudo": {"path": "indirect-test/indirect-test.host.O0.pseudo", "function_name": "foo", "address": "0x11e9", "label": "foo", "content": "int __cdecl foo(int x)\n{\n  return x * x;\n}\n"}, "pseudo_normalize": "", "binary": "indirect-test/indirect-test.host.O0", "assembly": "<foo>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nimul   %eax,%eax\npop    %rbp\nret\n"}
{"source": {"path": "indirect-test/indirect-test.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int (*pfoo)(int) = &foo;\n  (*pbar)(pfoo);\n  (*pbar)(pfoo);\n  (*pbar)(pfoo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "indirect-test/indirect-test.host.O0.pseudo", "function_name": "main", "address": "0x12c9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  pbar((int (*)(int))foo);\n  pbar((int (*)(int))foo);\n  pbar((int (*)(int))foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  pbar((int (*)(int))foo);\n  pbar((int (*)(int))foo);\n  pbar((int (*)(int))foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}", "binary": "indirect-test/indirect-test.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nlea    -0xf3(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    0x4d31(%rip),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   *%rdx\nmov    0x4d21(%rip),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   *%rdx\nmov    0x4d11(%rip),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   *%rdx\nmov    0x4cfa(%rip),%eax\nmov    %eax,%esi\nlea    0x2cf9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3474 <libmin_printf>\ncall   36e1 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "calculateCentroid", "content": "/*!\n * Calculate centoid and assign it to the cluster variable\n *\n * @param observations  an array of observations whose centroid is calculated\n * @param size  size of the observations array\n * @param centroid  a reference to cluster object to store information of\n * centroid\n */\nvoid calculateCentroid(observation observations[], size_t size,\n                       cluster* centroid)\n{\n    size_t i = 0;\n    centroid->x = 0;\n    centroid->y = 0;\n    centroid->count = size;\n    for (; i < size; i++)\n    {\n        centroid->x += observations[i].x;\n        centroid->y += observations[i].y;\n        observations[i].group = 0;\n    }\n    centroid->x /= centroid->count;\n    centroid->y /= centroid->count;\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O0.pseudo", "function_name": "calculateCentroid", "address": "0x1327", "label": "calculateCentroid", "content": "void __cdecl calculateCentroid(observation *observations, size_t size, cluster *centroid)\n{\n  signed __int64 count; // rax\n  double v4; // xmm0_8\n  size_t v5; // rdx\n  signed __int64 v6; // rax\n  double v7; // xmm0_8\n  size_t v8; // rdx\n  size_t i; // [rsp+20h] [rbp-8h]\n\n  i = 0LL;\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->count = size;\n  while ( i < size )\n  {\n    centroid->x = observations[i].x + centroid->x;\n    centroid->y = observations[i].y + centroid->y;\n    observations[i++].group = 0;\n  }\n  count = centroid->count;\n  if ( count < 0 )\n  {\n    v5 = centroid->count & 1 | ((unsigned __int64)count >> 1);\n    v4 = (double)(int)v5 + (double)(int)v5;\n  }\n  else\n  {\n    v4 = (double)(int)count;\n  }\n  centroid->x = centroid->x / v4;\n  v6 = centroid->count;\n  if ( v6 < 0 )\n  {\n    v8 = centroid->count & 1 | ((unsigned __int64)v6 >> 1);\n    v7 = (double)(int)v8 + (double)(int)v8;\n  }\n  else\n  {\n    v7 = (double)(int)v6;\n  }\n  centroid->y = centroid->y / v7;\n}\n"}, "pseudo_normalize": "void calculateCentroid(observation *observations, unsigned int size,\n                       cluster *centroid) {\n  signed long long count;\n  double v4;\n  unsigned int v5;\n  signed long long v6;\n  double v7;\n  unsigned int v8;\n  unsigned int i;\n  i = 0LL;\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->count = size;\n  while (i < size) {\n    centroid->x = observations[i].x + centroid->x;\n    centroid->y = observations[i].y + centroid->y;\n    observations[i++].group = 0;\n  }\n  count = centroid->count;\n  if (count < 0) {\n    v5 = centroid->count & 1 | ((unsigned long long)count >> 1);\n    v4 = (double)(int)v5 + (double)(int)v5;\n  } else {\n    v4 = (double)(int)count;\n  }\n  centroid->x = centroid->x / v4;\n  v6 = centroid->count;\n  if (v6 < 0) {\n    v8 = centroid->count & 1 | ((unsigned long long)v6 >> 1);\n    v7 = (double)(int)v8 + (double)(int)v8;\n  } else {\n    v7 = (double)(int)v6;\n  }\n  centroid->y = centroid->y / v7;\n}", "binary": "k-means/k-means.host.O0", "assembly": "<calculateCentroid>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x28(%rbp),%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,0x8(%rax)\nmov    -0x28(%rbp),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rdx,0x10(%rax)\njmp    13fd <calculateCentroid+0xd6>\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x8(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  %xmm0,(%rax)\nmov    -0x28(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x8(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  %xmm0,0x8(%rax)\nmov    -0x8(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x0,0x10(%rax)\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     136d <calculateCentroid+0x46>\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njs     142b <calculateCentroid+0x104>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1444 <calculateCentroid+0x11d>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\ndivsd  %xmm0,%xmm1\nmov    -0x28(%rbp),%rax\nmovsd  %xmm1,(%rax)\nmov    -0x28(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x28(%rbp),%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njs     1471 <calculateCentroid+0x14a>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    148a <calculateCentroid+0x163>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\ndivsd  %xmm0,%xmm1\nmov    -0x28(%rbp),%rax\nmovsd  %xmm1,0x8(%rax)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "calculateNearst", "content": "/*!\n * Returns the index of centroid nearest to\n * given observation\n *\n * @param o  observation\n * @param clusters  array of cluster having centroids coordinates\n * @param k  size of clusters array\n *\n * @returns the index of nearest centroid for given observation\n */\nint calculateNearst(observation* o, cluster clusters[], int k)\n{\n    double minD = DBL_MAX;\n    double dist = 0;\n    int index = -1;\n    int i = 0;\n    for (; i < k; i++)\n    {\n        /* Calculate Squared Distance*/\n        dist = (clusters[i].x - o->x) * (clusters[i].x - o->x) +\n               (clusters[i].y - o->y) * (clusters[i].y - o->y);\n        if (dist < minD)\n        {\n            minD = dist;\n            index = i;\n        }\n    }\n    return index;\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O0.pseudo", "function_name": "calculateNearst", "address": "0x11e9", "label": "calculateNearst", "content": "int __cdecl calculateNearst(observation *o, cluster *clusters, int k)\n{\n  int index; // [rsp+1Ch] [rbp-18h]\n  int i; // [rsp+20h] [rbp-14h]\n  double minD; // [rsp+24h] [rbp-10h]\n\n  minD = 1.797693134862316e308;\n  index = -1;\n  for ( i = 0; i < k; ++i )\n  {\n    if ( minD > (clusters[i].y - o->y) * (clusters[i].y - o->y) + (clusters[i].x - o->x) * (clusters[i].x - o->x) )\n    {\n      minD = (clusters[i].y - o->y) * (clusters[i].y - o->y) + (clusters[i].x - o->x) * (clusters[i].x - o->x);\n      index = i;\n    }\n  }\n  return index;\n}\n"}, "pseudo_normalize": "int calculateNearst(observation *o, cluster *clusters, int k) {\n  int index;\n  int i;\n  double minD;\n  minD = 1.797693134862316e308;\n  index = -1;\n  for (i = 0; i < k; ++i) {\n    if (minD > (clusters[i].y - o->y) * (clusters[i].y - o->y) +\n                   (clusters[i].x - o->x) * (clusters[i].x - o->x)) {\n      minD = (clusters[i].y - o->y) * (clusters[i].y - o->y) +\n             (clusters[i].x - o->x) * (clusters[i].x - o->x);\n      index = i;\n    }\n  }\n  return index;\n}", "binary": "k-means/k-means.host.O0", "assembly": "<calculateNearst>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %edx,-0x34(%rbp)\nmovsd  0x6f74(%rip),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0xffffffff,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    1316 <calculateNearst+0x12d>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm2\nmovapd %xmm0,%xmm1\nsubsd  %xmm2,%xmm1\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm2\nsubsd  %xmm2,%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  0x8(%rax),%xmm3\nmovapd %xmm0,%xmm2\nsubsd  %xmm3,%xmm2\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  0x8(%rax),%xmm3\nsubsd  %xmm3,%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x10(%rbp),%xmm0\ncomisd -0x8(%rbp),%xmm0\njbe    1312 <calculateNearst+0x129>\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x18(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njl     1225 <calculateNearst+0x3c>\nmov    -0x18(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "kMeans", "content": "/*!\n *    --K Means Algorithm--\n * 1. Assign each observation to one of k groups\n *    creating a random initial clustering\n * 2. Find the centroid of observations for each\n *    cluster to form new centroids\n * 3. Find the centroid which is nearest for each\n *    observation among the calculated centroids\n * 4. Assign the observation to its nearest centroid\n *    to create a new clustering.\n * 5. Repeat step 2,3,4 until there is no change\n *    the current clustering and is same as last\n *    clustering.\n *\n * @param observations  an array of observations to cluster\n * @param size  size of observations array\n * @param k  no of clusters to be made\n *\n * @returns pointer to cluster object\n */\ncluster* kMeans(observation observations[], size_t size, int k)\n{\n    cluster* clusters = NULL;\n    if (k <= 1)\n    {\n        /*\n        If we have to cluster them only in one group\n        then calculate centroid of observations and\n        that will be a ingle cluster\n        */\n        clusters = (cluster*)libmin_malloc(sizeof(cluster));\n        libmin_memset(clusters, 0, sizeof(cluster));\n        calculateCentroid(observations, size, clusters);\n    }\n    else if (k < size)\n    {\n        clusters = libmin_malloc(sizeof(cluster) * k);\n        libmin_memset(clusters, 0, k * sizeof(cluster));\n        /* STEP 1 */\n        for (size_t j = 0; j < size; j++)\n        {\n            observations[j].group = libmin_rand() % k;\n        }\n        size_t changed = 0;\n        size_t minAcceptedError =\n            size /\n            10000;  // Do until 99.99 percent points are in correct cluster\n        int t = 0;\n        do\n        {\n            /* Initialize clusters */\n            for (int i = 0; i < k; i++)\n            {\n                clusters[i].x = 0;\n                clusters[i].y = 0;\n                clusters[i].count = 0;\n            }\n            /* STEP 2*/\n            for (size_t j = 0; j < size; j++)\n            {\n                t = observations[j].group;\n                clusters[t].x += observations[j].x;\n                clusters[t].y += observations[j].y;\n                clusters[t].count++;\n            }\n            for (int i = 0; i < k; i++)\n            {\n                clusters[i].x /= clusters[i].count;\n                clusters[i].y /= clusters[i].count;\n            }\n            /* STEP 3 and 4 */\n            changed = 0;  // this variable stores change in clustering\n            for (size_t j = 0; j < size; j++)\n            {\n                t = calculateNearst(observations + j, clusters, k);\n                if (t != observations[j].group)\n                {\n                    changed++;\n                    observations[j].group = t;\n                }\n            }\n        } while (changed > minAcceptedError);  // Keep on grouping until we have\n                                               // got almost best clustering\n    }\n    else\n    {\n        /* If no of clusters is more than observations\n           each observation can be its own cluster\n        */\n        clusters = (cluster*)libmin_malloc(sizeof(cluster) * k);\n        libmin_memset(clusters, 0, k * sizeof(cluster));\n        for (int j = 0; j < size; j++)\n        {\n            clusters[j].x = observations[j].x;\n            clusters[j].y = observations[j].y;\n            clusters[j].count = 1;\n            observations[j].group = j;\n        }\n    }\n    return clusters;\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O0.pseudo", "function_name": "kMeans", "address": "0x149a", "label": "kMeans", "content": "cluster *__cdecl kMeans(observation *observations, size_t size, int k)\n{\n  __int64 count; // rax\n  double v4; // xmm0_8\n  __int64 v5; // rax\n  double v6; // xmm0_8\n  int i; // [rsp+20h] [rbp-40h]\n  int i_0; // [rsp+24h] [rbp-3Ch]\n  int j_2; // [rsp+28h] [rbp-38h]\n  int ta; // [rsp+2Ch] [rbp-34h]\n  int t; // [rsp+2Ch] [rbp-34h]\n  cluster *clusters; // [rsp+30h] [rbp-30h]\n  size_t j; // [rsp+38h] [rbp-28h]\n  size_t changed; // [rsp+40h] [rbp-20h]\n  size_t j_0; // [rsp+48h] [rbp-18h]\n  size_t j_1; // [rsp+50h] [rbp-10h]\n\n  if ( k > 1 )\n  {\n    if ( size <= k )\n    {\n      clusters = (cluster *)libmin_malloc(24LL * k);\n      libmin_memset(clusters, 0, 24LL * k);\n      for ( j_2 = 0; size > j_2; ++j_2 )\n      {\n        clusters[j_2].x = observations[j_2].x;\n        clusters[j_2].y = observations[j_2].y;\n        clusters[j_2].count = 1LL;\n        observations[j_2].group = j_2;\n      }\n    }\n    else\n    {\n      clusters = (cluster *)libmin_malloc(24LL * k);\n      libmin_memset(clusters, 0, 24LL * k);\n      for ( j = 0LL; j < size; ++j )\n        observations[j].group = libmin_rand() % k;\n      do\n      {\n        for ( i = 0; i < k; ++i )\n        {\n          clusters[i].x = 0.0;\n          clusters[i].y = 0.0;\n          clusters[i].count = 0LL;\n        }\n        for ( j_0 = 0LL; j_0 < size; ++j_0 )\n        {\n          ta = observations[j_0].group;\n          clusters[ta].x = observations[j_0].x + clusters[ta].x;\n          clusters[ta].y = observations[j_0].y + clusters[ta].y;\n          ++clusters[ta].count;\n        }\n        for ( i_0 = 0; i_0 < k; ++i_0 )\n        {\n          count = clusters[i_0].count;\n          if ( count < 0 )\n            v4 = (double)(int)(count & 1 | ((unsigned __int64)count >> 1))\n               + (double)(int)(count & 1 | ((unsigned __int64)count >> 1));\n          else\n            v4 = (double)(int)count;\n          clusters[i_0].x = clusters[i_0].x / v4;\n          v5 = clusters[i_0].count;\n          if ( v5 < 0 )\n            v6 = (double)(int)(v5 & 1 | ((unsigned __int64)v5 >> 1))\n               + (double)(int)(v5 & 1 | ((unsigned __int64)v5 >> 1));\n          else\n            v6 = (double)(int)v5;\n          clusters[i_0].y = clusters[i_0].y / v6;\n        }\n        changed = 0LL;\n        for ( j_1 = 0LL; j_1 < size; ++j_1 )\n        {\n          t = calculateNearst(&observations[j_1], clusters, k);\n          if ( t != observations[j_1].group )\n          {\n            ++changed;\n            observations[j_1].group = t;\n          }\n        }\n      }\n      while ( changed > size / 0x2710 );\n    }\n  }\n  else\n  {\n    clusters = (cluster *)libmin_malloc(0x18uLL);\n    libmin_memset(clusters, 0, 0x18uLL);\n    calculateCentroid(observations, size, clusters);\n  }\n  return clusters;\n}\n"}, "pseudo_normalize": "cluster *kMeans(observation *observations, unsigned int size, int k) {\n  long long count;\n  double v4;\n  long long v5;\n  double v6;\n  int i;\n  int i_0;\n  int j_2;\n  int ta;\n  int t;\n  cluster *clusters;\n  unsigned int j;\n  unsigned int changed;\n  unsigned int j_0;\n  unsigned int j_1;\n  if (k > 1) {\n    if (size <= k) {\n      clusters = (cluster *)libmin_malloc(24LL * k);\n      libmin_memset(clusters, 0, 24LL * k);\n      for (j_2 = 0; size > j_2; ++j_2) {\n        clusters[j_2].x = observations[j_2].x;\n        clusters[j_2].y = observations[j_2].y;\n        clusters[j_2].count = 1LL;\n        observations[j_2].group = j_2;\n      }\n    } else {\n      clusters = (cluster *)libmin_malloc(24LL * k);\n      libmin_memset(clusters, 0, 24LL * k);\n      for (j = 0LL; j < size; ++j) observations[j].group = libmin_rand() % k;\n      do {\n        for (i = 0; i < k; ++i) {\n          clusters[i].x = 0.0;\n          clusters[i].y = 0.0;\n          clusters[i].count = 0LL;\n        }\n        for (j_0 = 0LL; j_0 < size; ++j_0) {\n          ta = observations[j_0].group;\n          clusters[ta].x = observations[j_0].x + clusters[ta].x;\n          clusters[ta].y = observations[j_0].y + clusters[ta].y;\n          ++clusters[ta].count;\n        }\n        for (i_0 = 0; i_0 < k; ++i_0) {\n          count = clusters[i_0].count;\n          if (count < 0)\n            v4 = (double)(int)(count & 1 | ((unsigned long long)count >> 1)) +\n                 (double)(int)(count & 1 | ((unsigned long long)count >> 1));\n          else\n            v4 = (double)(int)count;\n          clusters[i_0].x = clusters[i_0].x / v4;\n          v5 = clusters[i_0].count;\n          if (v5 < 0)\n            v6 = (double)(int)(v5 & 1 | ((unsigned long long)v5 >> 1)) +\n                 (double)(int)(v5 & 1 | ((unsigned long long)v5 >> 1));\n          else\n            v6 = (double)(int)v5;\n          clusters[i_0].y = clusters[i_0].y / v6;\n        }\n        changed = 0LL;\n        for (j_1 = 0LL; j_1 < size; ++j_1) {\n          t = calculateNearst(&observations[j_1], clusters, k);\n          if (t != observations[j_1].group) {\n            ++changed;\n            observations[j_1].group = t;\n          }\n        }\n      } while (changed > size / 10000);\n    }\n  } else {\n    clusters = (cluster *)libmin_malloc(24uLL);\n    libmin_memset(clusters, 0, 24uLL);\n    calculateCentroid(observations, size, clusters);\n  }\n  return clusters;\n}", "binary": "k-means/k-means.host.O0", "assembly": "<kMeans>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %edx,-0x54(%rbp)\nmovq   $0x0,-0x30(%rbp)\ncmpl   $0x1,-0x54(%rbp)\njg     14ff <kMeans+0x65>\nmov    $0x18,%edi\ncall   2624 <libmin_malloc>\nmov    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\nmov    $0x18,%edx\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   2970 <libmin_memset>\nmov    -0x30(%rbp),%rdx\nmov    -0x50(%rbp),%rcx\nmov    -0x48(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1327 <calculateCentroid>\njmp    1aaa <kMeans+0x610>\nmov    -0x54(%rbp),%eax\ncltq\ncmp    %rax,-0x50(%rbp)\njbe    1975 <kMeans+0x4db>\nmov    -0x54(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   2624 <libmin_malloc>\nmov    %rax,-0x30(%rbp)\nmov    -0x54(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   2970 <libmin_memset>\nmovq   $0x0,-0x28(%rbp)\njmp    1594 <kMeans+0xfa>\ncall   4d67 <libmin_rand>\nmov    -0x54(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%ecx\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %edx,0x10(%rax)\naddq   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\ncmp    -0x50(%rbp),%rax\njb     155e <kMeans+0xc4>\nmovq   $0x0,-0x20(%rbp)\nmov    -0x50(%rbp),%rax\nmovabs $0x346dc5d63886594b,%rdx\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xb,%rax\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x34(%rbp)\nmovl   $0x0,-0x40(%rbp)\njmp    1646 <kMeans+0x1ac>\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,0x8(%rax)\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovq   $0x0,0x10(%rax)\naddl   $0x1,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0x54(%rbp),%eax\njl     15d2 <kMeans+0x138>\nmovq   $0x0,-0x18(%rbp)\njmp    1777 <kMeans+0x2dd>\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    0x10(%rax),%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,0x8(%rax)\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    0x10(%rax),%rdx\nadd    $0x1,%rdx\nmov    %rdx,0x10(%rax)\naddq   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    -0x50(%rbp),%rax\njb     165b <kMeans+0x1c1>\nmovl   $0x0,-0x3c(%rbp)\njmp    18b7 <kMeans+0x41d>\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njs     17e3 <kMeans+0x349>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    17fc <kMeans+0x362>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,(%rax)\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    0x10(%rax),%rax\ntest   %rax,%rax\njs     1874 <kMeans+0x3da>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    188d <kMeans+0x3f3>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,0x8(%rax)\naddl   $0x1,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncmp    -0x54(%rbp),%eax\njl     1791 <kMeans+0x2f7>\nmovq   $0x0,-0x20(%rbp)\nmovq   $0x0,-0x10(%rbp)\njmp    1954 <kMeans+0x4ba>\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x54(%rbp),%edx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   11e9 <calculateNearst>\nmov    %eax,-0x34(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    0x10(%rax),%eax\ncmp    %eax,-0x34(%rbp)\nje     194f <kMeans+0x4b5>\naddq   $0x1,-0x20(%rbp)\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x34(%rbp),%eax\nmov    %eax,0x10(%rdx)\naddq   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\ncmp    -0x50(%rbp),%rax\njb     18d5 <kMeans+0x43b>\nmov    -0x20(%rbp),%rax\ncmp    -0x8(%rbp),%rax\nja     15c9 <kMeans+0x12f>\njmp    1aaa <kMeans+0x610>\nmov    -0x54(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   2624 <libmin_malloc>\nmov    %rax,-0x30(%rbp)\nmov    -0x54(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   2970 <libmin_memset>\nmovl   $0x0,-0x38(%rbp)\njmp    1a9b <kMeans+0x601>\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rcx),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rcx),%xmm0\nmovsd  %xmm0,0x8(%rax)\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovq   $0x1,0x10(%rax)\nmov    -0x38(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x38(%rbp),%eax\nmov    %eax,0x10(%rdx)\naddl   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncltq\ncmp    %rax,-0x50(%rbp)\nja     19c7 <kMeans+0x52d>\nmov    -0x30(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "main", "content": "/*!\n * This function calls the test\n * function\n */\nint main()\n{\n    libmin_srand(42);\n    test();\n    /* test2(); */\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O0.pseudo", "function_name": "main", "address": "0x2469", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  test();\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "k-means/k-means.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x2a,%edi\ncall   4cb5 <libmin_srand>\nmov    $0x0,%eax\ncall   20bb <test>\ncall   55cc <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "printEPS", "content": "/**\n * @}\n * @}\n */\n\n/*!\n * A function to print observations and clusters\n * The code is taken from\n * http://rosettacode.org/wiki/K-means%2B%2B_clustering.\n * Even the K Means code is also inspired from it\n *\n * @note To print in a file use pipeline operator\n * ```sh\n * ./k_means_clustering > image.eps\n * ```\n *\n * @param observations  observations array\n * @param len  size of observation array\n * @param cent  clusters centroid's array\n * @param k  size of cent array\n */\nvoid printEPS(observation pts[], size_t len, cluster cent[], int k)\n{\n    int W = 400, H = 400;\n    double min_x = DBL_MAX, max_x = DBL_MIN, min_y = DBL_MAX, max_y = DBL_MIN;\n    double scale = 0, cx = 0, cy = 0;\n    double* colors = (double*)libmin_malloc(sizeof(double) * (k * 3));\n    int i;\n    size_t j;\n    double kd = k * 1.0;\n    for (i = 0; i < k; i++)\n    {\n        *(colors + 3 * i) = (3 * (i + 1) % k) / kd;\n        *(colors + 3 * i + 1) = (7 * i % k) / kd;\n        *(colors + 3 * i + 2) = (9 * i % k) / kd;\n    }\n\n    for (j = 0; j < len; j++)\n    {\n        if (max_x < pts[j].x)\n        {\n            max_x = pts[j].x;\n        }\n        if (min_x > pts[j].x)\n        {\n            min_x = pts[j].x;\n        }\n        if (max_y < pts[j].y)\n        {\n            max_y = pts[j].y;\n        }\n        if (min_y > pts[j].y)\n        {\n            min_y = pts[j].y;\n        }\n    }\n    scale = W / (max_x - min_x);\n    if (scale > (H / (max_y - min_y)))\n    {\n        scale = H / (max_y - min_y);\n    };\n    cx = (max_x + min_x) / 2;\n    cy = (max_y + min_y) / 2;\n\n    libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", W + 10,\n           H + 10);\n    libmin_printf(\n        \"/l {rlineto} def /m {rmoveto} def\\n\"\n        \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n        \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \"\n        \"\tgsave 1 setgray fill grestore gsave 3 setlinewidth\"\n        \" 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n    for (int i = 0; i < k; i++)\n    {\n        libmin_printf(\"%f %f %f setrgbcolor\\n\", *(colors + 3 * i),\n               *(colors + 3 * i + 1), *(colors + 3 * i + 2));\n        for (j = 0; j < len; j++)\n        {\n            if (pts[j].group != i)\n            {\n                continue;\n            }\n            libmin_printf(\"%.3f %.3f c\\n\", (pts[j].x - cx) * scale + W / 2,\n                   (pts[j].y - cy) * scale + H / 2);\n        }\n        libmin_printf(\"\\n0 setgray %f %f s\\n\", (cent[i].x - cx) * scale + W / 2,\n               (cent[i].y - cy) * scale + H / 2);\n    }\n    libmin_printf(\"\\n%%%%EOF\\n\");\n\n    // free accquired memory\n    libmin_free(colors);\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O0.pseudo", "function_name": "printEPS", "address": "0x1ab0", "label": "printEPS", "content": "void __cdecl printEPS(observation *pts, size_t len, cluster *cent, int k)\n{\n  int i; // [rsp+20h] [rbp-60h]\n  int i_0; // [rsp+24h] [rbp-5Ch]\n  double min_x; // [rsp+30h] [rbp-50h]\n  double max_x; // [rsp+38h] [rbp-48h]\n  double min_y; // [rsp+40h] [rbp-40h]\n  double max_y; // [rsp+48h] [rbp-38h]\n  double scale; // [rsp+50h] [rbp-30h]\n  size_t j; // [rsp+58h] [rbp-28h]\n  size_t ja; // [rsp+58h] [rbp-28h]\n  double cx_0; // [rsp+60h] [rbp-20h]\n  double cy; // [rsp+68h] [rbp-18h]\n  double *colors; // [rsp+70h] [rbp-10h]\n  double kd; // [rsp+78h] [rbp-8h]\n\n  min_x = 1.797693134862316e308;\n  max_x = 2.225073858507201e-308;\n  min_y = 1.797693134862316e308;\n  max_y = 2.225073858507201e-308;\n  colors = (double *)libmin_malloc(24LL * k);\n  kd = (double)k;\n  for ( i = 0; i < k; ++i )\n  {\n    colors[3 * i] = (double)(3 * (i + 1) % k) / kd;\n    colors[3 * i + 1] = (double)(7 * i % k) / kd;\n    colors[3 * i + 2] = (double)(9 * i % k) / kd;\n  }\n  for ( j = 0LL; j < len; ++j )\n  {\n    if ( pts[j].x > max_x )\n      max_x = pts[j].x;\n    if ( min_x > pts[j].x )\n      min_x = pts[j].x;\n    if ( pts[j].y > max_y )\n      max_y = pts[j].y;\n    if ( min_y > pts[j].y )\n      min_y = pts[j].y;\n  }\n  scale = (double)400 / (max_x - min_x);\n  if ( scale > (double)400 / (max_y - min_y) )\n    scale = (double)400 / (max_y - min_y);\n  cx_0 = (max_x + min_x) / 2.0;\n  cy = (max_y + min_y) / 2.0;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410, 410);\n  libmin_printf(\"/l {rlineto} def /m {rmoveto} def\\n\"\n                \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n                \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray fill grestore gsave 3 setlinewidth 1\"\n                \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  for ( i_0 = 0; i_0 < k; ++i_0 )\n  {\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", colors[3 * i_0], colors[3 * i_0 + 1], colors[3 * i_0 + 2]);\n    for ( ja = 0LL; ja < len; ++ja )\n    {\n      if ( i_0 == pts[ja].group )\n        libmin_printf(\"%.3f %.3f c\\n\", (pts[ja].x - cx_0) * scale + (double)200, (pts[ja].y - cy) * scale + (double)200);\n    }\n    libmin_printf(\n      \"\\n0 setgray %f %f s\\n\",\n      (cent[i_0].x - cx_0) * scale + (double)200,\n      (cent[i_0].y - cy) * scale + (double)200);\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(colors);\n}\n"}, "pseudo_normalize": "void printEPS(observation *pts, unsigned int len, cluster *cent, int k) {\n  int i;\n  int i_0;\n  double min_x;\n  double max_x;\n  double min_y;\n  double max_y;\n  double scale;\n  unsigned int j;\n  unsigned int ja;\n  double cx_0;\n  double cy;\n  double *colors;\n  double kd;\n  min_x = 1.797693134862316e308;\n  max_x = 2.225073858507201e-308;\n  min_y = 1.797693134862316e308;\n  max_y = 2.225073858507201e-308;\n  colors = (double *)libmin_malloc(24LL * k);\n  kd = (double)k;\n  for (i = 0; i < k; ++i) {\n    colors[3 * i] = (double)(3 * (i + 1) % k) / kd;\n    colors[3 * i + 1] = (double)(7 * i % k) / kd;\n    colors[3 * i + 2] = (double)(9 * i % k) / kd;\n  }\n  for (j = 0LL; j < len; ++j) {\n    if (pts[j].x > max_x) max_x = pts[j].x;\n    if (min_x > pts[j].x) min_x = pts[j].x;\n    if (pts[j].y > max_y) max_y = pts[j].y;\n    if (min_y > pts[j].y) min_y = pts[j].y;\n  }\n  scale = (double)400 / (max_x - min_x);\n  if (scale > (double)400 / (max_y - min_y))\n    scale = (double)400 / (max_y - min_y);\n  cx_0 = (max_x + min_x) / 2.0;\n  cy = (max_y + min_y) / 2.0;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410,\n                410);\n  libmin_printf(\n      \"/l {rlineto} def /m {rmoveto} def\\n\"\n      \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n      \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n      \"fill grestore gsave 3 setlinewidth 1\"\n      \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  for (i_0 = 0; i_0 < k; ++i_0) {\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", colors[3 * i_0],\n                  colors[3 * i_0 + 1], colors[3 * i_0 + 2]);\n    for (ja = 0LL; ja < len; ++ja) {\n      if (i_0 == pts[ja].group)\n        libmin_printf(\"%.3f %.3f c\\n\", (pts[ja].x - cx_0) * scale + (double)200,\n                      (pts[ja].y - cy) * scale + (double)200);\n    }\n    libmin_printf(\"\\n0 setgray %f %f s\\n\",\n                  (cent[i_0].x - cx_0) * scale + (double)200,\n                  (cent[i_0].y - cy) * scale + (double)200);\n  }\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(colors);\n}", "binary": "k-means/k-means.host.O0", "assembly": "<printEPS>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x68(%rbp)\nmov    %rsi,-0x70(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    %ecx,-0x7c(%rbp)\nmovl   $0x190,-0x58(%rbp)\nmovl   $0x190,-0x54(%rbp)\nmovsd  0x6697(%rip),%xmm0\nmovsd  %xmm0,-0x50(%rbp)\nmovsd  0x6692(%rip),%xmm0\nmovsd  %xmm0,-0x48(%rbp)\nmovsd  0x667d(%rip),%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovsd  0x6678(%rip),%xmm0\nmovsd  %xmm0,-0x38(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x7c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   2624 <libmin_malloc>\nmov    %rax,-0x10(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x7c(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x60(%rbp)\njmp    1c1c <printEPS+0x16c>\nmov    -0x60(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltd\nidivl  -0x7c(%rbp)\nmov    %edx,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x60(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\ndivsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x60(%rbp),%edx\nmov    %edx,%eax\nshl    $0x3,%eax\nsub    %edx,%eax\ncltd\nidivl  -0x7c(%rbp)\nmov    %edx,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x60(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\ndivsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x60(%rbp),%edx\nmov    %edx,%eax\nshl    $0x3,%eax\nadd    %edx,%eax\ncltd\nidivl  -0x7c(%rbp)\nmov    %edx,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x60(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nadd    $0x2,%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\ndivsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x60(%rbp)\nmov    -0x60(%rbp),%eax\ncmp    -0x7c(%rbp),%eax\njl     1b5d <printEPS+0xad>\nmovq   $0x0,-0x28(%rbp)\njmp    1d6e <printEPS+0x2be>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\ncomisd -0x48(%rbp),%xmm0\njbe    1c7f <printEPS+0x1cf>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x48(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmovsd  -0x50(%rbp),%xmm0\ncomisd %xmm1,%xmm0\njbe    1ccd <printEPS+0x21d>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x50(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\ncomisd -0x38(%rbp),%xmm0\njbe    1d19 <printEPS+0x269>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm1\nmovsd  -0x40(%rbp),%xmm0\ncomisd %xmm1,%xmm0\njbe    1d69 <printEPS+0x2b9>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nmovsd  %xmm0,-0x40(%rbp)\naddq   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\ncmp    -0x70(%rbp),%rax\njb     1c35 <printEPS+0x185>\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x58(%rbp),%xmm0\nmovsd  -0x48(%rbp),%xmm1\nsubsd  -0x50(%rbp),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x54(%rbp),%xmm0\nmovsd  -0x38(%rbp),%xmm1\nmovapd %xmm1,%xmm2\nsubsd  -0x40(%rbp),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  -0x30(%rbp),%xmm0\ncomisd %xmm1,%xmm0\njbe    1dde <printEPS+0x32e>\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x54(%rbp),%xmm0\nmovsd  -0x38(%rbp),%xmm1\nsubsd  -0x40(%rbp),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  -0x48(%rbp),%xmm0\naddsd  -0x50(%rbp),%xmm0\nmovsd  0x6398(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovsd  -0x38(%rbp),%xmm0\naddsd  -0x40(%rbp),%xmm0\nmovsd  0x637d(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x54(%rbp),%eax\nlea    0xa(%rax),%edx\nmov    -0x58(%rbp),%eax\nadd    $0xa,%eax\nmov    %eax,%esi\nlea    0x61df(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4a86 <libmin_printf>\nlea    0x6203(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4a86 <libmin_printf>\nmovl   $0x0,-0x5c(%rbp)\njmp    208c <printEPS+0x5dc>\nmov    -0x5c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nadd    $0x2,%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm1\nmov    -0x5c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x5c(%rbp),%edx\nmov    %edx,%eax\nadd    %eax,%eax\nadd    %edx,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x6265(%rip),%rax\nmov    %rax,%rdi\nmov    $0x3,%eax\ncall   4a86 <libmin_printf>\nmovq   $0x0,-0x28(%rbp)\njmp    1fc5 <printEPS+0x515>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmov    0x10(%rax),%eax\ncmp    %eax,-0x5c(%rbp)\njne    1fbf <printEPS+0x50f>\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nsubsd  -0x18(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x30(%rbp),%xmm1\nmov    -0x54(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmovapd %xmm1,%xmm2\naddsd  %xmm0,%xmm2\nmov    -0x28(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x68(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nsubsd  -0x20(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x30(%rbp),%xmm1\nmov    -0x58(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\naddsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovapd %xmm2,%xmm1\nmovq   %rax,%xmm0\nlea    0x6196(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   4a86 <libmin_printf>\njmp    1fc0 <printEPS+0x510>\nnop\naddq   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\ncmp    -0x70(%rbp),%rax\njb     1ee5 <printEPS+0x435>\nmov    -0x5c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x8(%rax),%xmm0\nsubsd  -0x18(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x30(%rbp),%xmm1\nmov    -0x54(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmovapd %xmm1,%xmm2\naddsd  %xmm0,%xmm2\nmov    -0x5c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x78(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nsubsd  -0x20(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x30(%rbp),%xmm1\nmov    -0x58(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\naddsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovapd %xmm2,%xmm1\nmovq   %rax,%xmm0\nlea    0x60d8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   4a86 <libmin_printf>\naddl   $0x1,-0x5c(%rbp)\nmov    -0x5c(%rbp),%eax\ncmp    -0x7c(%rbp),%eax\njl     1e56 <printEPS+0x3a6>\nlea    0x60c8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4a86 <libmin_printf>\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   270f <libmin_free>\nnop\nleave\nret\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "test", "content": "/*!\n * A function to test the kMeans function\n * Generates 100000 points in a circle of\n * radius 20.0 with center at (0,0)\n * and cluster them into 5 clusters\n *\n * <img alt=\"Output for 100000 points divided in 5 clusters\" src=\n * \"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest1.png\"\n * width=\"400px\" heiggt=\"400px\">\n * @returns None\n */\nstatic void test()\n{\n    size_t size = 200L;\n    observation* observations =\n        (observation*)libmin_malloc(sizeof(observation) * size);\n    double maxRadius = 20.00;\n    double radius = 0;\n    double ang = 0;\n    size_t i = 0;\n    for (; i < size; i++)\n    {\n        radius = maxRadius * ((double)libmin_rand() / RAND_MAX);\n        ang = 2 * M_PI * ((double)libmin_rand() / RAND_MAX);\n        observations[i].x = radius * libmin_cos(ang);\n        observations[i].y = radius * libmin_sin(ang);\n    }\n    int k = 5;  // No of clusters\n    cluster* clusters = kMeans(observations, size, k);\n    printEPS(observations, size, clusters, k);\n    // Free the accquired memory\n    libmin_free(observations);\n    libmin_free(clusters);\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O0.pseudo", "function_name": "test", "address": "0x20bb", "label": "test", "content": "void __cdecl test()\n{\n  size_t i; // [rsp+8h] [rbp-38h]\n  observation *observations; // [rsp+18h] [rbp-28h]\n  double radius; // [rsp+28h] [rbp-18h]\n  double ang; // [rsp+30h] [rbp-10h]\n  cluster *clusters; // [rsp+38h] [rbp-8h]\n\n  observations = (observation *)libmin_malloc(0x12C0uLL);\n  for ( i = 0LL; i < 0xC8; ++i )\n  {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = 6.283185307179586 * ((double)(int)libmin_rand() / 2147483647.0);\n    observations[i].x = libmin_cos(ang) * radius;\n    observations[i].y = libmin_sin(ang) * radius;\n  }\n  clusters = kMeans(observations, 0xC8uLL, 5);\n  printEPS(observations, 0xC8uLL, clusters, 5);\n  libmin_free(observations);\n  libmin_free(clusters);\n}\n"}, "pseudo_normalize": "void test() {\n  unsigned int i;\n  observation *observations;\n  double radius;\n  double ang;\n  cluster *clusters;\n  observations = (observation *)libmin_malloc(4800uLL);\n  for (i = 0LL; i < 200; ++i) {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = 6.283185307179586 * ((double)(int)libmin_rand() / 2147483647.0);\n    observations[i].x = libmin_cos(ang) * radius;\n    observations[i].y = libmin_sin(ang) * radius;\n  }\n  clusters = kMeans(observations, 200uLL, 5);\n  printEPS(observations, 200uLL, clusters, 5);\n  libmin_free(observations);\n  libmin_free(clusters);\n}", "binary": "k-means/k-means.host.O0", "assembly": "<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmovq   $0xc8,-0x30(%rbp)\nmov    -0x30(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   2624 <libmin_malloc>\nmov    %rax,-0x28(%rbp)\nmovsd  0x609c(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovq   $0x0,-0x38(%rbp)\njmp    2231 <test+0x176>\ncall   4d67 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     212f <test+0x74>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    2148 <test+0x8d>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x6048(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  -0x20(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\ncall   4d67 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     2179 <test+0xbe>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    2192 <test+0xd7>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x5ffe(%rip),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x5ff6(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovq   %rax,%xmm0\ncall   522d <libmin_cos>\nmovq   %xmm0,%rdx\nmov    -0x38(%rbp),%rcx\nmov    %rcx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nshl    $0x3,%rax\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovq   %rdx,%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x10(%rbp),%rax\nmovq   %rax,%xmm0\ncall   53de <libmin_sin>\nmovq   %xmm0,%rdx\nmov    -0x38(%rbp),%rcx\nmov    %rcx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nshl    $0x3,%rax\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovq   %rdx,%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,0x8(%rax)\naddq   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     2118 <test+0x5d>\nmovl   $0x5,-0x3c(%rbp)\nmov    -0x3c(%rbp),%edx\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   149a <kMeans>\nmov    %rax,-0x8(%rbp)\nmov    -0x3c(%rbp),%ecx\nmov    -0x8(%rbp),%rdx\nmov    -0x30(%rbp),%rsi\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1ab0 <printEPS>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   270f <libmin_free>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   270f <libmin_free>\nnop\nleave\nret\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "test2", "content": "/*!\n * A function to test the kMeans function\n * Generates 1000000 points in a circle of\n * radius 20.0 with center at (0,0)\n * and cluster them into 11 clusters\n *\n * <img alt=\"Output for 1000000 points divided in 11 clusters\" src=\n * \"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest2.png\"\n * width=\"400px\" heiggt=\"400px\">\n * @returns None\n */\nvoid test2()\n{\n    size_t size = 1000000L;\n    observation* observations =\n        (observation*)libmin_malloc(sizeof(observation) * size);\n    double maxRadius = 20.00;\n    double radius = 0;\n    double ang = 0;\n    size_t i = 0;\n    for (; i < size; i++)\n    {\n        radius = maxRadius * ((double)libmin_rand() / RAND_MAX);\n        ang = 2 * M_PI * ((double)libmin_rand() / RAND_MAX);\n        observations[i].x = radius * libmin_cos(ang);\n        observations[i].y = radius * libmin_sin(ang);\n    }\n    int k = 11;  // No of clusters\n    cluster* clusters = kMeans(observations, size, k);\n    printEPS(observations, size, clusters, k);\n    // Free the accquired memory\n    libmin_free(observations);\n    libmin_free(clusters);\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O0.pseudo", "function_name": "test2", "address": "0x2292", "label": "test2", "content": "void __cdecl test2()\n{\n  size_t i; // [rsp+8h] [rbp-38h]\n  observation *observations; // [rsp+18h] [rbp-28h]\n  double radius; // [rsp+28h] [rbp-18h]\n  double ang; // [rsp+30h] [rbp-10h]\n  cluster *clusters; // [rsp+38h] [rbp-8h]\n\n  observations = (observation *)libmin_malloc(0x16E3600uLL);\n  for ( i = 0LL; i < 0xF4240; ++i )\n  {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = 6.283185307179586 * ((double)(int)libmin_rand() / 2147483647.0);\n    observations[i].x = libmin_cos(ang) * radius;\n    observations[i].y = libmin_sin(ang) * radius;\n  }\n  clusters = kMeans(observations, 0xF4240uLL, 11);\n  printEPS(observations, 0xF4240uLL, clusters, 11);\n  libmin_free(observations);\n  libmin_free(clusters);\n}\n"}, "pseudo_normalize": "void test2() {\n  unsigned int i;\n  observation *observations;\n  double radius;\n  double ang;\n  cluster *clusters;\n  observations = (observation *)libmin_malloc(24000000uLL);\n  for (i = 0LL; i < 1000000; ++i) {\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = 6.283185307179586 * ((double)(int)libmin_rand() / 2147483647.0);\n    observations[i].x = libmin_cos(ang) * radius;\n    observations[i].y = libmin_sin(ang) * radius;\n  }\n  clusters = kMeans(observations, 1000000uLL, 11);\n  printEPS(observations, 1000000uLL, clusters, 11);\n  libmin_free(observations);\n  libmin_free(clusters);\n}", "binary": "k-means/k-means.host.O0", "assembly": "<test2>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmovq   $0xf4240,-0x30(%rbp)\nmov    -0x30(%rbp),%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   2624 <libmin_malloc>\nmov    %rax,-0x28(%rbp)\nmovsd  0x5ec5(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovq   $0x0,-0x38(%rbp)\njmp    2408 <test2+0x176>\ncall   4d67 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     2306 <test2+0x74>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    231f <test2+0x8d>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x5e71(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  -0x20(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\ncall   4d67 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     2350 <test2+0xbe>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    2369 <test2+0xd7>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x5e27(%rip),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x5e1f(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovq   %rax,%xmm0\ncall   522d <libmin_cos>\nmovq   %xmm0,%rdx\nmov    -0x38(%rbp),%rcx\nmov    %rcx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nshl    $0x3,%rax\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovq   %rdx,%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x10(%rbp),%rax\nmovq   %rax,%xmm0\ncall   53de <libmin_sin>\nmovq   %xmm0,%rdx\nmov    -0x38(%rbp),%rcx\nmov    %rcx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nshl    $0x3,%rax\nmov    %rax,%rcx\nmov    -0x28(%rbp),%rax\nadd    %rcx,%rax\nmovq   %rdx,%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,0x8(%rax)\naddq   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     22ef <test2+0x5d>\nmovl   $0xb,-0x3c(%rbp)\nmov    -0x3c(%rbp),%edx\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   149a <kMeans>\nmov    %rax,-0x8(%rbp)\nmov    -0x3c(%rbp),%ecx\nmov    -0x8(%rbp),%rdx\nmov    -0x30(%rbp),%rsi\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1ab0 <printEPS>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   270f <libmin_free>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   270f <libmin_free>\nnop\nleave\nret\n"}
{"source": {"path": "kadane/kadane.c", "function_name": "kadane", "content": "#include \"libmin.h\"\n \n// Function to find the maximum sum of a contiguous subarray\n// in a given integer array\nint\nkadane(int arr[], int n, int *ends_at)\n{\n  // stores the maximum sum subarray found so far\n  int max_so_far = 0;\n  *ends_at = -1;\n \n  // stores the maximum sum of subarray ending at the current position\n  int max_ending_here = 0;\n \n  // traverse the given array\n  for (int i = 0; i < n; i++)\n  {\n    // update the maximum sum of subarray \"ending\" at index `i` (by adding the\n    // current element to maximum sum ending at previous index `i-1`)\n    max_ending_here = max_ending_here + arr[i];\n \n    // if the maximum sum is negative, set it to 0 (which represents\n    // an empty subarray)\n    max_ending_here = MAX(max_ending_here, 0);\n\n    // update the result if the current subarray sum is found to be greater\n    if (max_so_far < max_ending_here)\n      *ends_at = i;\n    max_so_far = MAX(max_so_far, max_ending_here);\n  }\n  return max_so_far;\n}\n"}, "pseudo": {"path": "kadane/kadane.host.O0.pseudo", "function_name": "kadane", "address": "0x11e9", "label": "kadane", "content": "int __cdecl kadane(int *arr, int n, int *ends_at)\n{\n  int v3; // eax\n  int max_so_far; // [rsp+1Ch] [rbp-Ch]\n  int max_ending_here; // [rsp+20h] [rbp-8h]\n  int i; // [rsp+24h] [rbp-4h]\n\n  max_so_far = 0;\n  *ends_at = -1;\n  max_ending_here = 0;\n  for ( i = 0; i < n; ++i )\n  {\n    v3 = arr[i] + max_ending_here;\n    if ( v3 < 0 )\n      v3 = 0;\n    max_ending_here = v3;\n    if ( max_so_far >= v3 )\n      v3 = max_so_far;\n    else\n      *ends_at = i;\n    max_so_far = v3;\n  }\n  return max_so_far;\n}\n"}, "pseudo_normalize": "int kadane(int *arr, int n, int *ends_at) {\n  int v3;\n  int max_so_far;\n  int max_ending_here;\n  int i;\n  max_so_far = 0;\n  *ends_at = -1;\n  max_ending_here = 0;\n  for (i = 0; i < n; ++i) {\n    v3 = arr[i] + max_ending_here;\n    if (v3 < 0) v3 = 0;\n    max_ending_here = v3;\n    if (max_so_far >= v3)\n      v3 = max_so_far;\n    else\n      *ends_at = i;\n    max_so_far = v3;\n  }\n  return max_so_far;\n}", "binary": "kadane/kadane.host.O0", "assembly": "<kadane>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmov    -0x28(%rbp),%rax\nmovl   $0xffffffff,(%rax)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1269 <kadane+0x80>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\nmov    $0x0,%edx\ntest   %eax,%eax\ncmovs  %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    1257 <kadane+0x6e>\nmov    -0x28(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0xc(%rbp),%edx\nmov    -0x8(%rbp),%eax\ncmp    %eax,%edx\ncmovge %edx,%eax\nmov    %eax,-0xc(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     121d <kadane+0x34>\nmov    -0xc(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "kadane/kadane.c", "function_name": "main", "content": " \nint\nmain(void)\n{\n  int arr[] = {\n    8155, 17168, 11554, -14406, 13854, 20973, -26471, -11245, 25508, -24548, -2094, -16932, -23080,\n    29777, -27647, -5927, 20197, -16505, -28944, 2518, 22405, 15304, -19199, 5439, 4971, 24179, 1119,\n    16764, -24526, -973, -9585, 15066, 12069, -21990, -19708, -16603, 24065, 15869, -6208, 22922,\n    2901, 24070, -16253, 15350, -27951, -817, -10363, -4185, -17835, -21493, -25281, -4842, -1425,\n    6710, -7297, -17119, -10408, 18129, -28213, -12161, 13068, -4347, 27196, -9652, -19423, 6057,\n    -22147, -10601, -17130, -13839, 4925, 27786, -9734, -25871, -2776, 16462, 13778, 11363, -6662,\n    -24896, 19904, 29515, 9625, 18193, -17274, -3246, 27168, 508, -81, 15064, 19885, 18619, -5470,\n    23422, -10780, -21517, 26606, -20833, -27943, -11223, -10137, -29356, 2701, -10774, 13286, -15863,\n    24259, -3434, -16362, -4444, -20182, 7785, 23559, -16482, -23146, 7477, 25038, -19306, -26506,\n    29314, 2174, 7862, -29266, -1236, -28187, 27877, -7969, 10314, -5142, 5466, 28920, 29191, -27061,\n    27601, 7428, 12574, -5776, 27915, -13399, -11340, 3307, 7043, -6927, 16463, -6535, 26316, -10710,\n    16103, -5578, 26102, -22493, 23027, 12203, 3251, 5281, -17123, -9919, 18986, -9330, -192, 16263,\n    -19289, -22665, -2993, 27926, -3020, -10050, -4092, 17416, 26503, -16237, -25905, -19723, -5055,\n    2901, 24070, -16253, 15350, -27951, -817, -10363, -4185, -17835, -21493, -25281, -4842, -1425,\n    27601, 7428, 12574, -5776, 27915, -13399, -11340, 3307, 7043, -6927, 16463, -6535, 26316, -10710,\n    29777, -27647, -5927, 20197, -16505, -28944, 2518, 22405, 15304, -19199, 5439, 4971, 24179, 1119,\n    8155, 17168, 11554, -14406, 13854, 20973, -26471, -11245, 25508, -24548, -2094, -16932, -23080,\n    -25496, -27164, -9845, 25985, 21965, 26979, -28295, -4574, -27464, -26163, 11498, -6302,\n    29123, -4712, -24339, -27645, 23484, 12151, 14797, -5334, -15853, 9431, 7116, 27195, -1075,\n    17134, 21955, -3745, -4717, 11285, -9264, -20400, 15249, -18604, 390, 25377, -7495,\n    -24694, 25767, 17461, -21795, 1815, -5557, 22489, 11085, -6132, -2513, 131, 18955,\n    -28518, -14482, 15781, 21178, 5485, -12187, -24004, 12344, 20129, -26045, -28136, -26435, 23729,\n    -12384, 3157, 3121, -18724, -17193, 22853, -29225, 29921, -19534, -28048, -9185, -29704, -29260, -2534,\n    21587, 4770, 4880, -9269, 9197, 25075, -3083, -4795, -28614, -8794, 20376, -12507, -14627, 8109,\n    28004, -29128, -10195, 16767, -6852, -21305, 28599, -23297, -16460, 18601, 5359, -7017, -24250, -23556,\n    16491, -23856, -16880, 19593, 6171, 12602, -29905, -27567, 18969, -12582, 18015, 7774, 23534, -26819,\n    -8535, 13345, 9279, -20758, -1612, 13739, -29764, 6005, 2037, 14339, -23422, -11, -16605, -11701\n  };\n  int n = sizeof(arr)/sizeof(arr[0]);\n  int max_sum, ends_at;\n \n  libmin_printf(\"Array size= %d\\n\", n);\n\n  max_sum = kadane(arr, n, &ends_at);\n\n  libmin_printf(\"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\", max_sum, ends_at);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "kadane/kadane.host.O0.pseudo", "function_name": "main", "address": "0x1276", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int ends_at; // [rsp+4h] [rbp-5BCh] BYREF\n  int n; // [rsp+8h] [rbp-5B8h]\n  int max_sum; // [rsp+Ch] [rbp-5B4h]\n  int arr[362]; // [rsp+10h] [rbp-5B0h] BYREF\n  unsigned __int64 v7; // [rsp+5B8h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  qmemcpy(arr, &unk_4080, 0x5A0uLL);\n  n = 360;\n  libmin_printf(\"Array size= %d\\n\", 360);\n  max_sum = kadane(arr, 360, &ends_at);\n  libmin_printf(\"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\", max_sum, ends_at);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int ends_at;\n  int n;\n  int max_sum;\n  int arr[362];\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  qmemcpy(arr, &unk_4080, 1440uLL);\n  n = 360;\n  libmin_printf(\"Array size= %d\\n\", 360);\n  max_sum = kadane(arr, 360, &ends_at);\n  libmin_printf(\n      \"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\",\n      max_sum, ends_at);\n  libmin_success();\n}", "binary": "kadane/kadane.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x5c0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x5b0(%rbp),%rax\nlea    0x2dde(%rip),%rdx\nmov    $0xb4,%ecx\nmov    %rax,%rdi\nmov    %rdx,%rsi\nrep movsq %ds:(%rsi),%es:(%rdi)\nmovl   $0x168,-0x5b8(%rbp)\nmov    -0x5b8(%rbp),%eax\nmov    %eax,%esi\nlea    0x2d57(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3478 <libmin_printf>\nlea    -0x5bc(%rbp),%rdx\nmov    -0x5b8(%rbp),%ecx\nlea    -0x5b0(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <kadane>\nmov    %eax,-0x5b4(%rbp)\nmov    -0x5bc(%rbp),%edx\nmov    -0x5b4(%rbp),%eax\nmov    %eax,%esi\nlea    0x2d21(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3478 <libmin_printf>\ncall   36e5 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     133a <main+0xc4>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "J", "content": "/* The following routine calculates the Bessel function of the first kind \n   for an integer index. We just sum the series representation given by\n\n\n                      __                     2j\n\t              \\        j        (x/2)\nJ (x) = 1/n! (x/2)^n       (-1)   __________________\n n\t              /__          j!(n+1)...(n+j)\n\t\t      j=0\n\n   \nSee Special functions and their applications, N.N. Lebedev, Dover, 1972,\npp 95-142 for an introduction to Bessel functions and related cylinder\nfunctions.\n\n*/\n\ndouble J(int n, double x)\n{\n\tdouble dsum=0.0,dterm,s_j,d_n,d_j,cfact=1.0;\n\tint j,nn;\n\n\tnn = n >= 0 ? n : -n;  /* Absolute value of n. Use the relation\n                                  J  (x) = (-1)^n J  (x) for negative n \n\t\t\t\t    -n              n    */\n\n\td_n = (double) nn;\n\t\n\t/* Calculate the common factor (x/2)^n/n! so it only has to be\n           done once. */\n\n\tfor(j=1;j<=nn;j++){\n\t\td_j = (double)j;\n\t\tcfact *= x/(2.0*d_j);\n\t}\n\n\t/* j = 0 term: */\n\tdsum = dterm = cfact;\n\n\tj = 1;\n\n\tdo {\n\t\td_j = (double)j;\n\t\ts_j = j%2 ? -1.0: 1.0;\n\t\tdterm *= x*x/(d_j*4.0*(d_n + d_j));\n\t\tdsum += s_j*dterm;\n\t\tj++;\n\t} while( dterm > DBL_EPSILON );\n\t\t\n\ts_j = nn%2 ? -1.0 : 1.0;\n\treturn  n >= 0 ? dsum : s_j*dsum;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O0.pseudo", "function_name": "J", "address": "0x1c4a", "label": "J", "content": "double __cdecl J(int n, double x)\n{\n  int v2; // eax\n  double v3; // xmm0_8\n  double v4; // xmm0_8\n  int j; // [rsp+18h] [rbp-38h]\n  int ja; // [rsp+18h] [rbp-38h]\n  double dsum; // [rsp+20h] [rbp-30h]\n  double dterm; // [rsp+28h] [rbp-28h]\n  double cfact; // [rsp+30h] [rbp-20h]\n\n  cfact = 1.0;\n  v2 = n;\n  if ( n <= 0 )\n    v2 = -n;\n  for ( j = 1; j <= v2; ++j )\n    cfact = x / ((double)j + (double)j) * cfact;\n  dterm = cfact;\n  dsum = cfact;\n  ja = 1;\n  do\n  {\n    if ( (ja & 1) != 0 )\n      v3 = -1.0;\n    else\n      v3 = 1.0;\n    dterm = x * x / (((double)v2 + (double)ja) * ((double)ja * 4.0)) * dterm;\n    dsum = v3 * dterm + dsum;\n    ++ja;\n  }\n  while ( dterm > 2.220446049250313e-16 );\n  if ( (v2 & 1) != 0 )\n    v4 = -1.0;\n  else\n    v4 = 1.0;\n  if ( n >= 0 )\n    return dsum;\n  else\n    return v4 * dsum;\n}\n"}, "pseudo_normalize": "double J(int n, double x) {\n  int v2;\n  double v3;\n  double v4;\n  int j;\n  int ja;\n  double dsum;\n  double dterm;\n  double cfact;\n  cfact = 1.0;\n  v2 = n;\n  if (n <= 0) v2 = -n;\n  for (j = 1; j <= v2; ++j) cfact = x / ((double)j + (double)j) * cfact;\n  dterm = cfact;\n  dsum = cfact;\n  ja = 1;\n  do {\n    if ((ja & 1) != 0)\n      v3 = -1.0;\n    else\n      v3 = 1.0;\n    dterm = x * x / (((double)v2 + (double)ja) * ((double)ja * 4.0)) * dterm;\n    dsum = v3 * dterm + dsum;\n    ++ja;\n  } while (dterm > 2.220446049250313e-16);\n  if ((v2 & 1) != 0)\n    v4 = -1.0;\n  else\n    v4 = 1.0;\n  if (n >= 0)\n    return dsum;\n  else\n    return v4 * dsum;\n}", "binary": "kepler/kepler.host.O0", "assembly": "<J>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x44(%rbp)\nmovsd  %xmm0,-0x50(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  0x665d(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x44(%rbp),%eax\nmov    %eax,%edx\nneg    %edx\ncmovns %edx,%eax\nmov    %eax,-0x34(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x34(%rbp),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovl   $0x1,-0x38(%rbp)\njmp    1cca <J+0x80>\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x38(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  -0x50(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  -0x20(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\naddl   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njle    1c94 <J+0x4a>\nmovsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovl   $0x1,-0x38(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x38(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x38(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1d0f <J+0xc5>\nmovsd  0x65db(%rip),%xmm0\njmp    1d17 <J+0xcd>\nmovsd  0x65b1(%rip),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x50(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\nmovsd  -0x10(%rbp),%xmm2\nmovsd  0x65ee(%rip),%xmm1\nmulsd  %xmm1,%xmm2\nmovsd  -0x18(%rbp),%xmm1\naddsd  -0x10(%rbp),%xmm1\nmulsd  %xmm2,%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  -0x28(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x28(%rbp),%xmm0\nmovsd  -0x30(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\naddl   $0x1,-0x38(%rbp)\nmovsd  -0x28(%rbp),%xmm0\ncomisd 0x6581(%rip),%xmm0\nja     1ced <J+0xa3>\nmov    -0x34(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1d99 <J+0x14f>\nmovsd  0x6551(%rip),%xmm0\njmp    1da1 <J+0x157>\nmovsd  0x6527(%rip),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\ncmpl   $0x0,-0x44(%rbp)\njns    1db8 <J+0x16e>\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x30(%rbp),%xmm0\njmp    1dbd <J+0x173>\nmovsd  -0x30(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "bin_fact", "content": "#endif /* NO_MAIN */\n\n/* The bin_fact routine calculates C(n,k)(n-2k)^(n-1)/n!2^(n-1). This\n   routine assumes 2k <  n, and tries to keep the intermediate products\n   small to prevent overflow.  */\n\ndouble \nbin_fact(int n, int k)\n{\n\t\tint j;\n\t\tdouble cum_prod = 1.0;\n\t\tdouble num_fact,den_fact,dj,dk,x;\n\n\t\tx = ((double) n)/2.0 - (double)k;\n\n\t\tfor(j=n-k;j>1;j--){\n\t\t\tdj = (double)j;\n\t\t\tdk = (double) n -(double)k - dj + 1.0;\n\t\t\tden_fact = n - k - j + 1 <= k ? dk*dj : dj;  \n\t\t\tnum_fact = n - k - j + 1 <= k ? x*x : x; \n\t\t\tcum_prod *= (num_fact/den_fact);\n\t\t}\n\t\treturn cum_prod;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O0.pseudo", "function_name": "bin_fact", "address": "0x1b3e", "label": "bin_fact", "content": "double __cdecl bin_fact(int n, int k)\n{\n  double v2; // xmm0_8\n  double v3; // xmm0_8\n  int j; // [rsp+14h] [rbp-34h]\n  double cum_prod; // [rsp+18h] [rbp-30h]\n  double den_fact; // [rsp+38h] [rbp-10h]\n\n  cum_prod = 1.0;\n  for ( j = n - k; j > 1; --j )\n  {\n    if ( k <= n - k - j )\n      v2 = (double)j;\n    else\n      v2 = ((double)n - (double)k - (double)j + 1.0) * (double)j;\n    den_fact = v2;\n    if ( k <= n - k - j )\n      v3 = (double)n / 2.0 - (double)k;\n    else\n      v3 = ((double)n / 2.0 - (double)k) * ((double)n / 2.0 - (double)k);\n    cum_prod = v3 / den_fact * cum_prod;\n  }\n  return cum_prod;\n}\n"}, "pseudo_normalize": "double bin_fact(int n, int k) {\n  double v2;\n  double v3;\n  int j;\n  double cum_prod;\n  double den_fact;\n  cum_prod = 1.0;\n  for (j = n - k; j > 1; --j) {\n    if (k <= n - k - j)\n      v2 = (double)j;\n    else\n      v2 = ((double)n - (double)k - (double)j + 1.0) * (double)j;\n    den_fact = v2;\n    if (k <= n - k - j)\n      v3 = (double)n / 2.0 - (double)k;\n    else\n      v3 = ((double)n / 2.0 - (double)k) * ((double)n / 2.0 - (double)k);\n    cum_prod = v3 / den_fact * cum_prod;\n  }\n  return cum_prod;\n}", "binary": "kepler/kepler.host.O0", "assembly": "<bin_fact>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x44(%rbp)\nmov    %esi,-0x48(%rbp)\nmovsd  0x6774(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x44(%rbp),%xmm0\nmovsd  0x6776(%rip),%xmm1\ndivsd  %xmm1,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x48(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmov    -0x44(%rbp),%eax\nsub    -0x48(%rbp),%eax\nmov    %eax,-0x34(%rbp)\njmp    1c2f <bin_fact+0xf1>\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x34(%rbp),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x44(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x48(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\nsubsd  -0x20(%rbp),%xmm1\nmovsd  0x6705(%rip),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x44(%rbp),%eax\nsub    -0x48(%rbp),%eax\nsub    -0x34(%rbp),%eax\ncmp    %eax,-0x48(%rbp)\njle    1be6 <bin_fact+0xa8>\nmovsd  -0x18(%rbp),%xmm0\nmulsd  -0x20(%rbp),%xmm0\njmp    1beb <bin_fact+0xad>\nmovsd  -0x20(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x44(%rbp),%eax\nsub    -0x48(%rbp),%eax\nsub    -0x34(%rbp),%eax\ncmp    %eax,-0x48(%rbp)\njle    1c09 <bin_fact+0xcb>\nmovsd  -0x28(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\njmp    1c0e <bin_fact+0xd0>\nmovsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\ndivsd  -0x10(%rbp),%xmm0\nmovsd  -0x30(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nsubl   $0x1,-0x34(%rbp)\ncmpl   $0x1,-0x34(%rbp)\njg     1b8e <bin_fact+0x50>\nmovsd  -0x30(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "binary", "content": "/* The following routine implements the binary search algorithm due\n   to Roger Sinnott, Sky and Telescope, Vol 70, page 159 (August 1985.)\n   It is not the fastest algorithm, but it is completely reliable. \n*/\n\ndouble binary(double E, double e, double M, int reset)\n{\n\tstatic double scale = .7853981633975;   /* PI/4 */\n\tdouble R;\n\tdouble X;\n\n\tif(reset) {\n\t\tscale = PI/4.0;\n\t\treturn 0.0;\n\t}\n\n\tR = E - e*libmin_sin(E);\n\tX = M > R ? E + scale : E - scale;\n\tscale = scale/2.0;\n\treturn X;\n\t\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O0.pseudo", "function_name": "binary", "address": "0x12c6", "label": "binary", "content": "double __cdecl binary(double E, double e, double M, int reset)\n{\n  double result; // xmm0_8\n\n  if ( reset )\n  {\n    scale_2 = 0.7853981633975;\n    return 0.0;\n  }\n  else\n  {\n    if ( M <= E - libmin_sin(E) * e )\n      result = E - scale_2;\n    else\n      result = scale_2 + E;\n    scale_2 = scale_2 / 2.0;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "double binary(double E, double e, double M, int reset) {\n  double result;\n  if (reset) {\n    scale_2 = 0.7853981633975;\n    return 0.0;\n  } else {\n    if (M <= E - libmin_sin(E) * e)\n      result = E - scale_2;\n    else\n      result = scale_2 + E;\n    scale_2 = scale_2 / 2.0;\n  }\n  return result;\n}", "binary": "kepler/kepler.host.O0", "assembly": "<binary>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  %xmm1,-0x20(%rbp)\nmovsd  %xmm2,-0x28(%rbp)\nmov    %edi,-0x2c(%rbp)\ncmpl   $0x0,-0x2c(%rbp)\nje     1300 <binary+0x3a>\nmovsd  0x6fde(%rip),%xmm0\nmovsd  %xmm0,0x9d26(%rip)\npxor   %xmm0,%xmm0\njmp    137d <binary+0xb7>\nmov    -0x18(%rbp),%rax\nmovq   %rax,%xmm0\ncall   6067 <libmin_sin>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm1\nmulsd  -0x20(%rbp),%xmm1\nmovsd  -0x18(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x28(%rbp),%xmm0\ncomisd -0x10(%rbp),%xmm0\njbe    1346 <binary+0x80>\nmovsd  0x9ce1(%rip),%xmm0\naddsd  -0x18(%rbp),%xmm0\njmp    1357 <binary+0x91>\nmovsd  0x9cd2(%rip),%xmm1\nmovsd  -0x18(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  0x9cbc(%rip),%xmm0\nmovsd  0x6f74(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,0x9ca8(%rip)\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "e_series", "content": "/* The following infinite series expansion for E in powers of e is known:\n\n                 __\n\t        \\       n\n\tE = M +      A e\n\t\t/__   n\n\t\tn=1\n\nwhere              __ \n       \t     n-1  \\          k            (n-1)\nA =      (1/2 n!)        (-1) C(n,k)(n-2k)   sin((n-2k)M),\n n                /__\n                 0<= k <= [n/2]\n\nwhich converges for e < LAPLACE_LIMIT (defined above). This is based upon\nthe Laplace inversion formula -- see the discussion of Burmann's theorem\nand following material in Whittaker and Watson.\n\nThe bin_fact helper routine calculates C(n,k)(n-2k)^(n-1)/n!2^(n-1) */\n\n\ndouble e_series(double E, double e, double M, int reset)\n{\n\tstatic int n;\n\tint k;\n\tdouble n_2k,a_n=0.0,s_k;\n\n\tif(reset){\n\t\tn = 0;\n\t\treturn 0.0;\n\t}\n\n\tif(n==0){\n\t\tn++;\n\t\treturn M;\n\t}\n\n\n\tfor(k=0;2*k<=n;k++){\n\t\tn_2k = (double)n - 2.0 * ((double)k);\n\t\ts_k = k%2 ? -1.0 : 1.0;   /*   (-1)^k */\n\t\ta_n += s_k*bin_fact(n,k)*libmin_sin(n_2k*M);\n\t}\n\tn++;\n\treturn E + libmin_pow(e,n-1)*a_n;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O0.pseudo", "function_name": "e_series", "address": "0x1389", "label": "e_series", "content": "double __cdecl e_series(double E, double e, double M, int reset)\n{\n  double v5; // xmm0_8\n  double v6; // [rsp+8h] [rbp-48h]\n  int k; // [rsp+34h] [rbp-1Ch]\n  double a_n; // [rsp+38h] [rbp-18h]\n  double n_2k; // [rsp+40h] [rbp-10h]\n\n  a_n = 0.0;\n  if ( reset )\n  {\n    n_1 = 0;\n    return 0.0;\n  }\n  else if ( n_1 )\n  {\n    for ( k = 0; 2 * k <= n_1; ++k )\n    {\n      n_2k = (double)n_1 - ((double)k + (double)k);\n      if ( (k & 1) != 0 )\n        v5 = -1.0;\n      else\n        v5 = 1.0;\n      v6 = bin_fact(n_1, k) * v5;\n      a_n = libmin_sin(n_2k * M) * v6 + a_n;\n    }\n    return libmin_pow(e, (double)n_1++) * a_n + E;\n  }\n  else\n  {\n    n_1 = 1;\n    return M;\n  }\n}\n"}, "pseudo_normalize": "double e_series(double E, double e, double M, int reset) {\n  double v5;\n  double v6;\n  int k;\n  double a_n;\n  double n_2k;\n  a_n = 0.0;\n  if (reset) {\n    n_1 = 0;\n    return 0.0;\n  } else if (n_1) {\n    for (k = 0; 2 * k <= n_1; ++k) {\n      n_2k = (double)n_1 - ((double)k + (double)k);\n      if ((k & 1) != 0)\n        v5 = -1.0;\n      else\n        v5 = 1.0;\n      v6 = bin_fact(n_1, k) * v5;\n      a_n = libmin_sin(n_2k * M) * v6 + a_n;\n    }\n    return libmin_pow(e, (double)n_1++) * a_n + E;\n  } else {\n    n_1 = 1;\n    return M;\n  }\n}", "binary": "kepler/kepler.host.O0", "assembly": "<e_series>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  %xmm1,-0x30(%rbp)\nmovsd  %xmm2,-0x38(%rbp)\nmov    %edi,-0x3c(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\ncmpl   $0x0,-0x3c(%rbp)\nje     13c9 <e_series+0x40>\nmovl   $0x0,0x9f4c(%rip)\npxor   %xmm0,%xmm0\njmp    14f5 <e_series+0x16c>\nmov    0x9f3d(%rip),%eax\ntest   %eax,%eax\njne    13ec <e_series+0x63>\nmov    0x9f33(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9f2a(%rip)\nmovsd  -0x38(%rbp),%xmm0\njmp    14f5 <e_series+0x16c>\nmovl   $0x0,-0x1c(%rbp)\njmp    149b <e_series+0x112>\nmov    0x9f0e(%rip),%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x1c(%rbp),%xmm0\nmovapd %xmm0,%xmm2\naddsd  %xmm0,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x1c(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1438 <e_series+0xaf>\nmovsd  0x6eb2(%rip),%xmm0\njmp    1440 <e_series+0xb7>\nmovsd  0x6e88(%rip),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    0x9ec1(%rip),%eax\nmov    -0x1c(%rbp),%edx\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1b3e <bin_fact>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm3\nmulsd  -0x8(%rbp),%xmm3\nmovsd  %xmm3,-0x48(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x38(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   6067 <libmin_sin>\nmulsd  -0x48(%rbp),%xmm0\nmovsd  -0x18(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    0x9e65(%rip),%eax\ncmp    %eax,%edx\njle    13f8 <e_series+0x6f>\nmov    0x9e57(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9e4e(%rip)\nmov    0x9e48(%rip),%eax\nsub    $0x1,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmov    -0x30(%rbp),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   2602 <libmin_pow>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nmulsd  -0x18(%rbp),%xmm0\naddsd  -0x28(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "j_series", "content": "\t\n/* The eccentric anomaly is an odd periodic function in the Mean Anomoly\n   and so can be developed in a Fourier sine series. This turns out to\n   be \n                 __\n\t        \\  \n\tE = M +      (2/n)J (ne)sin(nM)\n\t\t/__        n \n\t\tn=1\n\n  where J_n is the Bessel function of the first kind. See, e.g, A Mathematical\n  Introdution to Celestial Mechanics, Harry Pollard, Prentice Hall, 1966,\n  pp 22-23. The following routine is used to sum this series.\n*/\n\n\ndouble j_series(double E, double e, double M, int reset)\n{\n\tstatic int n;\n\tdouble dn, term;\n\n\tif(reset){\n\t\tn = 0;\n\t\treturn 0.0;\n\t}\n\n\tif(n==0){\n\t\tn++;\n\t\treturn M;\n\t}\n\tdn = (double)n;\n\tterm = (2.0/(double)n)*J(n,dn*e)*libmin_sin(dn*M);\n\tn++;\n\treturn E + term;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O0.pseudo", "function_name": "j_series", "address": "0x1501", "label": "j_series", "content": "double __cdecl j_series(double E, double e, double M, int reset)\n{\n  double v5; // xmm0_8\n  double v6; // [rsp+8h] [rbp-38h]\n  double v7; // [rsp+8h] [rbp-38h]\n  double dn; // [rsp+30h] [rbp-10h]\n\n  if ( reset )\n  {\n    n_0 = 0;\n    return 0.0;\n  }\n  else if ( n_0 )\n  {\n    dn = (double)n_0;\n    v6 = 2.0 / (double)n_0;\n    v7 = J(n_0, (double)n_0 * e) * v6;\n    v5 = libmin_sin(dn * M);\n    ++n_0;\n    return E + v5 * v7;\n  }\n  else\n  {\n    n_0 = 1;\n    return M;\n  }\n}\n"}, "pseudo_normalize": "double j_series(double E, double e, double M, int reset) {\n  double v5;\n  double v6;\n  double v7;\n  double dn;\n  if (reset) {\n    n_0 = 0;\n    return 0.0;\n  } else if (n_0) {\n    dn = (double)n_0;\n    v6 = 2.0 / (double)n_0;\n    v7 = J(n_0, (double)n_0 * e) * v6;\n    v5 = libmin_sin(dn * M);\n    ++n_0;\n    return E + v5 * v7;\n  } else {\n    n_0 = 1;\n    return M;\n  }\n}", "binary": "kepler/kepler.host.O0", "assembly": "<j_series>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  %xmm1,-0x20(%rbp)\nmovsd  %xmm2,-0x28(%rbp)\nmov    %edi,-0x2c(%rbp)\ncmpl   $0x0,-0x2c(%rbp)\nje     1538 <j_series+0x37>\nmovl   $0x0,0x9de1(%rip)\npxor   %xmm0,%xmm0\njmp    15fc <j_series+0xfb>\nmov    0x9dd2(%rip),%eax\ntest   %eax,%eax\njne    155b <j_series+0x5a>\nmov    0x9dc8(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9dbf(%rip)\nmovsd  -0x28(%rbp),%xmm0\njmp    15fc <j_series+0xfb>\nmov    0x9daf(%rip),%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %eax,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    0x9d9c(%rip),%eax\npxor   %xmm1,%xmm1\ncvtsi2sd %eax,%xmm1\nmovsd  0x6d5c(%rip),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm4\nmulsd  -0x20(%rbp),%xmm4\nmovq   %xmm4,%rdx\nmov    0x9d6a(%rip),%eax\nmovq   %rdx,%xmm0\nmov    %eax,%edi\ncall   1c4a <J>\nmovapd %xmm0,%xmm5\nmulsd  -0x38(%rbp),%xmm5\nmovsd  %xmm5,-0x38(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x28(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   6067 <libmin_sin>\nmulsd  -0x38(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    0x9d27(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x9d1e(%rip)\nmovsd  -0x18(%rbp),%xmm0\naddsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "kepler", "content": "int\nkepler(double *E, double M, double e, double my_derror, int m)\n{\n\tint count = 0;\n\tdouble sign = 1.0;\n\tdouble  E_old=PI/2;\n\tdouble (*method)(double,double, double,int);\n\t\n\tif((m<0) || (m>=NMETHODS))return -1;\n\n\tmethod = (double(*)(double,double,double,int))methods[m];\n\n\tif((m==3)&&(e > LAPLACE_LIMIT))\n\t\treturn -1;\n\n\tif((e<0)||(e>=1.0))\n\t\treturn -1;\n\n\t/* Normalize M to lie between 0 and PI */\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M)/(2*PI);\n\tM = (M - libmin_floor(M))*2*PI*sign;\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M);\n\tif(M > PI){\n\t\tM = 2*PI - M;\n\t\tsign = -1.0;\n\t}\n\t\n\t/* Do selected calculation, and quit when accuracy is bettered. */\n\twhile(libmin_fabs(E_old - (*E = method(E_old,e,M,0))) >= my_derror){\n\t\tE_old = *E;\n\t\tcount++;\n\t}\n\t*E = sign*(*E);\n\tmethod(0.0,0.0,0.0,1);  /* reset */\n\n\treturn count;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O0.pseudo", "function_name": "kepler", "address": "0x1dc9", "label": "kepler", "content": "int __cdecl kepler(double *E, double M, double e, double my_derror, int m)\n{\n  unsigned __int64 v6; // xmm0_8\n  double v7; // xmm0_8\n  unsigned __int64 v8; // xmm0_8\n  double Md; // [rsp+20h] [rbp-30h]\n  double Mb; // [rsp+20h] [rbp-30h]\n  double Mc; // [rsp+20h] [rbp-30h]\n  int count; // [rsp+34h] [rbp-1Ch]\n  double signa; // [rsp+38h] [rbp-18h]\n  double sign; // [rsp+38h] [rbp-18h]\n  double E_old; // [rsp+40h] [rbp-10h]\n  double (*method)(double, double, double, int); // [rsp+48h] [rbp-8h]\n\n  count = 0;\n  E_old = 1.570796326795;\n  if ( (unsigned int)m > 4 )\n    return -1;\n  method = (double (*)(double, double, double, int))methods[m];\n  if ( m == 3 && e > 0.6627434193 )\n    return -1;\n  if ( e < 0.0 || e >= 1.0 )\n    return -1;\n  if ( M <= 0.0 )\n    v6 = 0xBFF0000000000000LL;\n  else\n    v6 = 0x3FF0000000000000LL;\n  signa = *(double *)&v6;\n  Md = libmin_fabs(M) / 6.28318530718;\n  v7 = libmin_floor(Md);\n  Mb = 3.14159265359 * (Md - v7 + Md - v7) * signa;\n  if ( Mb <= 0.0 )\n    v8 = 0xBFF0000000000000LL;\n  else\n    v8 = 0x3FF0000000000000LL;\n  sign = *(double *)&v8;\n  Mc = libmin_fabs(Mb);\n  if ( Mc > 3.14159265359 )\n  {\n    Mc = 6.28318530718 - Mc;\n    sign = -1.0;\n  }\n  while ( 1 )\n  {\n    *E = ((double (__cdecl *)(double, double, double, int))method)(E_old, e, Mc, 0);\n    if ( libmin_fabs(E_old - *E) < my_derror )\n      break;\n    E_old = *E;\n    ++count;\n  }\n  *E = *E * sign;\n  ((void (__cdecl *)(double, double, double, int))method)(0.0, 0.0, 0.0, 1);\n  return count;\n}\n"}, "pseudo_normalize": "int kepler(double *E, double M, double e, double my_derror, int m) {\n  unsigned long long v6;\n  double v7;\n  unsigned long long v8;\n  double Md;\n  double Mb;\n  double Mc;\n  int count;\n  double signa;\n  double sign;\n  double E_old;\n  double (*method)(double, double, double, int);\n  count = 0;\n  E_old = 1.570796326795;\n  if ((unsigned int)m > 4) return -1;\n  method = (double (*)(double, double, double, int))methods[m];\n  if (m == 3 && e > 0.6627434193) return -1;\n  if (e < 0.0 || e >= 1.0) return -1;\n  if (M <= 0.0)\n    v6 = 13830554455654793216LL;\n  else\n    v6 = 4607182418800017408LL;\n  signa = *(double *)&v6;\n  Md = libmin_fabs(M) / 6.28318530718;\n  v7 = libmin_floor(Md);\n  Mb = 3.14159265359 * (Md - v7 + Md - v7) * signa;\n  if (Mb <= 0.0)\n    v8 = 13830554455654793216LL;\n  else\n    v8 = 4607182418800017408LL;\n  sign = *(double *)&v8;\n  Mc = libmin_fabs(Mb);\n  if (Mc > 3.14159265359) {\n    Mc = 6.28318530718 - Mc;\n    sign = -1.0;\n  }\n  while (1) {\n    *E = ((double (*)(double, double, double, int))method)(E_old, e, Mc, 0);\n    if (libmin_fabs(E_old - *E) < my_derror) break;\n    E_old = *E;\n    ++count;\n  }\n  *E = *E * sign;\n  ((void (*)(double, double, double, int))method)(0.0, 0.0, 0.0, 1);\n  return count;\n}", "binary": "kepler/kepler.host.O0", "assembly": "<kepler>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %rdi,-0x28(%rbp)\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  %xmm1,-0x38(%rbp)\nmovsd  %xmm2,-0x40(%rbp)\nmov    %esi,-0x44(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovsd  0x64ce(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  0x64f1(%rip),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\ncmpl   $0x0,-0x44(%rbp)\njs     1e1a <kepler+0x51>\nmov    -0x44(%rbp),%eax\ncmp    $0x4,%eax\njbe    1e24 <kepler+0x5b>\nmov    $0xffffffff,%eax\njmp    202b <kepler+0x262>\nmov    -0x44(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x9208(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,-0x8(%rbp)\ncmpl   $0x3,-0x44(%rbp)\njne    1e5f <kepler+0x96>\nmovsd  -0x38(%rbp),%xmm0\ncomisd 0x64b5(%rip),%xmm0\njbe    1e5f <kepler+0x96>\nmov    $0xffffffff,%eax\njmp    202b <kepler+0x262>\npxor   %xmm0,%xmm0\ncomisd -0x38(%rbp),%xmm0\nja     1e7d <kepler+0xb4>\nmovsd  -0x38(%rbp),%xmm0\nmovsd  0x6451(%rip),%xmm1\ncomisd %xmm1,%xmm0\njb     1e87 <kepler+0xbe>\nmov    $0xffffffff,%eax\njmp    202b <kepler+0x262>\nmovsd  -0x30(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncomisd %xmm1,%xmm0\njbe    1ea0 <kepler+0xd7>\nmovsd  0x642a(%rip),%xmm0\njmp    1ea8 <kepler+0xdf>\nmovsd  0x6440(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovq   %rax,%xmm0\ncall   2485 <libmin_fabs>\nmovq   %xmm0,%rax\nmovsd  0x6448(%rip),%xmm1\nmovq   %rax,%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\nmovq   %rax,%xmm0\ncall   24eb <libmin_floor>\nmovapd %xmm0,%xmm1\nmovsd  -0x30(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x6417(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x18(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  -0x30(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncomisd %xmm1,%xmm0\njbe    1f2c <kepler+0x163>\nmovsd  0x639e(%rip),%xmm0\njmp    1f34 <kepler+0x16b>\nmovsd  0x63b4(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovq   %rax,%xmm0\ncall   2485 <libmin_fabs>\nmovq   %xmm0,%rax\nmov    %rax,-0x30(%rbp)\nmovsd  -0x30(%rbp),%xmm0\ncomisd 0x63bb(%rip),%xmm0\njbe    1f7e <kepler+0x1b5>\nmovsd  0x63a9(%rip),%xmm0\nsubsd  -0x30(%rbp),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  0x636f(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\njmp    1f91 <kepler+0x1c8>\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmovsd  -0x30(%rbp),%xmm1\nmovsd  -0x38(%rbp),%xmm0\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    $0x0,%edi\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   *%rdx\nmovq   %xmm0,%rax\nmov    -0x28(%rbp),%rdx\nmov    %rax,(%rdx)\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm1\nmovsd  -0x10(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2485 <libmin_fabs>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm3\ncomisd -0x40(%rbp),%xmm3\njae    1f80 <kepler+0x1b7>\nmov    -0x28(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmov    -0x28(%rbp),%rax\nmovsd  %xmm0,(%rax)\nmov    -0x8(%rbp),%rdx\nmov    $0x1,%edi\npxor   %xmm2,%xmm2\npxor   %xmm1,%xmm1\nmov    0x62b7(%rip),%rax\nmovq   %rax,%xmm0\ncall   *%rdx\nmov    -0x1c(%rbp),%eax\nleave\nret\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tint n = 1,i=1;\n\tint m=1;\n\tdouble sign = 1.0;\n\tdouble M = 0.0, e = -0.1, E_old=PI/2 ,E;\n\tdouble (*method)(double,double, double,int);\n\n\n\t/* Process command line options */\n\n\twhile(argv[i][0] == '-'){\n\t\t  if(libmin_strcmp(argv[i],\"-h\")==0){\n\t\t\tlibmin_printf(\"%s\\n\", HELP);\n\t\t\tlibmin_success();\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-v\")==0){\n\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\tlibmin_success();\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-a\")==0){\n\t\t\tderror = libmin_atof(argv[i+1]);\n\t\t\tif(derror <= DBL_EPSILON)\n\t\t\t        libmin_printf(\"Warning: requested precision may exceed implementation limit.\\n\");\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-m\")==0){\n\t\t\tm = libmin_atoi(argv[i+1]);\n\t\t\tif((m<=0) || (m>NMETHODS)){\n\t\t\t\tlibmin_printf(\"Bad method number %d\\n\",m);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t  }\n\t\t  libmin_printf(\"kepler: Unknown option %s\\n\", argv[i]);\n\t\t  libmin_printf(\"%s\\n\",USAGE);\n\t\t  return 1;\n\t\t}\n\tif(i + 2 > argc){\n\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\treturn 1;\n\t}\n\tM = libmin_atof(argv[i++]);\n\te = libmin_atof(argv[i]);\n\tmethod = (double(*)(double,double,double,int))methods[m-1];\n\n\tif((m==4)&&(e > LAPLACE_LIMIT)){\n\t\tlibmin_printf(\"e cannot exceed %f for this method.\\n\",\n\t\t\t\tLAPLACE_LIMIT);\n\t\treturn 1;\n\t}\n\n\tif((e<0)||(e>=1.0)){\n\t\tlibmin_printf(\"Eccentricity %f out of range.\\n\",e);\n\t\treturn 1;\n\t}\n\n\t/* Normalize M to lie between 0 and PI */\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M)/(2*PI);\n\tM = (M - libmin_floor(M))*2*PI*sign;\n\tsign = 1.0;\n\tif(M > PI){\n\t\tM = 2*PI - M;\n\t\tsign = -1.0;\n\t}\n\t\n\t/* Do selected calculation, and quit when accuracy is bettered. */\n\twhile(libmin_fabs(E_old - (E = method(E_old,e,M,0))) >= derror){\n\t\tE_old = E;\n\t\tlibmin_printf(\"n = %d\\tE = %f\\n\",n++,sign*E);\n\t}\n\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O0.pseudo", "function_name": "main", "address": "0x1608", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  unsigned __int64 v4; // xmm0_8\n  double v5; // xmm0_8\n  int v6; // eax\n  int n; // [rsp+4h] [rbp-3Ch]\n  int i; // [rsp+8h] [rbp-38h]\n  int m; // [rsp+Ch] [rbp-34h]\n  double signa; // [rsp+10h] [rbp-30h]\n  double sign; // [rsp+10h] [rbp-30h]\n  double M; // [rsp+18h] [rbp-28h]\n  double Mb; // [rsp+18h] [rbp-28h]\n  double Ma; // [rsp+18h] [rbp-28h]\n  double E_old; // [rsp+20h] [rbp-20h]\n  double e; // [rsp+28h] [rbp-18h]\n  double (*method)(double, double, double, int); // [rsp+30h] [rbp-10h]\n  double E; // [rsp+38h] [rbp-8h]\n\n  n = 1;\n  i = 1;\n  m = 1;\n  E_old = 1.570796326795;\n  while ( *::argv[i] == 45 )\n  {\n    if ( !libmin_strcmp(::argv[i], r) )\n    {\n      libmin_printf(\n        \"%s\\n\",\n        \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n        \"-h: print this helpful message\\n\"\n        \"-v: print version number and exit\\n\"\n        \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n        \"-m: use selected calculation method k, where\\n\"\n        \"\\tk = 1: Simple iteration.\\n\"\n        \"\\tk = 2: Newton's method.\\n\"\n        \"\\tk = 3: Binary search.\\n\"\n        \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n        \"\\tk = 5: Fourier Bessel series.\\n\"\n        \"M = mean anomaly (radians)\\n\"\n        \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if ( !libmin_strcmp(::argv[i], \"-v\") )\n    {\n      libmin_printf(\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if ( libmin_strcmp(::argv[i], \"-a\") )\n    {\n      if ( libmin_strcmp(::argv[i], \"-m\") )\n      {\n        libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[i]);\n        libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n        return 1;\n      }\n      m = libmin_atoi(::argv[i + 1]);\n      if ( m <= 0 || (unsigned int)m > 5 )\n      {\n        libmin_printf(\"Bad method number %d\\n\", m);\n        return 1;\n      }\n      i += 2;\n    }\n    else\n    {\n      derror = libmin_atof(::argv[i + 1]);\n      if ( derror <= 2.220446049250313e-16 )\n        libmin_printf(\"Warning: requested precision may exceed implementation limit.\\n\");\n      i += 2;\n    }\n  }\n  if ( i + 1 < ::argc )\n  {\n    M = libmin_atof(::argv[i]);\n    e = libmin_atof(::argv[i + 1]);\n    method = (double (*)(double, double, double, int))methods[m - 1];\n    if ( m == 4 && e > 0.6627434193 )\n    {\n      libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n      return 1;\n    }\n    else\n    {\n      if ( e >= 0.0 && e < 1.0 )\n      {\n        if ( M <= 0.0 )\n          v4 = 0xBFF0000000000000LL;\n        else\n          v4 = 0x3FF0000000000000LL;\n        signa = *(double *)&v4;\n        Mb = libmin_fabs(M) / 6.28318530718;\n        v5 = libmin_floor(Mb);\n        Ma = 3.14159265359 * (Mb - v5 + Mb - v5) * signa;\n        sign = 1.0;\n        if ( Ma > 3.14159265359 )\n        {\n          Ma = 6.28318530718 - Ma;\n          sign = -1.0;\n        }\n        while ( 1 )\n        {\n          E = ((double (__cdecl *)(double, double, double, int))method)(E_old, e, Ma, 0);\n          if ( libmin_fabs(E_old - E) < derror )\n            break;\n          E_old = E;\n          v6 = n++;\n          libmin_printf(\"n = %d\\tE = %f\\n\", v6, sign * E);\n        }\n        libmin_success();\n      }\n      libmin_printf(\"Eccentricity %f out of range.\\n\", e);\n      return 1;\n    }\n  }\n  else\n  {\n    libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  unsigned long long v4;\n  double v5;\n  int v6;\n  int n;\n  int i;\n  int m;\n  double signa;\n  double sign;\n  double M;\n  double Mb;\n  double Ma;\n  double E_old;\n  double e;\n  double (*method)(double, double, double, int);\n  double E;\n  n = 1;\n  i = 1;\n  m = 1;\n  E_old = 1.570796326795;\n  while (*::argv[i] == 45) {\n    if (!libmin_strcmp(::argv[i], r)) {\n      libmin_printf(\n          \"%s\\n\",\n          \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n          \"-h: print this helpful message\\n\"\n          \"-v: print version number and exit\\n\"\n          \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n          \"-m: use selected calculation method k, where\\n\"\n          \"\\tk = 1: Simple iteration.\\n\"\n          \"\\tk = 2: Newton's method.\\n\"\n          \"\\tk = 3: Binary search.\\n\"\n          \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n          \"\\tk = 5: Fourier Bessel series.\\n\"\n          \"M = mean anomaly (radians)\\n\"\n          \"e = orbit eccentricty.\");\n      libmin_success();\n    }\n    if (!libmin_strcmp(::argv[i], \"-v\")) {\n      libmin_printf(\"%s\\n\", \"1.11\");\n      libmin_success();\n    }\n    if (libmin_strcmp(::argv[i], \"-a\")) {\n      if (libmin_strcmp(::argv[i], \"-m\")) {\n        libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[i]);\n        libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n        return 1;\n      }\n      m = libmin_atoi(::argv[i + 1]);\n      if (m <= 0 || (unsigned int)m > 5) {\n        libmin_printf(\"Bad method number %d\\n\", m);\n        return 1;\n      }\n      i += 2;\n    } else {\n      derror = libmin_atof(::argv[i + 1]);\n      if (derror <= 2.220446049250313e-16)\n        libmin_printf(\n            \"Warning: requested precision may exceed implementation limit.\\n\");\n      i += 2;\n    }\n  }\n  if (i + 1 < ::argc) {\n    M = libmin_atof(::argv[i]);\n    e = libmin_atof(::argv[i + 1]);\n    method = (double (*)(double, double, double, int))methods[m - 1];\n    if (m == 4 && e > 0.6627434193) {\n      libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n      return 1;\n    } else {\n      if (e >= 0.0 && e < 1.0) {\n        if (M <= 0.0)\n          v4 = 13830554455654793216LL;\n        else\n          v4 = 4607182418800017408LL;\n        signa = *(double *)&v4;\n        Mb = libmin_fabs(M) / 6.28318530718;\n        v5 = libmin_floor(Mb);\n        Ma = 3.14159265359 * (Mb - v5 + Mb - v5) * signa;\n        sign = 1.0;\n        if (Ma > 3.14159265359) {\n          Ma = 6.28318530718 - Ma;\n          sign = -1.0;\n        }\n        while (1) {\n          E = ((double (*)(double, double, double, int))method)(E_old, e, Ma,\n                                                                0);\n          if (libmin_fabs(E_old - E) < derror) break;\n          E_old = E;\n          v6 = n++;\n          libmin_printf(\"n = %d\\tE = %f\\n\", v6, sign * E);\n        }\n        libmin_success();\n      }\n      libmin_printf(\"Eccentricity %f out of range.\\n\", e);\n      return 1;\n    }\n  } else {\n    libmin_printf(\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n    return 1;\n  }\n}", "binary": "kepler/kepler.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmovl   $0x1,-0x3c(%rbp)\nmovl   $0x1,-0x38(%rbp)\nmovl   $0x1,-0x34(%rbp)\nmovsd  0x6c97(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  0x6ca9(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  0x6ca4(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\njmp    1872 <main+0x26a>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x9a0e(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nlea    0x69a1(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   658e <libmin_strcmp>\ntest   %eax,%eax\njne    16af <main+0xa7>\nlea    0x6995(%rip),%rax\nmov    %rax,%rsi\nlea    0x6b2b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\ncall   662a <libmin_success>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x99bd(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nlea    0x6afe(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   658e <libmin_strcmp>\ntest   %eax,%eax\njne    1700 <main+0xf8>\nlea    0x6aeb(%rip),%rax\nmov    %rax,%rsi\nlea    0x6ada(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\ncall   662a <libmin_success>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x996c(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nlea    0x6ab5(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   658e <libmin_strcmp>\ntest   %eax,%eax\njne    1790 <main+0x188>\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x993b(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   216f <libmin_atof>\nmovq   %xmm0,%rax\nmov    %rax,0x98b3(%rip)\nmovsd  0x98ab(%rip),%xmm1\nmovsd  0x6b93(%rip),%xmm0\ncomisd %xmm1,%xmm0\njb     1787 <main+0x17f>\nlea    0x6a5e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\naddl   $0x2,-0x38(%rbp)\njmp    1872 <main+0x26a>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x98dc(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nlea    0x6860(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   658e <libmin_strcmp>\ntest   %eax,%eax\njne    181b <main+0x213>\nmov    -0x38(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x98ab(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   237d <libmin_atoi>\nmov    %eax,-0x34(%rbp)\ncmpl   $0x0,-0x34(%rbp)\njle    17f2 <main+0x1ea>\nmov    -0x34(%rbp),%eax\ncmp    $0x5,%eax\njbe    1815 <main+0x20d>\nmov    -0x34(%rbp),%eax\nmov    %eax,%esi\nlea    0x6a19(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\nmov    $0x1,%eax\njmp    1b3c <main+0x534>\naddl   $0x2,-0x38(%rbp)\njmp    1872 <main+0x26a>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x9851(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x69f0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\nlea    0x69f7(%rip),%rax\nmov    %rax,%rsi\nlea    0x696d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\nmov    $0x1,%eax\njmp    1b3c <main+0x534>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x97fa(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\nje     165e <main+0x56>\nmov    -0x38(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    0x9777(%rip),%eax\ncmp    %eax,%edx\njl     18cd <main+0x2c5>\nlea    0x699c(%rip),%rax\nmov    %rax,%rsi\nlea    0x6912(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   592c <libmin_printf>\nmov    $0x1,%eax\njmp    1b3c <main+0x534>\nmov    -0x38(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x38(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x9799(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   216f <libmin_atof>\nmovq   %xmm0,%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x9770(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   216f <libmin_atof>\nmovq   %xmm0,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x34(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x9704(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,-0x10(%rbp)\ncmpl   $0x4,-0x34(%rbp)\njne    1983 <main+0x37b>\nmovsd  -0x18(%rbp),%xmm0\ncomisd 0x69b1(%rip),%xmm0\njbe    1983 <main+0x37b>\nmov    0x69a8(%rip),%rax\nmovq   %rax,%xmm0\nlea    0x6904(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   592c <libmin_printf>\nmov    $0x1,%eax\njmp    1b3c <main+0x534>\npxor   %xmm0,%xmm0\ncomisd -0x18(%rbp),%xmm0\nja     19a1 <main+0x399>\nmovsd  -0x18(%rbp),%xmm0\nmovsd  0x692d(%rip),%xmm1\ncomisd %xmm1,%xmm0\njb     19c8 <main+0x3c0>\nmov    -0x18(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x68e7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   592c <libmin_printf>\nmov    $0x1,%eax\njmp    1b3c <main+0x534>\nmovsd  -0x28(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncomisd %xmm1,%xmm0\njbe    19e1 <main+0x3d9>\nmovsd  0x68e9(%rip),%xmm0\njmp    19e9 <main+0x3e1>\nmovsd  0x68ff(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmovq   %rax,%xmm0\ncall   2485 <libmin_fabs>\nmovq   %xmm0,%rax\nmovsd  0x6907(%rip),%xmm1\nmovq   %rax,%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovq   %rax,%xmm0\ncall   24eb <libmin_floor>\nmovapd %xmm0,%xmm1\nmovsd  -0x28(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x68d6(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x30(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  0x686c(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  -0x28(%rbp),%xmm0\ncomisd 0x68aa(%rip),%xmm0\njbe    1a8f <main+0x487>\nmovsd  0x6898(%rip),%xmm0\nsubsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  0x685e(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\njmp    1ace <main+0x4c6>\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovsd  -0x30(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rdx\nmov    -0x3c(%rbp),%eax\nlea    0x1(%rax),%ecx\nmov    %ecx,-0x3c(%rbp)\nmovq   %rdx,%xmm0\nmov    %eax,%esi\nlea    0x67f6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   592c <libmin_printf>\nmovsd  -0x28(%rbp),%xmm1\nmovsd  -0x18(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nmov    -0x10(%rbp),%rdx\nmov    $0x0,%edi\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   *%rdx\nmovq   %xmm0,%rax\nmov    %rax,-0x8(%rbp)\nmovsd  -0x20(%rbp),%xmm0\nsubsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2485 <libmin_fabs>\nmovq   %xmm0,%rax\nmovsd  0x94ed(%rip),%xmm0\nmovq   %rax,%xmm3\ncomisd %xmm0,%xmm3\njae    1a91 <main+0x489>\ncall   662a <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "newton", "content": "/* The following routine is used to solve kepler's equation using\n   Newton's method. It is very fast and reliable for small values of\n   e, but can be wildly erratic for e close to 1. See, e.g, the discussion\n   in Jean Meeus, Astronomical Algorithms, Willmann-Bell, 1991, 181-193.\n*/\n\ndouble newton(double E, double e, double M, int reset)\n{\n\t/* reset is not used in this routine. It may generate a compiler\n           warning */\n\treturn E + (M + e*libmin_sin(E) - E)/(1 - e*libmin_cos(E));\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O0.pseudo", "function_name": "newton", "address": "0x1235", "label": "newton", "content": "double __cdecl newton(double E, double e, double M, int reset)\n{\n  double v5; // [rsp+8h] [rbp-28h]\n\n  v5 = libmin_sin(E) * e + M - E;\n  return v5 / (1.0 - libmin_cos(E) * e) + E;\n}\n"}, "pseudo_normalize": "", "binary": "kepler/kepler.host.O0", "assembly": "<newton>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  %xmm1,-0x10(%rbp)\nmovsd  %xmm2,-0x18(%rbp)\nmov    %edi,-0x1c(%rbp)\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   6067 <libmin_sin>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nmulsd  -0x10(%rbp),%xmm0\naddsd  -0x18(%rbp),%xmm0\nsubsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   5eb6 <libmin_cos>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm2\nmulsd  -0x10(%rbp),%xmm2\nmovsd  0x7024(%rip),%xmm0\nmovapd %xmm0,%xmm1\nsubsd  %xmm2,%xmm1\nmovsd  -0x28(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\naddsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "strict_iteration", "content": "/* All the algorithms for solving kepler's equation are implemented in\n   the following subroutines. A subroutine is called iteratively from\n   main, until the previous value of E differs from the current one by\n   less than derror.\n\n   To add a new method, add its implementation as a subroutine \n   with signature\n\n\tdouble foo(double E, double e, double M, int reset);\n\n   It should return a better approximation to the true E\n   given the current E and the values of e and M. When passed a \n   nonzero value for the reset parameter it should reinitialize any\n   static information it retains and return.\n   Then add the address of\n   the new subroutine to the methods array defined below.\n*/ \n\n/* CURRENTLY IMPLEMENTED METHODS: */\n\n/* Used to solve kepler's equation by simple iteration */\n\ndouble strict_iteration(double E, double e, double M, int reset)\n{\n\n\t/* reset is not used in this routine. It may generate a compiler\n           warning */\n\treturn M + e*libmin_sin(E);\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O0.pseudo", "function_name": "strict_iteration", "address": "0x11e9", "label": "strict_iteration", "content": "double __cdecl strict_iteration(double E, double e, double M, int reset)\n{\n  return libmin_sin(E) * e + M;\n}\n"}, "pseudo_normalize": "", "binary": "kepler/kepler.host.O0", "assembly": "<strict_iteration>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  %xmm1,-0x10(%rbp)\nmovsd  %xmm2,-0x18(%rbp)\nmov    %edi,-0x1c(%rbp)\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   6067 <libmin_sin>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nmulsd  -0x10(%rbp),%xmm0\naddsd  -0x18(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "knapsack/knapsack.c", "function_name": "knapSack", "content": "// Returns the maximum value that can be put in a knapsack of capacity W\nvoid\nknapSack(int wt[], int val[], int K[N+1][W+1])\n{\n  int i, w;\n\n  // Build table K[][] in bottom up manner\n  for (i = 0; i <= N; i++)\n  {\n    for (w = 0; w <= W; w++)\n    {\n      if (i==0 || w==0)\n        K[i][w] = 0;\n      else\n      {\n        if (wt[i-1] <= w)\n          K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]);\n        else\n          K[i][w] = K[i-1][w];\n      }\n    }\n  }\n}\n"}, "pseudo": {"path": "knapsack/knapsack.host.O0.pseudo", "function_name": "knapSack", "address": "0x1209", "label": "knapSack", "content": "void __cdecl knapSack(int *wt, int *val, int (*K)[251])\n{\n  int i; // [rsp+20h] [rbp-10h]\n  int w; // [rsp+24h] [rbp-Ch]\n\n  for ( i = 0; i <= 50; ++i )\n  {\n    for ( w = 0; w <= 250; ++w )\n    {\n      if ( i && w )\n      {\n        if ( w < wt[i - 1] )\n          (*K)[251 * i + w] = (*K)[251 * i - 251 + w];\n        else\n          (*K)[251 * i + w] = max(val[i - 1] + (*K)[251 * i - 251 + w - wt[i - 1]], (*K)[251 * i - 251 + w]);\n      }\n      else\n      {\n        (*K)[251 * i + w] = 0;\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void knapSack(int *wt, int *val, int (*K)[251]) {\n  int i;\n  int w;\n  for (i = 0; i <= 50; ++i) {\n    for (w = 0; w <= 250; ++w) {\n      if (i && w) {\n        if (w < wt[i - 1])\n          (*K)[251 * i + w] = (*K)[251 * i - 251 + w];\n        else\n          (*K)[251 * i + w] =\n              max(val[i - 1] + (*K)[251 * i - 251 + w - wt[i - 1]],\n                  (*K)[251 * i - 251 + w]);\n      } else {\n        (*K)[251 * i + w] = 0;\n      }\n    }\n  }\n}", "binary": "knapsack/knapsack.host.O0", "assembly": "<knapSack>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x20(%rbp)\nmov    %rsi,-0x28(%rbp)\nmov    %rdx,-0x30(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    137c <knapSack+0x173>\nmovl   $0x0,-0xc(%rbp)\njmp    136b <knapSack+0x162>\ncmpl   $0x0,-0x10(%rbp)\nje     1246 <knapSack+0x3d>\ncmpl   $0x0,-0xc(%rbp)\njne    126a <knapSack+0x61>\nmov    -0x10(%rbp),%eax\ncltq\nimul   $0x3ec,%rax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nmovl   $0x0,(%rdx,%rax,4)\njmp    1367 <knapSack+0x15e>\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njl     132a <knapSack+0x121>\nmov    -0x10(%rbp),%eax\ncltq\nimul   $0x3ec,%rax,%rax\nlea    -0x3ec(%rax),%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nlea    -0x4(%rdx),%rcx\nmov    -0x28(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%esi\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nimul   $0x3ec,%rdx,%rdx\nlea    -0x3ec(%rdx),%rcx\nmov    -0x30(%rbp),%rdx\nadd    %rdx,%rcx\nmov    -0x10(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x2,%rdx\nlea    -0x4(%rdx),%rdi\nmov    -0x20(%rbp),%rdx\nadd    %rdi,%rdx\nmov    (%rdx),%edi\nmov    -0xc(%rbp),%edx\nsub    %edi,%edx\nmovslq %edx,%rdx\nmov    (%rcx,%rdx,4),%edx\nadd    %esi,%edx\nmov    -0x10(%rbp),%ecx\nmovslq %ecx,%rcx\nimul   $0x3ec,%rcx,%rsi\nmov    -0x30(%rbp),%rcx\nlea    (%rsi,%rcx,1),%rbx\nmov    %eax,%esi\nmov    %edx,%edi\ncall   11e9 <max>\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    %eax,(%rbx,%rdx,4)\njmp    1367 <knapSack+0x15e>\nmov    -0x10(%rbp),%eax\ncltq\nimul   $0x3ec,%rax,%rax\nlea    -0x3ec(%rax),%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%eax\ncltq\nimul   $0x3ec,%rax,%rcx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rcx\nmov    -0xc(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0xc(%rbp),%eax\ncltq\nmov    %edx,(%rcx,%rax,4)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0xfa,-0xc(%rbp)\njle    123a <knapSack+0x31>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x32,-0x10(%rbp)\njle    122e <knapSack+0x25>\nnop\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "knapsack/knapsack.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int n = N;\n  int w = W;\n  int K[N+1][W+1];\n\n\n  knapSack(wt, val, K);\n\n\tlibmin_printf(\"Max value: %d\\n\", K[n][W]);\n\t\n  libmin_printf(\"Selected packs:\\n\");\n  while (n != 0)\n  {\n    if (K[n][w] != K[n - 1][w]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", n, wt[n - 1], val[n - 1]);\n      w = w - wt[n-1];\n    }\n    n--;\n  }\n  libmin_printf(\"Total weight: %d\\n\", W - w);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "knapsack/knapsack.host.O0.pseudo", "function_name": "main", "address": "0x138e", "label": "main", "content": "// bad sp value at call has been detected, the output may be wrong!\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int n; // [rsp+0h] [rbp-C818h]\n  int w; // [rsp+4h] [rbp-C814h]\n  int K[51][251]; // [rsp+8h] [rbp-C810h] BYREF\n  unsigned __int64 v6; // [rsp+C810h] [rbp-8h]\n\n  while ( &K[46][234] != &K[2][14] )\n    ;\n  v6 = __readfsqword(0x28u);\n  n = 50;\n  w = 250;\n  knapSack(wt, val, K);\n  libmin_printf(\"Max value: %d\\n\", K[50][250]);\n  libmin_printf(\"Selected packs:\\n\");\n  while ( n )\n  {\n    if ( K[n][w] != K[n - 1][w] )\n    {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", n, wt[n - 1], val[n - 1]);\n      w -= wt[n - 1];\n    }\n    --n;\n  }\n  libmin_printf(\"Total weight: %d\\n\", 250 - w);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int n;\n  int w;\n  int K[51][251];\n  unsigned long long v6;\n  while (&K[46][234] != &K[2][14])\n    ;\n  v6 = __readfsqword(40u);\n  n = 50;\n  w = 250;\n  knapSack(wt, val, K);\n  libmin_printf(\"Max value: %d\\n\", K[50][250]);\n  libmin_printf(\"Selected packs:\\n\");\n  while (n) {\n    if (K[n][w] != K[n - 1][w]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", n, wt[n - 1],\n                    val[n - 1]);\n      w -= wt[n - 1];\n    }\n    --n;\n  }\n  libmin_printf(\"Total weight: %d\\n\", 250 - w);\n  libmin_success();\n}", "binary": "knapsack/knapsack.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    -0xc000(%rsp),%r11\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\ncmp    %r11,%rsp\njne    139e <main+0x10>\nsub    $0x820,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x32,-0xc818(%rbp)\nmovl   $0xfa,-0xc814(%rbp)\nlea    -0xc810(%rbp),%rax\nmov    %rax,%rdx\nlea    0x4c36(%rip),%rax\nmov    %rax,%rsi\nlea    0x4d0c(%rip),%rax\nmov    %rax,%rdi\ncall   1209 <knapSack>\nmov    -0xc818(%rbp),%eax\ncltq\nimul   $0x3ec,%rax,%rax\nadd    %rbp,%rax\nsub    $0xc428,%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x2be9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369b <libmin_printf>\nlea    0x2be4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369b <libmin_printf>\njmp    1511 <main+0x183>\nmov    -0xc814(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc818(%rbp),%eax\ncltq\nimul   $0xfb,%rax,%rax\nadd    %rdx,%rax\nmov    -0xc810(%rbp,%rax,4),%edx\nmov    -0xc818(%rbp),%eax\nlea    -0x1(%rax),%ecx\nmov    -0xc814(%rbp),%eax\nmovslq %eax,%rsi\nmovslq %ecx,%rax\nimul   $0xfb,%rax,%rax\nadd    %rsi,%rax\nmov    -0xc810(%rbp,%rax,4),%eax\ncmp    %eax,%edx\nje     150a <main+0x17c>\nmov    -0xc818(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4b75(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0xc818(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4c38(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0xc818(%rbp),%eax\nmov    %eax,%esi\nlea    0x2b4e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369b <libmin_printf>\nmov    -0xc818(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4bff(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nsub    %eax,-0xc814(%rbp)\nsubl   $0x1,-0xc818(%rbp)\ncmpl   $0x0,-0xc818(%rbp)\njne    1445 <main+0xb7>\nmov    $0xfa,%eax\nsub    -0xc814(%rbp),%eax\nmov    %eax,%esi\nlea    0x2b1a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   369b <libmin_printf>\ncall   3908 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     155d <main+0x1cf>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "knapsack/knapsack.c", "function_name": "max", "content": "#endif /* !PROBLEM_TINY */\n\n// A utility function that returns maximum of two integers\nint\nmax(int a, int b)\n{\n  if (a > b)\n    return a;\n  else\n    return b;\n}\n"}, "pseudo": {"path": "knapsack/knapsack.host.O0.pseudo", "function_name": "max", "address": "0x11e9", "label": "max", "content": "int __cdecl max(int a, int b)\n{\n  if ( a <= b )\n    return b;\n  else\n    return a;\n}\n"}, "pseudo_normalize": "int max(int a, int b) {\n  if (a <= b)\n    return b;\n  else\n    return a;\n}", "binary": "knapsack/knapsack.host.O0", "assembly": "<max>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njle    1204 <max+0x1b>\nmov    -0x4(%rbp),%eax\njmp    1207 <max+0x1e>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "isSafe", "content": "/* A utility function to check if i,j are valid indexes\n   for N*N chessboard */\nint\nisSafe(int x, int y, int sol[N][N])\n{\n    return ( x >= 0 && x < N && y >= 0 && y < N && sol[x][y] == -1);\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O0.pseudo", "function_name": "isSafe", "address": "0x11e9", "label": "isSafe", "content": "int __cdecl isSafe(int x, int y, int (*sol)[5])\n{\n  return (unsigned int)x <= 4 && (unsigned int)y <= 4 && (*sol)[5 * x + y] == -1;\n}\n"}, "pseudo_normalize": "", "binary": "knights-tour/knights-tour.host.O0", "assembly": "<isSafe>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %rdx,-0x10(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njs     1245 <isSafe+0x5c>\ncmpl   $0x4,-0x4(%rbp)\njg     1245 <isSafe+0x5c>\ncmpl   $0x0,-0x8(%rbp)\njs     1245 <isSafe+0x5c>\ncmpl   $0x4,-0x8(%rbp)\njg     1245 <isSafe+0x5c>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    $0xffffffff,%eax\njne    1245 <isSafe+0x5c>\nmov    $0x1,%eax\njmp    124a <isSafe+0x61>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "main", "content": "/* Driver program to test above functions */\nint\nmain(void)\n{\n    solveKT();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O0.pseudo", "function_name": "main", "address": "0x1596", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  solveKT();\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "knights-tour/knights-tour.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\ncall   12d6 <solveKT>\ncall   3958 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "printSolution", "content": "/* A utility function to print solution matrix sol[N][N] */\nvoid\nprintSolution(int sol[N][N])\n{\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++)\n            libmin_printf(\" %2d \", sol[x][y]);\n        libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O0.pseudo", "function_name": "printSolution", "address": "0x124c", "label": "printSolution", "content": "void __cdecl printSolution(int (*sol)[5])\n{\n  int x; // [rsp+18h] [rbp-8h]\n  int y; // [rsp+1Ch] [rbp-4h]\n\n  for ( x = 0; x <= 4; ++x )\n  {\n    for ( y = 0; y <= 4; ++y )\n      libmin_printf(\" %2d \", (*sol)[5 * x + y]);\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo_normalize": "void printSolution(int (*sol)[5]) {\n  int x;\n  int y;\n  for (x = 0; x <= 4; ++x) {\n    for (y = 0; y <= 4; ++y) libmin_printf(\" %2d \", (*sol)[5 * x + y]);\n    libmin_printf(\"\\n\");\n  }\n}", "binary": "knights-tour/knights-tour.host.O0", "assembly": "<printSolution>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    12cc <printSolution+0x80>\nmovl   $0x0,-0x4(%rbp)\njmp    12ae <printSolution+0x62>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\nmov    %eax,%esi\nlea    0x2d67(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36eb <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x4,-0x4(%rbp)\njle    126e <printSolution+0x22>\nlea    0x2d4f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36eb <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x4,-0x8(%rbp)\njle    1265 <printSolution+0x19>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "solveKT", "content": "/* This function solves the Knight Tour problem using\n   Backtracking.  This function mainly uses solveKTUtil()\n   to solve the problem. It returns false if no complete\n   tour is possible, otherwise return true and prints the\n   tour.\n*/\nint\nsolveKT(void)\n{\n    int sol[N][N];\n\n    /* Initialization of solution matrix */\n    for (int x = 0; x < N; x++)\n        for (int y = 0; y < N; y++)\n            sol[x][y] = -1;\n\n    /* xMove[] and yMove[] define next move of Knight.\n       xMove[] is for next value of x coordinate\n       yMove[] is for next value of y coordinate */\n    int xMove[8] = {  2, 1, -1, -2, -2, -1,  1,  2 };\n    int yMove[8] = {  1, 2,  2,  1, -1, -2, -2, -1 };\n\n    // Since the Knight is initially at the first block\n    sol[0][0]  = 0;\n\n    /* Start from 0,0 and explore all tours using\n       solveKTUtil() */\n    if (solveKTUtil(0, 0, 1, sol, xMove, yMove) == 0) {\n        libmin_printf(\"Solution does not exist\");\n        return 0;\n    }\n    else\n        printSolution(sol);\n\n    return 1;\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O0.pseudo", "function_name": "solveKT", "address": "0x12d6", "label": "solveKT", "content": "int __cdecl solveKT()\n{\n  int x; // [rsp+8h] [rbp-B8h]\n  int y; // [rsp+Ch] [rbp-B4h]\n  int xMove[8]; // [rsp+10h] [rbp-B0h] BYREF\n  int yMove[8]; // [rsp+30h] [rbp-90h] BYREF\n  int sol[5][5]; // [rsp+50h] [rbp-70h] BYREF\n  unsigned __int64 v6; // [rsp+B8h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  for ( x = 0; x <= 4; ++x )\n  {\n    for ( y = 0; y <= 4; ++y )\n      sol[x][y] = -1;\n  }\n  xMove[0] = 2;\n  xMove[1] = 1;\n  xMove[2] = -1;\n  xMove[3] = -2;\n  xMove[4] = -2;\n  xMove[5] = -1;\n  xMove[6] = 1;\n  xMove[7] = 2;\n  yMove[0] = 1;\n  yMove[1] = 2;\n  yMove[2] = 2;\n  yMove[3] = 1;\n  yMove[4] = -1;\n  yMove[5] = -2;\n  yMove[6] = -2;\n  yMove[7] = -1;\n  sol[0][0] = 0;\n  if ( solveKTUtil(0, 0, 1, sol, xMove, yMove) )\n  {\n    printSolution(sol);\n    return 1;\n  }\n  else\n  {\n    libmin_printf(\"Solution does not exist\");\n    return 0;\n  }\n}\n"}, "pseudo_normalize": "int solveKT() {\n  int x;\n  int y;\n  int xMove[8];\n  int yMove[8];\n  int sol[5][5];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  for (x = 0; x <= 4; ++x) {\n    for (y = 0; y <= 4; ++y) sol[x][y] = -1;\n  }\n  xMove[0] = 2;\n  xMove[1] = 1;\n  xMove[2] = -1;\n  xMove[3] = -2;\n  xMove[4] = -2;\n  xMove[5] = -1;\n  xMove[6] = 1;\n  xMove[7] = 2;\n  yMove[0] = 1;\n  yMove[1] = 2;\n  yMove[2] = 2;\n  yMove[3] = 1;\n  yMove[4] = -1;\n  yMove[5] = -2;\n  yMove[6] = -2;\n  yMove[7] = -1;\n  sol[0][0] = 0;\n  if (solveKTUtil(0, 0, 1, sol, xMove, yMove)) {\n    printSolution(sol);\n    return 1;\n  } else {\n    libmin_printf(\"Solution does not exist\");\n    return 0;\n  }\n}", "binary": "knights-tour/knights-tour.host.O0", "assembly": "<solveKT>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xc0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0xb8(%rbp)\njmp    134a <solveKT+0x74>\nmovl   $0x0,-0xb4(%rbp)\njmp    133a <solveKT+0x64>\nmov    -0xb4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0xb8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nmovl   $0xffffffff,-0x70(%rbp,%rax,4)\naddl   $0x1,-0xb4(%rbp)\ncmpl   $0x4,-0xb4(%rbp)\njle    130c <solveKT+0x36>\naddl   $0x1,-0xb8(%rbp)\ncmpl   $0x4,-0xb8(%rbp)\njle    1300 <solveKT+0x2a>\nmovl   $0x2,-0xb0(%rbp)\nmovl   $0x1,-0xac(%rbp)\nmovl   $0xffffffff,-0xa8(%rbp)\nmovl   $0xfffffffe,-0xa4(%rbp)\nmovl   $0xfffffffe,-0xa0(%rbp)\nmovl   $0xffffffff,-0x9c(%rbp)\nmovl   $0x1,-0x98(%rbp)\nmovl   $0x2,-0x94(%rbp)\nmovl   $0x1,-0x90(%rbp)\nmovl   $0x2,-0x8c(%rbp)\nmovl   $0x2,-0x88(%rbp)\nmovl   $0x1,-0x84(%rbp)\nmovl   $0xffffffff,-0x80(%rbp)\nmovl   $0xfffffffe,-0x7c(%rbp)\nmovl   $0xfffffffe,-0x78(%rbp)\nmovl   $0xffffffff,-0x74(%rbp)\nmovl   $0x0,-0x70(%rbp)\nlea    -0x90(%rbp),%rcx\nlea    -0xb0(%rbp),%rdx\nlea    -0x70(%rbp),%rax\nmov    %rcx,%r9\nmov    %rdx,%r8\nmov    %rax,%rcx\nmov    $0x1,%edx\nmov    $0x0,%esi\nmov    $0x0,%edi\ncall   1463 <solveKTUtil>\ntest   %eax,%eax\njne    143c <solveKT+0x166>\nlea    0x2be4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36eb <libmin_printf>\nmov    $0x0,%eax\njmp    144d <solveKT+0x177>\nlea    -0x70(%rbp),%rax\nmov    %rax,%rdi\ncall   124c <printSolution>\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1461 <solveKT+0x18b>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "solveKTUtil", "content": "/* A recursive utility function to solve Knight Tour\n   problem */\nint\nsolveKTUtil(int x, int y, int movei, int sol[N][N], int xMove[N], int yMove[N])\n{\n   int k, next_x, next_y;\n   if (movei == N*N)\n       return 1;\n\n   /* Try all next moves from the current coordinate x, y */\n   for (k = 0; k < 8; k++) {\n       next_x = x + xMove[k];\n       next_y = y + yMove[k];\n       if (isSafe(next_x, next_y, sol)) {\n         sol[next_x][next_y] = movei;\n         if (solveKTUtil(next_x, next_y, movei+1, sol, xMove, yMove) == 1)\n             return 1;\n         else\n             sol[next_x][next_y] = -1;// backtracking\n       }\n   }\n\n   return 0;\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O0.pseudo", "function_name": "solveKTUtil", "address": "0x1463", "label": "solveKTUtil", "content": "int __cdecl solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove, int *yMove)\n{\n  int k; // [rsp+34h] [rbp-Ch]\n  int next_x; // [rsp+38h] [rbp-8h]\n  int next_y; // [rsp+3Ch] [rbp-4h]\n\n  if ( movei == 25 )\n    return 1;\n  for ( k = 0; k <= 7; ++k )\n  {\n    next_x = xMove[k] + x;\n    next_y = yMove[k] + y;\n    if ( isSafe(next_x, next_y, sol) )\n    {\n      (*sol)[5 * next_x + next_y] = movei;\n      if ( solveKTUtil(next_x, next_y, movei + 1, sol, xMove, yMove) == 1 )\n        return 1;\n      (*sol)[5 * next_x + next_y] = -1;\n    }\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove,\n                int *yMove) {\n  int k;\n  int next_x;\n  int next_y;\n  if (movei == 25) return 1;\n  for (k = 0; k <= 7; ++k) {\n    next_x = xMove[k] + x;\n    next_y = yMove[k] + y;\n    if (isSafe(next_x, next_y, sol)) {\n      (*sol)[5 * next_x + next_y] = movei;\n      if (solveKTUtil(next_x, next_y, movei + 1, sol, xMove, yMove) == 1)\n        return 1;\n      (*sol)[5 * next_x + next_y] = -1;\n    }\n  }\n  return 0;\n}", "binary": "knights-tour/knights-tour.host.O0", "assembly": "<solveKTUtil>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %edx,-0x1c(%rbp)\nmov    %rcx,-0x28(%rbp)\nmov    %r8,-0x30(%rbp)\nmov    %r9,-0x38(%rbp)\ncmpl   $0x19,-0x1c(%rbp)\njne    1494 <solveKTUtil+0x31>\nmov    $0x1,%eax\njmp    1594 <solveKTUtil+0x131>\nmovl   $0x0,-0xc(%rbp)\njmp    1585 <solveKTUtil+0x122>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x4(%rbp),%ecx\nmov    -0x8(%rbp),%eax\nmov    %ecx,%esi\nmov    %eax,%edi\ncall   11e9 <isSafe>\ntest   %eax,%eax\nje     1581 <solveKTUtil+0x11e>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x4(%rbp),%eax\ncltq\nmov    -0x1c(%rbp),%edx\nmov    %edx,(%rcx,%rax,4)\nmov    -0x1c(%rbp),%eax\nlea    0x1(%rax),%edi\nmov    -0x38(%rbp),%r8\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x4(%rbp),%esi\nmov    -0x8(%rbp),%eax\nmov    %r8,%r9\nmov    %rcx,%r8\nmov    %rdx,%rcx\nmov    %edi,%edx\nmov    %eax,%edi\ncall   1463 <solveKTUtil>\ncmp    $0x1,%eax\njne    1557 <solveKTUtil+0xf4>\nmov    $0x1,%eax\njmp    1594 <solveKTUtil+0x131>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmovl   $0xffffffff,(%rdx,%rax,4)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njle    14a0 <solveKTUtil+0x3d>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "life/life.c", "function_name": "draw", "content": "void\ndraw(void)\n{\n  // go to home position on screen\n  libmin_printf(\"\\x1b[H\");\n\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", evolution++);\n  for (int y = 0; y < GRID_HEIGHT; ++y)\n    {\n      for (int x = 0; x < GRID_WIDTH; ++x)\n        libmin_printf(\"%c\", grid[x][y]);\n      libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "draw", "address": "0x1369", "label": "draw", "content": "void __cdecl draw()\n{\n  unsigned int v0; // eax\n  int y; // [rsp+8h] [rbp-8h]\n  int x; // [rsp+Ch] [rbp-4h]\n\n  libmin_printf(\"\\x1B[H\");\n  v0 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v0);\n  for ( y = 0; y <= 21; ++y )\n  {\n    for ( x = 0; x <= 69; ++x )\n      libmin_printf(\"%c\", (unsigned int)grid[x][y]);\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo_normalize": "void draw() {\n  unsigned int v0;\n  int y;\n  int x;\n  libmin_printf(\"\\x1B[H\");\n  v0 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v0);\n  for (y = 0; y <= 21; ++y) {\n    for (x = 0; x <= 69; ++x) libmin_printf(\"%c\", (unsigned int)grid[x][y]);\n    libmin_printf(\"\\n\");\n  }\n}", "binary": "life/life.host.O0", "assembly": "<draw>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nlea    0x3c91(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ad7 <libmin_printf>\nmov    0x5c89(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x5c80(%rip)\nmov    %eax,%esi\nlea    0x3c77(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ad7 <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    141c <draw+0xb3>\nmovl   $0x0,-0x4(%rbp)\njmp    13fe <draw+0x95>\nmov    0x5c59(%rip),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %eax,%esi\nlea    0x3c52(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ad7 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x45,-0x4(%rbp)\njle    13c0 <draw+0x57>\nlea    0x3c37(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ad7 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x15,-0x8(%rbp)\njle    13b7 <draw+0x4e>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "life/life.c", "function_name": "flip", "content": "void\nflip(void)\n{\n  char **tmp = grid;\n  grid = gridTmp;\n  gridTmp = tmp;\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "flip", "address": "0x16b8", "label": "flip", "content": "void __cdecl flip()\n{\n  char **tmp; // [rsp+0h] [rbp-8h]\n\n  tmp = grid;\n  grid = gridTmp;\n  gridTmp = tmp;\n}\n"}, "pseudo_normalize": "void flip() {\n  char **tmp;\n  tmp = grid;\n  grid = gridTmp;\n  gridTmp = tmp;\n}", "binary": "life/life.host.O0", "assembly": "<flip>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    0x5959(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    0x5956(%rip),%rax\nmov    %rax,0x5947(%rip)\nmov    -0x8(%rbp),%rax\nmov    %rax,0x5944(%rip)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getDown", "content": "char\ngetDown(int x, int y)\n{\n  if (y == GRID_HEIGHT - 1)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x][y + 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "getDown", "address": "0x17c8", "label": "getDown", "content": "char __cdecl getDown(int x, int y)\n{\n  if ( y == 21 )\n    return DEAD;\n  else\n    return grid[x][y + 1];\n}\n"}, "pseudo_normalize": "char getDown(int x, int y) {\n  if (y == 21)\n    return DEAD;\n  else\n    return grid[x][y + 1];\n}", "binary": "life/life.host.O0", "assembly": "<getDown>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x15,-0x18(%rbp)\njne    17e5 <getDown+0x1d>\nmovzbl 0x5832(%rip),%eax\njmp    1811 <getDown+0x49>\nmov    0x5834(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getDownLeft", "content": "char\ngetDownLeft(int x, int y)\n {\n  if (y == GRID_HEIGHT - 1 || x == 0)\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x - 1][y + 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "getDownLeft", "address": "0x18bd", "label": "getDownLeft", "content": "char __cdecl getDownLeft(int x, int y)\n{\n  if ( y != 21 && x )\n    return grid[x - 1][y + 1];\n  else\n    return DEAD;\n}\n"}, "pseudo_normalize": "char getDownLeft(int x, int y) {\n  if (y != 21 && x)\n    return grid[x - 1][y + 1];\n  else\n    return DEAD;\n}", "binary": "life/life.host.O0", "assembly": "<getDownLeft>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x15,-0x18(%rbp)\nje     18d7 <getDownLeft+0x1a>\ncmpl   $0x0,-0x14(%rbp)\njne    18e0 <getDownLeft+0x23>\nmovzbl 0x5737(%rip),%eax\njmp    1910 <getDownLeft+0x53>\nmov    0x5739(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nsub    $0x8,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getDownRight", "content": "char\ngetDownRight(int x, int y)\n{\n  if (y == GRID_HEIGHT - 1 || x == GRID_WIDTH - 1 )\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x + 1][y + 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "getDownRight", "address": "0x1912", "label": "getDownRight", "content": "char __cdecl getDownRight(int x, int y)\n{\n  if ( y == 21 || x == 69 )\n    return DEAD;\n  else\n    return grid[x + 1][y + 1];\n}\n"}, "pseudo_normalize": "char getDownRight(int x, int y) {\n  if (y == 21 || x == 69)\n    return DEAD;\n  else\n    return grid[x + 1][y + 1];\n}", "binary": "life/life.host.O0", "assembly": "<getDownRight>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x15,-0x18(%rbp)\nje     192c <getDownRight+0x1a>\ncmpl   $0x45,-0x14(%rbp)\njne    1935 <getDownRight+0x23>\nmovzbl 0x56e2(%rip),%eax\njmp    1965 <getDownRight+0x53>\nmov    0x56e4(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nadd    $0x1,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getLeft", "content": "char\ngetLeft(int x, int y)\n{\n  if (x == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x - 1][y];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "getLeft", "address": "0x16e7", "label": "getLeft", "content": "char __cdecl getLeft(int x, int y)\n{\n  if ( x )\n    return grid[x - 1][y];\n  else\n    return DEAD;\n}\n"}, "pseudo_normalize": "char getLeft(int x, int y) {\n  if (x)\n    return grid[x - 1][y];\n  else\n    return DEAD;\n}", "binary": "life/life.host.O0", "assembly": "<getLeft>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    1704 <getLeft+0x1d>\nmovzbl 0x5913(%rip),%eax\njmp    1730 <getLeft+0x49>\nmov    0x5915(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nsub    $0x8,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getNumNeigbors", "content": "int\ngetNumNeigbors(int x, int y)\n{\n  int i = 0;\n\n  if (getLeft(x, y) == LIVE)\n    i++;\n  if (getRight(x, y) == LIVE)\n    i++;\n  if (getUp(x, y) == LIVE)\n    i++;\n  if (getDown(x, y) == LIVE)\n    i++;\n  if (getUpLeft(x, y) == LIVE)\n    i++;\n  if (getUpRight(x, y) == LIVE)\n    i++;\n  if (getDownLeft(x, y) == LIVE)\n    i++;\n  if (getDownRight(x, y) == LIVE)\n    i++;\n\n  return i;\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "getNumNeigbors", "address": "0x156f", "label": "getNumNeigbors", "content": "int __cdecl getNumNeigbors(int x, int y)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  i = getLeft(x, y) == LIVE[0];\n  if ( getRight(x, y) == LIVE[0] )\n    ++i;\n  if ( getUp(x, y) == LIVE[0] )\n    ++i;\n  if ( getDown(x, y) == LIVE[0] )\n    ++i;\n  if ( getUpLeft(x, y) == LIVE[0] )\n    ++i;\n  if ( getUpRight(x, y) == LIVE[0] )\n    ++i;\n  if ( getDownLeft(x, y) == LIVE[0] )\n    ++i;\n  if ( getDownRight(x, y) == LIVE[0] )\n    ++i;\n  return i;\n}\n"}, "pseudo_normalize": "int getNumNeigbors(int x, int y) {\n  int i;\n  i = getLeft(x, y) == LIVE[0];\n  if (getRight(x, y) == LIVE[0]) ++i;\n  if (getUp(x, y) == LIVE[0]) ++i;\n  if (getDown(x, y) == LIVE[0]) ++i;\n  if (getUpLeft(x, y) == LIVE[0]) ++i;\n  if (getUpRight(x, y) == LIVE[0]) ++i;\n  if (getDownLeft(x, y) == LIVE[0]) ++i;\n  if (getDownRight(x, y) == LIVE[0]) ++i;\n  return i;\n}", "binary": "life/life.host.O0", "assembly": "<getNumNeigbors>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmovl   $0x0,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   16e7 <getLeft>\nmovzbl 0x5a76(%rip),%edx\ncmp    %dl,%al\njne    15a6 <getNumNeigbors+0x37>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1732 <getRight>\nmovzbl 0x5a58(%rip),%edx\ncmp    %dl,%al\njne    15c4 <getNumNeigbors+0x55>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   177d <getUp>\nmovzbl 0x5a3a(%rip),%edx\ncmp    %dl,%al\njne    15e2 <getNumNeigbors+0x73>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   17c8 <getDown>\nmovzbl 0x5a1c(%rip),%edx\ncmp    %dl,%al\njne    1600 <getNumNeigbors+0x91>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1813 <getUpLeft>\nmovzbl 0x59fe(%rip),%edx\ncmp    %dl,%al\njne    161e <getNumNeigbors+0xaf>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1868 <getUpRight>\nmovzbl 0x59e0(%rip),%edx\ncmp    %dl,%al\njne    163c <getNumNeigbors+0xcd>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   18bd <getDownLeft>\nmovzbl 0x59c2(%rip),%edx\ncmp    %dl,%al\njne    165a <getNumNeigbors+0xeb>\naddl   $0x1,-0x4(%rbp)\nmov    -0x18(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   1912 <getDownRight>\nmovzbl 0x59a4(%rip),%edx\ncmp    %dl,%al\njne    1678 <getNumNeigbors+0x109>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nleave\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getRight", "content": "char\ngetRight(int x, int y)\n{\n  if (x == GRID_WIDTH - 1)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x + 1][y];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "getRight", "address": "0x1732", "label": "getRight", "content": "char __cdecl getRight(int x, int y)\n{\n  if ( x == 69 )\n    return DEAD;\n  else\n    return grid[x + 1][y];\n}\n"}, "pseudo_normalize": "char getRight(int x, int y) {\n  if (x == 69)\n    return DEAD;\n  else\n    return grid[x + 1][y];\n}", "binary": "life/life.host.O0", "assembly": "<getRight>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x45,-0x14(%rbp)\njne    174f <getRight+0x1d>\nmovzbl 0x58c8(%rip),%eax\njmp    177b <getRight+0x49>\nmov    0x58ca(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getUp", "content": "char\ngetUp(int x, int y)\n{\n  if (y == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x][y - 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "getUp", "address": "0x177d", "label": "getUp", "content": "char __cdecl getUp(int x, int y)\n{\n  if ( y )\n    return grid[x][y - 1];\n  else\n    return DEAD;\n}\n"}, "pseudo_normalize": "char getUp(int x, int y) {\n  if (y)\n    return grid[x][y - 1];\n  else\n    return DEAD;\n}", "binary": "life/life.host.O0", "assembly": "<getUp>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njne    179a <getUp+0x1d>\nmovzbl 0x587d(%rip),%eax\njmp    17c6 <getUp+0x49>\nmov    0x587f(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nsub    $0x1,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getUpLeft", "content": "char\ngetUpLeft(int x, int y)\n{\n  if (x == 0 || y == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x - 1][y - 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "getUpLeft", "address": "0x1813", "label": "getUpLeft", "content": "char __cdecl getUpLeft(int x, int y)\n{\n  if ( x && y )\n    return grid[x - 1][y - 1];\n  else\n    return DEAD;\n}\n"}, "pseudo_normalize": "char getUpLeft(int x, int y) {\n  if (x && y)\n    return grid[x - 1][y - 1];\n  else\n    return DEAD;\n}", "binary": "life/life.host.O0", "assembly": "<getUpLeft>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x0,-0x14(%rbp)\nje     182d <getUpLeft+0x1a>\ncmpl   $0x0,-0x18(%rbp)\njne    1836 <getUpLeft+0x23>\nmovzbl 0x57e1(%rip),%eax\njmp    1866 <getUpLeft+0x53>\nmov    0x57e3(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x3,%rax\nsub    $0x8,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nsub    $0x1,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getUpRight", "content": "char\ngetUpRight(int x, int y)\n{\n  if (x == GRID_WIDTH - 1 || y == 0)\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x + 1][y - 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "getUpRight", "address": "0x1868", "label": "getUpRight", "content": "char __cdecl getUpRight(int x, int y)\n{\n  if ( x != 69 && y )\n    return grid[x + 1][y - 1];\n  else\n    return DEAD;\n}\n"}, "pseudo_normalize": "char getUpRight(int x, int y) {\n  if (x != 69 && y)\n    return grid[x + 1][y - 1];\n  else\n    return DEAD;\n}", "binary": "life/life.host.O0", "assembly": "<getUpRight>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x45,-0x14(%rbp)\nje     1882 <getUpRight+0x1a>\ncmpl   $0x0,-0x18(%rbp)\njne    188b <getUpRight+0x23>\nmovzbl 0x578c(%rip),%eax\njmp    18bb <getUpRight+0x53>\nmov    0x578e(%rip),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nadd    $0x1,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x18(%rbp),%eax\ncltq\nsub    $0x1,%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x1(%rbp)\nmovzbl -0x1(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "life/life.c", "function_name": "init", "content": "void\ninit(void)\n{ \n  libmin_srand(1001);\n  for (int x = 0; x < GRID_WIDTH; ++x)\n    {\n      grid[x] = gridVals[x];\n      gridTmp[x] = gridTmpVals[x];\n      for (int y = 0; y < GRID_HEIGHT; ++y)\n        {\n          grid[x][y] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n          gridTmp[x][y] = ' ';\n        }\n    }\n\n  // clear the screen\n  libmin_printf(\"\\x1b[2J\");\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "init", "address": "0x1237", "label": "init", "content": "void __cdecl init()\n{\n  int x; // [rsp+8h] [rbp-8h]\n  int y; // [rsp+Ch] [rbp-4h]\n\n  libmin_srand(0x3E9u);\n  for ( x = 0; x <= 69; ++x )\n  {\n    grid[x] = &gridVals[22 * x];\n    gridTmp[x] = &gridTmpVals[22 * x];\n    for ( y = 0; y <= 21; ++y )\n    {\n      grid[x][y] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[x][y] = 32;\n    }\n  }\n  libmin_printf(\"\\x1B[2J\");\n}\n"}, "pseudo_normalize": "void init() {\n  int x;\n  int y;\n  libmin_srand(1001u);\n  for (x = 0; x <= 69; ++x) {\n    grid[x] = &gridVals[22 * x];\n    gridTmp[x] = &gridTmpVals[22 * x];\n    for (y = 0; y <= 21; ++y) {\n      grid[x][y] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[x][y] = 32;\n    }\n  }\n  libmin_printf(\"\\x1B[2J\");\n}", "binary": "life/life.host.O0", "assembly": "<init>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x3e9,%edi\ncall   3d06 <libmin_srand>\nmovl   $0x0,-0x8(%rbp)\njmp    1348 <init+0x111>\nmov    0x5dc0(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nlea    0x6493(%rip),%rdx\nadd    %rdx,%rax\nmov    %rax,(%rcx)\nmov    0x5d8e(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nlea    0x6a79(%rip),%rdx\nadd    %rdx,%rax\nmov    %rax,(%rcx)\nmovl   $0x0,-0x4(%rbp)\njmp    133e <init+0x107>\ncall   3db8 <libmin_rand>\nmov    0x5d2f(%rip),%edx\nmov    %edx,%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%ecx\nmov    0x5d2d(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nadd    %rax,%rdx\nmov    %ecx,%ecx\nlea    0x5d03(%rip),%rax\nmovzbl (%rcx,%rax,1),%eax\nmov    %al,(%rdx)\nmov    0x5d08(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x4(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovb   $0x20,(%rax)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x15,-0x4(%rbp)\njle    12d6 <init+0x9f>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x45,-0x8(%rbp)\njle    1259 <init+0x22>\nlea    0x3caf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ad7 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "life/life.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int iters = 0;\n\n  init();\n  int running = TRUE;\n  while (running) {\n    draw();\n    //sleep(500);\n    process();\n    iters++;\n    if (iters == 80)\n      running = FALSE;\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int iters; // [rsp+8h] [rbp-8h]\n  int running; // [rsp+Ch] [rbp-4h]\n\n  iters = 0;\n  init();\n  running = 1;\n  while ( running )\n  {\n    draw();\n    process();\n    if ( ++iters == 80 )\n      running = 0;\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int iters;\n  int running;\n  iters = 0;\n  init();\n  running = 1;\n  while (running) {\n    draw();\n    process();\n    if (++iters == 80) running = 0;\n  }\n  libmin_success();\n}", "binary": "life/life.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x8(%rbp)\ncall   1237 <init>\nmovl   $0x1,-0x4(%rbp)\njmp    1225 <main+0x3c>\ncall   1369 <draw>\ncall   1426 <process>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x50,-0x8(%rbp)\njne    1225 <main+0x3c>\nmovl   $0x0,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    120a <main+0x21>\ncall   406f <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "life/life.c", "function_name": "process", "content": "void\nprocess(void)\n{\n  for (int y = 0; y < GRID_HEIGHT; ++y)\n    {\n      for (int x = 0; x < GRID_WIDTH; ++x)\n        {\n          int neighbors = getNumNeigbors(x, y);\n          if (grid[x][y] == LIVE)\n            {\n              //1. Any live cell with fewer than two live neighbors dies, as if caused by underpopulation.\n              //2. Any live cell with more than three live neighbors dies, as if by overcrowding.\n              if (neighbors < 2 || neighbors > 3)\n                gridTmp[x][y] = DEAD;\n              else\n                gridTmp[x][y] = LIVE;\n              //3. Any live cell with two or three live neighbors lives on to the next generation.\n            }\n          else\n            {\n              //4. Any dead cell with exactly three live neighbors becomes a live cell.\n              if (neighbors == 3)\n                gridTmp[x][y] = LIVE;\n              else\n                gridTmp[x][y] = DEAD;\n            }\n          processMutate(x, y);\n        }\n    }\n    flip();\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "process", "address": "0x1426", "label": "process", "content": "void __cdecl process()\n{\n  int y; // [rsp+4h] [rbp-Ch]\n  int x; // [rsp+8h] [rbp-8h]\n  int neighbors; // [rsp+Ch] [rbp-4h]\n\n  for ( y = 0; y <= 21; ++y )\n  {\n    for ( x = 0; x <= 69; ++x )\n    {\n      neighbors = getNumNeigbors(x, y);\n      if ( grid[x][y] == LIVE[0] )\n      {\n        if ( neighbors > 1 && neighbors <= 3 )\n          gridTmp[x][y] = LIVE[0];\n        else\n          gridTmp[x][y] = DEAD;\n      }\n      else if ( neighbors == 3 )\n      {\n        gridTmp[x][y] = LIVE[0];\n      }\n      else\n      {\n        gridTmp[x][y] = DEAD;\n      }\n      processMutate(x, y);\n    }\n  }\n  flip();\n}\n"}, "pseudo_normalize": "void process() {\n  int y;\n  int x;\n  int neighbors;\n  for (y = 0; y <= 21; ++y) {\n    for (x = 0; x <= 69; ++x) {\n      neighbors = getNumNeigbors(x, y);\n      if (grid[x][y] == LIVE[0]) {\n        if (neighbors > 1 && neighbors <= 3)\n          gridTmp[x][y] = LIVE[0];\n        else\n          gridTmp[x][y] = DEAD;\n      } else if (neighbors == 3) {\n        gridTmp[x][y] = LIVE[0];\n      } else {\n        gridTmp[x][y] = DEAD;\n      }\n      processMutate(x, y);\n    }\n  }\n  flip();\n}", "binary": "life/life.host.O0", "assembly": "<process>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0xc(%rbp)\njmp    155d <process+0x137>\nmovl   $0x0,-0x8(%rbp)\njmp    154f <process+0x129>\nmov    -0xc(%rbp),%edx\nmov    -0x8(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   156f <getNumNeigbors>\nmov    %eax,-0x4(%rbp)\nmov    0x5bbd(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmovzbl 0x5b90(%rip),%eax\ncmp    %al,%dl\njne    14e6 <process+0xc0>\ncmpl   $0x1,-0x4(%rbp)\njle    1494 <process+0x6e>\ncmpl   $0x3,-0x4(%rbp)\njle    14bd <process+0x97>\nmov    0x5b8d(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rax,%rdx\nmovzbl 0x5b5c(%rip),%eax\nmov    %al,(%rdx)\njmp    153c <process+0x116>\nmov    0x5b64(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rax,%rdx\nmovzbl 0x5b32(%rip),%eax\nmov    %al,(%rdx)\njmp    153c <process+0x116>\ncmpl   $0x3,-0x4(%rbp)\njne    1515 <process+0xef>\nmov    0x5b35(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rax,%rdx\nmovzbl 0x5b03(%rip),%eax\nmov    %al,(%rdx)\njmp    153c <process+0x116>\nmov    0x5b0c(%rip),%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nadd    %rax,%rdx\nmovzbl 0x5adb(%rip),%eax\nmov    %al,(%rdx)\nmov    -0xc(%rbp),%edx\nmov    -0x8(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   167d <processMutate>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x45,-0x8(%rbp)\njle    144a <process+0x24>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x15,-0xc(%rbp)\njle    143e <process+0x18>\ncall   16b8 <flip>\nnop\nleave\nret\n"}
{"source": {"path": "life/life.c", "function_name": "processMutate", "content": "void\nprocessMutate(int x, int y)\n{\n  if (libmin_rand() % 3000 > 2927)\n    {\n      if (gridTmp[x][y] == DEAD)\n        ; // gridTmp[x][y] = LIVE;\n    }\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "processMutate", "address": "0x167d", "label": "processMutate", "content": "void __cdecl processMutate(int x, int y)\n{\n  libmin_rand();\n}\n"}, "pseudo_normalize": "", "binary": "life/life.host.O0", "assembly": "<processMutate>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\ncall   3db8 <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x57619f1,%rax,%rax\nshr    $0x20,%rax\nshr    $0x6,%eax\nimul   $0xbb8,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ncmp    $0xb6f,%eax\nnop\nleave\nret\n"}
{"source": {"path": "life/life.c", "function_name": "sleep", "content": "void\nsleep(unsigned int mseconds)\n{\n  x = 0;\n  while (x < MS_DELAY)\n    x++;\n}\n"}, "pseudo": {"path": "life/life.host.O0.pseudo", "function_name": "sleep", "address": "0x1967", "label": "sleep", "content": "void __cdecl sleep(unsigned int mseconds)\n{\n  for ( x = 0; x <= 0; ++x )\n    ;\n}\n"}, "pseudo_normalize": "", "binary": "life/life.host.O0", "assembly": "<sleep>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x4(%rbp)\nmovl   $0x0,0x69c8(%rip)\njmp    198d <sleep+0x26>\nmov    0x69c0(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x69b7(%rip)\nmov    0x69b1(%rip),%eax\ntest   %eax,%eax\njle    197e <sleep+0x17>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "cut_off", "content": "/* Creates a new string by cutting the given number of characters off\n   the front of source */\n\nchar *\ncut_off(char *source, int n)\n{\n\tint k;\n\tchar *res;\n\n\tif((n <= 0)||(source == NULL))return NULL;\n\tk = libmin_strlen(source);\n\tk = ( n > k ? k : n );\n\tres = (char *)libmin_calloc(sizeof(char),(k+1));\n\tif(res == NULL){\n\t\tlibmin_printf(\"cut_off: Unable to malloc\\n\");\n\t\treturn NULL;\n\t}\n\tlibmin_strncpy(res,source,k);\n\treturn res;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O0.pseudo", "function_name": "cut_off", "address": "0x185f", "label": "cut_off", "content": "char *__cdecl cut_off(char *source, int n)\n{\n  int v3; // edx\n  int v4; // eax\n  int k; // [rsp+14h] [rbp-Ch]\n  char *res; // [rsp+18h] [rbp-8h]\n\n  if ( n <= 0 || !source )\n    return 0LL;\n  v3 = libmin_strlen(source);\n  v4 = n;\n  if ( v3 <= n )\n    v4 = v3;\n  k = v4;\n  res = (char *)libmin_calloc(1uLL, v4 + 1);\n  if ( res )\n  {\n    libmin_strncpy(res, source, k);\n    return res;\n  }\n  else\n  {\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n    return 0LL;\n  }\n}\n"}, "pseudo_normalize": "char *cut_off(char *source, int n) {\n  int v3;\n  int v4;\n  int k;\n  char *res;\n  if (n <= 0 || !source) return 0LL;\n  v3 = libmin_strlen(source);\n  v4 = n;\n  if (v3 <= n) v4 = v3;\n  k = v4;\n  res = (char *)libmin_calloc(1uLL, v4 + 1);\n  if (res) {\n    libmin_strncpy(res, source, k);\n    return res;\n  } else {\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n    return 0LL;\n  }\n}", "binary": "longdiv/longdiv.host.O0", "assembly": "<cut_off>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\njle    187f <cut_off+0x20>\ncmpq   $0x0,-0x18(%rbp)\njne    1886 <cut_off+0x27>\nmov    $0x0,%eax\njmp    18fb <cut_off+0x9c>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%edx\nmov    -0x1c(%rbp),%eax\ncmp    %eax,%edx\ncmovle %edx,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rsi\nmov    $0x1,%edi\ncall   272e <libmin_calloc>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    18de <cut_off+0x7f>\nlea    0x47d0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x0,%eax\njmp    18fb <cut_off+0x9c>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rcx\nmov    -0x8(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   4cc7 <libmin_strncpy>\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "isgte", "content": "/* Isgte: returns TRUE if first digit string is >=  the second */\n\nint\nisgte( char *A, char *B)\n{\n\tint a,b,i;\n\tchar *AA, *BB;\n\n\tif(B==NULL) return TRUE;\n\tif(A==NULL) return FALSE;\n\n/* Normalize by stripping off leading zeros */\n\n\tAA = libmin_strpbrk(A,DIGITS);\n\tBB = libmin_strpbrk(B,DIGITS);\n\n\tif(BB == NULL) return TRUE;\n\tif(AA == NULL) return FALSE;  \n\n\tif((b=libmin_strlen(BB ))>(a=libmin_strlen(AA)))return FALSE;\n\tif(a > b) return TRUE;\n\t\n\tfor(i=0;i<b;i++){\n\t\tif(AA[i]>BB[i]) return TRUE;\n\t\tif(AA[i]<BB[i]) return FALSE;\n\t}\n\treturn TRUE;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O0.pseudo", "function_name": "isgte", "address": "0x1242", "label": "isgte", "content": "int __cdecl isgte(char *A, char *B)\n{\n  int i; // [rsp+14h] [rbp-1Ch]\n  int b; // [rsp+18h] [rbp-18h]\n  int a; // [rsp+1Ch] [rbp-14h]\n  const char *AA; // [rsp+20h] [rbp-10h]\n  const char *BB; // [rsp+28h] [rbp-8h]\n\n  if ( !B )\n    return 1;\n  if ( !A )\n    return 0;\n  AA = libmin_strpbrk(A, \"123456789\");\n  BB = libmin_strpbrk(B, \"123456789\");\n  if ( !BB )\n    return 1;\n  if ( !AA )\n    return 0;\n  b = libmin_strlen(BB);\n  a = libmin_strlen(AA);\n  if ( b > a )\n    return 0;\n  if ( a > b )\n    return 1;\n  for ( i = 0; i < b; ++i )\n  {\n    if ( AA[i] > BB[i] )\n      return 1;\n    if ( AA[i] < BB[i] )\n      return 0;\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int isgte(char *A, char *B) {\n  int i;\n  int b;\n  int a;\n  const char *AA;\n  const char *BB;\n  if (!B) return 1;\n  if (!A) return 0;\n  AA = libmin_strpbrk(A, \"123456789\");\n  BB = libmin_strpbrk(B, \"123456789\");\n  if (!BB) return 1;\n  if (!AA) return 0;\n  b = libmin_strlen(BB);\n  a = libmin_strlen(AA);\n  if (b > a) return 0;\n  if (a > b) return 1;\n  for (i = 0; i < b; ++i) {\n    if (AA[i] > BB[i]) return 1;\n    if (AA[i] < BB[i]) return 0;\n  }\n  return 1;\n}", "binary": "longdiv/longdiv.host.O0", "assembly": "<isgte>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\ncmpq   $0x0,-0x30(%rbp)\njne    1267 <isgte+0x25>\nmov    $0x1,%eax\njmp    137a <isgte+0x138>\ncmpq   $0x0,-0x28(%rbp)\njne    1278 <isgte+0x36>\nmov    $0x0,%eax\njmp    137a <isgte+0x138>\nmov    -0x28(%rbp),%rax\nlea    0x4d85(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4d47 <libmin_strpbrk>\nmov    %rax,-0x10(%rbp)\nmov    -0x30(%rbp),%rax\nlea    0x4d6b(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4d47 <libmin_strpbrk>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    12bd <isgte+0x7b>\nmov    $0x1,%eax\njmp    137a <isgte+0x138>\ncmpq   $0x0,-0x10(%rbp)\njne    12ce <isgte+0x8c>\nmov    $0x0,%eax\njmp    137a <isgte+0x138>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x18(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njle    12fb <isgte+0xb9>\nmov    $0x0,%eax\njmp    137a <isgte+0x138>\nmov    -0x14(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njle    130a <isgte+0xc8>\nmov    $0x1,%eax\njmp    137a <isgte+0x138>\nmovl   $0x0,-0x1c(%rbp)\njmp    136d <isgte+0x12b>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njle    133e <isgte+0xfc>\nmov    $0x1,%eax\njmp    137a <isgte+0x138>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\ncmp    %al,%dl\njge    1369 <isgte+0x127>\nmov    $0x0,%eax\njmp    137a <isgte+0x138>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     1313 <isgte+0xd1>\nmov    $0x1,%eax\nleave\nret\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "main", "content": "int \nmain(void)\n{\n\tint dsr_len,ddnd_len;\n\tint dgts_fwd;   /* digits carried forward from previous step */\n\tint i,j,k;\n\tint step = 0;\n\tchar *quotient;\n\tchar *dsr;             /* Divisor */\n\tchar *ddnds[128];   /* Successive dividends */\n\tchar *shends[128]; /* Successive subtrahends */\n\tchar *mend;  /* Current minuend: see example below */\n\tchar *pend;  /* Points to 1st char beyond current minuend */\n\tchar *ptr;\n\n\t/* Do sanity checks on args */\n\n\tfor(i=0; i<libmin_strlen(argv[1]); i++)\n\t\tif(!isdigit(argv[1][i])){\n\t\t\tlibmin_printf(\"%s\\n%s\\n\",\"longdiv: syntax error\",\n\t\t\t\targv[1]);\n\t\t\tfor(j=0;j<i;j++)libmin_putc(' ');\n\t\t\tlibmin_putc('^');\n\t\t\tlibmin_putc('\\n');\n\t\t\treturn FALSE;\n\t\t}\n\n\tfor(i=0; i<libmin_strlen(argv[2]); i++)\n\t\tif(!isdigit(argv[2][i])){\n\t\t\tlibmin_printf(\"%s\\n%s\\n\",\"longdiv: syntax error\",\n\t\t\t\targv[2]);\n\t\t\tfor(j=0;j<i;j++)libmin_putc(' ');\n\t\t\tlibmin_putc('^');\n\t\t\tlibmin_putc('\\n');\n\t\t\treturn FALSE;\n\t\t}\n\n\t/* Make sure we're not dividing by 0 */\n\n\tj = TRUE; /* Guilty, till proven innocent */\n\tfor(i=0;i<libmin_strlen(argv[2]);i++)\n\t\tif(argv[2][i] != '0'){j = FALSE; break; }\n\tif(j){\n\t\tlibmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n\t\treturn FALSE;\n\t}\n\n\t/* OK, lookin' good */\n\t/* Save divisor and dividend */\n\n\tif((ptr = libmin_strpbrk(argv[1],DIGITS))==NULL)\n\t\t ddnd_len = 1;\n\telse \n\t   ddnd_len = libmin_strlen(ptr);\n\tddnds[0] = (char *)libmin_malloc((ddnd_len+1)*sizeof(char));\n\tif(ptr == NULL)\n\t\tlibmin_strcpy(ddnds[0],\"0\");\n\telse\n\t        libmin_strcpy(ddnds[0],ptr);\n\tptr = libmin_strpbrk(argv[2],DIGITS);\n\tdsr_len = libmin_strlen(ptr);\n\tdsr = (char *)libmin_malloc((dsr_len+1)*sizeof(char));\n\tlibmin_strcpy(dsr,ptr);\n\n\tdgts_fwd = dsr_len-1; /* Turns out to be the right initialization */\n\n\t/* Reserve space for, and properly terminate, quotient */\n\n\tquotient = (char *)libmin_calloc(sizeof(char),ddnd_len+1);\n\n\t/* stick an appropriate number of leading zeros on quotient */\n\t/* These will be stripped in the printout */\n\n\tfor(j=0;j<dsr_len-1;j++)quotient[j]='0';\n\n\t/* The algorithm breaks into steps, each of which involves a\n\t   set of trial multiplications and a subtraction. \n\t   As a try at the first minuend, we take the first n digits of\n\t   the first dividend, where n is length of the divisor. To\n\t   clarify the terminology, consider the problem:\n\n\t\t9\n          _______________________\n   3213   ) 29946712\n\t    28917\n\t    -------\n\t       29\n\t\n\tHere, the first minuend is 29546, the first subtrahend is\n\t28917, and dgts_fwd is 2.  This was step = 0.  \n        The next dividend will be 29712, and the next minuend will be gotten\n        by taking the appropriate initial string from it. \n\t*/\n\t\n        while(isgte(ddnds[step],dsr)){  /* loop until dividend shorter than\n                                             divisor. When we exit the loop,\n                                             the last dividend is the remainder\n\t\t\t\t\t*/\n\n\t  /* Determine the next minuend */\n\t  mend = cut_off(ddnds[step],++dgts_fwd);\t\n\t  while(!isgte(mend,dsr)){\n\t\tlibmin_strcat(quotient,\"0\");\n\t\tlibmin_free(mend);\n\t\tmend = cut_off(ddnds[step],++dgts_fwd);\n\t  } \n\n\t  pend = ddnds[step]+libmin_strlen(mend); /* Set pointer to rest of dividend that\n\t\t\t\t\t will be spliced on to form the\n                                         next dividend. (points to 7 in example\n\t\t\t\t\t above. */\n\n\t/* Now we do some \"trial multiplications\" to determine the next\n           digit of the quotient. */\n\n\t  for(i='9';i>='1';i--){\n\t\tshends[step] = times_digit(dsr,i);\n\t\tif(isgte(mend,shends[step]))break;\n\t\tlibmin_free(shends[step]);\n\t  }\n\n\t/* \n\t  Insert the new digit in the quotient.  \n\t*/\n\n\t  quotient[libmin_strlen(quotient)]=i;\n\n\t/* Now, subtract the current subtrahend from the current minuend,\n\t   and splice the result with pend to form the next dividend */\n\n\t  ptr = sbc(mend,shends[step]);\n\t  if(libmin_strpbrk(ptr,DIGITS)==NULL)dgts_fwd = 0;\n\t  else\n\t  \tdgts_fwd = libmin_strlen(libmin_strpbrk(ptr,DIGITS));\n\n\t/* A special situation arises here if dgts_fwd = 0 and pend\n           points to a zero: since we strip off leading zeros when defining\n           the new dividend, we would miss the need to append zero digits\n           to the quotient.\n\t*/\n\t if(dgts_fwd == 0)\n\t\twhile ((*pend == '0') && (*pend != '\\0')){\n\t\t\tlibmin_strcat(quotient,\"0\");\n\t\t\tpend++;\n\t\t} \n\t  ddnds[step+1] = libmin_strpbrk(splice(ptr,pend),\n\t\t\t\tDIGITS); \n\t  if(ddnds[step+1]==NULL){\n\t\tddnds[step+1]= libmin_malloc(2*sizeof(char));\n\t\tlibmin_strcpy(ddnds[step+1],\"0\");\n\t  }\n\t  libmin_free(mend);\n\t  step++;\n\n\t}  /* repeat with new dividend */\n\n\t/* Add any necessary trailing zeros to quotient */\n\tj = libmin_strlen(quotient);\n\tfor(i=0;i<ddnd_len - j;i++)libmin_strcat(quotient,\"0\");\n\n\t/* Calculation done. Print everything out */\n\n\t/* Print out the quotient */\n\tfor(i=0;i<dsr_len+2;i++)libmin_putc(' ');\n\tfor(;*quotient == '0';quotient++)libmin_putc(' ');\n\tlibmin_printf(\"%s\\n\",quotient);\n\n\t/* Print out the top bar */\n\t\n\tfor(i=0;i<dsr_len+2;i++)libmin_putc(' ');   /* space over */\n\tfor(i=0;i<ddnd_len;i++)libmin_putc('_');\n\n\t/* Print out divisor and dividend */\n\tlibmin_printf(\"\\n %s)%s\\n\",dsr,ddnds[0]);\n\n\tfor(i=0;i<step;i++){\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tlibmin_printf(\"%s\\n\",shends[i]);\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tfor(k=0;k<libmin_strlen(shends[i]);k++)libmin_putc('-');\n\t\tlibmin_putc('\\n');\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i+1]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tlibmin_printf(\"%s\\n\",ddnds[i+1]);\n\t}\t\n\t\t\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O0.pseudo", "function_name": "main", "address": "0x18fd", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  char *v4; // rbx\n  char *v5; // rax\n  char *v6; // rax\n  int ddnd_len; // [rsp+Ch] [rbp-864h]\n  int dgts_fwd; // [rsp+10h] [rbp-860h]\n  int dgts_fwda; // [rsp+10h] [rbp-860h]\n  int i; // [rsp+14h] [rbp-85Ch]\n  int ia; // [rsp+14h] [rbp-85Ch]\n  int ib; // [rsp+14h] [rbp-85Ch]\n  int ic; // [rsp+14h] [rbp-85Ch]\n  int id; // [rsp+14h] [rbp-85Ch]\n  int ie; // [rsp+14h] [rbp-85Ch]\n  int ig; // [rsp+14h] [rbp-85Ch]\n  int ih; // [rsp+14h] [rbp-85Ch]\n  int ii; // [rsp+14h] [rbp-85Ch]\n  int j; // [rsp+18h] [rbp-858h]\n  int ja; // [rsp+18h] [rbp-858h]\n  int jb; // [rsp+18h] [rbp-858h]\n  int jc; // [rsp+18h] [rbp-858h]\n  int jd; // [rsp+18h] [rbp-858h]\n  int je; // [rsp+18h] [rbp-858h]\n  int jf; // [rsp+18h] [rbp-858h]\n  int jg; // [rsp+18h] [rbp-858h]\n  int k; // [rsp+1Ch] [rbp-854h]\n  int step; // [rsp+20h] [rbp-850h]\n  int dsr_len; // [rsp+24h] [rbp-84Ch]\n  char *quotient; // [rsp+28h] [rbp-848h]\n  char *mend; // [rsp+30h] [rbp-840h]\n  char *pend; // [rsp+38h] [rbp-838h]\n  const char *ptr; // [rsp+40h] [rbp-830h]\n  const char *ptrb; // [rsp+40h] [rbp-830h]\n  char *ptra; // [rsp+40h] [rbp-830h]\n  char *dsr; // [rsp+48h] [rbp-828h]\n  char *ddnds[128]; // [rsp+50h] [rbp-820h]\n  char *shends[128]; // [rsp+450h] [rbp-420h]\n  unsigned __int64 v39; // [rsp+858h] [rbp-18h]\n\n  v39 = __readfsqword(0x28u);\n  step = 0;\n  for ( i = 0; i < libmin_strlen(::argv[1]); ++i )\n  {\n    if ( (pctype[::argv[1][i]] & 4) == 0 )\n    {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n      for ( j = 0; j < i; ++j )\n        libmin_putc(32);\nLABEL_6:\n      libmin_putc(94);\n      libmin_putc(10);\n      return 0;\n    }\n  }\n  for ( ia = 0; ia < libmin_strlen(::argv[2]); ++ia )\n  {\n    if ( (pctype[::argv[2][ia]] & 4) == 0 )\n    {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n      for ( ja = 0; ja < ia; ++ja )\n        libmin_putc(32);\n      goto LABEL_6;\n    }\n  }\n  jb = 1;\n  for ( ib = 0; ib < libmin_strlen(::argv[2]); ++ib )\n  {\n    if ( ::argv[2][ib] != 48 )\n    {\n      jb = 0;\n      break;\n    }\n  }\n  if ( !jb )\n  {\n    ptr = libmin_strpbrk(::argv[1], \"123456789\");\n    if ( ptr )\n      ddnd_len = libmin_strlen(ptr);\n    else\n      ddnd_len = 1;\n    ddnds[0] = (char *)libmin_malloc(ddnd_len + 1);\n    if ( ptr )\n      libmin_strcpy(ddnds[0], ptr);\n    else\n      libmin_strcpy(ddnds[0], \"0\");\n    ptrb = libmin_strpbrk(::argv[2], \"123456789\");\n    dsr_len = libmin_strlen(ptrb);\n    dsr = (char *)libmin_malloc(dsr_len + 1);\n    libmin_strcpy(dsr, ptrb);\n    dgts_fwd = dsr_len - 1;\n    quotient = (char *)libmin_calloc(1uLL, ddnd_len + 1);\n    for ( jc = 0; jc < dsr_len - 1; ++jc )\n      quotient[jc] = 48;\n    while ( isgte(ddnds[step], dsr) )\n    {\n      dgts_fwda = dgts_fwd + 1;\n      for ( mend = cut_off(ddnds[step], dgts_fwda); !isgte(mend, dsr); mend = cut_off(ddnds[step], dgts_fwda) )\n      {\n        libmin_strcat(quotient, \"0\");\n        libmin_free(mend);\n        ++dgts_fwda;\n      }\n      v4 = ddnds[step];\n      pend = &v4[libmin_strlen(mend)];\n      for ( ic = 57; ic > 48; --ic )\n      {\n        shends[step] = times_digit(dsr, ic);\n        if ( isgte(mend, shends[step]) )\n          break;\n        libmin_free(shends[step]);\n      }\n      quotient[libmin_strlen(quotient)] = ic;\n      ptra = sbc(mend, shends[step]);\n      if ( libmin_strpbrk(ptra, \"123456789\") )\n      {\n        v5 = libmin_strpbrk(ptra, \"123456789\");\n        dgts_fwd = libmin_strlen(v5);\n      }\n      else\n      {\n        dgts_fwd = 0;\n      }\n      if ( !dgts_fwd )\n      {\n        while ( *pend == 48 )\n        {\n          libmin_strcat(quotient, \"0\");\n          ++pend;\n        }\n      }\n      v6 = splice(ptra, pend);\n      ddnds[step + 1] = libmin_strpbrk(v6, \"123456789\");\n      if ( !ddnds[step + 1] )\n      {\n        ddnds[step + 1] = (char *)libmin_malloc(2uLL);\n        libmin_strcpy(ddnds[step + 1], \"0\");\n      }\n      libmin_free(mend);\n      ++step;\n    }\n    jd = libmin_strlen(quotient);\n    for ( id = 0; id < ddnd_len - jd; ++id )\n      libmin_strcat(quotient, \"0\");\n    for ( ie = 0; ie <= dsr_len + 1; ++ie )\n      libmin_putc(32);\n    while ( *quotient == 48 )\n    {\n      libmin_putc(32);\n      ++quotient;\n    }\n    libmin_printf(\"%s\\n\", quotient);\n    for ( ig = 0; ig <= dsr_len + 1; ++ig )\n      libmin_putc(32);\n    for ( ih = 0; ih < ddnd_len; ++ih )\n      libmin_putc(95);\n    libmin_printf(\"\\n %s)%s\\n\", dsr, ddnds[0]);\n    for ( ii = 0; ii < step; ++ii )\n    {\n      for ( je = 0; je < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii]); ++je )\n        libmin_putc(32);\n      libmin_printf(\"%s\\n\", shends[ii]);\n      for ( jf = 0; jf < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii]); ++jf )\n        libmin_putc(32);\n      for ( k = 0; k < libmin_strlen(shends[ii]); ++k )\n        libmin_putc(45);\n      libmin_putc(10);\n      for ( jg = 0; jg < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii + 1]); ++jg )\n        libmin_putc(32);\n      libmin_printf(\"%s\\n\", ddnds[ii + 1]);\n    }\n    libmin_success();\n  }\n  libmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n  return 0;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  char *v4;\n  char *v5;\n  char *v6;\n  int ddnd_len;\n  int dgts_fwd;\n  int dgts_fwda;\n  int i;\n  int ia;\n  int ib;\n  int ic;\n  int id;\n  int ie;\n  int ig;\n  int ih;\n  int ii;\n  int j;\n  int ja;\n  int jb;\n  int jc;\n  int jd;\n  int je;\n  int jf;\n  int jg;\n  int k;\n  int step;\n  int dsr_len;\n  char *quotient;\n  char *mend;\n  char *pend;\n  const char *ptr;\n  const char *ptrb;\n  char *ptra;\n  char *dsr;\n  char *ddnds[128];\n  char *shends[128];\n  unsigned long long v39;\n  v39 = __readfsqword(40u);\n  step = 0;\n  for (i = 0; i < libmin_strlen(::argv[1]); ++i) {\n    if ((pctype[::argv[1][i]] & 4) == 0) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n      for (j = 0; j < i; ++j) libmin_putc(32);\n    LABEL_6:\n      libmin_putc(94);\n      libmin_putc(10);\n      return 0;\n    }\n  }\n  for (ia = 0; ia < libmin_strlen(::argv[2]); ++ia) {\n    if ((pctype[::argv[2][ia]] & 4) == 0) {\n      libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n      for (ja = 0; ja < ia; ++ja) libmin_putc(32);\n      goto LABEL_6;\n    }\n  }\n  jb = 1;\n  for (ib = 0; ib < libmin_strlen(::argv[2]); ++ib) {\n    if (::argv[2][ib] != 48) {\n      jb = 0;\n      break;\n    }\n  }\n  if (!jb) {\n    ptr = libmin_strpbrk(::argv[1], \"123456789\");\n    if (ptr)\n      ddnd_len = libmin_strlen(ptr);\n    else\n      ddnd_len = 1;\n    ddnds[0] = (char *)libmin_malloc(ddnd_len + 1);\n    if (ptr)\n      libmin_strcpy(ddnds[0], ptr);\n    else\n      libmin_strcpy(ddnds[0], \"0\");\n    ptrb = libmin_strpbrk(::argv[2], \"123456789\");\n    dsr_len = libmin_strlen(ptrb);\n    dsr = (char *)libmin_malloc(dsr_len + 1);\n    libmin_strcpy(dsr, ptrb);\n    dgts_fwd = dsr_len - 1;\n    quotient = (char *)libmin_calloc(1uLL, ddnd_len + 1);\n    for (jc = 0; jc < dsr_len - 1; ++jc) quotient[jc] = 48;\n    while (isgte(ddnds[step], dsr)) {\n      dgts_fwda = dgts_fwd + 1;\n      for (mend = cut_off(ddnds[step], dgts_fwda); !isgte(mend, dsr);\n           mend = cut_off(ddnds[step], dgts_fwda)) {\n        libmin_strcat(quotient, \"0\");\n        libmin_free(mend);\n        ++dgts_fwda;\n      }\n      v4 = ddnds[step];\n      pend = &v4[libmin_strlen(mend)];\n      for (ic = 57; ic > 48; --ic) {\n        shends[step] = times_digit(dsr, ic);\n        if (isgte(mend, shends[step])) break;\n        libmin_free(shends[step]);\n      }\n      quotient[libmin_strlen(quotient)] = ic;\n      ptra = sbc(mend, shends[step]);\n      if (libmin_strpbrk(ptra, \"123456789\")) {\n        v5 = libmin_strpbrk(ptra, \"123456789\");\n        dgts_fwd = libmin_strlen(v5);\n      } else {\n        dgts_fwd = 0;\n      }\n      if (!dgts_fwd) {\n        while (*pend == 48) {\n          libmin_strcat(quotient, \"0\");\n          ++pend;\n        }\n      }\n      v6 = splice(ptra, pend);\n      ddnds[step + 1] = libmin_strpbrk(v6, \"123456789\");\n      if (!ddnds[step + 1]) {\n        ddnds[step + 1] = (char *)libmin_malloc(2uLL);\n        libmin_strcpy(ddnds[step + 1], \"0\");\n      }\n      libmin_free(mend);\n      ++step;\n    }\n    jd = libmin_strlen(quotient);\n    for (id = 0; id < ddnd_len - jd; ++id) libmin_strcat(quotient, \"0\");\n    for (ie = 0; ie <= dsr_len + 1; ++ie) libmin_putc(32);\n    while (*quotient == 48) {\n      libmin_putc(32);\n      ++quotient;\n    }\n    libmin_printf(\"%s\\n\", quotient);\n    for (ig = 0; ig <= dsr_len + 1; ++ig) libmin_putc(32);\n    for (ih = 0; ih < ddnd_len; ++ih) libmin_putc(95);\n    libmin_printf(\"\\n %s)%s\\n\", dsr, ddnds[0]);\n    for (ii = 0; ii < step; ++ii) {\n      for (je = 0; je < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii]); ++je)\n        libmin_putc(32);\n      libmin_printf(\"%s\\n\", shends[ii]);\n      for (jf = 0; jf < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii]); ++jf)\n        libmin_putc(32);\n      for (k = 0; k < libmin_strlen(shends[ii]); ++k) libmin_putc(45);\n      libmin_putc(10);\n      for (jg = 0; jg < dsr_len + 2 + ddnd_len - libmin_strlen(ddnds[ii + 1]);\n           ++jg)\n        libmin_putc(32);\n      libmin_printf(\"%s\\n\", ddnds[ii + 1]);\n    }\n    libmin_success();\n  }\n  libmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n  return 0;\n}", "binary": "longdiv/longdiv.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r12\npush   %rbx\nsub    $0x860,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x850(%rbp)\nmovl   $0x0,-0x85c(%rbp)\njmp    19e2 <main+0xe5>\nmov    0x690a(%rip),%rdx\nmov    0x66e3(%rip),%rcx\nmov    -0x85c(%rbp),%eax\ncltq\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x4,%eax\ntest   %eax,%eax\njne    19db <main+0xde>\nmov    0x66b7(%rip),%rax\nmov    %rax,%rdx\nlea    0x474e(%rip),%rax\nmov    %rax,%rsi\nlea    0x475a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmovl   $0x0,-0x858(%rbp)\njmp    19af <main+0xb2>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x858(%rbp)\nmov    -0x858(%rbp),%eax\ncmp    -0x85c(%rbp),%eax\njl     199e <main+0xa1>\nmov    $0x5e,%edi\ncall   4be3 <libmin_putc>\nmov    $0xa,%edi\ncall   4be3 <libmin_putc>\nmov    $0x0,%eax\njmp    232e <main+0xa31>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x85c(%rbp),%eax\nmovslq %eax,%rbx\nmov    0x6636(%rip),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\ncmp    %rax,%rbx\njb     1937 <main+0x3a>\nmovl   $0x0,-0x85c(%rbp)\njmp    1abd <main+0x1c0>\nmov    0x682f(%rip),%rdx\nmov    0x6610(%rip),%rcx\nmov    -0x85c(%rbp),%eax\ncltq\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbq %al,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x4,%eax\ntest   %eax,%eax\njne    1ab6 <main+0x1b9>\nmov    0x65e4(%rip),%rax\nmov    %rax,%rdx\nlea    0x4673(%rip),%rax\nmov    %rax,%rsi\nlea    0x467f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmovl   $0x0,-0x858(%rbp)\njmp    1a8a <main+0x18d>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x858(%rbp)\nmov    -0x858(%rbp),%eax\ncmp    -0x85c(%rbp),%eax\njl     1a79 <main+0x17c>\nmov    $0x5e,%edi\ncall   4be3 <libmin_putc>\nmov    $0xa,%edi\ncall   4be3 <libmin_putc>\nmov    $0x0,%eax\njmp    232e <main+0xa31>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x85c(%rbp),%eax\nmovslq %eax,%rbx\nmov    0x6563(%rip),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\ncmp    %rax,%rbx\njb     1a12 <main+0x115>\nmovl   $0x1,-0x858(%rbp)\nmovl   $0x0,-0x85c(%rbp)\njmp    1b20 <main+0x223>\nmov    0x6535(%rip),%rdx\nmov    -0x85c(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\nje     1b19 <main+0x21c>\nmovl   $0x0,-0x858(%rbp)\njmp    1b3d <main+0x240>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x85c(%rbp),%eax\nmovslq %eax,%rbx\nmov    0x6500(%rip),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\ncmp    %rax,%rbx\njb     1af4 <main+0x1f7>\ncmpl   $0x0,-0x858(%rbp)\nje     1b6e <main+0x271>\nlea    0x4599(%rip),%rax\nmov    %rax,%rsi\nlea    0x45ad(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x0,%eax\njmp    232e <main+0xa31>\nmov    0x64b3(%rip),%rax\nlea    0x448c(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4d47 <libmin_strpbrk>\nmov    %rax,-0x830(%rbp)\ncmpq   $0x0,-0x830(%rbp)\njne    1ba4 <main+0x2a7>\nmovl   $0x1,-0x864(%rbp)\njmp    1bb9 <main+0x2bc>\nmov    -0x830(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x864(%rbp)\nmov    -0x864(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x820(%rbp)\ncmpq   $0x0,-0x830(%rbp)\njne    1bf8 <main+0x2fb>\nmov    -0x820(%rbp),%rax\nlea    0x451d(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\njmp    1c11 <main+0x314>\nmov    -0x820(%rbp),%rax\nmov    -0x830(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\nmov    0x6418(%rip),%rax\nlea    0x43e9(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4d47 <libmin_strpbrk>\nmov    %rax,-0x830(%rbp)\nmov    -0x830(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x84c(%rbp)\nmov    -0x84c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x828(%rbp)\nmov    -0x830(%rbp),%rdx\nmov    -0x828(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\nmov    -0x84c(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,-0x860(%rbp)\nmov    -0x864(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rsi\nmov    $0x1,%edi\ncall   272e <libmin_calloc>\nmov    %rax,-0x848(%rbp)\nmovl   $0x0,-0x858(%rbp)\njmp    1cd0 <main+0x3d3>\nmov    -0x858(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x848(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\naddl   $0x1,-0x858(%rbp)\nmov    -0x84c(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x858(%rbp)\njl     1cb3 <main+0x3b6>\njmp    1fd0 <main+0x6d3>\naddl   $0x1,-0x860(%rbp)\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    -0x860(%rbp),%edx\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   185f <cut_off>\nmov    %rax,-0x840(%rbp)\njmp    1d6c <main+0x46f>\nmov    -0x848(%rbp),%rax\nlea    0x43e4(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c02 <libmin_strcat>\nmov    -0x840(%rbp),%rax\nmov    %rax,%rdi\ncall   263d <libmin_free>\naddl   $0x1,-0x860(%rbp)\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    -0x860(%rbp),%edx\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   185f <cut_off>\nmov    %rax,-0x840(%rbp)\nmov    -0x828(%rbp),%rdx\nmov    -0x840(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1242 <isgte>\ntest   %eax,%eax\nje     1d16 <main+0x419>\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rbx\nmov    -0x840(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nadd    %rbx,%rax\nmov    %rax,-0x838(%rbp)\nmovl   $0x39,-0x85c(%rbp)\njmp    1e2e <main+0x531>\nmov    -0x85c(%rbp),%eax\nmovsbl %al,%edx\nmov    -0x828(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   15d2 <times_digit>\nmov    -0x850(%rbp),%edx\nmovslq %edx,%rdx\nmov    %rax,-0x420(%rbp,%rdx,8)\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x420(%rbp,%rax,8),%rdx\nmov    -0x840(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1242 <isgte>\ntest   %eax,%eax\njne    1e39 <main+0x53c>\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x420(%rbp,%rax,8),%rax\nmov    %rax,%rdi\ncall   263d <libmin_free>\nsubl   $0x1,-0x85c(%rbp)\ncmpl   $0x30,-0x85c(%rbp)\njg     1dbe <main+0x4c1>\njmp    1e3a <main+0x53d>\nnop\nmov    -0x848(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    -0x848(%rbp),%rdx\nadd    %rdx,%rax\nmov    -0x85c(%rbp),%edx\nmov    %dl,(%rax)\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x420(%rbp,%rax,8),%rdx\nmov    -0x840(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   137c <sbc>\nmov    %rax,-0x830(%rbp)\nmov    -0x830(%rbp),%rax\nlea    0x4176(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4d47 <libmin_strpbrk>\ntest   %rax,%rax\njne    1eae <main+0x5b1>\nmovl   $0x0,-0x860(%rbp)\njmp    1ed5 <main+0x5d8>\nmov    -0x830(%rbp),%rax\nlea    0x414c(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4d47 <libmin_strpbrk>\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x860(%rbp)\ncmpl   $0x0,-0x860(%rbp)\njne    1f1d <main+0x620>\njmp    1f01 <main+0x604>\nmov    -0x848(%rbp),%rax\nlea    0x421a(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c02 <libmin_strcat>\naddq   $0x1,-0x838(%rbp)\nmov    -0x838(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\njne    1f1d <main+0x620>\nmov    -0x838(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    1ee0 <main+0x5e3>\nmov    -0x838(%rbp),%rdx\nmov    -0x830(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   17a8 <splice>\nmov    %rax,%rdx\nmov    -0x850(%rbp),%eax\nlea    0x1(%rax),%ebx\nlea    0x40bf(%rip),%rax\nmov    %rax,%rsi\nmov    %rdx,%rdi\ncall   4d47 <libmin_strpbrk>\nmovslq %ebx,%rdx\nmov    %rax,-0x820(%rbp,%rdx,8)\nmov    -0x850(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\ntest   %rax,%rax\njne    1fba <main+0x6bd>\nmov    -0x850(%rbp),%eax\nlea    0x1(%rax),%ebx\nmov    $0x2,%edi\ncall   2552 <libmin_malloc>\nmovslq %ebx,%rdx\nmov    %rax,-0x820(%rbp,%rdx,8)\nmov    -0x850(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nlea    0x4159(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\nmov    -0x840(%rbp),%rax\nmov    %rax,%rdi\ncall   263d <libmin_free>\naddl   $0x1,-0x850(%rbp)\nmov    -0x850(%rbp),%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    -0x828(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1242 <isgte>\ntest   %eax,%eax\njne    1ce6 <main+0x3e9>\nmov    -0x848(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x858(%rbp)\nmovl   $0x0,-0x85c(%rbp)\njmp    203b <main+0x73e>\nmov    -0x848(%rbp),%rax\nlea    0x40df(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c02 <libmin_strcat>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x864(%rbp),%eax\nsub    -0x858(%rbp),%eax\ncmp    %eax,-0x85c(%rbp)\njl     201b <main+0x71e>\nmovl   $0x0,-0x85c(%rbp)\njmp    206c <main+0x76f>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x84c(%rbp),%eax\nadd    $0x1,%eax\ncmp    %eax,-0x85c(%rbp)\njle    205b <main+0x75e>\njmp    2091 <main+0x794>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddq   $0x1,-0x848(%rbp)\nmov    -0x848(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\nje     207f <main+0x782>\nmov    -0x848(%rbp),%rax\nmov    %rax,%rsi\nlea    0x4054(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmovl   $0x0,-0x85c(%rbp)\njmp    20da <main+0x7dd>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x84c(%rbp),%eax\nadd    $0x1,%eax\ncmp    %eax,-0x85c(%rbp)\njle    20c9 <main+0x7cc>\nmovl   $0x0,-0x85c(%rbp)\njmp    2108 <main+0x80b>\nmov    $0x5f,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x85c(%rbp),%eax\ncmp    -0x864(%rbp),%eax\njl     20f7 <main+0x7fa>\nmov    -0x820(%rbp),%rdx\nmov    -0x828(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3fdc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmovl   $0x0,-0x85c(%rbp)\njmp    2312 <main+0xa15>\nmovl   $0x0,-0x858(%rbp)\njmp    2167 <main+0x86a>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x858(%rbp)\nmov    -0x858(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x84c(%rbp),%eax\nlea    0x2(%rax),%edx\nmov    -0x864(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%r12\nmov    -0x85c(%rbp),%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %rax,%rdx\nmov    %r12,%rax\nsub    %rdx,%rax\ncmp    %rax,%rbx\njb     2156 <main+0x859>\nmov    -0x85c(%rbp),%eax\ncltq\nmov    -0x420(%rbp,%rax,8),%rax\nmov    %rax,%rsi\nlea    0x3f40(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmovl   $0x0,-0x858(%rbp)\njmp    21ee <main+0x8f1>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x858(%rbp)\nmov    -0x858(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x84c(%rbp),%eax\nlea    0x2(%rax),%edx\nmov    -0x864(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%r12\nmov    -0x85c(%rbp),%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %rax,%rdx\nmov    %r12,%rax\nsub    %rdx,%rax\ncmp    %rax,%rbx\njb     21dd <main+0x8e0>\nmovl   $0x0,-0x854(%rbp)\njmp    224e <main+0x951>\nmov    $0x2d,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x854(%rbp)\nmov    -0x854(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x85c(%rbp),%eax\ncltq\nmov    -0x420(%rbp,%rax,8),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\ncmp    %rax,%rbx\njb     223d <main+0x940>\nmov    $0xa,%edi\ncall   4be3 <libmin_putc>\nmovl   $0x0,-0x858(%rbp)\njmp    229b <main+0x99e>\nmov    $0x20,%edi\ncall   4be3 <libmin_putc>\naddl   $0x1,-0x858(%rbp)\nmov    -0x858(%rbp),%eax\nmovslq %eax,%rbx\nmov    -0x84c(%rbp),%eax\nlea    0x2(%rax),%edx\nmov    -0x864(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%r12\nmov    -0x85c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %rax,%rdx\nmov    %r12,%rax\nsub    %rdx,%rax\ncmp    %rax,%rbx\njb     228a <main+0x98d>\nmov    -0x85c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    -0x820(%rbp,%rax,8),%rax\nmov    %rax,%rsi\nlea    0x3e06(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\naddl   $0x1,-0x85c(%rbp)\nmov    -0x85c(%rbp),%eax\ncmp    -0x850(%rbp),%eax\njl     214a <main+0x84d>\ncall   4d8a <libmin_success>\nmov    $0x0,%eax\nmov    -0x18(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     2342 <main+0xa45>\ncall   10b0 <__stack_chk_fail@plt>\nadd    $0x860,%rsp\npop    %rbx\npop    %r12\npop    %rbp\nret\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "sbc", "content": "\t\n\t\t \n\t\n\n/* Given character strings of digits with mend >= shend, this returns a pointer\nto the string corresponding to minuend - subtrahend. Returns NULL if\nminuend < subtrahend. Result array is padded with leading zeros.  \n*/\n\nchar *sbc(char *mend, char *shend)\n{\n\tint need_borrow = FALSE;\n\tint lm,ls,i;\n\tchar *res;\n\tchar *mnd,*p;\n\n\tif(!isgte(mend,shend))return NULL;\n\n\tlm = libmin_strlen(mend);\n\tls = libmin_strlen(shend);\n\tres = (char *)libmin_malloc(libmin_strlen(mend)+1);\n\tif(res == NULL){\n\t\tlibmin_printf(\"sbc: Unable to malloc space for result\\n\");\n\t\tlibmin_fail(1);\n\t}\n\tp = mnd = (char *)libmin_malloc(libmin_strlen(mend)+1);\n\tif(mnd == NULL){\n\t\tlibmin_printf(\"sbc: Unable to malloc\\n\");\n\t\tlibmin_fail(1);\n\t}\n\tlibmin_strcpy(mnd,mend);\n\n\t/* Fill result array with digit zero */\n\n\tfor(i=0;i<lm;i++)res[i]='0';\n\tres[lm] = '\\0';\n\n\n\tfor(i = 0; i<lm; i++){\n\t\tif (need_borrow)\n    {\n\t\t\tif(mnd[lm-i-1] == '0')\n\t\t\t\tmnd[lm-i-1] = '9'; /* need_borrow stays TRUE */\n\t\t\telse {\n\t\t\t\t--mnd[lm-i-1];\n\t\t\t\tneed_borrow = FALSE;\n\t\t\t}\n    }\n\t\tif( i < ls )\n\t\t need_borrow |= sub(mnd[lm-i-1],shend[ls-i-1],res+lm-i-1);\n\t\telse\n\t\t need_borrow |= sub(mnd[lm-i-1],'0',res+lm-i-1);\n\t}\n\t\t\n\tlibmin_free(p);\n\treturn res;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O0.pseudo", "function_name": "sbc", "address": "0x137c", "label": "sbc", "content": "char *__cdecl sbc(char *mend, char *shend)\n{\n  size_t v3; // rax\n  size_t v4; // rax\n  int need_borrow; // [rsp+18h] [rbp-28h]\n  int i; // [rsp+1Ch] [rbp-24h]\n  int ia; // [rsp+1Ch] [rbp-24h]\n  int lm; // [rsp+20h] [rbp-20h]\n  int ls; // [rsp+24h] [rbp-1Ch]\n  char *res; // [rsp+28h] [rbp-18h]\n  char *mnd; // [rsp+30h] [rbp-10h]\n\n  need_borrow = 0;\n  if ( !isgte(mend, shend) )\n    return 0LL;\n  lm = libmin_strlen(mend);\n  ls = libmin_strlen(shend);\n  v3 = libmin_strlen(mend);\n  res = (char *)libmin_malloc(v3 + 1);\n  if ( !res )\n  {\n    libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n    libmin_fail(1);\n  }\n  v4 = libmin_strlen(mend);\n  mnd = (char *)libmin_malloc(v4 + 1);\n  if ( !mnd )\n  {\n    libmin_printf(\"sbc: Unable to malloc\\n\");\n    libmin_fail(1);\n  }\n  libmin_strcpy(mnd, mend);\n  for ( i = 0; i < lm; ++i )\n    res[i] = 48;\n  res[lm] = 0;\n  for ( ia = 0; ia < lm; ++ia )\n  {\n    if ( need_borrow )\n    {\n      if ( mnd[lm - ia - 1] == 48 )\n      {\n        mnd[lm - ia - 1] = 57;\n      }\n      else\n      {\n        --mnd[lm - ia - 1];\n        need_borrow = 0;\n      }\n    }\n    if ( ia >= ls )\n      need_borrow |= sub(mnd[lm - ia - 1], 48, &res[lm - (__int64)ia - 1]);\n    else\n      need_borrow |= sub(mnd[lm - ia - 1], shend[ls - ia - 1], &res[lm - (__int64)ia - 1]);\n  }\n  libmin_free(mnd);\n  return res;\n}\n"}, "pseudo_normalize": "char *sbc(char *mend, char *shend) {\n  unsigned int v3;\n  unsigned int v4;\n  int need_borrow;\n  int i;\n  int ia;\n  int lm;\n  int ls;\n  char *res;\n  char *mnd;\n  need_borrow = 0;\n  if (!isgte(mend, shend)) return 0LL;\n  lm = libmin_strlen(mend);\n  ls = libmin_strlen(shend);\n  v3 = libmin_strlen(mend);\n  res = (char *)libmin_malloc(v3 + 1);\n  if (!res) {\n    libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n    libmin_fail(1);\n  }\n  v4 = libmin_strlen(mend);\n  mnd = (char *)libmin_malloc(v4 + 1);\n  if (!mnd) {\n    libmin_printf(\"sbc: Unable to malloc\\n\");\n    libmin_fail(1);\n  }\n  libmin_strcpy(mnd, mend);\n  for (i = 0; i < lm; ++i) res[i] = 48;\n  res[lm] = 0;\n  for (ia = 0; ia < lm; ++ia) {\n    if (need_borrow) {\n      if (mnd[lm - ia - 1] == 48) {\n        mnd[lm - ia - 1] = 57;\n      } else {\n        --mnd[lm - ia - 1];\n        need_borrow = 0;\n      }\n    }\n    if (ia >= ls)\n      need_borrow |= sub(mnd[lm - ia - 1], 48, &res[lm - (long long)ia - 1]);\n    else\n      need_borrow |= sub(mnd[lm - ia - 1], shend[ls - ia - 1],\n                         &res[lm - (long long)ia - 1]);\n  }\n  libmin_free(mnd);\n  return res;\n}", "binary": "longdiv/longdiv.host.O0", "assembly": "<sbc>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmovl   $0x0,-0x28(%rbp)\nmov    -0x40(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1242 <isgte>\ntest   %eax,%eax\njne    13b8 <sbc+0x3c>\nmov    $0x0,%eax\njmp    15d0 <sbc+0x254>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x20(%rbp)\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x1c(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nadd    $0x1,%rax\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1417 <sbc+0x9b>\nlea    0x4c18(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x1,%edi\ncall   24cf <libmin_fail>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nadd    $0x1,%rax\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    1460 <sbc+0xe4>\nlea    0x4bf7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x1,%edi\ncall   24cf <libmin_fail>\nmov    -0x38(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\nmovl   $0x0,-0x24(%rbp)\njmp    1490 <sbc+0x114>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x30,(%rax)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     147c <sbc+0x100>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0x24(%rbp)\njmp    15b4 <sbc+0x238>\ncmpl   $0x0,-0x28(%rbp)\nje     150e <sbc+0x192>\nmov    -0x20(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\njne    14ec <sbc+0x170>\nmov    -0x20(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x39,(%rax)\njmp    150e <sbc+0x192>\nmov    -0x20(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%edx\nsub    $0x1,%edx\nmov    %dl,(%rax)\nmovl   $0x0,-0x28(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njge    156f <sbc+0x1f3>\nmov    -0x20(%rbp),%eax\ncltq\nmov    -0x24(%rbp),%edx\nmovslq %edx,%rdx\nsub    %rdx,%rax\nlea    -0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rcx\nmov    -0x40(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%ecx\nmov    -0x20(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rsi\nmov    -0x10(%rbp),%rax\nadd    %rsi,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %ecx,%esi\nmov    %eax,%edi\ncall   11e9 <sub>\nor     %eax,-0x28(%rbp)\njmp    15b0 <sbc+0x234>\nmov    -0x20(%rbp),%eax\ncltq\nmov    -0x24(%rbp),%edx\nmovslq %edx,%rdx\nsub    %rdx,%rax\nlea    -0x1(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%eax\nsub    -0x24(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rcx\nmov    -0x10(%rbp),%rax\nadd    %rcx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    $0x30,%esi\nmov    %eax,%edi\ncall   11e9 <sub>\nor     %eax,-0x28(%rbp)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     14b4 <sbc+0x138>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   263d <libmin_free>\nmov    -0x18(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "splice", "content": "/* Allocates a new string consisting of front and back glued together */\n\nchar *\nsplice(char *front, char *back)\n{\n\n\tchar *res;\n\tint len;\n\n\tif(front == NULL)return back;\n\tif(back == NULL) return front;  \n\tlen = libmin_strlen(front)+libmin_strlen(back);\n\n\tres = (char *)libmin_malloc((len+1)*sizeof(char));\n\tif(res == NULL) {\n\t\tlibmin_printf(\"splice: unable to malloc\\n\");\n\t\treturn NULL;\n\t}\n\tlibmin_strcpy(res,front);\n\tlibmin_strcat(res,back);\n\treturn res;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O0.pseudo", "function_name": "splice", "address": "0x17a8", "label": "splice", "content": "char *__cdecl splice(char *front, char *back)\n{\n  int v3; // ebx\n  int len; // [rsp+14h] [rbp-1Ch]\n  char *res; // [rsp+18h] [rbp-18h]\n\n  if ( !front )\n    return back;\n  if ( !back )\n    return front;\n  v3 = libmin_strlen(front);\n  len = v3 + libmin_strlen(back);\n  res = (char *)libmin_malloc(len + 1);\n  if ( res )\n  {\n    libmin_strcpy(res, front);\n    libmin_strcat(res, back);\n    return res;\n  }\n  else\n  {\n    libmin_printf(\"splice: unable to malloc\\n\");\n    return 0LL;\n  }\n}\n"}, "pseudo_normalize": "char *splice(char *front, char *back) {\n  int v3;\n  int len;\n  char *res;\n  if (!front) return back;\n  if (!back) return front;\n  v3 = libmin_strlen(front);\n  len = v3 + libmin_strlen(back);\n  res = (char *)libmin_malloc(len + 1);\n  if (res) {\n    libmin_strcpy(res, front);\n    libmin_strcat(res, back);\n    return res;\n  } else {\n    libmin_printf(\"splice: unable to malloc\\n\");\n    return 0LL;\n  }\n}", "binary": "longdiv/longdiv.host.O0", "assembly": "<splice>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\ncmpq   $0x0,-0x28(%rbp)\njne    17cd <splice+0x25>\nmov    -0x30(%rbp),%rax\njmp    1859 <splice+0xb1>\ncmpq   $0x0,-0x30(%rbp)\njne    17da <splice+0x32>\nmov    -0x28(%rbp),%rax\njmp    1859 <splice+0xb1>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,%ebx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nadd    %ebx,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    182f <splice+0x87>\nlea    0x4865(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x0,%eax\njmp    1859 <splice+0xb1>\nmov    -0x28(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\nmov    -0x30(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c02 <libmin_strcat>\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "sub", "content": "/* longdiv.c: program to print out examples of \"long-division\" problems.\n*  (Sure wish I had one of these in grade school.)\n*\n* By Terry R. McConnell 12/97\n*\n* Usage: longdiv <dividend> <divisor>\n* Here both dividend and divisor must be positive integers. At some point\n* we should improve the program to handle decimal points, negative\n* numbers, and other bases,\n* but this should be sufficient to establish the concept.\n*\n* Dividend and divisor can be arbitrarily long, subject only to the size of\n* ARG_MAX on your system. POSIX.1 ensures that this is at least 4096 bytes.\n* I.e, this can handle REALLY LARGE division problems!\n*\n* A bit of useful terminology: \n*   dividend = that which is divided into ( = numerator ).\n*   divisor  = that which is divided by ( = denominator ).\n*   subtrahend = that which is subtracted.\n*   minuend  = that which is subtracted from.\n*/\n\n\n#define _POSIX_SOURCE\n#define USAGE \"Usage: longdiv <dividend> <divisor>\"\n#define DIGITS \"123456789\"\n\n#include \"libmin.h\"\n\n#define RADIX 10 /* Actually, base 10 is assumed at many points in the pgm,\n                    so porting this to handle other bases will involve more\n                    than just changing this define. */\n\n#define BORROW 1\n#define NO_BORROW 0\n\n\n/* The main routine is at the bottom, following a number of auxiliary\n   routines.\n*/\n\n/* Subtracts digits and stores result in res. Returns indicator of whether\n   or not borrow is needed.\n*/\n\nint\nsub( char x, char y, char *res)\n{\n\tif( x >= y){\n\t\t *res = '0' + x - y;\n\t\t return FALSE;\n\t}\n\t*res = '0' + x - y + 10;\n\treturn TRUE;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O0.pseudo", "function_name": "sub", "address": "0x11e9", "label": "sub", "content": "int __cdecl sub(char x, char y, char *res)\n{\n  if ( x < y )\n  {\n    *res = x - y + 58;\n    return 1;\n  }\n  else\n  {\n    *res = x - y + 48;\n    return 0;\n  }\n}\n"}, "pseudo_normalize": "int sub(char x, char y, char *res) {\n  if (x < y) {\n    *res = x - y + 58;\n    return 1;\n  } else {\n    *res = x - y + 48;\n    return 0;\n  }\n}", "binary": "longdiv/longdiv.host.O0", "assembly": "<sub>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%ecx\nmov    %esi,%eax\nmov    %rdx,-0x10(%rbp)\nmov    %ecx,%edx\nmov    %dl,-0x4(%rbp)\nmov    %al,-0x8(%rbp)\nmovzbl -0x4(%rbp),%eax\ncmp    -0x8(%rbp),%al\njl     1226 <sub+0x3d>\nmovzbl -0x4(%rbp),%eax\nmovzbl -0x8(%rbp),%edx\nsub    %edx,%eax\nadd    $0x30,%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %dl,(%rax)\nmov    $0x0,%eax\njmp    1240 <sub+0x57>\nmovzbl -0x4(%rbp),%eax\nmovzbl -0x8(%rbp),%edx\nsub    %edx,%eax\nadd    $0x3a,%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%rax\nmov    %dl,(%rax)\nmov    $0x1,%eax\npop    %rbp\nret\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "times_digit", "content": "/* Multiplies digit string by digit character. Returns string pointing\n   to answer. Leading zeros are removed.\n*/\n\nchar *\ntimes_digit(char *mcand, char dgt)\n{\n\n\tint i,len;\n\tint carry=0,idgt,curdgt,prod;\n\tchar *res,*tmp;\n\n\tif(mcand == NULL) return NULL;\n\n\tidgt = dgt - '0';\n\tlen = libmin_strlen(mcand);\n\ttmp = (char *)libmin_malloc(len+2);\n\tif(tmp==NULL){\n\t\tlibmin_printf(\"Unable to malloc partial product array\\n\");\n\t\tlibmin_fail(1);\n\t}\n\t\n\ttmp[len+1]='\\0';\n\n\tfor(i=0;i<len;i++){\n\t\tcurdgt = mcand[len-i-1] - '0';\n\t\tprod = curdgt*idgt + carry;\n\t\ttmp[len-i] = '0' + (prod % RADIX);\t\n\t\tcarry = prod/RADIX;\n\t}\n\ttmp[0] = '0' + carry;\n\tif(tmp[0]=='0'){\n\t\tres = (char *)libmin_malloc(len+1);\n\t\tif(res == NULL){\n\t\t\tlibmin_printf(\"Unable to malloc partial product array\\n\");\n\t\t\tlibmin_fail(1);\n\t\t}\n\t\tres[len]='\\0';\n\t\tlibmin_strcpy(res,tmp+1);\n\t\tlibmin_free(tmp);\n\t}\n\telse res = tmp;\n\treturn res;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O0.pseudo", "function_name": "times_digit", "address": "0x15d2", "label": "times_digit", "content": "char *__cdecl times_digit(char *mcand, char dgt)\n{\n  int i; // [rsp+18h] [rbp-28h]\n  int carry; // [rsp+1Ch] [rbp-24h]\n  int idgt; // [rsp+20h] [rbp-20h]\n  int len; // [rsp+24h] [rbp-1Ch]\n  int curdgt; // [rsp+28h] [rbp-18h]\n  char *res; // [rsp+30h] [rbp-10h]\n  char *tmp; // [rsp+38h] [rbp-8h]\n\n  carry = 0;\n  if ( !mcand )\n    return 0LL;\n  idgt = dgt - 48;\n  len = libmin_strlen(mcand);\n  tmp = (char *)libmin_malloc(len + 2);\n  if ( !tmp )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  tmp[len + 1] = 0;\n  for ( i = 0; i < len; ++i )\n  {\n    curdgt = mcand[len - i - 1] - 48;\n    tmp[len - i] = (char)(idgt * curdgt + carry) % 10 + 48;\n    carry = (idgt * curdgt + carry) / 10;\n  }\n  *tmp = carry + 48;\n  if ( *tmp != 48 )\n    return tmp;\n  res = (char *)libmin_malloc(len + 1);\n  if ( !res )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  res[len] = 0;\n  libmin_strcpy(res, tmp + 1);\n  libmin_free(tmp);\n  return res;\n}\n"}, "pseudo_normalize": "char *times_digit(char *mcand, char dgt) {\n  int i;\n  int carry;\n  int idgt;\n  int len;\n  int curdgt;\n  char *res;\n  char *tmp;\n  carry = 0;\n  if (!mcand) return 0LL;\n  idgt = dgt - 48;\n  len = libmin_strlen(mcand);\n  tmp = (char *)libmin_malloc(len + 2);\n  if (!tmp) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  tmp[len + 1] = 0;\n  for (i = 0; i < len; ++i) {\n    curdgt = mcand[len - i - 1] - 48;\n    tmp[len - i] = (char)(idgt * curdgt + carry) % 10 + 48;\n    carry = (idgt * curdgt + carry) / 10;\n  }\n  *tmp = carry + 48;\n  if (*tmp != 48) return tmp;\n  res = (char *)libmin_malloc(len + 1);\n  if (!res) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  res[len] = 0;\n  libmin_strcpy(res, tmp + 1);\n  libmin_free(tmp);\n  return res;\n}", "binary": "longdiv/longdiv.host.O0", "assembly": "<times_digit>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %esi,%eax\nmov    %al,-0x3c(%rbp)\nmovl   $0x0,-0x24(%rbp)\ncmpq   $0x0,-0x38(%rbp)\njne    15ff <times_digit+0x2d>\nmov    $0x0,%eax\njmp    17a6 <times_digit+0x1d4>\nmovsbl -0x3c(%rbp),%eax\nsub    $0x30,%eax\nmov    %eax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   4c89 <libmin_strlen>\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\nadd    $0x2,%eax\ncltq\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\njne    1651 <times_digit+0x7f>\nlea    0x4a1e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x1,%edi\ncall   24cf <libmin_fail>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmovl   $0x0,-0x28(%rbp)\njmp    1707 <times_digit+0x135>\nmov    -0x1c(%rbp),%eax\nsub    -0x28(%rbp),%eax\ncltq\nlea    -0x1(%rax),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nsub    $0x30,%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\nimul   -0x20(%rbp),%eax\nmov    %eax,%edx\nmov    -0x24(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %edx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%ecx\nmov    %ecx,%eax\nshl    $0x2,%eax\nadd    %ecx,%eax\nadd    %eax,%eax\nmov    %edx,%ecx\nsub    %eax,%ecx\nmov    %ecx,%eax\nlea    0x30(%rax),%ecx\nmov    -0x1c(%rbp),%eax\nsub    -0x28(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x24(%rbp)\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1670 <times_digit+0x9e>\nmov    -0x24(%rbp),%eax\nadd    $0x30,%eax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nmov    %dl,(%rax)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x30,%al\njne    179a <times_digit+0x1c8>\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   2552 <libmin_malloc>\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    1765 <times_digit+0x193>\nlea    0x490a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   49b4 <libmin_printf>\nmov    $0x1,%edi\ncall   24cf <libmin_fail>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x8(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4c3e <libmin_strcpy>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   263d <libmin_free>\njmp    17a2 <times_digit+0x1d0>\nmov    -0x8(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "lu-decomp/lu-decomp.c", "function_name": "lu_decomposition", "content": "void lu_decomposition(double A[N][N], double L[N][N], double U[N][N]) {\n    for (int i = 0; i < N; i++) {\n        // Compute U row\n        for (int k = i; k < N; k++) {\n            double sum = 0;\n            for (int j = 0; j < i; j++)\n                sum += L[i][j] * U[j][k];\n            U[i][k] = A[i][k] - sum;\n        }\n\n        // Compute L column\n        for (int k = i; k < N; k++) {\n            if (i == k)\n                L[i][i] = 1.0;\n            else {\n                double sum = 0;\n                for (int j = 0; j < i; j++)\n                    sum += L[k][j] * U[j][i];\n                L[k][i] = (A[k][i] - sum) / U[i][i];\n            }\n        }\n    }\n}\n"}, "pseudo": {"path": "lu-decomp/lu-decomp.host.O0.pseudo", "function_name": "lu_decomposition", "address": "0x12a9", "label": "lu_decomposition", "content": "void __cdecl lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5])\n{\n  int i; // [rsp+24h] [rbp-24h]\n  int k; // [rsp+28h] [rbp-20h]\n  int j; // [rsp+2Ch] [rbp-1Ch]\n  int k_0; // [rsp+30h] [rbp-18h]\n  int j_0; // [rsp+34h] [rbp-14h]\n  double sum; // [rsp+38h] [rbp-10h]\n  double sum_0; // [rsp+40h] [rbp-8h]\n\n  for ( i = 0; i <= 4; ++i )\n  {\n    for ( k = i; k <= 4; ++k )\n    {\n      sum = 0.0;\n      for ( j = 0; j < i; ++j )\n        sum = (*U)[5 * j + k] * (*L)[5 * i + j] + sum;\n      (*U)[5 * i + k] = (*A)[5 * i + k] - sum;\n    }\n    for ( k_0 = i; k_0 <= 4; ++k_0 )\n    {\n      if ( i == k_0 )\n      {\n        (*L)[5 * i + i] = 1.0;\n      }\n      else\n      {\n        sum_0 = 0.0;\n        for ( j_0 = 0; j_0 < i; ++j_0 )\n          sum_0 = (*U)[5 * j_0 + i] * (*L)[5 * k_0 + j_0] + sum_0;\n        (*L)[5 * k_0 + i] = ((*A)[5 * k_0 + i] - sum_0) / (*U)[5 * i + i];\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5]) {\n  int i;\n  int k;\n  int j;\n  int k_0;\n  int j_0;\n  double sum;\n  double sum_0;\n  for (i = 0; i <= 4; ++i) {\n    for (k = i; k <= 4; ++k) {\n      sum = 0.0;\n      for (j = 0; j < i; ++j) sum = (*U)[5 * j + k] * (*L)[5 * i + j] + sum;\n      (*U)[5 * i + k] = (*A)[5 * i + k] - sum;\n    }\n    for (k_0 = i; k_0 <= 4; ++k_0) {\n      if (i == k_0) {\n        (*L)[5 * i + i] = 1.0;\n      } else {\n        sum_0 = 0.0;\n        for (j_0 = 0; j_0 < i; ++j_0)\n          sum_0 = (*U)[5 * j_0 + i] * (*L)[5 * k_0 + j_0] + sum_0;\n        (*L)[5 * k_0 + i] = ((*A)[5 * k_0 + i] - sum_0) / (*U)[5 * i + i];\n      }\n    }\n  }\n}", "binary": "lu-decomp/lu-decomp.host.O0", "assembly": "<lu_decomposition>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmovl   $0x0,-0x24(%rbp)\njmp    1512 <lu_decomposition+0x269>\nmov    -0x24(%rbp),%eax\nmov    %eax,-0x20(%rbp)\njmp    13ad <lu_decomposition+0x104>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    134c <lu_decomposition+0xa3>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x40(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm1\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x10(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     12e6 <lu_decomposition+0x3d>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm0\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nsubsd  -0x10(%rbp),%xmm0\nmov    -0x20(%rbp),%eax\ncltq\nmovsd  %xmm0,(%rdx,%rax,8)\naddl   $0x1,-0x20(%rbp)\ncmpl   $0x4,-0x20(%rbp)\njle    12d4 <lu_decomposition+0x2b>\nmov    -0x24(%rbp),%eax\nmov    %eax,-0x18(%rbp)\njmp    1504 <lu_decomposition+0x25b>\nmov    -0x24(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njne    13ff <lu_decomposition+0x156>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x40(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x24(%rbp),%eax\ncltq\nmovsd  0x2c2b(%rip),%xmm0\nmovsd  %xmm0,(%rdx,%rax,8)\njmp    1500 <lu_decomposition+0x257>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x14(%rbp)\njmp    1477 <lu_decomposition+0x1ce>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x40(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x14(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm1\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x24(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\naddl   $0x1,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     1411 <lu_decomposition+0x168>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x24(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm0\nsubsd  -0x8(%rbp),%xmm0\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x48(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x24(%rbp),%eax\ncltq\nmovsd  (%rdx,%rax,8),%xmm1\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x40(%rbp),%rax\nadd    %rax,%rdx\ndivsd  %xmm1,%xmm0\nmov    -0x24(%rbp),%eax\ncltq\nmovsd  %xmm0,(%rdx,%rax,8)\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x4,-0x18(%rbp)\njle    13c2 <lu_decomposition+0x119>\naddl   $0x1,-0x24(%rbp)\ncmpl   $0x4,-0x24(%rbp)\njle    12c9 <lu_decomposition+0x20>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "lu-decomp/lu-decomp.c", "function_name": "main", "content": "int main() {\n    double A[N][N] = {\n        {  2.0,  -1.0,   0.0,   0.0,   0.0 },\n        { -1.0,   2.0,  -1.0,   0.0,   0.0 },\n        {  0.0,  -1.0,   2.0,  -1.0,   0.0 },\n        {  0.0,   0.0,  -1.0,   2.0,  -1.0 },\n        {  0.0,   0.0,   0.0,  -1.0,   2.0 }\n    }; // A tridiagonal symmetric positive definite matrix\n\n#if 0\n    double A[N][N] = {\n        {2.0, -1.0, -2.0},\n        {-4.0, 6.0, 3.0},\n        {-4.0, -2.0, 8.0}\n    };\n#endif\n    double L[N][N] = {0};\n    double U[N][N] = {0};\n\n    lu_decomposition(A, L, U);\n\n    print_matrix(\"A\", A);\n    print_matrix(\"L\", L);\n    print_matrix(\"U\", U);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "lu-decomp/lu-decomp.host.O0.pseudo", "function_name": "main", "address": "0x1520", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double A[5][5]; // [rsp+0h] [rbp-270h] BYREF\n  double L[5][5]; // [rsp+D0h] [rbp-1A0h] BYREF\n  double U[5][5]; // [rsp+1A0h] [rbp-D0h] BYREF\n  unsigned __int64 v6; // [rsp+268h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  A[0][0] = 2.0;\n  *(_OWORD *)&A[0][1] = 0xBFF0000000000000LL;\n  *(_OWORD *)&A[0][3] = 0uLL;\n  A[1][0] = -1.0;\n  A[1][1] = 2.0;\n  *(_OWORD *)&A[1][2] = 0xBFF0000000000000LL;\n  A[1][4] = 0.0;\n  A[2][0] = 0.0;\n  A[2][1] = -1.0;\n  A[2][2] = 2.0;\n  *(_OWORD *)&A[2][3] = 0xBFF0000000000000LL;\n  *(_OWORD *)&A[3][0] = 0uLL;\n  A[3][2] = -1.0;\n  A[3][3] = 2.0;\n  A[3][4] = -1.0;\n  memset(A[4], 0, 24);\n  A[4][3] = -1.0;\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double A[5][5];\n  double L[5][5];\n  double U[5][5];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  A[0][0] = 2.0;\n  *(long double *)&A[0][1] = 13830554455654793216LL;\n  *(long double *)&A[0][3] = 0uLL;\n  A[1][0] = -1.0;\n  A[1][1] = 2.0;\n  *(long double *)&A[1][2] = 13830554455654793216LL;\n  A[1][4] = 0.0;\n  A[2][0] = 0.0;\n  A[2][1] = -1.0;\n  A[2][2] = 2.0;\n  *(long double *)&A[2][3] = 13830554455654793216LL;\n  *(long double *)&A[3][0] = 0uLL;\n  A[3][2] = -1.0;\n  A[3][3] = 2.0;\n  A[3][4] = -1.0;\n  memset(A[4], 0, 24);\n  A[4][3] = -1.0;\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}", "binary": "lu-decomp/lu-decomp.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x270,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovsd  0x2ae2(%rip),%xmm0\nmovsd  %xmm0,-0x270(%rbp)\nmovsd  0x2ada(%rip),%xmm0\nmovsd  %xmm0,-0x268(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x260(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x258(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x250(%rbp)\nmovsd  0x2aa6(%rip),%xmm0\nmovsd  %xmm0,-0x248(%rbp)\nmovsd  0x2a8e(%rip),%xmm0\nmovsd  %xmm0,-0x240(%rbp)\nmovsd  0x2a86(%rip),%xmm0\nmovsd  %xmm0,-0x238(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x230(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x228(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x220(%rbp)\nmovsd  0x2a52(%rip),%xmm0\nmovsd  %xmm0,-0x218(%rbp)\nmovsd  0x2a3a(%rip),%xmm0\nmovsd  %xmm0,-0x210(%rbp)\nmovsd  0x2a32(%rip),%xmm0\nmovsd  %xmm0,-0x208(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x200(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x1f8(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x1f0(%rbp)\nmovsd  0x29fe(%rip),%xmm0\nmovsd  %xmm0,-0x1e8(%rbp)\nmovsd  0x29e6(%rip),%xmm0\nmovsd  %xmm0,-0x1e0(%rbp)\nmovsd  0x29de(%rip),%xmm0\nmovsd  %xmm0,-0x1d8(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x1d0(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x1c8(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x1c0(%rbp)\nmovsd  0x29aa(%rip),%xmm0\nmovsd  %xmm0,-0x1b8(%rbp)\nmovsd  0x2992(%rip),%xmm0\nmovsd  %xmm0,-0x1b0(%rbp)\nlea    -0x1a0(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x19,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nlea    -0xd0(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x19,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nlea    -0xd0(%rbp),%rdx\nlea    -0x1a0(%rbp),%rcx\nlea    -0x270(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   12a9 <lu_decomposition>\nlea    -0x270(%rbp),%rax\nmov    %rax,%rsi\nlea    0x291a(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <print_matrix>\nlea    -0x1a0(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2903(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <print_matrix>\nlea    -0xd0(%rbp),%rax\nmov    %rax,%rsi\nlea    0x28ec(%rip),%rax\nmov    %rax,%rdi\ncall   11e9 <print_matrix>\ncall   3b00 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1755 <main+0x235>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "lu-decomp/lu-decomp.c", "function_name": "print_matrix", "content": "#include \"libmin.h\"\n\n#define N 5  // Matrix size\n// #define N 3  // Matrix size\n\nvoid print_matrix(const char* name, double mat[N][N]) {\n    libmin_printf(\"%s =\\n\", name);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            libmin_printf(\"%8.4f \", mat[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "lu-decomp/lu-decomp.host.O0.pseudo", "function_name": "print_matrix", "address": "0x11e9", "label": "print_matrix", "content": "void __cdecl print_matrix(const char *name, double (*mat)[5])\n{\n  int i; // [rsp+18h] [rbp-8h]\n  int j; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"%s =\\n\", name);\n  for ( i = 0; i <= 4; ++i )\n  {\n    for ( j = 0; j <= 4; ++j )\n      libmin_printf(\"%8.4f \", (*mat)[5 * i + j]);\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void print_matrix(const char *name, double (*mat)[5]) {\n  int i;\n  int j;\n  libmin_printf(\"%s =\\n\", name);\n  for (i = 0; i <= 4; ++i) {\n    for (j = 0; j <= 4; ++j) libmin_printf(\"%8.4f \", (*mat)[5 * i + j]);\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "lu-decomp/lu-decomp.host.O0", "assembly": "<print_matrix>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2dfd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3893 <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    128c <print_matrix+0xa3>\nmovl   $0x0,-0x4(%rbp)\njmp    126e <print_matrix+0x85>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,8),%rax\nmovq   %rax,%xmm0\nlea    0x2db1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3893 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x4,-0x4(%rbp)\njle    122a <print_matrix+0x41>\nlea    0x2d9a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3893 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x4,-0x8(%rbp)\njle    1221 <print_matrix+0x38>\nlea    0x2d7c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3893 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "lz-compress/lz-compress.c", "function_name": "lz77_decompress", "content": "uint32_t lz77_decompress (uint8_t *compressed_text, uint8_t *uncompressed_text)\n{\n    uint8_t pointer_length_width;\n    uint16_t input_pointer, pointer_length, pointer_pos, pointer_length_mask;\n    uint32_t compressed_pointer, coding_pos, pointer_offset, uncompressed_size;\n\n    uncompressed_size = *((uint32_t *) compressed_text);\n    pointer_length_width = *(compressed_text + 4);\n    compressed_pointer = 5;\n\n    pointer_length_mask = (1 << pointer_length_width)- 1;\n\n\n    for(coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos)\n    {\n        input_pointer = *((uint16_t *) (compressed_text + compressed_pointer));\n        compressed_pointer += 2;\n        pointer_pos = input_pointer >> pointer_length_width;\n        pointer_length = pointer_pos ? ((input_pointer & pointer_length_mask) + 1) : 0;\n        if(pointer_pos)\n            for(pointer_offset = coding_pos - pointer_pos; pointer_length > 0; --pointer_length)\n                uncompressed_text[coding_pos++] = uncompressed_text[pointer_offset++];\n        *(uncompressed_text + coding_pos) = *(compressed_text + compressed_pointer++);\n    }\n\n    return coding_pos;\n}\n"}, "pseudo": {"path": "lz-compress/lz-compress.host.O0.pseudo", "function_name": "lz77_decompress", "address": "0x13df", "label": "lz77_decompress", "content": "uint32_t __cdecl lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text)\n{\n  uint16_t v2; // ax\n  uint32_t v3; // eax\n  uint8_t *v4; // rcx\n  uint32_t v5; // eax\n  uint32_t v6; // eax\n  uint8_t pointer_length_width; // [rsp+17h] [rbp-19h]\n  uint16_t pointer_length; // [rsp+18h] [rbp-18h]\n  uint16_t input_pointer; // [rsp+1Ch] [rbp-14h]\n  uint16_t pointer_pos; // [rsp+1Eh] [rbp-12h]\n  uint32_t compressed_pointer; // [rsp+20h] [rbp-10h]\n  uint32_t compressed_pointera; // [rsp+20h] [rbp-10h]\n  uint32_t coding_pos; // [rsp+24h] [rbp-Ch]\n  uint32_t pointer_offset; // [rsp+28h] [rbp-8h]\n  uint32_t uncompressed_size; // [rsp+2Ch] [rbp-4h]\n\n  uncompressed_size = *(_DWORD *)compressed_text;\n  pointer_length_width = compressed_text[4];\n  compressed_pointer = 5;\n  for ( coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos )\n  {\n    input_pointer = *(_WORD *)&compressed_text[compressed_pointer];\n    compressed_pointera = compressed_pointer + 2;\n    pointer_pos = (int)input_pointer >> pointer_length_width;\n    if ( pointer_pos )\n      v2 = (((1 << pointer_length_width) - 1) & input_pointer) + 1;\n    else\n      v2 = 0;\n    pointer_length = v2;\n    if ( pointer_pos )\n    {\n      pointer_offset = coding_pos - pointer_pos;\n      while ( pointer_length )\n      {\n        v3 = pointer_offset++;\n        v4 = &uncompressed_text[v3];\n        v5 = coding_pos++;\n        uncompressed_text[v5] = *v4;\n        --pointer_length;\n      }\n    }\n    v6 = compressed_pointera;\n    compressed_pointer = compressed_pointera + 1;\n    uncompressed_text[coding_pos] = compressed_text[v6];\n  }\n  return coding_pos;\n}\n"}, "pseudo_normalize": "uint32_t lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text) {\n  uint16_t v2;\n  uint32_t v3;\n  uint8_t *v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint8_t pointer_length_width;\n  uint16_t pointer_length;\n  uint16_t input_pointer;\n  uint16_t pointer_pos;\n  uint32_t compressed_pointer;\n  uint32_t compressed_pointera;\n  uint32_t coding_pos;\n  uint32_t pointer_offset;\n  uint32_t uncompressed_size;\n  uncompressed_size = *(uint32_t *)compressed_text;\n  pointer_length_width = compressed_text[4];\n  compressed_pointer = 5;\n  for (coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos) {\n    input_pointer = *(unsigned short *)&compressed_text[compressed_pointer];\n    compressed_pointera = compressed_pointer + 2;\n    pointer_pos = (int)input_pointer >> pointer_length_width;\n    if (pointer_pos)\n      v2 = (((1 << pointer_length_width) - 1) & input_pointer) + 1;\n    else\n      v2 = 0;\n    pointer_length = v2;\n    if (pointer_pos) {\n      pointer_offset = coding_pos - pointer_pos;\n      while (pointer_length) {\n        v3 = pointer_offset++;\n        v4 = &uncompressed_text[v3];\n        v5 = coding_pos++;\n        uncompressed_text[v5] = *v4;\n        --pointer_length;\n      }\n    }\n    v6 = compressed_pointera;\n    compressed_pointer = compressed_pointera + 1;\n    uncompressed_text[coding_pos] = compressed_text[v6];\n  }\n  return coding_pos;\n}", "binary": "lz-compress/lz-compress.host.O0", "assembly": "<lz77_decompress>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x28(%rbp),%rax\nmovzbl 0x4(%rax),%eax\nmov    %al,-0x19(%rbp)\nmovl   $0x5,-0x10(%rbp)\nmovzbl -0x19(%rbp),%eax\nmov    $0x1,%edx\nmov    %eax,%ecx\nshl    %cl,%edx\nmov    %edx,%eax\nsub    $0x1,%eax\nmov    %ax,-0x16(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    14e0 <lz77_decompress+0x101>\nmov    -0x10(%rbp),%edx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmov    %ax,-0x14(%rbp)\naddl   $0x2,-0x10(%rbp)\nmovzwl -0x14(%rbp),%edx\nmovzbl -0x19(%rbp),%eax\nmov    %eax,%ecx\nsar    %cl,%edx\nmov    %edx,%eax\nmov    %ax,-0x12(%rbp)\ncmpw   $0x0,-0x12(%rbp)\nje     1467 <lz77_decompress+0x88>\nmovzwl -0x14(%rbp),%eax\nand    -0x16(%rbp),%ax\nadd    $0x1,%eax\njmp    146c <lz77_decompress+0x8d>\nmov    $0x0,%eax\nmov    %ax,-0x18(%rbp)\ncmpw   $0x0,-0x12(%rbp)\nje     14bb <lz77_decompress+0xdc>\nmovzwl -0x12(%rbp),%edx\nmov    -0xc(%rbp),%eax\nsub    %edx,%eax\nmov    %eax,-0x8(%rbp)\njmp    14b4 <lz77_decompress+0xd5>\nmov    -0x8(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x8(%rbp)\nmov    %eax,%edx\nmov    -0x30(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\nmov    %eax,%edx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmovzbl (%rcx),%eax\nmov    %al,(%rdx)\nsubw   $0x1,-0x18(%rbp)\ncmpw   $0x0,-0x18(%rbp)\njne    1485 <lz77_decompress+0xa6>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\nmov    %eax,%edx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    -0xc(%rbp),%ecx\nmov    -0x30(%rbp),%rdx\nadd    %rcx,%rdx\nmovzbl (%rax),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njb     142c <lz77_decompress+0x4d>\nmov    -0xc(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "lz-compress/lz-compress.c", "function_name": "main", "content": "int main (int argc, char const *argv[])\n{\n    uint32_t compressed_size, uncompressed_size, orig_size;\n    uint8_t *compressed_text, *uncompressed_text;\n\n    libmin_mopen(infile, \"r\");\n    uncompressed_size = libmin_msize(infile);\n    libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n    uncompressed_text = libmin_malloc(uncompressed_size);\n    if((uncompressed_size != libmin_mread(uncompressed_text, uncompressed_size, infile)))\n        return 0;\n    libmin_mclose(infile);\n\n    compressed_text = libmin_malloc(MALLOC_SIZE);\n\n    for (unsigned i = 1; i < 16; ++i)\n    {\n      compressed_size = lz77_compress(uncompressed_text, uncompressed_size, compressed_text, i);\n      libmin_assert(compressed_size < MALLOC_SIZE);\n\n      orig_size = lz77_decompress(compressed_text, uncompressed_text);\n      libmin_assert(orig_size == uncompressed_size);\n\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i, compressed_size, uncompressed_size);\n    }\n\n    // output the final decompressed data\n    for (unsigned cnt=0; cnt < uncompressed_size; cnt++)\n      libmin_putc(uncompressed_text[cnt]);\n\n    libmin_success();\n}\n"}, "pseudo": {"path": "lz-compress/lz-compress.host.O0.pseudo", "function_name": "main", "address": "0x14f1", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-34h]\n  unsigned int cnt; // [rsp+20h] [rbp-30h]\n  uint32_t uncompressed_size; // [rsp+24h] [rbp-2Ch]\n  uint32_t compressed_size; // [rsp+28h] [rbp-28h]\n  uint8_t *uncompressed_text; // [rsp+30h] [rbp-20h]\n  uint8_t *compressed_text; // [rsp+38h] [rbp-18h]\n\n  libmin_mopen(infile, \"r\");\n  uncompressed_size = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n  uncompressed_text = (uint8_t *)libmin_malloc(uncompressed_size);\n  if ( uncompressed_size == libmin_mread(uncompressed_text, uncompressed_size, infile) )\n  {\n    libmin_mclose(infile);\n    compressed_text = (uint8_t *)libmin_malloc(0x40000uLL);\n    for ( i = 1; i <= 0xF; ++i )\n    {\n      compressed_size = lz77_compress(uncompressed_text, uncompressed_size, compressed_text, i);\n      if ( compressed_size > 0x3FFFF )\n        libmin_fail(1);\n      if ( lz77_decompress(compressed_text, uncompressed_text) != uncompressed_size )\n        libmin_fail(1);\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i, compressed_size, uncompressed_size);\n    }\n    for ( cnt = 0; cnt < uncompressed_size; ++cnt )\n      libmin_putc(uncompressed_text[cnt]);\n    libmin_success();\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int cnt;\n  uint32_t uncompressed_size;\n  uint32_t compressed_size;\n  uint8_t *uncompressed_text;\n  uint8_t *compressed_text;\n  libmin_mopen(infile, \"r\");\n  uncompressed_size = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n  uncompressed_text = (uint8_t *)libmin_malloc(uncompressed_size);\n  if (uncompressed_size ==\n      libmin_mread(uncompressed_text, uncompressed_size, infile)) {\n    libmin_mclose(infile);\n    compressed_text = (uint8_t *)libmin_malloc(262144uLL);\n    for (i = 1; i <= 15; ++i) {\n      compressed_size = lz77_compress(uncompressed_text, uncompressed_size,\n                                      compressed_text, i);\n      if (compressed_size > 262143) libmin_fail(1);\n      if (lz77_decompress(compressed_text, uncompressed_text) !=\n          uncompressed_size)\n        libmin_fail(1);\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i,\n                    compressed_size, uncompressed_size);\n    }\n    for (cnt = 0; cnt < uncompressed_size; ++cnt)\n      libmin_putc(uncompressed_text[cnt]);\n    libmin_success();\n  }\n  return 0;\n}", "binary": "lz-compress/lz-compress.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    0x13b34(%rip),%rax\nlea    0x10ec0(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1cac <libmin_mopen>\nmov    0x13b1b(%rip),%rax\nmov    %rax,%rdi\ncall   1db4 <libmin_msize>\nmov    %eax,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,%esi\nlea    0x10e99(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dc4 <libmin_printf>\nmov    -0x2c(%rbp),%eax\nmov    %rax,%rdi\ncall   182a <libmin_malloc>\nmov    %rax,-0x20(%rbp)\nmov    -0x2c(%rbp),%ebx\nmov    0x13ade(%rip),%rdx\nmov    -0x2c(%rbp),%ecx\nmov    -0x20(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1d06 <libmin_mread>\ncmp    %rax,%rbx\nje     1583 <main+0x92>\nmov    $0x0,%eax\njmp    165f <main+0x16e>\nmov    0x13ab6(%rip),%rax\nmov    %rax,%rdi\ncall   1b21 <libmin_mclose>\nmov    $0x40000,%edi\ncall   182a <libmin_malloc>\nmov    %rax,-0x18(%rbp)\nmovl   $0x1,-0x34(%rbp)\njmp    1623 <main+0x132>\nmov    -0x34(%rbp),%eax\nmovzbl %al,%ecx\nmov    -0x18(%rbp),%rdx\nmov    -0x2c(%rbp),%esi\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <lz77_compress>\nmov    %eax,-0x28(%rbp)\ncmpl   $0x3ffff,-0x28(%rbp)\njbe    15d8 <main+0xe7>\nmov    $0x1,%edi\ncall   17a7 <libmin_fail>\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   13df <lz77_decompress>\nmov    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\nje     1600 <main+0x10f>\nmov    $0x1,%edi\ncall   17a7 <libmin_fail>\nmov    -0x2c(%rbp),%ecx\nmov    -0x28(%rbp),%edx\nmov    -0x34(%rbp),%eax\nmov    %eax,%esi\nlea    0x10dde(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3dc4 <libmin_printf>\naddl   $0x1,-0x34(%rbp)\ncmpl   $0xf,-0x34(%rbp)\njbe    15a9 <main+0xb8>\nmovl   $0x0,-0x30(%rbp)\njmp    164d <main+0x15c>\nmov    -0x30(%rbp),%edx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %eax,%edi\ncall   3ff3 <libmin_putc>\naddl   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njb     1632 <main+0x141>\ncall   40ae <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "mandelbrot/mandelbrot.c", "function_name": "color", "content": "/**  mandel.c   by Eric R. Weeks   written 9-28-96\n **  weeks@dept.physics.upenn.edu\n **  http://dept.physics.upenn.edu/~weeks/\n **  \n **  This program is public domain, but this header must be left intact\n **  and unchanged.\n **  \n **  to compile:  cc -o mand mandel.c\n ** \n **/\n\n#include \"libmin.h\"\n\nvoid\ncolor(int red, int green, int blue)\n{\n  libmin_printf(\"<%d,%d,%d>\\n\", red, green, blue);\n}\n"}, "pseudo": {"path": "mandelbrot/mandelbrot.host.O0.pseudo", "function_name": "color", "address": "0x11e9", "label": "color", "content": "void __cdecl color(int red, int green, int blue)\n{\n  libmin_printf(\"<%d,%d,%d>\\n\", red, green, blue);\n}\n"}, "pseudo_normalize": "", "binary": "mandelbrot/mandelbrot.host.O0", "assembly": "<color>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %esi,-0x8(%rbp)\nmov    %edx,-0xc(%rbp)\nmov    -0xc(%rbp),%ecx\nmov    -0x8(%rbp),%edx\nmov    -0x4(%rbp),%eax\nmov    %eax,%esi\nlea    0x2df8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3580 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "mandelbrot/mandelbrot.c", "function_name": "main", "content": "int\nmain(void)\n{\n  double x, xx, y, cx, cy;\n  int iteration, hx, hy;\n  int itermax = 100;\t\t/* how many iterations to do\t*/\n  double magnify = 1.0;\t\t/* no magnification\t\t*/\n  int hxres = 78;\t\t/* horizonal resolution\t\t*/\n  int hyres = 48;\t\t/* vertical resolution\t\t*/\n\n  /* header for PPM output */\n  libmin_printf(\"** Mandelbrot ASCII image\\n\");\n  libmin_printf(\"** xres: %d, yres: %d\\n\", hxres, hyres);\n\n  for (hy=1; hy <= hyres; hy++)\n    {\n      for (hx=1; hx <= hxres; hx++)\n\t{\n\t  cx = (((float)hx)/((float)hxres)-0.5)/magnify*3.0-0.7;\n\t  cy = (((float)hy)/((float)hyres)-0.5)/magnify*3.0;\n\t  x = 0.0; y = 0.0;\n\n\t  for (iteration=1; iteration < itermax; iteration++)\n\t    {\n\t      xx = x*x-y*y+cx;\n\t      y = 2.0*x*y+cy;\n\t      x = xx;\n\t      if (x*x+y*y > 100.0)\n\t\titeration = 999999;\n\t    }\n\t  if (iteration < 99999)\n\t    libmin_printf(\" \");\n\t  else\n\t    libmin_printf(\"0\");\n\t}\n      libmin_printf(\"\\n\");\n    }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "mandelbrot/mandelbrot.host.O0.pseudo", "function_name": "main", "address": "0x1220", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int iteration; // [rsp+8h] [rbp-48h]\n  int hx; // [rsp+Ch] [rbp-44h]\n  int hy; // [rsp+10h] [rbp-40h]\n  double x; // [rsp+20h] [rbp-30h]\n  double y; // [rsp+28h] [rbp-28h]\n  double xx; // [rsp+48h] [rbp-8h]\n\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  for ( hy = 1; hy <= 48; ++hy )\n  {\n    for ( hx = 1; hx <= 78; ++hx )\n    {\n      x = 0.0;\n      y = 0.0;\n      for ( iteration = 1; iteration < 100; ++iteration )\n      {\n        xx = x * x - y * y + 3.0 * (((float)((float)hx / (float)78) - 0.5) / 1.0) - 0.7;\n        y = (x + x) * y + 3.0 * (((float)((float)hy / (float)48) - 0.5) / 1.0);\n        x = xx;\n        if ( y * y + xx * xx > 100.0 )\n          iteration = 999999;\n      }\n      if ( iteration > 99998 )\n        libmin_printf((char *)L\"0\\n\");\n      else\n        libmin_printf(\" \");\n    }\n    libmin_printf((char *)L\"\\n\");\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int iteration;\n  int hx;\n  int hy;\n  double x;\n  double y;\n  double xx;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  for (hy = 1; hy <= 48; ++hy) {\n    for (hx = 1; hx <= 78; ++hx) {\n      x = 0.0;\n      y = 0.0;\n      for (iteration = 1; iteration < 100; ++iteration) {\n        xx = x * x - y * y +\n             3.0 * (((float)((float)hx / (float)78) - 0.5) / 1.0) - 0.7;\n        y = (x + x) * y + 3.0 * (((float)((float)hy / (float)48) - 0.5) / 1.0);\n        x = xx;\n        if (y * y + xx * xx > 100.0) iteration = 999999;\n      }\n      if (iteration > 99998)\n        libmin_printf((char *)L\"0\\n\");\n      else\n        libmin_printf(\" \");\n    }\n    libmin_printf((char *)L\"\\n\");\n  }\n  libmin_success();\n}", "binary": "mandelbrot/mandelbrot.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmovl   $0x64,-0x3c(%rbp)\nmovsd  0x2e15(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovl   $0x4e,-0x38(%rbp)\nmovl   $0x30,-0x34(%rbp)\nlea    0x2dbf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3580 <libmin_printf>\nmov    -0x34(%rbp),%edx\nmov    -0x38(%rbp),%eax\nmov    %eax,%esi\nlea    0x2dbe(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3580 <libmin_printf>\nmovl   $0x1,-0x40(%rbp)\njmp    142c <main+0x20c>\nmovl   $0x1,-0x44(%rbp)\njmp    1408 <main+0x1e8>\npxor   %xmm0,%xmm0\ncvtsi2ssl -0x44(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncvtsi2ssl -0x38(%rbp),%xmm1\ndivss  %xmm1,%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0x2da0(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\ndivsd  -0x20(%rbp),%xmm1\nmovsd  0x2d93(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  0x2d8f(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2ssl -0x40(%rbp),%xmm0\npxor   %xmm1,%xmm1\ncvtsi2ssl -0x34(%rbp),%xmm1\ndivss  %xmm1,%xmm0\ncvtss2sd %xmm0,%xmm0\nmovsd  0x2d54(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\ndivsd  -0x20(%rbp),%xmm1\nmovsd  0x2d47(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovl   $0x1,-0x48(%rbp)\njmp    13c5 <main+0x1a5>\nmovsd  -0x30(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x28(%rbp),%xmm0\nmovapd %xmm0,%xmm2\nmulsd  %xmm0,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm1,%xmm0\nmovsd  -0x18(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x30(%rbp),%xmm0\naddsd  %xmm0,%xmm0\nmulsd  -0x28(%rbp),%xmm0\nmovsd  -0x10(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  -0x30(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x28(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncomisd 0x2cb8(%rip),%xmm0\njbe    13c1 <main+0x1a1>\nmovl   $0xf423f,-0x48(%rbp)\naddl   $0x1,-0x48(%rbp)\nmov    -0x48(%rbp),%eax\ncmp    -0x3c(%rbp),%eax\njl     1340 <main+0x120>\ncmpl   $0x1869e,-0x48(%rbp)\njg     13f0 <main+0x1d0>\nlea    0x2c65(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3580 <libmin_printf>\njmp    1404 <main+0x1e4>\nlea    0x2c51(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3580 <libmin_printf>\naddl   $0x1,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncmp    -0x38(%rbp),%eax\njle    1296 <main+0x76>\nlea    0x2c2f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3580 <libmin_printf>\naddl   $0x1,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njle    128a <main+0x6a>\ncall   37ed <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "matmult/matmult.c", "function_name": "main", "content": "   // Reference result using an alternative loop order (order: i, k, j)\n\nint main() {\n    // Initialize random seed\n    libmin_srand(12345);\n\n    // Initialize matrices A and B with random data; zero out C and refC\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            // Use modulo to restrict the range of random numbers (0..99)\n            A[i][j] = libmin_rand() % 1000;\n            B[i][j] = libmin_rand() % 1000;\n            C[i][j] = 0;\n            refC[i][j] = 0;\n        }\n    }\n\n    // --- First Multiplication: Loop order (i, j, k) ---\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    // --- Second Multiplication (Reference): Loop order (i, k, j) ---\n    for (int i = 0; i < N; i++) {\n        for (int k = 0; k < N; k++) {\n            for (int j = 0; j < N; j++) {\n                refC[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    // --- Verification: Compare C and refC ---\n    int error = 0;\n    for (int i = 0; i < N && !error; i++) {\n        for (int j = 0; j < N && !error; j++) {\n            if (C[i][j] != refC[i][j]) {\n                libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", \n                                i, j, C[i][j], refC[i][j]);\n                error = 1;\n            }\n        }\n    }\n\n    // --- Final Reporting ---\n    if (error) {\n        // If an error is detected, print a failure message.\n        libtarg_fail(1);\n    } else {\n        // Compute a checksum of the result matrix for quick verification.\n        int checksum = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                checksum = (checksum + C[i][j]) % 100000;\n            }\n        }\n        libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", checksum);\n        \n        // Print the computed result matrix.\n        libmin_printf(\"Result Matrix C:\\n\");\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                libmin_printf(\"%d \", C[i][j]);\n            }\n            libmin_printf(\"\\n\");\n        }\n        \n        libtarg_success();\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "matmult/matmult.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-40h]\n  int j; // [rsp+4h] [rbp-3Ch]\n  int i_0; // [rsp+8h] [rbp-38h]\n  int j_0; // [rsp+Ch] [rbp-34h]\n  int k; // [rsp+10h] [rbp-30h]\n  int i_1; // [rsp+14h] [rbp-2Ch]\n  int k_0; // [rsp+18h] [rbp-28h]\n  int j_1; // [rsp+1Ch] [rbp-24h]\n  int error; // [rsp+20h] [rbp-20h]\n  int i_2; // [rsp+24h] [rbp-1Ch]\n  int j_2; // [rsp+28h] [rbp-18h]\n  int checksum; // [rsp+2Ch] [rbp-14h]\n  int i_3; // [rsp+30h] [rbp-10h]\n  int j_3; // [rsp+34h] [rbp-Ch]\n  int i_4; // [rsp+38h] [rbp-8h]\n  int j_4; // [rsp+3Ch] [rbp-4h]\n\n  libmin_srand(0x3039u);\n  for ( i = 0; i <= 63; ++i )\n  {\n    for ( j = 0; j <= 63; ++j )\n    {\n      A[(__int64)i][j] = libmin_rand() % 0x3E8;\n      B[(__int64)i][j] = libmin_rand() % 0x3E8;\n      C[(__int64)i][j] = 0;\n      refC[(__int64)i][j] = 0;\n    }\n  }\n  for ( i_0 = 0; i_0 <= 63; ++i_0 )\n  {\n    for ( j_0 = 0; j_0 <= 63; ++j_0 )\n    {\n      for ( k = 0; k <= 63; ++k )\n        C[(__int64)i_0][j_0] += A[(__int64)i_0][k] * B[(__int64)k][j_0];\n    }\n  }\n  for ( i_1 = 0; i_1 <= 63; ++i_1 )\n  {\n    for ( k_0 = 0; k_0 <= 63; ++k_0 )\n    {\n      for ( j_1 = 0; j_1 <= 63; ++j_1 )\n        refC[(__int64)i_1][j_1] += A[(__int64)i_1][k_0] * B[(__int64)k_0][j_1];\n    }\n  }\n  error = 0;\n  for ( i_2 = 0; i_2 <= 63 && !error; ++i_2 )\n  {\n    for ( j_2 = 0; j_2 <= 63 && !error; ++j_2 )\n    {\n      if ( C[(__int64)i_2][j_2] != refC[(__int64)i_2][j_2] )\n      {\n        libmin_printf(\n          \"Mismatch at (%d, %d): computed %d, expected %d\\n\",\n          i_2,\n          j_2,\n          C[(__int64)i_2][j_2],\n          refC[(__int64)i_2][j_2]);\n        error = 1;\n      }\n    }\n  }\n  if ( error )\n    libtarg_fail(1);\n  checksum = 0;\n  for ( i_3 = 0; i_3 <= 63; ++i_3 )\n  {\n    for ( j_3 = 0; j_3 <= 63; ++j_3 )\n      checksum = (C[(__int64)i_3][j_3] + checksum) % 100000;\n  }\n  libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", checksum);\n  libmin_printf(\"Result Matrix C:\\n\");\n  for ( i_4 = 0; i_4 <= 63; ++i_4 )\n  {\n    for ( j_4 = 0; j_4 <= 63; ++j_4 )\n      libmin_printf(\"%d \", C[(__int64)i_4][j_4]);\n    libmin_printf(\"\\n\");\n  }\n  libtarg_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int j;\n  int i_0;\n  int j_0;\n  int k;\n  int i_1;\n  int k_0;\n  int j_1;\n  int error;\n  int i_2;\n  int j_2;\n  int checksum;\n  int i_3;\n  int j_3;\n  int i_4;\n  int j_4;\n  libmin_srand(12345u);\n  for (i = 0; i <= 63; ++i) {\n    for (j = 0; j <= 63; ++j) {\n      A[(long long)i][j] = libmin_rand() % 1000;\n      B[(long long)i][j] = libmin_rand() % 1000;\n      C[(long long)i][j] = 0;\n      refC[(long long)i][j] = 0;\n    }\n  }\n  for (i_0 = 0; i_0 <= 63; ++i_0) {\n    for (j_0 = 0; j_0 <= 63; ++j_0) {\n      for (k = 0; k <= 63; ++k)\n        C[(long long)i_0][j_0] += A[(long long)i_0][k] * B[(long long)k][j_0];\n    }\n  }\n  for (i_1 = 0; i_1 <= 63; ++i_1) {\n    for (k_0 = 0; k_0 <= 63; ++k_0) {\n      for (j_1 = 0; j_1 <= 63; ++j_1)\n        refC[(long long)i_1][j_1] +=\n            A[(long long)i_1][k_0] * B[(long long)k_0][j_1];\n    }\n  }\n  error = 0;\n  for (i_2 = 0; i_2 <= 63 && !error; ++i_2) {\n    for (j_2 = 0; j_2 <= 63 && !error; ++j_2) {\n      if (C[(long long)i_2][j_2] != refC[(long long)i_2][j_2]) {\n        libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", i_2,\n                      j_2, C[(long long)i_2][j_2], refC[(long long)i_2][j_2]);\n        error = 1;\n      }\n    }\n  }\n  if (error) libtarg_fail(1);\n  checksum = 0;\n  for (i_3 = 0; i_3 <= 63; ++i_3) {\n    for (j_3 = 0; j_3 <= 63; ++j_3)\n      checksum = (C[(long long)i_3][j_3] + checksum) % 100000;\n  }\n  libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", checksum);\n  libmin_printf(\"Result Matrix C:\\n\");\n  for (i_4 = 0; i_4 <= 63; ++i_4) {\n    for (j_4 = 0; j_4 <= 63; ++j_4)\n      libmin_printf(\"%d \", C[(long long)i_4][j_4]);\n    libmin_printf(\"\\n\");\n  }\n  libtarg_success();\n}", "binary": "matmult/matmult.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    $0x3039,%edi\ncall   3a7a <libmin_srand>\nmovl   $0x0,-0x40(%rbp)\njmp    1307 <main+0x11e>\nmovl   $0x0,-0x3c(%rbp)\njmp    12f9 <main+0x110>\ncall   3b2c <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x10624dd3,%rax,%rax\nshr    $0x20,%rax\nshr    $0x6,%eax\nimul   $0x3e8,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,%ecx\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x40(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x5025(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\ncall   3b2c <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x10624dd3,%rax,%rax\nshr    $0x20,%rax\nshr    $0x6,%eax\nimul   $0x3e8,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,%ecx\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x40(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x8fde(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x40(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xcfba(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x40(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x10f92(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x3f,-0x3c(%rbp)\njle    1217 <main+0x2e>\naddl   $0x1,-0x40(%rbp)\ncmpl   $0x3f,-0x40(%rbp)\njle    120b <main+0x22>\nmovl   $0x0,-0x38(%rbp)\njmp    13eb <main+0x202>\nmovl   $0x0,-0x34(%rbp)\njmp    13dd <main+0x1f4>\nmovl   $0x0,-0x30(%rbp)\njmp    13cf <main+0x1e6>\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xcf2a(%rip),%rax\nmov    (%rdx,%rax,1),%esi\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f06(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x30(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x8ee2(%rip),%rax\nmov    (%rcx,%rax,1),%eax\nimul   %edx,%eax\nlea    (%rsi,%rax,1),%ecx\nmov    -0x34(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xceb8(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x30(%rbp)\ncmpl   $0x3f,-0x30(%rbp)\njle    1335 <main+0x14c>\naddl   $0x1,-0x34(%rbp)\ncmpl   $0x3f,-0x34(%rbp)\njle    1329 <main+0x140>\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x3f,-0x38(%rbp)\njle    131d <main+0x134>\nmovl   $0x0,-0x2c(%rbp)\njmp    14cf <main+0x2e6>\nmovl   $0x0,-0x28(%rbp)\njmp    14c1 <main+0x2d8>\nmovl   $0x0,-0x24(%rbp)\njmp    14b3 <main+0x2ca>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x10e46(%rip),%rax\nmov    (%rdx,%rax,1),%esi\nmov    -0x28(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4e22(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x28(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x8dfe(%rip),%rax\nmov    (%rcx,%rax,1),%eax\nimul   %edx,%eax\nlea    (%rsi,%rax,1),%ecx\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x10dd4(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x24(%rbp)\ncmpl   $0x3f,-0x24(%rbp)\njle    1419 <main+0x230>\naddl   $0x1,-0x28(%rbp)\ncmpl   $0x3f,-0x28(%rbp)\njle    140d <main+0x224>\naddl   $0x1,-0x2c(%rbp)\ncmpl   $0x3f,-0x2c(%rbp)\njle    1401 <main+0x218>\nmovl   $0x0,-0x20(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    15ca <main+0x3e1>\nmovl   $0x0,-0x18(%rbp)\njmp    15b6 <main+0x3cd>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xcd67(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x10d43(%rip),%rax\nmov    (%rcx,%rax,1),%eax\ncmp    %eax,%edx\nje     15b2 <main+0x3c9>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x10d1b(%rip),%rax\nmov    (%rdx,%rax,1),%esi\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xccf7(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0x18(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nmov    %esi,%r8d\nmov    %eax,%esi\nlea    0x2a6a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   384b <libmin_printf>\nmovl   $0x1,-0x20(%rbp)\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x3f,-0x18(%rbp)\njg     15c6 <main+0x3dd>\ncmpl   $0x0,-0x20(%rbp)\nje     14f8 <main+0x30f>\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x3f,-0x1c(%rbp)\njg     15da <main+0x3f1>\ncmpl   $0x0,-0x20(%rbp)\nje     14ec <main+0x303>\ncmpl   $0x0,-0x20(%rbp)\nje     15ea <main+0x401>\nmov    $0x1,%edi\ncall   1721 <libtarg_fail>\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1663 <main+0x47a>\nmovl   $0x0,-0xc(%rbp)\njmp    1659 <main+0x470>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xcc5c(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x14(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nimul   $0x14f8b589,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0xd,%edx\nmov    %eax,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%edx\nmov    %edx,-0x14(%rbp)\nmov    -0x14(%rbp),%edx\nimul   $0x186a0,%edx,%edx\nsub    %edx,%eax\nmov    %eax,-0x14(%rbp)\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x3f,-0xc(%rbp)\njle    1603 <main+0x41a>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x3f,-0x10(%rbp)\njle    15fa <main+0x411>\nmov    -0x14(%rbp),%eax\nmov    %eax,%esi\nlea    0x29c3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   384b <libmin_printf>\nlea    0x29df(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   384b <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    1704 <main+0x51b>\nmovl   $0x0,-0x4(%rbp)\njmp    16e6 <main+0x4fd>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x6,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0xcbb7(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%esi\nlea    0x29a5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   384b <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x3f,-0x4(%rbp)\njle    16a8 <main+0x4bf>\nlea    0x298b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   384b <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x3f,-0x8(%rbp)\njle    169f <main+0x4b6>\ncall   170f <libtarg_success>\n"}
{"source": {"path": "max-subseq/max-subseq.c", "function_name": "lcsAlgo", "content": "void lcsAlgo() {\n  // Filling 0's in the matrix\n  for (i = 0; i <= m; i++)\n    LCS_table[i][0] = 0;\n  for (i = 0; i <= n; i++)\n    LCS_table[0][i] = 0;\n\n  // Building the mtrix in bottom-up way\n  for (i = 1; i <= m; i++)\n    for (j = 1; j <= n; j++) {\n      if (S1[i - 1] == S2[j - 1]) {\n        LCS_table[i][j] = LCS_table[i - 1][j - 1] + 1;\n      } else if (LCS_table[i - 1][j] >= LCS_table[i][j - 1]) {\n        LCS_table[i][j] = LCS_table[i - 1][j];\n      } else {\n        LCS_table[i][j] = LCS_table[i][j - 1];\n      }\n    }\n\n  int index = LCS_table[m][n];\n  char lcsAlgo[index + 1];\n  lcsAlgo[index] = '\\0';\n\n  int i = m, j = n;\n  while (i > 0 && j > 0) {\n    if (S1[i - 1] == S2[j - 1]) {\n      lcsAlgo[index - 1] = S1[i - 1];\n      i--;\n      j--;\n      index--;\n    }\n\n    else if (LCS_table[i - 1][j] > LCS_table[i][j - 1])\n      i--;\n    else\n      j--;\n  }\n\n  // Printing the sub sequences\n  libmin_printf(\"LCS: %s\", lcsAlgo);\n}\n"}, "pseudo": {"path": "max-subseq/max-subseq.host.O0.pseudo", "function_name": "lcsAlgo", "address": "0x11e9", "label": "lcsAlgo", "content": "void __cdecl lcsAlgo()\n{\n  int v0; // edx\n  unsigned __int64 v1; // rax\n  void *v2; // rsp\n  _BYTE v3[12]; // [rsp+8h] [rbp-40h] BYREF\n  int index; // [rsp+14h] [rbp-34h]\n  int i; // [rsp+18h] [rbp-30h]\n  int j; // [rsp+1Ch] [rbp-2Ch]\n  __int64 v7; // [rsp+20h] [rbp-28h]\n  char (*p_lcsAlgo)[]; // [rsp+28h] [rbp-20h]\n  unsigned __int64 v9; // [rsp+30h] [rbp-18h]\n\n  v9 = __readfsqword(0x28u);\n  for ( ::i = 0; ::i <= m; ++::i )\n    LCS_table[::i][0] = 0;\n  for ( ::i = 0; ::i <= n; ++::i )\n    LCS_table[0][::i] = 0;\n  for ( ::i = 1; ::i <= m; ++::i )\n  {\n    for ( ::j = 1; ::j <= n; ++::j )\n    {\n      if ( S1[::i - 1] == S2[::j - 1] )\n      {\n        LCS_table[::i][::j] = LCS_table[::i - 1][::j - 1] + 1;\n      }\n      else\n      {\n        if ( LCS_table[::i - 1][::j] < LCS_table[::i - 1][::j + 39] )\n          v0 = LCS_table[::i - 1][::j + 39];\n        else\n          v0 = LCS_table[::i - 1][::j];\n        LCS_table[::i][::j] = v0;\n      }\n    }\n  }\n  index = LCS_table[m][n];\n  v7 = index + 1 - 1LL;\n  v1 = 16 * ((index + 1 + 15LL) / 0x10uLL);\n  while ( v3 != &v3[-(v1 & 0xFFFFFFFFFFFFF000LL)] )\n    ;\n  v2 = alloca(v1 & 0xFFF);\n  if ( (v1 & 0xFFF) != 0 )\n    *(_QWORD *)&v3[(v1 & 0xFFF) - 8] = *(_QWORD *)&v3[(v1 & 0xFFF) - 8];\n  p_lcsAlgo = (char (*)[])v3;\n  v3[index] = 0;\n  i = m;\n  j = n;\n  while ( i > 0 && j > 0 )\n  {\n    if ( S1[i - 1] == S2[j - 1] )\n    {\n      *((_BYTE *)p_lcsAlgo + index - 1) = S1[--i];\n      --j;\n      --index;\n    }\n    else if ( LCS_table[i - 1][j] <= LCS_table[i - 1][j + 39] )\n    {\n      --j;\n    }\n    else\n    {\n      --i;\n    }\n  }\n  libmin_printf(\"LCS: %s\", (const char *)p_lcsAlgo);\n}\n"}, "pseudo_normalize": "void lcsAlgo() {\n  int v0;\n  unsigned long long v1;\n  void *v2;\n  uint8_t v3[12];\n  int index;\n  int i;\n  int j;\n  long long v7;\n  char(*p_lcsAlgo)[];\n  unsigned long long v9;\n  v9 = __readfsqword(40u);\n  for (::i = 0; ::i <= m; ++::i) LCS_table[::i][0] = 0;\n  for (::i = 0; ::i <= n; ++::i) LCS_table[0][::i] = 0;\n  for (::i = 1; ::i <= m; ++::i) {\n    for (::j = 1; ::j <= n; ++::j) {\n      if (S1[::i - 1] == S2[::j - 1]) {\n        LCS_table[::i][::j] = LCS_table[::i - 1][::j - 1] + 1;\n      } else {\n        if (LCS_table[::i - 1][::j] < LCS_table[::i - 1][::j + 39])\n          v0 = LCS_table[::i - 1][::j + 39];\n        else\n          v0 = LCS_table[::i - 1][::j];\n        LCS_table[::i][::j] = v0;\n      }\n    }\n  }\n  index = LCS_table[m][n];\n  v7 = index + 1 - 1LL;\n  v1 = 16 * ((index + 1 + 15LL) / 16uLL);\n  while (v3 != &v3[-(v1 & 18446744073709547520LL)])\n    ;\n  v2 = alloca(v1 & 4095);\n  if ((v1 & 4095) != 0)\n    *(uint64_t *)&v3[(v1 & 4095) - 8] = *(uint64_t *)&v3[(v1 & 4095) - 8];\n  p_lcsAlgo = (char(*)[])v3;\n  v3[index] = 0;\n  i = m;\n  j = n;\n  while (i > 0 && j > 0) {\n    if (S1[i - 1] == S2[j - 1]) {\n      *((uint8_t *)p_lcsAlgo + index - 1) = S1[--i];\n      --j;\n      --index;\n    } else if (LCS_table[i - 1][j] <= LCS_table[i - 1][j + 39]) {\n      --j;\n    } else {\n      --i;\n    }\n  }\n  libmin_printf(\"LCS: %s\", (const char *)p_lcsAlgo);\n}", "binary": "max-subseq/max-subseq.host.O0", "assembly": "<lcsAlgo>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    %rsp,%rax\nmov    %rax,%rbx\nmovl   $0x0,0x50ab(%rip)\njmp    124e <lcsAlgo+0x65>\nmov    0x50a3(%rip),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x5,%rax\nmov    %rax,%rdx\nlea    0x50a8(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\nmov    0x507b(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x5072(%rip)\nmov    0x506c(%rip),%edx\nmov    0x506e(%rip),%eax\ncmp    %eax,%edx\njle    1217 <lcsAlgo+0x2e>\nmovl   $0x0,0x5058(%rip)\njmp    1297 <lcsAlgo+0xae>\nmov    0x5050(%rip),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x505f(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\nmov    0x5032(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x5029(%rip)\nmov    0x5023(%rip),%edx\nmov    0x5029(%rip),%eax\ncmp    %eax,%edx\njle    126a <lcsAlgo+0x81>\nmovl   $0x1,0x500f(%rip)\njmp    14ef <lcsAlgo+0x306>\nmovl   $0x1,0x5004(%rip)\njmp    14cc <lcsAlgo+0x2e3>\nmov    0x4ff5(%rip),%eax\nsub    $0x1,%eax\ncltq\nlea    0x4d39(%rip),%rdx\nmovzbl (%rax,%rdx,1),%edx\nmov    0x4fe3(%rip),%eax\nsub    $0x1,%eax\ncltq\nlea    0x4d43(%rip),%rcx\nmovzbl (%rax,%rcx,1),%eax\ncmp    %al,%dl\njne    136d <lcsAlgo+0x184>\nmov    0x4fc5(%rip),%eax\nlea    -0x1(%rax),%edx\nmov    0x4fc0(%rip),%eax\nsub    $0x1,%eax\nmovslq %eax,%rcx\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4fb3(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    0x4f8a(%rip),%eax\nmov    0x4f88(%rip),%edx\nadd    $0x1,%ecx\nmovslq %edx,%rsi\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f7b(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\njmp    14bd <lcsAlgo+0x2d4>\nmov    0x4f4d(%rip),%eax\nlea    -0x1(%rax),%edx\nmov    0x4f48(%rip),%eax\nmovslq %eax,%rcx\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f3e(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    0x4f15(%rip),%eax\nmov    0x4f13(%rip),%edx\nsub    $0x1,%edx\nmovslq %edx,%rsi\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f06(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,%ecx\njl     1450 <lcsAlgo+0x267>\nmov    0x4ed9(%rip),%eax\nlea    -0x1(%rax),%edx\nmov    0x4ed4(%rip),%eax\nmov    0x4eca(%rip),%ecx\nmov    0x4ec8(%rip),%esi\nmovslq %eax,%rdi\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4ebe(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmovslq %esi,%rsi\nmovslq %ecx,%rcx\nmov    %rcx,%rax\nshl    $0x2,%rax\nadd    %rcx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x4e95(%rip),%rax\nmov    %edx,(%rcx,%rax,1)\njmp    14bd <lcsAlgo+0x2d4>\nmov    0x4e6a(%rip),%eax\nmov    0x4e68(%rip),%edx\nsub    $0x1,%edx\nmov    0x4e5b(%rip),%ecx\nmov    0x4e59(%rip),%esi\nmovslq %edx,%rdi\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4e4f(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmovslq %esi,%rsi\nmovslq %ecx,%rcx\nmov    %rcx,%rax\nshl    $0x2,%rax\nadd    %rcx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x4e26(%rip),%rax\nmov    %edx,(%rcx,%rax,1)\nmov    0x4e01(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x4df8(%rip)\nmov    0x4df2(%rip),%edx\nmov    0x4df4(%rip),%eax\ncmp    %eax,%edx\njle    12c5 <lcsAlgo+0xdc>\nmov    0x4dda(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x4dd1(%rip)\nmov    0x4dcb(%rip),%edx\nmov    0x4dcd(%rip),%eax\ncmp    %eax,%edx\njle    12b6 <lcsAlgo+0xcd>\nmov    0x4dbf(%rip),%eax\nmov    0x4dbd(%rip),%edx\nmovslq %edx,%rcx\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4dab(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\nadd    $0x1,%eax\nmovslq %eax,%rdx\nsub    $0x1,%rdx\nmov    %rdx,-0x28(%rbp)\nmovslq %eax,%rdx\nmov    %rdx,%r10\nmov    $0x0,%r11d\nmovslq %eax,%rdx\nmov    %rdx,%r8\nmov    $0x0,%r9d\ncltq\nmov    $0x10,%edx\nsub    $0x1,%rdx\nadd    %rdx,%rax\nmov    $0x10,%edi\nmov    $0x0,%edx\ndiv    %rdi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     15aa <lcsAlgo+0x3c1>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1593 <lcsAlgo+0x3aa>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     15d4 <lcsAlgo+0x3eb>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x0,%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x20(%rbp),%rdx\nmov    -0x34(%rbp),%eax\ncltq\nmovb   $0x0,(%rdx,%rax,1)\nmov    0x4cd6(%rip),%eax\nmov    %eax,-0x30(%rbp)\nmov    0x4cd1(%rip),%eax\nmov    %eax,-0x2c(%rbp)\njmp    16d1 <lcsAlgo+0x4e8>\nmov    -0x30(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x49fe(%rip),%rdx\nmovzbl (%rax,%rdx,1),%edx\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\ncltq\nlea    0x4a0b(%rip),%rcx\nmovzbl (%rax,%rcx,1),%eax\ncmp    %al,%dl\njne    165f <lcsAlgo+0x476>\nmov    -0x30(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x34(%rbp),%eax\nlea    -0x1(%rax),%esi\nmovslq %edx,%rax\nlea    0x49cd(%rip),%rdx\nmovzbl (%rax,%rdx,1),%ecx\nmov    -0x20(%rbp),%rdx\nmovslq %esi,%rax\nmov    %cl,(%rdx,%rax,1)\nsubl   $0x1,-0x30(%rbp)\nsubl   $0x1,-0x2c(%rbp)\nsubl   $0x1,-0x34(%rbp)\njmp    16d1 <lcsAlgo+0x4e8>\nmov    -0x30(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rcx\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4c52(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0x2c(%rbp),%eax\nsub    $0x1,%eax\nmovslq %eax,%rsi\nmov    -0x30(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4c20(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,%ecx\njle    16cd <lcsAlgo+0x4e4>\nsubl   $0x1,-0x30(%rbp)\njmp    16d1 <lcsAlgo+0x4e8>\nsubl   $0x1,-0x2c(%rbp)\ncmpl   $0x0,-0x30(%rbp)\njle    16e1 <lcsAlgo+0x4f8>\ncmpl   $0x0,-0x2c(%rbp)\njg     1603 <lcsAlgo+0x41a>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2915(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   38eb <libmin_printf>\nmov    %rbx,%rsp\nnop\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1714 <lcsAlgo+0x52b>\ncall   10b0 <__stack_chk_fail@plt>\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "max-subseq/max-subseq.c", "function_name": "main", "content": "int\nmain(void)\n{\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "max-subseq/max-subseq.host.O0.pseudo", "function_name": "main", "address": "0x171a", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n  libmin_success();\n}", "binary": "max-subseq/max-subseq.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    0x48e7(%rip),%rax\nmov    %rax,%rdi\ncall   3b1a <libmin_strlen>\nmov    %eax,0x4b91(%rip)\nlea    0x48f2(%rip),%rax\nmov    %rax,%rdi\ncall   3b1a <libmin_strlen>\nmov    %eax,0x4b80(%rip)\nmov    0x4b7a(%rip),%edx\nmov    0x4b70(%rip),%eax\nmov    %edx,%r8d\nlea    0x48ce(%rip),%rdx\nmov    %rdx,%rcx\nmov    %eax,%edx\nlea    0x48a2(%rip),%rax\nmov    %rax,%rsi\nlea    0x2894(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   38eb <libmin_printf>\nmov    $0x0,%eax\ncall   11e9 <lcsAlgo>\nlea    0x2893(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   38eb <libmin_printf>\ncall   3b58 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "mersenne/mersenne.c", "function_name": "genrand", "content": "unsigned int \ngenrand(void)\n{\n  unsigned int y;\n  static unsigned int mag01[2]={0x0, MATRIX_A};\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (mti >= N) { /* generate N words at one time */\n    int kk;\n\n    if (mti == N+1)   /* if sgenrand() has not been called, */\n      sgenrand(4357); /* a default initial seed is used   */\n\n    for (kk=0;kk<N-M;kk++)\n      {\n\ty = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n\tmt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];\n      }\n    for (;kk<N-1;kk++)\n      {\n\ty = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n\tmt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];\n      }\n    y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);\n    mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];\n\n    mti = 0;\n  }\n  \n  y = mt[mti++];\n  y ^= TEMPERING_SHIFT_U(y);\n  y ^= TEMPERING_SHIFT_S(y) & TEMPERING_MASK_B;\n  y ^= TEMPERING_SHIFT_T(y) & TEMPERING_MASK_C;\n  y ^= TEMPERING_SHIFT_L(y);\n\n  return y; \n}\n"}, "pseudo": {"path": "mersenne/mersenne.host.O0.pseudo", "function_name": "genrand", "address": "0x12ee", "label": "genrand", "content": "unsigned int __cdecl genrand()\n{\n  int v0; // eax\n  int kk; // [rsp+8h] [rbp-8h]\n  unsigned int y; // [rsp+Ch] [rbp-4h]\n  unsigned int ya; // [rsp+Ch] [rbp-4h]\n  unsigned int yb; // [rsp+Ch] [rbp-4h]\n  unsigned int yc; // [rsp+Ch] [rbp-4h]\n\n  if ( mti > 623 )\n  {\n    if ( mti == 625 )\n      sgenrand(0x1105u);\n    for ( kk = 0; kk <= 226; ++kk )\n    {\n      y = mt[kk] & 0x80000000 | mt[kk + 1] & 0x7FFFFFFF;\n      mt[kk] = mag01_0[y & 1] ^ (y >> 1) ^ mt[kk + 397];\n    }\n    while ( kk <= 622 )\n    {\n      ya = mt[kk] & 0x80000000 | mt[kk + 1] & 0x7FFFFFFF;\n      mt[kk] = mag01_0[ya & 1] ^ (ya >> 1) ^ mt[kk - 227];\n      ++kk;\n    }\n    mt[623] = ((mt[623] & 0x80000000 | mt[0] & 0x7FFFFFFF) >> 1) ^ mt[396] ^ mag01_0[mt[0] & 1];\n    mti = 0;\n  }\n  v0 = mti++;\n  yb = (mt[v0] >> 11) ^ mt[v0];\n  yc = (((yb << 7) & 0x9D2C5680 ^ yb) << 15) & 0xEFC60000 ^ (yb << 7) & 0x9D2C5680 ^ yb;\n  return (yc >> 18) ^ yc;\n}\n"}, "pseudo_normalize": "unsigned int genrand() {\n  int v0;\n  int kk;\n  unsigned int y;\n  unsigned int ya;\n  unsigned int yb;\n  unsigned int yc;\n  if (mti > 623) {\n    if (mti == 625) sgenrand(4357u);\n    for (kk = 0; kk <= 226; ++kk) {\n      y = mt[kk] & 2147483648 | mt[kk + 1] & 2147483647;\n      mt[kk] = mag01_0[y & 1] ^ (y >> 1) ^ mt[kk + 397];\n    }\n    while (kk <= 622) {\n      ya = mt[kk] & 2147483648 | mt[kk + 1] & 2147483647;\n      mt[kk] = mag01_0[ya & 1] ^ (ya >> 1) ^ mt[kk - 227];\n      ++kk;\n    }\n    mt[623] = ((mt[623] & 2147483648 | mt[0] & 2147483647) >> 1) ^ mt[396] ^\n              mag01_0[mt[0] & 1];\n    mti = 0;\n  }\n  v0 = mti++;\n  yb = (mt[v0] >> 11) ^ mt[v0];\n  yc = (((yb << 7) & 2636928640 ^ yb) << 15) & 4022730752 ^\n       (yb << 7) & 2636928640 ^ yb;\n  return (yc >> 18) ^ yc;\n}", "binary": "mersenne/mersenne.host.O0", "assembly": "<genrand>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    0x4d10(%rip),%eax\ncmp    $0x26f,%eax\njle    14e1 <genrand+0x1f3>\nmov    0x4cff(%rip),%eax\ncmp    $0x271,%eax\njne    1322 <genrand+0x34>\nmov    $0x1105,%edi\ncall   11e9 <sgenrand>\nmovl   $0x0,-0x8(%rbp)\njmp    13cc <genrand+0xde>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4f3e(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nand    $0x80000000,%eax\nmov    %eax,%ecx\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4f1d(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nand    $0x7fffffff,%eax\nor     %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\nadd    $0x18d,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4ef7(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x4(%rbp),%eax\nshr    %eax\nmov    %edx,%ecx\nxor    %eax,%ecx\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x4c6c(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nxor    %eax,%ecx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4ebb(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0xe2,-0x8(%rbp)\njle    132e <genrand+0x40>\njmp    147c <genrand+0x18e>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4e8e(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nand    $0x80000000,%eax\nmov    %eax,%ecx\nmov    -0x8(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4e6d(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nand    $0x7fffffff,%eax\nor     %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\nsub    $0xe3,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4e47(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x4(%rbp),%eax\nshr    %eax\nmov    %edx,%ecx\nxor    %eax,%ecx\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x4bbc(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nxor    %eax,%ecx\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4e0b(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x26e,-0x8(%rbp)\njle    13de <genrand+0xf0>\nmov    0x57ad(%rip),%eax\nand    $0x80000000,%eax\nmov    %eax,%edx\nmov    0x4de4(%rip),%eax\nand    $0x7fffffff,%eax\nor     %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    0x5404(%rip),%edx\nmov    -0x4(%rbp),%eax\nshr    %eax\nmov    %edx,%ecx\nxor    %eax,%ecx\nmov    -0x4(%rbp),%eax\nand    $0x1,%eax\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x4b4c(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nxor    %ecx,%eax\nmov    %eax,0x5765(%rip)\nmovl   $0x0,0x4b2f(%rip)\nmov    0x4b29(%rip),%eax\nlea    0x1(%rax),%edx\nmov    %edx,0x4b20(%rip)\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4d7f(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshr    $0xb,%eax\nxor    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshl    $0x7,%eax\nand    $0x9d2c5680,%eax\nxor    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshl    $0xf,%eax\nand    $0xefc60000,%eax\nxor    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nshr    $0x12,%eax\nxor    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nleave\nret\n"}
{"source": {"path": "mersenne/mersenne.c", "function_name": "lsgenrand", "content": "/* Initialization by \"sgenrand()\" is an example. Theoretically,      */\n/* there are 2^19937-1 possible states as an intial state.           */\n/* This function allows to choose any of 2^19937-1 ones.             */\n/* Essential bits in \"seed_array[]\" is following 19937 bits:         */\n/* (seed_array[0]&UPPER_MASK), seed_array[1], ..., seed_array[N-1]. */\n/* (seed_array[0]&LOWER_MASK) is discarded.                          */ \n/* Theoretically,                                                    */\n/* (seed_array[0]&UPPER_MASK), seed_array[1], ..., seed_array[N-1]  */\n/* can take any values except all zeros.                             */\nvoid\nlsgenrand(unsigned int seed_array[])\n     /* the length of seed_array[] must be at least N */\n{\n  int i;\n\n  for (i=0;i<N;i++) \n    mt[i] = seed_array[i];\n  mti=N;\n}\n"}, "pseudo": {"path": "mersenne/mersenne.host.O0.pseudo", "function_name": "lsgenrand", "address": "0x1291", "label": "lsgenrand", "content": "void __cdecl lsgenrand(unsigned int *seed_array)\n{\n  int i; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; i <= 623; ++i )\n    mt[i] = seed_array[i];\n  mti = 624;\n}\n"}, "pseudo_normalize": "", "binary": "mersenne/mersenne.host.O0", "assembly": "<lsgenrand>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    12d8 <lsgenrand+0x47>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,4),%rcx\nlea    0x4faf(%rip),%rdx\nmov    %eax,(%rcx,%rdx,1)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x26f,-0x4(%rbp)\njle    12a6 <lsgenrand+0x15>\nmovl   $0x270,0x4d25(%rip)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "mersenne/mersenne.c", "function_name": "main", "content": "/* This main() outputs first 1000 generated numbers.  */\nint\nmain(void)\n{ \n  int steps = 10000;\n  int i, j;\n    \n  sgenrand(4357);\n  for (i=0,j=0; i<steps; i++)\n    {\n      if ((i % 100) == 0)\n\t{\n\t  libmin_printf(\"%10u \", genrand());\n\t  if (++j%5==0)\n\t    libmin_printf(\"\\n\");\n\t}\n    }\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "mersenne/mersenne.host.O0.pseudo", "function_name": "main", "address": "0x153a", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // eax\n  int i; // [rsp+4h] [rbp-Ch]\n  int j; // [rsp+8h] [rbp-8h]\n\n  sgenrand(0x1105u);\n  i = 0;\n  j = 0;\n  while ( i < 10000 )\n  {\n    if ( !(i % 100) )\n    {\n      v3 = genrand();\n      argv = (const char **)v3;\n      libmin_printf(\"%10u \", v3);\n      if ( !(++j % 5) )\n        libmin_printf(\"\\n\");\n    }\n    ++i;\n  }\n  libmin_printf(\"\\n\", argv);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  int i;\n  int j;\n  sgenrand(4357u);\n  i = 0;\n  j = 0;\n  while (i < 10000) {\n    if (!(i % 100)) {\n      v3 = genrand();\n      argv = (const char **)v3;\n      libmin_printf(\"%10u \", v3);\n      if (!(++j % 5)) libmin_printf(\"\\n\");\n    }\n    ++i;\n  }\n  libmin_printf(\"\\n\", argv);\n  libmin_success();\n}", "binary": "mersenne/mersenne.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x2710,-0x4(%rbp)\nmov    $0x1105,%edi\ncall   11e9 <sgenrand>\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    15f0 <main+0xb6>\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x51eb851f,%rax,%rax\nshr    $0x20,%rax\nsar    $0x5,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nimul   $0x64,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\njne    15ec <main+0xb2>\ncall   12ee <genrand>\nmov    %eax,%esi\nlea    0x2a66(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3758 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    %eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x2,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\njne    15ec <main+0xb2>\nlea    0x2a2b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3758 <libmin_printf>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     156a <main+0x30>\nlea    0x2a07(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3758 <libmin_printf>\ncall   39c5 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "mersenne/mersenne.c", "function_name": "sgenrand", "content": " /* mti==N+1 means mt[N] is not initialized */\n\n/* Initializing the array with a seed */\nvoid\nsgenrand(unsigned int seed)\n{\n  int i;\n\n  for (i=0;i<N;i++)\n    {\n      mt[i] = seed & 0xffff0000;\n      seed = 69069 * seed + 1;\n      mt[i] |= (seed & 0xffff0000) >> 16;\n      seed = 69069 * seed + 1;\n    }\n  mti = N;\n}\n"}, "pseudo": {"path": "mersenne/mersenne.host.O0.pseudo", "function_name": "sgenrand", "address": "0x11e9", "label": "sgenrand", "content": "void __cdecl sgenrand(unsigned int seed)\n{\n  unsigned int v1; // eax\n  unsigned int seedb; // [rsp+0h] [rbp-14h]\n  int i; // [rsp+10h] [rbp-4h]\n\n  for ( i = 0; i <= 623; ++i )\n  {\n    HIWORD(v1) = HIWORD(seed);\n    LOWORD(v1) = 0;\n    mt[i] = v1;\n    seedb = 69069 * seed + 1;\n    mt[i] |= HIWORD(seedb);\n    seed = 69069 * seedb + 1;\n  }\n  mti = 624;\n}\n"}, "pseudo_normalize": "void sgenrand(unsigned int seed) {\n  unsigned int v1;\n  unsigned int seedb;\n  int i;\n  for (i = 0; i <= 623; ++i) {\n    HIWORD(v1) = HIWORD(seed);\n    LOWORD(v1) = 0;\n    mt[i] = v1;\n    seedb = 69069 * seed + 1;\n    mt[i] |= HIWORD(seedb);\n    seed = 69069 * seedb + 1;\n  }\n  mti = 624;\n}", "binary": "mersenne/mersenne.host.O0", "assembly": "<sgenrand>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1277 <sgenrand+0x8e>\nmov    -0x14(%rbp),%eax\nmov    $0x0,%ax\nmov    %eax,%ecx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5066(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nimul   $0x10dcd,%eax,%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5040(%rip),%rax\nmov    (%rdx,%rax,1),%edx\nmov    -0x14(%rbp),%eax\nshr    $0x10,%eax\nmov    %edx,%ecx\nor     %eax,%ecx\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x501f(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\nmov    -0x14(%rbp),%eax\nimul   $0x10dcd,%eax,%eax\nadd    $0x1,%eax\nmov    %eax,-0x14(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x26f,-0x4(%rbp)\njle    11fd <sgenrand+0x14>\nmovl   $0x270,0x4d82(%rip)\nnop\npop    %rbp\nret\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "displayGraph", "content": "void\ndisplayGraph(int32_t graph[V][V])\n{\n\tint index = 0;\n\tfor (int i=-1;i<V;i++)\n  {\n\t\tfor (int j=-1;j<V;j++)\n    {\n\t\t\tif (i==-1)\n      {\n\t\t\t\tif (j==-1)\n          libmin_printf(\"       \");\n\t\t\t\telse\n          libmin_printf(\"%8s\", vertName[j]);\n\t\t\t}\n      else\n      {\n\t\t\t\tif(j==-1)\n        {\n          libmin_printf(\"%8s\", vertName[index]);\n\t\t\t\t\tindex++;\n\t\t\t\t}\n        else\n          libmin_printf(\"%8d\", graph[i][j]);\n\t\t\t}\n\t\t}\n    libmin_printf(\"\\n\");\n\t}\n  libmin_printf(\"\\n\\n\");\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O0.pseudo", "function_name": "displayGraph", "address": "0x17f5", "label": "displayGraph", "content": "void __cdecl displayGraph(int32_t (*graph)[])\n{\n  __int64 v1; // rdx\n  const char *v2; // rsi\n  __int64 v3; // rcx\n  int index; // [rsp+1Ch] [rbp-24h]\n  int i; // [rsp+20h] [rbp-20h]\n  int j; // [rsp+24h] [rbp-1Ch]\n\n  v3 = 10LL;\n  index = 0;\n  for ( i = -1; i < 10; ++i )\n  {\n    for ( j = -1; j < 10; ++j )\n    {\n      if ( i == -1 )\n      {\n        if ( j == -1 )\n        {\n          libmin_printf(\"       \");\n        }\n        else\n        {\n          v2 = vertName[j];\n          libmin_printf(\"%8s\", v2);\n        }\n      }\n      else if ( j == -1 )\n      {\n        v2 = vertName[index];\n        libmin_printf(\"%8s\", v2);\n        ++index;\n      }\n      else\n      {\n        v2 = (const char *)*((unsigned int *)graph + 10 * i + j);\n        libmin_printf(\"%8d\", (_DWORD)v2);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\", v2, v1, v3);\n}\n"}, "pseudo_normalize": "void displayGraph(int32_t (*graph)[]) {\n  long long v1;\n  const char *v2;\n  long long v3;\n  int index;\n  int i;\n  int j;\n  v3 = 10LL;\n  index = 0;\n  for (i = -1; i < 10; ++i) {\n    for (j = -1; j < 10; ++j) {\n      if (i == -1) {\n        if (j == -1) {\n          libmin_printf(\"       \");\n        } else {\n          v2 = vertName[j];\n          libmin_printf(\"%8s\", v2);\n        }\n      } else if (j == -1) {\n        v2 = vertName[index];\n        libmin_printf(\"%8s\", v2);\n        ++index;\n      } else {\n        v2 = (const char *)*((unsigned int *)graph + 10 * i + j);\n        libmin_printf(\"%8d\", (uint32_t)v2);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\", v2, v1, v3);\n}", "binary": "minspan/minspan.host.O0", "assembly": "<displayGraph>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x18(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%rcx\nmov    $0x0,%ebx\nmovl   $0x0,-0x24(%rbp)\nmovl   $0xffffffff,-0x20(%rbp)\njmp    193c <displayGraph+0x147>\nmovl   $0xffffffff,-0x1c(%rbp)\njmp    1916 <displayGraph+0x121>\ncmpl   $0xffffffff,-0x20(%rbp)\njne    1899 <displayGraph+0xa4>\ncmpl   $0xffffffff,-0x1c(%rbp)\njne    1868 <displayGraph+0x73>\nlea    0x37f7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\njmp    1912 <displayGraph+0x11d>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x57a4(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x37cb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\njmp    1912 <displayGraph+0x11d>\ncmpl   $0xffffffff,-0x1c(%rbp)\njne    18d4 <displayGraph+0xdf>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x576d(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x3794(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\naddl   $0x1,-0x24(%rbp)\njmp    1912 <displayGraph+0x11d>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\nmov    %eax,%esi\nlea    0x3754(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\naddl   $0x1,-0x1c(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x1c(%rbp)\njl     1843 <displayGraph+0x4e>\nlea    0x3732(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\naddl   $0x1,-0x20(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x20(%rbp)\njl     1837 <displayGraph+0x42>\nlea    0x370e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "displayGraph1", "content": "void\ndisplayGraph1(int32_t graph[V][V], int32_t path[V])\n{\n\tint index = 0;\n\tfor (int i=-1;i<V;i++)\n  {\n\t\tfor (int j=-1;j<V;j++)\n    {\n\t\t\tif (i==-1)\n      {\n\t\t\t\tif (j==-1)\n          libmin_printf(\"       \");\n\t\t\t\telse\n          libmin_printf(\"%8s\", vertName[j]);\n\t\t\t}\n      else\n      {\n\t\t\t\tif(j==-1)\n        {\n          libmin_printf(\"%8s\", vertName[index]);\n\t\t\t\t\tindex++;\n\t\t\t\t}\n        else\n          libmin_printf(\"%8d / %d\", graph[i][j], path[i]);\n\t\t\t}\n\t\t}\n    libmin_printf(\"\\n\");\n\t}\n  libmin_printf(\"\\n\\n\");\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O0.pseudo", "function_name": "displayGraph1", "address": "0x1965", "label": "displayGraph1", "content": "void __cdecl displayGraph1(int32_t (*graph)[], int32_t *path)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  int32_t *patha; // [rsp+0h] [rbp-40h]\n  int index; // [rsp+1Ch] [rbp-24h]\n  int i; // [rsp+20h] [rbp-20h]\n  int j; // [rsp+24h] [rbp-1Ch]\n\n  patha = path;\n  v3 = 10LL;\n  index = 0;\n  for ( i = -1; i < 10; ++i )\n  {\n    for ( j = -1; j < 10; ++j )\n    {\n      if ( i == -1 )\n      {\n        if ( j == -1 )\n        {\n          libmin_printf(\"       \");\n        }\n        else\n        {\n          path = (int32_t *)vertName[j];\n          libmin_printf(\"%8s\", (const char *)path);\n        }\n      }\n      else if ( j == -1 )\n      {\n        path = (int32_t *)vertName[index];\n        libmin_printf(\"%8s\", (const char *)path);\n        ++index;\n      }\n      else\n      {\n        path = (int32_t *)*((unsigned int *)graph + 10 * i + j);\n        libmin_printf(\"%8d / %d\", (_DWORD)path, patha[i]);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\", path, v2, v3);\n}\n"}, "pseudo_normalize": "void displayGraph1(int32_t (*graph)[], int32_t *path) {\n  long long v2;\n  long long v3;\n  int32_t *patha;\n  int index;\n  int i;\n  int j;\n  patha = path;\n  v3 = 10LL;\n  index = 0;\n  for (i = -1; i < 10; ++i) {\n    for (j = -1; j < 10; ++j) {\n      if (i == -1) {\n        if (j == -1) {\n          libmin_printf(\"       \");\n        } else {\n          path = (int32_t *)vertName[j];\n          libmin_printf(\"%8s\", (const char *)path);\n        }\n      } else if (j == -1) {\n        path = (int32_t *)vertName[index];\n        libmin_printf(\"%8s\", (const char *)path);\n        ++index;\n      } else {\n        path = (int32_t *)*((unsigned int *)graph + 10 * i + j);\n        libmin_printf(\"%8d / %d\", (uint32_t)path, patha[i]);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\\n\", path, v2, v3);\n}", "binary": "minspan/minspan.host.O0", "assembly": "<displayGraph1>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x18(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%rcx\nmov    $0x0,%ebx\nmovl   $0x0,-0x24(%rbp)\nmovl   $0xffffffff,-0x20(%rbp)\njmp    1ac9 <displayGraph1+0x164>\nmovl   $0xffffffff,-0x1c(%rbp)\njmp    1aa3 <displayGraph1+0x13e>\ncmpl   $0xffffffff,-0x20(%rbp)\njne    1a10 <displayGraph1+0xab>\ncmpl   $0xffffffff,-0x1c(%rbp)\njne    19dc <displayGraph1+0x77>\nlea    0x3683(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\njmp    1a9f <displayGraph1+0x13a>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5630(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x3657(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\njmp    1a9f <displayGraph1+0x13a>\ncmpl   $0xffffffff,-0x1c(%rbp)\njne    1a4b <displayGraph1+0xe6>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x55f6(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x361d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\naddl   $0x1,-0x24(%rbp)\njmp    1a9f <displayGraph1+0x13a>\nmov    -0x20(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rcx\nmov    $0xa,%eax\ncltq\nimul   %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nmov    -0x38(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    (%rcx,%rax,4),%eax\nmov    %eax,%esi\nlea    0x35d0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\naddl   $0x1,-0x1c(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x1c(%rbp)\njl     19b7 <displayGraph1+0x52>\nlea    0x35a5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\naddl   $0x1,-0x20(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x20(%rbp)\njl     19ab <displayGraph1+0x46>\nlea    0x3581(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "displayPath", "content": "//Displays the path from source to destination\nvoid\ndisplayPath(int32_t source, int32_t dest, int32_t path[V])\n{\n\tstatic int count = 0;\n\t\n\tint currPath = dest;\n\t\n\tif (count == 0)\n  {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source], vertName[currPath]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n\t\tcount++;\n\t}\t\n\tif (path[currPath] != source)\n  {\n\t\tdisplayPath(source,path[currPath],path);\n\t}\n  libmin_printf(\"-> %s\", vertName[currPath]);\n\tif (currPath == dest)\n  {\n    libmin_printf(\"\\n\");\n\t}\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O0.pseudo", "function_name": "displayPath", "address": "0x1af2", "label": "displayPath", "content": "void __cdecl displayPath(int32_t source, int32_t dest, int32_t *path)\n{\n  if ( !count_0 )\n  {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source], vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  if ( source != path[dest] )\n    displayPath(source, path[dest], path);\n  libmin_printf(\"-> %s\", vertName[dest]);\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void displayPath(int32_t source, int32_t dest, int32_t *path) {\n  if (!count_0) {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source],\n                  vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  if (source != path[dest]) displayPath(source, path[dest], path);\n  libmin_printf(\"-> %s\", vertName[dest]);\n  libmin_printf(\"\\n\");\n}", "binary": "minspan/minspan.host.O0", "assembly": "<displayPath>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    %rdx,-0x20(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    0x57b8(%rip),%eax\ntest   %eax,%eax\njne    1ba1 <displayPath+0xaf>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x54f0(%rip),%rax\nmov    (%rdx,%rax,1),%rdx\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rcx\nlea    0x54d8(%rip),%rax\nmov    (%rcx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x3515(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x54a9(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x3504(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nmov    0x5734(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x572b(%rip)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x14(%rbp)\nje     1be2 <displayPath+0xf0>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%ecx\nmov    -0x20(%rbp),%rdx\nmov    -0x14(%rbp),%eax\nmov    %ecx,%esi\nmov    %eax,%edi\ncall   1af2 <displayPath>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x542a(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x348e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nmov    -0x4(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njne    1c2d <displayPath+0x13b>\nlea    0x343d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "displayTree", "content": "// display the minimum spanning tree\nvoid\ndisplayTree(int32_t graph[V][V], int32_t path[V])\n{\n  int cost = 0;\n  libmin_printf(\"minimum spanning tree:\\n\");\n  for (int i=1; i < V; i++)\n  {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", vertName[i], graph[i][path[i]], vertName[path[i]]);\n    cost += graph[i][path[i]];\n  }\n  libmin_printf(\"total cost = %d\\n\", cost);\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O0.pseudo", "function_name": "displayTree", "address": "0x1c30", "label": "displayTree", "content": "void __cdecl displayTree(int32_t (*graph)[], int32_t *path)\n{\n  __int64 v2; // rdx\n  int cost; // [rsp+10h] [rbp-20h]\n  int i; // [rsp+14h] [rbp-1Ch]\n\n  cost = 0;\n  libmin_printf(\"minimum spanning tree:\\n\", path, v2, 10LL);\n  for ( i = 1; i < 10; ++i )\n  {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", vertName[i], *((_DWORD *)graph + 10 * i + path[i]), vertName[path[i]]);\n    cost += *((_DWORD *)graph + 10 * i + path[i]);\n  }\n  libmin_printf(\"total cost = %d\\n\", cost);\n}\n"}, "pseudo_normalize": "void displayTree(int32_t (*graph)[], int32_t *path) {\n  long long v2;\n  int cost;\n  int i;\n  cost = 0;\n  libmin_printf(\"minimum spanning tree:\\n\", path, v2, 10LL);\n  for (i = 1; i < 10; ++i) {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", vertName[i],\n                  *((uint32_t *)graph + 10 * i + path[i]), vertName[path[i]]);\n    cost += *((uint32_t *)graph + 10 * i + path[i]);\n  }\n  libmin_printf(\"total cost = %d\\n\", cost);\n}", "binary": "minspan/minspan.host.O0", "assembly": "<displayTree>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x18(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%rcx\nmov    $0x0,%ebx\nmovl   $0x0,-0x20(%rbp)\nlea    0x3427(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nmovl   $0x1,-0x1c(%rbp)\njmp    1d61 <displayTree+0x131>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x536f(%rip),%rax\nmov    (%rdx,%rax,1),%rcx\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rsi\nmov    -0x30(%rbp),%rax\nadd    %rsi,%rax\nmov    (%rax),%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rsi\nlea    0x531c(%rip),%rax\nmov    (%rsi,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x339e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nmov    -0x30(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\nadd    %eax,-0x20(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x1c(%rbp)\njl     1c8a <displayTree+0x5a>\nmov    -0x20(%rbp),%eax\nmov    %eax,%esi\nlea    0x3347(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4191 <libmin_printf>\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "initializeData", "content": "//Used to initialize the graph\nvoid\ninitializeData(int32_t graph[V][V])\n{\n\tlibmin_srand(10);\n\tfor (int i=0; i < V; i++)\n  {\n\t\tfor (int j=0;j<V;j++)\n    {\n\t\t\tif (i>j)\n\t\t\t\tgraph[i][j] = graph[j][i];\n\t\t\telse if (i==j)\n\t\t\t\tgraph[i][j] = 0;\n\t\t\telse\n      {\n\t\t\t\tif (libmin_rand() % 5 == libmin_rand() % 5)\n\t\t\t\t\tgraph[i][j] = 0;\t\n\t\t\t\telse\n\t\t\t\t\tgraph[i][j] = libmin_rand() % 10;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O0.pseudo", "function_name": "initializeData", "address": "0x1616", "label": "initializeData", "content": "void __cdecl initializeData(int32_t (*graph)[])\n{\n  unsigned int v1; // ebx\n  int i; // [rsp+10h] [rbp-20h]\n  int j; // [rsp+14h] [rbp-1Ch]\n\n  libmin_srand(0xAu);\n  for ( i = 0; i < 10; ++i )\n  {\n    for ( j = 0; j < 10; ++j )\n    {\n      if ( i <= j )\n      {\n        if ( i == j )\n        {\n          *((_DWORD *)graph + 10 * i + j) = 0;\n        }\n        else\n        {\n          v1 = libmin_rand() % 5;\n          if ( v1 == libmin_rand() % 5 )\n            *((_DWORD *)graph + 10 * i + j) = 0;\n          else\n            *((_DWORD *)graph + 10 * i + j) = libmin_rand() % 0xA;\n        }\n      }\n      else\n      {\n        *((_DWORD *)graph + 10 * i + j) = *((_DWORD *)graph + 10 * j + i);\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void initializeData(int32_t (*graph)[]) {\n  unsigned int v1;\n  int i;\n  int j;\n  libmin_srand(10u);\n  for (i = 0; i < 10; ++i) {\n    for (j = 0; j < 10; ++j) {\n      if (i <= j) {\n        if (i == j) {\n          *((uint32_t *)graph + 10 * i + j) = 0;\n        } else {\n          v1 = libmin_rand() % 5;\n          if (v1 == libmin_rand() % 5)\n            *((uint32_t *)graph + 10 * i + j) = 0;\n          else\n            *((uint32_t *)graph + 10 * i + j) = libmin_rand() % 10;\n        }\n      } else {\n        *((uint32_t *)graph + 10 * i + j) = *((uint32_t *)graph + 10 * j + i);\n      }\n    }\n  }\n}", "binary": "minspan/minspan.host.O0", "assembly": "<initializeData>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x18(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%rcx\nmov    $0x0,%ebx\nmov    $0xa,%edi\ncall   43c0 <libmin_srand>\nmovl   $0x0,-0x20(%rbp)\njmp    17df <initializeData+0x1c9>\nmovl   $0x0,-0x1c(%rbp)\njmp    17cd <initializeData+0x1b7>\nmov    -0x20(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njle    16c4 <initializeData+0xae>\nmov    -0x1c(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rcx\nmov    $0xa,%eax\ncltq\nimul   %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x20(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%edx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    %edx,(%rcx,%rax,4)\njmp    17c9 <initializeData+0x1b3>\nmov    -0x20(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njne    16fd <initializeData+0xe7>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmovl   $0x0,(%rdx,%rax,4)\njmp    17c9 <initializeData+0x1b3>\ncall   4472 <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%ecx\nmov    $0xcccccccd,%eax\nimul   %rcx,%rax\nshr    $0x20,%rax\nmov    %eax,%ebx\nshr    $0x2,%ebx\nmov    %ebx,%eax\nshl    $0x2,%eax\nadd    %ebx,%eax\nmov    %edx,%ebx\nsub    %eax,%ebx\ncall   4472 <libmin_rand>\nmov    %eax,%ecx\nmov    %ecx,%edx\nmov    $0xcccccccd,%eax\nimul   %rdx,%rax\nshr    $0x20,%rax\nshr    $0x2,%eax\nmov    %eax,%edx\nshl    $0x2,%edx\nadd    %eax,%edx\nmov    %ecx,%eax\nsub    %edx,%eax\ncmp    %eax,%ebx\njne    1779 <initializeData+0x163>\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nmovl   $0x0,(%rdx,%rax,4)\njmp    17c9 <initializeData+0x1b3>\ncall   4472 <libmin_rand>\nmov    %eax,%ecx\nmov    %ecx,%edx\nmov    $0xcccccccd,%eax\nimul   %rdx,%rax\nshr    $0x20,%rax\nmov    %eax,%edx\nshr    $0x3,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rcx\nmov    $0xa,%eax\ncltq\nimul   %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x1c(%rbp),%eax\ncltq\nmov    %edx,(%rcx,%rax,4)\naddl   $0x1,-0x1c(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x1c(%rbp)\njl     1667 <initializeData+0x51>\naddl   $0x1,-0x20(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x20(%rbp)\njl     165b <initializeData+0x45>\nnop\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "main", "content": "int\nmain()\n{\n\t// int32_t source = 0;\n\t// int32_t destination = 1;\n\tint32_t graph[V][V];\n\tint32_t path[V];\t\n\tfor(int i=0;i<V;i++){\n\t\tpath[i]=-1;\n\t}\n\tinitializeData(graph);\t\n\tdisplayGraph(graph);\n  minSpanTree(graph,path);\n\n\t// displayPath(source,destination,path);\n\t// displayGraph1(graph, path);\n\tdisplayTree(graph, path);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O0.pseudo", "function_name": "main", "address": "0x1d8f", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  void *v3; // rsp\n  void *v4; // rsp\n  _QWORD v5[3]; // [rsp+8h] [rbp-80h] BYREF\n  int i; // [rsp+24h] [rbp-64h]\n  __int64 v7; // [rsp+28h] [rbp-60h]\n  __int64 v8; // [rsp+30h] [rbp-58h]\n  int32_t (*p_graph)[][]; // [rsp+38h] [rbp-50h]\n  __int64 v10; // [rsp+40h] [rbp-48h]\n  int32_t (*p_path)[]; // [rsp+48h] [rbp-40h]\n  unsigned __int64 v12; // [rsp+50h] [rbp-38h]\n\n  v12 = __readfsqword(0x28u);\n  v7 = 9LL;\n  v8 = 9LL;\n  v3 = alloca(400LL);\n  p_graph = (int32_t (*)[][])v5;\n  v10 = 9LL;\n  v5[0] = 10LL;\n  v5[1] = 0LL;\n  v4 = alloca(48LL);\n  p_path = (int32_t (*)[])v5;\n  for ( i = 0; i < 10; ++i )\n    *((_DWORD *)p_path + i) = -1;\n  initializeData((int32_t (*)[])p_graph);\n  displayGraph((int32_t (*)[])p_graph);\n  minSpanTree((int32_t (*)[])p_graph, (int32_t *)p_path);\n  displayTree((int32_t (*)[])p_graph, (int32_t *)p_path);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  void *v3;\n  void *v4;\n  uint64_t v5[3];\n  int i;\n  long long v7;\n  long long v8;\n  int32_t(*p_graph)[][];\n  long long v10;\n  int32_t(*p_path)[];\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  v7 = 9LL;\n  v8 = 9LL;\n  v3 = alloca(400LL);\n  p_graph = (int32_t(*)[][])v5;\n  v10 = 9LL;\n  v5[0] = 10LL;\n  v5[1] = 0LL;\n  v4 = alloca(48LL);\n  p_path = (int32_t(*)[])v5;\n  for (i = 0; i < 10; ++i) *((uint32_t *)p_path + i) = -1;\n  initializeData((int32_t(*)[])p_graph);\n  displayGraph((int32_t(*)[])p_graph);\n  minSpanTree((int32_t(*)[])p_graph, (int32_t *)p_path);\n  displayTree((int32_t(*)[])p_graph, (int32_t *)p_path);\n  libmin_success();\n}", "binary": "minspan/minspan.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x58,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x38(%rbp)\nxor    %eax,%eax\nmov    %rsp,%rax\nmov    %rax,%rbx\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x60(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%rdx\nmov    $0x0,%ecx\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x58(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%r12\nmov    $0x0,%r13d\nmov    $0xa,%eax\ncltq\nmov    %rax,%r10\nmov    $0x0,%r11d\nmov    %r13,%rdx\nimul   %r10,%rdx\nmov    %r11,%rax\nimul   %r12,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    %r12,%rax\nmul    %r10\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    $0xa,%eax\ncltq\nmov    %rax,%r8\nmov    $0x0,%r9d\nmov    $0xa,%eax\ncltq\nmov    %rax,%rsi\nmov    $0x0,%edi\nmov    %r9,%rdx\nimul   %rsi,%rdx\nmov    %rdi,%rax\nimul   %r8,%rax\nlea    (%rdx,%rax,1),%rcx\nmov    %r8,%rax\nmul    %rsi\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    $0xa,%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    $0x10,%eax\nsub    $0x1,%rax\nadd    %rdx,%rax\nmov    $0x10,%edi\nmov    $0x0,%edx\ndiv    %rdi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     1ec0 <main+0x131>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1ea9 <main+0x11a>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1eea <main+0x15b>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x3,%rax\nshr    $0x2,%rax\nshl    $0x2,%rax\nmov    %rax,-0x50(%rbp)\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x48(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,-0x80(%rbp)\nmovq   $0x0,-0x78(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%r14\nmov    $0x0,%r15d\nmov    $0xa,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    $0x10,%eax\nsub    $0x1,%rax\nadd    %rdx,%rax\nmov    $0x10,%edi\nmov    $0x0,%edx\ndiv    %rdi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     1f82 <main+0x1f3>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1f6b <main+0x1dc>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1fac <main+0x21d>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x3,%rax\nshr    $0x2,%rax\nshl    $0x2,%rax\nmov    %rax,-0x40(%rbp)\nmovl   $0x0,-0x64(%rbp)\njmp    1fdd <main+0x24e>\nmov    -0x40(%rbp),%rax\nmov    -0x64(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0xffffffff,(%rax,%rdx,4)\naddl   $0x1,-0x64(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x64(%rbp)\njl     1fc8 <main+0x239>\nmov    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   1616 <initializeData>\nmov    -0x50(%rbp),%rax\nmov    %rax,%rdi\ncall   17f5 <displayGraph>\nmov    -0x40(%rbp),%rdx\nmov    -0x50(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1297 <minSpanTree>\nmov    -0x40(%rbp),%rdx\nmov    -0x50(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1c30 <displayTree>\ncall   4729 <libmin_success>\nmov    $0x0,%eax\nmov    %rbx,%rsp\nmov    -0x38(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     2046 <main+0x2b7>\ncall   10b0 <__stack_chk_fail@plt>\nlea    -0x28(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "minSpanTree", "content": "// find the shortest path from the source to all other vertexes\nvoid\nminSpanTree(int32_t graph[V][V], int32_t path[V])\n{\n\tint32_t dist[V];\n\n  // KNOWN[I] set to true when the algorithm has linked node I into the minimal spanning tree being built\n\tint known[V];\n\tint32_t min = 0;\n\t\n\tfor (int i=0; i<V; i++)\n  {\n\t\tif (min == i)\n    {\n\t\t\tdist[i] = 0;\n\t\t\tknown[i] = TRUE;\n\t\t}\n    else\n    {\n\t\t\tdist[i] = INT_MAX;\n\t\t\tknown[i] = FALSE;\n\t\t}\n\t}\n\t\t\n\tfor (int i=0;i<V;i++)\n  {\n\t\tfor (int j = 0;j<V;j++)\n    {\n\t\t\tif (!known[j] && (graph[min][j] != 0) && (graph[min][j] < dist[j]))\n      {\n\t\t\t\tdist[j] = graph[min][j];\n\t\t\t\tpath[j] = min;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tmin = minVal(dist, known);\n\t}\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O0.pseudo", "function_name": "minSpanTree", "address": "0x1297", "label": "minSpanTree", "content": "void __cdecl minSpanTree(int32_t (*graph)[], int32_t *path)\n{\n  void *v2; // rsp\n  void *v3; // rsp\n  int32_t *patha; // [rsp+8h] [rbp-80h] BYREF\n  int32_t (*grapha)[]; // [rsp+10h] [rbp-78h]\n  int32_t min; // [rsp+18h] [rbp-70h]\n  int i; // [rsp+1Ch] [rbp-6Ch]\n  int i_0; // [rsp+20h] [rbp-68h]\n  int j; // [rsp+24h] [rbp-64h]\n  __int64 v10; // [rsp+28h] [rbp-60h]\n  __int64 v11; // [rsp+30h] [rbp-58h]\n  int32_t (*p_dist)[]; // [rsp+38h] [rbp-50h]\n  __int64 v13; // [rsp+40h] [rbp-48h]\n  int (*p_known)[]; // [rsp+48h] [rbp-40h]\n  unsigned __int64 v15; // [rsp+50h] [rbp-38h]\n\n  grapha = graph;\n  patha = path;\n  v15 = __readfsqword(0x28u);\n  v10 = 9LL;\n  v11 = 9LL;\n  v2 = alloca(48LL);\n  p_dist = (int32_t (*)[])&patha;\n  v13 = 9LL;\n  v3 = alloca(48LL);\n  p_known = (int (*)[])&patha;\n  min = 0;\n  for ( i = 0; i < 10; ++i )\n  {\n    if ( min == i )\n    {\n      *((_DWORD *)p_dist + i) = 0;\n      *((_DWORD *)p_known + i) = 1;\n    }\n    else\n    {\n      *((_DWORD *)p_dist + i) = 0x7FFFFFFF;\n      *((_DWORD *)p_known + i) = 0;\n    }\n  }\n  for ( i_0 = 0; i_0 < 10; ++i_0 )\n  {\n    for ( j = 0; j < 10; ++j )\n    {\n      if ( !*((_DWORD *)p_known + j)\n        && *((_DWORD *)grapha + 10 * min + j)\n        && *((_DWORD *)grapha + 10 * min + j) < *((_DWORD *)p_dist + j) )\n      {\n        *((_DWORD *)p_dist + j) = *((_DWORD *)grapha + 10 * min + j);\n        patha[j] = min;\n      }\n    }\n    min = minVal((int32_t *)p_dist, (int *)p_known);\n  }\n}\n"}, "pseudo_normalize": "void minSpanTree(int32_t (*graph)[], int32_t *path) {\n  void *v2;\n  void *v3;\n  int32_t *patha;\n  int32_t(*grapha)[];\n  int32_t min;\n  int i;\n  int i_0;\n  int j;\n  long long v10;\n  long long v11;\n  int32_t(*p_dist)[];\n  long long v13;\n  int(*p_known)[];\n  unsigned long long v15;\n  grapha = graph;\n  patha = path;\n  v15 = __readfsqword(40u);\n  v10 = 9LL;\n  v11 = 9LL;\n  v2 = alloca(48LL);\n  p_dist = (int32_t(*)[]) & patha;\n  v13 = 9LL;\n  v3 = alloca(48LL);\n  p_known = (int(*)[]) & patha;\n  min = 0;\n  for (i = 0; i < 10; ++i) {\n    if (min == i) {\n      *((uint32_t *)p_dist + i) = 0;\n      *((uint32_t *)p_known + i) = 1;\n    } else {\n      *((uint32_t *)p_dist + i) = 2147483647;\n      *((uint32_t *)p_known + i) = 0;\n    }\n  }\n  for (i_0 = 0; i_0 < 10; ++i_0) {\n    for (j = 0; j < 10; ++j) {\n      if (!*((uint32_t *)p_known + j) && *((uint32_t *)grapha + 10 * min + j) &&\n          *((uint32_t *)grapha + 10 * min + j) < *((uint32_t *)p_dist + j)) {\n        *((uint32_t *)p_dist + j) = *((uint32_t *)grapha + 10 * min + j);\n        patha[j] = min;\n      }\n    }\n    min = minVal((int32_t *)p_dist, (int *)p_known);\n  }\n}", "binary": "minspan/minspan.host.O0", "assembly": "<minSpanTree>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x58,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x38(%rbp)\nxor    %eax,%eax\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x60(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%rcx\nmov    $0x0,%ebx\nmov    %rsp,%rax\nmov    %rax,%rbx\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x58(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%r14\nmov    $0x0,%r15d\nmov    $0xa,%eax\ncltq\nmov    %rax,%r12\nmov    $0x0,%r13d\nmov    $0xa,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    $0x10,%eax\nsub    $0x1,%rax\nadd    %rdx,%rax\nmov    $0x10,%esi\nmov    $0x0,%edx\ndiv    %rsi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     1369 <minSpanTree+0xd2>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1352 <minSpanTree+0xbb>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1393 <minSpanTree+0xfc>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x3,%rax\nshr    $0x2,%rax\nshl    $0x2,%rax\nmov    %rax,-0x50(%rbp)\nmov    $0xa,%eax\ncltq\nsub    $0x1,%rax\nmov    %rax,-0x48(%rbp)\nmov    $0xa,%eax\ncltq\nmov    %rax,%r10\nmov    $0x0,%r11d\nmov    $0xa,%eax\ncltq\nmov    %rax,%r8\nmov    $0x0,%r9d\nmov    $0xa,%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    $0x10,%eax\nsub    $0x1,%rax\nadd    %rdx,%rax\nmov    $0x10,%edi\nmov    $0x0,%edx\ndiv    %rdi\nimul   $0x10,%rax,%rax\nmov    %rax,%rcx\nand    $0xfffffffffffff000,%rcx\nmov    %rsp,%rdx\nsub    %rcx,%rdx\ncmp    %rdx,%rsp\nje     1428 <minSpanTree+0x191>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1411 <minSpanTree+0x17a>\nmov    %rax,%rdx\nand    $0xfff,%edx\nsub    %rdx,%rsp\nmov    %rax,%rdx\nand    $0xfff,%edx\ntest   %rdx,%rdx\nje     1452 <minSpanTree+0x1bb>\nand    $0xfff,%eax\nsub    $0x8,%rax\nadd    %rsp,%rax\norq    $0x0,(%rax)\nmov    %rsp,%rax\nadd    $0x3,%rax\nshr    $0x2,%rax\nshl    $0x2,%rax\nmov    %rax,-0x40(%rbp)\nmovl   $0x0,-0x70(%rbp)\nmovl   $0x0,-0x6c(%rbp)\njmp    14c7 <minSpanTree+0x230>\nmov    -0x70(%rbp),%eax\ncmp    -0x6c(%rbp),%eax\njne    14a1 <minSpanTree+0x20a>\nmov    -0x50(%rbp),%rax\nmov    -0x6c(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0x0,(%rax,%rdx,4)\nmov    -0x40(%rbp),%rax\nmov    -0x6c(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0x1,(%rax,%rdx,4)\njmp    14c3 <minSpanTree+0x22c>\nmov    -0x50(%rbp),%rax\nmov    -0x6c(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0x7fffffff,(%rax,%rdx,4)\nmov    -0x40(%rbp),%rax\nmov    -0x6c(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0x0,(%rax,%rdx,4)\naddl   $0x1,-0x6c(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x6c(%rbp)\njl     1475 <minSpanTree+0x1de>\nmovl   $0x0,-0x68(%rbp)\njmp    15e1 <minSpanTree+0x34a>\nmovl   $0x0,-0x64(%rbp)\njmp    15b9 <minSpanTree+0x322>\nmov    -0x40(%rbp),%rax\nmov    -0x64(%rbp),%edx\nmovslq %edx,%rdx\nmov    (%rax,%rdx,4),%eax\ntest   %eax,%eax\njne    15b5 <minSpanTree+0x31e>\nmov    -0x70(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x78(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x64(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\nje     15b5 <minSpanTree+0x31e>\nmov    -0x70(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x78(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x64(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%ecx\nmov    -0x50(%rbp),%rax\nmov    -0x64(%rbp),%edx\nmovslq %edx,%rdx\nmov    (%rax,%rdx,4),%eax\ncmp    %eax,%ecx\njge    15b5 <minSpanTree+0x31e>\nmov    -0x70(%rbp),%eax\nmovslq %eax,%rdx\nmov    $0xa,%eax\ncltq\nimul   %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x78(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x64(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%ecx\nmov    -0x50(%rbp),%rax\nmov    -0x64(%rbp),%edx\nmovslq %edx,%rdx\nmov    %ecx,(%rax,%rdx,4)\nmov    -0x64(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x80(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x70(%rbp),%eax\nmov    %eax,(%rdx)\naddl   $0x1,-0x64(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x64(%rbp)\njl     14e9 <minSpanTree+0x252>\nmov    -0x40(%rbp),%rdx\nmov    -0x50(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <minVal>\nmov    %eax,-0x70(%rbp)\naddl   $0x1,-0x68(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x68(%rbp)\njl     14dd <minSpanTree+0x246>\nmov    %rbx,%rsp\nnop\nmov    -0x38(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1607 <minSpanTree+0x370>\ncall   10b0 <__stack_chk_fail@plt>\nlea    -0x28(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "minVal", "content": "// find the vertex with min distance from the unknown vertexes\nint32_t\nminVal(int32_t *dist, int *known)\n{\n\tint32_t min = -1;\n\tint32_t distVal = INT_MAX;\n\t\t\t\n\tfor (int i=0; i<V; i++)\n  {\n\t\tif (distVal>dist[i] && !known[i])\n    {\n\t\t\tdistVal = dist[i];\n\t\t\tmin = i;\n\t\t}\t\t\t\t\t\n\t}\n\t\t\t\t\n  if (min != -1)\n    known[min] = TRUE;\n  return min;\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O0.pseudo", "function_name": "minVal", "address": "0x11e9", "label": "minVal", "content": "int32_t __cdecl minVal(int32_t *dist, int *known)\n{\n  int32_t min; // [rsp+14h] [rbp-Ch]\n  int32_t distVal; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  min = -1;\n  distVal = 0x7FFFFFFF;\n  for ( i = 0; i < 10; ++i )\n  {\n    if ( distVal > dist[i] && !known[i] )\n    {\n      distVal = dist[i];\n      min = i;\n    }\n  }\n  if ( min != -1 )\n    known[min] = 1;\n  return min;\n}\n"}, "pseudo_normalize": "int32_t minVal(int32_t *dist, int *known) {\n  int32_t min;\n  int32_t distVal;\n  int i;\n  min = -1;\n  distVal = 2147483647;\n  for (i = 0; i < 10; ++i) {\n    if (distVal > dist[i] && !known[i]) {\n      distVal = dist[i];\n      min = i;\n    }\n  }\n  if (min != -1) known[min] = 1;\n  return min;\n}", "binary": "minspan/minspan.host.O0", "assembly": "<minVal>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0xffffffff,-0xc(%rbp)\nmovl   $0x7fffffff,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1268 <minVal+0x7f>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ncmp    %eax,-0x8(%rbp)\njle    1264 <minVal+0x7b>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    1264 <minVal+0x7b>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %eax,-0xc(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    $0xa,%eax\ncmp    %eax,-0x4(%rbp)\njl     1210 <minVal+0x27>\ncmpl   $0xffffffff,-0xc(%rbp)\nje     1292 <minVal+0xa9>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\nmov    -0xc(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "monte-carlo/monte-carlo.c", "function_name": "main", "content": "#include \"libmin.h\"\n\n#define NUM_SAMPLES 25000  // samples\n\nint\nmain(void)\n{\n  int count_inside_circle = 0;\n  double x, y;\n\n  // Seed the random number generator\n  libmin_srand(42);\n\n  for (int i = 0; i < NUM_SAMPLES; ++i)\n  {\n    // Generate random (x, y) point in [0, 1]  [0, 1]\n    x = (double)libmin_rand() / RAND_MAX;\n    y = (double)libmin_rand() / RAND_MAX;\n\n    // Check if the point is inside the unit circle\n    if (x*x + y*y <= 1.0)\n      count_inside_circle++;\n  }\n\n  // Estimate Pi\n  double pi_estimate = 4.0 * count_inside_circle / NUM_SAMPLES;\n\n  // Output result\n  libmin_printf(\"Estimated Pi = %.8f\\n\", pi_estimate);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "monte-carlo/monte-carlo.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int count_inside_circle; // [rsp+0h] [rbp-20h]\n  int i; // [rsp+4h] [rbp-1Ch]\n  double x; // [rsp+10h] [rbp-10h]\n  double y; // [rsp+18h] [rbp-8h]\n\n  count_inside_circle = 0;\n  libmin_srand(0x2Au);\n  for ( i = 0; i <= 24999; ++i )\n  {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    y = (double)(int)libmin_rand() / 2147483647.0;\n    if ( x * x + y * y <= 1.0 )\n      ++count_inside_circle;\n  }\n  libmin_printf(\"Estimated Pi = %.8f\\n\", 4.0 * (double)count_inside_circle / 25000.0);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int count_inside_circle;\n  int i;\n  double x;\n  double y;\n  count_inside_circle = 0;\n  libmin_srand(42u);\n  for (i = 0; i <= 24999; ++i) {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    y = (double)(int)libmin_rand() / 2147483647.0;\n    if (x * x + y * y <= 1.0) ++count_inside_circle;\n  }\n  libmin_printf(\"Estimated Pi = %.8f\\n\",\n                4.0 * (double)count_inside_circle / 25000.0);\n  libmin_success();\n}", "binary": "monte-carlo/monte-carlo.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovl   $0x0,-0x20(%rbp)\nmov    $0x2a,%edi\ncall   368b <libmin_srand>\nmovl   $0x0,-0x1c(%rbp)\njmp    12c4 <main+0xdb>\ncall   373d <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     1229 <main+0x40>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1242 <main+0x59>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x2dd6(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\ncall   373d <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     126a <main+0x81>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1283 <main+0x9a>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x2d95(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x8(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x2d72(%rip),%xmm0\ncomisd %xmm1,%xmm0\njb     12c0 <main+0xd7>\naddl   $0x1,-0x20(%rbp)\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x61a7,-0x1c(%rbp)\njle    1212 <main+0x29>\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x20(%rbp),%xmm1\nmovsd  0x2d4e(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  0x2d4a(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x2d01(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   345c <libmin_printf>\ncall   39f4 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "murmur-hash/murmur-hash.c", "function_name": "main", "content": "int\nmain(void)\n{\n    uint32_t seed = 0;\n\n    {\n      const char *key = \"kinkajou\"; // 0xb6d99cf8\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    {\n      const char *key = \"The bringup-bench benchmark MURMUR made this.\";\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    {\n      const char *key = \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\";\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "murmur-hash/murmur-hash.host.O0.pseudo", "function_name": "main", "address": "0x13a9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint32_t v3; // ecx\n  uint32_t v4; // ecx\n  uint32_t v5; // ecx\n  uint32_t hash; // [rsp+Ch] [rbp-24h]\n  uint32_t hash_0; // [rsp+10h] [rbp-20h]\n  uint32_t hash_1; // [rsp+14h] [rbp-1Ch]\n\n  v3 = libmin_strlen(\"kinkajou\");\n  hash = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", hash);\n  v4 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  hash_0 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v4, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"The bringup-bench benchmark MURMUR made this.\", hash_0);\n  v5 = libmin_strlen(\"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\");\n  hash_1 = murmurhash(\n             \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n             v5,\n             0);\n  libmin_printf(\n    \"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n    \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n    hash_1);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  uint32_t v3;\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t hash;\n  uint32_t hash_0;\n  uint32_t hash_1;\n  v3 = libmin_strlen(\"kinkajou\");\n  hash = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", hash);\n  v4 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  hash_0 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v4, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"The bringup-bench benchmark MURMUR made this.\", hash_0);\n  v5 = libmin_strlen(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\");\n  hash_1 = murmurhash(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\",\n      v5, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"It has to start somewhere, it has to start sometime, what \"\n                \"better place than here? What better time than now?\",\n                hash_1);\n  libmin_success();\n}", "binary": "murmur-hash/murmur-hash.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmovl   $0x0,-0x28(%rbp)\nlea    0x2c45(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   3814 <libmin_strlen>\nmov    %eax,%ecx\nmov    -0x28(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <murmurhash>\nmov    %eax,-0x24(%rbp)\nmov    -0x24(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2c17(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35e5 <libmin_printf>\nlea    0x2c22(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   3814 <libmin_strlen>\nmov    %eax,%ecx\nmov    -0x28(%rbp),%edx\nmov    -0x10(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <murmurhash>\nmov    %eax,-0x20(%rbp)\nmov    -0x20(%rbp),%edx\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2bcc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35e5 <libmin_printf>\nlea    0x2c07(%rip),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   3814 <libmin_strlen>\nmov    %eax,%ecx\nmov    -0x28(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <murmurhash>\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    -0x8(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2b81(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35e5 <libmin_printf>\ncall   3852 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "murmur-hash/murmur-hash.c", "function_name": "murmurhash", "content": "/**\n * `murmurhash.h' - murmurhash\n *\n * copyright (c) 2014-2022 joseph werle <joseph.werle@gmail.com>\n */\n\nuint32_t\nmurmurhash (const char *key, uint32_t len, uint32_t seed)\n{\n  uint32_t c1 = 0xcc9e2d51;\n  uint32_t c2 = 0x1b873593;\n  uint32_t r1 = 15;\n  uint32_t r2 = 13;\n  uint32_t m = 5;\n  uint32_t n = 0xe6546b64;\n  uint32_t h = 0;\n  uint32_t k = 0;\n  uint8_t *d = (uint8_t *) key; // 32 bit extract from `key'\n  const uint32_t *chunks = NULL;\n  const uint8_t *tail = NULL; // tail - last 8 bytes\n  int i = 0;\n  int l = len / 4; // chunk length\n\n  h = seed;\n\n  chunks = (const uint32_t *) (d + l * 4); // body\n  tail = (const uint8_t *) (d + l * 4); // last 8 byte chunk of `key'\n\n  // for each 4 byte chunk of `key'\n  for (i = -l; i != 0; ++i) {\n    // next 4 byte chunk of `key'\n    k = chunks[i];\n\n    // encode next 4 byte chunk of `key'\n    k *= c1;\n    k = (k << r1) | (k >> (32 - r1));\n    k *= c2;\n\n    // append to hash\n    h ^= k;\n    h = (h << r2) | (h >> (32 - r2));\n    h = h * m + n;\n  }\n\n  k = 0;\n\n  // remainder\n  switch (len & 3) { // `len % 4'\n    case 3: k ^= (tail[2] << 16);\n    case 2: k ^= (tail[1] << 8);\n\n    case 1:\n      k ^= tail[0];\n      k *= c1;\n      k = (k << r1) | (k >> (32 - r1));\n      k *= c2;\n      h ^= k;\n  }\n\n  h ^= len;\n\n  h ^= (h >> 16);\n  h *= 0x85ebca6b;\n  h ^= (h >> 13);\n  h *= 0xc2b2ae35;\n  h ^= (h >> 16);\n\n  return h;\n}\n"}, "pseudo": {"path": "murmur-hash/murmur-hash.host.O0.pseudo", "function_name": "murmurhash", "address": "0x11e9", "label": "murmurhash", "content": "uint32_t __cdecl murmurhash(const char *key, uint32_t len, uint32_t seed)\n{\n  uint32_t v3; // eax\n  uint32_t ha; // [rsp+10h] [rbp-40h]\n  uint32_t k; // [rsp+14h] [rbp-3Ch]\n  int i; // [rsp+18h] [rbp-38h]\n  const uint8_t *tail; // [rsp+48h] [rbp-8h]\n\n  tail = (const uint8_t *)&key[4 * (len >> 2)];\n  for ( i = -(len >> 2); i; ++i )\n    seed = 5 * __ROL4__((461845907 * __ROL4__(-862048943 * *(_DWORD *)&key[4 * i + 4 * (len >> 2)], 15)) ^ seed, 13)\n         - 430675100;\n  k = 0;\n  v3 = len & 3;\n  if ( v3 == 3 )\n  {\n    k = tail[2] << 16;\n    goto LABEL_10;\n  }\n  if ( v3 <= 3 )\n  {\n    if ( v3 == 1 )\n    {\nLABEL_11:\n      seed ^= 461845907 * __ROL4__(-862048943 * (*tail ^ k), 15);\n      goto LABEL_12;\n    }\n    if ( v3 != 2 )\n      goto LABEL_12;\nLABEL_10:\n    k ^= tail[1] << 8;\n    goto LABEL_11;\n  }\nLABEL_12:\n  ha = -2048144789 * (((len ^ seed) >> 16) ^ len ^ seed);\n  return ((-1028477387 * ((ha >> 13) ^ ha)) >> 16) ^ (-1028477387 * ((ha >> 13) ^ ha));\n}\n"}, "pseudo_normalize": "uint32_t murmurhash(const char *key, uint32_t len, uint32_t seed) {\n  uint32_t v3;\n  uint32_t ha;\n  uint32_t k;\n  int i;\n  const uint8_t *tail;\n  tail = (const uint8_t *)&key[4 * (len >> 2)];\n  for (i = -(len >> 2); i; ++i)\n    seed = 5 * __ROL4__((461845907 *\n                         __ROL4__(-862048943 *\n                                      *(uint32_t *)&key[4 * i + 4 * (len >> 2)],\n                                  15)) ^\n                            seed,\n                        13) -\n           430675100;\n  k = 0;\n  v3 = len & 3;\n  if (v3 == 3) {\n    k = tail[2] << 16;\n    goto LABEL_10;\n  }\n  if (v3 <= 3) {\n    if (v3 == 1) {\n    LABEL_11:\n      seed ^= 461845907 * __ROL4__(-862048943 * (*tail ^ k), 15);\n      goto LABEL_12;\n    }\n    if (v3 != 2) goto LABEL_12;\n  LABEL_10:\n    k ^= tail[1] << 8;\n    goto LABEL_11;\n  }\nLABEL_12:\n  ha = -2048144789 * (((len ^ seed) >> 16) ^ len ^ seed);\n  return ((-1028477387 * ((ha >> 13) ^ ha)) >> 16) ^\n         (-1028477387 * ((ha >> 13) ^ ha));\n}", "binary": "murmur-hash/murmur-hash.host.O0", "assembly": "<murmurhash>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x48(%rbp)\nmov    %esi,-0x4c(%rbp)\nmov    %edx,-0x50(%rbp)\nmovl   $0xcc9e2d51,-0x34(%rbp)\nmovl   $0x1b873593,-0x30(%rbp)\nmovl   $0xf,-0x2c(%rbp)\nmovl   $0xd,-0x28(%rbp)\nmovl   $0x5,-0x24(%rbp)\nmovl   $0xe6546b64,-0x20(%rbp)\nmovl   $0x0,-0x40(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmov    -0x48(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nmovq   $0x0,-0x10(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmov    -0x4c(%rbp),%eax\nshr    $0x2,%eax\nmov    %eax,-0x1c(%rbp)\nmov    -0x50(%rbp),%eax\nmov    %eax,-0x40(%rbp)\nmov    -0x1c(%rbp),%eax\nshl    $0x2,%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x1c(%rbp),%eax\nshl    $0x2,%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x1c(%rbp),%eax\nneg    %eax\nmov    %eax,-0x38(%rbp)\njmp    12eb <murmurhash+0x102>\nmov    -0x38(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nimul   -0x34(%rbp),%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,%ecx\nroll   %cl,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nimul   -0x30(%rbp),%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nxor    %eax,-0x40(%rbp)\nmov    -0x28(%rbp),%eax\nmov    %eax,%ecx\nroll   %cl,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nimul   -0x24(%rbp),%eax\nmov    %eax,%edx\nmov    -0x20(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x40(%rbp)\naddl   $0x1,-0x38(%rbp)\ncmpl   $0x0,-0x38(%rbp)\njne    1293 <murmurhash+0xaa>\nmovl   $0x0,-0x3c(%rbp)\nmov    -0x4c(%rbp),%eax\nand    $0x3,%eax\ncmp    $0x3,%eax\nje     1314 <murmurhash+0x12b>\ncmp    $0x3,%eax\nja     136b <murmurhash+0x182>\ncmp    $0x1,%eax\nje     133c <murmurhash+0x153>\ncmp    $0x2,%eax\nje     1328 <murmurhash+0x13f>\njmp    136b <murmurhash+0x182>\nmov    -0x8(%rbp),%rax\nadd    $0x2,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nshl    $0x10,%eax\nxor    %eax,-0x3c(%rbp)\nmov    -0x8(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nshl    $0x8,%eax\nxor    %eax,-0x3c(%rbp)\nmov    -0x8(%rbp),%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\nxor    %eax,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nimul   -0x34(%rbp),%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x2c(%rbp),%eax\nmov    %eax,%ecx\nroll   %cl,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nimul   -0x30(%rbp),%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\nxor    %eax,-0x40(%rbp)\nmov    -0x4c(%rbp),%eax\nxor    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nshr    $0x10,%eax\nxor    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nimul   $0x85ebca6b,%eax,%eax\nmov    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nshr    $0xd,%eax\nxor    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nimul   $0xc2b2ae35,%eax,%eax\nmov    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nshr    $0x10,%eax\nxor    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "n-queens/n-queens.c", "function_name": "is_safe", "content": "// Check if placing a queen at (row, col) is safe\nint\nis_safe(int queens[], int row, int col)\n{\n  for (int i = 0; i < row; i++)\n  {\n    int q_col = queens[i];\n    if (q_col == col || libmin_abs(q_col - col) == libmin_abs(i - row))\n      return FALSE;\n  }\n  return TRUE;\n}\n"}, "pseudo": {"path": "n-queens/n-queens.host.O0.pseudo", "function_name": "is_safe", "address": "0x11e9", "label": "is_safe", "content": "int __cdecl is_safe(int *queens, int row, int col)\n{\n  int v3; // ebx\n  int i; // [rsp+18h] [rbp-18h]\n  int q_col; // [rsp+1Ch] [rbp-14h]\n\n  for ( i = 0; i < row; ++i )\n  {\n    q_col = queens[i];\n    if ( q_col != col )\n    {\n      v3 = libmin_abs(q_col - col);\n      if ( v3 != libmin_abs(i - row) )\n        continue;\n    }\n    return 0;\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int is_safe(int *queens, int row, int col) {\n  int v3;\n  int i;\n  int q_col;\n  for (i = 0; i < row; ++i) {\n    q_col = queens[i];\n    if (q_col != col) {\n      v3 = libmin_abs(q_col - col);\n      if (v3 != libmin_abs(i - row)) continue;\n    }\n    return 0;\n  }\n  return 1;\n}", "binary": "n-queens/n-queens.host.O0", "assembly": "<is_safe>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %edx,-0x30(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    1255 <is_safe+0x6c>\nmov    -0x18(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncmp    -0x30(%rbp),%eax\nje     124a <is_safe+0x61>\nmov    -0x14(%rbp),%eax\nsub    -0x30(%rbp),%eax\nmov    %eax,%edi\ncall   1492 <libmin_abs>\nmov    %eax,%ebx\nmov    -0x18(%rbp),%eax\nsub    -0x2c(%rbp),%eax\nmov    %eax,%edi\ncall   1492 <libmin_abs>\ncmp    %eax,%ebx\njne    1251 <is_safe+0x68>\nmov    $0x0,%eax\njmp    1262 <is_safe+0x79>\naddl   $0x1,-0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x2c(%rbp),%eax\njl     1209 <is_safe+0x20>\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "n-queens/n-queens.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int *queens = (int *)libmin_malloc(BOARD_SIZE * sizeof(int));\n\n  solve(queens, 0);\n\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", BOARD_SIZE, solution_count);\n\n  libmin_free(queens);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "n-queens/n-queens.host.O0.pseudo", "function_name": "main", "address": "0x12ec", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *queens; // [rsp+8h] [rbp-8h]\n\n  queens = (int *)libmin_malloc(0x28uLL);\n  solve(queens, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(queens);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int *queens;\n  queens = (int *)libmin_malloc(40uLL);\n  solve(queens, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(queens);\n  libmin_success();\n}", "binary": "n-queens/n-queens.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x28,%edi\ncall   14fa <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x0,%esi\nmov    %rax,%rdi\ncall   1268 <solve>\nmov    0x4f4f(%rip),%eax\nmov    %eax,%edx\nmov    $0xa,%esi\nlea    0x2cdd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   395c <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   15e5 <libmin_free>\ncall   3bc9 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "n-queens/n-queens.c", "function_name": "solve", "content": "// Recursive backtracking solver\nvoid\nsolve(int queens[], int row)\n{\n  if (row == BOARD_SIZE)\n  {\n    solution_count++;\n    return;\n  }\n  for (int col = 0; col < BOARD_SIZE; col++)\n  {\n    if (is_safe(queens, row, col))\n    {\n      queens[row] = col;\n      solve(queens, row + 1);\n    }\n  }\n}\n"}, "pseudo": {"path": "n-queens/n-queens.host.O0.pseudo", "function_name": "solve", "address": "0x1268", "label": "solve", "content": "void __cdecl solve(int *queens, int row)\n{\n  int col; // [rsp+1Ch] [rbp-4h]\n\n  if ( row == 10 )\n  {\n    ++solution_count;\n  }\n  else\n  {\n    for ( col = 0; col <= 9; ++col )\n    {\n      if ( is_safe(queens, row, col) )\n      {\n        queens[row] = col;\n        solve(queens, row + 1);\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void solve(int *queens, int row) {\n  int col;\n  if (row == 10) {\n    ++solution_count;\n  } else {\n    for (col = 0; col <= 9; ++col) {\n      if (is_safe(queens, row, col)) {\n        queens[row] = col;\n        solve(queens, row + 1);\n      }\n    }\n  }\n}", "binary": "n-queens/n-queens.host.O0", "assembly": "<solve>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\ncmpl   $0xa,-0x1c(%rbp)\njne    1292 <solve+0x2a>\nmov    0x4fe5(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x4fdc(%rip)\njmp    12ea <solve+0x82>\nmovl   $0x0,-0x4(%rbp)\njmp    12e4 <solve+0x7c>\nmov    -0x4(%rbp),%edx\nmov    -0x1c(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   11e9 <is_safe>\ntest   %eax,%eax\nje     12e0 <solve+0x78>\nmov    -0x1c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\nmov    -0x1c(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    -0x18(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1268 <solve>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njle    129b <solve+0x33>\nleave\nret\n"}
{"source": {"path": "natlog/natlog.c", "function_name": "main", "content": "#include \"libmin.h\"\n\n/* calculate e=2.718..., using an interative approximation */\n\nint\nmain(void)\n{\n  /* STEPS is usually a very large number eg 10000000 */\n  int steps = 100000;\n  double x, y;\n\n  y = 1.0 + 1.0/steps;\n  x = 1.0;\n\n  for(; steps > 0; steps--)\n    x *= y;\n\n  libmin_printf(\"natlog: e=%f\\n\", x);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "natlog/natlog.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int steps; // [rsp+Ch] [rbp-14h]\n  double x; // [rsp+10h] [rbp-10h]\n\n  steps = 100000;\n  x = 1.0;\n  while ( steps > 0 )\n  {\n    x = x * (1.0 / (double)100000 + 1.0);\n    --steps;\n  }\n  libmin_printf(\"natlog: e=%f\\n\", x);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int steps;\n  double x;\n  steps = 100000;\n  x = 1.0;\n  while (steps > 0) {\n    x = x * (1.0 / (double)100000 + 1.0);\n    --steps;\n  }\n  libmin_printf(\"natlog: e=%f\\n\", x);\n  libmin_success();\n}", "binary": "natlog/natlog.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovl   $0x186a0,-0x14(%rbp)\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x14(%rbp),%xmm2\nmovsd  0x2e0b(%rip),%xmm0\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x2dfb(%rip),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  0x2dea(%rip),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\njmp    1248 <main+0x5f>\nmovsd  -0x10(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nsubl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njg     1235 <main+0x4c>\nmov    -0x10(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x2daa(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   33b3 <libmin_printf>\ncall   3620 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "nbody-sim/nbody-sim.c", "function_name": "main", "content": "int main(void) {\n    // Initialize three particles with arbitrary masses, positions (in meters), and velocities (in m/s)\n    Particle bodies[N_BODIES] = {\n        {1e24, {0.0,    0.0,    0.0},    {0.0,    0.0, 0.0}},      // Body 0\n        {1e24, {1e8,    0.0,    0.0},    {0.0,  1e3, 0.0}},      // Body 1\n        {1e24, {0.0,    1e8,    0.0},    {-1e3,   0.0, 0.0}}       // Body 2\n    };\n\n    // Time integration loop using Euler integration\n    for (int step = 0; step < NUM_STEPS; step++) {\n        // Array to store computed accelerations for each particle\n        double acc[N_BODIES][3] = { {0.0} };\n        \n        // Compute gravitational acceleration for each particle\n        for (int i = 0; i < N_BODIES; i++) {\n            for (int j = 0; j < N_BODIES; j++) {\n                if (i == j) \n                    continue; // Skip self-interaction\n                \n                // Compute difference vector between particle j and i\n                double dx = bodies[j].pos[0] - bodies[i].pos[0];\n                double dy = bodies[j].pos[1] - bodies[i].pos[1];\n                double dz = bodies[j].pos[2] - bodies[i].pos[2];\n                \n                // Compute squared distance (with softening factor to avoid division by zero)\n                double r2 = dx * dx + dy * dy + dz * dz + EPS;\n                double r = libmin_sqrt(r2);\n                \n                // Compute acceleration magnitude: a = G * m_j / r^2\n                // Multiply by (dx, dy, dz)/r to get the vector\n                double a = G * bodies[j].mass / r2;\n                acc[i][0] += a * (dx / r);\n                acc[i][1] += a * (dy / r);\n                acc[i][2] += a * (dz / r);\n            }\n        }\n        \n        // Update velocities and positions of each particle using the computed accelerations\n        for (int i = 0; i < N_BODIES; i++) {\n            bodies[i].vel[0] += acc[i][0] * DT;\n            bodies[i].vel[1] += acc[i][1] * DT;\n            bodies[i].vel[2] += acc[i][2] * DT;\n            \n            bodies[i].pos[0] += bodies[i].vel[0] * DT;\n            bodies[i].pos[1] += bodies[i].vel[1] * DT;\n            bodies[i].pos[2] += bodies[i].vel[2] * DT;\n        }\n    }\n\n    // Print final positions and velocities after the simulation\n    libmin_printf(\"Final state after %d steps:\\n\", NUM_STEPS);\n    for (int i = 0; i < N_BODIES; i++) {\n        libmin_printf(\"Body %d:\\n\", i);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", \n               bodies[i].pos[0], bodies[i].pos[1], bodies[i].pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", \n               bodies[i].vel[0], bodies[i].vel[1], bodies[i].vel[2]);\n    }\n    \n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "nbody-sim/nbody-sim.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int step; // [rsp+Ch] [rbp-144h]\n  int i; // [rsp+10h] [rbp-140h]\n  int j; // [rsp+14h] [rbp-13Ch]\n  int i_0; // [rsp+18h] [rbp-138h]\n  int i_1; // [rsp+1Ch] [rbp-134h]\n  double dx_0; // [rsp+20h] [rbp-130h]\n  double dy; // [rsp+28h] [rbp-128h]\n  double dz; // [rsp+30h] [rbp-120h]\n  double r2; // [rsp+38h] [rbp-118h]\n  double r; // [rsp+40h] [rbp-110h]\n  double a; // [rsp+48h] [rbp-108h]\n  double acc[10]; // [rsp+50h] [rbp-100h] BYREF\n  Particle bodies[3]; // [rsp+A0h] [rbp-B0h]\n  unsigned __int64 v16; // [rsp+148h] [rbp-8h]\n\n  v16 = __readfsqword(0x28u);\n  bodies[0].mass = 1.0e24;\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].mass = 1.0e24;\n  bodies[1].pos[0] = 100000000.0;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[1] = 1000.0;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[1] = 100000000.0;\n  bodies[2].pos[2] = 0.0;\n  bodies[2].vel[0] = -1000.0;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  for ( step = 0; step <= 999; ++step )\n  {\n    memset(acc, 0, 72);\n    for ( i = 0; i <= 2; ++i )\n    {\n      for ( j = 0; j <= 2; ++j )\n      {\n        if ( i != j )\n        {\n          dx_0 = bodies[j].pos[0] - bodies[i].pos[0];\n          dy = bodies[j].pos[1] - bodies[i].pos[1];\n          dz = bodies[j].pos[2] - bodies[i].pos[2];\n          r2 = dx_0 * dx_0 + dy * dy + dz * dz + 2.220446049250313e-16;\n          r = libmin_sqrt(r2);\n          a = 6.674299999999999e-11 * bodies[j].mass / r2;\n          acc[3 * i] = dx_0 / r * a + acc[3 * i];\n          acc[3 * i + 1] = dy / r * a + acc[3 * i + 1];\n          acc[3 * i + 2] = dz / r * a + acc[3 * i + 2];\n        }\n      }\n    }\n    for ( i_0 = 0; i_0 <= 2; ++i_0 )\n    {\n      bodies[i_0].vel[0] = 0.01 * acc[3 * i_0] + bodies[i_0].vel[0];\n      bodies[i_0].vel[1] = 0.01 * acc[3 * i_0 + 1] + bodies[i_0].vel[1];\n      bodies[i_0].vel[2] = 0.01 * acc[3 * i_0 + 2] + bodies[i_0].vel[2];\n      bodies[i_0].pos[0] = 0.01 * bodies[i_0].vel[0] + bodies[i_0].pos[0];\n      bodies[i_0].pos[1] = 0.01 * bodies[i_0].vel[1] + bodies[i_0].pos[1];\n      bodies[i_0].pos[2] = 0.01 * bodies[i_0].vel[2] + bodies[i_0].pos[2];\n    }\n  }\n  libmin_printf(\"Final state after %d steps:\\n\", 1000);\n  for ( i_1 = 0; i_1 <= 2; ++i_1 )\n  {\n    libmin_printf(\"Body %d:\\n\", i_1);\n    libmin_printf(\"  Position = (%f, %f, %f) m\\n\", bodies[i_1].pos[0], bodies[i_1].pos[1], bodies[i_1].pos[2]);\n    libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", bodies[i_1].vel[0], bodies[i_1].vel[1], bodies[i_1].vel[2]);\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int step;\n  int i;\n  int j;\n  int i_0;\n  int i_1;\n  double dx_0;\n  double dy;\n  double dz;\n  double r2;\n  double r;\n  double a;\n  double acc[10];\n  Particle bodies[3];\n  unsigned long long v16;\n  v16 = __readfsqword(40u);\n  bodies[0].mass = 1.0e24;\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].mass = 1.0e24;\n  bodies[1].pos[0] = 100000000.0;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[1] = 1000.0;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[1] = 100000000.0;\n  bodies[2].pos[2] = 0.0;\n  bodies[2].vel[0] = -1000.0;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  for (step = 0; step <= 999; ++step) {\n    memset(acc, 0, 72);\n    for (i = 0; i <= 2; ++i) {\n      for (j = 0; j <= 2; ++j) {\n        if (i != j) {\n          dx_0 = bodies[j].pos[0] - bodies[i].pos[0];\n          dy = bodies[j].pos[1] - bodies[i].pos[1];\n          dz = bodies[j].pos[2] - bodies[i].pos[2];\n          r2 = dx_0 * dx_0 + dy * dy + dz * dz + 2.220446049250313e-16;\n          r = libmin_sqrt(r2);\n          a = 6.674299999999999e-11 * bodies[j].mass / r2;\n          acc[3 * i] = dx_0 / r * a + acc[3 * i];\n          acc[3 * i + 1] = dy / r * a + acc[3 * i + 1];\n          acc[3 * i + 2] = dz / r * a + acc[3 * i + 2];\n        }\n      }\n    }\n    for (i_0 = 0; i_0 <= 2; ++i_0) {\n      bodies[i_0].vel[0] = 0.01 * acc[3 * i_0] + bodies[i_0].vel[0];\n      bodies[i_0].vel[1] = 0.01 * acc[3 * i_0 + 1] + bodies[i_0].vel[1];\n      bodies[i_0].vel[2] = 0.01 * acc[3 * i_0 + 2] + bodies[i_0].vel[2];\n      bodies[i_0].pos[0] = 0.01 * bodies[i_0].vel[0] + bodies[i_0].pos[0];\n      bodies[i_0].pos[1] = 0.01 * bodies[i_0].vel[1] + bodies[i_0].pos[1];\n      bodies[i_0].pos[2] = 0.01 * bodies[i_0].vel[2] + bodies[i_0].pos[2];\n    }\n  }\n  libmin_printf(\"Final state after %d steps:\\n\", 1000);\n  for (i_1 = 0; i_1 <= 2; ++i_1) {\n    libmin_printf(\"Body %d:\\n\", i_1);\n    libmin_printf(\"  Position = (%f, %f, %f) m\\n\", bodies[i_1].pos[0],\n                  bodies[i_1].pos[1], bodies[i_1].pos[2]);\n    libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", bodies[i_1].vel[0],\n                  bodies[i_1].vel[1], bodies[i_1].vel[2]);\n  }\n  libmin_success();\n}", "binary": "nbody-sim/nbody-sim.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x150,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovsd  0x3e61(%rip),%xmm0\nmovsd  %xmm0,-0xb0(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0xa8(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0xa0(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x98(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x90(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x88(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x80(%rbp)\nmovsd  0x3e0c(%rip),%xmm0\nmovsd  %xmm0,-0x78(%rbp)\nmovsd  0x3e07(%rip),%xmm0\nmovsd  %xmm0,-0x70(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x68(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x60(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x58(%rbp)\nmovsd  0x3de7(%rip),%xmm0\nmovsd  %xmm0,-0x50(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x48(%rbp)\nmovsd  0x3dc1(%rip),%xmm0\nmovsd  %xmm0,-0x40(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  0x3db3(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  0x3dad(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovl   $0x0,-0x144(%rbp)\njmp    198b <main+0x7a2>\nmovq   $0x0,-0x100(%rbp)\nmovq   $0x0,-0xf8(%rbp)\nmovq   $0x0,-0xf0(%rbp)\nmovq   $0x0,-0xe8(%rbp)\nmovq   $0x0,-0xe0(%rbp)\nmovq   $0x0,-0xd8(%rbp)\nmovq   $0x0,-0xd0(%rbp)\nmovq   $0x0,-0xc8(%rbp)\nmovq   $0x0,-0xc0(%rbp)\nmovl   $0x0,-0x140(%rbp)\njmp    1675 <main+0x48c>\nmovl   $0x0,-0x13c(%rbp)\njmp    1661 <main+0x478>\nmov    -0x140(%rbp),%eax\ncmp    -0x13c(%rbp),%eax\nje     1659 <main+0x470>\nmov    -0x13c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa8,%rax\nmovsd  (%rax),%xmm0\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa8,%rax\nmovsd  (%rax),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x130(%rbp)\nmov    -0x13c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa0,%rax\nmovsd  (%rax),%xmm0\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa0,%rax\nmovsd  (%rax),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x128(%rbp)\nmov    -0x13c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x98,%rax\nmovsd  (%rax),%xmm0\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x98,%rax\nmovsd  (%rax),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x120(%rbp)\nmovsd  -0x130(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x128(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  -0x120(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x3bc8(%rip),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x118(%rbp)\nmov    -0x118(%rbp),%rax\nmovq   %rax,%xmm0\ncall   3e94 <libmin_sqrt>\nmovq   %xmm0,%rax\nmov    %rax,-0x110(%rbp)\nmov    -0x13c(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xb0,%rax\nmovsd  (%rax),%xmm1\nmovsd  0x3b7b(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ndivsd  -0x118(%rbp),%xmm0\nmovsd  %xmm0,-0x108(%rbp)\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x100,%rax\nmovsd  (%rax),%xmm1\nmovsd  -0x130(%rbp),%xmm0\ndivsd  -0x110(%rbp),%xmm0\nmulsd  -0x108(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x100,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xf8,%rax\nmovsd  (%rax),%xmm1\nmovsd  -0x128(%rbp),%xmm0\ndivsd  -0x110(%rbp),%xmm0\nmulsd  -0x108(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xf8,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xf0,%rax\nmovsd  (%rax),%xmm1\nmovsd  -0x120(%rbp),%xmm0\ndivsd  -0x110(%rbp),%xmm0\nmulsd  -0x108(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x140(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xf0,%rax\nmovsd  %xmm0,(%rax)\njmp    165a <main+0x471>\nnop\naddl   $0x1,-0x13c(%rbp)\ncmpl   $0x2,-0x13c(%rbp)\njle    1382 <main+0x199>\naddl   $0x1,-0x140(%rbp)\ncmpl   $0x2,-0x140(%rbp)\njle    1373 <main+0x18a>\nmovl   $0x0,-0x138(%rbp)\njmp    1977 <main+0x78e>\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x90,%rax\nmovsd  (%rax),%xmm1\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x100,%rax\nmovsd  (%rax),%xmm2\nmovsd  0x39c0(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x90,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x88,%rax\nmovsd  (%rax),%xmm1\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xf8,%rax\nmovsd  (%rax),%xmm2\nmovsd  0x3945(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x88,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nadd    $0xffffffffffffff80,%rax\nmovsd  (%rax),%xmm1\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xf0,%rax\nmovsd  (%rax),%xmm2\nmovsd  0x38cc(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nadd    $0xffffffffffffff80,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa8,%rax\nmovsd  (%rax),%xmm1\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x90,%rax\nmovsd  (%rax),%xmm2\nmovsd  0x3852(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa8,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa0,%rax\nmovsd  (%rax),%xmm1\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x88,%rax\nmovsd  (%rax),%xmm2\nmovsd  0x37d6(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa0,%rax\nmovsd  %xmm0,(%rax)\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x98,%rax\nmovsd  (%rax),%xmm1\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nadd    $0xffffffffffffff80,%rax\nmovsd  (%rax),%xmm2\nmovsd  0x375c(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x138(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x98,%rax\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x138(%rbp)\ncmpl   $0x2,-0x138(%rbp)\njle    1691 <main+0x4a8>\naddl   $0x1,-0x144(%rbp)\ncmpl   $0x3e7,-0x144(%rbp)\njle    1301 <main+0x118>\nmov    $0x3e8,%esi\nlea    0x3661(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c65 <libmin_printf>\nmovl   $0x0,-0x134(%rbp)\njmp    1afc <main+0x913>\nmov    -0x134(%rbp),%eax\nmov    %eax,%esi\nlea    0x3653(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c65 <libmin_printf>\nmov    -0x134(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x98,%rax\nmovsd  (%rax),%xmm1\nmov    -0x134(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa0,%rax\nmovsd  (%rax),%xmm0\nmov    -0x134(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0xa8,%rax\nmov    (%rax),%rax\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x35d1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x3,%eax\ncall   3c65 <libmin_printf>\nmov    -0x134(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nadd    $0xffffffffffffff80,%rax\nmovsd  (%rax),%xmm1\nmov    -0x134(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x88,%rax\nmovsd  (%rax),%xmm0\nmov    -0x134(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nadd    %rbp,%rax\nsub    $0x90,%rax\nmov    (%rax),%rax\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x3568(%rip),%rax\nmov    %rax,%rdi\nmov    $0x3,%eax\ncall   3c65 <libmin_printf>\naddl   $0x1,-0x134(%rbp)\ncmpl   $0x2,-0x134(%rbp)\njle    19c3 <main+0x7da>\ncall   4249 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1b27 <main+0x93e>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "nr-solver/nr-solver.c", "function_name": "f", "content": "#define FN_SQRT\n\n#ifdef FN_SQRT\ndouble\nf(double x)\n{\n  return x*x - sqrt_value;\n}\n"}, "pseudo": {"path": "nr-solver/nr-solver.host.O0.pseudo", "function_name": "f", "address": "0x11e9", "label": "f", "content": "double __cdecl f(double x)\n{\n  return x * x - sqrt_value;\n}\n"}, "pseudo_normalize": "", "binary": "nr-solver/nr-solver.host.O0", "assembly": "<f>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\nmovsd  0x5209(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n"}
{"source": {"path": "nr-solver/nr-solver.c", "function_name": "myfabs", "content": "#endif\n\n// get absolute value of the number given by user\ndouble myfabs(double num)\n{\n  if (num < 0.0)\n    return -num;\n  else\n    return num;\n}\n"}, "pseudo": {"path": "nr-solver/nr-solver.host.O0.pseudo", "function_name": "myfabs", "address": "0x1239", "label": "myfabs", "content": "double __cdecl myfabs(double num)\n{\n  if ( num < 0.0 )\n    return -num;\n  return num;\n}\n"}, "pseudo_normalize": "", "binary": "nr-solver/nr-solver.host.O0", "assembly": "<myfabs>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x8(%rbp)\npxor   %xmm0,%xmm0\ncomisd -0x8(%rbp),%xmm0\njbe    1264 <myfabs+0x2b>\nmovsd  -0x8(%rbp),%xmm0\nmovq   0x2de2(%rip),%xmm1\nxorpd  %xmm1,%xmm0\njmp    1269 <myfabs+0x30>\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n"}
{"source": {"path": "nr-solver/nr-solver.c", "function_name": "rn_solver", "content": "// calculate function value using Newton-Raphson method\ndouble rn_solver(int *converged, double maxerr, unsigned maxiter, fn_type f, fn_type df)\n{\n  unsigned iter;\n  double guess = 1.0;\n\n  *converged = FALSE;\n  for (iter = 0; iter < maxiter; iter++)\n  {\n      *converged = myfabs(f(guess)) <= maxerr;\n      if (*converged)\n        break;\n      guess = guess - f(guess)/df(guess);\n  }\n  // libmin_printf(\"niter == %u\\n\", iter);\n  return guess;\n}\n"}, "pseudo": {"path": "nr-solver/nr-solver.host.O0.pseudo", "function_name": "rn_solver", "address": "0x1275", "label": "rn_solver", "content": "double __cdecl rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f, fn_type df_0)\n{\n  double v5; // xmm0_8\n  double v6; // rbx\n  unsigned int iter; // [rsp+34h] [rbp-1Ch]\n  double guess; // [rsp+38h] [rbp-18h]\n\n  guess = 1.0;\n  *converged = 0;\n  for ( iter = 0; iter < maxiter; ++iter )\n  {\n    v5 = f(guess);\n    *converged = maxerr >= myfabs(v5);\n    if ( *converged )\n      break;\n    v6 = f(guess);\n    guess = guess - v6 / df_0(guess);\n  }\n  return guess;\n}\n"}, "pseudo_normalize": "double rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f,\n                 fn_type df_0) {\n  double v5;\n  double v6;\n  unsigned int iter;\n  double guess;\n  guess = 1.0;\n  *converged = 0;\n  for (iter = 0; iter < maxiter; ++iter) {\n    v5 = f(guess);\n    *converged = maxerr >= myfabs(v5);\n    if (*converged) break;\n    v6 = f(guess);\n    guess = guess - v6 / df_0(guess);\n  }\n  return guess;\n}", "binary": "nr-solver/nr-solver.host.O0", "assembly": "<rn_solver>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x28(%rbp)\nmovsd  %xmm0,-0x30(%rbp)\nmov    %esi,-0x34(%rbp)\nmov    %rdx,-0x40(%rbp)\nmov    %rcx,-0x48(%rbp)\nmovsd  0x2db2(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x1c(%rbp)\njmp    1331 <rn_solver+0xbc>\nmov    -0x18(%rbp),%rax\nmov    -0x40(%rbp),%rdx\nmovq   %rax,%xmm0\ncall   *%rdx\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   1239 <myfabs>\nmovsd  -0x30(%rbp),%xmm1\ncomisd %xmm0,%xmm1\nsetae  %al\nmovzbl %al,%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    133f <rn_solver+0xca>\nmov    -0x18(%rbp),%rax\nmov    -0x40(%rbp),%rdx\nmovq   %rax,%xmm0\ncall   *%rdx\nmovq   %xmm0,%rbx\nmov    -0x18(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nmovq   %rax,%xmm0\ncall   *%rdx\nmovq   %rbx,%xmm1\ndivsd  %xmm0,%xmm1\nmovsd  -0x18(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njb     12b6 <rn_solver+0x41>\njmp    1340 <rn_solver+0xcb>\nnop\nmovsd  -0x18(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "check_packet_filter", "content": "// Check if the packet matches the filter criteria:\n// The packet should be using TCP and have a destination IP in the range 192.168.0.0/16.\nint check_packet_filter(Packet pkt) {\n    if (pkt.protocol != TCP_PROTOCOL) {\n        return FALSE;\n    }\n    // Extract the first two octets of the destination IP.\n    unsigned int first_octet = (pkt.dest_ip >> 24) & 0xFF;\n    unsigned int second_octet = (pkt.dest_ip >> 16) & 0xFF;\n    return (first_octet == FIXED_IP_FIRST && second_octet == FIXED_IP_SECOND);\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O0.pseudo", "function_name": "check_packet_filter", "address": "0x1347", "label": "check_packet_filter", "content": "int __cdecl check_packet_filter(Packet pkt)\n{\n  if ( pkt.protocol != 6 )\n    return 0;\n  return HIBYTE(pkt.dest_ip) == 192 && BYTE2(pkt.dest_ip) == 168;\n}\n"}, "pseudo_normalize": "", "binary": "packet-filter/packet-filter.host.O0", "assembly": "<check_packet_filter>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovzbl 0x1c(%rbp),%eax\ncmp    $0x6,%al\nje     135e <check_packet_filter+0x17>\nmov    $0x0,%eax\njmp    1393 <check_packet_filter+0x4c>\nmov    0x14(%rbp),%eax\nshr    $0x18,%eax\nmov    %eax,-0x8(%rbp)\nmov    0x14(%rbp),%eax\nshr    $0x10,%eax\nand    $0xff,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0xc0,-0x8(%rbp)\njne    138e <check_packet_filter+0x47>\ncmpl   $0xa8,-0x4(%rbp)\njne    138e <check_packet_filter+0x47>\nmov    $0x1,%eax\njmp    1393 <check_packet_filter+0x4c>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "generate_packet", "content": "// Generate a random packet.\n// With ~5% probability, the packet will have the TCP protocol \n// and a destination IP within the range 192.168.0.0 - 192.168.255.255.\nPacket generate_packet() {\n    Packet pkt;\n    \n    if (libmin_rand() % 20 == 0) {\n        // Force matching criteria: destination IP in 192.168.x.x and TCP protocol.\n        pkt.dest_ip = ((unsigned int)FIXED_IP_FIRST << 24) |\n                      ((unsigned int)FIXED_IP_SECOND << 16) |\n                      (((unsigned int)libmin_rand() % 256) << 8) |\n                      ((unsigned int)libmin_rand() % 256);\n        pkt.protocol = TCP_PROTOCOL;\n    } else {\n        // Generate a random destination IP and a random protocol.\n        pkt.dest_ip = (unsigned int)libmin_rand();\n        pkt.protocol = (unsigned char)(libmin_rand() % 256);\n    }\n    \n    // Generate a random source IP.\n    pkt.src_ip = (unsigned int)libmin_rand();\n    \n    // Generate random source and destination ports.\n    pkt.src_port = (unsigned short)(libmin_rand() % 65536);\n    pkt.dest_port = (unsigned short)(libmin_rand() % 65536);\n    \n    // Fill the payload with 63 random uppercase characters and null-terminate.\n    for (int i = 0; i < 63; i++) {\n        pkt.payload[i] = 'A' + (libmin_rand() % 26);\n    }\n    pkt.payload[63] = '\\0';\n    \n    return pkt;\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O0.pseudo", "function_name": "generate_packet", "address": "0x11e9", "label": "generate_packet", "content": "Packet *__cdecl generate_packet(Packet *__return_ptr retstr)\n{\n  unsigned int v1; // eax\n  int v2; // ebx\n  __int64 v3; // rbx\n  __int64 v4; // rbx\n  __int64 v5; // rbx\n  __int64 v6; // rbx\n  __int64 v7; // rbx\n  int i; // [rsp+1Ch] [rbp-74h]\n  Packet pkt; // [rsp+20h] [rbp-70h]\n  unsigned __int64 v11; // [rsp+78h] [rbp-18h]\n\n  v11 = __readfsqword(0x28u);\n  v1 = libmin_rand();\n  if ( v1 == 20 * (v1 / 0x14) )\n  {\n    v2 = (unsigned __int16)((unsigned __int16)libmin_rand() << 8);\n    pkt.dest_ip = v2 | (unsigned __int8)libmin_rand() | 0xC0A80000;\n    pkt.protocol = 6;\n  }\n  else\n  {\n    pkt.dest_ip = libmin_rand();\n    pkt.protocol = libmin_rand();\n  }\n  pkt.src_ip = libmin_rand();\n  pkt.src_port = libmin_rand();\n  pkt.dest_port = libmin_rand();\n  for ( i = 0; i <= 62; ++i )\n    pkt.payload[i] = libmin_rand() % 0x1A + 65;\n  pkt.payload[63] = 0;\n  v3 = *(_QWORD *)&pkt.src_port;\n  *(_QWORD *)&retstr->src_ip = *(_QWORD *)&pkt.src_ip;\n  *(_QWORD *)&retstr->src_port = v3;\n  v4 = *(_QWORD *)&pkt.payload[11];\n  *(_QWORD *)&retstr->payload[3] = *(_QWORD *)&pkt.payload[3];\n  *(_QWORD *)&retstr->payload[11] = v4;\n  v5 = *(_QWORD *)&pkt.payload[27];\n  *(_QWORD *)&retstr->payload[19] = *(_QWORD *)&pkt.payload[19];\n  *(_QWORD *)&retstr->payload[27] = v5;\n  v6 = *(_QWORD *)&pkt.payload[43];\n  *(_QWORD *)&retstr->payload[35] = *(_QWORD *)&pkt.payload[35];\n  *(_QWORD *)&retstr->payload[43] = v6;\n  v7 = *(_QWORD *)&pkt.payload[59];\n  *(_QWORD *)&retstr->payload[51] = *(_QWORD *)&pkt.payload[51];\n  *(_QWORD *)&retstr->payload[59] = v7;\n  return retstr;\n}\n"}, "pseudo_normalize": "Packet *generate_packet(Packet *__return_ptr retstr) {\n  unsigned int v1;\n  int v2;\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  int i;\n  Packet pkt;\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  v1 = libmin_rand();\n  if (v1 == 20 * (v1 / 20)) {\n    v2 = (unsigned short)((unsigned short)libmin_rand() << 8);\n    pkt.dest_ip = v2 | (unsigned char)libmin_rand() | 3232235520;\n    pkt.protocol = 6;\n  } else {\n    pkt.dest_ip = libmin_rand();\n    pkt.protocol = libmin_rand();\n  }\n  pkt.src_ip = libmin_rand();\n  pkt.src_port = libmin_rand();\n  pkt.dest_port = libmin_rand();\n  for (i = 0; i <= 62; ++i) pkt.payload[i] = libmin_rand() % 26 + 65;\n  pkt.payload[63] = 0;\n  v3 = *(uint64_t *)&pkt.src_port;\n  *(uint64_t *)&retstr->src_ip = *(uint64_t *)&pkt.src_ip;\n  *(uint64_t *)&retstr->src_port = v3;\n  v4 = *(uint64_t *)&pkt.payload[11];\n  *(uint64_t *)&retstr->payload[3] = *(uint64_t *)&pkt.payload[3];\n  *(uint64_t *)&retstr->payload[11] = v4;\n  v5 = *(uint64_t *)&pkt.payload[27];\n  *(uint64_t *)&retstr->payload[19] = *(uint64_t *)&pkt.payload[19];\n  *(uint64_t *)&retstr->payload[27] = v5;\n  v6 = *(uint64_t *)&pkt.payload[43];\n  *(uint64_t *)&retstr->payload[35] = *(uint64_t *)&pkt.payload[35];\n  *(uint64_t *)&retstr->payload[43] = v6;\n  v7 = *(uint64_t *)&pkt.payload[59];\n  *(uint64_t *)&retstr->payload[51] = *(uint64_t *)&pkt.payload[51];\n  *(uint64_t *)&retstr->payload[59] = v7;\n  return retstr;\n}", "binary": "packet-filter/packet-filter.host.O0", "assembly": "<generate_packet>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x88,%rsp\nmov    %rdi,-0x88(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\ncall   39bb <libmin_rand>\nmov    %eax,%ecx\nmov    %ecx,%edx\nmov    $0xcccccccd,%eax\nimul   %rdx,%rax\nshr    $0x20,%rax\nmov    %eax,%edx\nshr    $0x4,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nshl    $0x2,%eax\nmov    %ecx,%edx\nsub    %eax,%edx\ntest   %edx,%edx\njne    1263 <generate_packet+0x7a>\ncall   39bb <libmin_rand>\nshl    $0x8,%eax\nand    $0xff00,%eax\nmov    %eax,%ebx\ncall   39bb <libmin_rand>\nmovzbl %al,%eax\nor     %ebx,%eax\nor     $0xc0a80000,%eax\nmov    %eax,-0x6c(%rbp)\nmovb   $0x6,-0x64(%rbp)\njmp    1273 <generate_packet+0x8a>\ncall   39bb <libmin_rand>\nmov    %eax,-0x6c(%rbp)\ncall   39bb <libmin_rand>\nmov    %al,-0x64(%rbp)\ncall   39bb <libmin_rand>\nmov    %eax,-0x70(%rbp)\ncall   39bb <libmin_rand>\nmov    %ax,-0x68(%rbp)\ncall   39bb <libmin_rand>\nmov    %ax,-0x66(%rbp)\nmovl   $0x0,-0x74(%rbp)\njmp    12c6 <generate_packet+0xdd>\ncall   39bb <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x4ec4ec4f,%rax,%rax\nshr    $0x20,%rax\nshr    $0x3,%eax\nimul   $0x1a,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nadd    $0x41,%eax\nmov    %eax,%edx\nmov    -0x74(%rbp),%eax\ncltq\nmov    %dl,-0x63(%rbp,%rax,1)\naddl   $0x1,-0x74(%rbp)\ncmpl   $0x3e,-0x74(%rbp)\njle    1296 <generate_packet+0xad>\nmovb   $0x0,-0x24(%rbp)\nmov    -0x88(%rbp),%rax\nmov    -0x70(%rbp),%rcx\nmov    -0x68(%rbp),%rbx\nmov    %rcx,(%rax)\nmov    %rbx,0x8(%rax)\nmov    -0x60(%rbp),%rcx\nmov    -0x58(%rbp),%rbx\nmov    %rcx,0x10(%rax)\nmov    %rbx,0x18(%rax)\nmov    -0x50(%rbp),%rcx\nmov    -0x48(%rbp),%rbx\nmov    %rcx,0x20(%rax)\nmov    %rbx,0x28(%rax)\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rbx\nmov    %rcx,0x30(%rax)\nmov    %rbx,0x38(%rax)\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rbx\nmov    %rcx,0x40(%rax)\nmov    %rbx,0x48(%rax)\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\nje     133a <generate_packet+0x151>\ncall   10b0 <__stack_chk_fail@plt>\nmov    -0x88(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "main", "content": "int main() {\n    // Seed the random number generator.\n    libmin_srand(42);\n    \n    int packetCounter = 0;\n    \n    // Simulate packet processing.\n    while (packetCounter < PACKET_COUNT) {\n        Packet pkt = generate_packet();\n        packetCounter++;\n        \n        // Use the updated filter: check for TCP and IP range.\n        if (check_packet_filter(pkt)) {\n            libmin_printf(\"Matched Packet #%d:\\n\", packetCounter);\n            print_packet(pkt);\n        }\n    }\n    \n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O0.pseudo", "function_name": "main", "address": "0x14c3", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int packetCounter; // [rsp+Ch] [rbp-64h]\n  Packet pkt; // [rsp+10h] [rbp-60h] BYREF\n  unsigned __int64 v5; // [rsp+68h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  packetCounter = 0;\n  while ( packetCounter <= 99 )\n  {\n    generate_packet(&pkt);\n    ++packetCounter;\n    if ( check_packet_filter(pkt) )\n    {\n      libmin_printf(\"Matched Packet #%d:\\n\", packetCounter);\n      print_packet(pkt);\n    }\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int packetCounter;\n  Packet pkt;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  libmin_srand(42u);\n  packetCounter = 0;\n  while (packetCounter <= 99) {\n    generate_packet(&pkt);\n    ++packetCounter;\n    if (check_packet_filter(pkt)) {\n      libmin_printf(\"Matched Packet #%d:\\n\", packetCounter);\n      print_packet(pkt);\n    }\n  }\n  libmin_success();\n}", "binary": "packet-filter/packet-filter.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x2a,%edi\ncall   3909 <libmin_srand>\nmovl   $0x0,-0x64(%rbp)\njmp    1574 <main+0xb1>\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   11e9 <generate_packet>\naddl   $0x1,-0x64(%rbp)\npush   -0x18(%rbp)\npush   -0x20(%rbp)\npush   -0x28(%rbp)\npush   -0x30(%rbp)\npush   -0x38(%rbp)\npush   -0x40(%rbp)\npush   -0x48(%rbp)\npush   -0x50(%rbp)\npush   -0x58(%rbp)\npush   -0x60(%rbp)\ncall   1347 <check_packet_filter>\nadd    $0x50,%rsp\ntest   %eax,%eax\nje     1574 <main+0xb1>\nmov    -0x64(%rbp),%eax\nmov    %eax,%esi\nlea    0x2b78(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\npush   -0x18(%rbp)\npush   -0x20(%rbp)\npush   -0x28(%rbp)\npush   -0x30(%rbp)\npush   -0x38(%rbp)\npush   -0x40(%rbp)\npush   -0x48(%rbp)\npush   -0x50(%rbp)\npush   -0x58(%rbp)\npush   -0x60(%rbp)\ncall   13e2 <print_packet>\nadd    $0x50,%rsp\ncmpl   $0x63,-0x64(%rbp)\njle    14f4 <main+0x31>\ncall   3c72 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     159c <main+0xd9>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "print_ip", "content": "// Helper function to print an IP address in dotted notation.\nvoid print_ip(unsigned int ip) {\n    libmin_printf(\"%u.%u.%u.%u\", \n           (ip >> 24) & 0xFF, \n           (ip >> 16) & 0xFF, \n           (ip >> 8) & 0xFF, \n           ip & 0xFF);\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O0.pseudo", "function_name": "print_ip", "address": "0x1395", "label": "print_ip", "content": "void __cdecl print_ip(unsigned int ip_0)\n{\n  libmin_printf(\"%u.%u.%u.%u\", HIBYTE(ip_0), BYTE2(ip_0), BYTE1(ip_0), (unsigned __int8)ip_0);\n}\n"}, "pseudo_normalize": "", "binary": "packet-filter/packet-filter.host.O0", "assembly": "<print_ip>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovzbl %al,%edi\nmov    -0x4(%rbp),%eax\nshr    $0x8,%eax\nmovzbl %al,%edx\nmov    -0x4(%rbp),%eax\nshr    $0x10,%eax\nmovzbl %al,%eax\nmov    -0x4(%rbp),%ecx\nshr    $0x18,%ecx\nmov    %ecx,%esi\nmov    %edi,%r8d\nmov    %edx,%ecx\nmov    %eax,%edx\nlea    0x2c36(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "print_packet", "content": "// Print the details of a packet.\nvoid print_packet(Packet pkt) {\n    libmin_printf(\"Packet Details:\\n\");\n    libmin_printf(\"  Source IP: \");\n    print_ip(pkt.src_ip);\n    libmin_printf(\"\\n  Destination IP: \");\n    print_ip(pkt.dest_ip);\n    libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n    libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n    libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n    libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n    libmin_printf(\"------------------------------\\n\");\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O0.pseudo", "function_name": "print_packet", "address": "0x13e2", "label": "print_packet", "content": "void __cdecl print_packet(Packet pkt)\n{\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(pkt.src_ip);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(pkt.dest_ip);\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}\n"}, "pseudo_normalize": "void print_packet(Packet pkt) {\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  print_ip(pkt.src_ip);\n  libmin_printf(\"\\n  Destination IP: \");\n  print_ip(pkt.dest_ip);\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}", "binary": "packet-filter/packet-filter.host.O0", "assembly": "<print_packet>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    0x2c23(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nlea    0x2c20(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nmov    0x10(%rbp),%eax\nmov    %eax,%edi\ncall   1395 <print_ip>\nlea    0x2c10(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nmov    0x14(%rbp),%eax\nmov    %eax,%edi\ncall   1395 <print_ip>\nmovzwl 0x18(%rbp),%eax\nmovzwl %ax,%eax\nmov    %eax,%esi\nlea    0x2bfd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nmovzwl 0x1a(%rbp),%eax\nmovzwl %ax,%eax\nmov    %eax,%esi\nlea    0x2bf4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nmovzbl 0x1c(%rbp),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x2bef(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nlea    0x1d(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2be4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nlea    0x2be5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36da <libmin_printf>\nnop\npop    %rbp\nret\n"}
{"source": {"path": "parrondo/parrondo.c", "function_name": "cointoss", "content": "/* parrando.c: simulation of J. Parrando's probability paradox */\n\n\n/* Parrondo's game is based upon two simple games of chance.\n\n        The gambler's fortune starts at 0.\n\n\tThe simple game: Toss a biased coin and win +1 with probability\n\t\tS_WIN_PROB (defined below). Otherwise win -1; \n\n\tThe complex game: If the player's fortune is divisible by 3, toss\n\t\tthe \"bad coin\" having win probability BAD_WIN_PROB.\n\t\tIf the player's fortune is not divisible by 3 toss the\n                \"good coin\" having win probability GOOD_WIN_PROB.\n\n\tA game ends when the accumlated fortune exceeds MAX_FORTUNE ( a \"win\" )\n\tor dips below -MAX_FORTUNE ( a \"loss .)  \n\n\tThe numbers are chosen so that each game is quite unfavorable.\n        Remarkably, when the games are alternated at random, the resulting\n        game is quite favorable.\n\n\tThis program simulates many trials of a Parrondo game and reports\n        statistics on their outcomes. (It can also simulate the simple and\n        complex games individually.) The number of trials, fortune limits,\n        and a seed for the random number can be supplied on the command line.\n        The -h option prints detailed help. \n\n\tFor more information on Parrondo games and related phenomena see\n        J. Parrondo's website, http://seneca.fis.ucm.es/parr/,  or the\n        announcement in Nature magazine, 23/30, December 1999.\n*/\n\n/* compile: cc -o parrondo parrondo.c \n\n      Use -D_NO_RANDOM if your library doesn't have random/srandom. Most do,\n       \tbut the only truly portable RNG is rand/srand. Unfortunately it has\n        very poor performance, so you should use random if possible.\n\n      Use -D_MAX_RAND=  to set the size of the maximum value returned by\n         random(). The portable RNG rand() always returns a maximum of \n         RAND_MAX (defined in stdlib.h), but some implementations of random\n         do not use this value. Read the man page for random to be sure. A\n\t common value is 2^31-1 = 2147483647. In so, and this is not the\n         value of RAND_MAX on your system, you would compile with\n         -D_MAX_RAND=214748367.\n\n      Use -D_SHORT_STRINGS if your compiler does not support multiline\n          string constants.\n*/\n\n\n#include \"libmin.h\"\n\n#define VERSION \"1.1\"\n#define USAGE \"parrondo [ -s number -t number -m number -1 -2 -h -v]\"\n#ifndef _SHORT_STRINGS\n#define HELP \"parrondo [ -s number -t number -m number -1 -2 ]\\n\\n\\\nPrint information on simulations of Parrondo's paradoxical game.\\n\\n\\\n-s: Use next argument as RNG seed. (otherwise use system time as seed.)\\n\\\n-t: Use next argument as number of trials. Default 10000.\\n\\\n-m: Use number as max fortune (win), -number as min fortune(loss). Default 50. \\n\\\n-v: Print version number and exit. \\n\\\n-h: Print this helpful information. \\n\\\n-1: Simulate simple game alone.\\n\\\n-2: Simulate complex game alone.\\n\\n\"\n#else\n#define HELP USAGE\n#endif\n\n/* Default values */\n#define MAX_FORTUNE 50\n#define MAX_ITERATIONS 1000000L\n#define TRIALS 1000\n#define INITIAL_SEED 3445\n#ifndef _MAX_RAND\n#define _MAX_RAND RAND_MAX\n#endif\n\n/* See above for meaning of these */\n#define S_WIN_PROB .495\n#define BAD_WIN_PROB .095\n#define GOOD_WIN_PROB .745\n\n\n/* return -1 or +1 according as a simulated coin toss is heads (+1) or\n   tails (-1). Take p as probability of heads.\n*/\n\nint\ncointoss(double p)\n{\n\n\tdouble U;   /* U(0,1) random variable */\n\n\tU = ((double)libmin_rand())/((double)_MAX_RAND);\n\treturn U >= p ? -1 : 1;\n}\n"}, "pseudo": {"path": "parrondo/parrondo.host.O0.pseudo", "function_name": "cointoss", "address": "0x11e9", "label": "cointoss", "content": "int __cdecl cointoss(double p)\n{\n  if ( (double)(int)libmin_rand() / 2147483647.0 < p )\n    return 1;\n  else\n    return -1;\n}\n"}, "pseudo_normalize": "int cointoss(double p) {\n  if ((double)(int)libmin_rand() / 2147483647.0 < p)\n    return 1;\n  else\n    return -1;\n}", "binary": "parrondo/parrondo.host.O0", "assembly": "<cointoss>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovsd  %xmm0,-0x18(%rbp)\ncall   3e90 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     1211 <cointoss+0x28>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    122a <cointoss+0x41>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x4216(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\ncomisd -0x18(%rbp),%xmm0\njb     124e <cointoss+0x65>\nmov    $0xffffffff,%eax\njmp    1253 <cointoss+0x6a>\nmov    $0x1,%eax\nleave\nret\n"}
{"source": {"path": "parrondo/parrondo.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tlong n=0L;\n\tdouble n_bar,n_tot=0.0;\n\tint trials = TRIALS;\n\tint i=0,j=0,m;\n\tint win_count = 0;\n\tint loss_count = 0;\n\tlong site_visits[3];  /* counts visits to numbers mod 3 */\n\tint fortune = 0;\n\tint max_fortune = MAX_FORTUNE;\n\tdouble game_select = 0.5;  /* Governs a coin toss below which selects\n                                      between games. Setting this to 1.0 chooses\n\t\t\t\t      complex game only. Setting to 0.0 chooses\n                                      simple game only. \n\t\t\t\t   */\n                                      \n\tlong seed=0;\n\n\t/* Process command line */\n\twhile(++j < argc){\n\t\tif(argv[j][0] == '-')\n\t\t\tswitch(argv[j][1]){ \n\t\t\t\tcase 's':\n\t\t\t\tcase 'S':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\tseed = libmin_atol(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 't':\n\t\t\t\tcase 'T':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\ttrials = libmin_atoi(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\t\n\t\t\t\tcase 'm':\n\t\t\t\tcase 'M':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\tmax_fortune = libmin_atoi(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'v':\n\t\t\t\tcase 'V':\n\t\t\t\t\tlibmin_printf(\"%s\\n\", VERSION);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '?':\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'H':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",HELP);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '1':\n\t\t\t\t\tgame_select = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tgame_select = 1.0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlibmin_printf(\"parrondo: unkown option %s\\n\",\n\t\t\t\t\t\targv[j]);\n\t\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\telse {\n\t\t\tlibmin_printf(\"%s\\n\", USAGE);\n\t\t\tlibmin_fail(1);\n\t\t}\n\t}\n \n\t/* If no seed is supplied, then use current system time */\n\t\n\tif(!seed)\n  {\n\t\t\tseed = INITIAL_SEED; /* if all else fails */\n\t\t\tlibmin_printf(\"Using seed = %d\\n\",INITIAL_SEED);\n  }\n\t\t\n\tlibmin_srand((int)seed);\n\tfor(i=0;i<3;i++)site_visits[i] = 0L;  /* initialize counters */\n\ti=0;\n\tlibmin_printf(\"Simulating %d trials ...\\n\",trials);\n\twhile(i<trials){   /* Loop over trials */\n\n\t\t/* reseed */\n\t\tseed = libmin_rand();\n\t\tlibmin_srand((int)seed);\n\n\t\t/* Each trial: loop until fortune goes out of range */\n\t\tfortune = 0;\n\t\twhile(n++<MAX_ITERATIONS){\n\t\t\tif(cointoss(game_select) == 1)\n\t\t\t\tfortune += play_c(fortune);\n\t\t\telse\n\t\t\t\tfortune += play_s();\n\t\t\tif((fortune >= max_fortune)||(fortune <= -max_fortune))\n\t\t\t\tbreak;\n\n\t\t\tm = fortune > 0 ? fortune : -fortune;\n\t\t\tsite_visits[m%3]++;\t\n\t\t}\n\n\t\tif(fortune == max_fortune)\n\t\t\twin_count++;\n\t\telse if(fortune == -max_fortune)\n\t\t\tloss_count++;\n\n\t\ti++;\n\t\tn_tot += (double)n;\n\t\tn = 0L;\n\t\t\n\t}\n\n\tn_bar = n_tot/((double)i);\n\n\t/* Print stuff out */\n\n\tlibmin_printf(\"%d wins, %d losses, %d draws\\n\",win_count,\n\t\t\tloss_count, i-(win_count+loss_count));\n\tlibmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\",\n\t\t\tmax_fortune,max_fortune,MAX_ITERATIONS);\n\tlibmin_printf(\"Average trial length = %lf\\n\",n_bar);\n\tlibmin_printf(\"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n\t\t100.0*((double)site_visits[0])/n_tot,\n\t\t100.0*((double)site_visits[1])/n_tot,\n\t\t100.0*((double)site_visits[2])/n_tot\n\t);\n\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "parrondo/parrondo.host.O0.pseudo", "function_name": "main", "address": "0x12cb", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // eax\n  int v4; // eax\n  __int64 v5; // rax\n  int trials; // [rsp+8h] [rbp-68h]\n  int i; // [rsp+Ch] [rbp-64h]\n  int ia; // [rsp+Ch] [rbp-64h]\n  int j; // [rsp+10h] [rbp-60h]\n  int win_count; // [rsp+14h] [rbp-5Ch]\n  int loss_count; // [rsp+18h] [rbp-58h]\n  int fortune; // [rsp+1Ch] [rbp-54h]\n  int max_fortune; // [rsp+20h] [rbp-50h]\n  __int64 n; // [rsp+28h] [rbp-48h]\n  double n_tot; // [rsp+30h] [rbp-40h]\n  double game_select; // [rsp+38h] [rbp-38h]\n  __int64 seed; // [rsp+40h] [rbp-30h]\n  __int64 site_visits[3]; // [rsp+50h] [rbp-20h]\n  unsigned __int64 v20; // [rsp+68h] [rbp-8h]\n\n  v20 = __readfsqword(0x28u);\n  n = 0LL;\n  n_tot = 0.0;\n  trials = 1000;\n  j = 0;\n  win_count = 0;\n  loss_count = 0;\n  max_fortune = 50;\n  game_select = 0.5;\n  seed = 0LL;\n  while ( ++j < ::argc )\n  {\n    if ( *::argv[j] != 45 )\n    {\n      libmin_printf(\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n      libmin_fail(1);\n    }\n    switch ( ::argv[j][1] )\n    {\n      case '1':\n        game_select = 0.0;\n        break;\n      case '2':\n        game_select = 1.0;\n        break;\n      case '?':\n      case 'H':\n      case 'h':\n        libmin_printf(\n          \"%s\\n\",\n          \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n          \"\\n\"\n          \"Print information on simulations of Parrondo's paradoxical game.\\n\"\n          \"\\n\"\n          \"-s: Use next argument as RNG seed. (otherwise use system time as seed.)\\n\"\n          \"-t: Use next argument as number of trials. Default 10000.\\n\"\n          \"-m: Use number as max fortune (win), -number as min fortune(loss). Default 50. \\n\"\n          \"-v: Print version number and exit. \\n\"\n          \"-h: Print this helpful information. \\n\"\n          \"-1: Simulate simple game alone.\\n\"\n          \"-2: Simulate complex game alone.\\n\"\n          \"\\n\");\n        libmin_success();\n      case 'M':\n      case 'm':\n        if ( j + 1 >= ::argc )\n        {\n          libmin_printf(\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        max_fortune = libmin_atoi(::argv[++j]);\n        break;\n      case 'S':\n      case 's':\n        if ( j + 1 >= ::argc )\n        {\n          libmin_printf(\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        seed = libmin_atol(::argv[++j]);\n        break;\n      case 'T':\n      case 't':\n        if ( j + 1 >= ::argc )\n        {\n          libmin_printf(\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        trials = libmin_atoi(::argv[++j]);\n        break;\n      case 'V':\n      case 'v':\n        libmin_printf(\"%s\\n\", \"1.1\");\n        libmin_success();\n      default:\n        libmin_printf(\"parrondo: unkown option %s\\n\", ::argv[j]);\n        libmin_fail(1);\n    }\n  }\n  if ( !seed )\n  {\n    LODWORD(seed) = 3445;\n    libmin_printf(\"Using seed = %d\\n\", 3445);\n  }\n  libmin_srand(seed);\n  for ( i = 0; i <= 2; ++i )\n    site_visits[i] = 0LL;\n  ia = 0;\n  libmin_printf(\"Simulating %d trials ...\\n\", trials);\n  while ( ia < trials )\n  {\n    v3 = libmin_rand();\n    libmin_srand(v3);\n    fortune = 0;\n    while ( 1 )\n    {\n      v5 = n++;\n      if ( v5 > 999999 )\n        break;\n      fortune += cointoss(game_select) == 1 ? play_c(fortune) : play_s();\n      if ( fortune >= max_fortune || fortune <= -max_fortune )\n        break;\n      v4 = fortune;\n      if ( fortune <= 0 )\n        v4 = -fortune;\n      ++site_visits[v4 % 3];\n    }\n    if ( fortune == max_fortune )\n    {\n      ++win_count;\n    }\n    else if ( fortune == -max_fortune )\n    {\n      ++loss_count;\n    }\n    ++ia;\n    n_tot = (double)(int)n + n_tot;\n    n = 0LL;\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count, ia - (loss_count + win_count));\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\", max_fortune, max_fortune, 1000000LL);\n  libmin_printf(\"Average trial length = %lf\\n\", n_tot / (double)ia);\n  libmin_printf(\n    \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n    100.0 * (double)SLODWORD(site_visits[0]) / n_tot,\n    100.0 * (double)SLODWORD(site_visits[1]) / n_tot,\n    100.0 * (double)SLODWORD(site_visits[2]) / n_tot);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  int v4;\n  long long v5;\n  int trials;\n  int i;\n  int ia;\n  int j;\n  int win_count;\n  int loss_count;\n  int fortune;\n  int max_fortune;\n  long long n;\n  double n_tot;\n  double game_select;\n  long long seed;\n  long long site_visits[3];\n  unsigned long long v20;\n  v20 = __readfsqword(40u);\n  n = 0LL;\n  n_tot = 0.0;\n  trials = 1000;\n  j = 0;\n  win_count = 0;\n  loss_count = 0;\n  max_fortune = 50;\n  game_select = 0.5;\n  seed = 0LL;\n  while (++j < ::argc) {\n    if (*::argv[j] != 45) {\n      libmin_printf(\"%s\\n\",\n                    \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n      libmin_fail(1);\n    }\n    switch (::argv[j][1]) {\n      case '1':\n        game_select = 0.0;\n        break;\n      case '2':\n        game_select = 1.0;\n        break;\n      case '?':\n      case 'H':\n      case 'h':\n        libmin_printf(\n            \"%s\\n\",\n            \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n            \"\\n\"\n            \"Print information on simulations of Parrondo's paradoxical game.\\n\"\n            \"\\n\"\n            \"-s: Use next argument as RNG seed. (otherwise use system time as \"\n            \"seed.)\\n\"\n            \"-t: Use next argument as number of trials. Default 10000.\\n\"\n            \"-m: Use number as max fortune (win), -number as min \"\n            \"fortune(loss). Default 50. \\n\"\n            \"-v: Print version number and exit. \\n\"\n            \"-h: Print this helpful information. \\n\"\n            \"-1: Simulate simple game alone.\\n\"\n            \"-2: Simulate complex game alone.\\n\"\n            \"\\n\");\n        libmin_success();\n      case 'M':\n      case 'm':\n        if (j + 1 >= ::argc) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        max_fortune = libmin_atoi(::argv[++j]);\n        break;\n      case 'S':\n      case 's':\n        if (j + 1 >= ::argc) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        seed = libmin_atol(::argv[++j]);\n        break;\n      case 'T':\n      case 't':\n        if (j + 1 >= ::argc) {\n          libmin_printf(\n              \"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n          libmin_fail(1);\n        }\n        trials = libmin_atoi(::argv[++j]);\n        break;\n      case 'V':\n      case 'v':\n        libmin_printf(\"%s\\n\", \"1.1\");\n        libmin_success();\n      default:\n        libmin_printf(\"parrondo: unkown option %s\\n\", ::argv[j]);\n        libmin_fail(1);\n    }\n  }\n  if (!seed) {\n    LODWORD(seed) = 3445;\n    libmin_printf(\"Using seed = %d\\n\", 3445);\n  }\n  libmin_srand(seed);\n  for (i = 0; i <= 2; ++i) site_visits[i] = 0LL;\n  ia = 0;\n  libmin_printf(\"Simulating %d trials ...\\n\", trials);\n  while (ia < trials) {\n    v3 = libmin_rand();\n    libmin_srand(v3);\n    fortune = 0;\n    while (1) {\n      v5 = n++;\n      if (v5 > 999999) break;\n      fortune += cointoss(game_select) == 1 ? play_c(fortune) : play_s();\n      if (fortune >= max_fortune || fortune <= -max_fortune) break;\n      v4 = fortune;\n      if (fortune <= 0) v4 = -fortune;\n      ++site_visits[v4 % 3];\n    }\n    if (fortune == max_fortune) {\n      ++win_count;\n    } else if (fortune == -max_fortune) {\n      ++loss_count;\n    }\n    ++ia;\n    n_tot = (double)(int)n + n_tot;\n    n = 0LL;\n  }\n  libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count,\n                ia - (loss_count + win_count));\n  libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\",\n                max_fortune, max_fortune, 1000000LL);\n  libmin_printf(\"Average trial length = %lf\\n\", n_tot / (double)ia);\n  libmin_printf(\n      \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n      100.0 * (double)SLODWORD(site_visits[0]) / n_tot,\n      100.0 * (double)SLODWORD(site_visits[1]) / n_tot,\n      100.0 * (double)SLODWORD(site_visits[2]) / n_tot);\n  libmin_success();\n}", "binary": "parrondo/parrondo.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x48(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovl   $0x3e8,-0x68(%rbp)\nmovl   $0x0,-0x64(%rbp)\nmovl   $0x0,-0x60(%rbp)\nmovl   $0x0,-0x5c(%rbp)\nmovl   $0x0,-0x58(%rbp)\nmovl   $0x0,-0x54(%rbp)\nmovl   $0x32,-0x50(%rbp)\nmovsd  0x4138(%rip),%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmovq   $0x0,-0x30(%rbp)\njmp    15af <main+0x2e4>\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5cca(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\njne    1587 <main+0x2bc>\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5ca7(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nsub    $0x31,%eax\ncmp    $0x45,%eax\nja     154c <main+0x281>\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x3f8c(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x3f80(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x60(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    0x5c4e(%rip),%eax\ncmp    %eax,%edx\njl     13ee <main+0x123>\nlea    0x3c53(%rip),%rax\nmov    %rax,%rsi\nlea    0x3c7f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    $0x1,%edi\ncall   1b83 <libmin_fail>\nmov    -0x60(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5c1b(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   1a6b <libmin_atol>\nmov    %rax,-0x30(%rbp)\naddl   $0x1,-0x60(%rbp)\njmp    15af <main+0x2e4>\nmov    -0x60(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    0x5be6(%rip),%eax\ncmp    %eax,%edx\njl     1456 <main+0x18b>\nlea    0x3beb(%rip),%rax\nmov    %rax,%rsi\nlea    0x3c17(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    $0x1,%edi\ncall   1b83 <libmin_fail>\nmov    -0x60(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5bb3(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   19a2 <libmin_atoi>\nmov    %eax,-0x68(%rbp)\naddl   $0x1,-0x60(%rbp)\njmp    15af <main+0x2e4>\nmov    -0x60(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    0x5b7f(%rip),%eax\ncmp    %eax,%edx\njl     14bd <main+0x1f2>\nlea    0x3b84(%rip),%rax\nmov    %rax,%rsi\nlea    0x3bb0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    $0x1,%edi\ncall   1b83 <libmin_fail>\nmov    -0x60(%rbp),%eax\nadd    $0x1,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5b4c(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rdi\ncall   19a2 <libmin_atoi>\nmov    %eax,-0x50(%rbp)\naddl   $0x1,-0x60(%rbp)\njmp    15af <main+0x2e4>\nlea    0x3b67(%rip),%rax\nmov    %rax,%rsi\nlea    0x3b59(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\ncall   4147 <libmin_success>\nlea    0x3b4a(%rip),%rax\nmov    %rax,%rsi\nlea    0x3b36(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\ncall   4147 <libmin_success>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\njmp    15af <main+0x2e4>\nmovsd  0x3f2b(%rip),%xmm0\nmovsd  %xmm0,-0x38(%rbp)\njmp    15af <main+0x2e4>\nmov    -0x60(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5ac0(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,%rsi\nlea    0x3cc4(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    $0x1,%edi\ncall   1b83 <libmin_fail>\njmp    15af <main+0x2e4>\nlea    0x3a92(%rip),%rax\nmov    %rax,%rsi\nlea    0x3abe(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    $0x1,%edi\ncall   1b83 <libmin_fail>\naddl   $0x1,-0x60(%rbp)\nmov    0x5a57(%rip),%eax\ncmp    %eax,-0x60(%rbp)\njl     1342 <main+0x77>\ncmpq   $0x0,-0x30(%rbp)\njne    15ea <main+0x31f>\nmovq   $0xd75,-0x30(%rbp)\nmov    $0xd75,%esi\nlea    0x3c71(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    -0x30(%rbp),%rax\nmov    %eax,%edi\ncall   3dde <libmin_srand>\nmovl   $0x0,-0x64(%rbp)\njmp    1610 <main+0x345>\nmov    -0x64(%rbp),%eax\ncltq\nmovq   $0x0,-0x20(%rbp,%rax,8)\naddl   $0x1,-0x64(%rbp)\ncmpl   $0x2,-0x64(%rbp)\njle    15fe <main+0x333>\nmovl   $0x0,-0x64(%rbp)\nmov    -0x68(%rbp),%eax\nmov    %eax,%esi\nlea    0x3c36(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\njmp    1730 <main+0x465>\ncall   3e90 <libmin_rand>\nmov    %eax,%eax\nmov    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %eax,%edi\ncall   3dde <libmin_srand>\nmovl   $0x0,-0x54(%rbp)\njmp    16d8 <main+0x40d>\nmov    -0x38(%rbp),%rax\nmovq   %rax,%xmm0\ncall   11e9 <cointoss>\ncmp    $0x1,%eax\njne    167c <main+0x3b1>\nmov    -0x54(%rbp),%eax\nmov    %eax,%edi\ncall   1270 <play_c>\nadd    %eax,-0x54(%rbp)\njmp    1684 <main+0x3b9>\ncall   1255 <play_s>\nadd    %eax,-0x54(%rbp)\nmov    -0x54(%rbp),%eax\ncmp    -0x50(%rbp),%eax\njge    16f0 <main+0x425>\nmov    -0x50(%rbp),%eax\nneg    %eax\ncmp    %eax,-0x54(%rbp)\njle    16f0 <main+0x425>\nmov    -0x54(%rbp),%eax\nmov    %eax,%edx\nneg    %edx\ncmovns %edx,%eax\nmov    %eax,-0x4c(%rbp)\nmov    -0x4c(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nadd    %ecx,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmovslq %eax,%rdx\nmov    -0x20(%rbp,%rdx,8),%rdx\nadd    $0x1,%rdx\ncltq\nmov    %rdx,-0x20(%rbp,%rax,8)\nmov    -0x48(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x48(%rbp)\ncmp    $0xf423f,%rax\njle    165a <main+0x38f>\nmov    -0x54(%rbp),%eax\ncmp    -0x50(%rbp),%eax\njne    16fe <main+0x433>\naddl   $0x1,-0x5c(%rbp)\njmp    170c <main+0x441>\nmov    -0x50(%rbp),%eax\nneg    %eax\ncmp    %eax,-0x54(%rbp)\njne    170c <main+0x441>\naddl   $0x1,-0x58(%rbp)\naddl   $0x1,-0x64(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sdq -0x48(%rbp),%xmm0\nmovsd  -0x40(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovq   $0x0,-0x48(%rbp)\nmov    -0x64(%rbp),%eax\ncmp    -0x68(%rbp),%eax\njl     163b <main+0x370>\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x64(%rbp),%xmm1\nmovsd  -0x40(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmov    -0x5c(%rbp),%edx\nmov    -0x58(%rbp),%eax\nadd    %eax,%edx\nmov    -0x64(%rbp),%eax\nsub    %edx,%eax\nmov    %eax,%ecx\nmov    -0x58(%rbp),%edx\nmov    -0x5c(%rbp),%eax\nmov    %eax,%esi\nlea    0x3b08(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    -0x50(%rbp),%edx\nmov    -0x50(%rbp),%eax\nmov    $0xf4240,%ecx\nmov    %eax,%esi\nlea    0x3b06(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3baf <libmin_printf>\nmov    -0x28(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x3b20(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3baf <libmin_printf>\nmov    -0x10(%rbp),%rax\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovsd  0x3ca7(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm2\ndivsd  -0x40(%rbp),%xmm2\nmov    -0x18(%rbp),%rax\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovsd  0x3c85(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm3\ndivsd  -0x40(%rbp),%xmm3\nmov    -0x20(%rbp),%rax\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovsd  0x3c63(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ndivsd  -0x40(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovapd %xmm3,%xmm1\nmovq   %rax,%xmm0\nlea    0x3abd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x3,%eax\ncall   3baf <libmin_printf>\ncall   4147 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     185e <main+0x593>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "parrondo/parrondo.c", "function_name": "play_c", "content": "/* One play of the complicated game: +1 if win, -1 if loss. */\n\nint play_c(int fortune)\n{\n\n\tif( fortune % 3 )\n\t\treturn cointoss(GOOD_WIN_PROB);\n\treturn cointoss(BAD_WIN_PROB);\n}\n"}, "pseudo": {"path": "parrondo/parrondo.host.O0.pseudo", "function_name": "play_c", "address": "0x1270", "label": "play_c", "content": "int __cdecl play_c(int fortune)\n{\n  if ( fortune % 3 )\n    return cointoss(0.745);\n  else\n    return cointoss(0.095);\n}\n"}, "pseudo_normalize": "int play_c(int fortune) {\n  if (fortune % 3)\n    return cointoss(0.745);\n  else\n    return cointoss(0.095);\n}", "binary": "parrondo/parrondo.host.O0", "assembly": "<play_c>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nadd    %ecx,%ecx\nadd    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\ntest   %eax,%eax\nje     12b8 <play_c+0x48>\nmov    0x41ac(%rip),%rax\nmovq   %rax,%xmm0\ncall   11e9 <cointoss>\njmp    12c9 <play_c+0x59>\nmov    0x41a1(%rip),%rax\nmovq   %rax,%xmm0\ncall   11e9 <cointoss>\nleave\nret\n"}
{"source": {"path": "parrondo/parrondo.c", "function_name": "play_s", "content": " \n\n/* One play of the simple game: +1 if win, -1 if loss. */\n\nint play_s(void)\n{\n\treturn cointoss(S_WIN_PROB);\n\t\t\n}\n"}, "pseudo": {"path": "parrondo/parrondo.host.O0.pseudo", "function_name": "play_s", "address": "0x1255", "label": "play_s", "content": "int __cdecl play_s()\n{\n  return cointoss(0.495);\n}\n"}, "pseudo_normalize": "", "binary": "parrondo/parrondo.host.O0", "assembly": "<play_s>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    0x41ec(%rip),%rax\nmovq   %rax,%xmm0\ncall   11e9 <cointoss>\npop    %rbp\nret\n"}
{"source": {"path": "pascal/pascal.c", "function_name": "main", "content": "int main(void)\n{\n\tint argc=1; char **argv=NULL;\n\tint i=1,j;\n\tint cols_option = FALSE;\n\tint nrows;\n\tint max_width;\n\tint row_offset;\n\n\t/* Process command line */\n\t\n\twhile(((i+1)<=argc)&&(argv[i][0] == '-')){\n\t\tif(argv[i][1] == 'h'){\n\t\t\tlibmin_printf(HELP);\n\t\t\treturn 0;\n\t\t}\n\t\tif(argv[i][1] == 'v'){\n\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\treturn 0;\n\t\t}\n\t\tif(argv[i][1]=='c'){\n\t\t\t/* make sure there is an arg */\n\t\t\tif((i+1) >= argc){\n\t\t\t\tlibmin_printf(USAGE);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcols_option = TRUE;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Unknown option if we got to here */\n\t\tlibmin_printf(USAGE);\n\t\treturn 1;\n\t}\n\n\t/* Make sure there is one arg left */\n\n\tif((i+1) != argc){ \n\t  nrows = 20;\n\t}\n\telse\n\t  nrows = libmin_atoi(argv[i]);\n\n\t/* Sanity checks */\n\tif(nrows == 0){ \n\t\tif(cols_option)\n\t\t  libmin_printf(\"0\\n\");\n\t\tlibmin_success(); /* nothing to do */\n\t}\n\tif(nrows < 0){\n\t\tlibmin_printf(\"%s: %d is an invalid number of rows\\n\", PROGRAM_NAME,nrows);\n\t\tlibmin_fail(1);\n\t}\n\tif(nrows > MAX_ROWS){\n\t\tlibmin_printf(\"%s: %d > %d rows maximum\\n\",PROGRAM_NAME,nrows, MAX_ROWS);\n\t\tlibmin_fail(1);\n\t}\n\n\t/* build the triangle */\n\t\n\ttriangle[0][0] = 1;\n\tfor(i=1;i<nrows;i++){\n\t\ttriangle[i][0] = 1;\n\t\tfor(j=1;j<i;j++)\n\t\t\ttriangle[i][j] = triangle[i-1][j-1]\n\t\t\t\t+ triangle[i-1][j];\n\t\ttriangle[i][i] = 1;\n\t}\n\n\t/* Find the widest number in table. It's the middle one in\n           the bottom row */\n\n\tmax_width = num_digits(triangle[nrows-1][nrows/2]);\n\n\t/* make sure this value is even */\n\tif(max_width % 2) max_width++;\n\n\t/* Since each number is printed in a field max_width+2 wide\n\t   and there are nrows numbers in the longest (bottom) row\n           the number of columns needed for the display is\n           (max_width+2)*nrows */\n\n\tif(cols_option){\n\t\t\tlibmin_printf(\"%d\\n\",(max_width + 2)*nrows);\n\t\t\tlibmin_success();\n\t}\n\t   \n\t/* Now print everything out */ \n\n\tfor(i=0;i<nrows;i++){\n\n\t\t/* This is the only tricky part. Think of each number as\n                   being printed in the center of a brick. Each brick has\n                   width max_width/2 + 1. Going down one row, the bricks\n                   move over one half width */\n\n\t\trow_offset = (nrows-i-1)*(max_width/2+1);\n\n\t\t/* Move first row in deepest, etc., by printing the approp.\n                   number of leading blanks */\n\n\t\tfor(j=0;j<row_offset;j++)\n\t\t  libmin_printf(\" \");\n\n\t\t/* Print ith row of numbers */\n\n\t\tfor(j=0;j<i+1;j++)\n\t\t\tif( print_centered(triangle[i][j],max_width+2)){\n\t\t\t\tlibmin_printf(\"%s: error printing element %d,%d\\n\",PROGRAM_NAME,i,j);\n\t\t\t\tlibmin_fail(1);\n\t\t}\n\t\tlibmin_printf(\"\\n\");\n\t}\n\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "pascal/pascal.host.O0.pseudo", "function_name": "main", "address": "0x12e7", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+Ch] [rbp-24h]\n  int ia; // [rsp+Ch] [rbp-24h]\n  int j; // [rsp+10h] [rbp-20h]\n  int ja; // [rsp+10h] [rbp-20h]\n  int jb; // [rsp+10h] [rbp-20h]\n  int max_width; // [rsp+1Ch] [rbp-14h]\n\n  triangle[0][0] = 1;\n  for ( i = 1; i < 20; ++i )\n  {\n    triangle[i][0] = 1;\n    for ( j = 1; j < i; ++j )\n      triangle[i][j] = triangle[i - 1][j] + triangle[i - 1][j - 1];\n    triangle[0][31 * i] = 1;\n  }\n  max_width = num_digits(triangle[19][10]);\n  if ( (max_width & 1) != 0 )\n    ++max_width;\n  for ( ia = 0; ia < 20; ++ia )\n  {\n    for ( ja = 0; ja < (20 - ia - 1) * (max_width / 2 + 1); ++ja )\n      libmin_printf(\" \");\n    for ( jb = 0; ia >= jb; ++jb )\n    {\n      if ( print_centered(triangle[ia][jb], max_width + 2) )\n      {\n        libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", ia, jb);\n        libmin_fail(1);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  int i;\n  int ia;\n  int j;\n  int ja;\n  int jb;\n  int max_width;\n  triangle[0][0] = 1;\n  for (i = 1; i < 20; ++i) {\n    triangle[i][0] = 1;\n    for (j = 1; j < i; ++j)\n      triangle[i][j] = triangle[i - 1][j] + triangle[i - 1][j - 1];\n    triangle[0][31 * i] = 1;\n  }\n  max_width = num_digits(triangle[19][10]);\n  if ((max_width & 1) != 0) ++max_width;\n  for (ia = 0; ia < 20; ++ia) {\n    for (ja = 0; ja < (20 - ia - 1) * (max_width / 2 + 1); ++ja)\n      libmin_printf(\" \");\n    for (jb = 0; ia >= jb; ++jb) {\n      if (print_centered(triangle[ia][jb], max_width + 2)) {\n        libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", ia, jb);\n        libmin_fail(1);\n      }\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_success();\n}", "binary": "pascal/pascal.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmovl   $0x1,-0x10(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmovl   $0x1,-0x24(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    1415 <main+0x12e>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ncmp    $0x68,%al\njne    1355 <main+0x6e>\nlea    0x2cd2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x0,%eax\njmp    17ac <main+0x4c5>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ncmp    $0x76,%al\njne    139f <main+0xb8>\nlea    0x2d66(%rip),%rax\nmov    %rax,%rsi\nlea    0x2d60(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x0,%eax\njmp    17ac <main+0x4c5>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ncmp    $0x63,%al\njne    13f7 <main+0x110>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\ncmp    %eax,-0x10(%rbp)\njg     13ea <main+0x103>\nlea    0x2d1d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x1,%eax\njmp    17ac <main+0x4c5>\nmovl   $0x1,-0x1c(%rbp)\naddl   $0x1,-0x24(%rbp)\njmp    1415 <main+0x12e>\nlea    0x2cf2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x1,%eax\njmp    17ac <main+0x4c5>\nmov    -0x24(%rbp),%eax\ncmp    -0x10(%rbp),%eax\njge    143f <main+0x158>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\nje     1315 <main+0x2e>\nmov    -0x24(%rbp),%eax\nadd    $0x1,%eax\ncmp    %eax,-0x10(%rbp)\nje     1453 <main+0x16c>\nmovl   $0x14,-0x18(%rbp)\njmp    1475 <main+0x18e>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   18f0 <libmin_atoi>\nmov    %eax,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njne    149a <main+0x1b3>\ncmpl   $0x0,-0x1c(%rbp)\nje     1495 <main+0x1ae>\nlea    0x2c8f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\ncall   3c91 <libmin_success>\ncmpl   $0x0,-0x18(%rbp)\njns    14cd <main+0x1e6>\nmov    -0x18(%rbp),%eax\nmov    %eax,%edx\nlea    0x2c6e(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c72(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x1,%edi\ncall   19f8 <libmin_fail>\ncmpl   $0x1e,-0x18(%rbp)\njle    1505 <main+0x21e>\nmov    -0x18(%rbp),%eax\nmov    $0x1e,%ecx\nmov    %eax,%edx\nlea    0x2c36(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c5f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x1,%edi\ncall   19f8 <libmin_fail>\nmovl   $0x1,0x4d71(%rip)\nmovl   $0x1,-0x24(%rbp)\njmp    161a <main+0x333>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nlea    0x4d47(%rip),%rax\nmovl   $0x1,(%rdx,%rax,1)\nmovl   $0x1,-0x20(%rbp)\njmp    15e5 <main+0x2fe>\nmov    -0x24(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x20(%rbp),%eax\nsub    $0x1,%eax\nmovslq %eax,%rcx\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4d03(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0x24(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rsi\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nadd    %rax,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4cd2(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%ecx\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rsi\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nadd    %rax,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4ca2(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0x24(%rbp),%eax\njl     154c <main+0x265>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x5,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nlea    0x4c71(%rip),%rax\nmovl   $0x1,(%rdx,%rax,1)\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     151b <main+0x234>\nmov    -0x18(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x18(%rbp),%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\nmovslq %eax,%rcx\nmovslq %edx,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nadd    %rax,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4c23(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%edi\ncall   11e9 <num_digits>\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\nje     1678 <main+0x391>\naddl   $0x1,-0x14(%rbp)\ncmpl   $0x0,-0x1c(%rbp)\nje     16a3 <main+0x3bc>\nmov    -0x14(%rbp),%eax\nadd    $0x2,%eax\nimul   -0x18(%rbp),%eax\nmov    %eax,%esi\nlea    0x2ad6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\ncall   3c91 <libmin_success>\nmovl   $0x0,-0x24(%rbp)\njmp    1796 <main+0x4af>\nmov    -0x18(%rbp),%eax\nsub    -0x24(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    -0x14(%rbp),%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\nadd    $0x1,%eax\nimul   %edx,%eax\nmov    %eax,-0xc(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmp    16ee <main+0x407>\nlea    0x292b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\naddl   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     16d6 <main+0x3ef>\nmovl   $0x0,-0x20(%rbp)\njmp    1776 <main+0x48f>\nmov    -0x14(%rbp),%eax\nlea    0x2(%rax),%edx\nmov    -0x20(%rbp),%eax\nmovslq %eax,%rsi\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rcx\nmov    %rcx,%rax\nshl    $0x4,%rax\nsub    %rcx,%rax\nadd    %rax,%rax\nadd    %rsi,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x4b50(%rip),%rax\nmov    (%rcx,%rax,1),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   122c <print_centered>\ntest   %eax,%eax\nje     1772 <main+0x48b>\nmov    -0x20(%rbp),%edx\nmov    -0x24(%rbp),%eax\nmov    %edx,%ecx\nmov    %eax,%edx\nlea    0x29c9(%rip),%rax\nmov    %rax,%rsi\nlea    0x2a15(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmov    $0x1,%edi\ncall   19f8 <libmin_fail>\naddl   $0x1,-0x20(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njge    16ff <main+0x418>\nlea    0x2a0d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x18(%rbp),%eax\njl     16af <main+0x3c8>\ncall   3c91 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "pascal/pascal.c", "function_name": "num_digits", "content": "/* num_digits: count how man digits the argument has and return that number */\n\nint num_digits(int n) {\n\n\tint d = 1;\n\n\t\n\twhile((n=n/10) != 0)\n    d++;\n\treturn d;\n}\n"}, "pseudo": {"path": "pascal/pascal.host.O0.pseudo", "function_name": "num_digits", "address": "0x11e9", "label": "num_digits", "content": "int __cdecl num_digits(int n)\n{\n  int d; // [rsp+10h] [rbp-4h]\n\n  for ( d = 1; ; ++d )\n  {\n    n /= 10;\n    if ( !n )\n      break;\n  }\n  return d;\n}\n"}, "pseudo_normalize": "int num_digits(int n) {\n  int d;\n  for (d = 1;; ++d) {\n    n /= 10;\n    if (!n) break;\n  }\n  return d;\n}", "binary": "pascal/pascal.host.O0", "assembly": "<num_digits>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x14(%rbp)\nmovl   $0x1,-0x4(%rbp)\njmp    1201 <num_digits+0x18>\naddl   $0x1,-0x4(%rbp)\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x2,%edx\nsar    $0x1f,%eax\nmov    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    11fd <num_digits+0x14>\nmov    -0x4(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "pascal/pascal.c", "function_name": "print_centered", "content": "/* print_centered: print the first argument centered in a field of \n\twidth given by the second argument, to the extent possible.\n\t(The width is always the second argument, but the number may not\n        be quite centered, depending on parity.) \n\tReturn 0 if successful and 1 if not.\n*/\n\nint print_centered(int n, int width)\n{\n\tint nw;\n\tint pad_space;\n\tint i;\n\n\tnw = num_digits(n);\n\tif(width < nw) return 1;  /* no can do */\n\n\tpad_space = (width - nw)/2;\n\n\tfor(i=0;i<pad_space;i++)\n\t  libmin_printf(\" \");\n\tlibmin_printf(\"%d\",n);\n\tfor(i=0;i<width - nw - pad_space;i++)\n\t  libmin_printf(\" \");\n\treturn 0;\n}\n"}, "pseudo": {"path": "pascal/pascal.host.O0.pseudo", "function_name": "print_centered", "address": "0x122c", "label": "print_centered", "content": "int __cdecl print_centered(int n, int width)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  int ia; // [rsp+14h] [rbp-Ch]\n  int nw; // [rsp+18h] [rbp-8h]\n  int pad_space; // [rsp+1Ch] [rbp-4h]\n\n  nw = num_digits(n);\n  if ( width < nw )\n    return 1;\n  pad_space = (width - nw) / 2;\n  for ( i = 0; i < pad_space; ++i )\n    libmin_printf(\" \");\n  libmin_printf(\"%d\", n);\n  for ( ia = 0; ia < width - nw - pad_space; ++ia )\n    libmin_printf(\" \");\n  return 0;\n}\n"}, "pseudo_normalize": "int print_centered(int n, int width) {\n  int i;\n  int ia;\n  int nw;\n  int pad_space;\n  nw = num_digits(n);\n  if (width < nw) return 1;\n  pad_space = (width - nw) / 2;\n  for (i = 0; i < pad_space; ++i) libmin_printf(\" \");\n  libmin_printf(\"%d\", n);\n  for (ia = 0; ia < width - nw - pad_space; ++ia) libmin_printf(\" \");\n  return 0;\n}", "binary": "pascal/pascal.host.O0", "assembly": "<print_centered>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <num_digits>\nmov    %eax,-0x8(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x8(%rbp),%eax\njge    125d <print_centered+0x31>\nmov    $0x1,%eax\njmp    12e5 <print_centered+0xb9>\nmov    -0x18(%rbp),%eax\nsub    -0x8(%rbp),%eax\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1290 <print_centered+0x64>\nlea    0x2d89(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x4(%rbp),%eax\njl     1278 <print_centered+0x4c>\nmov    -0x14(%rbp),%eax\nmov    %eax,%esi\nlea    0x2d66(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\nmovl   $0x0,-0xc(%rbp)\njmp    12d2 <print_centered+0xa6>\nlea    0x2d47(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a24 <libmin_printf>\naddl   $0x1,-0xc(%rbp)\nmov    -0x18(%rbp),%eax\nsub    -0x8(%rbp),%eax\nsub    -0x4(%rbp),%eax\ncmp    %eax,-0xc(%rbp)\njl     12ba <print_centered+0x8e>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "pi-calc/pi-calc.c", "function_name": "main", "content": "int main(void){for(;(b=c-=14);h=libmin_printf(\"%04d\",e+d/f))for(e=d%=f;(g=--b*2);d/=g)d=d*b+f*(h?a[b]:f/5),a[b]=d%--g;libmin_success(); return 0;}\n"}, "pseudo": {"path": "pi-calc/pi-calc.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ecx\n  int v4; // eax\n\n  while ( 1 )\n  {\n    c -= 14;\n    b = c;\n    if ( !c )\n      break;\n    d %= f;\n    e = d;\n    while ( 1 )\n    {\n      --b;\n      g = 2 * b;\n      if ( !(2 * b) )\n        break;\n      v3 = b * d;\n      if ( h )\n        v4 = a[b];\n      else\n        v4 = f / 5;\n      d = v3 + f * v4;\n      --g;\n      a[b] = (v3 + f * v4) % g;\n      d /= g;\n    }\n    h = libmin_printf(\"%04d\", d / f + e);\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  while (1) {\n    c -= 14;\n    b = c;\n    if (!c) break;\n    d %= f;\n    e = d;\n    while (1) {\n      --b;\n      g = 2 * b;\n      if (!(2 * b)) break;\n      v3 = b * d;\n      if (h)\n        v4 = a[b];\n      else\n        v4 = f / 5;\n      d = v3 + f * v4;\n      --g;\n      a[b] = (v3 + f * v4) % g;\n      d /= g;\n    }\n    h = libmin_printf(\"%04d\", d / f + e);\n  }\n  libmin_success();\n}", "binary": "pi-calc/pi-calc.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\njmp    1335 <main+0x14c>\nmov    0x38510(%rip),%eax\nmov    0x4e12(%rip),%ecx\ncltd\nidiv   %ecx\nmov    %edx,%eax\nmov    %eax,0x384ff(%rip)\nmov    0x384f9(%rip),%eax\nmov    %eax,0x384f7(%rip)\njmp    12d5 <main+0xec>\nmov    0x384e8(%rip),%edx\nmov    0x384de(%rip),%eax\nmov    %edx,%ecx\nimul   %eax,%ecx\nmov    0x384e3(%rip),%eax\ntest   %eax,%eax\nje     1255 <main+0x6c>\nmov    0x384c9(%rip),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x5030(%rip),%rax\nmov    (%rdx,%rax,1),%eax\njmp    1274 <main+0x8b>\nmov    0x4db9(%rip),%eax\nmovslq %eax,%rdx\nimul   $0x66666667,%rdx,%rdx\nshr    $0x20,%rdx\nsar    %edx\nsar    $0x1f,%eax\nmov    %eax,%esi\nmov    %edx,%eax\nsub    %esi,%eax\nmov    0x4d9a(%rip),%edx\nimul   %edx,%eax\nadd    %ecx,%eax\nmov    %eax,0x38487(%rip)\nmov    0x38481(%rip),%eax\nmov    0x38483(%rip),%edx\nsub    $0x1,%edx\nmov    %edx,0x3847a(%rip)\nmov    0x38474(%rip),%esi\nmov    0x38462(%rip),%ecx\ncltd\nidiv   %esi\nmov    %edx,%esi\nmovslq %ecx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4fc3(%rip),%rax\nmov    %esi,(%rdx,%rax,1)\nmov    0x38446(%rip),%eax\nmov    0x38448(%rip),%edi\ncltd\nidiv   %edi\nmov    %eax,0x38437(%rip)\nmov    0x3842d(%rip),%eax\nsub    $0x1,%eax\nmov    %eax,0x38424(%rip)\nmov    0x3841e(%rip),%eax\nadd    %eax,%eax\nmov    %eax,0x38422(%rip)\nmov    0x3841c(%rip),%eax\ntest   %eax,%eax\njne    121e <main+0x35>\nmov    0x38406(%rip),%eax\nmov    0x4d08(%rip),%edi\ncltd\nidiv   %edi\nmov    %eax,%edx\nmov    0x383f9(%rip),%eax\nadd    %edx,%eax\nmov    %eax,%esi\nlea    0x2ce2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34a6 <libmin_printf>\nmov    %eax,0x383e3(%rip)\nmov    0x4cd5(%rip),%eax\nsub    $0xe,%eax\nmov    %eax,0x4ccc(%rip)\nmov    0x4cc6(%rip),%eax\nmov    %eax,0x383b8(%rip)\nmov    0x383b2(%rip),%eax\ntest   %eax,%eax\njne    11f6 <main+0xd>\ncall   3713 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "get_random_int", "content": "/*\n * This function generates a random integer between in the interval\n * [low, high].  As we divide by (high - low + 1) in the process, we need\n * low < high.\n */\nuint64_t get_random_int(uint64_t low, uint64_t high)\n{\n\treturn (uint64_t)libmin_rand() % (high - low + 1) + low;\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O0.pseudo", "function_name": "get_random_int", "address": "0x1259", "label": "get_random_int", "content": "uint64_t __cdecl get_random_int(uint64_t low, uint64_t high)\n{\n  return libmin_rand() % (high - low + 1) + low;\n}\n"}, "pseudo_normalize": "", "binary": "primal-test/primal-test.host.O0", "assembly": "<get_random_int>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\ncall   4d64 <libmin_rand>\nmov    %eax,%edx\nmov    -0x10(%rbp),%rax\nsub    -0x8(%rbp),%rax\nlea    0x1(%rax),%rcx\nmov    %rdx,%rax\nmov    $0x0,%edx\ndiv    %rcx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nleave\nret\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "main", "content": "int\nmain(void)\n{\n  // initialize the RNG\n  libmin_srand(42);\n\n  // locate primes in a stream of random numbers\n  {\n    uint32_t val = 3;\n    for (int i=0; i < 200; i++)\n    {\n      int32_t prim = miller_rabin_int(val, K);\n      int _pred = (prim != PT_COMPOSITE);\n      if (_pred)\n      {\n        q[q_head].val = val;\n        q[q_head].prim = prim;\n        if (q_head+1 < Q_SIZE)\n          q_head++;\n      }\n      val = libmin_rand();\n    } \n  }\n\n  // print out the primes that were found\n  libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n  for (int i=0; i < q_head; i++)\n  {\n    if (q[i].prim == PT_PRIME)\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\", q[i].val);\n    else if (q[i].prim == PT_PRIME_LIKELY)\n      libmin_printf(\"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\", q[i].val, libmin_pow(4.0, K));\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O0.pseudo", "function_name": "main", "address": "0x1459", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm0_8\n  unsigned int val; // [rsp+Ch] [rbp-14h]\n  int i; // [rsp+10h] [rbp-10h]\n  int i_0; // [rsp+14h] [rbp-Ch]\n  int32_t prim; // [rsp+18h] [rbp-8h]\n\n  libmin_srand(0x2Au);\n  val = 3;\n  for ( i = 0; i <= 199; ++i )\n  {\n    prim = miller_rabin_int(val, 0x10u);\n    if ( prim )\n    {\n      q[q_head].val = val;\n      q[q_head].prim = prim;\n      if ( q_head <= 62 )\n        ++q_head;\n    }\n    val = libmin_rand();\n  }\n  libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n  for ( i_0 = 0; i_0 < q_head; ++i_0 )\n  {\n    if ( q[i_0].prim == 1 )\n    {\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\", q[i_0].val);\n    }\n    else if ( q[i_0].prim == 2 )\n    {\n      v3 = libmin_pow(4.0, 16.0);\n      libmin_printf(\"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\", q[i_0].val, v3);\n    }\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  unsigned int val;\n  int i;\n  int i_0;\n  int32_t prim;\n  libmin_srand(42u);\n  val = 3;\n  for (i = 0; i <= 199; ++i) {\n    prim = miller_rabin_int(val, 16u);\n    if (prim) {\n      q[q_head].val = val;\n      q[q_head].prim = prim;\n      if (q_head <= 62) ++q_head;\n    }\n    val = libmin_rand();\n  }\n  libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n  for (i_0 = 0; i_0 < q_head; ++i_0) {\n    if (q[i_0].prim == 1) {\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\",\n                    q[i_0].val);\n    } else if (q[i_0].prim == 2) {\n      v3 = libmin_pow(4.0, 16.0);\n      libmin_printf(\n          \"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\",\n          q[i_0].val, v3);\n    }\n  }\n  libmin_success();\n}", "binary": "primal-test/primal-test.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    $0x2a,%edi\ncall   4cb2 <libmin_srand>\nmovl   $0x3,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1507 <main+0xae>\nmov    -0x14(%rbp),%eax\nmov    $0x10,%esi\nmov    %eax,%edi\ncall   12fd <miller_rabin_int>\nmov    %eax,-0x8(%rbp)\ncmpl   $0x0,-0x8(%rbp)\nsetne  %al\nmovzbl %al,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\nje     14fb <main+0xa2>\nmov    0x6fd3(%rip),%eax\ncltq\nlea    0x0(,%rax,8),%rcx\nlea    0x6dc2(%rip),%rdx\nmov    -0x14(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    0x6fb6(%rip),%eax\ncltq\nlea    0x0(,%rax,8),%rcx\nlea    0x6da9(%rip),%rdx\nmov    -0x8(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    0x6f99(%rip),%eax\ncmp    $0x3e,%eax\njg     14fb <main+0xa2>\nmov    0x6f8e(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x6f85(%rip)\ncall   4d64 <libmin_rand>\nmov    %eax,-0x14(%rbp)\naddl   $0x1,-0x10(%rbp)\ncmpl   $0xc7,-0x10(%rbp)\njle    1482 <main+0x29>\nmov    0x6f66(%rip),%eax\nmov    %eax,%esi\nlea    0x4ae5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4a83 <libmin_printf>\nmovl   $0x0,-0xc(%rbp)\njmp    15fc <main+0x1a3>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x6d34(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    $0x1,%eax\njne    1587 <main+0x12e>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x6d14(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%esi\nlea    0x4ab8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   4a83 <libmin_printf>\njmp    15f8 <main+0x19f>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x6ce9(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    $0x2,%eax\njne    15f8 <main+0x19f>\nmovsd  0x4b05(%rip),%xmm0\nmov    0x4b06(%rip),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   1759 <libmin_pow>\nmovq   %xmm0,%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\nlea    0x6ca6(%rip),%rdx\nmov    (%rcx,%rdx,1),%edx\nmovq   %rax,%xmm0\nmov    %edx,%esi\nlea    0x4a7d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   4a83 <libmin_printf>\naddl   $0x1,-0xc(%rbp)\nmov    0x6e7e(%rip),%eax\ncmp    %eax,-0xc(%rbp)\njl     153c <main+0xe3>\ncall   54a0 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "miller_rabin_int", "content": "/*\n * This function checks whether a given number n is a prime or not, using the\n * Miller-Rabin primality test.  This is a probabilistic test which randomly\n * chooses an integer a as a base and checks whether n satisfies a certain\n * property (which depends on b).  If it does, n is a prime for at least three\n * out of four of the possible values of a, if it does not, it is certainly not\n * prime.\n *\n * The implementation is taken from the pseudo code found on\n * http://en.wikipedia.org/wiki/Miller-Rabin_primality_test.\n *\n * The function returns `probably_prime` if it found no evidence, that n might\n * be composite and `composite` if it did find a counter example.\n */\nint32_t\nmiller_rabin_int(uint32_t n, uint32_t k)\n{\n\tuint64_t s;\n\tuint64_t a = 0, d, x, nm1;\n\t/* We need an odd integer greater than 3 */\n\tif ((n & 1) == 0)\n\t\treturn n == 2 ? PT_PRIME : PT_COMPOSITE;\n\tif (n == 3)\n\t\treturn PT_PRIME;\n\telse if (n < 3)\n\t\treturn PT_COMPOSITE;\n\n\tnm1 = n - 1;\n\n\t/* compute s and d s.t. n-1=2^s*d */\n\tsplit_int(&s, &d, n);\n\n\t/* Repeat the test itself k times to increase the accuracy */\n\tfor (unsigned i = 0; i < k; i++) {\n\t\ta = get_random_int(2, n - 2);\n\n\t\t/* compute a^d mod n */\n\t\tx = powm(a, d, n);\n\n\t\tif (x == 1 || x == nm1)\n\t\t\tcontinue;\n\n\t\tfor (uint64_t r = 1; r <= s; r++) {\n\t\t\tx = (x * x) % n;\n\t\t\tif (x == 1)\n\t\t\t\treturn PT_COMPOSITE;\n\t\t\tif (x == nm1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (x != nm1)\n\t\t\treturn PT_COMPOSITE;\n\t}\n\n\treturn PT_PRIME_LIKELY;\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O0.pseudo", "function_name": "miller_rabin_int", "address": "0x12fd", "label": "miller_rabin_int", "content": "int32_t __cdecl miller_rabin_int(uint32_t n, uint32_t k)\n{\n  uint32_t i; // [rsp+14h] [rbp-3Ch]\n  uint64_t s; // [rsp+18h] [rbp-38h] BYREF\n  uint64_t d; // [rsp+20h] [rbp-30h] BYREF\n  uint64_t x; // [rsp+28h] [rbp-28h]\n  uint64_t r; // [rsp+30h] [rbp-20h]\n  uint64_t a; // [rsp+38h] [rbp-18h]\n  uint64_t nm1; // [rsp+40h] [rbp-10h]\n  unsigned __int64 v10; // [rsp+48h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  a = 0LL;\n  if ( (n & 1) == 0 )\n    return n == 2;\n  if ( n == 3 )\n    return 1;\n  if ( n <= 2 )\n    return 0;\n  nm1 = n - 1;\n  split_int(&s, &d, n);\n  for ( i = 0; i < k; ++i )\n  {\n    a = get_random_int(2uLL, n - 2);\n    x = powm(a, d, n);\n    if ( x != 1 && x != nm1 )\n    {\n      for ( r = 1LL; r <= s; ++r )\n      {\n        x = x * x % n;\n        if ( x == 1 )\n          return 0;\n        if ( x == nm1 )\n          break;\n      }\n      if ( x != nm1 )\n        return 0;\n    }\n  }\n  return 2;\n}\n"}, "pseudo_normalize": "int32_t miller_rabin_int(uint32_t n, uint32_t k) {\n  uint32_t i;\n  uint64_t s;\n  uint64_t d;\n  uint64_t x;\n  uint64_t r;\n  uint64_t a;\n  uint64_t nm1;\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  a = 0LL;\n  if ((n & 1) == 0) return n == 2;\n  if (n == 3) return 1;\n  if (n <= 2) return 0;\n  nm1 = n - 1;\n  split_int(&s, &d, n);\n  for (i = 0; i < k; ++i) {\n    a = get_random_int(2uLL, n - 2);\n    x = powm(a, d, n);\n    if (x != 1 && x != nm1) {\n      for (r = 1LL; r <= s; ++r) {\n        x = x * x % n;\n        if (x == 1) return 0;\n        if (x == nm1) break;\n      }\n      if (x != nm1) return 0;\n    }\n  }\n  return 2;\n}", "binary": "primal-test/primal-test.host.O0", "assembly": "<miller_rabin_int>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %esi,-0x48(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x18(%rbp)\nmov    -0x44(%rbp),%eax\nand    $0x1,%eax\ntest   %eax,%eax\njne    133f <miller_rabin_int+0x42>\ncmpl   $0x2,-0x44(%rbp)\nsete   %al\nmovzbl %al,%eax\njmp    1443 <miller_rabin_int+0x146>\ncmpl   $0x3,-0x44(%rbp)\njne    134f <miller_rabin_int+0x52>\nmov    $0x1,%eax\njmp    1443 <miller_rabin_int+0x146>\ncmpl   $0x2,-0x44(%rbp)\nja     135f <miller_rabin_int+0x62>\nmov    $0x0,%eax\njmp    1443 <miller_rabin_int+0x146>\nmov    -0x44(%rbp),%eax\nsub    $0x1,%eax\nmov    %eax,%eax\nmov    %rax,-0x10(%rbp)\nmov    -0x44(%rbp),%edx\nlea    -0x30(%rbp),%rcx\nlea    -0x38(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1294 <split_int>\nmovl   $0x0,-0x3c(%rbp)\njmp    1432 <miller_rabin_int+0x135>\nmov    -0x44(%rbp),%eax\nsub    $0x2,%eax\nmov    %eax,%eax\nmov    %rax,%rsi\nmov    $0x2,%edi\ncall   1259 <get_random_int>\nmov    %rax,-0x18(%rbp)\nmov    -0x30(%rbp),%rcx\nmov    -0x44(%rbp),%edx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <powm>\nmov    %rax,-0x28(%rbp)\ncmpq   $0x1,-0x28(%rbp)\nje     142d <miller_rabin_int+0x130>\nmov    -0x28(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nje     142d <miller_rabin_int+0x130>\nmovq   $0x1,-0x20(%rbp)\njmp    140f <miller_rabin_int+0x112>\nmov    -0x28(%rbp),%rax\nimul   %rax,%rax\nmov    -0x44(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %rcx\nmov    %rdx,-0x28(%rbp)\ncmpq   $0x1,-0x28(%rbp)\njne    1400 <miller_rabin_int+0x103>\nmov    $0x0,%eax\njmp    1443 <miller_rabin_int+0x146>\nmov    -0x28(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nje     141b <miller_rabin_int+0x11e>\naddq   $0x1,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\ncmp    %rax,-0x20(%rbp)\njbe    13db <miller_rabin_int+0xde>\njmp    141c <miller_rabin_int+0x11f>\nnop\nmov    -0x28(%rbp),%rax\ncmp    -0x10(%rbp),%rax\nje     142e <miller_rabin_int+0x131>\nmov    $0x0,%eax\njmp    1443 <miller_rabin_int+0x146>\nnop\naddl   $0x1,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncmp    -0x48(%rbp),%eax\njb     138d <miller_rabin_int+0x90>\nmov    $0x2,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1457 <miller_rabin_int+0x15a>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "powm", "content": "/* miller_rabin_int.c -- long long implementation of the Miller-Rabin test\n *\n * Copyright 2014 by Colin Benner <colin-software@yzhs.de>\n *\n * This file is part of frobenius-test.\n *\n * frobenius-test is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * frobenius-test is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with frobenius-test.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"libmin.h\"\n\n// precision of the primality test, there p_failure = 1/4^K\n#define K 16\n\n// primality results\n#define PT_COMPOSITE    0\n#define PT_PRIME        1\n#define PT_PRIME_LIKELY 2\n\n/*\n * Raise b to the e'th power modulo m.  This uses 64-bit registers to hold the\n * results of the multipliations.  Therefore, the results will be wrong if m is\n * greater than 2^32-1\n */\nstatic uint64_t powm(uint64_t b, uint64_t e, uint32_t m)\n{\n\tuint64_t result = 1;\n\n\twhile (e != 0) {\n\t\tif ((e & 1) == 1)\n\t\t\tresult = (result * b) % m;\n\t\tb = (b * b) % m;\n\t\te /= 2;\n\t}\n\treturn result;\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O0.pseudo", "function_name": "powm", "address": "0x11e9", "label": "powm", "content": "uint64_t __cdecl powm(uint64_t b, uint64_t e, uint32_t m)\n{\n  uint64_t result; // [rsp+1Ch] [rbp-8h]\n\n  result = 1LL;\n  while ( e )\n  {\n    if ( (e & 1) != 0 )\n      result = b * result % m;\n    b = b * b % m;\n    e >>= 1;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "uint64_t powm(uint64_t b, uint64_t e, uint32_t m) {\n  uint64_t result;\n  result = 1LL;\n  while (e) {\n    if ((e & 1) != 0) result = b * result % m;\n    b = b * b % m;\n    e >>= 1;\n  }\n  return result;\n}", "binary": "primal-test/primal-test.host.O0", "assembly": "<powm>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmovq   $0x1,-0x8(%rbp)\njmp    124c <powm+0x63>\nmov    -0x20(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nje     122a <powm+0x41>\nmov    -0x8(%rbp),%rax\nimul   -0x18(%rbp),%rax\nmov    -0x24(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %rcx\nmov    %rdx,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nimul   %rax,%rax\nmov    -0x24(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %rcx\nmov    %rdx,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\nshr    %rax\nmov    %rax,-0x20(%rbp)\ncmpq   $0x0,-0x20(%rbp)\njne    1206 <powm+0x1d>\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "split_int", "content": "/*\n * Calculate s, d such that n-1=2^s*d where d is odd.\n */\nvoid split_int(uint64_t *s, uint64_t *d, uint64_t n)\n{\n\t*s = 0;\n\t*d = n - 1;\n\n\twhile ((*d & 1) == 0)\n  {\n\t\t(*s)++;\n\t\t*d /= 2;\n\t}\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O0.pseudo", "function_name": "split_int", "address": "0x1294", "label": "split_int", "content": "void __cdecl split_int(uint64_t *s, uint64_t *d, uint64_t n)\n{\n  *s = 0LL;\n  for ( *d = n - 1; (*d & 1) == 0; *d >>= 1 )\n    ++*s;\n}\n"}, "pseudo_normalize": "", "binary": "primal-test/primal-test.host.O0", "assembly": "<split_int>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,(%rax)\nmov    -0x18(%rbp),%rax\nlea    -0x1(%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,(%rax)\njmp    12ea <split_int+0x56>\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nlea    0x1(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nshr    %rax\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nje     12c4 <split_int+0x30>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "isEmpty", "content": "// Function to check is list is empty\nint isEmpty(Node** head)\n{\n    return (*head) == NULL;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O0.pseudo", "function_name": "isEmpty", "address": "0x1340", "label": "isEmpty", "content": "int __cdecl isEmpty(Node **head)\n{\n  return *head == 0LL;\n}\n"}, "pseudo_normalize": "", "binary": "priority-queue/priority-queue.host.O0", "assembly": "<isEmpty>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\ntest   %rax,%rax\nsete   %al\nmovzbl %al,%eax\npop    %rbp\nret\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "main", "content": "// Driver code\nint main()\n{\n    // Create a Priority Queue\n    // 7->4->5->6\n    Node* pq = newNode(4, 1);\n    push(&pq, 5, 2);\n    push(&pq, 6, 3);\n    push(&pq, 7, 0);\n    printPQ(&pq);\n\n    libmin_srand(42);\n    pq = newNode(4, 1);\n    for (int i=0; i < 250; i++)\n    {\n      int prio = libmin_rand() % 250;\n      int val = libmin_rand() % 250;\n      push(&pq, prio, val);\n    }\n    printPQ(&pq);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O0.pseudo", "function_name": "main", "address": "0x13ee", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+4h] [rbp-1Ch]\n  unsigned int prio; // [rsp+8h] [rbp-18h]\n  unsigned int val; // [rsp+Ch] [rbp-14h]\n  Node *pq[2]; // [rsp+10h] [rbp-10h] BYREF\n\n  pq[1] = (Node *)__readfsqword(0x28u);\n  pq[0] = newNode(4, 1);\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(0x2Au);\n  pq[0] = newNode(4, 1);\n  for ( i = 0; i <= 249; ++i )\n  {\n    prio = libmin_rand() % 0xFA;\n    val = libmin_rand() % 0xFA;\n    push(pq, prio, val);\n  }\n  printPQ(pq);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  unsigned int prio;\n  unsigned int val;\n  Node *pq[2];\n  pq[1] = (Node *)__readfsqword(40u);\n  pq[0] = newNode(4, 1);\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(42u);\n  pq[0] = newNode(4, 1);\n  for (i = 0; i <= 249; ++i) {\n    prio = libmin_rand() % 250;\n    val = libmin_rand() % 250;\n    push(pq, prio, val);\n  }\n  printPQ(pq);\n  libmin_success();\n}", "binary": "priority-queue/priority-queue.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x1,%esi\nmov    $0x4,%edi\ncall   11e9 <newNode>\nmov    %rax,-0x10(%rbp)\nlea    -0x10(%rbp),%rax\nmov    $0x2,%edx\nmov    $0x5,%esi\nmov    %rax,%rdi\ncall   1299 <push>\nlea    -0x10(%rbp),%rax\nmov    $0x3,%edx\nmov    $0x6,%esi\nmov    %rax,%rdi\ncall   1299 <push>\nlea    -0x10(%rbp),%rax\nmov    $0x0,%edx\nmov    $0x7,%esi\nmov    %rax,%rdi\ncall   1299 <push>\nlea    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   135e <printPQ>\nmov    $0x2a,%edi\ncall   3d49 <libmin_srand>\nmov    $0x1,%esi\nmov    $0x4,%edi\ncall   11e9 <newNode>\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    14f0 <main+0x102>\ncall   3dfb <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x10624dd3,%rax,%rax\nshr    $0x20,%rax\nshr    $0x4,%eax\nimul   $0xfa,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x18(%rbp)\ncall   3dfb <libmin_rand>\nmov    %eax,%edx\nmov    %edx,%eax\nimul   $0x10624dd3,%rax,%rax\nshr    $0x20,%rax\nshr    $0x4,%eax\nimul   $0xfa,%eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%edx\nmov    -0x18(%rbp),%ecx\nlea    -0x10(%rbp),%rax\nmov    %ecx,%esi\nmov    %rax,%rdi\ncall   1299 <push>\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0xf9,-0x1c(%rbp)\njle    1490 <main+0xa2>\nlea    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   135e <printPQ>\ncall   40b2 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1523 <main+0x135>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "newNode", "content": "// Function to Create A New Node\nNode* newNode(int d, int p)\n{\n    Node* temp = (Node*)libmin_malloc(sizeof(Node));\n    temp->data = d;\n    temp->priority = p;\n    temp->next = NULL;\n\n    return temp;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O0.pseudo", "function_name": "newNode", "address": "0x11e9", "label": "newNode", "content": "Node *__cdecl newNode(int d, int p)\n{\n  Node *result; // rax\n\n  result = (Node *)libmin_malloc(0x10uLL);\n  result->data = d;\n  result->priority = p;\n  result->next = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "Node *newNode(int d, int p) {\n  Node *result;\n  result = (Node *)libmin_malloc(16uLL);\n  result->data = d;\n  result->priority = p;\n  result->next = 0LL;\n  return result;\n}", "binary": "priority-queue/priority-queue.host.O0", "assembly": "<newNode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\nmov    $0x10,%edi\ncall   16b8 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    -0x18(%rbp),%edx\nmov    %edx,0x4(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "peek", "content": "// Return the value at head\nint peek(Node** head)\n{\n    return (*head)->data;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O0.pseudo", "function_name": "peek", "address": "0x122e", "label": "peek", "content": "int __cdecl peek(Node **head)\n{\n  return (*head)->data;\n}\n"}, "pseudo_normalize": "", "binary": "priority-queue/priority-queue.host.O0", "assembly": "<peek>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    (%rax),%eax\npop    %rbp\nret\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "pop", "content": "// Removes the element with the\n// highest priority form the list\nvoid pop(Node** head)\n{\n    Node* temp = *head;\n    (*head) = (*head)->next;\n    libmin_free(temp);\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O0.pseudo", "function_name": "pop", "address": "0x125d", "label": "pop", "content": "void __cdecl pop(Node **head)\n{\n  Node *temp; // [rsp+18h] [rbp-8h]\n\n  temp = *head;\n  *head = (*head)->next;\n  libmin_free(temp);\n}\n"}, "pseudo_normalize": "void pop(Node **head) {\n  Node *temp;\n  temp = *head;\n  *head = (*head)->next;\n  libmin_free(temp);\n}", "binary": "priority-queue/priority-queue.host.O0", "assembly": "<pop>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    0x8(%rax),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   17a3 <libmin_free>\nnop\nleave\nret\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "printPQ", "content": "void\nprintPQ(Node** pq)\n{\n  libmin_printf(\"priorityQ: \");\n  while (!isEmpty(pq)) {\n      libmin_printf(\"<prio:%d, val:%d> \", priopeek(pq), peek(pq));\n      pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O0.pseudo", "function_name": "printPQ", "address": "0x135e", "label": "printPQ", "content": "void __cdecl printPQ(Node **pq)\n{\n  int v1; // ebx\n  int v2; // eax\n\n  libmin_printf(\"priorityQ: \");\n  while ( !isEmpty(pq) )\n  {\n    v1 = peek(pq);\n    v2 = priopeek(pq);\n    libmin_printf(\"<prio:%d, val:%d> \", v2, v1);\n    pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void printPQ(Node **pq) {\n  int v1;\n  int v2;\n  libmin_printf(\"priorityQ: \");\n  while (!isEmpty(pq)) {\n    v1 = peek(pq);\n    v2 = priopeek(pq);\n    libmin_printf(\"<prio:%d, val:%d> \", v2, v1);\n    pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "priority-queue/priority-queue.host.O0", "assembly": "<printPQ>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,-0x18(%rbp)\nlea    0x3c8e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b1a <libmin_printf>\njmp    13c3 <printPQ+0x65>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   122e <peek>\nmov    %eax,%ebx\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1245 <priopeek>\nmov    %ebx,%edx\nmov    %eax,%esi\nlea    0x3c66(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b1a <libmin_printf>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   125d <pop>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1340 <isEmpty>\ntest   %eax,%eax\nje     1385 <printPQ+0x27>\nlea    0x3c49(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b1a <libmin_printf>\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "priopeek", "content": "// Return the value at head\nint priopeek(Node** head)\n{\n    return (*head)->priority;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O0.pseudo", "function_name": "priopeek", "address": "0x1245", "label": "priopeek", "content": "int __cdecl priopeek(Node **head)\n{\n  return (*head)->priority;\n}\n"}, "pseudo_normalize": "", "binary": "priority-queue/priority-queue.host.O0", "assembly": "<priopeek>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%eax\npop    %rbp\nret\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "push", "content": "// Function to push according to priority\nvoid push(Node** head, int d, int p)\n{\n    Node* start = (*head);\n\n    // Create new Node\n    Node* temp = newNode(d, p);\n\n    // Special Case: The head of list has lesser\n    // priority than new node. So insert new\n    // node before head node and change head node.\n    if ((*head)->priority > p) {\n\n        // Insert New Node before head\n        temp->next = *head;\n        (*head) = temp;\n    }\n    else {\n\n        // Traverse the list and find a\n        // position to insert new node\n        while (start->next != NULL &&\n               start->next->priority < p) {\n            start = start->next;\n        }\n\n        // Either at the ends of the list\n        // or at required position\n        temp->next = start->next;\n        start->next = temp;\n    }\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O0.pseudo", "function_name": "push", "address": "0x1299", "label": "push", "content": "void __cdecl push(Node **head, int d, int p)\n{\n  Node *start; // [rsp+10h] [rbp-10h]\n  Node *temp; // [rsp+18h] [rbp-8h]\n\n  start = *head;\n  temp = newNode(d, p);\n  if ( p >= (*head)->priority )\n  {\n    while ( start->next && p > start->next->priority )\n      start = start->next;\n    temp->next = start->next;\n    start->next = temp;\n  }\n  else\n  {\n    temp->next = *head;\n    *head = temp;\n  }\n}\n"}, "pseudo_normalize": "void push(Node **head, int d, int p) {\n  Node *start;\n  Node *temp;\n  start = *head;\n  temp = newNode(d, p);\n  if (p >= (*head)->priority) {\n    while (start->next && p > start->next->priority) start = start->next;\n    temp->next = start->next;\n    start->next = temp;\n  } else {\n    temp->next = *head;\n    *head = temp;\n  }\n}", "binary": "priority-queue/priority-queue.host.O0", "assembly": "<push>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%edx\nmov    -0x1c(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   11e9 <newNode>\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    0x4(%rax),%eax\ncmp    %eax,-0x20(%rbp)\njge    1304 <push+0x6b>\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\njmp    133d <push+0xa4>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\ntest   %rax,%rax\nje     1321 <push+0x88>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    0x4(%rax),%eax\ncmp    %eax,-0x20(%rbp)\njg     12f8 <push+0x5f>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,0x8(%rax)\nnop\nleave\nret\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "cstring_cmp", "content": "/* qsort C-string comparison function */\nint\ncstring_cmp(const void *a, const void *b)\n{\n    const char **ia = (const char **)a;\n    const char **ib = (const char **)b;\n    return libmin_strcmp(*ia, *ib);\n    /* strcmp functions works exactly as expected from\n    comparison function */\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O0.pseudo", "function_name": "cstring_cmp", "address": "0x135b", "label": "cstring_cmp", "content": "int __cdecl cstring_cmp(const void *a, const void *b)\n{\n  return libmin_strcmp(*(const char **)a, *(const char **)b);\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O0", "assembly": "<cstring_cmp>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3e5b <libmin_strcmp>\nleave\nret\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "int_cmp", "content": "#include \"libmin.h\"\n\n/* qsort int comparison function */\nint\nint_cmp(const void *a, const void *b)\n{\n    const int *ia = (const int *)a; // casting pointer types\n    const int *ib = (const int *)b;\n    return *ia  - *ib;\n    /* integer comparison: returns negative if a < b\n    and positive if a > b */\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O0.pseudo", "function_name": "int_cmp", "address": "0x11e9", "label": "int_cmp", "content": "int __cdecl int_cmp(const void *a, const void *b)\n{\n  return *(_DWORD *)a - *(_DWORD *)b;\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O0", "assembly": "<int_cmp>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\npop    %rbp\nret\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "main", "content": "/* MAIN program (calls all other examples) */\nint\nmain(void)\n{\n    /* run all example functions */\n    sort_integers_example();\n    sort_cstrings_example();\n    sort_structs_example();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O0.pseudo", "function_name": "main", "address": "0x17bf", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}", "binary": "qsort-demo/qsort-demo.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\ncall   1280 <sort_integers_example>\ncall   1401 <sort_cstrings_example>\ncall   1603 <sort_structs_example>\ncall   3ef7 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "print_cstring_array", "content": "/* C-string array printing function */\nvoid\nprint_cstring_array(char **array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"%s | \", array[i]);\n\n    libmin_putc('\\n');\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O0.pseudo", "function_name": "print_cstring_array", "address": "0x139a", "label": "print_cstring_array", "content": "void __cdecl print_cstring_array(char **array, size_t len)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0LL; i < len; ++i )\n    libmin_printf(\"%s | \", array[i]);\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O0", "assembly": "<print_cstring_array>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x0,-0x8(%rbp)\njmp    13ea <print_cstring_array+0x50>\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x3c4d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   391e <libmin_printf>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     13b8 <print_cstring_array+0x1e>\nmov    $0xa,%edi\ncall   3b4d <libmin_putc>\nnop\nleave\nret\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "print_int_array", "content": "/* integer array printing function */\nvoid\nprint_int_array(const int *array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"%d | \", array[i]);\n\n    libmin_putc('\\n');\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O0.pseudo", "function_name": "print_int_array", "address": "0x121b", "label": "print_int_array", "content": "void __cdecl print_int_array(const int *array, size_t len)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0LL; i < len; ++i )\n    libmin_printf(\"%d | \", array[i]);\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O0", "assembly": "<print_int_array>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x0,-0x8(%rbp)\njmp    1269 <print_int_array+0x4e>\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x3db1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   391e <libmin_printf>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     1239 <print_int_array+0x1e>\nmov    $0xa,%edi\ncall   3b4d <libmin_putc>\nnop\nleave\nret\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "print_struct_array", "content": "/* Example struct array printing function */\nvoid\nprint_struct_array(struct st_ex *array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array[i].product, array[i].price);\n\n    libmin_puts(\"--\");\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O0.pseudo", "function_name": "print_struct_array", "address": "0x155e", "label": "print_struct_array", "content": "void __cdecl print_struct_array(st_ex *array, size_t len)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0LL; i < len; ++i )\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array[i].product, array[i].price);\n  libmin_puts(\"--\");\n}\n"}, "pseudo_normalize": "void print_struct_array(st_ex *array, unsigned int len) {\n  unsigned int i;\n  for (i = 0LL; i < len; ++i)\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array[i].product,\n                  array[i].price);\n  libmin_puts(\"--\");\n}", "binary": "qsort-demo/qsort-demo.host.O0", "assembly": "<print_struct_array>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x0,-0x8(%rbp)\njmp    15e7 <print_struct_array+0x89>\nmov    -0x8(%rbp),%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovss  0x10(%rax),%xmm0\npxor   %xmm1,%xmm1\ncvtss2sd %xmm0,%xmm1\nmovq   %xmm1,%rdx\nmov    -0x8(%rbp),%rcx\nmov    %rcx,%rax\nshl    $0x2,%rax\nadd    %rcx,%rax\nshl    $0x2,%rax\nmov    %rax,%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmovq   %rdx,%xmm0\nmov    %rax,%rsi\nlea    0x3a93(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   391e <libmin_printf>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     157c <print_struct_array+0x1e>\nlea    0x3a90(%rip),%rax\nmov    %rax,%rdi\ncall   3b6c <libmin_puts>\nnop\nleave\nret\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "sort_cstrings_example", "content": "/* sorting C-strings array using qsort() example */\nvoid\nsort_cstrings_example(void)\n{\n    char *strings[] = { \"Zorro\", \"Alex\", \"Celine\", \"Bill\", \"Forest\", \"Dexter\" };\n    size_t strings_len = sizeof(strings) / sizeof(char *);\n\n    /* STRING */\n    libmin_puts(\"*** String sorting...\");\n\n    /* print original string array */\n    print_cstring_array(strings, strings_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(strings, strings_len, sizeof(char *), cstring_cmp);\n\n    /* print sorted string array */\n    print_cstring_array(strings, strings_len);\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O0.pseudo", "function_name": "sort_cstrings_example", "address": "0x1401", "label": "sort_cstrings_example", "content": "void __cdecl sort_cstrings_example()\n{\n  char *strings[6]; // [rsp+10h] [rbp-40h] BYREF\n  unsigned __int64 v1; // [rsp+48h] [rbp-8h]\n\n  v1 = __readfsqword(0x28u);\n  strings[0] = \"Zorro\";\n  strings[1] = \"Alex\";\n  strings[2] = \"Celine\";\n  strings[3] = \"Bill\";\n  strings[4] = \"Forest\";\n  strings[5] = \"Dexter\";\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(strings, 6uLL);\n  libmin_qsort(strings, 6uLL, 8uLL, (int (*)(const void *, const void *))cstring_cmp);\n  print_cstring_array(strings, 6uLL);\n}\n"}, "pseudo_normalize": "void sort_cstrings_example() {\n  char *strings[6];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  strings[0] = \"Zorro\";\n  strings[1] = \"Alex\";\n  strings[2] = \"Celine\";\n  strings[3] = \"Bill\";\n  strings[4] = \"Forest\";\n  strings[5] = \"Dexter\";\n  libmin_puts(\"*** String sorting...\");\n  print_cstring_array(strings, 6uLL);\n  libmin_qsort(strings, 6uLL, 8uLL,\n               (int (*)(const void *, const void *))cstring_cmp);\n  print_cstring_array(strings, 6uLL);\n}", "binary": "qsort-demo/qsort-demo.host.O0", "assembly": "<sort_cstrings_example>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x3c08(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0x3c03(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0x3bfd(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0x3bf9(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0x3bf3(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x3bef(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovq   $0x6,-0x48(%rbp)\nlea    0x3be3(%rip),%rax\nmov    %rax,%rdi\ncall   3b6c <libmin_puts>\nmov    -0x48(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   139a <print_cstring_array>\nmov    -0x48(%rbp),%rsi\nlea    -0x40(%rbp),%rax\nlea    -0x13c(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x8,%edx\nmov    %rax,%rdi\ncall   3e09 <libmin_qsort>\nmov    -0x48(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   139a <print_cstring_array>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     14cf <sort_cstrings_example+0xce>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "sort_integers_example", "content": "/* sorting integers using qsort() example */\nvoid\nsort_integers_example(void)\n{\n    int numbers[] = { 7, 3, 4, 1, -1, 23, 12, 43, 2, -4, 5 };\n    size_t numbers_len = sizeof(numbers)/sizeof(int);\n\n    libmin_puts(\"*** Integer sorting...\");\n\n    /* print original integer array */\n    print_int_array(numbers, numbers_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(numbers, numbers_len, sizeof(int), int_cmp);\n\n    /* print sorted integer array */\n    print_int_array(numbers, numbers_len);\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O0.pseudo", "function_name": "sort_integers_example", "address": "0x1280", "label": "sort_integers_example", "content": "void __cdecl sort_integers_example()\n{\n  int numbers[14]; // [rsp+10h] [rbp-40h] BYREF\n  unsigned __int64 v1; // [rsp+48h] [rbp-8h]\n\n  v1 = __readfsqword(0x28u);\n  numbers[0] = 7;\n  numbers[1] = 3;\n  numbers[2] = 4;\n  numbers[3] = 1;\n  numbers[4] = -1;\n  numbers[5] = 23;\n  numbers[6] = 12;\n  numbers[7] = 43;\n  numbers[8] = 2;\n  numbers[9] = -4;\n  numbers[10] = 5;\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(numbers, 0xBuLL);\n  libmin_qsort(numbers, 0xBuLL, 4uLL, (int (*)(const void *, const void *))int_cmp);\n  print_int_array(numbers, 0xBuLL);\n}\n"}, "pseudo_normalize": "void sort_integers_example() {\n  int numbers[14];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  numbers[0] = 7;\n  numbers[1] = 3;\n  numbers[2] = 4;\n  numbers[3] = 1;\n  numbers[4] = -1;\n  numbers[5] = 23;\n  numbers[6] = 12;\n  numbers[7] = 43;\n  numbers[8] = 2;\n  numbers[9] = -4;\n  numbers[10] = 5;\n  libmin_puts(\"*** Integer sorting...\");\n  print_int_array(numbers, 11uLL);\n  libmin_qsort(numbers, 11uLL, 4uLL,\n               (int (*)(const void *, const void *))int_cmp);\n  print_int_array(numbers, 11uLL);\n}", "binary": "qsort-demo/qsort-demo.host.O0", "assembly": "<sort_integers_example>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x7,-0x40(%rbp)\nmovl   $0x3,-0x3c(%rbp)\nmovl   $0x4,-0x38(%rbp)\nmovl   $0x1,-0x34(%rbp)\nmovl   $0xffffffff,-0x30(%rbp)\nmovl   $0x17,-0x2c(%rbp)\nmovl   $0xc,-0x28(%rbp)\nmovl   $0x2b,-0x24(%rbp)\nmovl   $0x2,-0x20(%rbp)\nmovl   $0xfffffffc,-0x1c(%rbp)\nmovl   $0x5,-0x18(%rbp)\nmovq   $0xb,-0x48(%rbp)\nlea    0x3d17(%rip),%rax\nmov    %rax,%rdi\ncall   3b6c <libmin_puts>\nmov    -0x48(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   121b <print_int_array>\nmov    -0x48(%rbp),%rsi\nlea    -0x40(%rbp),%rax\nlea    -0x138(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x4,%edx\nmov    %rax,%rdi\ncall   3e09 <libmin_qsort>\nmov    -0x48(%rbp),%rdx\nlea    -0x40(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   121b <print_int_array>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1359 <sort_integers_example+0xd9>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "sort_structs_example", "content": "/* sorting structs using qsort() example */\nvoid\nsort_structs_example(void)\n{\n    struct st_ex structs[] = {{\"mp3 player\", 299.0f}, {\"plasma tv\", 2200.0f},\n                              {\"notebook\", 1300.0f}, {\"smartphone\", 499.99f},\n                              {\"dvd player\", 150.0f}, {\"matches\", 0.2f }};\n\n    size_t structs_len = sizeof(structs) / sizeof(struct st_ex);\n\n    libmin_puts(\"*** Struct sorting (price)...\");\n\n    /* print original struct array */\n    print_struct_array(structs, structs_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(structs, structs_len, sizeof(struct st_ex), struct_cmp_by_price);\n\n    /* print sorted struct array */\n    print_struct_array(structs, structs_len);\n\n    libmin_puts(\"*** Struct sorting (product)...\");\n\n    /* resort using other comparision function */\n    libmin_qsort(structs, structs_len, sizeof(struct st_ex), struct_cmp_by_product);\n\n    /* print sorted struct array */\n    print_struct_array(structs, structs_len);\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O0.pseudo", "function_name": "sort_structs_example", "address": "0x1603", "label": "sort_structs_example", "content": "void __cdecl sort_structs_example()\n{\n  st_ex structs[6]; // [rsp+10h] [rbp-80h] BYREF\n  unsigned __int64 v1; // [rsp+88h] [rbp-8h]\n\n  v1 = __readfsqword(0x28u);\n  strcpy(structs[0].product, \"mp3 player\");\n  structs[0].product[11] = 0;\n  *(_DWORD *)&structs[0].product[12] = 0;\n  structs[0].price = 299.0;\n  strcpy(structs[1].product, \"plasma tv\");\n  *(_WORD *)&structs[1].product[10] = 0;\n  *(_DWORD *)&structs[1].product[12] = 0;\n  structs[1].price = 2200.0;\n  strcpy(structs[2].product, \"notebook\");\n  structs[2].product[9] = 0;\n  *(_WORD *)&structs[2].product[10] = 0;\n  *(_DWORD *)&structs[2].product[12] = 0;\n  structs[2].price = 1300.0;\n  strcpy(structs[3].product, \"smartphone\");\n  structs[3].product[11] = 0;\n  *(_DWORD *)&structs[3].product[12] = 0;\n  structs[3].price = 499.98999;\n  strcpy(structs[4].product, \"dvd player\");\n  structs[4].product[11] = 0;\n  *(_DWORD *)&structs[4].product[12] = 0;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(_QWORD *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(structs, 6uLL);\n  libmin_qsort(structs, 6uLL, 0x14uLL, (int (*)(const void *, const void *))struct_cmp_by_price);\n  print_struct_array(structs, 6uLL);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 0x14uLL, (int (*)(const void *, const void *))struct_cmp_by_product);\n  print_struct_array(structs, 6uLL);\n}\n"}, "pseudo_normalize": "void sort_structs_example() {\n  st_ex structs[6];\n  unsigned long long v1;\n  v1 = __readfsqword(40u);\n  strcpy(structs[0].product, \"mp3 player\");\n  structs[0].product[11] = 0;\n  *(uint32_t *)&structs[0].product[12] = 0;\n  structs[0].price = 299.0;\n  strcpy(structs[1].product, \"plasma tv\");\n  *(unsigned short *)&structs[1].product[10] = 0;\n  *(uint32_t *)&structs[1].product[12] = 0;\n  structs[1].price = 2200.0;\n  strcpy(structs[2].product, \"notebook\");\n  structs[2].product[9] = 0;\n  *(unsigned short *)&structs[2].product[10] = 0;\n  *(uint32_t *)&structs[2].product[12] = 0;\n  structs[2].price = 1300.0;\n  strcpy(structs[3].product, \"smartphone\");\n  structs[3].product[11] = 0;\n  *(uint32_t *)&structs[3].product[12] = 0;\n  structs[3].price = 499.98999;\n  strcpy(structs[4].product, \"dvd player\");\n  structs[4].product[11] = 0;\n  *(uint32_t *)&structs[4].product[12] = 0;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(uint64_t *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  libmin_puts(\"*** Struct sorting (price)...\");\n  print_struct_array(structs, 6uLL);\n  libmin_qsort(structs, 6uLL, 20uLL,\n               (int (*)(const void *, const void *))struct_cmp_by_price);\n  print_struct_array(structs, 6uLL);\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 20uLL,\n               (int (*)(const void *, const void *))struct_cmp_by_product);\n  print_struct_array(structs, 6uLL);\n}", "binary": "qsort-demo/qsort-demo.host.O0", "assembly": "<sort_structs_example>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x90,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovabs $0x79616c702033706d,%rax\nmov    $0x7265,%edx\nmov    %rax,-0x80(%rbp)\nmov    %rdx,-0x78(%rbp)\nmovss  0x3a94(%rip),%xmm0\nmovss  %xmm0,-0x70(%rbp)\nmovabs $0x7420616d73616c70,%rax\nmov    $0x76,%edx\nmov    %rax,-0x6c(%rbp)\nmov    %rdx,-0x64(%rbp)\nmovss  0x3a74(%rip),%xmm0\nmovss  %xmm0,-0x5c(%rbp)\nmovabs $0x6b6f6f6265746f6e,%rax\nmov    $0x0,%edx\nmov    %rax,-0x58(%rbp)\nmov    %rdx,-0x50(%rbp)\nmovss  0x3a54(%rip),%xmm0\nmovss  %xmm0,-0x48(%rbp)\nmovabs $0x6f68707472616d73,%rax\nmov    $0x656e,%edx\nmov    %rax,-0x44(%rbp)\nmov    %rdx,-0x3c(%rbp)\nmovss  0x3a34(%rip),%xmm0\nmovss  %xmm0,-0x34(%rbp)\nmovabs $0x79616c7020647664,%rax\nmov    $0x7265,%edx\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovss  0x3a14(%rip),%xmm0\nmovss  %xmm0,-0x20(%rbp)\nmovabs $0x7365686374616d,%rax\nmov    $0x0,%edx\nmov    %rax,-0x1c(%rbp)\nmov    %rdx,-0x14(%rbp)\nmovss  0x39f4(%rip),%xmm0\nmovss  %xmm0,-0xc(%rbp)\nmovq   $0x6,-0x88(%rbp)\nlea    0x3980(%rip),%rax\nmov    %rax,%rdi\ncall   3b6c <libmin_puts>\nmov    -0x88(%rbp),%rdx\nlea    -0x80(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   155e <print_struct_array>\nmov    -0x88(%rbp),%rsi\nlea    -0x80(%rbp),%rax\nlea    -0x26a(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x14,%edx\nmov    %rax,%rdi\ncall   3e09 <libmin_qsort>\nmov    -0x88(%rbp),%rdx\nlea    -0x80(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   155e <print_struct_array>\nlea    0x3948(%rip),%rax\nmov    %rax,%rdi\ncall   3b6c <libmin_puts>\nmov    -0x88(%rbp),%rsi\nlea    -0x80(%rbp),%rax\nlea    -0x25d(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x14,%edx\nmov    %rax,%rdi\ncall   3e09 <libmin_qsort>\nmov    -0x88(%rbp),%rdx\nlea    -0x80(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   155e <print_struct_array>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     17bd <sort_structs_example+0x1ba>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "struct_cmp_by_price", "content": "/* qsort struct comparision function (price float field) */\nint\nstruct_cmp_by_price(const void *a, const void *b)\n{\n    struct st_ex *ia = (struct st_ex *)a;\n    struct st_ex *ib = (struct st_ex *)b;\n    return (int)(100.f*ia->price - 100.f*ib->price);\n    /* float comparison: returns negative if b > a\n    and positive if a > b. We multiplied result by 100.0\n    to preserve decimal fraction */\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O0.pseudo", "function_name": "struct_cmp_by_price", "address": "0x14d1", "label": "struct_cmp_by_price", "content": "int __cdecl struct_cmp_by_price(const void *a, const void *b)\n{\n  return (int)(float)((float)(100.0 * *((float *)a + 4)) - (float)(100.0 * *((float *)b + 4)));\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O0", "assembly": "<struct_cmp_by_price>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%rax\nmovss  0x10(%rax),%xmm1\nmovss  0x3bce(%rip),%xmm0\nmulss  %xmm1,%xmm0\nmov    -0x8(%rbp),%rax\nmovss  0x10(%rax),%xmm2\nmovss  0x3bb9(%rip),%xmm1\nmulss  %xmm2,%xmm1\nsubss  %xmm1,%xmm0\ncvttss2si %xmm0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "struct_cmp_by_product", "content": "/* qsort struct comparision function (product C-string field) */\nint\nstruct_cmp_by_product(const void *a, const void *b)\n{\n    struct st_ex *ia = (struct st_ex *)a;\n    struct st_ex *ib = (struct st_ex *)b;\n    return libmin_strcmp(ia->product, ib->product);\n    /* strcmp functions works exactly as expected from\n    comparison function */\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O0.pseudo", "function_name": "struct_cmp_by_product", "address": "0x1525", "label": "struct_cmp_by_product", "content": "int __cdecl struct_cmp_by_product(const void *a, const void *b)\n{\n  return libmin_strcmp((const char *)a, (const char *)b);\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O0", "assembly": "<struct_cmp_by_product>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3e5b <libmin_strcmp>\nleave\nret\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "int_compare", "content": "#include \"libmin.h\"\n\n/* Comparison function for integers. */\nint int_compare(const void *a, const void *b) {\n    const int *ia = (const int *) a;\n    const int *ib = (const int *) b;\n    return (*ia) - (*ib);\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O0.pseudo", "function_name": "int_compare", "address": "0x11e9", "label": "int_compare", "content": "int __cdecl int_compare(const void *a, const void *b)\n{\n  return *(_DWORD *)a - *(_DWORD *)b;\n}\n"}, "pseudo_normalize": "", "binary": "qsort-test/qsort-test.host.O0", "assembly": "<int_compare>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x10(%rbp),%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    (%rax),%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\npop    %rbp\nret\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "is_sorted", "content": "/* Utility function to check if an array of integers is sorted (non-decreasing order). */\nint is_sorted(const int arr[], size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        if (arr[i - 1] > arr[i])\n            return 0;\n    }\n    return 1;\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O0.pseudo", "function_name": "is_sorted", "address": "0x121b", "label": "is_sorted", "content": "int __cdecl is_sorted(const int *arr, size_t n)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 1LL; i < n; ++i )\n  {\n    if ( arr[i - 1] > arr[i] )\n      return 0;\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int is_sorted(const int *arr, unsigned int n) {\n  unsigned int i;\n  for (i = 1LL; i < n; ++i) {\n    if (arr[i - 1] > arr[i]) return 0;\n  }\n  return 1;\n}", "binary": "qsort-test/qsort-test.host.O0", "assembly": "<is_sorted>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x1,-0x8(%rbp)\njmp    126f <is_sorted+0x54>\nmov    -0x8(%rbp),%rax\nshl    $0x2,%rax\nlea    -0x4(%rax),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%edx\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,4),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%eax\ncmp    %eax,%edx\njle    126a <is_sorted+0x4f>\nmov    $0x0,%eax\njmp    127e <is_sorted+0x63>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     1235 <is_sorted+0x1a>\nmov    $0x1,%eax\npop    %rbp\nret\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "is_sorted_string_array", "content": "/* Utility function to check if an array of strings is sorted lexicographically. */\nint is_sorted_string_array(const char *arr[], size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        if (libmin_strcmp(arr[i - 1], arr[i]) > 0)\n            return 0;\n    }\n    return 1;\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O0.pseudo", "function_name": "is_sorted_string_array", "address": "0x132e", "label": "is_sorted_string_array", "content": "int __cdecl is_sorted_string_array(const char **arr, size_t n)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 1LL; i < n; ++i )\n  {\n    if ( libmin_strcmp(arr[i - 1], arr[i]) > 0 )\n      return 0;\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int is_sorted_string_array(const char **arr, unsigned int n) {\n  unsigned int i;\n  for (i = 1LL; i < n; ++i) {\n    if (libmin_strcmp(arr[i - 1], arr[i]) > 0) return 0;\n  }\n  return 1;\n}", "binary": "qsort-test/qsort-test.host.O0", "assembly": "<is_sorted_string_array>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x1,-0x8(%rbp)\njmp    1393 <is_sorted_string_array+0x65>\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nshl    $0x3,%rax\nlea    -0x8(%rax),%rcx\nmov    -0x18(%rbp),%rax\nadd    %rcx,%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4292 <libmin_strcmp>\ntest   %eax,%eax\njle    138e <is_sorted_string_array+0x60>\nmov    $0x0,%eax\njmp    13a2 <is_sorted_string_array+0x74>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     134c <is_sorted_string_array+0x1e>\nmov    $0x1,%eax\nleave\nret\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "main", "content": "int main(void) {\n    /* ---------------------------\n     * Test 1: Random integer array (40 elements).\n     * These values are mostly unique with only few duplicates.\n     * ---------------------------\n     */\n    int test1[40] = {\n         5,  3, 12,  8,  1, 19,  7,  4,  0,  6,\n        10, 15,  2, 22, 11, 17, 13, 20,  9, 14,\n        16, 21, 23, 18, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39\n    };\n    size_t n1 = sizeof(test1) / sizeof(test1[0]);\n    libmin_qsort(test1, n1, sizeof(int), int_compare);\n    libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n    print_array(test1, n1);\n    if (is_sorted(test1, n1))\n        libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 2: Integer array with few duplicates (40 elements).\n     * Only one duplicate (the value '5' appears twice).\n     * ---------------------------\n     */\n    int test2[40] = {\n         2,  1,  3,  0,  4,  5,  5,  7,  8,  9,\n        10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39\n    };\n    size_t n2 = sizeof(test2) / sizeof(test2[0]);\n    libmin_qsort(test2, n2, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n    print_array(test2, n2);\n    if (is_sorted(test2, n2))\n        libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 3: Already sorted integer array (40 elements).\n     * Generate 40 ascending integers (0, 1, 2, ... 39).\n     * ---------------------------\n     */\n    int test3[40];\n    for (int i = 0; i < 40; i++) {\n        test3[i] = i;\n    }\n    libmin_qsort(test3, 40, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n    print_array(test3, 40);\n    if (is_sorted(test3, 40))\n        libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n    else\n        libmin_printf(\"Test 3 failed: already sorted array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 4: Reverse sorted integer array (40 elements).\n     * Generate 40 descending integers (39, 38, ... 0).\n     * ---------------------------\n     */\n    int test4[40];\n    for (int i = 0; i < 40; i++) {\n        test4[i] = 39 - i;\n    }\n    libmin_qsort(test4, 40, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n    print_array(test4, 40);\n    if (is_sorted(test4, 40))\n        libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 5: String array (32 elements).\n     * These 32 strings are mostly distinct with one duplicate (\"apple\").\n     * ---------------------------\n     */\n    const char *test_strings[32] = {\n        \"banana\", \"apple\", \"orange\", \"kiwi\", \"grape\", \"mango\", \"strawberry\", \"pear\",\n        \"pineapple\", \"watermelon\", \"blueberry\", \"raspberry\", \"blackberry\", \"cherry\", \"peach\", \"apricot\",\n        \"plum\", \"nectarine\", \"cantaloupe\", \"honeydew\", \"papaya\", \"passionfruit\", \"guava\", \"lychee\",\n        \"pomegranate\", \"grapefruit\", \"lemon\", \"lime\", \"tangerine\", \"cranberry\", \"fig\", \"apple\"  // \"apple\" appears twice\n    };\n    size_t n_str = sizeof(test_strings) / sizeof(test_strings[0]);\n    libmin_qsort(test_strings, n_str, sizeof(char *), string_compare);\n    libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n    print_string_array(test_strings, n_str);\n    if (is_sorted_string_array(test_strings, n_str))\n        libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O0.pseudo", "function_name": "main", "address": "0x1415", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+0h] [rbp-3B0h]\n  int i_0; // [rsp+4h] [rbp-3ACh]\n  int test1[40]; // [rsp+20h] [rbp-390h] BYREF\n  int test2[40]; // [rsp+C0h] [rbp-2F0h] BYREF\n  int test3[40]; // [rsp+160h] [rbp-250h] BYREF\n  int test4[40]; // [rsp+200h] [rbp-1B0h] BYREF\n  const char *test_strings[32]; // [rsp+2A0h] [rbp-110h] BYREF\n  unsigned __int64 v10; // [rsp+3A8h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  test1[0] = 5;\n  test1[1] = 3;\n  test1[2] = 12;\n  test1[3] = 8;\n  test1[4] = 1;\n  test1[5] = 19;\n  test1[6] = 7;\n  test1[7] = 4;\n  test1[8] = 0;\n  test1[9] = 6;\n  test1[10] = 10;\n  test1[11] = 15;\n  test1[12] = 2;\n  test1[13] = 22;\n  test1[14] = 11;\n  test1[15] = 17;\n  test1[16] = 13;\n  test1[17] = 20;\n  test1[18] = 9;\n  test1[19] = 14;\n  test1[20] = 16;\n  test1[21] = 21;\n  test1[22] = 23;\n  test1[23] = 18;\n  test1[24] = 24;\n  test1[25] = 25;\n  test1[26] = 26;\n  test1[27] = 27;\n  test1[28] = 28;\n  test1[29] = 29;\n  test1[30] = 30;\n  test1[31] = 31;\n  test1[32] = 32;\n  test1[33] = 33;\n  test1[34] = 34;\n  test1[35] = 35;\n  test1[36] = 36;\n  test1[37] = 37;\n  test1[38] = 38;\n  test1[39] = 39;\n  libmin_qsort(test1, 0x28uLL, 4uLL, (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(test1, 0x28uLL);\n  if ( is_sorted(test1, 0x28uLL) )\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  test2[0] = 2;\n  test2[1] = 1;\n  test2[2] = 3;\n  test2[3] = 0;\n  test2[4] = 4;\n  test2[5] = 5;\n  test2[6] = 5;\n  test2[7] = 7;\n  test2[8] = 8;\n  test2[9] = 9;\n  test2[10] = 10;\n  test2[11] = 11;\n  test2[12] = 12;\n  test2[13] = 13;\n  test2[14] = 14;\n  test2[15] = 15;\n  test2[16] = 16;\n  test2[17] = 17;\n  test2[18] = 18;\n  test2[19] = 19;\n  test2[20] = 20;\n  test2[21] = 21;\n  test2[22] = 22;\n  test2[23] = 23;\n  test2[24] = 24;\n  test2[25] = 25;\n  test2[26] = 26;\n  test2[27] = 27;\n  test2[28] = 28;\n  test2[29] = 29;\n  test2[30] = 30;\n  test2[31] = 31;\n  test2[32] = 32;\n  test2[33] = 33;\n  test2[34] = 34;\n  test2[35] = 35;\n  test2[36] = 36;\n  test2[37] = 37;\n  test2[38] = 38;\n  test2[39] = 39;\n  libmin_qsort(test2, 0x28uLL, 4uLL, (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(test2, 0x28uLL);\n  if ( is_sorted(test2, 0x28uLL) )\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  for ( i = 0; i <= 39; ++i )\n    test3[i] = i;\n  libmin_qsort(test3, 0x28uLL, 4uLL, (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(test3, 0x28uLL);\n  if ( is_sorted(test3, 0x28uLL) )\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  else\n    libmin_printf(\"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  for ( i_0 = 0; i_0 <= 39; ++i_0 )\n    test4[i_0] = 39 - i_0;\n  libmin_qsort(test4, 0x28uLL, 4uLL, (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(test4, 0x28uLL);\n  if ( is_sorted(test4, 0x28uLL) )\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  test_strings[0] = \"banana\";\n  test_strings[1] = \"apple\";\n  test_strings[2] = \"orange\";\n  test_strings[3] = \"kiwi\";\n  test_strings[4] = \"grape\";\n  test_strings[5] = \"mango\";\n  test_strings[6] = \"strawberry\";\n  test_strings[7] = \"pear\";\n  test_strings[8] = \"pineapple\";\n  test_strings[9] = \"watermelon\";\n  test_strings[10] = \"blueberry\";\n  test_strings[11] = \"raspberry\";\n  test_strings[12] = \"blackberry\";\n  test_strings[13] = \"cherry\";\n  test_strings[14] = \"peach\";\n  test_strings[15] = \"apricot\";\n  test_strings[16] = \"plum\";\n  test_strings[17] = \"nectarine\";\n  test_strings[18] = \"cantaloupe\";\n  test_strings[19] = \"honeydew\";\n  test_strings[20] = \"papaya\";\n  test_strings[21] = \"passionfruit\";\n  test_strings[22] = \"guava\";\n  test_strings[23] = \"lychee\";\n  test_strings[24] = \"pomegranate\";\n  test_strings[25] = \"grapefruit\";\n  test_strings[26] = \"lemon\";\n  test_strings[27] = \"lime\";\n  test_strings[28] = \"tangerine\";\n  test_strings[29] = \"cranberry\";\n  test_strings[30] = \"fig\";\n  test_strings[31] = \"apple\";\n  libmin_qsort(test_strings, 0x20uLL, 8uLL, (int (*)(const void *, const void *))string_compare);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(test_strings, 0x20uLL);\n  if ( is_sorted_string_array(test_strings, 0x20uLL) )\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  int i_0;\n  int test1[40];\n  int test2[40];\n  int test3[40];\n  int test4[40];\n  const char *test_strings[32];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  test1[0] = 5;\n  test1[1] = 3;\n  test1[2] = 12;\n  test1[3] = 8;\n  test1[4] = 1;\n  test1[5] = 19;\n  test1[6] = 7;\n  test1[7] = 4;\n  test1[8] = 0;\n  test1[9] = 6;\n  test1[10] = 10;\n  test1[11] = 15;\n  test1[12] = 2;\n  test1[13] = 22;\n  test1[14] = 11;\n  test1[15] = 17;\n  test1[16] = 13;\n  test1[17] = 20;\n  test1[18] = 9;\n  test1[19] = 14;\n  test1[20] = 16;\n  test1[21] = 21;\n  test1[22] = 23;\n  test1[23] = 18;\n  test1[24] = 24;\n  test1[25] = 25;\n  test1[26] = 26;\n  test1[27] = 27;\n  test1[28] = 28;\n  test1[29] = 29;\n  test1[30] = 30;\n  test1[31] = 31;\n  test1[32] = 32;\n  test1[33] = 33;\n  test1[34] = 34;\n  test1[35] = 35;\n  test1[36] = 36;\n  test1[37] = 37;\n  test1[38] = 38;\n  test1[39] = 39;\n  libmin_qsort(test1, 40uLL, 4uLL,\n               (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(test1, 40uLL);\n  if (is_sorted(test1, 40uLL))\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  test2[0] = 2;\n  test2[1] = 1;\n  test2[2] = 3;\n  test2[3] = 0;\n  test2[4] = 4;\n  test2[5] = 5;\n  test2[6] = 5;\n  test2[7] = 7;\n  test2[8] = 8;\n  test2[9] = 9;\n  test2[10] = 10;\n  test2[11] = 11;\n  test2[12] = 12;\n  test2[13] = 13;\n  test2[14] = 14;\n  test2[15] = 15;\n  test2[16] = 16;\n  test2[17] = 17;\n  test2[18] = 18;\n  test2[19] = 19;\n  test2[20] = 20;\n  test2[21] = 21;\n  test2[22] = 22;\n  test2[23] = 23;\n  test2[24] = 24;\n  test2[25] = 25;\n  test2[26] = 26;\n  test2[27] = 27;\n  test2[28] = 28;\n  test2[29] = 29;\n  test2[30] = 30;\n  test2[31] = 31;\n  test2[32] = 32;\n  test2[33] = 33;\n  test2[34] = 34;\n  test2[35] = 35;\n  test2[36] = 36;\n  test2[37] = 37;\n  test2[38] = 38;\n  test2[39] = 39;\n  libmin_qsort(test2, 40uLL, 4uLL,\n               (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\n      \"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(test2, 40uLL);\n  if (is_sorted(test2, 40uLL))\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  for (i = 0; i <= 39; ++i) test3[i] = i;\n  libmin_qsort(test3, 40uLL, 4uLL,\n               (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(test3, 40uLL);\n  if (is_sorted(test3, 40uLL))\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  else\n    libmin_printf(\n        \"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  for (i_0 = 0; i_0 <= 39; ++i_0) test4[i_0] = 39 - i_0;\n  libmin_qsort(test4, 40uLL, 4uLL,\n               (int (*)(const void *, const void *))int_compare);\n  libmin_printf(\n      \"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(test4, 40uLL);\n  if (is_sorted(test4, 40uLL))\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  else\n    libmin_printf(\n        \"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  test_strings[0] = \"banana\";\n  test_strings[1] = \"apple\";\n  test_strings[2] = \"orange\";\n  test_strings[3] = \"kiwi\";\n  test_strings[4] = \"grape\";\n  test_strings[5] = \"mango\";\n  test_strings[6] = \"strawberry\";\n  test_strings[7] = \"pear\";\n  test_strings[8] = \"pineapple\";\n  test_strings[9] = \"watermelon\";\n  test_strings[10] = \"blueberry\";\n  test_strings[11] = \"raspberry\";\n  test_strings[12] = \"blackberry\";\n  test_strings[13] = \"cherry\";\n  test_strings[14] = \"peach\";\n  test_strings[15] = \"apricot\";\n  test_strings[16] = \"plum\";\n  test_strings[17] = \"nectarine\";\n  test_strings[18] = \"cantaloupe\";\n  test_strings[19] = \"honeydew\";\n  test_strings[20] = \"papaya\";\n  test_strings[21] = \"passionfruit\";\n  test_strings[22] = \"guava\";\n  test_strings[23] = \"lychee\";\n  test_strings[24] = \"pomegranate\";\n  test_strings[25] = \"grapefruit\";\n  test_strings[26] = \"lemon\";\n  test_strings[27] = \"lime\";\n  test_strings[28] = \"tangerine\";\n  test_strings[29] = \"cranberry\";\n  test_strings[30] = \"fig\";\n  test_strings[31] = \"apple\";\n  libmin_qsort(test_strings, 32uLL, 8uLL,\n               (int (*)(const void *, const void *))string_compare);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array(test_strings, 32uLL);\n  if (is_sorted_string_array(test_strings, 32uLL))\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  libmin_success();\n}", "binary": "qsort-test/qsort-test.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x3b0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x5,-0x390(%rbp)\nmovl   $0x3,-0x38c(%rbp)\nmovl   $0xc,-0x388(%rbp)\nmovl   $0x8,-0x384(%rbp)\nmovl   $0x1,-0x380(%rbp)\nmovl   $0x13,-0x37c(%rbp)\nmovl   $0x7,-0x378(%rbp)\nmovl   $0x4,-0x374(%rbp)\nmovl   $0x0,-0x370(%rbp)\nmovl   $0x6,-0x36c(%rbp)\nmovl   $0xa,-0x368(%rbp)\nmovl   $0xf,-0x364(%rbp)\nmovl   $0x2,-0x360(%rbp)\nmovl   $0x16,-0x35c(%rbp)\nmovl   $0xb,-0x358(%rbp)\nmovl   $0x11,-0x354(%rbp)\nmovl   $0xd,-0x350(%rbp)\nmovl   $0x14,-0x34c(%rbp)\nmovl   $0x9,-0x348(%rbp)\nmovl   $0xe,-0x344(%rbp)\nmovl   $0x10,-0x340(%rbp)\nmovl   $0x15,-0x33c(%rbp)\nmovl   $0x17,-0x338(%rbp)\nmovl   $0x12,-0x334(%rbp)\nmovl   $0x18,-0x330(%rbp)\nmovl   $0x19,-0x32c(%rbp)\nmovl   $0x1a,-0x328(%rbp)\nmovl   $0x1b,-0x324(%rbp)\nmovl   $0x1c,-0x320(%rbp)\nmovl   $0x1d,-0x31c(%rbp)\nmovl   $0x1e,-0x318(%rbp)\nmovl   $0x1f,-0x314(%rbp)\nmovl   $0x20,-0x310(%rbp)\nmovl   $0x21,-0x30c(%rbp)\nmovl   $0x22,-0x308(%rbp)\nmovl   $0x23,-0x304(%rbp)\nmovl   $0x24,-0x300(%rbp)\nmovl   $0x25,-0x2fc(%rbp)\nmovl   $0x26,-0x2f8(%rbp)\nmovl   $0x27,-0x2f4(%rbp)\nmovq   $0x28,-0x3a8(%rbp)\nmov    -0x3a8(%rbp),%rsi\nlea    -0x390(%rbp),%rax\nlea    -0x3fa(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x4,%edx\nmov    %rax,%rdi\ncall   4240 <libmin_qsort>\nlea    0x3a1e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nmov    -0x3a8(%rbp),%rdx\nlea    -0x390(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1280 <print_array>\nmov    -0x3a8(%rbp),%rdx\nlea    -0x390(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   121b <is_sorted>\ntest   %eax,%eax\nje     1653 <main+0x23e>\nlea    0x3a0c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\njmp    1667 <main+0x252>\nlea    0x3a1e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nmovl   $0x2,-0x2f0(%rbp)\nmovl   $0x1,-0x2ec(%rbp)\nmovl   $0x3,-0x2e8(%rbp)\nmovl   $0x0,-0x2e4(%rbp)\nmovl   $0x4,-0x2e0(%rbp)\nmovl   $0x5,-0x2dc(%rbp)\nmovl   $0x5,-0x2d8(%rbp)\nmovl   $0x7,-0x2d4(%rbp)\nmovl   $0x8,-0x2d0(%rbp)\nmovl   $0x9,-0x2cc(%rbp)\nmovl   $0xa,-0x2c8(%rbp)\nmovl   $0xb,-0x2c4(%rbp)\nmovl   $0xc,-0x2c0(%rbp)\nmovl   $0xd,-0x2bc(%rbp)\nmovl   $0xe,-0x2b8(%rbp)\nmovl   $0xf,-0x2b4(%rbp)\nmovl   $0x10,-0x2b0(%rbp)\nmovl   $0x11,-0x2ac(%rbp)\nmovl   $0x12,-0x2a8(%rbp)\nmovl   $0x13,-0x2a4(%rbp)\nmovl   $0x14,-0x2a0(%rbp)\nmovl   $0x15,-0x29c(%rbp)\nmovl   $0x16,-0x298(%rbp)\nmovl   $0x17,-0x294(%rbp)\nmovl   $0x18,-0x290(%rbp)\nmovl   $0x19,-0x28c(%rbp)\nmovl   $0x1a,-0x288(%rbp)\nmovl   $0x1b,-0x284(%rbp)\nmovl   $0x1c,-0x280(%rbp)\nmovl   $0x1d,-0x27c(%rbp)\nmovl   $0x1e,-0x278(%rbp)\nmovl   $0x1f,-0x274(%rbp)\nmovl   $0x20,-0x270(%rbp)\nmovl   $0x21,-0x26c(%rbp)\nmovl   $0x22,-0x268(%rbp)\nmovl   $0x23,-0x264(%rbp)\nmovl   $0x24,-0x260(%rbp)\nmovl   $0x25,-0x25c(%rbp)\nmovl   $0x26,-0x258(%rbp)\nmovl   $0x27,-0x254(%rbp)\nmovq   $0x28,-0x3a0(%rbp)\nmov    -0x3a0(%rbp),%rsi\nlea    -0x2f0(%rbp),%rax\nlea    -0x62e(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x4,%edx\nmov    %rax,%rdi\ncall   4240 <libmin_qsort>\nlea    0x387a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nmov    -0x3a0(%rbp),%rdx\nlea    -0x2f0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1280 <print_array>\nmov    -0x3a0(%rbp),%rdx\nlea    -0x2f0(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   121b <is_sorted>\ntest   %eax,%eax\nje     1887 <main+0x472>\nlea    0x3878(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\njmp    189b <main+0x486>\nlea    0x389a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nmovl   $0x0,-0x3b0(%rbp)\njmp    18c3 <main+0x4ae>\nmov    -0x3b0(%rbp),%eax\ncltq\nmov    -0x3b0(%rbp),%edx\nmov    %edx,-0x250(%rbp,%rax,4)\naddl   $0x1,-0x3b0(%rbp)\ncmpl   $0x27,-0x3b0(%rbp)\njle    18a7 <main+0x492>\nlea    -0x250(%rbp),%rax\nlea    -0x6f1(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x4,%edx\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   4240 <libmin_qsort>\nlea    0x3872(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nlea    -0x250(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   1280 <print_array>\nlea    -0x250(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   121b <is_sorted>\ntest   %eax,%eax\nje     1945 <main+0x530>\nlea    0x386a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\njmp    1959 <main+0x544>\nlea    0x387c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nmovl   $0x0,-0x3ac(%rbp)\njmp    1988 <main+0x573>\nmov    $0x27,%eax\nsub    -0x3ac(%rbp),%eax\nmov    %eax,%edx\nmov    -0x3ac(%rbp),%eax\ncltq\nmov    %edx,-0x1b0(%rbp,%rax,4)\naddl   $0x1,-0x3ac(%rbp)\ncmpl   $0x27,-0x3ac(%rbp)\njle    1965 <main+0x550>\nlea    -0x1b0(%rbp),%rax\nlea    -0x7b6(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x4,%edx\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   4240 <libmin_qsort>\nlea    0x384d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nlea    -0x1b0(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   1280 <print_array>\nlea    -0x1b0(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   121b <is_sorted>\ntest   %eax,%eax\nje     1a0a <main+0x5f5>\nlea    0x384d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\njmp    1a1e <main+0x609>\nlea    0x386f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nlea    0x3896(%rip),%rax\nmov    %rax,-0x110(%rbp)\nlea    0x388f(%rip),%rax\nmov    %rax,-0x108(%rbp)\nlea    0x3887(%rip),%rax\nmov    %rax,-0x100(%rbp)\nlea    0x3880(%rip),%rax\nmov    %rax,-0xf8(%rbp)\nlea    0x3877(%rip),%rax\nmov    %rax,-0xf0(%rbp)\nlea    0x386f(%rip),%rax\nmov    %rax,-0xe8(%rbp)\nlea    0x3867(%rip),%rax\nmov    %rax,-0xe0(%rbp)\nlea    0x3864(%rip),%rax\nmov    %rax,-0xd8(%rbp)\nlea    0x385b(%rip),%rax\nmov    %rax,-0xd0(%rbp)\nlea    0x3857(%rip),%rax\nmov    %rax,-0xc8(%rbp)\nlea    0x3854(%rip),%rax\nmov    %rax,-0xc0(%rbp)\nlea    0x3850(%rip),%rax\nmov    %rax,-0xb8(%rbp)\nlea    0x384c(%rip),%rax\nmov    %rax,-0xb0(%rbp)\nlea    0x3849(%rip),%rax\nmov    %rax,-0xa8(%rbp)\nlea    0x3842(%rip),%rax\nmov    %rax,-0xa0(%rbp)\nlea    0x383a(%rip),%rax\nmov    %rax,-0x98(%rbp)\nlea    0x3834(%rip),%rax\nmov    %rax,-0x90(%rbp)\nlea    0x382b(%rip),%rax\nmov    %rax,-0x88(%rbp)\nlea    0x3827(%rip),%rax\nmov    %rax,-0x80(%rbp)\nlea    0x3827(%rip),%rax\nmov    %rax,-0x78(%rbp)\nlea    0x3825(%rip),%rax\nmov    %rax,-0x70(%rbp)\nlea    0x3821(%rip),%rax\nmov    %rax,-0x68(%rbp)\nlea    0x3823(%rip),%rax\nmov    %rax,-0x60(%rbp)\nlea    0x381e(%rip),%rax\nmov    %rax,-0x58(%rbp)\nlea    0x381a(%rip),%rax\nmov    %rax,-0x50(%rbp)\nlea    0x381b(%rip),%rax\nmov    %rax,-0x48(%rbp)\nlea    0x381b(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0x3816(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0x3810(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0x380f(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0x380e(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x3712(%rip),%rax\nmov    %rax,-0x18(%rbp)\nmovq   $0x20,-0x398(%rbp)\nmov    -0x398(%rbp),%rsi\nlea    -0x110(%rbp),%rax\nlea    -0x8e5(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x8,%edx\nmov    %rax,%rdi\ncall   4240 <libmin_qsort>\nlea    0x37cd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nmov    -0x398(%rbp),%rdx\nlea    -0x110(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   13a4 <print_string_array>\nmov    -0x398(%rbp),%rdx\nlea    -0x110(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   132e <is_sorted_string_array>\ntest   %eax,%eax\nje     1c44 <main+0x82f>\nlea    0x37b3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\njmp    1c58 <main+0x843>\nlea    0x37cd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\ncall   432e <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1c76 <main+0x861>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "print_array", "content": "/* Function to print an array of integers. */\nvoid print_array(const int arr[], size_t n) {\n    for (size_t i = 0; i < n; i++)\n        libmin_printf(\"%d \", arr[i]);\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O0.pseudo", "function_name": "print_array", "address": "0x1280", "label": "print_array", "content": "void __cdecl print_array(const int *arr, size_t n)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0LL; i < n; ++i )\n    libmin_printf(\"%d \", arr[i]);\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "", "binary": "qsort-test/qsort-test.host.O0", "assembly": "<print_array>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x0,-0x8(%rbp)\njmp    12ce <print_array+0x4e>\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x3d4c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     129e <print_array+0x1e>\nlea    0x3d2d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "print_string_array", "content": "/* Function to print an array of strings. */\nvoid print_string_array(const char *arr[], size_t n) {\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s \", arr[i]);\n    }\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O0.pseudo", "function_name": "print_string_array", "address": "0x13a4", "label": "print_string_array", "content": "void __cdecl print_string_array(const char **arr, size_t n)\n{\n  size_t i; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0LL; i < n; ++i )\n    libmin_printf(\"%s \", arr[i]);\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "", "binary": "qsort-test/qsort-test.host.O0", "assembly": "<print_string_array>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovq   $0x0,-0x8(%rbp)\njmp    13f4 <print_string_array+0x50>\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x3c2c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\naddq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     13c2 <print_string_array+0x1e>\nlea    0x3c07(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3db4 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "string_compare", "content": "/* Comparison function for strings using strcmp.\n * Note: Each element is a pointer to char.\n */\nint string_compare(const void *a, const void *b) {\n    const char * const *str1 = (const char * const *) a;\n    const char * const *str2 = (const char * const *) b;\n    return libmin_strcmp(*str1, *str2);\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O0.pseudo", "function_name": "string_compare", "address": "0x12ef", "label": "string_compare", "content": "int __cdecl string_compare(const void *a, const void *b)\n{\n  return libmin_strcmp(*(const char **)a, *(const char **)b);\n}\n"}, "pseudo_normalize": "", "binary": "qsort-test/qsort-test.host.O0", "assembly": "<string_compare>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   4292 <libmin_strcmp>\nleave\nret\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "euler_from_quat", "content": "/**\n * Function to convert given quaternion to Euler angles.\n * \\f{eqnarray*}{\n * \\phi & = &\n * \\tan^{-1}\\left[\\frac{2\\left(q_0q_1+q_2q_3\\right)}{1-2\\left(q_1^2+q_2^2\\right)}\\right]\\\\\n * \\theta & =\n * &-\\sin^{-1}\\left[2\\left(q_0q_2-q_3q_1\\right)\\right]\\\\\n * \\psi & = &\n * \\tan^{-1}\\left[\\frac{2\\left(q_0q_3+q_1q_2\\right)}{1-2\\left(q_2^2+q_3^2\\right)}\\right]\\\\\n * \\f}\n *\n * @param [in] in_quat input quaternion instance\n * @returns converted euler angles\n */\neuler euler_from_quat(const quaternion *in_quat)\n{\n    euler out_euler = {{0.0}, {0.0}, {0.0}};\n    if (!in_quat)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_euler;\n    }\n\n    out_euler.roll = libmin_atan2(\n        2.0 * (in_quat->w * in_quat->q1 + in_quat->q2 * in_quat->q3),\n        1.0 - 2.0 * (in_quat->q1 * in_quat->q1 + in_quat->q2 * in_quat->q2));\n    out_euler.pitch =\n        libmin_asin(2.0 * (in_quat->w * in_quat->q2 + in_quat->q1 * in_quat->q3));\n    out_euler.yaw = libmin_atan2(\n        2.0 * (in_quat->w * in_quat->q3 + in_quat->q1 * in_quat->q2),\n        1.0 - 2.0 * (in_quat->q2 * in_quat->q2 + in_quat->q3 * in_quat->q3));\n\n    return out_euler;\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O0.pseudo", "function_name": "euler_from_quat", "address": "0x1447", "label": "euler_from_quat", "content": "euler *__cdecl euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat)\n{\n  double v2; // xmm1_8\n  double v3; // xmm0_8\n  double v4; // xmm1_8\n  double v5; // xmm0_8\n  double v6; // xmm0_8\n  double out_euler; // [rsp+10h] [rbp-20h]\n  double out_euler_8; // [rsp+18h] [rbp-18h]\n\n  if ( in_quat )\n  {\n    v2 = in_quat->dual.y * in_quat->dual.y + in_quat->dual.x * in_quat->dual.x;\n    v3 = in_quat->dual.z * in_quat->dual.y + in_quat->w * in_quat->dual.x;\n    out_euler = libmin_atan2(v3 + v3, 1.0 - (v2 + v2));\n    out_euler_8 = libmin_asin(\n                    in_quat->dual.z * in_quat->dual.x\n                  + in_quat->w * in_quat->dual.y\n                  + in_quat->dual.z * in_quat->dual.x\n                  + in_quat->w * in_quat->dual.y);\n    v4 = in_quat->dual.z * in_quat->dual.z + in_quat->dual.y * in_quat->dual.y;\n    v5 = in_quat->dual.y * in_quat->dual.x + in_quat->w * in_quat->dual.z;\n    v6 = libmin_atan2(v5 + v5, 1.0 - (v4 + v4));\n    retstr->roll = out_euler;\n    retstr->pitch = out_euler_8;\n    retstr->yaw = v6;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    retstr->roll = 0.0;\n    retstr->pitch = 0.0;\n    retstr->yaw = 0.0;\n  }\n  return retstr;\n}\n"}, "pseudo_normalize": "euler *euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat) {\n  double v2;\n  double v3;\n  double v4;\n  double v5;\n  double v6;\n  double out_euler;\n  double out_euler_8;\n  if (in_quat) {\n    v2 = in_quat->dual.y * in_quat->dual.y + in_quat->dual.x * in_quat->dual.x;\n    v3 = in_quat->dual.z * in_quat->dual.y + in_quat->w * in_quat->dual.x;\n    out_euler = libmin_atan2(v3 + v3, 1.0 - (v2 + v2));\n    out_euler_8 = libmin_asin(\n        in_quat->dual.z * in_quat->dual.x + in_quat->w * in_quat->dual.y +\n        in_quat->dual.z * in_quat->dual.x + in_quat->w * in_quat->dual.y);\n    v4 = in_quat->dual.z * in_quat->dual.z + in_quat->dual.y * in_quat->dual.y;\n    v5 = in_quat->dual.y * in_quat->dual.x + in_quat->w * in_quat->dual.z;\n    v6 = libmin_atan2(v5 + v5, 1.0 - (v4 + v4));\n    retstr->roll = out_euler;\n    retstr->pitch = out_euler_8;\n    retstr->yaw = v6;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    retstr->roll = 0.0;\n    retstr->pitch = 0.0;\n    retstr->yaw = 0.0;\n  }\n  return retstr;\n}", "binary": "quaternions/quaternions.host.O0", "assembly": "<euler_from_quat>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\ncmpq   $0x0,-0x30(%rbp)\njne    14bb <euler_from_quat+0x74>\nlea    0x5c0c(%rip),%rax\nmov    %rax,%rsi\nlea    0x5b82(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   492b <libmin_printf>\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\njmp    164f <euler_from_quat+0x208>\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x5bc5(%rip),%xmm0\nmovapd %xmm0,%xmm3\nsubsd  %xmm1,%xmm3\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\nmovq   %xmm0,%rax\nmovapd %xmm3,%xmm1\nmovq   %rax,%xmm0\ncall   207f <libmin_atan2>\nmovq   %xmm0,%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   1be5 <libmin_asin>\nmovq   %xmm0,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm2\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x5ae3(%rip),%xmm0\nmovapd %xmm0,%xmm3\nsubsd  %xmm1,%xmm3\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\nmovq   %xmm0,%rax\nmovapd %xmm3,%xmm1\nmovq   %rax,%xmm0\ncall   207f <libmin_atan2>\nmovq   %xmm0,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\nmov    -0x28(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "main", "content": "int main()\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O0.pseudo", "function_name": "main", "address": "0x1a85", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  test();\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "quaternions/quaternions.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x0,%eax\ncall   18b2 <test>\ncall   54bd <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "quat_from_euler", "content": "/**\n * @addtogroup quats 3D Quaternion operations\n * @{\n */\n\n/**\n * Function to convert given Euler angles to a quaternion.\n * \\f{eqnarray*}{\n * q_{0} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * +\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{1} & =\n * &\\sin\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * -\n * \\cos\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{2} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * +\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{3} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\n * -\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\\\\\n * \\f}\n *\n * @param [in] in_euler input Euler angles instance\n * @returns converted quaternion\n */\nquaternion quat_from_euler(const euler *in_euler)\n{\n    quaternion out_quat = {{0.0}, {{0.0, 0.0, 0.0}}}; \n\n    if (!in_euler)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_quat;\n    }\n\n    quaternion temp;\n\n    double cy = libmin_cos(in_euler->yaw * 0.5);\n    double sy = libmin_sin(in_euler->yaw * 0.5);\n    double cp = libmin_cos(in_euler->pitch * 0.5);\n    double sp = libmin_sin(in_euler->pitch * 0.5);\n    double cr = libmin_cos(in_euler->roll * 0.5);\n    double sr = libmin_sin(in_euler->roll * 0.5);\n\n    temp.w = cr * cp * cy + sr * sp * sy;\n    temp.q1 = sr * cp * cy - cr * sp * sy;\n    temp.q2 = cr * sp * cy + sr * cp * sy;\n    temp.q3 = cr * cp * sy - sr * sp * cy;\n\n    return temp;\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O0.pseudo", "function_name": "quat_from_euler", "address": "0x11e9", "label": "quat_from_euler", "content": "quaternion *__cdecl quat_from_euler(quaternion *__return_ptr retstr, const euler *in_euler)\n{\n  double v2; // xmm0_8\n  double cy; // [rsp+10h] [rbp-70h]\n  double sy; // [rsp+18h] [rbp-68h]\n  double cp; // [rsp+20h] [rbp-60h]\n  double sp_0; // [rsp+28h] [rbp-58h]\n  double cr; // [rsp+30h] [rbp-50h]\n  quaternion out_quat; // [rsp+40h] [rbp-40h] BYREF\n  quaternion temp; // [rsp+60h] [rbp-20h]\n\n  memset(&out_quat.dual, 0, sizeof(out_quat.dual));\n  if ( in_euler )\n  {\n    cy = libmin_cos(in_euler->yaw * 0.5);\n    sy = libmin_sin(in_euler->yaw * 0.5);\n    cp = libmin_cos(in_euler->pitch * 0.5);\n    sp_0 = libmin_sin(in_euler->pitch * 0.5);\n    cr = libmin_cos(in_euler->roll * 0.5);\n    v2 = libmin_sin(in_euler->roll * 0.5);\n    temp.dual.y = v2 * cp * sy + cr * sp_0 * cy;\n    temp.dual.z = cr * cp * sy - v2 * sp_0 * cy;\n    retstr->w = v2 * sp_0 * sy + cr * cp * cy;\n    retstr->dual.x = v2 * cp * cy - cr * sp_0 * sy;\n    *(_OWORD *)&retstr->q2 = *(_OWORD *)&temp.q2;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    retstr->w = 0.0;\n    retstr->8 = out_quat.8;\n  }\n  return retstr;\n}\n"}, "pseudo_normalize": "quaternion *quat_from_euler(quaternion *__return_ptr retstr,\n                            const euler *in_euler) {\n  double v2;\n  double cy;\n  double sy;\n  double cp;\n  double sp_0;\n  double cr;\n  quaternion out_quat;\n  quaternion temp;\n  memset(&out_quat.dual, 0, sizeof(out_quat.dual));\n  if (in_euler) {\n    cy = libmin_cos(in_euler->yaw * 0.5);\n    sy = libmin_sin(in_euler->yaw * 0.5);\n    cp = libmin_cos(in_euler->pitch * 0.5);\n    sp_0 = libmin_sin(in_euler->pitch * 0.5);\n    cr = libmin_cos(in_euler->roll * 0.5);\n    v2 = libmin_sin(in_euler->roll * 0.5);\n    temp.dual.y = v2 * cp * sy + cr * sp_0 * cy;\n    temp.dual.z = cr * cp * sy - v2 * sp_0 * cy;\n    retstr->w = v2 * sp_0 * sy + cr * cp * cy;\n    retstr->dual.x = v2 * cp * cy - cr * sp_0 * sy;\n    *(long double *)&retstr->q2 = *(long double *)&temp.q2;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    retstr->w = 0.0;\n    retstr->8 = out_quat .8;\n  }\n  return retstr;\n}", "binary": "quaternions/quaternions.host.O0", "assembly": "<quat_from_euler>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x78(%rbp)\nmov    %rsi,-0x80(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\ncmpq   $0x0,-0x80(%rbp)\njne    126e <quat_from_euler+0x85>\nlea    0x5e51(%rip),%rax\nmov    %rax,%rsi\nlea    0x5dd7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   492b <libmin_printf>\nmov    -0x78(%rbp),%rcx\nmov    -0x40(%rbp),%rax\nmov    -0x38(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x30(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nmov    %rax,0x10(%rcx)\nmov    %rdx,0x18(%rcx)\njmp    1441 <quat_from_euler+0x258>\nmov    -0x80(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmovsd  0x5e39(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   4da7 <libmin_cos>\nmovq   %xmm0,%rax\nmov    %rax,-0x70(%rbp)\nmov    -0x80(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmovsd  0x5e0c(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   4f58 <libmin_sin>\nmovq   %xmm0,%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x80(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmovsd  0x5ddf(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   4da7 <libmin_cos>\nmovq   %xmm0,%rax\nmov    %rax,-0x60(%rbp)\nmov    -0x80(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmovsd  0x5db2(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   4f58 <libmin_sin>\nmovq   %xmm0,%rax\nmov    %rax,-0x58(%rbp)\nmov    -0x80(%rbp),%rax\nmovsd  (%rax),%xmm1\nmovsd  0x5d86(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   4da7 <libmin_cos>\nmovq   %xmm0,%rax\nmov    %rax,-0x50(%rbp)\nmov    -0x80(%rbp),%rax\nmovsd  (%rax),%xmm1\nmovsd  0x5d5a(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   4f58 <libmin_sin>\nmovq   %xmm0,%rax\nmov    %rax,-0x48(%rbp)\nmovsd  -0x50(%rbp),%xmm0\nmulsd  -0x60(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x70(%rbp),%xmm1\nmovsd  -0x48(%rbp),%xmm0\nmulsd  -0x58(%rbp),%xmm0\nmulsd  -0x68(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovsd  -0x48(%rbp),%xmm0\nmulsd  -0x60(%rbp),%xmm0\nmulsd  -0x70(%rbp),%xmm0\nmovsd  -0x50(%rbp),%xmm1\nmulsd  -0x58(%rbp),%xmm1\nmulsd  -0x68(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  -0x50(%rbp),%xmm0\nmulsd  -0x58(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x70(%rbp),%xmm1\nmovsd  -0x48(%rbp),%xmm0\nmulsd  -0x60(%rbp),%xmm0\nmulsd  -0x68(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  -0x50(%rbp),%xmm0\nmulsd  -0x60(%rbp),%xmm0\nmulsd  -0x68(%rbp),%xmm0\nmovsd  -0x48(%rbp),%xmm1\nmulsd  -0x58(%rbp),%xmm1\nmulsd  -0x70(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x78(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x10(%rcx)\nmov    %rdx,0x18(%rcx)\nmov    -0x78(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "quaternion_multiply", "content": "/**\n * Function to multiply two quaternions.\n * \\f{eqnarray*}{\n * \\mathbf{c} & = & \\mathbf{a}\\otimes\\mathbf{b}\\\\\n * & = & \\begin{bmatrix}a_{0} & a_{1} & a_{2} &\n *  a_{3}\\end{bmatrix}\\otimes\\begin{bmatrix}b_{0} & b_{1} & b_{2} &\n *  b_{3}\\end{bmatrix}\\\\\n * & = &\n * \\begin{bmatrix}\n *  a_{0}b_{0}-a_{1}b_{1}-a_{2}b_{2}-a_{3}b_{3}\\\\\n *  a_{0}b_{1}+a_{1}b_{0}+a_{2}b_{3}-a_{3}b_{2}\\\\\n *  a_{0}b_{2}-a_{1}b_{3}+a_{2}b_{0}+a_{3}b_{1}\\\\\n *  a_{0}b_{3}+a_{1}b_{2}-a_{2}b_{1}+a_{3}b_{0}\n * \\end{bmatrix}^{T}\n * \\f}\n *\n * @param [in] in_quat1 first input quaternion instance\n * @param [in] in_quat2 second input quaternion instance\n * @returns resultant quaternion\n */\nquaternion quaternion_multiply(const quaternion *in_quat1,\n                               const quaternion *in_quat2)\n{\n    quaternion out_quat = {{0.0}, {{0.0, 0.0, 0.0}}}; \n    if (!in_quat1 || !in_quat2)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_quat;\n    }\n\n    out_quat.w = in_quat1->w * in_quat2->w - in_quat1->q1 * in_quat2->q1 -\n                 in_quat1->q2 * in_quat2->q2 - in_quat1->q3 * in_quat2->q3;\n    out_quat.q1 = in_quat1->w * in_quat2->q1 + in_quat1->q1 * in_quat2->w +\n                  in_quat1->q2 * in_quat2->q3 - in_quat1->q3 * in_quat2->q2;\n    out_quat.q2 = in_quat1->w * in_quat2->q2 - in_quat1->q1 * in_quat2->q3 +\n                  in_quat1->q2 * in_quat2->w + in_quat1->q3 * in_quat2->q1;\n    out_quat.q3 = in_quat1->w * in_quat2->q3 + in_quat1->q1 * in_quat2->q2 -\n                  in_quat1->q2 * in_quat2->q1 + in_quat1->q3 * in_quat2->w;\n\n    return out_quat;\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O0.pseudo", "function_name": "quaternion_multiply", "address": "0x1655", "label": "quaternion_multiply", "content": "quaternion *__cdecl quaternion_multiply(\n        quaternion *__return_ptr retstr,\n        const quaternion *in_quat1,\n        const quaternion *in_quat2)\n{\n  double v3; // rdx\n  quaternion out_quat; // [rsp+20h] [rbp-20h] BYREF\n\n  memset(&out_quat.dual, 0, sizeof(out_quat.dual));\n  if ( in_quat1 && in_quat2 )\n  {\n    out_quat.dual.y = in_quat2->dual.x * in_quat1->dual.z\n                    + in_quat2->dual.y * in_quat1->w\n                    - in_quat1->dual.x * in_quat2->dual.z\n                    + in_quat2->w * in_quat1->dual.y;\n    out_quat.dual.z = in_quat2->w * in_quat1->dual.z\n                    + in_quat2->dual.y * in_quat1->dual.x\n                    + in_quat1->w * in_quat2->dual.z\n                    - in_quat1->dual.y * in_quat2->dual.x;\n    v3 = in_quat2->dual.z * in_quat1->dual.y\n       + in_quat1->w * in_quat2->dual.x\n       + in_quat2->w * in_quat1->dual.x\n       - in_quat2->dual.y * in_quat1->dual.z;\n    retstr->w = in_quat2->w * in_quat1->w\n              - in_quat2->dual.x * in_quat1->dual.x\n              - in_quat2->dual.y * in_quat1->dual.y\n              - in_quat2->dual.z * in_quat1->dual.z;\n    retstr->dual.x = v3;\n    *(_OWORD *)&retstr->q2 = *(_OWORD *)&out_quat.q2;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    retstr->w = 0.0;\n    retstr->8 = out_quat.8;\n  }\n  return retstr;\n}\n"}, "pseudo_normalize": "quaternion *quaternion_multiply(quaternion *__return_ptr retstr,\n                                const quaternion *in_quat1,\n                                const quaternion *in_quat2) {\n  double v3;\n  quaternion out_quat;\n  memset(&out_quat.dual, 0, sizeof(out_quat.dual));\n  if (in_quat1 && in_quat2) {\n    out_quat.dual.y =\n        in_quat2->dual.x * in_quat1->dual.z + in_quat2->dual.y * in_quat1->w -\n        in_quat1->dual.x * in_quat2->dual.z + in_quat2->w * in_quat1->dual.y;\n    out_quat.dual.z =\n        in_quat2->w * in_quat1->dual.z + in_quat2->dual.y * in_quat1->dual.x +\n        in_quat1->w * in_quat2->dual.z - in_quat1->dual.y * in_quat2->dual.x;\n    v3 = in_quat2->dual.z * in_quat1->dual.y + in_quat1->w * in_quat2->dual.x +\n         in_quat2->w * in_quat1->dual.x - in_quat2->dual.y * in_quat1->dual.z;\n    retstr->w = in_quat2->w * in_quat1->w -\n                in_quat2->dual.x * in_quat1->dual.x -\n                in_quat2->dual.y * in_quat1->dual.y -\n                in_quat2->dual.z * in_quat1->dual.z;\n    retstr->dual.x = v3;\n    *(long double *)&retstr->q2 = *(long double *)&out_quat.q2;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    retstr->w = 0.0;\n    retstr->8 = out_quat .8;\n  }\n  return retstr;\n}", "binary": "quaternions/quaternions.host.O0", "assembly": "<quaternion_multiply>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\ncmpq   $0x0,-0x30(%rbp)\nje     169f <quaternion_multiply+0x4a>\ncmpq   $0x0,-0x38(%rbp)\njne    16e5 <quaternion_multiply+0x90>\nlea    0x59fa(%rip),%rax\nmov    %rax,%rsi\nlea    0x5960(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   492b <libmin_printf>\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x10(%rcx)\nmov    %rdx,0x18(%rcx)\njmp    18ac <quaternion_multiply+0x257>\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmulsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmulsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x18(%rax),%xmm1\nmulsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x18(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmulsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x18(%rax),%xmm1\nmulsd  %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nsubsd  %xmm2,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x18(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmulsd  %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nsubsd  %xmm2,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x18(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x10(%rcx)\nmov    %rdx,0x18(%rcx)\nmov    -0x28(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "test", "content": "/** @} */\n\nstatic void test()\n{\n    quaternion quat = {{0.7071}, {{0.7071, 0.0, 0.0}}};\n    euler eul = euler_from_quat(&quat);\n    libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", eul.pitch, eul.roll, eul.yaw);\n\n    quaternion test_quat = quat_from_euler(&eul);\n    libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", test_quat.w,\n           test_quat.dual.x, test_quat.dual.y, test_quat.dual.z);\n\n    libmin_assert(libmin_fabs(test_quat.w - quat.w) < .01);\n    libmin_assert(libmin_fabs(test_quat.q1 - quat.q1) < .01);\n    libmin_assert(libmin_fabs(test_quat.q2 - quat.q2) < .01);\n    libmin_assert(libmin_fabs(test_quat.q3 - quat.q3) < .01);\n    libmin_printf(\"All tests passed!\\n\");\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O0.pseudo", "function_name": "test", "address": "0x18b2", "label": "test", "content": "void __cdecl test()\n{\n  euler eul; // [rsp+0h] [rbp-70h] BYREF\n  quaternion quat; // [rsp+20h] [rbp-50h] BYREF\n  quaternion test_quat; // [rsp+40h] [rbp-30h] BYREF\n  unsigned __int64 v3; // [rsp+68h] [rbp-8h]\n\n  v3 = __readfsqword(0x28u);\n  quat.w = 0.7071;\n  *(_OWORD *)&quat.dual.x = 0x3FE6A0902DE00D1BuLL;\n  quat.dual.z = 0.0;\n  euler_from_quat(&eul, &quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", eul.pitch, eul.roll, eul.yaw);\n  quat_from_euler(&test_quat, &eul);\n  libmin_printf(\n    \"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\",\n    test_quat.w,\n    test_quat.dual.x,\n    test_quat.dual.y,\n    test_quat.dual.z);\n  if ( libmin_fabs(test_quat.w - quat.w) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(test_quat.dual.x - quat.dual.x) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(test_quat.dual.y - quat.dual.y) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(test_quat.dual.z - quat.dual.z) >= 0.01 )\n    libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}\n"}, "pseudo_normalize": "void test() {\n  euler eul;\n  quaternion quat;\n  quaternion test_quat;\n  unsigned long long v3;\n  v3 = __readfsqword(40u);\n  quat.w = 0.7071;\n  *(long double *)&quat.dual.x = 4604544210138303771uLL;\n  quat.dual.z = 0.0;\n  euler_from_quat(&eul, &quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", eul.pitch, eul.roll, eul.yaw);\n  quat_from_euler(&test_quat, &eul);\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", test_quat.w,\n                test_quat.dual.x, test_quat.dual.y, test_quat.dual.z);\n  if (libmin_fabs(test_quat.w - quat.w) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(test_quat.dual.x - quat.dual.x) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(test_quat.dual.y - quat.dual.y) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(test_quat.dual.z - quat.dual.z) >= 0.01) libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}", "binary": "quaternions/quaternions.host.O0", "assembly": "<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovsd  0x57f3(%rip),%xmm0\nmovsd  %xmm0,-0x50(%rbp)\nmovsd  0x57e6(%rip),%xmm0\nmovsd  %xmm0,-0x48(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nlea    -0x70(%rbp),%rax\nlea    -0x50(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   1447 <euler_from_quat>\nmovsd  -0x60(%rbp),%xmm1\nmovsd  -0x70(%rbp),%xmm0\nmov    -0x68(%rbp),%rax\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x56f5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x3,%eax\ncall   492b <libmin_printf>\nlea    -0x30(%rbp),%rax\nlea    -0x70(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <quat_from_euler>\nmovsd  -0x18(%rbp),%xmm2\nmovsd  -0x20(%rbp),%xmm1\nmovsd  -0x28(%rbp),%xmm0\nmov    -0x30(%rbp),%rax\nmovapd %xmm2,%xmm3\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x56c7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x4,%eax\ncall   492b <libmin_printf>\nmovsd  -0x30(%rbp),%xmm0\nmovsd  -0x50(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2899 <libmin_fabs>\nmovsd  0x5725(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     19bb <test+0x109>\nmov    $0x1,%edi\ncall   28ff <libmin_fail>\nmovsd  -0x28(%rbp),%xmm0\nmovsd  -0x48(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2899 <libmin_fabs>\nmovsd  0x56f0(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     19f0 <test+0x13e>\nmov    $0x1,%edi\ncall   28ff <libmin_fail>\nmovsd  -0x20(%rbp),%xmm0\nmovsd  -0x40(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2899 <libmin_fabs>\nmovsd  0x56bb(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1a25 <test+0x173>\nmov    $0x1,%edi\ncall   28ff <libmin_fail>\nmovsd  -0x18(%rbp),%xmm0\nmovsd  -0x38(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2899 <libmin_fabs>\nmovsd  0x5686(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1a5a <test+0x1a8>\nmov    $0x1,%edi\ncall   28ff <libmin_fail>\nlea    0x5607(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   492b <libmin_printf>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1a83 <test+0x1d1>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "rabinkarp-search/rabinkarp-search.c", "function_name": "main", "content": "int\nmain(void) \n{ \n  int n = libmin_strlen(inp_txt); // String lengths are public\n  int m = libmin_strlen(inp_pat); // String lengths are public\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  \n  char *txt = libmin_malloc(sizeof(char)*(n+1));\n  int k;\n  for (k=0; k < n; k++)\n    txt[k] = inp_txt[k];\n  txt[k] = '\\0';\n\n  char *pat = libmin_malloc(sizeof(char)*(m+1));\n  for (k=0; k < m; k++)\n    pat[k] = inp_pat[k];\n  txt[k] = '\\0';\n\n  // Return vector\n  int *ret = (int *)libmin_malloc(sizeof(int)*n);\n  for (int i=0; i<n; i++)\n    ret[i] = FALSE; \n\n  // Run search\n  search(txt, n, pat, m, ret);\n\n  // print results\n  for(int i=0; i<n; i++)\n  {\n    if (ret[i]) \n    { \n      libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "rabinkarp-search/rabinkarp-search.host.O0.pseudo", "function_name": "main", "address": "0x1341", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int k; // [rsp+4h] [rbp-2Ch]\n  int ka; // [rsp+4h] [rbp-2Ch]\n  int i; // [rsp+8h] [rbp-28h]\n  int i_0; // [rsp+Ch] [rbp-24h]\n  int n; // [rsp+10h] [rbp-20h]\n  int m; // [rsp+14h] [rbp-1Ch]\n  char *txt; // [rsp+18h] [rbp-18h]\n  char *pat; // [rsp+20h] [rbp-10h]\n  int *ret; // [rsp+28h] [rbp-8h]\n\n  n = libmin_strlen(inp_txt);\n  m = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  txt = (char *)libmin_malloc(n + 1);\n  for ( k = 0; k < n; ++k )\n    txt[k] = inp_txt[k];\n  txt[k] = 0;\n  pat = (char *)libmin_malloc(m + 1);\n  for ( ka = 0; ka < m; ++ka )\n    pat[ka] = inp_pat[ka];\n  txt[ka] = 0;\n  ret = (int *)libmin_malloc(4LL * n);\n  for ( i = 0; i < n; ++i )\n    ret[i] = 0;\n  search(txt, n, pat, m, ret);\n  for ( i_0 = 0; i_0 < n; ++i_0 )\n  {\n    if ( ret[i_0] )\n      libmin_printf(\"pattern occurs at shift = %d\\n\", i_0);\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int k;\n  int ka;\n  int i;\n  int i_0;\n  int n;\n  int m;\n  char *txt;\n  char *pat;\n  int *ret;\n  n = libmin_strlen(inp_txt);\n  m = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  txt = (char *)libmin_malloc(n + 1);\n  for (k = 0; k < n; ++k) txt[k] = inp_txt[k];\n  txt[k] = 0;\n  pat = (char *)libmin_malloc(m + 1);\n  for (ka = 0; ka < m; ++ka) pat[ka] = inp_pat[ka];\n  txt[ka] = 0;\n  ret = (int *)libmin_malloc(4LL * n);\n  for (i = 0; i < n; ++i) ret[i] = 0;\n  search(txt, n, pat, m, ret);\n  for (i_0 = 0; i_0 < n; ++i_0) {\n    if (ret[i_0]) libmin_printf(\"pattern occurs at shift = %d\\n\", i_0);\n  }\n  libmin_success();\n}", "binary": "rabinkarp-search/rabinkarp-search.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nlea    0x4cec(%rip),%rax\nmov    %rax,%rdi\ncall   3d16 <libmin_strlen>\nmov    %eax,-0x20(%rbp)\nlea    0x4cba(%rip),%rax\nmov    %rax,%rdi\ncall   3d16 <libmin_strlen>\nmov    %eax,-0x1c(%rbp)\nmov    -0x1c(%rbp),%edx\nmov    -0x20(%rbp),%eax\nmov    %eax,%esi\nlea    0x2c84(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ae7 <libmin_printf>\nmov    -0x20(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   1685 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x2c(%rbp)\njmp    13cd <main+0x8c>\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x4c7d(%rip),%rcx\nmovzbl (%rax,%rcx,1),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     13aa <main+0x69>\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x1c(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmov    %rax,%rdi\ncall   1685 <libmin_malloc>\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x2c(%rbp)\njmp    1425 <main+0xe4>\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x4c05(%rip),%rcx\nmovzbl (%rax,%rcx,1),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x2c(%rbp)\nmov    -0x2c(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njl     1402 <main+0xc1>\nmov    -0x2c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x20(%rbp),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   1685 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    1479 <main+0x138>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x0,(%rax)\naddl   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     145b <main+0x11a>\nmov    -0x8(%rbp),%rdi\nmov    -0x1c(%rbp),%ecx\nmov    -0x10(%rbp),%rdx\nmov    -0x20(%rbp),%esi\nmov    -0x18(%rbp),%rax\nmov    %rdi,%r8\nmov    %rax,%rdi\ncall   11e9 <search>\nmovl   $0x0,-0x24(%rbp)\njmp    14de <main+0x19d>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\nje     14da <main+0x199>\nmov    -0x24(%rbp),%eax\nmov    %eax,%esi\nlea    0x2b47(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ae7 <libmin_printf>\naddl   $0x1,-0x24(%rbp)\nmov    -0x24(%rbp),%eax\ncmp    -0x20(%rbp),%eax\njl     14a7 <main+0x166>\ncall   3d54 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "rabinkarp-search/rabinkarp-search.c", "function_name": "search", "content": "// D is the number of characters in the input alphabet \n#define D 256 \n\n/* simple string search algorithm */\nvoid\nsearch(char *txt, int n, char *pat, int m, int *ret)\n{\n  int q = INT_MAX; \n\n  // value of h would be \"pow(d, M-1)%q\" \n  int h = 1;\n  for (int i = 0; i < m - 1; i++) \n    h = (h * D) % q; \n\n  int32_t p = 0; // hash value for pattern \n  int32_t t = 0; // hash value for txt \n\n  // calculate the hash value of pattern and first window of text \n  for (int i = 0; i < m; i++) \n  { \n    p = (D * p + pat[i]) % q; \n    t = (D * t + txt[i]) % q; \n  } \n\n  // slide the pattern over text one by one \n  for (int i = 0; i <= n - m; i++) \n    { \n  \n    // check the hash values of current window of text \n    // and pattern. If the hash values match then only \n    // check for characters one by one \n    ret[i] = (p == t);\n  \n    // calculate hash value for next window of text: Remove leading digit, add trailing digit \n    if (i < n-m) \n    { \n      t = (D*(t - ((int32_t)txt[i])*h) + txt[i+m])%q; \n  \n      // we might get negative value of t, converting it to positive \n      if (t < 0) \n        t = (t + q); \n    } \n  } \n}\n"}, "pseudo": {"path": "rabinkarp-search/rabinkarp-search.host.O0.pseudo", "function_name": "search", "address": "0x11e9", "label": "search", "content": "void __cdecl search(char *txt, int n, char *pat, int m, int *ret)\n{\n  int h; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+28h] [rbp-18h]\n  int32_t p; // [rsp+2Ch] [rbp-14h]\n  int32_t t; // [rsp+30h] [rbp-10h]\n  int32_t ta; // [rsp+30h] [rbp-10h]\n  int i_0; // [rsp+34h] [rbp-Ch]\n  int i_1; // [rsp+38h] [rbp-8h]\n\n  h = 1;\n  for ( i = 0; i < m - 1; ++i )\n    h = (h << 8) % 0x7FFFFFFF;\n  p = 0;\n  t = 0;\n  for ( i_0 = 0; i_0 < m; ++i_0 )\n  {\n    p = ((p << 8) + pat[i_0]) % 0x7FFFFFFF;\n    t = ((t << 8) + txt[i_0]) % 0x7FFFFFFF;\n  }\n  for ( i_1 = 0; i_1 <= n - m; ++i_1 )\n  {\n    ret[i_1] = p == t;\n    if ( i_1 < n - m )\n    {\n      ta = (((t - h * txt[i_1]) << 8) + txt[i_1 + m]) % 0x7FFFFFFF;\n      t = ta + (ta < 0 ? 0x7FFFFFFF : 0);\n    }\n  }\n}\n"}, "pseudo_normalize": "void search(char *txt, int n, char *pat, int m, int *ret) {\n  int h;\n  int i;\n  int32_t p;\n  int32_t t;\n  int32_t ta;\n  int i_0;\n  int i_1;\n  h = 1;\n  for (i = 0; i < m - 1; ++i) h = (h << 8) % 2147483647;\n  p = 0;\n  t = 0;\n  for (i_0 = 0; i_0 < m; ++i_0) {\n    p = ((p << 8) + pat[i_0]) % 2147483647;\n    t = ((t << 8) + txt[i_0]) % 2147483647;\n  }\n  for (i_1 = 0; i_1 <= n - m; ++i_1) {\n    ret[i_1] = p == t;\n    if (i_1 < n - m) {\n      ta = (((t - h * txt[i_1]) << 8) + txt[i_1 + m]) % 2147483647;\n      t = ta + (ta < 0 ? 2147483647 : 0);\n    }\n  }\n}", "binary": "rabinkarp-search/rabinkarp-search.host.O0", "assembly": "<search>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %ecx,-0x30(%rbp)\nmov    %r8,-0x40(%rbp)\nmovl   $0x7fffffff,-0x4(%rbp)\nmovl   $0x1,-0x1c(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    122b <search+0x42>\nmov    -0x1c(%rbp),%eax\nshl    $0x8,%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,-0x1c(%rbp)\naddl   $0x1,-0x18(%rbp)\nmov    -0x30(%rbp),%eax\nsub    $0x1,%eax\ncmp    %eax,-0x18(%rbp)\njl     121a <search+0x31>\nmovl   $0x0,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1299 <search+0xb0>\nmov    -0x14(%rbp),%eax\nshl    $0x8,%eax\nmov    %eax,%ecx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nadd    %ecx,%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,-0x14(%rbp)\nmov    -0x10(%rbp),%eax\nshl    $0x8,%eax\nmov    %eax,%ecx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nadd    %ecx,%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,-0x10(%rbp)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x30(%rbp),%eax\njl     124d <search+0x64>\nmovl   $0x0,-0x8(%rbp)\njmp    132e <search+0x145>\nmov    -0x14(%rbp),%eax\ncmp    -0x10(%rbp),%eax\nsete   %cl\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x40(%rbp),%rax\nadd    %rax,%rdx\nmovzbl %cl,%eax\nmov    %eax,(%rdx)\nmov    -0x2c(%rbp),%eax\nsub    -0x30(%rbp),%eax\ncmp    %eax,-0x8(%rbp)\njge    132a <search+0x141>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nimul   -0x1c(%rbp),%eax\nmov    %eax,%edx\nmov    -0x10(%rbp),%eax\nsub    %edx,%eax\nshl    $0x8,%eax\nmov    %eax,%ecx\nmov    -0x8(%rbp),%edx\nmov    -0x30(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nadd    %ecx,%eax\ncltd\nidivl  -0x4(%rbp)\nmov    %edx,-0x10(%rbp)\ncmpl   $0x0,-0x10(%rbp)\njns    132a <search+0x141>\nmov    -0x4(%rbp),%eax\nadd    %eax,-0x10(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0x2c(%rbp),%eax\nsub    -0x30(%rbp),%eax\ncmp    %eax,-0x8(%rbp)\njle    12ad <search+0xc4>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "bad_rand", "content": "// A deliberately weak (\"bad\") random number generator using a simple LCG.\nuint32_t bad_rand(void) {\n    static uint32_t state = 123456789;  // Fixed seed for reproducibility.\n    state = state * 110351524 + 12345;\n    return state;\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O0.pseudo", "function_name": "bad_rand", "address": "0x1201", "label": "bad_rand", "content": "uint32_t __cdecl bad_rand()\n{\n  state_0 = 110351524 * state_0 + 12345;\n  return state_0;\n}\n"}, "pseudo_normalize": "", "binary": "rand-test/rand-test.host.O0", "assembly": "<bad_rand>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    0x5e01(%rip),%eax\nimul   $0x693d4a4,%eax,%eax\nadd    $0x3039,%eax\nmov    %eax,0x5df0(%rip)\nmov    0x5dea(%rip),%eax\npop    %rbp\nret\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "count_bits", "content": "// Helper: Count the number of 1 bits in a 32-bit integer.\nstatic inline int count_bits(uint32_t x) {\n    return __builtin_popcount(x);\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O0.pseudo", "function_name": "count_bits", "address": "0x11e9", "label": "count_bits", "content": "int __cdecl count_bits(uint32_t x)\n{\n  return _popcountdi2(x);\n}\n"}, "pseudo_normalize": "", "binary": "rand-test/rand-test.host.O0", "assembly": "<count_bits>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmov    %rax,%rdi\ncall   4430 <__popcountdi2>\nleave\nret\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "good_rand", "content": "// A wrapper for the system's rand() function.\n// Since rand() may not return a full 32-bit value, we combine two calls.\nuint32_t good_rand(void) {\n    // Obtain two random numbers.\n    uint32_t r1 = (uint32_t) libmin_rand();\n    uint32_t r2 = (uint32_t) libmin_rand();\n    // Combine them. This assumes rand() returns at most 15 bits.\n    return (r1 << 15) | (r2 & 0x7FFF);\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O0.pseudo", "function_name": "good_rand", "address": "0x1228", "label": "good_rand", "content": "uint32_t __cdecl good_rand()\n{\n  uint32_t r1; // [rsp+8h] [rbp-8h]\n\n  r1 = libmin_rand();\n  return (r1 << 15) | libmin_rand() & 0x7FFF;\n}\n"}, "pseudo_normalize": "", "binary": "rand-test/rand-test.host.O0", "assembly": "<good_rand>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\ncall   3d80 <libmin_rand>\nmov    %eax,-0x8(%rbp)\ncall   3d80 <libmin_rand>\nmov    %eax,-0x4(%rbp)\nmov    -0x8(%rbp),%eax\nshl    $0xf,%eax\nmov    %eax,%edx\nmov    -0x4(%rbp),%eax\nand    $0x7fff,%eax\nor     %edx,%eax\nleave\nret\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "main", "content": "int main(void) {\n    // Seed the system's RNG for good_rand().\n    libmin_srand(42);\n\n    // First test: Use the deliberately weak generator (bad_rand).\n    run_tests(\"Bad (bad_rand())\", bad_rand);\n\n    // Second test: Use the system's standard rand() via good_rand.\n    run_tests(\"Good (good_rand())\", good_rand);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O0.pseudo", "function_name": "main", "address": "0x1913", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}", "binary": "rand-test/rand-test.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x2a,%edi\ncall   3cce <libmin_srand>\nlea    -0x72b(%rip),%rax\nmov    %rax,%rsi\nlea    0x385d(%rip),%rax\nmov    %rax,%rdi\ncall   1258 <run_tests>\nlea    -0x71d(%rip),%rax\nmov    %rax,%rsi\nlea    0x3855(%rip),%rax\nmov    %rax,%rdi\ncall   1258 <run_tests>\ncall   43ae <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "run_tests", "content": "// Test harness to run the battery of randomness tests on the provided RNG.\nvoid run_tests(const char *gen_name, rng_func_t rng_func) {\n    libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n\n    uint64_t ones_count = 0;\n    uint64_t total_bits = 0;\n    uint32_t bins[BIN_COUNT] = {0};\n\n    // Variables for the serial correlation test.\n    double serial_x_sum = 0.0, serial_y_sum = 0.0;\n    double serial_xy_sum = 0.0, serial_x2_sum = 0.0, serial_y2_sum = 0.0;\n    int serial_count = 0;\n    uint32_t prev = 0;\n    int first = 1;\n\n    // Loop to generate SAMPLE_SIZE random numbers.\n    for (size_t i = 0; i < SAMPLE_SIZE; i++) {\n        uint32_t sample = rng_func();\n\n        // Monobit Test: Count the number of 1 bits.\n        ones_count += count_bits(sample);\n        total_bits += 32;\n\n        // Chi-Square Test: Use the top 8 bits for binning.\n        uint32_t bin = sample >> 24;\n        bins[bin]++;\n\n        // Serial Correlation Test: Compare adjacent samples.\n        if (!first) {\n            serial_x_sum   += (double)prev;\n            serial_y_sum   += (double)sample;\n            serial_xy_sum  += (double)prev * sample;\n            serial_x2_sum  += (double)prev * prev;\n            serial_y2_sum  += (double)sample * sample;\n            serial_count++;\n        } else {\n            first = 0;\n        }\n        prev = sample;\n    }\n\n    // Report Monobit Test Results.\n    double ones_ratio = (double)ones_count / total_bits;\n    libmin_printf(\"Monobit Test:\\n\");\n    libmin_printf(\"  Total bits processed: %llu\\n\", total_bits);\n    libmin_printf(\"  Total ones count: %llu\\n\", ones_count);\n    libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", ones_ratio);\n\n    // Report Chi-Square Test results on top 8 bits.\n    double expected_count = (double)SAMPLE_SIZE / BIN_COUNT;\n    double chi_square = 0.0;\n    for (int i = 0; i < BIN_COUNT; i++) {\n        double diff = bins[i] - expected_count;\n        chi_square += (diff * diff) / expected_count;\n    }\n    libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n    libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", chi_square, BIN_COUNT - 1);\n\n    // Report Serial Correlation Test results.\n    double mean_x = serial_x_sum / serial_count;\n    double mean_y = serial_y_sum / serial_count;\n    double covariance = (serial_xy_sum / serial_count) - (mean_x * mean_y);\n    double var_x = (serial_x2_sum / serial_count) - (mean_x * mean_x);\n    double var_y = (serial_y2_sum / serial_count) - (mean_y * mean_y);\n    double serial_corr = covariance / (libmin_sqrt(var_x * var_y));\n    libmin_printf(\"\\nSerial Correlation Test:\\n\");\n    libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\", serial_corr);\n\n    libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O0.pseudo", "function_name": "run_tests", "address": "0x1258", "label": "run_tests", "content": "void __cdecl run_tests(const char *gen_name, rng_func_t rng_func)\n{\n  uint32_t *v2; // rdx\n  double v3; // xmm0_8\n  double v4; // xmm1_8\n  double v5; // xmm1_8\n  int serial_count; // [rsp+18h] [rbp-4B8h]\n  signed int prev; // [rsp+1Ch] [rbp-4B4h]\n  int first; // [rsp+20h] [rbp-4B0h]\n  int i_0; // [rsp+24h] [rbp-4ACh]\n  int sample; // [rsp+28h] [rbp-4A8h]\n  signed __int64 ones_count; // [rsp+30h] [rbp-4A0h]\n  signed __int64 total_bits; // [rsp+38h] [rbp-498h]\n  double serial_x_sum; // [rsp+40h] [rbp-490h]\n  double serial_y_sum; // [rsp+48h] [rbp-488h]\n  double serial_xy_sum; // [rsp+50h] [rbp-480h]\n  double serial_x2_sum; // [rsp+58h] [rbp-478h]\n  double serial_y2_sum; // [rsp+60h] [rbp-470h]\n  size_t i; // [rsp+68h] [rbp-468h]\n  double chi_square; // [rsp+70h] [rbp-460h]\n  double mean_y; // [rsp+90h] [rbp-440h]\n  double diff; // [rsp+B8h] [rbp-418h]\n  uint32_t bins[258]; // [rsp+C0h] [rbp-410h] BYREF\n  unsigned __int64 v23; // [rsp+4C8h] [rbp-8h]\n\n  v23 = __readfsqword(0x28u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  ones_count = 0LL;\n  total_bits = 0LL;\n  v2 = bins;\n  memset(bins, 0, 0x400uLL);\n  serial_x_sum = 0.0;\n  serial_y_sum = 0.0;\n  serial_xy_sum = 0.0;\n  serial_x2_sum = 0.0;\n  serial_y2_sum = 0.0;\n  serial_count = 0;\n  prev = 0;\n  first = 1;\n  for ( i = 0LL; i <= 0x270F; ++i )\n  {\n    sample = rng_func();\n    ones_count += count_bits(sample);\n    total_bits += 32LL;\n    v2 = (uint32_t *)(bins[HIBYTE(sample)] + 1);\n    bins[HIBYTE(sample)] = (unsigned int)v2;\n    if ( first )\n    {\n      first = 0;\n    }\n    else\n    {\n      serial_x_sum = (double)prev + serial_x_sum;\n      serial_y_sum = (double)sample + serial_y_sum;\n      serial_xy_sum = (double)sample * (double)prev + serial_xy_sum;\n      serial_x2_sum = (double)prev * (double)prev + serial_x2_sum;\n      serial_y2_sum = (double)sample * (double)sample + serial_y2_sum;\n      ++serial_count;\n    }\n    prev = sample;\n  }\n  if ( ones_count < 0 )\n  {\n    v2 = (uint32_t *)(ones_count & 1 | ((unsigned __int64)ones_count >> 1));\n    v3 = (double)(int)v2 + (double)(int)v2;\n  }\n  else\n  {\n    v3 = (double)(int)ones_count;\n  }\n  if ( total_bits < 0 )\n  {\n    v2 = (uint32_t *)(total_bits & 1 | ((unsigned __int64)total_bits >> 1));\n    v4 = (double)(int)v2 + (double)(int)v2;\n  }\n  else\n  {\n    v4 = (double)(int)total_bits;\n  }\n  libmin_printf(\"Monobit Test:\\n\", gen_name, v2);\n  libmin_printf(\"  Total bits processed: %llu\\n\", total_bits);\n  libmin_printf(\"  Total ones count: %llu\\n\", ones_count);\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v3 / v4);\n  chi_square = 0.0;\n  for ( i_0 = 0; i_0 <= 255; ++i_0 )\n  {\n    diff = (double)(int)bins[i_0] - 39.0625;\n    chi_square = diff * diff / 39.0625 + chi_square;\n  }\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", chi_square, 255);\n  mean_y = serial_y_sum / (double)serial_count;\n  v5 = libmin_sqrt(\n         (serial_x2_sum / (double)serial_count\n        - serial_x_sum / (double)serial_count * (serial_x_sum / (double)serial_count))\n       * (serial_y2_sum / (double)serial_count - mean_y * mean_y));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\n    \"  Serial correlation coefficient: %f (expected near 0)\\n\",\n    (serial_xy_sum / (double)serial_count - serial_x_sum / (double)serial_count * mean_y) / v5);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}\n"}, "pseudo_normalize": "void run_tests(const char *gen_name, rng_func_t rng_func) {\n  uint32_t *v2;\n  double v3;\n  double v4;\n  double v5;\n  int serial_count;\n  signed int prev;\n  int first;\n  int i_0;\n  int sample;\n  signed long long ones_count;\n  signed long long total_bits;\n  double serial_x_sum;\n  double serial_y_sum;\n  double serial_xy_sum;\n  double serial_x2_sum;\n  double serial_y2_sum;\n  unsigned int i;\n  double chi_square;\n  double mean_y;\n  double diff;\n  uint32_t bins[258];\n  unsigned long long v23;\n  v23 = __readfsqword(40u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  ones_count = 0LL;\n  total_bits = 0LL;\n  v2 = bins;\n  memset(bins, 0, 1024uLL);\n  serial_x_sum = 0.0;\n  serial_y_sum = 0.0;\n  serial_xy_sum = 0.0;\n  serial_x2_sum = 0.0;\n  serial_y2_sum = 0.0;\n  serial_count = 0;\n  prev = 0;\n  first = 1;\n  for (i = 0LL; i <= 9999; ++i) {\n    sample = rng_func();\n    ones_count += count_bits(sample);\n    total_bits += 32LL;\n    v2 = (uint32_t *)(bins[HIBYTE(sample)] + 1);\n    bins[HIBYTE(sample)] = (unsigned int)v2;\n    if (first) {\n      first = 0;\n    } else {\n      serial_x_sum = (double)prev + serial_x_sum;\n      serial_y_sum = (double)sample + serial_y_sum;\n      serial_xy_sum = (double)sample * (double)prev + serial_xy_sum;\n      serial_x2_sum = (double)prev * (double)prev + serial_x2_sum;\n      serial_y2_sum = (double)sample * (double)sample + serial_y2_sum;\n      ++serial_count;\n    }\n    prev = sample;\n  }\n  if (ones_count < 0) {\n    v2 = (uint32_t *)(ones_count & 1 | ((unsigned long long)ones_count >> 1));\n    v3 = (double)(int)v2 + (double)(int)v2;\n  } else {\n    v3 = (double)(int)ones_count;\n  }\n  if (total_bits < 0) {\n    v2 = (uint32_t *)(total_bits & 1 | ((unsigned long long)total_bits >> 1));\n    v4 = (double)(int)v2 + (double)(int)v2;\n  } else {\n    v4 = (double)(int)total_bits;\n  }\n  libmin_printf(\"Monobit Test:\\n\", gen_name, v2);\n  libmin_printf(\"  Total bits processed: %llu\\n\", total_bits);\n  libmin_printf(\"  Total ones count: %llu\\n\", ones_count);\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v3 / v4);\n  chi_square = 0.0;\n  for (i_0 = 0; i_0 <= 255; ++i_0) {\n    diff = (double)(int)bins[i_0] - 39.0625;\n    chi_square = diff * diff / 39.0625 + chi_square;\n  }\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\",\n                chi_square, 255);\n  mean_y = serial_y_sum / (double)serial_count;\n  v5 = libmin_sqrt((serial_x2_sum / (double)serial_count -\n                    serial_x_sum / (double)serial_count *\n                        (serial_x_sum / (double)serial_count)) *\n                   (serial_y2_sum / (double)serial_count - mean_y * mean_y));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\",\n                (serial_xy_sum / (double)serial_count -\n                 serial_x_sum / (double)serial_count * mean_y) /\n                    v5);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}", "binary": "rand-test/rand-test.host.O0", "assembly": "<run_tests>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x4d0,%rsp\nmov    %rdi,-0x4c8(%rbp)\nmov    %rsi,-0x4d0(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x4c8(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3d73(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nmovq   $0x0,-0x4a0(%rbp)\nmovq   $0x0,-0x498(%rbp)\nlea    -0x410(%rbp),%rdx\nmov    $0x0,%eax\nmov    $0x80,%ecx\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x490(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x488(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x480(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x478(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x470(%rbp)\nmovl   $0x0,-0x4b8(%rbp)\nmovl   $0x0,-0x4b4(%rbp)\nmovl   $0x1,-0x4b0(%rbp)\nmovq   $0x0,-0x468(%rbp)\njmp    15ba <run_tests+0x362>\nmov    -0x4d0(%rbp),%rax\ncall   *%rax\nmov    %eax,-0x4a8(%rbp)\nmov    -0x4a8(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <count_bits>\ncltq\nadd    %rax,-0x4a0(%rbp)\naddq   $0x20,-0x498(%rbp)\nmov    -0x4a8(%rbp),%eax\nshr    $0x18,%eax\nmov    %eax,-0x4a4(%rbp)\nmov    -0x4a4(%rbp),%eax\nmov    -0x410(%rbp,%rax,4),%eax\nlea    0x1(%rax),%edx\nmov    -0x4a4(%rbp),%eax\nmov    %edx,-0x410(%rbp,%rax,4)\ncmpl   $0x0,-0x4b0(%rbp)\njne    159c <run_tests+0x344>\nmov    -0x4b4(%rbp),%eax\ntest   %rax,%rax\njs     13b5 <run_tests+0x15d>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    13ce <run_tests+0x176>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  -0x490(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x490(%rbp)\nmov    -0x4a8(%rbp),%eax\ntest   %rax,%rax\njs     13f8 <run_tests+0x1a0>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1411 <run_tests+0x1b9>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  -0x488(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x488(%rbp)\nmov    -0x4b4(%rbp),%eax\ntest   %rax,%rax\njs     143b <run_tests+0x1e3>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\njmp    1458 <run_tests+0x200>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmov    -0x4a8(%rbp),%eax\ntest   %rax,%rax\njs     146e <run_tests+0x216>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1487 <run_tests+0x22f>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x480(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x480(%rbp)\nmov    -0x4b4(%rbp),%eax\ntest   %rax,%rax\njs     14b5 <run_tests+0x25d>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\njmp    14d2 <run_tests+0x27a>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmov    -0x4b4(%rbp),%eax\ntest   %rax,%rax\njs     14e8 <run_tests+0x290>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1501 <run_tests+0x2a9>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x478(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x478(%rbp)\nmov    -0x4a8(%rbp),%eax\ntest   %rax,%rax\njs     152f <run_tests+0x2d7>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\njmp    154c <run_tests+0x2f4>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmov    -0x4a8(%rbp),%eax\ntest   %rax,%rax\njs     1562 <run_tests+0x30a>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    157b <run_tests+0x323>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x470(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x470(%rbp)\naddl   $0x1,-0x4b8(%rbp)\njmp    15a6 <run_tests+0x34e>\nmovl   $0x0,-0x4b0(%rbp)\nmov    -0x4a8(%rbp),%eax\nmov    %eax,-0x4b4(%rbp)\naddq   $0x1,-0x468(%rbp)\ncmpq   $0x270f,-0x468(%rbp)\njbe    1339 <run_tests+0xe1>\nmov    -0x4a0(%rbp),%rax\ntest   %rax,%rax\njs     15e2 <run_tests+0x38a>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    15fb <run_tests+0x3a3>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmov    -0x498(%rbp),%rax\ntest   %rax,%rax\njs     1612 <run_tests+0x3ba>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\njmp    162b <run_tests+0x3d3>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm1,%xmm1\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x458(%rbp)\nlea    0x39f2(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nmov    -0x498(%rbp),%rax\nmov    %rax,%rsi\nlea    0x39e3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nmov    -0x4a0(%rbp),%rax\nmov    %rax,%rsi\nlea    0x39e3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nmov    -0x458(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x39de(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3a9f <libmin_printf>\nmovsd  0x3b09(%rip),%xmm0\nmovsd  %xmm0,-0x450(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x460(%rbp)\nmovl   $0x0,-0x4ac(%rbp)\njmp    1748 <run_tests+0x4f0>\nmov    -0x4ac(%rbp),%eax\ncltq\nmov    -0x410(%rbp,%rax,4),%eax\nmov    %eax,%eax\ntest   %rax,%rax\njs     16f0 <run_tests+0x498>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1709 <run_tests+0x4b1>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nsubsd  -0x450(%rbp),%xmm0\nmovsd  %xmm0,-0x418(%rbp)\nmovsd  -0x418(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\ndivsd  -0x450(%rbp),%xmm0\nmovsd  -0x460(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x460(%rbp)\naddl   $0x1,-0x4ac(%rbp)\ncmpl   $0xff,-0x4ac(%rbp)\njle    16cf <run_tests+0x477>\nlea    0x3941(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nmov    -0x460(%rbp),%rax\nmov    $0xff,%esi\nmovq   %rax,%xmm0\nlea    0x394c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3a9f <libmin_printf>\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x4b8(%rbp),%xmm1\nmovsd  -0x490(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x448(%rbp)\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x4b8(%rbp),%xmm1\nmovsd  -0x488(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x440(%rbp)\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x4b8(%rbp),%xmm1\nmovsd  -0x480(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  -0x448(%rbp),%xmm1\nmulsd  -0x440(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x438(%rbp)\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x4b8(%rbp),%xmm2\nmovsd  -0x478(%rbp),%xmm0\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  -0x448(%rbp),%xmm0\nmovapd %xmm0,%xmm2\nmulsd  %xmm0,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm0,-0x430(%rbp)\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x4b8(%rbp),%xmm2\nmovsd  -0x470(%rbp),%xmm0\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  -0x440(%rbp),%xmm0\nmovapd %xmm0,%xmm2\nmulsd  %xmm0,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm0,-0x428(%rbp)\nmovsd  -0x430(%rbp),%xmm0\nmulsd  -0x428(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   3ff9 <libmin_sqrt>\nmovapd %xmm0,%xmm1\nmovsd  -0x438(%rbp),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x420(%rbp)\nlea    0x384b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nmov    -0x420(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x384d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3a9f <libmin_printf>\nlea    0x3871(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3a9f <libmin_printf>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1911 <run_tests+0x6b9>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "ransac/ransac.c", "function_name": "line_distance", "content": "// Compute the perpendicular distance from a point to the line: y = m*x + b.\ndouble line_distance(Point p, double m, double b) {\n    return libmin_fabs(m * p.x - p.y + b) / libmin_sqrt(m * m + 1.0);\n}\n"}, "pseudo": {"path": "ransac/ransac.host.O0.pseudo", "function_name": "line_distance", "address": "0x11e9", "label": "line_distance", "content": "// local variable allocation has failed, the output may be wrong!\ndouble __cdecl line_distance(Point p, double m, double b)\n{\n  double v3; // rbx\n\n  v3 = libmin_fabs(p.x * m - p.y + b);\n  return v3 / libmin_sqrt(m * m + 1.0);\n}\n"}, "pseudo_normalize": "", "binary": "ransac/ransac.host.O0", "assembly": "<line_distance>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmovq   %xmm0,%rcx\nmovapd %xmm1,%xmm0\nmov    $0x0,%eax\nmov    $0x0,%edx\nmov    %rcx,%rax\nmovq   %xmm0,%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmovsd  %xmm2,-0x28(%rbp)\nmovsd  %xmm3,-0x30(%rbp)\nmovsd  -0x20(%rbp),%xmm0\nmulsd  -0x28(%rbp),%xmm0\nmovsd  -0x18(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\naddsd  -0x30(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   1892 <libmin_fabs>\nmovq   %xmm0,%rbx\nmovsd  -0x28(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x3dec(%rip),%xmm0\naddsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   3e4c <libmin_sqrt>\nmovq   %rbx,%xmm1\ndivsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "ransac/ransac.c", "function_name": "main", "content": "int main(void) {\n    libmin_srand(42);\n    Point points[NUM_POINTS];\n\n    // Generate inlier points along the line: y = 2*x + 1\n    int inlierCount = NUM_POINTS / 2;\n    for (int i = 0; i < inlierCount; i++) {\n        // Spread x values over a range.\n        double x = ((double) i / inlierCount) * 50.0;\n        // Add a small random noise in the y value.\n        double noise = ((double) libmin_rand() / RAND_MAX - 0.5) * 2.0;  // Noise in range [-1, 1]\n        points[i].x = x;\n        points[i].y = 2 * x + 1 + noise;\n    }\n\n    // Generate outlier points randomly.\n    for (int i = inlierCount; i < NUM_POINTS; i++) {\n        points[i].x = ((double) libmin_rand() / RAND_MAX) * 50.0;\n        points[i].y = ((double) libmin_rand() / RAND_MAX) * 100.0;\n    }\n\n    double best_m = 0, best_b = 0;\n    int best_inlier_count = 0;\n\n    // Run RANSAC to estimate the line parameters.\n    ransac_line_fitting(points, NUM_POINTS, &best_m, &best_b, &best_inlier_count);\n\n    // Display the results.\n    libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n    libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, NUM_POINTS);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "ransac/ransac.host.O0.pseudo", "function_name": "main", "address": "0x1466", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm0_8\n  int best_inlier_count; // [rsp+0h] [rbp-680h] BYREF\n  int i; // [rsp+4h] [rbp-67Ch]\n  int i_0; // [rsp+8h] [rbp-678h]\n  int inlierCount; // [rsp+Ch] [rbp-674h]\n  double best_m; // [rsp+10h] [rbp-670h] BYREF\n  double best_b; // [rsp+18h] [rbp-668h] BYREF\n  double x; // [rsp+20h] [rbp-660h]\n  double noise; // [rsp+28h] [rbp-658h]\n  Point points[100]; // [rsp+30h] [rbp-650h] BYREF\n  unsigned __int64 v13; // [rsp+678h] [rbp-8h]\n\n  v13 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  inlierCount = 50;\n  for ( i = 0; i < inlierCount; ++i )\n  {\n    x = 50.0 * ((double)i / (double)inlierCount);\n    v3 = (double)(int)libmin_rand();\n    noise = v3 / 2147483647.0 - 0.5 + v3 / 2147483647.0 - 0.5;\n    points[i].x = x;\n    points[i].y = x + x + 1.0 + noise;\n  }\n  for ( i_0 = inlierCount; i_0 <= 99; ++i_0 )\n  {\n    points[i_0].x = 50.0 * ((double)(int)libmin_rand() / 2147483647.0);\n    points[i_0].y = 100.0 * ((double)(int)libmin_rand() / 2147483647.0);\n  }\n  best_m = 0.0;\n  best_b = 0.0;\n  best_inlier_count = 0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  int best_inlier_count;\n  int i;\n  int i_0;\n  int inlierCount;\n  double best_m;\n  double best_b;\n  double x;\n  double noise;\n  Point points[100];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  libmin_srand(42u);\n  inlierCount = 50;\n  for (i = 0; i < inlierCount; ++i) {\n    x = 50.0 * ((double)i / (double)inlierCount);\n    v3 = (double)(int)libmin_rand();\n    noise = v3 / 2147483647.0 - 0.5 + v3 / 2147483647.0 - 0.5;\n    points[i].x = x;\n    points[i].y = x + x + 1.0 + noise;\n  }\n  for (i_0 = inlierCount; i_0 <= 99; ++i_0) {\n    points[i_0].x = 50.0 * ((double)(int)libmin_rand() / 2147483647.0);\n    points[i_0].y = 100.0 * ((double)(int)libmin_rand() / 2147483647.0);\n  }\n  best_m = 0.0;\n  best_b = 0.0;\n  best_inlier_count = 0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}", "binary": "ransac/ransac.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x680,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x2a,%edi\ncall   3b21 <libmin_srand>\nmovl   $0x32,-0x674(%rbp)\nmovl   $0x0,-0x67c(%rbp)\njmp    1594 <main+0x12e>\npxor   %xmm0,%xmm0\ncvtsi2sdl -0x67c(%rbp),%xmm0\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x674(%rbp),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x3b91(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x660(%rbp)\ncall   3bd3 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     14f2 <main+0x8c>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    150b <main+0xa5>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x3b55(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  0x3b51(%rip),%xmm1\nsubsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  %xmm0,-0x658(%rbp)\nmov    -0x67c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rbp,%rax\nsub    $0x650,%rax\nmovsd  -0x660(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmovsd  -0x660(%rbp),%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x3ae8(%rip),%xmm0\naddsd  %xmm1,%xmm0\naddsd  -0x658(%rbp),%xmm0\nmov    -0x67c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rbp,%rax\nsub    $0x648,%rax\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x67c(%rbp)\nmov    -0x67c(%rbp),%eax\ncmp    -0x674(%rbp),%eax\njl     14a7 <main+0x41>\nmov    -0x674(%rbp),%eax\nmov    %eax,-0x678(%rbp)\njmp    1688 <main+0x222>\ncall   3bd3 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     15ce <main+0x168>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    15e7 <main+0x181>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x3a79(%rip),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x3a61(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x678(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rbp,%rax\nsub    $0x650,%rax\nmovsd  %xmm0,(%rax)\ncall   3bd3 <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     1633 <main+0x1cd>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    164c <main+0x1e6>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x3a14(%rip),%xmm2\nmovapd %xmm0,%xmm1\ndivsd  %xmm2,%xmm1\nmovsd  0x3a14(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x678(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rbp,%rax\nsub    $0x648,%rax\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x678(%rbp)\ncmpl   $0x63,-0x678(%rbp)\njle    15b7 <main+0x151>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x670(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x668(%rbp)\nmovl   $0x0,-0x680(%rbp)\nlea    -0x680(%rbp),%rsi\nlea    -0x668(%rbp),%rcx\nlea    -0x670(%rbp),%rdx\nlea    -0x650(%rbp),%rax\nmov    %rsi,%r8\nmov    $0x64,%esi\nmov    %rax,%rdi\ncall   1290 <ransac_line_fitting>\nmovsd  -0x668(%rbp),%xmm0\nmov    -0x670(%rbp),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x3906(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   38f2 <libmin_printf>\nmov    -0x680(%rbp),%eax\nmov    $0x64,%edx\nmov    %eax,%esi\nlea    0x390d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   38f2 <libmin_printf>\ncall   4201 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     174e <main+0x2e8>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "ransac/ransac.c", "function_name": "ransac_line_fitting", "content": "// A simple RANSAC function to fit a line to a set of points.\nvoid ransac_line_fitting(Point points[], int numPoints, double *best_m, double *best_b, int *best_inlier_count) {\n    *best_inlier_count = 0;\n\n    for (int iter = 0; iter < NUM_ITERATIONS; iter++) {\n        // Randomly select two distinct points.\n        int idx1 = libmin_rand() % numPoints;\n        int idx2 = libmin_rand() % numPoints;\n        while (idx2 == idx1) {\n            idx2 = libmin_rand() % numPoints;\n        }\n        Point p1 = points[idx1];\n        Point p2 = points[idx2];\n\n        // Avoid vertical lines for simplicity; skip if x values are too close.\n        if (libmin_fabs(p2.x - p1.x) < 1e-6)\n            continue;\n\n        // Compute candidate line parameters.\n        double m = (p2.y - p1.y) / (p2.x - p1.x);\n        double b = p1.y - m * p1.x;\n\n        // Count inliers: points whose distance to the line is within DIST_THRESHOLD.\n        int inlierCount = 0;\n        for (int i = 0; i < numPoints; i++) {\n            if (line_distance(points[i], m, b) < DIST_THRESHOLD)\n                inlierCount++;\n        }\n        // If this candidate is the best so far, remember its parameters.\n        if (inlierCount > *best_inlier_count) {\n            *best_inlier_count = inlierCount;\n            *best_m = m;\n            *best_b = b;\n        }\n    }\n}\n"}, "pseudo": {"path": "ransac/ransac.host.O0.pseudo", "function_name": "ransac_line_fitting", "address": "0x1290", "label": "ransac_line_fitting", "content": "void __cdecl ransac_line_fitting(Point *points, int numPoints, double *best_m, double *best_b, int *best_inlier_count)\n{\n  Point *v5; // rax\n  Point *v6; // rax\n  int iter; // [rsp+3Ch] [rbp-44h]\n  unsigned int idx2; // [rsp+40h] [rbp-40h]\n  int inlierCount; // [rsp+44h] [rbp-3Ch]\n  int i; // [rsp+48h] [rbp-38h]\n  unsigned int idx1; // [rsp+4Ch] [rbp-34h]\n  double m; // [rsp+50h] [rbp-30h]\n  double b; // [rsp+58h] [rbp-28h]\n  double p1; // [rsp+60h] [rbp-20h]\n  double p1_8; // [rsp+68h] [rbp-18h]\n  double p2; // [rsp+70h] [rbp-10h]\n  double p2_8; // [rsp+78h] [rbp-8h]\n\n  *best_inlier_count = 0;\n  for ( iter = 0; iter <= 499; ++iter )\n  {\n    idx1 = libmin_rand() % numPoints;\n    for ( idx2 = libmin_rand() % numPoints; idx2 == idx1; idx2 = libmin_rand() % numPoints )\n      ;\n    v5 = &points[idx1];\n    p1 = v5->x;\n    p1_8 = v5->y;\n    v6 = &points[idx2];\n    p2 = v6->x;\n    p2_8 = v6->y;\n    if ( libmin_fabs(v6->x - p1) >= 0.000001 )\n    {\n      m = (p2_8 - p1_8) / (p2 - p1);\n      b = p1_8 - p1 * m;\n      inlierCount = 0;\n      for ( i = 0; i < numPoints; ++i )\n      {\n        if ( line_distance(points[i], m, b) < 1.0 )\n          ++inlierCount;\n      }\n      if ( inlierCount > *best_inlier_count )\n      {\n        *best_inlier_count = inlierCount;\n        *best_m = m;\n        *best_b = b;\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void ransac_line_fitting(Point *points, int numPoints, double *best_m,\n                         double *best_b, int *best_inlier_count) {\n  Point *v5;\n  Point *v6;\n  int iter;\n  unsigned int idx2;\n  int inlierCount;\n  int i;\n  unsigned int idx1;\n  double m;\n  double b;\n  double p1;\n  double p1_8;\n  double p2;\n  double p2_8;\n  *best_inlier_count = 0;\n  for (iter = 0; iter <= 499; ++iter) {\n    idx1 = libmin_rand() % numPoints;\n    for (idx2 = libmin_rand() % numPoints; idx2 == idx1;\n         idx2 = libmin_rand() % numPoints)\n      ;\n    v5 = &points[idx1];\n    p1 = v5->x;\n    p1_8 = v5->y;\n    v6 = &points[idx2];\n    p2 = v6->x;\n    p2_8 = v6->y;\n    if (libmin_fabs(v6->x - p1) >= 0.000001) {\n      m = (p2_8 - p1_8) / (p2 - p1);\n      b = p1_8 - p1 * m;\n      inlierCount = 0;\n      for (i = 0; i < numPoints; ++i) {\n        if (line_distance(points[i], m, b) < 1.0) ++inlierCount;\n      }\n      if (inlierCount > *best_inlier_count) {\n        *best_inlier_count = inlierCount;\n        *best_m = m;\n        *best_b = b;\n      }\n    }\n  }\n}", "binary": "ransac/ransac.host.O0", "assembly": "<ransac_line_fitting>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %esi,-0x5c(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    %rcx,-0x70(%rbp)\nmov    %r8,-0x78(%rbp)\nmov    -0x78(%rbp),%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x44(%rbp)\njmp    1455 <ransac_line_fitting+0x1c5>\ncall   3bd3 <libmin_rand>\nmov    -0x5c(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nmov    %eax,-0x34(%rbp)\ncall   3bd3 <libmin_rand>\nmov    -0x5c(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nmov    %eax,-0x40(%rbp)\njmp    1303 <ransac_line_fitting+0x73>\ncall   3bd3 <libmin_rand>\nmov    -0x5c(%rbp),%ecx\nmov    $0x0,%edx\ndiv    %ecx\nmov    %edx,%eax\nmov    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\ncmp    -0x34(%rbp),%eax\nje     12ef <ransac_line_fitting+0x5f>\nmov    -0x34(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x40(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmov    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rax,-0x10(%rbp)\nmov    %rdx,-0x8(%rbp)\nmovsd  -0x10(%rbp),%xmm0\nmovsd  -0x20(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   1892 <libmin_fabs>\nmovsd  0x3ce4(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1450 <ransac_line_fitting+0x1c0>\nmovsd  -0x8(%rbp),%xmm0\nmovsd  -0x18(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  -0x10(%rbp),%xmm1\nmovsd  -0x20(%rbp),%xmm2\nsubsd  %xmm2,%xmm1\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmovsd  -0x18(%rbp),%xmm0\nmovsd  -0x20(%rbp),%xmm1\nmulsd  -0x30(%rbp),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovl   $0x0,-0x3c(%rbp)\nmovl   $0x0,-0x38(%rbp)\njmp    1418 <ransac_line_fitting+0x188>\nmov    -0x38(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x28(%rbp),%xmm2\nmovsd  -0x30(%rbp),%xmm0\nmov    (%rax),%rdx\nmovsd  0x8(%rax),%xmm1\nmovapd %xmm2,%xmm3\nmovapd %xmm0,%xmm2\nmovq   %rdx,%xmm0\ncall   11e9 <line_distance>\nmovsd  0x3c46(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    1414 <ransac_line_fitting+0x184>\naddl   $0x1,-0x3c(%rbp)\naddl   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%eax\ncmp    -0x5c(%rbp),%eax\njl     13cb <ransac_line_fitting+0x13b>\nmov    -0x78(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x3c(%rbp)\njle    1451 <ransac_line_fitting+0x1c1>\nmov    -0x78(%rbp),%rax\nmov    -0x3c(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x68(%rbp),%rax\nmovsd  -0x30(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x70(%rbp),%rax\nmovsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\njmp    1451 <ransac_line_fitting+0x1c1>\nnop\naddl   $0x1,-0x44(%rbp)\ncmpl   $0x1f3,-0x44(%rbp)\njle    12c5 <ransac_line_fitting+0x35>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "ismetachar", "content": "static int ismetachar(char c)\n{\n  return ((c == 's') || (c == 'S') || (c == 'w') || (c == 'W') || (c == 'd') || (c == 'D'));\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "ismetachar", "address": "0x2bb4", "label": "ismetachar", "content": "int __cdecl ismetachar(char c)\n{\n  return c == 115 || c == 83 || c == 119 || c == 87 || c == 100 || c == 68;\n}\n"}, "pseudo_normalize": "", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<ismetachar>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x73,-0x4(%rbp)\nje     2be5 <ismetachar+0x31>\ncmpb   $0x53,-0x4(%rbp)\nje     2be5 <ismetachar+0x31>\ncmpb   $0x77,-0x4(%rbp)\nje     2be5 <ismetachar+0x31>\ncmpb   $0x57,-0x4(%rbp)\nje     2be5 <ismetachar+0x31>\ncmpb   $0x64,-0x4(%rbp)\nje     2be5 <ismetachar+0x31>\ncmpb   $0x44,-0x4(%rbp)\njne    2bec <ismetachar+0x38>\nmov    $0x1,%eax\njmp    2bf1 <ismetachar+0x3d>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "main", "content": "int main()\n{\n    char* text;\n    char* pattern;\n    int should_fail;\n    int length;\n    int correctlen;\n    size_t ntests = sizeof(test_vector) / sizeof(*test_vector);\n    size_t nfailed = 0;\n    size_t i;\n\n    for (i = 0; i < ntests; ++i)\n    {\n        pattern = test_vector[i][1];\n        text = test_vector[i][2];\n        should_fail = (test_vector[i][0] == NOK);\n        correctlen = (int)(long int)(test_vector[i][3]);\n\n        int m = re_match(pattern, text, &length);\n\n        if (should_fail)\n        {\n            if (m != (-1))\n            {\n                libmin_printf(\"\\n\");\n                re_print(re_compile(pattern));\n                libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \\n\", (i+1), ntests, pattern, text, length);\n                nfailed += 1;\n            }\n        }\n        else\n        {\n            if (m == (-1))\n            {\n                libmin_printf(\"\\n\");\n                re_print(re_compile(pattern));\n                libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", (i+1), ntests, pattern, text);\n                nfailed += 1;\n            }\n            else if (length != correctlen)\n            {\n                libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \\n\", (i+1), ntests, pattern, length, text, correctlen);\n                nfailed += 1;\n            }\n        }\n    }\n\n    // printf(\"\\n\");\n    libmin_printf(\"%lu/%lu tests succeeded.\\n\", ntests - nfailed, ntests);\n\n    if (nfailed != 0)\n      return nfailed; /* 0 if all tests passed */\n    else\n      libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "main", "address": "0x32b9", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  regex_t *v3; // rax\n  regex_t *v4; // rax\n  int length; // [rsp+0h] [rbp-40h] BYREF\n  int should_fail; // [rsp+4h] [rbp-3Ch]\n  int correctlen; // [rsp+8h] [rbp-38h]\n  int m; // [rsp+Ch] [rbp-34h]\n  size_t nfailed; // [rsp+10h] [rbp-30h]\n  size_t i; // [rsp+18h] [rbp-28h]\n  size_t ntests; // [rsp+20h] [rbp-20h]\n  char *pattern; // [rsp+28h] [rbp-18h]\n  char *text; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v15; // [rsp+38h] [rbp-8h]\n\n  v15 = __readfsqword(0x28u);\n  ntests = 68LL;\n  nfailed = 0LL;\n  for ( i = 0LL; i < ntests; ++i )\n  {\n    pattern = test_vector[i][1];\n    text = test_vector[i][2];\n    should_fail = test_vector[i][0] == 0LL;\n    correctlen = (int)test_vector[i][3];\n    m = re_match(pattern, text, &length);\n    if ( should_fail )\n    {\n      if ( m != -1 )\n      {\n        libmin_printf(\"\\n\");\n        v3 = re_compile(pattern);\n        re_print(v3);\n        libmin_printf(\n          \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \\n\",\n          i + 1,\n          ntests,\n          pattern,\n          text,\n          length);\n        ++nfailed;\n      }\n    }\n    else if ( m == -1 )\n    {\n      libmin_printf(\"\\n\");\n      v4 = re_compile(pattern);\n      re_print(v4);\n      libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", i + 1, ntests, pattern, text);\n      ++nfailed;\n    }\n    else if ( correctlen != length )\n    {\n      libmin_printf(\n        \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \\n\",\n        i + 1,\n        ntests,\n        pattern,\n        length,\n        text,\n        correctlen);\n      ++nfailed;\n    }\n  }\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", ntests - nfailed, ntests);\n  if ( !nfailed )\n    libmin_success();\n  return nfailed;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  regex_t *v3;\n  regex_t *v4;\n  int length;\n  int should_fail;\n  int correctlen;\n  int m;\n  unsigned int nfailed;\n  unsigned int i;\n  unsigned int ntests;\n  char *pattern;\n  char *text;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  ntests = 68LL;\n  nfailed = 0LL;\n  for (i = 0LL; i < ntests; ++i) {\n    pattern = test_vector[i][1];\n    text = test_vector[i][2];\n    should_fail = test_vector[i][0] == 0LL;\n    correctlen = (int)test_vector[i][3];\n    m = re_match(pattern, text, &length);\n    if (should_fail) {\n      if (m != -1) {\n        libmin_printf(\"\\n\");\n        v3 = re_compile(pattern);\n        re_print(v3);\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i \"\n            \"chars. \\n\",\n            i + 1, ntests, pattern, text, length);\n        ++nfailed;\n      }\n    } else if (m == -1) {\n      libmin_printf(\"\\n\");\n      v4 = re_compile(pattern);\n      re_print(v4);\n      libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\",\n                    i + 1, ntests, pattern, text);\n      ++nfailed;\n    } else if (correctlen != length) {\n      libmin_printf(\n          \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \"\n          \"\\n\",\n          i + 1, ntests, pattern, length, text, correctlen);\n      ++nfailed;\n    }\n  }\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", ntests - nfailed, ntests);\n  if (!nfailed) libmin_success();\n  return nfailed;\n}", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x44,-0x20(%rbp)\nmovq   $0x0,-0x30(%rbp)\nmovq   $0x0,-0x28(%rbp)\njmp    34ae <main+0x1f5>\nmov    -0x28(%rbp),%rax\nshl    $0x5,%rax\nmov    %rax,%rdx\nlea    0x5d25(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nshl    $0x5,%rax\nmov    %rax,%rdx\nlea    0x5d13(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nshl    $0x5,%rax\nmov    %rax,%rdx\nlea    0x5ce9(%rip),%rax\nmov    (%rdx,%rax,1),%rax\ntest   %rax,%rax\nsete   %al\nmovzbl %al,%eax\nmov    %eax,-0x3c(%rbp)\nmov    -0x28(%rbp),%rax\nshl    $0x5,%rax\nmov    %rax,%rdx\nlea    0x5cdf(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmov    %eax,-0x38(%rbp)\nlea    -0x40(%rbp),%rdx\nmov    -0x10(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   21e9 <re_match>\nmov    %eax,-0x34(%rbp)\ncmpl   $0x0,-0x3c(%rbp)\nje     33f3 <main+0x13a>\ncmpl   $0xffffffff,-0x34(%rbp)\nje     34a9 <main+0x1f0>\nlea    0x2e9a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   22e1 <re_compile>\nmov    %rax,%rdi\ncall   278f <re_print>\nmov    -0x40(%rbp),%edi\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rsi\nmov    -0x10(%rbp),%rcx\nmov    -0x18(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %edi,%r9d\nmov    %rcx,%r8\nmov    %rdx,%rcx\nmov    %rax,%rdx\nlea    0x31dc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\naddq   $0x1,-0x30(%rbp)\njmp    34a9 <main+0x1f0>\ncmpl   $0xffffffff,-0x34(%rbp)\njne    3459 <main+0x1a0>\nlea    0x2e2b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   22e1 <re_compile>\nmov    %rax,%rdi\ncall   278f <re_print>\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rsi\nmov    -0x10(%rbp),%rcx\nmov    -0x18(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rcx,%r8\nmov    %rdx,%rcx\nmov    %rax,%rdx\nlea    0x31bb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\naddq   $0x1,-0x30(%rbp)\njmp    34a9 <main+0x1f0>\nmov    -0x40(%rbp),%eax\ncmp    %eax,-0x38(%rbp)\nje     34a9 <main+0x1f0>\nmov    -0x40(%rbp),%edi\nmov    -0x28(%rbp),%rax\nlea    0x1(%rax),%rsi\nmov    -0x10(%rbp),%r8\nmov    -0x18(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nsub    $0x8,%rsp\nmov    -0x38(%rbp),%ecx\npush   %rcx\nmov    %r8,%r9\nmov    %edi,%r8d\nmov    %rdx,%rcx\nmov    %rax,%rdx\nlea    0x31ad(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\nadd    $0x10,%rsp\naddq   $0x1,-0x30(%rbp)\naddq   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\ncmp    -0x20(%rbp),%rax\njb     32f1 <main+0x38>\nmov    -0x20(%rbp),%rax\nsub    -0x30(%rbp),%rax\nmov    -0x20(%rbp),%rdx\nmov    %rax,%rsi\nlea    0x31b3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\ncmpq   $0x0,-0x30(%rbp)\nje     34ec <main+0x233>\nmov    -0x30(%rbp),%rax\njmp    34f6 <main+0x23d>\ncall   58f4 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     350a <main+0x251>\ncall   20b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchalpha", "content": "static int matchalpha(char c)\n{\n  return isalpha(c);\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchalpha", "address": "0x2a94", "label": "matchalpha", "content": "int __cdecl matchalpha(char c)\n{\n  return pctype[c] & 3;\n}\n"}, "pseudo_normalize": "", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchalpha>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmov    0x7000(%rip),%rdx\nmovsbq -0x4(%rbp),%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x3,%eax\npop    %rbp\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchalphanum", "content": "static int matchalphanum(char c)\n{\n  return ((c == '_') || matchalpha(c) || matchdigit(c));\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchalphanum", "address": "0x2ae8", "label": "matchalphanum", "content": "int __cdecl matchalphanum(char c)\n{\n  return c == 95 || matchalpha(c) || matchdigit(c);\n}\n"}, "pseudo_normalize": "", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchalphanum>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x8,%rsp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\ncmpb   $0x5f,-0x4(%rbp)\nje     2b1d <matchalphanum+0x35>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2a94 <matchalpha>\ntest   %eax,%eax\njne    2b1d <matchalphanum+0x35>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2a6a <matchdigit>\ntest   %eax,%eax\nje     2b24 <matchalphanum+0x3c>\nmov    $0x1,%eax\njmp    2b29 <matchalphanum+0x41>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchcharclass", "content": "static int matchcharclass(char c, const char* str)\n{\n  do\n  {\n    if (matchrange(c, str))\n    {\n      return 1;\n    }\n    else if (str[0] == '\\\\')\n    {\n      /* Escape-char: increment str-ptr and match on next char */\n      str += 1;\n      if (matchmetachar(c, str))\n      {\n        return 1;\n      }\n      else if ((c == str[0]) && !ismetachar(c))\n      {\n        return 1;\n      }\n    }\n    else if (c == str[0])\n    {\n      if (c == '-')\n      {\n        return ((str[-1] == '\\0') || (str[1] == '\\0'));\n      }\n      else\n      {\n        return 1;\n      }\n    }\n  }\n  while (*str++ != '\\0');\n\n  return 0;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchcharclass", "address": "0x2cd9", "label": "matchcharclass", "content": "int __cdecl matchcharclass(char c, const char *str)\n{\n  const char *v3; // rax\n\n  while ( 1 )\n  {\n    if ( matchrange(c, str) )\n      return 1;\n    if ( *str == 92 )\n    {\n      if ( matchmetachar(c, ++str) )\n        return 1;\n      if ( c == *str && !ismetachar(c) )\n        return 1;\n      goto LABEL_16;\n    }\n    if ( c == *str )\n      return c != 45 || !*(str - 1) || !str[1];\nLABEL_16:\n    v3 = str++;\n    if ( !*v3 )\n      return 0;\n  }\n}\n"}, "pseudo_normalize": "int matchcharclass(char c, const char *str) {\n  const char *v3;\n  while (1) {\n    if (matchrange(c, str)) return 1;\n    if (*str == 92) {\n      if (matchmetachar(c, ++str)) return 1;\n      if (c == *str && !ismetachar(c)) return 1;\n      goto LABEL_16;\n    }\n    if (c == *str) return c != 45 || !*(str - 1) || !str[1];\n  LABEL_16:\n    v3 = str++;\n    if (!*v3) return 0;\n  }\n}", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchcharclass>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %rsi,-0x10(%rbp)\nmov    %al,-0x4(%rbp)\nmovsbl -0x4(%rbp),%eax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %eax,%edi\ncall   2b2b <matchrange>\ntest   %eax,%eax\nje     2d0e <matchcharclass+0x35>\nmov    $0x1,%eax\njmp    2dc1 <matchcharclass+0xe8>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x5c,%al\njne    2d60 <matchcharclass+0x87>\naddq   $0x1,-0x10(%rbp)\nmovsbl -0x4(%rbp),%eax\nmov    -0x10(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %eax,%edi\ncall   2bf3 <matchmetachar>\ntest   %eax,%eax\nje     2d3e <matchcharclass+0x65>\nmov    $0x1,%eax\njmp    2dc1 <matchcharclass+0xe8>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,-0x4(%rbp)\njne    2da5 <matchcharclass+0xcc>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2bb4 <ismetachar>\ntest   %eax,%eax\njne    2da5 <matchcharclass+0xcc>\nmov    $0x1,%eax\njmp    2dc1 <matchcharclass+0xe8>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,-0x4(%rbp)\njne    2da5 <matchcharclass+0xcc>\ncmpb   $0x2d,-0x4(%rbp)\njne    2d9e <matchcharclass+0xc5>\nmov    -0x10(%rbp),%rax\nsub    $0x1,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     2d90 <matchcharclass+0xb7>\nmov    -0x10(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    2d97 <matchcharclass+0xbe>\nmov    $0x1,%eax\njmp    2dc1 <matchcharclass+0xe8>\nmov    $0x0,%eax\njmp    2dc1 <matchcharclass+0xe8>\nmov    $0x1,%eax\njmp    2dc1 <matchcharclass+0xe8>\nmov    -0x10(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x10(%rbp)\nmovzbl (%rax),%eax\ntest   %al,%al\njne    2cee <matchcharclass+0x15>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchdigit", "content": "/* Private functions: */\nstatic int matchdigit(char c)\n{\n  return isdigit(c);\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchdigit", "address": "0x2a6a", "label": "matchdigit", "content": "int __cdecl matchdigit(char c)\n{\n  return pctype[c] & 4;\n}\n"}, "pseudo_normalize": "", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchdigit>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmov    0x702a(%rip),%rdx\nmovsbq -0x4(%rbp),%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x4,%eax\npop    %rbp\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchdot", "content": "static int matchdot(char c)\n{\n#if defined(RE_DOT_MATCHES_NEWLINE) && (RE_DOT_MATCHES_NEWLINE == 1)\n  (void)c;\n  return 1;\n#else\n  return c != '\\n' && c != '\\r';\n#endif\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchdot", "address": "0x2ba0", "label": "matchdot", "content": "int __cdecl matchdot(char c)\n{\n  return 1;\n}\n"}, "pseudo_normalize": "", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchdot>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmov    $0x1,%eax\npop    %rbp\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchmetachar", "content": "static int matchmetachar(char c, const char* str)\n{\n  switch (str[0])\n  {\n    case 'd': return  matchdigit(c);\n    case 'D': return !matchdigit(c);\n    case 'w': return  matchalphanum(c);\n    case 'W': return !matchalphanum(c);\n    case 's': return  matchwhitespace(c);\n    case 'S': return !matchwhitespace(c);\n    default:  return (c == str[0]);\n  }\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchmetachar", "address": "0x2bf3", "label": "matchmetachar", "content": "int __cdecl matchmetachar(char c, const char *str)\n{\n  int v2; // eax\n  int result; // eax\n\n  v2 = *str;\n  if ( v2 == 68 )\n    return matchdigit(c) == 0;\n  if ( v2 < 68 || v2 > 119 || v2 < 83 )\n    return c == *str;\n  switch ( *str )\n  {\n    case 'S':\n      result = matchwhitespace(c) == 0;\n      break;\n    case 'W':\n      result = matchalphanum(c) == 0;\n      break;\n    case 'd':\n      result = matchdigit(c);\n      break;\n    case 's':\n      result = matchwhitespace(c);\n      break;\n    case 'w':\n      result = matchalphanum(c);\n      break;\n    default:\n      return c == *str;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int matchmetachar(char c, const char *str) {\n  int v2;\n  int result;\n  v2 = *str;\n  if (v2 == 68) return matchdigit(c) == 0;\n  if (v2 < 68 || v2 > 119 || v2 < 83) return c == *str;\n  switch (*str) {\n    case 'S':\n      result = matchwhitespace(c) == 0;\n      break;\n    case 'W':\n      result = matchalphanum(c) == 0;\n      break;\n    case 'd':\n      result = matchdigit(c);\n      break;\n    case 's':\n      result = matchwhitespace(c);\n      break;\n    case 'w':\n      result = matchalphanum(c);\n      break;\n    default:\n      return c == *str;\n  }\n  return result;\n}", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchmetachar>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,%eax\nmov    %rsi,-0x10(%rbp)\nmov    %al,-0x4(%rbp)\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncmp    $0x44,%eax\nje     2c6e <matchmetachar+0x7b>\ncmp    $0x44,%eax\njl     2cc7 <matchmetachar+0xd4>\ncmp    $0x77,%eax\njg     2cc7 <matchmetachar+0xd4>\ncmp    $0x53,%eax\njl     2cc7 <matchmetachar+0xd4>\nsub    $0x53,%eax\ncmp    $0x24,%eax\nja     2cc7 <matchmetachar+0xd4>\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x35e1(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x35d5(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2a6a <matchdigit>\njmp    2cd7 <matchmetachar+0xe4>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2a6a <matchdigit>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2cd7 <matchmetachar+0xe4>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2ae8 <matchalphanum>\njmp    2cd7 <matchmetachar+0xe4>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2ae8 <matchalphanum>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2cd7 <matchmetachar+0xe4>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2abe <matchwhitespace>\njmp    2cd7 <matchmetachar+0xe4>\nmovsbl -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   2abe <matchwhitespace>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2cd7 <matchmetachar+0xe4>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,-0x4(%rbp)\nsete   %al\nmovzbl %al,%eax\nleave\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchone", "content": "static int matchone(regex_t p, char c)\n{\n  switch (p.type)\n  {\n    case DOT:            return matchdot(c);\n    case CHAR_CLASS:     return  matchcharclass(c, (const char*)p.u.ccl);\n    case INV_CHAR_CLASS: return !matchcharclass(c, (const char*)p.u.ccl);\n    case DIGIT:          return  matchdigit(c);\n    case NOT_DIGIT:      return !matchdigit(c);\n    case ALPHA:          return  matchalphanum(c);\n    case NOT_ALPHA:      return !matchalphanum(c);\n    case WHITESPACE:     return  matchwhitespace(c);\n    case NOT_WHITESPACE: return !matchwhitespace(c);\n    default:             return  (p.u.ch == c);\n  }\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchone", "address": "0x2dc3", "label": "matchone", "content": "int __cdecl matchone(regex_t p, char c)\n{\n  int result; // eax\n\n  switch ( p.type )\n  {\n    case 1u:\n      result = matchdot(c);\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 0xAu:\n      result = matchdigit(c);\n      break;\n    case 0xBu:\n      result = matchdigit(c) == 0;\n      break;\n    case 0xCu:\n      result = matchalphanum(c);\n      break;\n    case 0xDu:\n      result = matchalphanum(c) == 0;\n      break;\n    case 0xEu:\n      result = matchwhitespace(c);\n      break;\n    case 0xFu:\n      result = matchwhitespace(c) == 0;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int matchone(regex_t p, char c) {\n  int result;\n  switch (p.type) {\n    case 1u:\n      result = matchdot(c);\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 10u:\n      result = matchdigit(c);\n      break;\n    case 11u:\n      result = matchdigit(c) == 0;\n      break;\n    case 12u:\n      result = matchalphanum(c);\n      break;\n    case 13u:\n      result = matchalphanum(c) == 0;\n      break;\n    case 14u:\n      result = matchwhitespace(c);\n      break;\n    case 15u:\n      result = matchwhitespace(c) == 0;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchone>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %edi,%ecx\nmov    %rsi,%rax\nmov    %rax,%rbx\nmov    %rcx,-0x20(%rbp)\nmov    %rbx,-0x18(%rbp)\nmov    %edx,%eax\nmov    %al,-0x24(%rbp)\nmovzbl -0x20(%rbp),%eax\nmovzbl %al,%eax\ncmp    $0xf,%eax\nja     2ec1 <matchone+0xfe>\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x34be(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x34b2(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2ba0 <matchdot>\njmp    2ed4 <matchone+0x111>\nmov    -0x18(%rbp),%rdx\nmovsbl -0x24(%rbp),%eax\nmov    %rdx,%rsi\nmov    %eax,%edi\ncall   2cd9 <matchcharclass>\njmp    2ed4 <matchone+0x111>\nmov    -0x18(%rbp),%rdx\nmovsbl -0x24(%rbp),%eax\nmov    %rdx,%rsi\nmov    %eax,%edi\ncall   2cd9 <matchcharclass>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2ed4 <matchone+0x111>\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2a6a <matchdigit>\njmp    2ed4 <matchone+0x111>\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2a6a <matchdigit>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2ed4 <matchone+0x111>\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2ae8 <matchalphanum>\njmp    2ed4 <matchone+0x111>\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2ae8 <matchalphanum>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2ed4 <matchone+0x111>\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2abe <matchwhitespace>\njmp    2ed4 <matchone+0x111>\nmovsbl -0x24(%rbp),%eax\nmov    %eax,%edi\ncall   2abe <matchwhitespace>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2ed4 <matchone+0x111>\nmovzbl -0x18(%rbp),%eax\nmovzbl %al,%edx\nmovsbl -0x24(%rbp),%eax\ncmp    %eax,%edx\nsete   %al\nmovzbl %al,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchpattern", "content": "/* Iterative matching */\nstatic int matchpattern(regex_t* pattern, const char* text, int* matchlength)\n{\n  int pre = *matchlength;\n  do\n  {\n    if ((pattern[0].type == UNUSED) || (pattern[1].type == QUESTIONMARK))\n    {\n      return matchquestion(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if (pattern[1].type == STAR)\n    {\n      return matchstar(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if (pattern[1].type == PLUS)\n    {\n      return matchplus(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if ((pattern[0].type == END) && pattern[1].type == UNUSED)\n    {\n      return (text[0] == '\\0');\n    }\n/*  Branching is not working properly\n    else if (pattern[1].type == BRANCH)\n    {\n      return (matchpattern(pattern, text) || matchpattern(&pattern[2], text));\n    }\n*/\n  (*matchlength)++;\n  }\n  while ((text[0] != '\\0') && matchone(*pattern++, *text++));\n\n  *matchlength = pre;\n  return 0;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchpattern", "address": "0x313f", "label": "matchpattern", "content": "// local variable allocation has failed, the output may be wrong!\nint __cdecl matchpattern(regex_t *pattern, const char *text, int *matchlength)\n{\n  int v3; // edi OVERLAPPED\n  unsigned __int8 *ccl; // rsi\n  int v6; // edi OVERLAPPED\n  unsigned __int8 *v7; // rsi\n  int v8; // edi OVERLAPPED\n  unsigned __int8 *v9; // rsi\n  char *v10; // rax\n  char v11; // dl\n  regex_t *v12; // rax\n  int v13; // edi OVERLAPPED\n  unsigned __int8 *v14; // rsi\n  int pre; // [rsp+2Ch] [rbp-4h]\n\n  pre = *matchlength;\n  do\n  {\n    if ( !pattern->type || pattern[1].type == 4 )\n    {\n      v3 = *(_DWORD *)&pattern->type;\n      ccl = pattern->u.ccl;\n      return matchquestion(*(regex_t *)&v3, pattern + 2, text, matchlength);\n    }\n    if ( pattern[1].type == 5 )\n    {\n      v6 = *(_DWORD *)&pattern->type;\n      v7 = pattern->u.ccl;\n      return matchstar(*(regex_t *)&v6, pattern + 2, text, matchlength);\n    }\n    if ( pattern[1].type == 6 )\n    {\n      v8 = *(_DWORD *)&pattern->type;\n      v9 = pattern->u.ccl;\n      return matchplus(*(regex_t *)&v8, pattern + 2, text, matchlength);\n    }\n    if ( pattern->type == 3 && !pattern[1].type )\n      return *text == 0;\n    ++*matchlength;\n    if ( !*text )\n      break;\n    v10 = (char *)text++;\n    v11 = *v10;\n    v12 = pattern++;\n    v13 = *(_DWORD *)&v12->type;\n    v14 = v12->u.ccl;\n  }\n  while ( matchone(*(regex_t *)&v13, v11) );\n  *matchlength = pre;\n  return 0;\n}\n"}, "pseudo_normalize": "int matchpattern(regex_t *pattern, const char *text, int *matchlength) {\n  int v3;\n  unsigned char *ccl;\n  int v6;\n  unsigned char *v7;\n  int v8;\n  unsigned char *v9;\n  char *v10;\n  char v11;\n  regex_t *v12;\n  int v13;\n  unsigned char *v14;\n  int pre;\n  pre = *matchlength;\n  do {\n    if (!pattern->type || pattern[1].type == 4) {\n      v3 = *(uint32_t *)&pattern->type;\n      ccl = pattern->u.ccl;\n      return matchquestion(*(regex_t *)&v3, pattern + 2, text, matchlength);\n    }\n    if (pattern[1].type == 5) {\n      v6 = *(uint32_t *)&pattern->type;\n      v7 = pattern->u.ccl;\n      return matchstar(*(regex_t *)&v6, pattern + 2, text, matchlength);\n    }\n    if (pattern[1].type == 6) {\n      v8 = *(uint32_t *)&pattern->type;\n      v9 = pattern->u.ccl;\n      return matchplus(*(regex_t *)&v8, pattern + 2, text, matchlength);\n    }\n    if (pattern->type == 3 && !pattern[1].type) return *text == 0;\n    ++*matchlength;\n    if (!*text) break;\n    v10 = (char *)text++;\n    v11 = *v10;\n    v12 = pattern++;\n    v13 = *(uint32_t *)&v12->type;\n    v14 = v12->u.ccl;\n  } while (matchone(*(regex_t *)&v13, v11));\n  *matchlength = pre;\n  return 0;\n}", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchpattern>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     317a <matchpattern+0x3b>\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovzbl (%rax),%eax\ncmp    $0x4,%al\njne    31ac <matchpattern+0x6d>\nmov    -0x18(%rbp),%rax\nlea    0x20(%rax),%rdi\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%esi\nmov    0x8(%rax),%rax\nmov    %rcx,%r8\nmov    %rdx,%rcx\nmov    %rdi,%rdx\nmov    %esi,%edi\nmov    %rax,%rsi\ncall   3072 <matchquestion>\njmp    32b7 <matchpattern+0x178>\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovzbl (%rax),%eax\ncmp    $0x5,%al\njne    31ed <matchpattern+0xae>\nmov    -0x18(%rbp),%rax\nlea    0x20(%rax),%rdi\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%esi\nmov    0x8(%rax),%rax\nmov    %rcx,%r8\nmov    %rdx,%rcx\nmov    %rdi,%rdx\nmov    %esi,%edi\nmov    %rax,%rsi\ncall   2eda <matchstar>\njmp    32b7 <matchpattern+0x178>\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovzbl (%rax),%eax\ncmp    $0x6,%al\njne    322e <matchpattern+0xef>\nmov    -0x18(%rbp),%rax\nlea    0x20(%rax),%rdi\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    (%rax),%esi\nmov    0x8(%rax),%rax\nmov    %rcx,%r8\nmov    %rdx,%rcx\nmov    %rdi,%rdx\nmov    %esi,%edi\nmov    %rax,%rsi\ncall   2faf <matchplus>\njmp    32b7 <matchpattern+0x178>\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x3,%al\njne    3259 <matchpattern+0x11a>\nmov    -0x18(%rbp),%rax\nadd    $0x10,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    3259 <matchpattern+0x11a>\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nsete   %al\nmovzbl %al,%eax\njmp    32b7 <matchpattern+0x178>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     32a9 <matchpattern+0x16a>\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x18(%rbp),%rax\nlea    0x10(%rax),%rcx\nmov    %rcx,-0x18(%rbp)\nmov    (%rax),%ecx\nmov    0x8(%rax),%rax\nmov    %ecx,%edi\nmov    %rax,%rsi\ncall   2dc3 <matchone>\ntest   %eax,%eax\njne    3160 <matchpattern+0x21>\nmov    -0x28(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmov    %edx,(%rax)\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchplus", "content": "static int matchplus(regex_t p, regex_t* pattern, const char* text, int* matchlength)\n{\n  const char* prepoint = text;\n  while ((text[0] != '\\0') && matchone(p, *text))\n  {\n    text++;\n    (*matchlength)++;\n  }\n  while (text > prepoint)\n  {\n    if (matchpattern(pattern, text--, matchlength))\n      return 1;\n    (*matchlength)--;\n  }\n\n  return 0;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchplus", "address": "0x2faf", "label": "matchplus", "content": "int __cdecl matchplus(regex_t p, regex_t *pattern, const char *text, int *matchlength)\n{\n  const char *v4; // rax\n  char *texta; // [rsp+10h] [rbp-30h]\n  unsigned __int8 pa; // [rsp+20h] [rbp-20h]\n  unsigned __int8 *p_8; // [rsp+28h] [rbp-18h]\n  regex_t v12; // 0:di.1,8:rsi.8\n\n  pa = p.type;\n  p_8 = p.u.ccl;\n  for ( texta = (char *)text; *texta; ++texta )\n  {\n    v12.type = pa;\n    v12.u.ccl = p_8;\n    if ( !matchone(v12, *texta) )\n      break;\n    ++*matchlength;\n  }\n  while ( texta > text )\n  {\n    v4 = texta--;\n    if ( matchpattern(pattern, v4, matchlength) )\n      return 1;\n    --*matchlength;\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int matchplus(regex_t p, regex_t *pattern, const char *text, int *matchlength) {\n  const char *v4;\n  char *texta;\n  unsigned char pa;\n  unsigned char *p_8;\n  regex_t v12;\n  pa = p.type;\n  p_8 = p.u.ccl;\n  for (texta = (char *)text; *texta; ++texta) {\n    v12.type = pa;\n    v12.u.ccl = p_8;\n    if (!matchone(v12, *texta)) break;\n    ++*matchlength;\n  }\n  while (texta > text) {\n    v4 = texta--;\n    if (matchpattern(pattern, v4, matchlength)) return 1;\n    --*matchlength;\n  }\n  return 0;\n}", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchplus>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rsi,%rax\nmov    %edi,%r9d\nmov    %r9,%rsi\nmov    %r10,%rdi\nmov    %rax,%rdi\nmov    %rsi,-0x20(%rbp)\nmov    %rdi,-0x18(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmov    %r8,-0x38(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    2ffc <matchplus+0x4d>\naddq   $0x1,-0x30(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     3061 <matchplus+0xb2>\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x20(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,%edi\nmov    %rax,%rsi\ncall   2dc3 <matchone>\ntest   %eax,%eax\njne    2fe8 <matchplus+0x39>\njmp    3061 <matchplus+0xb2>\nmov    -0x30(%rbp),%rax\nlea    -0x1(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    -0x28(%rbp),%rcx\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   313f <matchpattern>\ntest   %eax,%eax\nje     3052 <matchplus+0xa3>\nmov    $0x1,%eax\njmp    3070 <matchplus+0xc1>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nlea    -0x1(%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%rax\ncmp    -0x8(%rbp),%rax\nja     3028 <matchplus+0x79>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchquestion", "content": "static int matchquestion(regex_t p, regex_t* pattern, const char* text, int* matchlength)\n{\n  if (p.type == UNUSED)\n    return 1;\n  if (matchpattern(pattern, text, matchlength))\n      return 1;\n  if (*text && matchone(p, *text++))\n  {\n    if (matchpattern(pattern, text, matchlength))\n    {\n      (*matchlength)++;\n      return 1;\n    }\n  }\n  return 0;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchquestion", "address": "0x3072", "label": "matchquestion", "content": "int __cdecl matchquestion(regex_t p, regex_t *pattern, const char *text, int *matchlength)\n{\n  char *v5; // rax\n  const char *textb; // [rsp+10h] [rbp-20h]\n\n  if ( !p.type )\n    return 1;\n  if ( matchpattern(pattern, text, matchlength) )\n    return 1;\n  if ( !*text )\n    return 0;\n  v5 = (char *)text;\n  textb = text + 1;\n  if ( !matchone(p, *v5) || !matchpattern(pattern, textb, matchlength) )\n    return 0;\n  ++*matchlength;\n  return 1;\n}\n"}, "pseudo_normalize": "int matchquestion(regex_t p, regex_t *pattern, const char *text,\n                  int *matchlength) {\n  char *v5;\n  const char *textb;\n  if (!p.type) return 1;\n  if (matchpattern(pattern, text, matchlength)) return 1;\n  if (!*text) return 0;\n  v5 = (char *)text;\n  textb = text + 1;\n  if (!matchone(p, *v5) || !matchpattern(pattern, textb, matchlength)) return 0;\n  ++*matchlength;\n  return 1;\n}", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchquestion>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rsi,%rax\nmov    %edi,%r9d\nmov    %r9,%rsi\nmov    %r10,%rdi\nmov    %rax,%rdi\nmov    %rsi,-0x10(%rbp)\nmov    %rdi,-0x8(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    %rcx,-0x20(%rbp)\nmov    %r8,-0x28(%rbp)\nmovzbl -0x10(%rbp),%eax\ntest   %al,%al\njne    30b3 <matchquestion+0x41>\nmov    $0x1,%eax\njmp    313d <matchquestion+0xcb>\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   313f <matchpattern>\ntest   %eax,%eax\nje     30d5 <matchquestion+0x63>\nmov    $0x1,%eax\njmp    313d <matchquestion+0xcb>\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     3138 <matchquestion+0xc6>\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x10(%rbp),%ecx\nmov    -0x8(%rbp),%rax\nmov    %ecx,%edi\nmov    %rax,%rsi\ncall   2dc3 <matchone>\ntest   %eax,%eax\nje     3138 <matchquestion+0xc6>\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   313f <matchpattern>\ntest   %eax,%eax\nje     3138 <matchquestion+0xc6>\nmov    -0x28(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x28(%rbp),%rax\nmov    %edx,(%rax)\nmov    $0x1,%eax\njmp    313d <matchquestion+0xcb>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchrange", "content": "static int matchrange(char c, const char* str)\n{\n  return (    (c != '-')\n           && (str[0] != '\\0')\n           && (str[0] != '-')\n           && (str[1] == '-')\n           && (str[2] != '\\0')\n           && (    (c >= str[0])\n                && (c <= str[2])));\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchrange", "address": "0x2b2b", "label": "matchrange", "content": "int __cdecl matchrange(char c, const char *str)\n{\n  return c != 45 && *str && *str != 45 && str[1] == 45 && str[2] && c >= *str && c <= str[2];\n}\n"}, "pseudo_normalize": "", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchrange>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %rsi,-0x10(%rbp)\nmov    %al,-0x4(%rbp)\ncmpb   $0x2d,-0x4(%rbp)\nje     2b99 <matchrange+0x6e>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     2b99 <matchrange+0x6e>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\nje     2b99 <matchrange+0x6e>\nmov    -0x10(%rbp),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\njne    2b99 <matchrange+0x6e>\nmov    -0x10(%rbp),%rax\nadd    $0x2,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     2b99 <matchrange+0x6e>\nmov    -0x10(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    %al,-0x4(%rbp)\njl     2b99 <matchrange+0x6e>\nmov    -0x10(%rbp),%rax\nadd    $0x2,%rax\nmovzbl (%rax),%eax\ncmp    %al,-0x4(%rbp)\njg     2b99 <matchrange+0x6e>\nmov    $0x1,%eax\njmp    2b9e <matchrange+0x73>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchstar", "content": "static int matchstar(regex_t p, regex_t* pattern, const char* text, int* matchlength)\n{\n  int prelen = *matchlength;\n  const char* prepoint = text;\n  while ((text[0] != '\\0') && matchone(p, *text))\n  {\n    text++;\n    (*matchlength)++;\n  }\n  while (text >= prepoint)\n  {\n    if (matchpattern(pattern, text--, matchlength))\n      return 1;\n    (*matchlength)--;\n  }\n\n  *matchlength = prelen;\n  return 0;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchstar", "address": "0x2eda", "label": "matchstar", "content": "int __cdecl matchstar(regex_t p, regex_t *pattern, const char *text, int *matchlength)\n{\n  const char *v4; // rax\n  char *texta; // [rsp+10h] [rbp-30h]\n  unsigned __int8 pa; // [rsp+20h] [rbp-20h]\n  unsigned __int8 *p_8; // [rsp+28h] [rbp-18h]\n  int prelen; // [rsp+34h] [rbp-Ch]\n  regex_t v13; // 0:di.1,8:rsi.8\n\n  pa = p.type;\n  p_8 = p.u.ccl;\n  texta = (char *)text;\n  prelen = *matchlength;\n  while ( *texta )\n  {\n    v13.type = pa;\n    v13.u.ccl = p_8;\n    if ( !matchone(v13, *texta) )\n      break;\n    ++texta;\n    ++*matchlength;\n  }\n  while ( texta >= text )\n  {\n    v4 = texta--;\n    if ( matchpattern(pattern, v4, matchlength) )\n      return 1;\n    --*matchlength;\n  }\n  *matchlength = prelen;\n  return 0;\n}\n"}, "pseudo_normalize": "int matchstar(regex_t p, regex_t *pattern, const char *text, int *matchlength) {\n  const char *v4;\n  char *texta;\n  unsigned char pa;\n  unsigned char *p_8;\n  int prelen;\n  regex_t v13;\n  pa = p.type;\n  p_8 = p.u.ccl;\n  texta = (char *)text;\n  prelen = *matchlength;\n  while (*texta) {\n    v13.type = pa;\n    v13.u.ccl = p_8;\n    if (!matchone(v13, *texta)) break;\n    ++texta;\n    ++*matchlength;\n  }\n  while (texta >= text) {\n    v4 = texta--;\n    if (matchpattern(pattern, v4, matchlength)) return 1;\n    --*matchlength;\n  }\n  *matchlength = prelen;\n  return 0;\n}", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchstar>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rsi,%rax\nmov    %edi,%r9d\nmov    %r9,%rsi\nmov    %r10,%rdi\nmov    %rax,%rdi\nmov    %rsi,-0x20(%rbp)\nmov    %rdi,-0x18(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    %rcx,-0x30(%rbp)\nmov    %r8,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,-0x8(%rbp)\njmp    2f30 <matchstar+0x56>\naddq   $0x1,-0x30(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nlea    0x1(%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     2f95 <matchstar+0xbb>\nmov    -0x30(%rbp),%rax\nmovzbl (%rax),%eax\nmovsbl %al,%edx\nmov    -0x20(%rbp),%ecx\nmov    -0x18(%rbp),%rax\nmov    %ecx,%edi\nmov    %rax,%rsi\ncall   2dc3 <matchone>\ntest   %eax,%eax\njne    2f1c <matchstar+0x42>\njmp    2f95 <matchstar+0xbb>\nmov    -0x30(%rbp),%rax\nlea    -0x1(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    -0x28(%rbp),%rcx\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   313f <matchpattern>\ntest   %eax,%eax\nje     2f86 <matchstar+0xac>\nmov    $0x1,%eax\njmp    2fad <matchstar+0xd3>\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\nlea    -0x1(%rax),%edx\nmov    -0x38(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x30(%rbp),%rax\ncmp    -0x8(%rbp),%rax\njae    2f5c <matchstar+0x82>\nmov    -0x38(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmov    %edx,(%rax)\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchwhitespace", "content": "static int matchwhitespace(char c)\n{\n  return isspace(c);\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "matchwhitespace", "address": "0x2abe", "label": "matchwhitespace", "content": "int __cdecl matchwhitespace(char c)\n{\n  return pctype[c] & 8;\n}\n"}, "pseudo_normalize": "", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<matchwhitespace>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,%eax\nmov    %al,-0x4(%rbp)\nmov    0x6fd6(%rip),%rdx\nmovsbq -0x4(%rbp),%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nmovzwl (%rax),%eax\nmovzwl %ax,%eax\nand    $0x8,%eax\npop    %rbp\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "re_compile", "content": "re_t re_compile(const char* pattern)\n{\n  /* The sizes of the two static arrays below substantiates the static RAM usage of this module.\n     MAX_REGEXP_OBJECTS is the max number of symbols in the expression.\n     MAX_CHAR_CLASS_LEN determines the size of buffer for chars in all char-classes in the expression. */\n  static regex_t re_compiled[MAX_REGEXP_OBJECTS];\n  static unsigned char ccl_buf[MAX_CHAR_CLASS_LEN];\n  int ccl_bufidx = 1;\n\n  char c;     /* current char in pattern   */\n  int i = 0;  /* index into pattern        */\n  int j = 0;  /* index into re_compiled    */\n\n  while (pattern[i] != '\\0' && (j+1 < MAX_REGEXP_OBJECTS))\n  {\n    c = pattern[i];\n\n    switch (c)\n    {\n      /* Meta-characters: */\n      case '^': {    re_compiled[j].type = BEGIN;           } break;\n      case '$': {    re_compiled[j].type = END;             } break;\n      case '.': {    re_compiled[j].type = DOT;             } break;\n      case '*': {    re_compiled[j].type = STAR;            } break;\n      case '+': {    re_compiled[j].type = PLUS;            } break;\n      case '?': {    re_compiled[j].type = QUESTIONMARK;    } break;\n/*    case '|': {    re_compiled[j].type = BRANCH;          } break; <-- not working properly */\n\n      /* Escaped character-classes (\\s \\w ...): */\n      case '\\\\':\n      {\n        if (pattern[i+1] != '\\0')\n        {\n          /* Skip the escape-char '\\\\' */\n          i += 1;\n          /* ... and check the next */\n          switch (pattern[i])\n          {\n            /* Meta-character: */\n            case 'd': {    re_compiled[j].type = DIGIT;            } break;\n            case 'D': {    re_compiled[j].type = NOT_DIGIT;        } break;\n            case 'w': {    re_compiled[j].type = ALPHA;            } break;\n            case 'W': {    re_compiled[j].type = NOT_ALPHA;        } break;\n            case 's': {    re_compiled[j].type = WHITESPACE;       } break;\n            case 'S': {    re_compiled[j].type = NOT_WHITESPACE;   } break;\n\n            /* Escaped character, e.g. '.' or '$' */\n            default:\n            {\n              re_compiled[j].type = CHAR;\n              re_compiled[j].u.ch = pattern[i];\n            } break;\n          }\n        }\n        /* '\\\\' as last char in pattern -> invalid regular expression. */\n/*\n        else\n        {\n          re_compiled[j].type = CHAR;\n          re_compiled[j].ch = pattern[i];\n        }\n*/\n      } break;\n\n      /* Character class: */\n      case '[':\n      {\n        /* Remember where the char-buffer starts. */\n        int buf_begin = ccl_bufidx;\n\n        /* Look-ahead to determine if negated */\n        if (pattern[i+1] == '^')\n        {\n          re_compiled[j].type = INV_CHAR_CLASS;\n          i += 1; /* Increment i to avoid including '^' in the char-buffer */\n          if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '^' */\n          {\n            return 0;\n          }\n        }\n        else\n        {\n          re_compiled[j].type = CHAR_CLASS;\n        }\n\n        /* Copy characters inside [..] to buffer */\n        while (    (pattern[++i] != ']')\n                && (pattern[i]   != '\\0')) /* Missing ] */\n        {\n          if (pattern[i] == '\\\\')\n          {\n            if (ccl_bufidx >= MAX_CHAR_CLASS_LEN - 1)\n            {\n              //fputs(\"exceeded internal buffer!\\n\", stderr);\n              return 0;\n            }\n            if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '\\\\' */\n            {\n              return 0;\n            }\n            ccl_buf[ccl_bufidx++] = pattern[i++];\n          }\n          else if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)\n          {\n              //fputs(\"exceeded internal buffer!\\n\", stderr);\n              return 0;\n          }\n          ccl_buf[ccl_bufidx++] = pattern[i];\n        }\n        if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)\n        {\n            /* Catches cases such as [00000000000000000000000000000000000000][ */\n            //fputs(\"exceeded internal buffer!\\n\", stderr);\n            return 0;\n        }\n        /* Null-terminate string end */\n        ccl_buf[ccl_bufidx++] = 0;\n        re_compiled[j].u.ccl = &ccl_buf[buf_begin];\n      } break;\n\n      /* Other characters: */\n      default:\n      {\n        re_compiled[j].type = CHAR;\n        re_compiled[j].u.ch = c;\n      } break;\n    }\n    /* no buffer-out-of-bounds access on invalid patterns - see https://github.com/kokke/tiny-regex-c/commit/1a279e04014b70b0695fba559a7c05d55e6ee90b */\n    if (pattern[i] == 0)\n    {\n      return 0;\n    }\n\n    i += 1;\n    j += 1;\n  }\n  /* 'UNUSED' is a sentinel used to indicate end-of-pattern */\n  re_compiled[j].type = UNUSED;\n\n  return (re_t) re_compiled;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "re_compile", "address": "0x22e1", "label": "re_compile", "content": "re_t __cdecl re_compile(const char *pattern)\n{\n  int v1; // eax\n  int v3; // eax\n  unsigned __int8 v4; // cl\n  int v5; // eax\n  int v6; // eax\n  int v7; // eax\n  char c; // [rsp+17h] [rbp-11h]\n  int ccl_bufidx; // [rsp+18h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-Ch]\n  int j; // [rsp+20h] [rbp-8h]\n  int buf_begin; // [rsp+24h] [rbp-4h]\n\n  ccl_bufidx = 1;\n  i = 0;\n  for ( j = 0; pattern[i] && j <= 28; ++j )\n  {\n    c = pattern[i];\n    switch ( c )\n    {\n      case '$':\n        re_compiled_1[j].type = 3;\n        goto LABEL_42;\n      case '*':\n        re_compiled_1[j].type = 5;\n        goto LABEL_42;\n      case '+':\n        re_compiled_1[j].type = 6;\n        goto LABEL_42;\n      case '.':\n        re_compiled_1[j].type = 1;\n        goto LABEL_42;\n      case '?':\n        re_compiled_1[j].type = 4;\n        goto LABEL_42;\n      case '[':\n        buf_begin = ccl_bufidx;\n        if ( pattern[i + 1] != 94 )\n        {\n          re_compiled_1[j].type = 8;\n          break;\n        }\n        re_compiled_1[j].type = 9;\n        if ( !pattern[++i + 1] )\n          return 0LL;\n        break;\n      case '\\\\':\n        if ( pattern[i + 1] )\n        {\n          v1 = pattern[++i];\n          if ( v1 == 68 )\n          {\n            re_compiled_1[j].type = 11;\n          }\n          else if ( v1 < 68 || v1 > 119 || v1 < 83 )\n          {\nLABEL_21:\n            re_compiled_1[j].type = 7;\n            re_compiled_1[j].u.ch = pattern[i];\n          }\n          else\n          {\n            switch ( pattern[i] )\n            {\n              case 'S':\n                re_compiled_1[j].type = 15;\n                break;\n              case 'W':\n                re_compiled_1[j].type = 13;\n                break;\n              case 'd':\n                re_compiled_1[j].type = 10;\n                break;\n              case 's':\n                re_compiled_1[j].type = 14;\n                break;\n              case 'w':\n                re_compiled_1[j].type = 12;\n                break;\n              default:\n                goto LABEL_21;\n            }\n          }\n        }\n        goto LABEL_42;\n      case '^':\n        re_compiled_1[j].type = 2;\n        goto LABEL_42;\n      default:\n        re_compiled_1[j].type = 7;\n        re_compiled_1[j].u.ch = c;\n        goto LABEL_42;\n    }\n    while ( pattern[++i] != 93 && pattern[i] )\n    {\n      if ( pattern[i] == 92 )\n      {\n        if ( ccl_bufidx > 38 )\n          return 0LL;\n        if ( !pattern[i + 1] )\n          return 0LL;\n        v3 = i++;\n        v4 = pattern[v3];\n        v5 = ccl_bufidx++;\n        ccl_buf_0[v5] = v4;\n      }\n      else if ( ccl_bufidx > 39 )\n      {\n        return 0LL;\n      }\n      v6 = ccl_bufidx++;\n      ccl_buf_0[v6] = pattern[i];\n    }\n    if ( ccl_bufidx > 39 )\n      return 0LL;\n    v7 = ccl_bufidx++;\n    ccl_buf_0[v7] = 0;\n    re_compiled_1[j].u.ccl = &ccl_buf_0[buf_begin];\nLABEL_42:\n    if ( !pattern[i] )\n      return 0LL;\n    ++i;\n  }\n  re_compiled_1[j].type = 0;\n  return re_compiled_1;\n}\n"}, "pseudo_normalize": "re_t re_compile(const char *pattern) {\n  int v1;\n  int v3;\n  unsigned char v4;\n  int v5;\n  int v6;\n  int v7;\n  char c;\n  int ccl_bufidx;\n  int i;\n  int j;\n  int buf_begin;\n  ccl_bufidx = 1;\n  i = 0;\n  for (j = 0; pattern[i] && j <= 28; ++j) {\n    c = pattern[i];\n    switch (c) {\n      case '$':\n        re_compiled_1[j].type = 3;\n        goto LABEL_42;\n      case '*':\n        re_compiled_1[j].type = 5;\n        goto LABEL_42;\n      case '+':\n        re_compiled_1[j].type = 6;\n        goto LABEL_42;\n      case '.':\n        re_compiled_1[j].type = 1;\n        goto LABEL_42;\n      case '?':\n        re_compiled_1[j].type = 4;\n        goto LABEL_42;\n      case '[':\n        buf_begin = ccl_bufidx;\n        if (pattern[i + 1] != 94) {\n          re_compiled_1[j].type = 8;\n          break;\n        }\n        re_compiled_1[j].type = 9;\n        if (!pattern[++i + 1]) return 0LL;\n        break;\n      case '\\\\':\n        if (pattern[i + 1]) {\n          v1 = pattern[++i];\n          if (v1 == 68) {\n            re_compiled_1[j].type = 11;\n          } else if (v1 < 68 || v1 > 119 || v1 < 83) {\n          LABEL_21:\n            re_compiled_1[j].type = 7;\n            re_compiled_1[j].u.ch = pattern[i];\n          } else {\n            switch (pattern[i]) {\n              case 'S':\n                re_compiled_1[j].type = 15;\n                break;\n              case 'W':\n                re_compiled_1[j].type = 13;\n                break;\n              case 'd':\n                re_compiled_1[j].type = 10;\n                break;\n              case 's':\n                re_compiled_1[j].type = 14;\n                break;\n              case 'w':\n                re_compiled_1[j].type = 12;\n                break;\n              default:\n                goto LABEL_21;\n            }\n          }\n        }\n        goto LABEL_42;\n      case '^':\n        re_compiled_1[j].type = 2;\n        goto LABEL_42;\n      default:\n        re_compiled_1[j].type = 7;\n        re_compiled_1[j].u.ch = c;\n        goto LABEL_42;\n    }\n    while (pattern[++i] != 93 && pattern[i]) {\n      if (pattern[i] == 92) {\n        if (ccl_bufidx > 38) return 0LL;\n        if (!pattern[i + 1]) return 0LL;\n        v3 = i++;\n        v4 = pattern[v3];\n        v5 = ccl_bufidx++;\n        ccl_buf_0[v5] = v4;\n      } else if (ccl_bufidx > 39) {\n        return 0LL;\n      }\n      v6 = ccl_bufidx++;\n      ccl_buf_0[v6] = pattern[i];\n    }\n    if (ccl_bufidx > 39) return 0LL;\n    v7 = ccl_bufidx++;\n    ccl_buf_0[v7] = 0;\n    re_compiled_1[j].u.ccl = &ccl_buf_0[buf_begin];\n  LABEL_42:\n    if (!pattern[i]) return 0LL;\n    ++i;\n  }\n  re_compiled_1[j].type = 0;\n  return re_compiled_1;\n}", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<re_compile>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x1,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    2751 <re_compile+0x470>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x11(%rbp)\nmovsbl -0x11(%rbp),%eax\nsub    $0x24,%eax\ncmp    $0x3a,%eax\nja     26f9 <re_compile+0x418>\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x3ccd(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x3cc1(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x77a0(%rip),%rax\nmovb   $0x2,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7784(%rip),%rax\nmovb   $0x3,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7768(%rip),%rax\nmovb   $0x1,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x774c(%rip),%rax\nmovb   $0x5,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7730(%rip),%rax\nmovb   $0x6,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7714(%rip),%rax\nmovb   $0x4,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     272d <re_compile+0x44c>\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncmp    $0x44,%eax\nje     2492 <re_compile+0x1b1>\ncmp    $0x44,%eax\njl     2515 <re_compile+0x234>\ncmp    $0x77,%eax\njg     2515 <re_compile+0x234>\ncmp    $0x53,%eax\njl     2515 <re_compile+0x234>\nsub    $0x53,%eax\ncmp    $0x24,%eax\nja     2515 <re_compile+0x234>\nmov    %eax,%eax\nlea    0x0(,%rax,4),%rdx\nlea    0x3c90(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncltq\nlea    0x3c84(%rip),%rdx\nadd    %rdx,%rax\nnotrack jmp *%rax\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7677(%rip),%rax\nmovb   $0xa,(%rdx,%rax,1)\njmp    2555 <re_compile+0x274>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x765b(%rip),%rax\nmovb   $0xb,(%rdx,%rax,1)\njmp    2555 <re_compile+0x274>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x763f(%rip),%rax\nmovb   $0xc,(%rdx,%rax,1)\njmp    2555 <re_compile+0x274>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7623(%rip),%rax\nmovb   $0xd,(%rdx,%rax,1)\njmp    2555 <re_compile+0x274>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x760a(%rip),%rax\nmovb   $0xe,(%rdx,%rax,1)\njmp    2555 <re_compile+0x274>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x75f1(%rip),%rax\nmovb   $0xf,(%rdx,%rax,1)\njmp    2555 <re_compile+0x274>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x75d8(%rip),%rax\nmovb   $0x7,(%rdx,%rax,1)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %eax,%ecx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x75b7(%rip),%rax\nmov    %cl,(%rdx,%rax,1)\nnop\njmp    272d <re_compile+0x44c>\nmov    -0x10(%rbp),%eax\nmov    %eax,-0x4(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5e,%al\njne    25b7 <re_compile+0x2d6>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7576(%rip),%rax\nmovb   $0x9,(%rdx,%rax,1)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    267a <re_compile+0x399>\nmov    $0x0,%eax\njmp    278d <re_compile+0x4ac>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7536(%rip),%rax\nmovb   $0x8,(%rdx,%rax,1)\njmp    267a <re_compile+0x399>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5c,%al\njne    2645 <re_compile+0x364>\ncmpl   $0x26,-0x10(%rbp)\njle    25f7 <re_compile+0x316>\nmov    $0x0,%eax\njmp    278d <re_compile+0x4ac>\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x1(%rax),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    2618 <re_compile+0x337>\nmov    $0x0,%eax\njmp    278d <re_compile+0x4ac>\nmov    -0xc(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0xc(%rbp)\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x76a0(%rip),%rdx\nmov    %cl,(%rax,%rdx,1)\njmp    2655 <re_compile+0x374>\ncmpl   $0x27,-0x10(%rbp)\njle    2655 <re_compile+0x374>\nmov    $0x0,%eax\njmp    278d <re_compile+0x4ac>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%ecx\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x7669(%rip),%rdx\nmov    %cl,(%rax,%rdx,1)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x5d,%al\nje     26aa <re_compile+0x3c9>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    25d3 <re_compile+0x2f2>\ncmpl   $0x27,-0x10(%rbp)\njle    26ba <re_compile+0x3d9>\nmov    $0x0,%eax\njmp    278d <re_compile+0x4ac>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x7614(%rip),%rdx\nmovb   $0x0,(%rax,%rdx,1)\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x7604(%rip),%rdx\nlea    (%rax,%rdx,1),%rcx\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x7415(%rip),%rax\nmov    %rcx,(%rdx,%rax,1)\njmp    272e <re_compile+0x44d>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x73f4(%rip),%rax\nmovb   $0x7,(%rdx,%rax,1)\nmovzbl -0x11(%rbp),%eax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rdx\nmov    %rdx,%rcx\nshl    $0x4,%rcx\nlea    0x73e0(%rip),%rdx\nmov    %al,(%rcx,%rdx,1)\njmp    272e <re_compile+0x44d>\nnop\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    2749 <re_compile+0x468>\nmov    $0x0,%eax\njmp    278d <re_compile+0x4ac>\naddl   $0x1,-0xc(%rbp)\naddl   $0x1,-0x8(%rbp)\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     276f <re_compile+0x48e>\ncmpl   $0x1c,-0x8(%rbp)\njle    2307 <re_compile+0x26>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x737e(%rip),%rax\nmovb   $0x0,(%rdx,%rax,1)\nlea    0x7373(%rip),%rax\npop    %rbp\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "re_match", "content": "/* Public functions: */\nint re_match(const char* pattern, const char* text, int* matchlength)\n{\n  return re_matchp(re_compile(pattern), text, matchlength);\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "re_match", "address": "0x21e9", "label": "re_match", "content": "int __cdecl re_match(const char *pattern, const char *text, int *matchlength)\n{\n  regex_t *v3; // rcx\n\n  v3 = re_compile(pattern);\n  return re_matchp(v3, text, matchlength);\n}\n"}, "pseudo_normalize": "", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<re_match>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   22e1 <re_compile>\nmov    %rax,%rcx\nmov    -0x18(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   2225 <re_matchp>\nleave\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "re_matchp", "content": "int re_matchp(re_t pattern, const char* text, int* matchlength)\n{\n  *matchlength = 0;\n  if (pattern != 0)\n  {\n    if (pattern[0].type == BEGIN)\n    {\n      return ((matchpattern(&pattern[1], text, matchlength)) ? 0 : -1);\n    }\n    else\n    {\n      int idx = -1;\n\n      do\n      {\n        idx += 1;\n\n        if (matchpattern(pattern, text, matchlength))\n        {\n          if (text[0] == '\\0')\n            return -1;\n\n          return idx;\n        }\n      }\n      while (*text++ != '\\0');\n    }\n  }\n  return -1;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "re_matchp", "address": "0x2225", "label": "re_matchp", "content": "int __cdecl re_matchp(re_t pattern, const char *text, int *matchlength)\n{\n  const char *v4; // rax\n  const char *texta; // [rsp+10h] [rbp-20h]\n  int idx; // [rsp+2Ch] [rbp-4h]\n\n  texta = text;\n  *matchlength = 0;\n  if ( !pattern )\n    return -1;\n  if ( pattern->type == 2 )\n  {\n    if ( matchpattern(pattern + 1, text, matchlength) )\n      return 0;\n    else\n      return -1;\n  }\n  else\n  {\n    idx = -1;\n    while ( 1 )\n    {\n      ++idx;\n      if ( matchpattern(pattern, texta, matchlength) )\n        break;\n      v4 = texta++;\n      if ( !*v4 )\n        return -1;\n    }\n    if ( *texta )\n      return idx;\n    else\n      return -1;\n  }\n}\n"}, "pseudo_normalize": "int re_matchp(re_t pattern, const char *text, int *matchlength) {\n  const char *v4;\n  const char *texta;\n  int idx;\n  texta = text;\n  *matchlength = 0;\n  if (!pattern) return -1;\n  if (pattern->type == 2) {\n    if (matchpattern(pattern + 1, text, matchlength))\n      return 0;\n    else\n      return -1;\n  } else {\n    idx = -1;\n    while (1) {\n      ++idx;\n      if (matchpattern(pattern, texta, matchlength)) break;\n      v4 = texta++;\n      if (!*v4) return -1;\n    }\n    if (*texta)\n      return idx;\n    else\n      return -1;\n  }\n}", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<re_matchp>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovl   $0x0,(%rax)\ncmpq   $0x0,-0x18(%rbp)\nje     22da <re_matchp+0xb5>\nmov    -0x18(%rbp),%rax\nmovzbl (%rax),%eax\ncmp    $0x2,%al\njne    228a <re_matchp+0x65>\nmov    -0x18(%rbp),%rax\nlea    0x10(%rax),%rcx\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   313f <matchpattern>\ntest   %eax,%eax\nje     2283 <re_matchp+0x5e>\nmov    $0x0,%eax\njmp    22df <re_matchp+0xba>\nmov    $0xffffffff,%eax\njmp    22df <re_matchp+0xba>\nmovl   $0xffffffff,-0x4(%rbp)\naddl   $0x1,-0x4(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   313f <matchpattern>\ntest   %eax,%eax\nje     22c7 <re_matchp+0xa2>\nmov    -0x20(%rbp),%rax\nmovzbl (%rax),%eax\ntest   %al,%al\njne    22c2 <re_matchp+0x9d>\nmov    $0xffffffff,%eax\njmp    22df <re_matchp+0xba>\nmov    -0x4(%rbp),%eax\njmp    22df <re_matchp+0xba>\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nmovzbl (%rax),%eax\ntest   %al,%al\njne    2291 <re_matchp+0x6c>\nmov    $0xffffffff,%eax\nleave\nret\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "re_print", "content": "void re_print(regex_t* pattern)\n{\n  const char* types[] = { \"UNUSED\", \"DOT\", \"BEGIN\", \"END\", \"QUESTIONMARK\", \"STAR\", \"PLUS\", \"CHAR\", \"CHAR_CLASS\", \"INV_CHAR_CLASS\", \"DIGIT\", \"NOT_DIGIT\", \"ALPHA\", \"NOT_ALPHA\", \"WHITESPACE\", \"NOT_WHITESPACE\", \"BRANCH\" };\n\n  int i;\n  int j;\n  char c;\n  for (i = 0; i < MAX_REGEXP_OBJECTS; ++i)\n  {\n    if (pattern[i].type == UNUSED)\n    {\n      break;\n    }\n\n    libmin_printf(\"type: %s\", types[pattern[i].type]);\n    if (pattern[i].type == CHAR_CLASS || pattern[i].type == INV_CHAR_CLASS)\n    {\n      libmin_printf(\" [\");\n      for (j = 0; j < MAX_CHAR_CLASS_LEN; ++j)\n      {\n        c = pattern[i].u.ccl[j];\n        if ((c == '\\0') || (c == ']'))\n        {\n          break;\n        }\n        libmin_printf(\"%c\", c);\n      }\n      libmin_printf(\"]\");\n    }\n    else if (pattern[i].type == CHAR)\n    {\n      libmin_printf(\" '%c'\", pattern[i].u.ch);\n    }\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O0.pseudo", "function_name": "re_print", "address": "0x278f", "label": "re_print", "content": "void __cdecl re_print(regex_t *pattern)\n{\n  char c; // [rsp+17h] [rbp-99h]\n  int i; // [rsp+18h] [rbp-98h]\n  int j; // [rsp+1Ch] [rbp-94h]\n  const char *types[17]; // [rsp+20h] [rbp-90h]\n  unsigned __int64 v5; // [rsp+A8h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  types[0] = \"UNUSED\";\n  types[1] = \"DOT\";\n  types[2] = \"BEGIN\";\n  types[3] = \"END\";\n  types[4] = \"QUESTIONMARK\";\n  types[5] = \"STAR\";\n  types[6] = \"PLUS\";\n  types[7] = \"CHAR\";\n  types[8] = \"CHAR_CLASS\";\n  types[9] = \"INV_CHAR_CLASS\";\n  types[10] = \"DIGIT\";\n  types[11] = \"NOT_DIGIT\";\n  types[12] = \"ALPHA\";\n  types[13] = \"NOT_ALPHA\";\n  types[14] = \"WHITESPACE\";\n  types[15] = \"NOT_WHITESPACE\";\n  types[16] = \"BRANCH\";\n  for ( i = 0; i <= 29 && pattern[i].type; ++i )\n  {\n    libmin_printf(\"type: %s\", types[pattern[i].type]);\n    if ( pattern[i].type == 8 || pattern[i].type == 9 )\n    {\n      libmin_printf(\" [\");\n      for ( j = 0; j <= 39; ++j )\n      {\n        c = pattern[i].u.ccl[j];\n        if ( !c || c == 93 )\n          break;\n        libmin_printf(\"%c\", (unsigned int)c);\n      }\n      libmin_printf(\"]\");\n    }\n    else if ( pattern[i].type == 7 )\n    {\n      libmin_printf(\" '%c'\", pattern[i].u.ch);\n    }\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo_normalize": "void re_print(regex_t *pattern) {\n  char c;\n  int i;\n  int j;\n  const char *types[17];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  types[0] = \"UNUSED\";\n  types[1] = \"DOT\";\n  types[2] = \"BEGIN\";\n  types[3] = \"END\";\n  types[4] = \"QUESTIONMARK\";\n  types[5] = \"STAR\";\n  types[6] = \"PLUS\";\n  types[7] = \"CHAR\";\n  types[8] = \"CHAR_CLASS\";\n  types[9] = \"INV_CHAR_CLASS\";\n  types[10] = \"DIGIT\";\n  types[11] = \"NOT_DIGIT\";\n  types[12] = \"ALPHA\";\n  types[13] = \"NOT_ALPHA\";\n  types[14] = \"WHITESPACE\";\n  types[15] = \"NOT_WHITESPACE\";\n  types[16] = \"BRANCH\";\n  for (i = 0; i <= 29 && pattern[i].type; ++i) {\n    libmin_printf(\"type: %s\", types[pattern[i].type]);\n    if (pattern[i].type == 8 || pattern[i].type == 9) {\n      libmin_printf(\" [\");\n      for (j = 0; j <= 39; ++j) {\n        c = pattern[i].u.ccl[j];\n        if (!c || c == 93) break;\n        libmin_printf(\"%c\", (unsigned int)c);\n      }\n      libmin_printf(\"]\");\n    } else if (pattern[i].type == 7) {\n      libmin_printf(\" '%c'\", pattern[i].u.ch);\n    }\n    libmin_printf(\"\\n\");\n  }\n}", "binary": "regex-parser/regex-parser.host.O0", "assembly": "<re_print>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0xb0,%rsp\nmov    %rdi,-0xa8(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x39cd(%rip),%rax\nmov    %rax,-0x90(%rbp)\nlea    0x39c6(%rip),%rax\nmov    %rax,-0x88(%rbp)\nlea    0x39bc(%rip),%rax\nmov    %rax,-0x80(%rbp)\nlea    0x39b7(%rip),%rax\nmov    %rax,-0x78(%rbp)\nlea    0x39b0(%rip),%rax\nmov    %rax,-0x70(%rbp)\nlea    0x39b2(%rip),%rax\nmov    %rax,-0x68(%rbp)\nlea    0x39ac(%rip),%rax\nmov    %rax,-0x60(%rbp)\nlea    0x39a6(%rip),%rax\nmov    %rax,-0x58(%rbp)\nlea    0x39a0(%rip),%rax\nmov    %rax,-0x50(%rbp)\nlea    0x39a0(%rip),%rax\nmov    %rax,-0x48(%rbp)\nlea    0x39a4(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0x399f(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0x399e(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0x3999(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0x3998(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x3998(%rip),%rax\nmov    %rax,-0x18(%rbp)\nlea    0x399c(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmovl   $0x0,-0x98(%rbp)\njmp    2a43 <re_print+0x2b4>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     2a52 <re_print+0x2c3>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmovzbl %al,%eax\ncltq\nmov    -0x90(%rbp,%rax,8),%rax\nmov    %rax,%rsi\nlea    0x3939(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x8,%al\nje     292c <re_print+0x19d>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x9,%al\njne    29d2 <re_print+0x243>\nlea    0x38ea(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\nmovl   $0x0,-0x94(%rbp)\njmp    29b3 <re_print+0x224>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmov    0x8(%rax),%rdx\nmov    -0x94(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x99(%rbp)\ncmpb   $0x0,-0x99(%rbp)\nje     29bc <re_print+0x22d>\ncmpb   $0x5d,-0x99(%rbp)\nje     29bc <re_print+0x22d>\nmovsbl -0x99(%rbp),%eax\nmov    %eax,%esi\nlea    0x3881(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\naddl   $0x1,-0x94(%rbp)\ncmpl   $0x27,-0x94(%rbp)\njle    294c <re_print+0x1bd>\nlea    0x3860(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\njmp    2a28 <re_print+0x299>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    $0x7,%al\njne    2a28 <re_print+0x299>\nmov    -0x98(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nmov    -0xa8(%rbp),%rax\nadd    %rdx,%rax\nmovzbl 0x8(%rax),%eax\nmovzbl %al,%eax\nmov    %eax,%esi\nlea    0x380a(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\nlea    0x37fc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   5687 <libmin_printf>\naddl   $0x1,-0x98(%rbp)\ncmpl   $0x1d,-0x98(%rbp)\njle    2884 <re_print+0xf5>\njmp    2a53 <re_print+0x2c4>\nnop\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     2a68 <re_print+0x2d9>\ncall   20b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "rho-factor/rho-factor.c", "function_name": "factor", "content": "// fill the given array with prime factors of n, result will be zero terminated.\npositive_number * factor(positive_number n, positive_number *array) {\n    positive_number a, b; size_t s ;\n    do  if (n < 4)\n            *array++ = n, n = 1;\n        else if (n & 1) {\n            for (b = n >> 1, a = (b + n / b) >> 1; a < b; b = a, a = (b + n / b) >> 1);\n            if (b * b == n) {\n                s = factor(b, array) - array ;\n                libmin_memcpy(array + s, array, s * sizeof(positive_number)) ;\n                array += s + s ;\n                n = 1;\n            } else {\n                if (is_prime(n, 24)) // number of Miller-Rabin iterations.\n                    *array++ = n, n = 1;\n                else {\n                    a = factor_worker(n); // factor_worker can't be called with a prime.\n                    array = factor(a, array);\n                    n /= a;\n                }\n            }\n        } else\n            for (; !(n & 1); *array++ = 2, n >>= 1);\n    while (n > 1);\n    *array = 0 ;\n    return array ;\n}\n"}, "pseudo": {"path": "rho-factor/rho-factor.host.O0.pseudo", "function_name": "factor", "address": "0x5ab8", "label": "factor", "content": "positive_number *__cdecl factor(positive_number n, positive_number *array)\n{\n  positive_number *v2; // rax\n  positive_number *v3; // rax\n  positive_number *v4; // rax\n  positive_number a; // [rsp+18h] [rbp-18h]\n  positive_number aa; // [rsp+18h] [rbp-18h]\n  positive_number b; // [rsp+20h] [rbp-10h]\n  size_t s; // [rsp+28h] [rbp-8h]\n\n  do\n  {\n    if ( n > 3 )\n    {\n      if ( (n & 1) != 0 )\n      {\n        b = n >> 1;\n        for ( a = (n / (n >> 1) + (n >> 1)) >> 1; a < b; a = (n / a + a) >> 1 )\n          b = a;\n        if ( n == b * b )\n        {\n          s = factor(b, array) - array;\n          libmin_memcpy(&array[s], array, 8 * s);\n          array += 2 * s;\n          n = 1LL;\n        }\n        else if ( is_prime(n, 24) )\n        {\n          v3 = array++;\n          *v3 = n;\n          n = 1LL;\n        }\n        else\n        {\n          aa = factor_worker(n);\n          array = factor(aa, array);\n          n /= aa;\n        }\n      }\n      else\n      {\n        while ( (n & 1) == 0 )\n        {\n          v4 = array++;\n          *v4 = 2LL;\n          n >>= 1;\n        }\n      }\n    }\n    else\n    {\n      v2 = array++;\n      *v2 = n;\n      n = 1LL;\n    }\n  }\n  while ( n > 1 );\n  *array = 0LL;\n  return array;\n}\n"}, "pseudo_normalize": "positive_number *factor(positive_number n, positive_number *array) {\n  positive_number *v2;\n  positive_number *v3;\n  positive_number *v4;\n  positive_number a;\n  positive_number aa;\n  positive_number b;\n  unsigned int s;\n  do {\n    if (n > 3) {\n      if ((n & 1) != 0) {\n        b = n >> 1;\n        for (a = (n / (n >> 1) + (n >> 1)) >> 1; a < b; a = (n / a + a) >> 1)\n          b = a;\n        if (n == b * b) {\n          s = factor(b, array) - array;\n          libmin_memcpy(&array[s], array, 8 * s);\n          array += 2 * s;\n          n = 1LL;\n        } else if (is_prime(n, 24)) {\n          v3 = array++;\n          *v3 = n;\n          n = 1LL;\n        } else {\n          aa = factor_worker(n);\n          array = factor(aa, array);\n          n /= aa;\n        }\n      } else {\n        while ((n & 1) == 0) {\n          v4 = array++;\n          *v4 = 2LL;\n          n >>= 1;\n        }\n      }\n    } else {\n      v2 = array++;\n      *v2 = n;\n      n = 1LL;\n    }\n  } while (n > 1);\n  *array = 0LL;\n  return array;\n}", "binary": "rho-factor/rho-factor.host.O0", "assembly": "<factor>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\ncmpq   $0x3,-0x28(%rbp)\nja     5af3 <factor+0x3b>\nmov    -0x30(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    %rdx,(%rax)\nmovq   $0x1,-0x28(%rbp)\njmp    5c61 <factor+0x1a9>\nmov    -0x28(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nje     5c55 <factor+0x19d>\nmov    -0x28(%rbp),%rax\nshr    %rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x10(%rbp)\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nshr    %rax\nmov    %rax,-0x18(%rbp)\njmp    5b54 <factor+0x9c>\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x10(%rbp)\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nshr    %rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\ncmp    -0x10(%rbp),%rax\njb     5b2e <factor+0x76>\nmov    -0x10(%rbp),%rax\nimul   %rax,%rax\ncmp    %rax,-0x28(%rbp)\njne    5bd2 <factor+0x11a>\nmov    -0x30(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   5ab8 <factor>\nsub    -0x30(%rbp),%rax\nsar    $0x3,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nlea    0x0(,%rax,8),%rcx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rcx\nmov    -0x30(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   638a <libmin_memcpy>\nmov    -0x8(%rbp),%rax\nshl    $0x4,%rax\nadd    %rax,-0x30(%rbp)\nmovq   $0x1,-0x28(%rbp)\njmp    5c61 <factor+0x1a9>\nmov    -0x28(%rbp),%rax\nmov    $0x18,%esi\nmov    %rax,%rdi\ncall   1285 <is_prime>\ntest   %eax,%eax\nje     5c04 <factor+0x14c>\nmov    -0x30(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    %rdx,(%rax)\nmovq   $0x1,-0x28(%rbp)\njmp    5c61 <factor+0x1a9>\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   59a2 <factor_worker>\nmov    %rax,-0x18(%rbp)\nmov    -0x30(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   5ab8 <factor>\nmov    %rax,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x18(%rbp)\nmov    %rax,-0x28(%rbp)\njmp    5c61 <factor+0x1a9>\nmov    -0x30(%rbp),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,-0x30(%rbp)\nmovq   $0x2,(%rax)\nshrq   -0x28(%rbp)\nmov    -0x28(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nje     5c3e <factor+0x186>\ncmpq   $0x1,-0x28(%rbp)\nja     5acc <factor+0x14>\nmov    -0x30(%rbp),%rax\nmovq   $0x0,(%rax)\nmov    -0x30(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "rho-factor/rho-factor.c", "function_name": "factor_worker", "content": "positive_number factor_worker(const positive_number n) {\n    size_t a = -1, b = 2 ;\n    positive_number c, d = 1 + libmin_rand(), e, f;\n    c = d %= n;\n    do {\n        if (++a == b){\n            // handle your timeout here, when (a == 1 << 20) or another power of two.\n            d = c, b <<= 1, a = 0;\n        }\n        c = multiplication_modulo(c, c, n);\n        for (++c, c *= c != n, e = n, f = c > d ? c - d : d - c; (f %= e) && (e %= f););\n    } while ((f |= e) == 1);\n    return f;\n}\n"}, "pseudo": {"path": "rho-factor/rho-factor.host.O0.pseudo", "function_name": "factor_worker", "address": "0x59a2", "label": "factor_worker", "content": "positive_number __cdecl factor_worker(const positive_number n)\n{\n  positive_number v1; // rax\n  positive_number v2; // rax\n  size_t a; // [rsp+10h] [rbp-30h]\n  size_t b; // [rsp+18h] [rbp-28h]\n  unsigned __int64 c; // [rsp+20h] [rbp-20h]\n  positive_number d; // [rsp+28h] [rbp-18h]\n  positive_number e; // [rsp+30h] [rbp-10h]\n  positive_number f; // [rsp+38h] [rbp-8h]\n  positive_number fa; // [rsp+38h] [rbp-8h]\n\n  a = -1LL;\n  b = 2LL;\n  d = (libmin_rand() + 1) % n;\n  c = d;\n  do\n  {\n    if ( ++a == b )\n    {\n      d = c;\n      b *= 2LL;\n      a = 0LL;\n    }\n    v1 = multiplication_modulo(c, c, n);\n    c = (v1 + 1) * (v1 + 1 != n);\n    e = n;\n    if ( c <= d )\n      v2 = d - c;\n    else\n      v2 = c - d;\n    f = v2;\n    do\n    {\n      f %= e;\n      if ( !f )\n        break;\n      e %= f;\n    }\n    while ( e );\n    fa = e | f;\n  }\n  while ( fa == 1 );\n  return fa;\n}\n"}, "pseudo_normalize": "positive_number factor_worker(const positive_number n) {\n  positive_number v1;\n  positive_number v2;\n  unsigned int a;\n  unsigned int b;\n  unsigned long long c;\n  positive_number d;\n  positive_number e;\n  positive_number f;\n  positive_number fa;\n  a = -1LL;\n  b = 2LL;\n  d = (libmin_rand() + 1) % n;\n  c = d;\n  do {\n    if (++a == b) {\n      d = c;\n      b *= 2LL;\n      a = 0LL;\n    }\n    v1 = multiplication_modulo(c, c, n);\n    c = (v1 + 1) * (v1 + 1 != n);\n    e = n;\n    if (c <= d)\n      v2 = d - c;\n    else\n      v2 = c - d;\n    f = v2;\n    do {\n      f %= e;\n      if (!f) break;\n      e %= f;\n    } while (e);\n    fa = e | f;\n  } while (fa == 1);\n  return fa;\n}", "binary": "rho-factor/rho-factor.host.O0", "assembly": "<factor_worker>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmovq   $0xffffffffffffffff,-0x30(%rbp)\nmovq   $0x2,-0x28(%rbp)\ncall   87d6 <libmin_rand>\nadd    $0x1,%eax\nmov    %eax,%eax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x38(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x20(%rbp)\naddq   $0x1,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\ncmp    -0x28(%rbp),%rax\njne    5a0c <factor_worker+0x6a>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x18(%rbp)\nshlq   -0x28(%rbp)\nmovq   $0x0,-0x30(%rbp)\nmov    -0x38(%rbp),%rdx\nmov    -0x20(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <multiplication_modulo>\nmov    %rax,-0x20(%rbp)\naddq   $0x1,-0x20(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x38(%rbp),%rax\nsetne  %al\nmovzbl %al,%eax\nmov    -0x20(%rbp),%rdx\nimul   %rdx,%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x18(%rbp),%rax\njbe    5a62 <factor_worker+0xc0>\nmov    -0x20(%rbp),%rax\nsub    -0x18(%rbp),%rax\njmp    5a6a <factor_worker+0xc8>\nmov    -0x18(%rbp),%rax\nsub    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nnop\nmov    -0x8(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x10(%rbp)\nmov    %rdx,-0x8(%rbp)\ncmpq   $0x0,-0x8(%rbp)\nje     5a9f <factor_worker+0xfd>\nmov    -0x10(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x8(%rbp)\nmov    %rdx,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    5a6f <factor_worker+0xcd>\nmov    -0x10(%rbp),%rax\nor     %rax,-0x8(%rbp)\ncmpq   $0x1,-0x8(%rbp)\nje     59e9 <factor_worker+0x47>\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "rho-factor/rho-factor.c", "function_name": "is_prime", "content": "static int is_prime(positive_number n, int k) {\n    positive_number a = 0, b, c, d, e, f, g; int h, i;\n    if ((n == 1) == (n & 1)) return n == 2;\n    if (n < 4669921) // fast constexpr for small primes (this line is removable).\n        return ((n & 1) & ((n < 6) * 42 + 0x208A2882) >> n % 30 && (n < 49 || (n % 7 && n % 11 && n % 13 && n % 17 && n % 19 && n % 23 && n % 29 && (n < 961 || (n % 31 && n % 37 && n % 41 && n % 43 && n % 47 && n % 53 && n % 59 && n % 61 && n % 67 && (n < 5041 || (n % 71 && n % 73 && n % 79 && n % 83 && n % 89 && n % 97 && n % 101 && n % 103 && n % 107 && (n < 11881 || (n % 109 && n % 113 && n % 127 && n % 131 && n % 137 && n % 139 && n % 149 && n % 151 && n % 157 && (n < 26569 || (n % 163 && n % 167 && n % 173 && n % 179 && n % 181 && n % 191 && n % 193 && n % 197 && n % 199 && (n < 44521 || (n % 211 && n % 223 && n % 227 && n % 229 && n % 233 && n % 239 && n % 241 && n % 251 && n % 257 && (n < 69169 || (n % 263 && n % 269 && n % 271 && n % 277 && n % 281 && n % 283 && n % 293 && n % 307 && n % 311 && (n < 97969 || (n % 313 && n % 317 && n % 331 && n % 337 && n % 347 && n % 349 && n % 353 && n % 359 && n % 367 && (n < 139129 || (n % 373 && n % 379 && n % 383 && n % 389 && n % 397 && n % 401 && n % 409 && n % 419 && n % 421 && (n < 185761 || (n % 431 && n % 433 && n % 439 && n % 443 && n % 449 && n % 457 && n % 461 && n % 463 && n % 467 && (n < 229441 || (n % 479 && n % 487 && n % 491 && n % 499 && n % 503 && n % 509 && n % 521 && n % 523 && n % 541 && (n < 299209 || (n % 547 && n % 557 && n % 563 && n % 569 && n % 571 && n % 577 && n % 587 && n % 593 && n % 599 && (n < 361201 || (n % 601 && n % 607 && n % 613 && n % 617 && n % 619 && n % 631 && n % 641 && n % 643 && n % 647 && (n < 426409 || (n % 653 && n % 659 && n % 661 && n % 673 && n % 677 && n % 683 && n % 691 && n % 701 && n % 709 && (n < 516961 || (n % 719 && n % 727 && n % 733 && n % 739 && n % 743 && n % 751 && n % 757 && n % 761 && n % 769 && (n < 597529 || (n % 773 && n % 787 && n % 797 && n % 809 && n % 811 && n % 821 && n % 823 && n % 827 && n % 829 && (n < 703921 || (n % 839 && n % 853 && n % 857 && n % 859 && n % 863 && n % 877 && n % 881 && n % 883 && n % 887 && (n < 822649 || (n % 907 && n % 911 && n % 919 && n % 929 && n % 937 && n % 941 && n % 947 && n % 953 && n % 967 && (n < 942841 || (n % 971 && n % 977 && n % 983 && n % 991 && n % 997 && n % 1009 && n % 1013 && n % 1019 && n % 1021 && (n < 1062961 || (n % 1031 && n % 1033 && n % 1039 && n % 1049 && n % 1051 && n % 1061 && n % 1063 && n % 1069 && n % 1087 && (n < 1190281 || (n % 1091 && n % 1093 && n % 1097 && n % 1103 && n % 1109 && n % 1117 && n % 1123 && n % 1129 && n % 1151 && (n < 1329409 || (n % 1153 && n % 1163 && n % 1171 && n % 1181 && n % 1187 && n % 1193 && n % 1201 && n % 1213 && n % 1217 && (n < 1495729 || (n % 1223 && n % 1229 && n % 1231 && n % 1237 && n % 1249 && n % 1259 && n % 1277 && n % 1279 && n % 1283 && (n < 1661521 || (n % 1289 && n % 1291 && n % 1297 && n % 1301 && n % 1303 && n % 1307 && n % 1319 && n % 1321 && n % 1327 && (n < 1852321 || (n % 1361 && n % 1367 && n % 1373 && n % 1381 && n % 1399 && n % 1409 && n % 1423 && n % 1427 && n % 1429 && (n < 2053489 || (n % 1433 && n % 1439 && n % 1447 && n % 1451 && n % 1453 && n % 1459 && n % 1471 && n % 1481 && n % 1483 && (n < 2211169 || (n % 1487 && n % 1489 && n % 1493 && n % 1499 && n % 1511 && n % 1523 && n % 1531 && n % 1543 && n % 1549 && (n < 2411809 || (n % 1553 && n % 1559 && n % 1567 && n % 1571 && n % 1579 && n % 1583 && n % 1597 && n % 1601 && n % 1607 && (n < 2588881 || (n % 1609 && n % 1613 && n % 1619 && n % 1621 && n % 1627 && n % 1637 && n % 1657 && n % 1663 && n % 1667 && (n < 2785561 || (n % 1669 && n % 1693 && n % 1697 && n % 1699 && n % 1709 && n % 1721 && n % 1723 && n % 1733 && n % 1741 && (n < 3052009 || (n % 1747 && n % 1753 && n % 1759 && n % 1777 && n % 1783 && n % 1787 && n % 1789 && n % 1801 && n % 1811 && (n < 3323329 || (n % 1823 && n % 1831 && n % 1847 && n % 1861 && n % 1867 && n % 1871 && n % 1873 && n % 1877 && n % 1879 && (n < 3568321 || (n % 1889 && n % 1901 && n % 1907 && n % 1913 && n % 1931 && n % 1933 && n % 1949 && n % 1951 && n % 1973 && (n < 3916441 || (n % 1979 && n % 1987 && n % 1993 && n % 1997 && n % 1999 && n % 2003 && n % 2011 && n % 2017 && n % 2027 && (n < 4116841 || (n % 2029 && n % 2039 && n % 2053 && n % 2063 && n % 2069 && n % 2081 && n % 2083 && n % 2087 && n % 2089 && (n < 4405801 || (n % 2099 && n % 2111 && n % 2113 && n % 2129 && n % 2131 && n % 2137 && n % 2141 && n % 2143 && n % 2153 )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));\n    for (b = c = n - 1, h = 0; !(b & 1); b >>= 1, ++h);\n    for (; k--;) {\n        for (g = 0; g < sizeof(positive_number); ((char*)&a)[g++] = libmin_rand()); // random number.\n        do for (d = e = 1 + a % c, f = n; (d %= f) && (f %= d););\n        while (d > 1 && f > 1);\n        for (d = f = 1; f <= b; f <<= 1);\n        for (; f >>= 1; d = multiplication_modulo(d, d, n), f & b && (d = multiplication_modulo(e, d, n)));\n        if (d == 1) continue;\n        for (i = h; i-- && d != c; d = multiplication_modulo(d, d, n));\n        if (d != c) return 0;\n    }\n    return 1;\n}\n"}, "pseudo": {"path": "rho-factor/rho-factor.host.O0.pseudo", "function_name": "is_prime", "address": "0x1285", "label": "is_prime", "content": "int __cdecl is_prime(positive_number n, int k)\n{\n  int v3; // esi\n  char v4; // cl\n  positive_number v5; // rax\n  int v6; // eax\n  int h; // [rsp+18h] [rbp-48h]\n  int i; // [rsp+1Ch] [rbp-44h]\n  positive_number a; // [rsp+20h] [rbp-40h]\n  positive_number b; // [rsp+28h] [rbp-38h]\n  positive_number d; // [rsp+30h] [rbp-30h]\n  positive_number f; // [rsp+38h] [rbp-28h]\n  positive_number g; // [rsp+40h] [rbp-20h]\n  positive_number c; // [rsp+48h] [rbp-18h]\n  positive_number e; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v18; // [rsp+58h] [rbp-8h]\n\n  v18 = __readfsqword(0x28u);\n  a = 0LL;\n  if ( (n != 1) != (n & 1) )\n    return n == 2;\n  if ( n > 0x4741E0 )\n  {\n    c = n - 1;\n    b = n - 1;\n    h = 0;\n    while ( (b & 1) == 0 )\n    {\n      b >>= 1;\n      ++h;\n    }\n    while ( k-- )\n    {\n      g = 0LL;\n      while ( g <= 7 )\n      {\n        v4 = libmin_rand();\n        v5 = g++;\n        *((_BYTE *)&a + v5) = v4;\n      }\n      do\n      {\n        e = a % c + 1;\n        d = e;\n        f = n;\n        do\n        {\n          d %= f;\n          if ( !d )\n            break;\n          f %= d;\n        }\n        while ( f );\n      }\n      while ( d > 1 && f > 1 );\n      f = 1LL;\n      d = 1LL;\n      while ( f <= b )\n        f *= 2LL;\n      while ( 1 )\n      {\n        f >>= 1;\n        if ( !f )\n          break;\n        d = multiplication_modulo(d, d, n);\n        if ( (b & f) != 0 )\n          d = multiplication_modulo(e, d, n);\n      }\n      if ( d != 1 )\n      {\n        i = h;\n        while ( 1 )\n        {\n          v6 = i--;\n          if ( !v6 || d == c )\n            break;\n          d = multiplication_modulo(d, d, n);\n        }\n        if ( d != c )\n          return 0;\n      }\n    }\n    return 1;\n  }\n  else\n  {\n    if ( n > 5 )\n      v3 = 545925250;\n    else\n      v3 = 545925292;\n    return ((unsigned __int8)n & (unsigned __int8)(v3 >> (n % 0x1E)) & 1) != 0\n        && (n <= 0x30\n         || n % 7\n         && n % 0xB\n         && n % 0xD\n         && n % 0x11\n         && n % 0x13\n         && n % 0x17\n         && n % 0x1D\n         && (n <= 0x3C0\n          || n % 0x1F\n          && n % 0x25\n          && n % 0x29\n          && n % 0x2B\n          && n % 0x2F\n          && n % 0x35\n          && n % 0x3B\n          && n % 0x3D\n          && n % 0x43\n          && (n <= 0x13B0\n           || n % 0x47\n           && n % 0x49\n           && n % 0x4F\n           && n % 0x53\n           && n % 0x59\n           && n % 0x61\n           && n % 0x65\n           && n % 0x67\n           && n % 0x6B\n           && (n <= 0x2E68\n            || n % 0x6D\n            && n % 0x71\n            && n % 0x7F\n            && n % 0x83\n            && n % 0x89\n            && n % 0x8B\n            && n % 0x95\n            && n % 0x97\n            && n % 0x9D\n            && (n <= 0x67C8\n             || n % 0xA3\n             && n % 0xA7\n             && n % 0xAD\n             && n % 0xB3\n             && n % 0xB5\n             && n % 0xBF\n             && n % 0xC1\n             && n % 0xC5\n             && n % 0xC7\n             && (n <= 0xADE8\n              || n % 0xD3\n              && n % 0xDF\n              && n % 0xE3\n              && n % 0xE5\n              && n % 0xE9\n              && n % 0xEF\n              && n % 0xF1\n              && n % 0xFB\n              && n % 0x101\n              && (n <= 0x10E30\n               || n % 0x107\n               && n % 0x10D\n               && n % 0x10F\n               && n % 0x115\n               && n % 0x119\n               && n % 0x11B\n               && n % 0x125\n               && n % 0x133\n               && n % 0x137\n               && (n <= 0x17EB0\n                || n % 0x139\n                && n % 0x13D\n                && n % 0x14B\n                && n % 0x151\n                && n % 0x15B\n                && n % 0x15D\n                && n % 0x161\n                && n % 0x167\n                && n % 0x16F\n                && (n <= 0x21F78\n                 || n % 0x175\n                 && n % 0x17B\n                 && n % 0x17F\n                 && n % 0x185\n                 && n % 0x18D\n                 && n % 0x191\n                 && n % 0x199\n                 && n % 0x1A3\n                 && n % 0x1A5\n                 && (n <= 0x2D5A0\n                  || n % 0x1AF\n                  && n % 0x1B1\n                  && n % 0x1B7\n                  && n % 0x1BB\n                  && n % 0x1C1\n                  && n % 0x1C9\n                  && n % 0x1CD\n                  && n % 0x1CF\n                  && n % 0x1D3\n                  && (n <= 0x38040\n                   || n % 0x1DF\n                   && n % 0x1E7\n                   && n % 0x1EB\n                   && n % 0x1F3\n                   && n % 0x1F7\n                   && n % 0x1FD\n                   && n % 0x209\n                   && n % 0x20B\n                   && n % 0x21D\n                   && (n <= 0x490C8\n                    || n % 0x223\n                    && n % 0x22D\n                    && n % 0x233\n                    && n % 0x239\n                    && n % 0x23B\n                    && n % 0x241\n                    && n % 0x24B\n                    && n % 0x251\n                    && n % 0x257\n                    && (n <= 0x582F0\n                     || n % 0x259\n                     && n % 0x25F\n                     && n % 0x265\n                     && n % 0x269\n                     && n % 0x26B\n                     && n % 0x277\n                     && n % 0x281\n                     && n % 0x283\n                     && n % 0x287\n                     && (n <= 0x681A8\n                      || n % 0x28D\n                      && n % 0x293\n                      && n % 0x295\n                      && n % 0x2A1\n                      && n % 0x2A5\n                      && n % 0x2AB\n                      && n % 0x2B3\n                      && n % 0x2BD\n                      && n % 0x2C5\n                      && (n <= 0x7E360\n                       || n % 0x2CF\n                       && n % 0x2D7\n                       && n % 0x2DD\n                       && n % 0x2E3\n                       && n % 0x2E7\n                       && n % 0x2EF\n                       && n % 0x2F5\n                       && n % 0x2F9\n                       && n % 0x301\n                       && (n <= 0x91E18\n                        || n % 0x305\n                        && n % 0x313\n                        && n % 0x31D\n                        && n % 0x329\n                        && n % 0x32B\n                        && n % 0x335\n                        && n % 0x337\n                        && n % 0x33B\n                        && n % 0x33D\n                        && (n <= 0xABDB0\n                         || n % 0x347\n                         && n % 0x355\n                         && n % 0x359\n                         && n % 0x35B\n                         && n % 0x35F\n                         && n % 0x36D\n                         && n % 0x371\n                         && n % 0x373\n                         && n % 0x377\n                         && (n <= 0xC8D78\n                          || n % 0x38B\n                          && n % 0x38F\n                          && n % 0x397\n                          && n % 0x3A1\n                          && n % 0x3A9\n                          && n % 0x3AD\n                          && n % 0x3B3\n                          && n % 0x3B9\n                          && n % 0x3C7\n                          && (n <= 0xE62F8\n                           || n % 0x3CB\n                           && n % 0x3D1\n                           && n % 0x3D7\n                           && n % 0x3DF\n                           && n % 0x3E5\n                           && n % 0x3F1\n                           && n % 0x3F5\n                           && n % 0x3FB\n                           && n % 0x3FD\n                           && (n <= 0x103830\n                            || n % 0x407\n                            && n % 0x409\n                            && n % 0x40F\n                            && n % 0x419\n                            && n % 0x41B\n                            && n % 0x425\n                            && n % 0x427\n                            && n % 0x42D\n                            && n % 0x43F\n                            && (n <= 0x122988\n                             || n % 0x443\n                             && n % 0x445\n                             && n % 0x449\n                             && n % 0x44F\n                             && n % 0x455\n                             && n % 0x45D\n                             && n % 0x463\n                             && n % 0x469\n                             && n % 0x47F\n                             && (n <= 0x144900\n                              || n % 0x481\n                              && n % 0x48B\n                              && n % 0x493\n                              && n % 0x49D\n                              && n % 0x4A3\n                              && n % 0x4A9\n                              && n % 0x4B1\n                              && n % 0x4BD\n                              && n % 0x4C1\n                              && (n <= 0x16D2B0\n                               || n % 0x4C7\n                               && n % 0x4CD\n                               && n % 0x4CF\n                               && n % 0x4D5\n                               && n % 0x4E1\n                               && n % 0x4EB\n                               && n % 0x4FD\n                               && n % 0x4FF\n                               && n % 0x503\n                               && (n <= 0x195A50\n                                || n % 0x509\n                                && n % 0x50B\n                                && n % 0x511\n                                && n % 0x515\n                                && n % 0x517\n                                && n % 0x51B\n                                && n % 0x527\n                                && n % 0x529\n                                && n % 0x52F\n                                && (n <= 0x1C43A0\n                                 || n % 0x551\n                                 && n % 0x557\n                                 && n % 0x55D\n                                 && n % 0x565\n                                 && n % 0x577\n                                 && n % 0x581\n                                 && n % 0x58F\n                                 && n % 0x593\n                                 && n % 0x595\n                                 && (n <= 0x1F5570\n                                  || n % 0x599\n                                  && n % 0x59F\n                                  && n % 0x5A7\n                                  && n % 0x5AB\n                                  && n % 0x5AD\n                                  && n % 0x5B3\n                                  && n % 0x5BF\n                                  && n % 0x5C9\n                                  && n % 0x5CB\n                                  && (n <= 0x21BD60\n                                   || n % 0x5CF\n                                   && n % 0x5D1\n                                   && n % 0x5D5\n                                   && n % 0x5DB\n                                   && n % 0x5E7\n                                   && n % 0x5F3\n                                   && n % 0x5FB\n                                   && n % 0x607\n                                   && n % 0x60D\n                                   && (n <= 0x24CD20\n                                    || n % 0x611\n                                    && n % 0x617\n                                    && n % 0x61F\n                                    && n % 0x623\n                                    && n % 0x62B\n                                    && n % 0x62F\n                                    && n % 0x63D\n                                    && n % 0x641\n                                    && n % 0x647\n                                    && (n <= 0x2780D0\n                                     || n % 0x649\n                                     && n % 0x64D\n                                     && n % 0x653\n                                     && n % 0x655\n                                     && n % 0x65B\n                                     && n % 0x665\n                                     && n % 0x679\n                                     && n % 0x67F\n                                     && n % 0x683\n                                     && (n <= 0x2A8118\n                                      || n % 0x685\n                                      && n % 0x69D\n                                      && n % 0x6A1\n                                      && n % 0x6A3\n                                      && n % 0x6AD\n                                      && n % 0x6B9\n                                      && n % 0x6BB\n                                      && n % 0x6C5\n                                      && n % 0x6CD\n                                      && (n <= 0x2E91E8\n                                       || n % 0x6D3\n                                       && n % 0x6D9\n                                       && n % 0x6DF\n                                       && n % 0x6F1\n                                       && n % 0x6F7\n                                       && n % 0x6FB\n                                       && n % 0x6FD\n                                       && n % 0x709\n                                       && n % 0x713\n                                       && (n <= 0x32B5C0\n                                        || n % 0x71F\n                                        && n % 0x727\n                                        && n % 0x737\n                                        && n % 0x745\n                                        && n % 0x74B\n                                        && n % 0x74F\n                                        && n % 0x751\n                                        && n % 0x755\n                                        && n % 0x757\n                                        && (n <= 0x3672C0\n                                         || n % 0x761\n                                         && n % 0x76D\n                                         && n % 0x773\n                                         && n % 0x779\n                                         && n % 0x78B\n                                         && n % 0x78D\n                                         && n % 0x79D\n                                         && n % 0x79F\n                                         && n % 0x7B5\n                                         && (n <= 0x3BC298\n                                          || n % 0x7BB\n                                          && n % 0x7C3\n                                          && n % 0x7C9\n                                          && n % 0x7CD\n                                          && n % 0x7CF\n                                          && n % 0x7D3\n                                          && n % 0x7DB\n                                          && n % 0x7E1\n                                          && n % 0x7EB\n                                          && (n <= 0x3ED168\n                                           || n % 0x7ED\n                                           && n % 0x7F7\n                                           && n % 0x805\n                                           && n % 0x80F\n                                           && n % 0x815\n                                           && n % 0x821\n                                           && n % 0x823\n                                           && n % 0x827\n                                           && n % 0x829\n                                           && (n <= 0x433A28\n                                            || n % 0x833\n                                            && n % 0x83F\n                                            && n % 0x841\n                                            && n % 0x851\n                                            && n % 0x853\n                                            && n % 0x859\n                                            && n % 0x85D\n                                            && n % 0x85F\n                                            && n % 0x869))))))))))))))))))))))))))))))))))));\n  }\n}\n"}, "pseudo_normalize": "", "binary": "rho-factor/rho-factor.host.O0", "assembly": "<is_prime>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %esi,-0x5c(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x40(%rbp)\ncmpq   $0x1,-0x58(%rbp)\nsetne  %dl\nmov    -0x58(%rbp),%rax\nand    $0x1,%eax\nxor    %edx,%eax\ntest   %al,%al\nje     12d4 <is_prime+0x4f>\ncmpq   $0x2,-0x58(%rbp)\nsete   %al\nmovzbl %al,%eax\njmp    598c <is_prime+0x4707>\ncmpq   $0x4741e0,-0x58(%rbp)\nja     57e1 <is_prime+0x455c>\ncmpq   $0x5,-0x58(%rbp)\nja     12f0 <is_prime+0x6b>\nmov    $0x208a28ac,%esi\njmp    12f5 <is_prime+0x70>\nmov    $0x208a2882,%esi\nmov    -0x58(%rbp),%rcx\nmovabs $0x8888888888888889,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x4,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nadd    %rax,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\nmov    %edx,%eax\nmov    %eax,%ecx\nsar    %cl,%esi\nmov    %esi,%eax\ncltq\nand    -0x58(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x30,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2492492492492493,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x2,%rax\nmov    %rax,%rdx\nshl    $0x3,%rdx\nsub    %rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2e8ba2e8ba2e8ba3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    %rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4ec4ec4ec4ec4ec5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x2,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf0f0f0f0f0f0f0f1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x4,%rax\nmov    %rax,%rdx\nshl    $0x4,%rdx\nadd    %rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd79435e50d79435f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x4,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x642c8590b21642c9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x4,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x1a7b9611a7b9611b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x4,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\ncmpq   $0x3c0,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x842108421084211,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x4,%rax\nmov    %rax,%rdx\nshl    $0x5,%rdx\nsub    %rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xdd67c8a60dd67c8b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x5,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xc7ce0c7ce0c7ce0d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x5,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xbe82fa0be82fa0bf,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x5,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x5c9882b931057263,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x5,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3521cfb2b78c1353,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x5,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x8ad8f2fba9386823,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x5,%rax\nimul   $0x3b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xc9714fbcda3ac11,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x5,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf4898d5f85bb3951,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x6,%rdx\nmov    %rdx,%rax\nshl    $0x5,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\ncmpq   $0x13b0,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0xcd85689039b0ad13,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x6,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nsub    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x70381c0e070381c1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x5,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x67b23a5440cf6475,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x5,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x4,%rax\nsub    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3159721ed7e75347,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x4,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x702e05c0b81702e1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x6,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x51d07eae2f8151d1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x6,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x5,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x446f86562d9faee5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x6,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rsi\nadd    %rsi,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3e22cbce4a9027c5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x6,%rax\nimul   $0x67,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x323e34a2b10bf66f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x6,%rax\nimul   $0x6b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x2e68,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x964fda6c0964fda7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x6,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,8),%rsi\nadd    %rsi,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x90fdbc090fdbc091,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x6,%rax\nimul   $0x71,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x204081020408103,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x6,%rax\nmov    %rax,%rdx\nshl    $0x7,%rdx\nsub    %rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3e88cb3c9484e2b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    %rdx\nmov    %rdx,%rax\nshl    $0x6,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xde5d6e3f8868a471,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x7,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x4,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3aef6ca970586723,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x5,%rax\nimul   $0x8b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x1b7d6c3dda338b2b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x4,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6c80d901b2036407,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x6,%rax\nimul   $0x97,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x342da7f2f4960343,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x5,%rax\nimul   $0x9d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x67c8,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0xc907da4e871146ad,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x7,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,8),%rsi\nadd    %rsi,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x621b97c2aec12653,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x6,%rax\nimul   $0xa7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xbd69104707661aa3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0xad,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xb70fbb5a19be3659,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0xb3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6a13cd153729043f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x7,%rax\nimul   $0xb5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x55c7b4f141ace689,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x6,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x6,%rax\nsub    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x15390948f40feac7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x4,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x6,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x14cab88725af6e75,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x4,%rax\nimul   $0xc5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x49539e3b2d066ea3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x7,%rax\nimul   $0xc7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0xade8,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4da637cf781d1e55,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x6,%rax\nimul   $0xd3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x25e22708092f1139,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x7,%rax\nimul   $0xdf,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x905a38633e06c43b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0xe3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x8f1779d9fdc3a219,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0xe5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x19453808ca29c047,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x7,%rax\nimul   $0xe9,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x12358e75d30336a1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x7,%rax\nimul   $0xef,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x10fef010fef010ff,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x4,%rax\nimul   $0xf1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x5197f7d73404147,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x7,%rax\nimul   $0xfb,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xff00ff00ff00ff01,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nmov    %rax,%rdx\nshl    $0x8,%rdx\nadd    %rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x10e30,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x7c97d9108c2ad433,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x107,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf3a0d52cba872337,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x10d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf1d48bcee0d399fb,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x10f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x764bc88c79fe26d1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x115,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd272ca3fc5b1a6b9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x119,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x73c9b97112ff186d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x11b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6fd60fba1a362bb,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x3,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd578e97c3f5fe551,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x133,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x34ae820ed114942b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x6,%rax\nimul   $0x137,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x17eb0,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0xa2c2a87c51ca04e9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x139,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xcebcf8bb5b4169cb,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x13d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xc5fe740317f9d00d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x14b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x613c0309e0184f01,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x151,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x79baa6bb6398b6f7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x15b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xbbc8408cd63069a1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x15d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x1734f0c541fe8cb1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x5,%rax\nimul   $0x161,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6d1a62681c860fb1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x167,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6524f853b4aa339f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x16f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x21f78,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0xafb321a1496fdf0f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x175,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x59d61f123ccaa377,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x17b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x558e5ee9f14b87b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x3,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x7,%rax\nsub    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x50f22e111c4c56df,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x185,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2944ff5aec02945,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x2,%rax\nimul   $0x18d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x46dce34596066251,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x191,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x40782d10e6566065,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x199,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4e348b4d982236fd,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x1a3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x9baade8e4a2f6e1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x4,%rax\nimul   $0x1a5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x2d5a0,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x301c82ac40260391,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x1af,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2eb4ea1fed14b15f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x1b1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x9548e4979e0829fd,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x1b7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x27dfa38a1ce4d6f9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x1bb,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x91f5bcb8bb02d9cd,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x1c1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x1ecf43c7fb84c2f1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x1c9,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x47148bf073816367,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x1cd,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x1b17c67f2bae2b21,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x1cf,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x18ab083902bdab95,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x1d3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x38040,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x11a3019a748267af,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x1df,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd24456359e39d2d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x1e7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xaf2f722eecb5713,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x1eb,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x8355ace3c897db1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x4,%rax\nimul   $0x1f3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x824a4e60b3262bc5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x1f7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x10182436517a3753,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x5,%rdx\nmov    %rdx,%rax\nshl    $0x7,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xfb93e672fa98528d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x9,%rdx\nmov    %rdx,%rax\nshl    $0x6,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xfa9d9d1fd102728b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x20b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3c91beb2de672839,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x21d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x490c8,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0xef9ea78bef26d839,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x223,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xeb51599f7ba23d97,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x22d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xe8cf58aaf8451d8f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x233,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xe65ae1db1b71d3e9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x239,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x72c62a24c3797fc7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x23b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x7194a17f55a10dc1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x8,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x6,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x1be9526d0769f9e5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x6,%rax\nimul   $0x24b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xdd0833cdec244359,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x251,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x36b45a9ab6103d8b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x257,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x582f0,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6d0b803685c01b43,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x259,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd7ef215165a40f2f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x25f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd5d20fde972d8539,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x265,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6a37991a23aead6f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x269,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x69dfbdd4295b6627,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x26b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xcfb8988b90067dc5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x277,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xcc7b01ff3384fe01,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x9,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x7,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x65ec17e35599481,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x4,%rax\nimul   $0x283,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xca95906b9f74b92d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x287,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x681a8,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x322e42a57083b96f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x28d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x18dca64397e407c5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x6,%rax\nimul   $0x293,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6325913c07beef59,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x295,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6160ff9e9f006161,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x2a1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xc19b6a41cbd11c5d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x2a5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x7fd005ff4017fd01,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x2ab,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xbdaf3c6349b99bf9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x2b3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xbafa85a9158bde67,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x2bd,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x5c6f35ccba502871,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x2c5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x7e360,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6c9863b1ab4294d5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x2cf,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x168954dd2390b9ed,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x6,%rax\nimul   $0x2d7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xb2d0d9ee899ab7b5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x2dd,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x62ba5eeade65d883,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x2e3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x58345f1876865fc9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x2e7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xae87ab7648f2b4ab,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x2ef,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xad2589a356e95797,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x2f5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x58791a9357ccde07,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x2f9,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xaa71da0ca6732ef1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x9,%rdx\nmov    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nshl    $0x8,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\ncmpq   $0x91e18,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2a6403f9605f6109,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x305,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4d17bef15cb4dbe5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x313,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x48e9d63e504d16cf,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x31d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xa2046e1f02d913f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x5,%rax\nimul   $0x329,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xa19e253f72959f69,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x32b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x9fa6328395fba275,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x335,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4fa1704aa75945fd,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x337,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x9e7dada8b4c75a15,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x33b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4f0de57154ebed79,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x33d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0xabdb0,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x9c395d102bf0222d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x347,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3351ee97dbfc660b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x355,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x31e2b9cd37dc276f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x359,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x312c67b6173ee1e7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x35b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2fc24c887448614d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x35f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x95747843b8c67eb,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x5,%rax\nimul   $0x36d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4a6360c344de0095,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x371,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x28e0fa7dd35a2a55,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x373,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x278a3eeaee6503c1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x377,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0xc8d78,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x9082f6af8f19af47,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x38b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x1fc10dc4fce8ad1b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x38f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x1d3fca840a073e1f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x397,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x1a2dbe6a5e3e4719,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x3a1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x17c4fc72bfcb8b11,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x3a9,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x22d291467611f493,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x3ad,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x229a162ab6335cb9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x3b3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x131288ffbb3b5dc1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x3b9,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x21e2e1069e4ff34b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x3c7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0xe62f8,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0xdf9252c8e5e629b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x3cb,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xc50b446391f2e61,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x3d1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xaad71ce84d1622f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x3d7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x8865436c3cf6f57,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x3df,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x41bbb2f80a4553f7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x3e5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x81e722c258cd00c3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x3f1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x8163d282e7fdfa71,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x3f5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x14191f67411155b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x3fb,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xc0906c513cedb3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0x9,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x8,%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\ncmpq   $0x103830,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3f90c2ab542cb1c9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x407,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x7ee2825ab3eb2ed7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x9,%rdx\nmov    %rdx,%rax\nshl    $0x7,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xfc4ddc06e6210431,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x40f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf9e621ad8389e23b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x419,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf96c645a9c6074eb,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x41b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3dc4a50968f5246f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x425,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf69b9325540c85e7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x427,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x7a9c9e0de3bde793,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x42d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf129af7493e6909b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x43f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x122988,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x7823aa96a4b8e6e5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x443,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xefd6c715c84194bb,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x445,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xeef6e618bc8ed19,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x6,%rax\nimul   $0x449,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3b6a8801db54400f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x44f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x763079e1fdb10d9f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x455,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xeaaf8e52f70fd055,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x45d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3a5ba3e76156da63,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x463,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x74187d2a66f1b6fd,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x469,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x71e06ac264163dd5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x9,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x7,%rax\nsub    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\ncmpq   $0x144900,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0xe35bb2bbd6422a3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x6,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x7,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x70b39e443cc0d351,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x48b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6fee82bb92b11455,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x493,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xddf7c34e40989a57,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x49d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x373622136907fad3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x4a3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xdbbc30ece6e4bf69,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x4a9,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x36915f47d55e6d9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x4,%rax\nimul   $0x4b1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd81cb3cfe19bf6b7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x4bd,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd766dcdef97aa2d1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x4c1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x16d2b0,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd658556732071def,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x4c7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd54c7225e91649bd,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x4cd,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xa9e775e9f4c525a5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x4cf,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd3eb4e0561797b23,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x4d5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xa3c42688818987e5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x4e1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd0374eb0e6fd5b4d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x4eb,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xcd47f7fb3050301d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x4fd,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x667ae561136a4875,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0x9,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x8,%rax\nsub    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x66291a89ad64c38b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x503,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x195a50,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0xcb5ebbe1049160b9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x509,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xcb0e1439e703c483,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x50b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xca1d9b5641228a9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x6,%rax\nimul   $0x511,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xc97e8632c460cfcb,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x515,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x925eb2c993f1117d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x517,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xc891b9e10d83d1c7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x51b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x31afa5f1a33a0827,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x527,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xc6718ffce639c00d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x529,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x62c5eea3350d4fad,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x52f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x1c43a0,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x8138fe4e9fe1e78d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x551,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x5fe2095d12ea16d9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x557,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x7ddb1511b6899a33,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x55d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x7ba4cbe90385a765,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x565,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x76c25545b7e71d19,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x577,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x5d065bef48db7b01,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x581,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x5c1c108d0af957f9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x58f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x5bd9f7bf6abdcd69,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x593,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xb7721dbcffd22379,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x595,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x1f5570,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0xb6ef0753120b1379,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x599,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xb62bc38378155921,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x59f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xb529edf452cc29c1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x5a7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xb4aa141cef3d38a3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x5ab,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x68d4d589f45f241f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x5ad,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6758f5a5cfec5923,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x5b3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x591aa074f2f2997f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x5bf,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xb10135c21e13b4a3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x5c9,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xb0c4198c57b148ad,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x5cb,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x21bd60,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6094bec079332193,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x5cf,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x5806e0898abed6e9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x5d1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xaf95013344c219b9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x5d5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x57708b5b5e199df9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x5db,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x5afb1631cf8b6fa7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x5e7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xac1f99cd3cae23f9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x5f3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2ace569d8342b799,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x5fb,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x53c8eaedea6e7f17,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x607,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2a4eff8113017cc7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x60d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x24cd20,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2a3319e156df3247,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x611,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xa82618a1949bab45,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x617,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x14e94aa8ec8f1c97,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x61f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x29b7529e109f0aeb,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x623,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x298137491ea465d1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x62b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4b32f0f5cfced671,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x62f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x484ba9700cd2f49f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x63d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4779af172f7d8585,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x641,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4640ad525c13c0eb,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x647,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x2780d0,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x28bb1b867199dac5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x649,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4509ffaebd801451,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x64d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x50f567e2e7ceaa75,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x653,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xa1b7ab59dc4ef6af,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x655,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xa11eff369940fbc1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x65b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xa02307a9ad1dde89,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x665,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3c6870791ffb0e5f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x679,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3b4431e049e3fbb1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x67f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x9d4144569cf2a3b5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x683,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x2a8118,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x9d1106987706e7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x2,%rax\nimul   $0x685,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4d6b82cc2279e03f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x69d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4d3ccb5a0f631c83,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x6a1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4d2584bf0eeac12b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x6a3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4cb1f4ea479a23a7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x6ad,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4c290e219e1f3cd7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x6b9,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4c126c7644a49fdf,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x6bb,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x25d1065a1c1122b7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x6c5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x25a48a382b863fd1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x6cd,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x2e91e8,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2c1b8c87666de717,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x6d3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4ac525d2baa21969,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x6d9,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2a0f6d4c683464b7,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x6df,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x270a843ff6c7abdf,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x6f1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x498316412f3cbbcd,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x6f7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2563d99b6f0628f9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x6fb,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x9287f11e3182eef9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x6fd,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x2463801231c00919,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x709,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x21807ea83769983f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x713,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x32b5c0,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x47e6294929b502f3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x71f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x8f2b7b74beb4eb73,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x727,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x1bdbf69332501cd5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x737,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x23372967dbaf1d4d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x745,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x18d18451b8f901c9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x74b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x8c1be98f87980349,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x74f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x8bf59cc55d5a1251,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x751,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x175283c02ba4e497,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x755,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x22e0cce8b3d7209,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x4,%rax\nimul   $0x757,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x3672c0,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x8ac621e15f4585c3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x761,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x13cbbfe624e6026d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x76d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x12ed9bdaf2fa7eff,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x773,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x89086e44c8bb5987,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x779,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x87c16cd7d4840b23,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x78b,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf3aef2e386b0241,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x78d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xd00eb60cdf4b437,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x79d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x865d2998572068f9,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x79f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x9bb3b4be79b500f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x7b5,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x3bc298,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x8ecfbfd69af8a07,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x7bb,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x83edf6774db060e3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x7c3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x838848f598783a93,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x7c9,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x689adb3574c87e3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x7cd,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x6466f6a6bd4754f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x7cf,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x82e02cfd0f76fd51,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x7d3,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x4b5c8c07a35361b,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x7db,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x40fbcfc51bcbb55f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x7e1,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x40a9bd919e3f666d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x7eb,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x3ed168,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0x204cb630b3aab56f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x7ed,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x121456e1bdf5b47,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nshr    %rax\nadd    %rdx,%rax\nshr    $0xa,%rax\nimul   $0x7f7,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xff6063c1a6f7a539,%rdx\nmov    %rcx,%rax\nmul    %rdx\nshr    $0xb,%rdx\nmov    %rdx,%rax\nshl    $0x9,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\ntest   %rdx,%rdx\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x1fc46fae98a1d099,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x80f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xfd66d2187fb0cfdf,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xb,%rax\nimul   $0x815,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xfbf0beec70af2d65,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xb,%rax\nimul   $0x821,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x1f765a3556a4ee6d,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x8,%rax\nimul   $0x823,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xfb37524ec0178d3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x827,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xfaf9c007d7ce003f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xb,%rax\nimul   $0x829,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\ncmpq   $0x433a28,-0x58(%rbp)\njbe    57cd <is_prime+0x4548>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf9c7a736078fcb5,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nimul   $0x833,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf85c2a33a92bc73f,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xb,%rax\nimul   $0x83f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x7c0ffe0fc007c1,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x2,%rax\nimul   $0x841,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3d90a76147107935,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x851,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf60772b9b91f5ab3,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xb,%rax\nimul   $0x853,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0x3d55a71cded12917,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0x9,%rax\nimul   $0x859,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf4e1453b2ff29baf,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xb,%rax\nimul   $0x85d,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf4a6c3ac61001e95,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xb,%rax\nimul   $0x85f,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    -0x58(%rbp),%rcx\nmovabs $0xf383dd47b2f346fd,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    $0xb,%rax\nimul   $0x869,%rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\ntest   %rax,%rax\nje     57d7 <is_prime+0x4552>\nmov    $0x1,%eax\njmp    598c <is_prime+0x4707>\nmov    $0x0,%eax\njmp    598c <is_prime+0x4707>\nmov    -0x58(%rbp),%rax\nsub    $0x1,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x38(%rbp)\nmovl   $0x0,-0x48(%rbp)\njmp    5806 <is_prime+0x4581>\nshrq   -0x38(%rbp)\naddl   $0x1,-0x48(%rbp)\nmov    -0x38(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nje     57fe <is_prime+0x4579>\njmp    5976 <is_prime+0x46f1>\nmovq   $0x0,-0x20(%rbp)\njmp    583f <is_prime+0x45ba>\ncall   87d6 <libmin_rand>\nmov    %eax,%ecx\nmov    -0x20(%rbp),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,-0x20(%rbp)\nlea    -0x40(%rbp),%rdx\nadd    %rdx,%rax\nmov    %ecx,%edx\nmov    %dl,(%rax)\ncmpq   $0x7,-0x20(%rbp)\njbe    5821 <is_prime+0x459c>\nmov    -0x40(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x18(%rbp)\nmov    %rdx,%rax\nadd    $0x1,%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x58(%rbp),%rax\nmov    %rax,-0x28(%rbp)\nnop\nmov    -0x30(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x28(%rbp)\nmov    %rdx,-0x30(%rbp)\ncmpq   $0x0,-0x30(%rbp)\nje     589f <is_prime+0x461a>\nmov    -0x28(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\ncmpq   $0x0,-0x28(%rbp)\njne    586f <is_prime+0x45ea>\ncmpq   $0x1,-0x30(%rbp)\njbe    58ad <is_prime+0x4628>\ncmpq   $0x1,-0x28(%rbp)\nja     5846 <is_prime+0x45c1>\nmovq   $0x1,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,-0x30(%rbp)\njmp    58c3 <is_prime+0x463e>\nshlq   -0x28(%rbp)\nmov    -0x28(%rbp),%rax\ncmp    -0x38(%rbp),%rax\njbe    58bf <is_prime+0x463a>\njmp    5917 <is_prime+0x4692>\nmov    -0x58(%rbp),%rdx\nmov    -0x30(%rbp),%rcx\nmov    -0x30(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <multiplication_modulo>\nmov    %rax,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nand    -0x38(%rbp),%rax\ntest   %rax,%rax\nje     5917 <is_prime+0x4692>\nmov    -0x58(%rbp),%rdx\nmov    -0x30(%rbp),%rcx\nmov    -0x10(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <multiplication_modulo>\nmov    %rax,-0x30(%rbp)\ncmpq   $0x0,-0x30(%rbp)\nshrq   -0x28(%rbp)\ncmpq   $0x0,-0x28(%rbp)\njne    58cf <is_prime+0x464a>\ncmpq   $0x1,-0x30(%rbp)\njne    592b <is_prime+0x46a6>\njmp    5976 <is_prime+0x46f1>\nmov    -0x48(%rbp),%eax\nmov    %eax,-0x44(%rbp)\njmp    594e <is_prime+0x46c9>\nmov    -0x58(%rbp),%rdx\nmov    -0x30(%rbp),%rcx\nmov    -0x30(%rbp),%rax\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <multiplication_modulo>\nmov    %rax,-0x30(%rbp)\nmov    -0x44(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x44(%rbp)\ntest   %eax,%eax\nje     5965 <is_prime+0x46e0>\nmov    -0x30(%rbp),%rax\ncmp    -0x18(%rbp),%rax\njne    5933 <is_prime+0x46ae>\nmov    -0x30(%rbp),%rax\ncmp    -0x18(%rbp),%rax\nje     5976 <is_prime+0x46f1>\nmov    $0x0,%eax\njmp    598c <is_prime+0x4707>\nmov    -0x5c(%rbp),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,-0x5c(%rbp)\ntest   %eax,%eax\njne    5817 <is_prime+0x4592>\nmov    $0x1,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     59a0 <is_prime+0x471b>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "rho-factor/rho-factor.c", "function_name": "main", "content": "int main(void)\n{\n    // allocate memory for 64 factors.\n    positive_number *factors = libmin_calloc(64, sizeof(positive_number));\n    positive_number n = 0, mask = -1;\n    /* TMA: unsigned sr = (size_t)factors; sr = -sr / 561; libmin_printf(\"srand at %u :\\n\\n\", sr); */ libmin_srand(/* TMA: sr */42);\n    for (int wrapper = 4, count = 0, j; wrapper < 64; ++wrapper)\n    {\n        for (int64_t n_bits = wrapper; n_bits <= 64; ++n_bits)\n        {\n            // generate a random number of ~ n_bits bits.\n            n = 0;\n            for (size_t k = 0; k < sizeof(positive_number); k++)\n            {\n              ((char *) &n)[k] = (libmin_rand() & 0xff);\n            }\n            n &= mask >> ((positive_number)8 * sizeof(positive_number) - n_bits); n += !(n & (positive_number)1);\n            libmin_printf(\"%5d. (%2ld bits) %22lu = \", ++count, n_bits, n);\n            // fill the \"factors\" array with the prime factors.\n            factor(n, factors);\n            // iterate over the factors (zero terminated array).\n            for (j = 0; factors[j + 1]; ++j) {\n                libmin_printf(\"%lu * \", factors[j]);\n                libmin_assert(n % factors[j] == 0);\n                libmin_assert(is_prime(factors[j], 36));\n            }\n            libmin_printf(\"%lu\\n\", factors[j]);\n        }\n    }\n\n    // release memory.\n    libmin_free(factors);\n\n    // proper exit\n    libmin_success();\n}\n"}, "pseudo": {"path": "rho-factor/rho-factor.host.O0.pseudo", "function_name": "main", "address": "0x5c7d", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int wrapper; // [rsp+4h] [rbp-3Ch]\n  int count; // [rsp+8h] [rbp-38h]\n  int j; // [rsp+Ch] [rbp-34h]\n  positive_number n; // [rsp+10h] [rbp-30h]\n  int64_t n_bits; // [rsp+18h] [rbp-28h]\n  size_t k; // [rsp+20h] [rbp-20h]\n  positive_number *factors; // [rsp+28h] [rbp-18h]\n  positive_number mask; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+38h] [rbp-8h]\n\n  v11 = __readfsqword(0x28u);\n  factors = (positive_number *)libmin_calloc(0x40uLL, 8uLL);\n  n = 0LL;\n  mask = -1LL;\n  libmin_srand(0x2Au);\n  wrapper = 4;\n  count = 0;\n  while ( wrapper <= 63 )\n  {\n    for ( n_bits = wrapper; n_bits <= 64; ++n_bits )\n    {\n      n = 0LL;\n      for ( k = 0LL; k <= 7; ++k )\n        *((_BYTE *)&n + k) = libmin_rand();\n      n &= mask >> (64 - (unsigned __int8)n_bits);\n      n += (n & 1) == 0;\n      libmin_printf(\"%5d. (%2ld bits) %22lu = \", ++count, n_bits, n);\n      factor(n, factors);\n      for ( j = 0; factors[j + 1]; ++j )\n      {\n        libmin_printf(\"%lu * \", factors[j]);\n        if ( n % factors[j] )\n          libmin_fail(1);\n        if ( !is_prime(factors[j], 36) )\n          libmin_fail(1);\n      }\n      libmin_printf(\"%lu\\n\", factors[j]);\n    }\n    ++wrapper;\n  }\n  libmin_free(factors);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int wrapper;\n  int count;\n  int j;\n  positive_number n;\n  int64_t n_bits;\n  unsigned int k;\n  positive_number *factors;\n  positive_number mask;\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  factors = (positive_number *)libmin_calloc(64uLL, 8uLL);\n  n = 0LL;\n  mask = -1LL;\n  libmin_srand(42u);\n  wrapper = 4;\n  count = 0;\n  while (wrapper <= 63) {\n    for (n_bits = wrapper; n_bits <= 64; ++n_bits) {\n      n = 0LL;\n      for (k = 0LL; k <= 7; ++k) *((uint8_t *)&n + k) = libmin_rand();\n      n &= mask >> (64 - (unsigned char)n_bits);\n      n += (n & 1) == 0;\n      libmin_printf(\"%5d. (%2ld bits) %22lu = \", ++count, n_bits, n);\n      factor(n, factors);\n      for (j = 0; factors[j + 1]; ++j) {\n        libmin_printf(\"%lu * \", factors[j]);\n        if (n % factors[j]) libmin_fail(1);\n        if (!is_prime(factors[j], 36)) libmin_fail(1);\n      }\n      libmin_printf(\"%lu\\n\", factors[j]);\n    }\n    ++wrapper;\n  }\n  libmin_free(factors);\n  libmin_success();\n}", "binary": "rho-factor/rho-factor.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x8,%esi\nmov    $0x40,%edi\ncall   626f <libmin_calloc>\nmov    %rax,-0x18(%rbp)\nmovq   $0x0,-0x30(%rbp)\nmovq   $0xffffffffffffffff,-0x10(%rbp)\nmov    $0x2a,%edi\ncall   8724 <libmin_srand>\nmovl   $0x4,-0x3c(%rbp)\nmovl   $0x0,-0x38(%rbp)\njmp    5e98 <main+0x21b>\nmov    -0x3c(%rbp),%eax\ncltq\nmov    %rax,-0x28(%rbp)\njmp    5e89 <main+0x20c>\nmovq   $0x0,-0x30(%rbp)\nmovq   $0x0,-0x20(%rbp)\njmp    5d11 <main+0x94>\ncall   87d6 <libmin_rand>\nmov    %eax,%edx\nlea    -0x30(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nadd    %rcx,%rax\nmov    %dl,(%rax)\naddq   $0x1,-0x20(%rbp)\ncmpq   $0x7,-0x20(%rbp)\njbe    5cf8 <main+0x7b>\nmov    -0x28(%rbp),%rax\nmov    %eax,%edx\nmov    $0x40,%eax\nsub    %edx,%eax\nmov    -0x10(%rbp),%rdx\nmov    %eax,%ecx\nshr    %cl,%rdx\nmov    -0x30(%rbp),%rax\nand    %rdx,%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nsete   %al\nmovzbl %al,%edx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmov    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rcx\naddl   $0x1,-0x38(%rbp)\nmov    -0x28(%rbp),%rdx\nmov    -0x38(%rbp),%eax\nmov    %eax,%esi\nlea    0x3298(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   84f5 <libmin_printf>\nmov    -0x30(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   5ab8 <factor>\nmovl   $0x0,-0x34(%rbp)\njmp    5e32 <main+0x1b5>\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x3265(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   84f5 <libmin_printf>\nmov    -0x30(%rbp),%rax\nmov    -0x34(%rbp),%edx\nmovslq %edx,%rdx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%rcx\nmov    $0x0,%edx\ndiv    %rcx\nmov    %rdx,%rax\ntest   %rax,%rax\nje     5dfc <main+0x17f>\nmov    $0x1,%edi\ncall   6010 <libmin_fail>\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    $0x24,%esi\nmov    %rax,%rdi\ncall   1285 <is_prime>\ntest   %eax,%eax\njne    5e2e <main+0x1b1>\nmov    $0x1,%edi\ncall   6010 <libmin_fail>\naddl   $0x1,-0x34(%rbp)\nmov    -0x34(%rbp),%eax\ncltq\nadd    $0x1,%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\ntest   %rax,%rax\njne    5d98 <main+0x11b>\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x31ae(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   84f5 <libmin_printf>\naddq   $0x1,-0x28(%rbp)\ncmpq   $0x40,-0x28(%rbp)\njle    5ce6 <main+0x69>\naddl   $0x1,-0x3c(%rbp)\ncmpl   $0x3f,-0x3c(%rbp)\njle    5cd8 <main+0x5b>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   617e <libmin_free>\ncall   8a8d <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     5ecc <main+0x24f>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "rho-factor/rho-factor.c", "function_name": "multiplication_modulo", "content": "static positive_number multiplication_modulo(positive_number a, positive_number b, const positive_number mod) {\n    positive_number res = 0, tmp;\n    for (b %= mod; a; a & 1 ? b >= mod - res ? res -= mod : 0, res += b : 0, a >>= 1, (tmp = b) >= mod - b ? tmp -= mod : 0, b += tmp);\n    return res % mod;\n}\n"}, "pseudo": {"path": "rho-factor/rho-factor.host.O0.pseudo", "function_name": "multiplication_modulo", "address": "0x11e9", "label": "multiplication_modulo", "content": "positive_number __cdecl multiplication_modulo(positive_number a, positive_number b, const positive_number mod)\n{\n  positive_number ba; // [rsp+8h] [rbp-20h]\n  positive_number res; // [rsp+18h] [rbp-10h]\n  positive_number tmp; // [rsp+20h] [rbp-8h]\n\n  res = 0LL;\n  ba = b % mod;\n  while ( a )\n  {\n    if ( (a & 1) != 0 )\n    {\n      if ( ba >= mod - res )\n        res -= mod;\n      res += ba;\n    }\n    a >>= 1;\n    tmp = ba;\n    if ( ba >= mod - ba )\n      tmp = ba - mod;\n    ba += tmp;\n  }\n  return res % mod;\n}\n"}, "pseudo_normalize": "positive_number multiplication_modulo(positive_number a, positive_number b,\n                                      const positive_number mod) {\n  positive_number ba;\n  positive_number res;\n  positive_number tmp;\n  res = 0LL;\n  ba = b % mod;\n  while (a) {\n    if ((a & 1) != 0) {\n      if (ba >= mod - res) res -= mod;\n      res += ba;\n    }\n    a >>= 1;\n    tmp = ba;\n    if (ba >= mod - ba) tmp = ba - mod;\n    ba += tmp;\n  }\n  return res % mod;\n}", "binary": "rho-factor/rho-factor.host.O0", "assembly": "<multiplication_modulo>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %rdx,-0x28(%rbp)\nmovq   $0x0,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x28(%rbp)\nmov    %rdx,-0x20(%rbp)\njmp    126c <multiplication_modulo+0x83>\nmov    -0x18(%rbp),%rax\nand    $0x1,%eax\ntest   %rax,%rax\nje     1242 <multiplication_modulo+0x59>\nmov    -0x28(%rbp),%rax\nsub    -0x10(%rbp),%rax\ncmp    %rax,-0x20(%rbp)\njb     123a <multiplication_modulo+0x51>\nmov    -0x28(%rbp),%rax\nsub    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nadd    %rax,-0x10(%rbp)\nshrq   -0x18(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x28(%rbp),%rax\nsub    -0x20(%rbp),%rax\ncmp    %rax,-0x8(%rbp)\njb     1264 <multiplication_modulo+0x7b>\nmov    -0x28(%rbp),%rax\nsub    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nadd    %rax,-0x20(%rbp)\ncmpq   $0x0,-0x18(%rbp)\njne    1218 <multiplication_modulo+0x2f>\nmov    -0x10(%rbp),%rax\nmov    $0x0,%edx\ndivq   -0x28(%rbp)\nmov    %rdx,%rax\npop    %rbp\nret\n"}
{"source": {"path": "rle-compress/rle-compress.c", "function_name": "main", "content": "/**\n * @brief Main function\n * @returns 0 on exit\n */\nint main() {\n    test();  // run self-test implementations\n\n    libmin_printf(\"All tests have passed!\\n\");\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "rle-compress/rle-compress.host.O0.pseudo", "function_name": "main", "address": "0x14c8", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  test();\n  libmin_printf(\"All tests have passed!\\n\", argv);\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "rle-compress/rle-compress.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x0,%eax\ncall   137b <test>\nlea    0x2c91(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b21 <libmin_printf>\ncall   3eb7 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "rle-compress/rle-compress.c", "function_name": "run_length_encode", "content": "/**\n * @file\n * @author [serturx](https://github.com/serturx/)\n * @brief Encode a null terminated string using [Run-length encoding](https://en.wikipedia.org/wiki/Run-length_encoding)\n * @details\n * Run-length encoding is a lossless compression algorithm.\n * It works by counting the consecutive occurences symbols\n * and encodes that series of consecutive symbols into the\n * counted symbol and a number denoting the number of\n * consecutive occorences.\n * \n * For example the string \"AAAABBCCD\" gets encoded into \"4A2B2C1D\"\n * \n */\n\n#include \"libmin.h\"\n\n/**\n * @brief Encodes a null-terminated string using run-length encoding\n * @param str String to encode\n * @return char* Encoded string\n */\n\nchar* run_length_encode(char* str) {\n    int str_length = libmin_strlen(str);\n    int encoded_index = 0;\n\n    //allocate space for worst-case scenario\n    char* encoded = libmin_malloc(2 * libmin_strlen(str) + 1);\n    \n    //temp space for int to str conversion\n    char int_str[20];\n\n    for(int i = 0; i < str_length; ++i) {\n        int count = 0;\n        char current = str[i];\n\n        //count occurences\n        while(current == str[i + count]) count++;\n\n        i += count - 1;\n\n        //convert occurrence amount to string and write to encoded string\n        libmin_snprintf(int_str, 20, \"%d\", count);\n        libmin_strncpy(&encoded[encoded_index], int_str, libmin_strlen(int_str));\n\n        //write current char to encoded string\n        encoded_index += libmin_strlen(int_str);\n        encoded[encoded_index] = current;\n        ++encoded_index;\n    }\n\n    //null terminate string and move encoded string to compacted memory space \n    encoded[encoded_index] = '\\0';\n    char* compacted_string = libmin_malloc(libmin_strlen(encoded) + 1);\n    libmin_strcpy(compacted_string, encoded);\n    \n    libmin_free(encoded);\n\n    return compacted_string;\n}\n"}, "pseudo": {"path": "rle-compress/rle-compress.host.O0.pseudo", "function_name": "run_length_encode", "address": "0x11e9", "label": "run_length_encode", "content": "char *__cdecl run_length_encode(char *str)\n{\n  size_t v1; // rax\n  size_t v2; // rax\n  size_t v3; // rax\n  char current; // [rsp+1Fh] [rbp-41h]\n  int encoded_index; // [rsp+20h] [rbp-40h]\n  int encoded_indexa; // [rsp+20h] [rbp-40h]\n  int i; // [rsp+24h] [rbp-3Ch]\n  int count; // [rsp+28h] [rbp-38h]\n  int str_length; // [rsp+2Ch] [rbp-34h]\n  char *encoded; // [rsp+30h] [rbp-30h]\n  char *compacted_string; // [rsp+38h] [rbp-28h]\n  char int_str[24]; // [rsp+40h] [rbp-20h] BYREF\n  unsigned __int64 v14; // [rsp+58h] [rbp-8h]\n\n  v14 = __readfsqword(0x28u);\n  str_length = libmin_strlen(str);\n  encoded_index = 0;\n  v1 = libmin_strlen(str);\n  encoded = (char *)libmin_malloc(2 * v1 + 1);\n  for ( i = 0; i < str_length; i += count )\n  {\n    count = 0;\n    current = str[i];\n    while ( current == str[i + count] )\n      ++count;\n    libmin_snprintf(int_str, 0x14uLL, \"%d\", count);\n    v2 = libmin_strlen(int_str);\n    libmin_strncpy(&encoded[encoded_index], int_str, v2);\n    encoded_indexa = libmin_strlen(int_str) + encoded_index;\n    encoded[encoded_indexa] = current;\n    encoded_index = encoded_indexa + 1;\n  }\n  encoded[encoded_index] = 0;\n  v3 = libmin_strlen(encoded);\n  compacted_string = (char *)libmin_malloc(v3 + 1);\n  libmin_strcpy(compacted_string, encoded);\n  libmin_free(encoded);\n  return compacted_string;\n}\n"}, "pseudo_normalize": "char *run_length_encode(char *str) {\n  unsigned int v1;\n  unsigned int v2;\n  unsigned int v3;\n  char current;\n  int encoded_index;\n  int encoded_indexa;\n  int i;\n  int count;\n  int str_length;\n  char *encoded;\n  char *compacted_string;\n  char int_str[24];\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  str_length = libmin_strlen(str);\n  encoded_index = 0;\n  v1 = libmin_strlen(str);\n  encoded = (char *)libmin_malloc(2 * v1 + 1);\n  for (i = 0; i < str_length; i += count) {\n    count = 0;\n    current = str[i];\n    while (current == str[i + count]) ++count;\n    libmin_snprintf(int_str, 20uLL, \"%d\", count);\n    v2 = libmin_strlen(int_str);\n    libmin_strncpy(&encoded[encoded_index], int_str, v2);\n    encoded_indexa = libmin_strlen(int_str) + encoded_index;\n    encoded[encoded_indexa] = current;\n    encoded_index = encoded_indexa + 1;\n  }\n  encoded[encoded_index] = 0;\n  v3 = libmin_strlen(encoded);\n  compacted_string = (char *)libmin_malloc(v3 + 1);\n  libmin_strcpy(compacted_string, encoded);\n  libmin_free(encoded);\n  return compacted_string;\n}", "binary": "rle-compress/rle-compress.host.O0", "assembly": "<run_length_encode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   3df9 <libmin_strlen>\nmov    %eax,-0x34(%rbp)\nmovl   $0x0,-0x40(%rbp)\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   3df9 <libmin_strlen>\nadd    %rax,%rax\nadd    $0x1,%rax\nmov    %rax,%rdi\ncall   16bf <libmin_malloc>\nmov    %rax,-0x30(%rbp)\nmovl   $0x0,-0x3c(%rbp)\njmp    130a <run_length_encode+0x121>\nmovl   $0x0,-0x38(%rbp)\nmov    -0x3c(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\nmov    %al,-0x41(%rbp)\njmp    1269 <run_length_encode+0x80>\naddl   $0x1,-0x38(%rbp)\nmov    -0x3c(%rbp),%edx\nmov    -0x38(%rbp),%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    -0x58(%rbp),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ncmp    %al,-0x41(%rbp)\nje     1265 <run_length_encode+0x7c>\nmov    -0x38(%rbp),%eax\nsub    $0x1,%eax\nadd    %eax,-0x3c(%rbp)\nmov    -0x38(%rbp),%edx\nlea    -0x20(%rbp),%rax\nmov    %edx,%ecx\nlea    0x2d6c(%rip),%rdx\nmov    $0x14,%esi\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c50 <libmin_snprintf>\nlea    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   3df9 <libmin_strlen>\nmov    %rax,%rdx\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rcx\nlea    -0x20(%rbp),%rax\nmov    %rax,%rsi\nmov    %rcx,%rdi\ncall   3e37 <libmin_strncpy>\nlea    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   3df9 <libmin_strlen>\nmov    %eax,%edx\nmov    -0x40(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x40(%rbp)\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rax,%rdx\nmovzbl -0x41(%rbp),%eax\nmov    %al,(%rdx)\naddl   $0x1,-0x40(%rbp)\naddl   $0x1,-0x3c(%rbp)\nmov    -0x3c(%rbp),%eax\ncmp    -0x34(%rbp),%eax\njl     1249 <run_length_encode+0x60>\nmov    -0x40(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x30(%rbp),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   3df9 <libmin_strlen>\nadd    $0x1,%rax\nmov    %rax,%rdi\ncall   16bf <libmin_malloc>\nmov    %rax,-0x28(%rbp)\nmov    -0x30(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3dae <libmin_strcpy>\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   17aa <libmin_free>\nmov    -0x28(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1379 <run_length_encode+0x190>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "rle-compress/rle-compress.c", "function_name": "test", "content": "/**\n * @brief Self-test implementations\n * @returns void\n */\nstatic void test() {\n    char *in, *out;\n    in = \"aaaaaaabbbaaccccdefaadr\";\n    out = run_length_encode(in);\n    libmin_assert(!libmin_strcmp(out, \"7a3b2a4c1d1e1f2a1d1r\"));\n    libmin_printf(\"in: %s -> out: %s\\n\", in, out);\n    libmin_free(out);\n \n    in = \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\";\n    out = run_length_encode(in);\n    libmin_assert(!libmin_strcmp(out, \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\"));\n    libmin_printf(\"in: %s -> out: %s\\n\", in, out);\n    libmin_free(out);\n\n    in = \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\";\n    out = run_length_encode(in);\n    libmin_assert(!libmin_strcmp(out, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\"));\n    libmin_printf(\"in: %s -> out: %s\\n\", in, out);\n    libmin_free(out);\n}\n"}, "pseudo": {"path": "rle-compress/rle-compress.host.O0.pseudo", "function_name": "test", "address": "0x137b", "label": "test", "content": "void __cdecl test()\n{\n  char *out; // [rsp+8h] [rbp-8h]\n  char *outa; // [rsp+8h] [rbp-8h]\n  char *outb; // [rsp+8h] [rbp-8h]\n\n  out = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if ( libmin_strcmp(out, \"7a3b2a4c1d1e1f2a1d1r\") )\n    libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", out);\n  libmin_free(out);\n  outa = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n  if ( libmin_strcmp(outa, \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\") )\n    libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\", \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", outa);\n  libmin_free(outa);\n  outb = run_length_encode(\"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\");\n  if ( libmin_strcmp(outb, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\") )\n    libmin_fail(1);\n  libmin_printf(\n    \"in: %s -> out: %s\\n\",\n    \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n    outb);\n  libmin_free(outb);\n}\n"}, "pseudo_normalize": "void test() {\n  char *out;\n  char *outa;\n  char *outb;\n  out = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if (libmin_strcmp(out, \"7a3b2a4c1d1e1f2a1d1r\")) libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", out);\n  libmin_free(out);\n  outa = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n  if (libmin_strcmp(outa,\n                    \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u\"\n                    \"1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\"))\n    libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\",\n                \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", outa);\n  libmin_free(outa);\n  outb = run_length_encode(\n      \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n      \"aaaaaaaaaaaaaaaaaaaaahghghrw\");\n  if (libmin_strcmp(outb, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\"))\n    libmin_fail(1);\n  libmin_printf(\"in: %s -> out: %s\\n\",\n                \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n                \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n                outb);\n  libmin_free(outb);\n}", "binary": "rle-compress/rle-compress.host.O0", "assembly": "<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nlea    0x2c7d(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <run_length_encode>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x2c76(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3d50 <libmin_strcmp>\ntest   %eax,%eax\nje     13c6 <test+0x4b>\nmov    $0x1,%edi\ncall   163c <libmin_fail>\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2c60(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b21 <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   17aa <libmin_free>\nlea    0x2c58(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <run_length_encode>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x2c69(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3d50 <libmin_strcmp>\ntest   %eax,%eax\nje     1430 <test+0xb5>\nmov    $0x1,%edi\ncall   163c <libmin_fail>\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2bf6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b21 <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   17aa <libmin_free>\nlea    0x2c7e(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <run_length_encode>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nlea    0x2cc7(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3d50 <libmin_strcmp>\ntest   %eax,%eax\nje     149a <test+0x11f>\nmov    $0x1,%edi\ncall   163c <libmin_fail>\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2b8c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3b21 <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   17aa <libmin_free>\nnop\nleave\nret\n"}
{"source": {"path": "rsa-cipher/rsa-cipher.c", "function_name": "main", "content": "int main() {\n    // Fixed primes for demonstration (not cryptographically secure)\n    unsigned long long p_ll = 1000003ULL;  // About 1e6\n    unsigned long long q_ll = 1000033ULL;  // About 1e6\n    int128 p = p_ll;\n    int128 q = q_ll;\n    \n    // Compute modulus: n = p * q (using 128-bit arithmetic)\n    int128 n = p * q;\n    \n    // Compute Euler's totient: phi = (p - 1) * (q - 1)\n    int128 phi = (p - 1) * (q - 1);\n    \n    // Choose a common public exponent e = 65537\n    int128 e = 65537;\n    \n    // Compute private exponent d as the modular inverse of e modulo phi\n    int128 d = mod_inverse(e, phi);\n    \n    // Choose a sample message to encrypt (must be less than n)\n    int128 message = 0xdeadbeef;\n    \n    // Encrypt: ciphertext = message^e mod n\n    int128 encrypted = mod_pow(message, e, n);\n    \n    // Decrypt: decrypted = ciphertext^d mod n\n    int128 decrypted = mod_pow(encrypted, d, n);\n    \n    // Print all outputs in hexadecimal\n    libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n    \n    libmin_printf(\"p: \");\n    print_hex_int128(p);\n    libmin_printf(\"\\nq: \");\n    print_hex_int128(q);\n    \n    libmin_printf(\"\\nn (modulus): \");\n    print_hex_int128(n);\n    \n    libmin_printf(\"\\nphi(n): \");\n    print_hex_int128(phi);\n    \n    libmin_printf(\"\\n\\nPublic exponent (e): \");\n    print_hex_int128(e);\n    \n    libmin_printf(\"\\nPrivate exponent (d): \");\n    print_hex_int128(d);\n    \n    libmin_printf(\"\\n\\nOriginal message: \");\n    print_hex_int128(message);\n    \n    libmin_printf(\"\\nEncrypted message: \");\n    print_hex_int128(encrypted);\n    \n    libmin_printf(\"\\nDecrypted message: \");\n    print_hex_int128(decrypted);\n    \n    libmin_printf(\"\\n\");\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "rsa-cipher/rsa-cipher.host.O0.pseudo", "function_name": "main", "address": "0x1634", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int128 v3; // rdx\n  int128 v4; // rdi\n  int128 d; // [rsp+60h] [rbp-50h]\n  int128 decrypted; // [rsp+90h] [rbp-20h]\n\n  *((_QWORD *)&v3 + 1) = (__PAIR128__(((0xF4261 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1, 1000032LL)\n                        * __PAIR128__(((0xF4243 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1, 1000002LL)) >> 64;\n  *(_QWORD *)&v3 = 0xE8D6ABDCC0LL;\n  d = mod_inverse(0x10001uLL, v3);\n  v4 = mod_pow(0xDEADBEEFuLL, 0x10001uLL, 0xF4243 * (unsigned __int128)0xF4261uLL);\n  decrypted = mod_pow(v4, d, 0xF4243 * (unsigned __int128)0xF4261uLL);\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(0xF4243uLL);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(0xF4261uLL);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(0xF4243 * (unsigned __int128)0xF4261uLL);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(\n    __PAIR128__(((0xF4261 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1, 1000032LL)\n  * __PAIR128__(((0xF4243 + (unsigned __int128)0xFFFFFFFFFFFFFFFFLL) >> 64) - 1, 1000002LL));\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(0x10001uLL);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  print_hex_int128(d);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(0xDEADBEEFuLL);\n  libmin_printf(\"\\nEncrypted message: \");\n  print_hex_int128(v4);\n  libmin_printf(\"\\nDecrypted message: \");\n  print_hex_int128(decrypted);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int128 v3;\n  int128 v4;\n  int128 d;\n  int128 decrypted;\n  *((uint64_t *)&v3 + 1) =\n      (__PAIR128__(\n           ((1000033 + (unsigned __int128)18446744073709551615LL) >> 64) - 1,\n           1000032LL) *\n       __PAIR128__(\n           ((1000003 + (unsigned __int128)18446744073709551615LL) >> 64) - 1,\n           1000002LL)) >>\n      64;\n  *(uint64_t *)&v3 = 1000034000064LL;\n  d = mod_inverse(65537uLL, v3);\n  v4 =\n      mod_pow(3735928559uLL, 65537uLL, 1000003 * (unsigned __int128)1000033uLL);\n  decrypted = mod_pow(v4, d, 1000003 * (unsigned __int128)1000033uLL);\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(1000003uLL);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(1000033uLL);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(1000003 * (unsigned __int128)1000033uLL);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(\n      __PAIR128__(\n          ((1000033 + (unsigned __int128)18446744073709551615LL) >> 64) - 1,\n          1000032LL) *\n      __PAIR128__(\n          ((1000003 + (unsigned __int128)18446744073709551615LL) >> 64) - 1,\n          1000002LL));\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(65537uLL);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  print_hex_int128(d);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(3735928559uLL);\n  libmin_printf(\"\\nEncrypted message: \");\n  print_hex_int128(v4);\n  libmin_printf(\"\\nDecrypted message: \");\n  print_hex_int128(decrypted);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}", "binary": "rsa-cipher/rsa-cipher.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0xa8,%rsp\nmovq   $0xf4243,-0xb0(%rbp)\nmovq   $0xf4261,-0xa8(%rbp)\nmov    -0xb0(%rbp),%rax\nmov    %rax,-0xa0(%rbp)\nmovq   $0x0,-0x98(%rbp)\nmov    -0xa8(%rbp),%rax\nmov    %rax,-0x90(%rbp)\nmovq   $0x0,-0x88(%rbp)\nmov    -0x98(%rbp),%rax\nimul   -0x90(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x88(%rbp),%rax\nimul   -0xa0(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x90(%rbp),%rax\nmulq   -0xa0(%rbp)\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x80(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    %rax,-0x80(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    -0xa0(%rbp),%rax\nmov    -0x98(%rbp),%rdx\nadd    $0xffffffffffffffff,%rax\nadc    $0xffffffffffffffff,%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    -0x90(%rbp),%rax\nmov    -0x88(%rbp),%rdx\nadd    $0xffffffffffffffff,%rax\nadc    $0xffffffffffffffff,%rdx\nmov    %rbx,%rdi\nimul   %rax,%rdi\nmov    %rdx,%rsi\nimul   %rcx,%rsi\nadd    %rdi,%rsi\nmul    %rcx\nlea    (%rsi,%rdx,1),%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x70(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    %rax,-0x70(%rbp)\nmov    %rdx,-0x68(%rbp)\nmovq   $0x10001,-0x60(%rbp)\nmovq   $0x0,-0x58(%rbp)\nmov    -0x70(%rbp),%rax\nmov    -0x68(%rbp),%rdx\nmov    -0x60(%rbp),%rdi\nmov    -0x58(%rbp),%rsi\nmov    %rdx,%rcx\nmov    %rax,%rdx\ncall   1363 <mod_inverse>\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    $0xdeadbeef,%eax\nmov    $0x0,%edx\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x80(%rbp),%rcx\nmov    -0x78(%rbp),%rbx\nmov    -0x60(%rbp),%rax\nmov    -0x58(%rbp),%rdx\nmov    -0x40(%rbp),%rdi\nmov    -0x38(%rbp),%rsi\nmov    %rcx,%r8\nmov    %rbx,%r9\nmov    %rdx,%rcx\nmov    %rax,%rdx\ncall   11e9 <mod_pow>\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x80(%rbp),%rcx\nmov    -0x78(%rbp),%rbx\nmov    -0x50(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nmov    -0x30(%rbp),%rdi\nmov    -0x28(%rbp),%rsi\nmov    %rcx,%r8\nmov    %rbx,%r9\nmov    %rdx,%rcx\nmov    %rax,%rdx\ncall   11e9 <mod_pow>\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nlea    0x3848(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nlea    0x3861(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0xa0(%rbp),%rdx\nmov    -0x98(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x3838(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x90(%rbp),%rdx\nmov    -0x88(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x3810(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x80(%rbp),%rdx\nmov    -0x78(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x37f8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x70(%rbp),%rdx\nmov    -0x68(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x37db(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x60(%rbp),%rdx\nmov    -0x58(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x37cc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x50(%rbp),%rdx\nmov    -0x48(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x37bd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x40(%rbp),%rdx\nmov    -0x38(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x37ab(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x30(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x3799(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x20(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rdi\nmov    %rax,%rsi\ncall   14ef <print_hex_int128>\nlea    0x3787(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\ncall   3d25 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "rsa-cipher/rsa-cipher.c", "function_name": "mod_inverse", "content": "// Extended Euclidean Algorithm: returns d such that (a*d) % mod == 1\nint128 mod_inverse(int128 a, int128 mod) {\n    int128 m0 = mod, t, q;\n    int128 x0 = 0, x1 = 1;\n    \n    if (mod == 1)\n        return 0;\n    \n    while (a > 1) {\n        q = a / mod;\n        t = mod;\n        mod = a % mod;\n        a = t;\n        \n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    \n    if (x1 < 0)\n        x1 += m0;\n    return x1;\n}\n"}, "pseudo": {"path": "rsa-cipher/rsa-cipher.host.O0.pseudo", "function_name": "mod_inverse", "address": "0x1363", "label": "mod_inverse", "content": "int128 __cdecl mod_inverse(int128 a, int128 mod)\n{\n  int128 v3; // rax\n  int128 v4; // rax\n  int128 moda; // [rsp+0h] [rbp-80h]\n  int128 x0; // [rsp+20h] [rbp-60h]\n  int128 x1; // [rsp+30h] [rbp-50h]\n  int128 q; // [rsp+50h] [rbp-30h]\n  int128 t; // [rsp+60h] [rbp-20h]\n  int128 ta; // [rsp+60h] [rbp-20h]\n\n  moda = mod;\n  x0 = 0uLL;\n  x1 = 1uLL;\n  if ( !(*((_QWORD *)&mod + 1) | (unsigned __int64)mod ^ 1) )\n    return 0LL;\n  while ( 1 < a )\n  {\n    *(_QWORD *)&v3 = _divti3(a, *((_QWORD *)&a + 1), moda, *((_QWORD *)&moda + 1));\n    q = v3;\n    t = moda;\n    *(_QWORD *)&v4 = _modti3(a, *((_QWORD *)&a + 1), moda, *((_QWORD *)&moda + 1));\n    moda = v4;\n    a = t;\n    ta = x0;\n    x0 = x1 - q * x0;\n    x1 = ta;\n  }\n  if ( x1 < 0 )\n    x1 += mod;\n  return x1;\n}\n"}, "pseudo_normalize": "int128 mod_inverse(int128 a, int128 mod) {\n  int128 v3;\n  int128 v4;\n  int128 moda;\n  int128 x0;\n  int128 x1;\n  int128 q;\n  int128 t;\n  int128 ta;\n  moda = mod;\n  x0 = 0uLL;\n  x1 = 1uLL;\n  if (!(*((uint64_t *)&mod + 1) | (unsigned long long)mod ^ 1)) return 0LL;\n  while (1 < a) {\n    *(uint64_t *)&v3 =\n        _divti3(a, *((uint64_t *)&a + 1), moda, *((uint64_t *)&moda + 1));\n    q = v3;\n    t = moda;\n    *(uint64_t *)&v4 =\n        _modti3(a, *((uint64_t *)&a + 1), moda, *((uint64_t *)&moda + 1));\n    moda = v4;\n    a = t;\n    ta = x0;\n    x0 = x1 - q * x0;\n    x1 = ta;\n  }\n  if (x1 < 0) x1 += mod;\n  return x1;\n}", "binary": "rsa-cipher/rsa-cipher.host.O0", "assembly": "<mod_inverse>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x78,%rsp\nmov    %rsi,%rax\nmov    %rdi,%r8\nmov    %r8,%rsi\nmov    %r9,%rdi\nmov    %rax,%rdi\nmov    %rsi,-0x70(%rbp)\nmov    %rdi,-0x68(%rbp)\nmov    %rdx,-0x80(%rbp)\nmov    %rcx,-0x78(%rbp)\nmov    -0x80(%rbp),%rax\nmov    -0x78(%rbp),%rdx\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmovq   $0x0,-0x60(%rbp)\nmovq   $0x0,-0x58(%rbp)\nmovq   $0x1,-0x50(%rbp)\nmovq   $0x0,-0x48(%rbp)\nmov    -0x80(%rbp),%rax\nxor    $0x1,%rax\nor     -0x78(%rbp),%rax\ntest   %rax,%rax\njne    14b2 <mod_inverse+0x14f>\nmov    $0x0,%eax\nmov    $0x0,%edx\njmp    14e9 <mod_inverse+0x186>\nmov    -0x70(%rbp),%rsi\nmov    -0x68(%rbp),%rax\nmov    -0x80(%rbp),%rdx\nmov    -0x78(%rbp),%rcx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   3d80 <__divti3>\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x80(%rbp),%rax\nmov    -0x78(%rbp),%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x70(%rbp),%rax\nmov    -0x68(%rbp),%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    -0x80(%rbp),%rdx\nmov    -0x78(%rbp),%rcx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   3ef0 <__modti3>\nmov    %rax,-0x80(%rbp)\nmov    %rdx,-0x78(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,-0x70(%rbp)\nmov    %rdx,-0x68(%rbp)\nmov    -0x60(%rbp),%rax\nmov    -0x58(%rbp),%rdx\nmov    %rax,-0x20(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x28(%rbp),%rax\nimul   -0x60(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x58(%rbp),%rax\nimul   -0x30(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x60(%rbp),%rax\nmulq   -0x30(%rbp)\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    -0x50(%rbp),%rcx\nmov    -0x48(%rbp),%rbx\nsub    %rax,%rcx\nsbb    %rdx,%rbx\nmov    %rcx,-0x60(%rbp)\nmov    %rbx,-0x58(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    $0x1,%edx\nmov    $0x0,%eax\ncmp    -0x70(%rbp),%rdx\nsbb    -0x68(%rbp),%rax\njl     13e3 <mod_inverse+0x80>\ncmpq   $0x0,-0x48(%rbp)\njns    14e1 <mod_inverse+0x17e>\nmov    -0x40(%rbp),%rax\nmov    -0x38(%rbp),%rdx\nadd    %rax,-0x50(%rbp)\nadc    %rdx,-0x48(%rbp)\nmov    -0x50(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "rsa-cipher/rsa-cipher.c", "function_name": "mod_pow", "content": "// Fast modular exponentiation: computes (base^exp) mod mod\nint128 mod_pow(int128 base, int128 exp, int128 mod) {\n    int128 result = 1;\n    base = base % mod;\n    while (exp > 0) {\n        if (exp & 1)\n            result = (result * base) % mod;\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}\n"}, "pseudo": {"path": "rsa-cipher/rsa-cipher.host.O0.pseudo", "function_name": "mod_pow", "address": "0x11e9", "label": "mod_pow", "content": "int128 __cdecl mod_pow(int128 base, int128 exp, int128 mod)\n{\n  int128 v3; // rax\n  int128 v4; // rax\n  int128 v5; // rax\n  int128 basea; // [rsp+20h] [rbp-40h]\n  int128 result; // [rsp+30h] [rbp-30h]\n\n  result = 1uLL;\n  *(_QWORD *)&v3 = _modti3(base, *((_QWORD *)&base + 1), mod, *((_QWORD *)&mod + 1));\n  basea = v3;\n  while ( (__int64)(((_QWORD)exp != 0LL) + *((_QWORD *)&exp + 1)) > 0 )\n  {\n    if ( (exp & 1) != 0 )\n    {\n      *(_QWORD *)&v4 = _modti3(result * basea, (unsigned __int128)(result * basea) >> 64, mod, *((_QWORD *)&mod + 1));\n      result = v4;\n    }\n    exp >>= 1;\n    *(_QWORD *)&v5 = _modti3(\n                       basea * basea,\n                       (((unsigned __int64)basea * (unsigned __int128)(unsigned __int64)basea) >> 64)\n                     + 2 * basea * *((_QWORD *)&basea + 1),\n                       mod,\n                       *((_QWORD *)&mod + 1));\n    basea = v5;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int128 mod_pow(int128 base, int128 exp, int128 mod) {\n  int128 v3;\n  int128 v4;\n  int128 v5;\n  int128 basea;\n  int128 result;\n  result = 1uLL;\n  *(uint64_t *)&v3 =\n      _modti3(base, *((uint64_t *)&base + 1), mod, *((uint64_t *)&mod + 1));\n  basea = v3;\n  while ((long long)(((uint64_t)exp != 0LL) + *((uint64_t *)&exp + 1)) > 0) {\n    if ((exp & 1) != 0) {\n      *(uint64_t *)&v4 =\n          _modti3(result * basea, (unsigned __int128)(result * basea) >> 64,\n                  mod, *((uint64_t *)&mod + 1));\n      result = v4;\n    }\n    exp >>= 1;\n    *(uint64_t *)&v5 =\n        _modti3(basea * basea,\n                (((unsigned long long)basea *\n                  (unsigned __int128)(unsigned long long)basea) >>\n                 64) +\n                    2 * basea * *((uint64_t *)&basea + 1),\n                mod, *((uint64_t *)&mod + 1));\n    basea = v5;\n  }\n  return result;\n}", "binary": "rsa-cipher/rsa-cipher.host.O0", "assembly": "<mod_pow>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x48,%rsp\nmov    %rsi,%rax\nmov    %rdi,%r10\nmov    %r10,%rsi\nmov    %r11,%rdi\nmov    %rax,%rdi\nmov    %rsi,-0x40(%rbp)\nmov    %rdi,-0x38(%rbp)\nmov    %rdx,-0x50(%rbp)\nmov    %rcx,-0x48(%rbp)\nmov    %r8,-0x60(%rbp)\nmov    %r9,-0x58(%rbp)\nmovq   $0x1,-0x30(%rbp)\nmovq   $0x0,-0x28(%rbp)\nmov    -0x40(%rbp),%rax\nmov    -0x38(%rbp),%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    -0x60(%rbp),%rdx\nmov    -0x58(%rbp),%rcx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   3ef0 <__modti3>\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\njmp    1338 <mod_pow+0x14f>\nmov    -0x50(%rbp),%rax\nand    $0x1,%eax\nmov    %rax,%r12\nmov    -0x48(%rbp),%rax\nand    $0x0,%eax\nmov    %rax,%r13\nmov    %r13,%rax\nor     %r12,%rax\ntest   %rax,%rax\nje     12d2 <mod_pow+0xe9>\nmov    -0x28(%rbp),%rax\nimul   -0x40(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nimul   -0x30(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x40(%rbp),%rax\nmulq   -0x30(%rbp)\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    -0x60(%rbp),%rdx\nmov    -0x58(%rbp),%rcx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   3ef0 <__modti3>\nmov    %rax,-0x30(%rbp)\nmov    %rdx,-0x28(%rbp)\nmov    -0x50(%rbp),%rax\nmov    -0x48(%rbp),%rdx\nshrd   $0x1,%rdx,%rax\nsar    %rdx\nmov    %rax,-0x50(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    -0x38(%rbp),%rax\nimul   -0x40(%rbp),%rax\nmov    %rax,%rdx\nmov    -0x38(%rbp),%rax\nimul   -0x40(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x40(%rbp),%rax\nmulq   -0x40(%rbp)\nadd    %rdx,%rcx\nmov    %rcx,%rdx\nmov    %rax,%rcx\nmov    %rdx,%rbx\nmov    %rcx,%rsi\nmov    %rdx,%rax\nmov    -0x60(%rbp),%rdx\nmov    -0x58(%rbp),%rcx\nmov    %rsi,%rdi\nmov    %rax,%rsi\ncall   3ef0 <__modti3>\nmov    %rax,-0x40(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    $0x0,%edx\nmov    $0x0,%eax\ncmp    -0x50(%rbp),%rdx\nsbb    -0x48(%rbp),%rax\njl     1265 <mod_pow+0x7c>\nmov    -0x30(%rbp),%rax\nmov    -0x28(%rbp),%rdx\nadd    $0x48,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %rbp\nret\n"}
{"source": {"path": "rsa-cipher/rsa-cipher.c", "function_name": "print_hex_int128", "content": "// Helper function to print a 128-bit number in hexadecimal.\n// It converts the number to a 32-digit hex string, then trims leading zeros.\nvoid print_hex_int128(int128 n) {\n    if (n == 0) {\n        libmin_printf(\"0x0\");\n        return;\n    }\n    if (n < 0) {\n        libmin_printf(\"-\");\n        n = -n;\n    }\n    \n    // 128 bits = 32 hex digits; extra one for the null terminator\n    char hex_digits[33];\n    hex_digits[32] = '\\0';\n    \n    // Fill the array from the least-significant nibble upward.\n    for (int i = 31; i >= 0; i--) {\n        hex_digits[i] = \"0123456789abcdef\"[n & 0xF];\n        n >>= 4;\n    }\n    \n    // Skip over any leading zeros for a cleaner output.\n    int j = 0;\n    while (hex_digits[j] == '0' && hex_digits[j+1] != '\\0') {\n        j++;\n    }\n    libmin_printf(\"0x%s\", &hex_digits[j]);\n}\n"}, "pseudo": {"path": "rsa-cipher/rsa-cipher.host.O0.pseudo", "function_name": "print_hex_int128", "address": "0x14ef", "label": "print_hex_int128", "content": "void __cdecl print_hex_int128(int128 n)\n{\n  int128 na; // [rsp+0h] [rbp-60h]\n  int i; // [rsp+18h] [rbp-48h]\n  int j; // [rsp+1Ch] [rbp-44h]\n  char hex_digits[40]; // [rsp+20h] [rbp-40h] BYREF\n  unsigned __int64 v5; // [rsp+48h] [rbp-18h]\n\n  na = n;\n  v5 = __readfsqword(0x28u);\n  if ( n == 0 )\n  {\n    libmin_printf(\"0x0\");\n  }\n  else\n  {\n    if ( n < 0 )\n    {\n      libmin_printf(\"-\");\n      na = -n;\n    }\n    hex_digits[32] = 0;\n    for ( i = 31; i >= 0; --i )\n    {\n      hex_digits[i] = a0123456789abcd[na & 0xF];\n      na >>= 4;\n    }\n    for ( j = 0; hex_digits[j] == 48 && hex_digits[j + 1]; ++j )\n      ;\n    libmin_printf(\"0x%s\", &hex_digits[j]);\n  }\n}\n"}, "pseudo_normalize": "void print_hex_int128(int128 n) {\n  int128 na;\n  int i;\n  int j;\n  char hex_digits[40];\n  unsigned long long v5;\n  na = n;\n  v5 = __readfsqword(40u);\n  if (n == 0) {\n    libmin_printf(\"0\");\n  } else {\n    if (n < 0) {\n      libmin_printf(\"-\");\n      na = -n;\n    }\n    hex_digits[32] = 0;\n    for (i = 31; i >= 0; --i) {\n      hex_digits[i] = a0123456789abcd[na & 15];\n      na >>= 4;\n    }\n    for (j = 0; hex_digits[j] == 48 && hex_digits[j + 1]; ++j)\n      ;\n    libmin_printf(\"0x%s\", &hex_digits[j]);\n  }\n}", "binary": "rsa-cipher/rsa-cipher.host.O0", "assembly": "<print_hex_int128>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r13\npush   %r12\nsub    $0x50,%rsp\nmov    %rdi,%rax\nmov    %rsi,%rcx\nmov    %rcx,%rdx\nmov    %rax,-0x60(%rbp)\nmov    %rdx,-0x58(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\nmov    -0x58(%rbp),%rax\nor     -0x60(%rbp),%rax\ntest   %rax,%rax\njne    1545 <print_hex_int128+0x56>\nlea    0x3ad5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\njmp    1616 <print_hex_int128+0x127>\ncmpq   $0x0,-0x58(%rbp)\njns    156d <print_hex_int128+0x7e>\nlea    0x3ab9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nnegq   -0x60(%rbp)\nadcq   $0x0,-0x58(%rbp)\nnegq   -0x58(%rbp)\nmovb   $0x0,-0x20(%rbp)\nmovl   $0x1f,-0x48(%rbp)\njmp    15c1 <print_hex_int128+0xd2>\nmov    -0x60(%rbp),%rax\nand    $0xf,%eax\nmov    %rax,%r12\nmov    -0x58(%rbp),%rax\nand    $0x0,%eax\nmov    %rax,%r13\nlea    0x3a7e(%rip),%rax\nadd    %r12,%rax\nmovzbl (%rax),%edx\nmov    -0x48(%rbp),%eax\ncltq\nmov    %dl,-0x40(%rbp,%rax,1)\nmov    -0x60(%rbp),%rax\nmov    -0x58(%rbp),%rdx\nshrd   $0x4,%rdx,%rax\nsar    $0x4,%rdx\nmov    %rax,-0x60(%rbp)\nmov    %rdx,-0x58(%rbp)\nsubl   $0x1,-0x48(%rbp)\ncmpl   $0x0,-0x48(%rbp)\njns    157a <print_hex_int128+0x8b>\nmovl   $0x0,-0x44(%rbp)\njmp    15d4 <print_hex_int128+0xe5>\naddl   $0x1,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\ncmp    $0x30,%al\njne    15f3 <print_hex_int128+0x104>\nmov    -0x44(%rbp),%eax\nadd    $0x1,%eax\ncltq\nmovzbl -0x40(%rbp,%rax,1),%eax\ntest   %al,%al\njne    15d0 <print_hex_int128+0xe1>\nlea    -0x40(%rbp),%rdx\nmov    -0x44(%rbp),%eax\ncltq\nadd    %rdx,%rax\nmov    %rax,%rsi\nlea    0x3a05(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3ab8 <libmin_printf>\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\nje     162a <print_hex_int128+0x13b>\ncall   10b0 <__stack_chk_fail@plt>\nadd    $0x50,%rsp\npop    %r12\npop    %r13\npop    %rbp\nret\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "conflict", "content": "// Function to check if the current assignment causes a conflict.\n// For each clause, if all literals are assigned and none is true, then a conflict exists.\nint conflict() {\n    for (int i = 0; i < NUM_CLAUSES; i++) {\n        int satisfied = 0;\n        int fully_assigned = 1;\n        for (int j = 0; j < MAX_LITERALS && formula[i][j] != 0; j++) {\n            int lit = formula[i][j];\n            int var = (lit > 0) ? lit : -lit;\n            int val = assignment[var];\n            if (val == UNASSIGNED) {\n                fully_assigned = 0;\n            } else {\n                // For a positive literal, it is satisfied if the value is 1;\n                // for a negative literal, it is satisfied if the value is 0.\n                if ((lit > 0 && val == 1) || (lit < 0 && val == 0)) {\n                    satisfied = 1;\n                    break;  // This clause is satisfied.\n                }\n            }\n        }\n        // If a clause is fully assigned and not satisfied, there is a conflict.\n        if (!satisfied && fully_assigned)\n            return 1;\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O0.pseudo", "function_name": "conflict", "address": "0x11e9", "label": "conflict", "content": "int __cdecl conflict()\n{\n  int v0; // eax\n  int i; // [rsp+0h] [rbp-1Ch]\n  int satisfied; // [rsp+4h] [rbp-18h]\n  int fully_assigned; // [rsp+8h] [rbp-14h]\n  int j; // [rsp+Ch] [rbp-10h]\n  int lit; // [rsp+10h] [rbp-Ch]\n  int val; // [rsp+18h] [rbp-4h]\n\n  for ( i = 0; i <= 9; ++i )\n  {\n    satisfied = 0;\n    fully_assigned = 1;\n    for ( j = 0; j <= 3 && formula[i][j]; ++j )\n    {\n      lit = formula[i][j];\n      v0 = lit;\n      if ( lit <= 0 )\n        v0 = -lit;\n      val = assignment[v0];\n      if ( val == -1 )\n      {\n        fully_assigned = 0;\n      }\n      else if ( lit > 0 && val == 1 || lit < 0 && !val )\n      {\n        satisfied = 1;\n        break;\n      }\n    }\n    if ( !satisfied && fully_assigned )\n      return 1;\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int conflict() {\n  int v0;\n  int i;\n  int satisfied;\n  int fully_assigned;\n  int j;\n  int lit;\n  int val;\n  for (i = 0; i <= 9; ++i) {\n    satisfied = 0;\n    fully_assigned = 1;\n    for (j = 0; j <= 3 && formula[i][j]; ++j) {\n      lit = formula[i][j];\n      v0 = lit;\n      if (lit <= 0) v0 = -lit;\n      val = assignment[v0];\n      if (val == -1) {\n        fully_assigned = 0;\n      } else if (lit > 0 && val == 1 || lit < 0 && !val) {\n        satisfied = 1;\n        break;\n      }\n    }\n    if (!satisfied && fully_assigned) return 1;\n  }\n  return 0;\n}", "binary": "sat-solver/sat-solver.host.O0", "assembly": "<conflict>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovl   $0x0,-0x1c(%rbp)\njmp    12e2 <conflict+0xf9>\nmovl   $0x0,-0x18(%rbp)\nmovl   $0x1,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    1299 <conflict+0xb0>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4de8(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,%edx\nneg    %edx\ncmovns %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x50c1(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0xffffffff,-0x4(%rbp)\njne    1274 <conflict+0x8b>\nmovl   $0x0,-0x14(%rbp)\njmp    1295 <conflict+0xac>\ncmpl   $0x0,-0xc(%rbp)\njle    1280 <conflict+0x97>\ncmpl   $0x1,-0x4(%rbp)\nje     128c <conflict+0xa3>\ncmpl   $0x0,-0xc(%rbp)\njns    1295 <conflict+0xac>\ncmpl   $0x0,-0x4(%rbp)\njne    1295 <conflict+0xac>\nmovl   $0x1,-0x18(%rbp)\njmp    12cb <conflict+0xe2>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x3,-0x10(%rbp)\njg     12cb <conflict+0xe2>\nmov    -0x10(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4d60(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ntest   %eax,%eax\njne    1217 <conflict+0x2e>\ncmpl   $0x0,-0x18(%rbp)\njne    12de <conflict+0xf5>\ncmpl   $0x0,-0x14(%rbp)\nje     12de <conflict+0xf5>\nmov    $0x1,%eax\njmp    12f1 <conflict+0x108>\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x9,-0x1c(%rbp)\njle    11fd <conflict+0x14>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "main", "content": "int main() {\n    // Initialize all variables to UNASSIGNED.\n    for (int i = 1; i <= NUM_VARS; i++) {\n        assignment[i] = UNASSIGNED;\n    }\n    \n    printFormula();\n\n    if (solveSAT(1)) {\n        libmin_printf(\"SAT solution found:\\n\");\n        printAssignment();\n        libtarg_success();\n    } else {\n        libmin_printf(\"No SAT solution exists.\\n\");\n        libtarg_fail(1);\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O0.pseudo", "function_name": "main", "address": "0x1518", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int i; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 1; i <= 8; ++i )\n    assignment[i] = -1;\n  printFormula();\n  if ( solveSAT(1) )\n  {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int i;\n  for (i = 1; i <= 8; ++i) assignment[i] = -1;\n  printFormula();\n  if (solveSAT(1)) {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}", "binary": "sat-solver/sat-solver.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x1,-0x4(%rbp)\njmp    154c <main+0x34>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4ddf(%rip),%rax\nmovl   $0xffffffff,(%rdx,%rax,1)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x8,-0x4(%rbp)\njle    152d <main+0x15>\nmov    $0x0,%eax\ncall   1391 <printFormula>\nmov    $0x1,%edi\ncall   12f3 <solveSAT>\ntest   %eax,%eax\nje     158d <main+0x75>\nlea    0x2af1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\nmov    $0x0,%eax\ncall   1499 <printAssignment>\ncall   15ab <libtarg_success>\nlea    0x2ae3(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\nmov    $0x1,%edi\ncall   15bd <libtarg_fail>\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "printAssignment", "content": "// Utility to print the variable assignments once a solution is found.\nvoid printAssignment() {\n    libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n    for (int i = 1; i <= NUM_VARS; i++) {\n        libmin_printf(\"x%d = %s\\n\", i, (assignment[i] == 1 ? \"true\" : \"false\"));\n    }\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O0.pseudo", "function_name": "printAssignment", "address": "0x1499", "label": "printAssignment", "content": "void __cdecl printAssignment()\n{\n  const char *v0; // rax\n  int i; // [rsp+Ch] [rbp-4h]\n\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for ( i = 1; i <= 8; ++i )\n  {\n    if ( assignment[i] == 1 )\n      v0 = \"true\";\n    else\n      v0 = \"false\";\n    libmin_printf(\"x%d = %s\\n\", i, v0);\n  }\n}\n"}, "pseudo_normalize": "void printAssignment() {\n  const char *v0;\n  int i;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  for (i = 1; i <= 8; ++i) {\n    if (assignment[i] == 1)\n      v0 = \"true\";\n    else\n      v0 = \"false\";\n    libmin_printf(\"x%d = %s\\n\", i, v0);\n  }\n}", "binary": "sat-solver/sat-solver.host.O0", "assembly": "<printAssignment>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nlea    0x2b7c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\nmovl   $0x1,-0x4(%rbp)\njmp    150e <printAssignment+0x75>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4e4a(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    $0x1,%eax\njne    14e7 <printAssignment+0x4e>\nlea    0x2b68(%rip),%rax\njmp    14ee <printAssignment+0x55>\nlea    0x2b64(%rip),%rax\nmov    -0x4(%rbp),%ecx\nmov    %rax,%rdx\nmov    %ecx,%esi\nlea    0x2b5b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x8,-0x4(%rbp)\njle    14c2 <printAssignment+0x29>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "printFormula", "content": "// Utility to print the CNF formula.\nvoid printFormula() {\n    libmin_printf(\"CNF Formula:\\n\");\n    for (int i = 0; i < NUM_CLAUSES; i++) {\n        libmin_printf(\"(\");\n        for (int j = 0; j < MAX_LITERALS && formula[i][j] != 0; j++) {\n            int lit = formula[i][j];\n            if (lit < 0)\n                libmin_printf(\"x%d \", -lit);\n            else\n                libmin_printf(\"x%d \", lit);\n        }\n        libmin_printf(\")\\n\");\n    }\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O0.pseudo", "function_name": "printFormula", "address": "0x1391", "label": "printFormula", "content": "void __cdecl printFormula()\n{\n  int i; // [rsp+4h] [rbp-Ch]\n  int j; // [rsp+8h] [rbp-8h]\n  int lit; // [rsp+Ch] [rbp-4h]\n\n  libmin_printf(\"CNF Formula:\\n\");\n  for ( i = 0; i <= 9; ++i )\n  {\n    libmin_printf(\"(\");\n    for ( j = 0; j <= 3 && formula[i][j]; ++j )\n    {\n      lit = formula[i][j];\n      if ( lit >= 0 )\n        libmin_printf(\"x%d \", lit);\n      else\n        libmin_printf((char *)&byte_4018, (unsigned int)-lit);\n    }\n    libmin_printf(\")\\n\");\n  }\n}\n"}, "pseudo_normalize": "void printFormula() {\n  int i;\n  int j;\n  int lit;\n  libmin_printf(\"CNF Formula:\\n\");\n  for (i = 0; i <= 9; ++i) {\n    libmin_printf(\"(\");\n    for (j = 0; j <= 3 && formula[i][j]; ++j) {\n      lit = formula[i][j];\n      if (lit >= 0)\n        libmin_printf(\"x%d \", lit);\n      else\n        libmin_printf((char *)&byte_4018, (unsigned int)-lit);\n    }\n    libmin_printf(\")\\n\");\n  }\n}", "binary": "sat-solver/sat-solver.host.O0", "assembly": "<printFormula>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nlea    0x2c64(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\nmovl   $0x0,-0xc(%rbp)\njmp    148b <printFormula+0xfa>\nlea    0x2c52(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    1441 <printFormula+0xb0>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4c25(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njns    1424 <printFormula+0x93>\nmov    -0x4(%rbp),%eax\nneg    %eax\nmov    %eax,%esi\nlea    0x2c03(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\njmp    143d <printFormula+0xac>\nmov    -0x4(%rbp),%eax\nmov    %eax,%esi\nlea    0x2bef(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x3,-0x8(%rbp)\njg     1473 <printFormula+0xe2>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x2,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4bb8(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ntest   %eax,%eax\njne    13da <printFormula+0x49>\nlea    0x2baa(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e7 <libmin_printf>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x9,-0xc(%rbp)\njle    13bd <printFormula+0x2c>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "solveSAT", "content": "// Recursive backtracking solver.\n// 'var' is the current variable index to assign (starting at 1).\n// Returns 1 if a satisfying assignment is found.\nint solveSAT(int var) {\n    if (var > NUM_VARS) {\n        // All variables are assigned.\n        return conflict() ? 0 : 1;\n    }\n    // Try both truth values: 0 (false) and 1 (true).\n    for (int v = 0; v < 2; v++) {\n        assignment[var] = v;\n        if (!conflict() && solveSAT(var + 1))\n            return 1;\n    }\n    assignment[var] = UNASSIGNED;  // Backtrack.\n    return 0;\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O0.pseudo", "function_name": "solveSAT", "address": "0x12f3", "label": "solveSAT", "content": "int __cdecl solveSAT(int var)\n{\n  int v; // [rsp+1Ch] [rbp-4h]\n\n  if ( var > 8 )\n    return conflict() == 0;\n  for ( v = 0; v <= 1; ++v )\n  {\n    assignment[var] = v;\n    if ( !conflict() && solveSAT(var + 1) )\n      return 1;\n  }\n  assignment[var] = -1;\n  return 0;\n}\n"}, "pseudo_normalize": "int solveSAT(int var) {\n  int v;\n  if (var > 8) return conflict() == 0;\n  for (v = 0; v <= 1; ++v) {\n    assignment[var] = v;\n    if (!conflict() && solveSAT(var + 1)) return 1;\n  }\n  assignment[var] = -1;\n  return 0;\n}", "binary": "sat-solver/sat-solver.host.O0", "assembly": "<solveSAT>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\ncmpl   $0x8,-0x14(%rbp)\njle    131c <solveSAT+0x29>\nmov    $0x0,%eax\ncall   11e9 <conflict>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    138f <solveSAT+0x9c>\nmovl   $0x0,-0x4(%rbp)\njmp    1369 <solveSAT+0x76>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rcx\nlea    0x4fe7(%rip),%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    $0x0,%eax\ncall   11e9 <conflict>\ntest   %eax,%eax\njne    1365 <solveSAT+0x72>\nmov    -0x14(%rbp),%eax\nadd    $0x1,%eax\nmov    %eax,%edi\ncall   12f3 <solveSAT>\ntest   %eax,%eax\nje     1365 <solveSAT+0x72>\nmov    $0x1,%eax\njmp    138f <solveSAT+0x9c>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njle    1325 <solveSAT+0x32>\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nlea    0x4f9d(%rip),%rax\nmovl   $0xffffffff,(%rdx,%rax,1)\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "shortest-path/shortest-path.c", "function_name": "floydWarshall", "content": "// Solves the all-pairs shortest path problem using Floyd Warshall algorithm\nvoid\nfloydWarshall (int graph[][V])\n{\n  /* dist[][] will be the output matrix that will finally have the shortest \n    distances between every pair of vertices */\n  int i, j, k;\n \n  /* Initialize the solution matrix same as input graph matrix. Or \n     we can say the initial values of shortest distances are based\n     on shortest paths considering no intermediate vertex. */\n  for (i = 0; i < V; i++)\n    for (j = 0; j < V; j++)\n      dist[i][j] = graph[i][j];\n \n  /* Add all vertices one by one to the set of intermediate vertices.\n    ---> Before start of a iteration, we have shortest distances between all\n    pairs of vertices such that the shortest distances consider only the\n    vertices in set {0, 1, 2, .. k-1} as intermediate vertices.\n    ----> After the end of a iteration, vertex no. k is added to the set of\n    intermediate vertices and the set becomes {0, 1, 2, .. k} */\n  for (k = 0; k < V; k++)\n  {\n    // Pick all vertices as source one by one\n    for (i = 0; i < V; i++)\n    {\n      // Pick all vertices as destination for the\n      // above picked source\n      for (j = 0; j < V; j++)\n      {\n        // If vertex k is on the shortest path from\n        // i to j, then update the value of dist[i][j]\n        if (dist[i][k] + dist[k][j] < dist[i][j])\n          dist[i][j] = dist[i][k] + dist[k][j];\n      }\n    }\n  }\n}\n"}, "pseudo": {"path": "shortest-path/shortest-path.host.O0.pseudo", "function_name": "floydWarshall", "address": "0x11e9", "label": "floydWarshall", "content": "void __cdecl floydWarshall(int (*graph)[8])\n{\n  int i; // [rsp+Ch] [rbp-Ch]\n  int ia; // [rsp+Ch] [rbp-Ch]\n  int j; // [rsp+10h] [rbp-8h]\n  int ja; // [rsp+10h] [rbp-8h]\n  int k; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n      dist[i][j] = (*graph)[8 * i + j];\n  }\n  for ( k = 0; k <= 7; ++k )\n  {\n    for ( ia = 0; ia <= 7; ++ia )\n    {\n      for ( ja = 0; ja <= 7; ++ja )\n      {\n        if ( dist[k][ja] + dist[ia][k] < dist[ia][ja] )\n          dist[ia][ja] = dist[k][ja] + dist[ia][k];\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void floydWarshall(int (*graph)[8]) {\n  int i;\n  int ia;\n  int j;\n  int ja;\n  int k;\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j) dist[i][j] = (*graph)[8 * i + j];\n  }\n  for (k = 0; k <= 7; ++k) {\n    for (ia = 0; ia <= 7; ++ia) {\n      for (ja = 0; ja <= 7; ++ja) {\n        if (dist[k][ja] + dist[ia][k] < dist[ia][ja])\n          dist[ia][ja] = dist[k][ja] + dist[ia][k];\n      }\n    }\n  }\n}", "binary": "shortest-path/shortest-path.host.O0", "assembly": "<floydWarshall>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    1255 <floydWarshall+0x6c>\nmovl   $0x0,-0x8(%rbp)\njmp    124b <floydWarshall+0x62>\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x5,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\nmov    -0x8(%rbp),%edx\nmovslq %edx,%rcx\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nshl    $0x3,%rdx\nadd    %rcx,%rdx\nlea    0x0(,%rdx,4),%rcx\nlea    0x503c(%rip),%rdx\nmov    %eax,(%rcx,%rdx,1)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x7,-0x8(%rbp)\njle    1207 <floydWarshall+0x1e>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njle    11fe <floydWarshall+0x15>\nmovl   $0x0,-0x4(%rbp)\njmp    137f <floydWarshall+0x196>\nmovl   $0x0,-0xc(%rbp)\njmp    1371 <floydWarshall+0x188>\nmovl   $0x0,-0x8(%rbp)\njmp    1363 <floydWarshall+0x17a>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4fe0(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4fbc(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%ecx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f96(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,%ecx\njge    135f <floydWarshall+0x176>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f6e(%rip),%rax\nmov    (%rdx,%rax,1),%ecx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f4a(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nadd    %eax,%ecx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x3,%rax\nadd    %rdx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4f24(%rip),%rax\nmov    %ecx,(%rdx,%rax,1)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x7,-0x8(%rbp)\njle    127f <floydWarshall+0x96>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x7,-0xc(%rbp)\njle    1273 <floydWarshall+0x8a>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x7,-0x4(%rbp)\njle    1267 <floydWarshall+0x7e>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "shortest-path/shortest-path.c", "function_name": "main", "content": " \n// driver program to test above function\nint\nmain(void)\n{\n  /* Let us create the following weighted graph\n          10\n     (0)------->(3)\n      |         /|\\\n    5 |          |\n      |          | 1\n     \\|/         |\n     (1)------->(2)\n          3           */\n#ifdef notdef\n  int graph[V][V] = { {0,   5,  INF, 10},\n                      {INF, 0,   3, INF},\n                      {INF, INF, 0,   1},\n                      {INF, INF, INF, 0}\n                    };\n#endif /* notdef */\n\tint graph[V][V] = {\n  // Vertex # A  B  C  D  E  F  G  H\t   Vertex\n            { 0, N, 4, N, N, 7, N, N }, // A\n\t\t\t      { N, 0, N, N, 9, N, N, 3 }, // B\n\t\t\t      { 4, N, 0, 3, N, 2, 9, N }, // C\t\n\t\t\t      { N, N, 3, 0, 3, N, 7, N }, // D\n\t\t\t      { N, 9, N, 3, 0, N, 2, 7 }, // E\n\t\t\t      { 7, N, 2, N, N, 0, 8, N }, // F\n\t\t\t      { N, N, 9, 7, 2, 8, 0, 3 }, // G\n\t\t\t      { N, 3, N, N, 7, N, 3, 0 } };//H\n\n \n  // Print the solution\n  floydWarshall(graph);\n \n  // Print the shortest distance matrix\n  printSolution(dist);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "shortest-path/shortest-path.host.O0.pseudo", "function_name": "main", "address": "0x1469", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int graph[8][8]; // [rsp+0h] [rbp-110h] BYREF\n  unsigned __int64 v4; // [rsp+108h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  *(_QWORD *)&graph[0][0] = 0x1869F00000000LL;\n  *(_QWORD *)&graph[0][2] = 0x1869F00000004LL;\n  *(_QWORD *)&graph[0][4] = 0x70001869FLL;\n  *(_QWORD *)&graph[0][6] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[1][0] = 99999LL;\n  *(_QWORD *)&graph[1][2] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[1][4] = 0x1869F00000009LL;\n  *(_QWORD *)&graph[1][6] = 0x30001869FLL;\n  *(_QWORD *)&graph[2][0] = 0x1869F00000004LL;\n  *(_QWORD *)&graph[2][2] = 0x300000000LL;\n  *(_QWORD *)&graph[2][4] = 0x20001869FLL;\n  *(_QWORD *)&graph[2][6] = 0x1869F00000009LL;\n  *(_QWORD *)&graph[3][0] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[3][2] = 3LL;\n  *(_QWORD *)&graph[3][4] = 0x1869F00000003LL;\n  *(_QWORD *)&graph[3][6] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[4][0] = 0x90001869FLL;\n  *(_QWORD *)&graph[4][2] = 0x30001869FLL;\n  *(_QWORD *)&graph[4][4] = 0x1869F00000000LL;\n  *(_QWORD *)&graph[4][6] = 0x700000002LL;\n  *(_QWORD *)&graph[5][0] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[5][2] = 0x1869F00000002LL;\n  *(_QWORD *)&graph[5][4] = 99999LL;\n  *(_QWORD *)&graph[5][6] = 0x1869F00000008LL;\n  *(_QWORD *)&graph[6][0] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[6][2] = 0x700000009LL;\n  *(_QWORD *)&graph[6][4] = 0x800000002LL;\n  *(_QWORD *)&graph[6][6] = 0x300000000LL;\n  *(_QWORD *)&graph[7][0] = 0x30001869FLL;\n  *(_QWORD *)&graph[7][2] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[7][4] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[7][6] = 3LL;\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int graph[8][8];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  *(uint64_t *)&graph[0][0] = 429492434632704LL;\n  *(uint64_t *)&graph[0][2] = 429492434632708LL;\n  *(uint64_t *)&graph[0][4] = 30064871071LL;\n  *(uint64_t *)&graph[0][6] = 429492434732703LL;\n  *(uint64_t *)&graph[1][0] = 99999LL;\n  *(uint64_t *)&graph[1][2] = 429492434732703LL;\n  *(uint64_t *)&graph[1][4] = 429492434632713LL;\n  *(uint64_t *)&graph[1][6] = 12885001887LL;\n  *(uint64_t *)&graph[2][0] = 429492434632708LL;\n  *(uint64_t *)&graph[2][2] = 12884901888LL;\n  *(uint64_t *)&graph[2][4] = 8590034591LL;\n  *(uint64_t *)&graph[2][6] = 429492434632713LL;\n  *(uint64_t *)&graph[3][0] = 429492434732703LL;\n  *(uint64_t *)&graph[3][2] = 3LL;\n  *(uint64_t *)&graph[3][4] = 429492434632707LL;\n  *(uint64_t *)&graph[3][6] = 429492434632711LL;\n  *(uint64_t *)&graph[4][0] = 38654805663LL;\n  *(uint64_t *)&graph[4][2] = 12885001887LL;\n  *(uint64_t *)&graph[4][4] = 429492434632704LL;\n  *(uint64_t *)&graph[4][6] = 30064771074LL;\n  *(uint64_t *)&graph[5][0] = 429492434632711LL;\n  *(uint64_t *)&graph[5][2] = 429492434632706LL;\n  *(uint64_t *)&graph[5][4] = 99999LL;\n  *(uint64_t *)&graph[5][6] = 429492434632712LL;\n  *(uint64_t *)&graph[6][0] = 429492434732703LL;\n  *(uint64_t *)&graph[6][2] = 30064771081LL;\n  *(uint64_t *)&graph[6][4] = 34359738370LL;\n  *(uint64_t *)&graph[6][6] = 12884901888LL;\n  *(uint64_t *)&graph[7][0] = 12885001887LL;\n  *(uint64_t *)&graph[7][2] = 429492434732703LL;\n  *(uint64_t *)&graph[7][4] = 429492434632711LL;\n  *(uint64_t *)&graph[7][6] = 3LL;\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}", "binary": "shortest-path/shortest-path.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x110,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x110(%rbp)\nmovl   $0x1869f,-0x10c(%rbp)\nmovl   $0x4,-0x108(%rbp)\nmovl   $0x1869f,-0x104(%rbp)\nmovl   $0x1869f,-0x100(%rbp)\nmovl   $0x7,-0xfc(%rbp)\nmovl   $0x1869f,-0xf8(%rbp)\nmovl   $0x1869f,-0xf4(%rbp)\nmovl   $0x1869f,-0xf0(%rbp)\nmovl   $0x0,-0xec(%rbp)\nmovl   $0x1869f,-0xe8(%rbp)\nmovl   $0x1869f,-0xe4(%rbp)\nmovl   $0x9,-0xe0(%rbp)\nmovl   $0x1869f,-0xdc(%rbp)\nmovl   $0x1869f,-0xd8(%rbp)\nmovl   $0x3,-0xd4(%rbp)\nmovl   $0x4,-0xd0(%rbp)\nmovl   $0x1869f,-0xcc(%rbp)\nmovl   $0x0,-0xc8(%rbp)\nmovl   $0x3,-0xc4(%rbp)\nmovl   $0x1869f,-0xc0(%rbp)\nmovl   $0x2,-0xbc(%rbp)\nmovl   $0x9,-0xb8(%rbp)\nmovl   $0x1869f,-0xb4(%rbp)\nmovl   $0x1869f,-0xb0(%rbp)\nmovl   $0x1869f,-0xac(%rbp)\nmovl   $0x3,-0xa8(%rbp)\nmovl   $0x0,-0xa4(%rbp)\nmovl   $0x3,-0xa0(%rbp)\nmovl   $0x1869f,-0x9c(%rbp)\nmovl   $0x7,-0x98(%rbp)\nmovl   $0x1869f,-0x94(%rbp)\nmovl   $0x1869f,-0x90(%rbp)\nmovl   $0x9,-0x8c(%rbp)\nmovl   $0x1869f,-0x88(%rbp)\nmovl   $0x3,-0x84(%rbp)\nmovl   $0x0,-0x80(%rbp)\nmovl   $0x1869f,-0x7c(%rbp)\nmovl   $0x2,-0x78(%rbp)\nmovl   $0x7,-0x74(%rbp)\nmovl   $0x7,-0x70(%rbp)\nmovl   $0x1869f,-0x6c(%rbp)\nmovl   $0x2,-0x68(%rbp)\nmovl   $0x1869f,-0x64(%rbp)\nmovl   $0x1869f,-0x60(%rbp)\nmovl   $0x0,-0x5c(%rbp)\nmovl   $0x8,-0x58(%rbp)\nmovl   $0x1869f,-0x54(%rbp)\nmovl   $0x1869f,-0x50(%rbp)\nmovl   $0x1869f,-0x4c(%rbp)\nmovl   $0x9,-0x48(%rbp)\nmovl   $0x7,-0x44(%rbp)\nmovl   $0x2,-0x40(%rbp)\nmovl   $0x8,-0x3c(%rbp)\nmovl   $0x0,-0x38(%rbp)\nmovl   $0x3,-0x34(%rbp)\nmovl   $0x1869f,-0x30(%rbp)\nmovl   $0x3,-0x2c(%rbp)\nmovl   $0x1869f,-0x28(%rbp)\nmovl   $0x1869f,-0x24(%rbp)\nmovl   $0x7,-0x20(%rbp)\nmovl   $0x1869f,-0x1c(%rbp)\nmovl   $0x3,-0x18(%rbp)\nmovl   $0x0,-0x14(%rbp)\nlea    -0x110(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <floydWarshall>\nlea    0x4bb7(%rip),%rax\nmov    %rax,%rdi\ncall   138d <printSolution>\ncall   3a9a <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     16ef <main+0x286>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "shortest-path/shortest-path.c", "function_name": "printSolution", "content": " \n/* A utility function to print solution */\nvoid\nprintSolution(int dist[][V])\n{\n    libmin_printf (\"Following matrix shows the shortest distances\"\n                   \" between every pair of vertices \\n\");\n    for (int i = 0; i < V; i++)\n    {\n        for (int j = 0; j < V; j++)\n        {\n            if (dist[i][j] == INF)\n                libmin_printf(\"%7s\", \"INF\");\n            else\n                libmin_printf (\"%7d\", dist[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "shortest-path/shortest-path.host.O0.pseudo", "function_name": "printSolution", "address": "0x138d", "label": "printSolution", "content": "void __cdecl printSolution(int (*dist)[8])\n{\n  int i; // [rsp+18h] [rbp-8h]\n  int j; // [rsp+1Ch] [rbp-4h]\n\n  libmin_printf(\"Following matrix shows the shortest distances between every pair of vertices \\n\");\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; j <= 7; ++j )\n    {\n      if ( (*dist)[8 * i + j] == 99999 )\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", (*dist)[8 * i + j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo_normalize": "void printSolution(int (*dist)[8]) {\n  int i;\n  int j;\n  libmin_printf(\n      \"Following matrix shows the shortest distances between every pair of \"\n      \"vertices \\n\");\n  for (i = 0; i <= 7; ++i) {\n    for (j = 0; j <= 7; ++j) {\n      if ((*dist)[8 * i + j] == 99999)\n        libmin_printf(\"%7s\", \"INF\");\n      else\n        libmin_printf(\"%7d\", (*dist)[8 * i + j]);\n    }\n    libmin_printf(\"\\n\");\n  }\n}", "binary": "shortest-path/shortest-path.host.O0", "assembly": "<printSolution>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nlea    0x2c64(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   382d <libmin_printf>\nmovl   $0x0,-0x8(%rbp)\njmp    145b <printSolution+0xce>\nmovl   $0x0,-0x4(%rbp)\njmp    143d <printSolution+0xb0>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x5,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ncmp    $0x1869f,%eax\njne    1408 <printSolution+0x7b>\nlea    0x2c68(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c62(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   382d <libmin_printf>\njmp    1439 <printSolution+0xac>\nmov    -0x8(%rbp),%eax\ncltq\nshl    $0x5,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\nmov    %eax,%esi\nlea    0x2c33(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   382d <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x7,-0x4(%rbp)\njle    13c6 <printSolution+0x39>\nlea    0x2c19(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   382d <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x7,-0x8(%rbp)\njle    13bd <printSolution+0x30>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "sieve/sieve.c", "function_name": "SIEVE", "content": "/**************************************/\n/*  Sieve of Erathosthenes Program    */\n/**************************************/\n\nstatic int\nSIEVE(long m, long p)\n{\n  register long i,prime=0,k;\n  register long count,size;\n  long j;\n\n  size  = m - 1;\n\n  N_Prime   = 0L;\n  L_Prime   = 0L;\n\n  j = 0;\n\n      count = 0;\n\n      for(i=0 ; i<=size ; i++)\n\t{\n\t  *(flags+i) = TRUE;                                /* 1*size  */\n\t}                                                 /* 3*size  */\n      \n      for(i=0 ; i<=size ; i++)\n\t{\n\t  if(*(flags+i))                                /* 2*size  */\n\t    {                                             /* 1*count */\n\t      count++;                                      /* 1*count */\n\t      prime = i + i + 3;                            /* 3*count */\n\t      for(k = i + prime ; k<=size ; k+=prime)     /* 3*count */\n\t\t{\n\t\t  *(flags+k)=FALSE;                           /* 1*ci    */\n\t\t}                                           /* 3*ci    */\n\t      /* 1*count */\n\t    }\n\t}                                               /* 3*size  */\n      \n      j = j + count;\n\t\t\t\t\t\t\n  N_Prime = j ;\n  L_Prime = prime;\n\n  if (p != 0L)\n    libmin_printf(\"  %9ld   %8ld     %8ld\\n\",m,N_Prime,L_Prime);\n\n  return 0;\n}\n"}, "pseudo": {"path": "sieve/sieve.host.O0.pseudo", "function_name": "SIEVE", "address": "0x11e9", "label": "SIEVE", "content": "int __cdecl SIEVE(__int64 m, __int64 p)\n{\n  __int64 v2; // r15\n  __int64 v3; // r13\n  __int64 v4; // r14\n  __int64 i; // rbx\n  __int64 j; // rbx\n  __int64 k; // r12\n\n  v2 = 0LL;\n  v3 = m - 1;\n  N_Prime = 0LL;\n  L_Prime = 0LL;\n  v4 = 0LL;\n  for ( i = 0LL; i <= v3; ++i )\n    flags[i] = 1;\n  for ( j = 0LL; j <= v3; ++j )\n  {\n    if ( flags[j] )\n    {\n      ++v4;\n      v2 = 2 * j + 3;\n      for ( k = j + v2; k <= v3; k += v2 )\n        flags[k] = 0;\n    }\n  }\n  N_Prime = v4;\n  L_Prime = v2;\n  if ( p )\n    libmin_printf(\"  %9ld   %8ld     %8ld\\n\", m, N_Prime, L_Prime);\n  return 0;\n}\n"}, "pseudo_normalize": "int SIEVE(long long m, long long p) {\n  long long v2;\n  long long v3;\n  long long v4;\n  long long i;\n  long long j;\n  long long k;\n  v2 = 0LL;\n  v3 = m - 1;\n  N_Prime = 0LL;\n  L_Prime = 0LL;\n  v4 = 0LL;\n  for (i = 0LL; i <= v3; ++i) flags[i] = 1;\n  for (j = 0LL; j <= v3; ++j) {\n    if (flags[j]) {\n      ++v4;\n      v2 = 2 * j + 3;\n      for (k = j + v2; k <= v3; k += v2) flags[k] = 0;\n    }\n  }\n  N_Prime = v4;\n  L_Prime = v2;\n  if (p) libmin_printf(\"  %9ld   %8ld     %8ld\\n\", m, N_Prime, L_Prime);\n  return 0;\n}", "binary": "sieve/sieve.host.O0", "assembly": "<SIEVE>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,-0x48(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    $0x0,%r15d\nmov    -0x48(%rbp),%rax\nlea    -0x1(%rax),%r13\nmovq   $0x0,0x5069(%rip)\nmovq   $0x0,0x5056(%rip)\nmovq   $0x0,-0x38(%rbp)\nmov    $0x0,%r14d\nmov    $0x0,%ebx\njmp    1253 <SIEVE+0x6a>\nmov    %rbx,%rdx\nlea    0x5057(%rip),%rax\nadd    %rdx,%rax\nmovb   $0x1,(%rax)\nadd    $0x1,%rbx\ncmp    %r13,%rbx\njle    123f <SIEVE+0x56>\nmov    $0x0,%ebx\njmp    12a1 <SIEVE+0xb8>\nmov    %rbx,%rdx\nlea    0x5037(%rip),%rax\nadd    %rdx,%rax\nmovzbl (%rax),%eax\ntest   %al,%al\nje     129d <SIEVE+0xb4>\nadd    $0x1,%r14\nlea    (%rbx,%rbx,1),%rax\nlea    0x3(%rax),%r15\nlea    (%rbx,%r15,1),%r12\njmp    1298 <SIEVE+0xaf>\nmov    %r12,%rdx\nlea    0x5011(%rip),%rax\nadd    %rdx,%rax\nmovb   $0x0,(%rax)\nadd    %r15,%r12\ncmp    %r13,%r12\njle    1285 <SIEVE+0x9c>\nadd    $0x1,%rbx\ncmp    %r13,%rbx\njle    125f <SIEVE+0x76>\nadd    %r14,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\nmov    %rax,0x4fd3(%rip)\nmov    %r15,0x4fc4(%rip)\ncmpq   $0x0,-0x50(%rbp)\nje     12ec <SIEVE+0x103>\nmov    0x4fb6(%rip),%rcx\nmov    0x4fb7(%rip),%rdx\nmov    -0x48(%rbp),%rax\nmov    %rax,%rsi\nlea    0x2d29(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34c7 <libmin_printf>\nmov    $0x0,%eax\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\n"}
{"source": {"path": "sieve/sieve.c", "function_name": "main", "content": "int\nmain(void)\n{\n\n  long  j,p;\n\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\");\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n\t\n  j = 1024;\n  p = 1;\n  SIEVE(j,p);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "sieve/sieve.host.O0.pseudo", "function_name": "main", "address": "0x1300", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv, envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  SIEVE(1024LL, 1LL);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv,\n                envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  SIEVE(1024LL, 1LL);\n  libmin_success();\n}", "binary": "sieve/sieve.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nlea    0x2d0d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34c7 <libmin_printf>\nlea    0x2d31(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34c7 <libmin_printf>\nlea    0x2d3d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34c7 <libmin_printf>\nlea    0x2d4e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   34c7 <libmin_printf>\nmovq   $0x400,-0x10(%rbp)\nmovq   $0x1,-0x8(%rbp)\nmov    -0x8(%rbp),%rdx\nmov    -0x10(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   11e9 <SIEVE>\ncall   3734 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "simple-grep/simple-grep.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int ac = 3; char *av[] = { \"simple-grep\", \"speech.txt\", \"the\" };\n  char lineBuffer[BUFFER_LENGTH+1];\n  MFILE *fp = &speech;\n  int count = 0;\n\n  if (ac < 3)\n  {\n    libmin_printf(\"A string pattern and a file name are required\\n\" );\n    return 1;\n  }\n\n  libmin_mopen(&speech, \"r\");\n  if (!fp)\n  {\n    libmin_printf(\"Error - unable to open %s\\n\", av[1]);\n    return 2;\n  }\n\n  while (libmin_mgets(lineBuffer, BUFFER_LENGTH, fp))\n  {\n    // libmin_printf(\"%s\\n\", lineBuffer);\n    if (libmin_strstr(lineBuffer, av[2]))\n    {\n      libmin_printf(\"%s\", lineBuffer);\n      ++count;\n    }\n  }\n  libmin_mclose(fp);\n\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", count, av[2]);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "simple-grep/simple-grep.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int count; // [rsp+0h] [rbp-240h]\n  char lineBuffer[520]; // [rsp+30h] [rbp-210h] BYREF\n  unsigned __int64 v6; // [rsp+238h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  count = 0;\n  libmin_mopen(&speech, \"r\");\n  if ( &speech )\n  {\n    while ( libmin_mgets(lineBuffer, 0x1FFuLL, &speech) )\n    {\n      if ( libmin_strstr(lineBuffer, \"the\") )\n      {\n        libmin_printf(\"%s\", lineBuffer);\n        ++count;\n      }\n    }\n    libmin_mclose(&speech);\n    libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", count, \"the\");\n    libmin_success();\n  }\n  libmin_printf(\"Error - unable to open %s\\n\", \"speech.txt\");\n  return 2;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  int count;\n  char lineBuffer[520];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  count = 0;\n  libmin_mopen(&speech, \"r\");\n  if (&speech) {\n    while (libmin_mgets(lineBuffer, 511uLL, &speech)) {\n      if (libmin_strstr(lineBuffer, \"the\")) {\n        libmin_printf(\"%s\", lineBuffer);\n        ++count;\n      }\n    }\n    libmin_mclose(&speech);\n    libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\",\n                  count, \"the\");\n    libmin_success();\n  }\n  libmin_printf(\"Error - unable to open %s\\n\", \"speech.txt\");\n  return 2;\n}", "binary": "simple-grep/simple-grep.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x240,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x3,-0x23c(%rbp)\nlea    0x5bac(%rip),%rax\nmov    %rax,-0x230(%rbp)\nlea    0x5b93(%rip),%rax\nmov    %rax,-0x228(%rbp)\nlea    0x5b9c(%rip),%rax\nmov    %rax,-0x220(%rbp)\nlea    0x7dde(%rip),%rax\nmov    %rax,-0x238(%rbp)\nmovl   $0x0,-0x240(%rbp)\ncmpl   $0x2,-0x23c(%rbp)\njg     127a <main+0x91>\nlea    0x5b75(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3751 <libmin_printf>\nmov    $0x1,%eax\njmp    1364 <main+0x17b>\nlea    0x5b86(%rip),%rax\nmov    %rax,%rsi\nlea    0x7d95(%rip),%rax\nmov    %rax,%rdi\ncall   16fd <libmin_mopen>\ncmpq   $0x0,-0x238(%rbp)\njne    1308 <main+0x11f>\nmov    -0x228(%rbp),%rax\nmov    %rax,%rsi\nlea    0x5b5b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3751 <libmin_printf>\nmov    $0x2,%eax\njmp    1364 <main+0x17b>\nmov    -0x220(%rbp),%rdx\nlea    -0x210(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3a9c <libmin_strstr>\ntest   %rax,%rax\nje     1308 <main+0x11f>\nlea    -0x210(%rbp),%rax\nmov    %rax,%rsi\nlea    0x5b30(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3751 <libmin_printf>\naddl   $0x1,-0x240(%rbp)\nmov    -0x238(%rbp),%rdx\nlea    -0x210(%rbp),%rax\nmov    $0x1ff,%esi\nmov    %rax,%rdi\ncall   14d6 <libmin_mgets>\ntest   %rax,%rax\njne    12c5 <main+0xdc>\nmov    -0x238(%rbp),%rax\nmov    %rax,%rdi\ncall   14bc <libmin_mclose>\nmov    -0x220(%rbp),%rdx\nmov    -0x240(%rbp),%eax\nmov    %eax,%esi\nlea    0x5adb(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3751 <libmin_printf>\ncall   3b25 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1378 <main+0x18f>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "skeleton/skeleton.c", "function_name": "main", "content": "#include \"libmin.h\"\n\nint\nmain(void)\n{\n  libmin_printf(\"This is a test!, %d, %f...\\n\", 23, 44.4);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "skeleton/skeleton.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"This is a test!, %d, %f...\\n\", 23, 44.4);\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "skeleton/skeleton.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    0x2e30(%rip),%rax\nmovq   %rax,%xmm0\nmov    $0x17,%esi\nlea    0x2dff(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   335e <libmin_printf>\ncall   35cb <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "spelt2num/spelt2num.c", "function_name": "main", "content": "int main(){char **r;int e=0;for(;n++||(e=*p++)>0;b=\"ynwtsflrabg\"[n%=11]-e?b:b*8+n)for(r=(char **)(b%64-25);e<47&&b;b/=8)for(n=19;n;(void)(((n[\"1+DIY/.K430x9G(kC[\"]-42)&255)^b||(m+=n>15?n:n>9?m%u*~-u:~(long)r?n+!(long)r*16:n*16,b=0)))u=1ll<<6177%n--*4;libmin_printf(\"%llx\\n\",m);libmin_success();}\n"}, "pseudo": {"path": "spelt2num/spelt2num.host.O0.pseudo", "function_name": "main", "address": "0x11e9", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rdi\n  __int64 v4; // rax\n  __int64 v5; // rdx\n  __int64 v6; // rax\n  char *v8; // rax\n  int e; // [rsp+4h] [rbp-Ch]\n  char **r; // [rsp+8h] [rbp-8h]\n\n  e = 0;\n  while ( 1 )\n  {\n    if ( !n++ )\n    {\n      v8 = p++;\n      e = *v8;\n      if ( e <= 0 )\n        break;\n    }\n    r = (char **)(b % 64 - 25);\n    while ( e <= 46 && b )\n    {\n      n = 19LL;\n      while ( n )\n      {\n        v3 = n--;\n        u = 1LL << (4 * (unsigned __int8)(6177 % v3));\n        if ( (unsigned __int8)(a1DiyK430x9gKc[n] - 42) == b )\n        {\n          if ( n > 15 )\n          {\n            v4 = n;\n          }\n          else if ( n <= 9 )\n          {\n            if ( r == (char **)-1LL )\n            {\n              v4 = 16 * n;\n            }\n            else\n            {\n              if ( r )\n                v5 = 0LL;\n              else\n                v5 = 16LL;\n              v4 = v5 + n;\n            }\n          }\n          else\n          {\n            v4 = m % u * (u - 1);\n          }\n          m += v4;\n          b = 0LL;\n        }\n      }\n      b /= 8LL;\n    }\n    n %= 11LL;\n    if ( e == aYnwtsflrabg[n] )\n      v6 = 8 * b + n;\n    else\n      v6 = b;\n    b = v6;\n  }\n  libmin_printf(\"%llx\\n\", m);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  char *v8;\n  int e;\n  char **r;\n  e = 0;\n  while (1) {\n    if (!n++) {\n      v8 = p++;\n      e = *v8;\n      if (e <= 0) break;\n    }\n    r = (char **)(b % 64 - 25);\n    while (e <= 46 && b) {\n      n = 19LL;\n      while (n) {\n        v3 = n--;\n        u = 1LL << (4 * (unsigned char)(6177 % v3));\n        if ((unsigned char)(a1DiyK430x9gKc[n] - 42) == b) {\n          if (n > 15) {\n            v4 = n;\n          } else if (n <= 9) {\n            if (r == (char **)-1LL) {\n              v4 = 16 * n;\n            } else {\n              if (r)\n                v5 = 0LL;\n              else\n                v5 = 16LL;\n              v4 = v5 + n;\n            }\n          } else {\n            v4 = m % u * (u - 1);\n          }\n          m += v4;\n          b = 0LL;\n        }\n      }\n      b /= 8LL;\n    }\n    n %= 11LL;\n    if (e == aYnwtsflrabg[n])\n      v6 = 8 * b + n;\n    else\n      v6 = b;\n    b = v6;\n  }\n  libmin_printf(\"%llx\\n\", m);\n  libmin_success();\n}", "binary": "spelt2num/spelt2num.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0xc(%rbp)\njmp    1405 <main+0x21c>\nmov    0x5080(%rip),%rax\ncqto\nshr    $0x3a,%rdx\nadd    %rdx,%rax\nand    $0x3f,%eax\nsub    %rdx,%rax\nsub    $0x19,%rax\nmov    %rax,-0x8(%rbp)\njmp    1365 <main+0x17c>\nmovq   $0x13,0x5041(%rip)\njmp    1338 <main+0x14f>\nmov    0x5035(%rip),%rdi\nlea    -0x1(%rdi),%rax\nmov    %rax,0x502a(%rip)\nmov    $0x1821,%eax\ncqto\nidiv   %rdi\nmov    %rdx,%rcx\nmov    %rcx,%rax\nshl    $0x2,%eax\nmov    $0x1,%edx\nmov    %eax,%ecx\nshl    %cl,%rdx\nmov    %rdx,%rax\nmov    %rax,0x500b(%rip)\nmov    0x4ffc(%rip),%rax\nlea    0x2dfe(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\nsub    $0x2a,%eax\ncltq\nmovzbl %al,%edx\nmov    0x4ff7(%rip),%rax\ncmp    %rax,%rdx\njne    1338 <main+0x14f>\nmov    0x4fcf(%rip),%rax\ncmp    $0xf,%rax\njg     130b <main+0x122>\nmov    0x4fc2(%rip),%rax\ncmp    $0x9,%rax\njle    12d8 <main+0xef>\nmov    0x4fc5(%rip),%rax\nmov    0x4fb6(%rip),%rcx\ncqto\nidiv   %rcx\nmov    0x4faa(%rip),%rax\nsub    $0x1,%rax\nimul   %rdx,%rax\njmp    1312 <main+0x129>\ncmpq   $0xffffffffffffffff,-0x8(%rbp)\nje     12fe <main+0x115>\ncmpq   $0x0,-0x8(%rbp)\njne    12ed <main+0x104>\nmov    $0x10,%edx\njmp    12f2 <main+0x109>\nmov    $0x0,%edx\nmov    0x4f77(%rip),%rax\nadd    %rdx,%rax\njmp    1312 <main+0x129>\nmov    0x4f6b(%rip),%rax\nshl    $0x4,%rax\njmp    1312 <main+0x129>\nmov    0x4f5e(%rip),%rax\nmov    0x4f67(%rip),%rdx\nadd    %rdx,%rax\nmov    %rax,0x4f5d(%rip)\nmovq   $0x0,0x4f5a(%rip)\nmov    0x4f53(%rip),%rax\ntest   %rax,%rax\nmov    0x4f31(%rip),%rax\ntest   %rax,%rax\njne    1234 <main+0x4b>\nmov    0x4f39(%rip),%rax\nlea    0x7(%rax),%rdx\ntest   %rax,%rax\ncmovs  %rdx,%rax\nsar    $0x3,%rax\nmov    %rax,0x4f23(%rip)\ncmpl   $0x2e,-0xc(%rbp)\njg     137b <main+0x192>\nmov    0x4f16(%rip),%rax\ntest   %rax,%rax\njne    1224 <main+0x3b>\nmov    0x4eee(%rip),%rcx\nmovabs $0x2e8ba2e8ba2e8ba3,%rdx\nmov    %rcx,%rax\nimul   %rdx\nmov    %rdx,%rax\nsar    %rax\nmov    %rcx,%rsi\nsar    $0x3f,%rsi\nsub    %rsi,%rax\nmov    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nadd    %rax,%rax\nadd    %rdx,%rax\nsub    %rax,%rcx\nmov    %rcx,%rdx\nmov    %rdx,0x4eae(%rip)\nmov    0x4ea7(%rip),%rax\nlea    0x2cbc(%rip),%rdx\nmovzbl (%rax,%rdx,1),%eax\nmovsbl %al,%eax\ncmp    %eax,-0xc(%rbp)\njne    13f7 <main+0x20e>\nmov    0x4ea5(%rip),%rax\nlea    0x0(,%rax,8),%rdx\nmov    0x4e7e(%rip),%rax\nadd    %rdx,%rax\njmp    13fe <main+0x215>\nmov    0x4e8a(%rip),%rax\nmov    %rax,0x4e83(%rip)\nmov    0x4e64(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x4e59(%rip)\ntest   %rax,%rax\njne    1201 <main+0x18>\nmov    0x4be9(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x4bde(%rip)\nmovzbl (%rax),%eax\nmovsbl %al,%eax\nmov    %eax,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njg     1201 <main+0x18>\nmov    0x4e34(%rip),%rax\nmov    %rax,%rsi\nlea    0x2c1d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35ab <libmin_printf>\ncall   3818 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "spirograph/spirograph.c", "function_name": "main", "content": "/** Main function */\nint main(int argc, char **argv)\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "spirograph/spirograph.host.O0.pseudo", "function_name": "main", "address": "0x14cb", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  test();\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "spirograph/spirograph.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\nmov    %rsi,-0x10(%rbp)\ncall   13b8 <test>\ncall   42ff <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "spirograph/spirograph.c", "function_name": "spirograph", "content": "/**\n * @file\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Implementation of\n * [Spirograph](https://en.wikipedia.org/wiki/Spirograph)\n *\n * @details\n * Implementation of the program is based on the geometry shown in the figure\n * below:\n *\n * <a\n * href=\"https://commons.wikimedia.org/wiki/File:Resonance_Cascade.svg\"><img\n * src=\"https://upload.wikimedia.org/wikipedia/commons/3/39/Resonance_Cascade.svg\"\n * alt=\"Spirograph geometry from Wikipedia\" style=\"width: 250px\"/></a>\n */\n#include \"libmin.h\"\n\n/** Generate spirograph curve into arrays `x` and `y` such that the i^th point\n * in 2D is represented by `(x[i],y[i])`. The generating function is given by:\n * \\f{eqnarray*}{\n * x &=& R\\left[ (1-k) \\cos (t) + l\\cdot k\\cdot\\cos \\left(\\frac{1-k}{k}t\\right)\n * \\right]\\\\\n * y &=& R\\left[ (1-k) \\sin (t) - l\\cdot k\\cdot\\sin \\left(\\frac{1-k}{k}t\\right)\n * \\right] \\f}\n * where\n * * \\f$R\\f$ is the scaling parameter that we will consider \\f$=1\\f$\n * * \\f$l=\\frac{\\rho}{r}\\f$ is the relative distance of marker from the centre\n * of inner circle and \\f$0\\le l\\le1\\f$\n * * \\f$\\rho\\f$ is physical distance of marker from centre of inner circle\n * * \\f$r\\f$ is the radius of inner circle\n * * \\f$k=\\frac{r}{R}\\f$ is the ratio of radius of inner circle to outer circle\n * and \\f$0<k<1\\f$\n * * \\f$R\\f$ is the radius of outer circle\n * * \\f$t\\f$ is the angle of rotation of the point i.e., represents the time\n * parameter\n *\n * Since we are considering ratios, the actual values of \\f$r\\f$ and\n * \\f$R\\f$ are immaterial.\n *\n * @param [out] x output array containing absicca of points (must be\n * pre-allocated)\n * @param [out] y output array containing ordinates of points (must be\n * pre-allocated)\n * @param l the relative distance of marker from the centre of\n * inner circle and \\f$0\\le l\\le1\\f$\n * @param k the ratio of radius of inner circle to outer circle and\n * \\f$0<k<1\\f$\n * @param N number of sample points along the trajectory (higher = better\n * resolution but consumes more time and memory)\n * @param num_rot the number of rotations to perform (can be fractional value)\n */\nvoid spirograph(double *x, double *y, double l, double k, size_t N, double rot)\n{\n    double dt = rot * 2.f * M_PI / N;\n    double t = 0.f, R = 1.f;\n    const double k1 = 1.f - k;\n\n    for (size_t dk = 0; dk < N; dk++, t += dt)\n    {\n        x[dk] = R * (k1 * libmin_cos(t) + l * k * libmin_cos(k1 * t / k));\n        y[dk] = R * (k1 * libmin_sin(t) - l * k * libmin_sin(k1 * t / k));\n    }\n}\n"}, "pseudo": {"path": "spirograph/spirograph.host.O0.pseudo", "function_name": "spirograph", "address": "0x11e9", "label": "spirograph", "content": "void __cdecl spirograph(double *x, double *y, double l, double k, size_t N, double rot)\n{\n  double v6; // xmm0_8\n  double v7; // [rsp+8h] [rbp-68h]\n  double v8; // [rsp+8h] [rbp-68h]\n  double t; // [rsp+48h] [rbp-28h]\n  size_t dk; // [rsp+50h] [rbp-20h]\n  double dt; // [rsp+58h] [rbp-18h]\n  double k1_0; // [rsp+68h] [rbp-8h]\n\n  if ( (N & 0x8000000000000000LL) != 0LL )\n    v6 = (double)(int)(N & 1 | (N >> 1)) + (double)(int)(N & 1 | (N >> 1));\n  else\n    v6 = (double)(int)N;\n  dt = (rot + rot) * 3.141592653589793 / v6;\n  t = 0.0;\n  k1_0 = 1.0 - k;\n  for ( dk = 0LL; dk < N; ++dk )\n  {\n    v7 = libmin_cos(t) * k1_0;\n    x[dk] = (libmin_cos(k1_0 * t / k) * (l * k) + v7) * 1.0;\n    v8 = libmin_sin(t) * k1_0;\n    y[dk] = (v8 - l * k * libmin_sin(k1_0 * t / k)) * 1.0;\n    t = t + dt;\n  }\n}\n"}, "pseudo_normalize": "void spirograph(double *x, double *y, double l, double k, unsigned int N,\n                double rot) {\n  double v6;\n  double v7;\n  double v8;\n  double t;\n  unsigned int dk;\n  double dt;\n  double k1_0;\n  if ((N & 9223372036854775808LL) != 0LL)\n    v6 = (double)(int)(N & 1 | (N >> 1)) + (double)(int)(N & 1 | (N >> 1));\n  else\n    v6 = (double)(int)N;\n  dt = (rot + rot) * 3.141592653589793 / v6;\n  t = 0.0;\n  k1_0 = 1.0 - k;\n  for (dk = 0LL; dk < N; ++dk) {\n    v7 = libmin_cos(t) * k1_0;\n    x[dk] = (libmin_cos(k1_0 * t / k) * (l * k) + v7) * 1.0;\n    v8 = libmin_sin(t) * k1_0;\n    y[dk] = (v8 - l * k * libmin_sin(k1_0 * t / k)) * 1.0;\n    t = t + dt;\n  }\n}", "binary": "spirograph/spirograph.host.O0", "assembly": "<spirograph>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmovsd  %xmm0,-0x48(%rbp)\nmovsd  %xmm1,-0x50(%rbp)\nmov    %rdx,-0x58(%rbp)\nmovsd  %xmm2,-0x60(%rbp)\nmovsd  -0x60(%rbp),%xmm0\nmovapd %xmm0,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x4df3(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x58(%rbp),%rax\ntest   %rax,%rax\njs     123d <spirograph+0x54>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1256 <spirograph+0x6d>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,-0x18(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  0x4db0(%rip),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmovsd  0x4da3(%rip),%xmm0\nsubsd  -0x50(%rbp),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovq   $0x0,-0x20(%rbp)\njmp    13a6 <spirograph+0x1bd>\nmov    -0x28(%rbp),%rax\nmovq   %rax,%xmm0\ncall   3f60 <libmin_cos>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm5\nmulsd  -0x8(%rbp),%xmm5\nmovsd  %xmm5,-0x68(%rbp)\nmovsd  -0x48(%rbp),%xmm0\nmulsd  -0x50(%rbp),%xmm0\nmovsd  %xmm0,-0x70(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x28(%rbp),%xmm0\nmovapd %xmm0,%xmm7\ndivsd  -0x50(%rbp),%xmm7\nmovq   %xmm7,%rax\nmovq   %rax,%xmm0\ncall   3f60 <libmin_cos>\nmulsd  -0x70(%rbp),%xmm0\naddsd  -0x68(%rbp),%xmm0\nmov    -0x20(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmulsd  -0x10(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x28(%rbp),%rax\nmovq   %rax,%xmm0\ncall   4111 <libmin_sin>\nmovq   %xmm0,%rax\nmovq   %rax,%xmm3\nmulsd  -0x8(%rbp),%xmm3\nmovsd  %xmm3,-0x68(%rbp)\nmovsd  -0x48(%rbp),%xmm0\nmovapd %xmm0,%xmm4\nmulsd  -0x50(%rbp),%xmm4\nmovsd  %xmm4,-0x70(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmulsd  -0x28(%rbp),%xmm0\nmovapd %xmm0,%xmm2\ndivsd  -0x50(%rbp),%xmm2\nmovq   %xmm2,%rax\nmovq   %rax,%xmm0\ncall   4111 <libmin_sin>\nmovsd  -0x70(%rbp),%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  -0x68(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmov    -0x20(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x40(%rbp),%rax\nadd    %rdx,%rax\nmulsd  -0x10(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\naddq   $0x1,-0x20(%rbp)\nmovsd  -0x28(%rbp),%xmm0\naddsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x58(%rbp),%rax\njb     1294 <spirograph+0xab>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "spirograph/spirograph.c", "function_name": "test", "content": "/**\n * @brief Test function to save resulting points to a CSV file.\n *\n */\nvoid test(void)\n{\n    size_t N = 500;\n    double l = 0.3, k = 0.75, rot = 10.;\n    double *x = (double *)libmin_malloc(N * sizeof(double));\n    double *y = (double *)libmin_malloc(N * sizeof(double));\n\n    spirograph(x, y, l, k, N, rot);\n\n    for (size_t i = 0; i < N; i++)\n    {\n        libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n    }\n\n    libmin_free(x);\n    libmin_free(y);\n}\n"}, "pseudo": {"path": "spirograph/spirograph.host.O0.pseudo", "function_name": "test", "address": "0x13b8", "label": "test", "content": "void __cdecl test()\n{\n  size_t i; // [rsp+8h] [rbp-38h]\n  double *x; // [rsp+30h] [rbp-10h]\n  double *y; // [rsp+38h] [rbp-8h]\n\n  x = (double *)libmin_malloc(0xFA0uLL);\n  y = (double *)libmin_malloc(0xFA0uLL);\n  spirograph(x, y, 0.3, 0.75, 0x1F4uLL, 10.0);\n  for ( i = 0LL; i < 0x1F4; ++i )\n    libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n  libmin_free(x);\n  libmin_free(y);\n}\n"}, "pseudo_normalize": "void test() {\n  unsigned int i;\n  double *x;\n  double *y;\n  x = (double *)libmin_malloc(4000uLL);\n  y = (double *)libmin_malloc(4000uLL);\n  spirograph(x, y, 0.3, 0.75, 500uLL, 10.0);\n  for (i = 0LL; i < 500; ++i) libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n  libmin_free(x);\n  libmin_free(y);\n}", "binary": "spirograph/spirograph.host.O0", "assembly": "<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmovq   $0x1f4,-0x30(%rbp)\nmovsd  0x4c54(%rip),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovsd  0x4c4f(%rip),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmovsd  0x4c4a(%rip),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1682 <libmin_malloc>\nmov    %rax,-0x10(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1682 <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmovsd  -0x18(%rbp),%xmm1\nmov    -0x30(%rbp),%rdx\nmovsd  -0x20(%rbp),%xmm0\nmov    -0x28(%rbp),%rsi\nmov    -0x8(%rbp),%rcx\nmov    -0x10(%rbp),%rax\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rsi,%xmm0\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   11e9 <spirograph>\nmovq   $0x0,-0x38(%rbp)\njmp    14a6 <test+0xee>\nmov    -0x38(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmov    -0x38(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x10(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nlea    0x4b74(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   3ae4 <libmin_printf>\naddq   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     1457 <test+0x9f>\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   176d <libmin_free>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   176d <libmin_free>\nnop\nleave\nret\n"}
{"source": {"path": "sudoku-solver/sudoku-solver.c", "function_name": "isSafe", "content": "// Check if placing num at board[row][col] is valid.\nint isSafe(int row, int col, int num) {\n    // Check row for duplicates.\n    for (int i = 0; i < N; i++) {\n        if (board[row][i] == num)\n            return 0;\n    }\n    // Check column for duplicates.\n    for (int i = 0; i < N; i++) {\n        if (board[i][col] == num)\n            return 0;\n    }\n    // Check 3x3 subgrid for duplicates.\n    int startRow = row - row % 3;\n    int startCol = col - col % 3;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (board[startRow + i][startCol + j] == num)\n                return 0;\n        }\n    }\n    return 1;\n}\n"}, "pseudo": {"path": "sudoku-solver/sudoku-solver.host.O0.pseudo", "function_name": "isSafe", "address": "0x11e9", "label": "isSafe", "content": "int __cdecl isSafe(int row, int col, int num)\n{\n  int i; // [rsp+14h] [rbp-18h]\n  int i_0; // [rsp+18h] [rbp-14h]\n  int i_1; // [rsp+1Ch] [rbp-10h]\n  int j; // [rsp+20h] [rbp-Ch]\n\n  for ( i = 0; i <= 8; ++i )\n  {\n    if ( num == board[row][i] )\n      return 0;\n  }\n  for ( i_0 = 0; i_0 <= 8; ++i_0 )\n  {\n    if ( num == board[i_0][col] )\n      return 0;\n  }\n  for ( i_1 = 0; i_1 <= 2; ++i_1 )\n  {\n    for ( j = 0; j <= 2; ++j )\n    {\n      if ( num == board[row - row % 3][9 * i_1 + col - col % 3 + j] )\n        return 0;\n    }\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int isSafe(int row, int col, int num) {\n  int i;\n  int i_0;\n  int i_1;\n  int j;\n  for (i = 0; i <= 8; ++i) {\n    if (num == board[row][i]) return 0;\n  }\n  for (i_0 = 0; i_0 <= 8; ++i_0) {\n    if (num == board[i_0][col]) return 0;\n  }\n  for (i_1 = 0; i_1 <= 2; ++i_1) {\n    for (j = 0; j <= 2; ++j) {\n      if (num == board[row - row % 3][9 * i_1 + col - col % 3 + j]) return 0;\n    }\n  }\n  return 1;\n}", "binary": "sudoku-solver/sudoku-solver.host.O0", "assembly": "<isSafe>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %edi,-0x24(%rbp)\nmov    %esi,-0x28(%rbp)\nmov    %edx,-0x2c(%rbp)\nmovl   $0x0,-0x18(%rbp)\njmp    1241 <isSafe+0x58>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4df5(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,-0x2c(%rbp)\njne    123d <isSafe+0x54>\nmov    $0x0,%eax\njmp    1358 <isSafe+0x16f>\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x8,-0x18(%rbp)\njle    1203 <isSafe+0x1a>\nmovl   $0x0,-0x14(%rbp)\njmp    128e <isSafe+0xa5>\nmov    -0x28(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4da8(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,-0x2c(%rbp)\njne    128a <isSafe+0xa1>\nmov    $0x0,%eax\njmp    1358 <isSafe+0x16f>\naddl   $0x1,-0x14(%rbp)\ncmpl   $0x8,-0x14(%rbp)\njle    1250 <isSafe+0x67>\nmov    -0x24(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nmov    %eax,%esi\nsar    $0x1f,%esi\nmov    %edx,%ecx\nsub    %esi,%ecx\nmov    %ecx,%edx\nadd    %edx,%edx\nadd    %ecx,%edx\nsub    %edx,%eax\nmov    %eax,%ecx\nmov    -0x24(%rbp),%eax\nsub    %ecx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x28(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x55555556,%rdx,%rdx\nshr    $0x20,%rdx\nmov    %eax,%esi\nsar    $0x1f,%esi\nmov    %edx,%ecx\nsub    %esi,%ecx\nmov    %ecx,%edx\nadd    %edx,%edx\nadd    %ecx,%edx\nsub    %edx,%eax\nmov    %eax,%ecx\nmov    -0x28(%rbp),%eax\nsub    %ecx,%eax\nmov    %eax,-0x4(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    134d <isSafe+0x164>\nmovl   $0x0,-0xc(%rbp)\njmp    1343 <isSafe+0x15a>\nmov    -0x8(%rbp),%edx\nmov    -0x10(%rbp),%eax\nadd    %edx,%eax\nmov    -0x4(%rbp),%ecx\nmov    -0xc(%rbp),%edx\nadd    %ecx,%edx\nmovslq %edx,%rcx\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4cf0(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ncmp    %eax,-0x2c(%rbp)\njne    133f <isSafe+0x156>\nmov    $0x0,%eax\njmp    1358 <isSafe+0x16f>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x2,-0xc(%rbp)\njle    12fe <isSafe+0x115>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x2,-0x10(%rbp)\njle    12f5 <isSafe+0x10c>\nmov    $0x1,%eax\npop    %rbp\nret\n"}
{"source": {"path": "sudoku-solver/sudoku-solver.c", "function_name": "main", "content": "int main() {\n    libmin_printf(\"Initial Sudoku Puzzle:\\n\");\n    printBoard();\n\n    if (solveSudoku()) {\n        libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n        printBoard();\n        libtarg_success();\n    } else {\n        libmin_printf(\"No solution found.\\n\");\n        libtarg_fail(1);\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "sudoku-solver/sudoku-solver.host.O0.pseudo", "function_name": "main", "address": "0x1532", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if ( solveSudoku() )\n  {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if (solveSudoku()) {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}", "binary": "sudoku-solver/sudoku-solver.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nlea    0x2ac9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e3 <libmin_printf>\nmov    $0x0,%eax\ncall   14a7 <printBoard>\nmov    $0x0,%eax\ncall   135a <solveSudoku>\ntest   %eax,%eax\nje     1589 <main+0x57>\nlea    0x2ab5(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e3 <libmin_printf>\nmov    $0x0,%eax\ncall   14a7 <printBoard>\ncall   15a7 <libtarg_success>\nlea    0x2aaa(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e3 <libmin_printf>\nmov    $0x1,%edi\ncall   15b9 <libtarg_fail>\n"}
{"source": {"path": "sudoku-solver/sudoku-solver.c", "function_name": "printBoard", "content": "// Utility function to print the Sudoku board.\nvoid printBoard() {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            libmin_printf(\"%d \", board[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "sudoku-solver/sudoku-solver.host.O0.pseudo", "function_name": "printBoard", "address": "0x14a7", "label": "printBoard", "content": "void __cdecl printBoard()\n{\n  int i; // [rsp+8h] [rbp-8h]\n  int j; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i <= 8; ++i )\n  {\n    for ( j = 0; j <= 8; ++j )\n      libmin_printf(\"%d \", board[i][j]);\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo_normalize": "void printBoard() {\n  int i;\n  int j;\n  for (i = 0; i <= 8; ++i) {\n    for (j = 0; j <= 8; ++j) libmin_printf(\"%d \", board[i][j]);\n    libmin_printf(\"\\n\");\n  }\n}", "binary": "sudoku-solver/sudoku-solver.host.O0", "assembly": "<printBoard>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x8(%rbp)\njmp    1528 <printBoard+0x81>\nmovl   $0x0,-0x4(%rbp)\njmp    150a <printBoard+0x63>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4b33(%rip),%rax\nmov    (%rdx,%rax,1),%eax\nmov    %eax,%esi\nlea    0x2b0b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e3 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x8,-0x4(%rbp)\njle    14c5 <printBoard+0x1e>\nlea    0x2af1(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   36e3 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x8,-0x8(%rbp)\njle    14bc <printBoard+0x15>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "sudoku-solver/sudoku-solver.c", "function_name": "solveSudoku", "content": "// Recursively attempt to fill the Sudoku board.\nint solveSudoku() {\n    int row = -1;\n    int col = -1;\n    int emptyFound = 0;\n\n    // Find an empty cell.\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (board[i][j] == 0) {\n                row = i;\n                col = j;\n                emptyFound = 1;\n                break;\n            }\n        }\n        if (emptyFound)\n            break;\n    }\n\n    // No empty cell found; puzzle is solved.\n    if (!emptyFound)\n        return 1;\n\n    // Try placing numbers 1 to 9 in the empty cell.\n    for (int num = 1; num <= 9; num++) {\n        if (isSafe(row, col, num)) {\n            board[row][col] = num;\n            if (solveSudoku())\n                return 1;\n            board[row][col] = 0;  // Backtrack.\n        }\n    }\n    return 0;  // Trigger backtracking.\n}\n"}, "pseudo": {"path": "sudoku-solver/sudoku-solver.host.O0.pseudo", "function_name": "solveSudoku", "address": "0x135a", "label": "solveSudoku", "content": "int __cdecl solveSudoku()\n{\n  int row; // [rsp+8h] [rbp-18h]\n  int col; // [rsp+Ch] [rbp-14h]\n  int emptyFound; // [rsp+10h] [rbp-10h]\n  int i; // [rsp+14h] [rbp-Ch]\n  int j; // [rsp+18h] [rbp-8h]\n  int num; // [rsp+1Ch] [rbp-4h]\n\n  row = -1;\n  col = -1;\n  emptyFound = 0;\n  for ( i = 0; i <= 8; ++i )\n  {\n    for ( j = 0; j <= 8; ++j )\n    {\n      if ( !board[i][j] )\n      {\n        row = i;\n        col = j;\n        emptyFound = 1;\n        break;\n      }\n    }\n    if ( emptyFound )\n      break;\n  }\n  if ( !emptyFound )\n    return 1;\n  for ( num = 1; num <= 9; ++num )\n  {\n    if ( isSafe(row, col, num) )\n    {\n      board[row][col] = num;\n      if ( solveSudoku() )\n        return 1;\n      board[row][col] = 0;\n    }\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int solveSudoku() {\n  int row;\n  int col;\n  int emptyFound;\n  int i;\n  int j;\n  int num;\n  row = -1;\n  col = -1;\n  emptyFound = 0;\n  for (i = 0; i <= 8; ++i) {\n    for (j = 0; j <= 8; ++j) {\n      if (!board[i][j]) {\n        row = i;\n        col = j;\n        emptyFound = 1;\n        break;\n      }\n    }\n    if (emptyFound) break;\n  }\n  if (!emptyFound) return 1;\n  for (num = 1; num <= 9; ++num) {\n    if (isSafe(row, col, num)) {\n      board[row][col] = num;\n      if (solveSudoku()) return 1;\n      board[row][col] = 0;\n    }\n  }\n  return 0;\n}", "binary": "sudoku-solver/sudoku-solver.host.O0", "assembly": "<solveSudoku>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovl   $0xffffffff,-0x18(%rbp)\nmovl   $0xffffffff,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    13e5 <solveSudoku+0x8b>\nmovl   $0x0,-0x8(%rbp)\njmp    13d5 <solveSudoku+0x7b>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4c6b(%rip),%rax\nmov    (%rdx,%rax,1),%eax\ntest   %eax,%eax\njne    13d1 <solveSudoku+0x77>\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0x8(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmovl   $0x1,-0x10(%rbp)\njmp    13db <solveSudoku+0x81>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x8,-0x8(%rbp)\njle    138d <solveSudoku+0x33>\ncmpl   $0x0,-0x10(%rbp)\njne    13ed <solveSudoku+0x93>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x8,-0xc(%rbp)\njle    1384 <solveSudoku+0x2a>\njmp    13ee <solveSudoku+0x94>\nnop\ncmpl   $0x0,-0x10(%rbp)\njne    13fe <solveSudoku+0xa4>\nmov    $0x1,%eax\njmp    14a5 <solveSudoku+0x14b>\nmovl   $0x1,-0x4(%rbp)\njmp    1496 <solveSudoku+0x13c>\nmov    -0x4(%rbp),%edx\nmov    -0x14(%rbp),%ecx\nmov    -0x18(%rbp),%eax\nmov    %ecx,%esi\nmov    %eax,%edi\ncall   11e9 <isSafe>\ntest   %eax,%eax\nje     1492 <solveSudoku+0x138>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rcx\nlea    0x4bd8(%rip),%rdx\nmov    -0x4(%rbp),%eax\nmov    %eax,(%rcx,%rdx,1)\nmov    $0x0,%eax\ncall   135a <solveSudoku>\ntest   %eax,%eax\nje     1463 <solveSudoku+0x109>\nmov    $0x1,%eax\njmp    14a5 <solveSudoku+0x14b>\nmov    -0x14(%rbp),%eax\nmovslq %eax,%rcx\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nadd    %rcx,%rax\nlea    0x0(,%rax,4),%rdx\nlea    0x4b95(%rip),%rax\nmovl   $0x0,(%rdx,%rax,1)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njle    140a <solveSudoku+0xb0>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "aggregate_height", "content": "int aggregate_height(int heights[BOARD_WIDTH]) {\n    int sum = 0;\n    for (int i = 0; i < BOARD_WIDTH; i++)\n        sum += heights[i];\n    return sum;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "aggregate_height", "address": "0x1554", "label": "aggregate_height", "content": "int __cdecl aggregate_height(int *heights)\n{\n  int sum; // [rsp+10h] [rbp-8h]\n  int i; // [rsp+14h] [rbp-4h]\n\n  sum = 0;\n  for ( i = 0; i <= 9; ++i )\n    sum += heights[i];\n  return sum;\n}\n"}, "pseudo_normalize": "int aggregate_height(int *heights) {\n  int sum;\n  int i;\n  sum = 0;\n  for (i = 0; i <= 9; ++i) sum += heights[i];\n  return sum;\n}", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<aggregate_height>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    158d <aggregate_height+0x39>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njle    1570 <aggregate_height+0x1c>\nmov    -0x8(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "best_move", "content": "// ------------------------\n// AI: Find the best move for a given piece on the current board.\n// ------------------------\nint best_move(const int board[BOARD_HEIGHT][BOARD_WIDTH], const Piece *piece, const Orientation **best_ori, int *best_offset, double *best_score, int best_board[BOARD_HEIGHT][BOARD_WIDTH], int *lines_cleared_out) {\n    double max_score = -1e9;\n    int move_found = 0;\n    int temp_board[BOARD_HEIGHT][BOARD_WIDTH];\n    int lines;\n    // For each orientation of the piece.\n    for (int o = 0; o < piece->numOrientations; o++) {\n        const Orientation *ori = &(piece->orientations[o]);\n        // Calculate the horizontal span of the orientation.\n        int min_x = 100, max_x = -100;\n        for (int i = 0; i < ori->numBlocks; i++) {\n            int bx = ori->blocks[i].x;\n            if (bx < min_x) min_x = bx;\n            if (bx > max_x) max_x = bx;\n        }\n        // Determine valid horizontal offsets so that the piece remains within the board.\n        int start = -min_x;\n        int end = BOARD_WIDTH - max_x;\n        for (int x = start; x < end; x++) {\n            if (simulate_board((int (*)[BOARD_WIDTH])board, ori, x, temp_board, &lines)) {\n                double score = evaluate_board(temp_board, lines);\n                if (score > max_score) {\n                    max_score = score;\n                    *best_score = score;\n                    *best_ori = ori;\n                    *best_offset = x;\n                    libmin_memcpy(best_board, temp_board, sizeof(int)*BOARD_HEIGHT*BOARD_WIDTH);\n                    *lines_cleared_out = lines;\n                    move_found = 1;\n                }\n            }\n        }\n    }\n    return move_found;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "best_move", "address": "0x1810", "label": "best_move", "content": "int __cdecl best_move(\n        const int (*board)[10],\n        const Piece *piece,\n        const Orientation **best_ori,\n        int *best_offset,\n        double *best_score,\n        int (*best_board)[10],\n        int *lines_cleared_out)\n{\n  int lines; // [rsp+40h] [rbp-370h] BYREF\n  int move_found; // [rsp+44h] [rbp-36Ch]\n  int o; // [rsp+48h] [rbp-368h]\n  int min_x; // [rsp+4Ch] [rbp-364h]\n  int max_x; // [rsp+50h] [rbp-360h]\n  int i; // [rsp+54h] [rbp-35Ch]\n  int x; // [rsp+58h] [rbp-358h]\n  int start; // [rsp+5Ch] [rbp-354h]\n  int end; // [rsp+60h] [rbp-350h]\n  int bx_0; // [rsp+64h] [rbp-34Ch]\n  double max_score; // [rsp+68h] [rbp-348h]\n  const Orientation *ori; // [rsp+70h] [rbp-340h]\n  double score; // [rsp+78h] [rbp-338h]\n  int temp_board[20][10]; // [rsp+80h] [rbp-330h] BYREF\n  unsigned __int64 v26; // [rsp+3A8h] [rbp-8h]\n\n  v26 = __readfsqword(0x28u);\n  max_score = -1000000000.0;\n  move_found = 0;\n  for ( o = 0; o < piece->numOrientations; ++o )\n  {\n    ori = &piece->orientations[o];\n    min_x = 100;\n    max_x = -100;\n    for ( i = 0; i < ori->numBlocks; ++i )\n    {\n      bx_0 = ori->blocks[i].x;\n      if ( bx_0 < min_x )\n        min_x = bx_0;\n      if ( bx_0 > max_x )\n        max_x = bx_0;\n    }\n    start = -min_x;\n    end = 10 - max_x;\n    for ( x = -min_x; x < end; ++x )\n    {\n      if ( simulate_board((int (*)[10])board, ori, x, temp_board, &lines) )\n      {\n        score = evaluate_board(temp_board, lines);\n        if ( score > max_score )\n        {\n          max_score = score;\n          *best_score = score;\n          *best_ori = ori;\n          *best_offset = x;\n          libmin_memcpy(best_board, temp_board, 0x320uLL);\n          *lines_cleared_out = lines;\n          move_found = 1;\n        }\n      }\n    }\n  }\n  return move_found;\n}\n"}, "pseudo_normalize": "int best_move(const int (*board)[10], const Piece *piece,\n              const Orientation **best_ori, int *best_offset,\n              double *best_score, int (*best_board)[10],\n              int *lines_cleared_out) {\n  int lines;\n  int move_found;\n  int o;\n  int min_x;\n  int max_x;\n  int i;\n  int x;\n  int start;\n  int end;\n  int bx_0;\n  double max_score;\n  const Orientation *ori;\n  double score;\n  int temp_board[20][10];\n  unsigned long long v26;\n  v26 = __readfsqword(40u);\n  max_score = -1000000000.0;\n  move_found = 0;\n  for (o = 0; o < piece->numOrientations; ++o) {\n    ori = &piece->orientations[o];\n    min_x = 100;\n    max_x = -100;\n    for (i = 0; i < ori->numBlocks; ++i) {\n      bx_0 = ori->blocks[i].x;\n      if (bx_0 < min_x) min_x = bx_0;\n      if (bx_0 > max_x) max_x = bx_0;\n    }\n    start = -min_x;\n    end = 10 - max_x;\n    for (x = -min_x; x < end; ++x) {\n      if (simulate_board((int(*)[10])board, ori, x, temp_board, &lines)) {\n        score = evaluate_board(temp_board, lines);\n        if (score > max_score) {\n          max_score = score;\n          *best_score = score;\n          *best_ori = ori;\n          *best_offset = x;\n          libmin_memcpy(best_board, temp_board, 800uLL);\n          *lines_cleared_out = lines;\n          move_found = 1;\n        }\n      }\n    }\n  }\n  return move_found;\n}", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<best_move>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x3b0,%rsp\nmov    %rdi,-0x378(%rbp)\nmov    %rsi,-0x380(%rbp)\nmov    %rdx,-0x388(%rbp)\nmov    %rcx,-0x390(%rbp)\nmov    %r8,-0x398(%rbp)\nmov    %r9,-0x3a0(%rbp)\nmov    0x10(%rbp),%rax\nmov    %rax,-0x3a8(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovsd  0x3b95(%rip),%xmm0\nmovsd  %xmm0,-0x348(%rbp)\nmovl   $0x0,-0x36c(%rbp)\nmovl   $0x0,-0x368(%rbp)\njmp    1a72 <best_move+0x262>\nmov    -0x380(%rbp),%rax\nmov    0x8(%rax),%rcx\nmov    -0x368(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x3,%rax\nadd    %rdx,%rax\nshl    $0x2,%rax\nadd    %rcx,%rax\nmov    %rax,-0x340(%rbp)\nmovl   $0x64,-0x364(%rbp)\nmovl   $0xffffff9c,-0x360(%rbp)\nmovl   $0x0,-0x35c(%rbp)\njmp    192d <best_move+0x11d>\nmov    -0x340(%rbp),%rax\nmov    -0x35c(%rbp),%edx\nmovslq %edx,%rdx\nmov    0x4(%rax,%rdx,8),%eax\nmov    %eax,-0x34c(%rbp)\nmov    -0x34c(%rbp),%eax\ncmp    -0x364(%rbp),%eax\njge    190c <best_move+0xfc>\nmov    -0x34c(%rbp),%eax\nmov    %eax,-0x364(%rbp)\nmov    -0x34c(%rbp),%eax\ncmp    -0x360(%rbp),%eax\njle    1926 <best_move+0x116>\nmov    -0x34c(%rbp),%eax\nmov    %eax,-0x360(%rbp)\naddl   $0x1,-0x35c(%rbp)\nmov    -0x340(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x35c(%rbp)\njl     18d8 <best_move+0xc8>\nmov    -0x364(%rbp),%eax\nneg    %eax\nmov    %eax,-0x354(%rbp)\nmov    $0xa,%eax\nsub    -0x360(%rbp),%eax\nmov    %eax,-0x350(%rbp)\nmov    -0x354(%rbp),%eax\nmov    %eax,-0x358(%rbp)\njmp    1a59 <best_move+0x249>\nlea    -0x370(%rbp),%rdi\nlea    -0x330(%rbp),%rcx\nmov    -0x358(%rbp),%edx\nmov    -0x340(%rbp),%rsi\nmov    -0x378(%rbp),%rax\nmov    %rdi,%r8\nmov    %rax,%rdi\ncall   1772 <simulate_board>\ntest   %eax,%eax\nje     1a52 <best_move+0x242>\nmov    -0x370(%rbp),%edx\nlea    -0x330(%rbp),%rax\nmov    %edx,%esi\nmov    %rax,%rdi\ncall   1686 <evaluate_board>\nmovq   %xmm0,%rax\nmov    %rax,-0x338(%rbp)\nmovsd  -0x338(%rbp),%xmm0\ncomisd -0x348(%rbp),%xmm0\njbe    1a52 <best_move+0x242>\nmovsd  -0x338(%rbp),%xmm0\nmovsd  %xmm0,-0x348(%rbp)\nmov    -0x398(%rbp),%rax\nmovsd  -0x338(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x388(%rbp),%rax\nmov    -0x340(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x390(%rbp),%rax\nmov    -0x358(%rbp),%edx\nmov    %edx,(%rax)\nlea    -0x330(%rbp),%rcx\nmov    -0x3a0(%rbp),%rax\nmov    $0x320,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1eb6 <libmin_memcpy>\nmov    -0x370(%rbp),%edx\nmov    -0x3a8(%rbp),%rax\nmov    %edx,(%rax)\nmovl   $0x1,-0x36c(%rbp)\naddl   $0x1,-0x358(%rbp)\nmov    -0x358(%rbp),%eax\ncmp    -0x350(%rbp),%eax\njl     196e <best_move+0x15e>\naddl   $0x1,-0x368(%rbp)\nmov    -0x380(%rbp),%rax\nmov    0x4(%rax),%eax\ncmp    %eax,-0x368(%rbp)\njl     188c <best_move+0x7c>\nmov    -0x36c(%rbp),%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1aa2 <best_move+0x292>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "bumpiness", "content": "int bumpiness(int heights[BOARD_WIDTH]) {\n    int bump = 0;\n    for (int i = 0; i < BOARD_WIDTH - 1; i++)\n        bump += libmin_abs(heights[i] - heights[i+1]);\n    return bump;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "bumpiness", "address": "0x161a", "label": "bumpiness", "content": "int __cdecl bumpiness(int *heights)\n{\n  int bump; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  bump = 0;\n  for ( i = 0; i <= 8; ++i )\n    bump += libmin_abs(heights[i] - heights[i + 1]);\n  return bump;\n}\n"}, "pseudo_normalize": "int bumpiness(int *heights) {\n  int bump;\n  int i;\n  bump = 0;\n  for (i = 0; i <= 8; ++i) bump += libmin_abs(heights[i] - heights[i + 1]);\n  return bump;\n}", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<bumpiness>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    167b <bumpiness+0x61>\nmov    -0x4(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nadd    $0x1,%rdx\nlea    0x0(,%rdx,4),%rcx\nmov    -0x18(%rbp),%rdx\nadd    %rcx,%rdx\nmov    (%rdx),%edx\nsub    %edx,%eax\nmov    %eax,%edi\ncall   1e9f <libmin_abs>\nadd    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x8,-0x4(%rbp)\njle    163a <bumpiness+0x20>\nmov    -0x8(%rbp),%eax\nleave\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "check_collision", "content": "// Check whether placing an orientation at (offset_x, offset_y) causes a collision.\nint check_collision(int board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int offset_y) {\n    for (int i = 0; i < ori->numBlocks; i++) {\n        int x = offset_x + ori->blocks[i].x;\n        int y = offset_y + ori->blocks[i].y;\n        if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT)\n            return 1;\n        if (board[y][x] != 0)\n            return 1;\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "check_collision", "address": "0x1249", "label": "check_collision", "content": "int __cdecl check_collision(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  int i; // [rsp+1Ch] [rbp-Ch]\n  unsigned int x; // [rsp+20h] [rbp-8h]\n  unsigned int y; // [rsp+24h] [rbp-4h]\n\n  for ( i = 0; i < ori->numBlocks; ++i )\n  {\n    x = ori->blocks[i].x + offset_x;\n    y = ori->blocks[i].y + offset_y;\n    if ( x > 9 || y >= 0x14 )\n      return 1;\n    if ( (*board)[10 * y + x] )\n      return 1;\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int check_collision(int (*board)[10], const Orientation *ori, int offset_x,\n                    int offset_y) {\n  int i;\n  unsigned int x;\n  unsigned int y;\n  for (i = 0; i < ori->numBlocks; ++i) {\n    x = ori->blocks[i].x + offset_x;\n    y = ori->blocks[i].y + offset_y;\n    if (x > 9 || y >= 20) return 1;\n    if ((*board)[10 * y + x]) return 1;\n  }\n  return 0;\n}", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<check_collision>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    %ecx,-0x28(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    12eb <check_collision+0xa2>\nmov    -0x20(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    0x4(%rax,%rdx,8),%edx\nmov    -0x24(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    0x8(%rax,%rdx,8),%edx\nmov    -0x28(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x8(%rbp)\njs     12af <check_collision+0x66>\ncmpl   $0x9,-0x8(%rbp)\njg     12af <check_collision+0x66>\ncmpl   $0x0,-0x4(%rbp)\njs     12af <check_collision+0x66>\ncmpl   $0x13,-0x4(%rbp)\njle    12b6 <check_collision+0x6d>\nmov    $0x1,%eax\njmp    12ff <check_collision+0xb6>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\nje     12e7 <check_collision+0x9e>\nmov    $0x1,%eax\njmp    12ff <check_collision+0xb6>\naddl   $0x1,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njl     126b <check_collision+0x22>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "clear_lines", "content": "// Clear full lines from the board.\n// Returns the number of lines cleared.\nint clear_lines(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    int lines_cleared = 0;\n    for (int y = BOARD_HEIGHT - 1; y >= 0; y--) {\n        int full = 1;\n        for (int x = 0; x < BOARD_WIDTH; x++) {\n            if (board[y][x] == 0) {\n                full = 0;\n                break;\n            }\n        }\n        if (full) {\n            lines_cleared++;\n            // Move all rows above down one row.\n            for (int yy = y; yy > 0; yy--) {\n                for (int x = 0; x < BOARD_WIDTH; x++) {\n                    board[yy][x] = board[yy-1][x];\n                }\n            }\n            // Clear the top row.\n            for (int x = 0; x < BOARD_WIDTH; x++) {\n                board[0][x] = 0;\n            }\n            y++; // Recheck this row since new content was shifted down.\n        }\n    }\n    return lines_cleared;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "clear_lines", "address": "0x1389", "label": "clear_lines", "content": "int __cdecl clear_lines(int (*board)[10])\n{\n  int lines_cleared; // [rsp+Ch] [rbp-1Ch]\n  int y; // [rsp+10h] [rbp-18h]\n  int full; // [rsp+14h] [rbp-14h]\n  int x; // [rsp+18h] [rbp-10h]\n  int yy; // [rsp+1Ch] [rbp-Ch]\n  int x_0; // [rsp+20h] [rbp-8h]\n  int x_1; // [rsp+24h] [rbp-4h]\n\n  lines_cleared = 0;\n  for ( y = 19; y >= 0; --y )\n  {\n    full = 1;\n    for ( x = 0; x <= 9; ++x )\n    {\n      if ( !(*board)[10 * y + x] )\n      {\n        full = 0;\n        break;\n      }\n    }\n    if ( full )\n    {\n      ++lines_cleared;\n      for ( yy = y; yy > 0; --yy )\n      {\n        for ( x_0 = 0; x_0 <= 9; ++x_0 )\n          (*board)[10 * yy + x_0] = (*board)[10 * yy - 10 + x_0];\n      }\n      for ( x_1 = 0; x_1 <= 9; ++x_1 )\n        (*board)[x_1] = 0;\n      ++y;\n    }\n  }\n  return lines_cleared;\n}\n"}, "pseudo_normalize": "int clear_lines(int (*board)[10]) {\n  int lines_cleared;\n  int y;\n  int full;\n  int x;\n  int yy;\n  int x_0;\n  int x_1;\n  lines_cleared = 0;\n  for (y = 19; y >= 0; --y) {\n    full = 1;\n    for (x = 0; x <= 9; ++x) {\n      if (!(*board)[10 * y + x]) {\n        full = 0;\n        break;\n      }\n    }\n    if (full) {\n      ++lines_cleared;\n      for (yy = y; yy > 0; --yy) {\n        for (x_0 = 0; x_0 <= 9; ++x_0)\n          (*board)[10 * yy + x_0] = (*board)[10 * yy - 10 + x_0];\n      }\n      for (x_1 = 0; x_1 <= 9; ++x_1) (*board)[x_1] = 0;\n      ++y;\n    }\n  }\n  return lines_cleared;\n}", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<clear_lines>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmovl   $0x0,-0x1c(%rbp)\nmovl   $0x13,-0x18(%rbp)\njmp    14a3 <clear_lines+0x11a>\nmovl   $0x1,-0x14(%rbp)\nmovl   $0x0,-0x10(%rbp)\njmp    13ef <clear_lines+0x66>\nmov    -0x18(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x10(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\njne    13eb <clear_lines+0x62>\nmovl   $0x0,-0x14(%rbp)\njmp    13f5 <clear_lines+0x6c>\naddl   $0x1,-0x10(%rbp)\ncmpl   $0x9,-0x10(%rbp)\njle    13b8 <clear_lines+0x2f>\ncmpl   $0x0,-0x14(%rbp)\nje     149f <clear_lines+0x116>\naddl   $0x1,-0x1c(%rbp)\nmov    -0x18(%rbp),%eax\nmov    %eax,-0xc(%rbp)\njmp    1471 <clear_lines+0xe8>\nmovl   $0x0,-0x8(%rbp)\njmp    1467 <clear_lines+0xde>\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nlea    -0x28(%rax),%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rsi\nmov    -0xc(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x28(%rbp),%rax\nlea    (%rdx,%rax,1),%rcx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rsi,%rax,4),%edx\nmov    -0x8(%rbp),%eax\ncltq\nmov    %edx,(%rcx,%rax,4)\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x9,-0x8(%rbp)\njle    1414 <clear_lines+0x8b>\nsubl   $0x1,-0xc(%rbp)\ncmpl   $0x0,-0xc(%rbp)\njg     140b <clear_lines+0x82>\nmovl   $0x0,-0x4(%rbp)\njmp    1495 <clear_lines+0x10c>\nmov    -0x28(%rbp),%rax\nmov    -0x4(%rbp),%edx\nmovslq %edx,%rdx\nmovl   $0x0,(%rax,%rdx,4)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njle    1480 <clear_lines+0xf7>\naddl   $0x1,-0x18(%rbp)\nsubl   $0x1,-0x18(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njns    13a8 <clear_lines+0x1f>\nmov    -0x1c(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "count_holes", "content": "int count_holes(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    int holes = 0;\n    for (int x = 0; x < BOARD_WIDTH; x++) {\n        int block_found = 0;\n        for (int y = 0; y < BOARD_HEIGHT; y++) {\n            if (board[y][x] != 0)\n                block_found = 1;\n            else if (block_found)\n                holes++;\n        }\n    }\n    return holes;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "count_holes", "address": "0x1598", "label": "count_holes", "content": "int __cdecl count_holes(int (*board)[10])\n{\n  int holes; // [rsp+8h] [rbp-10h]\n  int x; // [rsp+Ch] [rbp-Ch]\n  int block_found; // [rsp+10h] [rbp-8h]\n  int y; // [rsp+14h] [rbp-4h]\n\n  holes = 0;\n  for ( x = 0; x <= 9; ++x )\n  {\n    block_found = 0;\n    for ( y = 0; y <= 19; ++y )\n    {\n      if ( (*board)[10 * y + x] )\n      {\n        block_found = 1;\n      }\n      else if ( block_found )\n      {\n        ++holes;\n      }\n    }\n  }\n  return holes;\n}\n"}, "pseudo_normalize": "int count_holes(int (*board)[10]) {\n  int holes;\n  int x;\n  int block_found;\n  int y;\n  holes = 0;\n  for (x = 0; x <= 9; ++x) {\n    block_found = 0;\n    for (y = 0; y <= 19; ++y) {\n      if ((*board)[10 * y + x]) {\n        block_found = 1;\n      } else if (block_found) {\n        ++holes;\n      }\n    }\n  }\n  return holes;\n}", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<count_holes>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x10(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    160f <count_holes+0x77>\nmovl   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1605 <count_holes+0x6d>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0xc(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\nje     15f7 <count_holes+0x5f>\nmovl   $0x1,-0x8(%rbp)\njmp    1601 <count_holes+0x69>\ncmpl   $0x0,-0x8(%rbp)\nje     1601 <count_holes+0x69>\naddl   $0x1,-0x10(%rbp)\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x13,-0x4(%rbp)\njle    15c4 <count_holes+0x2c>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x9,-0xc(%rbp)\njle    15b4 <count_holes+0x1c>\nmov    -0x10(%rbp),%eax\npop    %rbp\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "evaluate_board", "content": "// Evaluate a board state given the number of lines cleared by the last move.\ndouble evaluate_board(int board[BOARD_HEIGHT][BOARD_WIDTH], int lines_cleared) {\n    int heights[BOARD_WIDTH];\n    get_column_heights(board, heights);\n    int agg = aggregate_height(heights);\n    int holes = count_holes(board);\n    int bump = bumpiness(heights);\n    double score = WEIGHT_AGGREGATE_HEIGHT * agg +\n                   WEIGHT_COMPLETE_LINES * lines_cleared +\n                   WEIGHT_HOLES * holes +\n                   WEIGHT_BUMPINESS * bump;\n    return score;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "evaluate_board", "address": "0x1686", "label": "evaluate_board", "content": "double __cdecl evaluate_board(int (*board)[10], int lines_cleared)\n{\n  int agg; // [rsp+1Ch] [rbp-44h]\n  int holes; // [rsp+20h] [rbp-40h]\n  int heights[10]; // [rsp+30h] [rbp-30h] BYREF\n  unsigned __int64 v6; // [rsp+58h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  get_column_heights(board, heights);\n  agg = aggregate_height(heights);\n  holes = count_holes(board);\n  return -0.184483 * (double)bumpiness(heights)\n       + (double)agg * -0.510066\n       + 0.760666 * (double)lines_cleared\n       + -0.35663 * (double)holes;\n}\n"}, "pseudo_normalize": "double evaluate_board(int (*board)[10], int lines_cleared) {\n  int agg;\n  int holes;\n  int heights[10];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  get_column_heights(board, heights);\n  agg = aggregate_height(heights);\n  holes = count_holes(board);\n  return -0.184483 * (double)bumpiness(heights) + (double)agg * -0.510066 +\n         0.760666 * (double)lines_cleared + -0.35663 * (double)holes;\n}", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<evaluate_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x58(%rbp)\nmov    %esi,-0x5c(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x30(%rbp),%rdx\nmov    -0x58(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   14b2 <get_column_heights>\nlea    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   1554 <aggregate_height>\nmov    %eax,-0x44(%rbp)\nmov    -0x58(%rbp),%rax\nmov    %rax,%rdi\ncall   1598 <count_holes>\nmov    %eax,-0x40(%rbp)\nlea    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   161a <bumpiness>\nmov    %eax,-0x3c(%rbp)\npxor   %xmm1,%xmm1\ncvtsi2sdl -0x44(%rbp),%xmm1\nmovsd  0x3ce7(%rip),%xmm0\nmulsd  %xmm0,%xmm1\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x5c(%rbp),%xmm2\nmovsd  0x3cda(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm1\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x40(%rbp),%xmm2\nmovsd  0x3cc9(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm1\npxor   %xmm2,%xmm2\ncvtsi2sdl -0x3c(%rbp),%xmm2\nmovsd  0x3cb8(%rip),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  -0x38(%rbp),%xmm0\nmovq   %xmm0,%rax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     176b <evaluate_board+0xe5>\ncall   10b0 <__stack_chk_fail@plt>\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "get_column_heights", "content": "// ------------------------\n// Heuristic Evaluation Functions\n// ------------------------\n\n// Compute the height of each column.\nvoid get_column_heights(int board[BOARD_HEIGHT][BOARD_WIDTH], int heights[BOARD_WIDTH]) {\n    for (int x = 0; x < BOARD_WIDTH; x++) {\n        heights[x] = 0;\n        for (int y = 0; y < BOARD_HEIGHT; y++) {\n            if (board[y][x] != 0) {\n                heights[x] = BOARD_HEIGHT - y;\n                break;\n            }\n        }\n    }\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "get_column_heights", "address": "0x14b2", "label": "get_column_heights", "content": "void __cdecl get_column_heights(int (*board)[10], int *heights)\n{\n  int x; // [rsp+18h] [rbp-8h]\n  int y; // [rsp+1Ch] [rbp-4h]\n\n  for ( x = 0; x <= 9; ++x )\n  {\n    heights[x] = 0;\n    for ( y = 0; y <= 19; ++y )\n    {\n      if ( (*board)[10 * y + x] )\n      {\n        heights[x] = 20 - y;\n        break;\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void get_column_heights(int (*board)[10], int *heights) {\n  int x;\n  int y;\n  for (x = 0; x <= 9; ++x) {\n    heights[x] = 0;\n    for (y = 0; y <= 19; ++y) {\n      if ((*board)[10 * y + x]) {\n        heights[x] = 20 - y;\n        break;\n      }\n    }\n  }\n}", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<get_column_heights>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1546 <get_column_heights+0x94>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x0,(%rax)\nmovl   $0x0,-0x4(%rbp)\njmp    153c <get_column_heights+0x8a>\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\nje     1538 <get_column_heights+0x86>\nmov    -0x8(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rax,%rdx\nmov    $0x14,%eax\nsub    -0x4(%rbp),%eax\nmov    %eax,(%rdx)\njmp    1542 <get_column_heights+0x90>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x13,-0x4(%rbp)\njle    14ee <get_column_heights+0x3c>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x9,-0x8(%rbp)\njle    14cb <get_column_heights+0x19>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "main", "content": "// ------------------------\n// Main Simulation Loop\n// ------------------------\nint main(void) {\n    libmin_srand(42);\n    int board[BOARD_HEIGHT][BOARD_WIDTH];\n    create_board(board);\n    int move_count = 0;\n    int total_lines_cleared = 0;\n\n    while (1) {\n        const Piece *piece = random_piece();\n        const Orientation *best_ori;\n        int best_offset;\n        double best_score;\n        int new_board[BOARD_HEIGHT][BOARD_WIDTH];\n        int lines;\n        if (!best_move(board, piece, &best_ori, &best_offset, &best_score, new_board, &lines)) {\n            libmin_printf(\"Game over!\\n\");\n            break;\n        }\n        // Update board state.\n        libmin_memcpy(board, new_board, sizeof(board));\n        total_lines_cleared += lines;\n        move_count++;\n        // Print board every 10 moves.\n        if (move_count % 10 == 0) {\n            libmin_printf(\"After move %d, total lines cleared: %d, last move score: %f\\n\", move_count, total_lines_cleared, best_score);\n            print_board(board);\n        }\n    }\n    libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", move_count, total_lines_cleared);\n    print_board(board);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "main", "address": "0x1ba5", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int best_offset; // [rsp+8h] [rbp-678h] BYREF\n  int lines; // [rsp+Ch] [rbp-674h] BYREF\n  int move_count; // [rsp+10h] [rbp-670h]\n  int total_lines_cleared; // [rsp+14h] [rbp-66Ch]\n  const Orientation *best_ori; // [rsp+18h] [rbp-668h] BYREF\n  double best_score; // [rsp+20h] [rbp-660h] BYREF\n  const Piece *piece; // [rsp+28h] [rbp-658h]\n  int board[20][10]; // [rsp+30h] [rbp-650h] BYREF\n  int new_board[20][10]; // [rsp+350h] [rbp-330h] BYREF\n  unsigned __int64 v12; // [rsp+678h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  create_board(board);\n  move_count = 0;\n  total_lines_cleared = 0;\n  while ( 1 )\n  {\n    piece = random_piece();\n    if ( !best_move(board, piece, &best_ori, &best_offset, &best_score, new_board, &lines) )\n      break;\n    libmin_memcpy(board, new_board, 0x320uLL);\n    total_lines_cleared += lines;\n    if ( !(++move_count % 10) )\n    {\n      libmin_printf(\n        \"After move %d, total lines cleared: %d, last move score: %f\\n\",\n        move_count,\n        total_lines_cleared,\n        best_score);\n      print_board(board);\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", move_count, total_lines_cleared);\n  print_board(board);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int best_offset;\n  int lines;\n  int move_count;\n  int total_lines_cleared;\n  const Orientation *best_ori;\n  double best_score;\n  const Piece *piece;\n  int board[20][10];\n  int new_board[20][10];\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  libmin_srand(42u);\n  create_board(board);\n  move_count = 0;\n  total_lines_cleared = 0;\n  while (1) {\n    piece = random_piece();\n    if (!best_move(board, piece, &best_ori, &best_offset, &best_score,\n                   new_board, &lines))\n      break;\n    libmin_memcpy(board, new_board, 800uLL);\n    total_lines_cleared += lines;\n    if (!(++move_count % 10)) {\n      libmin_printf(\n          \"After move %d, total lines cleared: %d, last move score: %f\\n\",\n          move_count, total_lines_cleared, best_score);\n      print_board(board);\n    }\n  }\n  libmin_printf(\"Game over!\\n\");\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\",\n                move_count, total_lines_cleared);\n  print_board(board);\n  libmin_success();\n}", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x680,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmov    $0x2a,%edi\ncall   4134 <libmin_srand>\nlea    -0x650(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <create_board>\nmovl   $0x0,-0x670(%rbp)\nmovl   $0x0,-0x66c(%rbp)\nmov    $0x0,%eax\ncall   1b51 <random_piece>\nmov    %rax,-0x658(%rbp)\nlea    -0x330(%rbp),%r9\nlea    -0x660(%rbp),%r8\nlea    -0x678(%rbp),%rcx\nlea    -0x668(%rbp),%rdx\nmov    -0x658(%rbp),%rsi\nlea    -0x650(%rbp),%rax\nsub    $0x8,%rsp\nlea    -0x674(%rbp),%rdi\npush   %rdi\nmov    %rax,%rdi\ncall   1810 <best_move>\nadd    $0x10,%rsp\ntest   %eax,%eax\njne    1cae <main+0x109>\nlea    0x3707(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3f05 <libmin_printf>\nmov    -0x66c(%rbp),%edx\nmov    -0x670(%rbp),%eax\nmov    %eax,%esi\nlea    0x36f8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3f05 <libmin_printf>\nlea    -0x650(%rbp),%rax\nmov    %rax,%rdi\ncall   1aa4 <print_board>\ncall   449d <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1d5b <main+0x1b6>\njmp    1d56 <main+0x1b1>\nlea    -0x330(%rbp),%rcx\nlea    -0x650(%rbp),%rax\nmov    $0x320,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1eb6 <libmin_memcpy>\nmov    -0x674(%rbp),%eax\nadd    %eax,-0x66c(%rbp)\naddl   $0x1,-0x670(%rbp)\nmov    -0x670(%rbp),%ecx\nmovslq %ecx,%rax\nimul   $0x66666667,%rax,%rax\nshr    $0x20,%rax\nsar    $0x2,%eax\nmov    %ecx,%esi\nsar    $0x1f,%esi\nsub    %esi,%eax\nmov    %eax,%edx\nmov    %edx,%eax\nshl    $0x2,%eax\nadd    %edx,%eax\nadd    %eax,%eax\nsub    %eax,%ecx\nmov    %ecx,%edx\ntest   %edx,%edx\njne    1bf0 <main+0x4b>\nmov    -0x660(%rbp),%rcx\nmov    -0x66c(%rbp),%edx\nmov    -0x670(%rbp),%eax\nmovq   %rcx,%xmm0\nmov    %eax,%esi\nlea    0x366b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3f05 <libmin_printf>\nlea    -0x650(%rbp),%rax\nmov    %rax,%rdi\ncall   1aa4 <print_board>\njmp    1bf0 <main+0x4b>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "place_piece", "content": "// Place the piece on the board (modifies board)\nvoid place_piece(int board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int offset_y) {\n    for (int i = 0; i < ori->numBlocks; i++) {\n        int x = offset_x + ori->blocks[i].x;\n        int y = offset_y + ori->blocks[i].y;\n        board[y][x] = 1;\n    }\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "place_piece", "address": "0x1301", "label": "place_piece", "content": "void __cdecl place_piece(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  int i; // [rsp+1Ch] [rbp-Ch]\n\n  for ( i = 0; i < ori->numBlocks; ++i )\n    (*board)[10 * ori->blocks[i].y + 10 * offset_y + ori->blocks[i].x + offset_x] = 1;\n}\n"}, "pseudo_normalize": "void place_piece(int (*board)[10], const Orientation *ori, int offset_x,\n                 int offset_y) {\n  int i;\n  for (i = 0; i < ori->numBlocks; ++i)\n    (*board)[10 * ori->blocks[i].y + 10 * offset_y + ori->blocks[i].x +\n             offset_x] = 1;\n}", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<place_piece>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    %ecx,-0x28(%rbp)\nmovl   $0x0,-0xc(%rbp)\njmp    137a <place_piece+0x79>\nmov    -0x20(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    0x4(%rax,%rdx,8),%edx\nmov    -0x24(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x8(%rbp)\nmov    -0x20(%rbp),%rax\nmov    -0xc(%rbp),%edx\nmovslq %edx,%rdx\nmov    0x8(%rax,%rdx,8),%edx\nmov    -0x28(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%eax\ncltq\nmovl   $0x1,(%rdx,%rax,4)\naddl   $0x1,-0xc(%rbp)\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0xc(%rbp)\njl     1320 <place_piece+0x1f>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "print_board", "content": "// ------------------------\n// Board Display (text-based)\n// ------------------------\nvoid print_board(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    for (int y = 0; y < BOARD_HEIGHT; y++) {\n        for (int x = 0; x < BOARD_WIDTH; x++) {\n            libmin_printf(\"%c\", board[y][x] ? 'X' : '.');\n        }\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "print_board", "address": "0x1aa4", "label": "print_board", "content": "void __cdecl print_board(int (*board)[10])\n{\n  unsigned int v1; // eax\n  int y; // [rsp+18h] [rbp-8h]\n  int x; // [rsp+1Ch] [rbp-4h]\n\n  for ( y = 0; y <= 19; ++y )\n  {\n    for ( x = 0; x <= 9; ++x )\n    {\n      if ( (*board)[10 * y + x] )\n        v1 = 88;\n      else\n        v1 = 46;\n      libmin_printf(\"%c\", v1);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void print_board(int (*board)[10]) {\n  unsigned int v1;\n  int y;\n  int x;\n  for (y = 0; y <= 19; ++y) {\n    for (x = 0; x <= 9; ++x) {\n      if ((*board)[10 * y + x])\n        v1 = 88;\n      else\n        v1 = 46;\n      libmin_printf(\"%c\", v1);\n    }\n    libmin_printf(\"\\n\");\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<print_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmovl   $0x0,-0x8(%rbp)\njmp    1b34 <print_board+0x90>\nmovl   $0x0,-0x4(%rbp)\njmp    1b16 <print_board+0x72>\nmov    -0x8(%rbp),%eax\nmovslq %eax,%rdx\nmov    %rdx,%rax\nshl    $0x2,%rax\nadd    %rdx,%rax\nshl    $0x3,%rax\nmov    %rax,%rdx\nmov    -0x18(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x4(%rbp),%eax\ncltq\nmov    (%rdx,%rax,4),%eax\ntest   %eax,%eax\nje     1af7 <print_board+0x53>\nmov    $0x58,%eax\njmp    1afc <print_board+0x58>\nmov    $0x2e,%eax\nmov    %eax,%esi\nlea    0x384b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3f05 <libmin_printf>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x9,-0x4(%rbp)\njle    1ac6 <print_board+0x22>\nlea    0x3830(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3f05 <libmin_printf>\naddl   $0x1,-0x8(%rbp)\ncmpl   $0x13,-0x8(%rbp)\njle    1abd <print_board+0x19>\nlea    0x3812(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3f05 <libmin_printf>\nnop\nleave\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "random_piece", "content": "// ------------------------\n// Random Piece Selection\n// ------------------------\nconst Piece* random_piece() {\n    int index = libmin_rand() % NUM_PIECES;\n    return &pieces[index];\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "random_piece", "address": "0x1b51", "label": "random_piece", "content": "const Piece *__cdecl random_piece()\n{\n  return &pieces[libmin_rand() % 7];\n}\n"}, "pseudo_normalize": "", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<random_piece>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\ncall   41e6 <libmin_rand>\nmov    %eax,%ecx\nmov    %ecx,%eax\nimul   $0x24924925,%rax,%rax\nshr    $0x20,%rax\nmov    %rax,%rdx\nmov    %ecx,%eax\nsub    %edx,%eax\nshr    %eax\nadd    %edx,%eax\nshr    $0x2,%eax\nmov    %eax,%edx\nshl    $0x3,%edx\nsub    %eax,%edx\nmov    %ecx,%eax\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdx\nlea    0x6180(%rip),%rax\nadd    %rdx,%rax\nleave\nret\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "simulate_board", "content": "// ------------------------\n// Simulation: Try dropping a piece and evaluating the resulting board.\n// ------------------------\n\n// Simulate dropping the piece (of a given orientation) at horizontal offset 'offset_x'.\n// The result is written into sim_board, and the number of lines cleared is returned via lines_cleared.\n// Returns 1 if placement is valid, 0 otherwise.\nint simulate_board(int orig_board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int sim_board[BOARD_HEIGHT][BOARD_WIDTH], int *lines_cleared) {\n    libmin_memcpy(sim_board, orig_board, sizeof(int) * BOARD_HEIGHT * BOARD_WIDTH);\n    int y = 0;\n    // Drop the piece until a collision is detected.\n    while (!check_collision(sim_board, ori, offset_x, y))\n        y++;\n    y--;  // last valid position\n    if (y < 0)\n        return 0;\n    place_piece(sim_board, ori, offset_x, y);\n    *lines_cleared = clear_lines(sim_board);\n    return 1;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O0.pseudo", "function_name": "simulate_board", "address": "0x1772", "label": "simulate_board", "content": "int __cdecl simulate_board(\n        int (*orig_board)[10],\n        const Orientation *ori,\n        int offset_x,\n        int (*sim_board)[10],\n        int *lines_cleared)\n{\n  int y; // [rsp+3Ch] [rbp-4h]\n  int ya; // [rsp+3Ch] [rbp-4h]\n\n  libmin_memcpy(sim_board, orig_board, 0x320uLL);\n  for ( y = 0; !check_collision(sim_board, ori, offset_x, y); ++y )\n    ;\n  ya = y - 1;\n  if ( ya < 0 )\n    return 0;\n  place_piece(sim_board, ori, offset_x, ya);\n  *lines_cleared = clear_lines(sim_board);\n  return 1;\n}\n"}, "pseudo_normalize": "int simulate_board(int (*orig_board)[10], const Orientation *ori, int offset_x,\n                   int (*sim_board)[10], int *lines_cleared) {\n  int y;\n  int ya;\n  libmin_memcpy(sim_board, orig_board, 800uLL);\n  for (y = 0; !check_collision(sim_board, ori, offset_x, y); ++y)\n    ;\n  ya = y - 1;\n  if (ya < 0) return 0;\n  place_piece(sim_board, ori, offset_x, ya);\n  *lines_cleared = clear_lines(sim_board);\n  return 1;\n}", "binary": "tetris-sim/tetris-sim.host.O0", "assembly": "<simulate_board>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    %edx,-0x24(%rbp)\nmov    %rcx,-0x30(%rbp)\nmov    %r8,-0x38(%rbp)\nmov    -0x18(%rbp),%rcx\nmov    -0x30(%rbp),%rax\nmov    $0x320,%edx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1eb6 <libmin_memcpy>\nmovl   $0x0,-0x4(%rbp)\njmp    17b6 <simulate_board+0x44>\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%ecx\nmov    -0x24(%rbp),%edx\nmov    -0x20(%rbp),%rsi\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   1249 <check_collision>\ntest   %eax,%eax\nje     17b2 <simulate_board+0x40>\nsubl   $0x1,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njns    17e1 <simulate_board+0x6f>\nmov    $0x0,%eax\njmp    180e <simulate_board+0x9c>\nmov    -0x4(%rbp),%ecx\nmov    -0x24(%rbp),%edx\nmov    -0x20(%rbp),%rsi\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   1301 <place_piece>\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   1389 <clear_lines>\nmov    -0x38(%rbp),%rdx\nmov    %eax,(%rdx)\nmov    $0x1,%eax\nleave\nret\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "fillArrayNull", "content": "/*\n * fills the array with 0\n */\nvoid fillArrayNull(NETWORK_DATA_TYPE* array, unsigned int size)\n{\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tarray[i] = (NETWORK_DATA_TYPE)0;\n\t}\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O0.pseudo", "function_name": "fillArrayNull", "address": "0x1443", "label": "fillArrayNull", "content": "void __cdecl fillArrayNull(double *array, unsigned int size)\n{\n  unsigned int i; // [rsp+18h] [rbp-4h]\n\n  for ( i = 0; i < size; ++i )\n    array[i] = 0.0;\n}\n"}, "pseudo_normalize": "", "binary": "tiny-NN/tiny-NN.host.O0", "assembly": "<fillArrayNull>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1479 <fillArrayNull+0x36>\nmov    -0x4(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njb     145b <fillArrayNull+0x18>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "fillArrayRand", "content": "/*\n * fills the array with values from [-0.5,0.5]\n */\nvoid fillArrayRand(NETWORK_DATA_TYPE* array, unsigned int size)\n{\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tarray[i] = (NETWORK_DATA_TYPE)libmin_rand()/(NETWORK_DATA_TYPE)RAND_MAX - 0.5;\n\t}\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O0.pseudo", "function_name": "fillArrayRand", "address": "0x13b9", "label": "fillArrayRand", "content": "void __cdecl fillArrayRand(double *array, unsigned int size)\n{\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; i < size; ++i )\n    array[i] = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n}\n"}, "pseudo_normalize": "", "binary": "tiny-NN/tiny-NN.host.O0", "assembly": "<fillArrayRand>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmovl   $0x0,-0x4(%rbp)\njmp    1437 <fillArrayRand+0x7e>\ncall   416e <libmin_rand>\nmov    %eax,%eax\ntest   %rax,%rax\njs     13ec <fillArrayRand+0x33>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1405 <fillArrayRand+0x4c>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x5c3b(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmov    -0x4(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x5c25(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\naddl   $0x1,-0x4(%rbp)\nmov    -0x4(%rbp),%eax\ncmp    -0x1c(%rbp),%eax\njb     13d5 <fillArrayRand+0x1c>\nnop\nnop\nleave\nret\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "g", "content": "/*\n * the sigmoid function\n */\ninline NETWORK_DATA_TYPE g(NETWORK_DATA_TYPE a)\n{\n\treturn 1.0 / (1.0 + libmin_exp(-1.0*a));\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O0.pseudo", "function_name": "g", "address": "0x1255", "label": "g", "content": "double __cdecl g(double a)\n{\n  return 1.0 / (libmin_exp(-a) + 1.0);\n}\n"}, "pseudo_normalize": "", "binary": "tiny-NN/tiny-NN.host.O0", "assembly": "<g>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovq   0x5dbd(%rip),%xmm1\nxorpd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   1bc9 <libmin_exp>\nmovsd  0x5db2(%rip),%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x5da6(%rip),%xmm0\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "g_deriv", "content": "//flavor!\n//#define FANCY\n#define OUTPUT\n\n/*\n * the derivative of the sigmoid function\n */\ninline NETWORK_DATA_TYPE g_deriv(NETWORK_DATA_TYPE a)\n{\n\tNETWORK_DATA_TYPE sigmoid = 1.0 / (1.0 + libmin_exp(-1.0*a));\n\n\treturn sigmoid*(1.0-sigmoid);\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O0.pseudo", "function_name": "g_deriv", "address": "0x11e9", "label": "g_deriv", "content": "double __cdecl g_deriv(double a)\n{\n  double v1; // xmm0_8\n\n  v1 = libmin_exp(-a);\n  return (1.0 - 1.0 / (v1 + 1.0)) * (1.0 / (v1 + 1.0));\n}\n"}, "pseudo_normalize": "", "binary": "tiny-NN/tiny-NN.host.O0", "assembly": "<g_deriv>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovsd  %xmm0,-0x18(%rbp)\nmovsd  -0x18(%rbp),%xmm0\nmovq   0x5e29(%rip),%xmm1\nxorpd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   1bc9 <libmin_exp>\nmovsd  0x5e1e(%rip),%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x5e12(%rip),%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  0x5e01(%rip),%xmm0\nsubsd  -0x8(%rbp),%xmm0\nmulsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "main", "content": "int\nmain(void)\n{\n  libmin_srand(42);\n\ttrain(0.005, 0.01, 1.0, 0.4);\n\n\tlibmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O0.pseudo", "function_name": "main", "address": "0x1a1b", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  train(0.005, 0.01, 1.0, 0.4);\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "tiny-NN/tiny-NN.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x2a,%edi\ncall   40bc <libmin_srand>\nmovsd  0x5633(%rip),%xmm2\nmovsd  0x5603(%rip),%xmm1\nmovsd  0x562b(%rip),%xmm0\nmov    0x562c(%rip),%rax\nmovapd %xmm2,%xmm3\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\ncall   1485 <train>\ncall   4ae1 <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "sampleSine", "content": "/*\n * samples the sin function from 'start' to 'end' with 'size' equidistant steps\n */\nvoid sampleSine(NETWORK_DATA_TYPE* input, NETWORK_DATA_TYPE* output, NETWORK_DATA_TYPE start, NETWORK_DATA_TYPE end, unsigned int size)\n{\n\tNETWORK_DATA_TYPE step = (end-start)/(NETWORK_DATA_TYPE)size;\n\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tinput[i] = start + step * (NETWORK_DATA_TYPE)i;\n\t\toutput[i] = libmin_sin(input[i]);\n\t}\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O0.pseudo", "function_name": "sampleSine", "address": "0x12aa", "label": "sampleSine", "content": "void __cdecl sampleSine(double *input, double *output, double start, double end, unsigned int size)\n{\n  int i; // [rsp+34h] [rbp-1Ch]\n  double step; // [rsp+38h] [rbp-18h]\n\n  step = (end - start) / (double)(int)size;\n  for ( i = 0; i < size; ++i )\n  {\n    input[i] = (double)i * step + start;\n    output[i] = libmin_sin(input[i]);\n  }\n}\n"}, "pseudo_normalize": "void sampleSine(double *input, double *output, double start, double end,\n                unsigned int size) {\n  int i;\n  double step;\n  step = (end - start) / (double)(int)size;\n  for (i = 0; i < size; ++i) {\n    input[i] = (double)i * step + start;\n    output[i] = libmin_sin(input[i]);\n  }\n}", "binary": "tiny-NN/tiny-NN.host.O0", "assembly": "<sampleSine>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  %xmm1,-0x40(%rbp)\nmov    %edx,-0x44(%rbp)\nmovsd  -0x40(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nsubsd  -0x38(%rbp),%xmm1\nmov    -0x44(%rbp),%eax\ntest   %rax,%rax\njs     12ed <sampleSine+0x43>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1306 <sampleSine+0x5c>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,-0x18(%rbp)\nmovl   $0x0,-0x1c(%rbp)\njmp    13a5 <sampleSine+0xfb>\nmov    -0x1c(%rbp),%eax\ntest   %rax,%rax\njs     132e <sampleSine+0x84>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1347 <sampleSine+0x9d>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmulsd  -0x18(%rbp),%xmm0\nmov    -0x1c(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\naddsd  -0x38(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmov    -0x1c(%rbp),%eax\nlea    0x0(,%rax,8),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    -0x1c(%rbp),%edx\nlea    0x0(,%rdx,8),%rcx\nmov    -0x30(%rbp),%rdx\nlea    (%rcx,%rdx,1),%rbx\nmovq   %rax,%xmm0\ncall   48f3 <libmin_sin>\nmovq   %xmm0,%rax\nmov    %rax,(%rbx)\naddl   $0x1,-0x1c(%rbp)\nmov    -0x1c(%rbp),%eax\ncmp    -0x44(%rbp),%eax\njb     131b <sampleSine+0x71>\nnop\nnop\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "train", "content": "int train(NETWORK_DATA_TYPE eta, NETWORK_DATA_TYPE error_threshold, NETWORK_DATA_TYPE bias, NETWORK_DATA_TYPE alpha)\n{\n\n\tNETWORK_DATA_TYPE total_error = error_threshold + 1.0;//why?\n\n\t//data\n\tNETWORK_DATA_TYPE input[SAMPLE_COUNT];\n\tNETWORK_DATA_TYPE output[SAMPLE_COUNT];\n\n\t//NN container for NEURON_COUNT neurons\n\tNETWORK_DATA_TYPE NN_output = 0;\n\tNETWORK_DATA_TYPE weights_layer0_1[NEURON_COUNT*2]; //don't forget the bias :-) {PSSSTT: format = [input_w, bias_w, input_w, bias_w...]}\n\tNETWORK_DATA_TYPE weights_layer1_2[NEURON_COUNT];\n\n\tNETWORK_DATA_TYPE delta_weights_layer0_1[NEURON_COUNT*2]; //don't forget the bias :-) {PSSSTT: format = [input_w, bias_w, input_w, bias_w...]}\n\tNETWORK_DATA_TYPE delta_weights_layer1_2[NEURON_COUNT];\n\n\tNETWORK_DATA_TYPE delta_layer_2, delta_layer_1;\n\tNETWORK_DATA_TYPE a;\n\tNETWORK_DATA_TYPE g_layer_1[NEURON_COUNT];\n\tNETWORK_DATA_TYPE g_deriv_layer_1[NEURON_COUNT];\n\tNETWORK_DATA_TYPE delta_w_layer_2_1;\n\tNETWORK_DATA_TYPE delta_w_layer_1_0;\n\n\t//init the network\n\tfillArrayRand(weights_layer0_1,NEURON_COUNT*2);//random values for the weight 0->1\n\tfillArrayRand(weights_layer1_2,NEURON_COUNT);//random values for the weights 1->2\n\n\tfillArrayNull(delta_weights_layer0_1,NEURON_COUNT*2);\n\tfillArrayNull(delta_weights_layer1_2,NEURON_COUNT);\n\n\t//create the training data\n\tsampleSine(input, output, 0, 3.14, SAMPLE_COUNT);\n\n\t//train the network\n\tunsigned int iteration_count = 0;\n\n\twhile(total_error > error_threshold && iteration_count < MAX_ITERATIONS)\n\t{\n\t\ttotal_error = 0;//hmmm....\n\n\t\t//present the data to the NN\n\t\tunsigned int i;\n\t\tfor(i=0; i<SAMPLE_COUNT; ++i)\n\t\t{\n\t\t\t//propagate the sample forward\n\t\t\t//layer 0 -> 1 ... and layer 1->2\n\t\t\tunsigned int j;\n\t\t\tfor(j=0; j<NEURON_COUNT; ++j)\n\t\t\t{\n\t\t\t\ta = input[i] * weights_layer0_1[2*j] + bias * weights_layer0_1[2*j+1];\n\t\t\t\tg_layer_1[j] = g(a);\n\t\t\t\tg_deriv_layer_1[j] = g_deriv(a);\n\n\t\t\t\tNN_output += weights_layer1_2[j] * g_layer_1[j];\n\t\t\t}\n\n\t\t\t//calculate the errors\n\t\t\tdelta_layer_2 = NN_output - output[i];\n\t\t\ttotal_error += delta_layer_2*delta_layer_2;\n\n\t\t\t//backpropagate the deltas\n\t\t\t//layer 2->1 ... and 1->0\n\t\t\tfor(j=0; j<NEURON_COUNT; ++j)\n\t\t\t{\n\t\t\t\tdelta_layer_1 = g_deriv_layer_1[j] * weights_layer1_2[j] * delta_layer_2;\n\t\t\t\tdelta_w_layer_2_1 = delta_layer_2 * g_layer_1[j];\n\n\t\t\t\t//?\n\t\t\t\tweights_layer1_2[j] -= delta_w_layer_2_1 * eta + alpha*delta_weights_layer1_2[j] ;\n\t\t\t\tdelta_weights_layer1_2[j] = delta_w_layer_2_1 * eta + alpha*delta_weights_layer1_2[j] ;\n\n\t\t\t\tdelta_w_layer_1_0 = delta_layer_1 * input[i];\n\t\t\t\tweights_layer0_1[2*j] -= delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j];\n\t\t\t\tdelta_weights_layer0_1[2*j] = delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j];\n\n\t\t\t\tdelta_w_layer_1_0 = delta_layer_1 * bias;\n\t\t\t\tweights_layer0_1[2*j+1] -= delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j+1];\n\t\t\t\tdelta_weights_layer0_1[2*j+1] = delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j+1];\n\t\t\t}\n\n\t\t\t//update the weights (uppsi, did it already... but how?)\n\t\t\t#ifdef FANCY\n\t\t\tlibmin_printf(\"sample error %f, should %f is %f\\n\",delta_layer_2,output[i], NN_output);\n\t\t\t#endif\n\n\t\t\t//prepare for the next nerve wrecking round\n\t\t\tNN_output = 0;\n\t\t}\n\n\t\t#ifdef FANCY\n\t\tlibmin_printf(\"Total error %f\\n\\n\",total_error);\n\t\t#endif\n\n\t\t++iteration_count;\n\n\t\tfillArrayNull(delta_weights_layer0_1,NEURON_COUNT*2);\n\t\tfillArrayNull(delta_weights_layer1_2,NEURON_COUNT);\n\n\t\t#ifdef OUTPUT\n\t\tlibmin_printf(\"iteration %d Total error %f\\n\",iteration_count,total_error);\n\t\t#endif\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O0.pseudo", "function_name": "train", "address": "0x1485", "label": "train", "content": "int __cdecl train(double eta, double error_threshold, double bias, double alpha)\n{\n  unsigned int iteration_count; // [rsp+2Ch] [rbp-694h]\n  unsigned int i; // [rsp+30h] [rbp-690h]\n  unsigned int j; // [rsp+34h] [rbp-68Ch]\n  unsigned int ja; // [rsp+34h] [rbp-68Ch]\n  double total_error; // [rsp+38h] [rbp-688h]\n  double NN_output; // [rsp+40h] [rbp-680h]\n  double delta_layer_2; // [rsp+48h] [rbp-678h]\n  double delta_layer_1; // [rsp+50h] [rbp-670h]\n  double delta_w_layer_2_1; // [rsp+58h] [rbp-668h]\n  double delta_w_layer_1_0; // [rsp+60h] [rbp-660h]\n  double a; // [rsp+68h] [rbp-658h]\n  double input[20]; // [rsp+70h] [rbp-650h] BYREF\n  double output[20]; // [rsp+110h] [rbp-5B0h] BYREF\n  double weights_layer1_2[20]; // [rsp+1B0h] [rbp-510h] BYREF\n  double delta_weights_layer1_2[20]; // [rsp+250h] [rbp-470h] BYREF\n  double g_layer_1[20]; // [rsp+2F0h] [rbp-3D0h]\n  double g_deriv_layer_1[20]; // [rsp+390h] [rbp-330h]\n  double weights_layer0_1[40]; // [rsp+430h] [rbp-290h] BYREF\n  double delta_weights_layer0_1[42]; // [rsp+570h] [rbp-150h] BYREF\n\n  *(_QWORD *)&delta_weights_layer0_1[41] = __readfsqword(0x28u);\n  total_error = error_threshold + 1.0;\n  NN_output = 0.0;\n  fillArrayRand(weights_layer0_1, 0x28u);\n  fillArrayRand(weights_layer1_2, 0x14u);\n  fillArrayNull(delta_weights_layer0_1, 0x28u);\n  fillArrayNull(delta_weights_layer1_2, 0x14u);\n  sampleSine(input, output, 0.0, 3.14, 0x14u);\n  for ( iteration_count = 0;\n        total_error > error_threshold && iteration_count <= 9;\n        libmin_printf(\"iteration %d Total error %f\\n\", iteration_count, total_error) )\n  {\n    total_error = 0.0;\n    for ( i = 0; i <= 0x13; ++i )\n    {\n      for ( j = 0; j <= 0x13; ++j )\n      {\n        a = weights_layer0_1[2 * j + 1] * bias + input[i] * weights_layer0_1[2 * j];\n        g_layer_1[j] = g(a);\n        g_deriv_layer_1[j] = g_deriv(a);\n        NN_output = g_layer_1[j] * weights_layer1_2[j] + NN_output;\n      }\n      delta_layer_2 = NN_output - output[i];\n      total_error = delta_layer_2 * delta_layer_2 + total_error;\n      for ( ja = 0; ja <= 0x13; ++ja )\n      {\n        delta_layer_1 = weights_layer1_2[ja] * g_deriv_layer_1[ja] * delta_layer_2;\n        delta_w_layer_2_1 = g_layer_1[ja] * delta_layer_2;\n        weights_layer1_2[ja] = weights_layer1_2[ja] - (delta_weights_layer1_2[ja] * alpha + delta_w_layer_2_1 * eta);\n        delta_weights_layer1_2[ja] = delta_weights_layer1_2[ja] * alpha + delta_w_layer_2_1 * eta;\n        delta_w_layer_1_0 = input[i] * delta_layer_1;\n        weights_layer0_1[2 * ja] = weights_layer0_1[2 * ja]\n                                 - (delta_weights_layer0_1[2 * ja] * alpha\n                                  + delta_w_layer_1_0 * eta);\n        delta_weights_layer0_1[2 * ja] = delta_weights_layer0_1[2 * ja] * alpha + delta_w_layer_1_0 * eta;\n        weights_layer0_1[2 * ja + 1] = weights_layer0_1[2 * ja + 1]\n                                     - (delta_weights_layer0_1[2 * ja + 1] * alpha\n                                      + delta_layer_1 * bias * eta);\n        delta_weights_layer0_1[2 * ja + 1] = delta_weights_layer0_1[2 * ja + 1] * alpha + delta_layer_1 * bias * eta;\n      }\n      NN_output = 0.0;\n    }\n    ++iteration_count;\n    fillArrayNull(delta_weights_layer0_1, 0x28u);\n    fillArrayNull(delta_weights_layer1_2, 0x14u);\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int train(double eta, double error_threshold, double bias, double alpha) {\n  unsigned int iteration_count;\n  unsigned int i;\n  unsigned int j;\n  unsigned int ja;\n  double total_error;\n  double NN_output;\n  double delta_layer_2;\n  double delta_layer_1;\n  double delta_w_layer_2_1;\n  double delta_w_layer_1_0;\n  double a;\n  double input[20];\n  double output[20];\n  double weights_layer1_2[20];\n  double delta_weights_layer1_2[20];\n  double g_layer_1[20];\n  double g_deriv_layer_1[20];\n  double weights_layer0_1[40];\n  double delta_weights_layer0_1[42];\n  *(uint64_t *)&delta_weights_layer0_1[41] = __readfsqword(40u);\n  total_error = error_threshold + 1.0;\n  NN_output = 0.0;\n  fillArrayRand(weights_layer0_1, 40u);\n  fillArrayRand(weights_layer1_2, 20u);\n  fillArrayNull(delta_weights_layer0_1, 40u);\n  fillArrayNull(delta_weights_layer1_2, 20u);\n  sampleSine(input, output, 0.0, 3.14, 20u);\n  for (iteration_count = 0;\n       total_error > error_threshold && iteration_count <= 9; libmin_printf(\n           \"iteration %d Total error %f\\n\", iteration_count, total_error)) {\n    total_error = 0.0;\n    for (i = 0; i <= 19; ++i) {\n      for (j = 0; j <= 19; ++j) {\n        a = weights_layer0_1[2 * j + 1] * bias +\n            input[i] * weights_layer0_1[2 * j];\n        g_layer_1[j] = g(a);\n        g_deriv_layer_1[j] = g_deriv(a);\n        NN_output = g_layer_1[j] * weights_layer1_2[j] + NN_output;\n      }\n      delta_layer_2 = NN_output - output[i];\n      total_error = delta_layer_2 * delta_layer_2 + total_error;\n      for (ja = 0; ja <= 19; ++ja) {\n        delta_layer_1 =\n            weights_layer1_2[ja] * g_deriv_layer_1[ja] * delta_layer_2;\n        delta_w_layer_2_1 = g_layer_1[ja] * delta_layer_2;\n        weights_layer1_2[ja] =\n            weights_layer1_2[ja] -\n            (delta_weights_layer1_2[ja] * alpha + delta_w_layer_2_1 * eta);\n        delta_weights_layer1_2[ja] =\n            delta_weights_layer1_2[ja] * alpha + delta_w_layer_2_1 * eta;\n        delta_w_layer_1_0 = input[i] * delta_layer_1;\n        weights_layer0_1[2 * ja] =\n            weights_layer0_1[2 * ja] -\n            (delta_weights_layer0_1[2 * ja] * alpha + delta_w_layer_1_0 * eta);\n        delta_weights_layer0_1[2 * ja] =\n            delta_weights_layer0_1[2 * ja] * alpha + delta_w_layer_1_0 * eta;\n        weights_layer0_1[2 * ja + 1] =\n            weights_layer0_1[2 * ja + 1] -\n            (delta_weights_layer0_1[2 * ja + 1] * alpha +\n             delta_layer_1 * bias * eta);\n        delta_weights_layer0_1[2 * ja + 1] =\n            delta_weights_layer0_1[2 * ja + 1] * alpha +\n            delta_layer_1 * bias * eta;\n      }\n      NN_output = 0.0;\n    }\n    ++iteration_count;\n    fillArrayNull(delta_weights_layer0_1, 40u);\n    fillArrayNull(delta_weights_layer1_2, 20u);\n  }\n  return 0;\n}", "binary": "tiny-NN/tiny-NN.host.O0", "assembly": "<train>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x6c0,%rsp\nmovsd  %xmm0,-0x6a8(%rbp)\nmovsd  %xmm1,-0x6b0(%rbp)\nmovsd  %xmm2,-0x6b8(%rbp)\nmovsd  %xmm3,-0x6c0(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovsd  -0x6b0(%rbp),%xmm1\nmovsd  0x5b6d(%rip),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x688(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x680(%rbp)\nlea    -0x290(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   13b9 <fillArrayRand>\nlea    -0x510(%rbp),%rax\nmov    $0x14,%esi\nmov    %rax,%rdi\ncall   13b9 <fillArrayRand>\nlea    -0x150(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   1443 <fillArrayNull>\nlea    -0x470(%rbp),%rax\nmov    $0x14,%esi\nmov    %rax,%rdi\ncall   1443 <fillArrayNull>\nmovsd  0x5b1d(%rip),%xmm0\nlea    -0x5b0(%rbp),%rcx\nlea    -0x650(%rbp),%rax\nmov    $0x14,%edx\nmovapd %xmm0,%xmm1\nmov    0x5af7(%rip),%rsi\nmovq   %rsi,%xmm0\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   12aa <sampleSine>\nmovl   $0x0,-0x694(%rbp)\njmp    19e1 <train+0x55c>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x688(%rbp)\nmovl   $0x0,-0x690(%rbp)\njmp    197d <train+0x4f8>\nmovl   $0x0,-0x68c(%rbp)\njmp    167f <train+0x1fa>\nmov    -0x690(%rbp),%eax\nmovsd  -0x650(%rbp,%rax,8),%xmm1\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,%eax\nmovsd  -0x290(%rbp,%rax,8),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nmovsd  -0x290(%rbp,%rax,8),%xmm0\nmulsd  -0x6b8(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x658(%rbp)\nmov    -0x658(%rbp),%rax\nmovq   %rax,%xmm0\ncall   1255 <g>\nmovq   %xmm0,%rax\nmov    -0x68c(%rbp),%edx\nmov    %rax,-0x3d0(%rbp,%rdx,8)\nmov    -0x658(%rbp),%rax\nmovq   %rax,%xmm0\ncall   11e9 <g_deriv>\nmovq   %xmm0,%rax\nmov    -0x68c(%rbp),%edx\nmov    %rax,-0x330(%rbp,%rdx,8)\nmov    -0x68c(%rbp),%eax\nmovsd  -0x510(%rbp,%rax,8),%xmm1\nmov    -0x68c(%rbp),%eax\nmovsd  -0x3d0(%rbp,%rax,8),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x680(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x680(%rbp)\naddl   $0x1,-0x68c(%rbp)\ncmpl   $0x13,-0x68c(%rbp)\njbe    15aa <train+0x125>\nmov    -0x690(%rbp),%eax\nmovsd  -0x5b0(%rbp,%rax,8),%xmm1\nmovsd  -0x680(%rbp),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x678(%rbp)\nmovsd  -0x678(%rbp),%xmm0\nmulsd  %xmm0,%xmm0\nmovsd  -0x688(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x688(%rbp)\nmovl   $0x0,-0x68c(%rbp)\njmp    195d <train+0x4d8>\nmov    -0x68c(%rbp),%eax\nmovsd  -0x330(%rbp,%rax,8),%xmm1\nmov    -0x68c(%rbp),%eax\nmovsd  -0x510(%rbp,%rax,8),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x678(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x670(%rbp)\nmov    -0x68c(%rbp),%eax\nmovsd  -0x3d0(%rbp,%rax,8),%xmm0\nmovsd  -0x678(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x668(%rbp)\nmov    -0x68c(%rbp),%eax\nmovsd  -0x510(%rbp,%rax,8),%xmm0\nmovsd  -0x668(%rbp),%xmm1\nmovapd %xmm1,%xmm2\nmulsd  -0x6a8(%rbp),%xmm2\nmov    -0x68c(%rbp),%eax\nmovsd  -0x470(%rbp,%rax,8),%xmm1\nmulsd  -0x6c0(%rbp),%xmm1\naddsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmov    -0x68c(%rbp),%eax\nmovsd  %xmm0,-0x510(%rbp,%rax,8)\nmovsd  -0x668(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x6a8(%rbp),%xmm1\nmov    -0x68c(%rbp),%eax\nmovsd  -0x470(%rbp,%rax,8),%xmm0\nmulsd  -0x6c0(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x68c(%rbp),%eax\nmovsd  %xmm0,-0x470(%rbp,%rax,8)\nmov    -0x690(%rbp),%eax\nmovsd  -0x650(%rbp,%rax,8),%xmm0\nmovsd  -0x670(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x660(%rbp)\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,%eax\nmovsd  -0x290(%rbp,%rax,8),%xmm0\nmovsd  -0x660(%rbp),%xmm1\nmovapd %xmm1,%xmm2\nmulsd  -0x6a8(%rbp),%xmm2\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,%eax\nmovsd  -0x150(%rbp,%rax,8),%xmm1\nmulsd  -0x6c0(%rbp),%xmm1\naddsd  %xmm2,%xmm1\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nsubsd  %xmm1,%xmm0\nmov    %eax,%eax\nmovsd  %xmm0,-0x290(%rbp,%rax,8)\nmovsd  -0x660(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x6a8(%rbp),%xmm1\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nmov    %eax,%eax\nmovsd  -0x150(%rbp,%rax,8),%xmm0\nmulsd  -0x6c0(%rbp),%xmm0\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\naddsd  %xmm1,%xmm0\nmov    %eax,%eax\nmovsd  %xmm0,-0x150(%rbp,%rax,8)\nmovsd  -0x670(%rbp),%xmm0\nmulsd  -0x6b8(%rbp),%xmm0\nmovsd  %xmm0,-0x660(%rbp)\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nmovsd  -0x290(%rbp,%rax,8),%xmm0\nmovsd  -0x660(%rbp),%xmm1\nmovapd %xmm1,%xmm2\nmulsd  -0x6a8(%rbp),%xmm2\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nmovsd  -0x150(%rbp,%rax,8),%xmm1\nmulsd  -0x6c0(%rbp),%xmm1\naddsd  %xmm2,%xmm1\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nsubsd  %xmm1,%xmm0\nmov    %eax,%eax\nmovsd  %xmm0,-0x290(%rbp,%rax,8)\nmovsd  -0x660(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x6a8(%rbp),%xmm1\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\nmov    %eax,%eax\nmovsd  -0x150(%rbp,%rax,8),%xmm0\nmulsd  -0x6c0(%rbp),%xmm0\nmov    -0x68c(%rbp),%eax\nadd    %eax,%eax\nadd    $0x1,%eax\naddsd  %xmm1,%xmm0\nmov    %eax,%eax\nmovsd  %xmm0,-0x150(%rbp,%rax,8)\naddl   $0x1,-0x68c(%rbp)\ncmpl   $0x13,-0x68c(%rbp)\njbe    16de <train+0x259>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x680(%rbp)\naddl   $0x1,-0x690(%rbp)\ncmpl   $0x13,-0x690(%rbp)\njbe    159b <train+0x116>\naddl   $0x1,-0x694(%rbp)\nlea    -0x150(%rbp),%rax\nmov    $0x28,%esi\nmov    %rax,%rdi\ncall   1443 <fillArrayNull>\nlea    -0x470(%rbp),%rax\nmov    $0x14,%esi\nmov    %rax,%rdi\ncall   1443 <fillArrayNull>\nmov    -0x688(%rbp),%rdx\nmov    -0x694(%rbp),%eax\nmovq   %rdx,%xmm0\nmov    %eax,%esi\nlea    0x563c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   3e8d <libmin_printf>\nmovsd  -0x688(%rbp),%xmm0\ncomisd -0x6b0(%rbp),%xmm0\njbe    1a00 <train+0x57b>\ncmpl   $0x9,-0x694(%rbp)\njbe    1580 <train+0xfb>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1a19 <train+0x594>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "addEdge", "content": " \n  \n// Function to add an edge to the graph \nvoid\naddEdge(struct Graph* graph, int v, int w) \n{ \n  struct List* newNode = createListNode(w); \n  newNode->next = graph->adj[v].next; \n  graph->adj[v].next = newNode; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O0.pseudo", "function_name": "addEdge", "address": "0x12cf", "label": "addEdge", "content": "void __cdecl addEdge(Graph *graph, int v, int w)\n{\n  List *newNode; // [rsp+18h] [rbp-8h]\n\n  newNode = createListNode(w);\n  newNode->next = graph->adj[v].next;\n  graph->adj[v].next = newNode;\n}\n"}, "pseudo_normalize": "void addEdge(Graph *graph, int v, int w) {\n  List *newNode;\n  newNode = createListNode(w);\n  newNode->next = graph->adj[v].next;\n  graph->adj[v].next = newNode;\n}", "binary": "topo-sort/topo-sort.host.O0", "assembly": "<addEdge>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %esi,-0x1c(%rbp)\nmov    %edx,-0x20(%rbp)\nmov    -0x20(%rbp),%eax\nmov    %eax,%edi\ncall   1221 <createListNode>\nmov    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rdx,%rax\nmov    0x8(%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x18(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x1c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rax,%rdx\nmov    -0x8(%rbp),%rax\nmov    %rax,0x8(%rdx)\nnop\nleave\nret\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "createGraph", "content": " \n  \n// Function to initialize a graph with V vertices \nstruct Graph *\ncreateGraph(int V) \n{ \n  struct Graph* graph = (struct Graph*)libmin_malloc(sizeof(struct Graph)); \n  graph->V = V; \n  graph->adj = (struct List*)libmin_malloc(V * sizeof(struct List)); \n  for (int i = 0; i < V; ++i)\n    graph->adj[i].next = NULL; \n  return graph; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O0.pseudo", "function_name": "createGraph", "address": "0x1259", "label": "createGraph", "content": "Graph *__cdecl createGraph(int V)\n{\n  int i; // [rsp+14h] [rbp-Ch]\n  Graph *graph; // [rsp+18h] [rbp-8h]\n\n  graph = (Graph *)libmin_malloc(0x10uLL);\n  graph->V = V;\n  graph->adj = (List *)libmin_malloc(16LL * V);\n  for ( i = 0; i < V; ++i )\n    graph->adj[i].next = 0LL;\n  return graph;\n}\n"}, "pseudo_normalize": "Graph *createGraph(int V) {\n  int i;\n  Graph *graph;\n  graph = (Graph *)libmin_malloc(16uLL);\n  graph->V = V;\n  graph->adj = (List *)libmin_malloc(16LL * V);\n  for (i = 0; i < V; ++i) graph->adj[i].next = 0LL;\n  return graph;\n}", "binary": "topo-sort/topo-sort.host.O0", "assembly": "<createGraph>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x10,%edi\ncall   17ae <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x14(%rbp),%eax\ncltq\nshl    $0x4,%rax\nmov    %rax,%rdi\ncall   17ae <libmin_malloc>\nmov    -0x8(%rbp),%rdx\nmov    %rax,0x8(%rdx)\nmovl   $0x0,-0xc(%rbp)\njmp    12c1 <createGraph+0x68>\nmov    -0x8(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0xc(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rdx,%rax\nmovq   $0x0,0x8(%rax)\naddl   $0x1,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njl     12a1 <createGraph+0x48>\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "createListNode", "content": " \n  \n// Create a new node for the adjacency list \nstruct List *\ncreateListNode(int data) \n{ \n  struct List* newNode = (struct List*)libmin_malloc(sizeof(struct List)); \n  newNode->data = data; \n  newNode->next = NULL; \n  return newNode; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O0.pseudo", "function_name": "createListNode", "address": "0x1221", "label": "createListNode", "content": "List *__cdecl createListNode(int data)\n{\n  List *result; // rax\n\n  result = (List *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "List *createListNode(int data) {\n  List *result;\n  result = (List *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}", "binary": "topo-sort/topo-sort.host.O0", "assembly": "<createListNode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x10,%edi\ncall   17ae <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "createStackNode", "content": " \n  \n// Create a new node for the stack \nstruct Stack *\ncreateStackNode(int data) \n{ \n  struct Stack* newNode = (struct Stack*)libmin_malloc(sizeof(struct Stack)); \n  newNode->data = data; \n  newNode->next = NULL; \n  return newNode; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O0.pseudo", "function_name": "createStackNode", "address": "0x11e9", "label": "createStackNode", "content": "Stack *__cdecl createStackNode(int data)\n{\n  Stack *result; // rax\n\n  result = (Stack *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "Stack *createStackNode(int data) {\n  Stack *result;\n  result = (Stack *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}", "binary": "topo-sort/topo-sort.host.O0", "assembly": "<createStackNode>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    $0x10,%edi\ncall   17ae <libmin_malloc>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    -0x14(%rbp),%edx\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nmovq   $0x0,0x8(%rax)\nmov    -0x8(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "main", "content": " \n  \n// Driver program to test above functions \nint\nmain(void) \n{ \n  // Create a graph given in the above diagram \n  struct Graph* g = createGraph(6); \n  addEdge(g, 5, 2); \n  addEdge(g, 5, 0); \n  addEdge(g, 4, 0); \n  addEdge(g, 4, 1); \n  addEdge(g, 2, 3); \n  addEdge(g, 3, 1); \n  \n  libmin_printf(\"Topological Sorting Order: \"); \n  topologicalSort(g); \n  libmin_printf(\"\\n\");\n  \n  libmin_success();\n  return 0; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O0.pseudo", "function_name": "main", "address": "0x153d", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Graph *g; // [rsp+8h] [rbp-8h]\n\n  g = createGraph(6);\n  addEdge(g, 5, 2);\n  addEdge(g, 5, 0);\n  addEdge(g, 4, 0);\n  addEdge(g, 4, 1);\n  addEdge(g, 2, 3);\n  addEdge(g, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(g);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  Graph *g;\n  g = createGraph(6);\n  addEdge(g, 5, 2);\n  addEdge(g, 5, 0);\n  addEdge(g, 4, 0);\n  addEdge(g, 4, 1);\n  addEdge(g, 2, 3);\n  addEdge(g, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(g);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}", "binary": "topo-sort/topo-sort.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    $0x6,%edi\ncall   1259 <createGraph>\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    $0x2,%edx\nmov    $0x5,%esi\nmov    %rax,%rdi\ncall   12cf <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x0,%edx\nmov    $0x5,%esi\nmov    %rax,%rdi\ncall   12cf <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x0,%edx\nmov    $0x4,%esi\nmov    %rax,%rdi\ncall   12cf <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x1,%edx\nmov    $0x4,%esi\nmov    %rax,%rdi\ncall   12cf <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x3,%edx\nmov    $0x2,%esi\nmov    %rax,%rdi\ncall   12cf <addEdge>\nmov    -0x8(%rbp),%rax\nmov    $0x1,%edx\nmov    $0x3,%esi\nmov    %rax,%rdi\ncall   12cf <addEdge>\nlea    0x2a26(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c10 <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   13fd <topologicalSort>\nlea    0x2a22(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c10 <libmin_printf>\ncall   3e7d <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "topologicalSort", "content": " \n  \n// The function to do Topological Sort. It uses recursive \n// topologicalSortUtil \nvoid topologicalSort(struct Graph* graph) \n{ \n    struct Stack* stack = NULL; \n  \n    // Mark all the vertices as not visited \n    int* visited = (int*)libmin_malloc(graph->V * sizeof(int)); \n    for (int i = 0; i < graph->V; ++i) { \n        visited[i] = FALSE; \n    } \n  \n    // Call the recursive helper function to store \n    // Topological Sort starting from all vertices one by \n    // one \n    for (int i = 0; i < graph->V; ++i) { \n        if (!visited[i]) { \n            topologicalSortUtil(graph, i, visited, &stack); \n        } \n    } \n  \n    // Print contents of stack \n    while (stack != NULL) { \n        libmin_printf(\"%d \", stack->data); \n        struct Stack* temp = stack; \n        stack = stack->next; \n        libmin_free(temp); \n    } \n  \n    // Free allocated memory \n    libmin_free(visited); \n    libmin_free(graph->adj); \n    libmin_free(graph); \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O0.pseudo", "function_name": "topologicalSort", "address": "0x13fd", "label": "topologicalSort", "content": "void __cdecl topologicalSort(Graph *graph)\n{\n  int i; // [rsp+18h] [rbp-28h]\n  int i_0; // [rsp+1Ch] [rbp-24h]\n  Stack *stack; // [rsp+20h] [rbp-20h] BYREF\n  int *visited; // [rsp+28h] [rbp-18h]\n  Stack *temp; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v6; // [rsp+38h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  stack = 0LL;\n  visited = (int *)libmin_malloc(4LL * graph->V);\n  for ( i = 0; i < graph->V; ++i )\n    visited[i] = 0;\n  for ( i_0 = 0; i_0 < graph->V; ++i_0 )\n  {\n    if ( !visited[i_0] )\n      topologicalSortUtil(graph, i_0, visited, &stack);\n  }\n  while ( stack )\n  {\n    libmin_printf(\"%d \", stack->data);\n    temp = stack;\n    stack = stack->next;\n    libmin_free(temp);\n  }\n  libmin_free(visited);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}\n"}, "pseudo_normalize": "void topologicalSort(Graph *graph) {\n  int i;\n  int i_0;\n  Stack *stack;\n  int *visited;\n  Stack *temp;\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  stack = 0LL;\n  visited = (int *)libmin_malloc(4LL * graph->V);\n  for (i = 0; i < graph->V; ++i) visited[i] = 0;\n  for (i_0 = 0; i_0 < graph->V; ++i_0) {\n    if (!visited[i_0]) topologicalSortUtil(graph, i_0, visited, &stack);\n  }\n  while (stack) {\n    libmin_printf(\"%d \", stack->data);\n    temp = stack;\n    stack = stack->next;\n    libmin_free(temp);\n  }\n  libmin_free(visited);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}", "binary": "topo-sort/topo-sort.host.O0", "assembly": "<topologicalSort>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovq   $0x0,-0x20(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\ncltq\nshl    $0x2,%rax\nmov    %rax,%rdi\ncall   17ae <libmin_malloc>\nmov    %rax,-0x18(%rbp)\nmovl   $0x0,-0x28(%rbp)\njmp    1463 <topologicalSort+0x66>\nmov    -0x28(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x0,(%rax)\naddl   $0x1,-0x28(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x28(%rbp)\njl     1445 <topologicalSort+0x48>\nmovl   $0x0,-0x24(%rbp)\njmp    14ac <topologicalSort+0xaf>\nmov    -0x24(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    14a8 <topologicalSort+0xab>\nlea    -0x20(%rbp),%rcx\nmov    -0x18(%rbp),%rdx\nmov    -0x24(%rbp),%esi\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   1332 <topologicalSortUtil>\naddl   $0x1,-0x24(%rbp)\nmov    -0x38(%rbp),%rax\nmov    (%rax),%eax\ncmp    %eax,-0x24(%rbp)\njl     1477 <topologicalSort+0x7a>\njmp    14f5 <topologicalSort+0xf8>\nmov    -0x20(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,%esi\nlea    0x2b3c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   3c10 <libmin_printf>\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x10(%rbp),%rax\nmov    %rax,%rdi\ncall   1899 <libmin_free>\nmov    -0x20(%rbp),%rax\ntest   %rax,%rax\njne    14b9 <topologicalSort+0xbc>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1899 <libmin_free>\nmov    -0x38(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,%rdi\ncall   1899 <libmin_free>\nmov    -0x38(%rbp),%rax\nmov    %rax,%rdi\ncall   1899 <libmin_free>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     153b <topologicalSort+0x13e>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "topologicalSortUtil", "content": " \n  \n// A recursive function used by topologicalSort \nvoid\ntopologicalSortUtil(struct Graph* graph, int v, int visited[], struct Stack** stack) \n{ \n  visited[v] = TRUE; \n  \n  struct List* current = graph->adj[v].next; \n  while (current != NULL)\n  { \n    int adjacentVertex = current->data; \n    if (!visited[adjacentVertex]) \n      topologicalSortUtil(graph, adjacentVertex, visited, stack); \n    current = current->next; \n  } \n  \n  // Push the current vertex to stack which stores the \n  // result \n  struct Stack* newNode = createStackNode(v); \n  newNode->next = *stack; \n  *stack = newNode; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O0.pseudo", "function_name": "topologicalSortUtil", "address": "0x1332", "label": "topologicalSortUtil", "content": "void __cdecl topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack)\n{\n  List *current; // [rsp+30h] [rbp-10h]\n  Stack *newNode; // [rsp+38h] [rbp-8h]\n\n  visited[v] = 1;\n  for ( current = graph->adj[v].next; current; current = current->next )\n  {\n    if ( !visited[current->data] )\n      topologicalSortUtil(graph, current->data, visited, stack);\n  }\n  newNode = createStackNode(v);\n  newNode->next = *stack;\n  *stack = newNode;\n}\n"}, "pseudo_normalize": "void topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack) {\n  List *current;\n  Stack *newNode;\n  visited[v] = 1;\n  for (current = graph->adj[v].next; current; current = current->next) {\n    if (!visited[current->data])\n      topologicalSortUtil(graph, current->data, visited, stack);\n  }\n  newNode = createStackNode(v);\n  newNode->next = *stack;\n  *stack = newNode;\n}", "binary": "topo-sort/topo-sort.host.O0", "assembly": "<topologicalSortUtil>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %esi,-0x2c(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    %rcx,-0x40(%rbp)\nmov    -0x2c(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovl   $0x1,(%rax)\nmov    -0x28(%rbp),%rax\nmov    0x8(%rax),%rdx\nmov    -0x2c(%rbp),%eax\ncltq\nshl    $0x4,%rax\nadd    %rdx,%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\njmp    13cb <topologicalSortUtil+0x99>\nmov    -0x10(%rbp),%rax\nmov    (%rax),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,4),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    13bf <topologicalSortUtil+0x8d>\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rdx\nmov    -0x14(%rbp),%esi\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   1332 <topologicalSortUtil>\nmov    -0x10(%rbp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,-0x10(%rbp)\ncmpq   $0x0,-0x10(%rbp)\njne    1385 <topologicalSortUtil+0x53>\nmov    -0x2c(%rbp),%eax\nmov    %eax,%edi\ncall   11e9 <createStackNode>\nmov    %rax,-0x8(%rbp)\nmov    -0x40(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x8(%rbp),%rax\nmov    %rdx,0x8(%rax)\nmov    -0x40(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\nnop\nleave\nret\n"}
{"source": {"path": "totient/totient.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tint argc=1; char **argv=NULL;\n\tint n;\n\tint j=0;\n\n\t/* Process command line */\n\twhile(++j < argc){\n\t\tif(argv[j][0] == '-')\n\t\t\tswitch(argv[j][1]){ \n\t\t\t\tcase '-':\n\t\t\t\t\t++j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\tcase 'V':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '?':\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'H':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",HELP);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tdefault:\n\t\t\t\t\tlibmin_printf(\"totient: unkown option %s\\n\", argv[j]);\n\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\tbreak;\n\t}\n\n\tif(j >= argc){\n\t\t//fprintf(stderr,\"totient: usage error.\\n\");\n\t\t//fprintf(stderr,\"%s\\n\",USAGE);\n\t\tn = 45457;\n\t}\n\telse\n\t  n = libmin_atoi(argv[j++]);\n\n\tif(n == 0){\n\t\tlibmin_printf(\"totient: not defined for n = 0.\\n\");\n\t\treturn 1;\n\t}\n\n\tlibmin_printf(\"phi(%d) = %d\\n\",n,phi(n));\n\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "totient/totient.host.O0.pseudo", "function_name": "main", "address": "0x1352", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  int v3;\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}", "binary": "totient/totient.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmovl   $0x1,-0xc(%rbp)\nmovq   $0x0,-0x8(%rbp)\nmovl   $0x0,-0x10(%rbp)\nnop\naddl   $0x1,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njge    14cc <main+0x17a>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmovzbl (%rax),%eax\ncmp    $0x2d,%al\njne    14cb <main+0x179>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nadd    $0x1,%rax\nmovzbl (%rax),%eax\nmovsbl %al,%eax\ncmp    $0x2d,%eax\nje     1425 <main+0xd3>\ncmp    $0x2d,%eax\njl     1475 <main+0x123>\ncmp    $0x76,%eax\njg     1475 <main+0x123>\ncmp    $0x3f,%eax\njl     1475 <main+0x123>\nsub    $0x3f,%eax\nmov    $0x1,%edx\nmov    %eax,%ecx\nshl    %cl,%rdx\nmovabs $0x20000000201,%rax\nand    %rdx,%rax\ntest   %rax,%rax\nsetne  %al\ntest   %al,%al\njne    1452 <main+0x100>\nmovabs $0x80000000800000,%rax\nand    %rdx,%rax\ntest   %rax,%rax\nsetne  %al\ntest   %al,%al\njne    142f <main+0xdd>\njmp    1475 <main+0x123>\naddl   $0x1,-0x10(%rbp)\nnop\njmp    14cb <main+0x179>\nlea    0x2bd2(%rip),%rax\nmov    %rax,%rsi\nlea    0x2bcc(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37cd <libmin_printf>\ncall   3a3a <libmin_success>\nlea    0x2bb7(%rip),%rax\nmov    %rax,%rsi\nlea    0x2ba9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37cd <libmin_printf>\ncall   3a3a <libmin_success>\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rsi\nlea    0x2cd9(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37cd <libmin_printf>\nlea    0x2ce0(%rip),%rax\nmov    %rax,%rsi\nlea    0x2b58(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37cd <libmin_printf>\nmov    $0x1,%edi\ncall   17a1 <libmin_fail>\nnop\nmov    -0x10(%rbp),%eax\ncmp    -0xc(%rbp),%eax\njl     14dd <main+0x18b>\nmovl   $0xb191,-0x14(%rbp)\njmp    1505 <main+0x1b3>\nmov    -0x10(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    %edx,-0x10(%rbp)\ncltq\nlea    0x0(,%rax,8),%rdx\nmov    -0x8(%rbp),%rax\nadd    %rdx,%rax\nmov    (%rax),%rax\nmov    %rax,%rdi\ncall   1699 <libmin_atoi>\nmov    %eax,-0x14(%rbp)\ncmpl   $0x0,-0x14(%rbp)\njne    1526 <main+0x1d4>\nlea    0x2c96(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37cd <libmin_printf>\nmov    $0x1,%eax\njmp    1555 <main+0x203>\nmov    -0x14(%rbp),%eax\nmov    %eax,%edi\ncall   1271 <phi>\nmov    %eax,%edx\nmov    -0x14(%rbp),%eax\nmov    %eax,%esi\nlea    0x2c8b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   37cd <libmin_printf>\ncall   3a3a <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "totient/totient.c", "function_name": "my_gcd", "content": "/* totient.c: Calculates the Euler totient function, phi. \n *\n *  By Terry R. McConnell\n *\n *                              Theory\n *\n *  Euler's totient function, phi(n), is defined as the number of natural\n *  numbers <= n which are relatively prime to n. (We count 1 as relatively\n *  prime to everything.) It is an extremely important function in number\n *  theory. For primes p it is clear from the definition that phi(p) = p - 1.\n *  For powers of a prime it also easy to see (use induction on n) that\n *  phi(p^n) = p^(n-1)(p-1). Thus, e.g, phi(125) = 100. For all other\n *  values phi can be computed by factoring n completely and using the\n *  following result:\n *\n *  Theorem: Phi is a multiplicative function, i.e., if (m,n) = 1 (relatively\n *  prime) then phi(mn) = phi(m)phi(n).\n *\n *  Perhaps the easiest proof is via group theory. It follows from the\n *  Chinese Remainder Theorem that the multiplicative group of invertible \n *  integers modulo  mn, Z(mn), is isomorphic to the direct product Z(m)xZ(n).\n *  The result follows since the orders of these groups are given by the \n *  totient function. \n *\n *  For a proof of the version of the Chinese Remainder Theorem required,\n *  see Theorem 3.7 in H.M. Stark, An Introduction to Number Theory, \n *  Markham, Chicago, 1970.\n *\n *  Our implementation is highly recursive and is motivated by the McCarthy\n *  conditional statement formalism. (See Marvin Minsky, Computation:\n *  finite and infinite machines, Prentice Hall, Englewood Cliffs, 1967,\n *  problem 10.7-1.)\n *\n *  We define phi(-n) = phi(n), and do not define phi(0).\n *\n*/\n\n/* compile: cc -o totient  totient.c\n\n      Use -D_SHORT_STRINGS if your compiler does not support multiline\n          string constants.\n\n   Run totient -h for usage information.\n\n*/\n\n\n#include \"libmin.h\"\n\n#define VERSION \"1.0\"\n#define USAGE \"totient [ -h -v -- ] n\"\n#ifndef _SHORT_STRINGS\n#define HELP \"\\ntotient [ -h -v --] n\\n\\n\\\nFind the Euler totient function of n, the number of k <= n such that\\n\\\nk and n are relatively prime. (1 is relatively prime to everything.)\\n\\n\\\n--: Signal end of options so that negative n can be input. (Silly, since\\n\\\n    we merely define phi(-n) = phi(n).)\\n\\\n-v: Print version number and exit. \\n\\\n-h: Print this helpful information. \\n\\n\"\n#else\n#define HELP USAGE\n#endif\n\n/* my_gcd: return the greatest common divisor of a and b, or -1 if it\n * is not defined. (See also euclid.c for a standalone implementation\n * of my_gcd.) \n * \n */\n\nstatic int my_gcd(int a, int b)\n{\n\tint q,r,t;\n\n\t/* Normalize so that 0 < a <= b */\n\tif((a == 0)||(b == 0)) return -1;\n\tif(a < 0) a = -a;\n\tif(b < 0) b = -b;\n\tif(b < a){\n\t\tt = b;\n\t\tb = a;\n\t\ta = t;\n\t}\n\n\t/* Now a <= b and both >= 1. */\n\n\tq = b/a;\n\tr = b - a*q;\n\tif(r == 0) \n\t\treturn a;\n\n\treturn my_gcd(a,r);\n}\n"}, "pseudo": {"path": "totient/totient.host.O0.pseudo", "function_name": "my_gcd", "address": "0x11e9", "label": "my_gcd", "content": "int __cdecl my_gcd(int a, int b)\n{\n  int ba; // [rsp+8h] [rbp-18h]\n  int aa; // [rsp+Ch] [rbp-14h]\n  int t; // [rsp+14h] [rbp-Ch]\n\n  aa = a;\n  ba = b;\n  if ( !a || !b )\n    return -1;\n  if ( a < 0 )\n    aa = -a;\n  if ( b < 0 )\n    ba = -b;\n  if ( ba < aa )\n  {\n    t = ba;\n    ba = aa;\n    aa = t;\n  }\n  if ( ba % aa )\n    return my_gcd(aa, ba % aa);\n  else\n    return aa;\n}\n"}, "pseudo_normalize": "int my_gcd(int a, int b) {\n  int ba;\n  int aa;\n  int t;\n  aa = a;\n  ba = b;\n  if (!a || !b) return -1;\n  if (a < 0) aa = -a;\n  if (b < 0) ba = -b;\n  if (ba < aa) {\n    t = ba;\n    ba = aa;\n    aa = t;\n  }\n  if (ba % aa)\n    return my_gcd(aa, ba % aa);\n  else\n    return aa;\n}", "binary": "totient/totient.host.O0", "assembly": "<my_gcd>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %edi,-0x14(%rbp)\nmov    %esi,-0x18(%rbp)\ncmpl   $0x0,-0x14(%rbp)\nje     1207 <my_gcd+0x1e>\ncmpl   $0x0,-0x18(%rbp)\njne    120e <my_gcd+0x25>\nmov    $0xffffffff,%eax\njmp    126f <my_gcd+0x86>\ncmpl   $0x0,-0x14(%rbp)\njns    1217 <my_gcd+0x2e>\nnegl   -0x14(%rbp)\ncmpl   $0x0,-0x18(%rbp)\njns    1220 <my_gcd+0x37>\nnegl   -0x18(%rbp)\nmov    -0x18(%rbp),%eax\ncmp    -0x14(%rbp),%eax\njge    123a <my_gcd+0x51>\nmov    -0x18(%rbp),%eax\nmov    %eax,-0xc(%rbp)\nmov    -0x14(%rbp),%eax\nmov    %eax,-0x18(%rbp)\nmov    -0xc(%rbp),%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x18(%rbp),%eax\ncltd\nidivl  -0x14(%rbp)\nmov    %eax,-0x8(%rbp)\nmov    -0x14(%rbp),%eax\nimul   -0x8(%rbp),%eax\nmov    %eax,%edx\nmov    -0x18(%rbp),%eax\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njne    1260 <my_gcd+0x77>\nmov    -0x14(%rbp),%eax\njmp    126f <my_gcd+0x86>\nmov    -0x4(%rbp),%edx\nmov    -0x14(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   11e9 <my_gcd>\nleave\nret\n"}
{"source": {"path": "totient/totient.c", "function_name": "phi", "content": "static int phi(int n)\n{\n\tif(n<0)n=-n;\n\t/* handle a few trivial boundary cases */\n\tif(n<=1)return 0;\n\tif(n==2)return 1;\n\tif(n==3)return 2;\n\treturn phiphi(n,2);\n}\n"}, "pseudo": {"path": "totient/totient.host.O0.pseudo", "function_name": "phi", "address": "0x1271", "label": "phi", "content": "int __cdecl phi(int n)\n{\n  int na; // [rsp+Ch] [rbp-4h]\n\n  na = n;\n  if ( n < 0 )\n    na = -n;\n  if ( na <= 1 )\n    return 0;\n  if ( na == 2 )\n    return 1;\n  if ( na == 3 )\n    return 2;\n  return phiphi(na, 2);\n}\n"}, "pseudo_normalize": "int phi(int n) {\n  int na;\n  na = n;\n  if (n < 0) na = -n;\n  if (na <= 1) return 0;\n  if (na == 2) return 1;\n  if (na == 3) return 2;\n  return phiphi(na, 2);\n}", "binary": "totient/totient.host.O0", "assembly": "<phi>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %edi,-0x4(%rbp)\ncmpl   $0x0,-0x4(%rbp)\njns    1289 <phi+0x18>\nnegl   -0x4(%rbp)\ncmpl   $0x1,-0x4(%rbp)\njg     1296 <phi+0x25>\nmov    $0x0,%eax\njmp    12bf <phi+0x4e>\ncmpl   $0x2,-0x4(%rbp)\njne    12a3 <phi+0x32>\nmov    $0x1,%eax\njmp    12bf <phi+0x4e>\ncmpl   $0x3,-0x4(%rbp)\njne    12b0 <phi+0x3f>\nmov    $0x2,%eax\njmp    12bf <phi+0x4e>\nmov    -0x4(%rbp),%eax\nmov    $0x2,%esi\nmov    %eax,%edi\ncall   12c1 <phiphi>\nleave\nret\n"}
{"source": {"path": "totient/totient.c", "function_name": "phiphi", "content": "/* This only gets called with y >= 3 and y > x >= 2 */\n\nstatic int phiphi(int y, int x)\n{\n\tint z;\n\n\tif(x+1 == y)return x; /* phi(prime p) = p-1 */\n\tif((y%x)==0){\n\t\tif(my_gcd(x,z=y/x)==1)\n\t\t\treturn phi(x)*phi(z); /* multiplicative property */\n\t\telse\n\t\t\treturn x*phi(z); /* This is a tricky case. It may\n\t\t\t\t\t    happen when x is a prime such\n\t\t\t\t\t    that a power of x divides y. In\n\t\t\t\t\t    case y = p^n, phi(y) = p^(n-1)(p-1)\n\t\t\t\t\t   */\n\t}\n\telse return phiphi(y,x+1);\n}\n"}, "pseudo": {"path": "totient/totient.host.O0.pseudo", "function_name": "phiphi", "address": "0x12c1", "label": "phiphi", "content": "int __cdecl phiphi(int y, int x)\n{\n  int v3; // ebx\n  int z; // [rsp+1Ch] [rbp-14h]\n\n  if ( y == x + 1 )\n    return x;\n  if ( y % x )\n    return phiphi(y, x + 1);\n  z = y / x;\n  if ( my_gcd(x, y / x) != 1 )\n    return x * phi(z);\n  v3 = phi(x);\n  return v3 * phi(z);\n}\n"}, "pseudo_normalize": "int phiphi(int y, int x) {\n  int v3;\n  int z;\n  if (y == x + 1) return x;\n  if (y % x) return phiphi(y, x + 1);\n  z = y / x;\n  if (my_gcd(x, y / x) != 1) return x * phi(z);\n  v3 = phi(x);\n  return v3 * phi(z);\n}", "binary": "totient/totient.host.O0", "assembly": "<phiphi>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %edi,-0x24(%rbp)\nmov    %esi,-0x28(%rbp)\nmov    -0x28(%rbp),%eax\nadd    $0x1,%eax\ncmp    %eax,-0x24(%rbp)\njne    12e4 <phiphi+0x23>\nmov    -0x28(%rbp),%eax\njmp    134c <phiphi+0x8b>\nmov    -0x24(%rbp),%eax\ncltd\nidivl  -0x28(%rbp)\nmov    %edx,%eax\ntest   %eax,%eax\njne    133a <phiphi+0x79>\nmov    -0x24(%rbp),%eax\ncltd\nidivl  -0x28(%rbp)\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%edx\nmov    -0x28(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   11e9 <my_gcd>\ncmp    $0x1,%eax\njne    132a <phiphi+0x69>\nmov    -0x28(%rbp),%eax\nmov    %eax,%edi\ncall   1271 <phi>\nmov    %eax,%ebx\nmov    -0x14(%rbp),%eax\nmov    %eax,%edi\ncall   1271 <phi>\nimul   %ebx,%eax\njmp    134c <phiphi+0x8b>\nmov    -0x14(%rbp),%eax\nmov    %eax,%edi\ncall   1271 <phi>\nimul   -0x28(%rbp),%eax\njmp    134c <phiphi+0x8b>\nmov    -0x28(%rbp),%eax\nlea    0x1(%rax),%edx\nmov    -0x24(%rbp),%eax\nmov    %edx,%esi\nmov    %eax,%edi\ncall   12c1 <phiphi>\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "transcend/transcend.c", "function_name": "init_inputs_f64", "content": "// --------------------- Input initialization (domain-safe) --------------------\nstatic void init_inputs_f64(double* x, size_t n, size_t stride, fn_t fn, uint64_t seed) {\n  uint64_t s = seed ? seed : 1;\n  for (size_t i=0, idx=0; i<n; i++, idx=(idx+stride)%n) {\n    double u = (double)((xorshift64(&s) >> 11) * (1.0/9007199254740992.0)); // [0,1)\n    switch (fn) {\n      case FN_EXP:  x[idx] = -10.0 + 20.0 * u; break;            // [-10,10]\n      case FN_SIN:\n      case FN_COS:  x[idx] = -M_PI + 2.0*M_PI * u; break;        // [-pi,pi]\n      case FN_MIX:  x[idx] = -4.0 + 8.0 * u; break;              // general range\n      default:      x[idx] = u;\n    }\n  }\n}\n"}, "pseudo": {"path": "transcend/transcend.host.O0.pseudo", "function_name": "init_inputs_f64", "address": "0x1235", "label": "init_inputs_f64", "content": "void __cdecl init_inputs_f64(double *x, size_t n, size_t stride, fn_t fn, uint64_t seed)\n{\n  uint64_t v5; // rax\n  uint64_t s; // [rsp+38h] [rbp-28h] BYREF\n  size_t i; // [rsp+40h] [rbp-20h]\n  size_t idx; // [rsp+48h] [rbp-18h]\n  double u; // [rsp+50h] [rbp-10h]\n  unsigned __int64 v12; // [rsp+58h] [rbp-8h]\n\n  v12 = __readfsqword(0x28u);\n  if ( seed )\n    v5 = seed;\n  else\n    v5 = 1LL;\n  s = v5;\n  i = 0LL;\n  idx = 0LL;\n  while ( i < n )\n  {\n    u = (double)(int)(xorshift64(&s) >> 11) * 1.110223024625157e-16;\n    if ( fn == FN_MIX )\n    {\n      x[idx] = 8.0 * u - 4.0;\n    }\n    else\n    {\n      if ( (unsigned int)fn <= FN_MIX )\n      {\n        if ( fn == FN_EXP )\n        {\n          x[idx] = 20.0 * u - 10.0;\n          goto LABEL_13;\n        }\n        if ( (unsigned int)(fn - 1) <= 1 )\n        {\n          x[idx] = 6.283185307179586 * u - 3.141592653589793;\n          goto LABEL_13;\n        }\n      }\n      x[idx] = u;\n    }\nLABEL_13:\n    ++i;\n    idx = (idx + stride) % n;\n  }\n}\n"}, "pseudo_normalize": "void init_inputs_f64(double *x, unsigned int n, unsigned int stride, fn_t fn,\n                     uint64_t seed) {\n  uint64_t v5;\n  uint64_t s;\n  unsigned int i;\n  unsigned int idx;\n  double u;\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  if (seed)\n    v5 = seed;\n  else\n    v5 = 1LL;\n  s = v5;\n  i = 0LL;\n  idx = 0LL;\n  while (i < n) {\n    u = (double)(int)(xorshift64(&s) >> 11) * 1.110223024625157e-16;\n    if (fn == FN_MIX) {\n      x[idx] = 8.0 * u - 4.0;\n    } else {\n      if ((unsigned int)fn <= FN_MIX) {\n        if (fn == FN_EXP) {\n          x[idx] = 20.0 * u - 10.0;\n          goto LABEL_13;\n        }\n        if ((unsigned int)(fn - 1) <= 1) {\n          x[idx] = 6.283185307179586 * u - 3.141592653589793;\n          goto LABEL_13;\n        }\n      }\n      x[idx] = u;\n    }\n  LABEL_13:\n    ++i;\n    idx = (idx + stride) % n;\n  }\n}", "binary": "transcend/transcend.host.O0", "assembly": "<init_inputs_f64>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x60,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmov    %rdx,-0x48(%rbp)\nmov    %ecx,-0x4c(%rbp)\nmov    %r8,-0x58(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\ncmpq   $0x0,-0x58(%rbp)\nje     1270 <init_inputs_f64+0x3b>\nmov    -0x58(%rbp),%rax\njmp    1275 <init_inputs_f64+0x40>\nmov    $0x1,%eax\nmov    %rax,-0x28(%rbp)\nmovq   $0x0,-0x20(%rbp)\nmovq   $0x0,-0x18(%rbp)\njmp    13e1 <init_inputs_f64+0x1ac>\nlea    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <xorshift64>\nshr    $0xb,%rax\ntest   %rax,%rax\njs     12ae <init_inputs_f64+0x79>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    12c7 <init_inputs_f64+0x92>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x5da9(%rip),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\ncmpl   $0x3,-0x4c(%rbp)\nje     1372 <init_inputs_f64+0x13d>\ncmpl   $0x3,-0x4c(%rbp)\nja     13a8 <init_inputs_f64+0x173>\ncmpl   $0x0,-0x4c(%rbp)\nje     1303 <init_inputs_f64+0xce>\nmov    -0x4c(%rbp),%eax\nsub    $0x1,%eax\ncmp    $0x1,%eax\nja     13a8 <init_inputs_f64+0x173>\njmp    133c <init_inputs_f64+0x107>\nmovsd  -0x10(%rbp),%xmm1\nmovsd  0x5d70(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x5d59(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    13c4 <init_inputs_f64+0x18f>\nmovsd  -0x10(%rbp),%xmm1\nmovsd  0x5d47(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x5d30(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    13c4 <init_inputs_f64+0x18f>\nmovsd  -0x10(%rbp),%xmm1\nmovsd  0x5d21(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x18(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  0x5d0a(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rax)\njmp    13c4 <init_inputs_f64+0x18f>\nmov    -0x18(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x38(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x10(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\naddq   $0x1,-0x20(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x48(%rbp),%rax\nadd    %rdx,%rax\nmov    $0x0,%edx\ndivq   -0x40(%rbp)\nmov    %rdx,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\ncmp    -0x40(%rbp),%rax\njb     128e <init_inputs_f64+0x59>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1404 <init_inputs_f64+0x1cf>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "transcend/transcend.c", "function_name": "main", "content": "// --------------------------------- Main -------------------------------------\nint main(void) {\n  for (int f = 0; f < FN_COUNT; ++f) {\n    (void)run_fp64((fn_t)f);\n  }\n  libmin_success();\n}\n"}, "pseudo": {"path": "transcend/transcend.host.O0.pseudo", "function_name": "main", "address": "0x1764", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  fn_t f; // [rsp+Ch] [rbp-4h]\n\n  for ( f = FN_EXP; f <= FN_MIX; ++f )\n    run_fp64(f);\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "transcend/transcend.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmovl   $0x0,-0x4(%rbp)\njmp    1787 <main+0x23>\nmov    -0x4(%rbp),%eax\nmov    %eax,%edi\ncall   1406 <run_fp64>\naddl   $0x1,-0x4(%rbp)\ncmpl   $0x3,-0x4(%rbp)\njle    1779 <main+0x15>\ncall   49cc <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "transcend/transcend.c", "function_name": "run_fp64", "content": "// ------------------------------ Kernel (FP64) --------------------------------\nstatic double run_fp64(fn_t fn) {\n  const size_t n = (size_t)N_ELEMS, stride = (size_t)STRIDE;\n  double *x = (double*)libmin_malloc(n*sizeof(double));\n  double *y = (double*)libmin_malloc(n*sizeof(double));\n  if (!x || !y) { libmin_printf(\"alloc failed\\n\"); libmin_fail(1); }\n  init_inputs_f64(x, n, stride, fn, (uint64_t)SEED);\n\n  volatile double sink = 0.0;\n\n  for (uint64_t it=0; it < (uint64_t)N_ITER; ++it) {\n    for (size_t i=0, idx=0; i<n; i++, idx=(idx+stride)%n) {\n      double v = x[idx]; double r;\n      switch (fn) {\n        case FN_EXP:  r = libmin_exp(v); break;\n        case FN_SIN:  r = libmin_sin(v); break;\n        case FN_COS:  r = libmin_cos(v); break;\n        case FN_MIX: {\n          int sel = (int)(i % 3); // 0:exp, 1:sin, 2:cos\n          r = (sel==0)?libmin_exp(v):(sel==1)?libmin_sin(v):libmin_cos(v);\n        } break;\n        default: r = v;\n      }\n      y[idx] = r; sink += r * 1e-16;\n    }\n  }\n\n  const double ops = (double)N_ITER * (double)n;   // one transcendental per element\n  double checksum = 0.0; for (size_t i=0;i<n;i++) checksum += y[i];\n\n  libmin_printf(\"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n         FN_NAMES[(int)fn], (unsigned)N_ITER, n, stride, ops, checksum);\n\n  libmin_free((void*)x); libmin_free((void*)y);\n  return checksum + sink;\n}\n"}, "pseudo": {"path": "transcend/transcend.host.O0.pseudo", "function_name": "run_fp64", "address": "0x1406", "label": "run_fp64", "content": "double __cdecl run_fp64(fn_t fn)\n{\n  double v1; // rax\n  int sel; // [rsp+14h] [rbp-6Ch]\n  double sink; // [rsp+18h] [rbp-68h]\n  uint64_t it; // [rsp+20h] [rbp-60h]\n  size_t i; // [rsp+28h] [rbp-58h]\n  size_t idx; // [rsp+30h] [rbp-50h]\n  double r; // [rsp+38h] [rbp-48h]\n  double checksum; // [rsp+40h] [rbp-40h]\n  size_t i_0; // [rsp+48h] [rbp-38h]\n  double *x; // [rsp+60h] [rbp-20h]\n  double *y; // [rsp+68h] [rbp-18h]\n  double v; // [rsp+78h] [rbp-8h]\n\n  x = (double *)libmin_malloc(0x200uLL);\n  y = (double *)libmin_malloc(0x200uLL);\n  if ( !x || !y )\n  {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  init_inputs_f64(x, 0x40uLL, 1uLL, fn, 1uLL);\n  sink = 0.0;\n  for ( it = 0LL; it <= 9; ++it )\n  {\n    i = 0LL;\n    idx = 0LL;\n    while ( i < 0x40 )\n    {\n      v = x[idx];\n      if ( fn == FN_MIX )\n      {\n        sel = i % 3;\n        if ( sel )\n        {\n          if ( sel == 1 )\n            v1 = libmin_sin(v);\n          else\n            v1 = libmin_cos(v);\n        }\n        else\n        {\n          v1 = libmin_exp(v);\n        }\n        r = v1;\n      }\n      else if ( (unsigned int)fn > FN_MIX )\n      {\n        r = x[idx];\n      }\n      else if ( fn == FN_COS )\n      {\n        r = libmin_cos(v);\n      }\n      else if ( fn )\n      {\n        r = libmin_sin(v);\n      }\n      else\n      {\n        r = libmin_exp(v);\n      }\n      y[idx] = r;\n      sink = sink + r * 1.0e-16;\n      ++i;\n      idx = (idx + 1) % 0x40;\n    }\n  }\n  checksum = 0.0;\n  for ( i_0 = 0LL; i_0 < 0x40; ++i_0 )\n    checksum = y[i_0] + checksum;\n  libmin_printf(\n    \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n    FN_NAMES[fn],\n    10,\n    64,\n    1,\n    (double)64 * 10.0,\n    checksum);\n  libmin_free(x);\n  libmin_free(y);\n  return sink + checksum;\n}\n"}, "pseudo_normalize": "double run_fp64(fn_t fn) {\n  double v1;\n  int sel;\n  double sink;\n  uint64_t it;\n  unsigned int i;\n  unsigned int idx;\n  double r;\n  double checksum;\n  unsigned int i_0;\n  double *x;\n  double *y;\n  double v;\n  x = (double *)libmin_malloc(512uLL);\n  y = (double *)libmin_malloc(512uLL);\n  if (!x || !y) {\n    libmin_printf(\"alloc failed\\n\");\n    libmin_fail(1);\n  }\n  init_inputs_f64(x, 64uLL, 1uLL, fn, 1uLL);\n  sink = 0.0;\n  for (it = 0LL; it <= 9; ++it) {\n    i = 0LL;\n    idx = 0LL;\n    while (i < 64) {\n      v = x[idx];\n      if (fn == FN_MIX) {\n        sel = i % 3;\n        if (sel) {\n          if (sel == 1)\n            v1 = libmin_sin(v);\n          else\n            v1 = libmin_cos(v);\n        } else {\n          v1 = libmin_exp(v);\n        }\n        r = v1;\n      } else if ((unsigned int)fn > FN_MIX) {\n        r = x[idx];\n      } else if (fn == FN_COS) {\n        r = libmin_cos(v);\n      } else if (fn) {\n        r = libmin_sin(v);\n      } else {\n        r = libmin_exp(v);\n      }\n      y[idx] = r;\n      sink = sink + r * 1.0e-16;\n      ++i;\n      idx = (idx + 1) % 64;\n    }\n  }\n  checksum = 0.0;\n  for (i_0 = 0LL; i_0 < 64; ++i_0) checksum = y[i_0] + checksum;\n  libmin_printf(\n      \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f \"\n      \"checksum=%f\\n\",\n      FN_NAMES[fn], 10, 64, 1, (double)64 * 10.0, checksum);\n  libmin_free(x);\n  libmin_free(y);\n  return sink + checksum;\n}", "binary": "transcend/transcend.host.O0", "assembly": "<run_fp64>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nadd    $0xffffffffffffff80,%rsp\nmov    %edi,-0x74(%rbp)\nmovq   $0x40,-0x30(%rbp)\nmovq   $0x1,-0x28(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1c41 <libmin_malloc>\nmov    %rax,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x3,%rax\nmov    %rax,%rdi\ncall   1c41 <libmin_malloc>\nmov    %rax,-0x18(%rbp)\ncmpq   $0x0,-0x20(%rbp)\nje     145b <run_fp64+0x55>\ncmpq   $0x0,-0x18(%rbp)\njne    1479 <run_fp64+0x73>\nlea    0x5bb6(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   40a3 <libmin_printf>\nmov    $0x1,%edi\ncall   1bbe <libmin_fail>\nmov    -0x74(%rbp),%ecx\nmov    -0x28(%rbp),%rdx\nmov    -0x30(%rbp),%rsi\nmov    -0x20(%rbp),%rax\nmov    $0x1,%r8d\nmov    %rax,%rdi\ncall   1235 <init_inputs_f64>\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x68(%rbp)\nmovq   $0x0,-0x60(%rbp)\njmp    1652 <run_fp64+0x24c>\nmovq   $0x0,-0x58(%rbp)\nmovq   $0x0,-0x50(%rbp)\njmp    163f <run_fp64+0x239>\nmov    -0x50(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x20(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\ncmpl   $0x3,-0x74(%rbp)\nje     1562 <run_fp64+0x15c>\ncmpl   $0x3,-0x74(%rbp)\nja     15dd <run_fp64+0x1d7>\ncmpl   $0x2,-0x74(%rbp)\nje     1546 <run_fp64+0x140>\ncmpl   $0x2,-0x74(%rbp)\nja     15dd <run_fp64+0x1d7>\ncmpl   $0x0,-0x74(%rbp)\nje     150e <run_fp64+0x108>\ncmpl   $0x1,-0x74(%rbp)\nje     152a <run_fp64+0x124>\njmp    15dd <run_fp64+0x1d7>\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   18f4 <libmin_exp>\nmovq   %xmm0,%rax\nmov    %rax,-0x48(%rbp)\njmp    15e7 <run_fp64+0x1e1>\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   47de <libmin_sin>\nmovq   %xmm0,%rax\nmov    %rax,-0x48(%rbp)\njmp    15e7 <run_fp64+0x1e1>\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   462d <libmin_cos>\nmovq   %xmm0,%rax\nmov    %rax,-0x48(%rbp)\njmp    15e7 <run_fp64+0x1e1>\nmov    -0x58(%rbp),%rcx\nmovabs $0xaaaaaaaaaaaaaaab,%rdx\nmov    %rcx,%rax\nmul    %rdx\nmov    %rdx,%rax\nshr    %rax\nmov    %rax,%rdx\nadd    %rdx,%rdx\nadd    %rax,%rdx\nmov    %rcx,%rax\nsub    %rdx,%rax\nmov    %eax,-0x6c(%rbp)\ncmpl   $0x0,-0x6c(%rbp)\njne    15a9 <run_fp64+0x1a3>\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   18f4 <libmin_exp>\nmovq   %xmm0,%rax\njmp    15d7 <run_fp64+0x1d1>\ncmpl   $0x1,-0x6c(%rbp)\njne    15c4 <run_fp64+0x1be>\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   47de <libmin_sin>\nmovq   %xmm0,%rax\njmp    15d7 <run_fp64+0x1d1>\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   462d <libmin_cos>\nmovq   %xmm0,%rax\nmov    %rax,-0x48(%rbp)\njmp    15e7 <run_fp64+0x1e1>\nmovsd  -0x8(%rbp),%xmm0\nmovsd  %xmm0,-0x48(%rbp)\nmov    -0x50(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  -0x48(%rbp),%xmm0\nmovsd  %xmm0,(%rax)\nmovsd  -0x48(%rbp),%xmm1\nmovsd  0x5aa0(%rip),%xmm0\nmulsd  %xmm0,%xmm1\nmovsd  -0x68(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x68(%rbp)\naddq   $0x1,-0x58(%rbp)\nmov    -0x50(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nadd    %rdx,%rax\nmov    $0x0,%edx\ndivq   -0x30(%rbp)\nmov    %rdx,-0x50(%rbp)\nmov    -0x58(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     14c1 <run_fp64+0xbb>\naddq   $0x1,-0x60(%rbp)\ncmpq   $0x9,-0x60(%rbp)\njbe    14ac <run_fp64+0xa6>\nmov    -0x30(%rbp),%rax\ntest   %rax,%rax\njs     1671 <run_fp64+0x26b>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    168a <run_fp64+0x284>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x59f6(%rip),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovq   $0x0,-0x38(%rbp)\njmp    16d8 <run_fp64+0x2d2>\nmov    -0x38(%rbp),%rax\nlea    0x0(,%rax,8),%rdx\nmov    -0x18(%rbp),%rax\nadd    %rdx,%rax\nmovsd  (%rax),%xmm0\nmovsd  -0x40(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\naddq   $0x1,-0x38(%rbp)\nmov    -0x38(%rbp),%rax\ncmp    -0x30(%rbp),%rax\njb     16ae <run_fp64+0x2a8>\nmov    -0x74(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x892a(%rip),%rax\nmov    (%rdx,%rax,1),%rax\nmovsd  -0x40(%rbp),%xmm0\nmov    -0x10(%rbp),%rcx\nmov    -0x28(%rbp),%rsi\nmov    -0x30(%rbp),%rdx\nmovapd %xmm0,%xmm1\nmovq   %rcx,%xmm0\nmov    %rsi,%r8\nmov    %rdx,%rcx\nmov    $0xa,%edx\nmov    %rax,%rsi\nlea    0x58ff(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   40a3 <libmin_printf>\nmov    -0x20(%rbp),%rax\nmov    %rax,%rdi\ncall   1d2c <libmin_free>\nmov    -0x18(%rbp),%rax\nmov    %rax,%rdi\ncall   1d2c <libmin_free>\nmovsd  -0x68(%rbp),%xmm0\naddsd  -0x40(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "transcend/transcend.c", "function_name": "xorshift64", "content": "// --------------------------------- RNG ---------------------------------------\nstatic uint64_t xorshift64(uint64_t *s) {\n  uint64_t x = *s;\n  x ^= x << 13; x ^= x >> 7; x ^= x << 17; *s = x;\n  return x;\n}\n"}, "pseudo": {"path": "transcend/transcend.host.O0.pseudo", "function_name": "xorshift64", "address": "0x11e9", "label": "xorshift64", "content": "uint64_t __cdecl xorshift64(uint64_t *s)\n{\n  uint64_t x; // [rsp+10h] [rbp-8h]\n\n  x = (((*s << 13) ^ *s) >> 7) ^ (*s << 13) ^ *s;\n  *s = (x << 17) ^ x;\n  return (x << 17) ^ x;\n}\n"}, "pseudo_normalize": "uint64_t xorshift64(uint64_t *s) {\n  uint64_t x;\n  x = (((*s << 13) ^ *s) >> 7) ^ (*s << 13) ^ *s;\n  *s = (x << 17) ^ x;\n  return (x << 17) ^ x;\n}", "binary": "transcend/transcend.host.O0", "assembly": "<xorshift64>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rax\nmov    (%rax),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshl    $0xd,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshr    $0x7,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nshl    $0x11,%rax\nxor    %rax,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmov    -0x8(%rbp),%rdx\nmov    %rdx,(%rax)\nmov    -0x8(%rbp),%rax\npop    %rbp\nret\n"}
{"source": {"path": "uniquify/uniquify.c", "function_name": "main", "content": "int main(void) {\n    /* \n     * Define a statically allocated list of strings.\n     * Most strings are unique, with a few duplicates.\n     */\n    char *strings[] = {\n        \"banana\",\n        \"apple\",\n        \"orange\",\n        \"kiwi\",\n        \"grape\",\n        \"mango\",\n        \"strawberry\",\n        \"pear\",\n        \"pineapple\",\n        \"watermelon\",\n        \"blueberry\",\n        \"raspberry\",\n        \"apple\",   /* duplicate */\n        \"blackberry\",\n        \"cherry\",\n        \"banana\",  /* duplicate */\n        \"peach\",\n        \"apricot\",\n        \"plum\",\n        \"nectarine\",\n        \"cantaloupe\",\n        \"honeydew\",\n        \"lime\", /* duplicate */\n        \"papaya\",\n        \"passionfruit\",\n        \"guava\",\n        \"lychee\",\n        \"pomegranate\",\n        \"grapefruit\",\n        \"lemon\",\n        \"lime\",\n        \"tangerine\",\n        \"cranberry\",\n        \"fig\",\n        \"plum\" /* duplicate */\n    };\n    size_t n = sizeof(strings) / sizeof(strings[0]);\n\n    libmin_printf(\"Unsorted Strings:\\n\");\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s\\n\", strings[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* Sort the list using qsort from qsort.h/qsort.c */\n    libmin_qsort(strings, n, sizeof(char *), string_compare);\n\n    libmin_printf(\"Sorted Strings:\\n\");\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s\\n\", strings[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* Remove duplicates from the sorted list.\n     * Since duplicates become adjacent after sorting, we simply print the\n     * first occurrence and then any string that differs from its predecessor.\n     */\n    libmin_printf(\"Unique Strings:\\n\");\n    if (n > 0) {\n        libmin_printf(\"%s\\n\", strings[0]);\n        size_t unique_count = 1;\n        for (size_t i = 1; i < n; i++) {\n            if (libmin_strcmp(strings[i], strings[i - 1]) != 0) {\n                libmin_printf(\"%s\\n\", strings[i]);\n                unique_count++;\n            }\n        }\n        libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_count);\n    } else {\n        libmin_printf(\"No strings.\\n\");\n    }\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "uniquify/uniquify.host.O0.pseudo", "function_name": "main", "address": "0x1228", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  size_t i; // [rsp+8h] [rbp-148h]\n  size_t i_0; // [rsp+10h] [rbp-140h]\n  int unique_count; // [rsp+18h] [rbp-138h]\n  size_t i_1; // [rsp+20h] [rbp-130h]\n  char *strings[35]; // [rsp+30h] [rbp-120h] BYREF\n  unsigned __int64 v8; // [rsp+148h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u);\n  qmemcpy(strings, off_7020, sizeof(strings));\n  libmin_printf(\"Unsorted Strings:\\n\", &off_7020[35], off_7020);\n  for ( i = 0LL; i < 0x23; ++i )\n    libmin_printf(\"%s\\n\", strings[i]);\n  libmin_printf(\"\\n\");\n  libmin_qsort(strings, 0x23uLL, 8uLL, (int (*)(const void *, const void *))string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  for ( i_0 = 0LL; i_0 < 0x23; ++i_0 )\n    libmin_printf(\"%s\\n\", strings[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  unique_count = 1;\n  for ( i_1 = 1LL; i_1 < 0x23; ++i_1 )\n  {\n    if ( libmin_strcmp(strings[i_1], strings[i_1 - 1]) )\n    {\n      libmin_printf(\"%s\\n\", strings[i_1]);\n      ++unique_count;\n    }\n  }\n  libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_count);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int i;\n  unsigned int i_0;\n  int unique_count;\n  unsigned int i_1;\n  char *strings[35];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  qmemcpy(strings, off_7020, sizeof(strings));\n  libmin_printf(\"Unsorted Strings:\\n\", &off_7020[35], off_7020);\n  for (i = 0LL; i < 35; ++i) libmin_printf(\"%s\\n\", strings[i]);\n  libmin_printf(\"\\n\");\n  libmin_qsort(strings, 35uLL, 8uLL,\n               (int (*)(const void *, const void *))string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  for (i_0 = 0LL; i_0 < 35; ++i_0) libmin_printf(\"%s\\n\", strings[i_0]);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  unique_count = 1;\n  for (i_1 = 1LL; i_1 < 35; ++i_1) {\n    if (libmin_strcmp(strings[i_1], strings[i_1 - 1])) {\n      libmin_printf(\"%s\\n\", strings[i_1]);\n      ++unique_count;\n    }\n  }\n  libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_count);\n  libmin_success();\n}", "binary": "uniquify/uniquify.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x150,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    -0x120(%rbp),%rax\nlea    0x5dcc(%rip),%rdx\nmov    $0x23,%ecx\nmov    %rax,%rdi\nmov    %rdx,%rsi\nrep movsq %ds:(%rsi),%es:(%rdi)\nmovq   $0x23,-0x128(%rbp)\nlea    0x3d90(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\nmovq   $0x0,-0x148(%rbp)\njmp    12bc <main+0x94>\nmov    -0x148(%rbp),%rax\nmov    -0x120(%rbp,%rax,8),%rax\nmov    %rax,%rsi\nlea    0x3d70(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\naddq   $0x1,-0x148(%rbp)\nmov    -0x148(%rbp),%rax\ncmp    -0x128(%rbp),%rax\njb     128e <main+0x66>\nlea    0x3d48(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\nmov    -0x128(%rbp),%rsi\nlea    -0x120(%rbp),%rax\nlea    -0x10c(%rip),%rdx\nmov    %rdx,%rcx\nmov    $0x8,%edx\nmov    %rax,%rdi\ncall   3a63 <libmin_qsort>\nlea    0x3d11(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\nmovq   $0x0,-0x140(%rbp)\njmp    1354 <main+0x12c>\nmov    -0x140(%rbp),%rax\nmov    -0x120(%rbp,%rax,8),%rax\nmov    %rax,%rsi\nlea    0x3cd8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\naddq   $0x1,-0x140(%rbp)\nmov    -0x140(%rbp),%rax\ncmp    -0x128(%rbp),%rax\njb     1326 <main+0xfe>\nlea    0x3cb0(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\nlea    0x3caf(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\ncmpq   $0x0,-0x128(%rbp)\nje     1467 <main+0x23f>\nmov    -0x120(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3c6c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\nmovq   $0x1,-0x138(%rbp)\nmovq   $0x1,-0x130(%rbp)\njmp    1437 <main+0x20f>\nmov    -0x130(%rbp),%rax\nsub    $0x1,%rax\nmov    -0x120(%rbp,%rax,8),%rdx\nmov    -0x130(%rbp),%rax\nmov    -0x120(%rbp,%rax,8),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3ab5 <libmin_strcmp>\ntest   %eax,%eax\nje     142f <main+0x207>\nmov    -0x130(%rbp),%rax\nmov    -0x120(%rbp,%rax,8),%rax\nmov    %rax,%rsi\nlea    0x3bfd(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\naddq   $0x1,-0x138(%rbp)\naddq   $0x1,-0x130(%rbp)\nmov    -0x130(%rbp),%rax\ncmp    -0x128(%rbp),%rax\njb     13d0 <main+0x1a8>\nmov    -0x138(%rbp),%rax\nmov    %rax,%rsi\nlea    0x3be7(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\njmp    147b <main+0x253>\nlea    0x3bec(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35d7 <libmin_printf>\ncall   3b51 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     1499 <main+0x271>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "uniquify/uniquify.c", "function_name": "string_compare", "content": "#include \"libmin.h\"\n\n/* Comparison function for strings.\n * qsort passes pointers to elements (here pointers to char pointers),\n * so we cast accordingly.\n */\nint string_compare(const void *a, const void *b) {\n    const char * const *str1 = (const char * const *) a;\n    const char * const *str2 = (const char * const *) b;\n    return libmin_strcmp(*str1, *str2);\n}\n"}, "pseudo": {"path": "uniquify/uniquify.host.O0.pseudo", "function_name": "string_compare", "address": "0x11e9", "label": "string_compare", "content": "int __cdecl string_compare(const void *a, const void *b)\n{\n  return libmin_strcmp(*(const char **)a, *(const char **)b);\n}\n"}, "pseudo_normalize": "", "binary": "uniquify/uniquify.host.O0", "assembly": "<string_compare>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nmov    (%rax),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   3ab5 <libmin_strcmp>\nleave\nret\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "dot_prod", "content": "/**\n * Obtain the dot product of two 3D vectors.\n * @f[\n * \\vec{a}\\cdot\\vec{b}=a_xb_x + a_yb_y + a_zb_z\n * @f]\n * @param[in] a first vector\n * @param[in] b second vector\n * @returns resulting dot product\n */\ndouble dot_prod(const vec_3d *a, const vec_3d *b)\n{\n    double dot;\n    dot = a->x * b->x;\n    dot += a->y * b->y;\n    dot += a->z * b->z;\n\n    return dot;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O0.pseudo", "function_name": "dot_prod", "address": "0x12f1", "label": "dot_prod", "content": "double __cdecl dot_prod(const vec_3d *a, const vec_3d *b)\n{\n  return b->z * a->z + b->y * a->y + b->x * a->x;\n}\n"}, "pseudo_normalize": "", "binary": "vectors-3d/vectors-3d.host.O0", "assembly": "<dot_prod>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x18(%rbp)\nmov    %rsi,-0x20(%rbp)\nmov    -0x18(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x20(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x20(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmov    -0x18(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmov    -0x20(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x8(%rbp),%xmm1\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\npop    %rbp\nret\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "get_angle", "content": "/**\n * Obtain the angle between two given vectors.\n * @f[\\alpha=acos\\left(\\frac{\\vec{a} \\cdot \\vec{b}}{\\lVert\\vec{a}\\rVert \\cdot \\lVert\\vec{b}\\rVert}\\right)@f]\n * @param[in] a first input vector\n * @param[in] b second input vector\n * @returns angle between @f$\\vec{a}@f$ and @f$\\vec{b}@f$ in radians\n */\n\ndouble get_angle(const vec_3d *a, const vec_3d *b)\n{\n    double alpha, cos_alpha;\n    double norm_a = vector_norm(a); ///< The norm of vector a\n    double norm_b = vector_norm(b); ///< The norm of vector b\n    if (libmin_fabs(norm_a) < EPSILON || libmin_fabs(norm_b) < EPSILON) /// detect possible division by 0 - the angle is not defined in this case\n    {  \n        return NAN; \n    }\n\n    cos_alpha = dot_prod(a, b) / (norm_a * norm_b);\n    alpha = libmin_acos(cos_alpha); // delivers the radian\n    return alpha; // in range from -1 to 1\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O0.pseudo", "function_name": "get_angle", "address": "0x171f", "label": "get_angle", "content": "double __cdecl get_angle(const vec_3d *a, const vec_3d *b)\n{\n  double norm_a; // [rsp+10h] [rbp-20h]\n  double norm_b; // [rsp+18h] [rbp-18h]\n  double cos_alpha; // [rsp+20h] [rbp-10h]\n\n  norm_a = vector_norm(a);\n  norm_b = vector_norm(b);\n  if ( libmin_fabs(norm_a) < 0.000000001 || libmin_fabs(norm_b) < 0.000000001 )\n    return NAN;\n  cos_alpha = dot_prod(a, b) / (norm_a * norm_b);\n  return libmin_acos(cos_alpha);\n}\n"}, "pseudo_normalize": "double get_angle(const vec_3d *a, const vec_3d *b) {\n  double norm_a;\n  double norm_b;\n  double cos_alpha;\n  norm_a = vector_norm(a);\n  norm_b = vector_norm(b);\n  if (libmin_fabs(norm_a) < 0.000000001 || libmin_fabs(norm_b) < 0.000000001)\n    return NAN;\n  cos_alpha = dot_prod(a, b) / (norm_a * norm_b);\n  return libmin_acos(cos_alpha);\n}", "binary": "vectors-3d/vectors-3d.host.O0", "assembly": "<get_angle>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    -0x28(%rbp),%rax\nmov    %rax,%rdi\ncall   14bc <vector_norm>\nmovq   %xmm0,%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmov    %rax,%rdi\ncall   14bc <vector_norm>\nmovq   %xmm0,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x394d(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1795 <get_angle+0x76>\nmov    -0x18(%rbp),%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x3931(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    179f <get_angle+0x80>\nmovsd  0x3933(%rip),%xmm0\njmp    17ef <get_angle+0xd0>\nmov    -0x30(%rbp),%rdx\nmov    -0x28(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   12f1 <dot_prod>\nmovq   %xmm0,%rax\nmovsd  -0x20(%rbp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  -0x18(%rbp),%xmm1\nmovq   %rax,%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x10(%rbp),%rax\nmovq   %rax,%xmm0\ncall   1cff <libmin_acos>\nmovq   %xmm0,%rax\nmov    %rax,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "get_cross_matrix", "content": "/**\n * The cross product of vectors can be represented as a matrix\n * multiplication operation. This function obtains the `3x3` matrix\n * of the cross-product operator from the first vector.\n * @f[\\begin{align*}\n * \\left(\\vec{a}\\times\\right)\\vec{b} &= \\tilde{A}_a\\vec{b}\\\\\n * \\tilde{A}_a &=\n * \\begin{bmatrix}0&-a_z&a_y\\\\a_z&0&-a_x\\\\-a_y&a_x&0\\end{bmatrix}\n * \\end{align*}@f]\n * @param[in] a input vector\n * @returns the `3x3` matrix for the cross product operator\n * @f$\\left(\\vec{a}\\times\\right)@f$\n */\nmat_3x3 get_cross_matrix(const vec_3d *a)\n{\n    mat_3x3 A = {{{0., -a->z, a->y}}, {{a->z, 0., -a->x}}, {{-a->y, a->x, 0.}}};\n    return A;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O0.pseudo", "function_name": "get_cross_matrix", "address": "0x1601", "label": "get_cross_matrix", "content": "mat_3x3 *__cdecl get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a)\n{\n  double v2; // rbx\n  double A_16; // [rsp+20h] [rbp-50h]\n  mat_3x3_::$4A5FC7197C751F0AC9C53218BAF67BC8 A_24; // [rsp+28h] [rbp-48h]\n  _BYTE A_48[24]; // [rsp+40h] [rbp-30h]\n\n  A_16 = a->y;\n  *(_OWORD *)A_24.row2 = *(unsigned __int64 *)&a->z;\n  A_24.row2[2] = -a->x;\n  *(double *)A_48 = -A_16;\n  *(_OWORD *)&A_48[8] = *(unsigned __int64 *)&a->x;\n  v2 = -a->z;\n  retstr->row1[0] = 0.0;\n  retstr->row1[1] = v2;\n  retstr->row1[2] = A_16;\n  retstr->24 = A_24;\n  retstr->48 = *(mat_3x3_::$C21D9BE3F8A00503D67A0121862B4A80 *)A_48;\n  return retstr;\n}\n"}, "pseudo_normalize": "mat_3x3 *get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a) {\n  double v2;\n  double A_16;\n  mat_3x3_::$4A5FC7197C751F0AC9C53218BAF67BC8 A_24;\n  uint8_t A_48[24];\n  A_16 = a->y;\n  *(long double *)A_24.row2 = *(unsigned long long *)&a->z;\n  A_24.row2[2] = -a->x;\n  *(double *)A_48 = -A_16;\n  *(long double *)&A_48[8] = *(unsigned long long *)&a->x;\n  v2 = -a->z;\n  retstr->row1[0] = 0.0;\n  retstr->row1[1] = v2;\n  retstr->row1[2] = A_16;\n  retstr->24 = A_24;\n  retstr->48 = *(mat_3x3_::$C21D9BE3F8A00503D67A0121862B4A80 *)A_48;\n  return retstr;\n}", "binary": "vectors-3d/vectors-3d.host.O0", "assembly": "<get_cross_matrix>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %rdi,-0x68(%rbp)\nmov    %rsi,-0x70(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nxor    %eax,%eax\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x60(%rbp)\nmov    -0x70(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmovq   0x3a71(%rip),%xmm1\nxorpd  %xmm1,%xmm0\nmovsd  %xmm0,-0x58(%rbp)\nmov    -0x70(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmovsd  %xmm0,-0x50(%rbp)\nmov    -0x70(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmovsd  %xmm0,-0x48(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmov    -0x70(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovq   0x3a33(%rip),%xmm1\nxorpd  %xmm1,%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmov    -0x70(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmovq   0x3a19(%rip),%xmm1\nxorpd  %xmm1,%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nmov    -0x70(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\npxor   %xmm0,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x68(%rbp),%rax\nmov    -0x60(%rbp),%rcx\nmov    -0x58(%rbp),%rbx\nmov    %rcx,(%rax)\nmov    %rbx,0x8(%rax)\nmov    -0x50(%rbp),%rcx\nmov    -0x48(%rbp),%rbx\nmov    %rcx,0x10(%rax)\nmov    %rbx,0x18(%rax)\nmov    -0x40(%rbp),%rcx\nmov    -0x38(%rbp),%rbx\nmov    %rcx,0x20(%rax)\nmov    %rbx,0x28(%rax)\nmov    -0x30(%rbp),%rcx\nmov    -0x28(%rbp),%rbx\nmov    %rcx,0x30(%rax)\nmov    %rbx,0x38(%rax)\nmov    -0x20(%rbp),%rdx\nmov    %rdx,0x40(%rax)\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1715 <get_cross_matrix+0x114>\ncall   10b0 <__stack_chk_fail@plt>\nmov    -0x68(%rbp),%rax\nmov    -0x8(%rbp),%rbx\nleave\nret\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "main", "content": "/**\n * @brief Main function\n *\n * @return 0 on exit\n */\nint main(void)\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O0.pseudo", "function_name": "main", "address": "0x1b9f", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  test();\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "vectors-3d/vectors-3d.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    $0x0,%eax\ncall   17fb <test>\ncall   48bc <libmin_success>\nmov    $0x0,%eax\npop    %rbp\nret\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "print_vector", "content": "/**\n * Print formatted vector on stdout.\n * @param[in] a vector to print\n * @param[in] name  name of the vector\n * @returns string representation of vector\n */\nconst char *print_vector(const vec_3d *a, const char *name)\n{\n    static char vec_str[100];  // static to ensure the string life extends the\n                               // life of function\n\n    libmin_snprintf(vec_str, 99, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x,\n             a->y, a->z);\n    return vec_str;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O0.pseudo", "function_name": "print_vector", "address": "0x144f", "label": "print_vector", "content": "const char *__cdecl print_vector(const vec_3d *a, const char *name)\n{\n  libmin_snprintf(vec_str_0, 0x63uLL, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x, a->y, a->z);\n  return vec_str_0;\n}\n"}, "pseudo_normalize": "const char *print_vector(const vec_3d *a, const char *name) {\n  libmin_snprintf(vec_str_0, 99uLL,\n                  \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x,\n                  a->y, a->z);\n  return vec_str_0;\n}", "binary": "vectors-3d/vectors-3d.host.O0", "assembly": "<print_vector>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    %rsi,-0x10(%rbp)\nmov    -0x8(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmov    -0x8(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmov    -0x8(%rbp),%rax\nmov    (%rax),%rdx\nmov    -0x10(%rbp),%rax\nmovapd %xmm1,%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rdx,%xmm0\nmov    %rax,%rcx\nlea    0x3b79(%rip),%rax\nmov    %rax,%rdx\nmov    $0x63,%esi\nlea    0x5dda(%rip),%rax\nmov    %rax,%rdi\nmov    $0x3,%eax\ncall   4407 <libmin_snprintf>\nlea    0x5dc6(%rip),%rax\nleave\nret\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "test", "content": "/** @} */\n\n/**\n * @brief Testing function\n * @returns `void`\n */\nstatic void test()\n{\n    vec_3d a = {1., 2., 3.};\n    vec_3d b = {1., 1., 1.};\n    double d;\n\n    libmin_printf(\"%s\", print_vector(&a, \"a\"));\n    libmin_printf(\"%s\", print_vector(&b, \"b\"));\n\n    d = vector_norm(&a);\n    libmin_printf(\"|a| = %.4lf\\n\", d);\n    libmin_assert(libmin_fabs(d - 3.742) < 0.01);\n    d = vector_norm(&b);\n    libmin_printf(\"|b| = %.4lf\\n\", d);\n    libmin_assert(libmin_fabs(d - 1.732) < 0.01);\n\n    d = dot_prod(&a, &b);\n    libmin_printf(\"Dot product: %lf\\n\", d);\n    libmin_assert(libmin_fabs(d - 6.0) < 0.01);\n\n    vec_3d c = vector_prod(&a, &b);\n    libmin_printf(\"Vector product \");\n    libmin_printf(\"%s\", print_vector(&c, \"c\"));\n    libmin_assert(libmin_fabs(c.x - (-1.0)) < 0.01);\n    libmin_assert(libmin_fabs(c.y - (2.0)) < 0.01);\n    libmin_assert(libmin_fabs(c.z - (-1.0)) < 0.01);\n\n    double alpha = get_angle(&a, &b);\n    libmin_printf(\"The angle is %lf\\n\", alpha);\n    libmin_assert(libmin_fabs(alpha - 0.387597) < 0.01);\n\n    libmin_printf(\"All tests passed!\\n\");\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O0.pseudo", "function_name": "test", "address": "0x17fb", "label": "test", "content": "void __cdecl test()\n{\n  const char *v0; // rax\n  const char *v1; // rax\n  const char *v2; // rax\n  double d; // [rsp+0h] [rbp-70h]\n  double da; // [rsp+0h] [rbp-70h]\n  double db; // [rsp+0h] [rbp-70h]\n  double alpha; // [rsp+8h] [rbp-68h]\n  vec_3d a; // [rsp+10h] [rbp-60h] BYREF\n  vec_3d b; // [rsp+30h] [rbp-40h] BYREF\n  vec_3d c; // [rsp+50h] [rbp-20h] BYREF\n  unsigned __int64 v10; // [rsp+68h] [rbp-8h]\n\n  v10 = __readfsqword(0x28u);\n  a.x = 1.0;\n  a.y = 2.0;\n  a.z = 3.0;\n  b.x = 1.0;\n  b.y = 1.0;\n  b.z = 1.0;\n  v0 = print_vector(&a, \"a\");\n  libmin_printf(\"%s\", v0);\n  v1 = print_vector(&b, \"b\");\n  libmin_printf(\"%s\", v1);\n  d = vector_norm(&a);\n  libmin_printf(\"|a| = %.4lf\\n\", d);\n  if ( libmin_fabs(d - 3.742) >= 0.01 )\n    libmin_fail(1);\n  da = vector_norm(&b);\n  libmin_printf(\"|b| = %.4lf\\n\", da);\n  if ( libmin_fabs(da - 1.732) >= 0.01 )\n    libmin_fail(1);\n  db = dot_prod(&a, &b);\n  libmin_printf(\"Dot product: %lf\\n\", db);\n  if ( libmin_fabs(db - 6.0) >= 0.01 )\n    libmin_fail(1);\n  vector_prod(&c, &a, &b);\n  libmin_printf(\"Vector product \");\n  v2 = print_vector(&c, \"c\");\n  libmin_printf(\"%s\", v2);\n  if ( libmin_fabs(c.x + 1.0) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(c.y - 2.0) >= 0.01 )\n    libmin_fail(1);\n  if ( libmin_fabs(c.z + 1.0) >= 0.01 )\n    libmin_fail(1);\n  alpha = get_angle(&a, &b);\n  libmin_printf(\"The angle is %lf\\n\", alpha);\n  if ( libmin_fabs(alpha - 0.387597) >= 0.01 )\n    libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}\n"}, "pseudo_normalize": "void test() {\n  const char *v0;\n  const char *v1;\n  const char *v2;\n  double d;\n  double da;\n  double db;\n  double alpha;\n  vec_3d a;\n  vec_3d b;\n  vec_3d c;\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  a.x = 1.0;\n  a.y = 2.0;\n  a.z = 3.0;\n  b.x = 1.0;\n  b.y = 1.0;\n  b.z = 1.0;\n  v0 = print_vector(&a, \"a\");\n  libmin_printf(\"%s\", v0);\n  v1 = print_vector(&b, \"b\");\n  libmin_printf(\"%s\", v1);\n  d = vector_norm(&a);\n  libmin_printf(\"|a| = %.4lf\\n\", d);\n  if (libmin_fabs(d - 3.742) >= 0.01) libmin_fail(1);\n  da = vector_norm(&b);\n  libmin_printf(\"|b| = %.4lf\\n\", da);\n  if (libmin_fabs(da - 1.732) >= 0.01) libmin_fail(1);\n  db = dot_prod(&a, &b);\n  libmin_printf(\"Dot product: %lf\\n\", db);\n  if (libmin_fabs(db - 6.0) >= 0.01) libmin_fail(1);\n  vector_prod(&c, &a, &b);\n  libmin_printf(\"Vector product \");\n  v2 = print_vector(&c, \"c\");\n  libmin_printf(\"%s\", v2);\n  if (libmin_fabs(c.x + 1.0) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(c.y - 2.0) >= 0.01) libmin_fail(1);\n  if (libmin_fabs(c.z + 1.0) >= 0.01) libmin_fail(1);\n  alpha = get_angle(&a, &b);\n  libmin_printf(\"The angle is %lf\\n\", alpha);\n  if (libmin_fabs(alpha - 0.387597) >= 0.01) libmin_fail(1);\n  libmin_printf(\"All tests passed!\\n\");\n}", "binary": "vectors-3d/vectors-3d.host.O0", "assembly": "<test>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x70,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovsd  0x38aa(%rip),%xmm0\nmovsd  %xmm0,-0x60(%rbp)\nmovsd  0x38ad(%rip),%xmm0\nmovsd  %xmm0,-0x58(%rbp)\nmovsd  0x38a8(%rip),%xmm0\nmovsd  %xmm0,-0x50(%rbp)\nmovsd  0x3883(%rip),%xmm0\nmovsd  %xmm0,-0x40(%rbp)\nmovsd  0x3876(%rip),%xmm0\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  0x3869(%rip),%xmm0\nmovsd  %xmm0,-0x30(%rbp)\nlea    -0x60(%rbp),%rax\nlea    0x37cb(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   144f <print_vector>\nmov    %rax,%rsi\nlea    0x37b8(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   42d8 <libmin_printf>\nlea    -0x40(%rbp),%rax\nlea    0x37a3(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   144f <print_vector>\nmov    %rax,%rsi\nlea    0x378b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   42d8 <libmin_printf>\nlea    -0x60(%rbp),%rax\nmov    %rax,%rdi\ncall   14bc <vector_norm>\nmovq   %xmm0,%rax\nmov    %rax,-0x70(%rbp)\nmov    -0x70(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x375e(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   42d8 <libmin_printf>\nmovsd  -0x70(%rbp),%xmm0\nmovsd  0x37eb(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x37d8(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1928 <test+0x12d>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nlea    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   14bc <vector_norm>\nmovq   %xmm0,%rax\nmov    %rax,-0x70(%rbp)\nmov    -0x70(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x3701(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   42d8 <libmin_printf>\nmovsd  -0x70(%rbp),%xmm0\nmovsd  0x3791(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x376e(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1992 <test+0x197>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nlea    -0x40(%rbp),%rdx\nlea    -0x60(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   12f1 <dot_prod>\nmovq   %xmm0,%rax\nmov    %rax,-0x70(%rbp)\nmov    -0x70(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x369d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   42d8 <libmin_printf>\nmovsd  -0x70(%rbp),%xmm0\nmovsd  0x3728(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x36fd(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1a03 <test+0x208>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nlea    -0x20(%rbp),%rax\nlea    -0x40(%rbp),%rdx\nlea    -0x60(%rbp),%rcx\nmov    %rcx,%rsi\nmov    %rax,%rdi\ncall   1373 <vector_prod>\nlea    0x364c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   42d8 <libmin_printf>\nlea    -0x20(%rbp),%rax\nlea    0x3644(%rip),%rdx\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   144f <print_vector>\nmov    %rax,%rsi\nlea    0x35ee(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   42d8 <libmin_printf>\nmovsd  -0x20(%rbp),%xmm1\nmovsd  0x3660(%rip),%xmm0\naddsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x366d(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1a93 <test+0x298>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nmovsd  -0x18(%rbp),%xmm0\nmovsd  0x3638(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x3635(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1acb <test+0x2d0>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nmovsd  -0x10(%rbp),%xmm1\nmovsd  0x35f0(%rip),%xmm0\naddsd  %xmm0,%xmm1\nmovq   %xmm1,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x35fd(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1b03 <test+0x308>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nlea    -0x40(%rbp),%rdx\nlea    -0x60(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   171f <get_angle>\nmovq   %xmm0,%rax\nmov    %rax,-0x68(%rbp)\nmov    -0x68(%rbp),%rax\nmovq   %rax,%xmm0\nlea    0x3550(%rip),%rax\nmov    %rax,%rdi\nmov    $0x1,%eax\ncall   42d8 <libmin_printf>\nmovsd  -0x68(%rbp),%xmm0\nmovsd  0x35bf(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x358c(%rip),%xmm1\ncomisd %xmm0,%xmm1\nja     1b74 <test+0x379>\nmov    $0x1,%edi\ncall   22ac <libmin_fail>\nlea    0x3516(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   42d8 <libmin_printf>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     1b9d <test+0x3a2>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "unit_vec", "content": "/**\n * Obtain unit vector in the same direction as given vector.\n * @f[\\hat{a}=\\frac{\\vec{a}}{\\lVert\\vec{a}\\rVert}@f]\n * @param[in] a input vector\n * @returns n unit vector in the direction of @f$\\vec{a}@f$\n */\nvec_3d unit_vec(const vec_3d *a)\n{\n    vec_3d n = {0};\n\n    double norm = vector_norm(a);\n    if (libmin_fabs(norm) < EPSILON)\n    {  // detect possible divide by 0\n        return n;\n    }\n\n    if (norm != 1.0)  // perform division only if needed\n    {\n        n.x = a->x / norm;\n        n.y = a->y / norm;\n        n.z = a->z / norm;\n    }\n    return n;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O0.pseudo", "function_name": "unit_vec", "address": "0x1510", "label": "unit_vec", "content": "vec_3d *__cdecl unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a)\n{\n  double norm; // [rsp+18h] [rbp-28h]\n  vec_3d n; // [rsp+20h] [rbp-20h] BYREF\n\n  memset(&n, 0, sizeof(n));\n  norm = vector_norm(a);\n  if ( libmin_fabs(norm) >= 0.000000001 )\n  {\n    if ( norm != 1.0 )\n    {\n      n.x = a->x / norm;\n      n.y = a->y / norm;\n      n.z = a->z / norm;\n    }\n    *retstr = n;\n  }\n  else\n  {\n    retstr->x = 0.0;\n    retstr->y = 0.0;\n    retstr->z = 0.0;\n  }\n  return retstr;\n}\n"}, "pseudo_normalize": "vec_3d *unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a) {\n  double norm;\n  vec_3d n;\n  memset(&n, 0, sizeof(n));\n  norm = vector_norm(a);\n  if (libmin_fabs(norm) >= 0.000000001) {\n    if (norm != 1.0) {\n      n.x = a->x / norm;\n      n.y = a->y / norm;\n      n.z = a->z / norm;\n    }\n    *retstr = n;\n  } else {\n    retstr->x = 0.0;\n    retstr->y = 0.0;\n    retstr->z = 0.0;\n  }\n  return retstr;\n}", "binary": "vectors-3d/vectors-3d.host.O0", "assembly": "<unit_vec>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x40,%rsp\nmov    %rdi,-0x38(%rbp)\nmov    %rsi,-0x40(%rbp)\nmovq   $0x0,-0x20(%rbp)\nmovq   $0x0,-0x18(%rbp)\nmovq   $0x0,-0x10(%rbp)\nmov    -0x40(%rbp),%rax\nmov    %rax,%rdi\ncall   14bc <vector_norm>\nmovq   %xmm0,%rax\nmov    %rax,-0x28(%rbp)\nmov    -0x28(%rbp),%rax\nmovq   %rax,%xmm0\ncall   2246 <libmin_fabs>\nmovsd  0x3b59(%rip),%xmm1\ncomisd %xmm0,%xmm1\njbe    158a <unit_vec+0x7a>\nmov    -0x38(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\njmp    15fb <unit_vec+0xeb>\nmovsd  0x3b36(%rip),%xmm0\nucomisd -0x28(%rbp),%xmm0\njp     15a8 <unit_vec+0x98>\nmovsd  0x3b27(%rip),%xmm0\nucomisd -0x28(%rbp),%xmm0\nje     15e0 <unit_vec+0xd0>\nmov    -0x40(%rbp),%rax\nmovsd  (%rax),%xmm0\ndivsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x40(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\ndivsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x40(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\ndivsd  -0x28(%rbp),%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x38(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\nmov    -0x38(%rbp),%rax\nleave\nret\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "vector_add", "content": "/**\n * Add one vector to another. @f[\n * \\vec{c}=\\vec{a}+\\vec{b}=\\left(a_x+b_x\\right)\\hat{i}+\n * \\left(a_y+b_y\\right)\\hat{j}+\\left(a_z+b_z\\right)\\hat{k}@f]\n * @param[in] a vector to add to\n * @param[in] b vector to add\n * @returns resultant vector\n */\nvec_3d vector_add(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;\n    out.x = a->x + b->x;\n    out.y = a->y + b->y;\n    out.z = a->z + b->z;\n\n    return out;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O0.pseudo", "function_name": "vector_add", "address": "0x126d", "label": "vector_add", "content": "vec_3d *__cdecl vector_add(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  double v3; // rdx\n  double out; // [rsp+18h] [rbp-20h]\n  double out_16; // [rsp+28h] [rbp-10h]\n\n  out = b->x + a->x;\n  out_16 = b->z + a->z;\n  v3 = b->y + a->y;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}\n"}, "pseudo_normalize": "vec_3d *vector_add(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  double v3;\n  double out;\n  double out_16;\n  out = b->x + a->x;\n  out_16 = b->z + a->z;\n  v3 = b->y + a->y;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}", "binary": "vectors-3d/vectors-3d.host.O0", "assembly": "<vector_add>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\nmov    -0x28(%rbp),%rax\npop    %rbp\nret\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "vector_norm", "content": "/**\n * Compute the norm a vector.\n * @f[\\lVert\\vec{a}\\rVert = \\sqrt{\\vec{a}\\cdot\\vec{a}} @f]\n * @param[in] a input vector\n * @returns norm of the given vector\n */\ndouble vector_norm(const vec_3d *a)\n{\n    double n = dot_prod(a, a);\n    n = libmin_sqrt(n);\n\n    return n;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O0.pseudo", "function_name": "vector_norm", "address": "0x14bc", "label": "vector_norm", "content": "double __cdecl vector_norm(const vec_3d *a)\n{\n  double v1; // xmm0_8\n\n  v1 = dot_prod(a, a);\n  return libmin_sqrt(v1);\n}\n"}, "pseudo_normalize": "", "binary": "vectors-3d/vectors-3d.host.O0", "assembly": "<vector_norm>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x20,%rsp\nmov    %rdi,-0x18(%rbp)\nmov    -0x18(%rbp),%rdx\nmov    -0x18(%rbp),%rax\nmov    %rdx,%rsi\nmov    %rax,%rdi\ncall   12f1 <dot_prod>\nmovq   %xmm0,%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmovq   %rax,%xmm0\ncall   4507 <libmin_sqrt>\nmovq   %xmm0,%rax\nmov    %rax,-0x8(%rbp)\nmovsd  -0x8(%rbp),%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "vector_prod", "content": "/**\n * Compute the vector product of two 3d vectors.\n * @f[\\begin{align*}\n * \\vec{a}\\times\\vec{b} &= \\begin{vmatrix}\n *  \\hat{i} & \\hat{j} & \\hat{k}\\\\\n *  a_x & a_y & a_z\\\\\n *  b_x & b_y & b_z\n *  \\end{vmatrix}\\\\\n *  &= \\left(a_yb_z-b_ya_z\\right)\\hat{i} - \\left(a_xb_z-b_xa_z\\right)\\hat{j}\n * + \\left(a_xb_y-b_xa_y\\right)\\hat{k} \\end{align*}\n * @f]\n * @param[in] a first vector @f$\\vec{a}@f$\n * @param[in] b second vector @f$\\vec{b}@f$\n * @returns resultant vector @f$\\vec{o}=\\vec{a}\\times\\vec{b}@f$\n */\nvec_3d vector_prod(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;  // better this way to avoid copying results to input\n                 // vectors themselves\n    out.x = a->y * b->z - a->z * b->y;\n    out.y = -a->x * b->z + a->z * b->x;\n    out.z = a->x * b->y - a->y * b->x;\n\n    return out;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O0.pseudo", "function_name": "vector_prod", "address": "0x1373", "label": "vector_prod", "content": "vec_3d *__cdecl vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  double v3; // rdx\n  double out; // [rsp+18h] [rbp-20h]\n  double out_16; // [rsp+28h] [rbp-10h]\n\n  out = b->z * a->y - b->y * a->z;\n  out_16 = b->y * a->x - b->x * a->y;\n  v3 = b->x * a->z + -a->x * b->z;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}\n"}, "pseudo_normalize": "vec_3d *vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a,\n                    const vec_3d *b) {\n  double v3;\n  double out;\n  double out_16;\n  out = b->z * a->y - b->y * a->z;\n  out_16 = b->y * a->x - b->x * a->y;\n  v3 = b->x * a->z + -a->x * b->z;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}", "binary": "vectors-3d/vectors-3d.host.O0", "assembly": "<vector_prod>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nmulsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm0\nmovq   0x3ce4(%rip),%xmm1\nxorpd  %xmm0,%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmulsd  %xmm0,%xmm1\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm1\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm2\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm1\nmulsd  %xmm2,%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\nmov    -0x28(%rbp),%rax\npop    %rbp\nret\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "vector_sub", "content": "/**\n * @addtogroup vec_3d 3D Vector operations\n * @{\n */\n\n/**\n * Subtract one vector from another. @f[\n * \\vec{c}=\\vec{a}-\\vec{b}=\\left(a_x-b_x\\right)\\hat{i}+\n * \\left(a_y-b_y\\right)\\hat{j}+\\left(a_z-b_z\\right)\\hat{k}@f]\n * @param[in] a vector to subtract from\n * @param[in] b vector to subtract\n * @returns resultant vector\n */\nvec_3d vector_sub(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;\n    out.x = a->x - b->x;\n    out.y = a->y - b->y;\n    out.z = a->z - b->z;\n\n    return out;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O0.pseudo", "function_name": "vector_sub", "address": "0x11e9", "label": "vector_sub", "content": "vec_3d *__cdecl vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  double v3; // rdx\n  double out; // [rsp+18h] [rbp-20h]\n  double out_16; // [rsp+28h] [rbp-10h]\n\n  out = a->x - b->x;\n  out_16 = a->z - b->z;\n  v3 = a->y - b->y;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}\n"}, "pseudo_normalize": "vec_3d *vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  double v3;\n  double out;\n  double out_16;\n  out = a->x - b->x;\n  out_16 = a->z - b->z;\n  v3 = a->y - b->y;\n  retstr->x = out;\n  retstr->y = v3;\n  retstr->z = out_16;\n  return retstr;\n}", "binary": "vectors-3d/vectors-3d.host.O0", "assembly": "<vector_sub>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x28(%rbp)\nmov    %rsi,-0x30(%rbp)\nmov    %rdx,-0x38(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  (%rax),%xmm0\nmov    -0x38(%rbp),%rax\nmovsd  (%rax),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x20(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  0x8(%rax),%xmm0\nmov    -0x38(%rbp),%rax\nmovsd  0x8(%rax),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nmov    -0x30(%rbp),%rax\nmovsd  0x10(%rax),%xmm0\nmov    -0x38(%rbp),%rax\nmovsd  0x10(%rax),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x28(%rbp),%rcx\nmov    -0x20(%rbp),%rax\nmov    -0x18(%rbp),%rdx\nmov    %rax,(%rcx)\nmov    %rdx,0x8(%rcx)\nmov    -0x10(%rbp),%rax\nmov    %rax,0x10(%rcx)\nmov    -0x28(%rbp),%rax\npop    %rbp\nret\n"}
{"source": {"path": "verlet/verlet.c", "function_name": "main", "content": " /* for NO_STDIO mode */\n\nint main(void) {\n  vb_init();\n\n  for (int s = 0; s < VB_STEPS; ++s) {\n    vb_step_avg((VB_FP)VB_DT);\n  }\n  uint64_t sum = vb_checksum();\n\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\",\n         VB_N, VB_STEPS, (double)VB_DT, (double)VB_K, VB_DIM,\n         (sizeof(VB_FP)==sizeof(double)) ? \"double\" : \"float\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", (uint32_t)((sum >> 32)), (uint32_t)(sum & (uint32_t)0xffffffffU));\n\n  libmin_success();\n}\n"}, "pseudo": {"path": "verlet/verlet.host.O0.pseudo", "function_name": "main", "address": "0x170b", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int s; // [rsp+4h] [rbp-Ch]\n  uint64_t sum; // [rsp+8h] [rbp-8h]\n\n  vb_init();\n  for ( s = 0; s <= 49; ++s )\n    vb_step_avg(0.001);\n  sum = vb_checksum();\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50, 0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(sum), sum);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int s;\n  uint64_t sum;\n  vb_init();\n  for (s = 0; s <= 49; ++s) vb_step_avg(0.001);\n  sum = vb_checksum();\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50,\n                0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(sum), sum);\n  libmin_success();\n}", "binary": "verlet/verlet.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x10,%rsp\ncall   1271 <vb_init>\nmovl   $0x0,-0xc(%rbp)\njmp    173a <main+0x2f>\nmov    0x295c(%rip),%rax\nmovq   %rax,%xmm0\ncall   13aa <vb_step_avg>\naddl   $0x1,-0xc(%rbp)\ncmpl   $0x31,-0xc(%rbp)\njle    1725 <main+0x1a>\ncall   160b <vb_checksum>\nmov    %rax,-0x8(%rbp)\nmovsd  0x293f(%rip),%xmm0\nmov    0x2930(%rip),%rax\nlea    0x28a9(%rip),%r8\nmov    $0x2,%ecx\nmovapd %xmm0,%xmm1\nmovq   %rax,%xmm0\nmov    $0x32,%edx\nmov    $0x80,%esi\nlea    0x2892(%rip),%rax\nmov    %rax,%rdi\nmov    $0x2,%eax\ncall   38f7 <libmin_printf>\nmov    -0x8(%rbp),%rax\nmov    %eax,%edx\nmov    -0x8(%rbp),%rax\nshr    $0x20,%rax\nmov    %eax,%esi\nlea    0x289f(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   38f7 <libmin_printf>\ncall   3b64 <libmin_success>\nmov    $0x0,%eax\nleave\nret\n"}
{"source": {"path": "verlet/verlet.c", "function_name": "vb_checksum", "content": "/* ---------------- Checksum for correctness ---------------- */\nstatic uint64_t vb_checksum(void) {\n  /* Mix positions and velocities into a 64-bit hash in a stable way. */\n  const VB_FP scale = (VB_FP)1e6; /* scale to stabilize floating rounding in cast */\n  uint64_t h = 0xcbf29ce484222325ULL; /* FNV-ish seed */\n  for (int i = 0; i < VB_N * VB_DIM; ++i) {\n    int64_t xi = (int64_t)(x[i] * scale);\n    int64_t vi = (int64_t)(v[i] * scale);\n    uint64_t ux = (uint64_t)xi;\n    uint64_t uv = (uint64_t)vi;\n    h ^= ux + 0x9e3779b97f4a7c15ULL + (h << 6) + (h >> 2);\n    h ^= uv + 0x9e3779b97f4a7c15ULL + (h << 6) + (h >> 2);\n  }\n  return h;\n}\n"}, "pseudo": {"path": "verlet/verlet.host.O0.pseudo", "function_name": "vb_checksum", "address": "0x160b", "label": "vb_checksum", "content": "uint64_t __cdecl vb_checksum()\n{\n  int i; // [rsp+0h] [rbp-34h]\n  unsigned __int64 h; // [rsp+4h] [rbp-30h]\n  uint64_t ha; // [rsp+4h] [rbp-30h]\n\n  h = 0xCBF29CE484222325LL;\n  for ( i = 0; i <= 255; ++i )\n  {\n    ha = ((h >> 2) + (unsigned int)(int)(x[i] * 1000000.0) + (h << 6) - 0x61C8864680B583EBLL) ^ h;\n    h = ((ha >> 2) + (unsigned int)(int)(v[i] * 1000000.0) + (ha << 6) - 0x61C8864680B583EBLL) ^ ha;\n  }\n  return h;\n}\n"}, "pseudo_normalize": "uint64_t vb_checksum() {\n  int i;\n  unsigned long long h;\n  uint64_t ha;\n  h = 14695981039346656037LL;\n  for (i = 0; i <= 255; ++i) {\n    ha = ((h >> 2) + (unsigned int)(int)(x[i] * 1000000.0) + (h << 6) -\n          7046029254386353131LL) ^\n         h;\n    h = ((ha >> 2) + (unsigned int)(int)(v[i] * 1000000.0) + (ha << 6) -\n         7046029254386353131LL) ^\n        ha;\n  }\n  return h;\n}", "binary": "verlet/verlet.host.O0", "assembly": "<vb_checksum>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovsd  0x2a65(%rip),%xmm0\nmovsd  %xmm0,-0x28(%rbp)\nmovabs $0xcbf29ce484222325,%rax\nmov    %rax,-0x30(%rbp)\nmovl   $0x0,-0x34(%rbp)\njmp    16f8 <vb_checksum+0xed>\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4c52(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmulsd  -0x28(%rbp),%xmm0\ncvttsd2si %xmm0,%rax\nmov    %rax,-0x20(%rbp)\nmov    -0x34(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x542b(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmulsd  -0x28(%rbp),%xmm0\ncvttsd2si %xmm0,%rax\nmov    %rax,-0x18(%rbp)\nmov    -0x20(%rbp),%rax\nmov    %rax,-0x10(%rbp)\nmov    -0x18(%rbp),%rax\nmov    %rax,-0x8(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x6,%rax\nmov    %rax,%rdx\nmov    -0x10(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x30(%rbp),%rax\nshr    $0x2,%rax\nadd    %rax,%rdx\nmovabs $0x9e3779b97f4a7c15,%rax\nadd    %rdx,%rax\nxor    %rax,-0x30(%rbp)\nmov    -0x30(%rbp),%rax\nshl    $0x6,%rax\nmov    %rax,%rdx\nmov    -0x8(%rbp),%rax\nadd    %rax,%rdx\nmov    -0x30(%rbp),%rax\nshr    $0x2,%rax\nadd    %rax,%rdx\nmovabs $0x9e3779b97f4a7c15,%rax\nadd    %rdx,%rax\nxor    %rax,-0x30(%rbp)\naddl   $0x1,-0x34(%rbp)\ncmpl   $0xff,-0x34(%rbp)\njle    163a <vb_checksum+0x2f>\nmov    -0x30(%rbp),%rax\npop    %rbp\nret\n"}
{"source": {"path": "verlet/verlet.c", "function_name": "vb_init", "content": "   /* accelerations */\n\n/* ---------------- Physics kernel ----------------\n   Force model: independent harmonic wells, per coordinate:\n     a = -k * x\n   Integration (position-Verlet + velocity update):\n     x(t+dt) = x(t) + v(t)*dt + 0.5*a(t)*dt^2\n     a(t+dt) = -k * x(t+dt)\n     v(t+dt) = v(t) + 0.5*(a(t) + a(t+dt))*dt\n*/\nstatic void vb_init(void) {\n  uint32_t rng = 0x12345678u;\n  for (int i = 0; i < VB_N; ++i) {\n    for (int d = 0; d < VB_DIM; ++d) {\n      VB_FP px = (vb_urand(&rng) * (VB_FP)2.0 - (VB_FP)1.0);  /* [-1, 1) */\n      VB_FP pv = (vb_urand(&rng) * (VB_FP)2.0 - (VB_FP)1.0);\n      x[i*VB_DIM + d] = px;\n      v[i*VB_DIM + d] = pv * (VB_FP)0.1;                      /* smaller initial v */\n      a[i*VB_DIM + d] = (VB_FP)(-VB_K) * px;\n    }\n#if VB_DIM < 3\n    /* nothing: arrays sized by VB_DIM */\n#endif\n  }\n}\n"}, "pseudo": {"path": "verlet/verlet.host.O0.pseudo", "function_name": "vb_init", "address": "0x1271", "label": "vb_init", "content": "void __cdecl vb_init()\n{\n  double v0; // xmm0_8\n  double v1; // xmm0_8\n  uint32_t rng; // [rsp+Ch] [rbp-24h] BYREF\n  int i; // [rsp+10h] [rbp-20h]\n  int d; // [rsp+14h] [rbp-1Ch]\n  double px; // [rsp+18h] [rbp-18h]\n  double pv; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v7; // [rsp+28h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  rng = 305419896;\n  for ( i = 0; i <= 127; ++i )\n  {\n    for ( d = 0; d <= 1; ++d )\n    {\n      v0 = vb_urand(&rng);\n      px = v0 + v0 - 1.0;\n      v1 = vb_urand(&rng);\n      pv = v1 + v1 - 1.0;\n      x[2 * i + d] = px;\n      v[2 * i + d] = 0.1 * pv;\n      a[2 * i + d] = -5.0 * px;\n    }\n  }\n}\n"}, "pseudo_normalize": "void vb_init() {\n  double v0;\n  double v1;\n  uint32_t rng;\n  int i;\n  int d;\n  double px;\n  double pv;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  rng = 305419896;\n  for (i = 0; i <= 127; ++i) {\n    for (d = 0; d <= 1; ++d) {\n      v0 = vb_urand(&rng);\n      px = v0 + v0 - 1.0;\n      v1 = vb_urand(&rng);\n      pv = v1 + v1 - 1.0;\n      x[2 * i + d] = px;\n      v[2 * i + d] = 0.1 * pv;\n      a[2 * i + d] = -5.0 * px;\n    }\n  }\n}", "binary": "verlet/verlet.host.O0", "assembly": "<vb_init>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x30,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x12345678,-0x24(%rbp)\nmovl   $0x0,-0x20(%rbp)\njmp    1389 <vb_init+0x118>\nmovl   $0x0,-0x1c(%rbp)\njmp    137b <vb_init+0x10a>\nlea    -0x24(%rbp),%rax\nmov    %rax,%rdi\ncall   1211 <vb_urand>\naddsd  %xmm0,%xmm0\nmovsd  0x2d9d(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%rbp)\nlea    -0x24(%rbp),%rax\nmov    %rax,%rdi\ncall   1211 <vb_urand>\naddsd  %xmm0,%xmm0\nmovsd  0x2d7c(%rip),%xmm1\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rbp)\nmov    -0x20(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4f97(%rip),%rax\nmovsd  -0x18(%rbp),%xmm0\nmovsd  %xmm0,(%rdx,%rax,1)\nmov    -0x20(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nmovsd  -0x10(%rbp),%xmm1\nmovsd  0x2d3d(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5760(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\nmov    -0x20(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x1c(%rbp),%eax\nadd    %edx,%eax\nmovsd  -0x18(%rbp),%xmm1\nmovsd  0x2d13(%rip),%xmm0\nmulsd  %xmm1,%xmm0\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5f2e(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x1,-0x1c(%rbp)\njle    12ab <vb_init+0x3a>\naddl   $0x1,-0x20(%rbp)\ncmpl   $0x7f,-0x20(%rbp)\njle    129f <vb_init+0x2e>\nnop\nmov    -0x8(%rbp),%rax\nsub    %fs:0x28,%rax\nje     13a8 <vb_init+0x137>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "verlet/verlet.c", "function_name": "vb_lcg", "content": "/*\n * verlet.c\n *\n * Minimal Verlet integration benchmark (2D harmonic oscillators).\n * - Deterministic init (fixed LCG seed)\n * - Tunable problem size via macros\n * - No malloc; static storage\n * - Optional timing via RISC-V rdcycle or portable fallbacks\n * - Produces a simple checksum to verify determinism\n *\n * You can compile this as freestanding or hosted. If printf is unavailable,\n * define NO_STDIO and the code will avoid it (writes checksum to a volatile).\n */\n\n#include \"libmin.h\"\n\n/* ---------------- Tunables (override via -D) ---------------- */\n#ifndef VB_N\n#define VB_N  128        /* number of particles */\n#endif\n\n#ifndef VB_STEPS\n#define VB_STEPS  50    /* number of time steps */\n#endif\n\n#ifndef VB_DT\n#define VB_DT  1.0e-3     /* time step */\n#endif\n\n#ifndef VB_K\n#define VB_K   5.0        /* spring constant for a = -k*x */\n#endif\n\n#ifndef VB_DIM\n#define VB_DIM 2          /* 1, 2, or 3 (we store 2D when VB_DIM==2) */\n#endif\n\n#ifndef VB_FP\n#define VB_FP double      /* float or double */\n#endif\n\n/* ---------------- Deterministic pseudo-random init ---------------- */\nstatic inline uint32_t vb_lcg(uint32_t *state) {\n  /* 32-bit LCG (Numerical Recipes constants) */\n  *state = (*state) * 1664525u + 1013904223u;\n  return *state;\n}\n"}, "pseudo": {"path": "verlet/verlet.host.O0.pseudo", "function_name": "vb_lcg", "address": "0x11e9", "label": "vb_lcg", "content": "uint32_t __cdecl vb_lcg(uint32_t *state)\n{\n  *state = 1664525 * *state + 1013904223;\n  return *state;\n}\n"}, "pseudo_normalize": "", "binary": "verlet/verlet.host.O0", "assembly": "<vb_lcg>:\npush   %rbp\nmov    %rsp,%rbp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\nimul   $0x19660d,%eax,%eax\nlea    0x3c6ef35f(%rax),%edx\nmov    -0x8(%rbp),%rax\nmov    %edx,(%rax)\nmov    -0x8(%rbp),%rax\nmov    (%rax),%eax\npop    %rbp\nret\n"}
{"source": {"path": "verlet/verlet.c", "function_name": "vb_step_avg", "content": "/* Store a_old in a small temp to keep code simple and avoid big memory churn */\nstatic void vb_step_avg(VB_FP dt) {\n  const VB_FP half_dt2 = (VB_FP)0.5 * dt * dt;\n\n  /* 1) save a_old in a temp (stack or static) */\n  static VB_FP a_old[VB_N * VB_DIM];\n  for (int i = 0; i < VB_N * VB_DIM; ++i) a_old[i] = a[i];\n\n  /* 2) x update */\n  for (int i = 0; i < VB_N; ++i) {\n    for (int d = 0; d < VB_DIM; ++d) {\n      int idx = i*VB_DIM + d;\n      x[idx] = x[idx] + v[idx]*dt + a_old[idx]*half_dt2;\n    }\n  }\n\n  /* 3) a_new */\n  for (int i = 0; i < VB_N; ++i) {\n    for (int d = 0; d < VB_DIM; ++d) {\n      int idx = i*VB_DIM + d;\n      a[idx] = (VB_FP)(-VB_K) * x[idx];\n    }\n  }\n\n  /* 4) v update with average accel */\n  for (int i = 0; i < VB_N; ++i) {\n    for (int d = 0; d < VB_DIM; ++d) {\n      int idx = i*VB_DIM + d;\n      v[idx] = v[idx] + ((a_old[idx] + a[idx]) * (VB_FP)0.5) * dt;\n    }\n  }\n}\n"}, "pseudo": {"path": "verlet/verlet.host.O0.pseudo", "function_name": "vb_step_avg", "address": "0x13aa", "label": "vb_step_avg", "content": "void __cdecl vb_step_avg(double dt)\n{\n  int i; // [rsp+8h] [rbp-30h]\n  int i_0; // [rsp+Ch] [rbp-2Ch]\n  int d; // [rsp+10h] [rbp-28h]\n  int i_1; // [rsp+14h] [rbp-24h]\n  int d_0; // [rsp+18h] [rbp-20h]\n  int i_2; // [rsp+1Ch] [rbp-1Ch]\n  int d_1; // [rsp+20h] [rbp-18h]\n\n  for ( i = 0; i <= 255; ++i )\n    a_old_0[i] = a[i];\n  for ( i_0 = 0; i_0 <= 127; ++i_0 )\n  {\n    for ( d = 0; d <= 1; ++d )\n      x[2 * i_0 + d] = a_old_0[2 * i_0 + d] * (0.5 * dt * dt) + x[2 * i_0 + d] + v[2 * i_0 + d] * dt;\n  }\n  for ( i_1 = 0; i_1 <= 127; ++i_1 )\n  {\n    for ( d_0 = 0; d_0 <= 1; ++d_0 )\n      a[2 * i_1 + d_0] = -5.0 * x[2 * i_1 + d_0];\n  }\n  for ( i_2 = 0; i_2 <= 127; ++i_2 )\n  {\n    for ( d_1 = 0; d_1 <= 1; ++d_1 )\n      v[2 * i_2 + d_1] = 0.5 * (a_old_0[2 * i_2 + d_1] + a[2 * i_2 + d_1]) * dt + v[2 * i_2 + d_1];\n  }\n}\n"}, "pseudo_normalize": "void vb_step_avg(double dt) {\n  int i;\n  int i_0;\n  int d;\n  int i_1;\n  int d_0;\n  int i_2;\n  int d_1;\n  for (i = 0; i <= 255; ++i) a_old_0[i] = a[i];\n  for (i_0 = 0; i_0 <= 127; ++i_0) {\n    for (d = 0; d <= 1; ++d)\n      x[2 * i_0 + d] = a_old_0[2 * i_0 + d] * (0.5 * dt * dt) + x[2 * i_0 + d] +\n                       v[2 * i_0 + d] * dt;\n  }\n  for (i_1 = 0; i_1 <= 127; ++i_1) {\n    for (d_0 = 0; d_0 <= 1; ++d_0) a[2 * i_1 + d_0] = -5.0 * x[2 * i_1 + d_0];\n  }\n  for (i_2 = 0; i_2 <= 127; ++i_2) {\n    for (d_1 = 0; d_1 <= 1; ++d_1)\n      v[2 * i_2 + d_1] =\n          0.5 * (a_old_0[2 * i_2 + d_1] + a[2 * i_2 + d_1]) * dt +\n          v[2 * i_2 + d_1];\n  }\n}", "binary": "verlet/verlet.host.O0", "assembly": "<vb_step_avg>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nmovsd  %xmm0,-0x38(%rbp)\nmovsd  -0x38(%rbp),%xmm1\nmovsd  0x2cb4(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  -0x38(%rbp),%xmm1\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rbp)\nmovl   $0x0,-0x30(%rbp)\njmp    1415 <vb_step_avg+0x6b>\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5ead(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmov    -0x30(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x6694(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x30(%rbp)\ncmpl   $0xff,-0x30(%rbp)\njle    13df <vb_step_avg+0x35>\nmovl   $0x0,-0x2c(%rbp)\njmp    14cc <vb_step_avg+0x122>\nmovl   $0x0,-0x28(%rbp)\njmp    14be <vb_step_avg+0x114>\nmov    -0x2c(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x28(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0xc(%rbp)\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4e48(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x562f(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmulsd  -0x38(%rbp),%xmm0\naddsd  %xmm0,%xmm1\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x660d(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\nmulsd  -0x8(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0xc(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4deb(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x28(%rbp)\ncmpl   $0x1,-0x28(%rbp)\njle    1436 <vb_step_avg+0x8c>\naddl   $0x1,-0x2c(%rbp)\ncmpl   $0x7f,-0x2c(%rbp)\njle    142a <vb_step_avg+0x80>\nmovl   $0x0,-0x24(%rbp)\njmp    1542 <vb_step_avg+0x198>\nmovl   $0x0,-0x20(%rbp)\njmp    1538 <vb_step_avg+0x18e>\nmov    -0x24(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x20(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x10(%rbp)\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x4d96(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmovsd  0x2b59(%rip),%xmm0\nmulsd  %xmm1,%xmm0\nmov    -0x10(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5d71(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x20(%rbp)\ncmpl   $0x1,-0x20(%rbp)\njle    14e8 <vb_step_avg+0x13e>\naddl   $0x1,-0x24(%rbp)\ncmpl   $0x7f,-0x24(%rbp)\njle    14df <vb_step_avg+0x135>\nmovl   $0x0,-0x1c(%rbp)\njmp    15fd <vb_step_avg+0x253>\nmovl   $0x0,-0x18(%rbp)\njmp    15ef <vb_step_avg+0x245>\nmov    -0x1c(%rbp),%eax\nlea    (%rax,%rax,1),%edx\nmov    -0x18(%rbp),%eax\nadd    %edx,%eax\nmov    %eax,-0x14(%rbp)\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x551e(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm1\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x6505(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm2\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x5cec(%rip),%rax\nmovsd  (%rdx,%rax,1),%xmm0\naddsd  %xmm0,%xmm2\nmovsd  0x2ab3(%rip),%xmm0\nmulsd  %xmm2,%xmm0\nmulsd  -0x38(%rbp),%xmm0\naddsd  %xmm1,%xmm0\nmov    -0x14(%rbp),%eax\ncltq\nlea    0x0(,%rax,8),%rdx\nlea    0x54ba(%rip),%rax\nmovsd  %xmm0,(%rdx,%rax,1)\naddl   $0x1,-0x18(%rbp)\ncmpl   $0x1,-0x18(%rbp)\njle    1560 <vb_step_avg+0x1b6>\naddl   $0x1,-0x1c(%rbp)\ncmpl   $0x7f,-0x1c(%rbp)\njle    1554 <vb_step_avg+0x1aa>\nnop\nnop\npop    %rbp\nret\n"}
{"source": {"path": "verlet/verlet.c", "function_name": "vb_urand", "content": "static inline VB_FP vb_urand(uint32_t *state) {\n  /* Convert to [0,1) as VB_FP */\n  return (VB_FP)(vb_lcg(state) & 0x00FFFFFFu) / (VB_FP)16777216.0;\n}\n"}, "pseudo": {"path": "verlet/verlet.host.O0.pseudo", "function_name": "vb_urand", "address": "0x1211", "label": "vb_urand", "content": "double __cdecl vb_urand(uint32_t *state)\n{\n  return (double)(vb_lcg(state) & 0xFFFFFF) / 16777216.0;\n}\n"}, "pseudo_normalize": "", "binary": "verlet/verlet.host.O0", "assembly": "<vb_urand>:\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x8,%rsp\nmov    %rdi,-0x8(%rbp)\nmov    -0x8(%rbp),%rax\nmov    %rax,%rdi\ncall   11e9 <vb_lcg>\nand    $0xffffff,%eax\nmov    %eax,%eax\ntest   %rax,%rax\njs     1240 <vb_urand+0x2f>\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\njmp    1259 <vb_urand+0x48>\nmov    %rax,%rdx\nshr    %rdx\nand    $0x1,%eax\nor     %rax,%rdx\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\naddsd  %xmm0,%xmm0\nmovsd  0x2df7(%rip),%xmm1\ndivsd  %xmm1,%xmm0\nmovq   %xmm0,%rax\nmovq   %rax,%xmm0\nleave\nret\n"}
{"source": {"path": "weekday/weekday.c", "function_name": "dayOfWeek", "content": "#include \"libmin.h\"\n\nint\ndayOfWeek(int y, int m, int d)\n{\n  int t[]={0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};\n  y -= (m<3) ? 1 : 0;\n  return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;\n}\n"}, "pseudo": {"path": "weekday/weekday.host.O0.pseudo", "function_name": "dayOfWeek", "address": "0x11e9", "label": "dayOfWeek", "content": "int __cdecl dayOfWeek(int y, int m, int d)\n{\n  int t[14]; // [rsp+10h] [rbp-40h]\n  unsigned __int64 v5; // [rsp+48h] [rbp-8h]\n\n  v5 = __readfsqword(0x28u);\n  t[0] = 0;\n  t[1] = 3;\n  t[2] = 2;\n  t[3] = 5;\n  t[4] = 0;\n  t[5] = 3;\n  t[6] = 5;\n  t[7] = 1;\n  t[8] = 4;\n  t[9] = 6;\n  t[10] = 2;\n  t[11] = 4;\n  return (d + t[m - 1] + (y - (m <= 2)) / -100 + (y - (m <= 2)) / 4 + y - (m <= 2) + (y - (m <= 2)) / 400) % 7;\n}\n"}, "pseudo_normalize": "int dayOfWeek(int y, int m, int d) {\n  int t[14];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  t[0] = 0;\n  t[1] = 3;\n  t[2] = 2;\n  t[3] = 5;\n  t[4] = 0;\n  t[5] = 3;\n  t[6] = 5;\n  t[7] = 1;\n  t[8] = 4;\n  t[9] = 6;\n  t[10] = 2;\n  t[11] = 4;\n  return (d + t[m - 1] + (y - (m <= 2)) / -100 + (y - (m <= 2)) / 4 + y -\n          (m <= 2) + (y - (m <= 2)) / 400) %\n         7;\n}", "binary": "weekday/weekday.host.O0", "assembly": "<dayOfWeek>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %esi,-0x48(%rbp)\nmov    %edx,-0x4c(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nmovl   $0x0,-0x40(%rbp)\nmovl   $0x3,-0x3c(%rbp)\nmovl   $0x2,-0x38(%rbp)\nmovl   $0x5,-0x34(%rbp)\nmovl   $0x0,-0x30(%rbp)\nmovl   $0x3,-0x2c(%rbp)\nmovl   $0x5,-0x28(%rbp)\nmovl   $0x1,-0x24(%rbp)\nmovl   $0x4,-0x20(%rbp)\nmovl   $0x6,-0x1c(%rbp)\nmovl   $0x2,-0x18(%rbp)\nmovl   $0x4,-0x14(%rbp)\ncmpl   $0x2,-0x48(%rbp)\nsetle  %al\nmovzbl %al,%eax\nsub    %eax,-0x44(%rbp)\nmov    -0x44(%rbp),%eax\nlea    0x3(%rax),%edx\ntest   %eax,%eax\ncmovs  %edx,%eax\nsar    $0x2,%eax\nmov    %eax,%edx\nmov    -0x44(%rbp),%eax\nlea    (%rdx,%rax,1),%ecx\nmov    -0x44(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x51eb851f,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x5,%edx\nsar    $0x1f,%eax\nsub    %edx,%eax\nadd    %eax,%ecx\nmov    -0x44(%rbp),%eax\nmovslq %eax,%rdx\nimul   $0x51eb851f,%rdx,%rdx\nshr    $0x20,%rdx\nsar    $0x7,%edx\nsar    $0x1f,%eax\nmov    %eax,%esi\nmov    %edx,%eax\nsub    %esi,%eax\nlea    (%rcx,%rax,1),%edx\nmov    -0x48(%rbp),%eax\nsub    $0x1,%eax\ncltq\nmov    -0x40(%rbp,%rax,4),%eax\nadd    %eax,%edx\nmov    -0x4c(%rbp),%eax\nadd    %eax,%edx\nmovslq %edx,%rax\nimul   $0xffffffff92492493,%rax,%rax\nshr    $0x20,%rax\nadd    %edx,%eax\nsar    $0x2,%eax\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsub    %ecx,%eax\nmov    %eax,%ecx\nshl    $0x3,%ecx\nsub    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     130b <dayOfWeek+0x122>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
{"source": {"path": "weekday/weekday.c", "function_name": "main", "content": "int\nmain(int argc, char** argv)\n{\n  const char *days[7]={\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[dayOfWeek(2024, 2, 20)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[dayOfWeek(1994, 4, 5)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[dayOfWeek(1975, 1, 1)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[dayOfWeek(1964, 2, 7)]);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "weekday/weekday.host.O0.pseudo", "function_name": "main", "address": "0x130d", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int v6; // eax\n  const char *days[7]; // [rsp+10h] [rbp-40h]\n  unsigned __int64 v8; // [rsp+48h] [rbp-8h]\n\n  v8 = __readfsqword(0x28u);\n  days[0] = \"Sunday\";\n  days[1] = \"Monday\";\n  days[2] = \"Tuesday\";\n  days[3] = \"Wednesday\";\n  days[4] = \"Thursday\";\n  days[5] = \"Friday\";\n  days[6] = \"Saturday\";\n  v3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[v3]);\n  v4 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[v4]);\n  v5 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[v5]);\n  v6 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[v6]);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  const char *days[7];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  days[0] = \"Sunday\";\n  days[1] = \"Monday\";\n  days[2] = \"Tuesday\";\n  days[3] = \"Wednesday\";\n  days[4] = \"Thursday\";\n  days[5] = \"Friday\";\n  days[6] = \"Saturday\";\n  v3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[v3]);\n  v4 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[v4]);\n  v5 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[v5]);\n  v6 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[v6]);\n  libmin_success();\n}", "binary": "weekday/weekday.host.O0", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\nsub    $0x50,%rsp\nmov    %edi,-0x44(%rbp)\nmov    %rsi,-0x50(%rbp)\nmov    %fs:0x28,%rax\nmov    %rax,-0x8(%rbp)\nxor    %eax,%eax\nlea    0x2cce(%rip),%rax\nmov    %rax,-0x40(%rbp)\nlea    0x2cca(%rip),%rax\nmov    %rax,-0x38(%rbp)\nlea    0x2cc6(%rip),%rax\nmov    %rax,-0x30(%rbp)\nlea    0x2cc3(%rip),%rax\nmov    %rax,-0x28(%rbp)\nlea    0x2cc2(%rip),%rax\nmov    %rax,-0x20(%rbp)\nlea    0x2cc0(%rip),%rax\nmov    %rax,-0x18(%rbp)\nlea    0x2cbc(%rip),%rax\nmov    %rax,-0x10(%rbp)\nmov    $0x14,%edx\nmov    $0x2,%esi\nmov    $0x7e8,%edi\ncall   11e9 <dayOfWeek>\ncltq\nmov    -0x40(%rbp,%rax,8),%rax\nmov    %rax,%r8\nmov    $0x7e8,%ecx\nmov    $0x14,%edx\nmov    $0x2,%esi\nlea    0x2c8d(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35dc <libmin_printf>\nmov    $0x5,%edx\nmov    $0x4,%esi\nmov    $0x7ca,%edi\ncall   11e9 <dayOfWeek>\ncltq\nmov    -0x40(%rbp,%rax,8),%rax\nmov    %rax,%r8\nmov    $0x7ca,%ecx\nmov    $0x5,%edx\nmov    $0x4,%esi\nlea    0x2c4c(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35dc <libmin_printf>\nmov    $0x1,%edx\nmov    $0x1,%esi\nmov    $0x7b7,%edi\ncall   11e9 <dayOfWeek>\ncltq\nmov    -0x40(%rbp,%rax,8),%rax\nmov    %rax,%r8\nmov    $0x7b7,%ecx\nmov    $0x1,%edx\nmov    $0x1,%esi\nlea    0x2c0b(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35dc <libmin_printf>\nmov    $0x7,%edx\nmov    $0x2,%esi\nmov    $0x7ac,%edi\ncall   11e9 <dayOfWeek>\ncltq\nmov    -0x40(%rbp,%rax,8),%rax\nmov    %rax,%r8\nmov    $0x7ac,%ecx\nmov    $0x7,%edx\nmov    $0x2,%esi\nlea    0x2bca(%rip),%rax\nmov    %rax,%rdi\nmov    $0x0,%eax\ncall   35dc <libmin_printf>\ncall   3849 <libmin_success>\nmov    $0x0,%eax\nmov    -0x8(%rbp),%rdx\nsub    %fs:0x28,%rdx\nje     149e <main+0x191>\ncall   10b0 <__stack_chk_fail@plt>\nleave\nret\n"}
