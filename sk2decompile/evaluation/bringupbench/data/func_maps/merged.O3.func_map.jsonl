{"source": {"path": "ackermann/ackermann.c", "function_name": "ack", "content": "/* Implement Ackermann function as recursive function that remembers its values */\nunsigned\nack(unsigned x, unsigned y)\n{\n\tdepth++;\n\tif (depth > MAX_DEPTH)\n  {\n\t\tlibmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", MAX_DEPTH);\n\t\tlibmin_fail(1);\n\t}\n\tif (x >= MAX_X)\n  {\n\t\tlibmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", MAX_X);\n\t\tlibmin_fail(1);\n\t}\n\tif (y >= MAX_Y)\n  {\n\t\tlibmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", MAX_Y);\n\t\tlibmin_fail(1);\n\t}\n\tif (a[x][y])\n    return a[x][y];\n\tif (y==0)\n    return a[x][0] = x+1;\n\tif (x==0)\n    return a[0][y] = ack(1,y-1);\n  return a[x][y] = ack(ack(x-1,y),y-1);\n}\n"}, "pseudo": {"path": "ackermann/ackermann.host.O3.pseudo", "function_name": "ack", "address": "0x13b0", "label": "ack", "content": "unsigned int __fastcall ack(unsigned int x, unsigned int y)\n{\n  unsigned int result; // eax\n  unsigned int v3; // r15d\n  unsigned int v4; // eax\n\n  if ( ++depth > 0xFFFFFF )\n  {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 0xFFFFFF);\n    libmin_fail(1);\n  }\n  if ( x > 0xFFFE )\n  {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 0xFFFF);\n    libmin_fail(1);\n  }\n  if ( y > 0xF )\n  {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  result = a[x][y];\n  if ( !result )\n  {\n    if ( y )\n    {\n      v3 = y - 1;\n      if ( x )\n      {\n        v4 = ack(x - 1, y);\n        result = ack(v4, v3);\n        a[x][y] = result;\n      }\n      else\n      {\n        result = ack(1u, v3);\n        a[0][y] = result;\n      }\n    }\n    else\n    {\n      result = x + 1;\n      a[(unsigned __int64)x][0] = x + 1;\n    }\n  }\n  return result;\n}\n"}, "pseudo_normalize": "unsigned int ack(unsigned int x, unsigned int y) {\n  unsigned int result;\n  unsigned int v3;\n  unsigned int v4;\n  if (++depth > 16777215) {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 16777215);\n    libmin_fail(1);\n  }\n  if (x > 65534) {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 65535);\n    libmin_fail(1);\n  }\n  if (y > 15) {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  result = a[x][y];\n  if (!result) {\n    if (y) {\n      v3 = y - 1;\n      if (x) {\n        v4 = ack(x - 1, y);\n        result = ack(v4, v3);\n        a[x][y] = result;\n      } else {\n        result = ack(1u, v3);\n        a[0][y] = result;\n      }\n    } else {\n      result = x + 1;\n      a[(unsigned long long)x][0] = x + 1;\n    }\n  }\n  return result;\n}", "binary": "ackermann/ackermann.host.O3", "assembly": "<ack>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmov    %edi,%ebx\nsub    $0x8,%rsp\nmov    0x4eb8(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x4eaf(%rip)\ncmp    $0xffffff,%eax\nja     14e0 <ack+0x130>\ncmp    $0xfffe,%ebx\nja     14b8 <ack+0x108>\ncmp    $0xf,%ebp\nja     1438 <ack+0x88>\nmov    %ebx,%r12d\nmov    %ebp,%r14d\nlea    0x4ea2(%rip),%r13\nmov    %r12,%rax\nshl    $0x4,%rax\nadd    %r14,%rax\nmov    0x0(%r13,%rax,4),%eax\ntest   %eax,%eax\njne    1424 <ack+0x74>\ntest   %ebp,%ebp\njne    1475 <ack+0xc5>\nmov    %r12,%rdx\nlea    0x1(%rbx),%eax\nshl    $0x6,%rdx\nmov    %eax,0x0(%r13,%rdx,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0x10,%esi\nxor    %eax,%eax\nmov    %ebx,%r12d\nmov    %ebp,%r14d\nlea    0x2c14(%rip),%rdi\nlea    0x4e4d(%rip),%r13\ncall   3620 <libmin_printf>\nmov    $0x1,%edi\ncall   1710 <libmin_fail>\nmov    %r12,%rax\nshl    $0x4,%rax\nadd    %r14,%rax\nmov    0x0(%r13,%rax,4),%eax\ntest   %eax,%eax\njne    1424 <ack+0x74>\nlea    -0x1(%rbp),%r15d\ntest   %ebx,%ebx\nje     1508 <ack+0x158>\nlea    -0x1(%rbx),%edi\nmov    %ebp,%esi\ncall   13b0 <ack>\nmov    %r15d,%esi\nmov    %eax,%edi\ncall   13b0 <ack>\nmov    %r12,%rdx\nshl    $0x4,%rdx\nadd    %r14,%rdx\nmov    %eax,0x0(%r13,%rdx,4)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0xffff,%esi\nlea    0x2b74(%rip),%rdi\nxor    %eax,%eax\ncall   3620 <libmin_printf>\nmov    $0x1,%edi\ncall   1710 <libmin_fail>\njmp    13ec <ack+0x3c>\nnopw   0x0(%rax,%rax,1)\nmov    $0xffffff,%esi\nlea    0x2b1c(%rip),%rdi\nxor    %eax,%eax\ncall   3620 <libmin_printf>\nmov    $0x1,%edi\ncall   1710 <libmin_fail>\njmp    13e0 <ack+0x30>\nnopw   0x0(%rax,%rax,1)\nmov    %r15d,%esi\nmov    $0x1,%edi\ncall   13b0 <ack>\nmov    %eax,0x0(%r13,%r14,4)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "ackermann/ackermann.c", "function_name": "main", "content": "\t\n\nint\nmain(void)\n{\n\tunsigned y,k; \n\n  max_depth = 0;\n\tfor(k=0;k<=AMAX;k++)\n  {\n\t\tlibmin_printf(\"\\nx+y=%d:\\n\\n\",k);\n\t\tfor(y=0;y<=k;y++)\n    {\n\t\t  depth = 0;  /* stack guard */\n\t\t\tlibmin_printf(\"A(%d,%d) = %d\\n\",k-y,y,ack(k-y,y));\n      if (depth > max_depth)\n        max_depth = depth;   \n\t\t}\n\t}\n  libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "ackermann/ackermann.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // r12d\n  unsigned int v4; // r14d\n  __int64 v5; // r15\n  unsigned int v6; // eax\n  unsigned int v7; // eax\n  unsigned int v8; // eax\n  unsigned int v9; // r10d\n  __int64 v10; // rbx\n  unsigned int v11; // ecx\n  unsigned int v12; // esi\n  unsigned int v13; // eax\n  unsigned int *v14; // [rsp+18h] [rbp-40h]\n\n  v3 = 0;\n  max_depth = 0;\n  v14 = a[0];\nLABEL_2:\n  v4 = v3;\n  libmin_printf(\"\\nx+y=%d:\\n\\n\", v3++);\n  v5 = 0LL;\n  depth = 1;\n  while ( 1 )\n  {\n    v10 = (unsigned int)v5 + 16LL * v4;\n    v11 = a[0][v10];\n    if ( !v11 )\n    {\n      if ( v5 )\n      {\n        if ( v4 )\n        {\n          v6 = ack(v4 - 1, v5);\n          v7 = ack(v6, v5 - 1);\n          a[0][v10] = v7;\n          libmin_printf(\"A(%d,%d) = %d\\n\", v4, v5, v7);\n          v8 = depth;\n          if ( max_depth >= depth )\n          {\n            v9 = v4 - 1;\n            goto LABEL_7;\n          }\n        }\n        else\n        {\n          v13 = ack(1u, v5 - 1);\n          a[0][v5] = v13;\n          libmin_printf(\"A(%d,%d) = %d\\n\", 0, v5, v13);\n          v8 = depth;\n          v12 = max_depth;\n          if ( depth <= max_depth )\n          {\nLABEL_15:\n            v14 += 16;\n            if ( v3 == 6 )\n            {\n              libmin_printf(\"Max recursive depth = %u\\n\", v12);\n              libmin_success();\n            }\n            goto LABEL_2;\n          }\n        }\nLABEL_10:\n        max_depth = v8;\n        v12 = v8;\n        goto LABEL_11;\n      }\n      v11 = v3;\n      *v14 = v3;\n    }\n    libmin_printf(\"A(%d,%d) = %d\\n\", v4, v5, v11);\n    v8 = depth;\n    v12 = max_depth;\n    if ( depth > max_depth )\n      goto LABEL_10;\nLABEL_11:\n    if ( !v4 )\n      goto LABEL_15;\n    v9 = v4 - 1;\nLABEL_7:\n    depth = 1;\n    v4 = v9;\n    ++v5;\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  unsigned int v4;\n  long long v5;\n  unsigned int v6;\n  unsigned int v7;\n  unsigned int v8;\n  unsigned int v9;\n  long long v10;\n  unsigned int v11;\n  unsigned int v12;\n  unsigned int v13;\n  unsigned int *v14;\n  v3 = 0;\n  max_depth = 0;\n  v14 = a[0];\nLABEL_2:\n  v4 = v3;\n  libmin_printf(\"\\nx+y=%d:\\n\\n\", v3++);\n  v5 = 0LL;\n  depth = 1;\n  while (1) {\n    v10 = (unsigned int)v5 + 16LL * v4;\n    v11 = a[0][v10];\n    if (!v11) {\n      if (v5) {\n        if (v4) {\n          v6 = ack(v4 - 1, v5);\n          v7 = ack(v6, v5 - 1);\n          a[0][v10] = v7;\n          libmin_printf(\"A(%d,%d) = %d\\n\", v4, v5, v7);\n          v8 = depth;\n          if (max_depth >= depth) {\n            v9 = v4 - 1;\n            goto LABEL_7;\n          }\n        } else {\n          v13 = ack(1u, v5 - 1);\n          a[0][v5] = v13;\n          libmin_printf(\"A(%d,%d) = %d\\n\", 0, v5, v13);\n          v8 = depth;\n          v12 = max_depth;\n          if (depth <= max_depth) {\n          LABEL_15:\n            v14 += 16;\n            if (v3 == 6) {\n              libmin_printf(\"Max recursive depth = %u\\n\", v12);\n              libmin_success();\n            }\n            goto LABEL_2;\n          }\n        }\n      LABEL_10:\n        max_depth = v8;\n        v12 = v8;\n        goto LABEL_11;\n      }\n      v11 = v3;\n      *v14 = v3;\n    }\n    libmin_printf(\"A(%d,%d) = %d\\n\", v4, v5, v11);\n    v8 = depth;\n    v12 = max_depth;\n    if (depth > max_depth) goto LABEL_10;\n  LABEL_11:\n    if (!v4) goto LABEL_15;\n    v9 = v4 - 1;\n  LABEL_7:\n    depth = 1;\n    v4 = v9;\n    ++v5;\n  }\n}", "binary": "ackermann/ackermann.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nlea    0x2f80(%rip),%r13\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nlea    0x5182(%rip),%rbp\npush   %rbx\nsub    $0x28,%rsp\nmovl   $0x0,0x5153(%rip)\nmov    %rbp,0x18(%rsp)\nnopw   0x0(%rax,%rax,1)\nmov    %r12d,%esi\nlea    0x2f44(%rip),%rdi\nxor    %eax,%eax\nmov    %r12d,%r14d\ncall   3620 <libmin_printf>\nadd    $0x1,%r12d\nxor    %r15d,%r15d\nmovl   $0x1,0x5127(%rip)\njmp    11e9 <main+0xe9>\nnopw   0x0(%rax,%rax,1)\ntest   %r15,%r15\nje     1238 <main+0x138>\nlea    -0x1(%r15),%r11d\ntest   %r14d,%r14d\nje     1248 <main+0x148>\nlea    -0x1(%r14),%r10d\nmov    %r15d,%esi\nmov    %r11d,0x10(%rsp)\nmov    %r10d,%edi\nmov    %r10d,0x14(%rsp)\nmov    %r15d,0xc(%rsp)\ncall   13b0 <ack>\nmov    0x10(%rsp),%esi\nmov    %eax,%edi\ncall   13b0 <ack>\nmov    0xc(%rsp),%edx\nmov    %r14d,%esi\nmov    %r13,%rdi\nmov    %eax,0x0(%rbp,%rbx,4)\nmov    %eax,%ecx\nxor    %eax,%eax\ncall   3620 <libmin_printf>\nmov    0x50c0(%rip),%eax\ncmp    %eax,0x50b6(%rip)\njb     1222 <main+0x122>\nmov    0x14(%rsp),%r10d\nnopl   0x0(%rax)\nmovl   $0x1,0x50a2(%rip)\nmov    %r10d,%r14d\nadd    $0x1,%r15\nmov    %r14d,%ebx\nmov    %r15d,%eax\nmov    %r15d,%edx\nshl    $0x4,%rbx\nadd    %rax,%rbx\nmov    0x0(%rbp,%rbx,4),%ecx\ntest   %ecx,%ecx\nje     1168 <main+0x68>\nmov    %r14d,%esi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   3620 <libmin_printf>\nmov    0x506c(%rip),%eax\nmov    0x5062(%rip),%esi\ncmp    %esi,%eax\njbe    122a <main+0x12a>\nmov    %eax,0x5058(%rip)\nmov    %eax,%esi\ntest   %r14d,%r14d\nje     1281 <main+0x181>\nlea    -0x1(%r14),%r10d\njmp    11d8 <main+0xd8>\nnopl   (%rax)\nmov    0x18(%rsp),%rax\nmov    %r12d,%ecx\nmov    %r12d,(%rax)\njmp    1205 <main+0x105>\nnopl   (%rax)\nmov    %r11d,%esi\nmov    $0x1,%edi\nmov    %r15d,0xc(%rsp)\ncall   13b0 <ack>\nmov    0xc(%rsp),%edx\nxor    %esi,%esi\nmov    %r13,%rdi\nmov    %eax,0x0(%rbp,%r15,4)\nmov    %eax,%ecx\nxor    %eax,%eax\ncall   3620 <libmin_printf>\nmov    0x500d(%rip),%eax\nmov    0x5003(%rip),%esi\ncmp    %esi,%eax\nja     1222 <main+0x122>\naddq   $0x40,0x18(%rsp)\ncmp    $0x6,%r12d\njne    1138 <main+0x38>\nlea    0x2e08(%rip),%rdi\nxor    %eax,%eax\ncall   3620 <libmin_printf>\ncall   3860 <libmin_success>\nadd    $0x28,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "aes/aes.c", "function_name": "add_round_key", "content": "void add_round_key(uint8_t *s, const uint8_t *round_key) {\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] ^= round_key[i];\n}\n"}, "pseudo": {"path": "aes/aes.host.O3.pseudo", "function_name": "add_round_key", "address": "0x1810", "label": "add_round_key", "content": "void __fastcall add_round_key(uint8_t *s, const uint8_t *round_key)\n{\n  if ( (unsigned __int64)(s - (round_key + 1)) <= 0xE )\n  {\n    *s ^= *round_key;\n    s[1] ^= round_key[1];\n    s[2] ^= round_key[2];\n    s[3] ^= round_key[3];\n    s[4] ^= round_key[4];\n    s[5] ^= round_key[5];\n    s[6] ^= round_key[6];\n    s[7] ^= round_key[7];\n    s[8] ^= round_key[8];\n    s[9] ^= round_key[9];\n    s[10] ^= round_key[10];\n    s[11] ^= round_key[11];\n    s[12] ^= round_key[12];\n    s[13] ^= round_key[13];\n    s[14] ^= round_key[14];\n    s[15] ^= round_key[15];\n  }\n  else\n  {\n    *(__m128i *)s = _mm_xor_si128(_mm_loadu_si128((const __m128i *)round_key), _mm_loadu_si128((const __m128i *)s));\n  }\n}\n"}, "pseudo_normalize": "void add_round_key(uint8_t *s, const uint8_t *round_key) {\n  if ((unsigned long long)(s - (round_key + 1)) <= 14) {\n    *s ^= *round_key;\n    s[1] ^= round_key[1];\n    s[2] ^= round_key[2];\n    s[3] ^= round_key[3];\n    s[4] ^= round_key[4];\n    s[5] ^= round_key[5];\n    s[6] ^= round_key[6];\n    s[7] ^= round_key[7];\n    s[8] ^= round_key[8];\n    s[9] ^= round_key[9];\n    s[10] ^= round_key[10];\n    s[11] ^= round_key[11];\n    s[12] ^= round_key[12];\n    s[13] ^= round_key[13];\n    s[14] ^= round_key[14];\n    s[15] ^= round_key[15];\n  } else {\n    *(__m128i *)s = _mm_xor_si128(_mm_loadu_si128((const __m128i *)round_key),\n                                  _mm_loadu_si128((const __m128i *)s));\n  }\n}", "binary": "aes/aes.host.O3", "assembly": "<add_round_key>:\nendbr64\nmov    %rsi,%rdx\nmov    %rdi,%rcx\nlea    0x1(%rsi),%rsi\nsub    %rsi,%rcx\ncmp    $0xe,%rcx\njbe    1840 <add_round_key+0x30>\nmovdqu (%rdx),%xmm0\nmovdqu (%rdi),%xmm1\npxor   %xmm1,%xmm0\nmovups %xmm0,(%rdi)\nret\nnopw   0x0(%rax,%rax,1)\nmovzbl (%rdx),%ecx\nxor    %cl,(%rdi)\nmovzbl 0x1(%rdx),%ecx\nxor    %cl,0x1(%rdi)\nmovzbl 0x2(%rdx),%ecx\nxor    %cl,0x2(%rdi)\nmovzbl 0x3(%rdx),%ecx\nxor    %cl,0x3(%rdi)\nmovzbl 0x4(%rdx),%ecx\nxor    %cl,0x4(%rdi)\nmovzbl 0x5(%rdx),%ecx\nxor    %cl,0x5(%rdi)\nmovzbl 0x6(%rdx),%ecx\nxor    %cl,0x6(%rdi)\nmovzbl 0x7(%rdx),%ecx\nxor    %cl,0x7(%rdi)\nmovzbl 0x8(%rdx),%ecx\nxor    %cl,0x8(%rdi)\nmovzbl 0x9(%rdx),%ecx\nxor    %cl,0x9(%rdi)\nmovzbl 0xa(%rdx),%ecx\nxor    %cl,0xa(%rdi)\nmovzbl 0xb(%rdx),%ecx\nxor    %cl,0xb(%rdi)\nmovzbl 0xc(%rdx),%ecx\nxor    %cl,0xc(%rdi)\nmovzbl 0xd(%rdx),%ecx\nxor    %cl,0xd(%rdi)\nmovzbl 0xe(%rdx),%ecx\nxor    %cl,0xe(%rdi)\nmovzbl 0xf(%rdx),%edx\nxor    %dl,0xf(%rdi)\nret\nnop\n"}
{"source": {"path": "aes/aes.c", "function_name": "aes_decrypt", "content": "void aes_decrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t round_keys[(ROUNDS + 1) * BLK_SIZE];\n  key_expansion(key, round_keys);\n\n  add_round_key(data, round_keys + ROUNDS * BLK_SIZE);\n  for (int round = 9; round > 0; round--) {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, round_keys + round * BLK_SIZE);\n    inv_mix_columns(data);\n  }\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys + 0 * BLK_SIZE);\n}\n"}, "pseudo": {"path": "aes/aes.host.O3.pseudo", "function_name": "aes_decrypt", "address": "0x2760", "label": "aes_decrypt", "content": "void __fastcall aes_decrypt(uint8_t *data, const uint8_t *key)\n{\n  uint8_t *v3; // r12\n  uint8_t v4; // bp\n  __int64 v5; // r9\n  __int64 v6; // r8\n  __int64 v7; // rax\n  __int64 v8; // rdi\n  __int64 v9; // rsi\n  __int64 v10; // rcx\n  __int64 v11; // rdx\n  __int64 v12; // rbx\n  __int64 v13; // r11\n  __int64 v14; // r10\n  __int64 v15; // r15\n  __int64 v16; // rbp\n  __int64 v17; // r10\n  __int64 v18; // r11\n  __int64 v19; // rbx\n  __int64 v20; // rax\n  __int64 v21; // rax\n  __int64 v22; // rcx\n  __int64 v23; // rax\n  __int64 v24; // rdx\n  __int64 v25; // r10\n  __m128i v26; // xmm0\n  __int64 v27; // rax\n  __int64 v28; // r10\n  __int64 v29; // r9\n  __int64 v30; // r8\n  __int64 v31; // rsi\n  __int64 v32; // rax\n  __int64 v33; // r10\n  __int64 v34; // rcx\n  __int64 v35; // rdx\n  __int64 v36; // rax\n  __int64 v37; // r10\n  __int64 v38; // r15\n  uint8_t v39; // dl\n  __int64 v40; // rsi\n  __int64 v41; // rdi\n  __int64 v42; // r8\n  __int64 v43; // r9\n  uint8_t v44; // al\n  __int64 v45; // r10\n  uint8_t v46; // dl\n  __int64 v47; // r11\n  __int64 v48; // rbx\n  __int64 v49; // rbp\n  uint8_t v50; // al\n  __int64 v51; // r15\n  uint8_t v52; // cl\n  __int64 v53; // r12\n  uint8_t v54; // al\n  __m128i v55; // [rsp+0h] [rbp-128h] BYREF\n  uint8_t *v56; // [rsp+18h] [rbp-110h]\n  uint8_t v57; // [rsp+23h] [rbp-105h]\n  uint8_t v58; // [rsp+24h] [rbp-104h]\n  uint8_t v59; // [rsp+25h] [rbp-103h]\n  uint8_t v60; // [rsp+26h] [rbp-102h]\n  unsigned __int8 v61; // [rsp+27h] [rbp-101h]\n  __int64 v62; // [rsp+28h] [rbp-100h]\n  uint8_t round_keys[176]; // [rsp+30h] [rbp-F8h] BYREF\n  unsigned __int64 v64; // [rsp+E8h] [rbp-40h]\n\n  v64 = __readfsqword(0x28u);\n  v3 = &round_keys[144];\n  v56 = round_keys;\n  key_expansion(key, round_keys);\n  *(__m128i *)data = _mm_xor_si128(_mm_loadu_si128((const __m128i *)data), *(__m128i *)&round_keys[160]);\n  do\n  {\n    v4 = data[6];\n    v5 = data[1];\n    v3 -= 16;\n    v6 = data[14];\n    v7 = data[11];\n    v8 = data[5];\n    v9 = data[2];\n    data[14] = v4;\n    v10 = data[15];\n    v11 = data[9];\n    v60 = v4;\n    v12 = data[13];\n    v13 = data[10];\n    data[5] = v5;\n    v14 = data[7];\n    v15 = data[3];\n    data[6] = v6;\n    v16 = *data;\n    data[1] = v12;\n    data[3] = v14;\n    data[7] = v7;\n    data[9] = v8;\n    data[10] = v9;\n    data[11] = v10;\n    data[13] = v11;\n    data[15] = v15;\n    data[2] = v13;\n    LOBYTE(v16) = inv_sbox[v16];\n    *data = v16;\n    LOBYTE(v12) = inv_sbox[v12];\n    data[1] = v12;\n    LOBYTE(v13) = inv_sbox[v13];\n    v55.m128i_i8[0] = v12;\n    v57 = v13;\n    data[2] = v13;\n    LOBYTE(v14) = inv_sbox[v14];\n    data[3] = v14;\n    v58 = v14;\n    LOBYTE(v12) = inv_sbox[data[4]];\n    data[4] = v12;\n    v17 = inv_sbox[v5];\n    v59 = v12;\n    data[5] = v17;\n    v18 = inv_sbox[v6];\n    data[6] = v18;\n    v19 = inv_sbox[v7];\n    v20 = data[8];\n    data[7] = v19;\n    v21 = inv_sbox[v20];\n    data[8] = v21;\n    LOBYTE(v5) = inv_sbox[v8];\n    data[9] = v5;\n    LOBYTE(v6) = inv_sbox[v9];\n    data[10] = v6;\n    LOBYTE(v8) = inv_sbox[v10];\n    v22 = data[12];\n    data[11] = v8;\n    v23 = (v17 | ((v18 | ((v19 | (v21 << 8)) << 8)) << 8)) << 8;\n    LOBYTE(v9) = inv_sbox[v22];\n    data[12] = v9;\n    LOBYTE(v22) = inv_sbox[v11];\n    v24 = v60;\n    data[13] = v22;\n    LOBYTE(v24) = inv_sbox[v24];\n    data[14] = v24;\n    LOBYTE(v15) = inv_sbox[v15];\n    v25 = v59;\n    LOBYTE(v8) = v3[27] ^ v8;\n    v26 = _mm_loadl_epi64((const __m128i *)(v3 + 17));\n    *data = v3[16] ^ v16;\n    v27 = v25 | v23;\n    v28 = v58;\n    v29 = (unsigned __int8)(v3[25] ^ v5);\n    data[11] = v8;\n    v30 = (unsigned __int8)(v3[26] ^ v6);\n    v31 = (unsigned __int8)(v3[28] ^ v9);\n    data[9] = v29;\n    v32 = v28 | (v27 << 8);\n    v33 = v57;\n    data[10] = v30;\n    v34 = (unsigned __int8)(v3[29] ^ v22);\n    v35 = (unsigned __int8)(v3[30] ^ v24);\n    data[12] = v31;\n    v36 = v33 | (v32 << 8);\n    v37 = v55.m128i_u8[0];\n    v38 = (unsigned __int8)(v3[31] ^ v15);\n    data[13] = v34;\n    data[14] = v35;\n    data[15] = v38;\n    *(_QWORD *)(data + 1) = _mm_xor_si128(v26, (__m128i)(v37 | (unsigned __int64)(v36 << 8))).m128i_u64[0];\n    inv_mix_columns(data);\n  }\n  while ( v56 != v3 );\n  v39 = data[15];\n  v40 = data[11];\n  v41 = data[14];\n  v42 = data[1];\n  v43 = data[4];\n  LOBYTE(v56) = data[5];\n  v44 = data[12];\n  v45 = data[7];\n  v58 = v39;\n  v46 = data[9];\n  v47 = data[10];\n  v48 = data[13];\n  v49 = *data;\n  v59 = v44;\n  v50 = data[6];\n  v51 = data[2];\n  v60 = v46;\n  v52 = data[8];\n  v53 = v50;\n  v54 = data[3];\n  v61 = v53;\n  v57 = v54;\n  v62 = (unsigned __int8)v49;\n  v55.m128i_i64[0] = (unsigned __int8)v49 | (((unsigned __int8)v48 | (((unsigned __int8)v47 | (((unsigned __int8)v45 | (((unsigned __int8)v43 | (((unsigned __int8)v42 | (((unsigned __int8)v41 | ((unsigned __int64)(unsigned __int8)v40 << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);\n  v55.m128i_i64[1] = v52 | (((unsigned __int8)v56 | (((unsigned __int8)v51 | ((v58 | ((v59 | ((v46 | ((v53 | ((unsigned __int64)v54 << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);\n  *(__m128i *)data = _mm_load_si128(&v55);\n  *data = inv_sbox[v49];\n  data[1] = inv_sbox[v48];\n  data[2] = inv_sbox[v47];\n  data[3] = inv_sbox[v45];\n  data[4] = inv_sbox[v43];\n  data[5] = inv_sbox[v42];\n  data[6] = inv_sbox[v41];\n  data[7] = inv_sbox[v40];\n  data[8] = inv_sbox[v52];\n  data[9] = inv_sbox[(unsigned __int8)v56];\n  data[10] = inv_sbox[v51];\n  data[11] = inv_sbox[v58];\n  data[12] = inv_sbox[v59];\n  data[13] = inv_sbox[v60];\n  data[14] = inv_sbox[v61];\n  data[15] = inv_sbox[v57];\n  *(__m128i *)data = _mm_xor_si128(_mm_loadu_si128((const __m128i *)data), *(__m128i *)round_keys);\n}\n"}, "pseudo_normalize": "void aes_decrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t *v3;\n  uint8_t v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  long long v10;\n  long long v11;\n  long long v12;\n  long long v13;\n  long long v14;\n  long long v15;\n  long long v16;\n  long long v17;\n  long long v18;\n  long long v19;\n  long long v20;\n  long long v21;\n  long long v22;\n  long long v23;\n  long long v24;\n  long long v25;\n  __m128i v26;\n  long long v27;\n  long long v28;\n  long long v29;\n  long long v30;\n  long long v31;\n  long long v32;\n  long long v33;\n  long long v34;\n  long long v35;\n  long long v36;\n  long long v37;\n  long long v38;\n  uint8_t v39;\n  long long v40;\n  long long v41;\n  long long v42;\n  long long v43;\n  uint8_t v44;\n  long long v45;\n  uint8_t v46;\n  long long v47;\n  long long v48;\n  long long v49;\n  uint8_t v50;\n  long long v51;\n  uint8_t v52;\n  long long v53;\n  uint8_t v54;\n  __m128i v55;\n  uint8_t *v56;\n  uint8_t v57;\n  uint8_t v58;\n  uint8_t v59;\n  uint8_t v60;\n  unsigned char v61;\n  long long v62;\n  uint8_t round_keys[176];\n  unsigned long long v64;\n  v64 = __readfsqword(40u);\n  v3 = &round_keys[144];\n  v56 = round_keys;\n  key_expansion(key, round_keys);\n  *(__m128i *)data = _mm_xor_si128(_mm_loadu_si128((const __m128i *)data),\n                                   *(__m128i *)&round_keys[160]);\n  do {\n    v4 = data[6];\n    v5 = data[1];\n    v3 -= 16;\n    v6 = data[14];\n    v7 = data[11];\n    v8 = data[5];\n    v9 = data[2];\n    data[14] = v4;\n    v10 = data[15];\n    v11 = data[9];\n    v60 = v4;\n    v12 = data[13];\n    v13 = data[10];\n    data[5] = v5;\n    v14 = data[7];\n    v15 = data[3];\n    data[6] = v6;\n    v16 = *data;\n    data[1] = v12;\n    data[3] = v14;\n    data[7] = v7;\n    data[9] = v8;\n    data[10] = v9;\n    data[11] = v10;\n    data[13] = v11;\n    data[15] = v15;\n    data[2] = v13;\n    LOBYTE(v16) = inv_sbox[v16];\n    *data = v16;\n    LOBYTE(v12) = inv_sbox[v12];\n    data[1] = v12;\n    LOBYTE(v13) = inv_sbox[v13];\n    v55.m128i_i8[0] = v12;\n    v57 = v13;\n    data[2] = v13;\n    LOBYTE(v14) = inv_sbox[v14];\n    data[3] = v14;\n    v58 = v14;\n    LOBYTE(v12) = inv_sbox[data[4]];\n    data[4] = v12;\n    v17 = inv_sbox[v5];\n    v59 = v12;\n    data[5] = v17;\n    v18 = inv_sbox[v6];\n    data[6] = v18;\n    v19 = inv_sbox[v7];\n    v20 = data[8];\n    data[7] = v19;\n    v21 = inv_sbox[v20];\n    data[8] = v21;\n    LOBYTE(v5) = inv_sbox[v8];\n    data[9] = v5;\n    LOBYTE(v6) = inv_sbox[v9];\n    data[10] = v6;\n    LOBYTE(v8) = inv_sbox[v10];\n    v22 = data[12];\n    data[11] = v8;\n    v23 = (v17 | ((v18 | ((v19 | (v21 << 8)) << 8)) << 8)) << 8;\n    LOBYTE(v9) = inv_sbox[v22];\n    data[12] = v9;\n    LOBYTE(v22) = inv_sbox[v11];\n    v24 = v60;\n    data[13] = v22;\n    LOBYTE(v24) = inv_sbox[v24];\n    data[14] = v24;\n    LOBYTE(v15) = inv_sbox[v15];\n    v25 = v59;\n    LOBYTE(v8) = v3[27] ^ v8;\n    v26 = _mm_loadl_epi64((const __m128i *)(v3 + 17));\n    *data = v3[16] ^ v16;\n    v27 = v25 | v23;\n    v28 = v58;\n    v29 = (unsigned char)(v3[25] ^ v5);\n    data[11] = v8;\n    v30 = (unsigned char)(v3[26] ^ v6);\n    v31 = (unsigned char)(v3[28] ^ v9);\n    data[9] = v29;\n    v32 = v28 | (v27 << 8);\n    v33 = v57;\n    data[10] = v30;\n    v34 = (unsigned char)(v3[29] ^ v22);\n    v35 = (unsigned char)(v3[30] ^ v24);\n    data[12] = v31;\n    v36 = v33 | (v32 << 8);\n    v37 = v55.m128i_u8[0];\n    v38 = (unsigned char)(v3[31] ^ v15);\n    data[13] = v34;\n    data[14] = v35;\n    data[15] = v38;\n    *(uint64_t *)(data + 1) =\n        _mm_xor_si128(v26, (__m128i)(v37 | (unsigned long long)(v36 << 8)))\n            .m128i_u64[0];\n    inv_mix_columns(data);\n  } while (v56 != v3);\n  v39 = data[15];\n  v40 = data[11];\n  v41 = data[14];\n  v42 = data[1];\n  v43 = data[4];\n  LOBYTE(v56) = data[5];\n  v44 = data[12];\n  v45 = data[7];\n  v58 = v39;\n  v46 = data[9];\n  v47 = data[10];\n  v48 = data[13];\n  v49 = *data;\n  v59 = v44;\n  v50 = data[6];\n  v51 = data[2];\n  v60 = v46;\n  v52 = data[8];\n  v53 = v50;\n  v54 = data[3];\n  v61 = v53;\n  v57 = v54;\n  v62 = (unsigned char)v49;\n  v55.m128i_i64[0] = (unsigned char)v49 |\n                     (((unsigned char)v48 |\n                       (((unsigned char)v47 |\n                         (((unsigned char)v45 |\n                           (((unsigned char)v43 |\n                             (((unsigned char)v42 |\n                               (((unsigned char)v41 |\n                                 ((unsigned long long)(unsigned char)v40 << 8))\n                                << 8))\n                              << 8))\n                            << 8))\n                          << 8))\n                        << 8))\n                      << 8);\n  v55.m128i_i64[1] =\n      v52 |\n      (((unsigned char)v56 |\n        (((unsigned char)v51 |\n          ((v58 | ((v59 | ((v46 | ((v53 | ((unsigned long long)v54 << 8)) << 8))\n                           << 8))\n                   << 8))\n           << 8))\n         << 8))\n       << 8);\n  *(__m128i *)data = _mm_load_si128(&v55);\n  *data = inv_sbox[v49];\n  data[1] = inv_sbox[v48];\n  data[2] = inv_sbox[v47];\n  data[3] = inv_sbox[v45];\n  data[4] = inv_sbox[v43];\n  data[5] = inv_sbox[v42];\n  data[6] = inv_sbox[v41];\n  data[7] = inv_sbox[v40];\n  data[8] = inv_sbox[v52];\n  data[9] = inv_sbox[(unsigned char)v56];\n  data[10] = inv_sbox[v51];\n  data[11] = inv_sbox[v58];\n  data[12] = inv_sbox[v59];\n  data[13] = inv_sbox[v60];\n  data[14] = inv_sbox[v61];\n  data[15] = inv_sbox[v57];\n  *(__m128i *)data = _mm_xor_si128(_mm_loadu_si128((const __m128i *)data),\n                                   *(__m128i *)round_keys);\n}", "binary": "aes/aes.host.O3", "assembly": "<aes_decrypt>:\nendbr64\npush   %r15\npush   %r14\nlea    0x58b1(%rip),%r14\npush   %r13\nmov    %rdi,%r13\nmov    %rsi,%rdi\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xf8,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0xe8(%rsp)\nxor    %eax,%eax\nlea    0x30(%rsp),%rsi\nlea    0xc0(%rsp),%r12\nmov    %rsi,0x18(%rsp)\ncall   1ff0 <key_expansion>\nmovdqu 0x0(%r13),%xmm0\npxor   0xd0(%rsp),%xmm0\nmovups %xmm0,0x0(%r13)\nmovzbl 0x6(%r13),%ebp\nmovzbl 0x1(%r13),%r9d\nsub    $0x10,%r12\nmovzbl 0xe(%r13),%r8d\nmovzbl 0xb(%r13),%eax\nmovzbl 0x5(%r13),%edi\nmovzbl 0x2(%r13),%esi\nmov    %bpl,0xe(%r13)\nmovzbl 0xf(%r13),%ecx\nmovzbl 0x9(%r13),%edx\nmov    %bpl,0x26(%rsp)\nmovzbl 0xd(%r13),%ebx\nmovzbl 0xa(%r13),%r11d\nmov    %r9b,0x5(%r13)\nmovzbl 0x7(%r13),%r10d\nmovzbl 0x3(%r13),%r15d\nmov    %r8b,0x6(%r13)\nmovzbl 0x0(%r13),%ebp\nmov    %bl,0x1(%r13)\nmov    %r10b,0x3(%r13)\nmov    %al,0x7(%r13)\nmov    %dil,0x9(%r13)\nmov    %sil,0xa(%r13)\nmov    %cl,0xb(%r13)\nmov    %dl,0xd(%r13)\nmov    %r15b,0xf(%r13)\nmov    %r11b,0x2(%r13)\nmovzbl (%r14,%rbp,1),%ebp\nmov    %bpl,0x0(%r13)\nmovzbl (%r14,%rbx,1),%ebx\nmov    %bl,0x1(%r13)\nmovzbl (%r14,%r11,1),%r11d\nmov    %bl,(%rsp)\nmov    %r11b,0x23(%rsp)\nmov    %r11b,0x2(%r13)\nmovzbl (%r14,%r10,1),%r10d\nmov    %r10b,0x3(%r13)\nmov    %r10b,0x24(%rsp)\nmovzbl 0x4(%r13),%r10d\nmovzbl (%r14,%r10,1),%ebx\nmov    %bl,0x4(%r13)\nmovzbl (%r14,%r9,1),%r10d\nmov    %bl,0x25(%rsp)\nmov    %r10b,0x5(%r13)\nmovzbl (%r14,%r8,1),%r11d\nmov    %r11b,0x6(%r13)\nmovzbl (%r14,%rax,1),%ebx\nmovzbl 0x8(%r13),%eax\nmov    %bl,0x7(%r13)\nmovzbl (%r14,%rax,1),%eax\nmov    %al,0x8(%r13)\nmovzbl (%r14,%rdi,1),%r9d\nshl    $0x8,%rax\nor     %rbx,%rax\nmov    %r9b,0x9(%r13)\nmovzbl (%r14,%rsi,1),%r8d\nshl    $0x8,%rax\nor     %r11,%rax\nmov    %r8b,0xa(%r13)\nmovzbl (%r14,%rcx,1),%edi\nshl    $0x8,%rax\nmovzbl 0xc(%r13),%ecx\nor     %r10,%rax\nmov    %dil,0xb(%r13)\nshl    $0x8,%rax\nmovzbl (%r14,%rcx,1),%esi\nmov    %sil,0xc(%r13)\nmovzbl (%r14,%rdx,1),%ecx\nmovzbl 0x26(%rsp),%edx\nmov    %cl,0xd(%r13)\nmovzbl (%r14,%rdx,1),%edx\nmov    %dl,0xe(%r13)\nmovzbl (%r14,%r15,1),%r15d\nxor    0x10(%r12),%bpl\nmovzbl 0x25(%rsp),%r10d\nxor    0x1b(%r12),%dil\nmovq   0x11(%r12),%xmm0\nmov    %bpl,0x0(%r13)\nor     %r10,%rax\nmovzbl 0x24(%rsp),%r10d\nxor    0x19(%r12),%r9b\nmov    %dil,0xb(%r13)\nshl    $0x8,%rax\nxor    0x1a(%r12),%r8b\nxor    0x1c(%r12),%sil\nmov    %r9b,0x9(%r13)\nor     %r10,%rax\nmovzbl 0x23(%rsp),%r10d\nmov    %r8b,0xa(%r13)\nmov    %r13,%rdi\nshl    $0x8,%rax\nxor    0x1d(%r12),%cl\nxor    0x1e(%r12),%dl\nmov    %sil,0xc(%r13)\nor     %r10,%rax\nmovzbl (%rsp),%r10d\nxor    0x1f(%r12),%r15b\nmov    %cl,0xd(%r13)\nshl    $0x8,%rax\nmov    %dl,0xe(%r13)\nor     %r10,%rax\nmov    %r15b,0xf(%r13)\nmovq   %rax,%xmm1\npxor   %xmm1,%xmm0\nmovq   %xmm0,0x1(%r13)\ncall   1e40 <inv_mix_columns>\ncmp    %r12,0x18(%rsp)\njne    27c0 <aes_decrypt+0x60>\nmovzbl 0x5(%r13),%eax\nmovzbl 0xf(%r13),%edx\nmovzbl 0xb(%r13),%esi\nmovzbl 0xe(%r13),%edi\nmovzbl 0x1(%r13),%r8d\nmovzbl 0x4(%r13),%r9d\nmov    %al,0x18(%rsp)\nmovzbl 0xc(%r13),%eax\nmovzbl 0x7(%r13),%r10d\nmov    %dl,0x24(%rsp)\nmovzbl 0x9(%r13),%edx\nmovzbl 0xa(%r13),%r11d\nmovzbl 0xd(%r13),%ebx\nmovzbl 0x0(%r13),%ebp\nmov    %al,0x25(%rsp)\nmovzbl 0x6(%r13),%eax\nmovzbl 0x2(%r13),%r15d\nmov    %dl,0x26(%rsp)\nmovzbl %sil,%edx\nshl    $0x8,%rdx\nmovzbl 0x8(%r13),%ecx\nmovzbl %al,%r12d\nmovzbl 0x3(%r13),%eax\nmov    %r12b,0x27(%rsp)\nmov    %al,0x23(%rsp)\nmovzbl %dil,%eax\nor     %rax,%rdx\nmovzbl %r8b,%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl %r9b,%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl %r10b,%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl %r11b,%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl %bl,%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl %bpl,%eax\nmov    %rax,0x28(%rsp)\nmovzbl 0x23(%rsp),%eax\nshl    $0x8,%rdx\nor     0x28(%rsp),%rdx\nshl    $0x8,%rax\nmov    %rdx,(%rsp)\nor     %r12,%rax\nmovzbl 0x26(%rsp),%r12d\nshl    $0x8,%rax\nor     %r12,%rax\nmovzbl 0x25(%rsp),%r12d\nshl    $0x8,%rax\nor     %r12,%rax\nmovzbl 0x24(%rsp),%r12d\nshl    $0x8,%rax\nor     %r12,%rax\nmovzbl %r15b,%r12d\nshl    $0x8,%rax\nor     %r12,%rax\nmovzbl 0x18(%rsp),%r12d\nshl    $0x8,%rax\nor     %r12,%rax\nmovzbl %cl,%r12d\nshl    $0x8,%rax\nmov    %rax,%rdx\nor     %r12,%rdx\nmov    %rdx,0x8(%rsp)\nmovdqa (%rsp),%xmm2\nmovups %xmm2,0x0(%r13)\nmovzbl (%r14,%rbp,1),%eax\nmov    %al,0x0(%r13)\nmovzbl (%r14,%rbx,1),%eax\nmov    %al,0x1(%r13)\nmovzbl (%r14,%r11,1),%eax\nmov    %al,0x2(%r13)\nmovzbl (%r14,%r10,1),%eax\nmov    %al,0x3(%r13)\nmovzbl (%r14,%r9,1),%eax\nmov    %al,0x4(%r13)\nmovzbl (%r14,%r8,1),%eax\nmov    %al,0x5(%r13)\nmovzbl (%r14,%rdi,1),%eax\nmov    %al,0x6(%r13)\nmovzbl (%r14,%rsi,1),%eax\nmov    %al,0x7(%r13)\nmovzbl (%r14,%r12,1),%eax\nmov    %al,0x8(%r13)\nmovzbl 0x18(%rsp),%eax\nmovzbl (%r14,%rax,1),%eax\nmov    %al,0x9(%r13)\nmovzbl (%r14,%r15,1),%eax\nmov    %al,0xa(%r13)\nmovzbl 0x24(%rsp),%eax\nmovzbl (%r14,%rax,1),%eax\nmov    %al,0xb(%r13)\nmovzbl 0x25(%rsp),%eax\nmovzbl (%r14,%rax,1),%eax\nmov    %al,0xc(%r13)\nmovzbl 0x26(%rsp),%eax\nmovzbl (%r14,%rax,1),%eax\nmov    %al,0xd(%r13)\nmovzbl 0x27(%rsp),%eax\nmovzbl (%r14,%rax,1),%eax\nmov    %al,0xe(%r13)\nmovzbl 0x23(%rsp),%eax\nmovzbl (%r14,%rax,1),%eax\nmov    %al,0xf(%r13)\nmovdqu 0x0(%r13),%xmm0\npxor   0x30(%rsp),%xmm0\nmovups %xmm0,0x0(%r13)\nmov    0xe8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    2bb8 <aes_decrypt+0x458>\nadd    $0xf8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopl   (%rax)\n"}
{"source": {"path": "aes/aes.c", "function_name": "aes_encrypt", "content": "void aes_encrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t round_keys[(ROUNDS + 1) * BLK_SIZE];\n  key_expansion(key, round_keys);\n\n  add_round_key(data, round_keys);\n  for (int round = 1; round < ROUNDS; round++) {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, round_keys + round * BLK_SIZE);\n  }\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, round_keys + ROUNDS * BLK_SIZE);\n}\n"}, "pseudo": {"path": "aes/aes.host.O3.pseudo", "function_name": "aes_encrypt", "address": "0x2200", "label": "aes_encrypt", "content": "void __fastcall aes_encrypt(uint8_t *data, const uint8_t *key)\n{\n  __m128i v3; // xmm0\n  unsigned __int8 v4; // r14\n  unsigned __int8 v5; // r13\n  unsigned __int8 v6; // r12\n  unsigned __int8 v7; // bp\n  unsigned __int8 v8; // r9\n  unsigned __int8 v9; // r8\n  unsigned __int8 v10; // di\n  unsigned __int8 v11; // si\n  unsigned __int8 v12; // cl\n  unsigned __int8 v13; // dl\n  unsigned __int8 v14; // r15\n  uint8_t *v15; // r11\n  __int64 v16; // rax\n  uint8_t v17; // r13\n  __int64 v18; // r14\n  uint8_t v19; // r12\n  uint8_t v20; // bp\n  uint8_t v21; // r8\n  __int64 v22; // r9\n  uint8_t v23; // di\n  uint8_t v24; // si\n  uint8_t v25; // dl\n  uint8_t v26; // cl\n  __int64 v27; // r15\n  uint8_t *v28; // r10\n  __m128i v29; // xmm0\n  uint8_t v30; // r13\n  unsigned __int8 v31; // al\n  uint8_t v32; // cl\n  __int64 v33; // r8\n  uint8_t v34; // al\n  __int64 v35; // rdx\n  __int64 v36; // r12\n  __int64 v37; // r10\n  __int64 v38; // r9\n  __int64 v39; // rsi\n  uint8_t v40; // r15\n  __int64 v41; // r13\n  __int64 v42; // rbp\n  __int64 v43; // rax\n  __int64 v44; // rdi\n  __int8 v45; // r14\n  __int64 v46; // r14\n  __int64 v47; // r11\n  __m128i v48; // [rsp+0h] [rbp-2F8h] BYREF\n  unsigned __int8 v49; // [rsp+14h] [rbp-2E4h]\n  unsigned __int8 v50; // [rsp+15h] [rbp-2E3h]\n  unsigned __int8 v51; // [rsp+16h] [rbp-2E2h]\n  unsigned __int8 v52; // [rsp+17h] [rbp-2E1h]\n  uint8_t *v53; // [rsp+18h] [rbp-2E0h]\n  __m128i v54; // [rsp+20h] [rbp-2D8h]\n  __m128i v55; // [rsp+30h] [rbp-2C8h]\n  __m128i v56; // [rsp+40h] [rbp-2B8h]\n  __m128i v57; // [rsp+50h] [rbp-2A8h]\n  __m128i v58; // [rsp+60h] [rbp-298h]\n  __m128i v59; // [rsp+70h] [rbp-288h]\n  __m128i v60; // [rsp+80h] [rbp-278h]\n  __m128i v61; // [rsp+90h] [rbp-268h]\n  __m128i v62; // [rsp+A0h] [rbp-258h]\n  __m128i v63; // [rsp+B0h] [rbp-248h]\n  __m128i v64; // [rsp+C0h] [rbp-238h]\n  __m128i v65; // [rsp+D0h] [rbp-228h]\n  __m128i v66; // [rsp+E0h] [rbp-218h]\n  __m128i v67; // [rsp+F0h] [rbp-208h]\n  __m128i v68; // [rsp+100h] [rbp-1F8h]\n  __m128i v69; // [rsp+110h] [rbp-1E8h]\n  __m128i v70; // [rsp+120h] [rbp-1D8h]\n  __m128i v71; // [rsp+130h] [rbp-1C8h]\n  __m128i v72; // [rsp+140h] [rbp-1B8h]\n  __m128i v73; // [rsp+150h] [rbp-1A8h]\n  __m128i v74; // [rsp+160h] [rbp-198h]\n  __m128i v75; // [rsp+170h] [rbp-188h]\n  __m128i v76; // [rsp+180h] [rbp-178h]\n  __m128i v77; // [rsp+190h] [rbp-168h]\n  __m128i v78; // [rsp+1A0h] [rbp-158h]\n  __m128i v79; // [rsp+1B0h] [rbp-148h]\n  __m128i v80; // [rsp+1C0h] [rbp-138h]\n  __m128i v81; // [rsp+1D0h] [rbp-128h]\n  __m128i v82; // [rsp+1E0h] [rbp-118h]\n  __m128i v83; // [rsp+1F0h] [rbp-108h]\n  uint8_t round_keys[176]; // [rsp+200h] [rbp-F8h] BYREF\n  unsigned __int64 v85; // [rsp+2B8h] [rbp-40h]\n\n  v85 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  v3 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)data), *(__m128i *)round_keys);\n  v72 = v3;\n  v4 = _mm_cvtsi128_si32(v3);\n  v71 = v3;\n  v49 = v3.m128i_u8[12];\n  v83 = v3;\n  v5 = v3.m128i_u8[1];\n  v82 = v3;\n  v6 = v3.m128i_u8[2];\n  v81 = v3;\n  v7 = v3.m128i_u8[3];\n  v80 = v3;\n  v8 = v3.m128i_u8[4];\n  v79 = v3;\n  v9 = v3.m128i_u8[5];\n  v78 = v3;\n  v10 = v3.m128i_u8[6];\n  v77 = v3;\n  v11 = v3.m128i_u8[7];\n  v76 = v3;\n  v12 = v3.m128i_u8[8];\n  v75 = v3;\n  v13 = v3.m128i_u8[9];\n  v74 = v3;\n  v73 = v3;\n  v14 = v3.m128i_u8[11];\n  v50 = v3.m128i_u8[13];\n  *(__m128i *)data = v3;\n  v70 = v3;\n  v69 = v3;\n  v48.m128i_i8[0] = v3.m128i_i8[14];\n  v52 = v3.m128i_u8[10];\n  v51 = v3.m128i_u8[15];\n  v53 = &round_keys[160];\n  v15 = sbox;\n  do\n  {\n    v16 = v52;\n    *data = v15[v4];\n    v17 = v15[v5];\n    v18 = v48.m128i_u8[0];\n    data[1] = v17;\n    v19 = v15[v6];\n    data[2] = v19;\n    v20 = v15[v7];\n    data[3] = v20;\n    data[4] = v15[v8];\n    v21 = v15[v9];\n    v22 = v49;\n    data[5] = v21;\n    v23 = v15[v10];\n    data[6] = v23;\n    v24 = v15[v11];\n    data[7] = v24;\n    data[8] = v15[v12];\n    v25 = v15[v13];\n    data[9] = v25;\n    LOBYTE(v16) = v15[v16];\n    data[10] = v16;\n    v26 = v15[v14];\n    data[11] = v26;\n    data[12] = v15[v22];\n    LOBYTE(v22) = v15[v50];\n    data[13] = v22;\n    LOBYTE(v18) = v15[v18];\n    v27 = v51;\n    data[14] = v18;\n    LOBYTE(v27) = v15[v27];\n    data[1] = v21;\n    data[2] = v16;\n    data[3] = v27;\n    data[5] = v25;\n    data[6] = v18;\n    data[7] = v20;\n    data[9] = v22;\n    data[10] = v19;\n    data[11] = v24;\n    data[13] = v17;\n    data[14] = v23;\n    data[15] = v26;\n    mix_columns(data);\n    LOBYTE(v18) = *data;\n    v52 = *(v28 - 6) ^ data[10];\n    v29 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)data), *((__m128i *)v28 - 1));\n    v30 = data[1];\n    v49 = *(v28 - 4) ^ data[12];\n    v4 = *(v28 - 16) ^ v18;\n    v5 = *(v28 - 15) ^ v30;\n    v6 = *(v28 - 14) ^ data[2];\n    v7 = *(v28 - 13) ^ data[3];\n    v8 = *(v28 - 12) ^ data[4];\n    v9 = *(v28 - 11) ^ data[5];\n    v10 = *(v28 - 10) ^ data[6];\n    v11 = *(v28 - 9) ^ data[7];\n    v12 = *(v28 - 8) ^ data[8];\n    v13 = *(v28 - 7) ^ data[9];\n    v14 = *(v28 - 5) ^ data[11];\n    v50 = *(v28 - 3) ^ data[13];\n    v48.m128i_i8[0] = *(v28 - 2) ^ data[14];\n    v31 = *(v28 - 1) ^ data[15];\n    *(__m128i *)data = v29;\n    v51 = v31;\n  }\n  while ( v53 != v28 );\n  v32 = v15[(unsigned __int8)_mm_cvtsi128_si32(v29)];\n  v68 = v29;\n  *data = v32;\n  v33 = v15[v29.m128i_u8[1]];\n  v67 = v29;\n  data[1] = v33;\n  v34 = v15[v29.m128i_u8[2]];\n  v66 = v29;\n  v49 = v32;\n  data[2] = v34;\n  v50 = v34;\n  v35 = v15[v66.m128i_u8[3]];\n  v65 = v29;\n  data[3] = v35;\n  v36 = v15[v29.m128i_u8[4]];\n  v64 = v29;\n  data[4] = v36;\n  v37 = v15[v29.m128i_u8[5]];\n  v63 = v29;\n  data[5] = v37;\n  v38 = v15[v29.m128i_u8[6]];\n  v62 = v29;\n  data[6] = v38;\n  v39 = v15[v29.m128i_u8[7]];\n  data[7] = v39;\n  v61 = v29;\n  v40 = v15[v29.m128i_u8[8]];\n  v60 = v29;\n  data[8] = v40;\n  v41 = v15[v29.m128i_u8[9]];\n  v59 = v29;\n  data[9] = v41;\n  v42 = v15[v29.m128i_u8[10]];\n  v58 = v29;\n  data[10] = v42;\n  v43 = v15[v29.m128i_u8[11]];\n  v57 = v29;\n  data[11] = v43;\n  v44 = v15[v29.m128i_u8[12]];\n  v56 = v29;\n  data[12] = v44;\n  v45 = v15[v29.m128i_u8[13]];\n  v55 = v29;\n  data[13] = v45;\n  v48.m128i_i8[0] = v45;\n  v46 = v15[v55.m128i_u8[14]];\n  v54 = v29;\n  data[14] = v46;\n  v47 = v15[v29.m128i_u8[15]];\n  v48.m128i_i64[1] = v40 | ((v48.m128i_u8[0] | ((v50 | ((v39 | ((v44 | ((v33 | ((v38 | (v43 << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);\n  v48.m128i_i64[0] = v49 | ((v37 | ((v42 | ((v47 | ((v36 | ((v41 | ((v46 | (v35 << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);\n  *(__m128i *)data = _mm_xor_si128(_mm_load_si128(&v48), *(__m128i *)&round_keys[160]);\n}\n"}, "pseudo_normalize": "void aes_encrypt(uint8_t *data, const uint8_t *key) {\n  __m128i v3;\n  unsigned char v4;\n  unsigned char v5;\n  unsigned char v6;\n  unsigned char v7;\n  unsigned char v8;\n  unsigned char v9;\n  unsigned char v10;\n  unsigned char v11;\n  unsigned char v12;\n  unsigned char v13;\n  unsigned char v14;\n  uint8_t *v15;\n  long long v16;\n  uint8_t v17;\n  long long v18;\n  uint8_t v19;\n  uint8_t v20;\n  uint8_t v21;\n  long long v22;\n  uint8_t v23;\n  uint8_t v24;\n  uint8_t v25;\n  uint8_t v26;\n  long long v27;\n  uint8_t *v28;\n  __m128i v29;\n  uint8_t v30;\n  unsigned char v31;\n  uint8_t v32;\n  long long v33;\n  uint8_t v34;\n  long long v35;\n  long long v36;\n  long long v37;\n  long long v38;\n  long long v39;\n  uint8_t v40;\n  long long v41;\n  long long v42;\n  long long v43;\n  long long v44;\n  char v45;\n  long long v46;\n  long long v47;\n  __m128i v48;\n  unsigned char v49;\n  unsigned char v50;\n  unsigned char v51;\n  unsigned char v52;\n  uint8_t *v53;\n  __m128i v54;\n  __m128i v55;\n  __m128i v56;\n  __m128i v57;\n  __m128i v58;\n  __m128i v59;\n  __m128i v60;\n  __m128i v61;\n  __m128i v62;\n  __m128i v63;\n  __m128i v64;\n  __m128i v65;\n  __m128i v66;\n  __m128i v67;\n  __m128i v68;\n  __m128i v69;\n  __m128i v70;\n  __m128i v71;\n  __m128i v72;\n  __m128i v73;\n  __m128i v74;\n  __m128i v75;\n  __m128i v76;\n  __m128i v77;\n  __m128i v78;\n  __m128i v79;\n  __m128i v80;\n  __m128i v81;\n  __m128i v82;\n  __m128i v83;\n  uint8_t round_keys[176];\n  unsigned long long v85;\n  v85 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  v3 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)data),\n                     *(__m128i *)round_keys);\n  v72 = v3;\n  v4 = _mm_cvtsi128_si32(v3);\n  v71 = v3;\n  v49 = v3.m128i_u8[12];\n  v83 = v3;\n  v5 = v3.m128i_u8[1];\n  v82 = v3;\n  v6 = v3.m128i_u8[2];\n  v81 = v3;\n  v7 = v3.m128i_u8[3];\n  v80 = v3;\n  v8 = v3.m128i_u8[4];\n  v79 = v3;\n  v9 = v3.m128i_u8[5];\n  v78 = v3;\n  v10 = v3.m128i_u8[6];\n  v77 = v3;\n  v11 = v3.m128i_u8[7];\n  v76 = v3;\n  v12 = v3.m128i_u8[8];\n  v75 = v3;\n  v13 = v3.m128i_u8[9];\n  v74 = v3;\n  v73 = v3;\n  v14 = v3.m128i_u8[11];\n  v50 = v3.m128i_u8[13];\n  *(__m128i *)data = v3;\n  v70 = v3;\n  v69 = v3;\n  v48.m128i_i8[0] = v3.m128i_i8[14];\n  v52 = v3.m128i_u8[10];\n  v51 = v3.m128i_u8[15];\n  v53 = &round_keys[160];\n  v15 = sbox;\n  do {\n    v16 = v52;\n    *data = v15[v4];\n    v17 = v15[v5];\n    v18 = v48.m128i_u8[0];\n    data[1] = v17;\n    v19 = v15[v6];\n    data[2] = v19;\n    v20 = v15[v7];\n    data[3] = v20;\n    data[4] = v15[v8];\n    v21 = v15[v9];\n    v22 = v49;\n    data[5] = v21;\n    v23 = v15[v10];\n    data[6] = v23;\n    v24 = v15[v11];\n    data[7] = v24;\n    data[8] = v15[v12];\n    v25 = v15[v13];\n    data[9] = v25;\n    LOBYTE(v16) = v15[v16];\n    data[10] = v16;\n    v26 = v15[v14];\n    data[11] = v26;\n    data[12] = v15[v22];\n    LOBYTE(v22) = v15[v50];\n    data[13] = v22;\n    LOBYTE(v18) = v15[v18];\n    v27 = v51;\n    data[14] = v18;\n    LOBYTE(v27) = v15[v27];\n    data[1] = v21;\n    data[2] = v16;\n    data[3] = v27;\n    data[5] = v25;\n    data[6] = v18;\n    data[7] = v20;\n    data[9] = v22;\n    data[10] = v19;\n    data[11] = v24;\n    data[13] = v17;\n    data[14] = v23;\n    data[15] = v26;\n    mix_columns(data);\n    LOBYTE(v18) = *data;\n    v52 = *(v28 - 6) ^ data[10];\n    v29 = _mm_xor_si128(_mm_loadu_si128((const __m128i *)data),\n                        *((__m128i *)v28 - 1));\n    v30 = data[1];\n    v49 = *(v28 - 4) ^ data[12];\n    v4 = *(v28 - 16) ^ v18;\n    v5 = *(v28 - 15) ^ v30;\n    v6 = *(v28 - 14) ^ data[2];\n    v7 = *(v28 - 13) ^ data[3];\n    v8 = *(v28 - 12) ^ data[4];\n    v9 = *(v28 - 11) ^ data[5];\n    v10 = *(v28 - 10) ^ data[6];\n    v11 = *(v28 - 9) ^ data[7];\n    v12 = *(v28 - 8) ^ data[8];\n    v13 = *(v28 - 7) ^ data[9];\n    v14 = *(v28 - 5) ^ data[11];\n    v50 = *(v28 - 3) ^ data[13];\n    v48.m128i_i8[0] = *(v28 - 2) ^ data[14];\n    v31 = *(v28 - 1) ^ data[15];\n    *(__m128i *)data = v29;\n    v51 = v31;\n  } while (v53 != v28);\n  v32 = v15[(unsigned char)_mm_cvtsi128_si32(v29)];\n  v68 = v29;\n  *data = v32;\n  v33 = v15[v29.m128i_u8[1]];\n  v67 = v29;\n  data[1] = v33;\n  v34 = v15[v29.m128i_u8[2]];\n  v66 = v29;\n  v49 = v32;\n  data[2] = v34;\n  v50 = v34;\n  v35 = v15[v66.m128i_u8[3]];\n  v65 = v29;\n  data[3] = v35;\n  v36 = v15[v29.m128i_u8[4]];\n  v64 = v29;\n  data[4] = v36;\n  v37 = v15[v29.m128i_u8[5]];\n  v63 = v29;\n  data[5] = v37;\n  v38 = v15[v29.m128i_u8[6]];\n  v62 = v29;\n  data[6] = v38;\n  v39 = v15[v29.m128i_u8[7]];\n  data[7] = v39;\n  v61 = v29;\n  v40 = v15[v29.m128i_u8[8]];\n  v60 = v29;\n  data[8] = v40;\n  v41 = v15[v29.m128i_u8[9]];\n  v59 = v29;\n  data[9] = v41;\n  v42 = v15[v29.m128i_u8[10]];\n  v58 = v29;\n  data[10] = v42;\n  v43 = v15[v29.m128i_u8[11]];\n  v57 = v29;\n  data[11] = v43;\n  v44 = v15[v29.m128i_u8[12]];\n  v56 = v29;\n  data[12] = v44;\n  v45 = v15[v29.m128i_u8[13]];\n  v55 = v29;\n  data[13] = v45;\n  v48.m128i_i8[0] = v45;\n  v46 = v15[v55.m128i_u8[14]];\n  v54 = v29;\n  data[14] = v46;\n  v47 = v15[v29.m128i_u8[15]];\n  v48.m128i_i64[1] =\n      v40 |\n      ((v48.m128i_u8[0] |\n        ((v50 | ((v39 | ((v44 | ((v33 | ((v38 | (v43 << 8)) << 8)) << 8)) << 8))\n                 << 8))\n         << 8))\n       << 8);\n  v48.m128i_i64[0] =\n      v49 |\n      ((v37 |\n        ((v42 | ((v47 | ((v36 | ((v41 | ((v46 | (v35 << 8)) << 8)) << 8)) << 8))\n                 << 8))\n         << 8))\n       << 8);\n  *(__m128i *)data =\n      _mm_xor_si128(_mm_load_si128(&v48), *(__m128i *)&round_keys[160]);\n}", "binary": "aes/aes.host.O3", "assembly": "<aes_encrypt>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %rsi,%rdi\nsub    $0x2c8,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x2b8(%rsp)\nxor    %eax,%eax\nlea    0x200(%rsp),%rsi\ncall   1ff0 <key_expansion>\nmovdqu (%rbx),%xmm0\npxor   0x200(%rsp),%xmm0\nlea    0x210(%rsp),%r10\nmovaps %xmm0,0x140(%rsp)\nmovd   %xmm0,%r14d\nmovzbl 0x14c(%rsp),%r11d\nmovaps %xmm0,0x130(%rsp)\nmov    %r11b,0x14(%rsp)\nmovzbl 0x13d(%rsp),%r11d\nmovaps %xmm0,0x1f0(%rsp)\nmovzbl 0x1f1(%rsp),%r13d\nmovaps %xmm0,0x1e0(%rsp)\nmovzbl 0x1e2(%rsp),%r12d\nmovaps %xmm0,0x1d0(%rsp)\nmovzbl 0x1d3(%rsp),%ebp\nmovaps %xmm0,0x1c0(%rsp)\nmovzbl 0x1c4(%rsp),%r9d\nmovaps %xmm0,0x1b0(%rsp)\nmovzbl 0x1b5(%rsp),%r8d\nmovaps %xmm0,0x1a0(%rsp)\nmovzbl 0x1a6(%rsp),%edi\nmovaps %xmm0,0x190(%rsp)\nmovzbl 0x197(%rsp),%esi\nmovaps %xmm0,0x180(%rsp)\nmovzbl 0x188(%rsp),%ecx\nmovaps %xmm0,0x170(%rsp)\nmovzbl 0x179(%rsp),%edx\nmovaps %xmm0,0x160(%rsp)\nmovzbl 0x16a(%rsp),%eax\nmovaps %xmm0,0x150(%rsp)\nmovzbl 0x15b(%rsp),%r15d\nmov    %r11b,0x15(%rsp)\nmovups %xmm0,(%rbx)\nmovaps %xmm0,0x120(%rsp)\nmovzbl 0x12e(%rsp),%r11d\nmovaps %xmm0,0x110(%rsp)\nmov    %r11b,(%rsp)\nmovzbl 0x11f(%rsp),%r11d\nmov    %al,0x17(%rsp)\nmov    %r11b,0x16(%rsp)\nlea    0x2a0(%rsp),%r11\nmov    %r11,0x18(%rsp)\nlea    0x5da4(%rip),%r11\nnopl   0x0(%rax)\nmovzbl %r14b,%r14d\nmovzbl %r13b,%r13d\nmovzbl %r12b,%r12d\nmovzbl %bpl,%ebp\nmovzbl (%r11,%r14,1),%r14d\nmovzbl %r9b,%r9d\nmovzbl %r8b,%r8d\nmovzbl %cl,%ecx\nmovzbl %dil,%edi\nmovzbl %sil,%esi\nmovzbl %dl,%edx\nmovzbl 0x17(%rsp),%eax\nmov    %r14b,(%rbx)\nmovzbl (%r11,%r13,1),%r13d\nmovzbl %r15b,%r15d\nadd    $0x10,%r10\nmovzbl (%rsp),%r14d\nmov    %r13b,0x1(%rbx)\nmovzbl (%r11,%r12,1),%r12d\nmov    %r12b,0x2(%rbx)\nmovzbl (%r11,%rbp,1),%ebp\nmov    %bpl,0x3(%rbx)\nmovzbl (%r11,%r9,1),%r9d\nmov    %r9b,0x4(%rbx)\nmovzbl (%r11,%r8,1),%r8d\nmovzbl 0x14(%rsp),%r9d\nmov    %r8b,0x5(%rbx)\nmovzbl (%r11,%rdi,1),%edi\nmov    %dil,0x6(%rbx)\nmovzbl (%r11,%rsi,1),%esi\nmov    %sil,0x7(%rbx)\nmovzbl (%r11,%rcx,1),%ecx\nmov    %cl,0x8(%rbx)\nmovzbl (%r11,%rdx,1),%edx\nmov    %dl,0x9(%rbx)\nmovzbl (%r11,%rax,1),%eax\nmov    %al,0xa(%rbx)\nmovzbl (%r11,%r15,1),%ecx\nmov    %cl,0xb(%rbx)\nmovzbl (%r11,%r9,1),%r9d\nmov    %r9b,0xc(%rbx)\nmovzbl 0x15(%rsp),%r9d\nmovzbl (%r11,%r9,1),%r9d\nmov    %r9b,0xd(%rbx)\nmovzbl (%r11,%r14,1),%r14d\nmovzbl 0x16(%rsp),%r15d\nmov    %r14b,0xe(%rbx)\nmovzbl (%r11,%r15,1),%r15d\nmov    %r8b,0x1(%rbx)\nmov    %al,0x2(%rbx)\nmov    %r15b,0x3(%rbx)\nmov    %dl,0x5(%rbx)\nmov    %r14b,0x6(%rbx)\nmov    %bpl,0x7(%rbx)\nmov    %r9b,0x9(%rbx)\nmov    %r12b,0xa(%rbx)\nmov    %sil,0xb(%rbx)\nmov    %r13b,0xd(%rbx)\nmov    %dil,0xe(%rbx)\nmov    %rbx,%rdi\nmov    %cl,0xf(%rbx)\ncall   1bd0 <mix_columns>\nmovzbl 0xa(%rbx),%eax\nxor    -0x6(%r10),%al\nmovdqu (%rbx),%xmm0\nmovzbl (%rbx),%r14d\nmov    %al,0x17(%rsp)\nmovzbl 0xc(%rbx),%eax\nxor    -0x4(%r10),%al\npxor   -0x10(%r10),%xmm0\nmovzbl 0x1(%rbx),%r13d\nmov    %al,0x14(%rsp)\nmovzbl 0xd(%rbx),%eax\nxor    -0x3(%r10),%al\nmovzbl 0x2(%rbx),%r12d\nmovzbl 0x3(%rbx),%ebp\nmovzbl 0x4(%rbx),%r9d\nmovzbl 0x5(%rbx),%r8d\nmovzbl 0x6(%rbx),%edi\nmovzbl 0x7(%rbx),%esi\nmovzbl 0x8(%rbx),%ecx\nmovzbl 0x9(%rbx),%edx\nmovzbl 0xb(%rbx),%r15d\nxor    -0x10(%r10),%r14b\nxor    -0xf(%r10),%r13b\nxor    -0xe(%r10),%r12b\nxor    -0xd(%r10),%bpl\nxor    -0xc(%r10),%r9b\nxor    -0xb(%r10),%r8b\nxor    -0xa(%r10),%dil\nxor    -0x9(%r10),%sil\nxor    -0x8(%r10),%cl\nxor    -0x7(%r10),%dl\nxor    -0x5(%r10),%r15b\nmov    %al,0x15(%rsp)\nmovzbl 0xe(%rbx),%eax\nxor    -0x2(%r10),%al\nmov    %al,(%rsp)\nmovzbl 0xf(%rbx),%eax\nxor    -0x1(%r10),%al\nmovups %xmm0,(%rbx)\nmov    %al,0x16(%rsp)\ncmp    %r10,0x18(%rsp)\njne    2380 <aes_encrypt+0x180>\nmovd   %xmm0,%eax\nmovzbl %al,%eax\nmovzbl (%r11,%rax,1),%ecx\nmovaps %xmm0,0x100(%rsp)\nmovzbl 0x101(%rsp),%eax\nmov    %cl,(%rbx)\nmovzbl (%r11,%rax,1),%r8d\nmovaps %xmm0,0xf0(%rsp)\nmovzbl 0xf2(%rsp),%eax\nmov    %r8b,0x1(%rbx)\nmovzbl (%r11,%rax,1),%eax\nmovaps %xmm0,0xe0(%rsp)\nmov    %cl,0x14(%rsp)\nmov    %al,0x2(%rbx)\nmov    %al,0x15(%rsp)\nmovzbl 0xe3(%rsp),%eax\nmovzbl (%r11,%rax,1),%edx\nmovaps %xmm0,0xd0(%rsp)\nmovzbl 0xd4(%rsp),%eax\nmov    %dl,0x3(%rbx)\nmovzbl (%r11,%rax,1),%r12d\nshl    $0x8,%rdx\nmovaps %xmm0,0xc0(%rsp)\nmovzbl 0xc5(%rsp),%eax\nmov    %r12b,0x4(%rbx)\nmovzbl (%r11,%rax,1),%r10d\nmovaps %xmm0,0xb0(%rsp)\nmovzbl 0xb6(%rsp),%eax\nmov    %r10b,0x5(%rbx)\nmovzbl (%r11,%rax,1),%r9d\nmovaps %xmm0,0xa0(%rsp)\nmovzbl 0xa7(%rsp),%eax\nmov    %r9b,0x6(%rbx)\nmovzbl (%r11,%rax,1),%esi\nmov    %sil,0x7(%rbx)\nmovaps %xmm0,0x90(%rsp)\nmovzbl 0x98(%rsp),%eax\nmovzbl (%r11,%rax,1),%r15d\nmovaps %xmm0,0x80(%rsp)\nmovzbl 0x89(%rsp),%eax\nmov    %r15b,0x8(%rbx)\nmovzbl (%r11,%rax,1),%r13d\nmovaps %xmm0,0x70(%rsp)\nmovzbl 0x7a(%rsp),%eax\nmov    %r13b,0x9(%rbx)\nmovzbl (%r11,%rax,1),%ebp\nmovaps %xmm0,0x60(%rsp)\nmovzbl 0x6b(%rsp),%eax\nmov    %bpl,0xa(%rbx)\nmovzbl (%r11,%rax,1),%eax\nmovaps %xmm0,0x50(%rsp)\nmovzbl 0x5c(%rsp),%edi\nmov    %al,0xb(%rbx)\nshl    $0x8,%rax\nmovzbl (%r11,%rdi,1),%edi\nmovaps %xmm0,0x40(%rsp)\nmovzbl 0x4d(%rsp),%r14d\nor     %r9,%rax\nshl    $0x8,%rax\nmov    %dil,0xc(%rbx)\nmovzbl (%r11,%r14,1),%r14d\nor     %r8,%rax\nmovaps %xmm0,0x30(%rsp)\nshl    $0x8,%rax\nmov    %r14b,0xd(%rbx)\nor     %rdi,%rax\nmov    %r14b,(%rsp)\nmovzbl 0x3e(%rsp),%r14d\nshl    $0x8,%rax\nor     %rsi,%rax\nmovzbl (%r11,%r14,1),%r14d\nmovaps %xmm0,0x20(%rsp)\nmovzbl 0x2f(%rsp),%ecx\nshl    $0x8,%rax\nor     %r14,%rdx\nmov    %r14b,0xe(%rbx)\nmovzbl (%r11,%rcx,1),%r11d\nshl    $0x8,%rdx\nmovzbl 0x14(%rsp),%ecx\nmovzbl 0x15(%rsp),%esi\nor     %r13,%rdx\nshl    $0x8,%rdx\nor     %rsi,%rax\nmovzbl (%rsp),%esi\nor     %r12,%rdx\nshl    $0x8,%rax\nshl    $0x8,%rdx\nor     %rsi,%rax\nmovzbl %r15b,%esi\nor     %r11,%rdx\nshl    $0x8,%rax\nshl    $0x8,%rdx\nor     %rsi,%rax\nor     %rbp,%rdx\nmov    %rax,0x8(%rsp)\nshl    $0x8,%rdx\nor     %r10,%rdx\nshl    $0x8,%rdx\nor     %rcx,%rdx\nmov    %rdx,(%rsp)\nmovdqa (%rsp),%xmm0\npxor   0x2a0(%rsp),%xmm0\nmovups %xmm0,(%rbx)\nmov    0x2b8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    2751 <aes_encrypt+0x551>\nadd    $0x2c8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "aes/aes.c", "function_name": "gf256_mul2", "content": "/*\n * Multiply by 0x02 in GF(2^8) using the AES irreducible polynomial.\n * If the high bit is set, reduce the result modulo 0x11B by XORing with 0x1B.\n */\nuint8_t gf256_mul2(uint8_t x) { return (x << 1) ^ ((x & 0x80) ? 0x1b : 0x00); }\n"}, "pseudo": {"path": "aes/aes.host.O3.pseudo", "function_name": "gf256_mul2", "address": "0x1bb0", "label": "gf256_mul2", "content": "uint8_t __fastcall gf256_mul2(uint8_t x)\n{\n  uint8_t result; // al\n\n  result = 2 * x;\n  if ( (x & 0x80u) != 0 )\n    return (2 * x) ^ 0x1B;\n  return result;\n}\n"}, "pseudo_normalize": "uint8_t gf256_mul2(uint8_t x) {\n  uint8_t result;\n  result = 2 * x;\n  if ((x & 128u) != 0) return (2 * x) ^ 27;\n  return result;\n}", "binary": "aes/aes.host.O3", "assembly": "<gf256_mul2>:\nendbr64\nmovzbl %dil,%eax\nadd    %eax,%eax\nmov    %eax,%edx\nxor    $0x1b,%edx\ntest   %dil,%dil\ncmovs  %edx,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "aes/aes.c", "function_name": "inv_mix_columns", "content": "void inv_mix_columns(uint8_t *s) {\n  for (int i = 0; i < 4; i++) {\n    int c = i * 4;\n    uint8_t a = s[c];\n    uint8_t b = s[c + 1];\n    uint8_t c1 = s[c + 2];\n    uint8_t d = s[c + 3];\n\n    uint8_t a1 = gf256_mul2(gf256_mul2(a ^ c1));\n    uint8_t b1 = gf256_mul2(gf256_mul2(b ^ d));\n\n    s[c] ^= a1;\n    s[c + 1] ^= b1;\n    s[c + 2] ^= a1;\n    s[c + 3] ^= b1;\n  }\n  mix_columns(s);\n}\n"}, "pseudo": {"path": "aes/aes.host.O3.pseudo", "function_name": "inv_mix_columns", "address": "0x1e40", "label": "inv_mix_columns", "content": "void __fastcall inv_mix_columns(uint8_t *s)\n{\n  char v1; // dl\n  char v2; // al\n  char v3; // dl\n  char v4; // al\n  char v5; // cl\n  char v6; // al\n  uint8_t v7; // cl\n  uint8_t v8; // dl\n  uint8_t v9; // cl\n  uint8_t v10; // cl\n  char v11; // dl\n  char v12; // al\n  char v13; // dl\n  char v14; // al\n  char v15; // cl\n  char v16; // al\n  uint8_t v17; // cl\n  uint8_t v18; // dl\n  uint8_t v19; // cl\n  uint8_t v20; // cl\n  char v21; // dl\n  char v22; // al\n  char v23; // dl\n  char v24; // al\n  char v25; // cl\n  char v26; // al\n  char v27; // dl\n  char v28; // al\n  char v29; // dl\n  char v30; // al\n  char v31; // cl\n  char v32; // al\n  uint8_t v33; // cl\n  uint8_t v34; // dl\n  uint8_t v35; // cl\n  uint8_t v36; // cl\n  uint8_t v37; // al\n\n  v1 = s[2] ^ *s;\n  v2 = 2 * v1;\n  if ( v1 < 0 )\n    v2 = (2 * v1) ^ 0x1B;\n  v3 = 2 * v2;\n  if ( v2 < 0 )\n    v3 = (2 * v2) ^ 0x1B;\n  v4 = s[3] ^ s[1];\n  v5 = 2 * v4;\n  if ( v4 < 0 )\n    v5 = (2 * v4) ^ 0x1B;\n  v6 = 2 * v5;\n  if ( v5 < 0 )\n    v6 = (2 * v5) ^ 0x1B;\n  v7 = v3 ^ *s;\n  v8 = s[2] ^ v3;\n  *s = v7;\n  v9 = s[1];\n  s[2] = v8;\n  v10 = v6 ^ v9;\n  v11 = s[4] ^ s[6];\n  s[3] ^= v6;\n  v12 = 2 * v11;\n  s[1] = v10;\n  if ( v11 < 0 )\n    v12 = (2 * v11) ^ 0x1B;\n  v13 = 2 * v12;\n  if ( v12 < 0 )\n    v13 = (2 * v12) ^ 0x1B;\n  v14 = s[5] ^ s[7];\n  v15 = 2 * v14;\n  if ( v14 < 0 )\n    v15 = (2 * v14) ^ 0x1B;\n  v16 = 2 * v15;\n  if ( v15 < 0 )\n    v16 = (2 * v15) ^ 0x1B;\n  v17 = v13 ^ s[4];\n  v18 = s[6] ^ v13;\n  s[4] = v17;\n  v19 = s[5];\n  s[6] = v18;\n  v20 = v16 ^ v19;\n  v21 = s[10] ^ s[8];\n  s[7] ^= v16;\n  v22 = 2 * v21;\n  s[5] = v20;\n  if ( v21 < 0 )\n    v22 = (2 * v21) ^ 0x1B;\n  v23 = 2 * v22;\n  if ( v22 < 0 )\n    v23 = (2 * v22) ^ 0x1B;\n  v24 = s[11] ^ s[9];\n  v25 = 2 * v24;\n  if ( v24 < 0 )\n    v25 = (2 * v24) ^ 0x1B;\n  v26 = 2 * v25;\n  if ( v25 < 0 )\n    v26 = (2 * v25) ^ 0x1B;\n  s[8] ^= v23;\n  s[9] ^= v26;\n  s[10] ^= v23;\n  v27 = s[12] ^ s[14];\n  s[11] ^= v26;\n  v28 = 2 * v27;\n  if ( v27 < 0 )\n    v28 = (2 * v27) ^ 0x1B;\n  v29 = 2 * v28;\n  if ( v28 < 0 )\n    v29 = (2 * v28) ^ 0x1B;\n  v30 = s[13] ^ s[15];\n  v31 = 2 * v30;\n  if ( v30 < 0 )\n    v31 = (2 * v30) ^ 0x1B;\n  v32 = 2 * v31;\n  if ( v31 < 0 )\n    v32 = (2 * v31) ^ 0x1B;\n  v33 = v29 ^ s[12];\n  v34 = s[14] ^ v29;\n  s[12] = v33;\n  v35 = s[13];\n  s[14] = v34;\n  v36 = v32 ^ v35;\n  v37 = s[15] ^ v32;\n  s[13] = v36;\n  s[15] = v37;\n  mix_columns(s);\n}\n"}, "pseudo_normalize": "void inv_mix_columns(uint8_t *s) {\n  char v1;\n  char v2;\n  char v3;\n  char v4;\n  char v5;\n  char v6;\n  uint8_t v7;\n  uint8_t v8;\n  uint8_t v9;\n  uint8_t v10;\n  char v11;\n  char v12;\n  char v13;\n  char v14;\n  char v15;\n  char v16;\n  uint8_t v17;\n  uint8_t v18;\n  uint8_t v19;\n  uint8_t v20;\n  char v21;\n  char v22;\n  char v23;\n  char v24;\n  char v25;\n  char v26;\n  char v27;\n  char v28;\n  char v29;\n  char v30;\n  char v31;\n  char v32;\n  uint8_t v33;\n  uint8_t v34;\n  uint8_t v35;\n  uint8_t v36;\n  uint8_t v37;\n  v1 = s[2] ^ *s;\n  v2 = 2 * v1;\n  if (v1 < 0) v2 = (2 * v1) ^ 27;\n  v3 = 2 * v2;\n  if (v2 < 0) v3 = (2 * v2) ^ 27;\n  v4 = s[3] ^ s[1];\n  v5 = 2 * v4;\n  if (v4 < 0) v5 = (2 * v4) ^ 27;\n  v6 = 2 * v5;\n  if (v5 < 0) v6 = (2 * v5) ^ 27;\n  v7 = v3 ^ *s;\n  v8 = s[2] ^ v3;\n  *s = v7;\n  v9 = s[1];\n  s[2] = v8;\n  v10 = v6 ^ v9;\n  v11 = s[4] ^ s[6];\n  s[3] ^= v6;\n  v12 = 2 * v11;\n  s[1] = v10;\n  if (v11 < 0) v12 = (2 * v11) ^ 27;\n  v13 = 2 * v12;\n  if (v12 < 0) v13 = (2 * v12) ^ 27;\n  v14 = s[5] ^ s[7];\n  v15 = 2 * v14;\n  if (v14 < 0) v15 = (2 * v14) ^ 27;\n  v16 = 2 * v15;\n  if (v15 < 0) v16 = (2 * v15) ^ 27;\n  v17 = v13 ^ s[4];\n  v18 = s[6] ^ v13;\n  s[4] = v17;\n  v19 = s[5];\n  s[6] = v18;\n  v20 = v16 ^ v19;\n  v21 = s[10] ^ s[8];\n  s[7] ^= v16;\n  v22 = 2 * v21;\n  s[5] = v20;\n  if (v21 < 0) v22 = (2 * v21) ^ 27;\n  v23 = 2 * v22;\n  if (v22 < 0) v23 = (2 * v22) ^ 27;\n  v24 = s[11] ^ s[9];\n  v25 = 2 * v24;\n  if (v24 < 0) v25 = (2 * v24) ^ 27;\n  v26 = 2 * v25;\n  if (v25 < 0) v26 = (2 * v25) ^ 27;\n  s[8] ^= v23;\n  s[9] ^= v26;\n  s[10] ^= v23;\n  v27 = s[12] ^ s[14];\n  s[11] ^= v26;\n  v28 = 2 * v27;\n  if (v27 < 0) v28 = (2 * v27) ^ 27;\n  v29 = 2 * v28;\n  if (v28 < 0) v29 = (2 * v28) ^ 27;\n  v30 = s[13] ^ s[15];\n  v31 = 2 * v30;\n  if (v30 < 0) v31 = (2 * v30) ^ 27;\n  v32 = 2 * v31;\n  if (v31 < 0) v32 = (2 * v31) ^ 27;\n  v33 = v29 ^ s[12];\n  v34 = s[14] ^ v29;\n  s[12] = v33;\n  v35 = s[13];\n  s[14] = v34;\n  v36 = v32 ^ v35;\n  v37 = s[15] ^ v32;\n  s[13] = v36;\n  s[15] = v37;\n  mix_columns(s);\n}", "binary": "aes/aes.host.O3", "assembly": "<inv_mix_columns>:\nendbr64\nmovzbl (%rdi),%edx\nxor    0x2(%rdi),%dl\nmovzbl %dl,%eax\nadd    %eax,%eax\nmov    %eax,%ecx\nxor    $0x1b,%ecx\ntest   %dl,%dl\ncmovs  %ecx,%eax\nmovzbl %al,%edx\nadd    %edx,%edx\nmov    %edx,%ecx\nxor    $0x1b,%ecx\ntest   %al,%al\nmovzbl 0x1(%rdi),%eax\ncmovs  %ecx,%edx\nxor    0x3(%rdi),%al\nmovzbl %al,%ecx\nadd    %ecx,%ecx\nmov    %ecx,%esi\nxor    $0x1b,%esi\ntest   %al,%al\ncmovs  %esi,%ecx\nmovzbl %cl,%eax\nadd    %eax,%eax\nmov    %eax,%esi\nxor    $0x1b,%esi\ntest   %cl,%cl\nmovzbl (%rdi),%ecx\ncmovs  %esi,%eax\nxor    %edx,%ecx\nxor    0x2(%rdi),%dl\nmov    %cl,(%rdi)\nmovzbl 0x1(%rdi),%ecx\nmov    %dl,0x2(%rdi)\nmovzbl 0x6(%rdi),%edx\nxor    %eax,%ecx\nxor    0x4(%rdi),%dl\nxor    0x3(%rdi),%al\nmov    %al,0x3(%rdi)\nmovzbl %dl,%eax\nadd    %eax,%eax\nmov    %cl,0x1(%rdi)\nmov    %eax,%ecx\nxor    $0x1b,%ecx\ntest   %dl,%dl\ncmovs  %ecx,%eax\nmovzbl %al,%edx\nadd    %edx,%edx\nmov    %edx,%ecx\nxor    $0x1b,%ecx\ntest   %al,%al\nmovzbl 0x7(%rdi),%eax\ncmovs  %ecx,%edx\nxor    0x5(%rdi),%al\nmovzbl %al,%ecx\nadd    %ecx,%ecx\nmov    %ecx,%esi\nxor    $0x1b,%esi\ntest   %al,%al\ncmovs  %esi,%ecx\nmovzbl %cl,%eax\nadd    %eax,%eax\nmov    %eax,%esi\nxor    $0x1b,%esi\ntest   %cl,%cl\nmovzbl 0x4(%rdi),%ecx\ncmovs  %esi,%eax\nxor    %edx,%ecx\nxor    0x6(%rdi),%dl\nmov    %cl,0x4(%rdi)\nmovzbl 0x5(%rdi),%ecx\nmov    %dl,0x6(%rdi)\nmovzbl 0x8(%rdi),%edx\nxor    %eax,%ecx\nxor    0xa(%rdi),%dl\nxor    0x7(%rdi),%al\nmov    %al,0x7(%rdi)\nmovzbl %dl,%eax\nadd    %eax,%eax\nmov    %cl,0x5(%rdi)\nmov    %eax,%ecx\nxor    $0x1b,%ecx\ntest   %dl,%dl\ncmovs  %ecx,%eax\nmovzbl %al,%edx\nadd    %edx,%edx\nmov    %edx,%ecx\nxor    $0x1b,%ecx\ntest   %al,%al\nmovzbl 0x9(%rdi),%eax\ncmovs  %ecx,%edx\nxor    0xb(%rdi),%al\nmovzbl %al,%ecx\nadd    %ecx,%ecx\nmov    %ecx,%esi\nxor    $0x1b,%esi\ntest   %al,%al\ncmovs  %esi,%ecx\nmovzbl %cl,%eax\nadd    %eax,%eax\nmov    %eax,%esi\nxor    $0x1b,%esi\ntest   %cl,%cl\nmovzbl 0x8(%rdi),%ecx\ncmovs  %esi,%eax\nxor    %edx,%ecx\nmov    %cl,0x8(%rdi)\nmovzbl 0x9(%rdi),%ecx\nxor    %eax,%ecx\nmov    %cl,0x9(%rdi)\nxor    0xa(%rdi),%dl\nmov    %dl,0xa(%rdi)\nxor    0xb(%rdi),%al\nmovzbl 0xe(%rdi),%edx\nxor    0xc(%rdi),%dl\nmov    %al,0xb(%rdi)\nmovzbl %dl,%eax\nadd    %eax,%eax\nmov    %eax,%ecx\nxor    $0x1b,%ecx\ntest   %dl,%dl\ncmovs  %ecx,%eax\nmovzbl %al,%edx\nadd    %edx,%edx\nmov    %edx,%ecx\nxor    $0x1b,%ecx\ntest   %al,%al\nmovzbl 0xf(%rdi),%eax\ncmovs  %ecx,%edx\nxor    0xd(%rdi),%al\nmovzbl %al,%ecx\nadd    %ecx,%ecx\nmov    %ecx,%esi\nxor    $0x1b,%esi\ntest   %al,%al\ncmovs  %esi,%ecx\nmovzbl %cl,%eax\nadd    %eax,%eax\nmov    %eax,%esi\nxor    $0x1b,%esi\ntest   %cl,%cl\nmovzbl 0xc(%rdi),%ecx\ncmovs  %esi,%eax\nxor    %edx,%ecx\nxor    0xe(%rdi),%dl\nmov    %cl,0xc(%rdi)\nmovzbl 0xd(%rdi),%ecx\nmov    %dl,0xe(%rdi)\nxor    %eax,%ecx\nxor    0xf(%rdi),%al\nmov    %cl,0xd(%rdi)\nmov    %al,0xf(%rdi)\njmp    1bd0 <mix_columns>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "aes/aes.c", "function_name": "inv_shift_rows", "content": "void inv_shift_rows(uint8_t *s) {\n  uint8_t res[BLK_SIZE];\n  uint8_t idx[BLK_SIZE] = {0, 13, 10, 7,  4,  1, 14, 11,\n                           8, 5,  2,  15, 12, 9, 6,  3};\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    res[i] = s[idx[i]];\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = res[i];\n}\n"}, "pseudo": {"path": "aes/aes.host.O3.pseudo", "function_name": "inv_shift_rows", "address": "0x1af0", "label": "inv_shift_rows", "content": "void __fastcall inv_shift_rows(uint8_t *s)\n{\n  unsigned __int64 v2; // rdx\n  unsigned __int64 v3; // rax\n  __int64 v4; // rdi\n  __m128i v5; // [rsp+0h] [rbp-18h] BYREF\n\n  v2 = *s | ((s[13] | ((s[10] | ((s[7] | ((s[4] | ((s[1] | ((s[14] | ((unsigned __int64)s[11] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);\n  v3 = s[6] | ((unsigned __int64)s[3] << 8);\n  v4 = s[9];\n  v5.m128i_i64[0] = v2;\n  v5.m128i_i64[1] = s[8] | ((s[5] | ((s[2] | ((s[15] | ((s[12] | ((v4 | (v3 << 8)) << 8)) << 8)) << 8)) << 8)) << 8);\n  *(__m128i *)s = _mm_load_si128(&v5);\n}\n"}, "pseudo_normalize": "void inv_shift_rows(uint8_t *s) {\n  unsigned long long v2;\n  unsigned long long v3;\n  long long v4;\n  __m128i v5;\n  v2 =\n      *s |\n      ((s[13] |\n        ((s[10] |\n          ((s[7] |\n            ((s[4] |\n              ((s[1] | ((s[14] | ((unsigned long long)s[11] << 8)) << 8)) << 8))\n             << 8))\n           << 8))\n         << 8))\n       << 8);\n  v3 = s[6] | ((unsigned long long)s[3] << 8);\n  v4 = s[9];\n  v5.m128i_i64[0] = v2;\n  v5.m128i_i64[1] =\n      s[8] |\n      ((s[5] |\n        ((s[2] | ((s[15] | ((s[12] | ((v4 | (v3 << 8)) << 8)) << 8)) << 8))\n         << 8))\n       << 8);\n  *(__m128i *)s = _mm_load_si128(&v5);\n}", "binary": "aes/aes.host.O3", "assembly": "<inv_shift_rows>:\nendbr64\nmovzbl 0xb(%rdi),%edx\nmovzbl 0xe(%rdi),%eax\nmov    %rdi,%rcx\nmovzbl (%rdi),%esi\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl 0x1(%rdi),%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl 0x4(%rdi),%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl 0x7(%rdi),%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl 0xa(%rdi),%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl 0xd(%rdi),%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl 0x3(%rdi),%eax\nmovzbl 0x6(%rdi),%edi\nshl    $0x8,%rdx\nshl    $0x8,%rax\nor     %rsi,%rdx\nor     %rdi,%rax\nmovzbl 0x9(%rcx),%edi\nmov    %rdx,-0x18(%rsp)\nshl    $0x8,%rax\nor     %rdi,%rax\nmovzbl 0xc(%rcx),%edi\nshl    $0x8,%rax\nor     %rdi,%rax\nmovzbl 0xf(%rcx),%edi\nshl    $0x8,%rax\nor     %rdi,%rax\nmovzbl 0x2(%rcx),%edi\nshl    $0x8,%rax\nor     %rdi,%rax\nmovzbl 0x5(%rcx),%edi\nshl    $0x8,%rax\nor     %rdi,%rax\nmovzbl 0x8(%rcx),%edi\nshl    $0x8,%rax\nor     %rdi,%rax\nmov    %rax,-0x10(%rsp)\nmovdqa -0x18(%rsp),%xmm0\nmovups %xmm0,(%rcx)\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "aes/aes.c", "function_name": "inv_sub_bytes", "content": "void inv_sub_bytes(uint8_t *s) {\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = inv_sbox[s[i]];\n}\n"}, "pseudo": {"path": "aes/aes.host.O3.pseudo", "function_name": "inv_sub_bytes", "address": "0x1970", "label": "inv_sub_bytes", "content": "void __fastcall inv_sub_bytes(uint8_t *s)\n{\n  *s = inv_sbox[*s];\n  s[1] = inv_sbox[s[1]];\n  s[2] = inv_sbox[s[2]];\n  s[3] = inv_sbox[s[3]];\n  s[4] = inv_sbox[s[4]];\n  s[5] = inv_sbox[s[5]];\n  s[6] = inv_sbox[s[6]];\n  s[7] = inv_sbox[s[7]];\n  s[8] = inv_sbox[s[8]];\n  s[9] = inv_sbox[s[9]];\n  s[10] = inv_sbox[s[10]];\n  s[11] = inv_sbox[s[11]];\n  s[12] = inv_sbox[s[12]];\n  s[13] = inv_sbox[s[13]];\n  s[14] = inv_sbox[s[14]];\n  s[15] = inv_sbox[s[15]];\n}\n"}, "pseudo_normalize": "void inv_sub_bytes(uint8_t *s) {\n  *s = inv_sbox[*s];\n  s[1] = inv_sbox[s[1]];\n  s[2] = inv_sbox[s[2]];\n  s[3] = inv_sbox[s[3]];\n  s[4] = inv_sbox[s[4]];\n  s[5] = inv_sbox[s[5]];\n  s[6] = inv_sbox[s[6]];\n  s[7] = inv_sbox[s[7]];\n  s[8] = inv_sbox[s[8]];\n  s[9] = inv_sbox[s[9]];\n  s[10] = inv_sbox[s[10]];\n  s[11] = inv_sbox[s[11]];\n  s[12] = inv_sbox[s[12]];\n  s[13] = inv_sbox[s[13]];\n  s[14] = inv_sbox[s[14]];\n  s[15] = inv_sbox[s[15]];\n}", "binary": "aes/aes.host.O3", "assembly": "<inv_sub_bytes>:\nendbr64\nmovzbl (%rdi),%ecx\nlea    0x66a2(%rip),%rdx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,(%rdi)\nmovzbl 0x1(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0x1(%rdi)\nmovzbl 0x2(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0x2(%rdi)\nmovzbl 0x3(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0x3(%rdi)\nmovzbl 0x4(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0x4(%rdi)\nmovzbl 0x5(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0x5(%rdi)\nmovzbl 0x6(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0x6(%rdi)\nmovzbl 0x7(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0x7(%rdi)\nmovzbl 0x8(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0x8(%rdi)\nmovzbl 0x9(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0x9(%rdi)\nmovzbl 0xa(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0xa(%rdi)\nmovzbl 0xb(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0xb(%rdi)\nmovzbl 0xc(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0xc(%rdi)\nmovzbl 0xd(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0xd(%rdi)\nmovzbl 0xe(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%ecx\nmov    %cl,0xe(%rdi)\nmovzbl 0xf(%rdi),%ecx\nmovzbl (%rdx,%rcx,1),%edx\nmov    %dl,0xf(%rdi)\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "aes/aes.c", "function_name": "key_expansion", "content": "// Simple 128-bit key expansion for 10 rounds\nvoid key_expansion(const uint8_t *key, uint8_t *round_keys) {\n  static const uint8_t rcon[10] = {0x01, 0x02, 0x04, 0x08, 0x10,\n                                   0x20, 0x40, 0x80, 0x1B, 0x36};\n  for (int i = 0; i < BLK_SIZE; i++)\n    round_keys[i] = key[i];\n\n  for (int i = 1; i <= ROUNDS; i++) {\n    uint8_t *prev = &round_keys[BLK_SIZE * (i - 1)];\n    uint8_t *curr = &round_keys[BLK_SIZE * i];\n    curr[0] = prev[0] ^ sbox[prev[13]] ^ rcon[i - 1];\n    curr[1] = prev[1] ^ sbox[prev[14]];\n    curr[2] = prev[2] ^ sbox[prev[15]];\n    curr[3] = prev[3] ^ sbox[prev[12]];\n    for (int j = 4; j < BLK_SIZE; j++)\n      curr[j] = curr[j - 4] ^ prev[j];\n  }\n}\n"}, "pseudo": {"path": "aes/aes.host.O3.pseudo", "function_name": "key_expansion", "address": "0x1ff0", "label": "key_expansion", "content": "void __fastcall key_expansion(const uint8_t *key, uint8_t *round_keys)\n{\n  uint8_t *v2; // rax\n  int v3; // r14d\n  int v4; // r13d\n  int v5; // r12d\n  int v6; // ebp\n  int v7; // edi\n  int v8; // r8d\n  int v9; // ebx\n  int v10; // r11d\n  int v11; // r9d\n  int v12; // r10d\n  int v13; // esi\n  const uint8_t *v14; // [rsp+0h] [rbp-48h]\n  uint8_t v15; // [rsp+Bh] [rbp-3Dh]\n  uint8_t v16; // [rsp+Ch] [rbp-3Ch]\n  uint8_t v17; // [rsp+Dh] [rbp-3Bh]\n  uint8_t v18; // [rsp+Eh] [rbp-3Ah]\n  uint8_t v19; // [rsp+Fh] [rbp-39h]\n\n  if ( (unsigned __int64)(round_keys - (key + 1)) <= 0xE )\n  {\n    *round_keys = *key;\n    round_keys[1] = key[1];\n    round_keys[2] = key[2];\n    round_keys[3] = key[3];\n    round_keys[4] = key[4];\n    round_keys[5] = key[5];\n    round_keys[6] = key[6];\n    round_keys[7] = key[7];\n    round_keys[8] = key[8];\n    round_keys[9] = key[9];\n    round_keys[10] = key[10];\n    round_keys[11] = key[11];\n    round_keys[12] = key[12];\n    round_keys[13] = key[13];\n    round_keys[14] = key[14];\n    round_keys[15] = key[15];\n  }\n  else\n  {\n    *(__m128i *)round_keys = _mm_loadu_si128((const __m128i *)key);\n  }\n  v2 = round_keys + 16;\n  v3 = round_keys[11];\n  v15 = round_keys[12];\n  v4 = round_keys[10];\n  v17 = round_keys[13];\n  v5 = round_keys[9];\n  v6 = round_keys[8];\n  v18 = *round_keys;\n  v16 = round_keys[15];\n  v7 = round_keys[2];\n  v8 = round_keys[4];\n  v9 = round_keys[7];\n  v10 = round_keys[6];\n  v14 = rcon_0;\n  v11 = round_keys[5];\n  v12 = round_keys[3];\n  v19 = round_keys[14];\n  v13 = round_keys[1];\n  do\n  {\n    v2 += 16;\n    v18 ^= *v14 ^ sbox[v17];\n    LOBYTE(v8) = v18 ^ v8;\n    v6 ^= v8;\n    *(v2 - 16) = v18;\n    LOBYTE(v13) = sbox[v19] ^ v13;\n    *(v2 - 15) = v13;\n    v11 ^= v13;\n    v5 ^= v11;\n    v17 ^= v5;\n    LOBYTE(v7) = sbox[v16] ^ v7;\n    *(v2 - 14) = v7;\n    v10 ^= v7;\n    LOBYTE(v12) = sbox[v15] ^ v12;\n    v15 ^= v6;\n    v4 ^= v10;\n    v9 ^= v12;\n    *(v2 - 13) = v12;\n    v3 ^= v9;\n    *(v2 - 12) = v8;\n    *(v2 - 11) = v11;\n    *(v2 - 10) = v10;\n    *(v2 - 9) = v9;\n    *(v2 - 8) = v6;\n    *(v2 - 7) = v5;\n    *(v2 - 6) = v4;\n    *(v2 - 5) = v3;\n    *(v2 - 4) = v15;\n    v16 ^= v3;\n    *(v2 - 3) = v17;\n    ++v14;\n    *(v2 - 2) = v4 ^ v19;\n    v19 ^= v4;\n    *(v2 - 1) = v16;\n  }\n  while ( v14 != (const uint8_t *)&unk_60AA );\n}\n"}, "pseudo_normalize": "void key_expansion(const uint8_t *key, uint8_t *round_keys) {\n  uint8_t *v2;\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  const uint8_t *v14;\n  uint8_t v15;\n  uint8_t v16;\n  uint8_t v17;\n  uint8_t v18;\n  uint8_t v19;\n  if ((unsigned long long)(round_keys - (key + 1)) <= 14) {\n    *round_keys = *key;\n    round_keys[1] = key[1];\n    round_keys[2] = key[2];\n    round_keys[3] = key[3];\n    round_keys[4] = key[4];\n    round_keys[5] = key[5];\n    round_keys[6] = key[6];\n    round_keys[7] = key[7];\n    round_keys[8] = key[8];\n    round_keys[9] = key[9];\n    round_keys[10] = key[10];\n    round_keys[11] = key[11];\n    round_keys[12] = key[12];\n    round_keys[13] = key[13];\n    round_keys[14] = key[14];\n    round_keys[15] = key[15];\n  } else {\n    *(__m128i *)round_keys = _mm_loadu_si128((const __m128i *)key);\n  }\n  v2 = round_keys + 16;\n  v3 = round_keys[11];\n  v15 = round_keys[12];\n  v4 = round_keys[10];\n  v17 = round_keys[13];\n  v5 = round_keys[9];\n  v6 = round_keys[8];\n  v18 = *round_keys;\n  v16 = round_keys[15];\n  v7 = round_keys[2];\n  v8 = round_keys[4];\n  v9 = round_keys[7];\n  v10 = round_keys[6];\n  v14 = rcon_0;\n  v11 = round_keys[5];\n  v12 = round_keys[3];\n  v19 = round_keys[14];\n  v13 = round_keys[1];\n  do {\n    v2 += 16;\n    v18 ^= *v14 ^ sbox[v17];\n    LOBYTE(v8) = v18 ^ v8;\n    v6 ^= v8;\n    *(v2 - 16) = v18;\n    LOBYTE(v13) = sbox[v19] ^ v13;\n    *(v2 - 15) = v13;\n    v11 ^= v13;\n    v5 ^= v11;\n    v17 ^= v5;\n    LOBYTE(v7) = sbox[v16] ^ v7;\n    *(v2 - 14) = v7;\n    v10 ^= v7;\n    LOBYTE(v12) = sbox[v15] ^ v12;\n    v15 ^= v6;\n    v4 ^= v10;\n    v9 ^= v12;\n    *(v2 - 13) = v12;\n    v3 ^= v9;\n    *(v2 - 12) = v8;\n    *(v2 - 11) = v11;\n    *(v2 - 10) = v10;\n    *(v2 - 9) = v9;\n    *(v2 - 8) = v6;\n    *(v2 - 7) = v5;\n    *(v2 - 6) = v4;\n    *(v2 - 5) = v3;\n    *(v2 - 4) = v15;\n    v16 ^= v3;\n    *(v2 - 3) = v17;\n    ++v14;\n    *(v2 - 2) = v4 ^ v19;\n    v19 ^= v4;\n    *(v2 - 1) = v16;\n  } while (v14 != (const uint8_t *)&unk_60AA);\n}", "binary": "aes/aes.host.O3", "assembly": "<key_expansion>:\nendbr64\nmov    %rsi,%rax\nlea    0x1(%rdi),%rsi\npush   %r15\nmov    %rax,%rcx\npush   %r14\nsub    %rsi,%rcx\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ncmp    $0xe,%rcx\njbe    218c <key_expansion+0x19c>\nmovdqu (%rdi),%xmm0\nmovups %xmm0,(%rax)\nmovzbl 0xc(%rax),%esi\nmovzbl 0x4(%rax),%edi\nadd    $0x10,%rax\nmovzbl -0x3(%rax),%edx\nmovzbl -0x10(%rax),%ecx\nmovzbl -0xe(%rax),%r8d\nmovzbl -0x5(%rax),%r14d\nmov    %sil,-0xd(%rsp)\nmovzbl -0x1(%rax),%esi\nmovzbl -0x6(%rax),%r13d\nmov    %dl,-0xb(%rsp)\nlea    0x404d(%rip),%rdx\nmovzbl -0x7(%rax),%r12d\nmovzbl -0x8(%rax),%ebp\nmov    %cl,-0xa(%rsp)\nmov    %edi,%ecx\nmov    %sil,-0xc(%rsp)\nmovzbl -0x2(%rax),%esi\nmov    %r8d,%edi\nmov    %ecx,%r8d\nmovzbl -0x9(%rax),%ebx\nmovzbl -0xa(%rax),%r11d\nmov    %rdx,-0x18(%rsp)\nlea    0x609a(%rip),%rdx\nmovzbl -0xb(%rax),%r9d\nmovzbl -0xd(%rax),%r10d\nmov    %sil,-0x9(%rsp)\nmovzbl -0xf(%rax),%esi\nnopl   0x0(%rax)\nmovzbl -0xb(%rsp),%r15d\nmov    -0x18(%rsp),%rcx\nadd    $0x10,%rax\nmovzbl (%rdx,%r15,1),%r15d\nxor    (%rcx),%r15b\nxor    %r15b,-0xa(%rsp)\nmovzbl -0x9(%rsp),%r15d\nmovzbl -0xa(%rsp),%ecx\nxor    -0xa(%rsp),%r8b\nxor    %r8d,%ebp\nmov    %cl,-0x10(%rax)\nmov    %r15,%rcx\nxor    (%rdx,%r15,1),%sil\nmovzbl -0xc(%rsp),%r15d\nmov    %sil,-0xf(%rax)\nxor    %esi,%r9d\nxor    %r9d,%r12d\nxor    %r12b,-0xb(%rsp)\nxor    (%rdx,%r15,1),%dil\nmovzbl -0xd(%rsp),%r15d\nmov    %dil,-0xe(%rax)\nxor    %edi,%r11d\nxor    (%rdx,%r15,1),%r10b\nxor    %bpl,-0xd(%rsp)\nxor    %r11d,%r13d\nmovzbl -0xd(%rsp),%r15d\nxor    %r10d,%ebx\nmov    %r10b,-0xd(%rax)\nxor    %ebx,%r14d\nmov    %r8b,-0xc(%rax)\nmov    %r9b,-0xb(%rax)\nmov    %r11b,-0xa(%rax)\nmov    %bl,-0x9(%rax)\nmov    %bpl,-0x8(%rax)\nmov    %r12b,-0x7(%rax)\nmov    %r13b,-0x6(%rax)\nmov    %r14b,-0x5(%rax)\nmov    %r15b,-0x4(%rax)\nmovzbl -0xb(%rsp),%r15d\nxor    %r14b,-0xc(%rsp)\nmov    %r15b,-0x3(%rax)\nmov    %ecx,%r15d\nxor    %r13d,%r15d\naddq   $0x1,-0x18(%rsp)\nmov    -0x18(%rsp),%rcx\nmov    %r15b,-0x2(%rax)\nmov    %r15b,-0x9(%rsp)\nmovzbl -0xc(%rsp),%r15d\nmov    %r15b,-0x1(%rax)\nlea    0x3f32(%rip),%r15\ncmp    %r15,%rcx\njne    20a0 <key_expansion+0xb0>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovzbl (%rdi),%ecx\nmov    %cl,(%rax)\nmovzbl 0x1(%rdi),%ecx\nmov    %cl,0x1(%rax)\nmovzbl 0x2(%rdi),%ecx\nmov    %cl,0x2(%rax)\nmovzbl 0x3(%rdi),%ecx\nmov    %cl,0x3(%rax)\nmovzbl 0x4(%rdi),%ecx\nmov    %cl,0x4(%rax)\nmovzbl 0x5(%rdi),%ecx\nmov    %cl,0x5(%rax)\nmovzbl 0x6(%rdi),%ecx\nmov    %cl,0x6(%rax)\nmovzbl 0x7(%rdi),%ecx\nmov    %cl,0x7(%rax)\nmovzbl 0x8(%rdi),%ecx\nmov    %cl,0x8(%rax)\nmovzbl 0x9(%rdi),%ecx\nmov    %cl,0x9(%rax)\nmovzbl 0xa(%rdi),%ecx\nmov    %cl,0xa(%rax)\nmovzbl 0xb(%rdi),%ecx\nmov    %cl,0xb(%rax)\nmovzbl 0xc(%rdi),%ecx\nmov    %cl,0xc(%rax)\nmovzbl 0xd(%rdi),%ecx\nmov    %cl,0xd(%rax)\nmovzbl 0xe(%rdi),%ecx\nmov    %cl,0xe(%rax)\nmovzbl 0xf(%rdi),%edx\nmov    %dl,0xf(%rax)\njmp    201c <key_expansion+0x2c>\nnop\n"}
{"source": {"path": "aes/aes.c", "function_name": "main", "content": "int main(void) {\n  uint8_t key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,\n                     0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};\n\n  char *plaintext = \"This is a test!!\";\n  if (libmin_strlen(plaintext) != BLK_SIZE) {\n    libmin_fail(1);\n  }\n\n  uint8_t ciphertext[BLK_SIZE];\n  uint8_t decrypted[BLK_SIZE];\n\n  libmin_memcpy(ciphertext, plaintext, BLK_SIZE);\n  aes_encrypt(ciphertext, key);\n\n  uint8_t ref_ciphertext[BLK_SIZE] = {0xf8, 0x6e, 0x9e, 0x4e, 0x8d, 0x38,\n                                      0x05, 0xe9, 0x72, 0x9f, 0xf1, 0x55,\n                                      0xe5, 0x17, 0xbd, 0x65};\n\n  for (int i = 0; i < BLK_SIZE; i++) {\n    if (ref_ciphertext[i] != ciphertext[i]) {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", ref_ciphertext[i],\n                    ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n\n  libmin_memcpy(decrypted, ciphertext, BLK_SIZE);\n  aes_decrypt(decrypted, key);\n\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", plaintext);\n  libmin_printf(\"  ciphertext: \");\n  for (int i = 0; i < BLK_SIZE; i++) {\n    libmin_printf(\"%02x \", ciphertext[i]);\n  }\n\n  libmin_printf(\"\\n\");\n\n  libmin_printf(\"  decrypted:  \");\n  for (int i = 0; i < BLK_SIZE; i++) {\n    libmin_printf(\"%c\", decrypted[i]);\n  }\n  libmin_printf(\"\\n\");\n\n  for (int i = 0; i < BLK_SIZE; i++) {\n    if (decrypted[i] != plaintext[i]) {\n      libmin_fail(3);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "aes/aes.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint8_t *v3; // rbx\n  int v4; // esi\n  __int64 v5; // rsi\n  uint8_t key[16]; // [rsp+0h] [rbp-68h] BYREF\n  uint8_t ciphertext[16]; // [rsp+10h] [rbp-58h] BYREF\n  uint8_t decrypted[16]; // [rsp+20h] [rbp-48h] BYREF\n  char v9; // [rsp+30h] [rbp-38h] BYREF\n  unsigned __int64 v10; // [rsp+38h] [rbp-30h]\n\n  v10 = __readfsqword(0x28u);\n  *(__m128i *)key = _mm_load_si128((const __m128i *)&xmmword_60B0);\n  if ( libmin_strlen(\"This is a test!!\") != 16 )\n    libmin_fail(1);\n  v3 = ciphertext;\n  libmin_memcpy(ciphertext, \"This is a test!!\", 0x10uLL);\n  aes_encrypt(ciphertext, key);\n  if ( ciphertext[0] != 0xF8 )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 0);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 248, ciphertext[0]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[1] != 110 )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 1);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 110, ciphertext[1]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[2] != 0x9E )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 2);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 158, ciphertext[2]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[3] != 78 )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 3);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 78, ciphertext[3]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[4] != 0x8D )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 4);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 141, ciphertext[4]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[5] != 56 )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 5);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 56, ciphertext[5]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[6] != 5 )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 6);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 5, ciphertext[6]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[7] != 0xE9 )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 7);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 233, ciphertext[7]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[8] != 114 )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 8);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 114, ciphertext[8]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[9] != 0x9F )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 9);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 159, ciphertext[9]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[10] != 0xF1 )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 10);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 241, ciphertext[10]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[11] != 85 )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 11);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 85, ciphertext[11]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[12] != 0xE5 )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 12);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 229, ciphertext[12]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[13] != 23 )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 13);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 23, ciphertext[13]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[14] != 0xBD )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 14);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 189, ciphertext[14]);\n    libmin_fail(2);\n  }\n  if ( ciphertext[15] != 101 )\n  {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 15);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 101, ciphertext[15]);\n    libmin_fail(2);\n  }\n  libmin_memcpy(decrypted, ciphertext, 0x10uLL);\n  aes_decrypt(decrypted, key);\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n  libmin_printf(\"  ciphertext: \");\n  do\n  {\n    v4 = *v3++;\n    libmin_printf(\"%02x \", v4);\n  }\n  while ( v3 != decrypted );\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"  decrypted:  \");\n  do\n  {\n    v5 = *v3++;\n    libmin_printf(\"%c\", v5);\n  }\n  while ( v3 != (uint8_t *)&v9 );\n  libmin_printf((char *)\"\\n\");\n  if ( decrypted[0] != 84 )\n    libmin_fail(3);\n  if ( decrypted[1] != 104 )\n    libmin_fail(3);\n  if ( decrypted[2] != 105 )\n    libmin_fail(3);\n  if ( decrypted[3] != 115 )\n    libmin_fail(3);\n  if ( decrypted[4] != 32 )\n    libmin_fail(3);\n  if ( decrypted[5] != 105 )\n    libmin_fail(3);\n  if ( decrypted[6] != 115 )\n    libmin_fail(3);\n  if ( decrypted[7] != 32 )\n    libmin_fail(3);\n  if ( decrypted[8] != 97 )\n    libmin_fail(3);\n  if ( decrypted[9] != 32 )\n    libmin_fail(3);\n  if ( decrypted[10] != 116 )\n    libmin_fail(3);\n  if ( decrypted[11] != 101 )\n    libmin_fail(3);\n  if ( decrypted[12] != 115 )\n    libmin_fail(3);\n  if ( decrypted[13] != 116 )\n    libmin_fail(3);\n  if ( decrypted[14] != 33 )\n    libmin_fail(3);\n  if ( decrypted[15] != 33 )\n    libmin_fail(3);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  uint8_t *v3;\n  int v4;\n  long long v5;\n  uint8_t key[16];\n  uint8_t ciphertext[16];\n  uint8_t decrypted[16];\n  char v9;\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  *(__m128i *)key = _mm_load_si128((const __m128i *)&xmmword_60B0);\n  if (libmin_strlen(\"This is a test!!\") != 16) libmin_fail(1);\n  v3 = ciphertext;\n  libmin_memcpy(ciphertext, \"This is a test!!\", 16uLL);\n  aes_encrypt(ciphertext, key);\n  if (ciphertext[0] != 248) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 0);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 248, ciphertext[0]);\n    libmin_fail(2);\n  }\n  if (ciphertext[1] != 110) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 1);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 110, ciphertext[1]);\n    libmin_fail(2);\n  }\n  if (ciphertext[2] != 158) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 2);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 158, ciphertext[2]);\n    libmin_fail(2);\n  }\n  if (ciphertext[3] != 78) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 3);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 78, ciphertext[3]);\n    libmin_fail(2);\n  }\n  if (ciphertext[4] != 141) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 4);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 141, ciphertext[4]);\n    libmin_fail(2);\n  }\n  if (ciphertext[5] != 56) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 5);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 56, ciphertext[5]);\n    libmin_fail(2);\n  }\n  if (ciphertext[6] != 5) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 6);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 5, ciphertext[6]);\n    libmin_fail(2);\n  }\n  if (ciphertext[7] != 233) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 7);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 233, ciphertext[7]);\n    libmin_fail(2);\n  }\n  if (ciphertext[8] != 114) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 8);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 114, ciphertext[8]);\n    libmin_fail(2);\n  }\n  if (ciphertext[9] != 159) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 9);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 159, ciphertext[9]);\n    libmin_fail(2);\n  }\n  if (ciphertext[10] != 241) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 10);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 241, ciphertext[10]);\n    libmin_fail(2);\n  }\n  if (ciphertext[11] != 85) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 11);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 85, ciphertext[11]);\n    libmin_fail(2);\n  }\n  if (ciphertext[12] != 229) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 12);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 229, ciphertext[12]);\n    libmin_fail(2);\n  }\n  if (ciphertext[13] != 23) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 13);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 23, ciphertext[13]);\n    libmin_fail(2);\n  }\n  if (ciphertext[14] != 189) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 14);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 189, ciphertext[14]);\n    libmin_fail(2);\n  }\n  if (ciphertext[15] != 101) {\n    libmin_printf(\"Ciphertext mismatch at byte %d\\n\", 15);\n    libmin_printf(\"Expected: %02x, Got: %02x\\n\", 101, ciphertext[15]);\n    libmin_fail(2);\n  }\n  libmin_memcpy(decrypted, ciphertext, 16uLL);\n  aes_decrypt(decrypted, key);\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n  libmin_printf(\"  ciphertext: \");\n  do {\n    v4 = *v3++;\n    libmin_printf(\"%02x \", v4);\n  } while (v3 != decrypted);\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"  decrypted:  \");\n  do {\n    v5 = *v3++;\n    libmin_printf(\"%c\", v5);\n  } while (v3 != (uint8_t *)&v9);\n  libmin_printf((char *)\"\\n\");\n  if (decrypted[0] != 84) libmin_fail(3);\n  if (decrypted[1] != 104) libmin_fail(3);\n  if (decrypted[2] != 105) libmin_fail(3);\n  if (decrypted[3] != 115) libmin_fail(3);\n  if (decrypted[4] != 32) libmin_fail(3);\n  if (decrypted[5] != 105) libmin_fail(3);\n  if (decrypted[6] != 115) libmin_fail(3);\n  if (decrypted[7] != 32) libmin_fail(3);\n  if (decrypted[8] != 97) libmin_fail(3);\n  if (decrypted[9] != 32) libmin_fail(3);\n  if (decrypted[10] != 116) libmin_fail(3);\n  if (decrypted[11] != 101) libmin_fail(3);\n  if (decrypted[12] != 115) libmin_fail(3);\n  if (decrypted[13] != 116) libmin_fail(3);\n  if (decrypted[14] != 33) libmin_fail(3);\n  if (decrypted[15] != 33) libmin_fail(3);\n  libmin_success();\n}", "binary": "aes/aes.host.O3", "assembly": "<main>:\nendbr64\npush   %r13\npush   %r12\nlea    0x4ef5(%rip),%r12\npush   %rbp\nmov    %r12,%rdi\npush   %rbx\nsub    $0x48,%rsp\nmovdqa 0x4f90(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nmovaps %xmm0,(%rsp)\ncall   5000 <libmin_strlen>\ncmp    $0x10,%rax\nje     1149 <main+0x49>\nmov    $0x1,%edi\ncall   2da0 <libmin_fail>\nlea    0x10(%rsp),%rbx\nmov    $0x10,%edx\nmov    %r12,%rsi\nmov    %rsp,%r13\nmov    %rbx,%rdi\ncall   2dc0 <libmin_memcpy>\nmov    %r13,%rsi\nmov    %rbx,%rdi\ncall   2200 <aes_encrypt>\ncmpb   $0xf8,0x10(%rsp)\nje     11a5 <main+0xa5>\nxor    %esi,%esi\nlea    0x4f04(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x10(%rsp),%edx\nlea    0x4e86(%rip),%rdi\nxor    %eax,%eax\nmov    $0xf8,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x6e,0x11(%rsp)\nje     11e1 <main+0xe1>\nmov    $0x1,%esi\nlea    0x4ec8(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x11(%rsp),%edx\nlea    0x4e4a(%rip),%rdi\nxor    %eax,%eax\nmov    $0x6e,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x9e,0x12(%rsp)\nje     121d <main+0x11d>\nmov    $0x2,%esi\nlea    0x4e8c(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x12(%rsp),%edx\nlea    0x4e0e(%rip),%rdi\nxor    %eax,%eax\nmov    $0x9e,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x4e,0x13(%rsp)\nje     1259 <main+0x159>\nmov    $0x3,%esi\nlea    0x4e50(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x13(%rsp),%edx\nlea    0x4dd2(%rip),%rdi\nxor    %eax,%eax\nmov    $0x4e,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x8d,0x14(%rsp)\nje     1295 <main+0x195>\nmov    $0x4,%esi\nlea    0x4e14(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x14(%rsp),%edx\nlea    0x4d96(%rip),%rdi\nxor    %eax,%eax\nmov    $0x8d,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x38,0x15(%rsp)\nje     12d1 <main+0x1d1>\nmov    $0x5,%esi\nlea    0x4dd8(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x15(%rsp),%edx\nlea    0x4d5a(%rip),%rdi\nxor    %eax,%eax\nmov    $0x38,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x5,0x16(%rsp)\nje     130d <main+0x20d>\nmov    $0x6,%esi\nlea    0x4d9c(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x16(%rsp),%edx\nlea    0x4d1e(%rip),%rdi\nxor    %eax,%eax\nmov    $0x5,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0xe9,0x17(%rsp)\nje     1349 <main+0x249>\nmov    $0x7,%esi\nlea    0x4d60(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x17(%rsp),%edx\nlea    0x4ce2(%rip),%rdi\nxor    %eax,%eax\nmov    $0xe9,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x72,0x18(%rsp)\nje     1385 <main+0x285>\nmov    $0x8,%esi\nlea    0x4d24(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x18(%rsp),%edx\nlea    0x4ca6(%rip),%rdi\nxor    %eax,%eax\nmov    $0x72,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x9f,0x19(%rsp)\nje     13c1 <main+0x2c1>\nmov    $0x9,%esi\nlea    0x4ce8(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x19(%rsp),%edx\nlea    0x4c6a(%rip),%rdi\nxor    %eax,%eax\nmov    $0x9f,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0xf1,0x1a(%rsp)\nje     13fd <main+0x2fd>\nmov    $0xa,%esi\nlea    0x4cac(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x1a(%rsp),%edx\nlea    0x4c2e(%rip),%rdi\nxor    %eax,%eax\nmov    $0xf1,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x55,0x1b(%rsp)\nje     1439 <main+0x339>\nmov    $0xb,%esi\nlea    0x4c70(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x1b(%rsp),%edx\nlea    0x4bf2(%rip),%rdi\nxor    %eax,%eax\nmov    $0x55,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0xe5,0x1c(%rsp)\nje     1475 <main+0x375>\nmov    $0xc,%esi\nlea    0x4c34(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x1c(%rsp),%edx\nlea    0x4bb6(%rip),%rdi\nxor    %eax,%eax\nmov    $0xe5,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x17,0x1d(%rsp)\nje     14b1 <main+0x3b1>\nmov    $0xd,%esi\nlea    0x4bf8(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x1d(%rsp),%edx\nlea    0x4b7a(%rip),%rdi\nxor    %eax,%eax\nmov    $0x17,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0xbd,0x1e(%rsp)\nje     14ed <main+0x3ed>\nmov    $0xe,%esi\nlea    0x4bbc(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x1e(%rsp),%edx\nlea    0x4b3e(%rip),%rdi\nxor    %eax,%eax\nmov    $0xbd,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x65,0x1f(%rsp)\nje     1529 <main+0x429>\nmov    $0xf,%esi\nlea    0x4b80(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmovzbl 0x1f(%rsp),%edx\nlea    0x4b02(%rip),%rdi\nxor    %eax,%eax\nmov    $0x65,%esi\ncall   4df0 <libmin_printf>\nmov    $0x2,%edi\ncall   2da0 <libmin_fail>\nlea    0x20(%rsp),%rbp\nmov    $0x10,%edx\nmov    %rbx,%rsi\nmov    %rbp,%rdi\ncall   2dc0 <libmin_memcpy>\nmov    %r13,%rsi\nmov    %rbp,%rdi\ncall   2760 <aes_decrypt>\nlea    0x4ae0(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nmov    %r12,%rsi\nlea    0x4ae4(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nlea    0x4ae8(%rip),%rdi\nxor    %eax,%eax\nlea    0x4aee(%rip),%r12\ncall   4df0 <libmin_printf>\nnopl   (%rax)\nmovzbl (%rbx),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   4df0 <libmin_printf>\ncmp    %rbp,%rbx\njne    1580 <main+0x480>\nlea    0x4aa6(%rip),%r13\nxor    %eax,%eax\nlea    0x30(%rsp),%r12\nmov    %r13,%rdi\nlea    0x4acd(%rip),%rbp\ncall   4df0 <libmin_printf>\nlea    0x4ab2(%rip),%rdi\nxor    %eax,%eax\ncall   4df0 <libmin_printf>\nnopl   0x0(%rax)\nmovzbl (%rbx),%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   4df0 <libmin_printf>\ncmp    %r12,%rbx\njne    15c8 <main+0x4c8>\nxor    %eax,%eax\nmov    %r13,%rdi\ncall   4df0 <libmin_printf>\ncmpb   $0x54,0x20(%rsp)\nje     15f9 <main+0x4f9>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x68,0x21(%rsp)\nje     160a <main+0x50a>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x69,0x22(%rsp)\nje     161b <main+0x51b>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x73,0x23(%rsp)\nje     162c <main+0x52c>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x20,0x24(%rsp)\nje     163d <main+0x53d>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x69,0x25(%rsp)\nje     164e <main+0x54e>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x73,0x26(%rsp)\nje     165f <main+0x55f>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x20,0x27(%rsp)\nje     1670 <main+0x570>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x61,0x28(%rsp)\nje     1681 <main+0x581>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x20,0x29(%rsp)\nje     1692 <main+0x592>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x74,0x2a(%rsp)\nje     16a3 <main+0x5a3>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x65,0x2b(%rsp)\nje     16b4 <main+0x5b4>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x73,0x2c(%rsp)\nje     16c5 <main+0x5c5>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x74,0x2d(%rsp)\nje     16d6 <main+0x5d6>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x21,0x2e(%rsp)\nje     16e7 <main+0x5e7>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncmpb   $0x21,0x2f(%rsp)\nje     16f8 <main+0x5f8>\nmov    $0x3,%edi\ncall   2da0 <libmin_fail>\ncall   5030 <libmin_success>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    171a <main+0x61a>\nadd    $0x48,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   10b0 <__stack_chk_fail@plt>\nnop\n"}
{"source": {"path": "aes/aes.c", "function_name": "mix_columns", "content": "void mix_columns(uint8_t *s) {\n  for (int i = 0; i < 4; i++) {\n    int c = i * 4;\n    uint8_t a = s[c];\n    uint8_t b = s[c + 1];\n    uint8_t c1 = s[c + 2];\n    uint8_t d = s[c + 3];\n    uint8_t r = a ^ b ^ c1 ^ d;\n\n    uint8_t x = a ^ b;\n    x = gf256_mul2(x);\n    s[c] ^= x ^ r;\n\n    x = b ^ c1;\n    x = gf256_mul2(x);\n    s[c + 1] ^= x ^ r;\n\n    x = c1 ^ d;\n    x = gf256_mul2(x);\n    s[c + 2] ^= x ^ r;\n\n    x = d ^ a;\n    x = gf256_mul2(x);\n    s[c + 3] ^= x ^ r;\n  }\n}\n"}, "pseudo": {"path": "aes/aes.host.O3.pseudo", "function_name": "mix_columns", "address": "0x1bd0", "label": "mix_columns", "content": "void __fastcall mix_columns(uint8_t *s)\n{\n  uint8_t v1; // cl\n  __int64 v3; // r8\n  char v4; // si\n  char v5; // dl\n  char v6; // di\n  char v7; // si\n  char v8; // dl\n  bool v9; // sf\n  char v10; // si\n  char v11; // dl\n  char v12; // si\n  uint8_t v13; // r8\n  char v14; // cl\n  char v15; // si\n  char v16; // r8\n  char v17; // dl\n  char v18; // cl\n  uint8_t v19; // si\n  char v20; // di\n  char v21; // dl\n  char v22; // cl\n  char v23; // r9\n  char v24; // di\n  uint8_t v25; // cl\n  char v26; // di\n  char v27; // cl\n  char v28; // di\n  char v29; // cl\n  char v30; // di\n  uint8_t v31; // r8\n  char v32; // si\n  char v33; // cl\n  char v34; // di\n  uint8_t v35; // si\n  char v36; // r8\n  uint8_t v37; // dl\n  uint8_t v38; // cl\n  char v39; // si\n  char v40; // dl\n  char v41; // di\n  char v42; // si\n  char v43; // dl\n  char v44; // si\n  char v45; // dl\n  char v46; // si\n  uint8_t v47; // r8\n  char v48; // cl\n  char v49; // si\n  char v50; // r8\n  char v51; // dl\n  char v52; // cl\n  uint8_t v53; // si\n  char v54; // di\n  char v55; // dl\n  char v56; // cl\n  char v57; // r9\n  char v58; // di\n  uint8_t v59; // cl\n  char v60; // di\n  char v61; // cl\n  char v62; // di\n  char v63; // di\n  char v64; // si\n  char v65; // cl\n\n  v1 = *s;\n  v3 = (unsigned __int8)(s[3] ^ s[2]);\n  v4 = *s ^ s[1];\n  v5 = 2 * v4;\n  v6 = v3 ^ v4;\n  if ( v4 < 0 )\n    v5 = (2 * v4) ^ 0x1B;\n  v7 = s[2] ^ s[1];\n  *s = v6 ^ v1 ^ v5;\n  v8 = 2 * v7;\n  v9 = v7 < 0;\n  v10 = (2 * v7) ^ 0x1B;\n  if ( !v9 )\n    v10 = v8;\n  s[1] ^= v10 ^ v6;\n  v11 = 2 * v3;\n  v12 = (2 * v3) ^ 0x1B;\n  v9 = (v3 & 0x80u) != 0LL;\n  v13 = s[7];\n  if ( !v9 )\n    v12 = v11;\n  v14 = s[3] ^ v1;\n  s[2] ^= v12 ^ v6;\n  v15 = (2 * v14) ^ 0x1B;\n  if ( v14 >= 0 )\n    v15 = 2 * v14;\n  v16 = s[6] ^ v13;\n  v17 = s[3] ^ v6;\n  v18 = v15;\n  v19 = s[4];\n  v20 = v19 ^ s[5];\n  s[3] = v18 ^ v17;\n  v21 = v20 ^ v16;\n  v22 = 2 * v20;\n  v23 = (2 * v20) ^ 0x1B;\n  v9 = v20 < 0;\n  v24 = v20 ^ v16;\n  if ( v9 )\n    v22 = v23;\n  v25 = v19 ^ v24 ^ v22;\n  v26 = s[5] ^ s[6];\n  s[4] = v25;\n  v27 = 2 * v26;\n  v9 = v26 < 0;\n  v28 = (2 * v26) ^ 0x1B;\n  if ( !v9 )\n    v28 = v27;\n  s[5] ^= v28 ^ v21;\n  v29 = 2 * v16;\n  v30 = (2 * v16) ^ 0x1B;\n  v9 = v16 < 0;\n  v31 = s[10];\n  if ( !v9 )\n    v30 = v29;\n  v32 = s[7] ^ v19;\n  s[6] ^= v30 ^ v21;\n  v33 = 2 * v32;\n  v34 = (2 * v32) ^ 0x1B;\n  v9 = v32 < 0;\n  v35 = s[9];\n  if ( v9 )\n    v33 = v34;\n  v36 = s[11] ^ v31;\n  v37 = v33 ^ s[7] ^ v21;\n  v38 = s[8];\n  s[7] = v37;\n  v39 = v38 ^ v35;\n  v40 = 2 * v39;\n  v41 = v36 ^ v39;\n  if ( v39 < 0 )\n    v40 = (2 * v39) ^ 0x1B;\n  s[8] = v41 ^ v38 ^ v40;\n  v42 = s[10] ^ s[9];\n  v43 = 2 * v42;\n  v9 = v42 < 0;\n  v44 = (2 * v42) ^ 0x1B;\n  if ( !v9 )\n    v44 = v43;\n  s[9] ^= v44 ^ v41;\n  v45 = 2 * v36;\n  v46 = (2 * v36) ^ 0x1B;\n  v9 = v36 < 0;\n  v47 = s[15];\n  if ( !v9 )\n    v46 = v45;\n  v48 = s[11] ^ v38;\n  s[10] ^= v46 ^ v41;\n  v49 = (2 * v48) ^ 0x1B;\n  if ( v48 >= 0 )\n    v49 = 2 * v48;\n  v50 = s[14] ^ v47;\n  v51 = s[11] ^ v41;\n  v52 = v49;\n  v53 = s[12];\n  v54 = v53 ^ s[13];\n  s[11] = v52 ^ v51;\n  v55 = v54 ^ v50;\n  v56 = 2 * v54;\n  v57 = (2 * v54) ^ 0x1B;\n  v9 = v54 < 0;\n  v58 = v54 ^ v50;\n  if ( v9 )\n    v56 = v57;\n  v59 = v53 ^ v58 ^ v56;\n  v60 = s[13] ^ s[14];\n  s[12] = v59;\n  v61 = 2 * v60;\n  v9 = v60 < 0;\n  v62 = (2 * v60) ^ 0x1B;\n  if ( !v9 )\n    v62 = v61;\n  s[13] ^= v62 ^ v55;\n  v63 = (2 * v50) ^ 0x1B;\n  if ( v50 >= 0 )\n    v63 = 2 * v50;\n  v64 = s[15] ^ v53;\n  s[14] ^= v63 ^ v55;\n  v65 = 2 * v64;\n  if ( v64 < 0 )\n    v65 = (2 * v64) ^ 0x1B;\n  s[15] ^= v65 ^ v55;\n}\n"}, "pseudo_normalize": "void mix_columns(uint8_t *s) {\n  uint8_t v1;\n  long long v3;\n  char v4;\n  char v5;\n  char v6;\n  char v7;\n  char v8;\n  bool v9;\n  char v10;\n  char v11;\n  char v12;\n  uint8_t v13;\n  char v14;\n  char v15;\n  char v16;\n  char v17;\n  char v18;\n  uint8_t v19;\n  char v20;\n  char v21;\n  char v22;\n  char v23;\n  char v24;\n  uint8_t v25;\n  char v26;\n  char v27;\n  char v28;\n  char v29;\n  char v30;\n  uint8_t v31;\n  char v32;\n  char v33;\n  char v34;\n  uint8_t v35;\n  char v36;\n  uint8_t v37;\n  uint8_t v38;\n  char v39;\n  char v40;\n  char v41;\n  char v42;\n  char v43;\n  char v44;\n  char v45;\n  char v46;\n  uint8_t v47;\n  char v48;\n  char v49;\n  char v50;\n  char v51;\n  char v52;\n  uint8_t v53;\n  char v54;\n  char v55;\n  char v56;\n  char v57;\n  char v58;\n  uint8_t v59;\n  char v60;\n  char v61;\n  char v62;\n  char v63;\n  char v64;\n  char v65;\n  v1 = *s;\n  v3 = (unsigned char)(s[3] ^ s[2]);\n  v4 = *s ^ s[1];\n  v5 = 2 * v4;\n  v6 = v3 ^ v4;\n  if (v4 < 0) v5 = (2 * v4) ^ 27;\n  v7 = s[2] ^ s[1];\n  *s = v6 ^ v1 ^ v5;\n  v8 = 2 * v7;\n  v9 = v7 < 0;\n  v10 = (2 * v7) ^ 27;\n  if (!v9) v10 = v8;\n  s[1] ^= v10 ^ v6;\n  v11 = 2 * v3;\n  v12 = (2 * v3) ^ 27;\n  v9 = (v3 & 128u) != 0LL;\n  v13 = s[7];\n  if (!v9) v12 = v11;\n  v14 = s[3] ^ v1;\n  s[2] ^= v12 ^ v6;\n  v15 = (2 * v14) ^ 27;\n  if (v14 >= 0) v15 = 2 * v14;\n  v16 = s[6] ^ v13;\n  v17 = s[3] ^ v6;\n  v18 = v15;\n  v19 = s[4];\n  v20 = v19 ^ s[5];\n  s[3] = v18 ^ v17;\n  v21 = v20 ^ v16;\n  v22 = 2 * v20;\n  v23 = (2 * v20) ^ 27;\n  v9 = v20 < 0;\n  v24 = v20 ^ v16;\n  if (v9) v22 = v23;\n  v25 = v19 ^ v24 ^ v22;\n  v26 = s[5] ^ s[6];\n  s[4] = v25;\n  v27 = 2 * v26;\n  v9 = v26 < 0;\n  v28 = (2 * v26) ^ 27;\n  if (!v9) v28 = v27;\n  s[5] ^= v28 ^ v21;\n  v29 = 2 * v16;\n  v30 = (2 * v16) ^ 27;\n  v9 = v16 < 0;\n  v31 = s[10];\n  if (!v9) v30 = v29;\n  v32 = s[7] ^ v19;\n  s[6] ^= v30 ^ v21;\n  v33 = 2 * v32;\n  v34 = (2 * v32) ^ 27;\n  v9 = v32 < 0;\n  v35 = s[9];\n  if (v9) v33 = v34;\n  v36 = s[11] ^ v31;\n  v37 = v33 ^ s[7] ^ v21;\n  v38 = s[8];\n  s[7] = v37;\n  v39 = v38 ^ v35;\n  v40 = 2 * v39;\n  v41 = v36 ^ v39;\n  if (v39 < 0) v40 = (2 * v39) ^ 27;\n  s[8] = v41 ^ v38 ^ v40;\n  v42 = s[10] ^ s[9];\n  v43 = 2 * v42;\n  v9 = v42 < 0;\n  v44 = (2 * v42) ^ 27;\n  if (!v9) v44 = v43;\n  s[9] ^= v44 ^ v41;\n  v45 = 2 * v36;\n  v46 = (2 * v36) ^ 27;\n  v9 = v36 < 0;\n  v47 = s[15];\n  if (!v9) v46 = v45;\n  v48 = s[11] ^ v38;\n  s[10] ^= v46 ^ v41;\n  v49 = (2 * v48) ^ 27;\n  if (v48 >= 0) v49 = 2 * v48;\n  v50 = s[14] ^ v47;\n  v51 = s[11] ^ v41;\n  v52 = v49;\n  v53 = s[12];\n  v54 = v53 ^ s[13];\n  s[11] = v52 ^ v51;\n  v55 = v54 ^ v50;\n  v56 = 2 * v54;\n  v57 = (2 * v54) ^ 27;\n  v9 = v54 < 0;\n  v58 = v54 ^ v50;\n  if (v9) v56 = v57;\n  v59 = v53 ^ v58 ^ v56;\n  v60 = s[13] ^ s[14];\n  s[12] = v59;\n  v61 = 2 * v60;\n  v9 = v60 < 0;\n  v62 = (2 * v60) ^ 27;\n  if (!v9) v62 = v61;\n  s[13] ^= v62 ^ v55;\n  v63 = (2 * v50) ^ 27;\n  if (v50 >= 0) v63 = 2 * v50;\n  v64 = s[15] ^ v53;\n  s[14] ^= v63 ^ v55;\n  v65 = 2 * v64;\n  if (v64 < 0) v65 = (2 * v64) ^ 27;\n  s[15] ^= v65 ^ v55;\n}", "binary": "aes/aes.host.O3", "assembly": "<mix_columns>:\nendbr64\nmovzbl (%rdi),%ecx\nmovzbl 0x1(%rdi),%esi\nmov    %rdi,%rax\nmovzbl 0x2(%rdi),%r8d\nxor    0x3(%rdi),%r8b\nxor    %ecx,%esi\nmovzbl %sil,%edx\nmov    %esi,%edi\nadd    %edx,%edx\nxor    %r8d,%edi\nmov    %edx,%r9d\nxor    $0x1b,%r9d\ntest   %sil,%sil\nmov    %ecx,%esi\ncmovs  %r9d,%edx\nxor    %edi,%esi\nxor    %esi,%edx\nmovzbl 0x1(%rax),%esi\nxor    0x2(%rax),%sil\nmov    %dl,(%rax)\nmovzbl %sil,%edx\nadd    %edx,%edx\nmov    %edx,%r9d\nxor    $0x1b,%r9d\ntest   %sil,%sil\nmov    %r9d,%esi\ncmovns %edx,%esi\nmovzbl 0x1(%rax),%edx\nxor    %edi,%edx\nxor    %esi,%edx\nmov    %dl,0x1(%rax)\nmovzbl %r8b,%edx\nadd    %edx,%edx\nmov    %edx,%esi\nxor    $0x1b,%esi\ntest   %r8b,%r8b\nmovzbl 0x7(%rax),%r8d\ncmovns %edx,%esi\nmovzbl 0x2(%rax),%edx\nxor    0x3(%rax),%cl\nxor    %edi,%edx\nxor    %esi,%edx\nmov    %dl,0x2(%rax)\nmovzbl %cl,%edx\nadd    %edx,%edx\nmov    %edx,%esi\nxor    $0x1b,%esi\ntest   %cl,%cl\ncmovns %edx,%esi\nxor    0x3(%rax),%dil\nxor    0x6(%rax),%r8b\nmov    %edi,%edx\nmovzbl 0x5(%rax),%edi\nmov    %esi,%ecx\nmovzbl 0x4(%rax),%esi\nxor    %ecx,%edx\nxor    %esi,%edi\nmov    %dl,0x3(%rax)\nmov    %r8d,%edx\nmovzbl %dil,%ecx\nxor    %edi,%edx\nadd    %ecx,%ecx\nmov    %ecx,%r9d\nxor    $0x1b,%r9d\ntest   %dil,%dil\nmov    %edx,%edi\ncmovs  %r9d,%ecx\nxor    %esi,%edi\nxor    %edi,%ecx\nmovzbl 0x6(%rax),%edi\nxor    0x5(%rax),%dil\nmov    %cl,0x4(%rax)\nmovzbl %dil,%ecx\nadd    %ecx,%ecx\nmov    %ecx,%r9d\nxor    $0x1b,%r9d\ntest   %dil,%dil\nmov    %r9d,%edi\ncmovns %ecx,%edi\nmovzbl 0x5(%rax),%ecx\nxor    %edx,%ecx\nxor    %edi,%ecx\nmov    %cl,0x5(%rax)\nmovzbl %r8b,%ecx\nadd    %ecx,%ecx\nmov    %ecx,%edi\nxor    $0x1b,%edi\ntest   %r8b,%r8b\nmovzbl 0xa(%rax),%r8d\ncmovns %ecx,%edi\nmovzbl 0x6(%rax),%ecx\nxor    0x7(%rax),%sil\nxor    %edx,%ecx\nxor    %edi,%ecx\nmov    %cl,0x6(%rax)\nmovzbl %sil,%ecx\nadd    %ecx,%ecx\nmov    %ecx,%edi\nxor    $0x1b,%edi\ntest   %sil,%sil\nmovzbl 0x9(%rax),%esi\ncmovs  %edi,%ecx\nxor    0x7(%rax),%dl\nxor    0xb(%rax),%r8b\nxor    %ecx,%edx\nmovzbl 0x8(%rax),%ecx\nmov    %dl,0x7(%rax)\nxor    %ecx,%esi\nmovzbl %sil,%edx\nmov    %esi,%edi\nadd    %edx,%edx\nxor    %r8d,%edi\nmov    %edx,%r9d\nxor    $0x1b,%r9d\ntest   %sil,%sil\nmov    %ecx,%esi\ncmovs  %r9d,%edx\nxor    %edi,%esi\nxor    %esi,%edx\nmov    %dl,0x8(%rax)\nmovzbl 0x9(%rax),%esi\nxor    0xa(%rax),%sil\nmovzbl %sil,%edx\nadd    %edx,%edx\nmov    %edx,%r9d\nxor    $0x1b,%r9d\ntest   %sil,%sil\nmov    %r9d,%esi\ncmovns %edx,%esi\nmovzbl 0x9(%rax),%edx\nxor    %edi,%edx\nxor    %esi,%edx\nmov    %dl,0x9(%rax)\nmovzbl %r8b,%edx\nadd    %edx,%edx\nmov    %edx,%esi\nxor    $0x1b,%esi\ntest   %r8b,%r8b\nmovzbl 0xf(%rax),%r8d\ncmovns %edx,%esi\nmovzbl 0xa(%rax),%edx\nxor    0xb(%rax),%cl\nxor    %edi,%edx\nxor    %esi,%edx\nmov    %dl,0xa(%rax)\nmovzbl %cl,%edx\nadd    %edx,%edx\nmov    %edx,%esi\nxor    $0x1b,%esi\ntest   %cl,%cl\ncmovns %edx,%esi\nxor    0xb(%rax),%dil\nxor    0xe(%rax),%r8b\nmov    %edi,%edx\nmovzbl 0xd(%rax),%edi\nmov    %esi,%ecx\nmovzbl 0xc(%rax),%esi\nxor    %ecx,%edx\nxor    %esi,%edi\nmov    %dl,0xb(%rax)\nmov    %r8d,%edx\nmovzbl %dil,%ecx\nxor    %edi,%edx\nadd    %ecx,%ecx\nmov    %ecx,%r9d\nxor    $0x1b,%r9d\ntest   %dil,%dil\nmov    %edx,%edi\ncmovs  %r9d,%ecx\nxor    %esi,%edi\nxor    %edi,%ecx\nmovzbl 0xe(%rax),%edi\nxor    0xd(%rax),%dil\nmov    %cl,0xc(%rax)\nmovzbl %dil,%ecx\nadd    %ecx,%ecx\nmov    %ecx,%r9d\nxor    $0x1b,%r9d\ntest   %dil,%dil\nmov    %r9d,%edi\ncmovns %ecx,%edi\nmovzbl 0xd(%rax),%ecx\nxor    %edx,%ecx\nxor    %edi,%ecx\nmov    %cl,0xd(%rax)\nmovzbl %r8b,%ecx\nadd    %ecx,%ecx\nmov    %ecx,%edi\nxor    $0x1b,%edi\ntest   %r8b,%r8b\ncmovns %ecx,%edi\nmovzbl 0xe(%rax),%ecx\nxor    0xf(%rax),%sil\nxor    %edx,%ecx\nxor    %edi,%ecx\nmov    %cl,0xe(%rax)\nmovzbl %sil,%ecx\nadd    %ecx,%ecx\nmov    %ecx,%edi\nxor    $0x1b,%edi\ntest   %sil,%sil\ncmovs  %edi,%ecx\nxor    0xf(%rax),%dl\nxor    %ecx,%edx\nmov    %dl,0xf(%rax)\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "aes/aes.c", "function_name": "shift_rows", "content": "void shift_rows(uint8_t *s) {\n  uint8_t res[BLK_SIZE];\n  uint8_t idx[BLK_SIZE] = {0, 5,  10, 15, 4,  9, 14, 3,\n                           8, 13, 2,  7,  12, 1, 6,  11};\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    res[i] = s[idx[i]];\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = res[i];\n}\n"}, "pseudo": {"path": "aes/aes.host.O3.pseudo", "function_name": "shift_rows", "address": "0x1a30", "label": "shift_rows", "content": "void __fastcall shift_rows(uint8_t *s)\n{\n  unsigned __int64 v2; // rdx\n  unsigned __int64 v3; // rax\n  __int64 v4; // rdi\n  __m128i v5; // [rsp+0h] [rbp-18h] BYREF\n\n  v2 = *s | ((s[5] | ((s[10] | ((s[15] | ((s[4] | ((s[9] | ((s[14] | ((unsigned __int64)s[3] << 8)) << 8)) << 8)) << 8)) << 8)) << 8)) << 8);\n  v3 = s[6] | ((unsigned __int64)s[11] << 8);\n  v4 = s[1];\n  v5.m128i_i64[0] = v2;\n  v5.m128i_i64[1] = s[8] | ((s[13] | ((s[2] | ((s[7] | ((s[12] | ((v4 | (v3 << 8)) << 8)) << 8)) << 8)) << 8)) << 8);\n  *(__m128i *)s = _mm_load_si128(&v5);\n}\n"}, "pseudo_normalize": "void shift_rows(uint8_t *s) {\n  unsigned long long v2;\n  unsigned long long v3;\n  long long v4;\n  __m128i v5;\n  v2 = *s |\n       ((s[5] |\n         ((s[10] |\n           ((s[15] |\n             ((s[4] |\n               ((s[9] | ((s[14] | ((unsigned long long)s[3] << 8)) << 8)) << 8))\n              << 8))\n            << 8))\n          << 8))\n        << 8);\n  v3 = s[6] | ((unsigned long long)s[11] << 8);\n  v4 = s[1];\n  v5.m128i_i64[0] = v2;\n  v5.m128i_i64[1] =\n      s[8] |\n      ((s[13] |\n        ((s[2] | ((s[7] | ((s[12] | ((v4 | (v3 << 8)) << 8)) << 8)) << 8))\n         << 8))\n       << 8);\n  *(__m128i *)s = _mm_load_si128(&v5);\n}", "binary": "aes/aes.host.O3", "assembly": "<shift_rows>:\nendbr64\nmovzbl 0x3(%rdi),%edx\nmovzbl 0xe(%rdi),%eax\nmov    %rdi,%rcx\nmovzbl (%rdi),%esi\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl 0x9(%rdi),%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl 0x4(%rdi),%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl 0xf(%rdi),%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl 0xa(%rdi),%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl 0x5(%rdi),%eax\nshl    $0x8,%rdx\nor     %rax,%rdx\nmovzbl 0xb(%rdi),%eax\nmovzbl 0x6(%rdi),%edi\nshl    $0x8,%rdx\nshl    $0x8,%rax\nor     %rsi,%rdx\nor     %rdi,%rax\nmovzbl 0x1(%rcx),%edi\nmov    %rdx,-0x18(%rsp)\nshl    $0x8,%rax\nor     %rdi,%rax\nmovzbl 0xc(%rcx),%edi\nshl    $0x8,%rax\nor     %rdi,%rax\nmovzbl 0x7(%rcx),%edi\nshl    $0x8,%rax\nor     %rdi,%rax\nmovzbl 0x2(%rcx),%edi\nshl    $0x8,%rax\nor     %rdi,%rax\nmovzbl 0xd(%rcx),%edi\nshl    $0x8,%rax\nor     %rdi,%rax\nmovzbl 0x8(%rcx),%edi\nshl    $0x8,%rax\nor     %rdi,%rax\nmov    %rax,-0x10(%rsp)\nmovdqa -0x18(%rsp),%xmm0\nmovups %xmm0,(%rcx)\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "AddWords", "content": "/* AddWords -- build the list of candidates */\nvoid\nAddWords(void) {\n    char * pch = pchDictionary;     /* walk through the dictionary */\n\n    cpwCand = 0;\n\n    while (*pch) {\n        if ((pch[1] >= cchMinLength && pch[1]+cchMinLength <= cchPhraseLength)\n            || pch[1] == cchPhraseLength)\n\t    BuildWord(pch+2);\n        pch += *pch;\n    }\n\n    libmin_printf(\"%d candidates\\n\", cpwCand);\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "AddWords", "address": "0x1b70", "label": "AddWords", "content": "void __cdecl AddWords()\n{\n  char *v0; // rbx\n  __int64 v1; // rax\n  int v2; // ecx\n\n  v0 = pchDictionary;\n  cpwCand = 0;\n  v1 = *pchDictionary;\n  if ( (_BYTE)v1 )\n  {\n    do\n    {\n      while ( 1 )\n      {\n        v2 = v0[1];\n        if ( (v2 < cchMinLength || v2 + cchMinLength > cchPhraseLength) && v2 != cchPhraseLength )\n          break;\n        BuildWord(v0 + 2);\n        v0 += *v0;\n        v1 = *v0;\n        if ( !(_BYTE)v1 )\n          goto LABEL_8;\n      }\n      v0 += v1;\n      v1 = *v0;\n    }\n    while ( (_BYTE)v1 );\nLABEL_8:\n    libmin_printf(\"%d candidates\\n\", cpwCand);\n  }\n  else\n  {\n    libmin_printf(\"%d candidates\\n\", 0);\n  }\n}\n"}, "pseudo_normalize": "void AddWords() {\n  char *v0;\n  long long v1;\n  int v2;\n  v0 = pchDictionary;\n  cpwCand = 0;\n  v1 = *pchDictionary;\n  if ((uint8_t)v1) {\n    do {\n      while (1) {\n        v2 = v0[1];\n        if ((v2 < cchMinLength || v2 + cchMinLength > cchPhraseLength) &&\n            v2 != cchPhraseLength)\n          break;\n        BuildWord(v0 + 2);\n        v0 += *v0;\n        v1 = *v0;\n        if (!(uint8_t)v1) goto LABEL_8;\n      }\n      v0 += v1;\n      v1 = *v0;\n    } while ((uint8_t)v1);\n  LABEL_8:\n    libmin_printf(\"%d candidates\\n\", cpwCand);\n  } else {\n    libmin_printf(\"%d candidates\\n\", 0);\n  }\n}", "binary": "anagram/anagram.host.O3", "assembly": "<AddWords>:\nendbr64\npush   %rbx\nmov    0x37a3c(%rip),%rbx\nmovl   $0x0,0x37c9a(%rip)\nmovsbq (%rbx),%rax\ntest   %al,%al\njne    1bae <AddWords+0x3e>\njmp    1bf0 <AddWords+0x80>\nadd    %ecx,%edx\ncmp    %esi,%edx\njg     1bc2 <AddWords+0x52>\nlea    0x2(%rbx),%rdi\ncall   1940 <BuildWord>\nmovsbq (%rbx),%rax\nadd    %rax,%rbx\nmovsbq (%rbx),%rax\ntest   %al,%al\nje     1bd1 <AddWords+0x61>\nmovsbl 0x1(%rbx),%ecx\nmov    0x37458(%rip),%edx\nmov    0x37ab2(%rip),%esi\ncmp    %edx,%ecx\njge    1b90 <AddWords+0x20>\ncmp    %esi,%ecx\nje     1b96 <AddWords+0x26>\nadd    %rax,%rbx\nmovsbq (%rbx),%rax\ntest   %al,%al\njne    1bae <AddWords+0x3e>\nmov    0x37c49(%rip),%esi\nlea    0x3516(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\njmp    4890 <libmin_printf>\ncs nopw 0x0(%rax,%rax,1)\nxor    %esi,%esi\nlea    0x34fb(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\njmp    4890 <libmin_printf>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "BuildMask", "content": "void BuildMask(char * pchPhrase) {\n    int i;\n    int ch;\n    unsigned iq;                        /* which Quad? */\n    int cbtUsed;                        /* bits used in the current Quad */\n    int cbtNeed;                        /* bits needed for current letter */\n    Quad qNeed;                         /* used to build the mask */\n\n    libmin_memset(alPhrase, 0, sizeof(Letter)*ALPHABET);\n    libmin_memset(aqMainMask, 0, sizeof(Quad)*MAX_QUADS);\n    libmin_memset(aqMainSign, 0, sizeof(Quad)*MAX_QUADS);\n/*\n    Zero(alPhrase);\n    Zero(aqMainMask);\n    Zero(aqMainSign);\n*/\n\n    /* Tabulate letter frequencies in the phrase */\n    cchPhraseLength = 0;\n    while ((ch = *pchPhrase++) != '\\0') {\n        if (isalpha(ch)) {\n            ch = tolower(ch);\n            lPhrase(ch).uFrequency++;\n            cchPhraseLength++;\n        }\n    }\n\n    /* Build  masks */\n    iq = 0;                             /* which quad being used */\n    cbtUsed = 0;                        /* bits used so far */\n\n    for (i = 0; i < ALPHABET; i++) {\n        if (alPhrase[i].uFrequency == 0) {\n            auGlobalFrequency[i] = ~0;  /* to make it sort last */\n        } else {\n            auGlobalFrequency[i] = 0;\n            for (cbtNeed = 1, qNeed = 1;\n                 alPhrase[i].uFrequency >= qNeed;\n                 cbtNeed++, qNeed <<= 1);\n            if (cbtUsed + cbtNeed > MASK_BITS) {\n                if (++iq >= MAX_QUADS)\n\t\t    Fatal(\"MAX_QUADS not large enough\\n\", 0);\n                cbtUsed = 0;\n            }\n            alPhrase[i].uBits = qNeed-1;\n            if (cbtUsed)\n\t\tqNeed <<= cbtUsed;\n            aqMainSign[iq] |= qNeed;\n            aqMainMask[iq] |= (Quad)alPhrase[i].uFrequency << cbtUsed;\n            alPhrase[i].uShift = cbtUsed;\n            alPhrase[i].iq = iq;\n            cbtUsed += cbtNeed;\n        }\n    }\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "BuildMask", "address": "0x1620", "label": "BuildMask", "content": "void __fastcall BuildMask(char *pchPhrase)\n{\n  unsigned __int16 *v1; // rsi\n  char *v2; // rcx\n  int v3; // eax\n  __int64 v4; // rdx\n  unsigned __int16 v5; // dx\n  Letter *v6; // r12\n  unsigned int *v7; // r13\n  unsigned int v8; // esi\n  unsigned int v9; // r8d\n  Letter *v10; // rdx\n  unsigned __int64 uFrequency; // rax\n  unsigned __int64 v12; // rbx\n  int v13; // ebp\n  unsigned int v14; // r10d\n  __m128i v15; // xmm0\n  __int64 v16; // rdi\n\n  libmin_memset(alPhrase, 0, 0x1A0uLL);\n  libmin_memset(aqMainMask, 0, 0x10uLL);\n  libmin_memset(aqMainSign, 0, 0x10uLL);\n  v1 = pctype;\n  v2 = pchPhrase + 1;\n  cchPhraseLength = 0;\n  v3 = *pchPhrase;\n  v4 = *pchPhrase;\n  if ( *pchPhrase )\n  {\n    do\n    {\n      v5 = v1[v4];\n      if ( (v5 & 3) != 0 )\n      {\n        if ( (v5 & 1) != 0 )\n          v3 += 32;\n        ++cchPhraseLength;\n        ++alPhrase[v3 - 97].uFrequency;\n      }\n      v4 = *v2++;\n      v3 = (char)v4;\n    }\n    while ( (_BYTE)v4 );\n  }\n  v6 = alPhrase;\n  v7 = auGlobalFrequency;\n  v8 = 0;\n  v9 = 0;\n  v10 = &alPhrase[26];\n  do\n  {\n    while ( 1 )\n    {\n      uFrequency = v6->uFrequency;\n      if ( (_DWORD)uFrequency )\n        break;\n      ++v6;\n      *v7++ = -1;\n      if ( v10 == v6 )\n        return;\n    }\n    *v7 = 0;\n    v12 = 1LL;\n    v13 = 1;\n    do\n    {\n      v12 *= 2LL;\n      ++v13;\n    }\n    while ( v12 <= uFrequency );\n    v14 = v12 - 1;\n    if ( (int)(v13 + v8) <= 32 )\n    {\n      v15 = _mm_cvtsi32_si128(v8);\n      if ( v8 )\n      {\n        v12 <<= v8;\n        v2 = (char *)v8;\n      }\n      else\n      {\n        v2 = 0LL;\n      }\n      v8 += v13;\n    }\n    else\n    {\n      if ( ++v9 > 1 )\n      {\n        libmin_printf(\"MAX_QUADS not large enough\\n\", 0LL, v10, v2);\n        libmin_fail(1);\n      }\n      v8 = v13;\n      v15 = 0LL;\n      v2 = 0LL;\n    }\n    v16 = v6->uFrequency;\n    ++v6;\n    v6[-1].iq = v9;\n    ++v7;\n    *(_QWORD *)&v6[-1].uShift = _mm_unpacklo_epi32(v15, _mm_cvtsi32_si128(v14)).m128i_u64[0];\n    aqMainSign[v9] |= v12;\n    aqMainMask[v9] |= v16 << (char)v2;\n  }\n  while ( v10 != v6 );\n}\n"}, "pseudo_normalize": "void BuildMask(char *pchPhrase) {\n  unsigned short *v1;\n  char *v2;\n  int v3;\n  long long v4;\n  unsigned short v5;\n  Letter *v6;\n  unsigned int *v7;\n  unsigned int v8;\n  unsigned int v9;\n  Letter *v10;\n  unsigned long long uFrequency;\n  unsigned long long v12;\n  int v13;\n  unsigned int v14;\n  __m128i v15;\n  long long v16;\n  libmin_memset(alPhrase, 0, 416uLL);\n  libmin_memset(aqMainMask, 0, 16uLL);\n  libmin_memset(aqMainSign, 0, 16uLL);\n  v1 = pctype;\n  v2 = pchPhrase + 1;\n  cchPhraseLength = 0;\n  v3 = *pchPhrase;\n  v4 = *pchPhrase;\n  if (*pchPhrase) {\n    do {\n      v5 = v1[v4];\n      if ((v5 & 3) != 0) {\n        if ((v5 & 1) != 0) v3 += 32;\n        ++cchPhraseLength;\n        ++alPhrase[v3 - 97].uFrequency;\n      }\n      v4 = *v2++;\n      v3 = (char)v4;\n    } while ((uint8_t)v4);\n  }\n  v6 = alPhrase;\n  v7 = auGlobalFrequency;\n  v8 = 0;\n  v9 = 0;\n  v10 = &alPhrase[26];\n  do {\n    while (1) {\n      uFrequency = v6->uFrequency;\n      if ((uint32_t)uFrequency) break;\n      ++v6;\n      *v7++ = -1;\n      if (v10 == v6) return;\n    }\n    *v7 = 0;\n    v12 = 1LL;\n    v13 = 1;\n    do {\n      v12 *= 2LL;\n      ++v13;\n    } while (v12 <= uFrequency);\n    v14 = v12 - 1;\n    if ((int)(v13 + v8) <= 32) {\n      v15 = _mm_cvtsi32_si128(v8);\n      if (v8) {\n        v12 <<= v8;\n        v2 = (char *)v8;\n      } else {\n        v2 = 0LL;\n      }\n      v8 += v13;\n    } else {\n      if (++v9 > 1) {\n        libmin_printf(\"MAX_QUADS not large enough\\n\", 0LL, v10, v2);\n        libmin_fail(1);\n      }\n      v8 = v13;\n      v15 = 0LL;\n      v2 = 0LL;\n    }\n    v16 = v6->uFrequency;\n    ++v6;\n    v6[-1].iq = v9;\n    ++v7;\n    *(uint64_t *)&v6[-1].uShift =\n        _mm_unpacklo_epi32(v15, _mm_cvtsi32_si128(v14)).m128i_u64[0];\n    aqMainSign[v9] |= v12;\n    aqMainMask[v9] |= v16 << (char)v2;\n  } while (v10 != v6);\n}", "binary": "anagram/anagram.host.O3", "assembly": "<BuildMask>:\nendbr64\npush   %r15\nmov    $0x1a0,%edx\nxor    %esi,%esi\nlea    0x3802c(%rip),%r15\npush   %r14\nlea    0x38013(%rip),%r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nlea    0x38033(%rip),%rbx\nmov    %rbx,%rdi\nsub    $0x18,%rsp\ncall   26a0 <libmin_memset>\nmov    $0x10,%edx\nxor    %esi,%esi\nmov    %r15,%rdi\ncall   26a0 <libmin_memset>\nmov    $0x10,%edx\nxor    %esi,%esi\nmov    %r14,%rdi\ncall   26a0 <libmin_memset>\nmov    0x37c2a(%rip),%rsi\nlea    0x1(%rbp),%rcx\nmovl   $0x0,0x37fe4(%rip)\nmovsbq 0x0(%rbp),%rax\nmov    %rax,%rdx\ntest   %eax,%eax\nje     16d5 <BuildMask+0xb5>\nnopl   0x0(%rax,%rax,1)\nmovzwl (%rsi,%rdx,2),%edx\ntest   $0x3,%dl\nje     16c6 <BuildMask+0xa6>\nand    $0x1,%edx\nlea    0x20(%rax),%edi\ncmovne %edi,%eax\naddl   $0x1,0x37fb7(%rip)\nsub    $0x61,%eax\ncltq\nshl    $0x4,%rax\naddl   $0x1,(%rbx,%rax,1)\nmovsbq (%rcx),%rdx\nadd    $0x1,%rcx\nmovsbl %dl,%eax\ntest   %eax,%eax\njne    16a0 <BuildMask+0x80>\nlea    0x37fa4(%rip),%r12\nlea    0x37efd(%rip),%r13\nxor    %esi,%esi\nxor    %r8d,%r8d\nlea    0x1a0(%r12),%rdx\nlea    0x39c8(%rip),%r9\njmp    1715 <BuildMask+0xf5>\nnopl   0x0(%rax)\nadd    $0x10,%r12\nmovl   $0xffffffff,0x0(%r13)\nadd    $0x4,%r13\ncmp    %r12,%rdx\nje     178e <BuildMask+0x16e>\nmov    (%r12),%eax\ntest   %eax,%eax\nje     1700 <BuildMask+0xe0>\nmovl   $0x0,0x0(%r13)\nmov    $0x1,%ebx\nmov    $0x1,%ebp\nnop\nadd    %rbx,%rbx\nadd    $0x1,%ebp\ncmp    %rax,%rbx\njbe    1730 <BuildMask+0x110>\nlea    0x0(%rbp,%rsi,1),%eax\nlea    -0x1(%rbx),%r10d\ncmp    $0x20,%eax\njle    17a0 <BuildMask+0x180>\nadd    $0x1,%r8d\ncmp    $0x1,%r8d\nja     17b8 <BuildMask+0x198>\nmov    %ebp,%esi\npxor   %xmm0,%xmm0\nxor    %ecx,%ecx\nmovd   %r10d,%xmm1\nmov    (%r12),%edi\nmov    %r8d,%eax\nadd    $0x10,%r12\npunpckldq %xmm1,%xmm0\nmov    %r8d,-0x4(%r12)\nadd    $0x4,%r13\nshl    %cl,%rdi\nmovq   %xmm0,-0xc(%r12)\nor     %rbx,(%r14,%rax,8)\nor     %rdi,(%r15,%rax,8)\ncmp    %r12,%rdx\njne    1715 <BuildMask+0xf5>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nmovd   %esi,%xmm0\ntest   %esi,%esi\nje     17fd <BuildMask+0x1dd>\nmov    %esi,%ecx\nshl    %cl,%rbx\nmov    %esi,%ecx\nmov    %eax,%esi\njmp    175a <BuildMask+0x13a>\nnopl   0x0(%rax,%rax,1)\nmov    %r9,%rdi\nxor    %esi,%esi\nxor    %eax,%eax\nmov    %r10d,0xc(%rsp)\nmov    %r8d,0x8(%rsp)\ncall   4890 <libmin_printf>\nmov    $0x1,%edi\ncall   2290 <libmin_fail>\nmov    0x8(%rsp),%r8d\nmov    %ebp,%esi\npxor   %xmm0,%xmm0\nmov    0xc(%rsp),%r10d\nxor    %ecx,%ecx\nlea    0x38ce(%rip),%r9\nlea    0x38028(%rip),%rdx\njmp    175a <BuildMask+0x13a>\nxor    %ecx,%ecx\nmov    %eax,%esi\njmp    175a <BuildMask+0x13a>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "BuildWord", "content": "/* BuildWord -- build a Word structure from an ASCII word\n * If the word does not fit, then do nothing.\n */\nvoid BuildWord(char * pchWord) {\n    unsigned char cchFrequency[ALPHABET];\n    int i;\n    char * pch = pchWord;\n    PWord pw;\n    int cchLength = 0;\n\n    libmin_memset(cchFrequency, 0, sizeof(unsigned char)*ALPHABET);\n    /* Zero(cchFrequency); */\n\n    /* Build frequency table */\n    while ((i = *pch++) != '\\0') {\n        if (!isalpha(i)) continue;\n        i = ch2i(tolower(i));\n        if (++cchFrequency[i] > alPhrase[i].uFrequency)\n\t    return;\n        ++cchLength;\n    }\n\n    Debug(wprint(pchWord);)\n\n    /* Update global count */\n    for (i = 0; i < ALPHABET; i++)\n        auGlobalFrequency[i] += cchFrequency[i];\n\n    /* Create a Word structure and fill it in, including building the\n     * bitfield of frequencies.\n     */\n    pw = NextWord();\n    libmin_memset(pw->aqMask, 0, sizeof(Quad)*MAX_QUADS);\n    /* Zero(pw->aqMask); */\n    pw->pchWord = pchWord;\n    pw->cchLength = cchLength;\n    for (i = 0; i < ALPHABET; i++) {\n        pw->aqMask[alPhrase[i].iq] |=\n            (Quad)cchFrequency[i] << alPhrase[i].uShift;\n    }\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "BuildWord", "address": "0x1940", "label": "BuildWord", "content": "void __fastcall BuildWord(char *pchWord)\n{\n  unsigned __int8 *v2; // rbx\n  int v3; // eax\n  unsigned __int16 *v4; // rdi\n  char *v5; // rcx\n  __int64 v6; // rdx\n  unsigned int v7; // esi\n  unsigned __int16 v8; // dx\n  int v9; // r9d\n  int v10; // eax\n  unsigned __int8 v11; // dl\n  unsigned int v12; // r13d\n  __m128i si128; // xmm1\n  __m128i v14; // xmm3\n  __m128i v15; // xmm4\n  PWord Word; // r12\n  Letter *p_uShift; // rax\n  __int64 v18; // rdx\n  unsigned int uFrequency; // ecx\n  unsigned __int8 cchFrequency[26]; // [rsp+0h] [rbp-58h] BYREF\n  unsigned __int64 v21; // [rsp+28h] [rbp-30h]\n\n  v21 = __readfsqword(0x28u);\n  v2 = cchFrequency;\n  libmin_memset(cchFrequency, 0, 0x1AuLL);\n  v3 = *pchWord;\n  if ( *pchWord )\n  {\n    v4 = pctype;\n    v5 = pchWord + 1;\n    v6 = *pchWord;\n    v7 = 0;\n    do\n    {\n      v8 = v4[v6];\n      if ( (v8 & 3) != 0 )\n      {\n        v9 = v3 - 65;\n        v10 = v3 - 97;\n        if ( (v8 & 1) != 0 )\n          v10 = v9;\n        v11 = cchFrequency[v10] + 1;\n        cchFrequency[v10] = v11;\n        if ( v11 > alPhrase[v10].uFrequency )\n          return;\n        ++v7;\n      }\n      v6 = *v5++;\n      v3 = (char)v6;\n    }\n    while ( (_BYTE)v6 );\n    v12 = v7;\n  }\n  else\n  {\n    v12 = 0;\n  }\n  si128 = _mm_load_si128((const __m128i *)cchFrequency);\n  v14 = _mm_unpackhi_epi8(si128, (__m128i)0LL);\n  v15 = _mm_unpacklo_epi8(si128, (__m128i)0LL);\n  *(__m128i *)&auGlobalFrequency[12] = _mm_add_epi32(\n                                         _mm_unpackhi_epi16(v14, (__m128i)0LL),\n                                         *(__m128i *)&auGlobalFrequency[12]);\n  *(__m128i *)auGlobalFrequency = _mm_add_epi32(_mm_unpacklo_epi16(v15, (__m128i)0LL), *(__m128i *)auGlobalFrequency);\n  *(__m128i *)&auGlobalFrequency[4] = _mm_add_epi32(\n                                        _mm_unpackhi_epi16(v15, (__m128i)0LL),\n                                        *(__m128i *)&auGlobalFrequency[4]);\n  auGlobalFrequency[24] += cchFrequency[24];\n  *(__m128i *)&auGlobalFrequency[8] = _mm_add_epi32(\n                                        _mm_unpacklo_epi16(v14, (__m128i)0LL),\n                                        *(__m128i *)&auGlobalFrequency[8]);\n  *(__m128i *)&auGlobalFrequency[20] = _mm_add_epi32(\n                                         _mm_unpacklo_epi64(\n                                           _mm_unpacklo_epi32(\n                                             _mm_cvtsi32_si128(cchFrequency[20]),\n                                             _mm_cvtsi32_si128(cchFrequency[21])),\n                                           _mm_unpacklo_epi32(\n                                             _mm_cvtsi32_si128(cchFrequency[22]),\n                                             _mm_cvtsi32_si128(cchFrequency[23]))),\n                                         *(__m128i *)&auGlobalFrequency[20]);\n  auGlobalFrequency[25] += cchFrequency[25];\n  *(__m128i *)&auGlobalFrequency[16] = _mm_add_epi32(\n                                         _mm_unpacklo_epi64(\n                                           _mm_unpacklo_epi32(\n                                             _mm_cvtsi32_si128(cchFrequency[16]),\n                                             _mm_cvtsi32_si128(cchFrequency[17])),\n                                           _mm_unpacklo_epi32(\n                                             _mm_cvtsi32_si128(cchFrequency[18]),\n                                             _mm_cvtsi32_si128(cchFrequency[19]))),\n                                         *(__m128i *)&auGlobalFrequency[16]);\n  Word = NextWord();\n  libmin_memset(Word, 0, 0x10uLL);\n  Word->pchWord = pchWord;\n  p_uShift = (Letter *)&alPhrase[0].uShift;\n  Word->cchLength = v12;\n  do\n  {\n    v18 = *v2;\n    uFrequency = p_uShift->uFrequency;\n    ++p_uShift;\n    ++v2;\n    Word->aqMask[p_uShift[-1].uBits] |= v18 << uFrequency;\n  }\n  while ( &alPhrase[26].uShift != (unsigned int *)p_uShift );\n}\n"}, "pseudo_normalize": "void BuildWord(char *pchWord) {\n  unsigned char *v2;\n  int v3;\n  unsigned short *v4;\n  char *v5;\n  long long v6;\n  unsigned int v7;\n  unsigned short v8;\n  int v9;\n  int v10;\n  unsigned char v11;\n  unsigned int v12;\n  __m128i si128;\n  __m128i v14;\n  __m128i v15;\n  PWord Word;\n  Letter *p_uShift;\n  long long v18;\n  unsigned int uFrequency;\n  unsigned char cchFrequency[26];\n  unsigned long long v21;\n  v21 = __readfsqword(40u);\n  v2 = cchFrequency;\n  libmin_memset(cchFrequency, 0, 26uLL);\n  v3 = *pchWord;\n  if (*pchWord) {\n    v4 = pctype;\n    v5 = pchWord + 1;\n    v6 = *pchWord;\n    v7 = 0;\n    do {\n      v8 = v4[v6];\n      if ((v8 & 3) != 0) {\n        v9 = v3 - 65;\n        v10 = v3 - 97;\n        if ((v8 & 1) != 0) v10 = v9;\n        v11 = cchFrequency[v10] + 1;\n        cchFrequency[v10] = v11;\n        if (v11 > alPhrase[v10].uFrequency) return;\n        ++v7;\n      }\n      v6 = *v5++;\n      v3 = (char)v6;\n    } while ((uint8_t)v6);\n    v12 = v7;\n  } else {\n    v12 = 0;\n  }\n  si128 = _mm_load_si128((const __m128i *)cchFrequency);\n  v14 = _mm_unpackhi_epi8(si128, (__m128i)0LL);\n  v15 = _mm_unpacklo_epi8(si128, (__m128i)0LL);\n  *(__m128i *)&auGlobalFrequency[12] =\n      _mm_add_epi32(_mm_unpackhi_epi16(v14, (__m128i)0LL),\n                    *(__m128i *)&auGlobalFrequency[12]);\n  *(__m128i *)auGlobalFrequency = _mm_add_epi32(\n      _mm_unpacklo_epi16(v15, (__m128i)0LL), *(__m128i *)auGlobalFrequency);\n  *(__m128i *)&auGlobalFrequency[4] = _mm_add_epi32(\n      _mm_unpackhi_epi16(v15, (__m128i)0LL), *(__m128i *)&auGlobalFrequency[4]);\n  auGlobalFrequency[24] += cchFrequency[24];\n  *(__m128i *)&auGlobalFrequency[8] = _mm_add_epi32(\n      _mm_unpacklo_epi16(v14, (__m128i)0LL), *(__m128i *)&auGlobalFrequency[8]);\n  *(__m128i *)&auGlobalFrequency[20] = _mm_add_epi32(\n      _mm_unpacklo_epi64(\n          _mm_unpacklo_epi32(_mm_cvtsi32_si128(cchFrequency[20]),\n                             _mm_cvtsi32_si128(cchFrequency[21])),\n          _mm_unpacklo_epi32(_mm_cvtsi32_si128(cchFrequency[22]),\n                             _mm_cvtsi32_si128(cchFrequency[23]))),\n      *(__m128i *)&auGlobalFrequency[20]);\n  auGlobalFrequency[25] += cchFrequency[25];\n  *(__m128i *)&auGlobalFrequency[16] = _mm_add_epi32(\n      _mm_unpacklo_epi64(\n          _mm_unpacklo_epi32(_mm_cvtsi32_si128(cchFrequency[16]),\n                             _mm_cvtsi32_si128(cchFrequency[17])),\n          _mm_unpacklo_epi32(_mm_cvtsi32_si128(cchFrequency[18]),\n                             _mm_cvtsi32_si128(cchFrequency[19]))),\n      *(__m128i *)&auGlobalFrequency[16]);\n  Word = NextWord();\n  libmin_memset(Word, 0, 16uLL);\n  Word->pchWord = pchWord;\n  p_uShift = (Letter *)&alPhrase[0].uShift;\n  Word->cchLength = v12;\n  do {\n    v18 = *v2;\n    uFrequency = p_uShift->uFrequency;\n    ++p_uShift;\n    ++v2;\n    Word->aqMask[p_uShift[-1].uBits] |= v18 << uFrequency;\n  } while (&alPhrase[26].uShift != (unsigned int *)p_uShift);\n}", "binary": "anagram/anagram.host.O3", "assembly": "<BuildWord>:\nendbr64\npush   %r13\nmov    $0x1a,%edx\nxor    %esi,%esi\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbx\nmov    %rbx,%rdi\ncall   26a0 <libmin_memset>\nmovsbq 0x0(%rbp),%rax\ntest   %eax,%eax\nje     1b57 <BuildWord+0x217>\nmov    0x37921(%rip),%rdi\nlea    0x1(%rbp),%rcx\nmov    %rax,%rdx\nxor    %esi,%esi\nlea    0x37ce9(%rip),%r8\nnopw   0x0(%rax,%rax,1)\nmovzwl (%rdi,%rdx,2),%edx\ntest   $0x3,%dl\nje     19d7 <BuildWord+0x97>\nlea    -0x41(%rax),%r9d\nsub    $0x61,%eax\nand    $0x1,%edx\ncmovne %r9d,%eax\ncltq\nmovzbl (%rsp,%rax,1),%edx\nadd    $0x1,%edx\nmov    %dl,(%rsp,%rax,1)\nshl    $0x4,%rax\nmovzbl %dl,%edx\ncmp    (%r8,%rax,1),%edx\nja     1b3c <BuildWord+0x1fc>\nadd    $0x1,%esi\nmovsbq (%rcx),%rdx\nadd    $0x1,%rcx\nmovsbl %dl,%eax\ntest   %eax,%eax\njne    19a0 <BuildWord+0x60>\nmov    %esi,%r13d\nmovdqa (%rsp),%xmm0\npxor   %xmm2,%xmm2\nmovzbl 0x14(%rsp),%eax\nmovzbl 0x16(%rsp),%edi\nmovzbl 0x17(%rsp),%edx\nmovdqa %xmm0,%xmm1\npunpckhbw %xmm2,%xmm0\npunpcklbw %xmm2,%xmm1\npxor   %xmm2,%xmm2\nmovdqa %xmm0,%xmm3\npunpckhwd %xmm2,%xmm0\npaddd  0x37bef(%rip),%xmm0\nmovdqa %xmm1,%xmm4\npunpcklwd %xmm2,%xmm1\npaddd  0x37baf(%rip),%xmm1\nmovd   %edx,%xmm5\nmovzbl 0x13(%rsp),%edx\nmovaps %xmm0,0x37bcf(%rip)\nmovd   %eax,%xmm0\nmovzbl 0x15(%rsp),%eax\npunpckhwd %xmm2,%xmm4\nmovaps %xmm1,0x37b8b(%rip)\nmovd   %edi,%xmm1\nmovzbl 0x12(%rsp),%edi\nmovd   %edx,%xmm7\nmovd   %eax,%xmm6\npunpckldq %xmm5,%xmm1\nmovzbl 0x10(%rsp),%eax\npunpcklwd %xmm2,%xmm3\npunpckldq %xmm6,%xmm0\nmovd   %edi,%xmm2\npaddd  0x37b6d(%rip),%xmm4\npunpcklqdq %xmm1,%xmm0\nmovd   %eax,%xmm1\npunpckldq %xmm7,%xmm2\nmovzbl 0x11(%rsp),%eax\npaddd  0x37b64(%rip),%xmm3\npaddd  0x37b8c(%rip),%xmm0\nmovaps %xmm4,0x37b45(%rip)\nmovd   %eax,%xmm5\nmovzbl 0x18(%rsp),%eax\nadd    %eax,0x37b86(%rip)\npunpckldq %xmm5,%xmm1\nmovzbl 0x19(%rsp),%eax\nmovaps %xmm3,0x37b36(%rip)\npunpcklqdq %xmm2,%xmm1\npaddd  0x37b4a(%rip),%xmm1\nmovaps %xmm0,0x37b53(%rip)\nadd    %eax,0x37b61(%rip)\nmovaps %xmm1,0x37b36(%rip)\ncall   1880 <NextWord>\nmov    $0x10,%edx\nxor    %esi,%esi\nmov    %rax,%r12\nmov    %rax,%rdi\ncall   26a0 <libmin_memset>\nmov    %rbp,0x10(%r12)\nlea    0x37b77(%rip),%rax\nmov    %r13d,0x18(%r12)\nlea    0x1a0(%rax),%rdi\nnopl   0x0(%rax)\nmovzbl (%rbx),%edx\nmov    (%rax),%ecx\nadd    $0x10,%rax\nadd    $0x1,%rbx\nmov    -0x8(%rax),%esi\nshl    %cl,%rdx\nor     %rdx,(%r12,%rsi,8)\ncmp    %rax,%rdi\njne    1b20 <BuildWord+0x1e0>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1b5f <BuildWord+0x21f>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nxor    %r13d,%r13d\njmp    19e9 <BuildWord+0xa9>\ncall   10c0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "CompareFrequency", "content": "int Cdecl CompareFrequency(char *pch1, char *pch2) {\n    return auGlobalFrequency[(int)(*pch1)] < auGlobalFrequency[(int)(*pch2)]\n        ?  -1 :\n           auGlobalFrequency[(int)(*pch1)] == auGlobalFrequency[(int)(*pch2)]\n        ?   0 : 1;\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "CompareFrequency", "address": "0x1470", "label": "CompareFrequency", "content": "int __fastcall CompareFrequency(char *pch1, char *pch2)\n{\n  __int64 v2; // rcx\n  int v3; // r8d\n  unsigned int v4; // edx\n\n  v2 = *pch1;\n  v3 = -1;\n  v4 = auGlobalFrequency[*pch2];\n  if ( auGlobalFrequency[v2] >= v4 )\n    return auGlobalFrequency[v2] != v4;\n  return v3;\n}\n"}, "pseudo_normalize": "int CompareFrequency(char *pch1, char *pch2) {\n  long long v2;\n  int v3;\n  unsigned int v4;\n  v2 = *pch1;\n  v3 = -1;\n  v4 = auGlobalFrequency[*pch2];\n  if (auGlobalFrequency[v2] >= v4) return auGlobalFrequency[v2] != v4;\n  return v3;\n}", "binary": "anagram/anagram.host.O3", "assembly": "<CompareFrequency>:\nendbr64\nmovsbq (%rsi),%rdx\nmovsbq (%rdi),%rcx\nlea    0x3815d(%rip),%rax\nmov    $0xffffffff,%r8d\nmov    (%rax,%rdx,4),%edx\ncmp    %edx,(%rax,%rcx,4)\njb     1499 <CompareFrequency+0x29>\nsetne  %r8b\nmovzbl %r8b,%r8d\nmov    %r8d,%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "DumpCandidates", "content": "void DumpCandidates(void) {\n    unsigned u;\n\n    for (u = 0; u < cpwCand; u++)\n        libmin_printf(StringFormat, apwCand[u]->pchWord, (u % 4 == 3) ? '\\n' : ' ');\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "DumpCandidates", "address": "0x1c10", "label": "DumpCandidates", "content": "void __cdecl DumpCandidates()\n{\n  __int64 v0; // rbx\n  __int64 v1; // rdx\n\n  if ( cpwCand )\n  {\n    v0 = 1LL;\n    v1 = 32LL;\n    while ( 1 )\n    {\n      libmin_printf(\"%15s%c\", *(const char **)(qword_39838[v0] + 16LL), v1);\n      if ( cpwCand <= (unsigned int)v0 )\n        break;\n      v1 = 10LL;\n      if ( (v0 & 3) != 3 )\n        v1 = 32LL;\n      ++v0;\n    }\n  }\n  libmin_printf((char *)\"\\n\");\n}\n"}, "pseudo_normalize": "void DumpCandidates() {\n  long long v0;\n  long long v1;\n  if (cpwCand) {\n    v0 = 1LL;\n    v1 = 32LL;\n    while (1) {\n      libmin_printf(\"%15s%c\", *(const char **)(qword_39838[v0] + 16LL), v1);\n      if (cpwCand <= (unsigned int)v0) break;\n      v1 = 10LL;\n      if ((v0 & 3) != 3) v1 = 32LL;\n      ++v0;\n    }\n  }\n  libmin_printf((char *)\"\\n\");\n}", "binary": "anagram/anagram.host.O3", "assembly": "<DumpCandidates>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x37bfc(%rip),%eax\ntest   %eax,%eax\nje     1c80 <DumpCandidates+0x70>\nmov    $0x1,%ebx\nmov    $0x20,%edx\nlea    0x37bff(%rip),%r13\nmov    $0x20,%r12d\nlea    0x34bd(%rip),%rbp\njmp    1c65 <DumpCandidates+0x55>\nnopl   0x0(%rax,%rax,1)\nmov    %ebx,%eax\nmov    $0xa,%edx\nand    $0x3,%eax\ncmp    $0x3,%eax\ncmovne %r12d,%edx\nadd    $0x1,%rbx\nmov    0x0(%r13,%rbx,8),%rax\nmov    %rbp,%rdi\nmov    0x10(%rax),%rsi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\ncmp    %ebx,0x37ba2(%rip)\nja     1c50 <DumpCandidates+0x40>\nadd    $0x8,%rsp\nlea    0x34a6(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    4890 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "DumpWords", "content": ")                                       /* End of debug code */\n\nvoid DumpWords(void) {\n    int i;\n    for (i = 0; i < cpwLast; i++) wprint(apwSol[i]->pchWord);\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "DumpWords", "address": "0x1ca0", "label": "DumpWords", "content": "void __cdecl DumpWords()\n{\n  __int64 v0; // rbx\n  PWord v1; // rax\n\n  if ( cpwLast > 0 )\n  {\n    v0 = 0LL;\n    do\n    {\n      v1 = apwSol[v0++];\n      libmin_printf(\"%s \", v1->pchWord);\n    }\n    while ( cpwLast > (int)v0 );\n  }\n  libmin_printf((char *)\"\\n\");\n}\n"}, "pseudo_normalize": "void DumpWords() {\n  long long v0;\n  PWord v1;\n  if (cpwLast > 0) {\n    v0 = 0LL;\n    do {\n      v1 = apwSol[v0++];\n      libmin_printf(\"%s \", v1->pchWord);\n    } while (cpwLast > (int)v0);\n  }\n  libmin_printf((char *)\"\\n\");\n}", "binary": "anagram/anagram.host.O3", "assembly": "<DumpWords>:\nendbr64\nmov    0x37756(%rip),%eax\npush   %r12\npush   %rbp\npush   %rbx\ntest   %eax,%eax\njle    1ce6 <DumpWords+0x46>\nxor    %ebx,%ebx\nlea    0x37765(%rip),%r12\nlea    0x3419(%rip),%rbp\nnopw   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,8),%rax\nmov    %rbp,%rdi\nadd    $0x1,%rbx\nmov    0x10(%rax),%rsi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\ncmp    %ebx,0x3771c(%rip)\njg     1cc8 <DumpWords+0x28>\npop    %rbx\nlea    0x3443(%rip),%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\njmp    4890 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "FindAnagram", "content": "void\nFindAnagram(Quad * pqMask, PPWord ppwStart, int iLetter)\n{\n    Quad aqNext[MAX_QUADS];\n    register PWord pw;\n    Quad qMask;\n    unsigned iq;\n    PPWord ppwEnd = &apwCand[0];\n    ppwEnd += cpwCand;\n\n    ;\n\n    Debug(libmin_printf(\"Trying :\"); DumpWord(pqMask); libmin_printf(\":\\n\");)\n\n    for (;;) {\n        iq = alPhrase[(int)achByFrequency[iLetter]].iq;\n        qMask = alPhrase[(int)achByFrequency[iLetter]].uBits <<\n                alPhrase[(int)achByFrequency[iLetter]].uShift;\n        if (pqMask[iq] & qMask) break;\n        iLetter++;\n    }\n\n    Debug(libmin_printf(\"Pivoting on %c\\n\", i2ch(achByFrequency[iLetter]));)\n\n    while (ppwStart < ppwEnd) {          /* Half of the program execution */\n        pw = *ppwStart;                  /* time is spent in these three */\n\n        Stat(if (++ulLowCount == 0) ++ulHighCount;)\n\n#if MAX_QUADS > 0\n        OneStep(0);                     /* lines of code. */\n#endif\n\n#if MAX_QUADS > 1\n        OneStep(1);\n#endif\n\n#if MAX_QUADS > 2\n        OneStep(2);\n#endif\n\n#if MAX_QUADS > 3\n        OneStep(3);\n#endif\n\n#if MAX_QUADS > 4\n            @@\"Add more unrolling steps here, please.\"@@\n#endif\n\n        /* If the pivot letter isn't present, defer this word until later */\n        if ((pw->aqMask[iq] & qMask) == 0) {\n            *ppwStart = *--ppwEnd;\n            *ppwEnd = pw;\n            continue;\n        }\n\n        /* If we get here, this means the word fits. */\n        apwSol[cpwLast++] = pw;\n        if (cchPhraseLength -= pw->cchLength) { /* recurse */\n            Debug(DumpWords();)\n            /* The recursive call scrambles the tail, so we have to be\n             * pessimistic.\n             */\n\t    ppwEnd = &apwCand[0];\n\t    ppwEnd += cpwCand;\n            FindAnagram(&aqNext[0],\n\t\t\tppwStart, iLetter);\n        } else DumpWords();             /* found one */\n        cchPhraseLength += pw->cchLength;\n        --cpwLast;\n        ppwStart++;\n        continue;\n    }\n\n    ;\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "FindAnagram", "address": "0x1d00", "label": "FindAnagram", "content": "void __fastcall FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter)\n{\n  int v3; // r14d\n  const char *pchWord; // rsi\n  Letter *v6; // rax\n  __int64 iq; // rbp\n  __int64 i; // rbx\n  __int64 v9; // rax\n  Letter *v10; // rax\n  PWord *v11; // r14\n  PPWord v12; // r15\n  Word *v13; // r13\n  Quad v14; // rbx\n  Word *v15; // rax\n  int v16; // edx\n  bool v17; // zf\n  int v18; // eax\n  unsigned int cchLength; // eax\n  PWord v20; // rax\n  __int64 v21; // [rsp+8h] [rbp-70h]\n  int iLettera; // [rsp+1Ch] [rbp-5Ch]\n  Quad aqNext[3]; // [rsp+20h] [rbp-58h] BYREF\n  unsigned __int64 v24; // [rsp+38h] [rbp-40h]\n\n  v3 = iLetter;\n  pchWord = (const char *)(iLetter + 1);\n  v24 = __readfsqword(0x28u);\n  v6 = &alPhrase[achByFrequency[iLetter]];\n  iq = v6->iq;\n  for ( i = v6->uBits << v6->uShift; (pqMask[iq] & (unsigned int)i) == 0; i = v10->uBits << v10->uShift )\n  {\n    v9 = achByFrequency[(_QWORD)pchWord];\n    v3 = (int)pchWord++;\n    v10 = &alPhrase[v9];\n    iq = v10->iq;\n  }\n  if ( &apwCand[cpwCand] > ppwStart )\n  {\n    v21 = i;\n    iLettera = v3;\n    v11 = &apwCand[cpwCand];\n    v12 = ppwStart;\n    while ( 1 )\n    {\n      v13 = *v12;\n      aqNext[0] = *pqMask - (*v12)->aqMask[0];\n      if ( (aqMainSign[0] & aqNext[0]) != 0 )\n        goto LABEL_14;\n      aqNext[1] = pqMask[1] - v13->aqMask[1];\n      v14 = aqMainSign[1] & aqNext[1];\n      if ( (aqMainSign[1] & aqNext[1]) != 0 )\n        goto LABEL_14;\n      if ( (v13->aqMask[iq] & v21) != 0 )\n        break;\n      v15 = *--v11;\n      *v12 = v15;\n      *v11 = v13;\nLABEL_9:\n      if ( v11 <= v12 )\n        return;\n    }\n    v16 = cpwLast + 1;\n    apwSol[cpwLast] = v13;\n    v17 = cchPhraseLength == v13->cchLength;\n    v18 = cchPhraseLength - v13->cchLength;\n    cpwLast = v16;\n    cchPhraseLength = v18;\n    if ( v17 )\n    {\n      if ( v16 > 0 )\n      {\n        do\n        {\n          v20 = apwSol[v14++];\n          pchWord = v20->pchWord;\n          libmin_printf(\"%s \", pchWord);\n        }\n        while ( cpwLast > (int)v14 );\n      }\n      libmin_printf((char *)\"\\n\", pchWord);\n    }\n    else\n    {\n      pchWord = (const char *)v12;\n      v11 = &apwCand[cpwCand];\n      FindAnagram(aqNext, v12, iLettera);\n    }\n    cchLength = v13->cchLength;\n    --cpwLast;\n    cchPhraseLength += cchLength;\nLABEL_14:\n    ++v12;\n    goto LABEL_9;\n  }\n}\n"}, "pseudo_normalize": "void FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter) {\n  int v3;\n  const char *pchWord;\n  Letter *v6;\n  long long iq;\n  long long i;\n  long long v9;\n  Letter *v10;\n  PWord *v11;\n  PPWord v12;\n  Word *v13;\n  Quad v14;\n  Word *v15;\n  int v16;\n  bool v17;\n  int v18;\n  unsigned int cchLength;\n  PWord v20;\n  long long v21;\n  int iLettera;\n  Quad aqNext[3];\n  unsigned long long v24;\n  v3 = iLetter;\n  pchWord = (const char *)(iLetter + 1);\n  v24 = __readfsqword(40u);\n  v6 = &alPhrase[achByFrequency[iLetter]];\n  iq = v6->iq;\n  for (i = v6->uBits << v6->uShift; (pqMask[iq] & (unsigned int)i) == 0;\n       i = v10->uBits << v10->uShift) {\n    v9 = achByFrequency[(uint64_t)pchWord];\n    v3 = (int)pchWord++;\n    v10 = &alPhrase[v9];\n    iq = v10->iq;\n  }\n  if (&apwCand[cpwCand] > ppwStart) {\n    v21 = i;\n    iLettera = v3;\n    v11 = &apwCand[cpwCand];\n    v12 = ppwStart;\n    while (1) {\n      v13 = *v12;\n      aqNext[0] = *pqMask - (*v12)->aqMask[0];\n      if ((aqMainSign[0] & aqNext[0]) != 0) goto LABEL_14;\n      aqNext[1] = pqMask[1] - v13->aqMask[1];\n      v14 = aqMainSign[1] & aqNext[1];\n      if ((aqMainSign[1] & aqNext[1]) != 0) goto LABEL_14;\n      if ((v13->aqMask[iq] & v21) != 0) break;\n      v15 = *--v11;\n      *v12 = v15;\n      *v11 = v13;\n    LABEL_9:\n      if (v11 <= v12) return;\n    }\n    v16 = cpwLast + 1;\n    apwSol[cpwLast] = v13;\n    v17 = cchPhraseLength == v13->cchLength;\n    v18 = cchPhraseLength - v13->cchLength;\n    cpwLast = v16;\n    cchPhraseLength = v18;\n    if (v17) {\n      if (v16 > 0) {\n        do {\n          v20 = apwSol[v14++];\n          pchWord = v20->pchWord;\n          libmin_printf(\"%s \", pchWord);\n        } while (cpwLast > (int)v14);\n      }\n      libmin_printf((char *)\"\\n\", pchWord);\n    } else {\n      pchWord = (const char *)v12;\n      v11 = &apwCand[cpwCand];\n      FindAnagram(aqNext, v12, iLettera);\n    }\n    cchLength = v13->cchLength;\n    --cpwLast;\n    cchPhraseLength += cchLength;\n  LABEL_14:\n    ++v12;\n    goto LABEL_9;\n  }\n}", "binary": "anagram/anagram.host.O3", "assembly": "<FindAnagram>:\nendbr64\npush   %r15\nlea    0x378b3(%rip),%r10\npush   %r14\nmov    %edx,%r14d\nlea    0x37b27(%rip),%rdx\npush   %r13\nmov    %rsi,%r13\nlea    0x1(%r14),%esi\npush   %r12\nmov    %rdi,%r12\nlea    0x37952(%rip),%rdi\nmovslq %esi,%rsi\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nmov    0x37ad3(%rip),%eax\nlea    (%rdx,%rax,8),%r15\nmovslq %r14d,%rax\nmovsbq (%r10,%rax,1),%rax\nshl    $0x4,%rax\nadd    %rdi,%rax\nmov    0x4(%rax),%ecx\nmov    0x8(%rax),%ebx\nmov    0xc(%rax),%ebp\nshl    %cl,%ebx\nmov    %rbx,%rax\nand    (%r12,%rbp,8),%rax\njne    1d9f <FindAnagram+0x9f>\nnopl   0x0(%rax)\nmovsbq (%r10,%rsi,1),%rax\nmov    %esi,%r14d\nadd    $0x1,%rsi\nshl    $0x4,%rax\nadd    %rdi,%rax\nmov    0x4(%rax),%ecx\nmov    0x8(%rax),%ebx\nmov    0xc(%rax),%ebp\nshl    %cl,%ebx\nmov    %rbx,%rax\nand    (%r12,%rbp,8),%rax\nje     1d78 <FindAnagram+0x78>\nlea    0x20(%rsp),%rax\nlea    0x37675(%rip),%r10\nmov    %rax,0x10(%rsp)\ncmp    %r13,%r15\njbe    1e27 <FindAnagram+0x127>\nmov    %rbx,0x8(%rsp)\nmov    %rbp,%rax\nmov    %r12,%rbp\nmov    %r14d,0x1c(%rsp)\nmov    %rax,%r12\nmov    %r15,%r14\nmov    %r13,%r15\nmov    (%r15),%r13\nmov    0x0(%rbp),%rax\nlea    0x37874(%rip),%rdx\nsub    0x0(%r13),%rax\nmov    %rax,0x20(%rsp)\nand    (%rdx),%rax\njne    1eb0 <FindAnagram+0x1b0>\nmov    0x8(%rbp),%rbx\nsub    0x8(%r13),%rbx\nmov    %rbx,0x28(%rsp)\nand    0x37856(%rip),%rbx\njne    1eb0 <FindAnagram+0x1b0>\nmov    0x8(%rsp),%rax\nand    0x0(%r13,%r12,8),%rax\njne    1e50 <FindAnagram+0x150>\nmov    -0x8(%r14),%rax\nsub    $0x8,%r14\nmov    %rax,(%r15)\nmov    %r13,(%r14)\ncmp    %r15,%r14\nja     1dce <FindAnagram+0xce>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1f08 <FindAnagram+0x208>\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmovslq 0x375a9(%rip),%rax\nlea    0x1(%rax),%edx\nmov    %r13,(%r10,%rax,8)\nmov    0x3780c(%rip),%eax\nsub    0x18(%r13),%eax\nmov    %edx,0x37592(%rip)\nmov    %eax,0x377fc(%rip)\nje     1ec0 <FindAnagram+0x1c0>\nmov    0x379a4(%rip),%eax\nlea    0x379bd(%rip),%rdx\nmov    0x10(%rsp),%rdi\nmov    %r15,%rsi\nlea    (%rdx,%rax,8),%r14\nmov    0x1c(%rsp),%edx\ncall   1d00 <FindAnagram>\nlea    0x37581(%rip),%r10\nmov    0x18(%r13),%eax\nsubl   $0x1,0x37556(%rip)\nadd    %eax,0x377c0(%rip)\nadd    $0x8,%r15\njmp    1e22 <FindAnagram+0x122>\nnopl   0x0(%rax)\ntest   %edx,%edx\njle    1ef1 <FindAnagram+0x1f1>\nnopl   0x0(%rax)\nmov    (%r10,%rbx,8),%rax\nlea    0x3208(%rip),%rdi\nadd    $0x1,%rbx\nmov    0x10(%rax),%rsi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\ncmp    %ebx,0x37518(%rip)\nlea    0x37531(%rip),%r10\njg     1ec8 <FindAnagram+0x1c8>\nlea    0x3239(%rip),%rdi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\nlea    0x3751a(%rip),%r10\njmp    1e9f <FindAnagram+0x19f>\ncall   10c0 <__stack_chk_fail@plt>\nnopl   (%rax)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "GetPhrase", "content": "char * GetPhrase(char * pch) {\n    if (libmin_mgets(pch, 255, minput) == NULL) {\n\t    return NULL;\n    }\n    // libmin_printf(\"Processing: %s...\\n\", pch);\n    return(pch);\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "GetPhrase", "address": "0x1fa0", "label": "GetPhrase", "content": "char *__fastcall GetPhrase(char *pch)\n{\n  char *v1; // r12\n\n  v1 = pch;\n  if ( !libmin_mgets(pch, 0xFFuLL, minput) )\n    return 0LL;\n  return v1;\n}\n"}, "pseudo_normalize": "char *GetPhrase(char *pch) {\n  char *v1;\n  v1 = pch;\n  if (!libmin_mgets(pch, 255uLL, minput)) return 0LL;\n  return v1;\n}", "binary": "anagram/anagram.host.O3", "assembly": "<GetPhrase>:\nendbr64\npush   %r12\nmov    0x37073(%rip),%rdx\nmov    $0xff,%esi\nmov    %rdi,%r12\ncall   2760 <libmin_mgets>\ntest   %rax,%rax\nmov    $0x0,%eax\ncmove  %rax,%r12\nmov    %r12,%rax\npop    %r12\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "NewWord", "content": "PWord\nNewWord(void) {\n    PWord pw;\n\n    pw = (Word *)libmin_malloc(sizeof(Word));\n    if (pw == NULL)\n        Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n    return pw;\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "NewWord", "address": "0x1810", "label": "NewWord", "content": "PWord __cdecl NewWord()\n{\n  PWord result; // rax\n\n  result = (PWord)libmin_malloc(0x20uLL);\n  if ( !result )\n  {\n    libmin_printf(\"Out of memory after %d candidates\\n\", cpwCand);\n    libmin_fail(1);\n  }\n  return result;\n}\n"}, "pseudo_normalize": "PWord NewWord() {\n  PWord result;\n  result = (PWord)libmin_malloc(32uLL);\n  if (!result) {\n    libmin_printf(\"Out of memory after %d candidates\\n\", cpwCand);\n    libmin_fail(1);\n  }\n  return result;\n}", "binary": "anagram/anagram.host.O3", "assembly": "<NewWord>:\nendbr64\npush   %r12\nmov    $0x20,%edi\ncall   22b0 <libmin_malloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1830 <NewWord+0x20>\nmov    %r12,%rax\npop    %r12\nret\nxchg   %ax,%ax\nmov    0x37fea(%rip),%esi\nlea    0x384b(%rip),%rdi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\nmov    $0x1,%edi\ncall   2290 <libmin_fail>\nmov    %r12,%rax\npop    %r12\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "NextWord", "content": "/* NextWord -- get another candidate entry, creating if necessary */\nPWord NextWord(void) {\n    PWord pw;\n    if (cpwCand >= MAXCAND)\n\tFatal(\"Too many candidates\\n\", 0);\n    pw = apwCand[cpwCand++];\n    if (pw != NULL)\n\treturn pw;\n    apwCand[cpwCand-1] = NewWord();\n    return apwCand[cpwCand-1];\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "NextWord", "address": "0x1880", "label": "NextWord", "content": "PWord __cdecl NextWord()\n{\n  __int64 v0; // rbx\n  PWord result; // rax\n  Word *v2; // r12\n  unsigned int v3; // eax\n\n  if ( cpwCand > 0x1387 )\n  {\n    libmin_printf(\"Too many candidates\\n\", 0LL);\n    libmin_fail(1);\n  }\n  v0 = cpwCand;\n  result = apwCand[cpwCand++];\n  if ( !result )\n  {\n    v2 = (Word *)libmin_malloc(0x20uLL);\n    if ( !v2 )\n    {\n      libmin_printf(\"Out of memory after %d candidates\\n\", cpwCand);\n      libmin_fail(1);\n    }\n    v3 = cpwCand;\n    apwCand[v0] = v2;\n    return apwCand[v3 - 1];\n  }\n  return result;\n}\n"}, "pseudo_normalize": "PWord NextWord() {\n  long long v0;\n  PWord result;\n  Word *v2;\n  unsigned int v3;\n  if (cpwCand > 4999) {\n    libmin_printf(\"Too many candidates\\n\", 0LL);\n    libmin_fail(1);\n  }\n  v0 = cpwCand;\n  result = apwCand[cpwCand++];\n  if (!result) {\n    v2 = (Word *)libmin_malloc(32uLL);\n    if (!v2) {\n      libmin_printf(\"Out of memory after %d candidates\\n\", cpwCand);\n      libmin_fail(1);\n    }\n    v3 = cpwCand;\n    apwCand[v0] = v2;\n    return apwCand[v3 - 1];\n  }\n  return result;\n}", "binary": "anagram/anagram.host.O3", "assembly": "<NextWord>:\nendbr64\nmov    0x37f96(%rip),%eax\npush   %r12\npush   %rbp\npush   %rbx\ncmp    $0x1387,%eax\nja     18c0 <NextWord+0x40>\nlea    0x37fa4(%rip),%rbp\nmov    %eax,%ebx\nlea    0x1(%rax),%edx\nmov    0x0(%rbp,%rbx,8),%rax\nmov    %edx,0x37f74(%rip)\ntest   %rax,%rax\nje     18e8 <NextWord+0x68>\npop    %rbx\npop    %rbp\npop    %r12\nret\ncs nopw 0x0(%rax,%rax,1)\nxor    %esi,%esi\nlea    0x3816(%rip),%rdi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\nmov    $0x1,%edi\ncall   2290 <libmin_fail>\nmov    0x37f40(%rip),%eax\njmp    1895 <NextWord+0x15>\nnopw   0x0(%rax,%rax,1)\nmov    $0x20,%edi\ncall   22b0 <libmin_malloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1918 <NextWord+0x98>\nmov    0x37f20(%rip),%eax\nmov    %r12,0x0(%rbp,%rbx,8)\npop    %rbx\nsub    $0x1,%eax\nmov    0x0(%rbp,%rax,8),%rax\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nmov    0x37f02(%rip),%esi\nlea    0x3763(%rip),%rdi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\nmov    $0x1,%edi\ncall   2290 <libmin_fail>\njmp    18fa <NextWord+0x7a>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "ReadDict", "content": "/* ReadDict -- read the dictionary file into memory and preprocess it\n *\n * A word of length cch in the dictionary is encoded as follows:\n *\n *    byte 0    = cch + 3\n *    byte 1    = number of letters in the word\n *    byte 2... = the word itself, null-terminated\n *\n * Observe that cch+3 is the length of the total encoding.  These\n * byte streams are concatenated, and terminated with a 0.\n */\n\nvoid ReadDict(char *pchFile) {\n    char * pch;\n    char * pchBase;\n    unsigned long ulLen;\n    unsigned cWords = 0;\n    unsigned cLetters;\n    int ch;\n\n    ulLen = libmin_msize(mwords) + 2 * (unsigned long)MAXWORDS;\n    pchBase = pchDictionary = (char *)libmin_malloc(ulLen);\n\n    if(pchDictionary == NULL)\n\tFatal(\"Unable to allocate memory for dictionary\\n\", 0);\n\n    libmin_mopen(mwords, \"r\");\n\n    while (!libmin_meof(mwords)) {\n        pch = pchBase+2;                /* reserve for length */\n        cLetters = 0;\n        while ((ch = libmin_mgetc(mwords)) != '\\n' && ch != EOF) {\n            if (isalpha(ch)) cLetters++;\n            *pch++ = ch;\n        }\n        *pch++ = '\\0';\n        *pchBase = pch - pchBase;\n        pchBase[1] = cLetters;\n        pchBase = pch;\n        cWords++;\n    }\n    libmin_mclose(mwords);\n\n    *pchBase++ = 0;\n\n    libmin_printf(\"main dictionary has %u entries\\n\", cWords);\n    if (cWords >= MAXWORDS)\n\t    Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n    libmin_printf(\"%lu bytes wasted\\n\", ulLen - (pchBase - pchDictionary));\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "ReadDict", "address": "0x14c0", "label": "ReadDict", "content": "void __fastcall ReadDict(char *pchFile)\n{\n  size_t v1; // r13\n  char *v2; // rbp\n  unsigned int v3; // r12d\n  _BYTE *v4; // r14\n  char v5; // bl\n  int v6; // eax\n\n  v1 = libmin_msize(mwords) + 52000;\n  pchDictionary = (char *)libmin_malloc(v1);\n  v2 = pchDictionary;\n  if ( !pchDictionary )\n  {\n    libmin_printf(\"Unable to allocate memory for dictionary\\n\", 0LL);\n    libmin_fail(1);\n  }\n  v3 = 0;\n  libmin_mopen(mwords, \"r\");\n  for ( ; !libmin_meof(mwords); v2 = v4 + 1 )\n  {\n    v4 = v2 + 2;\n    v5 = 0;\n    while ( 1 )\n    {\n      v6 = libmin_mgetc(mwords);\n      if ( v6 == -1 || v6 == 10 )\n        break;\n      v5 -= ((pctype[v6] & 3) == 0) - 1;\n      *v4++ = v6;\n    }\n    *v4 = 0;\n    ++v3;\n    v2[1] = v5;\n    *v2 = (_BYTE)v4 + 1 - (_BYTE)v2;\n  }\n  libmin_mclose(mwords);\n  *v2 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", v3);\n  if ( v3 > 0x658F )\n  {\n    libmin_printf(\"Dictionary too large; increase MAXWORDS\\n\", 0LL);\n    libmin_fail(1);\n  }\n  libmin_printf(\"%lu bytes wasted\\n\", v1 - (v2 + 1 - pchDictionary));\n}\n"}, "pseudo_normalize": "void ReadDict(char *pchFile) {\n  unsigned int v1;\n  char *v2;\n  unsigned int v3;\n  uint8_t *v4;\n  char v5;\n  int v6;\n  v1 = libmin_msize(mwords) + 52000;\n  pchDictionary = (char *)libmin_malloc(v1);\n  v2 = pchDictionary;\n  if (!pchDictionary) {\n    libmin_printf(\"Unable to allocate memory for dictionary\\n\", 0LL);\n    libmin_fail(1);\n  }\n  v3 = 0;\n  libmin_mopen(mwords, \"r\");\n  for (; !libmin_meof(mwords); v2 = v4 + 1) {\n    v4 = v2 + 2;\n    v5 = 0;\n    while (1) {\n      v6 = libmin_mgetc(mwords);\n      if (v6 == -1 || v6 == 10) break;\n      v5 -= ((pctype[v6] & 3) == 0) - 1;\n      *v4++ = v6;\n    }\n    *v4 = 0;\n    ++v3;\n    v2[1] = v5;\n    *v2 = (uint8_t)v4 + 1 - (uint8_t)v2;\n  }\n  libmin_mclose(mwords);\n  *v2 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", v3);\n  if (v3 > 25999) {\n    libmin_printf(\"Dictionary too large; increase MAXWORDS\\n\", 0LL);\n    libmin_fail(1);\n  }\n  libmin_printf(\"%lu bytes wasted\\n\", v1 - (v2 + 1 - pchDictionary));\n}", "binary": "anagram/anagram.host.O3", "assembly": "<ReadDict>:\nendbr64\npush   %r14\nmov    0x37b93(%rip),%rdi\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ncall   2990 <libmin_msize>\nlea    0xcb20(%rax),%r13\nmov    %r13,%rdi\ncall   22b0 <libmin_malloc>\nmov    %rax,0x380ca(%rip)\nmov    %rax,%rbp\ntest   %rax,%rax\nje     15fe <ReadDict+0x13e>\nmov    0x37b5f(%rip),%rdi\nlea    0x3ba3(%rip),%rsi\nxor    %r12d,%r12d\ncall   2940 <libmin_mopen>\nmov    0x37b49(%rip),%rdi\ncall   2710 <libmin_meof>\ntest   %eax,%eax\njne    1591 <ReadDict+0xd1>\nlea    0x2(%rbp),%r14\nxor    %ebx,%ebx\njmp    1555 <ReadDict+0x95>\nnopl   0x0(%rax,%rax,1)\ncmp    $0xa,%eax\nje     1566 <ReadDict+0xa6>\nmov    0x37d6c(%rip),%rdx\nmovslq %eax,%rcx\nmovzwl (%rdx,%rcx,2),%edx\nand    $0x3,%edx\ncmp    $0x1,%dx\nsbb    $0xffffffff,%ebx\nadd    $0x1,%r14\nmov    %al,-0x1(%r14)\nmov    0x37b04(%rip),%rdi\ncall   2730 <libmin_mgetc>\ncmp    $0xffffffff,%eax\njne    1530 <ReadDict+0x70>\nlea    0x1(%r14),%rax\nmovb   $0x0,(%r14)\nadd    $0x1,%r12d\nmov    %rax,%rdx\nmov    %bl,0x1(%rbp)\nsub    %rbp,%rdx\nmov    %dl,0x0(%rbp)\nmov    0x37adb(%rip),%rdi\nmov    %rax,%rbp\ncall   2710 <libmin_meof>\ntest   %eax,%eax\nje     1520 <ReadDict+0x60>\nmov    0x37ac8(%rip),%rdi\nlea    0x1(%rbp),%rbx\ncall   2550 <libmin_mclose>\nmovb   $0x0,0x0(%rbp)\nxor    %eax,%eax\nmov    %r12d,%esi\nlea    0x3a87(%rip),%rdi\ncall   4890 <libmin_printf>\ncmp    $0x658f,%r12d\nja     15e2 <ReadDict+0x122>\nsub    0x37ff2(%rip),%rbx\nmov    %r13,%rsi\nlea    0x3add(%rip),%rdi\nxor    %eax,%eax\nsub    %rbx,%rsi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\njmp    4890 <libmin_printf>\nxor    %esi,%esi\nlea    0x3a6d(%rip),%rdi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\nmov    $0x1,%edi\ncall   2290 <libmin_fail>\njmp    15bf <ReadDict+0xff>\nxor    %esi,%esi\nlea    0x3a01(%rip),%rdi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\nmov    $0x1,%edi\ncall   2290 <libmin_fail>\njmp    14fa <ReadDict+0x3a>\nnopl   (%rax)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "SortCandidates", "content": "void SortCandidates(void) {\n    int i;\n\n    /* Sort the letters by frequency */\n    for (i = 0; i < ALPHABET; i++) achByFrequency[i] = i;\n    libmin_qsort(achByFrequency, ALPHABET, sizeof(char),\n          (int (*)(const void *, const void *))CompareFrequency);\n\n    libmin_printf(\"Order of search will be \");\n    for (i = 0; i < ALPHABET; i++)\n\t    libmin_putc(i2ch(achByFrequency[i]));\n    libmin_putc('\\n');\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "SortCandidates", "address": "0x1f10", "label": "SortCandidates", "content": "void __cdecl SortCandidates()\n{\n  char *v0; // rbx\n  char v1; // al\n\n  v0 = achByFrequency;\n  *(_QWORD *)&achByFrequency[16] = 0x1716151413121110LL;\n  *(_WORD *)&achByFrequency[24] = 6424;\n  *(__m128i *)achByFrequency = _mm_load_si128((const __m128i *)&xmmword_362D0);\n  libmin_qsort(achByFrequency, 0x1AuLL, 1uLL, (int (*)(const void *, const void *))CompareFrequency);\n  libmin_printf(\"Order of search will be \");\n  do\n  {\n    v1 = *v0++;\n    libmin_putc(v1 + 97);\n  }\n  while ( &achByFrequency[26] != v0 );\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "void SortCandidates() {\n  char *v0;\n  char v1;\n  v0 = achByFrequency;\n  *(uint64_t *)&achByFrequency[16] = 1663540288323457296LL;\n  *(unsigned short *)&achByFrequency[24] = 6424;\n  *(__m128i *)achByFrequency = _mm_load_si128((const __m128i *)&xmmword_362D0);\n  libmin_qsort(achByFrequency, 26uLL, 1uLL,\n               (int (*)(const void *, const void *))CompareFrequency);\n  libmin_printf(\"Order of search will be \");\n  do {\n    v1 = *v0++;\n    libmin_putc(v1 + 97);\n  } while (&achByFrequency[26] != v0);\n  libmin_putc(10);\n}", "binary": "anagram/anagram.host.O3", "assembly": "<SortCandidates>:\nendbr64\npush   %rbp\nmov    $0x1,%edx\nmov    $0x1a,%esi\nlea    -0xab6(%rip),%rcx\npush   %rbx\nlea    0x37692(%rip),%rbx\nmov    %rbx,%rdi\nlea    0x1a(%rbx),%rbp\nsub    $0x8,%rsp\nmov    0x343a0(%rip),%rax\nmovdqa 0x34388(%rip),%xmm0\nmov    %rax,0x37681(%rip)\nmov    $0x1918,%eax\nmov    %ax,0x3767d(%rip)\nmovaps %xmm0,0x3765e(%rip)\ncall   4cf0 <libmin_qsort>\nlea    0x319c(%rip),%rdi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\nnopl   (%rax)\nmovzbl (%rbx),%eax\nadd    $0x1,%rbx\nlea    0x61(%rax),%edi\nmovsbl %dil,%edi\ncall   4aa0 <libmin_putc>\ncmp    %rbx,%rbp\njne    1f78 <SortCandidates+0x68>\nadd    $0x8,%rsp\nmov    $0xa,%edi\npop    %rbx\npop    %rbp\njmp    4aa0 <libmin_putc>\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "main", "content": "int \nmain(int cpchArgc, char **ppchArgv)\n{\n    ReadDict(ppchArgv[1]);\n\n    while (GetPhrase(&achPhrase[0]) != NULL) {\n        if (isdigit(achPhrase[0])) {\n            cchMinLength = libmin_atoi(achPhrase);\n            libmin_printf(\"New length: %d\\n\", cchMinLength);\n        } else if (achPhrase[0] == '?') {\n            DumpCandidates();\n        } else {\n            BuildMask(&achPhrase[0]);\n            AddWords();\n            if (cpwCand == 0 || cchPhraseLength == 0) continue;\n\n            Stat(ulHighCount = ulLowCount = 0;)\n            cpwLast = 0;\n            SortCandidates();\n            FindAnagram(&aqMainMask[0], &apwCand[0], 0);\n            Stat(libmin_printf(\"%lu:%lu probes\\n\", ulHighCount, ulLowCount);)\n        }\n    }\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char *v3; // r13\n  __int64 i; // rax\n  int v5; // ecx\n  char *v6; // r14\n  char v7; // al\n  const char *v8; // rsi\n  __int64 v9; // r13\n  __int64 v10; // rdx\n\n  ReadDict((char *)argv[1]);\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        if ( !libmin_mgets(achPhrase, 0xFFuLL, minput) )\n          libmin_success();\n        if ( (pctype[achPhrase[0]] & 4) == 0 )\n          break;\n        cchMinLength = libmin_atoi(achPhrase);\n        libmin_printf(\"New length: %d\\n\", cchMinLength);\n      }\n      if ( achPhrase[0] != 63 )\n        break;\n      v8 = (const char *)cpwCand;\n      v9 = 1LL;\n      v10 = 32LL;\n      if ( cpwCand )\n      {\n        while ( 1 )\n        {\n          v8 = *(const char **)(qword_39838[v9] + 16LL);\n          libmin_printf(\"%15s%c\", v8, v10);\n          if ( cpwCand <= (unsigned int)v9 )\n            break;\n          v10 = 10LL;\n          if ( (v9 & 3) != 3 )\n            v10 = 32LL;\n          ++v9;\n        }\n      }\n      libmin_printf((char *)\"\\n\", v8, v10);\n    }\n    BuildMask(achPhrase);\n    v3 = pchDictionary;\n    cpwCand = 0;\n    for ( i = *pchDictionary; (_BYTE)i; i = *v3 )\n    {\n      while ( 1 )\n      {\n        v5 = v3[1];\n        if ( (v5 < cchMinLength || v5 + cchMinLength > cchPhraseLength) && v5 != cchPhraseLength )\n          break;\n        BuildWord(v3 + 2);\n        v3 += *v3;\n        i = *v3;\n        if ( !(_BYTE)i )\n          goto LABEL_12;\n      }\n      v3 += i;\n    }\nLABEL_12:\n    libmin_printf(\"%d candidates\\n\", cpwCand);\n    if ( cpwCand && cchPhraseLength )\n    {\n      v6 = achByFrequency;\n      cpwLast = 0;\n      *(_QWORD *)&achByFrequency[16] = 0x1716151413121110LL;\n      *(_WORD *)&achByFrequency[24] = 6424;\n      *(__m128i *)achByFrequency = _mm_load_si128((const __m128i *)&xmmword_362D0);\n      libmin_qsort(achByFrequency, 0x1AuLL, 1uLL, (int (*)(const void *, const void *))CompareFrequency);\n      libmin_printf(\"Order of search will be \");\n      do\n      {\n        v7 = *v6++;\n        libmin_putc(v7 + 97);\n      }\n      while ( &achByFrequency[26] != v6 );\n      libmin_putc(10);\n      FindAnagram(aqMainMask, apwCand, 0);\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  char *v3;\n  long long i;\n  int v5;\n  char *v6;\n  char v7;\n  const char *v8;\n  long long v9;\n  long long v10;\n  ReadDict((char *)argv[1]);\n  while (1) {\n    while (1) {\n      while (1) {\n        if (!libmin_mgets(achPhrase, 255uLL, minput)) libmin_success();\n        if ((pctype[achPhrase[0]] & 4) == 0) break;\n        cchMinLength = libmin_atoi(achPhrase);\n        libmin_printf(\"New length: %d\\n\", cchMinLength);\n      }\n      if (achPhrase[0] != 63) break;\n      v8 = (const char *)cpwCand;\n      v9 = 1LL;\n      v10 = 32LL;\n      if (cpwCand) {\n        while (1) {\n          v8 = *(const char **)(qword_39838[v9] + 16LL);\n          libmin_printf(\"%15s%c\", v8, v10);\n          if (cpwCand <= (unsigned int)v9) break;\n          v10 = 10LL;\n          if ((v9 & 3) != 3) v10 = 32LL;\n          ++v9;\n        }\n      }\n      libmin_printf((char *)\"\\n\", v8, v10);\n    }\n    BuildMask(achPhrase);\n    v3 = pchDictionary;\n    cpwCand = 0;\n    for (i = *pchDictionary; (uint8_t)i; i = *v3) {\n      while (1) {\n        v5 = v3[1];\n        if ((v5 < cchMinLength || v5 + cchMinLength > cchPhraseLength) &&\n            v5 != cchPhraseLength)\n          break;\n        BuildWord(v3 + 2);\n        v3 += *v3;\n        i = *v3;\n        if (!(uint8_t)i) goto LABEL_12;\n      }\n      v3 += i;\n    }\n  LABEL_12:\n    libmin_printf(\"%d candidates\\n\", cpwCand);\n    if (cpwCand && cchPhraseLength) {\n      v6 = achByFrequency;\n      cpwLast = 0;\n      *(uint64_t *)&achByFrequency[16] = 1663540288323457296LL;\n      *(unsigned short *)&achByFrequency[24] = 6424;\n      *(__m128i *)achByFrequency =\n          _mm_load_si128((const __m128i *)&xmmword_362D0);\n      libmin_qsort(achByFrequency, 26uLL, 1uLL,\n                   (int (*)(const void *, const void *))CompareFrequency);\n      libmin_printf(\"Order of search will be \");\n      do {\n        v7 = *v6++;\n        libmin_putc(v7 + 97);\n      } while (&achByFrequency[26] != v6);\n      libmin_putc(10);\n      FindAnagram(aqMainMask, apwCand, 0);\n    }\n  }\n}", "binary": "anagram/anagram.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nlea    0x3fc1(%rip),%r12\npush   %rbp\nmov    $0x20,%ebp\npush   %rbx\nlea    0x381bf(%rip),%rbx\nsub    $0x8,%rsp\nmov    0x8(%rsi),%rdi\ncall   14c0 <ReadDict>\nxchg   %ax,%ax\nmov    0x37ec9(%rip),%rdx\nmov    $0xff,%esi\nmov    %rbx,%rdi\ncall   2760 <libmin_mgets>\ntest   %rax,%rax\nje     1368 <main+0x248>\nmovsbq (%rbx),%rcx\nmov    0x38130(%rip),%rdx\ntestb  $0x4,(%rdx,%rcx,2)\njne    12d0 <main+0x1b0>\ncmp    $0x3f,%cl\nje     12f8 <main+0x1d8>\nmov    %rbx,%rdi\ncall   1620 <BuildMask>\nmov    0x3841e(%rip),%r13\nmovl   $0x0,0x3867c(%rip)\nmovsbq 0x0(%r13),%rax\ntest   %al,%al\njne    11d0 <main+0xb0>\njmp    11f5 <main+0xd5>\nnop\nadd    %ecx,%edx\ncmp    %esi,%edx\njg     11e5 <main+0xc5>\nlea    0x2(%r13),%rdi\ncall   1940 <BuildWord>\nmovsbq 0x0(%r13),%rax\nadd    %rax,%r13\nmovsbq 0x0(%r13),%rax\ntest   %al,%al\nje     11f5 <main+0xd5>\nmovsbl 0x1(%r13),%ecx\nmov    0x37e35(%rip),%edx\nmov    0x3848f(%rip),%esi\ncmp    %edx,%ecx\njge    11b0 <main+0x90>\ncmp    %esi,%ecx\nje     11b6 <main+0x96>\nadd    %rax,%r13\nmovsbq 0x0(%r13),%rax\ntest   %al,%al\njne    11d0 <main+0xb0>\nmov    0x38625(%rip),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\nmov    0x38615(%rip),%ecx\ntest   %ecx,%ecx\nje     1150 <main+0x30>\nmov    0x38457(%rip),%edx\ntest   %edx,%edx\nje     1150 <main+0x30>\nmov    0x350b8(%rip),%rax\nmovdqa 0x350a0(%rip),%xmm0\nlea    0x38389(%rip),%r14\nlea    0x232(%rip),%rcx\nmov    $0x1,%edx\nmov    $0x1a,%esi\nmov    %r14,%rdi\nmovl   $0x0,0x381ab(%rip)\nmov    %rax,0x38374(%rip)\nmov    $0x1918,%eax\nlea    0x1a(%r14),%r13\nmov    %ax,0x3836c(%rip)\nmovaps %xmm0,0x3834d(%rip)\ncall   4cf0 <libmin_qsort>\nlea    0x3e8b(%rip),%rdi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\ncs nopw 0x0(%rax,%rax,1)\nmovzbl (%r14),%eax\nadd    $0x1,%r14\nlea    0x61(%rax),%edi\nmovsbl %dil,%edi\ncall   4aa0 <libmin_putc>\ncmp    %r14,%r13\njne    1290 <main+0x170>\nmov    $0xa,%edi\ncall   4aa0 <libmin_putc>\nxor    %edx,%edx\nlea    0x38584(%rip),%rsi\nlea    0x3839d(%rip),%rdi\ncall   1d00 <FindAnagram>\njmp    1150 <main+0x30>\nnopl   (%rax)\nmov    %rbx,%rdi\ncall   21b0 <libmin_atoi>\nlea    0x3e44(%rip),%rdi\nmov    %eax,%esi\nmov    %eax,0x37d29(%rip)\nxor    %eax,%eax\ncall   4890 <libmin_printf>\njmp    1150 <main+0x30>\nnopl   0x0(%rax,%rax,1)\nmov    0x38522(%rip),%esi\nmov    $0x1,%r13d\nmov    $0x20,%edx\nlea    0x38528(%rip),%r15\nlea    0x3dec(%rip),%r14\ntest   %esi,%esi\njne    1335 <main+0x215>\njmp    1350 <main+0x230>\nnopl   (%rax)\nmov    %r13d,%eax\nmov    $0xa,%edx\nand    $0x3,%eax\ncmp    $0x3,%eax\ncmovne %ebp,%edx\nadd    $0x1,%r13\nmov    (%r15,%r13,8),%rax\nmov    %r14,%rdi\nmov    0x10(%rax),%rsi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\ncmp    %r13d,0x384d2(%rip)\nja     1320 <main+0x200>\nlea    0x3dda(%rip),%rdi\nxor    %eax,%eax\ncall   4890 <libmin_printf>\njmp    1150 <main+0x30>\nnopl   0x0(%rax,%rax,1)\ncall   4e00 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "wprint", "content": "/* wprint -- print a word, followed by a space\n *\n * We would normally just use printf, but the string being printed is\n * is a huge pointer (on an IBM PC), so special care must be taken.\n */\nvoid wprint(char * pch) {\n    libmin_printf(\"%s \", pch);\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O3.pseudo", "function_name": "wprint", "address": "0x1860", "label": "wprint", "content": "void __fastcall wprint(char *pch)\n{\n  libmin_printf(\"%s \", pch);\n}\n"}, "pseudo_normalize": "", "binary": "anagram/anagram.host.O3", "assembly": "<wprint>:\nendbr64\nmov    %rdi,%rsi\nxor    %eax,%eax\nlea    0x386b(%rip),%rdi\njmp    4890 <libmin_printf>\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "audio-codec/audio-codec.c", "function_name": "decode", "content": "/**\n * @brief 8bit alaw to 16bit pcm\n * @param out signed 16bit pcm array\n * @param in  unsigned 8bit alaw array\n * @param len length of alaw array\n * @returns void\n */\nvoid decode(int16_t *out, uint8_t *in, size_t len)\n{\n    uint8_t alaw = 0;\n    int32_t pcm = 0;\n    int32_t sign = 0;\n    int32_t eee = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        alaw = *in++;\n\n        /* Re-toggle toggled bits */\n        alaw ^= 0xD5;\n\n        /* Get sign bit */\n        sign = alaw & 0x80;\n\n        /* Get eee bits */\n        eee = (alaw & 0x70) >> 4;\n\n        /* Get abcd bits and add 1/2 quantization step */\n        pcm = (alaw & 0x0f) << 4 | 8;\n\n        /* If quantization level > 0, there need `1` bit before abcd bits */\n        pcm += eee ? 0x100 : 0x0;\n\n        /* Left shift according quantization level */\n        pcm <<= eee > 1 ? (eee - 1) : 0;\n\n        /* Use the right sign */\n        *out++ = sign ? -pcm : pcm;\n    }\n}\n"}, "pseudo": {"path": "audio-codec/audio-codec.host.O3.pseudo", "function_name": "decode", "address": "0x1590", "label": "decode", "content": "void __fastcall decode(int16_t *out, uint8_t *in, size_t len)\n{\n  __int64 v4; // rdx\n  int v5; // ecx\n  unsigned __int8 v6; // al\n  int v7; // ecx\n  int v8; // eax\n  int v9; // eax\n\n  if ( len )\n  {\n    v4 = 0LL;\n    do\n    {\n      while ( 1 )\n      {\n        v5 = in[v4] ^ 0xD5;\n        v6 = 16 * v5;\n        v7 = (v5 >> 4) & 7;\n        v8 = ((v7 != 0) << 8) + (v6 | 8);\n        if ( v7 <= 0 )\n          LOBYTE(v7) = 1;\n        v9 = v8 << (v7 - 1);\n        if ( (in[v4] & 0x80u) == 0 )\n          break;\n        out[v4++] = v9;\n        if ( len == v4 )\n          return;\n      }\n      out[v4++] = -(__int16)v9;\n    }\n    while ( v4 != len );\n  }\n}\n"}, "pseudo_normalize": "void decode(int16_t *out, uint8_t *in, unsigned int len) {\n  long long v4;\n  int v5;\n  unsigned char v6;\n  int v7;\n  int v8;\n  int v9;\n  if (len) {\n    v4 = 0LL;\n    do {\n      while (1) {\n        v5 = in[v4] ^ 213;\n        v6 = 16 * v5;\n        v7 = (v5 >> 4) & 7;\n        v8 = ((v7 != 0) << 8) + (v6 | 8);\n        if (v7 <= 0) LOBYTE(v7) = 1;\n        v9 = v8 << (v7 - 1);\n        if ((in[v4] & 128u) == 0) break;\n        out[v4++] = v9;\n        if (len == v4) return;\n      }\n      out[v4++] = -(short)v9;\n    } while (v4 != len);\n  }\n}", "binary": "audio-codec/audio-codec.host.O3", "assembly": "<decode>:\nendbr64\nmov    %rsi,%r8\nmov    %rdx,%r9\ntest   %rdx,%rdx\nje     15f6 <decode+0x66>\nxor    %edx,%edx\nnopl   0x0(%rax)\nmovzbl (%r8,%rdx,1),%esi\nxor    %r10d,%r10d\nxor    $0xffffffd5,%esi\nmovzbl %sil,%eax\nmov    %eax,%ecx\nshl    $0x4,%eax\nsar    $0x4,%ecx\nmovzbl %al,%eax\nor     $0x8,%eax\nand    $0x7,%ecx\nsetne  %r10b\nshl    $0x8,%r10d\nadd    %r10d,%eax\ntest   %ecx,%ecx\nmov    $0x1,%r10d\ncmovle %r10d,%ecx\nsub    $0x1,%ecx\nshl    %cl,%eax\ntest   %sil,%sil\njs     1600 <decode+0x70>\nmov    %ax,(%rdi,%rdx,2)\nadd    $0x1,%rdx\ncmp    %rdx,%r9\njne    15a8 <decode+0x18>\nret\nnopw   0x0(%rax,%rax,1)\nneg    %eax\nmov    %ax,(%rdi,%rdx,2)\nadd    $0x1,%rdx\ncmp    %r9,%rdx\njne    15a8 <decode+0x18>\nret\n"}
{"source": {"path": "audio-codec/audio-codec.c", "function_name": "encode", "content": "/**\n * @brief 16bit pcm to 8bit alaw\n * @param out unsigned 8bit alaw array\n * @param in  signed 16bit pcm array\n * @param len length of pcm array\n * @returns void\n */\nvoid encode(uint8_t *out, int16_t *in, size_t len)\n{\n    uint8_t alaw = 0;\n    int16_t pcm = 0;\n    int32_t sign = 0;\n    int32_t abcd = 0;\n    int32_t eee = 0;\n    int32_t mask = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        pcm = *in++;\n        /* 0-7 kinds of quantization level from the table above */\n        eee = 7;\n        mask = 0x4000; /* 0x4000: '0b0100 0000 0000 0000' */\n\n        /* Get sign bit */\n        sign = (pcm & 0x8000) >> 8;\n\n        /* Turn negative pcm to positive */\n        /* The absolute value of a negative number may be larger than the size\n         * of the corresponding positive number, so here needs `-pcm -1` after\n         * taking the opposite number. */\n        pcm = sign ? (-pcm - 1) : pcm;\n\n        /* Get eee and abcd bit */\n        /* Use mask to locate the first `1` bit and quantization level at the\n         * same time */\n        while ((pcm & mask) == 0 && eee > 0)\n        {\n            eee--;\n            mask >>= 1;\n        }\n\n        /* The location of abcd bits is related with quantization level. Check\n         * the table above to determine how many bits to `>>` to get abcd */\n        abcd = (pcm >> (eee ? (eee + 3) : 4)) & 0x0f;\n\n        /* Put the quantization level number at right bit location to get eee\n         * bits */\n        eee <<= 4;\n\n        /* Splice results */\n        alaw = (sign | eee | abcd);\n\n        /* The standard specifies that all resulting even bits (LSB\n         * is even) are inverted before the octet is transmitted. This is to\n         * provide plenty of 0/1 transitions to facilitate the clock recovery\n         * process in the PCM receivers. Thus, a silent A-law encoded PCM\n         * channel has the 8 bit samples coded 0xD5 instead of 0x80 in the\n         * octets. (Reference from wiki above) */\n        *out++ = alaw ^ 0xD5;\n    }\n}\n"}, "pseudo": {"path": "audio-codec/audio-codec.host.O3.pseudo", "function_name": "encode", "address": "0x14c0", "label": "encode", "content": "void __fastcall encode(uint8_t *out, int16_t *in, size_t len)\n{\n  __int64 v5; // rsi\n  int v6; // edx\n  int16_t v7; // ax\n  int v8; // r10d\n  char v9; // cl\n  char v10; // al\n\n  v5 = 0LL;\n  if ( len )\n  {\n    do\n    {\n      v6 = in[v5];\n      v7 = in[v5];\n      v8 = (v6 >> 8) & 0x80;\n      if ( v8 )\n      {\n        v7 = ~v7;\n        v6 = v7;\n      }\n      if ( (v7 & 0x4000) != 0 )\n      {\n        v10 = 112;\n        v9 = 10;\n      }\n      else if ( (v7 & 0x2000) != 0 )\n      {\n        v10 = 96;\n        v9 = 9;\n      }\n      else if ( (v7 & 0x1000) != 0 )\n      {\n        v10 = 80;\n        v9 = 8;\n      }\n      else if ( (v7 & 0x800) != 0 )\n      {\n        v10 = 64;\n        v9 = 7;\n      }\n      else if ( (v7 & 0x400) != 0 )\n      {\n        v10 = 48;\n        v9 = 6;\n      }\n      else if ( (v7 & 0x200) != 0 )\n      {\n        v10 = 32;\n        v9 = 5;\n      }\n      else\n      {\n        v9 = 4;\n        v10 = (v7 & 0x100) != 0 ? 0x10 : 0;\n      }\n      out[v5++] = ((v6 >> v9) & 0xF | v8 | v10) ^ 0xD5;\n    }\n    while ( len != v5 );\n  }\n}\n"}, "pseudo_normalize": "void encode(uint8_t *out, int16_t *in, unsigned int len) {\n  long long v5;\n  int v6;\n  int16_t v7;\n  int v8;\n  char v9;\n  char v10;\n  v5 = 0LL;\n  if (len) {\n    do {\n      v6 = in[v5];\n      v7 = in[v5];\n      v8 = (v6 >> 8) & 128;\n      if (v8) {\n        v7 = ~v7;\n        v6 = v7;\n      }\n      if ((v7 & 16384) != 0) {\n        v10 = 112;\n        v9 = 10;\n      } else if ((v7 & 8192) != 0) {\n        v10 = 96;\n        v9 = 9;\n      } else if ((v7 & 4096) != 0) {\n        v10 = 80;\n        v9 = 8;\n      } else if ((v7 & 2048) != 0) {\n        v10 = 64;\n        v9 = 7;\n      } else if ((v7 & 1024) != 0) {\n        v10 = 48;\n        v9 = 6;\n      } else if ((v7 & 512) != 0) {\n        v10 = 32;\n        v9 = 5;\n      } else {\n        v9 = 4;\n        v10 = (v7 & 256) != 0 ? 16 : 0;\n      }\n      out[v5++] = ((v6 >> v9) & 15 | v8 | v10) ^ 213;\n    } while (len != v5);\n  }\n}", "binary": "audio-codec/audio-codec.host.O3", "assembly": "<encode>:\nendbr64\nmov    %rsi,%r8\nmov    %rdx,%r9\nxor    %esi,%esi\ntest   %rdx,%rdx\nje     153c <encode+0x7c>\nnopl   0x0(%rax)\nmovswl (%r8,%rsi,2),%edx\nmov    %edx,%ecx\nmov    %edx,%eax\nsar    $0x8,%ecx\nand    $0x80,%ecx\nmov    %ecx,%r10d\nje     14f4 <encode+0x34>\nnot    %eax\nmovswl %ax,%edx\ntest   $0x40,%ah\njne    153d <encode+0x7d>\ntest   $0x20,%ah\njne    1549 <encode+0x89>\ntest   $0x10,%ah\njne    1555 <encode+0x95>\ntest   $0x8,%ah\njne    1561 <encode+0xa1>\ntest   $0x4,%ah\njne    156d <encode+0xad>\ntest   $0x2,%ah\njne    1579 <encode+0xb9>\nand    $0x100,%ax\nmov    $0x4,%ecx\nneg    %ax\nsbb    %al,%al\nand    $0x10,%eax\nsar    %cl,%edx\nor     %r10d,%eax\nand    $0xf,%edx\nor     %edx,%eax\nxor    $0xffffffd5,%eax\nmov    %al,(%rdi,%rsi,1)\nadd    $0x1,%rsi\ncmp    %rsi,%r9\njne    14d8 <encode+0x18>\nret\nmov    $0x70,%eax\nmov    $0xa,%ecx\njmp    1523 <encode+0x63>\nmov    $0x60,%eax\nmov    $0x9,%ecx\njmp    1523 <encode+0x63>\nmov    $0x50,%eax\nmov    $0x8,%ecx\njmp    1523 <encode+0x63>\nmov    $0x40,%eax\nmov    $0x7,%ecx\njmp    1523 <encode+0x63>\nmov    $0x30,%eax\nmov    $0x6,%ecx\njmp    1523 <encode+0x63>\nmov    $0x20,%eax\nmov    $0x5,%ecx\njmp    1523 <encode+0x63>\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "audio-codec/audio-codec.c", "function_name": "main", "content": "/**\n * @brief Main function\n * @param argc commandline argument count (ignored)\n * @param argv commandline array of arguments (ignored)\n * @returns 0 on exit\n */\nint main(int argc, char *argv[])\n{\n    /* output alaw encoded by encode() */\n    uint8_t coded[LEN];\n\n    /* output pcm decoded by decode() from coded[LEN] */\n    int16_t decoded[LEN];\n\n    test(pcm, coded, decoded, LEN);  // run self-test implementations\n\n    /* print test pcm inputs */\n    libmin_printf(\"inputs: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%d \", pcm[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* print encoded alaw */\n    libmin_printf(\"encode: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%u \", coded[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* print decoded pcm */\n    libmin_printf(\"decode: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%d \", decoded[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* It can be seen that the encoded alaw is smaller than the input PCM, so\n     * the purpose of compression is achieved. And the decoded PCM is almost the\n     * same as the original input PCM, which verifies the correctness of the\n     * decoding. The reason why it is not exactly the same is that there is\n     * precision loss during encode / decode.  */\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "audio-codec/audio-codec.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int16_t *v3; // r13\n  int v4; // esi\n  uint8_t *v5; // rbx\n  int v6; // esi\n  uint8_t *v7; // rbx\n  int v8; // esi\n  int16_t decoded[8]; // [rsp+10h] [rbp-58h] BYREF\n  uint8_t coded[8]; // [rsp+20h] [rbp-48h] BYREF\n  unsigned __int64 v11; // [rsp+28h] [rbp-40h] BYREF\n\n  v11 = __readfsqword(0x28u);\n  encode(coded, pcm, 8uLL);\n  if ( coded[0] != r_coded[0] )\n    libmin_fail(1);\n  if ( coded[1] != r_coded[1] )\n    libmin_fail(1);\n  if ( coded[2] != r_coded[2] )\n    libmin_fail(1);\n  if ( coded[3] != r_coded[3] )\n    libmin_fail(1);\n  if ( coded[4] != r_coded[4] )\n    libmin_fail(1);\n  if ( coded[5] != r_coded[5] )\n    libmin_fail(1);\n  if ( coded[6] != r_coded[6] )\n    libmin_fail(1);\n  if ( coded[7] != r_coded[7] )\n    libmin_fail(1);\n  decode(decoded, coded, 8uLL);\n  if ( r_decoded[0] != decoded[0] )\n    libmin_fail(1);\n  if ( decoded[1] != r_decoded[1] )\n    libmin_fail(1);\n  if ( decoded[2] != r_decoded[2] )\n    libmin_fail(1);\n  if ( decoded[3] != r_decoded[3] )\n    libmin_fail(1);\n  if ( decoded[4] != r_decoded[4] )\n    libmin_fail(1);\n  if ( decoded[5] != r_decoded[5] )\n    libmin_fail(1);\n  if ( decoded[6] != r_decoded[6] )\n    libmin_fail(1);\n  if ( decoded[7] != r_decoded[7] )\n    libmin_fail(1);\n  v3 = pcm;\n  libmin_printf(\"inputs: \");\n  do\n  {\n    v4 = *v3++;\n    libmin_printf(\"%d \", v4);\n  }\n  while ( v3 != &pcm[8] );\n  v5 = coded;\n  libmin_printf(\"\\n\");\n  libmin_printf(\"encode: \");\n  do\n  {\n    v6 = *v5++;\n    libmin_printf(\"%u \", v6);\n  }\n  while ( v5 != (uint8_t *)&v11 );\n  libmin_printf(\"\\n\");\n  libmin_printf(\"decode: \");\n  v7 = (uint8_t *)decoded;\n  do\n  {\n    v8 = *(__int16 *)v7;\n    v7 += 2;\n    libmin_printf(\"%d \", v8);\n  }\n  while ( v7 != coded );\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int16_t *v3;\n  int v4;\n  uint8_t *v5;\n  int v6;\n  uint8_t *v7;\n  int v8;\n  int16_t decoded[8];\n  uint8_t coded[8];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  encode(coded, pcm, 8uLL);\n  if (coded[0] != r_coded[0]) libmin_fail(1);\n  if (coded[1] != r_coded[1]) libmin_fail(1);\n  if (coded[2] != r_coded[2]) libmin_fail(1);\n  if (coded[3] != r_coded[3]) libmin_fail(1);\n  if (coded[4] != r_coded[4]) libmin_fail(1);\n  if (coded[5] != r_coded[5]) libmin_fail(1);\n  if (coded[6] != r_coded[6]) libmin_fail(1);\n  if (coded[7] != r_coded[7]) libmin_fail(1);\n  decode(decoded, coded, 8uLL);\n  if (r_decoded[0] != decoded[0]) libmin_fail(1);\n  if (decoded[1] != r_decoded[1]) libmin_fail(1);\n  if (decoded[2] != r_decoded[2]) libmin_fail(1);\n  if (decoded[3] != r_decoded[3]) libmin_fail(1);\n  if (decoded[4] != r_decoded[4]) libmin_fail(1);\n  if (decoded[5] != r_decoded[5]) libmin_fail(1);\n  if (decoded[6] != r_decoded[6]) libmin_fail(1);\n  if (decoded[7] != r_decoded[7]) libmin_fail(1);\n  v3 = pcm;\n  libmin_printf(\"inputs: \");\n  do {\n    v4 = *v3++;\n    libmin_printf(\"%d \", v4);\n  } while (v3 != &pcm[8]);\n  v5 = coded;\n  libmin_printf(\"\\n\");\n  libmin_printf(\"encode: \");\n  do {\n    v6 = *v5++;\n    libmin_printf(\"%u \", v6);\n  } while (v5 != (uint8_t *)&v11);\n  libmin_printf(\"\\n\");\n  libmin_printf(\"decode: \");\n  v7 = (uint8_t *)decoded;\n  do {\n    v8 = *(short *)v7;\n    v7 += 2;\n    libmin_printf(\"%d \", v8);\n  } while (v7 != coded);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}", "binary": "audio-codec/audio-codec.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x8,%edx\nlea    0x4f1e(%rip),%rsi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nlea    0x20(%rsp),%r12\nmov    %r12,%rdi\ncall   14c0 <encode>\nmovzbl 0x4ede(%rip),%eax\ncmp    %al,0x20(%rsp)\nje     1152 <main+0x52>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzbl 0x4ec8(%rip),%eax\ncmp    %al,0x21(%rsp)\nje     1169 <main+0x69>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzbl 0x4eb2(%rip),%eax\ncmp    %al,0x22(%rsp)\nje     1180 <main+0x80>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzbl 0x4e9c(%rip),%eax\ncmp    %al,0x23(%rsp)\nje     1197 <main+0x97>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzbl 0x4e86(%rip),%eax\ncmp    %al,0x24(%rsp)\nje     11ae <main+0xae>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzbl 0x4e70(%rip),%eax\ncmp    %al,0x25(%rsp)\nje     11c5 <main+0xc5>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzbl 0x4e5a(%rip),%eax\ncmp    %al,0x26(%rsp)\nje     11dc <main+0xdc>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzbl 0x4e44(%rip),%eax\ncmp    %al,0x27(%rsp)\nje     11f3 <main+0xf3>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nlea    0x10(%rsp),%rdi\nmov    $0x8,%edx\nmov    %r12,%rsi\nmov    %rdi,0x8(%rsp)\ncall   1590 <decode>\nmovzwl 0x10(%rsp),%eax\ncmp    %ax,0x4dfa(%rip)\nje     1222 <main+0x122>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzwl 0x4de9(%rip),%eax\ncmp    %ax,0x12(%rsp)\nje     123a <main+0x13a>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzwl 0x4dd3(%rip),%eax\ncmp    %ax,0x14(%rsp)\nje     1252 <main+0x152>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzwl 0x4dbd(%rip),%eax\ncmp    %ax,0x16(%rsp)\nje     126a <main+0x16a>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzwl 0x4da7(%rip),%eax\ncmp    %ax,0x18(%rsp)\nje     1282 <main+0x182>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzwl 0x4d91(%rip),%eax\ncmp    %ax,0x1a(%rsp)\nje     129a <main+0x19a>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzwl 0x4d7b(%rip),%eax\ncmp    %ax,0x1c(%rsp)\nje     12b2 <main+0x1b2>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nmovzwl 0x4d65(%rip),%eax\ncmp    %ax,0x1e(%rsp)\nje     12ca <main+0x1ca>\nmov    $0x1,%edi\ncall   17f0 <libmin_fail>\nlea    0x2d33(%rip),%rdi\nxor    %eax,%eax\nlea    0x4d56(%rip),%r13\ncall   3700 <libmin_printf>\nlea    0x10(%r13),%r14\nlea    0x2d23(%rip),%rbp\nnopw   0x0(%rax,%rax,1)\nmovswl 0x0(%r13),%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x2,%r13\ncall   3700 <libmin_printf>\ncmp    %r14,%r13\njne    12f0 <main+0x1f0>\nlea    0x2d02(%rip),%r14\nxor    %eax,%eax\nlea    0x28(%rsp),%r15\nmov    %r12,%rbx\nmov    %r14,%rdi\nlea    0x2cf9(%rip),%r13\ncall   3700 <libmin_printf>\nlea    0x2ce4(%rip),%rdi\nxor    %eax,%eax\ncall   3700 <libmin_printf>\ncs nopw 0x0(%rax,%rax,1)\nmovzbl (%rbx),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   3700 <libmin_printf>\ncmp    %r15,%rbx\njne    1340 <main+0x240>\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   3700 <libmin_printf>\nlea    0x2cb9(%rip),%rdi\nxor    %eax,%eax\ncall   3700 <libmin_printf>\nmov    0x8(%rsp),%rbx\nnopl   0x0(%rax,%rax,1)\nmovswl (%rbx),%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x2,%rbx\ncall   3700 <libmin_printf>\ncmp    %r12,%rbx\njne    1378 <main+0x278>\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   3700 <libmin_printf>\ncall   3940 <libmin_success>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    13be <main+0x2be>\nadd    $0x38,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "CheckTreeNodeRotation", "content": "TreeNode *CheckTreeNodeRotation(TreeNode *tnode,\n                                TreeNode *subtree, short *finished)\n{\n    /* this function will check to see if tnode's Balance factor indicates\n        that a rotation is needed. Subtree is the child link that was either\n        just added or possibly changed */\n    switch(tnode->Balance)  {\n        case 0:\n            /* nothing special, but we have balanced out properly, yay */\n            *finished = 1;\n            break;\n        case 2:\n            /* right heavy */\n            *finished = 1;\n            if(subtree->Balance == -1)   {\n                /* update balance factors */\n                if(subtree->Left->Balance == 1)    {\n                    subtree->Balance = 0;\n                    tnode->Balance = -1;\n                } else if(subtree->Left->Balance == -1)    {\n                    subtree->Balance = 1;\n                    tnode->Balance = 0;\n                } else\n                    subtree->Balance = tnode->Balance = 0;\n                subtree->Left->Balance = 0;\n                tnode = DoubleLeftRotation(tnode);\n            } else if(subtree->Balance == 1)   {\n                /* update balance factors */\n                subtree->Balance = tnode->Balance = 0;\n                tnode = SingleLeftRotation(tnode);\n            }\n            break;\n        case -2:\n            /* left heavy */\n            *finished = 1;\n            if(subtree->Balance == 1)  {\n                /* update balance factors */\n                if(subtree->Right->Balance == -1)    {\n                    subtree->Balance = 0;\n                    tnode->Balance = 1;\n                } else if(subtree->Right->Balance == 1)    {\n                    subtree->Balance = -1;\n                    tnode->Balance = 0;\n                } else\n                    subtree->Balance = tnode->Balance = 0;\n                subtree->Right->Balance = 0;\n                tnode = DoubleRightRotation(tnode);\n            } else if(subtree->Balance == -1)   {\n                /* update balance factors */\n                subtree->Balance = tnode->Balance = 0;\n                tnode = SingleRightRotation(tnode);\n            }\n    }\n    return tnode;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "CheckTreeNodeRotation", "address": "0x1c50", "label": "CheckTreeNodeRotation", "content": "TreeNode *__fastcall CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree, __int16 *finished)\n{\n  __int16 Balance; // cx\n  TreeNode *result; // rax\n  __int16 v5; // dx\n  TreeNodeTag *v6; // rdx\n  __int16 v7; // dx\n  TreeNodeTag *v8; // rdx\n  TreeNodeTag *v9; // rcx\n  TreeNodeTag *Left; // rdx\n  __int16 v11; // cx\n  TreeNodeTag *Right; // rcx\n  TreeNode *v13; // rdx\n  TreeNodeTag *v14; // rdx\n  __int16 v15; // cx\n  TreeNodeTag *v16; // rcx\n  TreeNode *v17; // rdx\n\n  Balance = tnode->Balance;\n  result = tnode;\n  if ( Balance )\n  {\n    if ( Balance == 2 )\n    {\n      *finished = 1;\n      v7 = subtree->Balance;\n      if ( v7 == -1 )\n      {\n        Left = subtree->Left;\n        v11 = subtree->Left->Balance;\n        if ( v11 == 1 )\n        {\n          subtree->Balance = 0;\n          tnode->Balance = -1;\n        }\n        else if ( v11 == -1 )\n        {\n          subtree->Balance = 1;\n          tnode->Balance = 0;\n        }\n        else\n        {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        Right = tnode->Right;\n        Left->Balance = 0;\n        v13 = Right->Left;\n        Right->Left = Right->Left->Right;\n        v13->Right = Right;\n        tnode->Right = v13->Left;\n        v13->Left = tnode;\n        return v13;\n      }\n      else if ( v7 == 1 )\n      {\n        v8 = tnode->Right;\n        tnode->Balance = 0;\n        v9 = v8->Left;\n        subtree->Balance = 0;\n        result = v8;\n        tnode->Right = v9;\n        v8->Left = tnode;\n      }\n    }\n    else if ( Balance == -2 )\n    {\n      *finished = 1;\n      v5 = subtree->Balance;\n      if ( v5 == 1 )\n      {\n        v14 = subtree->Right;\n        v15 = v14->Balance;\n        if ( v15 == -1 )\n        {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        }\n        else if ( v15 == 1 )\n        {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        }\n        else\n        {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        v16 = tnode->Left;\n        v14->Balance = 0;\n        v17 = v16->Right;\n        v16->Right = v17->Left;\n        v17->Left = v16;\n        tnode->Left = v17->Right;\n        v17->Right = tnode;\n        return v17;\n      }\n      else if ( v5 == -1 )\n      {\n        tnode->Balance = 0;\n        v6 = tnode->Left;\n        subtree->Balance = 0;\n        tnode->Left = v6->Right;\n        v6->Right = tnode;\n        return v6;\n      }\n    }\n  }\n  else\n  {\n    *finished = 1;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree,\n                                short *finished) {\n  short Balance;\n  TreeNode *result;\n  short v5;\n  TreeNodeTag *v6;\n  short v7;\n  TreeNodeTag *v8;\n  TreeNodeTag *v9;\n  TreeNodeTag *Left;\n  short v11;\n  TreeNodeTag *Right;\n  TreeNode *v13;\n  TreeNodeTag *v14;\n  short v15;\n  TreeNodeTag *v16;\n  TreeNode *v17;\n  Balance = tnode->Balance;\n  result = tnode;\n  if (Balance) {\n    if (Balance == 2) {\n      *finished = 1;\n      v7 = subtree->Balance;\n      if (v7 == -1) {\n        Left = subtree->Left;\n        v11 = subtree->Left->Balance;\n        if (v11 == 1) {\n          subtree->Balance = 0;\n          tnode->Balance = -1;\n        } else if (v11 == -1) {\n          subtree->Balance = 1;\n          tnode->Balance = 0;\n        } else {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        Right = tnode->Right;\n        Left->Balance = 0;\n        v13 = Right->Left;\n        Right->Left = Right->Left->Right;\n        v13->Right = Right;\n        tnode->Right = v13->Left;\n        v13->Left = tnode;\n        return v13;\n      } else if (v7 == 1) {\n        v8 = tnode->Right;\n        tnode->Balance = 0;\n        v9 = v8->Left;\n        subtree->Balance = 0;\n        result = v8;\n        tnode->Right = v9;\n        v8->Left = tnode;\n      }\n    } else if (Balance == -2) {\n      *finished = 1;\n      v5 = subtree->Balance;\n      if (v5 == 1) {\n        v14 = subtree->Right;\n        v15 = v14->Balance;\n        if (v15 == -1) {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        } else if (v15 == 1) {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        } else {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        v16 = tnode->Left;\n        v14->Balance = 0;\n        v17 = v16->Right;\n        v16->Right = v17->Left;\n        v17->Left = v16;\n        tnode->Left = v17->Right;\n        v17->Right = tnode;\n        return v17;\n      } else if (v5 == -1) {\n        tnode->Balance = 0;\n        v6 = tnode->Left;\n        subtree->Balance = 0;\n        tnode->Left = v6->Right;\n        v6->Right = tnode;\n        return v6;\n      }\n    }\n  } else {\n    *finished = 1;\n  }\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<CheckTreeNodeRotation>:\nendbr64\nmovzwl 0x20(%rdi),%ecx\nmov    %rdi,%rax\ntest   %cx,%cx\nje     1cf8 <CheckTreeNodeRotation+0xa8>\ncmp    $0x2,%cx\nje     1cb8 <CheckTreeNodeRotation+0x68>\ncmp    $0xfffe,%cx\nje     1c78 <CheckTreeNodeRotation+0x28>\nret\nnopl   0x0(%rax)\nmov    $0x1,%edi\nmov    %di,(%rdx)\nmovzwl 0x20(%rsi),%edx\ncmp    $0x1,%dx\nje     1d60 <CheckTreeNodeRotation+0x110>\ncmp    $0xffff,%dx\njne    1c70 <CheckTreeNodeRotation+0x20>\nxor    %edx,%edx\nxor    %ecx,%ecx\nmov    %dx,0x20(%rax)\nmov    (%rax),%rdx\nmov    %cx,0x20(%rsi)\nmov    0x8(%rdx),%rcx\nmov    %rcx,(%rax)\nmov    %rax,0x8(%rdx)\nmov    %rdx,%rax\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%r11d\nmov    %r11w,(%rdx)\nmovzwl 0x20(%rsi),%edx\ncmp    $0xffff,%dx\nje     1d08 <CheckTreeNodeRotation+0xb8>\ncmp    $0x1,%dx\njne    1c70 <CheckTreeNodeRotation+0x20>\nmov    0x8(%rdi),%rdx\nxor    %r8d,%r8d\nxor    %r9d,%r9d\nmov    %r8w,0x20(%rdi)\nmov    (%rdx),%rcx\nmov    %r9w,0x20(%rsi)\nmov    %rdx,%rax\nmov    %rcx,0x8(%rdi)\nmov    %rdi,(%rdx)\nret\nnopl   0x0(%rax)\nmov    $0x1,%ecx\nmov    %cx,(%rdx)\nret\nnopl   0x0(%rax)\nmov    (%rsi),%rdx\nmovzwl 0x20(%rdx),%ecx\ncmp    $0x1,%cx\nje     1df8 <CheckTreeNodeRotation+0x1a8>\ncmp    $0xffff,%cx\nje     1dc8 <CheckTreeNodeRotation+0x178>\nxor    %r11d,%r11d\nxor    %ecx,%ecx\nmov    %r11w,0x20(%rdi)\nmov    %cx,0x20(%rsi)\nmov    0x8(%rax),%rcx\nxor    %r10d,%r10d\nmov    %r10w,0x20(%rdx)\nmov    (%rcx),%rdx\nmov    0x8(%rdx),%rsi\nmov    %rsi,(%rcx)\nmov    %rcx,0x8(%rdx)\nmov    (%rdx),%rcx\nmov    %rcx,0x8(%rax)\nmov    %rax,(%rdx)\nmov    %rdx,%rax\nret\nnopl   0x0(%rax)\nmov    0x8(%rsi),%rdx\nmovzwl 0x20(%rdx),%ecx\ncmp    $0xffff,%cx\nje     1de0 <CheckTreeNodeRotation+0x190>\ncmp    $0x1,%cx\nje     1db0 <CheckTreeNodeRotation+0x160>\nxor    %edi,%edi\nxor    %r8d,%r8d\nmov    %di,0x20(%rax)\nmov    %r8w,0x20(%rsi)\nmov    (%rax),%rcx\nxor    %esi,%esi\nmov    %si,0x20(%rdx)\nmov    0x8(%rcx),%rdx\nmov    (%rdx),%rsi\nmov    %rsi,0x8(%rcx)\nmov    %rcx,(%rdx)\nmov    0x8(%rdx),%rcx\nmov    %rcx,(%rax)\nmov    %rax,0x8(%rdx)\nmov    %rdx,%rax\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0xffffffff,%r9d\nxor    %r10d,%r10d\nmov    %r9w,0x20(%rsi)\nmov    %r10w,0x20(%rax)\njmp    1d82 <CheckTreeNodeRotation+0x132>\nnopl   (%rax)\nmov    $0x1,%edi\nxor    %r8d,%r8d\nmov    %di,0x20(%rsi)\nmov    %r8w,0x20(%rax)\njmp    1d31 <CheckTreeNodeRotation+0xe1>\nxchg   %ax,%ax\nxor    %r11d,%r11d\nmov    $0x1,%ecx\nmov    %r11w,0x20(%rsi)\nmov    %cx,0x20(%rax)\njmp    1d82 <CheckTreeNodeRotation+0x132>\nnopl   0x0(%rax,%rax,1)\nxor    %r9d,%r9d\nmov    $0xffffffff,%r10d\nmov    %r9w,0x20(%rsi)\nmov    %r10w,0x20(%rdi)\njmp    1d31 <CheckTreeNodeRotation+0xe1>\n"}
{"source": {"path": "avl-tree/element.c", "function_name": "Compare", "content": "#include \"libmin.h\"\n#include \"element.h\"\n\nshort Compare(Element Data1, Element Data2)\n{\n    if(*Data1 > *Data2)\n        return 1;\n    else if(*Data1 < *Data2)\n        return -1;\n    return 0;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "Compare", "address": "0x1af0", "label": "Compare", "content": "__int16 __fastcall Compare(Element Data1, Element Data2)\n{\n  int v2; // eax\n\n  LOWORD(v2) = 1;\n  if ( *Data1 <= *Data2 )\n    return -(*Data1 < *Data2);\n  return v2;\n}\n"}, "pseudo_normalize": "short Compare(Element Data1, Element Data2) {\n  int v2;\n  LOWORD(v2) = 1;\n  if (*Data1 <= *Data2) return -(*Data1 < *Data2);\n  return v2;\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<Compare>:\nendbr64\nmov    (%rsi),%edx\nmov    $0x1,%eax\ncmp    %edx,(%rdi)\njg     1b07 <Compare+0x17>\nsetl   %al\nmovzbl %al,%eax\nneg    %eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DeleteByElement", "content": "TreeNode *DeleteByElement(TreeNode *rootNode, Element Item)\n{\n    short finished = 0;\n    TreeNode *newRoot = NULL;\n    newRoot = DeleteByElementRecursive(rootNode, Item, &finished);\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "DeleteByElement", "address": "0x2e50", "label": "DeleteByElement", "content": "TreeNode *__fastcall DeleteByElement(TreeNode *rootNode, Element Item)\n{\n  __int16 v2; // ax\n  TreeNode *v3; // rbx\n  TreeNodeTag *Right; // r12\n  TreeNodeTag *Left; // rbp\n  TreeNode *v6; // r13\n  TreeNode *v7; // rax\n  bool v8; // zf\n  TreeNode *v10; // rax\n  __int16 finished; // [rsp+Ch] [rbp-3Ch] BYREF\n  __int16 v12; // [rsp+Eh] [rbp-3Ah] BYREF\n  TreeNode *rootNodea[7]; // [rsp+10h] [rbp-38h] BYREF\n\n  rootNodea[1] = (TreeNode *)__readfsqword(0x28u);\n  rootNodea[0] = rootNode;\n  finished = 0;\n  v12 = 0;\n  if ( !rootNode )\n    return 0LL;\n  v2 = Compare(rootNode->Item, Item);\n  v12 = v2;\n  if ( v2 > 0 )\n  {\n    v10 = DeleteByElementRecursive(rootNodea[0]->Right, Item, &finished);\n    Right = rootNodea[0];\n    v8 = finished == 0;\n    rootNodea[0]->Right = v10;\n    if ( v8 && v10 )\n    {\n      --Right->Balance;\n      return CheckTreeNodeRotation(Right, v10, &finished);\n    }\n  }\n  else\n  {\n    v3 = rootNodea[0];\n    if ( !v2 )\n    {\n      Right = rootNodea[0]->Right;\n      if ( Right )\n      {\n        Left = Right->Left;\n        if ( Right->Left )\n        {\n          v6 = Left->Right;\n          if ( Left->Left )\n          {\n            v7 = DeleteLeftMost(rootNodea, Left->Left, &v12);\n            v8 = v12 == 0;\n            Left->Left = v7;\n            if ( !v8 )\n            {\n              Right->Left = Left;\nLABEL_12:\n              v3->Right = Right;\n              return rootNodea[0];\n            }\n            ++Left->Balance;\n            if ( !v7 )\n            {\n              ++Right->Balance;\n              Right->Left = Left;\nLABEL_28:\n              Right = CheckTreeNodeRotation(Right, Left, &v12);\n              goto LABEL_12;\n            }\n            v6 = CheckTreeNodeRotation(Left, v7, &v12);\n          }\n          else\n          {\n            libmin_free(rootNodea[0]->Name);\n            FreeElement(rootNodea[0]->Item);\n            *(__m128i *)&rootNodea[0]->Item = _mm_loadu_si128((const __m128i *)&Left->Item);\n            libmin_free(Left);\n          }\n          v8 = v12 == 0;\n          Right->Left = v6;\n          if ( !v8 )\n            goto LABEL_12;\n          ++Right->Balance;\n          if ( !v6 )\n            goto LABEL_12;\n          Left = v6;\n          goto LABEL_28;\n        }\n        Right->Balance = rootNodea[0]->Balance;\n        Right->Left = v3->Left;\n      }\n      else\n      {\n        Right = rootNodea[0]->Left;\n      }\n      libmin_free(v3->Name);\n      FreeElement(rootNodea[0]->Item);\n      libmin_free(rootNodea[0]);\n      return Right;\n    }\n    v10 = DeleteByElementRecursive(rootNodea[0]->Left, Item, &finished);\n    Right = rootNodea[0];\n    v8 = finished == 0;\n    rootNodea[0]->Left = v10;\n    if ( v8 && v10 )\n    {\n      ++Right->Balance;\n      return CheckTreeNodeRotation(Right, v10, &finished);\n    }\n  }\n  return Right;\n}\n"}, "pseudo_normalize": "TreeNode *DeleteByElement(TreeNode *rootNode, Element Item) {\n  short v2;\n  TreeNode *v3;\n  TreeNodeTag *Right;\n  TreeNodeTag *Left;\n  TreeNode *v6;\n  TreeNode *v7;\n  bool v8;\n  TreeNode *v10;\n  short finished;\n  short v12;\n  TreeNode *rootNodea[7];\n  rootNodea[1] = (TreeNode *)__readfsqword(40u);\n  rootNodea[0] = rootNode;\n  finished = 0;\n  v12 = 0;\n  if (!rootNode) return 0LL;\n  v2 = Compare(rootNode->Item, Item);\n  v12 = v2;\n  if (v2 > 0) {\n    v10 = DeleteByElementRecursive(rootNodea[0]->Right, Item, &finished);\n    Right = rootNodea[0];\n    v8 = finished == 0;\n    rootNodea[0]->Right = v10;\n    if (v8 && v10) {\n      --Right->Balance;\n      return CheckTreeNodeRotation(Right, v10, &finished);\n    }\n  } else {\n    v3 = rootNodea[0];\n    if (!v2) {\n      Right = rootNodea[0]->Right;\n      if (Right) {\n        Left = Right->Left;\n        if (Right->Left) {\n          v6 = Left->Right;\n          if (Left->Left) {\n            v7 = DeleteLeftMost(rootNodea, Left->Left, &v12);\n            v8 = v12 == 0;\n            Left->Left = v7;\n            if (!v8) {\n              Right->Left = Left;\n            LABEL_12:\n              v3->Right = Right;\n              return rootNodea[0];\n            }\n            ++Left->Balance;\n            if (!v7) {\n              ++Right->Balance;\n              Right->Left = Left;\n            LABEL_28:\n              Right = CheckTreeNodeRotation(Right, Left, &v12);\n              goto LABEL_12;\n            }\n            v6 = CheckTreeNodeRotation(Left, v7, &v12);\n          } else {\n            libmin_free(rootNodea[0]->Name);\n            FreeElement(rootNodea[0]->Item);\n            *(__m128i *)&rootNodea[0]->Item =\n                _mm_loadu_si128((const __m128i *)&Left->Item);\n            libmin_free(Left);\n          }\n          v8 = v12 == 0;\n          Right->Left = v6;\n          if (!v8) goto LABEL_12;\n          ++Right->Balance;\n          if (!v6) goto LABEL_12;\n          Left = v6;\n          goto LABEL_28;\n        }\n        Right->Balance = rootNodea[0]->Balance;\n        Right->Left = v3->Left;\n      } else {\n        Right = rootNodea[0]->Left;\n      }\n      libmin_free(v3->Name);\n      FreeElement(rootNodea[0]->Item);\n      libmin_free(rootNodea[0]);\n      return Right;\n    }\n    v10 = DeleteByElementRecursive(rootNodea[0]->Left, Item, &finished);\n    Right = rootNodea[0];\n    v8 = finished == 0;\n    rootNodea[0]->Left = v10;\n    if (v8 && v10) {\n      ++Right->Balance;\n      return CheckTreeNodeRotation(Right, v10, &finished);\n    }\n  }\n  return Right;\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<DeleteByElement>:\nendbr64\npush   %r13\nxor    %edx,%edx\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nxor    %eax,%eax\nmov    %rdi,0x10(%rsp)\nmov    %ax,0xc(%rsp)\nmov    %dx,0xe(%rsp)\ntest   %rdi,%rdi\nje     3030 <DeleteByElement+0x1e0>\nmov    0x10(%rdi),%rdi\nmov    %rsi,%r12\ncall   1af0 <Compare>\nmov    %ax,0xe(%rsp)\ntest   %ax,%ax\njg     2f68 <DeleteByElement+0x118>\nmov    0x10(%rsp),%rbx\njne    2ff0 <DeleteByElement+0x1a0>\nmov    0x8(%rbx),%r12\ntest   %r12,%r12\nje     3040 <DeleteByElement+0x1f0>\nmov    (%r12),%rbp\ntest   %rbp,%rbp\nje     2fb8 <DeleteByElement+0x168>\nmov    0x0(%rbp),%rsi\nmov    0x8(%rbp),%r13\ntest   %rsi,%rsi\nje     3060 <DeleteByElement+0x210>\nlea    0xe(%rsp),%r13\nlea    0x10(%rsp),%rdi\nmov    %r13,%rdx\ncall   2720 <DeleteLeftMost>\ncmpw   $0x0,0xe(%rsp)\nmov    %rax,0x0(%rbp)\njne    3050 <DeleteByElement+0x200>\naddw   $0x1,0x20(%rbp)\ntest   %rax,%rax\nje     3098 <DeleteByElement+0x248>\nmov    %r13,%rdx\nmov    %rax,%rsi\nmov    %rbp,%rdi\ncall   1c50 <CheckTreeNodeRotation>\nmov    %rax,%r13\ncmpw   $0x0,0xe(%rsp)\nmov    %r13,(%r12)\njne    2f37 <DeleteByElement+0xe7>\naddw   $0x1,0x20(%r12)\ntest   %r13,%r13\njne    30b9 <DeleteByElement+0x269>\nmov    %r12,0x8(%rbx)\nmov    0x10(%rsp),%r12\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    30c3 <DeleteByElement+0x273>\nadd    $0x28,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopw   0x0(%rax,%rax,1)\nmov    0x10(%rsp),%rax\nlea    0xc(%rsp),%r13\nmov    %r12,%rsi\nmov    %r13,%rdx\nmov    0x8(%rax),%rdi\ncall   2bf0 <DeleteByElementRecursive>\nmov    0x10(%rsp),%r12\ncmpw   $0x0,0xc(%rsp)\nmov    %rax,0x8(%r12)\njne    2f40 <DeleteByElement+0xf0>\ntest   %rax,%rax\nje     2f40 <DeleteByElement+0xf0>\nsubw   $0x1,0x20(%r12)\nmov    %r12,%rdi\nmov    %r13,%rdx\nmov    %rax,%rsi\ncall   1c50 <CheckTreeNodeRotation>\nmov    %rax,%r12\njmp    2f40 <DeleteByElement+0xf0>\nnopw   0x0(%rax,%rax,1)\nmovzwl 0x20(%rbx),%eax\nmov    %ax,0x20(%r12)\nmov    (%rbx),%rax\nmov    %rax,(%r12)\nmov    0x18(%rbx),%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%rsp),%rax\nmov    0x10(%rax),%rdi\ncall   1b10 <FreeElement>\nmov    0x10(%rsp),%rdi\ncall   3ba0 <libmin_free>\njmp    2f40 <DeleteByElement+0xf0>\nnop\nmov    (%rbx),%rdi\nlea    0xc(%rsp),%r13\nmov    %r12,%rsi\nmov    %r13,%rdx\ncall   2bf0 <DeleteByElementRecursive>\nmov    0x10(%rsp),%r12\ncmpw   $0x0,0xc(%rsp)\nmov    %rax,(%r12)\njne    2f40 <DeleteByElement+0xf0>\ntest   %rax,%rax\nje     2f40 <DeleteByElement+0xf0>\naddw   $0x1,0x20(%r12)\njmp    2f9f <DeleteByElement+0x14f>\nnopl   (%rax)\nxor    %r12d,%r12d\njmp    2f40 <DeleteByElement+0xf0>\nnopl   0x0(%rax,%rax,1)\nmov    (%rbx),%r12\njmp    2fc9 <DeleteByElement+0x179>\nnopl   0x0(%rax,%rax,1)\nmov    %rbp,(%r12)\njmp    2f37 <DeleteByElement+0xe7>\nnopl   0x0(%rax)\nmov    0x18(%rbx),%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%rsp),%rax\nmov    0x10(%rax),%rdi\ncall   1b10 <FreeElement>\nmov    0x10(%rsp),%rax\nmovdqu 0x10(%rbp),%xmm0\nmov    %rbp,%rdi\nmovups %xmm0,0x10(%rax)\ncall   3ba0 <libmin_free>\njmp    2f1b <DeleteByElement+0xcb>\nnopw   0x0(%rax,%rax,1)\naddw   $0x1,0x20(%r12)\nmov    %rbp,(%r12)\nmov    %r12,%rdi\nmov    %r13,%rdx\nmov    %rbp,%rsi\ncall   1c50 <CheckTreeNodeRotation>\nmov    %rax,%r12\njmp    2f37 <DeleteByElement+0xe7>\nmov    %r13,%rbp\nlea    0xe(%rsp),%r13\njmp    30a3 <DeleteByElement+0x253>\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DeleteByElementRecursive", "content": "TreeNode *DeleteByElementRecursive(TreeNode *rootNode,\n                                   Element Item, short *finished)\n{\n    TreeNode *subtree = NULL;\n    short comp = 0;\n    \n    /* found a leaf */\n    if(rootNode == NULL)\n        return NULL;\n    /* figure out where the node in question is in relation to the current */\n    comp = Compare(rootNode->Item, Item);\n    if(comp > 0)    {\n        /* buried somewhere in the right subtree */\n        subtree = DeleteByElementRecursive(rootNode->Right, Item, finished);\n        rootNode->Right = subtree;\n        if(!*finished && subtree != NULL)  {\n            rootNode->Balance--;\n            rootNode = CheckTreeNodeRotation(rootNode, subtree, finished);\n        }\n    } else if(comp < 0) {\n        subtree = DeleteByElementRecursive(rootNode->Left, Item, finished);\n        rootNode->Left = subtree;\n        if(!*finished && subtree != NULL)  {\n            rootNode->Balance++;\n            rootNode = CheckTreeNodeRotation(rootNode, subtree, finished);\n        }\n    } else {\n        /* found what we were looking for */\n        if(rootNode->Right == NULL) {\n            /* rootNode is replaced by the left child; can be null */\n            subtree = rootNode->Left;\n            libmin_free(rootNode->Name);\n            FreeElement(rootNode->Item);\n            libmin_free(rootNode);\n            rootNode = subtree;\n        } else if(rootNode->Right->Left == NULL)  {\n            /* rootNode is replaced by Right */\n            subtree = rootNode->Right;\n            subtree->Balance = rootNode->Balance;\n            subtree->Left = rootNode->Left;\n            libmin_free(rootNode->Name);\n            FreeElement(rootNode->Item);\n            libmin_free(rootNode);\n            rootNode = subtree;\n        } else {\n            /* rootNode is replaced by inorder successor */\n            /* re-using comp as another flag since it is 0 */\n            rootNode->Right = DeleteLeftMost(&rootNode, rootNode->Right, &comp);\n        }\n    }\n    return rootNode;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "DeleteByElementRecursive", "address": "0x2bf0", "label": "DeleteByElementRecursive", "content": "TreeNode *__fastcall DeleteByElementRecursive(TreeNode *rootNode, Element Item, __int16 *finished)\n{\n  TreeNode *Right; // r12\n  __int16 v5; // ax\n  TreeNode *v6; // rbx\n  TreeNodeTag *Left; // rbp\n  TreeNode *v8; // r13\n  TreeNode *v9; // rax\n  bool v10; // zf\n  TreeNode *v12; // rax\n  TreeNode *deletedNode; // [rsp+8h] [rbp-40h] BYREF\n  __int16 comp; // [rsp+16h] [rbp-32h] BYREF\n  unsigned __int64 v15; // [rsp+18h] [rbp-30h]\n\n  Right = rootNode;\n  deletedNode = rootNode;\n  v15 = __readfsqword(0x28u);\n  comp = 0;\n  if ( rootNode )\n  {\n    v5 = Compare(rootNode->Item, Item);\n    comp = v5;\n    if ( v5 > 0 )\n    {\n      v12 = DeleteByElementRecursive(deletedNode->Right, Item, finished);\n      Right = deletedNode;\n      v10 = *finished == 0;\n      deletedNode->Right = v12;\n      if ( v10 && v12 )\n      {\n        --Right->Balance;\n        return CheckTreeNodeRotation(Right, v12, finished);\n      }\n    }\n    else\n    {\n      v6 = deletedNode;\n      if ( !v5 )\n      {\n        Right = deletedNode->Right;\n        if ( Right )\n        {\n          Left = Right->Left;\n          if ( Right->Left )\n          {\n            v8 = Left->Right;\n            if ( Left->Left )\n            {\n              v9 = DeleteLeftMost(&deletedNode, Left->Left, &comp);\n              v10 = comp == 0;\n              Left->Left = v9;\n              if ( !v10 )\n              {\n                Right->Left = Left;\nLABEL_12:\n                v6->Right = Right;\n                return deletedNode;\n              }\n              ++Left->Balance;\n              if ( !v9 )\n              {\n                ++Right->Balance;\n                Right->Left = Left;\nLABEL_27:\n                Right = CheckTreeNodeRotation(Right, Left, &comp);\n                goto LABEL_12;\n              }\n              v8 = CheckTreeNodeRotation(Left, v9, &comp);\n            }\n            else\n            {\n              libmin_free(deletedNode->Name);\n              FreeElement(deletedNode->Item);\n              *(__m128i *)&deletedNode->Item = _mm_loadu_si128((const __m128i *)&Left->Item);\n              libmin_free(Left);\n            }\n            v10 = comp == 0;\n            Right->Left = v8;\n            if ( !v10 )\n              goto LABEL_12;\n            ++Right->Balance;\n            if ( !v8 )\n              goto LABEL_12;\n            Left = v8;\n            goto LABEL_27;\n          }\n          Right->Balance = deletedNode->Balance;\n          Right->Left = v6->Left;\n        }\n        else\n        {\n          Right = deletedNode->Left;\n        }\n        libmin_free(v6->Name);\n        FreeElement(deletedNode->Item);\n        libmin_free(deletedNode);\n        return Right;\n      }\n      v12 = DeleteByElementRecursive(deletedNode->Left, Item, finished);\n      Right = deletedNode;\n      v10 = *finished == 0;\n      deletedNode->Left = v12;\n      if ( v10 && v12 )\n      {\n        ++Right->Balance;\n        return CheckTreeNodeRotation(Right, v12, finished);\n      }\n    }\n  }\n  return Right;\n}\n"}, "pseudo_normalize": "TreeNode *DeleteByElementRecursive(TreeNode *rootNode, Element Item,\n                                   short *finished) {\n  TreeNode *Right;\n  short v5;\n  TreeNode *v6;\n  TreeNodeTag *Left;\n  TreeNode *v8;\n  TreeNode *v9;\n  bool v10;\n  TreeNode *v12;\n  TreeNode *deletedNode;\n  short comp;\n  unsigned long long v15;\n  Right = rootNode;\n  deletedNode = rootNode;\n  v15 = __readfsqword(40u);\n  comp = 0;\n  if (rootNode) {\n    v5 = Compare(rootNode->Item, Item);\n    comp = v5;\n    if (v5 > 0) {\n      v12 = DeleteByElementRecursive(deletedNode->Right, Item, finished);\n      Right = deletedNode;\n      v10 = *finished == 0;\n      deletedNode->Right = v12;\n      if (v10 && v12) {\n        --Right->Balance;\n        return CheckTreeNodeRotation(Right, v12, finished);\n      }\n    } else {\n      v6 = deletedNode;\n      if (!v5) {\n        Right = deletedNode->Right;\n        if (Right) {\n          Left = Right->Left;\n          if (Right->Left) {\n            v8 = Left->Right;\n            if (Left->Left) {\n              v9 = DeleteLeftMost(&deletedNode, Left->Left, &comp);\n              v10 = comp == 0;\n              Left->Left = v9;\n              if (!v10) {\n                Right->Left = Left;\n              LABEL_12:\n                v6->Right = Right;\n                return deletedNode;\n              }\n              ++Left->Balance;\n              if (!v9) {\n                ++Right->Balance;\n                Right->Left = Left;\n              LABEL_27:\n                Right = CheckTreeNodeRotation(Right, Left, &comp);\n                goto LABEL_12;\n              }\n              v8 = CheckTreeNodeRotation(Left, v9, &comp);\n            } else {\n              libmin_free(deletedNode->Name);\n              FreeElement(deletedNode->Item);\n              *(__m128i *)&deletedNode->Item =\n                  _mm_loadu_si128((const __m128i *)&Left->Item);\n              libmin_free(Left);\n            }\n            v10 = comp == 0;\n            Right->Left = v8;\n            if (!v10) goto LABEL_12;\n            ++Right->Balance;\n            if (!v8) goto LABEL_12;\n            Left = v8;\n            goto LABEL_27;\n          }\n          Right->Balance = deletedNode->Balance;\n          Right->Left = v6->Left;\n        } else {\n          Right = deletedNode->Left;\n        }\n        libmin_free(v6->Name);\n        FreeElement(deletedNode->Item);\n        libmin_free(deletedNode);\n        return Right;\n      }\n      v12 = DeleteByElementRecursive(deletedNode->Left, Item, finished);\n      Right = deletedNode;\n      v10 = *finished == 0;\n      deletedNode->Left = v12;\n      if (v10 && v12) {\n        ++Right->Balance;\n        return CheckTreeNodeRotation(Right, v12, finished);\n      }\n    }\n  }\n  return Right;\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<DeleteByElementRecursive>:\nendbr64\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %rdi,0x8(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nxor    %eax,%eax\nmov    %ax,0x16(%rsp)\ntest   %rdi,%rdi\nje     2ce0 <DeleteByElementRecursive+0xf0>\nmov    0x10(%rdi),%rdi\nmov    %rsi,%rbp\nmov    %rdx,%r13\ncall   1af0 <Compare>\nmov    %ax,0x16(%rsp)\ntest   %ax,%ax\njg     2d08 <DeleteByElementRecursive+0x118>\nmov    0x8(%rsp),%rbx\njne    2d90 <DeleteByElementRecursive+0x1a0>\nmov    0x8(%rbx),%r12\ntest   %r12,%r12\nje     2dd0 <DeleteByElementRecursive+0x1e0>\nmov    (%r12),%rbp\ntest   %rbp,%rbp\nje     2d50 <DeleteByElementRecursive+0x160>\nmov    0x0(%rbp),%rsi\nmov    0x8(%rbp),%r13\ntest   %rsi,%rsi\nje     2de8 <DeleteByElementRecursive+0x1f8>\nlea    0x16(%rsp),%r13\nlea    0x8(%rsp),%rdi\nmov    %r13,%rdx\ncall   2720 <DeleteLeftMost>\ncmpw   $0x0,0x16(%rsp)\nmov    %rax,0x0(%rbp)\njne    2dd8 <DeleteByElementRecursive+0x1e8>\naddw   $0x1,0x20(%rbp)\ntest   %rax,%rax\nje     2e20 <DeleteByElementRecursive+0x230>\nmov    %r13,%rdx\nmov    %rax,%rsi\nmov    %rbp,%rdi\ncall   1c50 <CheckTreeNodeRotation>\nmov    %rax,%r13\ncmpw   $0x0,0x16(%rsp)\nmov    %r13,(%r12)\njne    2cd6 <DeleteByElementRecursive+0xe6>\naddw   $0x1,0x20(%r12)\ntest   %r13,%r13\njne    2e41 <DeleteByElementRecursive+0x251>\nmov    %r12,0x8(%rbx)\nmov    0x8(%rsp),%r12\nnop\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    2e4b <DeleteByElementRecursive+0x25b>\nadd    $0x28,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopw   0x0(%rax,%rax,1)\nmov    0x8(%rsp),%rax\nmov    %r13,%rdx\nmov    %rbp,%rsi\nmov    0x8(%rax),%rdi\ncall   2bf0 <DeleteByElementRecursive>\nmov    0x8(%rsp),%r12\ncmpw   $0x0,0x0(%r13)\nmov    %rax,0x8(%r12)\njne    2ce0 <DeleteByElementRecursive+0xf0>\ntest   %rax,%rax\nje     2ce0 <DeleteByElementRecursive+0xf0>\nsubw   $0x1,0x20(%r12)\nmov    %r12,%rdi\nmov    %r13,%rdx\nmov    %rax,%rsi\ncall   1c50 <CheckTreeNodeRotation>\nmov    %rax,%r12\njmp    2ce0 <DeleteByElementRecursive+0xf0>\nnopl   (%rax)\nmovzwl 0x20(%rbx),%eax\nmov    %ax,0x20(%r12)\nmov    (%rbx),%rax\nmov    %rax,(%r12)\nmov    0x18(%rbx),%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%rsp),%rax\nmov    0x10(%rax),%rdi\ncall   1b10 <FreeElement>\nmov    0x8(%rsp),%rdi\ncall   3ba0 <libmin_free>\njmp    2ce0 <DeleteByElementRecursive+0xf0>\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%rdi\nmov    %r13,%rdx\nmov    %rbp,%rsi\ncall   2bf0 <DeleteByElementRecursive>\nmov    0x8(%rsp),%r12\ncmpw   $0x0,0x0(%r13)\nmov    %rax,(%r12)\njne    2ce0 <DeleteByElementRecursive+0xf0>\ntest   %rax,%rax\nje     2ce0 <DeleteByElementRecursive+0xf0>\naddw   $0x1,0x20(%r12)\njmp    2d3a <DeleteByElementRecursive+0x14a>\nnopl   0x0(%rax,%rax,1)\nmov    (%rbx),%r12\njmp    2d61 <DeleteByElementRecursive+0x171>\nnopl   (%rax)\nmov    %rbp,(%r12)\njmp    2cd6 <DeleteByElementRecursive+0xe6>\nnopl   0x0(%rax)\nmov    0x18(%rbx),%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%rsp),%rax\nmov    0x10(%rax),%rdi\ncall   1b10 <FreeElement>\nmov    0x8(%rsp),%rax\nmovdqu 0x10(%rbp),%xmm0\nmov    %rbp,%rdi\nmovups %xmm0,0x10(%rax)\ncall   3ba0 <libmin_free>\njmp    2cba <DeleteByElementRecursive+0xca>\nnopw   0x0(%rax,%rax,1)\naddw   $0x1,0x20(%r12)\nmov    %rbp,(%r12)\nmov    %r12,%rdi\nmov    %r13,%rdx\nmov    %rbp,%rsi\ncall   1c50 <CheckTreeNodeRotation>\nmov    %rax,%r12\njmp    2cd6 <DeleteByElementRecursive+0xe6>\nmov    %r13,%rbp\nlea    0x16(%rsp),%r13\njmp    2e2b <DeleteByElementRecursive+0x23b>\ncall   10c0 <__stack_chk_fail@plt>\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DeleteLeftMost", "content": "TreeNode *DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode,\n                    short *finished)\n{\n    TreeNode *subtree = rootNode->Right;\n    if(rootNode == NULL)    {\n        libmin_printf(\"bailing!\\n\");\n        return NULL;\n    }\n    if(rootNode->Left == NULL)  {\n        libmin_free((*deletedNode)->Name);\n        FreeElement((*deletedNode)->Item);\n        (*deletedNode)->Name = rootNode->Name;\n        (*deletedNode)->Item = rootNode->Item;\n        libmin_free(rootNode);\n        rootNode = subtree;\n    } else {\n        rootNode->Left = DeleteLeftMost(deletedNode, rootNode->Left, finished);\n        if(!*finished)  {\n            rootNode->Balance++;\n            if(rootNode->Left != NULL)\n                rootNode = CheckTreeNodeRotation(rootNode, rootNode->Left,\n                                finished);\n        }\n    }\n    return rootNode;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "DeleteLeftMost", "address": "0x2720", "label": "DeleteLeftMost", "content": "TreeNode *__fastcall DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode, __int16 *finished)\n{\n  TreeNodeTag *Left; // r13\n  TreeNode *Right; // r15\n  TreeNode *v5; // r15\n  TreeNode *v6; // rbx\n  TreeNode *v8; // rbx\n  TreeNodeTag *v9; // r8\n  __m128i *v10; // r9\n  TreeNode *v11; // r10\n  TreeNode *v12; // rax\n  TreeNode *v13; // r10\n  bool v14; // zf\n  TreeNode *v15; // r8\n  TreeNode *v16; // r9\n  TreeNode *v17; // rax\n  __int64 v18; // rax\n  TreeNode *v19; // rax\n  __int64 v21; // rax\n  TreeNode *v22; // rax\n  __int64 v23; // rax\n  TreeNode *v24; // rax\n  __int64 v25; // rax\n  TreeNode *v26; // rax\n  __int64 v27; // rax\n  __int64 v28; // rax\n  TreeNode *v29; // [rsp+0h] [rbp-58h]\n  __m128i *v30; // [rsp+0h] [rbp-58h]\n  TreeNode *v31; // [rsp+0h] [rbp-58h]\n  TreeNode *v32; // [rsp+0h] [rbp-58h]\n  TreeNode *v33; // [rsp+0h] [rbp-58h]\n  TreeNode *v34; // [rsp+0h] [rbp-58h]\n  TreeNode *v35; // [rsp+0h] [rbp-58h]\n  TreeNode *v36; // [rsp+8h] [rbp-50h]\n  TreeNode *v37; // [rsp+8h] [rbp-50h]\n  __m128i *v38; // [rsp+8h] [rbp-50h]\n  TreeNode *v39; // [rsp+8h] [rbp-50h]\n  TreeNode *tnode; // [rsp+10h] [rbp-48h]\n  TreeNode *tnodea; // [rsp+10h] [rbp-48h]\n  __m128i *tnodeb; // [rsp+10h] [rbp-48h]\n  TreeNode *v43; // [rsp+18h] [rbp-40h]\n\n  Left = rootNode->Left;\n  Right = rootNode->Right;\n  if ( !rootNode->Left )\n  {\n    libmin_free((*deletedNode)->Name);\n    FreeElement((*deletedNode)->Item);\n    *(__m128i *)&(*deletedNode)->Item = _mm_loadu_si128((const __m128i *)&rootNode->Item);\n    libmin_free(rootNode);\n    return Right;\n  }\n  v5 = Left->Left;\n  v6 = Left->Right;\n  if ( Left->Left )\n  {\n    v8 = v5->Left;\n    if ( !v5->Left )\n    {\n      v31 = v5->Right;\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      *(__m128i *)&(*deletedNode)->Item = _mm_loadu_si128((const __m128i *)&v5->Item);\n      libmin_free(v5);\n      v22 = v31;\nLABEL_29:\n      v14 = *finished == 0;\n      Left->Left = v22;\n      if ( v14 )\n      {\n        ++Left->Balance;\n        if ( !v22 )\n        {\n          v23 = (unsigned __int16)*finished;\n          rootNode->Left = Left;\n          if ( !(_WORD)v23 )\n          {\n            ++rootNode->Balance;\n            return CheckTreeNodeRotation(rootNode, Left, finished);\n          }\n          return rootNode;\n        }\n        v5 = v22;\n        goto LABEL_46;\n      }\n      goto LABEL_39;\n    }\n    v9 = v8->Left;\n    if ( !v8->Left )\n    {\n      v32 = v8->Right;\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      *(__m128i *)&(*deletedNode)->Item = _mm_loadu_si128((const __m128i *)&v8->Item);\n      libmin_free(v8);\n      v24 = v32;\n      goto LABEL_42;\n    }\n    v10 = (__m128i *)v9->Left;\n    if ( !v9->Left )\n    {\n      v37 = v9->Right;\n      v30 = (__m128i *)v8->Left;\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      *(__m128i *)&(*deletedNode)->Item = _mm_loadu_si128(v30 + 1);\n      libmin_free(v30);\n      v19 = v37;\nLABEL_24:\n      v14 = *finished == 0;\n      v8->Left = v19;\n      if ( v14 )\n      {\n        ++v8->Balance;\n        if ( !v19 )\n        {\n          v21 = (unsigned __int16)*finished;\n          v5->Left = v8;\n          if ( !(_WORD)v21 )\n          {\n            ++v5->Balance;\nLABEL_28:\n            v22 = CheckTreeNodeRotation(v5, v8, finished);\n            goto LABEL_29;\n          }\n          goto LABEL_38;\n        }\n        v15 = v19;\n        goto LABEL_52;\n      }\n      goto LABEL_37;\n    }\n    v11 = (TreeNode *)v10->m128i_i64[0];\n    if ( !v10->m128i_i64[0] )\n    {\n      tnodea = (TreeNode *)v10->m128i_i64[1];\n      v33 = v8->Left;\n      v38 = (__m128i *)v9->Left;\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      *(__m128i *)&(*deletedNode)->Item = _mm_loadu_si128(v38 + 1);\n      libmin_free(v38);\n      v15 = v33;\n      v26 = tnodea;\n      goto LABEL_48;\n    }\n    if ( v11->Left )\n    {\n      tnode = (TreeNode *)v10->m128i_i64[0];\n      v36 = v9->Left;\n      v29 = v8->Left;\n      v12 = DeleteLeftMost(deletedNode, v11->Left, finished);\n      v13 = tnode;\n      v14 = *finished == 0;\n      v15 = v29;\n      v16 = v36;\n      tnode->Left = v12;\n      if ( !v14 )\n      {\n        v36->Left = tnode;\n        goto LABEL_35;\n      }\n      ++tnode->Balance;\n      if ( !v12 )\n      {\n        v28 = (unsigned __int16)*finished;\n        v36->Left = tnode;\n        if ( !(_WORD)v28 )\n        {\n          ++v36->Balance;\nLABEL_56:\n          v35 = v15;\n          v26 = CheckTreeNodeRotation(v16, v13, finished);\n          v15 = v35;\nLABEL_48:\n          v14 = *finished == 0;\n          v15->Left = v26;\n          if ( v14 )\n          {\n            ++v15->Balance;\n            if ( !v26 )\n            {\n              v27 = (unsigned __int16)*finished;\n              v8->Left = v15;\n              if ( !(_WORD)v27 )\n              {\n                ++v8->Balance;\nLABEL_52:\n                v24 = CheckTreeNodeRotation(v8, v15, finished);\nLABEL_42:\n                v14 = *finished == 0;\n                v5->Left = v24;\n                if ( v14 )\n                {\n                  ++v5->Balance;\n                  if ( !v24 )\n                  {\n                    v25 = (unsigned __int16)*finished;\n                    Left->Left = v5;\n                    if ( !(_WORD)v25 )\n                    {\n                      ++Left->Balance;\nLABEL_46:\n                      v6 = CheckTreeNodeRotation(Left, v5, finished);\n                      goto LABEL_17;\n                    }\nLABEL_39:\n                    rootNode->Left = Left;\n                    return rootNode;\n                  }\n                  v8 = v24;\n                  goto LABEL_28;\n                }\nLABEL_38:\n                Left->Left = v5;\n                goto LABEL_39;\n              }\nLABEL_37:\n              v5->Left = v8;\n              goto LABEL_38;\n            }\n            v16 = v26;\n            goto LABEL_15;\n          }\nLABEL_36:\n          v8->Left = v15;\n          goto LABEL_37;\n        }\nLABEL_35:\n        v15->Left = v16;\n        goto LABEL_36;\n      }\n      v17 = CheckTreeNodeRotation(tnode, v12, finished);\n      v16 = v36;\n      v15 = v29;\n    }\n    else\n    {\n      v43 = v11->Right;\n      v39 = v9->Left;\n      v34 = v8->Left;\n      tnodeb = (__m128i *)v10->m128i_i64[0];\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      *(__m128i *)&(*deletedNode)->Item = _mm_loadu_si128(tnodeb + 1);\n      libmin_free(tnodeb);\n      v15 = v34;\n      v16 = v39;\n      v17 = v43;\n    }\n    v14 = *finished == 0;\n    v16->Left = v17;\n    if ( v14 )\n    {\n      ++v16->Balance;\n      if ( !v17 )\n      {\n        v18 = (unsigned __int16)*finished;\n        v15->Left = v16;\n        if ( !(_WORD)v18 )\n        {\n          ++v15->Balance;\nLABEL_15:\n          v19 = CheckTreeNodeRotation(v15, v16, finished);\n          goto LABEL_24;\n        }\n        goto LABEL_36;\n      }\n      v13 = v17;\n      goto LABEL_56;\n    }\n    goto LABEL_35;\n  }\n  libmin_free((*deletedNode)->Name);\n  FreeElement((*deletedNode)->Item);\n  *(__m128i *)&(*deletedNode)->Item = _mm_loadu_si128((const __m128i *)&Left->Item);\n  libmin_free(Left);\nLABEL_17:\n  v14 = *finished == 0;\n  rootNode->Left = v6;\n  if ( !v14 )\n    return rootNode;\n  ++rootNode->Balance;\n  if ( !v6 )\n    return rootNode;\n  Left = v6;\n  return CheckTreeNodeRotation(rootNode, Left, finished);\n}\n"}, "pseudo_normalize": "TreeNode *DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode,\n                         short *finished) {\n  TreeNodeTag *Left;\n  TreeNode *Right;\n  TreeNode *v5;\n  TreeNode *v6;\n  TreeNode *v8;\n  TreeNodeTag *v9;\n  __m128i *v10;\n  TreeNode *v11;\n  TreeNode *v12;\n  TreeNode *v13;\n  bool v14;\n  TreeNode *v15;\n  TreeNode *v16;\n  TreeNode *v17;\n  long long v18;\n  TreeNode *v19;\n  long long v21;\n  TreeNode *v22;\n  long long v23;\n  TreeNode *v24;\n  long long v25;\n  TreeNode *v26;\n  long long v27;\n  long long v28;\n  TreeNode *v29;\n  __m128i *v30;\n  TreeNode *v31;\n  TreeNode *v32;\n  TreeNode *v33;\n  TreeNode *v34;\n  TreeNode *v35;\n  TreeNode *v36;\n  TreeNode *v37;\n  __m128i *v38;\n  TreeNode *v39;\n  TreeNode *tnode;\n  TreeNode *tnodea;\n  __m128i *tnodeb;\n  TreeNode *v43;\n  Left = rootNode->Left;\n  Right = rootNode->Right;\n  if (!rootNode->Left) {\n    libmin_free((*deletedNode)->Name);\n    FreeElement((*deletedNode)->Item);\n    *(__m128i *)&(*deletedNode)->Item =\n        _mm_loadu_si128((const __m128i *)&rootNode->Item);\n    libmin_free(rootNode);\n    return Right;\n  }\n  v5 = Left->Left;\n  v6 = Left->Right;\n  if (Left->Left) {\n    v8 = v5->Left;\n    if (!v5->Left) {\n      v31 = v5->Right;\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      *(__m128i *)&(*deletedNode)->Item =\n          _mm_loadu_si128((const __m128i *)&v5->Item);\n      libmin_free(v5);\n      v22 = v31;\n    LABEL_29:\n      v14 = *finished == 0;\n      Left->Left = v22;\n      if (v14) {\n        ++Left->Balance;\n        if (!v22) {\n          v23 = (unsigned short)*finished;\n          rootNode->Left = Left;\n          if (!(unsigned short)v23) {\n            ++rootNode->Balance;\n            return CheckTreeNodeRotation(rootNode, Left, finished);\n          }\n          return rootNode;\n        }\n        v5 = v22;\n        goto LABEL_46;\n      }\n      goto LABEL_39;\n    }\n    v9 = v8->Left;\n    if (!v8->Left) {\n      v32 = v8->Right;\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      *(__m128i *)&(*deletedNode)->Item =\n          _mm_loadu_si128((const __m128i *)&v8->Item);\n      libmin_free(v8);\n      v24 = v32;\n      goto LABEL_42;\n    }\n    v10 = (__m128i *)v9->Left;\n    if (!v9->Left) {\n      v37 = v9->Right;\n      v30 = (__m128i *)v8->Left;\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      *(__m128i *)&(*deletedNode)->Item = _mm_loadu_si128(v30 + 1);\n      libmin_free(v30);\n      v19 = v37;\n    LABEL_24:\n      v14 = *finished == 0;\n      v8->Left = v19;\n      if (v14) {\n        ++v8->Balance;\n        if (!v19) {\n          v21 = (unsigned short)*finished;\n          v5->Left = v8;\n          if (!(unsigned short)v21) {\n            ++v5->Balance;\n          LABEL_28:\n            v22 = CheckTreeNodeRotation(v5, v8, finished);\n            goto LABEL_29;\n          }\n          goto LABEL_38;\n        }\n        v15 = v19;\n        goto LABEL_52;\n      }\n      goto LABEL_37;\n    }\n    v11 = (TreeNode *)v10->m128i_i64[0];\n    if (!v10->m128i_i64[0]) {\n      tnodea = (TreeNode *)v10->m128i_i64[1];\n      v33 = v8->Left;\n      v38 = (__m128i *)v9->Left;\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      *(__m128i *)&(*deletedNode)->Item = _mm_loadu_si128(v38 + 1);\n      libmin_free(v38);\n      v15 = v33;\n      v26 = tnodea;\n      goto LABEL_48;\n    }\n    if (v11->Left) {\n      tnode = (TreeNode *)v10->m128i_i64[0];\n      v36 = v9->Left;\n      v29 = v8->Left;\n      v12 = DeleteLeftMost(deletedNode, v11->Left, finished);\n      v13 = tnode;\n      v14 = *finished == 0;\n      v15 = v29;\n      v16 = v36;\n      tnode->Left = v12;\n      if (!v14) {\n        v36->Left = tnode;\n        goto LABEL_35;\n      }\n      ++tnode->Balance;\n      if (!v12) {\n        v28 = (unsigned short)*finished;\n        v36->Left = tnode;\n        if (!(unsigned short)v28) {\n          ++v36->Balance;\n        LABEL_56:\n          v35 = v15;\n          v26 = CheckTreeNodeRotation(v16, v13, finished);\n          v15 = v35;\n        LABEL_48:\n          v14 = *finished == 0;\n          v15->Left = v26;\n          if (v14) {\n            ++v15->Balance;\n            if (!v26) {\n              v27 = (unsigned short)*finished;\n              v8->Left = v15;\n              if (!(unsigned short)v27) {\n                ++v8->Balance;\n              LABEL_52:\n                v24 = CheckTreeNodeRotation(v8, v15, finished);\n              LABEL_42:\n                v14 = *finished == 0;\n                v5->Left = v24;\n                if (v14) {\n                  ++v5->Balance;\n                  if (!v24) {\n                    v25 = (unsigned short)*finished;\n                    Left->Left = v5;\n                    if (!(unsigned short)v25) {\n                      ++Left->Balance;\n                    LABEL_46:\n                      v6 = CheckTreeNodeRotation(Left, v5, finished);\n                      goto LABEL_17;\n                    }\n                  LABEL_39:\n                    rootNode->Left = Left;\n                    return rootNode;\n                  }\n                  v8 = v24;\n                  goto LABEL_28;\n                }\n              LABEL_38:\n                Left->Left = v5;\n                goto LABEL_39;\n              }\n            LABEL_37:\n              v5->Left = v8;\n              goto LABEL_38;\n            }\n            v16 = v26;\n            goto LABEL_15;\n          }\n        LABEL_36:\n          v8->Left = v15;\n          goto LABEL_37;\n        }\n      LABEL_35:\n        v15->Left = v16;\n        goto LABEL_36;\n      }\n      v17 = CheckTreeNodeRotation(tnode, v12, finished);\n      v16 = v36;\n      v15 = v29;\n    } else {\n      v43 = v11->Right;\n      v39 = v9->Left;\n      v34 = v8->Left;\n      tnodeb = (__m128i *)v10->m128i_i64[0];\n      libmin_free((*deletedNode)->Name);\n      FreeElement((*deletedNode)->Item);\n      *(__m128i *)&(*deletedNode)->Item = _mm_loadu_si128(tnodeb + 1);\n      libmin_free(tnodeb);\n      v15 = v34;\n      v16 = v39;\n      v17 = v43;\n    }\n    v14 = *finished == 0;\n    v16->Left = v17;\n    if (v14) {\n      ++v16->Balance;\n      if (!v17) {\n        v18 = (unsigned short)*finished;\n        v15->Left = v16;\n        if (!(unsigned short)v18) {\n          ++v15->Balance;\n        LABEL_15:\n          v19 = CheckTreeNodeRotation(v15, v16, finished);\n          goto LABEL_24;\n        }\n        goto LABEL_36;\n      }\n      v13 = v17;\n      goto LABEL_56;\n    }\n    goto LABEL_35;\n  }\n  libmin_free((*deletedNode)->Name);\n  FreeElement((*deletedNode)->Item);\n  *(__m128i *)&(*deletedNode)->Item =\n      _mm_loadu_si128((const __m128i *)&Left->Item);\n  libmin_free(Left);\nLABEL_17:\n  v14 = *finished == 0;\n  rootNode->Left = v6;\n  if (!v14) return rootNode;\n  ++rootNode->Balance;\n  if (!v6) return rootNode;\n  Left = v6;\n  return CheckTreeNodeRotation(rootNode, Left, finished);\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<DeleteLeftMost>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    (%rsi),%r13\nmov    0x8(%rsi),%r15\ntest   %r13,%r13\nje     28a0 <DeleteLeftMost+0x180>\nmov    0x0(%r13),%r15\nmov    0x8(%r13),%rbx\nmov    %rdx,%r14\ntest   %r15,%r15\nje     2850 <DeleteLeftMost+0x130>\nmov    (%r15),%rbx\nmov    0x8(%r15),%rax\ntest   %rbx,%rbx\nje     29d8 <DeleteLeftMost+0x2b8>\nmov    (%rbx),%r8\nmov    0x8(%rbx),%rax\ntest   %r8,%r8\nje     2a18 <DeleteLeftMost+0x2f8>\nmov    (%r8),%r9\nmov    0x8(%r8),%rax\ntest   %r9,%r9\nje     28e8 <DeleteLeftMost+0x1c8>\nmov    (%r9),%r10\nmov    0x8(%r9),%rax\ntest   %r10,%r10\nje     2aa0 <DeleteLeftMost+0x380>\nmov    (%r10),%rsi\nmov    0x8(%r10),%rax\ntest   %rsi,%rsi\nje     2b30 <DeleteLeftMost+0x410>\nmov    %r10,0x10(%rsp)\nmov    %r9,0x8(%rsp)\nmov    %r8,(%rsp)\ncall   2720 <DeleteLeftMost>\nmov    0x10(%rsp),%r10\ncmpw   $0x0,(%r14)\nmov    (%rsp),%r8\nmov    0x8(%rsp),%r9\nmov    %rax,(%r10)\njne    29b8 <DeleteLeftMost+0x298>\naddw   $0x1,0x20(%r10)\ntest   %rax,%rax\nje     2b90 <DeleteLeftMost+0x470>\nmov    %r14,%rdx\nmov    %rax,%rsi\nmov    %r10,%rdi\nmov    %r9,0x8(%rsp)\nmov    %r8,(%rsp)\ncall   1c50 <CheckTreeNodeRotation>\nmov    0x8(%rsp),%r9\nmov    (%rsp),%r8\ncmpw   $0x0,(%r14)\nmov    %rax,(%r9)\njne    29bb <DeleteLeftMost+0x29b>\naddw   $0x1,0x20(%r9)\ntest   %rax,%rax\njne    2be1 <DeleteLeftMost+0x4c1>\nmovzwl (%r14),%eax\nmov    %r9,(%r8)\ntest   %ax,%ax\njne    29be <DeleteLeftMost+0x29e>\naddw   $0x1,0x20(%r8)\nmov    %r14,%rdx\nmov    %r9,%rsi\nmov    %r8,%rdi\ncall   1c50 <CheckTreeNodeRotation>\njmp    2929 <DeleteLeftMost+0x209>\nmov    (%rdi),%rax\nmov    0x18(%rax),%rdi\ncall   3ba0 <libmin_free>\nmov    (%r12),%rax\nmov    0x10(%rax),%rdi\ncall   1b10 <FreeElement>\nmov    (%r12),%rax\nmovdqu 0x10(%r13),%xmm1\nmov    %r13,%rdi\nmovups %xmm1,0x10(%rax)\ncall   3ba0 <libmin_free>\ncmpw   $0x0,(%r14)\nmov    %rbx,0x0(%rbp)\nje     28d0 <DeleteLeftMost+0x1b0>\nmov    %rbp,%r15\nadd    $0x28,%rsp\nmov    %r15,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnop\nmov    (%rdi),%rax\nmov    0x18(%rax),%rdi\ncall   3ba0 <libmin_free>\nmov    (%r12),%rax\nmov    0x10(%rax),%rdi\ncall   1b10 <FreeElement>\nmov    (%r12),%rax\nmovdqu 0x10(%rbp),%xmm0\nmov    %rbp,%rdi\nmovups %xmm0,0x10(%rax)\ncall   3ba0 <libmin_free>\njmp    288d <DeleteLeftMost+0x16d>\naddw   $0x1,0x20(%rbp)\ntest   %rbx,%rbx\nje     288a <DeleteLeftMost+0x16a>\nmov    %rbx,%r13\njmp    2995 <DeleteLeftMost+0x275>\nnopw   0x0(%rax,%rax,1)\nmov    (%rdi),%rdx\nmov    %rax,0x8(%rsp)\nmov    %r8,(%rsp)\nmov    0x18(%rdx),%rdi\ncall   3ba0 <libmin_free>\nmov    (%r12),%rdx\nmov    0x10(%rdx),%rdi\ncall   1b10 <FreeElement>\nmov    (%rsp),%r8\nmov    (%r12),%rdx\nmovdqu 0x10(%r8),%xmm4\nmov    %r8,%rdi\nmovups %xmm4,0x10(%rdx)\ncall   3ba0 <libmin_free>\nmov    0x8(%rsp),%rax\ncmpw   $0x0,(%r14)\nmov    %rax,(%rbx)\njne    29c1 <DeleteLeftMost+0x2a1>\naddw   $0x1,0x20(%rbx)\ntest   %rax,%rax\njne    2bd1 <DeleteLeftMost+0x4b1>\nmovzwl (%r14),%eax\nmov    %rbx,(%r15)\ntest   %ax,%ax\njne    29c4 <DeleteLeftMost+0x2a4>\naddw   $0x1,0x20(%r15)\nmov    %r14,%rdx\nmov    %rbx,%rsi\nmov    %r15,%rdi\ncall   1c50 <CheckTreeNodeRotation>\ncmpw   $0x0,(%r14)\nmov    %rax,0x0(%r13)\njne    29c8 <DeleteLeftMost+0x2a8>\naddw   $0x1,0x20(%r13)\ntest   %rax,%rax\njne    2bc1 <DeleteLeftMost+0x4a1>\nmovzwl (%r14),%eax\nmov    %r13,0x0(%rbp)\ntest   %ax,%ax\njne    288a <DeleteLeftMost+0x16a>\naddw   $0x1,0x20(%rbp)\nadd    $0x28,%rsp\nmov    %r14,%rdx\nmov    %r13,%rsi\nmov    %rbp,%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    1c50 <CheckTreeNodeRotation>\nnopl   0x0(%rax)\nmov    %r10,(%r9)\nmov    %r9,(%r8)\nmov    %r8,(%rbx)\nmov    %rbx,(%r15)\nmov    %r15,0x0(%r13)\nmov    %r13,0x0(%rbp)\njmp    288a <DeleteLeftMost+0x16a>\nnopl   0x0(%rax)\nmov    (%rdi),%rdx\nmov    %rax,(%rsp)\nmov    0x18(%rdx),%rdi\ncall   3ba0 <libmin_free>\nmov    (%r12),%rdx\nmov    0x10(%rdx),%rdi\ncall   1b10 <FreeElement>\nmov    (%r12),%rdx\nmovdqu 0x10(%r15),%xmm2\nmov    %r15,%rdi\nmovups %xmm2,0x10(%rdx)\ncall   3ba0 <libmin_free>\nmov    (%rsp),%rax\njmp    2965 <DeleteLeftMost+0x245>\nnopl   0x0(%rax)\nmov    (%rdi),%rdx\nmov    %rax,(%rsp)\nmov    0x18(%rdx),%rdi\ncall   3ba0 <libmin_free>\nmov    (%r12),%rdx\nmov    0x10(%rdx),%rdi\ncall   1b10 <FreeElement>\nmov    (%r12),%rdx\nmovdqu 0x10(%rbx),%xmm3\nmov    %rbx,%rdi\nmovups %xmm3,0x10(%rdx)\ncall   3ba0 <libmin_free>\nmov    (%rsp),%rax\ncmpw   $0x0,(%r14)\nmov    %rax,(%r15)\njne    29c4 <DeleteLeftMost+0x2a4>\naddw   $0x1,0x20(%r15)\ntest   %rax,%rax\njne    2bc9 <DeleteLeftMost+0x4a9>\nmovzwl (%r14),%eax\nmov    %r15,0x0(%r13)\ntest   %ax,%ax\njne    29c8 <DeleteLeftMost+0x2a8>\naddw   $0x1,0x20(%r13)\nmov    %r14,%rdx\nmov    %r15,%rsi\nmov    %r13,%rdi\ncall   1c50 <CheckTreeNodeRotation>\nmov    %rax,%rbx\njmp    287f <DeleteLeftMost+0x15f>\nnopl   0x0(%rax,%rax,1)\nmov    (%rdi),%rdx\nmov    %rax,0x10(%rsp)\nmov    %r8,(%rsp)\nmov    0x18(%rdx),%rdi\nmov    %r9,0x8(%rsp)\ncall   3ba0 <libmin_free>\nmov    (%r12),%rdx\nmov    0x10(%rdx),%rdi\ncall   1b10 <FreeElement>\nmov    0x8(%rsp),%r9\nmov    (%r12),%rdx\nmovdqu 0x10(%r9),%xmm5\nmov    %r9,%rdi\nmovups %xmm5,0x10(%rdx)\ncall   3ba0 <libmin_free>\nmov    (%rsp),%r8\nmov    0x10(%rsp),%rax\ncmpw   $0x0,(%r14)\nmov    %rax,(%r8)\njne    29be <DeleteLeftMost+0x29e>\naddw   $0x1,0x20(%r8)\ntest   %rax,%rax\njne    2bd9 <DeleteLeftMost+0x4b9>\nmovzwl (%r14),%eax\nmov    %r8,(%rbx)\ntest   %ax,%ax\njne    29c1 <DeleteLeftMost+0x2a1>\naddw   $0x1,0x20(%rbx)\nmov    %r14,%rdx\nmov    %r8,%rsi\nmov    %rbx,%rdi\ncall   1c50 <CheckTreeNodeRotation>\njmp    2a4e <DeleteLeftMost+0x32e>\nmov    (%rdi),%rdx\nmov    %rax,0x18(%rsp)\nmov    %r9,0x8(%rsp)\nmov    0x18(%rdx),%rdi\nmov    %r8,(%rsp)\nmov    %r10,0x10(%rsp)\ncall   3ba0 <libmin_free>\nmov    (%r12),%rdx\nmov    0x10(%rdx),%rdi\ncall   1b10 <FreeElement>\nmov    0x10(%rsp),%r10\nmov    (%r12),%rdx\nmovdqu 0x10(%r10),%xmm6\nmov    %r10,%rdi\nmovups %xmm6,0x10(%rdx)\ncall   3ba0 <libmin_free>\nmov    (%rsp),%r8\nmov    0x8(%rsp),%r9\nmov    0x18(%rsp),%rax\njmp    280a <DeleteLeftMost+0xea>\nnopw   0x0(%rax,%rax,1)\nmovzwl (%r14),%eax\nmov    %r10,(%r9)\ntest   %ax,%ax\njne    29bb <DeleteLeftMost+0x29b>\naddw   $0x1,0x20(%r9)\nmov    %r14,%rdx\nmov    %r10,%rsi\nmov    %r9,%rdi\nmov    %r8,(%rsp)\ncall   1c50 <CheckTreeNodeRotation>\nmov    (%rsp),%r8\njmp    2aeb <DeleteLeftMost+0x3cb>\nmov    %rax,%r15\njmp    2a82 <DeleteLeftMost+0x362>\nmov    %rax,%rbx\njmp    2957 <DeleteLeftMost+0x237>\nmov    %rax,%r8\njmp    2b1d <DeleteLeftMost+0x3fd>\nmov    %rax,%r9\njmp    283d <DeleteLeftMost+0x11d>\nmov    %rax,%r10\njmp    2ba6 <DeleteLeftMost+0x486>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DoubleLeftRotation", "content": "TreeNode *DoubleLeftRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = SingleRightRotation(rootNode->Right);\n    rootNode->Right = newRoot;\n    newRoot = SingleLeftRotation(rootNode);\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "DoubleLeftRotation", "address": "0x1c20", "label": "DoubleLeftRotation", "content": "TreeNode *__fastcall DoubleLeftRotation(TreeNode *rootNode)\n{\n  TreeNodeTag *Right; // rdx\n  TreeNode *result; // rax\n\n  Right = rootNode->Right;\n  result = Right->Left;\n  Right->Left = Right->Left->Right;\n  result->Right = Right;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *DoubleLeftRotation(TreeNode *rootNode) {\n  TreeNodeTag *Right;\n  TreeNode *result;\n  Right = rootNode->Right;\n  result = Right->Left;\n  Right->Left = Right->Left->Right;\n  result->Right = Right;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<DoubleLeftRotation>:\nendbr64\nmov    0x8(%rdi),%rdx\nmov    (%rdx),%rax\nmov    0x8(%rax),%rcx\nmov    %rcx,(%rdx)\nmov    %rdx,0x8(%rax)\nmov    (%rax),%rdx\nmov    %rdx,0x8(%rdi)\nmov    %rdi,(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DoubleRightRotation", "content": "TreeNode *DoubleRightRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = SingleLeftRotation(rootNode->Left);\n    rootNode->Left = newRoot;\n    newRoot = SingleRightRotation(rootNode);\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "DoubleRightRotation", "address": "0x1bf0", "label": "DoubleRightRotation", "content": "TreeNode *__fastcall DoubleRightRotation(TreeNode *rootNode)\n{\n  TreeNodeTag *Left; // rdx\n  TreeNode *result; // rax\n\n  Left = rootNode->Left;\n  result = rootNode->Left->Right;\n  Left->Right = result->Left;\n  result->Left = Left;\n  rootNode->Left = result->Right;\n  result->Right = rootNode;\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *DoubleRightRotation(TreeNode *rootNode) {\n  TreeNodeTag *Left;\n  TreeNode *result;\n  Left = rootNode->Left;\n  result = rootNode->Left->Right;\n  Left->Right = result->Left;\n  result->Left = Left;\n  rootNode->Left = result->Right;\n  result->Right = rootNode;\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<DoubleRightRotation>:\nendbr64\nmov    (%rdi),%rdx\nmov    0x8(%rdx),%rax\nmov    (%rax),%rcx\nmov    %rcx,0x8(%rdx)\nmov    %rdx,(%rax)\nmov    0x8(%rax),%rdx\nmov    %rdx,(%rdi)\nmov    %rdi,0x8(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "FindByElement", "content": "/*\n * A free AVLTree implementation written by Andrew Coleman\n * find out more cool things and licensing at http://penguincoder.org\n */\n#include \"libmin.h\"\n#include \"avlcore.h\"\n\nTreeNode *FindByElement(TreeNode *rootNode, Element Data)\n{\n    short comp;\n    TreeNode *Return;\n    \n    /* sanity checks */\n    if(Data == NULL)\n        return NULL;\n    else if(rootNode == NULL || rootNode->Item == NULL)  {\n        /* reached a leaf, and the data was not found */\n        return NULL;\n    }\n    \n    /* non recursive search because it really isn't neccessary right here */\n    Return = rootNode;\n    do    {\n        comp = Compare(Return->Item, Data);\n        if(comp < 0)\n            Return = Return->Left;\n        else if(comp > 0)\n            Return = Return->Right;\n    } while(Return != NULL && comp != 0);\n    return Return;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "FindByElement", "address": "0x1b20", "label": "FindByElement", "content": "TreeNode *__fastcall FindByElement(TreeNode *rootNode, Element Data)\n{\n  TreeNode *v2; // r12\n  int *Item; // rdi\n  __int16 v4; // ax\n\n  if ( !Data )\n    return 0LL;\n  v2 = rootNode;\n  if ( !rootNode )\n    return 0LL;\n  Item = rootNode->Item;\n  if ( !Item )\n    return 0LL;\n  while ( 1 )\n  {\n    v4 = Compare(Item, Data);\n    if ( v4 < 0 )\n    {\n      v2 = v2->Left;\n    }\n    else\n    {\n      if ( !v4 )\n        return v2;\n      v2 = v2->Right;\n    }\n    if ( !v2 )\n      break;\n    Item = v2->Item;\n  }\n  return v2;\n}\n"}, "pseudo_normalize": "TreeNode *FindByElement(TreeNode *rootNode, Element Data) {\n  TreeNode *v2;\n  int *Item;\n  short v4;\n  if (!Data) return 0LL;\n  v2 = rootNode;\n  if (!rootNode) return 0LL;\n  Item = rootNode->Item;\n  if (!Item) return 0LL;\n  while (1) {\n    v4 = Compare(Item, Data);\n    if (v4 < 0) {\n      v2 = v2->Left;\n    } else {\n      if (!v4) return v2;\n      v2 = v2->Right;\n    }\n    if (!v2) break;\n    Item = v2->Item;\n  }\n  return v2;\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<FindByElement>:\nendbr64\npush   %r12\npush   %rbx\nsub    $0x8,%rsp\ntest   %rsi,%rsi\nje     1b90 <FindByElement+0x70>\nmov    %rdi,%r12\ntest   %rdi,%rdi\nje     1b90 <FindByElement+0x70>\nmov    0x10(%rdi),%rdi\nmov    %rsi,%rbx\ntest   %rdi,%rdi\nje     1b90 <FindByElement+0x70>\nnopl   0x0(%rax)\nmov    %rbx,%rsi\ncall   1af0 <Compare>\ntest   %ax,%ax\njs     1b68 <FindByElement+0x48>\njne    1b80 <FindByElement+0x60>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nmov    (%r12),%r12\ntest   %r12,%r12\nje     1b57 <FindByElement+0x37>\ntest   %ax,%ax\nje     1b57 <FindByElement+0x37>\nmov    0x10(%r12),%rdi\njmp    1b48 <FindByElement+0x28>\nnopl   (%rax)\nmov    0x8(%r12),%r12\njmp    1b6c <FindByElement+0x4c>\nnopw   0x0(%rax,%rax,1)\nxor    %r12d,%r12d\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %r12\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "avl-tree/element.c", "function_name": "FreeElement", "content": "void FreeElement(Element Data)\n{\n    libmin_free(Data);\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "FreeElement", "address": "0x1b10", "label": "FreeElement", "content": "void __fastcall FreeElement(Element Data)\n{\n  libmin_free(Data);\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<FreeElement>:\nendbr64\njmp    3ba0 <libmin_free>\nnopl   0x0(%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "Height", "content": "long Height(TreeNode *rootNode)\n{\n    /* recursive function to determine the height by comparing the height of\n        the left and right child and returning the larger value */\n    long lresult = 0, rresult = 0;\n    /* either the tree is empty or we found a leaf */\n    if(rootNode == NULL)\n        return 0;\n    lresult = Height(rootNode->Left);\n    rresult = Height(rootNode->Right);\n    /* minimum height is 1, but that's probably correct */\n    return (lresult > rresult ? lresult : rresult) + 1;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "Height", "address": "0x30d0", "label": "Height", "content": "__int64 __fastcall Height(TreeNode *rootNode)\n{\n  __int64 v1; // rbx\n  TreeNodeTag *Left; // r13\n  TreeNodeTag *v3; // r14\n  __int64 v4; // rbp\n  TreeNode ****v5; // rdx\n  TreeNode ***v6; // r15\n  TreeNode **v7; // rbp\n  __int64 v8; // rbx\n  __int64 v9; // rax\n  TreeNode **v10; // r15\n  __int64 v11; // rbp\n  __int64 v12; // rbp\n  __int64 v13; // rax\n  TreeNode ***v14; // rdx\n  __int64 v15; // rbx\n  TreeNode **v16; // rbx\n  __int64 v17; // r15\n  __int64 v18; // r15\n  __int64 v19; // rax\n  TreeNode **v20; // rdx\n  __int64 v21; // rbx\n  __int64 v22; // rbx\n  __int64 v23; // rax\n  TreeNode ****Right; // rdx\n  __int64 v25; // rbp\n  TreeNode ***v26; // r15\n  __int64 v27; // r14\n  TreeNode **v28; // r14\n  __int64 v29; // rbp\n  __int64 v30; // rax\n  TreeNode **v31; // r15\n  __int64 v32; // r14\n  __int64 v33; // r14\n  __int64 v34; // rax\n  TreeNode **v35; // r15\n  __int64 v36; // rbp\n  __int64 v37; // rbp\n  __int64 v38; // rax\n  TreeNodeTag *v39; // r14\n  __int64 v40; // rbx\n  TreeNode ****v41; // rdx\n  __int64 v42; // r13\n  TreeNode ***v43; // r15\n  TreeNode **v44; // rbx\n  __int64 v45; // r13\n  __int64 v46; // rax\n  TreeNode **v47; // r15\n  __int64 v48; // rbx\n  __int64 v49; // rbx\n  __int64 v50; // rax\n  TreeNode **v51; // r15\n  __int64 v52; // r13\n  __int64 v53; // r13\n  __int64 v54; // rax\n  TreeNode ****v55; // rdx\n  __int64 v56; // rbx\n  TreeNode ***v57; // r15\n  __int64 v58; // r14\n  TreeNode **v59; // r14\n  __int64 v60; // rbx\n  __int64 v61; // rax\n  TreeNode **v62; // r15\n  __int64 v63; // r14\n  __int64 v64; // r14\n  __int64 v65; // rax\n  TreeNode **v66; // r15\n  __int64 v67; // rbx\n  __int64 v68; // rbx\n  __int64 v69; // rax\n  TreeNodeTag *v70; // r12\n  __int64 v71; // rax\n  TreeNodeTag *v72; // r14\n  __int64 v73; // rbp\n  TreeNode ****v74; // rdx\n  __int64 v75; // r13\n  TreeNode ***v76; // r15\n  TreeNode **v77; // rbp\n  __int64 v78; // r13\n  __int64 v79; // rax\n  TreeNode **v80; // r15\n  __int64 v81; // rbp\n  __int64 v82; // rbp\n  __int64 v83; // rax\n  TreeNode ***v84; // rdx\n  __int64 v85; // r13\n  TreeNode **v86; // r13\n  __int64 v87; // r15\n  __int64 v88; // r15\n  __int64 v89; // rax\n  TreeNode **v90; // rdx\n  __int64 v91; // r13\n  __int64 v92; // r13\n  __int64 v93; // rax\n  TreeNode ****v94; // rdx\n  __int64 v95; // rbp\n  TreeNode ***v96; // r15\n  __int64 v97; // r14\n  TreeNode **v98; // r14\n  __int64 v99; // rbp\n  __int64 v100; // rax\n  TreeNode **v101; // r15\n  __int64 v102; // r14\n  __int64 v103; // r14\n  __int64 v104; // rax\n  TreeNode ***v105; // rdx\n  __int64 v106; // rbp\n  TreeNode **v107; // rbp\n  __int64 v108; // r15\n  __int64 v109; // r15\n  __int64 v110; // rax\n  TreeNode **v111; // rdx\n  __int64 v112; // rbp\n  __int64 v113; // rbp\n  __int64 v114; // rax\n  TreeNodeTag *v115; // r14\n  __int64 v116; // rax\n  TreeNode ****v117; // rdx\n  __int64 v118; // r13\n  TreeNode ***v119; // r15\n  __int64 v120; // r12\n  TreeNode **v121; // r12\n  __int64 v122; // r13\n  __int64 v123; // rax\n  TreeNode **v124; // r15\n  __int64 v125; // r12\n  __int64 v126; // r12\n  __int64 v127; // rax\n  TreeNode ***v128; // rdx\n  __int64 v129; // r13\n  TreeNode **v130; // r13\n  __int64 v131; // r15\n  __int64 v132; // r15\n  __int64 v133; // rax\n  TreeNode **v134; // rdx\n  __int64 v135; // r13\n  __int64 v136; // r13\n  __int64 v137; // rax\n  TreeNodeTag *v138; // r12\n  __int64 v139; // rax\n  TreeNode **p_Left; // r15\n  __int64 v141; // r14\n  __int64 v142; // r14\n  __int64 v143; // rax\n  TreeNode ***v144; // r12\n  __int64 v145; // rax\n  __int64 v146; // r15\n  __int64 v147; // r15\n  __int64 v148; // rax\n  TreeNode **v149; // rdx\n  __int64 v150; // rax\n  __int64 v151; // r12\n  __int64 v152; // rax\n  TreeNodeTag *v154; // [rsp+0h] [rbp-40h]\n  TreeNode ****v155; // [rsp+0h] [rbp-40h]\n  TreeNode ***v156; // [rsp+0h] [rbp-40h]\n  TreeNode **v157; // [rsp+0h] [rbp-40h]\n  TreeNode ****v158; // [rsp+0h] [rbp-40h]\n  TreeNode ****v159; // [rsp+0h] [rbp-40h]\n  TreeNodeTag *v160; // [rsp+0h] [rbp-40h]\n  TreeNode ****v161; // [rsp+0h] [rbp-40h]\n  TreeNode ****v162; // [rsp+0h] [rbp-40h]\n  TreeNode ****v163; // [rsp+0h] [rbp-40h]\n  TreeNodeTag *v164; // [rsp+0h] [rbp-40h]\n  TreeNode ****v165; // [rsp+0h] [rbp-40h]\n  TreeNode ***v166; // [rsp+0h] [rbp-40h]\n  TreeNode **v167; // [rsp+0h] [rbp-40h]\n  TreeNode ****v168; // [rsp+0h] [rbp-40h]\n  TreeNode ****v169; // [rsp+0h] [rbp-40h]\n  TreeNode ***v170; // [rsp+0h] [rbp-40h]\n  TreeNode **v171; // [rsp+0h] [rbp-40h]\n  TreeNodeTag *v172; // [rsp+0h] [rbp-40h]\n  TreeNode ****v173; // [rsp+0h] [rbp-40h]\n  TreeNode ***v174; // [rsp+0h] [rbp-40h]\n  TreeNode **v175; // [rsp+0h] [rbp-40h]\n  TreeNode **v176; // [rsp+0h] [rbp-40h]\n  TreeNode **v177; // [rsp+0h] [rbp-40h]\n\n  if ( !rootNode )\n    return 0LL;\n  v1 = 0LL;\n  Left = rootNode->Left;\n  if ( rootNode->Left )\n  {\n    v3 = Left->Left;\n    v4 = 0LL;\n    if ( Left->Left )\n    {\n      v5 = (TreeNode ****)v3->Left;\n      if ( v3->Left )\n      {\n        v6 = *v5;\n        if ( *v5 )\n        {\n          v7 = *v6;\n          if ( *v6 )\n          {\n            v154 = v3->Left;\n            v8 = Height(*v7);\n            v9 = Height(v7[1]);\n            v5 = (TreeNode ****)v154;\n            if ( v8 < v9 )\n              v8 = v9;\n            v1 = v8 + 1;\n          }\n          v10 = v6[1];\n          v11 = 0LL;\n          if ( v10 )\n          {\n            v155 = v5;\n            v12 = Height(*v10);\n            v13 = Height(v10[1]);\n            v5 = v155;\n            if ( v12 < v13 )\n              v12 = v13;\n            v11 = v12 + 1;\n          }\n          if ( v11 < v1 )\n            v11 = v1;\n          v4 = v11 + 1;\n        }\n        v14 = v5[1];\n        v15 = 0LL;\n        if ( v14 )\n        {\n          v16 = *v14;\n          v17 = 0LL;\n          if ( *v14 )\n          {\n            v156 = v14;\n            v18 = Height(*v16);\n            v19 = Height(v16[1]);\n            v14 = v156;\n            if ( v18 < v19 )\n              v18 = v19;\n            v17 = v18 + 1;\n          }\n          v20 = v14[1];\n          v21 = 0LL;\n          if ( v20 )\n          {\n            v157 = v20;\n            v22 = Height(*v20);\n            v23 = Height(v157[1]);\n            if ( v22 < v23 )\n              v22 = v23;\n            v21 = v22 + 1;\n          }\n          if ( v21 < v17 )\n            v21 = v17;\n          v15 = v21 + 1;\n        }\n        if ( v15 < v4 )\n          v15 = v4;\n        v1 = v15 + 1;\n      }\n      Right = (TreeNode ****)v3->Right;\n      v25 = 0LL;\n      if ( Right )\n      {\n        v26 = *Right;\n        v27 = 0LL;\n        if ( *Right )\n        {\n          v28 = *v26;\n          if ( *v26 )\n          {\n            v158 = Right;\n            v29 = Height(*v28);\n            v30 = Height(v28[1]);\n            Right = v158;\n            if ( v29 < v30 )\n              v29 = v30;\n            v25 = v29 + 1;\n          }\n          v31 = v26[1];\n          v32 = 0LL;\n          if ( v31 )\n          {\n            v159 = Right;\n            v33 = Height(*v31);\n            v34 = Height(v31[1]);\n            Right = v159;\n            if ( v33 < v34 )\n              v33 = v34;\n            v32 = v33 + 1;\n          }\n          if ( v32 < v25 )\n            v32 = v25;\n          v27 = v32 + 1;\n        }\n        v35 = (TreeNode **)Right[1];\n        v36 = 0LL;\n        if ( v35 )\n        {\n          v37 = Height(*v35);\n          v38 = Height(v35[1]);\n          if ( v37 < v38 )\n            v37 = v38;\n          v36 = v37 + 1;\n        }\n        if ( v36 < v27 )\n          v36 = v27;\n        v25 = v36 + 1;\n      }\n      if ( v25 < v1 )\n        v25 = v1;\n      v4 = v25 + 1;\n    }\n    v39 = Left->Right;\n    v40 = 0LL;\n    if ( v39 )\n    {\n      v41 = (TreeNode ****)v39->Left;\n      v42 = 0LL;\n      if ( v39->Left )\n      {\n        v43 = *v41;\n        if ( *v41 )\n        {\n          v44 = *v43;\n          if ( *v43 )\n          {\n            v160 = v39->Left;\n            v45 = Height(*v44);\n            v46 = Height(v44[1]);\n            v41 = (TreeNode ****)v160;\n            if ( v45 < v46 )\n              v45 = v46;\n            v42 = v45 + 1;\n          }\n          v47 = v43[1];\n          v48 = 0LL;\n          if ( v47 )\n          {\n            v161 = v41;\n            v49 = Height(*v47);\n            v50 = Height(v47[1]);\n            v41 = v161;\n            if ( v49 < v50 )\n              v49 = v50;\n            v48 = v49 + 1;\n          }\n          if ( v48 < v42 )\n            v48 = v42;\n          v40 = v48 + 1;\n        }\n        v51 = (TreeNode **)v41[1];\n        v52 = 0LL;\n        if ( v51 )\n        {\n          v53 = Height(*v51);\n          v54 = Height(v51[1]);\n          if ( v53 < v54 )\n            v53 = v54;\n          v52 = v53 + 1;\n        }\n        if ( v52 < v40 )\n          v52 = v40;\n        v42 = v52 + 1;\n      }\n      v55 = (TreeNode ****)v39->Right;\n      v56 = 0LL;\n      if ( v55 )\n      {\n        v57 = *v55;\n        v58 = 0LL;\n        if ( *v55 )\n        {\n          v59 = *v57;\n          if ( *v57 )\n          {\n            v162 = v55;\n            v60 = Height(*v59);\n            v61 = Height(v59[1]);\n            v55 = v162;\n            if ( v60 < v61 )\n              v60 = v61;\n            v56 = v60 + 1;\n          }\n          v62 = v57[1];\n          v63 = 0LL;\n          if ( v62 )\n          {\n            v163 = v55;\n            v64 = Height(*v62);\n            v65 = Height(v62[1]);\n            v55 = v163;\n            if ( v64 < v65 )\n              v64 = v65;\n            v63 = v64 + 1;\n          }\n          if ( v63 < v56 )\n            v63 = v56;\n          v58 = v63 + 1;\n        }\n        v66 = (TreeNode **)v55[1];\n        v67 = 0LL;\n        if ( v66 )\n        {\n          v68 = Height(*v66);\n          v69 = Height(v66[1]);\n          if ( v68 < v69 )\n            v68 = v69;\n          v67 = v68 + 1;\n        }\n        if ( v67 < v58 )\n          v67 = v58;\n        v56 = v67 + 1;\n      }\n      if ( v56 < v42 )\n        v56 = v42;\n      v40 = v56 + 1;\n    }\n    if ( v40 < v4 )\n      v40 = v4;\n    v1 = v40 + 1;\n  }\n  v70 = rootNode->Right;\n  v71 = 0LL;\n  if ( v70 )\n  {\n    v72 = v70->Left;\n    v73 = 0LL;\n    if ( v70->Left )\n    {\n      v74 = (TreeNode ****)v72->Left;\n      v75 = 0LL;\n      if ( v72->Left )\n      {\n        v76 = *v74;\n        if ( *v74 )\n        {\n          v77 = *v76;\n          if ( *v76 )\n          {\n            v164 = v72->Left;\n            v78 = Height(*v77);\n            v79 = Height(v77[1]);\n            v74 = (TreeNode ****)v164;\n            if ( v78 < v79 )\n              v78 = v79;\n            v75 = v78 + 1;\n          }\n          v80 = v76[1];\n          v81 = 0LL;\n          if ( v80 )\n          {\n            v165 = v74;\n            v82 = Height(*v80);\n            v83 = Height(v80[1]);\n            v74 = v165;\n            if ( v82 < v83 )\n              v82 = v83;\n            v81 = v82 + 1;\n          }\n          if ( v81 < v75 )\n            v81 = v75;\n          v73 = v81 + 1;\n        }\n        v84 = v74[1];\n        v85 = 0LL;\n        if ( v84 )\n        {\n          v86 = *v84;\n          v87 = 0LL;\n          if ( *v84 )\n          {\n            v166 = v84;\n            v88 = Height(*v86);\n            v89 = Height(v86[1]);\n            v84 = v166;\n            if ( v88 < v89 )\n              v88 = v89;\n            v87 = v88 + 1;\n          }\n          v90 = v84[1];\n          v91 = 0LL;\n          if ( v90 )\n          {\n            v167 = v90;\n            v92 = Height(*v90);\n            v93 = Height(v167[1]);\n            if ( v92 < v93 )\n              v92 = v93;\n            v91 = v92 + 1;\n          }\n          if ( v91 < v87 )\n            v91 = v87;\n          v85 = v91 + 1;\n        }\n        if ( v85 < v73 )\n          v85 = v73;\n        v75 = v85 + 1;\n      }\n      v94 = (TreeNode ****)v72->Right;\n      v95 = 0LL;\n      if ( v94 )\n      {\n        v96 = *v94;\n        v97 = 0LL;\n        if ( *v94 )\n        {\n          v98 = *v96;\n          if ( *v96 )\n          {\n            v168 = v94;\n            v99 = Height(*v98);\n            v100 = Height(v98[1]);\n            v94 = v168;\n            if ( v99 < v100 )\n              v99 = v100;\n            v95 = v99 + 1;\n          }\n          v101 = v96[1];\n          v102 = 0LL;\n          if ( v101 )\n          {\n            v169 = v94;\n            v103 = Height(*v101);\n            v104 = Height(v101[1]);\n            v94 = v169;\n            if ( v103 < v104 )\n              v103 = v104;\n            v102 = v103 + 1;\n          }\n          if ( v102 < v95 )\n            v102 = v95;\n          v97 = v102 + 1;\n        }\n        v105 = v94[1];\n        v106 = 0LL;\n        if ( v105 )\n        {\n          v107 = *v105;\n          v108 = 0LL;\n          if ( *v105 )\n          {\n            v170 = v105;\n            v109 = Height(*v107);\n            v110 = Height(v107[1]);\n            v105 = v170;\n            if ( v109 < v110 )\n              v109 = v110;\n            v108 = v109 + 1;\n          }\n          v111 = v105[1];\n          v112 = 0LL;\n          if ( v111 )\n          {\n            v171 = v111;\n            v113 = Height(*v111);\n            v114 = Height(v171[1]);\n            if ( v113 < v114 )\n              v113 = v114;\n            v112 = v113 + 1;\n          }\n          if ( v112 < v108 )\n            v112 = v108;\n          v106 = v112 + 1;\n        }\n        if ( v106 < v97 )\n          v106 = v97;\n        v95 = v106 + 1;\n      }\n      if ( v95 < v75 )\n        v95 = v75;\n      v73 = v95 + 1;\n    }\n    v115 = v70->Right;\n    v116 = 0LL;\n    if ( v115 )\n    {\n      v117 = (TreeNode ****)v115->Left;\n      v118 = 0LL;\n      if ( v115->Left )\n      {\n        v119 = *v117;\n        v120 = 0LL;\n        if ( *v117 )\n        {\n          v121 = *v119;\n          if ( *v119 )\n          {\n            v172 = v115->Left;\n            v122 = Height(*v121);\n            v123 = Height(v121[1]);\n            v117 = (TreeNode ****)v172;\n            if ( v122 < v123 )\n              v122 = v123;\n            v118 = v122 + 1;\n          }\n          v124 = v119[1];\n          v125 = 0LL;\n          if ( v124 )\n          {\n            v173 = v117;\n            v126 = Height(*v124);\n            v127 = Height(v124[1]);\n            v117 = v173;\n            if ( v126 < v127 )\n              v126 = v127;\n            v125 = v126 + 1;\n          }\n          if ( v125 < v118 )\n            v125 = v118;\n          v120 = v125 + 1;\n        }\n        v128 = v117[1];\n        v129 = 0LL;\n        if ( v128 )\n        {\n          v130 = *v128;\n          v131 = 0LL;\n          if ( *v128 )\n          {\n            v174 = v128;\n            v132 = Height(*v130);\n            v133 = Height(v130[1]);\n            v128 = v174;\n            if ( v132 < v133 )\n              v132 = v133;\n            v131 = v132 + 1;\n          }\n          v134 = v128[1];\n          v135 = 0LL;\n          if ( v134 )\n          {\n            v175 = v134;\n            v136 = Height(*v134);\n            v137 = Height(v175[1]);\n            if ( v136 < v137 )\n              v136 = v137;\n            v135 = v136 + 1;\n          }\n          if ( v135 < v131 )\n            v135 = v131;\n          v129 = v135 + 1;\n        }\n        if ( v129 < v120 )\n          v129 = v120;\n        v118 = v129 + 1;\n      }\n      v138 = v115->Right;\n      v139 = 0LL;\n      if ( v138 )\n      {\n        p_Left = &v138->Left->Left;\n        v141 = 0LL;\n        if ( v138->Left )\n        {\n          v142 = Height(*p_Left);\n          v143 = Height(p_Left[1]);\n          if ( v142 < v143 )\n            v142 = v143;\n          v141 = v142 + 1;\n        }\n        v144 = (TreeNode ***)v138->Right;\n        v145 = 0LL;\n        if ( v144 )\n        {\n          v146 = 0LL;\n          if ( *v144 )\n          {\n            v176 = *v144;\n            v147 = Height(**v144);\n            v148 = Height(v176[1]);\n            if ( v147 < v148 )\n              v147 = v148;\n            v146 = v147 + 1;\n          }\n          v149 = v144[1];\n          v150 = 0LL;\n          if ( v149 )\n          {\n            v177 = v144[1];\n            v151 = Height(*v149);\n            v152 = Height(v177[1]);\n            if ( v151 >= v152 )\n              v152 = v151;\n            v150 = v152 + 1;\n          }\n          if ( v150 < v146 )\n            v150 = v146;\n          v145 = v150 + 1;\n        }\n        if ( v145 < v141 )\n          v145 = v141;\n        v139 = v145 + 1;\n      }\n      if ( v139 < v118 )\n        v139 = v118;\n      v116 = v139 + 1;\n    }\n    if ( v116 < v73 )\n      v116 = v73;\n    v71 = v116 + 1;\n  }\n  if ( v71 < v1 )\n    v71 = v1;\n  return v71 + 1;\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<Height>:\nendbr64\ntest   %rdi,%rdi\nje     3900 <Height+0x830>\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x18,%rsp\nmov    (%rdi),%r13\ntest   %r13,%r13\nje     3486 <Height+0x3b6>\nmov    0x0(%r13),%r14\nxor    %ebp,%ebp\ntest   %r14,%r14\nje     32e4 <Height+0x214>\nmov    (%r14),%rdx\ntest   %rdx,%rdx\nje     3219 <Height+0x149>\nmov    (%rdx),%r15\ntest   %r15,%r15\nje     3190 <Height+0xc0>\nmov    (%r15),%rbp\ntest   %rbp,%rbp\nje     3151 <Height+0x81>\nmov    0x0(%rbp),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%rbp),%rdi\nmov    %rax,%rbx\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbx\ncmovl  %rax,%rbx\nadd    $0x1,%rbx\nmov    0x8(%r15),%r15\nxor    %ebp,%ebp\ntest   %r15,%r15\nje     3185 <Height+0xb5>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%rbp\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbp\ncmovl  %rax,%rbp\nadd    $0x1,%rbp\ncmp    %rbx,%rbp\ncmovl  %rbx,%rbp\nadd    $0x1,%rbp\nmov    0x8(%rdx),%rdx\nxor    %ebx,%ebx\ntest   %rdx,%rdx\nje     320e <Height+0x13e>\nmov    (%rdx),%rbx\nxor    %r15d,%r15d\ntest   %rbx,%rbx\nje     31cf <Height+0xff>\nmov    (%rbx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%rbx),%rdi\nmov    %rax,%r15\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r15\ncmovl  %rax,%r15\nadd    $0x1,%r15\nmov    0x8(%rdx),%rdx\nxor    %ebx,%ebx\ntest   %rdx,%rdx\nje     3203 <Height+0x133>\nmov    (%rdx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\nmov    %rax,%rbx\nmov    0x8(%rdx),%rdi\ncall   30d0 <Height>\ncmp    %rax,%rbx\ncmovl  %rax,%rbx\nadd    $0x1,%rbx\ncmp    %r15,%rbx\ncmovl  %r15,%rbx\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\ncmovl  %rbp,%rbx\nadd    $0x1,%rbx\nmov    0x8(%r14),%rdx\nxor    %ebp,%ebp\ntest   %rdx,%rdx\nje     32d9 <Height+0x209>\nmov    (%rdx),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     32a4 <Height+0x1d4>\nmov    (%r15),%r14\ntest   %r14,%r14\nje     3264 <Height+0x194>\nmov    (%r14),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r14),%rdi\nmov    %rax,%rbp\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbp\ncmovl  %rax,%rbp\nadd    $0x1,%rbp\nmov    0x8(%r15),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     3299 <Height+0x1c9>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%r14\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r14\ncmovl  %rax,%r14\nadd    $0x1,%r14\ncmp    %rbp,%r14\ncmovl  %rbp,%r14\nadd    $0x1,%r14\nmov    0x8(%rdx),%r15\nxor    %ebp,%ebp\ntest   %r15,%r15\nje     32ce <Height+0x1fe>\nmov    (%r15),%rdi\ncall   30d0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%rbp\ncall   30d0 <Height>\ncmp    %rax,%rbp\ncmovl  %rax,%rbp\nadd    $0x1,%rbp\ncmp    %r14,%rbp\ncmovl  %r14,%rbp\nadd    $0x1,%rbp\ncmp    %rbx,%rbp\ncmovl  %rbx,%rbp\nadd    $0x1,%rbp\nmov    0x8(%r13),%r14\nxor    %ebx,%ebx\ntest   %r14,%r14\nje     347b <Height+0x3ab>\nmov    (%r14),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     33b0 <Height+0x2e0>\nmov    (%rdx),%r15\ntest   %r15,%r15\nje     337a <Height+0x2aa>\nmov    (%r15),%rbx\ntest   %rbx,%rbx\nje     333b <Height+0x26b>\nmov    (%rbx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%rbx),%rdi\nmov    %rax,%r13\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r13\ncmovl  %rax,%r13\nadd    $0x1,%r13\nmov    0x8(%r15),%r15\nxor    %ebx,%ebx\ntest   %r15,%r15\nje     336f <Height+0x29f>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%rbx\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbx\ncmovl  %rax,%rbx\nadd    $0x1,%rbx\ncmp    %r13,%rbx\ncmovl  %r13,%rbx\nadd    $0x1,%rbx\nmov    0x8(%rdx),%r15\nxor    %r13d,%r13d\ntest   %r15,%r15\nje     33a5 <Height+0x2d5>\nmov    (%r15),%rdi\ncall   30d0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%r13\ncall   30d0 <Height>\ncmp    %rax,%r13\ncmovl  %rax,%r13\nadd    $0x1,%r13\ncmp    %rbx,%r13\ncmovl  %rbx,%r13\nadd    $0x1,%r13\nmov    0x8(%r14),%rdx\nxor    %ebx,%ebx\ntest   %rdx,%rdx\nje     3470 <Height+0x3a0>\nmov    (%rdx),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     343b <Height+0x36b>\nmov    (%r15),%r14\ntest   %r14,%r14\nje     33fb <Height+0x32b>\nmov    (%r14),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r14),%rdi\nmov    %rax,%rbx\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbx\ncmovl  %rax,%rbx\nadd    $0x1,%rbx\nmov    0x8(%r15),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     3430 <Height+0x360>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%r14\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r14\ncmovl  %rax,%r14\nadd    $0x1,%r14\ncmp    %rbx,%r14\ncmovl  %rbx,%r14\nadd    $0x1,%r14\nmov    0x8(%rdx),%r15\nxor    %ebx,%ebx\ntest   %r15,%r15\nje     3465 <Height+0x395>\nmov    (%r15),%rdi\ncall   30d0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%rbx\ncall   30d0 <Height>\ncmp    %rax,%rbx\ncmovl  %rax,%rbx\nadd    $0x1,%rbx\ncmp    %r14,%rbx\ncmovl  %r14,%rbx\nadd    $0x1,%rbx\ncmp    %r13,%rbx\ncmovl  %r13,%rbx\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\ncmovl  %rbp,%rbx\nadd    $0x1,%rbx\nmov    0x8(%r12),%r12\nxor    %eax,%eax\ntest   %r12,%r12\nje     38de <Height+0x80e>\nmov    (%r12),%r14\nxor    %ebp,%ebp\ntest   %r14,%r14\nje     36d9 <Height+0x609>\nmov    (%r14),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     35b9 <Height+0x4e9>\nmov    (%rdx),%r15\ntest   %r15,%r15\nje     352d <Height+0x45d>\nmov    (%r15),%rbp\ntest   %rbp,%rbp\nje     34ee <Height+0x41e>\nmov    0x0(%rbp),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%rbp),%rdi\nmov    %rax,%r13\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r13\ncmovl  %rax,%r13\nadd    $0x1,%r13\nmov    0x8(%r15),%r15\nxor    %ebp,%ebp\ntest   %r15,%r15\nje     3522 <Height+0x452>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%rbp\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbp\ncmovl  %rax,%rbp\nadd    $0x1,%rbp\ncmp    %r13,%rbp\ncmovl  %r13,%rbp\nadd    $0x1,%rbp\nmov    0x8(%rdx),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     35ae <Height+0x4de>\nmov    (%rdx),%r13\nxor    %r15d,%r15d\ntest   %r13,%r13\nje     356e <Height+0x49e>\nmov    0x0(%r13),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r13),%rdi\nmov    %rax,%r15\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r15\ncmovl  %rax,%r15\nadd    $0x1,%r15\nmov    0x8(%rdx),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     35a3 <Height+0x4d3>\nmov    (%rdx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\nmov    %rax,%r13\nmov    0x8(%rdx),%rdi\ncall   30d0 <Height>\ncmp    %rax,%r13\ncmovl  %rax,%r13\nadd    $0x1,%r13\ncmp    %r15,%r13\ncmovl  %r15,%r13\nadd    $0x1,%r13\ncmp    %rbp,%r13\ncmovl  %rbp,%r13\nadd    $0x1,%r13\nmov    0x8(%r14),%rdx\nxor    %ebp,%ebp\ntest   %rdx,%rdx\nje     36ce <Height+0x5fe>\nmov    (%rdx),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     3644 <Height+0x574>\nmov    (%r15),%r14\ntest   %r14,%r14\nje     3604 <Height+0x534>\nmov    (%r14),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r14),%rdi\nmov    %rax,%rbp\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbp\ncmovl  %rax,%rbp\nadd    $0x1,%rbp\nmov    0x8(%r15),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     3639 <Height+0x569>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%r14\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r14\ncmovl  %rax,%r14\nadd    $0x1,%r14\ncmp    %rbp,%r14\ncmovl  %rbp,%r14\nadd    $0x1,%r14\nmov    0x8(%rdx),%rdx\nxor    %ebp,%ebp\ntest   %rdx,%rdx\nje     36c3 <Height+0x5f3>\nmov    (%rdx),%rbp\nxor    %r15d,%r15d\ntest   %rbp,%rbp\nje     3684 <Height+0x5b4>\nmov    0x0(%rbp),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%rbp),%rdi\nmov    %rax,%r15\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r15\ncmovl  %rax,%r15\nadd    $0x1,%r15\nmov    0x8(%rdx),%rdx\nxor    %ebp,%ebp\ntest   %rdx,%rdx\nje     36b8 <Height+0x5e8>\nmov    (%rdx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\nmov    %rax,%rbp\nmov    0x8(%rdx),%rdi\ncall   30d0 <Height>\ncmp    %rax,%rbp\ncmovl  %rax,%rbp\nadd    $0x1,%rbp\ncmp    %r15,%rbp\ncmovl  %r15,%rbp\nadd    $0x1,%rbp\ncmp    %r14,%rbp\ncmovl  %r14,%rbp\nadd    $0x1,%rbp\ncmp    %r13,%rbp\ncmovl  %r13,%rbp\nadd    $0x1,%rbp\nmov    0x8(%r12),%r14\nxor    %eax,%eax\ntest   %r14,%r14\nje     38d3 <Height+0x803>\nmov    (%r14),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     3802 <Height+0x732>\nmov    (%rdx),%r15\nxor    %r12d,%r12d\ntest   %r15,%r15\nje     3776 <Height+0x6a6>\nmov    (%r15),%r12\ntest   %r12,%r12\nje     3736 <Height+0x666>\nmov    (%r12),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r12),%rdi\nmov    %rax,%r13\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r13\ncmovl  %rax,%r13\nadd    $0x1,%r13\nmov    0x8(%r15),%r15\nxor    %r12d,%r12d\ntest   %r15,%r15\nje     376b <Height+0x69b>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%r12\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r12\ncmovl  %rax,%r12\nadd    $0x1,%r12\ncmp    %r13,%r12\ncmovl  %r13,%r12\nadd    $0x1,%r12\nmov    0x8(%rdx),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     37f7 <Height+0x727>\nmov    (%rdx),%r13\nxor    %r15d,%r15d\ntest   %r13,%r13\nje     37b7 <Height+0x6e7>\nmov    0x0(%r13),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%r13),%rdi\nmov    %rax,%r15\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r15\ncmovl  %rax,%r15\nadd    $0x1,%r15\nmov    0x8(%rdx),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     37ec <Height+0x71c>\nmov    (%rdx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\nmov    %rax,%r13\nmov    0x8(%rdx),%rdi\ncall   30d0 <Height>\ncmp    %rax,%r13\ncmovl  %rax,%r13\nadd    $0x1,%r13\ncmp    %r15,%r13\ncmovl  %r15,%r13\nadd    $0x1,%r13\ncmp    %r12,%r13\ncmovl  %r12,%r13\nadd    $0x1,%r13\nmov    0x8(%r14),%r12\nxor    %eax,%eax\ntest   %r12,%r12\nje     38c8 <Height+0x7f8>\nmov    (%r12),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     383c <Height+0x76c>\nmov    (%r15),%rdi\ncall   30d0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%r14\ncall   30d0 <Height>\ncmp    %rax,%r14\ncmovl  %rax,%r14\nadd    $0x1,%r14\nmov    0x8(%r12),%r12\nxor    %eax,%eax\ntest   %r12,%r12\nje     38bd <Height+0x7ed>\nmov    (%r12),%rdx\nxor    %r15d,%r15d\ntest   %rdx,%rdx\nje     387d <Height+0x7ad>\nmov    (%rdx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\nmov    %rax,%r15\nmov    0x8(%rdx),%rdi\ncall   30d0 <Height>\ncmp    %rax,%r15\ncmovl  %rax,%r15\nadd    $0x1,%r15\nmov    0x8(%r12),%rdx\nxor    %eax,%eax\ntest   %rdx,%rdx\nje     38b2 <Height+0x7e2>\nmov    (%rdx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   30d0 <Height>\nmov    0x8(%rsp),%rdx\nmov    %rax,%r12\nmov    0x8(%rdx),%rdi\ncall   30d0 <Height>\ncmp    %rax,%r12\ncmovge %r12,%rax\nadd    $0x1,%rax\ncmp    %r15,%rax\ncmovl  %r15,%rax\nadd    $0x1,%rax\ncmp    %r14,%rax\ncmovl  %r14,%rax\nadd    $0x1,%rax\ncmp    %r13,%rax\ncmovl  %r13,%rax\nadd    $0x1,%rax\ncmp    %rbp,%rax\ncmovl  %rbp,%rax\nadd    $0x1,%rax\ncmp    %rbx,%rax\ncmovl  %rbx,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\nadd    $0x1,%rax\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "Insert", "content": "TreeNode *Insert(TreeNode *tnode, Element Item, char *Name)\n{\n    /* flag for the recursive function */\n    short done = 0;\n    /* run and return the recursive insert */\n    return InsertNode(tnode, Item, Name, &done);\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "Insert", "address": "0x1f40", "label": "Insert", "content": "TreeNode *__fastcall Insert(TreeNode *tnode, Element Item, char *Name)\n{\n  __m128 v3; // xmm0\n  __int16 v4; // ax\n  TreeNode *inserted; // rax\n  TreeNode *v6; // rsi\n  __int16 v7; // dx\n  TreeNode *result; // rax\n  __m128i v9; // xmm0\n  TreeNode *v10; // rax\n  __int16 v11; // dx\n  __m128i Namea; // [rsp+0h] [rbp-38h] BYREF\n  __int16 done; // [rsp+16h] [rbp-22h] BYREF\n  unsigned __int64 v14; // [rsp+18h] [rbp-20h]\n\n  Namea.m128i_i64[0] = (__int64)Name;\n  v14 = __readfsqword(0x28u);\n  v3 = _mm_loadh_ps((const double *)Namea.m128i_i64);\n  done = 0;\n  if ( tnode )\n  {\n    v4 = Compare(Item, tnode->Item);\n    if ( v4 >= 0 )\n    {\n      if ( v4 )\n      {\n        inserted = InsertNode(tnode->Right, Item, (char *)Namea.m128i_i64[0], &done);\n        v6 = inserted;\n        if ( inserted )\n        {\n          v7 = done;\n          if ( !done )\n            ++tnode->Balance;\n          tnode->Right = inserted;\n          result = tnode;\n          if ( v7 )\n            return result;\n          return CheckTreeNodeRotation(tnode, v6, &done);\n        }\n      }\n      return 0LL;\n    }\n    v10 = InsertNode(tnode->Left, Item, (char *)Namea.m128i_i64[0], &done);\n    v6 = v10;\n    if ( !v10 )\n      return 0LL;\n    v11 = done;\n    if ( !done )\n      --tnode->Balance;\n    tnode->Left = v10;\n    result = tnode;\n    if ( !v11 )\n      return CheckTreeNodeRotation(tnode, v6, &done);\n  }\n  else\n  {\n    Namea = (__m128i)v3;\n    result = (TreeNode *)libmin_malloc(0x28uLL);\n    if ( result )\n    {\n      v9 = _mm_load_si128(&Namea);\n      result->Balance = 0;\n      *(_OWORD *)&result->Left = 0LL;\n      *(__m128i *)&result->Item = v9;\n    }\n  }\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *Insert(TreeNode *tnode, Element Item, char *Name) {\n  __m128 v3;\n  short v4;\n  TreeNode *inserted;\n  TreeNode *v6;\n  short v7;\n  TreeNode *result;\n  __m128i v9;\n  TreeNode *v10;\n  short v11;\n  __m128i Namea;\n  short done;\n  unsigned long long v14;\n  Namea.m128i_i64[0] = (long long)Name;\n  v14 = __readfsqword(40u);\n  v3 = _mm_loadh_ps((const double *)Namea.m128i_i64);\n  done = 0;\n  if (tnode) {\n    v4 = Compare(Item, tnode->Item);\n    if (v4 >= 0) {\n      if (v4) {\n        inserted =\n            InsertNode(tnode->Right, Item, (char *)Namea.m128i_i64[0], &done);\n        v6 = inserted;\n        if (inserted) {\n          v7 = done;\n          if (!done) ++tnode->Balance;\n          tnode->Right = inserted;\n          result = tnode;\n          if (v7) return result;\n          return CheckTreeNodeRotation(tnode, v6, &done);\n        }\n      }\n      return 0LL;\n    }\n    v10 = InsertNode(tnode->Left, Item, (char *)Namea.m128i_i64[0], &done);\n    v6 = v10;\n    if (!v10) return 0LL;\n    v11 = done;\n    if (!done) --tnode->Balance;\n    tnode->Left = v10;\n    result = tnode;\n    if (!v11) return CheckTreeNodeRotation(tnode, v6, &done);\n  } else {\n    Namea = (__m128i)v3;\n    result = (TreeNode *)libmin_malloc(40uLL);\n    if (result) {\n      v9 = _mm_load_si128(&Namea);\n      result->Balance = 0;\n      *(long double *)&result->Left = 0LL;\n      *(__m128i *)&result->Item = v9;\n    }\n  }\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<Insert>:\nendbr64\npush   %r12\nmovq   %rsi,%xmm0\nxor    %ecx,%ecx\npush   %rbp\npush   %rbx\nsub    $0x20,%rsp\nmov    %rdx,(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmovhps (%rsp),%xmm0\nmov    %cx,0x16(%rsp)\ntest   %rdi,%rdi\nje     1ff8 <Insert+0xb8>\nmov    %rsi,%rbp\nmov    0x10(%rdi),%rsi\nmov    %rdi,%rbx\nmov    %rbp,%rdi\ncall   1af0 <Compare>\ntest   %ax,%ax\njs     2030 <Insert+0xf0>\nje     1ff0 <Insert+0xb0>\nmov    0x8(%rbx),%rdi\nmov    (%rsp),%rdx\nlea    0x16(%rsp),%r12\nmov    %rbp,%rsi\nmov    %r12,%rcx\ncall   1e10 <InsertNode>\nmov    %rax,%rsi\ntest   %rax,%rax\nje     1ff0 <Insert+0xb0>\nmovzwl 0x16(%rsp),%edx\ntest   %dx,%dx\nje     2028 <Insert+0xe8>\nmov    %rsi,0x8(%rbx)\nmov    %rbx,%rax\ntest   %dx,%dx\nje     206d <Insert+0x12d>\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    207d <Insert+0x13d>\nadd    $0x20,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopl   (%rax)\nxor    %eax,%eax\njmp    1fd0 <Insert+0x90>\nnopl   0x0(%rax)\nmov    $0x28,%edi\nmovaps %xmm0,(%rsp)\ncall   3af0 <libmin_malloc>\ntest   %rax,%rax\nje     1fd0 <Insert+0x90>\nmovdqa (%rsp),%xmm0\npxor   %xmm1,%xmm1\nxor    %edx,%edx\nmov    %dx,0x20(%rax)\nmovups %xmm1,(%rax)\nmovups %xmm0,0x10(%rax)\njmp    1fd0 <Insert+0x90>\nnopl   0x0(%rax,%rax,1)\naddw   $0x1,0x20(%rbx)\njmp    1fc0 <Insert+0x80>\nnop\nmov    (%rsp),%rdx\nmov    (%rbx),%rdi\nlea    0x16(%rsp),%r12\nmov    %rbp,%rsi\nmov    %r12,%rcx\ncall   1e10 <InsertNode>\nmov    %rax,%rsi\ntest   %rax,%rax\nje     1ff0 <Insert+0xb0>\nmovzwl 0x16(%rsp),%edx\ntest   %dx,%dx\njne    205e <Insert+0x11e>\nsubw   $0x1,0x20(%rbx)\nmov    %rsi,(%rbx)\nmov    %rbx,%rax\ntest   %dx,%dx\njne    1fd0 <Insert+0x90>\nmov    %r12,%rdx\nmov    %rbx,%rdi\ncall   1c50 <CheckTreeNodeRotation>\njmp    1fd0 <Insert+0x90>\ncall   10c0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "InsertNode", "content": "TreeNode *InsertNode(TreeNode *tnode, Element Item,\n                     char *Name, short *finished)\n{\n    TreeNode *subtree = NULL;\n    short comp = 0;\n    \n    if(tnode == NULL)    {\n        /* found the spot that the TreeNode belongs */\n        tnode = libmin_malloc(sizeof(TreeNode));\n        /* malloc problem, return NULL */\n        if(tnode == NULL)\n            return NULL;\n        else    {\n            /* default settings for a new node */\n            tnode->Left = NULL;\n            tnode->Right = NULL;\n            tnode->Item = Item;\n            tnode->Name = Name;\n            tnode->Balance = 0;\n        }\n    } else {\n        /* need to find the new node, don't check for a 0,\n           cos its already in teh tree, foo */\n        comp = Compare(Item, tnode->Item);\n        if(comp < 0)    {\n            /* go left */\n            subtree = InsertNode(tnode->Left, Item, Name, finished);\n            /* if this is NULL, there is problem. quit now */\n            if(subtree == NULL)\n                return NULL;\n            /* you are not finished until Balance == 0, reached the root\n                or a rotation has occured */\n            if(!*finished)\n                tnode->Balance--;\n            tnode->Left = subtree;\n        } else if(comp > 0)    {\n            /* go right */\n            subtree = InsertNode(tnode->Right, Item, Name, finished);\n            if(subtree == NULL)\n                return NULL;\n            if(!*finished)\n                tnode->Balance++;\n            tnode->Right = subtree;\n        } else\n            /* got a dupe, return NULL */\n            return NULL;\n\n        /* check if a rotation is neccessary */\n        if(!*finished)  {\n            tnode = CheckTreeNodeRotation(tnode, subtree, finished);\n        }\n    }\n    return tnode;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "InsertNode", "address": "0x1e10", "label": "InsertNode", "content": "TreeNode *__fastcall InsertNode(TreeNode *tnode, Element Item, char *Name, __int16 *finished)\n{\n  __m128 v4; // xmm0\n  __int16 v6; // ax\n  TreeNode *inserted; // rax\n  TreeNode *v8; // rsi\n  __int16 v9; // dx\n  TreeNode *result; // rax\n  __m128i si128; // xmm0\n  TreeNode *v12; // rax\n  __int16 v13; // dx\n  __m128i Namea[2]; // [rsp+0h] [rbp-28h] BYREF\n\n  Namea[0].m128i_i64[0] = (__int64)Name;\n  v4 = _mm_loadh_ps((const double *)Namea[0].m128i_i64);\n  if ( tnode )\n  {\n    v6 = Compare(Item, tnode->Item);\n    if ( v6 >= 0 )\n    {\n      if ( v6 )\n      {\n        inserted = InsertNode(tnode->Right, Item, (char *)Namea[0].m128i_i64[0], finished);\n        v8 = inserted;\n        if ( inserted )\n        {\n          v9 = *finished;\n          if ( !*finished )\n          {\n            ++tnode->Balance;\n            v9 = *finished;\n          }\n          tnode->Right = inserted;\n          result = tnode;\n          if ( v9 )\n            return result;\n          return CheckTreeNodeRotation(tnode, v8, finished);\n        }\n      }\n      return 0LL;\n    }\n    v12 = InsertNode(tnode->Left, Item, (char *)Namea[0].m128i_i64[0], finished);\n    v8 = v12;\n    if ( !v12 )\n      return 0LL;\n    v13 = *finished;\n    if ( !*finished )\n    {\n      --tnode->Balance;\n      v13 = *finished;\n    }\n    tnode->Left = v12;\n    result = tnode;\n    if ( !v13 )\n      return CheckTreeNodeRotation(tnode, v8, finished);\n  }\n  else\n  {\n    Namea[0] = (__m128i)v4;\n    result = (TreeNode *)libmin_malloc(0x28uLL);\n    if ( result )\n    {\n      si128 = _mm_load_si128(Namea);\n      result->Balance = 0;\n      *(_OWORD *)&result->Left = 0LL;\n      *(__m128i *)&result->Item = si128;\n    }\n  }\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *InsertNode(TreeNode *tnode, Element Item, char *Name,\n                     short *finished) {\n  __m128 v4;\n  short v6;\n  TreeNode *inserted;\n  TreeNode *v8;\n  short v9;\n  TreeNode *result;\n  __m128i si128;\n  TreeNode *v12;\n  short v13;\n  __m128i Namea[2];\n  Namea[0].m128i_i64[0] = (long long)Name;\n  v4 = _mm_loadh_ps((const double *)Namea[0].m128i_i64);\n  if (tnode) {\n    v6 = Compare(Item, tnode->Item);\n    if (v6 >= 0) {\n      if (v6) {\n        inserted = InsertNode(tnode->Right, Item, (char *)Namea[0].m128i_i64[0],\n                              finished);\n        v8 = inserted;\n        if (inserted) {\n          v9 = *finished;\n          if (!*finished) {\n            ++tnode->Balance;\n            v9 = *finished;\n          }\n          tnode->Right = inserted;\n          result = tnode;\n          if (v9) return result;\n          return CheckTreeNodeRotation(tnode, v8, finished);\n        }\n      }\n      return 0LL;\n    }\n    v12 =\n        InsertNode(tnode->Left, Item, (char *)Namea[0].m128i_i64[0], finished);\n    v8 = v12;\n    if (!v12) return 0LL;\n    v13 = *finished;\n    if (!*finished) {\n      --tnode->Balance;\n      v13 = *finished;\n    }\n    tnode->Left = v12;\n    result = tnode;\n    if (!v13) return CheckTreeNodeRotation(tnode, v8, finished);\n  } else {\n    Namea[0] = (__m128i)v4;\n    result = (TreeNode *)libmin_malloc(40uLL);\n    if (result) {\n      si128 = _mm_load_si128(Namea);\n      result->Balance = 0;\n      *(long double *)&result->Left = 0LL;\n      *(__m128i *)&result->Item = si128;\n    }\n  }\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<InsertNode>:\nendbr64\npush   %r13\nmovq   %rsi,%xmm0\npush   %r12\npush   %rbp\nsub    $0x10,%rsp\nmov    %rdx,(%rsp)\nmovhps (%rsp),%xmm0\ntest   %rdi,%rdi\nje     1ea0 <InsertNode+0x90>\nmov    %rsi,%r12\nmov    0x10(%rdi),%rsi\nmov    %rdi,%rbp\nmov    %rcx,%r13\nmov    %r12,%rdi\ncall   1af0 <Compare>\ntest   %ax,%ax\njs     1ee8 <InsertNode+0xd8>\nje     1e90 <InsertNode+0x80>\nmov    0x8(%rbp),%rdi\nmov    (%rsp),%rdx\nmov    %r12,%rsi\nmov    %r13,%rcx\ncall   1e10 <InsertNode>\nmov    %rax,%rsi\ntest   %rax,%rax\nje     1e90 <InsertNode+0x80>\nmovzwl 0x0(%r13),%edx\ntest   %dx,%dx\nje     1ed8 <InsertNode+0xc8>\nmov    %rsi,0x8(%rbp)\nmov    %rbp,%rax\ntest   %dx,%dx\nje     1f27 <InsertNode+0x117>\nadd    $0x10,%rsp\npop    %rbp\npop    %r12\npop    %r13\nret\nxchg   %ax,%ax\nadd    $0x10,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nmov    $0x28,%edi\nmovaps %xmm0,(%rsp)\ncall   3af0 <libmin_malloc>\ntest   %rax,%rax\nje     1e84 <InsertNode+0x74>\nmovdqa (%rsp),%xmm0\npxor   %xmm1,%xmm1\nxor    %edx,%edx\nmov    %dx,0x20(%rax)\nmovups %xmm1,(%rax)\nmovups %xmm0,0x10(%rax)\nadd    $0x10,%rsp\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax,%rax,1)\naddw   $0x1,0x20(%rbp)\nmovzwl 0x0(%r13),%edx\njmp    1e74 <InsertNode+0x64>\nnopl   0x0(%rax)\nmov    (%rsp),%rdx\nmov    0x0(%rbp),%rdi\nmov    %r12,%rsi\nmov    %r13,%rcx\ncall   1e10 <InsertNode>\nmov    %rax,%rsi\ntest   %rax,%rax\nje     1e90 <InsertNode+0x80>\nmovzwl 0x0(%r13),%edx\ntest   %dx,%dx\njne    1f17 <InsertNode+0x107>\nsubw   $0x1,0x20(%rbp)\nmovzwl 0x0(%r13),%edx\nmov    %rsi,0x0(%rbp)\nmov    %rbp,%rax\ntest   %dx,%dx\njne    1e84 <InsertNode+0x74>\nadd    $0x10,%rsp\nmov    %r13,%rdx\nmov    %rbp,%rdi\npop    %rbp\npop    %r12\npop    %r13\njmp    1c50 <CheckTreeNodeRotation>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "IsEmpty", "content": "short IsEmpty(TreeNode *rootNode)\n{\n    return (rootNode == NULL);\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "IsEmpty", "address": "0x1ba0", "label": "IsEmpty", "content": "__int16 __fastcall IsEmpty(TreeNode *rootNode)\n{\n  return rootNode == 0LL;\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<IsEmpty>:\nendbr64\nxor    %eax,%eax\ntest   %rdi,%rdi\nsete   %al\nret\nnopl   (%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "MakeEmpty", "content": "void MakeEmpty(TreeNode *rootNode)\n{\n    /* this function is pretty simple, just traverses the tree and starts\n        free'ing from the bottom up */\n    if(rootNode == NULL)\n        return;\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "MakeEmpty", "address": "0x2090", "label": "MakeEmpty", "content": "void __fastcall MakeEmpty(TreeNode *rootNode)\n{\n  TreeNodeTag *Left; // r12\n  TreeNodeTag *v2; // r13\n  TreeNodeTag *v3; // r14\n  TreeNodeTag *v4; // r15\n  TreeNodeTag *Right; // r15\n  TreeNodeTag *v6; // r14\n  TreeNodeTag *v7; // r15\n  TreeNodeTag *v8; // r15\n  TreeNodeTag *v9; // r13\n  TreeNodeTag *v10; // r14\n  TreeNodeTag *v11; // r15\n  TreeNodeTag *v12; // r15\n  TreeNodeTag *v13; // r14\n  TreeNodeTag *v14; // r15\n  TreeNodeTag *v15; // r15\n  TreeNodeTag *v16; // r12\n  TreeNodeTag *v17; // r13\n  TreeNodeTag *v18; // r14\n  TreeNodeTag *v19; // r15\n  TreeNodeTag *v20; // r15\n  TreeNodeTag *v21; // r14\n  TreeNodeTag *v22; // r15\n  TreeNodeTag *v23; // rbx\n  TreeNodeTag *v24; // rbx\n  TreeNodeTag *v25; // r15\n  TreeNodeTag *v26; // rbx\n  TreeNodeTag *v27; // rbx\n  TreeNodeTag *v28; // r13\n  TreeNodeTag *v29; // r14\n  TreeNodeTag *v30; // r15\n  TreeNode *v31; // rbx\n  TreeNodeTag *v32; // r15\n  TreeNodeTag *v33; // r14\n  TreeNodeTag *v34; // r15\n  TreeNodeTag *v35; // r15\n\n  if ( rootNode )\n  {\n    Left = rootNode->Left;\n    if ( rootNode->Left )\n    {\n      v2 = Left->Left;\n      if ( Left->Left )\n      {\n        v3 = v2->Left;\n        if ( v2->Left )\n        {\n          v4 = v3->Left;\n          if ( v3->Left )\n          {\n            MakeEmpty(v4->Left);\n            MakeEmpty(v4->Right);\n            FreeElement(v4->Item);\n            libmin_free(v4->Name);\n            libmin_free(v4);\n          }\n          Right = v3->Right;\n          if ( Right )\n          {\n            MakeEmpty(Right->Left);\n            MakeEmpty(Right->Right);\n            FreeElement(Right->Item);\n            libmin_free(Right->Name);\n            libmin_free(Right);\n          }\n          FreeElement(v3->Item);\n          libmin_free(v3->Name);\n          libmin_free(v3);\n        }\n        v6 = v2->Right;\n        if ( v6 )\n        {\n          v7 = v6->Left;\n          if ( v6->Left )\n          {\n            MakeEmpty(v7->Left);\n            MakeEmpty(v7->Right);\n            FreeElement(v7->Item);\n            libmin_free(v7->Name);\n            libmin_free(v7);\n          }\n          v8 = v6->Right;\n          if ( v8 )\n          {\n            MakeEmpty(v8->Left);\n            MakeEmpty(v8->Right);\n            FreeElement(v8->Item);\n            libmin_free(v8->Name);\n            libmin_free(v8);\n          }\n          FreeElement(v6->Item);\n          libmin_free(v6->Name);\n          libmin_free(v6);\n        }\n        FreeElement(v2->Item);\n        libmin_free(v2->Name);\n        libmin_free(v2);\n      }\n      v9 = Left->Right;\n      if ( v9 )\n      {\n        v10 = v9->Left;\n        if ( v9->Left )\n        {\n          v11 = v10->Left;\n          if ( v10->Left )\n          {\n            MakeEmpty(v11->Left);\n            MakeEmpty(v11->Right);\n            FreeElement(v11->Item);\n            libmin_free(v11->Name);\n            libmin_free(v11);\n          }\n          v12 = v10->Right;\n          if ( v12 )\n          {\n            MakeEmpty(v12->Left);\n            MakeEmpty(v12->Right);\n            FreeElement(v12->Item);\n            libmin_free(v12->Name);\n            libmin_free(v12);\n          }\n          FreeElement(v10->Item);\n          libmin_free(v10->Name);\n          libmin_free(v10);\n        }\n        v13 = v9->Right;\n        if ( v13 )\n        {\n          v14 = v13->Left;\n          if ( v13->Left )\n          {\n            MakeEmpty(v14->Left);\n            MakeEmpty(v14->Right);\n            FreeElement(v14->Item);\n            libmin_free(v14->Name);\n            libmin_free(v14);\n          }\n          v15 = v13->Right;\n          if ( v15 )\n          {\n            MakeEmpty(v15->Left);\n            MakeEmpty(v15->Right);\n            FreeElement(v15->Item);\n            libmin_free(v15->Name);\n            libmin_free(v15);\n          }\n          FreeElement(v13->Item);\n          libmin_free(v13->Name);\n          libmin_free(v13);\n        }\n        FreeElement(v9->Item);\n        libmin_free(v9->Name);\n        libmin_free(v9);\n      }\n      FreeElement(Left->Item);\n      libmin_free(Left->Name);\n      libmin_free(Left);\n    }\n    v16 = rootNode->Right;\n    if ( v16 )\n    {\n      v17 = v16->Left;\n      if ( v16->Left )\n      {\n        v18 = v17->Left;\n        if ( v17->Left )\n        {\n          v19 = v18->Left;\n          if ( v18->Left )\n          {\n            MakeEmpty(v19->Left);\n            MakeEmpty(v19->Right);\n            FreeElement(v19->Item);\n            libmin_free(v19->Name);\n            libmin_free(v19);\n          }\n          v20 = v18->Right;\n          if ( v20 )\n          {\n            MakeEmpty(v20->Left);\n            MakeEmpty(v20->Right);\n            FreeElement(v20->Item);\n            libmin_free(v20->Name);\n            libmin_free(v20);\n          }\n          FreeElement(v18->Item);\n          libmin_free(v18->Name);\n          libmin_free(v18);\n        }\n        v21 = v17->Right;\n        if ( v21 )\n        {\n          v22 = v21->Left;\n          if ( v21->Left )\n          {\n            v23 = v22->Left;\n            if ( v22->Left )\n            {\n              MakeEmpty(v23->Left);\n              MakeEmpty(v23->Right);\n              FreeElement(v23->Item);\n              libmin_free(v23->Name);\n              libmin_free(v23);\n            }\n            v24 = v22->Right;\n            if ( v24 )\n            {\n              MakeEmpty(v24->Left);\n              MakeEmpty(v24->Right);\n              FreeElement(v24->Item);\n              libmin_free(v24->Name);\n              libmin_free(v24);\n            }\n            FreeElement(v22->Item);\n            libmin_free(v22->Name);\n            libmin_free(v22);\n          }\n          v25 = v21->Right;\n          if ( v25 )\n          {\n            v26 = v25->Left;\n            if ( v25->Left )\n            {\n              MakeEmpty(v26->Left);\n              MakeEmpty(v26->Right);\n              FreeElement(v26->Item);\n              libmin_free(v26->Name);\n              libmin_free(v26);\n            }\n            v27 = v25->Right;\n            if ( v27 )\n            {\n              MakeEmpty(v27->Left);\n              MakeEmpty(v27->Right);\n              FreeElement(v27->Item);\n              libmin_free(v27->Name);\n              libmin_free(v27);\n            }\n            FreeElement(v25->Item);\n            libmin_free(v25->Name);\n            libmin_free(v25);\n          }\n          FreeElement(v21->Item);\n          libmin_free(v21->Name);\n          libmin_free(v21);\n        }\n        FreeElement(v17->Item);\n        libmin_free(v17->Name);\n        libmin_free(v17);\n      }\n      v28 = v16->Right;\n      if ( v28 )\n      {\n        v29 = v28->Left;\n        if ( v28->Left )\n        {\n          v30 = v29->Left;\n          if ( v29->Left )\n          {\n            v31 = v30->Left;\n            if ( v30->Left )\n            {\n              MakeEmpty(v31->Left);\n              MakeEmpty(v31->Right);\n              FreeElement(v31->Item);\n              libmin_free(v31->Name);\n              libmin_free(v31);\n            }\n            MakeEmpty(v30->Right);\n            FreeElement(v30->Item);\n            libmin_free(v30->Name);\n            libmin_free(v30);\n          }\n          v32 = v29->Right;\n          if ( v32 )\n          {\n            MakeEmpty(v32->Left);\n            MakeEmpty(v32->Right);\n            FreeElement(v32->Item);\n            libmin_free(v32->Name);\n            libmin_free(v32);\n          }\n          FreeElement(v29->Item);\n          libmin_free(v29->Name);\n          libmin_free(v29);\n        }\n        v33 = v28->Right;\n        if ( v33 )\n        {\n          v34 = v33->Left;\n          if ( v33->Left )\n          {\n            MakeEmpty(v34->Left);\n            MakeEmpty(v34->Right);\n            FreeElement(v34->Item);\n            libmin_free(v34->Name);\n            libmin_free(v34);\n          }\n          v35 = v33->Right;\n          if ( v35 )\n          {\n            MakeEmpty(v35->Left);\n            MakeEmpty(v35->Right);\n            FreeElement(v35->Item);\n            libmin_free(v35->Name);\n            libmin_free(v35);\n          }\n          FreeElement(v33->Item);\n          libmin_free(v33->Name);\n          libmin_free(v33);\n        }\n        FreeElement(v28->Item);\n        libmin_free(v28->Name);\n        libmin_free(v28);\n      }\n      FreeElement(v16->Item);\n      libmin_free(v16->Name);\n      libmin_free(v16);\n    }\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}\n"}, "pseudo_normalize": "void MakeEmpty(TreeNode *rootNode) {\n  TreeNodeTag *Left;\n  TreeNodeTag *v2;\n  TreeNodeTag *v3;\n  TreeNodeTag *v4;\n  TreeNodeTag *Right;\n  TreeNodeTag *v6;\n  TreeNodeTag *v7;\n  TreeNodeTag *v8;\n  TreeNodeTag *v9;\n  TreeNodeTag *v10;\n  TreeNodeTag *v11;\n  TreeNodeTag *v12;\n  TreeNodeTag *v13;\n  TreeNodeTag *v14;\n  TreeNodeTag *v15;\n  TreeNodeTag *v16;\n  TreeNodeTag *v17;\n  TreeNodeTag *v18;\n  TreeNodeTag *v19;\n  TreeNodeTag *v20;\n  TreeNodeTag *v21;\n  TreeNodeTag *v22;\n  TreeNodeTag *v23;\n  TreeNodeTag *v24;\n  TreeNodeTag *v25;\n  TreeNodeTag *v26;\n  TreeNodeTag *v27;\n  TreeNodeTag *v28;\n  TreeNodeTag *v29;\n  TreeNodeTag *v30;\n  TreeNode *v31;\n  TreeNodeTag *v32;\n  TreeNodeTag *v33;\n  TreeNodeTag *v34;\n  TreeNodeTag *v35;\n  if (rootNode) {\n    Left = rootNode->Left;\n    if (rootNode->Left) {\n      v2 = Left->Left;\n      if (Left->Left) {\n        v3 = v2->Left;\n        if (v2->Left) {\n          v4 = v3->Left;\n          if (v3->Left) {\n            MakeEmpty(v4->Left);\n            MakeEmpty(v4->Right);\n            FreeElement(v4->Item);\n            libmin_free(v4->Name);\n            libmin_free(v4);\n          }\n          Right = v3->Right;\n          if (Right) {\n            MakeEmpty(Right->Left);\n            MakeEmpty(Right->Right);\n            FreeElement(Right->Item);\n            libmin_free(Right->Name);\n            libmin_free(Right);\n          }\n          FreeElement(v3->Item);\n          libmin_free(v3->Name);\n          libmin_free(v3);\n        }\n        v6 = v2->Right;\n        if (v6) {\n          v7 = v6->Left;\n          if (v6->Left) {\n            MakeEmpty(v7->Left);\n            MakeEmpty(v7->Right);\n            FreeElement(v7->Item);\n            libmin_free(v7->Name);\n            libmin_free(v7);\n          }\n          v8 = v6->Right;\n          if (v8) {\n            MakeEmpty(v8->Left);\n            MakeEmpty(v8->Right);\n            FreeElement(v8->Item);\n            libmin_free(v8->Name);\n            libmin_free(v8);\n          }\n          FreeElement(v6->Item);\n          libmin_free(v6->Name);\n          libmin_free(v6);\n        }\n        FreeElement(v2->Item);\n        libmin_free(v2->Name);\n        libmin_free(v2);\n      }\n      v9 = Left->Right;\n      if (v9) {\n        v10 = v9->Left;\n        if (v9->Left) {\n          v11 = v10->Left;\n          if (v10->Left) {\n            MakeEmpty(v11->Left);\n            MakeEmpty(v11->Right);\n            FreeElement(v11->Item);\n            libmin_free(v11->Name);\n            libmin_free(v11);\n          }\n          v12 = v10->Right;\n          if (v12) {\n            MakeEmpty(v12->Left);\n            MakeEmpty(v12->Right);\n            FreeElement(v12->Item);\n            libmin_free(v12->Name);\n            libmin_free(v12);\n          }\n          FreeElement(v10->Item);\n          libmin_free(v10->Name);\n          libmin_free(v10);\n        }\n        v13 = v9->Right;\n        if (v13) {\n          v14 = v13->Left;\n          if (v13->Left) {\n            MakeEmpty(v14->Left);\n            MakeEmpty(v14->Right);\n            FreeElement(v14->Item);\n            libmin_free(v14->Name);\n            libmin_free(v14);\n          }\n          v15 = v13->Right;\n          if (v15) {\n            MakeEmpty(v15->Left);\n            MakeEmpty(v15->Right);\n            FreeElement(v15->Item);\n            libmin_free(v15->Name);\n            libmin_free(v15);\n          }\n          FreeElement(v13->Item);\n          libmin_free(v13->Name);\n          libmin_free(v13);\n        }\n        FreeElement(v9->Item);\n        libmin_free(v9->Name);\n        libmin_free(v9);\n      }\n      FreeElement(Left->Item);\n      libmin_free(Left->Name);\n      libmin_free(Left);\n    }\n    v16 = rootNode->Right;\n    if (v16) {\n      v17 = v16->Left;\n      if (v16->Left) {\n        v18 = v17->Left;\n        if (v17->Left) {\n          v19 = v18->Left;\n          if (v18->Left) {\n            MakeEmpty(v19->Left);\n            MakeEmpty(v19->Right);\n            FreeElement(v19->Item);\n            libmin_free(v19->Name);\n            libmin_free(v19);\n          }\n          v20 = v18->Right;\n          if (v20) {\n            MakeEmpty(v20->Left);\n            MakeEmpty(v20->Right);\n            FreeElement(v20->Item);\n            libmin_free(v20->Name);\n            libmin_free(v20);\n          }\n          FreeElement(v18->Item);\n          libmin_free(v18->Name);\n          libmin_free(v18);\n        }\n        v21 = v17->Right;\n        if (v21) {\n          v22 = v21->Left;\n          if (v21->Left) {\n            v23 = v22->Left;\n            if (v22->Left) {\n              MakeEmpty(v23->Left);\n              MakeEmpty(v23->Right);\n              FreeElement(v23->Item);\n              libmin_free(v23->Name);\n              libmin_free(v23);\n            }\n            v24 = v22->Right;\n            if (v24) {\n              MakeEmpty(v24->Left);\n              MakeEmpty(v24->Right);\n              FreeElement(v24->Item);\n              libmin_free(v24->Name);\n              libmin_free(v24);\n            }\n            FreeElement(v22->Item);\n            libmin_free(v22->Name);\n            libmin_free(v22);\n          }\n          v25 = v21->Right;\n          if (v25) {\n            v26 = v25->Left;\n            if (v25->Left) {\n              MakeEmpty(v26->Left);\n              MakeEmpty(v26->Right);\n              FreeElement(v26->Item);\n              libmin_free(v26->Name);\n              libmin_free(v26);\n            }\n            v27 = v25->Right;\n            if (v27) {\n              MakeEmpty(v27->Left);\n              MakeEmpty(v27->Right);\n              FreeElement(v27->Item);\n              libmin_free(v27->Name);\n              libmin_free(v27);\n            }\n            FreeElement(v25->Item);\n            libmin_free(v25->Name);\n            libmin_free(v25);\n          }\n          FreeElement(v21->Item);\n          libmin_free(v21->Name);\n          libmin_free(v21);\n        }\n        FreeElement(v17->Item);\n        libmin_free(v17->Name);\n        libmin_free(v17);\n      }\n      v28 = v16->Right;\n      if (v28) {\n        v29 = v28->Left;\n        if (v28->Left) {\n          v30 = v29->Left;\n          if (v29->Left) {\n            v31 = v30->Left;\n            if (v30->Left) {\n              MakeEmpty(v31->Left);\n              MakeEmpty(v31->Right);\n              FreeElement(v31->Item);\n              libmin_free(v31->Name);\n              libmin_free(v31);\n            }\n            MakeEmpty(v30->Right);\n            FreeElement(v30->Item);\n            libmin_free(v30->Name);\n            libmin_free(v30);\n          }\n          v32 = v29->Right;\n          if (v32) {\n            MakeEmpty(v32->Left);\n            MakeEmpty(v32->Right);\n            FreeElement(v32->Item);\n            libmin_free(v32->Name);\n            libmin_free(v32);\n          }\n          FreeElement(v29->Item);\n          libmin_free(v29->Name);\n          libmin_free(v29);\n        }\n        v33 = v28->Right;\n        if (v33) {\n          v34 = v33->Left;\n          if (v33->Left) {\n            MakeEmpty(v34->Left);\n            MakeEmpty(v34->Right);\n            FreeElement(v34->Item);\n            libmin_free(v34->Name);\n            libmin_free(v34);\n          }\n          v35 = v33->Right;\n          if (v35) {\n            MakeEmpty(v35->Left);\n            MakeEmpty(v35->Right);\n            FreeElement(v35->Item);\n            libmin_free(v35->Name);\n            libmin_free(v35);\n          }\n          FreeElement(v33->Item);\n          libmin_free(v33->Name);\n          libmin_free(v33);\n        }\n        FreeElement(v28->Item);\n        libmin_free(v28->Name);\n        libmin_free(v28);\n      }\n      FreeElement(v16->Item);\n      libmin_free(v16->Name);\n      libmin_free(v16);\n    }\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<MakeEmpty>:\nendbr64\ntest   %rdi,%rdi\nje     2718 <MakeEmpty+0x688>\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    (%rdi),%r12\ntest   %r12,%r12\nje     235d <MakeEmpty+0x2cd>\nmov    (%r12),%r13\ntest   %r13,%r13\nje     21fd <MakeEmpty+0x16d>\nmov    0x0(%r13),%r14\ntest   %r14,%r14\nje     2155 <MakeEmpty+0xc5>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     2107 <MakeEmpty+0x77>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     213b <MakeEmpty+0xab>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3ba0 <libmin_free>\nmov    %r14,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r13),%r14\ntest   %r14,%r14\nje     21e3 <MakeEmpty+0x153>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     2195 <MakeEmpty+0x105>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     21c9 <MakeEmpty+0x139>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3ba0 <libmin_free>\nmov    %r14,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r13),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r13),%rdi\ncall   3ba0 <libmin_free>\nmov    %r13,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r12),%r13\ntest   %r13,%r13\nje     2341 <MakeEmpty+0x2b1>\nmov    0x0(%r13),%r14\ntest   %r14,%r14\nje     2299 <MakeEmpty+0x209>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     224b <MakeEmpty+0x1bb>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     227f <MakeEmpty+0x1ef>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3ba0 <libmin_free>\nmov    %r14,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r13),%r14\ntest   %r14,%r14\nje     2327 <MakeEmpty+0x297>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     22d9 <MakeEmpty+0x249>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     230d <MakeEmpty+0x27d>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3ba0 <libmin_free>\nmov    %r14,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r13),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r13),%rdi\ncall   3ba0 <libmin_free>\nmov    %r13,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r12),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r12),%rdi\ncall   3ba0 <libmin_free>\nmov    %r12,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%rbp),%r12\ntest   %r12,%r12\nje     26ec <MakeEmpty+0x65c>\nmov    (%r12),%r13\ntest   %r13,%r13\nje     2561 <MakeEmpty+0x4d1>\nmov    0x0(%r13),%r14\ntest   %r14,%r14\nje     2405 <MakeEmpty+0x375>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     23b7 <MakeEmpty+0x327>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     23eb <MakeEmpty+0x35b>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3ba0 <libmin_free>\nmov    %r14,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r13),%r14\ntest   %r14,%r14\nje     2547 <MakeEmpty+0x4b7>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     249f <MakeEmpty+0x40f>\nmov    (%r15),%rbx\ntest   %rbx,%rbx\nje     2451 <MakeEmpty+0x3c1>\nmov    (%rbx),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%rbx),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%rbx),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%rbx),%rdi\ncall   3ba0 <libmin_free>\nmov    %rbx,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r15),%rbx\ntest   %rbx,%rbx\nje     2485 <MakeEmpty+0x3f5>\nmov    (%rbx),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%rbx),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%rbx),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%rbx),%rdi\ncall   3ba0 <libmin_free>\nmov    %rbx,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     252d <MakeEmpty+0x49d>\nmov    (%r15),%rbx\ntest   %rbx,%rbx\nje     24df <MakeEmpty+0x44f>\nmov    (%rbx),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%rbx),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%rbx),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%rbx),%rdi\ncall   3ba0 <libmin_free>\nmov    %rbx,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r15),%rbx\ntest   %rbx,%rbx\nje     2513 <MakeEmpty+0x483>\nmov    (%rbx),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%rbx),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%rbx),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%rbx),%rdi\ncall   3ba0 <libmin_free>\nmov    %rbx,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3ba0 <libmin_free>\nmov    %r14,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r13),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r13),%rdi\ncall   3ba0 <libmin_free>\nmov    %r13,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r12),%r13\ntest   %r13,%r13\nje     26d0 <MakeEmpty+0x640>\nmov    0x0(%r13),%r14\ntest   %r14,%r14\nje     2628 <MakeEmpty+0x598>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     25da <MakeEmpty+0x54a>\nmov    (%r15),%rbx\ntest   %rbx,%rbx\nje     25b7 <MakeEmpty+0x527>\nmov    (%rbx),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%rbx),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%rbx),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%rbx),%rdi\ncall   3ba0 <libmin_free>\nmov    %rbx,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     260e <MakeEmpty+0x57e>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3ba0 <libmin_free>\nmov    %r14,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r13),%r14\ntest   %r14,%r14\nje     26b6 <MakeEmpty+0x626>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     2668 <MakeEmpty+0x5d8>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     269c <MakeEmpty+0x60c>\nmov    (%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   2090 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3ba0 <libmin_free>\nmov    %r15,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3ba0 <libmin_free>\nmov    %r14,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r13),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r13),%rdi\ncall   3ba0 <libmin_free>\nmov    %r13,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%r12),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%r12),%rdi\ncall   3ba0 <libmin_free>\nmov    %r12,%rdi\ncall   3ba0 <libmin_free>\nmov    0x10(%rbp),%rdi\ncall   1b10 <FreeElement>\nmov    0x18(%rbp),%rdi\ncall   3ba0 <libmin_free>\nadd    $0x8,%rsp\nmov    %rbp,%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    3ba0 <libmin_free>\nnopl   0x0(%rax)\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "SingleLeftRotation", "content": "TreeNode *SingleLeftRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = NULL;\n    newRoot = rootNode->Right;\n    rootNode->Right = newRoot->Left;\n    newRoot->Left = rootNode;\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "SingleLeftRotation", "address": "0x1bd0", "label": "SingleLeftRotation", "content": "TreeNode *__fastcall SingleLeftRotation(TreeNode *rootNode)\n{\n  TreeNode *result; // rax\n\n  result = rootNode->Right;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *SingleLeftRotation(TreeNode *rootNode) {\n  TreeNode *result;\n  result = rootNode->Right;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<SingleLeftRotation>:\nendbr64\nmov    0x8(%rdi),%rax\nmov    (%rax),%rdx\nmov    %rdx,0x8(%rdi)\nmov    %rdi,(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "SingleRightRotation", "content": "TreeNode *SingleRightRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = NULL;\n    newRoot = rootNode->Left;\n    rootNode->Left = newRoot->Right;\n    newRoot->Right = rootNode;\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "SingleRightRotation", "address": "0x1bb0", "label": "SingleRightRotation", "content": "TreeNode *__fastcall SingleRightRotation(TreeNode *rootNode)\n{\n  TreeNode *result; // rax\n\n  result = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  result->Right = rootNode;\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *SingleRightRotation(TreeNode *rootNode) {\n  TreeNode *result;\n  result = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  result->Right = rootNode;\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<SingleRightRotation>:\nendbr64\nmov    (%rdi),%rax\nmov    0x8(%rax),%rdx\nmov    %rdx,(%rdi)\nmov    %rdi,0x8(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "avl-tree/avl-tree.c", "function_name": "breadth", "content": "long breadth(TreeNode *start)\n{\n    if(start == NULL)\n        return (long)0;\n    if(start->Left == NULL && start->Right == NULL)\n        return (long)1;\n    return (long)(breadth(start->Left) + breadth(start->Right));\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "breadth", "address": "0x1780", "label": "breadth", "content": "__int64 __fastcall breadth(TreeNode *start)\n{\n  TreeNode *v1; // rcx\n  TreeNodeTag *Left; // r15\n  TreeNodeTag *v3; // r15\n  TreeNodeTag *v4; // rbx\n  __int64 v5; // r15\n  TreeNodeTag *v6; // rbp\n  __int64 v7; // rbx\n  TreeNodeTag *Right; // r12\n  __int64 v9; // rbp\n  TreeNodeTag *v10; // r13\n  __int64 v11; // r12\n  __int64 *v12; // rbx\n  __int64 v13; // rbp\n  __int64 v14; // r14\n  __int64 v15; // r15\n  __int64 v16; // rax\n  __int64 v17; // r15\n  __int64 v18; // r15\n  __int64 v19; // rcx\n  __int64 v22; // rax\n  __int64 v23; // [rsp+0h] [rbp-98h]\n  __int64 v24; // [rsp+8h] [rbp-90h]\n  __int64 v25; // [rsp+10h] [rbp-88h]\n  TreeNode *v26; // [rsp+18h] [rbp-80h]\n  TreeNodeTag *v27; // [rsp+20h] [rbp-78h]\n  TreeNodeTag *v28; // [rsp+28h] [rbp-70h]\n  TreeNodeTag *v29; // [rsp+30h] [rbp-68h]\n  __int64 v30; // [rsp+38h] [rbp-60h]\n  __int64 v31; // [rsp+40h] [rbp-58h]\n  TreeNodeTag *v32; // [rsp+48h] [rbp-50h]\n  TreeNodeTag *v33; // [rsp+50h] [rbp-48h]\n  __int64 v34; // [rsp+58h] [rbp-40h]\n\n  if ( !start )\n    return 0LL;\n  v1 = start;\n  v24 = 0LL;\n  do\n  {\nLABEL_3:\n    while ( 1 )\n    {\n      v23 = 0LL;\n      if ( !v1->Left )\n        break;\n      v26 = v1;\n      Left = v1->Left;\n      do\n      {\nLABEL_5:\n        while ( 2 )\n        {\n          if ( Left->Left )\n          {\n            v25 = 0LL;\n            v27 = Left;\n            v3 = Left->Left;\n            do\n            {\n              while ( 1 )\n              {\n                v4 = v3->Left;\n                if ( !v3->Left )\n                  break;\n                v28 = v3;\n                v5 = 0LL;\n                do\n                {\n                  while ( 1 )\n                  {\n                    v6 = v4->Left;\n                    if ( !v4->Left )\n                      break;\n                    v30 = v5;\n                    v29 = v4;\n                    v7 = 0LL;\n                    do\n                    {\n                      while ( 1 )\n                      {\n                        Right = v6->Left;\n                        if ( !v6->Left )\n                          break;\n                        v31 = v7;\n                        v32 = v6;\n                        v9 = 0LL;\n                        do\n                        {\n                          while ( 1 )\n                          {\n                            v10 = Right->Left;\n                            if ( !Right->Left )\n                              break;\n                            v34 = v9;\n                            v33 = Right;\n                            v11 = 0LL;\n                            do\n                            {\n                              while ( 1 )\n                              {\n                                v12 = (__int64 *)v10->Left;\n                                v13 = 0LL;\n                                if ( !v10->Left )\n                                  break;\n                                do\n                                {\n                                  while ( 1 )\n                                  {\n                                    v14 = *v12;\n                                    v15 = 0LL;\n                                    if ( !*v12 )\n                                      break;\n                                    while ( 1 )\n                                    {\n                                      while ( *(_QWORD *)v14 )\n                                      {\n                                        v16 = breadth(*(TreeNode **)v14);\n                                        v14 = *(_QWORD *)(v14 + 8);\n                                        v15 += v16;\n                                        if ( !v14 )\n                                        {\n                                          v12 = (__int64 *)v12[1];\n                                          v13 += v15;\n                                          goto LABEL_20;\n                                        }\n                                      }\n                                      v14 = *(_QWORD *)(v14 + 8);\n                                      if ( !v14 )\n                                        break;\n                                      v15 += breadth(0LL);\n                                    }\n                                    v12 = (__int64 *)v12[1];\n                                    v13 += v15 + 1;\nLABEL_20:\n                                    if ( !v12 )\n                                    {\n                                      v10 = v10->Right;\n                                      v11 += v13;\n                                      goto LABEL_22;\n                                    }\n                                  }\n                                  v12 = (__int64 *)v12[1];\n                                }\n                                while ( v12 );\n                                v10 = v10->Right;\n                                v11 += v13 + 1;\nLABEL_22:\n                                if ( !v10 )\n                                {\n                                  v17 = v11;\n                                  Right = v33->Right;\n                                  v9 = v17 + v34;\n                                  goto LABEL_24;\n                                }\n                              }\n                              v10 = v10->Right;\n                            }\n                            while ( v10 );\n                            v9 = v34 + v11 + 1;\n                            Right = v33->Right;\nLABEL_24:\n                            if ( !Right )\n                            {\n                              v18 = v9;\n                              v6 = v32->Right;\n                              v7 = v18 + v31;\n                              goto LABEL_26;\n                            }\n                          }\n                          Right = Right->Right;\n                        }\n                        while ( Right );\n                        v7 = v9 + v31 + 1;\n                        v6 = v32->Right;\nLABEL_26:\n                        if ( !v6 )\n                        {\n                          v19 = v7;\n                          v4 = v29->Right;\n                          v5 = v19 + v30;\n                          goto LABEL_28;\n                        }\n                      }\n                      v6 = v6->Right;\n                    }\n                    while ( v6 );\n                    v5 = v30 + v7 + 1;\n                    v4 = v29->Right;\nLABEL_28:\n                    if ( !v4 )\n                    {\n                      v25 += v5;\n                      v3 = v28->Right;\n                      goto LABEL_30;\n                    }\n                  }\n                  v4 = v4->Right;\n                }\n                while ( v4 );\n                v22 = v5 + v25 + 1;\n                v3 = v28->Right;\n                v25 = v22;\nLABEL_30:\n                if ( !v3 )\n                {\n                  v23 += v25;\n                  Left = v27->Right;\n                  if ( Left )\n                    goto LABEL_5;\n                  goto LABEL_32;\n                }\n              }\n              v3 = v3->Right;\n            }\n            while ( v3 );\n            Left = v27->Right;\n            v23 += v25 + 1;\n            if ( Left )\n              continue;\nLABEL_32:\n            v24 += v23;\n            v1 = v26->Right;\n            if ( v1 )\n              goto LABEL_3;\n            return v24;\n          }\n          break;\n        }\n        Left = Left->Right;\n      }\n      while ( Left );\n      v1 = v26->Right;\n      v24 += v23 + 1;\n      if ( !v1 )\n        return v24;\n    }\n    v1 = v1->Right;\n  }\n  while ( v1 );\n  return v24 + 1;\n}\n"}, "pseudo_normalize": "long long breadth(TreeNode *start) {\n  TreeNode *v1;\n  TreeNodeTag *Left;\n  TreeNodeTag *v3;\n  TreeNodeTag *v4;\n  long long v5;\n  TreeNodeTag *v6;\n  long long v7;\n  TreeNodeTag *Right;\n  long long v9;\n  TreeNodeTag *v10;\n  long long v11;\n  long long *v12;\n  long long v13;\n  long long v14;\n  long long v15;\n  long long v16;\n  long long v17;\n  long long v18;\n  long long v19;\n  long long v22;\n  long long v23;\n  long long v24;\n  long long v25;\n  TreeNode *v26;\n  TreeNodeTag *v27;\n  TreeNodeTag *v28;\n  TreeNodeTag *v29;\n  long long v30;\n  long long v31;\n  TreeNodeTag *v32;\n  TreeNodeTag *v33;\n  long long v34;\n  if (!start) return 0LL;\n  v1 = start;\n  v24 = 0LL;\n  do {\n  LABEL_3:\n    while (1) {\n      v23 = 0LL;\n      if (!v1->Left) break;\n      v26 = v1;\n      Left = v1->Left;\n      do {\n      LABEL_5:\n        while (2) {\n          if (Left->Left) {\n            v25 = 0LL;\n            v27 = Left;\n            v3 = Left->Left;\n            do {\n              while (1) {\n                v4 = v3->Left;\n                if (!v3->Left) break;\n                v28 = v3;\n                v5 = 0LL;\n                do {\n                  while (1) {\n                    v6 = v4->Left;\n                    if (!v4->Left) break;\n                    v30 = v5;\n                    v29 = v4;\n                    v7 = 0LL;\n                    do {\n                      while (1) {\n                        Right = v6->Left;\n                        if (!v6->Left) break;\n                        v31 = v7;\n                        v32 = v6;\n                        v9 = 0LL;\n                        do {\n                          while (1) {\n                            v10 = Right->Left;\n                            if (!Right->Left) break;\n                            v34 = v9;\n                            v33 = Right;\n                            v11 = 0LL;\n                            do {\n                              while (1) {\n                                v12 = (long long *)v10->Left;\n                                v13 = 0LL;\n                                if (!v10->Left) break;\n                                do {\n                                  while (1) {\n                                    v14 = *v12;\n                                    v15 = 0LL;\n                                    if (!*v12) break;\n                                    while (1) {\n                                      while (*(uint64_t *)v14) {\n                                        v16 = breadth(*(TreeNode **)v14);\n                                        v14 = *(uint64_t *)(v14 + 8);\n                                        v15 += v16;\n                                        if (!v14) {\n                                          v12 = (long long *)v12[1];\n                                          v13 += v15;\n                                          goto LABEL_20;\n                                        }\n                                      }\n                                      v14 = *(uint64_t *)(v14 + 8);\n                                      if (!v14) break;\n                                      v15 += breadth(0LL);\n                                    }\n                                    v12 = (long long *)v12[1];\n                                    v13 += v15 + 1;\n                                  LABEL_20:\n                                    if (!v12) {\n                                      v10 = v10->Right;\n                                      v11 += v13;\n                                      goto LABEL_22;\n                                    }\n                                  }\n                                  v12 = (long long *)v12[1];\n                                } while (v12);\n                                v10 = v10->Right;\n                                v11 += v13 + 1;\n                              LABEL_22:\n                                if (!v10) {\n                                  v17 = v11;\n                                  Right = v33->Right;\n                                  v9 = v17 + v34;\n                                  goto LABEL_24;\n                                }\n                              }\n                              v10 = v10->Right;\n                            } while (v10);\n                            v9 = v34 + v11 + 1;\n                            Right = v33->Right;\n                          LABEL_24:\n                            if (!Right) {\n                              v18 = v9;\n                              v6 = v32->Right;\n                              v7 = v18 + v31;\n                              goto LABEL_26;\n                            }\n                          }\n                          Right = Right->Right;\n                        } while (Right);\n                        v7 = v9 + v31 + 1;\n                        v6 = v32->Right;\n                      LABEL_26:\n                        if (!v6) {\n                          v19 = v7;\n                          v4 = v29->Right;\n                          v5 = v19 + v30;\n                          goto LABEL_28;\n                        }\n                      }\n                      v6 = v6->Right;\n                    } while (v6);\n                    v5 = v30 + v7 + 1;\n                    v4 = v29->Right;\n                  LABEL_28:\n                    if (!v4) {\n                      v25 += v5;\n                      v3 = v28->Right;\n                      goto LABEL_30;\n                    }\n                  }\n                  v4 = v4->Right;\n                } while (v4);\n                v22 = v5 + v25 + 1;\n                v3 = v28->Right;\n                v25 = v22;\n              LABEL_30:\n                if (!v3) {\n                  v23 += v25;\n                  Left = v27->Right;\n                  if (Left) goto LABEL_5;\n                  goto LABEL_32;\n                }\n              }\n              v3 = v3->Right;\n            } while (v3);\n            Left = v27->Right;\n            v23 += v25 + 1;\n            if (Left) continue;\n          LABEL_32:\n            v24 += v23;\n            v1 = v26->Right;\n            if (v1) goto LABEL_3;\n            return v24;\n          }\n          break;\n        }\n        Left = Left->Right;\n      } while (Left);\n      v1 = v26->Right;\n      v24 += v23 + 1;\n      if (!v1) return v24;\n    }\n    v1 = v1->Right;\n  } while (v1);\n  return v24 + 1;\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<breadth>:\nendbr64\ntest   %rdi,%rdi\nje     1ae6 <breadth+0x366>\npush   %r15\nxor    %r8d,%r8d\nmov    %rdi,%rcx\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %r8,0x8(%rsp)\nmov    (%rcx),%rsi\nmovq   $0x0,(%rsp)\ntest   %rsi,%rsi\nje     1acb <breadth+0x34b>\nmov    %rcx,0x18(%rsp)\nmov    %rsi,%r15\nmov    (%r15),%rcx\nxor    %r11d,%r11d\ntest   %rcx,%rcx\nje     1a94 <breadth+0x314>\nmov    %r11,0x10(%rsp)\nmov    %r15,0x20(%rsp)\nmov    %rcx,%r15\nmov    (%r15),%rbx\nxor    %r11d,%r11d\ntest   %rbx,%rbx\nje     1a5e <breadth+0x2de>\nmov    %r15,0x28(%rsp)\nmov    %r11,%r15\nmov    (%rbx),%rbp\nxor    %ecx,%ecx\ntest   %rbp,%rbp\nje     1964 <breadth+0x1e4>\nmov    %r15,0x38(%rsp)\nmov    %rbx,0x30(%rsp)\nmov    %rcx,%rbx\nmov    0x0(%rbp),%r12\nxor    %r15d,%r15d\ntest   %r12,%r12\nje     19f4 <breadth+0x274>\nmov    %rbx,0x40(%rsp)\nmov    %rbp,0x48(%rsp)\nmov    %r15,%rbp\nmov    (%r12),%r13\nxor    %r15d,%r15d\ntest   %r13,%r13\nje     19cb <breadth+0x24b>\nmov    %rbp,0x58(%rsp)\nmov    %r12,0x50(%rsp)\nmov    %r15,%r12\nnopw   0x0(%rax,%rax,1)\nmov    0x0(%r13),%rbx\nxor    %ebp,%ebp\ntest   %rbx,%rbx\nje     1a20 <breadth+0x2a0>\nnop\nmov    (%rbx),%r14\nxor    %r15d,%r15d\ntest   %r14,%r14\nje     19b0 <breadth+0x230>\nnop\nmov    (%r14),%rdi\ntest   %rdi,%rdi\nje     1990 <breadth+0x210>\ncall   1780 <breadth>\nmov    0x8(%r14),%r14\nadd    %rax,%r15\ntest   %r14,%r14\njne    1870 <breadth+0xf0>\nmov    0x8(%rbx),%rbx\nadd    %r15,%rbp\ntest   %rbx,%rbx\njne    1860 <breadth+0xe0>\nmov    0x8(%r13),%r13\nadd    %rbp,%r12\ntest   %r13,%r13\njne    1850 <breadth+0xd0>\nmov    %r12,%r15\nmov    0x50(%rsp),%r12\nmov    0x58(%rsp),%rbp\nmov    0x8(%r12),%r12\nadd    %r15,%rbp\ntest   %r12,%r12\njne    182d <breadth+0xad>\nmov    %rbp,%r15\nmov    0x48(%rsp),%rbp\nmov    0x40(%rsp),%rbx\nmov    0x8(%rbp),%rbp\nadd    %r15,%rbx\ntest   %rbp,%rbp\njne    1810 <breadth+0x90>\nmov    %rbx,%rcx\nmov    0x30(%rsp),%rbx\nmov    0x38(%rsp),%r15\nmov    0x8(%rbx),%rbx\nadd    %rcx,%r15\ntest   %rbx,%rbx\njne    17f5 <breadth+0x75>\nmov    %r15,%r11\nmov    0x28(%rsp),%r15\nadd    %r11,0x10(%rsp)\nmov    0x8(%r15),%r15\ntest   %r15,%r15\njne    17de <breadth+0x5e>\nmov    0x20(%rsp),%r15\nmov    0x10(%rsp),%r11\nadd    %r11,(%rsp)\nmov    0x8(%r15),%r15\ntest   %r15,%r15\njne    17c2 <breadth+0x42>\nmov    0x18(%rsp),%rcx\nmov    (%rsp),%rdx\nadd    %rdx,0x8(%rsp)\nmov    0x8(%rcx),%rcx\ntest   %rcx,%rcx\njne    17a6 <breadth+0x26>\nmov    0x8(%rsp),%r8\nadd    $0x68,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\njne    17f5 <breadth+0x75>\nmov    0x10(%rsp),%rax\nmov    %r15,%r11\nmov    0x28(%rsp),%r15\nlea    0x1(%r11,%rax,1),%rax\nmov    0x8(%r15),%r15\nmov    %rax,0x10(%rsp)\njmp    190e <breadth+0x18e>\nxchg   %ax,%ax\nmov    0x8(%r14),%r14\ntest   %r14,%r14\nje     1a50 <breadth+0x2d0>\nxor    %edi,%edi\ncall   1780 <breadth>\nadd    %rax,%r15\njmp    1870 <breadth+0xf0>\nnopl   0x0(%rax)\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\njne    1860 <breadth+0xe0>\nmov    0x8(%r13),%r13\nlea    0x1(%rbp,%r12,1),%r12\njmp    18a0 <breadth+0x120>\nmov    0x8(%r12),%r12\ntest   %r12,%r12\njne    182d <breadth+0xad>\nmov    %rbp,%r15\nmov    0x40(%rsp),%rbx\nmov    0x48(%rsp),%rbp\nlea    0x1(%r15,%rbx,1),%rbx\nmov    0x8(%rbp),%rbp\njmp    18d7 <breadth+0x157>\nmov    0x8(%rbp),%rbp\ntest   %rbp,%rbp\njne    1810 <breadth+0x90>\nmov    %rbx,%rcx\nmov    0x38(%rsp),%r15\nmov    0x30(%rsp),%rbx\nlea    0x1(%r15,%rcx,1),%r15\nmov    0x8(%rbx),%rbx\njmp    18f4 <breadth+0x174>\nnopl   0x0(%rax)\nmov    0x8(%r13),%r13\ntest   %r13,%r13\njne    1850 <breadth+0xd0>\nmov    %r12,%r15\nmov    0x58(%rsp),%rbp\nmov    0x50(%rsp),%r12\nlea    0x1(%rbp,%r15,1),%rbp\nmov    0x8(%r12),%r12\njmp    18ba <breadth+0x13a>\nnopl   0x0(%rax)\nmov    0x8(%rbx),%rbx\nlea    0x1(%r15,%rbp,1),%rbp\njmp    1894 <breadth+0x114>\nmov    0x8(%r15),%r15\ntest   %r15,%r15\njne    17de <breadth+0x5e>\nmov    0x20(%rsp),%r15\nmov    (%rsp),%rax\nmov    0x10(%rsp),%r11\nmov    0x8(%r15),%r15\nlea    0x1(%rax,%r11,1),%rax\nmov    %rax,(%rsp)\ntest   %r15,%r15\njne    17c2 <breadth+0x42>\njmp    1932 <breadth+0x1b2>\nmov    0x8(%r15),%r15\ntest   %r15,%r15\njne    17c2 <breadth+0x42>\nmov    0x18(%rsp),%rcx\nmov    0x8(%rsp),%rdx\nmov    (%rsp),%rax\nmov    0x8(%rcx),%rcx\nlea    0x1(%rax,%rdx,1),%rax\nmov    %rax,0x8(%rsp)\ntest   %rcx,%rcx\njne    17a6 <breadth+0x26>\njmp    194d <breadth+0x1cd>\nmov    0x8(%rcx),%rcx\ntest   %rcx,%rcx\njne    17a6 <breadth+0x26>\nmov    0x8(%rsp),%r8\nadd    $0x1,%r8\njmp    1952 <breadth+0x1d2>\nxor    %eax,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "avl-tree/avl-tree.c", "function_name": "main", "content": "int main(int argc, char** argv)\n{\n    TreeNode *tree = NULL, *newTree = NULL;\n    Element newItem = NULL;\n    char *itemName = NULL;\n    long i = 0, topsize = 0, tick = 0, last = 0;\n    long height = 0, oldheight = 0;\n    \n    /* get the command argument, used for a custom size parameter */\n    topsize = 25;\n    tick = topsize / 20;\n    \n    libmin_srand(42);\n    libmin_printf(\"Start  -->  Finished\\n\");\n    for(i = 0; i < topsize; i++) {\n        newItem = libmin_malloc(sizeof(Element));\n        itemName = libmin_malloc(sizeof(char) * 11);\n        libmin_snprintf(itemName, 11, \"Name%ld\", i);\n        do  {\n            *newItem = libmin_rand();\n            newTree = Insert(tree, newItem, itemName);\n            if(newTree == NULL) {\n                if(last == *newItem)    {\n                    libmin_free(itemName);\n                    libmin_free(newItem);\n                    libmin_printf(\"going to try and skip: %ld\\n\", *newItem);\n                    break;\n                } else\n                    last = *newItem;\n            }\n        } while(newTree == NULL);\n        if(i % tick == 0)   {\n            libmin_printf(\".\");\n        }\n        tree = newTree;\n    }\n    libmin_printf(\"\\n\");\n    \n    /* test out the delete functionality */\n    libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *tree->Item);\n    newTree = DeleteByElement(tree, tree->Item);\n    if(newTree == NULL)\n        libmin_printf(\"failure!\\n\");\n    else {\n        tree = newTree;\n        libmin_printf(\"success! new root is %ld\\n\", *tree->Item);\n    }\n    libmin_printf(\"\\nGoing to delete leftMost child... \");\n    for(newTree = tree;\n        newTree != NULL && newTree->Left != NULL;\n        newTree = newTree->Left)    {}\n    if(newTree != NULL) {\n        libmin_printf(\"found item: %ld\\n\", *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n    }\n    /* duplicated from left side */\n    libmin_printf(\"\\nGoing to delete rightMost child... \");\n    for(newTree = tree;\n        newTree != NULL && newTree->Right != NULL;\n        newTree = newTree->Right)   {}\n    if(newTree != NULL) {\n        libmin_printf(\"found item: %ld\\n\", *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n    }\n    libmin_printf(\"\\n\");\n\t\n    if(topsize <= 25)\n        printTree(tree, 0);\n    libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\",\n           breadth(tree->Left), breadth(tree->Right));\n    oldheight = Height(tree->Left);\n    libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\",\n           oldheight, Height(tree->Right));\n\n    last = (long)(INT_MAX / 2);\n    for(i = 0; i < 3; i++)  {\n        libmin_printf(\"\\n\");\n        height = libmin_rand() % oldheight;\n        libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\",\n                oldheight, height);\n        newTree = tree;\n        do  {\n            if(newTree->Left == NULL)   {\n                if(newTree->Right == NULL)\n                    break;\n                tick = last + 1;\n            } else if(newTree->Right == NULL)\n                tick = last - 1;\n            else\n                tick = libmin_rand();\n            newTree = (tick >= last ? newTree->Right : newTree->Left);\n            height--;\n        } while(height > 0);\n        libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                newTree->Name, *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n        oldheight = (int)(oldheight * 0.6);\n    }\n    \n    MakeEmpty(tree);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // r14\n  __int64 v4; // r13\n  TreeNode *v5; // r12\n  int *v6; // rbx\n  char *v7; // rbp\n  TreeNode *v8; // r15\n  TreeNode *v9; // rax\n  TreeNode *v10; // rbx\n  TreeNode *v11; // rax\n  TreeNode *v12; // r12\n  TreeNode *v13; // rax\n  TreeNode *v14; // r12\n  TreeNode *v15; // rax\n  TreeNode *v16; // rbx\n  TreeNode *v17; // rax\n  TreeNode *v18; // rbp\n  __int64 v19; // rax\n  __int64 v20; // r9\n  __int64 v21; // rbx\n  __int64 v22; // rax\n  TreeNode *v23; // r12\n  __int64 v24; // r14\n  TreeNode *Left; // rax\n  TreeNode *Right; // rsi\n  TreeNode *v27; // rax\n  bool v28; // zf\n  TreeNode *v29; // r8\n  TreeNode *newTree; // [rsp+0h] [rbp-48h]\n  __int64 v31; // [rsp+8h] [rbp-40h]\n\n  v3 = 0LL;\n  v4 = 0LL;\n  v5 = 0LL;\n  libmin_srand(0x2Au);\n  libmin_printf(\"Start  -->  Finished\\n\", argv);\n  while ( 1 )\n  {\n    v6 = (int *)libmin_malloc(8uLL);\n    v7 = (char *)libmin_malloc(0xBuLL);\n    libmin_snprintf(v7, 0xBuLL, \"Name%ld\", v3);\n    while ( 1 )\n    {\n      *v6 = libmin_rand();\n      v8 = Insert(v5, v6, v7);\n      if ( v8 )\n        goto LABEL_2;\n      if ( *v6 == v4 )\n        break;\n      v4 = *v6;\n    }\n    libmin_free(v7);\n    libmin_free(v6);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*v6);\nLABEL_2:\n    ++v3;\n    libmin_printf(\".\");\n    if ( v3 == 25 )\n      break;\n    v5 = v8;\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *(unsigned int *)v8->Item);\n  v9 = DeleteByElement(v8, v8->Item);\n  v10 = v9;\n  if ( v9 )\n  {\n    libmin_printf(\"success! new root is %ld\\n\", *(unsigned int *)v9->Item);\n  }\n  else\n  {\n    v10 = v8;\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf(\"\\nGoing to delete leftMost child... \");\n  v11 = v10;\n  do\n  {\n    v12 = v11;\n    v11 = v11->Left;\n  }\n  while ( v11 );\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)v12->Item);\n  v13 = DeleteByElement(v10, v12->Item);\n  v14 = v13;\n  if ( v13 )\n  {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v13->Item);\n  }\n  else\n  {\n    v14 = v10;\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf(\"\\nGoing to delete rightMost child... \");\n  v15 = v14;\n  do\n  {\n    v16 = v15;\n    v15 = v15->Right;\n  }\n  while ( v15 );\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)v16->Item);\n  v17 = DeleteByElement(v14, v16->Item);\n  v18 = v17;\n  if ( v17 )\n  {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v17->Item);\n  }\n  else\n  {\n    v18 = v14;\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf((char *)\"\\n\");\n  printTree_0(v18, 0LL);\n  breadth(v18->Right);\n  v19 = breadth(v18->Left);\n  libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v19, v20);\n  v21 = Height(v18->Left);\n  v22 = Height(v18->Right);\n  libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", v21, v22);\n  v31 = 3LL;\nLABEL_20:\n  v23 = v18;\n  libmin_printf((char *)\"\\n\");\n  v24 = libmin_rand() % v21;\n  libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\", v21, v24);\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      Left = v23->Left;\n      Right = v23->Right;\n      if ( !v23->Left )\n      {\n        if ( !Right )\n          goto LABEL_28;\n        goto LABEL_27;\n      }\n      if ( Right )\n        break;\nLABEL_24:\n      --v24;\n      v23 = Left;\n      if ( v24 <= 0 )\n        goto LABEL_28;\n    }\n    if ( libmin_rand() <= 0x3FFFFFFE )\n    {\n      Left = v23->Left;\n      goto LABEL_24;\n    }\n    Right = v23->Right;\nLABEL_27:\n    --v24;\n    v23 = Right;\n    if ( v24 <= 0 )\n    {\nLABEL_28:\n      libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\", v23->Name, *(unsigned int *)v23->Item);\n      v27 = DeleteByElement(v18, v23->Item);\n      if ( v27 )\n      {\n        newTree = v27;\n        libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v27->Item);\n        v28 = v31-- == 1;\n        v29 = newTree;\n        v21 = (int)((double)(int)v21 * 0.6);\n        if ( !v28 )\n          goto LABEL_30;\nLABEL_33:\n        MakeEmpty(v29);\n        libmin_success();\n      }\n      libmin_printf(\"failure!\\n\");\n      v28 = v31-- == 1;\n      v29 = v18;\n      v21 = (int)((double)(int)v21 * 0.6);\n      if ( v28 )\n        goto LABEL_33;\nLABEL_30:\n      v18 = v29;\n      goto LABEL_20;\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  TreeNode *v5;\n  int *v6;\n  char *v7;\n  TreeNode *v8;\n  TreeNode *v9;\n  TreeNode *v10;\n  TreeNode *v11;\n  TreeNode *v12;\n  TreeNode *v13;\n  TreeNode *v14;\n  TreeNode *v15;\n  TreeNode *v16;\n  TreeNode *v17;\n  TreeNode *v18;\n  long long v19;\n  long long v20;\n  long long v21;\n  long long v22;\n  TreeNode *v23;\n  long long v24;\n  TreeNode *Left;\n  TreeNode *Right;\n  TreeNode *v27;\n  bool v28;\n  TreeNode *v29;\n  TreeNode *newTree;\n  long long v31;\n  v3 = 0LL;\n  v4 = 0LL;\n  v5 = 0LL;\n  libmin_srand(42u);\n  libmin_printf(\"Start  -->  Finished\\n\", argv);\n  while (1) {\n    v6 = (int *)libmin_malloc(8uLL);\n    v7 = (char *)libmin_malloc(11uLL);\n    libmin_snprintf(v7, 11uLL, \"Name%ld\", v3);\n    while (1) {\n      *v6 = libmin_rand();\n      v8 = Insert(v5, v6, v7);\n      if (v8) goto LABEL_2;\n      if (*v6 == v4) break;\n      v4 = *v6;\n    }\n    libmin_free(v7);\n    libmin_free(v6);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*v6);\n  LABEL_2:\n    ++v3;\n    libmin_printf(\".\");\n    if (v3 == 25) break;\n    v5 = v8;\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\",\n                *(unsigned int *)v8->Item);\n  v9 = DeleteByElement(v8, v8->Item);\n  v10 = v9;\n  if (v9) {\n    libmin_printf(\"success! new root is %ld\\n\", *(unsigned int *)v9->Item);\n  } else {\n    v10 = v8;\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf(\"\\nGoing to delete leftMost child... \");\n  v11 = v10;\n  do {\n    v12 = v11;\n    v11 = v11->Left;\n  } while (v11);\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)v12->Item);\n  v13 = DeleteByElement(v10, v12->Item);\n  v14 = v13;\n  if (v13) {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v13->Item);\n  } else {\n    v14 = v10;\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf(\"\\nGoing to delete rightMost child... \");\n  v15 = v14;\n  do {\n    v16 = v15;\n    v15 = v15->Right;\n  } while (v15);\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)v16->Item);\n  v17 = DeleteByElement(v14, v16->Item);\n  v18 = v17;\n  if (v17) {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v17->Item);\n  } else {\n    v18 = v14;\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf((char *)\"\\n\");\n  printTree_0(v18, 0LL);\n  breadth(v18->Right);\n  v19 = breadth(v18->Left);\n  libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v19, v20);\n  v21 = Height(v18->Left);\n  v22 = Height(v18->Right);\n  libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", v21, v22);\n  v31 = 3LL;\nLABEL_20:\n  v23 = v18;\n  libmin_printf((char *)\"\\n\");\n  v24 = libmin_rand() % v21;\n  libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\", v21,\n                v24);\n  while (1) {\n    while (1) {\n      Left = v23->Left;\n      Right = v23->Right;\n      if (!v23->Left) {\n        if (!Right) goto LABEL_28;\n        goto LABEL_27;\n      }\n      if (Right) break;\n    LABEL_24:\n      --v24;\n      v23 = Left;\n      if (v24 <= 0) goto LABEL_28;\n    }\n    if (libmin_rand() <= 1073741822) {\n      Left = v23->Left;\n      goto LABEL_24;\n    }\n    Right = v23->Right;\n  LABEL_27:\n    --v24;\n    v23 = Right;\n    if (v24 <= 0) {\n    LABEL_28:\n      libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                    v23->Name, *(unsigned int *)v23->Item);\n      v27 = DeleteByElement(v18, v23->Item);\n      if (v27) {\n        newTree = v27;\n        libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v27->Item);\n        v28 = v31-- == 1;\n        v29 = newTree;\n        v21 = (int)((double)(int)v21 * 0.6);\n        if (!v28) goto LABEL_30;\n      LABEL_33:\n        MakeEmpty(v29);\n        libmin_success();\n      }\n      libmin_printf(\"failure!\\n\");\n      v28 = v31-- == 1;\n      v29 = v18;\n      v21 = (int)((double)(int)v21 * 0.6);\n      if (v28) goto LABEL_33;\n    LABEL_30:\n      v18 = v29;\n      goto LABEL_20;\n    }\n  }\n}", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x2a,%edi\npush   %r14\nxor    %r14d,%r14d\npush   %r13\nxor    %r13d,%r13d\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   6040 <libmin_srand>\nlea    0x5ede(%rip),%rdi\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\njmp    1177 <main+0x57>\nnopl   (%rax)\nlea    0x5f05(%rip),%rdi\nxor    %eax,%eax\nadd    $0x1,%r14\ncall   5e30 <libmin_printf>\ncmp    $0x19,%r14\nje     1205 <main+0xe5>\nmov    %r15,%r12\nmov    $0x8,%edi\ncall   3af0 <libmin_malloc>\nmov    $0xb,%edi\nmov    %rax,%rbx\ncall   3af0 <libmin_malloc>\nmov    %r14,%rcx\nmov    $0xb,%esi\nlea    0x5ea3(%rip),%rdx\nmov    %rax,%rbp\nmov    %rax,%rdi\nxor    %eax,%eax\ncall   5f70 <libmin_snprintf>\nnopw   0x0(%rax,%rax,1)\ncall   60a0 <libmin_rand>\nmov    %rbp,%rdx\nmov    %rbx,%rsi\nmov    %r12,%rdi\nmov    %eax,(%rbx)\ncall   1f40 <Insert>\nmov    %rax,%r15\ntest   %rax,%rax\njne    1158 <main+0x38>\nmovslq (%rbx),%rax\ncmp    %r13,%rax\nje     11e0 <main+0xc0>\nmov    %rax,%r13\njmp    11b0 <main+0x90>\nnopw   0x0(%rax,%rax,1)\nmov    %rbp,%rdi\ncall   3ba0 <libmin_free>\nmov    %rbx,%rdi\ncall   3ba0 <libmin_free>\nmov    (%rbx),%esi\nlea    0x5e4f(%rip),%rdi\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\njmp    1158 <main+0x38>\nlea    0x5e62(%rip),%r13\nxor    %eax,%eax\nmov    %r13,%rdi\ncall   5e30 <libmin_printf>\nmov    0x10(%r15),%rax\nlea    0x5e97(%rip),%rdi\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\nmov    0x10(%r15),%rsi\nmov    %r15,%rdi\ncall   2e50 <DeleteByElement>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     14d9 <main+0x3b9>\nmov    0x10(%rax),%rax\nlea    0x5e23(%rip),%rdi\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\nlea    0x5e83(%rip),%rdi\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\nmov    %rbx,%rax\nnopw   0x0(%rax,%rax,1)\nmov    %rax,%r12\nmov    (%rax),%rax\ntest   %rax,%rax\njne    1270 <main+0x150>\nmov    0x10(%r12),%rax\nlea    0x5e03(%rip),%rbp\nmov    %rbp,%rdi\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\nmov    0x10(%r12),%rsi\nmov    %rbx,%rdi\ncall   2e50 <DeleteByElement>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1505 <main+0x3e5>\nmov    0x10(%rax),%rax\nlea    0x5de4(%rip),%rdi\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\nlea    0x5e41(%rip),%rdi\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\nmov    %r12,%rax\nnopl   0x0(%rax)\nmov    %rax,%rbx\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    12d8 <main+0x1b8>\nmov    0x10(%rbx),%rax\nmov    %rbp,%rdi\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\nmov    0x10(%rbx),%rsi\nmov    %r12,%rdi\ncall   2e50 <DeleteByElement>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     14ef <main+0x3cf>\nmov    0x10(%rax),%rax\nlea    0x5d84(%rip),%rdi\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\nmov    %r13,%rdi\nxor    %eax,%eax\nlea    0x5e64(%rip),%r15\ncall   5e30 <libmin_printf>\nxor    %esi,%esi\nmov    %rbp,%rdi\ncall   1610 <printTree.part.0>\nmov    0x8(%rbp),%rdi\ncall   1780 <breadth>\nmov    0x0(%rbp),%rdi\nmov    %rax,%r9\ncall   1780 <breadth>\nmov    %r9,%rdx\nlea    0x5dd6(%rip),%rdi\nmov    %rax,%rsi\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\nmov    0x0(%rbp),%rdi\ncall   30d0 <Height>\nmov    0x8(%rbp),%rdi\nmov    %rax,%rbx\ncall   30d0 <Height>\nmov    %rbx,%rsi\nlea    0x5ddd(%rip),%rdi\nmov    %rax,%rdx\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\nmovq   $0x3,0x8(%rsp)\nmov    %r13,%rdi\nxor    %eax,%eax\nmov    %rbp,%r12\ncall   5e30 <libmin_printf>\ncall   60a0 <libmin_rand>\nmov    %rbx,%rsi\nmov    %r15,%rdi\nmov    %eax,%eax\ncqto\nidiv   %rbx\nxor    %eax,%eax\nmov    %rdx,%r14\ncall   5e30 <libmin_printf>\njmp    13ed <main+0x2cd>\nnopl   0x0(%rax)\ntest   %rsi,%rsi\nje     13e1 <main+0x2c1>\ncall   60a0 <libmin_rand>\ncmp    $0x3ffffffe,%eax\nja     1480 <main+0x360>\nmov    (%r12),%rax\nsub    $0x1,%r14\nmov    %rax,%r12\ntest   %r14,%r14\njle    140c <main+0x2ec>\nmov    (%r12),%rax\nmov    0x8(%r12),%rsi\ntest   %rax,%rax\njne    13c8 <main+0x2a8>\ntest   %rsi,%rsi\nje     140c <main+0x2ec>\nsub    $0x1,%r14\nmov    %rsi,%r12\ntest   %r14,%r14\njg     13ed <main+0x2cd>\nmov    0x10(%r12),%rax\nmov    0x18(%r12),%rsi\nlea    0x5dab(%rip),%rdi\nmov    (%rax),%edx\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\nmov    0x10(%r12),%rsi\nmov    %rbp,%rdi\ncall   2e50 <DeleteByElement>\nmov    %rax,%r8\ntest   %rax,%rax\nje     148a <main+0x36a>\nmov    0x10(%rax),%rax\nlea    0x5c55(%rip),%rdi\nmov    %r8,(%rsp)\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   5e30 <libmin_printf>\npxor   %xmm0,%xmm0\nsubq   $0x1,0x8(%rsp)\nmov    (%rsp),%r8\ncvtsi2sd %rbx,%xmm0\nmulsd  0x5d92(%rip),%xmm0\ncvttsd2si %xmm0,%ebx\nmovslq %ebx,%rbx\nje     14bb <main+0x39b>\nmov    %r8,%rbp\njmp    1396 <main+0x276>\nnop\nmov    0x8(%r12),%rsi\njmp    1400 <main+0x2e0>\nxor    %eax,%eax\nlea    0x5bd3(%rip),%rdi\ncall   5e30 <libmin_printf>\npxor   %xmm0,%xmm0\nsubq   $0x1,0x8(%rsp)\nmov    %rbp,%r8\ncvtsi2sd %rbx,%xmm0\nmulsd  0x5d4e(%rip),%xmm0\ncvttsd2si %xmm0,%ebx\nmovslq %ebx,%rbx\njne    1477 <main+0x357>\nmov    %r8,%rdi\ncall   2090 <MakeEmpty>\ncall   6290 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x5b86(%rip),%rdi\nxor    %eax,%eax\nmov    %r15,%rbx\ncall   5e30 <libmin_printf>\njmp    1256 <main+0x136>\nlea    0x5b70(%rip),%rdi\nxor    %eax,%eax\nmov    %r12,%rbp\ncall   5e30 <libmin_printf>\njmp    1320 <main+0x200>\nlea    0x5b5a(%rip),%rdi\nxor    %eax,%eax\nmov    %rbx,%r12\ncall   5e30 <libmin_printf>\njmp    12c0 <main+0x1a0>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "avl-tree/avl-tree.c", "function_name": "printTree", "content": "/* A balanced binary search tree(AVLTree) implementation\n * Written by Coleman\n * Released under GNU GPL Version 2 or later(http://www.gnu.org/)\n */\n#include \"libmin.h\"\n#include \"element.h\"\n#include \"avlcore.h\"\n\n#define MAXELEMENTSIZE 500000\n\nvoid printTree(TreeNode *start, long level)\n{\n    long i = 0;\n    if(start == NULL)\n        return;\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name,\n\t\t\t\t*start->Item, start->Balance);\n    for(i = 0; i < level; i++)\n        libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(start->Left, level + 1);\n    libmin_printf(\"\\n\");\n    for(i = 0; i < level; i++)\n        libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(start->Right, level + 1);\n    if(level == 0)\n        libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O3.pseudo", "function_name": "printTree", "address": "0x1760", "label": "printTree", "content": "void __fastcall printTree(TreeNode *start, __int64 level)\n{\n  if ( start )\n    printTree_0(start, level);\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O3", "assembly": "<printTree>:\nendbr64\ntest   %rdi,%rdi\nje     1770 <printTree+0x10>\njmp    1610 <printTree.part.0>\nxchg   %ax,%ax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "banner/banner.c", "function_name": "main", "content": "int\nmain(void)\n{ \n\tint ch;\n\n\twhile ((ch = libmin_getopt(argc, argv, \"w:tdh\")) != -1)\n\t\tswitch (ch) {\n\t\tcase 'd':\n\t\t\tdebug = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twidth = libmin_atoi(optarg);\n\t\t\tif (width <= 0)\n\t\t\t\tlibmin_printf(\"error: illegal argument for -w option\\n\");\n\t\t\tbreak;\n\t\tcase '?': case 'h':\n\t\tdefault:\n\t\t\tlibmin_printf(\"usage: banner [-w width]\\n\");\n\t\t\tlibmin_fail(1);\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tfor (i = 0; i < width; i++) {\n\t\tj = i * 132 / width;\n\t\tprint[j] = 1;\n\t}\n\n\t/* Have now read in the data. Next get the message to be printed. */\n\tif (*argv) {\n\t\tlibmin_strncpy(message, *argv, sizeof message);\n\t\twhile (*++argv) {\n\t\t\tlibmin_strncat(message, \" \", sizeof message);\n\t\t\tlibmin_strncat(message, *argv, sizeof message);\n\t\t}\n\t\tnchars = libmin_strlen(message);\n\t} else {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n\t}\n\n\t/* some debugging print statements */\n\tif (debug) {\n\t\tlibmin_printf(\"int asc_ptr[128] = {\\n\");\n\t\tfor (i = 0; i < 128; i++) {\n\t\t\tlibmin_printf(\"%4d,   \",asc_ptr[i]);\n\t\t\tif ((i+1) % 8 == 0)\n\t\t\t\tlibmin_printf(\"\\n\");\n\t\t}\n\t\tlibmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n\t\tlibmin_printf(\"  /*   \");\n\t\tfor (i = 0; i < 10; i++) libmin_printf(\" %3d  \",i);\n\t\tlibmin_printf(\"   */\\n\");\n\t\tfor (i = 0; i < NBYTES; i += 10) {\n\t\t\tlibmin_printf(\"/* %4d */  \",i);\n\t\t\tfor (j = i; j < i+10; j++) { \n\t\t\t\tx = data_table[j] & 0377;\n\t\t\t\tlibmin_printf(\" %3d, \",x);\n\t\t\t}\n\t\t\tlibmin_putc('\\n');\n\t\t}\n\t\tlibmin_printf(\"};\\n\");\n\t}\n\n\t/* check message to make sure it's legal */\n\tj = 0;\n\tfor (i = 0; i < nchars; i++)\n\t\tif ((uint8_t) message[i] >= NCHARS ||\n\t\t    asc_ptr[(uint8_t) message[i]] == 0) {\n\t\t\tlibmin_printf(\"The character is not in my character set\\n\");\n\t\t\tj++;\n\t\t}\n\tif (j)\n\t\tlibmin_fail(1);\n\n\t/* Now have message. Print it one character at a time.  */\n\n\tfor (i = 0; i < nchars; i++) {\n\t\tfor (j = 0; j < DWIDTH; j++) line[j] = ' ';\n\t\tpc = asc_ptr[(uint8_t) message[i]];\n\t\tterm = 0;\n\t\tmax = 0;\n\t\tlinen = 0;\n\t\twhile (!term) {\n\t\t\tif (pc < 0 || pc >= NBYTES) {\n\t\t\t\tlibmin_printf(\"bad pc: %d\\n\",pc);\n\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\t\tx = data_table[pc] & 0377;\n\t\t\tif (x >= 128) {\n\t\t\t\tif (x>192) term++;\n\t\t\t\tx = x & 63;\n\t\t\t\twhile (x--) {\n\t\t\t\t\tif (print[linen++]) {\n\t\t\t\t\t\tfor (j=0; j <= max; j++)\n\t\t\t\t\t\t\tif (print[j])\n\t\t\t\t\t\t\t\tlibmin_putc(line[j]);\n\t\t\t\t\t\tlibmin_putc('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < DWIDTH; j++) line[j] = ' ';\n\t\t\t\tpc++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty = data_table[pc+1];\n\t\t\t\t/* compensate for narrow teminals */\n#ifdef notdef\n\t\t\t\tx = (x*width + (DWIDTH/2)) / DWIDTH;\n\t\t\t\ty = (y*width + (DWIDTH/2)) / DWIDTH;\n#endif\n\t\t\t\tmax = x+y;\n\t\t\t\twhile (x < max) line[x++] = '#';\n\t\t\t\tpc += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tlibmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "banner/banner.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int v4; // edi\n  char **v5; // r9\n  int v6; // r8d\n  int v7; // ecx\n  int v8; // eax\n  int v9; // eax\n  bool v10; // zf\n  int v11; // ecx\n  int v12; // eax\n  __int64 v13; // rdx\n  int v14; // eax\n  unsigned int v15; // r15d\n  int v16; // ecx\n  int i; // r8d\n  char v18; // di\n  int v19; // eax\n  char *v20; // rdx\n  int v21; // ecx\n  int v22; // r9d\n  int v23; // r8d\n  int v24; // eax\n  int v25; // r14d\n  int v26; // ecx\n  int v27; // eax\n  int v28; // eax\n  int v29; // esi\n  int v30; // esi\n  int v31; // eax\n\n  while ( 1 )\n  {\n    v3 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if ( v3 == -1 )\n      break;\n    if ( v3 == 100 )\n    {\n      debug = 1;\n    }\n    else\n    {\n      if ( v3 != 119 )\n      {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if ( width <= 0 )\n        libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  v4 = width;\n  ::i = 0;\n  ::argc -= optind;\n  v5 = &::argv[optind];\n  ::argv = v5;\n  if ( width > 0 )\n  {\n    v6 = 132 * width;\n    v7 = 0;\n    do\n    {\n      v8 = v7;\n      v7 += 132;\n      v9 = v8 / v4;\n      print[v9] = 1;\n    }\n    while ( v6 != v7 );\n    j = v9;\n    ::i = v4;\n  }\n  if ( !*v5 )\n  {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n  }\n  libmin_strncpy(message, *v5, 0x400uLL);\n  v10 = ::argv[1] == 0LL;\n  for ( ++::argv; !v10; ++::argv )\n  {\n    libmin_strncat(message, \" \", 0x400uLL);\n    libmin_strncat(message, *::argv, 0x400uLL);\n    v10 = ::argv[1] == 0LL;\n  }\n  nchars = libmin_strlen(message);\n  if ( debug )\n  {\n    libmin_printf(\"int asc_ptr[128] = {\\n\");\n    v28 = 0;\n    ::i = 0;\n    do\n    {\n      while ( 1 )\n      {\n        libmin_printf(\"%4d,   \", asc_ptr[v28]);\n        v28 = ::i + 1;\n        if ( (((_BYTE)::i + 1) & 7) == 0 )\n          break;\n        ++::i;\n        if ( v28 > 127 )\n          goto LABEL_52;\n      }\n      libmin_printf((char *)\"\\n\");\n      v28 = ::i + 1;\n      ::i = v28;\n    }\n    while ( v28 <= 127 );\nLABEL_52:\n    libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n    libmin_printf(\"  /*   \");\n    v29 = 0;\n    ::i = 0;\n    do\n    {\n      libmin_printf(\" %3d  \", v29);\n      v29 = ::i + 1;\n      ::i = v29;\n    }\n    while ( v29 <= 9 );\n    libmin_printf(\"   */\\n\");\n    v30 = 0;\n    ::i = 0;\n    do\n    {\n      libmin_printf(\"/* %4d */  \", v30);\n      v31 = ::i;\n      j = ::i;\n      do\n      {\n        x = (unsigned __int8)data_table[v31];\n        libmin_printf(\" %3d, \", x);\n        v31 = j + 1;\n        j = v31;\n      }\n      while ( v31 <= ::i + 9 );\n      libmin_putc(10);\n      v30 = ::i + 10;\n      ::i = v30;\n    }\n    while ( v30 <= 9270 );\n    libmin_printf(\"};\\n\");\n  }\n  v11 = nchars;\n  v12 = 0;\n  j = 0;\n  ::i = 0;\n  if ( nchars > 0 )\n  {\n    do\n    {\n      v13 = message[v12];\n      if ( (v13 & 0x80u) != 0LL || !asc_ptr[v13] )\n      {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++j;\n        v12 = ::i;\n        v11 = nchars;\n      }\n      ::i = ++v12;\n    }\n    while ( v12 < v11 );\n    if ( j )\n      libmin_fail(1);\n  }\n  v14 = 0;\n  for ( ::i = 0; ::i < nchars; v14 = ::i )\n  {\n    memset(line, 32, sizeof(line));\n    v15 = asc_ptr[(unsigned __int8)message[v14]];\n    j = 132;\n    pc = v15;\n    term = 0;\n    max = 0;\n    linen = 0;\n    do\n    {\n      if ( v15 > 0x2436 )\n      {\n        libmin_printf(\"bad pc: %d\\n\", v15);\n        libmin_fail(1);\n      }\n      v16 = (unsigned __int8)data_table[v15];\n      x = v16;\n      if ( (v16 & 0x80u) != 0 )\n      {\n        if ( v16 > 192 )\n          ++term;\n        for ( i = v16 & 0x3F; ; i = x )\n        {\n          v18 = 0;\n          v19 = linen;\n          v20 = &print[linen];\n          v21 = i + linen;\n          v22 = i + linen - 1;\n          do\n          {\n            v23 = v22 - v19;\n            if ( v21 == v19 )\n            {\n              x = v22 - v19;\n              if ( v18 )\n                linen = v21;\n              memset(line, 32, sizeof(line));\n              v15 = pc + 1;\n              j = 132;\n              goto LABEL_36;\n            }\n            ++v20;\n            ++v19;\n            v18 = 1;\n          }\n          while ( !*(v20 - 1) );\n          v26 = max;\n          linen = v19;\n          v27 = 0;\n          x = v23;\n          for ( j = 0; v27 <= max; j = v27 )\n          {\n            while ( !print[v27] )\n            {\n              j = ++v27;\n              if ( v27 > v26 )\n                goto LABEL_45;\n            }\n            libmin_putc(line[v27]);\n            v26 = max;\n            v27 = j + 1;\n          }\nLABEL_45:\n          libmin_putc(10);\n        }\n      }\n      v24 = data_table[v15 + 1];\n      v25 = v16 + v24;\n      y = v24;\n      max = v16 + v24;\n      if ( v16 < v16 + v24 )\n      {\n        memset(&line[v16], 35, (unsigned int)(v24 - 1) + 1LL);\n        x = v25;\n      }\n      v15 += 2;\nLABEL_36:\n      pc = v15;\n    }\n    while ( !term );\n    ++::i;\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  char **v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  bool v10;\n  int v11;\n  int v12;\n  long long v13;\n  int v14;\n  unsigned int v15;\n  int v16;\n  int i;\n  char v18;\n  int v19;\n  char *v20;\n  int v21;\n  int v22;\n  int v23;\n  int v24;\n  int v25;\n  int v26;\n  int v27;\n  int v28;\n  int v29;\n  int v30;\n  int v31;\n  while (1) {\n    v3 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if (v3 == -1) break;\n    if (v3 == 100) {\n      debug = 1;\n    } else {\n      if (v3 != 119) {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if (width <= 0) libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  v4 = width;\n  ::i = 0;\n  ::argc -= optind;\n  v5 = &::argv[optind];\n  ::argv = v5;\n  if (width > 0) {\n    v6 = 132 * width;\n    v7 = 0;\n    do {\n      v8 = v7;\n      v7 += 132;\n      v9 = v8 / v4;\n      print[v9] = 1;\n    } while (v6 != v7);\n    j = v9;\n    ::i = v4;\n  }\n  if (!*v5) {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n  }\n  libmin_strncpy(message, *v5, 1024uLL);\n  v10 = ::argv[1] == 0LL;\n  for (++::argv; !v10; ++::argv) {\n    libmin_strncat(message, \" \", 1024uLL);\n    libmin_strncat(message, *::argv, 1024uLL);\n    v10 = ::argv[1] == 0LL;\n  }\n  nchars = libmin_strlen(message);\n  if (debug) {\n    libmin_printf(\"int asc_ptr[128] = {\\n\");\n    v28 = 0;\n    ::i = 0;\n    do {\n      while (1) {\n        libmin_printf(\"%4d,   \", asc_ptr[v28]);\n        v28 = ::i + 1;\n        if ((((uint8_t)::i + 1) & 7) == 0) break;\n        ++::i;\n        if (v28 > 127) goto LABEL_52;\n      }\n      libmin_printf((char *)\"\\n\");\n      v28 = ::i + 1;\n      ::i = v28;\n    } while (v28 <= 127);\n  LABEL_52:\n    libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n    libmin_printf(\"  \\n\");\n    v30 = 0;\n    ::i = 0;\n    do {\n      libmin_printf(\"  \", v30);\n      v31 = ::i;\n      j = ::i;\n      do {\n        x = (unsigned char)data_table[v31];\n        libmin_printf(\" %3d, \", x);\n        v31 = j + 1;\n        j = v31;\n      } while (v31 <= ::i + 9);\n      libmin_putc(10);\n      v30 = ::i + 10;\n      ::i = v30;\n    } while (v30 <= 9270);\n    libmin_printf(\"};\\n\");\n  }\n  v11 = nchars;\n  v12 = 0;\n  j = 0;\n  ::i = 0;\n  if (nchars > 0) {\n    do {\n      v13 = message[v12];\n      if ((v13 & 128u) != 0LL || !asc_ptr[v13]) {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++j;\n        v12 = ::i;\n        v11 = nchars;\n      }\n      ::i = ++v12;\n    } while (v12 < v11);\n    if (j) libmin_fail(1);\n  }\n  v14 = 0;\n  for (::i = 0; ::i < nchars; v14 = ::i) {\n    memset(line, 32, sizeof(line));\n    v15 = asc_ptr[(unsigned char)message[v14]];\n    j = 132;\n    pc = v15;\n    term = 0;\n    max = 0;\n    linen = 0;\n    do {\n      if (v15 > 9270) {\n        libmin_printf(\"bad pc: %d\\n\", v15);\n        libmin_fail(1);\n      }\n      v16 = (unsigned char)data_table[v15];\n      x = v16;\n      if ((v16 & 128u) != 0) {\n        if (v16 > 192) ++term;\n        for (i = v16 & 63;; i = x) {\n          v18 = 0;\n          v19 = linen;\n          v20 = &print[linen];\n          v21 = i + linen;\n          v22 = i + linen - 1;\n          do {\n            v23 = v22 - v19;\n            if (v21 == v19) {\n              x = v22 - v19;\n              if (v18) linen = v21;\n              memset(line, 32, sizeof(line));\n              v15 = pc + 1;\n              j = 132;\n              goto LABEL_36;\n            }\n            ++v20;\n            ++v19;\n            v18 = 1;\n          } while (!*(v20 - 1));\n          v26 = max;\n          linen = v19;\n          v27 = 0;\n          x = v23;\n          for (j = 0; v27 <= max; j = v27) {\n            while (!print[v27]) {\n              j = ++v27;\n              if (v27 > v26) goto LABEL_45;\n            }\n            libmin_putc(line[v27]);\n            v26 = max;\n            v27 = j + 1;\n          }\n        LABEL_45:\n          libmin_putc(10);\n        }\n      }\n      v24 = data_table[v15 + 1];\n      v25 = v16 + v24;\n      y = v24;\n      max = v16 + v24;\n      if (v16 < v16 + v24) {\n        memset(&line[v16], 35, (unsigned int)(v24 - 1) + 1LL);\n        x = v25;\n      }\n      v15 += 2;\n    LABEL_36:\n      pc = v15;\n    } while (!term);\n    ++::i;\n  }\n  libmin_success();\n}", "binary": "banner/banner.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nlea    0x3ed5(%rip),%r12\npush   %rbp\nlea    0x3f3f(%rip),%rbp\npush   %rbx\nlea    0x3f51(%rip),%rbx\nsub    $0x18,%rsp\nnopw   0x0(%rax,%rax,1)\nmov    0x8ec9(%rip),%rsi\nmov    0x8eb3(%rip),%edi\nmov    %rbx,%rdx\ncall   1c50 <libmin_getopt>\ncmp    $0xffffffff,%eax\nje     11b8 <main+0x98>\ncmp    $0x64,%eax\nje     118a <main+0x6a>\ncmp    $0x77,%eax\nje     1196 <main+0x76>\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   3d50 <libmin_printf>\nmov    $0x1,%edi\ncall   1c30 <libmin_fail>\njmp    1150 <main+0x30>\nmovl   $0x1,0x9150(%rip)\njmp    1150 <main+0x30>\nmov    0x96a3(%rip),%rdi\ncall   1b50 <libmin_atoi>\nmov    %eax,0x8e6c(%rip)\ntest   %eax,%eax\njg     1150 <main+0x30>\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3d50 <libmin_printf>\njmp    1150 <main+0x30>\nmovslq 0x90b5(%rip),%rax\nmov    0x8e4f(%rip),%edi\nmovl   $0x0,0x9111(%rip)\nmov    0x8e4a(%rip),%rdx\nsub    %eax,0x8e34(%rip)\nlea    (%rdx,%rax,8),%r9\nmov    %r9,0x8e39(%rip)\ntest   %edi,%edi\njle    1224 <main+0x104>\nimul   $0x84,%edi,%r8d\nxor    %ecx,%ecx\nlea    0x9105(%rip),%r15\nnopl   0x0(%rax,%rax,1)\nmov    %ecx,%eax\nadd    $0x84,%ecx\ncltd\nidiv   %edi\nmovslq %eax,%rdx\nmovb   $0x1,(%r15,%rdx,1)\ncmp    %ecx,%r8d\njne    1200 <main+0xe0>\nmov    %eax,0x90be(%rip)\nmov    %edi,0x90bc(%rip)\nmov    (%r9),%rsi\ntest   %rsi,%rsi\nje     185d <main+0x73d>\nlea    0x9169(%rip),%rax\nmov    $0x400,%edx\nlea    0x3e91(%rip),%rbx\nmov    %rax,%rdi\nmov    %rax,(%rsp)\ncall   3ff0 <libmin_strncpy>\nmov    0x8dca(%rip),%rax\nlea    0x8(%rax),%rdx\ncmpq   $0x0,0x8(%rax)\nmov    %rdx,0x8dba(%rip)\nje     12ac <main+0x18c>\nmov    (%rsp),%r14\nmov    $0x400,%edx\nmov    %rbx,%rsi\nmov    %r14,%rdi\ncall   3fa0 <libmin_strncat>\nmov    0x8d9d(%rip),%rax\nmov    $0x400,%edx\nmov    %r14,%rdi\nmov    (%rax),%rsi\ncall   3fa0 <libmin_strncat>\nmov    0x8d86(%rip),%rax\nlea    0x8(%rax),%rdx\ncmpq   $0x0,0x8(%rax)\nmov    %rdx,0x8d76(%rip)\njne    1268 <main+0x148>\nmov    (%rsp),%rdi\ncall   3f70 <libmin_strlen>\nmov    %eax,0x9015(%rip)\nmov    0x9023(%rip),%edi\ntest   %edi,%edi\njne    16d7 <main+0x5b7>\nmov    0x9001(%rip),%ecx\nxor    %eax,%eax\nlea    0x90c8(%rip),%rbx\nmovl   $0x0,0x8ffa(%rip)\nmov    %rbx,(%rsp)\nlea    0x3d63(%rip),%rbp\nlea    0x626c(%rip),%rbx\nmovl   $0x0,0x8fe2(%rip)\ntest   %ecx,%ecx\njle    135d <main+0x23d>\nnopw   0x0(%rax,%rax,1)\nmov    (%rsp),%rsi\nmovslq %eax,%rdx\nmovsbq (%rsi,%rdx,1),%rdx\ntest   %dl,%dl\njs     131f <main+0x1ff>\nmov    (%rbx,%rdx,4),%esi\ntest   %esi,%esi\njne    133c <main+0x21c>\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   3d50 <libmin_printf>\naddl   $0x1,0x8fac(%rip)\nmov    0x8faa(%rip),%eax\nmov    0x8f94(%rip),%ecx\nadd    $0x1,%eax\nmov    %eax,0x8f9b(%rip)\ncmp    %ecx,%eax\njl     1308 <main+0x1e8>\nmov    0x8f8d(%rip),%ecx\ntest   %ecx,%ecx\nje     135d <main+0x23d>\nmov    $0x1,%edi\ncall   1c30 <libmin_fail>\nlea    0x903c(%rip),%rbx\nmov    0x8f66(%rip),%edx\nxor    %eax,%eax\nmovl   $0x0,0x8f6a(%rip)\nmov    %rbx,(%rsp)\nlea    0x61df(%rip),%rbx\nmovabs $0x2020202020202020,%r12\nmovabs $0x2020202020202020,%r13\nmov    %rbx,0x8(%rsp)\nlea    0x93ff(%rip),%rbp\nlea    0x3d78(%rip),%rbx\ntest   %edx,%edx\njle    15c0 <main+0x4a0>\nmov    (%rsp),%rsi\ncltq\nmov    %r12,0x93e3(%rip)\nmov    %r13,0x93e4(%rip)\nmovzbl (%rsi,%rax,1),%eax\nmov    0x8(%rsp),%rsi\nmov    %r12,0x93dc(%rip)\nmov    %r13,0x93dd(%rip)\nmov    (%rsi,%rax,4),%r15d\nmov    %r12,0x93da(%rip)\nmov    %r13,0x93db(%rip)\nmov    %r12,0x93dc(%rip)\nmov    %r13,0x93dd(%rip)\nmov    %r12,0x93de(%rip)\nmov    %r13,0x93df(%rip)\nmov    %r12,0x93e0(%rip)\nmov    %r13,0x93e1(%rip)\nmov    %r12,0x93e2(%rip)\nmov    %r13,0x93e3(%rip)\nmov    %r12,0x93e4(%rip)\nmov    %r13,0x93e5(%rip)\nmovl   $0x20202020,0x93e3(%rip)\nmovl   $0x84,0x8e95(%rip)\nmov    %r15d,0x8e7e(%rip)\nmovl   $0x0,0x8e70(%rip)\nmovl   $0x0,0x8e72(%rip)\nmovl   $0x0,0x8e6c(%rip)\nnopl   0x0(%rax)\ncmp    $0x2436,%r15d\nja     16b0 <main+0x590>\nmovslq %r15d,%rax\nmovzbl (%rbx,%rax,1),%ecx\nmov    %ecx,0x8e3a(%rip)\nmov    %ecx,%eax\ntest   %cl,%cl\njns    15e0 <main+0x4c0>\ncmp    $0xc0,%ecx\njle    14a3 <main+0x383>\naddl   $0x1,0x8e25(%rip)\nmov    %eax,%r8d\nlea    0x8e53(%rip),%r15\nand    $0x3f,%r8d\nmovslq 0x8e20(%rip),%rdx\nxor    %edi,%edi\nmov    %rdx,%rax\nadd    %r15,%rdx\nlea    (%r8,%rax,1),%ecx\nlea    -0x1(%r8,%rax,1),%r9d\njmp    14e6 <main+0x3c6>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rdx\nadd    $0x1,%eax\nmov    $0x1,%edi\ncmpb   $0x0,-0x1(%rdx)\njne    1630 <main+0x510>\nmov    %r9d,%r8d\nsub    %eax,%r8d\ncmp    %eax,%ecx\njne    14d0 <main+0x3b0>\nmov    %r8d,0x8dcd(%rip)\ntest   %dil,%dil\nje     1502 <main+0x3e2>\nmov    %ecx,0x8dd6(%rip)\nmov    0x8dc4(%rip),%eax\nmov    %r12,0x9291(%rip)\nmov    %r13,0x9292(%rip)\nmov    %r12,0x9293(%rip)\nlea    0x1(%rax),%r15d\nmov    %r13,0x9290(%rip)\nmov    %r12,0x9291(%rip)\nmov    %r13,0x9292(%rip)\nmov    %r12,0x9293(%rip)\nmov    %r13,0x9294(%rip)\nmov    %r12,0x9295(%rip)\nmov    %r13,0x9296(%rip)\nmov    %r12,0x9297(%rip)\nmov    %r13,0x9298(%rip)\nmov    %r12,0x9299(%rip)\nmov    %r13,0x929a(%rip)\nmov    %r12,0x929b(%rip)\nmov    %r13,0x929c(%rip)\nmovl   $0x20202020,0x929a(%rip)\nmovl   $0x84,0x8d4c(%rip)\nmov    0x8d32(%rip),%eax\nmov    %r15d,0x8d2f(%rip)\ntest   %eax,%eax\nje     1470 <main+0x350>\nmov    0x8d35(%rip),%eax\nadd    $0x1,%eax\ncmp    0x8d1c(%rip),%eax\nmov    %eax,0x8d26(%rip)\njl     13b0 <main+0x290>\ncall   4040 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\nlea    0x1(%r15),%eax\ncltq\nmovsbl (%rbx,%rax,1),%eax\nlea    (%rcx,%rax,1),%r14d\nmov    %eax,0x8ccc(%rip)\nmov    %r14d,0x8cd9(%rip)\ncmp    %r14d,%ecx\njge    161f <main+0x4ff>\nlea    -0x1(%rax),%edx\nmovslq %ecx,%rcx\nmov    $0x23,%esi\nadd    $0x1,%rdx\nlea    (%rcx,%rbp,1),%rdi\ncall   10d0 <memset@plt>\nmov    %r14d,0x8ca5(%rip)\nadd    $0x2,%r15d\njmp    1590 <main+0x470>\nnopl   0x0(%rax,%rax,1)\nmov    0x8c9e(%rip),%ecx\nmov    %eax,0x8c9c(%rip)\nxor    %eax,%eax\nmov    %r8d,0x8c7f(%rip)\nmovl   $0x0,0x8c8d(%rip)\ntest   %ecx,%ecx\njs     166f <main+0x54f>\nnopl   0x0(%rax,%rax,1)\nmovslq %eax,%rdx\ncmpb   $0x0,(%r15,%rdx,1)\njne    1688 <main+0x568>\nadd    $0x1,%eax\nmov    %eax,0x8c71(%rip)\ncmp    %ecx,%eax\njle    1658 <main+0x538>\nmov    $0xa,%edi\ncall   3f60 <libmin_putc>\nmov    0x8c44(%rip),%r8d\njmp    14b1 <main+0x391>\nnopl   (%rax)\nmovsbl 0x0(%rbp,%rdx,1),%edi\ncall   3f60 <libmin_putc>\nmov    0x8c44(%rip),%eax\nmov    0x8c36(%rip),%ecx\nadd    $0x1,%eax\nmov    %eax,0x8c35(%rip)\ncmp    %ecx,%eax\njle    1658 <main+0x538>\njmp    166f <main+0x54f>\nnopl   (%rax)\nmov    %r15d,%esi\nlea    0x3a41(%rip),%rdi\nxor    %eax,%eax\ncall   3d50 <libmin_printf>\nmov    $0x1,%edi\ncall   1c30 <libmin_fail>\nmov    0x8bfa(%rip),%r15d\njmp    147d <main+0x35d>\nlea    0x39d2(%rip),%rdi\nxor    %eax,%eax\nlea    0x5e79(%rip),%rbx\ncall   3d50 <libmin_printf>\nlea    0x39bb(%rip),%rbp\nmov    %rbx,0x8(%rsp)\nxor    %eax,%eax\nmovl   $0x0,0x8bdc(%rip)\nlea    0x39bb(%rip),%rbx\nmov    0x8(%rsp),%rsi\ncltq\nmov    %rbx,%rdi\nmov    (%rsi,%rax,4),%esi\nxor    %eax,%eax\ncall   3d50 <libmin_printf>\nmov    0x8bbb(%rip),%eax\nadd    $0x1,%eax\ntest   $0x7,%al\nje     1836 <main+0x716>\nmov    %eax,0x8baa(%rip)\ncmp    $0x7f,%eax\njle    170b <main+0x5eb>\nlea    0x38ee(%rip),%rdi\nxor    %eax,%eax\nlea    0x398b(%rip),%rbx\ncall   3d50 <libmin_printf>\nlea    0x3977(%rip),%rdi\nxor    %eax,%eax\ncall   3d50 <libmin_printf>\nxor    %esi,%esi\nmovl   $0x0,0x8b76(%rip)\nmov    %rbx,%rdi\nxor    %eax,%eax\ncall   3d50 <libmin_printf>\nmov    0x8b66(%rip),%eax\nlea    0x1(%rax),%esi\nmov    %esi,0x8b5d(%rip)\ncmp    $0x9,%esi\njle    176a <main+0x64a>\nlea    0x394e(%rip),%rdi\nxor    %eax,%eax\nlea    0x394c(%rip),%r12\ncall   3d50 <libmin_printf>\nlea    0x397c(%rip),%rbx\nxor    %esi,%esi\nmovl   $0x0,0x8b30(%rip)\nlea    0x3939(%rip),%rbp\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3d50 <libmin_printf>\nmov    0x8b19(%rip),%eax\nmov    %eax,0x8b0f(%rip)\nnopl   (%rax)\ncltq\nmov    %rbp,%rdi\nmovzbl (%rbx,%rax,1),%esi\nxor    %eax,%eax\nmov    %esi,0x8ae3(%rip)\ncall   3d50 <libmin_printf>\nmov    0x8af0(%rip),%eax\nmov    0x8aee(%rip),%esi\nadd    $0x1,%eax\nlea    0x9(%rsi),%edx\nmov    %eax,0x8ade(%rip)\ncmp    %edx,%eax\njle    17d0 <main+0x6b0>\nmov    $0xa,%edi\ncall   3f60 <libmin_putc>\nmov    0x8ace(%rip),%eax\nlea    0xa(%rax),%esi\nmov    %esi,0x8ac5(%rip)\ncmp    $0x2436,%esi\njle    17b7 <main+0x697>\nlea    0x38cd(%rip),%rdi\nxor    %eax,%eax\ncall   3d50 <libmin_printf>\njmp    12c9 <main+0x1a9>\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   3d50 <libmin_printf>\nmov    0x8a9a(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x8a91(%rip)\ncmp    $0x7f,%eax\njle    170b <main+0x5eb>\njmp    173b <main+0x61b>\nlea    0x3836(%rip),%rdi\nxor    %eax,%eax\ncall   3d50 <libmin_printf>\nmov    $0x1,%edi\ncall   1c30 <libmin_fail>\njmp    12bb <main+0x19b>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_builtin", "content": "// ------------------------------\n// Bit-counting Kernel 3: Compiler built-in popcount (GCC/Clang)\n// ------------------------------\nunsigned int count_bits_builtin(uint32_t x) {\n    return __builtin_popcount(x);\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O3.pseudo", "function_name": "count_bits_builtin", "address": "0x15a0", "label": "count_bits_builtin", "content": "unsigned int __fastcall count_bits_builtin(uint32_t x)\n{\n  return _popcountdi2(x);\n}\n"}, "pseudo_normalize": "", "binary": "bit-kernels/bit-kernels.host.O3", "assembly": "<count_bits_builtin>:\nendbr64\nsub    $0x8,%rsp\nmov    %edi,%edi\ncall   4070 <__popcountdi2>\nadd    $0x8,%rsp\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_kernighan", "content": "// ------------------------------\n// Bit-counting Kernel 2: Kernighan's algorithm\n// ------------------------------\nunsigned int count_bits_kernighan(uint32_t x) {\n    unsigned int count = 0;\n    while (x) {\n        x &= (x - 1);\n        count++;\n    }\n    return count;\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O3.pseudo", "function_name": "count_bits_kernighan", "address": "0x1580", "label": "count_bits_kernighan", "content": "unsigned int __fastcall count_bits_kernighan(uint32_t x)\n{\n  unsigned int i; // r8d\n\n  for ( i = 0; x; x &= x - 1 )\n    ++i;\n  return i;\n}\n"}, "pseudo_normalize": "", "binary": "bit-kernels/bit-kernels.host.O3", "assembly": "<count_bits_kernighan>:\nendbr64\nxor    %r8d,%r8d\ntest   %edi,%edi\nje     159b <count_bits_kernighan+0x1b>\nnopl   0x0(%rax,%rax,1)\nlea    -0x1(%rdi),%eax\nadd    $0x1,%r8d\nand    %eax,%edi\njne    1590 <count_bits_kernighan+0x10>\nmov    %r8d,%eax\nret\nnop\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_naive", "content": "// ------------------------------\n// Bit-counting Kernel 1: Naive method\n// ------------------------------\nunsigned int count_bits_naive(uint32_t x) {\n    unsigned int count = 0;\n    while (x) {\n        count += (x & 1);\n        x >>= 1;\n    }\n    return count;\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O3.pseudo", "function_name": "count_bits_naive", "address": "0x1550", "label": "count_bits_naive", "content": "unsigned int __fastcall count_bits_naive(uint32_t x)\n{\n  unsigned int result; // eax\n\n  for ( result = 0; x; x >>= 1 )\n    result += x & 1;\n  return result;\n}\n"}, "pseudo_normalize": "", "binary": "bit-kernels/bit-kernels.host.O3", "assembly": "<count_bits_naive>:\nendbr64\nxor    %eax,%eax\ntest   %edi,%edi\nje     1570 <count_bits_naive+0x20>\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%edx\nand    $0x1,%edx\nadd    %edx,%eax\nshr    %edi\njne    1560 <count_bits_naive+0x10>\nret\nnopl   0x0(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_parallel", "content": "// ------------------------------\n// Bit-counting Kernel 5: Parallel counting (SWAR algorithm)\n// ------------------------------\nunsigned int count_bits_parallel(uint32_t x) {\n    // Subtract pairs of bits\n    x = x - ((x >> 1) & 0x55555555);\n    // Sum bits in nibble groups\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    // Aggregate counts in bytes\n    x = (x + (x >> 4)) & 0x0F0F0F0F;\n    // Multiply and shift out the sum\n    return (x * 0x01010101) >> 24;\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O3.pseudo", "function_name": "count_bits_parallel", "address": "0x1650", "label": "count_bits_parallel", "content": "unsigned int __fastcall count_bits_parallel(uint32_t x)\n{\n  uint32_t v1; // edx\n\n  v1 = (((x - ((x >> 1) & 0x55555555)) >> 2) & 0x33333333) + ((x - ((x >> 1) & 0x55555555)) & 0x33333333);\n  return (16843009 * ((v1 + (v1 >> 4)) & 0xF0F0F0F)) >> 24;\n}\n"}, "pseudo_normalize": "unsigned int count_bits_parallel(uint32_t x) {\n  uint32_t v1;\n  v1 = (((x - ((x >> 1) & 1431655765)) >> 2) & 858993459) +\n       ((x - ((x >> 1) & 1431655765)) & 858993459);\n  return (16843009 * ((v1 + (v1 >> 4)) & 252645135)) >> 24;\n}", "binary": "bit-kernels/bit-kernels.host.O3", "assembly": "<count_bits_parallel>:\nendbr64\nmov    %edi,%eax\nshr    %eax\nand    $0x55555555,%eax\nsub    %eax,%edi\nmov    %edi,%edx\nshr    $0x2,%edi\nand    $0x33333333,%edx\nand    $0x33333333,%edi\nadd    %edi,%edx\nmov    %edx,%eax\nshr    $0x4,%eax\nadd    %edx,%eax\nand    $0xf0f0f0f,%eax\nimul   $0x1010101,%eax,%eax\nshr    $0x18,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_table", "content": "  \n// Use the table to compute popcount for a 32-bit integer.\nunsigned int count_bits_table(uint32_t x) {\n    return popcount_table[x & 0xFF] +\n           popcount_table[(x >> 8) & 0xFF] +\n           popcount_table[(x >> 16) & 0xFF] +\n           popcount_table[(x >> 24) & 0xFF];\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O3.pseudo", "function_name": "count_bits_table", "address": "0x1620", "label": "count_bits_table", "content": "unsigned int __fastcall count_bits_table(uint32_t x)\n{\n  return popcount_table[BYTE2(x)]\n       + popcount_table[BYTE1(x)]\n       + popcount_table[(unsigned __int8)x]\n       + popcount_table[HIBYTE(x)];\n}\n"}, "pseudo_normalize": "", "binary": "bit-kernels/bit-kernels.host.O3", "assembly": "<count_bits_table>:\nendbr64\nmov    %edi,%eax\nlea    0x5c53(%rip),%rcx\nmov    %edi,%edx\nmovzbl %dil,%esi\nshr    $0x18,%eax\nmov    (%rcx,%rax,4),%eax\nadd    (%rcx,%rsi,4),%eax\nmovzbl %dh,%esi\nshr    $0x10,%edx\nmov    %esi,%esi\nmovzbl %dl,%edx\nadd    (%rcx,%rsi,4),%eax\nadd    (%rcx,%rdx,4),%eax\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "init_popcount_table", "content": "// ------------------------------\n// Bit-counting Kernel 4: Table lookup\n// ------------------------------\n// Initialize the lookup table for 8-bit popcount.\nvoid init_popcount_table() {\n    for (int i = 0; i < TABLE_SIZE; i++) {\n        unsigned int count = 0;\n        int value = i;\n        while (value) {\n            count += (value & 1);\n            value >>= 1;\n        }\n        popcount_table[i] = count;\n    }\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O3.pseudo", "function_name": "init_popcount_table", "address": "0x15c0", "label": "init_popcount_table", "content": "void __cdecl init_popcount_table()\n{\n  __int64 v0; // rsi\n  unsigned int v1; // edx\n  int v2; // eax\n\n  v0 = 0LL;\nLABEL_5:\n  popcount_table[0] = 0;\n  do\n  {\n    ++v0;\n    v1 = 0;\n    v2 = v0;\n    if ( !v0 )\n      goto LABEL_5;\n    do\n    {\n      v1 += v2 & 1;\n      v2 >>= 1;\n    }\n    while ( v2 );\n    popcount_table[v0] = v1;\n  }\n  while ( v0 != 255 );\n}\n"}, "pseudo_normalize": "void init_popcount_table() {\n  long long v0;\n  unsigned int v1;\n  int v2;\n  v0 = 0LL;\nLABEL_5:\n  popcount_table[0] = 0;\n  do {\n    ++v0;\n    v1 = 0;\n    v2 = v0;\n    if (!v0) goto LABEL_5;\n    do {\n      v1 += v2 & 1;\n      v2 >>= 1;\n    } while (v2);\n    popcount_table[v0] = v1;\n  } while (v0 != 255);\n}", "binary": "bit-kernels/bit-kernels.host.O3", "assembly": "<init_popcount_table>:\nendbr64\nxor    %esi,%esi\nlea    0x5cb3(%rip),%rdi\nxor    %edx,%edx\nmov    %esi,%eax\ntest   %rsi,%rsi\nje     1604 <init_popcount_table+0x44>\ncs nopw 0x0(%rax,%rax,1)\nmov    %eax,%ecx\nand    $0x1,%ecx\nadd    %ecx,%edx\nsar    %eax\njne    15e0 <init_popcount_table+0x20>\nmov    %edx,(%rdi,%rsi,4)\ncmp    $0xff,%rsi\nje     1610 <init_popcount_table+0x50>\nadd    $0x1,%rsi\nxor    %edx,%edx\nmov    %esi,%eax\ntest   %rsi,%rsi\njne    15e0 <init_popcount_table+0x20>\nmovl   $0x0,0x5c72(%rip)\njmp    15f7 <init_popcount_table+0x37>\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "main", "content": "// ------------------------------\n// Main testing function\n// ------------------------------\nint main(void) {\n    // Seed random generator\n    libmin_srand(42);\n    \n    // Initialize lookup table for table lookup method.\n    init_popcount_table();\n    \n    // Allocate an array of NUM_ELEMENTS random 32-bit numbers.\n    uint32_t *numbers = libmin_malloc(NUM_ELEMENTS * sizeof(uint32_t));\n    if (numbers == NULL) {\n        libmin_printf(\"ERROR: Memory allocation error!\\n\");\n        return 1;\n    }\n    \n    // Fill the array with random 32-bit numbers.\n    for (size_t i = 0; i < NUM_ELEMENTS; i++) {\n        // Combine two calls to rand() to create a 32-bit number.\n        numbers[i] = ((uint32_t)libmin_rand() << 16) | (libmin_rand() & 0xFFFF);\n    }\n    \n    // Variables to sum total bit counts for each method.\n    unsigned long long total_naive = 0;\n    unsigned long long total_kernighan = 0;\n    unsigned long long total_builtin = 0;\n    unsigned long long total_table = 0;\n    unsigned long long total_parallel = 0;\n    \n    // Process each number.\n    for (size_t i = 0; i < NUM_ELEMENTS; i++) {\n        uint32_t val = numbers[i];\n        unsigned int naive   = count_bits_naive(val);\n        unsigned int kernighan = count_bits_kernighan(val);\n        unsigned int builtin = count_bits_builtin(val);\n        unsigned int table   = count_bits_table(val);\n        unsigned int parallel = count_bits_parallel(val);\n        \n        // Verify that all methods agree.\n        if (naive != kernighan || naive != builtin || naive != table || naive != parallel) {\n            libmin_printf(\"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, table=%u, parallel=%u\\n\",\n                   val, naive, kernighan, builtin, table, parallel);\n        }\n        \n        // Accumulate totals.\n        total_naive   += naive;\n        total_kernighan += kernighan;\n        total_builtin += builtin;\n        total_table   += table;\n        total_parallel += parallel;\n        \n        // For demonstration, print the first 5 numbers with their popcount from each method.\n        if (i < 5) {\n            libmin_printf(\"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, parallel=%2u\\n\",\n                   val, naive, kernighan, builtin, table, parallel);\n        }\n    }\n    \n    // Print overall totals for comparison.\n    libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", NUM_ELEMENTS);\n    libmin_printf(\"Naive         : %llu\\n\", total_naive);\n    libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n    libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n    libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n    libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n    \n    // Clean up\n    libmin_free(numbers);\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rcx\n  unsigned int v4; // eax\n  int v5; // r13d\n  uint32_t *v6; // r14\n  unsigned int v7; // ebx\n  unsigned __int64 v8; // r10\n  uint32_t v9; // ebx\n  uint32_t v10; // r12d\n  unsigned int v11; // r13d\n  uint32_t v12; // eax\n  int v13; // eax\n  unsigned __int64 v14; // r10\n  int v15; // r8d\n  unsigned int v16; // r15d\n  unsigned int v17; // edx\n  unsigned int v18; // r14d\n  unsigned __int64 v19; // r11\n  const char **v21; // [rsp-8h] [rbp-90h]\n  unsigned __int64 builtin; // [rsp+8h] [rbp-80h]\n  int builtina; // [rsp+8h] [rbp-80h]\n  unsigned __int64 builtinb; // [rsp+8h] [rbp-80h]\n  bool v25; // [rsp+10h] [rbp-78h]\n  unsigned __int64 v26; // [rsp+10h] [rbp-78h]\n  uint32_t *numbers; // [rsp+18h] [rbp-70h]\n  unsigned __int64 total_builtin; // [rsp+20h] [rbp-68h]\n  unsigned __int64 total_table; // [rsp+28h] [rbp-60h]\n  unsigned __int64 total_parallel; // [rsp+30h] [rbp-58h]\n  unsigned __int64 total_naive; // [rsp+38h] [rbp-50h]\n  unsigned __int64 total_kernighan; // [rsp+40h] [rbp-48h]\n\n  libmin_srand(0x2Au);\n  v3 = 0LL;\nLABEL_5:\n  popcount_table[0] = 0;\n  do\n  {\n    ++v3;\n    v4 = 0;\n    v5 = v3;\n    if ( !v3 )\n      goto LABEL_5;\n    do\n    {\n      v4 += v5 & 1;\n      v5 >>= 1;\n    }\n    while ( v5 );\n    popcount_table[v3] = v4;\n  }\n  while ( v3 != 255 );\n  numbers = (uint32_t *)libmin_malloc(0x190uLL);\n  v6 = numbers;\n  if ( numbers )\n  {\n    do\n    {\n      ++v6;\n      v7 = libmin_rand();\n      *(v6 - 1) = (unsigned __int16)libmin_rand() | (v7 << 16);\n    }\n    while ( numbers + 100 != v6 );\n    v8 = 0LL;\n    total_parallel = 0LL;\n    total_table = 0LL;\n    v9 = *numbers;\n    total_builtin = 0LL;\n    total_kernighan = 0LL;\n    total_naive = 0LL;\n    if ( !*numbers )\n      goto LABEL_21;\n    while ( 1 )\n    {\n      v10 = v9;\n      v11 = 0;\n      do\n      {\n        v11 += v10 & 1;\n        v10 >>= 1;\n      }\n      while ( v10 );\n      v12 = v9;\n      do\n      {\n        ++v10;\n        v12 &= v12 - 1;\n      }\n      while ( v12 );\n      v25 = v10 != v11;\n      total_naive += v11;\n      total_kernighan += v10;\n      while ( 1 )\n      {\n        builtin = v8;\n        v13 = _popcountdi2(v9, argv);\n        v14 = builtin;\n        v15 = v13;\n        v16 = popcount_table[BYTE2(v9)]\n            + popcount_table[BYTE1(v9)]\n            + popcount_table[(unsigned __int8)v9]\n            + popcount_table[HIBYTE(v9)];\n        v17 = (((v9 - ((v9 >> 1) & 0x55555555)) >> 2) & 0x33333333) + ((v9 - ((v9 >> 1) & 0x55555555)) & 0x33333333);\n        v18 = (16843009 * ((v17 + (v17 >> 4)) & 0xF0F0F0F)) >> 24;\n        if ( v13 != v11 || v25 || v16 != v11 || v18 != v11 )\n        {\n          v26 = builtin;\n          builtina = v13;\n          libmin_printf(\n            \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, table=%u, parallel=%u\\n\",\n            v9,\n            v11,\n            v10,\n            v13,\n            v16,\n            (16843009 * ((v17 + (v17 >> 4)) & 0xF0F0F0F)) >> 24);\n          argv = v21;\n          v14 = v26;\n          v15 = builtina;\n        }\n        v19 = v14 + 1;\n        total_builtin += v15;\n        total_table += v16;\n        total_parallel += v18;\n        if ( v14 <= 4 )\n        {\n          builtinb = v14 + 1;\n          argv = (const char **)v9;\n          libmin_printf(\n            \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, parallel=%2u\\n\",\n            v9,\n            v11,\n            v10,\n            v15,\n            v16,\n            v18);\n          v19 = builtinb;\n        }\n        else if ( v14 == 99 )\n        {\n          libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n          libmin_printf(\"Naive         : %llu\\n\", total_naive);\n          libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n          libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n          libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n          libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n          libmin_free(numbers);\n          libmin_success();\n        }\n        v8 = v19;\n        v9 = numbers[v19];\n        if ( v9 )\n          break;\nLABEL_21:\n        v25 = 0;\n        v11 = 0;\n        v10 = 0;\n      }\n    }\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  unsigned int v4;\n  int v5;\n  uint32_t *v6;\n  unsigned int v7;\n  unsigned long long v8;\n  uint32_t v9;\n  uint32_t v10;\n  unsigned int v11;\n  uint32_t v12;\n  int v13;\n  unsigned long long v14;\n  int v15;\n  unsigned int v16;\n  unsigned int v17;\n  unsigned int v18;\n  unsigned long long v19;\n  const char **v21;\n  unsigned long long builtin;\n  int builtina;\n  unsigned long long builtinb;\n  bool v25;\n  unsigned long long v26;\n  uint32_t *numbers;\n  unsigned long long total_builtin;\n  unsigned long long total_table;\n  unsigned long long total_parallel;\n  unsigned long long total_naive;\n  unsigned long long total_kernighan;\n  libmin_srand(42u);\n  v3 = 0LL;\nLABEL_5:\n  popcount_table[0] = 0;\n  do {\n    ++v3;\n    v4 = 0;\n    v5 = v3;\n    if (!v3) goto LABEL_5;\n    do {\n      v4 += v5 & 1;\n      v5 >>= 1;\n    } while (v5);\n    popcount_table[v3] = v4;\n  } while (v3 != 255);\n  numbers = (uint32_t *)libmin_malloc(400uLL);\n  v6 = numbers;\n  if (numbers) {\n    do {\n      ++v6;\n      v7 = libmin_rand();\n      *(v6 - 1) = (unsigned short)libmin_rand() | (v7 << 16);\n    } while (numbers + 100 != v6);\n    v8 = 0LL;\n    total_parallel = 0LL;\n    total_table = 0LL;\n    v9 = *numbers;\n    total_builtin = 0LL;\n    total_kernighan = 0LL;\n    total_naive = 0LL;\n    if (!*numbers) goto LABEL_21;\n    while (1) {\n      v10 = v9;\n      v11 = 0;\n      do {\n        v11 += v10 & 1;\n        v10 >>= 1;\n      } while (v10);\n      v12 = v9;\n      do {\n        ++v10;\n        v12 &= v12 - 1;\n      } while (v12);\n      v25 = v10 != v11;\n      total_naive += v11;\n      total_kernighan += v10;\n      while (1) {\n        builtin = v8;\n        v13 = _popcountdi2(v9, argv);\n        v14 = builtin;\n        v15 = v13;\n        v16 = popcount_table[BYTE2(v9)] + popcount_table[BYTE1(v9)] +\n              popcount_table[(unsigned char)v9] + popcount_table[HIBYTE(v9)];\n        v17 = (((v9 - ((v9 >> 1) & 1431655765)) >> 2) & 858993459) +\n              ((v9 - ((v9 >> 1) & 1431655765)) & 858993459);\n        v18 = (16843009 * ((v17 + (v17 >> 4)) & 252645135)) >> 24;\n        if (v13 != v11 || v25 || v16 != v11 || v18 != v11) {\n          v26 = builtin;\n          builtina = v13;\n          libmin_printf(\n              \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, \"\n              \"table=%u, parallel=%u\\n\",\n              v9, v11, v10, v13, v16,\n              (16843009 * ((v17 + (v17 >> 4)) & 252645135)) >> 24);\n          argv = v21;\n          v14 = v26;\n          v15 = builtina;\n        }\n        v19 = v14 + 1;\n        total_builtin += v15;\n        total_table += v16;\n        total_parallel += v18;\n        if (v14 <= 4) {\n          builtinb = v14 + 1;\n          argv = (const char **)v9;\n          libmin_printf(\n              \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, \"\n              \"parallel=%2u\\n\",\n              v9, v11, v10, v15, v16, v18);\n          v19 = builtinb;\n        } else if (v14 == 99) {\n          libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n          libmin_printf(\"Naive         : %llu\\n\", total_naive);\n          libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n          libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n          libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n          libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n          libmin_free(numbers);\n          libmin_success();\n        }\n        v8 = v19;\n        v9 = numbers[v19];\n        if (v9) break;\n      LABEL_21:\n        v25 = 0;\n        v11 = 0;\n        v10 = 0;\n      }\n    }\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}", "binary": "bit-kernels/bit-kernels.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x2a,%edi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nlea    0x6147(%rip),%rbp\npush   %rbx\nsub    $0x58,%rsp\ncall   3dc0 <libmin_srand>\nxor    %ecx,%ecx\nxor    %eax,%eax\nmov    %ecx,%r13d\ntest   %rcx,%rcx\nje     1178 <main+0x58>\nnop\nmov    %r13d,%edx\nand    $0x1,%edx\nadd    %edx,%eax\nsar    %r13d\njne    1150 <main+0x30>\nmov    %eax,0x0(%rbp,%rcx,4)\ncmp    $0xff,%rcx\nje     1184 <main+0x64>\nadd    $0x1,%rcx\nxor    %eax,%eax\nmov    %ecx,%r13d\ntest   %rcx,%rcx\njne    1150 <main+0x30>\nmovl   $0x0,0x60fe(%rip)\njmp    116a <main+0x4a>\nmov    $0x190,%edi\ncall   1870 <libmin_malloc>\nmov    %rax,0x18(%rsp)\nmov    %rax,%r14\nlea    0x190(%rax),%r12\ntest   %rax,%rax\nje     144a <main+0x32a>\ncs nopw 0x0(%rax,%rax,1)\ncall   3e20 <libmin_rand>\nadd    $0x4,%r14\nmov    %eax,%ebx\ncall   3e20 <libmin_rand>\nshl    $0x10,%ebx\nmovzwl %ax,%eax\nor     %eax,%ebx\nmov    %ebx,-0x4(%r14)\ncmp    %r14,%r12\njne    11b0 <main+0x90>\nmov    0x18(%rsp),%rax\nxor    %r10d,%r10d\nmovq   $0x0,0x30(%rsp)\nmovq   $0x0,0x28(%rsp)\nmov    (%rax,%r10,4),%ebx\nmov    %r13d,0x4c(%rsp)\nmovq   $0x0,0x20(%rsp)\nmovq   $0x0,0x40(%rsp)\nmovq   $0x0,0x38(%rsp)\ntest   %ebx,%ebx\nje     1332 <main+0x212>\nnopw   0x0(%rax,%rax,1)\nmov    %ebx,%r12d\nxor    %r13d,%r13d\ncs nopw 0x0(%rax,%rax,1)\nmov    %r12d,%eax\nand    $0x1,%eax\nadd    %eax,%r13d\nshr    %r12d\njne    1230 <main+0x110>\nmov    %ebx,%eax\nlea    -0x1(%rax),%edx\nadd    $0x1,%r12d\nand    %edx,%eax\njne    1240 <main+0x120>\ncmp    %r13d,%r12d\nmov    %r13d,%eax\nsetne  0x10(%rsp)\nadd    %rax,0x38(%rsp)\nmov    %r12d,%eax\nadd    %rax,0x40(%rsp)\nmov    %ebx,%edi\nmov    %r10,0x8(%rsp)\ncall   4070 <__popcountdi2>\nmov    %ebx,%edx\nmov    0x8(%rsp),%r10\nshr    $0x18,%edx\nmov    %eax,%r8d\nmovzbl %bl,%eax\nmov    0x0(%rbp,%rdx,4),%r15d\nadd    0x0(%rbp,%rax,4),%r15d\nmovzbl %bh,%eax\nmov    %ebx,%edx\nmov    %eax,%eax\nshr    %edx\nadd    0x0(%rbp,%rax,4),%r15d\nmov    %ebx,%eax\nand    $0x55555555,%edx\nshr    $0x10,%eax\nmovzbl %al,%eax\nadd    0x0(%rbp,%rax,4),%r15d\nmov    %ebx,%eax\nsub    %edx,%eax\nmov    %eax,%edx\nshr    $0x2,%eax\nand    $0x33333333,%edx\nand    $0x33333333,%eax\nadd    %eax,%edx\nmov    %edx,%r14d\nshr    $0x4,%r14d\nadd    %edx,%r14d\nand    $0xf0f0f0f,%r14d\nimul   $0x1010101,%r14d,%r14d\nshr    $0x18,%r14d\ncmp    %r13d,%r8d\njne    1348 <main+0x228>\ncmpb   $0x0,0x10(%rsp)\njne    1348 <main+0x228>\ncmp    %r13d,%r15d\njne    1348 <main+0x228>\ncmp    %r13d,%r14d\njne    1348 <main+0x228>\nmovslq %r8d,%rax\nlea    0x1(%r10),%r11\nadd    %rax,0x20(%rsp)\nmov    %r15d,%eax\nadd    %rax,0x28(%rsp)\nmov    %r14d,%eax\nadd    %rax,0x30(%rsp)\ncmp    $0x4,%r10\njbe    1382 <main+0x262>\ncmp    $0x64,%r11\nje     13b2 <main+0x292>\nmov    0x18(%rsp),%rax\nmov    %r11,%r10\nmov    (%rax,%r10,4),%ebx\ntest   %ebx,%ebx\njne    1220 <main+0x100>\nmovb   $0x0,0x10(%rsp)\nxor    %r13d,%r13d\nxor    %r12d,%r12d\njmp    1263 <main+0x143>\nnopw   0x0(%rax,%rax,1)\nmov    %r10,0x10(%rsp)\nsub    $0x8,%rsp\nmov    %r12d,%ecx\nmov    %ebx,%esi\npush   %r14\nmov    %r15d,%r9d\nmov    %r13d,%edx\nlea    0x3ccb(%rip),%rdi\nxor    %eax,%eax\nmov    %r8d,0x18(%rsp)\ncall   3bb0 <libmin_printf>\npop    %rcx\npop    %rsi\nmov    0x10(%rsp),%r10\nmov    0x8(%rsp),%r8d\njmp    12f2 <main+0x1d2>\nmov    %r11,0x8(%rsp)\nsub    $0x8,%rsp\nmov    %r13d,%edx\nmov    %r15d,%r9d\npush   %r14\nmov    %r12d,%ecx\nmov    %ebx,%esi\nlea    0x3ce9(%rip),%rdi\nxor    %eax,%eax\ncall   3bb0 <libmin_printf>\npop    %rax\npop    %rdx\nmov    0x8(%rsp),%r11\njmp    131e <main+0x1fe>\nmov    $0x64,%esi\nlea    0x3d1a(%rip),%rdi\nxor    %eax,%eax\nmov    0x4c(%rsp),%r13d\ncall   3bb0 <libmin_printf>\nmov    0x38(%rsp),%rsi\nlea    0x3d25(%rip),%rdi\nxor    %eax,%eax\ncall   3bb0 <libmin_printf>\nmov    0x40(%rsp),%rsi\nlea    0x3d28(%rip),%rdi\nxor    %eax,%eax\ncall   3bb0 <libmin_printf>\nmov    0x20(%rsp),%rsi\nlea    0x3d2b(%rip),%rdi\nxor    %eax,%eax\ncall   3bb0 <libmin_printf>\nmov    0x28(%rsp),%rsi\nlea    0x3d2e(%rip),%rdi\nxor    %eax,%eax\ncall   3bb0 <libmin_printf>\nmov    0x30(%rsp),%rsi\nlea    0x3d31(%rip),%rdi\nxor    %eax,%eax\ncall   3bb0 <libmin_printf>\nmov    0x18(%rsp),%rdi\ncall   1920 <libmin_free>\ncall   4010 <libmin_success>\nadd    $0x58,%rsp\nmov    %r13d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x3bb7(%rip),%rdi\nmov    $0x1,%r13d\ncall   3bb0 <libmin_printf>\njmp    1438 <main+0x318>\nxchg   %ax,%ax\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "F", "content": "/**\n * @brief compression function F\n *\n * Securely mixes the values in block m into\n * the state vector h. Value at v[14] is also\n * inverted if this is the final block to be\n * compressed.\n *\n * @param h the state vector\n * @param m message vector to be compressed into h\n * @param t 128-bit offset counter\n * @param f flag to indicate whether this is the final block\n *\n * @returns void\n */\nstatic void F(uint64_t h[8], block_t m, u128 t, int f)\n{\n    int i;\n    block_t v;\n\n    /* v[0..7] := h[0..7] */\n    for (i = 0; i < 8; i++)\n    {\n        v[i] = h[i];\n    }\n    /* v[8..15] := IV[0..7] */\n    for (; i < 16; i++)\n    {\n        v[i] = blake2b_iv[i - 8];\n    }\n\n    v[12] ^= t[0]; /* v[12] ^ (t mod 2**w) */\n    v[13] ^= t[1]; /* v[13] ^ (t >> w) */\n\n    if (f)\n    {\n        v[14] = ~v[14];\n    }\n\n    for (i = 0; i < 12; i++)\n    {\n        const uint8_t *s = blake2b_sigma[i];\n\n        G(v, 0, 4, 8, 12, m[s[0]], m[s[1]]);\n        G(v, 1, 5, 9, 13, m[s[2]], m[s[3]]);\n        G(v, 2, 6, 10, 14, m[s[4]], m[s[5]]);\n        G(v, 3, 7, 11, 15, m[s[6]], m[s[7]]);\n\n        G(v, 0, 5, 10, 15, m[s[8]], m[s[9]]);\n        G(v, 1, 6, 11, 12, m[s[10]], m[s[11]]);\n        G(v, 2, 7, 8, 13, m[s[12]], m[s[13]]);\n        G(v, 3, 4, 9, 14, m[s[14]], m[s[15]]);\n    }\n\n    for (i = 0; i < 8; i++)\n    {\n        h[i] ^= v[i] ^ v[i + 8];\n    }\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O3.pseudo", "function_name": "F", "address": "0x12e0", "label": "F", "content": "void __fastcall F(uint64_t *h, uint64_t *m, uint64_t *t, int f)\n{\n  const uint8_t *v5; // r15\n  uint64_t v6; // r13\n  __m128i v8; // xmm1\n  __m128i v9; // xmm3\n  __m128i v10; // xmm5\n  __m128i v11; // xmm7\n  uint64_t v12; // rcx\n  uint64_t v13; // rdx\n  uint64_t v14; // r10\n  uint64_t v15; // r14\n  uint64_t v16; // rax\n  uint64_t v17; // rsi\n  uint64_t v18; // r8\n  uint64_t v19; // r11\n  uint64_t v20; // r9\n  uint64_t v21; // rdi\n  uint64_t v22; // rbx\n  __int64 v23; // rcx\n  uint64_t v24; // rdi\n  __int64 v25; // r10\n  uint64_t v26; // rbx\n  __int64 v27; // rcx\n  uint64_t v28; // r8\n  __int64 v29; // rdx\n  uint64_t v30; // rsi\n  __int64 v31; // rdi\n  uint64_t v32; // rbp\n  __int64 v33; // rdx\n  __int64 v34; // rdi\n  uint64_t v35; // r8\n  __int64 v36; // rax\n  uint64_t v37; // r13\n  __int64 v38; // rsi\n  uint64_t v39; // r9\n  __int64 v40; // rax\n  uint64_t v41; // r13\n  __int64 v42; // rsi\n  uint64_t v43; // r10\n  __int64 v44; // r8\n  uint64_t v45; // r11\n  __int64 v46; // rax\n  uint64_t v47; // r10\n  uint64_t v48; // rbx\n  __int64 v49; // r8\n  uint64_t v50; // r11\n  __int64 v51; // r8\n  __int64 v52; // r13\n  __int64 v53; // rax\n  __int64 v54; // rdi\n  uint64_t v55; // r8\n  uint64_t v56; // rbp\n  __int64 v57; // rcx\n  uint64_t v58; // r8\n  __int64 v59; // r11\n  __int64 v60; // rsi\n  uint64_t v61; // r9\n  __int64 v62; // rdx\n  __int64 v63; // rdi\n  __int64 v64; // rax\n  uint64_t v65; // r11\n  __int64 v66; // rax\n  __int64 v67; // rsi\n  __int64 v68; // r10\n  __m128i v69; // xmm2\n  __m128i si128; // xmm0\n  __m128i v71; // xmm4\n  __m128i v72; // xmm0\n  __m128i v73; // xmm0\n  __m128i v74; // xmm1\n  __int64 v75; // [rsp+0h] [rbp-128h]\n  uint64_t v76; // [rsp+18h] [rbp-110h]\n  uint64_t v77; // [rsp+20h] [rbp-108h]\n  uint64_t v78; // [rsp+28h] [rbp-100h]\n  uint64_t v79; // [rsp+30h] [rbp-F8h]\n  uint64_t v80; // [rsp+38h] [rbp-F0h]\n  uint64_t v81; // [rsp+40h] [rbp-E8h]\n  uint64_t v82; // [rsp+48h] [rbp-E0h]\n  __int64 v83; // [rsp+50h] [rbp-D8h]\n  block_t v; // [rsp+60h] [rbp-C8h] BYREF\n  unsigned __int64 v86; // [rsp+E8h] [rbp-40h]\n\n  v5 = blake2b_sigma[0];\n  v6 = 0x3C6EF372FE94F82BLL;\n  v8 = _mm_loadu_si128((const __m128i *)h);\n  v9 = _mm_loadu_si128((const __m128i *)h + 1);\n  v10 = _mm_loadu_si128((const __m128i *)h + 2);\n  v11 = _mm_loadu_si128((const __m128i *)h + 3);\n  v12 = *t ^ 0x510E527FADE682D1LL;\n  v86 = __readfsqword(0x28u);\n  v13 = t[1] ^ 0x9B05688C2B3E6C1FLL;\n  v14 = v10.m128i_i64[0];\n  v15 = v8.m128i_i64[0];\n  *(__m128i *)&v[4] = v10;\n  v16 = 0xE07C265404BE4294LL;\n  if ( !f )\n    v16 = 0x1F83D9ABFB41BD6BLL;\n  v82 = v10.m128i_u64[1];\n  v79 = v11.m128i_i64[0];\n  v17 = 0xBB67AE8584CAA73BLL;\n  *(__m128i *)v = v8;\n  v18 = v8.m128i_u64[1];\n  *(__m128i *)&v[2] = v9;\n  *(__m128i *)&v[6] = v11;\n  v19 = v9.m128i_u64[1];\n  v78 = v11.m128i_u64[1];\n  v80 = 0xA54FF53A5F1D36F1LL;\n  v81 = 0x5BE0CD19137E2179LL;\n  v20 = v9.m128i_i64[0];\n  v21 = 0x6A09E667F3BCC908LL;\n  do\n  {\n    v22 = v15 + v14 + m[*v5];\n    v23 = __ROL8__(v22 ^ v12, 32);\n    v24 = v23 + v21;\n    v25 = __ROR8__(v24 ^ v14, 24);\n    v26 = v25 + m[v5[1]] + v22;\n    v27 = __ROR8__(v26 ^ v23, 16);\n    v77 = v27 + v24;\n    v83 = __ROL8__((v27 + v24) ^ v25, 1);\n    v28 = v82 + m[v5[2]] + v18;\n    v29 = __ROL8__(v28 ^ v13, 32);\n    v30 = v29 + v17;\n    v31 = __ROR8__(v30 ^ v82, 24);\n    v32 = m[v5[3]] + v28 + v31;\n    v33 = __ROR8__(v32 ^ v29, 16);\n    v76 = v33 + v30;\n    v34 = __ROL8__((v33 + v30) ^ v31, 1);\n    v35 = v20 + v79 + m[v5[4]];\n    v36 = __ROL8__(v35 ^ v16, 32);\n    v37 = v36 + v6;\n    v38 = __ROR8__(v37 ^ v79, 24);\n    v39 = m[v5[5]] + v35 + v38;\n    v40 = __ROR8__(v39 ^ v36, 16);\n    v41 = v40 + v37;\n    v75 = v40;\n    v42 = __ROL8__(v41 ^ v38, 1);\n    v43 = v19 + v78 + m[v5[6]];\n    v44 = __ROL8__(v43 ^ v81, 32);\n    v45 = v44 + v80;\n    v46 = __ROR8__((v44 + v80) ^ v78, 24);\n    v47 = v46 + m[v5[7]] + v43;\n    v48 = v34 + m[v5[8]] + v26;\n    v49 = __ROR8__(v47 ^ v44, 16);\n    v50 = v49 + v45;\n    v51 = __ROL8__(v48 ^ v49, 32);\n    v52 = v51 + v41;\n    v53 = __ROL8__(v50 ^ v46, 1);\n    v54 = __ROR8__(v52 ^ v34, 24);\n    v15 = m[v5[9]] + v48 + v54;\n    v55 = __ROR8__(v15 ^ v51, 16);\n    v6 = v55 + v52;\n    v81 = v55;\n    v82 = __ROL8__(v6 ^ v54, 1);\n    v56 = m[v5[10]] + v32;\n    v57 = __ROL8__((v56 + v42) ^ v27, 32);\n    v58 = m[v5[11]] + v56 + v42;\n    v59 = v57 + v50;\n    v60 = __ROR8__(v59 ^ v42, 24);\n    v18 = v60 + v58;\n    v12 = __ROR8__(v18 ^ v57, 16);\n    v80 = v12 + v59;\n    v79 = __ROL8__((v12 + v59) ^ v60, 1);\n    v61 = v53 + m[v5[12]] + v39;\n    v62 = __ROL8__(v61 ^ v33, 32);\n    v63 = v62 + v77;\n    v64 = __ROR8__((v62 + v77) ^ v53, 24);\n    v20 = v64 + m[v5[13]] + v61;\n    v13 = __ROR8__(v20 ^ v62, 16);\n    v21 = v13 + v63;\n    v78 = __ROL8__(v21 ^ v64, 1);\n    v65 = m[v5[14]] + v47 + v83;\n    v66 = __ROL8__(v65 ^ v75, 32);\n    v5 += 16;\n    v67 = v66 + v76;\n    v68 = __ROR8__((v66 + v76) ^ v83, 24);\n    v19 = v68 + m[*(v5 - 1)] + v65;\n    v16 = __ROR8__(v19 ^ v66, 16);\n    v17 = v16 + v67;\n    v14 = __ROL8__(v17 ^ v68, 1);\n  }\n  while ( v5 != (const uint8_t *)&xmmword_5120 );\n  v[14] = v16;\n  v[0] = v15;\n  v69 = _mm_loadu_si128((const __m128i *)h);\n  v[1] = v18;\n  si128 = _mm_load_si128((const __m128i *)v);\n  v[8] = v21;\n  v[9] = v17;\n  v71 = _mm_loadu_si128((const __m128i *)h + 1);\n  v[12] = v12;\n  v[10] = v6;\n  v[2] = v20;\n  v[11] = v80;\n  v[3] = v19;\n  *(__m128i *)h = _mm_xor_si128(_mm_xor_si128(si128, *(__m128i *)&v[8]), v69);\n  v72 = _mm_xor_si128(_mm_load_si128((const __m128i *)&v[10]), *(__m128i *)&v[2]);\n  v[13] = v13;\n  v[15] = v81;\n  v[4] = v14;\n  v[5] = v82;\n  *((__m128i *)h + 1) = _mm_xor_si128(v72, v71);\n  v73 = _mm_xor_si128(_mm_load_si128((const __m128i *)&v[12]), *(__m128i *)&v[4]);\n  v[6] = v79;\n  v[7] = v78;\n  v74 = _mm_loadu_si128((const __m128i *)h + 3);\n  *((__m128i *)h + 2) = _mm_xor_si128(v73, _mm_loadu_si128((const __m128i *)h + 2));\n  *((__m128i *)h + 3) = _mm_xor_si128(_mm_xor_si128(_mm_load_si128((const __m128i *)&v[6]), *(__m128i *)&v[14]), v74);\n}\n"}, "pseudo_normalize": "void F(uint64_t *h, uint64_t *m, uint64_t *t, int f) {\n  const uint8_t *v5;\n  uint64_t v6;\n  __m128i v8;\n  __m128i v9;\n  __m128i v10;\n  __m128i v11;\n  uint64_t v12;\n  uint64_t v13;\n  uint64_t v14;\n  uint64_t v15;\n  uint64_t v16;\n  uint64_t v17;\n  uint64_t v18;\n  uint64_t v19;\n  uint64_t v20;\n  uint64_t v21;\n  uint64_t v22;\n  long long v23;\n  uint64_t v24;\n  long long v25;\n  uint64_t v26;\n  long long v27;\n  uint64_t v28;\n  long long v29;\n  uint64_t v30;\n  long long v31;\n  uint64_t v32;\n  long long v33;\n  long long v34;\n  uint64_t v35;\n  long long v36;\n  uint64_t v37;\n  long long v38;\n  uint64_t v39;\n  long long v40;\n  uint64_t v41;\n  long long v42;\n  uint64_t v43;\n  long long v44;\n  uint64_t v45;\n  long long v46;\n  uint64_t v47;\n  uint64_t v48;\n  long long v49;\n  uint64_t v50;\n  long long v51;\n  long long v52;\n  long long v53;\n  long long v54;\n  uint64_t v55;\n  uint64_t v56;\n  long long v57;\n  uint64_t v58;\n  long long v59;\n  long long v60;\n  uint64_t v61;\n  long long v62;\n  long long v63;\n  long long v64;\n  uint64_t v65;\n  long long v66;\n  long long v67;\n  long long v68;\n  __m128i v69;\n  __m128i si128;\n  __m128i v71;\n  __m128i v72;\n  __m128i v73;\n  __m128i v74;\n  long long v75;\n  uint64_t v76;\n  uint64_t v77;\n  uint64_t v78;\n  uint64_t v79;\n  uint64_t v80;\n  uint64_t v81;\n  uint64_t v82;\n  long long v83;\n  block_t v;\n  unsigned long long v86;\n  v5 = blake2b_sigma[0];\n  v6 = 4354685564936845355LL;\n  v8 = _mm_loadu_si128((const __m128i *)h);\n  v9 = _mm_loadu_si128((const __m128i *)h + 1);\n  v10 = _mm_loadu_si128((const __m128i *)h + 2);\n  v11 = _mm_loadu_si128((const __m128i *)h + 3);\n  v12 = *t ^ 5840696475078001361LL;\n  v86 = __readfsqword(40u);\n  v13 = t[1] ^ 11170449401992604703LL;\n  v14 = v10.m128i_i64[0];\n  v15 = v8.m128i_i64[0];\n  *(__m128i *)&v[4] = v10;\n  v16 = 16175846103906665108LL;\n  if (!f) v16 = 2270897969802886507LL;\n  v82 = v10.m128i_u64[1];\n  v79 = v11.m128i_i64[0];\n  v17 = 13503953896175478587LL;\n  *(__m128i *)v = v8;\n  v18 = v8.m128i_u64[1];\n  *(__m128i *)&v[2] = v9;\n  *(__m128i *)&v[6] = v11;\n  v19 = v9.m128i_u64[1];\n  v78 = v11.m128i_u64[1];\n  v80 = 11912009170470909681LL;\n  v81 = 6620516959819538809LL;\n  v20 = v9.m128i_i64[0];\n  v21 = 7640891576956012808LL;\n  do {\n    v22 = v15 + v14 + m[*v5];\n    v23 = __ROL8__(v22 ^ v12, 32);\n    v24 = v23 + v21;\n    v25 = __ROR8__(v24 ^ v14, 24);\n    v26 = v25 + m[v5[1]] + v22;\n    v27 = __ROR8__(v26 ^ v23, 16);\n    v77 = v27 + v24;\n    v83 = __ROL8__((v27 + v24) ^ v25, 1);\n    v28 = v82 + m[v5[2]] + v18;\n    v29 = __ROL8__(v28 ^ v13, 32);\n    v30 = v29 + v17;\n    v31 = __ROR8__(v30 ^ v82, 24);\n    v32 = m[v5[3]] + v28 + v31;\n    v33 = __ROR8__(v32 ^ v29, 16);\n    v76 = v33 + v30;\n    v34 = __ROL8__((v33 + v30) ^ v31, 1);\n    v35 = v20 + v79 + m[v5[4]];\n    v36 = __ROL8__(v35 ^ v16, 32);\n    v37 = v36 + v6;\n    v38 = __ROR8__(v37 ^ v79, 24);\n    v39 = m[v5[5]] + v35 + v38;\n    v40 = __ROR8__(v39 ^ v36, 16);\n    v41 = v40 + v37;\n    v75 = v40;\n    v42 = __ROL8__(v41 ^ v38, 1);\n    v43 = v19 + v78 + m[v5[6]];\n    v44 = __ROL8__(v43 ^ v81, 32);\n    v45 = v44 + v80;\n    v46 = __ROR8__((v44 + v80) ^ v78, 24);\n    v47 = v46 + m[v5[7]] + v43;\n    v48 = v34 + m[v5[8]] + v26;\n    v49 = __ROR8__(v47 ^ v44, 16);\n    v50 = v49 + v45;\n    v51 = __ROL8__(v48 ^ v49, 32);\n    v52 = v51 + v41;\n    v53 = __ROL8__(v50 ^ v46, 1);\n    v54 = __ROR8__(v52 ^ v34, 24);\n    v15 = m[v5[9]] + v48 + v54;\n    v55 = __ROR8__(v15 ^ v51, 16);\n    v6 = v55 + v52;\n    v81 = v55;\n    v82 = __ROL8__(v6 ^ v54, 1);\n    v56 = m[v5[10]] + v32;\n    v57 = __ROL8__((v56 + v42) ^ v27, 32);\n    v58 = m[v5[11]] + v56 + v42;\n    v59 = v57 + v50;\n    v60 = __ROR8__(v59 ^ v42, 24);\n    v18 = v60 + v58;\n    v12 = __ROR8__(v18 ^ v57, 16);\n    v80 = v12 + v59;\n    v79 = __ROL8__((v12 + v59) ^ v60, 1);\n    v61 = v53 + m[v5[12]] + v39;\n    v62 = __ROL8__(v61 ^ v33, 32);\n    v63 = v62 + v77;\n    v64 = __ROR8__((v62 + v77) ^ v53, 24);\n    v20 = v64 + m[v5[13]] + v61;\n    v13 = __ROR8__(v20 ^ v62, 16);\n    v21 = v13 + v63;\n    v78 = __ROL8__(v21 ^ v64, 1);\n    v65 = m[v5[14]] + v47 + v83;\n    v66 = __ROL8__(v65 ^ v75, 32);\n    v5 += 16;\n    v67 = v66 + v76;\n    v68 = __ROR8__((v66 + v76) ^ v83, 24);\n    v19 = v68 + m[*(v5 - 1)] + v65;\n    v16 = __ROR8__(v19 ^ v66, 16);\n    v17 = v16 + v67;\n    v14 = __ROL8__(v17 ^ v68, 1);\n  } while (v5 != (const uint8_t *)&xmmword_5120);\n  v[14] = v16;\n  v[0] = v15;\n  v69 = _mm_loadu_si128((const __m128i *)h);\n  v[1] = v18;\n  si128 = _mm_load_si128((const __m128i *)v);\n  v[8] = v21;\n  v[9] = v17;\n  v71 = _mm_loadu_si128((const __m128i *)h + 1);\n  v[12] = v12;\n  v[10] = v6;\n  v[2] = v20;\n  v[11] = v80;\n  v[3] = v19;\n  *(__m128i *)h = _mm_xor_si128(_mm_xor_si128(si128, *(__m128i *)&v[8]), v69);\n  v72 =\n      _mm_xor_si128(_mm_load_si128((const __m128i *)&v[10]), *(__m128i *)&v[2]);\n  v[13] = v13;\n  v[15] = v81;\n  v[4] = v14;\n  v[5] = v82;\n  *((__m128i *)h + 1) = _mm_xor_si128(v72, v71);\n  v73 =\n      _mm_xor_si128(_mm_load_si128((const __m128i *)&v[12]), *(__m128i *)&v[4]);\n  v[6] = v79;\n  v[7] = v78;\n  v74 = _mm_loadu_si128((const __m128i *)h + 3);\n  *((__m128i *)h + 2) =\n      _mm_xor_si128(v73, _mm_loadu_si128((const __m128i *)h + 2));\n  *((__m128i *)h + 3) = _mm_xor_si128(\n      _mm_xor_si128(_mm_load_si128((const __m128i *)&v[6]), *(__m128i *)&v[14]),\n      v74);\n}", "binary": "blake2b/blake2b.host.O3", "assembly": "<F>:\npush   %r15\nmov    %ecx,%r9d\nmov    %rdi,%rcx\nmov    %rdx,%rax\npush   %r14\nlea    0x3d6c(%rip),%r15\npush   %r13\nmovabs $0x3c6ef372fe94f82b,%r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\npush   %rbx\nsub    $0xf8,%rsp\nmovdqu (%rdi),%xmm1\nmovdqu 0x10(%rdi),%xmm3\nmovdqu 0x20(%rcx),%xmm5\nmovdqu 0x30(%rcx),%xmm7\nmov    %rdi,0x58(%rsp)\nmovabs $0x510e527fade682d1,%rcx\nxor    (%rax),%rcx\nmov    %fs:0x28,%rdx\nmov    %rdx,0xe8(%rsp)\nxor    %edx,%edx\nmovaps %xmm1,(%rsp)\nmov    (%rsp),%r8\nmovabs $0x9b05688c2b3e6c1f,%rdx\nmovaps %xmm3,(%rsp)\nmov    (%rsp),%rdi\nxor    0x8(%rax),%rdx\ntest   %r9d,%r9d\nmovaps %xmm5,(%rsp)\nmov    (%rsp),%r10\nmov    %r8,%r14\nmovabs $0x1f83d9abfb41bd6b,%r9\nmovaps %xmm5,0x80(%rsp)\nmov    0x88(%rsp),%rbx\nmovabs $0xe07c265404be4294,%rax\nmovaps %xmm7,(%rsp)\nmov    (%rsp),%rsi\ncmove  %r9,%rax\nmovabs $0x6a09e667f3bcc908,%r9\nmov    %rbx,0x48(%rsp)\nmov    %rsi,0x30(%rsp)\nmovabs $0xbb67ae8584caa73b,%rsi\nmovaps %xmm1,0x60(%rsp)\nmov    0x68(%rsp),%r8\nmovaps %xmm3,0x70(%rsp)\nmovaps %xmm7,0x90(%rsp)\nmov    0x78(%rsp),%r11\nmov    0x98(%rsp),%rbx\nmov    %rbx,0x28(%rsp)\nmovabs $0xa54ff53a5f1d36f1,%rbx\nmov    %rbx,0x38(%rsp)\nmovabs $0x5be0cd19137e2179,%rbx\nmov    %rbx,0x40(%rsp)\nmov    %r9,%rbx\nmov    %rdi,%r9\nmov    %rbx,%rdi\nmovzbl (%r15),%ebx\nmov    (%r12,%rbx,8),%rbp\nadd    %r10,%rbp\nmov    %rbp,%rbx\nmovzbl 0x1(%r15),%ebp\nadd    %r14,%rbx\nmov    0x48(%rsp),%r14\nxor    %rbx,%rcx\nadd    (%r12,%rbp,8),%rbx\nrol    $0x20,%rcx\nadd    %rcx,%rdi\nxor    %rdi,%r10\nror    $0x18,%r10\nadd    %r10,%rbx\nxor    %rbx,%rcx\nror    $0x10,%rcx\nadd    %rcx,%rdi\nxor    %rdi,%r10\nmov    %rdi,0x20(%rsp)\nmovzbl 0x2(%r15),%edi\nrol    %r10\nmov    (%r12,%rdi,8),%rbp\nmov    %r10,0x50(%rsp)\nmov    %r14,%rdi\nmovzbl 0x3(%r15),%r10d\nadd    %r14,%rbp\nmov    0x30(%rsp),%r14\nadd    %rbp,%r8\nxor    %r8,%rdx\nadd    (%r12,%r10,8),%r8\nrol    $0x20,%rdx\nadd    %rdx,%rsi\nxor    %rsi,%rdi\nror    $0x18,%rdi\nlea    (%r8,%rdi,1),%rbp\nxor    %rbp,%rdx\nror    $0x10,%rdx\nadd    %rdx,%rsi\nxor    %rsi,%rdi\nmov    %rsi,0x18(%rsp)\nmovzbl 0x4(%r15),%esi\nrol    %rdi\nmov    (%r12,%rsi,8),%r8\nmov    %r14,%rsi\nadd    %r14,%r8\nmov    0x28(%rsp),%r14\nadd    %r9,%r8\nmovzbl 0x5(%r15),%r9d\nxor    %r8,%rax\nrol    $0x20,%rax\nadd    %rax,%r13\nxor    %r13,%rsi\nadd    (%r12,%r9,8),%r8\nror    $0x18,%rsi\nlea    (%r8,%rsi,1),%r9\nmov    0x40(%rsp),%r8\nxor    %r9,%rax\nror    $0x10,%rax\nadd    %rax,%r13\nmov    %rax,(%rsp)\nmovzbl 0x6(%r15),%eax\nxor    %r13,%rsi\nmov    (%r12,%rax,8),%r10\nrol    %rsi\nadd    %r14,%r10\nadd    %r11,%r10\nmov    0x38(%rsp),%r11\nxor    %r10,%r8\nrol    $0x20,%r8\nadd    %r8,%r11\nxor    %r11,%r14\nmov    %r14,%rax\nmovzbl 0x7(%r15),%r14d\nror    $0x18,%rax\nadd    (%r12,%r14,8),%r10\nmovzbl 0x8(%r15),%r14d\nadd    %rax,%r10\nadd    (%r12,%r14,8),%rbx\nxor    %r10,%r8\nmovzbl 0x9(%r15),%r14d\nadd    %rdi,%rbx\nror    $0x10,%r8\nadd    %r8,%r11\nxor    %rbx,%r8\nadd    (%r12,%r14,8),%rbx\nrol    $0x20,%r8\nxor    %r11,%rax\nadd    %r8,%r13\nrol    %rax\nxor    %r13,%rdi\nror    $0x18,%rdi\nlea    (%rbx,%rdi,1),%r14\nxor    %r14,%r8\nror    $0x10,%r8\nadd    %r8,%r13\nmov    %r8,0x40(%rsp)\nxor    %r13,%rdi\nmov    %rdi,%r8\nmovzbl 0xa(%r15),%edi\nrol    %r8\nmov    %r8,0x48(%rsp)\nadd    (%r12,%rdi,8),%rbp\nlea    0x0(%rbp,%rsi,1),%r8\nmovzbl 0xb(%r15),%edi\nmov    0x50(%rsp),%rbx\nxor    %r8,%rcx\nrol    $0x20,%rcx\nadd    (%r12,%rdi,8),%r8\nmov    0x20(%rsp),%rdi\nadd    %rcx,%r11\nxor    %r11,%rsi\nror    $0x18,%rsi\nadd    %rsi,%r8\nxor    %r8,%rcx\nror    $0x10,%rcx\nadd    %rcx,%r11\nxor    %r11,%rsi\nmov    %r11,0x38(%rsp)\nmov    %rsi,%r11\nmovzbl 0xc(%r15),%esi\nrol    %r11\nadd    (%r12,%rsi,8),%r9\nmovzbl 0xd(%r15),%esi\nmov    %r11,0x30(%rsp)\nadd    %rax,%r9\nxor    %r9,%rdx\nadd    (%r12,%rsi,8),%r9\nmov    0x18(%rsp),%rsi\nrol    $0x20,%rdx\nadd    %rdx,%rdi\nxor    %rdi,%rax\nror    $0x18,%rax\nadd    %rax,%r9\nxor    %r9,%rdx\nror    $0x10,%rdx\nadd    %rdx,%rdi\nxor    %rdi,%rax\nmov    %rax,%r11\nmovzbl 0xe(%r15),%eax\nrol    %r11\nadd    (%r12,%rax,8),%r10\nmov    (%rsp),%rax\nmov    %r11,0x28(%rsp)\nlea    (%r10,%rbx,1),%r11\nxor    %r11,%rax\nrol    $0x20,%rax\nadd    $0x10,%r15\nadd    %rax,%rsi\nxor    %rsi,%rbx\nmov    %rbx,%r10\nmovzbl -0x1(%r15),%ebx\nror    $0x18,%r10\nadd    (%r12,%rbx,8),%r11\nlea    0x3acf(%rip),%rbx\nadd    %r10,%r11\nxor    %r11,%rax\nror    $0x10,%rax\nadd    %rax,%rsi\nxor    %rsi,%r10\nrol    %r10\ncmp    %rbx,%r15\njne    1410 <F+0x130>\nmov    %rdi,%rbx\nmov    %rax,0xd0(%rsp)\nmov    0x58(%rsp),%rax\nmov    %r9,%rdi\nmov    %rbx,%r9\nmov    %r14,0x60(%rsp)\nmov    0x40(%rsp),%rbx\nmovdqu (%rax),%xmm2\nmov    %r8,0x68(%rsp)\nmovdqa 0x60(%rsp),%xmm0\nmov    %r9,0xa0(%rsp)\nmov    %rsi,0xa8(%rsp)\nmovdqu 0x10(%rax),%xmm4\npxor   0xa0(%rsp),%xmm0\nmov    %rcx,0xc0(%rsp)\nmov    0x38(%rsp),%rcx\nmov    %r13,0xb0(%rsp)\npxor   %xmm2,%xmm0\nmov    %rdi,0x70(%rsp)\nmov    %rcx,0xb8(%rsp)\nmov    0x30(%rsp),%rcx\nmov    %r11,0x78(%rsp)\nmovups %xmm0,(%rax)\nmovdqa 0xb0(%rsp),%xmm0\npxor   0x70(%rsp),%xmm0\nmov    %rdx,0xc8(%rsp)\nmov    0x28(%rsp),%rdx\nmov    %rbx,0xd8(%rsp)\nmov    0x48(%rsp),%rbx\npxor   %xmm4,%xmm0\nmov    %r10,0x80(%rsp)\nmov    %rbx,0x88(%rsp)\nmovups %xmm0,0x10(%rax)\nmovdqa 0xc0(%rsp),%xmm0\npxor   0x80(%rsp),%xmm0\nmov    %rcx,0x90(%rsp)\nmov    %rdx,0x98(%rsp)\nmovdqu 0x20(%rax),%xmm6\nmovdqu 0x30(%rax),%xmm1\npxor   %xmm6,%xmm0\nmovups %xmm0,0x20(%rax)\nmovdqa 0x90(%rsp),%xmm0\npxor   0xd0(%rsp),%xmm0\nmovaps %xmm1,(%rsp)\npxor   %xmm1,%xmm0\nmovups %xmm0,0x30(%rax)\nmov    0xe8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    17a5 <F+0x4c5>\nadd    $0xf8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10c0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "blake2b", "content": "/**\n * @brief blake2b hash function\n *\n * This is the front-end function that sets up the argument for BLAKE2B().\n *\n * @param message the message to be hashed\n * @param len length of message (0 <= len < 2**128) (depends on sizeof(size_t)\n * for this implementation)\n * @param key optional secret key\n * @param kk length of optional secret key (0 <= kk <= 64)\n * @param nn length of output digest (1 <= nn < 64)\n *\n * @returns NULL if heap memory couldn't be allocated. Otherwise heap allocated\n * memory nn bytes large\n */\nuint8_t *blake2b(const uint8_t *message, size_t len, const uint8_t *key,\n                 uint8_t kk, uint8_t nn)\n{\n    uint8_t *dest = NULL;\n    uint64_t long_hold;\n    size_t dd, has_key, i;\n    size_t block_index, word_in_block;\n    u128 ll;\n    block_t *blocks;\n\n    if (message == NULL)\n    {\n        len = 0;\n    }\n    if (key == NULL)\n    {\n        kk = 0;\n    }\n\n    kk = MIN(kk, KK_MAX);\n    nn = MIN(nn, NN_MAX);\n\n    dd = MAX(CEIL(kk, bb) + CEIL(len, bb), 1);\n\n    blocks = libmin_calloc(dd, sizeof(block_t));\n    if (blocks == NULL)\n    {\n        return NULL;\n    }\n\n    dest = libmin_malloc(nn * sizeof(uint8_t));\n    if (dest == NULL)\n    {\n        libmin_free(blocks);\n        return NULL;\n    }\n\n    /* If there is a secret key it occupies the first block */\n    for (i = 0; i < kk; i++)\n    {\n        long_hold = key[i];\n        long_hold <<= 8 * (i % 8);\n\n        word_in_block = (i % bb) / 8;\n        /* block_index will always be 0 because kk <= 64 and bb = 128*/\n        blocks[0][word_in_block] |= long_hold;\n    }\n\n    has_key = kk > 0 ? 1 : 0;\n\n    for (i = 0; i < len; i++)\n    {\n        /* long_hold exists because the bit-shifting will overflow if we don't\n         * store the value */\n        long_hold = message[i];\n        long_hold <<= 8 * (i % 8);\n\n        block_index = has_key + (i / bb);\n        word_in_block = (i % bb) / 8;\n\n        blocks[block_index][word_in_block] |= long_hold;\n    }\n\n    u128_fill(ll, len);\n\n    BLAKE2B(dest, blocks, dd, ll, kk, nn);\n\n    libmin_free(blocks);\n\n    return dest;\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O3.pseudo", "function_name": "blake2b", "address": "0x17b0", "label": "blake2b", "content": "uint8_t *__fastcall blake2b(const uint8_t *message, size_t len, const uint8_t *key, uint8_t kk, uint8_t nn)\n{\n  size_t v7; // rbx\n  size_t v8; // rbp\n  uint8_t v9; // al\n  __int64 v10; // rdx\n  uint8_t v11; // al\n  uint8_t v12; // r12\n  size_t v13; // rax\n  _QWORD *v14; // r13\n  uint8_t *v15; // r12\n  unsigned __int64 v16; // rax\n  char v17; // cl\n  __int64 v18; // rsi\n  unsigned __int64 v19; // rdi\n  unsigned __int64 v20; // rsi\n  __int64 v21; // r8\n  unsigned __int64 v22; // rax\n  unsigned __int64 v23; // rdi\n  char v24; // cl\n  uint64_t v25; // r12\n  unsigned __int64 v26; // rbx\n  unsigned __int64 v27; // rax\n  uint64_t v29; // rdx\n  __int64 v30; // [rsp+0h] [rbp-D8h]\n  uint8_t blocks; // [rsp+8h] [rbp-D0h]\n  size_t dd; // [rsp+10h] [rbp-C8h]\n  uint8_t kka; // [rsp+1Fh] [rbp-B9h]\n  uint8_t dest; // [rsp+20h] [rbp-B8h]\n  uint8_t *desta; // [rsp+20h] [rbp-B8h]\n  __int64 v37; // [rsp+28h] [rbp-B0h]\n  size_t v38; // [rsp+28h] [rbp-B0h]\n  u128 ll; // [rsp+30h] [rbp-A8h] BYREF\n  uint64_t t[2]; // [rsp+40h] [rbp-98h] BYREF\n  uint64_t h[8]; // [rsp+50h] [rbp-88h] BYREF\n  _QWORD v42[9]; // [rsp+90h] [rbp-48h]\n\n  kka = kk;\n  v42[1] = __readfsqword(0x28u);\n  if ( message )\n  {\n    v7 = len;\n    v8 = ((len & 0x7F) != 0) + (len >> 7);\n  }\n  else\n  {\n    v8 = 0LL;\n    v7 = 0LL;\n  }\n  if ( key )\n  {\n    v9 = 64;\n    v10 = kk != 0;\n    v8 += v10;\n    if ( kk <= 0x40u )\n      v9 = kk;\n    blocks = v9;\n  }\n  else\n  {\n    blocks = 0;\n    v10 = 0LL;\n    kka = 0;\n  }\n  v37 = v10;\n  v11 = 64;\n  if ( nn <= 0x40u )\n    v11 = nn;\n  dest = v11;\n  v12 = v11;\n  v13 = 1LL;\n  if ( v8 )\n    v13 = v8;\n  dd = v13;\n  v14 = libmin_calloc(v13, 0x80uLL);\n  if ( !v14 )\n    return 0LL;\n  v30 = v12;\n  v15 = (uint8_t *)libmin_malloc(v12);\n  if ( v15 )\n  {\n    v16 = 0LL;\n    if ( blocks )\n    {\n      do\n      {\n        v17 = v16;\n        v18 = key[v16];\n        v19 = v16++;\n        v14[v19 >> 3] |= v18 << (8 * (v17 & 7u));\n      }\n      while ( v16 != blocks );\n    }\n    v20 = 0LL;\n    if ( v7 )\n    {\n      do\n      {\n        v21 = message[v20];\n        v22 = v20 >> 7;\n        v23 = v20 >> 3;\n        v24 = v20++ & 7;\n        v14[16 * v37 + 16 * v22 + (v23 & 0xF)] |= v21 << (8 * v24);\n      }\n      while ( v7 != v20 );\n    }\n    ll[0] = v7;\n    h[1] = 0xBB67AE8584CAA73BLL;\n    h[2] = 0x3C6EF372FE94F82BLL;\n    h[3] = 0xA54FF53A5F1D36F1LL;\n    h[4] = 0x510E527FADE682D1LL;\n    h[5] = 0x9B05688C2B3E6C1FLL;\n    h[6] = 0x1F83D9ABFB41BD6BLL;\n    h[7] = 0x5BE0CD19137E2179LL;\n    ll[1] = 0LL;\n    *(_OWORD *)t = 0LL;\n    h[0] = dest ^ (blocks << 8) ^ 0x1010000u ^ 0x6A09E667F3BCC908LL;\n    if ( v8 > 1 )\n    {\n      desta = v15;\n      v25 = 128LL;\n      v38 = v7;\n      v26 = 0LL;\n      while ( 1 )\n      {\n        ++v26;\n        t[0] = v25;\n        F(h, &v14[v25 / 8 - 16], t, 0);\n        if ( v26 >= dd - 1 )\n          break;\n        if ( v25 > 0xFFFFFFFFFFFFFF7ELL )\n          ++t[1];\n        v25 += 128LL;\n      }\n      v15 = desta;\n      v7 = v38;\n    }\n    if ( kka )\n    {\n      if ( v7 > 0xFFFFFFFFFFFFFF7ELL )\n        ll[1] = 1LL;\n      ll[0] = v7 + 128;\n    }\n    F(h, &v14[16 * dd - 16], ll, 1);\n    v27 = 0LL;\n    if ( nn )\n    {\n      do\n      {\n        while ( (v27 & 7) != 0 )\n        {\n          v15[v27] = *((_BYTE *)v42 + (v27 & 7));\n          if ( v30 == ++v27 )\n            goto LABEL_31;\n        }\n        v29 = h[v27 >> 3];\n        v15[v27++] = v29;\n        v42[0] = v29;\n      }\n      while ( v30 != v27 );\n    }\n  }\nLABEL_31:\n  libmin_free(v14);\n  return v15;\n}\n"}, "pseudo_normalize": "uint8_t *blake2b(const uint8_t *message, unsigned int len, const uint8_t *key,\n                 uint8_t kk, uint8_t nn) {\n  unsigned int v7;\n  unsigned int v8;\n  uint8_t v9;\n  long long v10;\n  uint8_t v11;\n  uint8_t v12;\n  unsigned int v13;\n  uint64_t *v14;\n  uint8_t *v15;\n  unsigned long long v16;\n  char v17;\n  long long v18;\n  unsigned long long v19;\n  unsigned long long v20;\n  long long v21;\n  unsigned long long v22;\n  unsigned long long v23;\n  char v24;\n  uint64_t v25;\n  unsigned long long v26;\n  unsigned long long v27;\n  uint64_t v29;\n  long long v30;\n  uint8_t blocks;\n  unsigned int dd;\n  uint8_t kka;\n  uint8_t dest;\n  uint8_t *desta;\n  long long v37;\n  unsigned int v38;\n  u128 ll;\n  uint64_t t[2];\n  uint64_t h[8];\n  uint64_t v42[9];\n  kka = kk;\n  v42[1] = __readfsqword(40u);\n  if (message) {\n    v7 = len;\n    v8 = ((len & 127) != 0) + (len >> 7);\n  } else {\n    v8 = 0LL;\n    v7 = 0LL;\n  }\n  if (key) {\n    v9 = 64;\n    v10 = kk != 0;\n    v8 += v10;\n    if (kk <= 64u) v9 = kk;\n    blocks = v9;\n  } else {\n    blocks = 0;\n    v10 = 0LL;\n    kka = 0;\n  }\n  v37 = v10;\n  v11 = 64;\n  if (nn <= 64u) v11 = nn;\n  dest = v11;\n  v12 = v11;\n  v13 = 1LL;\n  if (v8) v13 = v8;\n  dd = v13;\n  v14 = libmin_calloc(v13, 128uLL);\n  if (!v14) return 0LL;\n  v30 = v12;\n  v15 = (uint8_t *)libmin_malloc(v12);\n  if (v15) {\n    v16 = 0LL;\n    if (blocks) {\n      do {\n        v17 = v16;\n        v18 = key[v16];\n        v19 = v16++;\n        v14[v19 >> 3] |= v18 << (8 * (v17 & 7u));\n      } while (v16 != blocks);\n    }\n    v20 = 0LL;\n    if (v7) {\n      do {\n        v21 = message[v20];\n        v22 = v20 >> 7;\n        v23 = v20 >> 3;\n        v24 = v20++ & 7;\n        v14[16 * v37 + 16 * v22 + (v23 & 15)] |= v21 << (8 * v24);\n      } while (v7 != v20);\n    }\n    ll[0] = v7;\n    h[1] = 13503953896175478587LL;\n    h[2] = 4354685564936845355LL;\n    h[3] = 11912009170470909681LL;\n    h[4] = 5840696475078001361LL;\n    h[5] = 11170449401992604703LL;\n    h[6] = 2270897969802886507LL;\n    h[7] = 6620516959819538809LL;\n    ll[1] = 0LL;\n    *(long double *)t = 0LL;\n    h[0] = dest ^ (blocks << 8) ^ 16842752u ^ 7640891576956012808LL;\n    if (v8 > 1) {\n      desta = v15;\n      v25 = 128LL;\n      v38 = v7;\n      v26 = 0LL;\n      while (1) {\n        ++v26;\n        t[0] = v25;\n        F(h, &v14[v25 / 8 - 16], t, 0);\n        if (v26 >= dd - 1) break;\n        if (v25 > 18446744073709551486LL) ++t[1];\n        v25 += 128LL;\n      }\n      v15 = desta;\n      v7 = v38;\n    }\n    if (kka) {\n      if (v7 > 18446744073709551486LL) ll[1] = 1LL;\n      ll[0] = v7 + 128;\n    }\n    F(h, &v14[16 * dd - 16], ll, 1);\n    v27 = 0LL;\n    if (nn) {\n      do {\n        while ((v27 & 7) != 0) {\n          v15[v27] = *((uint8_t *)v42 + (v27 & 7));\n          if (v30 == ++v27) goto LABEL_31;\n        }\n        v29 = h[v27 >> 3];\n        v15[v27++] = v29;\n        v42[0] = v29;\n      } while (v30 != v27);\n    }\n  }\nLABEL_31:\n  libmin_free(v14);\n  return v15;\n}", "binary": "blake2b/blake2b.host.O3", "assembly": "<blake2b>:\nendbr64\npush   %r15\nmov    %rdx,%r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xa8,%rsp\nmov    %r8d,0x18(%rsp)\nmov    %cl,0x1f(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x98(%rsp)\nxor    %eax,%eax\ntest   %rdi,%rdi\nje     1b30 <blake2b+0x380>\nxor    %r9d,%r9d\nmov    %rsi,%rax\ntest   $0x7f,%sil\nmov    %rsi,%rbx\nsetne  %r9b\nshr    $0x7,%rax\nlea    (%r9,%rax,1),%rbp\ntest   %r15,%r15\nje     1b18 <blake2b+0x368>\nxor    %edx,%edx\ntest   %cl,%cl\nmov    $0x40,%eax\nsetne  %dl\nadd    %rdx,%rbp\ncmp    %al,%cl\ncmovbe %ecx,%eax\nmov    %al,0x8(%rsp)\nmov    %rdx,0x28(%rsp)\nmov    0x18(%rsp),%edx\nmov    $0x40,%eax\ncmp    %al,%dl\nmov    %edx,%esi\ncmovbe %esi,%eax\ntest   %rbp,%rbp\nmov    $0x80,%esi\nmov    %al,0x20(%rsp)\nmov    %eax,%r12d\nmov    $0x1,%eax\ncmovne %rbp,%rax\nmov    %rax,%rdi\nmov    %rax,0x10(%rsp)\ncall   21b0 <libmin_calloc>\nmov    %rax,%r13\ntest   %rax,%rax\nje     1b39 <blake2b+0x389>\nmovzbl %r12b,%eax\nmov    %rax,%rdi\nmov    %rax,(%rsp)\ncall   2060 <libmin_malloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1ab6 <blake2b+0x306>\nmovzbl 0x8(%rsp),%r10d\nxor    %eax,%eax\nmov    0x28(%rsp),%rdx\ntest   %r10b,%r10b\nje     18c5 <blake2b+0x115>\nxchg   %ax,%ax\nmov    %eax,%ecx\nmovzbl (%r15,%rax,1),%esi\nmov    %rax,%rdi\nadd    $0x1,%rax\nand    $0x7,%ecx\nshr    $0x3,%rdi\nshl    $0x3,%ecx\nshl    %cl,%rsi\nor     %rsi,0x0(%r13,%rdi,8)\ncmp    %r10,%rax\njne    18a0 <blake2b+0xf0>\nxor    %esi,%esi\ntest   %rbx,%rbx\nje     1908 <blake2b+0x158>\nnopl   0x0(%rax)\nmov    %rsi,%rax\nmov    %rsi,%rdi\nmov    %esi,%ecx\nmovzbl (%r14,%rsi,1),%r8d\nshr    $0x7,%rax\nshr    $0x3,%rdi\nand    $0x7,%ecx\nadd    $0x1,%rsi\nadd    %rdx,%rax\nand    $0xf,%edi\nshl    $0x3,%ecx\nshl    $0x7,%rax\nshl    %cl,%r8\nadd    %r13,%rax\nor     %r8,(%rax,%rdi,8)\ncmp    %rsi,%rbx\njne    18d0 <blake2b+0x120>\nmovzbl 0x20(%rsp),%edx\npxor   %xmm0,%xmm0\nmov    %rbx,0x30(%rsp)\nmovabs $0xbb67ae8584caa73b,%rax\nmov    %rax,0x58(%rsp)\nlea    0x50(%rsp),%r15\nmovabs $0x3c6ef372fe94f82b,%rax\nmov    %rax,0x60(%rsp)\nmovabs $0xa54ff53a5f1d36f1,%rax\nmov    %rax,0x68(%rsp)\nmovabs $0x510e527fade682d1,%rax\nmov    %rax,0x70(%rsp)\nmovabs $0x9b05688c2b3e6c1f,%rax\nmov    %rax,0x78(%rsp)\nmovabs $0x1f83d9abfb41bd6b,%rax\nmov    %rax,0x80(%rsp)\nmovabs $0x5be0cd19137e2179,%rax\nmov    %rax,0x88(%rsp)\nmovzbl 0x8(%rsp),%eax\nmovq   $0x0,0x38(%rsp)\nshl    $0x8,%eax\nmovaps %xmm0,0x40(%rsp)\nxor    %edx,%eax\nmovabs $0x6a09e667f3bcc908,%rdx\nxor    $0x1010000,%eax\ncltq\nxor    %rdx,%rax\nmov    %rax,0x50(%rsp)\ncmp    $0x1,%rbp\njbe    1a49 <blake2b+0x299>\nmov    0x10(%rsp),%rax\nmov    $0x80,%ebp\nxor    %r14d,%r14d\nlea    -0x80(%r13),%rsi\nlea    0x40(%rsp),%rdi\nmov    %r13,0x8(%rsp)\nlea    0x50(%rsp),%r15\nsub    $0x1,%rax\nmov    %r12,0x20(%rsp)\nmov    %rbp,%r12\nmov    %rdi,%rbp\nmov    %rbx,0x28(%rsp)\nmov    %rax,%r13\nmov    %r14,%rbx\nmov    %rsi,%r14\njmp    1a1b <blake2b+0x26b>\nnopl   0x0(%rax)\ncmp    $0xffffffffffffff7e,%r12\njbe    1a17 <blake2b+0x267>\naddq   $0x1,0x48(%rsp)\nsub    $0xffffffffffffff80,%r12\nlea    (%r14,%r12,1),%rsi\nxor    %ecx,%ecx\nmov    %rbp,%rdx\nmov    %r15,%rdi\nadd    $0x1,%rbx\nmov    %r12,0x40(%rsp)\ncall   12e0 <F>\ncmp    %r13,%rbx\njb     1a08 <blake2b+0x258>\nmov    0x8(%rsp),%r13\nmov    0x20(%rsp),%r12\nmov    0x28(%rsp),%rbx\ncmpb   $0x0,0x1f(%rsp)\nje     1a6b <blake2b+0x2bb>\ncmp    $0xffffffffffffff7e,%rbx\njbe    1a62 <blake2b+0x2b2>\nmovq   $0x1,0x38(%rsp)\nsub    $0xffffffffffffff80,%rbx\nmov    %rbx,0x30(%rsp)\nmov    0x10(%rsp),%rax\nlea    0x30(%rsp),%rdx\nmov    $0x1,%ecx\nmov    %r15,%rdi\nshl    $0x7,%rax\nlea    -0x80(%r13,%rax,1),%rsi\ncall   12e0 <F>\nxor    %eax,%eax\ncmpb   $0x0,0x18(%rsp)\nje     1ab6 <blake2b+0x306>\nnopl   0x0(%rax)\nmov    %rax,%rdx\nand    $0x7,%edx\nje     1af0 <blake2b+0x340>\nmovzbl 0x90(%rsp,%rdx,1),%edx\nmov    %dl,(%r12,%rax,1)\nadd    $0x1,%rax\ncmp    %rax,(%rsp)\njne    1a98 <blake2b+0x2e8>\nmov    %r13,%rdi\ncall   2110 <libmin_free>\nmov    0x98(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1b3e <blake2b+0x38e>\nadd    $0xa8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\nmov    %rax,%rdx\nshr    $0x3,%rdx\nmov    0x50(%rsp,%rdx,8),%rdx\nmov    %dl,(%r12,%rax,1)\nadd    $0x1,%rax\nmov    %rdx,0x90(%rsp)\ncmp    %rax,(%rsp)\njne    1a98 <blake2b+0x2e8>\njmp    1ab6 <blake2b+0x306>\nnopl   0x0(%rax)\nmovb   $0x0,0x8(%rsp)\nxor    %edx,%edx\nmovb   $0x0,0x1f(%rsp)\njmp    182a <blake2b+0x7a>\nnopl   0x0(%rax)\nxor    %ebp,%ebp\nxor    %ebx,%ebx\njmp    1809 <blake2b+0x59>\nxor    %r12d,%r12d\njmp    1abe <blake2b+0x30e>\ncall   10c0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "main", "content": "/**\n * @brief main function\n *\n * @returns 0 on successful program exit\n */\nint main()\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  test();\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "blake2b/blake2b.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nxor    %eax,%eax\ncall   1b50 <test>\ncall   45e0 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "test", "content": "/**\n * @brief testing function\n *\n * @returns void\n */\nstatic void test()\n{\n    uint8_t *digest = NULL;\n\n    /* \"abc\" example straight out of RFC-7693 */\n    uint8_t abc[3] = {'a', 'b', 'c'};\n    uint8_t abc_answer[64] = {\n        0xBA, 0x80, 0xA5, 0x3F, 0x98, 0x1C, 0x4D, 0x0D, 0x6A, 0x27, 0x97,\n        0xB6, 0x9F, 0x12, 0xF6, 0xE9, 0x4C, 0x21, 0x2F, 0x14, 0x68, 0x5A,\n        0xC4, 0xB7, 0x4B, 0x12, 0xBB, 0x6F, 0xDB, 0xFF, 0xA2, 0xD1, 0x7D,\n        0x87, 0xC5, 0x39, 0x2A, 0xAB, 0x79, 0x2D, 0xC2, 0x52, 0xD5, 0xDE,\n        0x45, 0x33, 0xCC, 0x95, 0x18, 0xD3, 0x8A, 0xA8, 0xDB, 0xF1, 0x92,\n        0x5A, 0xB9, 0x23, 0x86, 0xED, 0xD4, 0x00, 0x99, 0x23};\n\n    digest = blake2b(abc, 3, NULL, 0, 64);\n    assert_bytes(abc_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t key_answer[64] = {\n        0x10, 0xeb, 0xb6, 0x77, 0x00, 0xb1, 0x86, 0x8e, 0xfb, 0x44, 0x17,\n        0x98, 0x7a, 0xcf, 0x46, 0x90, 0xae, 0x9d, 0x97, 0x2f, 0xb7, 0xa5,\n        0x90, 0xc2, 0xf0, 0x28, 0x71, 0x79, 0x9a, 0xaa, 0x47, 0x86, 0xb5,\n        0xe9, 0x96, 0xe8, 0xf0, 0xf4, 0xeb, 0x98, 0x1f, 0xc2, 0x14, 0xb0,\n        0x05, 0xf4, 0x2d, 0x2f, 0xf4, 0x23, 0x34, 0x99, 0x39, 0x16, 0x53,\n        0xdf, 0x7a, 0xef, 0xcb, 0xc1, 0x3f, 0xc5, 0x15, 0x68};\n\n    digest = blake2b(NULL, 0, key, 64, 64);\n    assert_bytes(key_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t zero[1] = {0};\n    uint8_t zero_key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t zero_answer[64] = {\n        0x96, 0x1f, 0x6d, 0xd1, 0xe4, 0xdd, 0x30, 0xf6, 0x39, 0x01, 0x69,\n        0x0c, 0x51, 0x2e, 0x78, 0xe4, 0xb4, 0x5e, 0x47, 0x42, 0xed, 0x19,\n        0x7c, 0x3c, 0x5e, 0x45, 0xc5, 0x49, 0xfd, 0x25, 0xf2, 0xe4, 0x18,\n        0x7b, 0x0b, 0xc9, 0xfe, 0x30, 0x49, 0x2b, 0x16, 0xb0, 0xd0, 0xbc,\n        0x4e, 0xf9, 0xb0, 0xf3, 0x4c, 0x70, 0x03, 0xfa, 0xc0, 0x9a, 0x5e,\n        0xf1, 0x53, 0x2e, 0x69, 0x43, 0x02, 0x34, 0xce, 0xbd};\n\n    digest = blake2b(zero, 1, zero_key, 64, 64);\n    assert_bytes(zero_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t filled[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t filled_key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t filled_answer[64] = {\n        0x65, 0x67, 0x6d, 0x80, 0x06, 0x17, 0x97, 0x2f, 0xbd, 0x87, 0xe4,\n        0xb9, 0x51, 0x4e, 0x1c, 0x67, 0x40, 0x2b, 0x7a, 0x33, 0x10, 0x96,\n        0xd3, 0xbf, 0xac, 0x22, 0xf1, 0xab, 0xb9, 0x53, 0x74, 0xab, 0xc9,\n        0x42, 0xf1, 0x6e, 0x9a, 0xb0, 0xea, 0xd3, 0x3b, 0x87, 0xc9, 0x19,\n        0x68, 0xa6, 0xe5, 0x09, 0xe1, 0x19, 0xff, 0x07, 0x78, 0x7b, 0x3e,\n        0xf4, 0x83, 0xe1, 0xdc, 0xdc, 0xcf, 0x6e, 0x30, 0x22};\n\n    digest = blake2b(filled, 64, filled_key, 64, 64);\n    assert_bytes(filled_answer, digest, 64);\n\n    libmin_free(digest);\n\n    libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O3.pseudo", "function_name": "test", "address": "0x1b50", "label": "test", "content": "void __cdecl test()\n{\n  uint8_t *v0; // rbp\n  uint8_t v1; // dl\n  uint8_t *v2; // rbp\n  uint8_t v3; // dl\n  uint8_t *v4; // rbp\n  uint8_t v5; // dl\n  uint8_t *v6; // rsi\n  uint8_t v7; // dl\n  uint8_t zero[1]; // [rsp+Ch] [rbp-21Ch] BYREF\n  uint8_t abc[3]; // [rsp+Dh] [rbp-21Bh] BYREF\n  uint8_t abc_answer[64]; // [rsp+10h] [rbp-218h] BYREF\n  uint8_t key[64]; // [rsp+50h] [rbp-1D8h] BYREF\n  uint8_t key_answer[64]; // [rsp+90h] [rbp-198h] BYREF\n  uint8_t zero_key[64]; // [rsp+D0h] [rbp-158h] BYREF\n  uint8_t zero_answer[64]; // [rsp+110h] [rbp-118h] BYREF\n  uint8_t filled[64]; // [rsp+150h] [rbp-D8h] BYREF\n  uint8_t filled_key[64]; // [rsp+190h] [rbp-98h] BYREF\n  uint8_t filled_answer[64]; // [rsp+1D0h] [rbp-58h] BYREF\n  unsigned __int64 v18; // [rsp+218h] [rbp-10h]\n\n  v18 = __readfsqword(0x28u);\n  *(__m128i *)abc_answer = _mm_load_si128((const __m128i *)&xmmword_5120);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(__m128i *)&abc_answer[16] = _mm_load_si128((const __m128i *)&xmmword_5130);\n  *(__m128i *)&abc_answer[32] = _mm_load_si128((const __m128i *)&xmmword_5140);\n  *(__m128i *)&abc_answer[48] = _mm_load_si128((const __m128i *)&xmmword_5150);\n  v0 = blake2b(abc, 3uLL, 0LL, 0, 0x40u);\n  assert_bytes(abc_answer, v0, v1);\n  libmin_free(v0);\n  *(__m128i *)key = _mm_load_si128((const __m128i *)&xmmword_5160);\n  *(__m128i *)key_answer = _mm_load_si128((const __m128i *)&xmmword_51A0);\n  *(__m128i *)&key[16] = _mm_load_si128((const __m128i *)&xmmword_5170);\n  *(__m128i *)&key_answer[16] = _mm_load_si128((const __m128i *)&xmmword_51B0);\n  *(__m128i *)&key[32] = _mm_load_si128((const __m128i *)&xmmword_5180);\n  *(__m128i *)&key_answer[32] = _mm_load_si128((const __m128i *)&xmmword_51C0);\n  *(__m128i *)&key[48] = _mm_load_si128((const __m128i *)&xmmword_5190);\n  *(__m128i *)&key_answer[48] = _mm_load_si128((const __m128i *)&xmmword_51D0);\n  v2 = blake2b(0LL, 0LL, key, 0x40u, 0x40u);\n  assert_bytes(key_answer, v2, v3);\n  libmin_free(v2);\n  *(__m128i *)zero_answer = _mm_load_si128((const __m128i *)&xmmword_51E0);\n  *(__m128i *)zero_key = _mm_load_si128((const __m128i *)&xmmword_5160);\n  *(__m128i *)&zero_answer[16] = _mm_load_si128((const __m128i *)&xmmword_51F0);\n  *(__m128i *)&zero_key[16] = _mm_load_si128((const __m128i *)&xmmword_5170);\n  *(__m128i *)&zero_answer[32] = _mm_load_si128((const __m128i *)&xmmword_5200);\n  *(__m128i *)&zero_key[32] = _mm_load_si128((const __m128i *)&xmmword_5180);\n  *(__m128i *)&zero_answer[48] = _mm_load_si128((const __m128i *)&xmmword_5210);\n  *(__m128i *)&zero_key[48] = _mm_load_si128((const __m128i *)&xmmword_5190);\n  zero[0] = 0;\n  v4 = blake2b(zero, 1uLL, zero_key, 0x40u, 0x40u);\n  assert_bytes(zero_answer, v4, v5);\n  libmin_free(v4);\n  *(__m128i *)&filled[48] = _mm_load_si128((const __m128i *)&xmmword_5190);\n  *(_OWORD *)&filled_key[48] = *(_OWORD *)&filled[48];\n  *(__m128i *)filled = _mm_load_si128((const __m128i *)&xmmword_5160);\n  *(__m128i *)filled_answer = _mm_load_si128((const __m128i *)&xmmword_5220);\n  *(__m128i *)&filled[16] = _mm_load_si128((const __m128i *)&xmmword_5170);\n  *(__m128i *)&filled_answer[16] = _mm_load_si128((const __m128i *)&xmmword_5230);\n  *(__m128i *)&filled[32] = _mm_load_si128((const __m128i *)&xmmword_5180);\n  *(__m128i *)&filled_answer[32] = _mm_load_si128((const __m128i *)&xmmword_5240);\n  *(_OWORD *)filled_key = *(_OWORD *)filled;\n  *(_OWORD *)&filled_key[16] = *(_OWORD *)&filled[16];\n  *(_OWORD *)&filled_key[32] = *(_OWORD *)&filled[32];\n  *(__m128i *)&filled_answer[48] = _mm_load_si128((const __m128i *)&xmmword_5250);\n  v6 = blake2b(filled, 0x40uLL, filled_key, 0x40u, 0x40u);\n  assert_bytes(filled_answer, v6, v7);\n  libmin_free(v6);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}\n"}, "pseudo_normalize": "void test() {\n  uint8_t *v0;\n  uint8_t v1;\n  uint8_t *v2;\n  uint8_t v3;\n  uint8_t *v4;\n  uint8_t v5;\n  uint8_t *v6;\n  uint8_t v7;\n  uint8_t zero[1];\n  uint8_t abc[3];\n  uint8_t abc_answer[64];\n  uint8_t key[64];\n  uint8_t key_answer[64];\n  uint8_t zero_key[64];\n  uint8_t zero_answer[64];\n  uint8_t filled[64];\n  uint8_t filled_key[64];\n  uint8_t filled_answer[64];\n  unsigned long long v18;\n  v18 = __readfsqword(40u);\n  *(__m128i *)abc_answer = _mm_load_si128((const __m128i *)&xmmword_5120);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(__m128i *)&abc_answer[16] = _mm_load_si128((const __m128i *)&xmmword_5130);\n  *(__m128i *)&abc_answer[32] = _mm_load_si128((const __m128i *)&xmmword_5140);\n  *(__m128i *)&abc_answer[48] = _mm_load_si128((const __m128i *)&xmmword_5150);\n  v0 = blake2b(abc, 3uLL, 0LL, 0, 64u);\n  assert_bytes(abc_answer, v0, v1);\n  libmin_free(v0);\n  *(__m128i *)key = _mm_load_si128((const __m128i *)&xmmword_5160);\n  *(__m128i *)key_answer = _mm_load_si128((const __m128i *)&xmmword_51A0);\n  *(__m128i *)&key[16] = _mm_load_si128((const __m128i *)&xmmword_5170);\n  *(__m128i *)&key_answer[16] = _mm_load_si128((const __m128i *)&xmmword_51B0);\n  *(__m128i *)&key[32] = _mm_load_si128((const __m128i *)&xmmword_5180);\n  *(__m128i *)&key_answer[32] = _mm_load_si128((const __m128i *)&xmmword_51C0);\n  *(__m128i *)&key[48] = _mm_load_si128((const __m128i *)&xmmword_5190);\n  *(__m128i *)&key_answer[48] = _mm_load_si128((const __m128i *)&xmmword_51D0);\n  v2 = blake2b(0LL, 0LL, key, 64u, 64u);\n  assert_bytes(key_answer, v2, v3);\n  libmin_free(v2);\n  *(__m128i *)zero_answer = _mm_load_si128((const __m128i *)&xmmword_51E0);\n  *(__m128i *)zero_key = _mm_load_si128((const __m128i *)&xmmword_5160);\n  *(__m128i *)&zero_answer[16] = _mm_load_si128((const __m128i *)&xmmword_51F0);\n  *(__m128i *)&zero_key[16] = _mm_load_si128((const __m128i *)&xmmword_5170);\n  *(__m128i *)&zero_answer[32] = _mm_load_si128((const __m128i *)&xmmword_5200);\n  *(__m128i *)&zero_key[32] = _mm_load_si128((const __m128i *)&xmmword_5180);\n  *(__m128i *)&zero_answer[48] = _mm_load_si128((const __m128i *)&xmmword_5210);\n  *(__m128i *)&zero_key[48] = _mm_load_si128((const __m128i *)&xmmword_5190);\n  zero[0] = 0;\n  v4 = blake2b(zero, 1uLL, zero_key, 64u, 64u);\n  assert_bytes(zero_answer, v4, v5);\n  libmin_free(v4);\n  *(__m128i *)&filled[48] = _mm_load_si128((const __m128i *)&xmmword_5190);\n  *(long double *)&filled_key[48] = *(long double *)&filled[48];\n  *(__m128i *)filled = _mm_load_si128((const __m128i *)&xmmword_5160);\n  *(__m128i *)filled_answer = _mm_load_si128((const __m128i *)&xmmword_5220);\n  *(__m128i *)&filled[16] = _mm_load_si128((const __m128i *)&xmmword_5170);\n  *(__m128i *)&filled_answer[16] =\n      _mm_load_si128((const __m128i *)&xmmword_5230);\n  *(__m128i *)&filled[32] = _mm_load_si128((const __m128i *)&xmmword_5180);\n  *(__m128i *)&filled_answer[32] =\n      _mm_load_si128((const __m128i *)&xmmword_5240);\n  *(long double *)filled_key = *(long double *)filled;\n  *(long double *)&filled_key[16] = *(long double *)&filled[16];\n  *(long double *)&filled_key[32] = *(long double *)&filled[32];\n  *(__m128i *)&filled_answer[48] =\n      _mm_load_si128((const __m128i *)&xmmword_5250);\n  v6 = blake2b(filled, 64uLL, filled_key, 64u, 64u);\n  assert_bytes(filled_answer, v6, v7);\n  libmin_free(v6);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}", "binary": "blake2b/blake2b.host.O3", "assembly": "<test>:\npush   %rbp\nxor    %ecx,%ecx\nxor    %edx,%edx\nmov    $0x40,%r8d\nmov    $0x3,%esi\nsub    $0x220,%rsp\nmovdqa 0x35b1(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x218(%rsp)\nxor    %eax,%eax\nlea    0xd(%rsp),%rdi\nmov    $0x6261,%eax\nmovb   $0x63,0xf(%rsp)\nmovaps %xmm0,0x10(%rsp)\nmovdqa 0x3592(%rip),%xmm0\nmov    %ax,0xd(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmovdqa 0x3590(%rip),%xmm0\nmovaps %xmm0,0x30(%rsp)\nmovdqa 0x3593(%rip),%xmm0\nmovaps %xmm0,0x40(%rsp)\ncall   17b0 <blake2b>\nlea    0x10(%rsp),%rdi\nmov    %rax,%rbp\nmov    %rax,%rsi\ncall   1230 <assert_bytes.constprop.0>\nmov    %rbp,%rdi\ncall   2110 <libmin_free>\nmovdqa 0x35b9(%rip),%xmm4\nxor    %esi,%esi\nmovdqa 0x356f(%rip),%xmm3\nmovdqa 0x3577(%rip),%xmm2\nmovdqa 0x357f(%rip),%xmm1\nlea    0x50(%rsp),%rdx\nxor    %edi,%edi\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmovaps %xmm3,0x50(%rsp)\nmovdqa 0x3570(%rip),%xmm0\nmovaps %xmm4,0x90(%rsp)\nmovdqa 0x3580(%rip),%xmm4\nmovaps %xmm2,0x60(%rsp)\nmovaps %xmm4,0xa0(%rsp)\nmovdqa 0x357b(%rip),%xmm4\nmovaps %xmm1,0x70(%rsp)\nmovaps %xmm4,0xb0(%rsp)\nmovdqa 0x3576(%rip),%xmm4\nmovaps %xmm0,0x80(%rsp)\nmovaps %xmm4,0xc0(%rsp)\ncall   17b0 <blake2b>\nlea    0x90(%rsp),%rdi\nmov    %rax,%rbp\nmov    %rax,%rsi\ncall   1230 <assert_bytes.constprop.0>\nmov    %rbp,%rdi\ncall   2110 <libmin_free>\nmovdqa 0x354e(%rip),%xmm4\nmovdqa 0x34c6(%rip),%xmm3\nlea    0xd0(%rsp),%rdx\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nlea    0xc(%rsp),%rdi\nmovdqa 0x34b6(%rip),%xmm2\nmovaps %xmm4,0x110(%rsp)\nmovdqa 0x3526(%rip),%xmm4\nmov    $0x1,%esi\nmovdqa 0x34a9(%rip),%xmm1\nmovdqa 0x34b1(%rip),%xmm0\nmovaps %xmm3,0xd0(%rsp)\nmovaps %xmm4,0x120(%rsp)\nmovdqa 0x3509(%rip),%xmm4\nmovaps %xmm2,0xe0(%rsp)\nmovaps %xmm4,0x130(%rsp)\nmovdqa 0x3501(%rip),%xmm4\nmovaps %xmm1,0xf0(%rsp)\nmovaps %xmm4,0x140(%rsp)\nmovaps %xmm0,0x100(%rsp)\nmovb   $0x0,0xc(%rsp)\ncall   17b0 <blake2b>\nlea    0x110(%rsp),%rdi\nmov    %rax,%rbp\nmov    %rax,%rsi\ncall   1230 <assert_bytes.constprop.0>\nmov    %rbp,%rdi\ncall   2110 <libmin_free>\nmovdqa 0x343c(%rip),%xmm0\nmovdqa 0x3404(%rip),%xmm3\nlea    0x190(%rsp),%rdx\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmovdqa 0x33f9(%rip),%xmm2\nmovdqa 0x3401(%rip),%xmm1\nmovaps %xmm0,0x180(%rsp)\nlea    0x150(%rsp),%rdi\nmov    $0x40,%esi\nmovaps %xmm0,0x1c0(%rsp)\nmovdqa 0x347c(%rip),%xmm0\nmovaps %xmm3,0x150(%rsp)\nmovaps %xmm0,0x1d0(%rsp)\nmovdqa 0x3474(%rip),%xmm0\nmovaps %xmm2,0x160(%rsp)\nmovaps %xmm0,0x1e0(%rsp)\nmovdqa 0x346c(%rip),%xmm0\nmovaps %xmm1,0x170(%rsp)\nmovaps %xmm0,0x1f0(%rsp)\nmovdqa 0x3464(%rip),%xmm0\nmovaps %xmm3,0x190(%rsp)\nmovaps %xmm2,0x1a0(%rsp)\nmovaps %xmm1,0x1b0(%rsp)\nmovaps %xmm0,0x200(%rsp)\ncall   17b0 <blake2b>\nlea    0x1d0(%rsp),%rdi\nmov    %rax,%rbp\nmov    %rax,%rsi\ncall   1230 <assert_bytes.constprop.0>\nmov    %rbp,%rdi\ncall   2110 <libmin_free>\nxor    %eax,%eax\nlea    0x31fb(%rip),%rdi\ncall   43a0 <libmin_printf>\nmov    0x218(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1e56 <test+0x306>\nadd    $0x220,%rsp\npop    %rbp\nret\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "bloom-filter/bloom-filter.c", "function_name": "bad_search", "content": "#include \"libmin.h\"\n#include \"tinybloom.h\"\n\n#define NUM_ITEMS 2048\n#define NUM_BUCKETS NUM_ITEMS * 4\n\nint bad_search(const unsigned int* array, unsigned int target, size_t size)\n{\n\tint i;\n\tfor(i = 0; i < size; i++)\n\t\tif(array[i] == target) return 1;\n\n\treturn 0;\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O3.pseudo", "function_name": "bad_search", "address": "0x1450", "label": "bad_search", "content": "int __fastcall bad_search(const unsigned int *array, unsigned int target, size_t size)\n{\n  __int64 v3; // rax\n\n  if ( !size )\n    return 0;\n  v3 = 0LL;\n  while ( array[v3] != target )\n  {\n    if ( size == ++v3 )\n      return 0;\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int bad_search(const unsigned int *array, unsigned int target,\n               unsigned int size) {\n  long long v3;\n  if (!size) return 0;\n  v3 = 0LL;\n  while (array[v3] != target) {\n    if (size == ++v3) return 0;\n  }\n  return 1;\n}", "binary": "bloom-filter/bloom-filter.host.O3", "assembly": "<bad_search>:\nendbr64\ntest   %rdx,%rdx\nje     1478 <bad_search+0x28>\nxor    %eax,%eax\njmp    1469 <bad_search+0x19>\nnopl   (%rax)\nadd    $0x1,%rax\ncmp    %rax,%rdx\nje     1478 <bad_search+0x28>\ncmp    %esi,(%rdi,%rax,4)\njne    1460 <bad_search+0x10>\nmov    $0x1,%eax\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "bloom-filter/tinybloom.c", "function_name": "bfilter_add", "content": "void bfilter_add(const bloom_filter* bFilter, const unsigned* input)\n{\n\tSETBIT(bFilter->filter, *input % bFilter->num_buckets);\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O3.pseudo", "function_name": "bfilter_add", "address": "0x1510", "label": "bfilter_add", "content": "void __fastcall bfilter_add(const bloom_filter *bFilter, const unsigned int *input)\n{\n  bFilter->filter[(*input % bFilter->num_buckets) >> 5] |= 1 << (*input % bFilter->num_buckets);\n}\n"}, "pseudo_normalize": "", "binary": "bloom-filter/bloom-filter.host.O3", "assembly": "<bfilter_add>:\nendbr64\nmov    (%rsi),%eax\nxor    %edx,%edx\nmov    $0x1,%esi\ndivl   0x10(%rdi)\nmov    0x8(%rdi),%rdi\nmov    %edx,%eax\nmov    %edx,%ecx\nshr    $0x5,%eax\nshl    %cl,%esi\nor     %esi,(%rdi,%rax,4)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "bloom-filter/tinybloom.c", "function_name": "bfilter_check", "content": "int bfilter_check(const bloom_filter* bFilter, const unsigned* input)\n{\n\treturn GETBIT(bFilter->filter, *input % bFilter->num_buckets);\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O3.pseudo", "function_name": "bfilter_check", "address": "0x1540", "label": "bfilter_check", "content": "int __fastcall bfilter_check(const bloom_filter *bFilter, const unsigned int *input)\n{\n  return (bFilter->filter[(*input % bFilter->num_buckets) >> 5] & (1 << (*input % bFilter->num_buckets))) != 0;\n}\n"}, "pseudo_normalize": "", "binary": "bloom-filter/bloom-filter.host.O3", "assembly": "<bfilter_check>:\nendbr64\nmov    (%rsi),%eax\nxor    %edx,%edx\ndivl   0x10(%rdi)\nmov    0x8(%rdi),%rdi\nmov    $0x1,%eax\nmov    %edx,%esi\nmov    %edx,%ecx\nshr    $0x5,%esi\nshl    %cl,%eax\nand    (%rdi,%rsi,4),%eax\nsetne  %al\nmovzbl %al,%eax\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "bloom-filter/tinybloom.c", "function_name": "bfilter_intersect", "content": "int bfilter_intersect(bloom_filter* a, bloom_filter* b)\n{\n\tif(a->filter_size != b->filter_size) return 1;\n\n\tint i;\n\tfor(i = 0; i < a->filter_size; i++)\n\t\ta->filter[i] |= b->filter[i];\n\n\treturn 0;\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O3.pseudo", "function_name": "bfilter_intersect", "address": "0x1570", "label": "bfilter_intersect", "content": "int __fastcall bfilter_intersect(bloom_filter *a, bloom_filter *b)\n{\n  size_t filter_size; // rcx\n  int result; // eax\n  unsigned int *filter; // rdx\n  unsigned int *v5; // rsi\n  __int64 v6; // rax\n  unsigned __int64 v7; // rax\n  __int64 v8; // rcx\n  unsigned __int64 v9; // rax\n\n  filter_size = a->filter_size;\n  result = 1;\n  if ( a->filter_size == b->filter_size )\n  {\n    if ( filter_size )\n    {\n      filter = a->filter;\n      v5 = b->filter;\n      if ( (unsigned __int64)((char *)filter - (char *)(v5 + 1)) <= 8 || filter_size == 1 )\n      {\n        v8 = 4 * filter_size;\n        v9 = 0LL;\n        do\n        {\n          filter[v9 / 4] |= v5[v9 / 4];\n          v9 += 4LL;\n        }\n        while ( v9 != v8 );\n        return 0;\n      }\n      if ( filter_size - 1 <= 2 )\n      {\n        v7 = 0LL;\n      }\n      else\n      {\n        v6 = 0LL;\n        do\n        {\n          *(__m128i *)&filter[v6] = _mm_or_si128(\n                                      _mm_loadu_si128((const __m128i *)&filter[v6]),\n                                      _mm_loadu_si128((const __m128i *)&v5[v6]));\n          v6 += 4LL;\n        }\n        while ( 4 * (filter_size >> 2) != v6 );\n        v7 = filter_size & 0xFFFFFFFFFFFFFFFCLL;\n        if ( (filter_size & 3) == 0 )\n          return 0;\n        filter_size -= v7;\n        if ( filter_size == 1 )\n          goto LABEL_11;\n      }\n      *(_QWORD *)&filter[v7] = _mm_or_si128(\n                                 _mm_loadl_epi64((const __m128i *)&v5[v7]),\n                                 _mm_loadl_epi64((const __m128i *)&filter[v7])).m128i_u64[0];\n      v7 += filter_size & 0xFFFFFFFFFFFFFFFELL;\n      if ( filter_size != (filter_size & 0xFFFFFFFFFFFFFFFELL) )\nLABEL_11:\n        filter[v7] |= v5[v7];\n    }\n    return 0;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int bfilter_intersect(bloom_filter *a, bloom_filter *b) {\n  unsigned int filter_size;\n  int result;\n  unsigned int *filter;\n  unsigned int *v5;\n  long long v6;\n  unsigned long long v7;\n  long long v8;\n  unsigned long long v9;\n  filter_size = a->filter_size;\n  result = 1;\n  if (a->filter_size == b->filter_size) {\n    if (filter_size) {\n      filter = a->filter;\n      v5 = b->filter;\n      if ((unsigned long long)((char *)filter - (char *)(v5 + 1)) <= 8 ||\n          filter_size == 1) {\n        v8 = 4 * filter_size;\n        v9 = 0LL;\n        do {\n          filter[v9 / 4] |= v5[v9 / 4];\n          v9 += 4LL;\n        } while (v9 != v8);\n        return 0;\n      }\n      if (filter_size - 1 <= 2) {\n        v7 = 0LL;\n      } else {\n        v6 = 0LL;\n        do {\n          *(__m128i *)&filter[v6] =\n              _mm_or_si128(_mm_loadu_si128((const __m128i *)&filter[v6]),\n                           _mm_loadu_si128((const __m128i *)&v5[v6]));\n          v6 += 4LL;\n        } while (4 * (filter_size >> 2) != v6);\n        v7 = filter_size & 18446744073709551612LL;\n        if ((filter_size & 3) == 0) return 0;\n        filter_size -= v7;\n        if (filter_size == 1) goto LABEL_11;\n      }\n      *(uint64_t *)&filter[v7] =\n          _mm_or_si128(_mm_loadl_epi64((const __m128i *)&v5[v7]),\n                       _mm_loadl_epi64((const __m128i *)&filter[v7]))\n              .m128i_u64[0];\n      v7 += filter_size & 18446744073709551614LL;\n      if (filter_size != (filter_size & 18446744073709551614LL))\n      LABEL_11:\n        filter[v7] |= v5[v7];\n    }\n    return 0;\n  }\n  return result;\n}", "binary": "bloom-filter/bloom-filter.host.O3", "assembly": "<bfilter_intersect>:\nendbr64\nmov    (%rdi),%rcx\nmov    $0x1,%eax\ncmp    (%rsi),%rcx\njne    1630 <bfilter_intersect+0xc0>\ntest   %rcx,%rcx\nje     162a <bfilter_intersect+0xba>\nmov    0x8(%rdi),%rdx\nmov    0x8(%rsi),%rsi\nmov    %rdx,%rax\nlea    0x4(%rsi),%rdi\nsub    %rdi,%rax\ncmp    $0x8,%rax\njbe    1638 <bfilter_intersect+0xc8>\ncmp    $0x1,%rcx\nje     1638 <bfilter_intersect+0xc8>\nlea    -0x1(%rcx),%rax\ncmp    $0x2,%rax\njbe    1651 <bfilter_intersect+0xe1>\nmov    %rcx,%rdi\nxor    %eax,%eax\nshr    $0x2,%rdi\nshl    $0x4,%rdi\nnop\nmovdqu (%rdx,%rax,1),%xmm0\nmovdqu (%rsi,%rax,1),%xmm2\npor    %xmm2,%xmm0\nmovups %xmm0,(%rdx,%rax,1)\nadd    $0x10,%rax\ncmp    %rax,%rdi\njne    15d0 <bfilter_intersect+0x60>\nmov    %rcx,%rax\nand    $0xfffffffffffffffc,%rax\ntest   $0x3,%cl\nje     162a <bfilter_intersect+0xba>\nsub    %rax,%rcx\ncmp    $0x1,%rcx\nje     1624 <bfilter_intersect+0xb4>\nlea    (%rdx,%rax,4),%rdi\nmovq   (%rsi,%rax,4),%xmm0\nmovq   (%rdi),%xmm1\npor    %xmm1,%xmm0\nmovq   %xmm0,(%rdi)\nmov    %rcx,%rdi\nand    $0xfffffffffffffffe,%rdi\nadd    %rdi,%rax\ncmp    %rdi,%rcx\nje     162a <bfilter_intersect+0xba>\nmov    (%rsi,%rax,4),%ecx\nor     %ecx,(%rdx,%rax,4)\nxor    %eax,%eax\nret\nnopl   (%rax)\nret\nnopl   0x0(%rax)\nshl    $0x2,%rcx\nxor    %eax,%eax\nxchg   %ax,%ax\nmov    (%rsi,%rax,1),%edi\nor     %edi,(%rdx,%rax,1)\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    1640 <bfilter_intersect+0xd0>\njmp    162a <bfilter_intersect+0xba>\nxor    %eax,%eax\njmp    1600 <bfilter_intersect+0x90>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "bloom-filter/tinybloom.c", "function_name": "destroy_bfilter", "content": "void destroy_bfilter(bloom_filter* bFilter)\n{\n\tif(bFilter->filter) libmin_free(bFilter->filter);\n\tif(bFilter) libmin_free(bFilter);\n\n\tbFilter->filter = NULL;\n\tbFilter = NULL;\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O3.pseudo", "function_name": "destroy_bfilter", "address": "0x14e0", "label": "destroy_bfilter", "content": "void __fastcall destroy_bfilter(bloom_filter *bFilter)\n{\n  unsigned int *filter; // rdi\n\n  filter = bFilter->filter;\n  if ( filter )\n    libmin_free(filter);\n  libmin_free(bFilter);\n  bFilter->filter = 0LL;\n}\n"}, "pseudo_normalize": "void destroy_bfilter(bloom_filter *bFilter) {\n  unsigned int *filter;\n  filter = bFilter->filter;\n  if (filter) libmin_free(filter);\n  libmin_free(bFilter);\n  bFilter->filter = 0LL;\n}", "binary": "bloom-filter/bloom-filter.host.O3", "assembly": "<destroy_bfilter>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\nmov    0x8(%rdi),%rdi\ntest   %rdi,%rdi\nje     14f6 <destroy_bfilter+0x16>\ncall   18f0 <libmin_free>\nmov    %rbx,%rdi\ncall   18f0 <libmin_free>\nmovq   $0x0,0x8(%rbx)\npop    %rbx\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "bloom-filter/bloom-filter.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tunsigned false_positives = 0, true_positives = 0;\n\tunsigned false_negatives = 0, true_negatives = 0;\n\n\tunsigned* filter_contents = libmin_malloc(sizeof(unsigned) * NUM_ITEMS);\n\tunsigned* test_array = libmin_malloc(sizeof(unsigned) * NUM_ITEMS);\n\n\t// Create a bloom filter with (2 << 13) buckets\n\tbloom_filter* bFilter = create_bfilter(NUM_BUCKETS);\n\n\tlibmin_printf(\"Using %lu kilobytes for filter.\\n\\n\", (bFilter->filter_size * sizeof(unsigned)) / 1024);\n\n\tlibmin_srand(42);\n\n\tint i;\n\tfor(i = 0; i < NUM_ITEMS; i++)\n\t{\n\t\tfilter_contents[i] = libmin_rand();\n\t\tbfilter_add(bFilter, &filter_contents[i]);\n\n\t\t// Fill our test array with a 50/50 mix of numbers that have been entered into the filter, and random numbers\n\t\tif(libmin_rand() & 1)\n\t\t\ttest_array[i] = filter_contents[i];\n\t\telse\n\t\t\ttest_array[i] = libmin_rand();\n\t}\n\n\tfor(i = 0; i < NUM_ITEMS; i++)\n\t{\n\t\tint filter_present = 0;\n\t\tint array_present = 0;\n\n\t\tfilter_present = bfilter_check(bFilter, &test_array[i]);\n\n\t\tarray_present = bad_search(filter_contents, test_array[i], NUM_ITEMS);\n\n\t\tif(array_present && filter_present) \t   true_positives++;\n\t\telse if(!array_present && !filter_present) true_negatives++;\n\t\telse if(!array_present && filter_present)  false_positives++;\n\t\telse if(array_present && !filter_present)  false_negatives++;\n\t}\n\n\tlibmin_printf(\"True positives: %i\\n\"\n\t\t\"True negatives: %i\\n\"\n\t\t\"False positives: %i\\n\"\n\t\t\"False negatives: %i\\n\",\n\t\ttrue_positives, true_negatives, false_positives, false_negatives);\n\n\tfloat success_rate = ((100.0f / NUM_ITEMS) * (true_positives + true_negatives));\n\tlibmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_rate);\n\n\tif(success_rate < 80.0f) libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n\n\tif(false_negatives) libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n\telse libmin_printf(\"Test PASSED.\\n\");\n\n\tlibmin_free(test_array);\n\tlibmin_free(filter_contents);\n\tdestroy_bfilter(bFilter);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int *v3; // r12\n  unsigned int *v4; // r14\n  unsigned int *v5; // rbx\n  unsigned int *v6; // r13\n  const unsigned int *v7; // r15\n  bloom_filter *bfilter; // rbp\n  unsigned int v9; // eax\n  int v10; // ebx\n  int v11; // eax\n  unsigned int *v12; // rdx\n  int success_rate; // [rsp+Ch] [rbp-4Ch]\n  float success_ratea; // [rsp+Ch] [rbp-4Ch]\n  unsigned int true_negatives; // [rsp+10h] [rbp-48h]\n  unsigned int false_negatives; // [rsp+14h] [rbp-44h]\n  unsigned int *test_array; // [rsp+18h] [rbp-40h]\n\n  v3 = (unsigned int *)libmin_malloc(0x2000uLL);\n  v4 = v3 + 2048;\n  v5 = v3;\n  v6 = (unsigned int *)libmin_malloc(0x2000uLL);\n  test_array = v6;\n  v7 = v6;\n  bfilter = create_bfilter(0x2000uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\", (4 * bfilter->filter_size) >> 10);\n  libmin_srand(0x2Au);\n  while ( 1 )\n  {\n    *v5 = libmin_rand();\n    bfilter_add(bfilter, v5);\n    if ( (libmin_rand() & 1) != 0 )\n    {\n      v9 = *v5++;\n      *v6++ = v9;\n      if ( v4 == v5 )\n        goto LABEL_4;\n    }\n    else\n    {\n      ++v5;\n      *v6++ = libmin_rand();\n      if ( v5 == v4 )\n      {\nLABEL_4:\n        true_negatives = 0;\n        v10 = 0;\n        false_negatives = 0;\n        success_rate = 0;\n        while ( 1 )\n        {\n          v11 = bfilter_check(bfilter, v7);\n          v12 = v3;\n          while ( *v7 != *v12 )\n          {\n            if ( ++v12 == v4 )\n            {\n              if ( v11 )\n                ++success_rate;\n              else\n                ++true_negatives;\n              goto LABEL_10;\n            }\n          }\n          if ( v11 )\n            ++v10;\n          else\n            ++false_negatives;\nLABEL_10:\n          if ( ++v7 == test_array + 2048 )\n          {\n            libmin_printf(\n              \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse negatives: %i\\n\",\n              v10,\n              true_negatives,\n              success_rate,\n              false_negatives);\n            success_ratea = (float)(int)(v10 + true_negatives) * 0.048828125;\n            libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_ratea);\n            if ( success_ratea < 80.0 )\n              libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n            if ( false_negatives )\n              libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n            else\n              libmin_printf(\"Test PASSED.\\n\");\n            libmin_free(test_array);\n            libmin_free(v3);\n            destroy_bfilter(bfilter);\n            libmin_success();\n          }\n        }\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int *v3;\n  unsigned int *v4;\n  unsigned int *v5;\n  unsigned int *v6;\n  const unsigned int *v7;\n  bloom_filter *bfilter;\n  unsigned int v9;\n  int v10;\n  int v11;\n  unsigned int *v12;\n  int success_rate;\n  float success_ratea;\n  unsigned int true_negatives;\n  unsigned int false_negatives;\n  unsigned int *test_array;\n  v3 = (unsigned int *)libmin_malloc(8192uLL);\n  v4 = v3 + 2048;\n  v5 = v3;\n  v6 = (unsigned int *)libmin_malloc(8192uLL);\n  test_array = v6;\n  v7 = v6;\n  bfilter = create_bfilter(8192uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\",\n                (4 * bfilter->filter_size) >> 10);\n  libmin_srand(42u);\n  while (1) {\n    *v5 = libmin_rand();\n    bfilter_add(bfilter, v5);\n    if ((libmin_rand() & 1) != 0) {\n      v9 = *v5++;\n      *v6++ = v9;\n      if (v4 == v5) goto LABEL_4;\n    } else {\n      ++v5;\n      *v6++ = libmin_rand();\n      if (v5 == v4) {\n      LABEL_4:\n        true_negatives = 0;\n        v10 = 0;\n        false_negatives = 0;\n        success_rate = 0;\n        while (1) {\n          v11 = bfilter_check(bfilter, v7);\n          v12 = v3;\n          while (*v7 != *v12) {\n            if (++v12 == v4) {\n              if (v11)\n                ++success_rate;\n              else\n                ++true_negatives;\n              goto LABEL_10;\n            }\n          }\n          if (v11)\n            ++v10;\n          else\n            ++false_negatives;\n        LABEL_10:\n          if (++v7 == test_array + 2048) {\n            libmin_printf(\n                \"True positives: %i\\nTrue negatives: %i\\nFalse positives: \"\n                \"%i\\nFalse negatives: %i\\n\",\n                v10, true_negatives, success_rate, false_negatives);\n            success_ratea = (float)(int)(v10 + true_negatives) * 0.048828125;\n            libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_ratea);\n            if (success_ratea < 80.0)\n              libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n            if (false_negatives)\n              libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n            else\n              libmin_printf(\"Test PASSED.\\n\");\n            libmin_free(test_array);\n            libmin_free(v3);\n            destroy_bfilter(bfilter);\n            libmin_success();\n          }\n        }\n      }\n    }\n  }\n}", "binary": "bloom-filter/bloom-filter.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x2000,%edi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\ncall   1840 <libmin_malloc>\nmov    $0x2000,%edi\nmov    %rax,%r12\ncall   1840 <libmin_malloc>\nmov    $0x2000,%edi\nlea    0x2000(%r12),%r14\nmov    %r12,%rbx\nmov    %rax,%r13\nmov    %rax,0x18(%rsp)\ncall   1480 <create_bfilter>\nlea    0x3e9b(%rip),%rdi\nmov    %r13,%r15\nmov    %rax,%rbp\nmov    (%rax),%rax\nlea    0x0(,%rax,4),%rsi\nxor    %eax,%eax\nshr    $0xa,%rsi\ncall   3b80 <libmin_printf>\nmov    $0x2a,%edi\ncall   3d90 <libmin_srand>\nnopl   0x0(%rax,%rax,1)\ncall   3df0 <libmin_rand>\nmov    %rbx,%rsi\nmov    %rbp,%rdi\nmov    %eax,(%rbx)\ncall   1510 <bfilter_add>\ncall   3df0 <libmin_rand>\ntest   $0x1,%al\nje     1300 <main+0x1e0>\nmov    (%rbx),%eax\nadd    $0x4,%rbx\nadd    $0x4,%r13\nmov    %eax,-0x4(%r13)\ncmp    %rbx,%r14\njne    1198 <main+0x78>\nmov    0x18(%rsp),%rax\nmovl   $0x0,0x10(%rsp)\nxor    %ebx,%ebx\nmovl   $0x0,0x14(%rsp)\nmovl   $0x0,0xc(%rsp)\nlea    0x2000(%rax),%r13\nmov    %r15,%rsi\nmov    %rbp,%rdi\ncall   1540 <bfilter_check>\nmov    (%r15),%ecx\nmov    %r12,%rdx\njmp    1215 <main+0xf5>\nnopl   0x0(%rax,%rax,1)\nadd    $0x4,%rdx\ncmp    %r14,%rdx\nje     12f0 <main+0x1d0>\ncmp    (%rdx),%ecx\njne    1208 <main+0xe8>\ntest   %eax,%eax\nje     132a <main+0x20a>\nadd    $0x1,%ebx\nadd    $0x4,%r15\ncmp    %r13,%r15\njne    11f0 <main+0xd0>\nmov    0x10(%rsp),%r15d\nmov    0x14(%rsp),%r8d\nmov    %ebx,%esi\nxor    %eax,%eax\nmov    0xc(%rsp),%ecx\nlea    0x3dea(%rip),%rdi\nmov    %r15d,%edx\ncall   3b80 <libmin_printf>\nmov    %r15d,%eax\npxor   %xmm1,%xmm1\npxor   %xmm0,%xmm0\nadd    %ebx,%eax\nlea    0x3e46(%rip),%rdi\nmov    %eax,%eax\ncvtsi2ss %rax,%xmm1\nmulss  0x3e77(%rip),%xmm1\nmov    $0x1,%eax\ncvtss2sd %xmm1,%xmm0\nmovss  %xmm1,0xc(%rsp)\ncall   3b80 <libmin_printf>\nmovss  0x3e5f(%rip),%xmm0\nmovss  0xc(%rsp),%xmm1\ncomiss %xmm1,%xmm0\nja     1347 <main+0x227>\nmov    0x14(%rsp),%eax\ntest   %eax,%eax\nje     1334 <main+0x214>\nlea    0x3e11(%rip),%rdi\nxor    %eax,%eax\ncall   3b80 <libmin_printf>\nmov    0x18(%rsp),%rdi\ncall   18f0 <libmin_free>\nmov    %r12,%rdi\ncall   18f0 <libmin_free>\nmov    %rbp,%rdi\ncall   14e0 <destroy_bfilter>\ncall   3fe0 <libmin_success>\nadd    $0x28,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\ntest   %eax,%eax\njne    1320 <main+0x200>\naddl   $0x1,0x10(%rsp)\njmp    1224 <main+0x104>\nxchg   %ax,%ax\ncall   3df0 <libmin_rand>\nadd    $0x4,%rbx\nadd    $0x4,%r13\nmov    %eax,-0x4(%r13)\ncmp    %r14,%rbx\njne    1198 <main+0x78>\njmp    11ca <main+0xaa>\nnop\naddl   $0x1,0xc(%rsp)\njmp    1224 <main+0x104>\naddl   $0x1,0x14(%rsp)\njmp    1224 <main+0x104>\nlea    0x3d9e(%rip),%rdi\nxor    %eax,%eax\ncall   3b80 <libmin_printf>\njmp    12b6 <main+0x196>\nlea    0x3d32(%rip),%rdi\nxor    %eax,%eax\ncall   3b80 <libmin_printf>\njmp    129c <main+0x17c>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "boyer-moore-search/boyer-moore-search.c", "function_name": "badCharHeuristic", "content": "#define NO_OF_CHARS 256\n\n// The preprocessing function for Boyer Moore's\n// bad character heuristic\nvoid badCharHeuristic(char *str, int size, int badchar[NO_OF_CHARS])\n{\n\t// Initialize all occurrences as -1\n\tfor(int i = 0; i < NO_OF_CHARS; i++)\n  {\n\t\tbadchar[i] = -1;\n  }\n\n\t// Fill the actual value of last occurrence of a character\n\tfor(int i = 0; i < size; i++)\n  {\n\t\tbadchar[(int)str[i]] = i;\n  }\n}\n"}, "pseudo": {"path": "boyer-moore-search/boyer-moore-search.host.O3.pseudo", "function_name": "badCharHeuristic", "address": "0x15d0", "label": "badCharHeuristic", "content": "void __fastcall badCharHeuristic(char *str, int size, int *badchar)\n{\n  __int64 i; // rax\n\n  *(_QWORD *)badchar = -1LL;\n  *((_QWORD *)badchar + 127) = -1LL;\n  memset(\n    (void *)((unsigned __int64)(badchar + 2) & 0xFFFFFFFFFFFFFFF8LL),\n    0xFFu,\n    8LL * (((unsigned int)badchar - (((_DWORD)badchar + 8) & 0xFFFFFFF8) + 1024) >> 3));\n  if ( size > 0 )\n  {\n    for ( i = 0LL; i != size; ++i )\n      badchar[str[i]] = i;\n  }\n}\n"}, "pseudo_normalize": "void badCharHeuristic(char *str, int size, int *badchar) {\n  long long i;\n  *(uint64_t *)badchar = -1LL;\n  *((uint64_t *)badchar + 127) = -1LL;\n  memset((void *)((unsigned long long)(badchar + 2) & 18446744073709551608LL),\n         255u,\n         8LL * (((unsigned int)badchar -\n                 (((uint32_t)badchar + 8) & 4294967288) + 1024) >>\n                3));\n  if (size > 0) {\n    for (i = 0LL; i != size; ++i) badchar[str[i]] = i;\n  }\n}", "binary": "boyer-moore-search/boyer-moore-search.host.O3", "assembly": "<badCharHeuristic>:\nendbr64\nmov    %rdi,%r8\nlea    0x8(%rdx),%rdi\nmov    %rdx,%rcx\nmov    $0xffffffffffffffff,%rax\nand    $0xfffffffffffffff8,%rdi\nmovq   $0xffffffffffffffff,(%rdx)\nmovq   $0xffffffffffffffff,0x3f8(%rdx)\nsub    %rdi,%rcx\nadd    $0x400,%ecx\nshr    $0x3,%ecx\nrep stos %rax,%es:(%rdi)\ntest   %esi,%esi\njle    1629 <badCharHeuristic+0x59>\nmovslq %esi,%rsi\nxor    %eax,%eax\nnopl   0x0(%rax,%rax,1)\nmovsbq (%r8,%rax,1),%rcx\nmov    %eax,(%rdx,%rcx,4)\nadd    $0x1,%rax\ncmp    %rax,%rsi\njne    1618 <badCharHeuristic+0x48>\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "boyer-moore-search/boyer-moore-search.c", "function_name": "main", "content": "int\nmain(void) \n{ \n  int n = libmin_strlen(inp_txt); // String lengths are public\n  int m = libmin_strlen(inp_pat); // String lengths are public\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  \n  char txt[n];\n  for (int k=0; k < n; k++)\n    txt[k] = inp_txt[k];\n\n  char pat[m];\n  for (int k=0; k < m; k++)\n    pat[k] = inp_pat[k];\n\n  // Return vector\n  int ret[n];\n  for(int i=0; i<n; i++) ret[i] = FALSE; \n\t\n\n  // Run search\n  search(txt, n, pat, m, ret);\n\n  // print results\n  for(int i=0; i<n; i++)\n  {\n    if(ret[i]) \n    { \n      libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "boyer-moore-search/boyer-moore-search.host.O3.pseudo", "function_name": "main", "address": "0x1140", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char *v3; // rax\n  int v4; // r13d\n  int v5; // r14d\n  int v6; // ecx\n  __int64 v7; // rbx\n  __int64 v8; // rdx\n  int *v9; // rsi\n  __int16 v10; // dx\n  signed __int64 v11; // rdx\n  void *v12; // rsp\n  unsigned int v13; // ecx\n  __int64 v14; // rdx\n  unsigned __int64 v15; // rax\n  __int16 v16; // dx\n  signed __int64 v17; // rdx\n  void *v18; // rsp\n  char *v19; // r9\n  __int64 v20; // rdx\n  unsigned __int64 v21; // rax\n  __int16 v22; // dx\n  __int64 v23; // rdx\n  unsigned __int64 v24; // rax\n  __int16 v25; // dx\n  signed __int64 v26; // rdx\n  void *v27; // rsp\n  char *v28; // r9\n  __int64 v29; // rdx\n  unsigned __int64 v30; // rax\n  __int16 v31; // dx\n  signed __int64 v32; // rdx\n  void *v33; // rsp\n  __int64 v34; // r12\n  __int64 v35; // rbx\n  __int64 v36; // rax\n  signed __int64 v37; // rdx\n  void *v38; // rsp\n  __int64 v39; // rax\n  unsigned __int64 v40; // rdx\n  __int16 v41; // ax\n  signed __int64 v42; // rax\n  void *v43; // rsp\n  __int64 v44; // rax\n  unsigned __int64 v45; // rdx\n  __int16 v46; // ax\n  signed __int64 v47; // rax\n  void *v48; // rsp\n  int v50[1022]; // [rsp+8h] [rbp-1060h] BYREF\n  _BYTE v51[12]; // [rsp+1008h] [rbp-60h] BYREF\n  unsigned int v52; // [rsp+1014h] [rbp-54h]\n  char *txt; // [rsp+1018h] [rbp-50h]\n  char *n; // [rsp+1020h] [rbp-48h]\n  unsigned __int64 v55; // [rsp+1030h] [rbp-38h]\n\n  v55 = __readfsqword(0x28u);\n  v3 = (char *)libmin_strlen(inp_txt);\n  v4 = (int)v3;\n  n = v3;\n  v5 = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", v4, v5);\n  v6 = (int)n;\n  v7 = (int)n;\n  v8 = (int)n + 15LL;\n  v9 = (int *)&v51[-(v8 & 0xFFFFFFFFFFFFF000LL)];\n  v10 = v8 & 0xFFF0;\n  if ( v51 != (_BYTE *)v9 )\n  {\n    while ( v50 != v9 )\n      ;\n  }\n  v11 = v10 & 0xFFF;\n  v12 = alloca(v11);\n  if ( v11 )\n    *(_QWORD *)((char *)&v50[-2] + v11) = *(_QWORD *)((char *)&v50[-2] + v11);\n  txt = (char *)v50;\n  if ( v6 > 0 )\n  {\n    LODWORD(n) = v6 - 1;\n    memcpy(v50, inp_txt, (unsigned int)(v6 - 1) + 1LL);\n    v13 = (unsigned int)n;\n    v14 = v5 + 15LL;\n    v15 = v14 & 0xFFFFFFFFFFFFF000LL;\n    v16 = v14 & 0xFFF0;\n    while ( v50 != (int *)((char *)v50 - v15) )\n      ;\n    v17 = v16 & 0xFFF;\n    v18 = alloca(v17);\n    if ( v17 )\n      *(_QWORD *)((char *)&v50[-2] + v17) = *(_QWORD *)((char *)&v50[-2] + v17);\n    v19 = (char *)v50;\n    if ( v5 > 0 )\n    {\n      v52 = v13;\n      n = (char *)v50;\n      memcpy(v50, inp_pat, (unsigned int)(v5 - 1) + 1LL);\n      v13 = v52;\n      v19 = n;\n      v44 = 4 * v7 + 15;\n      v45 = v44 & 0xFFFFFFFFFFFFF000LL;\n      v46 = v44 & 0xFFF0;\n      while ( v50 != (int *)((char *)v50 - v45) )\n        ;\n      v47 = v46 & 0xFFF;\n      v48 = alloca(v47);\n      if ( v47 )\n        *(_QWORD *)((char *)&v50[-2] + v47) = *(_QWORD *)((char *)&v50[-2] + v47);\n    }\n    else\n    {\n      v20 = 4 * v7 + 15;\n      v21 = v20 & 0xFFFFFFFFFFFFF000LL;\n      v22 = v20 & 0xFFF0;\n      while ( v50 != (int *)((char *)v50 - v21) )\n        ;\n      v32 = v22 & 0xFFF;\n      v33 = alloca(v32);\n      if ( v32 )\n        *(_QWORD *)((char *)&v50[-2] + v32) = *(_QWORD *)((char *)&v50[-2] + v32);\n    }\n    v34 = v13;\n    n = v19;\n    v35 = 0LL;\n    memset(v50, 0, 4LL * v13 + 4);\n    search(txt, v4, n, v5, v50);\n    while ( 1 )\n    {\n      if ( v50[v35] )\n      {\n        libmin_printf(\"pattern occurs at shift = %d\\n\", v35);\n        v36 = v35 + 1;\n        if ( v34 == v35 )\n          goto LABEL_29;\n      }\n      else\n      {\n        v36 = v35 + 1;\n        if ( v34 == v35 )\n          goto LABEL_29;\n      }\n      v35 = v36;\n    }\n  }\n  v23 = v5 + 15LL;\n  v24 = v23 & 0xFFFFFFFFFFFFF000LL;\n  v25 = v23 & 0xFFF0;\n  while ( v50 != (int *)((char *)v50 - v24) )\n    ;\n  v26 = v25 & 0xFFF;\n  v27 = alloca(v26);\n  if ( v26 )\n    *(_QWORD *)((char *)&v50[-2] + v26) = *(_QWORD *)((char *)&v50[-2] + v26);\n  v28 = (char *)v50;\n  if ( v5 <= 0 )\n  {\n    v39 = 4 * v7 + 15;\n    v40 = v39 & 0xFFFFFFFFFFFFF000LL;\n    v41 = v39 & 0xFFF0;\n    while ( v50 != (int *)((char *)v50 - v40) )\n      ;\n    v42 = v41 & 0xFFF;\n    v43 = alloca(v42);\n    if ( v42 )\n      *(_QWORD *)((char *)&v50[-2] + v42) = *(_QWORD *)((char *)&v50[-2] + v42);\n  }\n  else\n  {\n    n = (char *)v50;\n    memcpy(v50, inp_pat, (unsigned int)(v5 - 1) + 1LL);\n    v28 = n;\n    v29 = 4 * v7 + 15;\n    v30 = v29 & 0xFFFFFFFFFFFFF000LL;\n    v31 = v29 & 0xFFF0;\n    while ( v50 != (int *)((char *)v50 - v30) )\n      ;\n    v37 = v31 & 0xFFF;\n    v38 = alloca(v37);\n    if ( v37 )\n      *(_QWORD *)((char *)&v50[-2] + v37) = *(_QWORD *)((char *)&v50[-2] + v37);\n  }\n  search(txt, v4, v28, v5, v50);\nLABEL_29:\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  char *v3;\n  int v4;\n  int v5;\n  int v6;\n  long long v7;\n  long long v8;\n  int *v9;\n  short v10;\n  signed long long v11;\n  void *v12;\n  unsigned int v13;\n  long long v14;\n  unsigned long long v15;\n  short v16;\n  signed long long v17;\n  void *v18;\n  char *v19;\n  long long v20;\n  unsigned long long v21;\n  short v22;\n  long long v23;\n  unsigned long long v24;\n  short v25;\n  signed long long v26;\n  void *v27;\n  char *v28;\n  long long v29;\n  unsigned long long v30;\n  short v31;\n  signed long long v32;\n  void *v33;\n  long long v34;\n  long long v35;\n  long long v36;\n  signed long long v37;\n  void *v38;\n  long long v39;\n  unsigned long long v40;\n  short v41;\n  signed long long v42;\n  void *v43;\n  long long v44;\n  unsigned long long v45;\n  short v46;\n  signed long long v47;\n  void *v48;\n  int v50[1022];\n  uint8_t v51[12];\n  unsigned int v52;\n  char *txt;\n  char *n;\n  unsigned long long v55;\n  v55 = __readfsqword(40u);\n  v3 = (char *)libmin_strlen(inp_txt);\n  v4 = (int)v3;\n  n = v3;\n  v5 = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", v4, v5);\n  v6 = (int)n;\n  v7 = (int)n;\n  v8 = (int)n + 15LL;\n  v9 = (int *)&v51[-(v8 & 18446744073709547520LL)];\n  v10 = v8 & 65520;\n  if (v51 != (uint8_t *)v9) {\n    while (v50 != v9)\n      ;\n  }\n  v11 = v10 & 4095;\n  v12 = alloca(v11);\n  if (v11)\n    *(uint64_t *)((char *)&v50[-2] + v11) =\n        *(uint64_t *)((char *)&v50[-2] + v11);\n  txt = (char *)v50;\n  if (v6 > 0) {\n    LODWORD(n) = v6 - 1;\n    memcpy(v50, inp_txt, (unsigned int)(v6 - 1) + 1LL);\n    v13 = (unsigned int)n;\n    v14 = v5 + 15LL;\n    v15 = v14 & 18446744073709547520LL;\n    v16 = v14 & 65520;\n    while (v50 != (int *)((char *)v50 - v15))\n      ;\n    v17 = v16 & 4095;\n    v18 = alloca(v17);\n    if (v17)\n      *(uint64_t *)((char *)&v50[-2] + v17) =\n          *(uint64_t *)((char *)&v50[-2] + v17);\n    v19 = (char *)v50;\n    if (v5 > 0) {\n      v52 = v13;\n      n = (char *)v50;\n      memcpy(v50, inp_pat, (unsigned int)(v5 - 1) + 1LL);\n      v13 = v52;\n      v19 = n;\n      v44 = 4 * v7 + 15;\n      v45 = v44 & 18446744073709547520LL;\n      v46 = v44 & 65520;\n      while (v50 != (int *)((char *)v50 - v45))\n        ;\n      v47 = v46 & 4095;\n      v48 = alloca(v47);\n      if (v47)\n        *(uint64_t *)((char *)&v50[-2] + v47) =\n            *(uint64_t *)((char *)&v50[-2] + v47);\n    } else {\n      v20 = 4 * v7 + 15;\n      v21 = v20 & 18446744073709547520LL;\n      v22 = v20 & 65520;\n      while (v50 != (int *)((char *)v50 - v21))\n        ;\n      v32 = v22 & 4095;\n      v33 = alloca(v32);\n      if (v32)\n        *(uint64_t *)((char *)&v50[-2] + v32) =\n            *(uint64_t *)((char *)&v50[-2] + v32);\n    }\n    v34 = v13;\n    n = v19;\n    v35 = 0LL;\n    memset(v50, 0, 4LL * v13 + 4);\n    search(txt, v4, n, v5, v50);\n    while (1) {\n      if (v50[v35]) {\n        libmin_printf(\"pattern occurs at shift = %d\\n\", v35);\n        v36 = v35 + 1;\n        if (v34 == v35) goto LABEL_29;\n      } else {\n        v36 = v35 + 1;\n        if (v34 == v35) goto LABEL_29;\n      }\n      v35 = v36;\n    }\n  }\n  v23 = v5 + 15LL;\n  v24 = v23 & 18446744073709547520LL;\n  v25 = v23 & 65520;\n  while (v50 != (int *)((char *)v50 - v24))\n    ;\n  v26 = v25 & 4095;\n  v27 = alloca(v26);\n  if (v26)\n    *(uint64_t *)((char *)&v50[-2] + v26) =\n        *(uint64_t *)((char *)&v50[-2] + v26);\n  v28 = (char *)v50;\n  if (v5 <= 0) {\n    v39 = 4 * v7 + 15;\n    v40 = v39 & 18446744073709547520LL;\n    v41 = v39 & 65520;\n    while (v50 != (int *)((char *)v50 - v40))\n      ;\n    v42 = v41 & 4095;\n    v43 = alloca(v42);\n    if (v42)\n      *(uint64_t *)((char *)&v50[-2] + v42) =\n          *(uint64_t *)((char *)&v50[-2] + v42);\n  } else {\n    n = (char *)v50;\n    memcpy(v50, inp_pat, (unsigned int)(v5 - 1) + 1LL);\n    v28 = n;\n    v29 = 4 * v7 + 15;\n    v30 = v29 & 18446744073709547520LL;\n    v31 = v29 & 65520;\n    while (v50 != (int *)((char *)v50 - v30))\n      ;\n    v37 = v31 & 4095;\n    v38 = alloca(v37);\n    if (v37)\n      *(uint64_t *)((char *)&v50[-2] + v37) =\n          *(uint64_t *)((char *)&v50[-2] + v37);\n  }\n  search(txt, v4, v28, v5, v50);\nLABEL_29:\n  libmin_success();\n}", "binary": "boyer-moore-search/boyer-moore-search.host.O3", "assembly": "<main>:\nendbr64\npush   %rbp\nlea    0x4ed4(%rip),%r9\nmov    %r9,%rdi\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nlea    0x51bf(%rip),%r12\npush   %rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x38(%rbp)\nxor    %eax,%eax\ncall   3a40 <libmin_strlen>\nmov    %r12,%rdi\nmov    %eax,%r13d\nmov    %rax,-0x48(%rbp)\ncall   3a40 <libmin_strlen>\nmov    %r13d,%esi\nlea    0x2e71(%rip),%rdi\nmov    %eax,%edx\nmov    %rax,%r14\nmov    %eax,%r15d\nxor    %eax,%eax\ncall   3830 <libmin_printf>\nmov    -0x48(%rbp),%rcx\nmov    %rsp,%rsi\nlea    0x4e70(%rip),%r9\nmovslq %ecx,%rbx\nlea    0xf(%rbx),%rax\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nsub    %rax,%rsi\nand    $0xfffffffffffffff0,%rdx\ncmp    %rsi,%rsp\nje     11e1 <main+0xa1>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\ncmp    %rsi,%rsp\njne    11cc <main+0x8c>\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\njne    1298 <main+0x158>\nmov    %rsp,-0x50(%rbp)\ntest   %ecx,%ecx\njle    12ab <main+0x16b>\nlea    -0x1(%rcx),%edx\nmov    %r9,%rsi\nmov    %rsp,%rdi\nmov    %edx,-0x48(%rbp)\nadd    $0x1,%rdx\ncall   1110 <memcpy@plt>\nmovslq %r14d,%rax\nmov    %rsp,%rsi\nmov    -0x48(%rbp),%ecx\nadd    $0xf,%rax\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nand    $0xfffffffffffffff0,%rdx\nsub    %rax,%rsi\ncmp    %rsi,%rsp\nje     1248 <main+0x108>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1231 <main+0xf1>\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\njne    12a3 <main+0x163>\nmov    %rsp,%r9\ntest   %r14d,%r14d\njg     1465 <main+0x325>\nlea    0xf(,%rbx,4),%rax\nmov    %rsp,%rsi\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nand    $0xfffffffffffffff0,%rdx\nsub    %rax,%rsi\ncmp    %rsi,%rsp\nje     134d <main+0x20d>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    127d <main+0x13d>\norq    $0x0,-0x8(%rsp,%rdx,1)\njmp    11f3 <main+0xb3>\norq    $0x0,-0x8(%rsp,%rdx,1)\njmp    1256 <main+0x116>\nmovslq %r14d,%rax\nmov    %rsp,%rcx\nadd    $0xf,%rax\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nand    $0xfffffffffffffff0,%rdx\nsub    %rax,%rcx\ncmp    %rcx,%rsp\nje     12dc <main+0x19c>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    12c5 <main+0x185>\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\nje     12f0 <main+0x1b0>\norq    $0x0,-0x8(%rsp,%rdx,1)\nmov    %rsp,%r9\ntest   %r14d,%r14d\njle    141d <main+0x2dd>\nlea    -0x1(%r14),%edx\nmov    %r12,%rsi\nmov    %rsp,%rdi\nmov    %r9,-0x48(%rbp)\nadd    $0x1,%rdx\ncall   1110 <memcpy@plt>\nlea    0xf(,%rbx,4),%rax\nmov    %rsp,%rcx\nmov    -0x48(%rbp),%r9\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nand    $0xfffffffffffffff0,%rdx\nsub    %rax,%rcx\ncmp    %rcx,%rsp\nje     13f2 <main+0x2b2>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1332 <main+0x1f2>\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\nje     1361 <main+0x221>\norq    $0x0,-0x8(%rsp,%rdx,1)\nmov    %ecx,%r12d\nmov    %rsp,%r14\nxor    %esi,%esi\nmov    %r9,-0x48(%rbp)\nlea    0x4(,%r12,4),%rdx\nmov    %r14,%rdi\nxor    %ebx,%ebx\ncall   10e0 <memset@plt>\nmov    -0x48(%rbp),%rdx\nmov    -0x50(%rbp),%rdi\nmov    %r13d,%esi\nmov    %r14,%r8\nmov    %r15d,%ecx\nlea    0x2c7d(%rip),%r13\ncall   1630 <search>\njmp    13ac <main+0x26c>\nxchg   %ax,%ax\nlea    0x1(%rbx),%rax\ncmp    %rbx,%r12\nje     13c9 <main+0x289>\nmov    %rax,%rbx\nmov    (%r14,%rbx,4),%eax\nmov    %ebx,%esi\ntest   %eax,%eax\nje     13a0 <main+0x260>\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   3830 <libmin_printf>\nlea    0x1(%rbx),%rax\ncmp    %rbx,%r12\njne    13a9 <main+0x269>\ncall   3a70 <libmin_success>\nmov    -0x38(%rbp),%rax\nsub    %fs:0x28,%rax\njne    14b9 <main+0x379>\nlea    -0x28(%rbp),%rsp\nxor    %eax,%eax\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\nje     1406 <main+0x2c6>\norq    $0x0,-0x8(%rsp,%rdx,1)\nmov    -0x50(%rbp),%rdi\nmov    %rsp,%r8\nmov    %r15d,%ecx\nmov    %r9,%rdx\nmov    %r13d,%esi\ncall   1630 <search>\njmp    13c9 <main+0x289>\nlea    0xf(,%rbx,4),%rdx\nmov    %rsp,%rcx\nmov    %rdx,%rax\nand    $0xfffffffffffff000,%rdx\nand    $0xfffffffffffffff0,%rax\nsub    %rdx,%rcx\ncmp    %rcx,%rsp\nje     1450 <main+0x310>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1439 <main+0x2f9>\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     1406 <main+0x2c6>\norq    $0x0,-0x8(%rsp,%rax,1)\njmp    1406 <main+0x2c6>\nlea    -0x1(%r14),%edx\nmov    %r12,%rsi\nmov    %rsp,%rdi\nmov    %ecx,-0x54(%rbp)\nadd    $0x1,%rdx\nmov    %r9,-0x48(%rbp)\ncall   1110 <memcpy@plt>\nmov    %rsp,%rsi\nmov    -0x54(%rbp),%ecx\nmov    -0x48(%rbp),%r9\nlea    0xf(,%rbx,4),%rdx\nmov    %rdx,%rax\nand    $0xfffffffffffff000,%rdx\nand    $0xfffffffffffffff0,%rax\nsub    %rdx,%rsi\ncmp    %rsi,%rsp\nje     14be <main+0x37e>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    14a2 <main+0x362>\ncall   10d0 <__stack_chk_fail@plt>\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     1361 <main+0x221>\norq    $0x0,-0x8(%rsp,%rax,1)\njmp    1361 <main+0x221>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "boyer-moore-search/boyer-moore-search.c", "function_name": "search", "content": "/* A pattern searching function that uses Bad\nCharacter Heuristic of Boyer Moore Algorithm */\nvoid search(char *txt, int n, char *pat, int m, int *ret)\n{\n\tint badchar[NO_OF_CHARS];\n\n\t/* Fill the bad character array by calling\n\tthe preprocessing function badCharHeuristic()\n\tfor given pattern */\n\tbadCharHeuristic(pat, m, badchar);\n\n\tint s = 0; // s is shift of the pattern with\n\t\t\t\t     // respect to text\n  \n\tfor(int l=0; l<=(n - m); l++)\n\t{\n    //Early exit if not data-oblivious... \n    if (s > (n-m)) break;\n\n\t\tint idx = m-1;\n\n\t\t/* Keep reducing index idx of pattern while\n\t\tcharacters of pattern and text are\n\t\tmatching at this shift s */\n\t\twhile(idx >= 0 && pat[idx] == txt[s+idx])\n    {\n\t\t\tidx--;\n    }\n\n\t\t/* If the pattern is present at current\n\t\tshift, then index idx will become -1 after\n\t\tthe above loop */\n    int cond = (idx < 0);\n    if(cond)\n    {\n      ret[s] = TRUE; \n\t\t\ts += (s+m < n)? m-badchar[(int)txt[s+m]] : 1;\n    }\n\t\telse \n    {\n      int s_shift = idx - badchar[(int)txt[s+idx]];\n\t\t\ts += 1 > s_shift ? 1 : s_shift;\n    }\n\t}\n}\n"}, "pseudo": {"path": "boyer-moore-search/boyer-moore-search.host.O3.pseudo", "function_name": "search", "address": "0x1630", "label": "search", "content": "void __fastcall search(char *txt, int n, char *pat, int m, int *ret)\n{\n  __int64 i; // rax\n  int v9; // r13d\n  int v10; // r12d\n  int v11; // ebp\n  int v12; // r9d\n  __int64 v13; // r14\n  __int64 v14; // rax\n  __int64 v15; // rdx\n  int v16; // ecx\n  int v17; // eax\n  int v18; // eax\n  int badchar[258]; // [rsp+0h] [rbp-438h] BYREF\n  unsigned __int64 v20; // [rsp+408h] [rbp-30h]\n\n  v20 = __readfsqword(0x28u);\n  memset(badchar, 0xFFu, 0x400uLL);\n  if ( m > 0 )\n  {\n    for ( i = 0LL; i != m; ++i )\n      badchar[pat[i]] = i;\n  }\n  v9 = n - m;\n  if ( n - m >= 0 )\n  {\n    v10 = m - 1;\n    v11 = 0;\n    v12 = 0;\n    do\n    {\n      v13 = v12;\n      if ( v10 < 0 )\n      {\nLABEL_17:\n        ret[v13] = 1;\n        if ( m + v12 < n )\n          v18 = m - badchar[txt[m + v12]];\n        else\n          v18 = 1;\n        v12 += v18;\n      }\n      else\n      {\n        v13 = v12;\n        v14 = v10;\n        while ( 1 )\n        {\n          v15 = txt[v12 + v14];\n          if ( pat[v14] != (_BYTE)v15 )\n            break;\n          if ( (int)--v14 < 0 )\n            goto LABEL_17;\n        }\n        v16 = v14 - badchar[v15];\n        if ( v16 <= 0 )\n          v16 = 1;\n        v12 += v16;\n      }\n      v17 = ++v11;\n      if ( v12 >= v11 )\n        v17 = v12;\n    }\n    while ( v9 >= v17 );\n  }\n}\n"}, "pseudo_normalize": "void search(char *txt, int n, char *pat, int m, int *ret) {\n  long long i;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  long long v13;\n  long long v14;\n  long long v15;\n  int v16;\n  int v17;\n  int v18;\n  int badchar[258];\n  unsigned long long v20;\n  v20 = __readfsqword(40u);\n  memset(badchar, 255u, 1024uLL);\n  if (m > 0) {\n    for (i = 0LL; i != m; ++i) badchar[pat[i]] = i;\n  }\n  v9 = n - m;\n  if (n - m >= 0) {\n    v10 = m - 1;\n    v11 = 0;\n    v12 = 0;\n    do {\n      v13 = v12;\n      if (v10 < 0) {\n      LABEL_17:\n        ret[v13] = 1;\n        if (m + v12 < n)\n          v18 = m - badchar[txt[m + v12]];\n        else\n          v18 = 1;\n        v12 += v18;\n      } else {\n        v13 = v12;\n        v14 = v10;\n        while (1) {\n          v15 = txt[v12 + v14];\n          if (pat[v14] != (uint8_t)v15) break;\n          if ((int)--v14 < 0) goto LABEL_17;\n        }\n        v16 = v14 - badchar[v15];\n        if (v16 <= 0) v16 = 1;\n        v12 += v16;\n      }\n      v17 = ++v11;\n      if (v12 >= v11) v17 = v12;\n    } while (v9 >= v17);\n  }\n}", "binary": "boyer-moore-search/boyer-moore-search.host.O3", "assembly": "<search>:\nendbr64\npush   %r14\nmov    %esi,%r11d\nmov    %rdx,%rsi\nmov    %rdi,%r10\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %ecx,%ebx\nmov    $0x80,%ecx\nsub    $0x410,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x408(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdx\nmov    $0xffffffffffffffff,%rax\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\ntest   %ebx,%ebx\njle    1691 <search+0x61>\nmovslq %ebx,%rcx\nxor    %eax,%eax\nnop\nmovsbq (%rsi,%rax,1),%rdx\nmov    %eax,(%rsp,%rdx,4)\nadd    $0x1,%rax\ncmp    %rax,%rcx\njne    1680 <search+0x50>\nmov    %r11d,%r13d\nsub    %ebx,%r13d\njs     16f5 <search+0xc5>\nlea    -0x1(%rbx),%r12d\nxor    %ebp,%ebp\nxor    %r9d,%r9d\nnopw   0x0(%rax,%rax,1)\nmovslq %r9d,%r14\ntest   %r12d,%r12d\njs     1720 <search+0xf0>\nmovslq %r9d,%r14\nmovslq %r12d,%rax\nlea    (%r10,%r14,1),%rdi\njmp    16c8 <search+0x98>\nnopl   0x0(%rax)\nsub    $0x1,%rax\ntest   %eax,%eax\njs     1720 <search+0xf0>\nmovsbq (%rdi,%rax,1),%rdx\nmov    %eax,%ecx\ncmp    %dl,(%rsi,%rax,1)\nje     16c0 <search+0x90>\nsub    (%rsp,%rdx,4),%ecx\nmov    $0x1,%eax\ntest   %ecx,%ecx\ncmovle %eax,%ecx\nadd    %ecx,%r9d\nadd    $0x1,%ebp\ncmp    %ebp,%r9d\nmov    %ebp,%eax\ncmovge %r9d,%eax\ncmp    %eax,%r13d\njge    16a8 <search+0x78>\nmov    0x408(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1750 <search+0x120>\nadd    $0x410,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nlea    (%rbx,%r9,1),%eax\nmovl   $0x1,(%r8,%r14,4)\ncmp    %r11d,%eax\njl     1740 <search+0x110>\nmov    $0x1,%eax\nadd    %eax,%r9d\njmp    16e4 <search+0xb4>\nnopl   0x0(%rax,%rax,1)\ncltq\nmov    %ebx,%edi\nmovsbq (%r10,%rax,1),%rax\nsub    (%rsp,%rax,4),%edi\nmov    %edi,%eax\njmp    1736 <search+0x106>\ncall   10d0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "bubble-sort/bubble-sort.c", "function_name": "bubblesort", "content": "void\nbubblesort(int *data, unsigned size)\n{\n  for (unsigned i=0; i < size-1; i++)\n  {\n    int swapped = FALSE;\n    for (unsigned j=0; j < size-1; j++)\n    {\n      if (data[j] > data[j+1])\n      {\n        int tmp = data[j];\n        data[j] = data[j+1];\n        data[j+1] = tmp;\n        swapped = TRUE;\n        swaps++;\n      }\n    }\n    // done?\n    if (!swapped)\n      break;\n  }\n}\n"}, "pseudo": {"path": "bubble-sort/bubble-sort.host.O3.pseudo", "function_name": "bubblesort", "address": "0x1330", "label": "bubblesort", "content": "void __fastcall bubblesort(int *data, unsigned int size)\n{\n  unsigned int v2; // esi\n  int v3; // r9d\n  int v4; // r11d\n  __int64 v5; // rdx\n  int v6; // r10d\n  int *v7; // r8\n  unsigned int v8; // eax\n\n  v2 = size - 1;\n  if ( v2 )\n  {\n    v3 = *data;\n    v4 = 0;\n    v5 = 0LL;\n    v6 = 0;\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        v7 = &data[(unsigned int)(v5 + 1)];\n        v8 = v5 + 1;\n        if ( *v7 >= v3 )\n          break;\n        data[v5] = *v7;\n        v6 = 1;\n        *v7 = v3;\n        ++swaps;\n        if ( v8 < v2 )\n          goto LABEL_5;\nLABEL_8:\n        if ( ++v4 >= v2 )\n          return;\n        v3 = *data;\n        v6 = 0;\n        v5 = 0LL;\n      }\n      v3 = *v7;\n      if ( v8 >= v2 )\n      {\n        if ( !v6 )\n          return;\n        goto LABEL_8;\n      }\nLABEL_5:\n      v5 = v8;\n    }\n  }\n}\n"}, "pseudo_normalize": "void bubblesort(int *data, unsigned int size) {\n  unsigned int v2;\n  int v3;\n  int v4;\n  long long v5;\n  int v6;\n  int *v7;\n  unsigned int v8;\n  v2 = size - 1;\n  if (v2) {\n    v3 = *data;\n    v4 = 0;\n    v5 = 0LL;\n    v6 = 0;\n    while (1) {\n      while (1) {\n        v7 = &data[(unsigned int)(v5 + 1)];\n        v8 = v5 + 1;\n        if (*v7 >= v3) break;\n        data[v5] = *v7;\n        v6 = 1;\n        *v7 = v3;\n        ++swaps;\n        if (v8 < v2) goto LABEL_5;\n      LABEL_8:\n        if (++v4 >= v2) return;\n        v3 = *data;\n        v6 = 0;\n        v5 = 0LL;\n      }\n      v3 = *v7;\n      if (v8 >= v2) {\n        if (!v6) return;\n        goto LABEL_8;\n      }\n    LABEL_5:\n      v5 = v8;\n    }\n  }\n}", "binary": "bubble-sort/bubble-sort.host.O3", "assembly": "<bubblesort>:\nendbr64\nsub    $0x1,%esi\nje     13a1 <bubblesort+0x71>\nmov    (%rdi),%r9d\nxor    %r11d,%r11d\nxor    %edx,%edx\nxor    %r10d,%r10d\nnopl   0x0(%rax)\nlea    0x1(%rdx),%ecx\nlea    (%rdi,%rcx,4),%r8\nmov    %rcx,%rax\nmov    (%r8),%ecx\ncmp    %r9d,%ecx\njge    1380 <bubblesort+0x50>\nmov    %ecx,(%rdi,%rdx,4)\nmov    $0x1,%r10d\nmov    %r9d,(%r8)\naddq   $0x1,0x4f12(%rip)\ncmp    %esi,%eax\njae    138c <bubblesort+0x5c>\nmov    %eax,%edx\njmp    1348 <bubblesort+0x18>\ncs nopw 0x0(%rax,%rax,1)\nmov    %ecx,%r9d\ncmp    %esi,%eax\njb     1372 <bubblesort+0x42>\ntest   %r10d,%r10d\nje     13a1 <bubblesort+0x71>\nadd    $0x1,%r11d\ncmp    %esi,%r11d\njae    13a1 <bubblesort+0x71>\nxor    %eax,%eax\nmov    (%rdi),%r9d\nxor    %r10d,%r10d\nmov    %eax,%edx\njmp    1348 <bubblesort+0x18>\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "bubble-sort/bubble-sort.c", "function_name": "main", "content": "int\nmain(void)\n{\n  // initialize the pseudo-RNG\n  libmin_srand(42);\n  // mysrand(time(NULL));\n\n  // initialize the array to sort\n  for (unsigned i=0; i < DATASET_SIZE; i++)\n    data[i] = libmin_rand();\n  print_data(data, DATASET_SIZE);\n\n  {\n    // performance monitoring\n    libtarg_start_perf();\n\n    bubblesort(data, DATASET_SIZE);\n\n    libtarg_stop_perf();\n  }\n  print_data(data, DATASET_SIZE);\n\n  // check the array\n  for (unsigned i=0; i < DATASET_SIZE-1; i++)\n  {\n    if (data[i] > data[i+1])\n    {\n      libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n      return -1;\n    }\n  }\n  libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n  libmin_printf(\"INFO: data is properly sorted.\\n\");\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "bubble-sort/bubble-sort.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // rbp\n  int *v4; // rbx\n  int v5; // edx\n  int *v6; // rax\n  int v7; // ecx\n\n  v3 = &data[256];\n  v4 = data;\n  libmin_srand(0x2Au);\n  do\n    *v4++ = libmin_rand();\n  while ( v4 != v3 );\n  print_data(data, 0x100u);\n  libtarg_start_perf();\n  bubblesort(data, 0x100u);\n  libtarg_stop_perf();\n  print_data(data, 0x100u);\n  v5 = data[0];\n  v6 = &data[1];\n  while ( 1 )\n  {\n    v7 = v5;\n    v5 = *v6;\n    if ( *v6 < v7 )\n      break;\n    if ( ++v6 == v3 )\n    {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  int *v4;\n  int v5;\n  int *v6;\n  int v7;\n  v3 = &data[256];\n  v4 = data;\n  libmin_srand(42u);\n  do *v4++ = libmin_rand();\n  while (v4 != v3);\n  print_data(data, 256u);\n  libtarg_start_perf();\n  bubblesort(data, 256u);\n  libtarg_stop_perf();\n  print_data(data, 256u);\n  v5 = data[0];\n  v6 = &data[1];\n  while (1) {\n    v7 = v5;\n    v5 = *v6;\n    if (*v6 < v7) break;\n    if (++v6 == v3) {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}", "binary": "bubble-sort/bubble-sort.host.O3", "assembly": "<main>:\nendbr64\npush   %r12\nmov    $0x2a,%edi\nlea    0x518e(%rip),%r12\npush   %rbp\nlea    0x400(%r12),%rbp\npush   %rbx\nmov    %r12,%rbx\ncall   3690 <libmin_srand>\nnopl   0x0(%rax)\ncall   36f0 <libmin_rand>\nadd    $0x4,%rbx\nmov    %eax,-0x4(%rbx)\ncmp    %rbp,%rbx\njne    1128 <main+0x28>\nmov    $0x100,%esi\nmov    %r12,%rdi\ncall   12d0 <print_data>\nxor    %eax,%eax\ncall   1480 <libtarg_start_perf>\nmov    $0x100,%esi\nmov    %r12,%rdi\ncall   1330 <bubblesort>\nxor    %eax,%eax\ncall   1500 <libtarg_stop_perf>\nmov    $0x100,%esi\nmov    %r12,%rdi\ncall   12d0 <print_data>\nmov    0x512c(%rip),%edx\nlea    0x5129(%rip),%rax\njmp    1189 <main+0x89>\nnopl   (%rax)\nadd    $0x4,%rax\ncmp    %rbp,%rax\nje     11a9 <main+0xa9>\nmov    %edx,%ecx\nmov    (%rax),%edx\ncmp    %ecx,%edx\njge    1180 <main+0x80>\nlea    0x2ea8(%rip),%rdi\nxor    %eax,%eax\ncall   3480 <libmin_printf>\nmov    $0xffffffff,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    0x50d0(%rip),%rsi\nlea    0x2e6a(%rip),%rdi\nxor    %eax,%eax\ncall   3480 <libmin_printf>\nlea    0x2ea3(%rip),%rdi\nxor    %eax,%eax\ncall   3480 <libmin_printf>\ncall   38e0 <libmin_success>\nxor    %eax,%eax\njmp    11a4 <main+0xa4>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "bubble-sort/bubble-sort.c", "function_name": "print_data", "content": "void\nprint_data(int *data, unsigned size)\n{\n  libmin_printf(\"DATA DUMP:\\n\");\n  for (unsigned i=0; i < size; i++)\n    libmin_printf(\"  data[%u] = %d\\n\", i, data[i]);\n}\n"}, "pseudo": {"path": "bubble-sort/bubble-sort.host.O3.pseudo", "function_name": "print_data", "address": "0x12d0", "label": "print_data", "content": "void __fastcall print_data(int *data, unsigned int size)\n{\n  __int64 v2; // rbp\n  __int64 v3; // rbx\n  int v4; // edx\n  int v5; // esi\n\n  v2 = size;\n  libmin_printf(\"DATA DUMP:\\n\");\n  if ( size )\n  {\n    v3 = 0LL;\n    do\n    {\n      v4 = data[v3];\n      v5 = v3++;\n      libmin_printf(\"  data[%u] = %d\\n\", v5, v4);\n    }\n    while ( v2 != v3 );\n  }\n}\n"}, "pseudo_normalize": "void print_data(int *data, unsigned int size) {\n  long long v2;\n  long long v3;\n  int v4;\n  int v5;\n  v2 = size;\n  libmin_printf(\"DATA DUMP:\\n\");\n  if (size) {\n    v3 = 0LL;\n    do {\n      v4 = data[v3];\n      v5 = v3++;\n      libmin_printf(\"  data[%u] = %d\\n\", v5, v4);\n    } while (v2 != v3);\n  }\n}", "binary": "bubble-sort/bubble-sort.host.O3", "assembly": "<print_data>:\nendbr64\npush   %r13\nxor    %eax,%eax\npush   %r12\nmov    %rdi,%r12\nlea    0x2d20(%rip),%rdi\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nsub    $0x8,%rsp\ncall   3480 <libmin_printf>\ntest   %ebp,%ebp\nje     1319 <print_data+0x49>\nxor    %ebx,%ebx\nlea    0x2d12(%rip),%r13\nxchg   %ax,%ax\nmov    (%r12,%rbx,4),%edx\nmov    %ebx,%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   3480 <libmin_printf>\ncmp    %rbx,%rbp\njne    1300 <print_data+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "enum_declaration", "content": "void enum_declaration() {\n    // parse enum [id] { a = 1, b = 3, ...}\n    long i;\n    i = 0;\n    while (token != '}') {\n        if (token != Id) {\n            libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, token);\n            libmin_fail(-1);\n        }\n        next();\n        if (token == Assign) {\n            // like {a=10}\n            next();\n            if (token != Num) {\n                libmin_printf(\"%ld: bad enum initializer\\n\", line);\n                libmin_fail(-1);\n            }\n            i = token_val;\n            next();\n        }\n\n        current_id[Class] = Num;\n        current_id[Type] = INT;\n        current_id[Value] = i++;\n\n        if (token == ',') {\n            next();\n        }\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O3.pseudo", "function_name": "enum_declaration", "address": "0x34f0", "label": "enum_declaration", "content": "void __cdecl enum_declaration()\n{\n  __int64 v0; // rdx\n  __int64 i; // rbx\n  __int64 *v2; // rax\n  __m128i si128; // xmm0\n\n  v0 = token;\n  if ( token != 125 )\n  {\n    for ( i = 0LL; ; ++i )\n    {\n      if ( v0 != 133 )\n      {\n        libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, v0);\n        libmin_fail(-1);\n      }\n      next();\n      v0 = token;\n      if ( token == 142 )\n      {\n        next();\n        if ( token != 128 )\n        {\n          libmin_printf(\"%ld: bad enum initializer\\n\", line);\n          libmin_fail(-1);\n        }\n        i = token_val;\n        next();\n        v0 = token;\n      }\n      v2 = current_id;\n      si128 = _mm_load_si128((const __m128i *)&xmmword_7990);\n      current_id[5] = i;\n      *(__m128i *)(v2 + 3) = si128;\n      if ( v0 == 44 )\n      {\n        next();\n        v0 = token;\n        if ( token == 125 )\n          return;\n      }\n      else if ( v0 == 125 )\n      {\n        return;\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void enum_declaration() {\n  long long v0;\n  long long i;\n  long long *v2;\n  __m128i si128;\n  v0 = token;\n  if (token != 125) {\n    for (i = 0LL;; ++i) {\n      if (v0 != 133) {\n        libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, v0);\n        libmin_fail(-1);\n      }\n      next();\n      v0 = token;\n      if (token == 142) {\n        next();\n        if (token != 128) {\n          libmin_printf(\"%ld: bad enum initializer\\n\", line);\n          libmin_fail(-1);\n        }\n        i = token_val;\n        next();\n        v0 = token;\n      }\n      v2 = current_id;\n      si128 = _mm_load_si128((const __m128i *)&xmmword_7990);\n      current_id[5] = i;\n      *(__m128i *)(v2 + 3) = si128;\n      if (v0 == 44) {\n        next();\n        v0 = token;\n        if (token == 125) return;\n      } else if (v0 == 125) {\n        return;\n      }\n    }\n  }\n}", "binary": "c-interp/c-interp.host.O3", "assembly": "<enum_declaration>:\nendbr64\nmov    0x6e55(%rip),%rdx\ncmp    $0x7d,%rdx\nje     3600 <enum_declaration+0x110>\npush   %r13\nlea    0x3be8(%rip),%r13\npush   %r12\nlea    0x3bc1(%rip),%r12\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x8,%rsp\njmp    3531 <enum_declaration+0x41>\nnopl   0x0(%rax)\ncmp    $0x7d,%rdx\nje     35a1 <enum_declaration+0xb1>\nmov    %rbp,%rbx\ncmp    $0x85,%rdx\nje     3555 <enum_declaration+0x65>\nmov    0x6d8f(%rip),%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x6ded(%rip),%rdx\ncmp    $0x8e,%rdx\nje     35b0 <enum_declaration+0xc0>\nmov    0x6d6d(%rip),%rax\nmovdqa 0x4415(%rip),%xmm0\nlea    0x1(%rbx),%rbp\nmov    %rbx,0x28(%rax)\nmovups %xmm0,0x18(%rax)\ncmp    $0x2c,%rdx\njne    3528 <enum_declaration+0x38>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x6db5(%rip),%rdx\ncmp    $0x7d,%rdx\njne    352e <enum_declaration+0x3e>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\ncmpq   $0x80,0x6d8e(%rip)\nje     35df <enum_declaration+0xef>\nmov    0x6d05(%rip),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nxor    %eax,%eax\nmov    0x6ce0(%rip),%rbx\ncall   15a0 <next>\nmov    0x6d5c(%rip),%rdx\njmp    356c <enum_declaration+0x7c>\nnopl   0x0(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "eval", "content": "long eval() {\n    long op, *tmp;\n    cycle = 0;\n    while (1) {\n        cycle ++;\n        op = *pc++; // get next operation code\n\n        // print debug info\n        if (debug) {\n            libmin_printf(\"%ld> %.4s\", cycle,\n                   & \"LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,\"\n                   \"OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\"\n                   \"OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT\"[op * 5]);\n            if (op <= ADJ)\n                libmin_printf(\" %ld\\n\", *pc);\n            else\n                libmin_printf(\"\\n\");\n        }\n        if (op == IMM)       {ax = *pc++;}                                     // load immediate value to ax\n        else if (op == LC)   {ax = *(char *)ax;}                               // load character to ax, address in ax\n        else if (op == LI)   {ax = *(long *)ax;}                                // load integer to ax, address in ax\n        else if (op == SC)   {ax = *(char *)*sp++ = ax;}                       // save character to address, value in ax, address on stack\n        else if (op == SI)   {*(long *)*sp++ = ax;}                             // save integer to address, value in ax, address on stack\n        else if (op == PUSH) {*--sp = ax;}                                     // push the value of ax onto the stack\n        else if (op == JMP)  {pc = (long *)*pc;}                                // jump to the address\n        else if (op == JZ)   {pc = ax ? pc + 1 : (long *)*pc;}                   // jump if ax is zero\n        else if (op == JNZ)  {pc = ax ? (long *)*pc : pc + 1;}                   // jump if ax is not zero\n        else if (op == CALL) {*--sp = (long)(pc+1); pc = (long *)*pc;}           // call subroutine\n        //else if (op == RET)  {pc = (long *)*sp++;}                              // return from subroutine;\n        else if (op == ENT)  {*--sp = (long)bp; bp = sp; sp = sp - *pc++;}      // make new stack frame\n        else if (op == ADJ)  {sp = sp + *pc++;}                                // add esp, <size>\n        else if (op == LEV)  {sp = bp; bp = (long *)*sp++; pc = (long *)*sp++;}  // restore call frame and PC\n        else if (op == LEA)  {ax = (long)(bp + *pc++);}                         // load address for arguments.\n\n        else if (op == OR)  ax = *sp++ | ax;\n        else if (op == XOR) ax = *sp++ ^ ax;\n        else if (op == AND) ax = *sp++ & ax;\n        else if (op == EQ)  ax = *sp++ == ax;\n        else if (op == NE)  ax = *sp++ != ax;\n        else if (op == LT)  ax = *sp++ < ax;\n        else if (op == LE)  ax = *sp++ <= ax;\n        else if (op == GT)  ax = *sp++ >  ax;\n        else if (op == GE)  ax = *sp++ >= ax;\n        else if (op == SHL) ax = *sp++ << ax;\n        else if (op == SHR) ax = *sp++ >> ax;\n        else if (op == ADD) ax = *sp++ + ax;\n        else if (op == SUB) ax = *sp++ - ax;\n        else if (op == MUL) ax = *sp++ * ax;\n        else if (op == DIV) ax = *sp++ / ax;\n        else if (op == MOD) ax = *sp++ % ax;\n\n        else if (op == EXIT) { libmin_printf(\"exit(%ld)\", *sp); return *sp;}\n        // else if (op == OPEN) { ax = open((char *)sp[1], sp[0]); }\n        // else if (op == CLOS) { ax = close(*sp);}\n        // else if (op == READ) { ax = read(sp[2], (char *)sp[1], *sp); }\n        else if (op == PRTF) { tmp = sp + pc[1]; ax = libmin_printf((char *)tmp[-1], tmp[-2], tmp[-3], tmp[-4], tmp[-5], tmp[-6]); }\n        // else if (op == MALC) { ax = (long)malloc(*sp);}\n        else if (op == MSET) { ax = (long)libmin_memset((char *)sp[2], sp[1], *sp);}\n        else if (op == MCMP) { ax = libmin_memcmp((char *)sp[2], (char *)sp[1], *sp);}\n        else {\n            libmin_printf(\"unknown instruction:%ld\\n\", op);\n            return -1;\n        }\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O3.pseudo", "function_name": "eval", "address": "0x3ea0", "label": "eval", "content": "__int64 __cdecl eval()\n{\n  __int64 *v0; // rax\n  __int64 i; // rsi\n  __int64 v2; // rsi\n  __int64 v3; // r14\n  __int64 *v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rdx\n  __int64 v8; // rax\n  __int64 *v9; // rdx\n  __int64 v10; // rax\n  __int64 v11; // rax\n  bool v12; // al\n  bool v13; // al\n  bool v14; // al\n  bool v15; // al\n  bool v16; // al\n  bool v17; // al\n  __int64 *v18; // rax\n  char v19; // al\n  _BYTE *v20; // rdx\n  _QWORD *v21; // rax\n  __int64 *v22; // rax\n  __int64 *v23; // rdx\n  __int64 *v24; // rax\n  __int64 **v25; // rax\n  __int64 *v26; // rdx\n\n  v0 = pc;\n  for ( i = 0LL; ; i = cycle )\n  {\n    v2 = i + 1;\n    cycle = v2;\n    v3 = *v0;\n    pc = v0 + 1;\n    if ( !debug )\n      goto LABEL_3;\n    libmin_printf(\"%ld> %.4s\", v2, &aLeaImmJmpCallJ[5 * v3]);\n    if ( v3 > 7 )\n      break;\n    libmin_printf((char *)\" %ld\\n\", *pc);\nLABEL_3:\n    if ( v3 != 1 )\n      goto LABEL_4;\n    v0 = pc + 1;\n    qword_A2F0 = *pc;\nLABEL_6:\n    ;\n  }\n  libmin_printf((char *)\"\\n\");\n  if ( (unsigned __int64)v3 <= 0x25 )\n  {\nLABEL_4:\n    switch ( v3 )\n    {\n      case 0LL:\n        v0 = pc + 1;\n        qword_A2F0 = (__int64)&qword_A300[*pc];\n        goto LABEL_6;\n      case 2LL:\n        v0 = (__int64 *)*pc;\n        goto LABEL_6;\n      case 3LL:\n        v26 = qword_A2F8;\n        v25 = (__int64 **)pc;\n        --qword_A2F8;\n        *(v26 - 1) = (__int64)(pc + 1);\n        goto LABEL_44;\n      case 4LL:\n        v25 = (__int64 **)pc;\n        if ( qword_A2F0 )\n          v0 = pc + 1;\n        else\nLABEL_44:\n          v0 = *v25;\n        goto LABEL_6;\n      case 5LL:\n        v0 = pc + 1;\n        if ( qword_A2F0 )\n          v0 = (__int64 *)*pc;\n        goto LABEL_6;\n      case 6LL:\n        v24 = qword_A2F8;\n        *(qword_A2F8 - 1) = (__int64)qword_A300;\n        qword_A300 = v24 - 1;\n        v0 = pc + 1;\n        qword_A2F8 = &qword_A300[-*pc];\n        goto LABEL_6;\n      case 7LL:\n        v0 = pc + 1;\n        qword_A2F8 += *pc;\n        goto LABEL_6;\n      case 8LL:\n        v22 = qword_A300;\n        qword_A300 = (__int64 *)*qword_A300;\n        v23 = v22 + 2;\n        v0 = (__int64 *)v22[1];\n        qword_A2F8 = v23;\n        goto LABEL_6;\n      case 9LL:\n        qword_A2F0 = *(_QWORD *)qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 10LL:\n        qword_A2F0 = *(char *)qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 11LL:\n        v21 = (_QWORD *)*qword_A2F8++;\n        *v21 = qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 12LL:\n        v19 = qword_A2F0;\n        v20 = (_BYTE *)*qword_A2F8++;\n        *v20 = qword_A2F0;\n        qword_A2F0 = v19;\n        v0 = pc;\n        goto LABEL_6;\n      case 13LL:\n        v18 = qword_A2F8--;\n        *(v18 - 1) = qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 14LL:\n        qword_A2F0 |= *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 15LL:\n        qword_A2F0 ^= *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 16LL:\n        qword_A2F0 &= *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 17LL:\n        v17 = *qword_A2F8++ == qword_A2F0;\n        qword_A2F0 = v17;\n        v0 = pc;\n        goto LABEL_6;\n      case 18LL:\n        v16 = *qword_A2F8++ != qword_A2F0;\n        qword_A2F0 = v16;\n        v0 = pc;\n        goto LABEL_6;\n      case 19LL:\n        v15 = *qword_A2F8++ < qword_A2F0;\n        qword_A2F0 = v15;\n        v0 = pc;\n        goto LABEL_6;\n      case 20LL:\n        v14 = *qword_A2F8++ > qword_A2F0;\n        qword_A2F0 = v14;\n        v0 = pc;\n        goto LABEL_6;\n      case 21LL:\n        v13 = *qword_A2F8++ <= qword_A2F0;\n        qword_A2F0 = v13;\n        v0 = pc;\n        goto LABEL_6;\n      case 22LL:\n        v12 = *qword_A2F8++ >= qword_A2F0;\n        qword_A2F0 = v12;\n        v0 = pc;\n        goto LABEL_6;\n      case 23LL:\n        v11 = *qword_A2F8++;\n        qword_A2F0 = v11 << qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 24LL:\n        v10 = *qword_A2F8++;\n        qword_A2F0 = v10 >> qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 25LL:\n        qword_A2F0 += *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 26LL:\n        qword_A2F0 = *qword_A2F8 - qword_A2F0;\n        v0 = pc;\n        ++qword_A2F8;\n        goto LABEL_6;\n      case 27LL:\n        v9 = qword_A2F8++;\n        qword_A2F0 *= *v9;\n        v0 = pc;\n        goto LABEL_6;\n      case 28LL:\n        v8 = *qword_A2F8++;\n        qword_A2F0 = v8 / qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 29LL:\n        v6 = *qword_A2F8++;\n        v7 = v6 % qword_A2F0;\n        v0 = pc;\n        qword_A2F0 = v7;\n        goto LABEL_6;\n      case 33LL:\n        v5 = &qword_A2F8[pc[1]];\n        qword_A2F0 = libmin_printf((char *)*(v5 - 1), *(v5 - 2), *(v5 - 3), *(v5 - 4), *(v5 - 5), *(v5 - 6));\n        v0 = pc;\n        goto LABEL_6;\n      case 35LL:\n        qword_A2F0 = (__int64)libmin_memset((void *)qword_A2F8[2], *((_DWORD *)qword_A2F8 + 2), *qword_A2F8);\n        v0 = pc;\n        goto LABEL_6;\n      case 36LL:\n        qword_A2F0 = libmin_memcmp((const void *)qword_A2F8[2], (const void *)qword_A2F8[1], *qword_A2F8);\n        v0 = pc;\n        goto LABEL_6;\n      case 37LL:\n        libmin_printf(\"exit(%ld)\", *qword_A2F8);\n        return *qword_A2F8;\n      default:\n        break;\n    }\n  }\n  libmin_printf(\"unknown instruction:%ld\\n\", v3);\n  return -1LL;\n}\n"}, "pseudo_normalize": "long long eval() {\n  long long *v0;\n  long long i;\n  long long v2;\n  long long v3;\n  long long *v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long *v9;\n  long long v10;\n  long long v11;\n  bool v12;\n  bool v13;\n  bool v14;\n  bool v15;\n  bool v16;\n  bool v17;\n  long long *v18;\n  char v19;\n  uint8_t *v20;\n  uint64_t *v21;\n  long long *v22;\n  long long *v23;\n  long long *v24;\n  long long **v25;\n  long long *v26;\n  v0 = pc;\n  for (i = 0LL;; i = cycle) {\n    v2 = i + 1;\n    cycle = v2;\n    v3 = *v0;\n    pc = v0 + 1;\n    if (!debug) goto LABEL_3;\n    libmin_printf(\"%ld> %.4s\", v2, &aLeaImmJmpCallJ[5 * v3]);\n    if (v3 > 7) break;\n    libmin_printf((char *)\" %ld\\n\", *pc);\n  LABEL_3:\n    if (v3 != 1) goto LABEL_4;\n    v0 = pc + 1;\n    qword_A2F0 = *pc;\n  LABEL_6:;\n  }\n  libmin_printf((char *)\"\\n\");\n  if ((unsigned long long)v3 <= 37) {\n  LABEL_4:\n    switch (v3) {\n      case 0LL:\n        v0 = pc + 1;\n        qword_A2F0 = (long long)&qword_A300[*pc];\n        goto LABEL_6;\n      case 2LL:\n        v0 = (long long *)*pc;\n        goto LABEL_6;\n      case 3LL:\n        v26 = qword_A2F8;\n        v25 = (long long **)pc;\n        --qword_A2F8;\n        *(v26 - 1) = (long long)(pc + 1);\n        goto LABEL_44;\n      case 4LL:\n        v25 = (long long **)pc;\n        if (qword_A2F0)\n          v0 = pc + 1;\n        else\n        LABEL_44:\n          v0 = *v25;\n        goto LABEL_6;\n      case 5LL:\n        v0 = pc + 1;\n        if (qword_A2F0) v0 = (long long *)*pc;\n        goto LABEL_6;\n      case 6LL:\n        v24 = qword_A2F8;\n        *(qword_A2F8 - 1) = (long long)qword_A300;\n        qword_A300 = v24 - 1;\n        v0 = pc + 1;\n        qword_A2F8 = &qword_A300[-*pc];\n        goto LABEL_6;\n      case 7LL:\n        v0 = pc + 1;\n        qword_A2F8 += *pc;\n        goto LABEL_6;\n      case 8LL:\n        v22 = qword_A300;\n        qword_A300 = (long long *)*qword_A300;\n        v23 = v22 + 2;\n        v0 = (long long *)v22[1];\n        qword_A2F8 = v23;\n        goto LABEL_6;\n      case 9LL:\n        qword_A2F0 = *(uint64_t *)qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 10LL:\n        qword_A2F0 = *(char *)qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 11LL:\n        v21 = (uint64_t *)*qword_A2F8++;\n        *v21 = qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 12LL:\n        v19 = qword_A2F0;\n        v20 = (uint8_t *)*qword_A2F8++;\n        *v20 = qword_A2F0;\n        qword_A2F0 = v19;\n        v0 = pc;\n        goto LABEL_6;\n      case 13LL:\n        v18 = qword_A2F8--;\n        *(v18 - 1) = qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 14LL:\n        qword_A2F0 |= *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 15LL:\n        qword_A2F0 ^= *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 16LL:\n        qword_A2F0 &= *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 17LL:\n        v17 = *qword_A2F8++ == qword_A2F0;\n        qword_A2F0 = v17;\n        v0 = pc;\n        goto LABEL_6;\n      case 18LL:\n        v16 = *qword_A2F8++ != qword_A2F0;\n        qword_A2F0 = v16;\n        v0 = pc;\n        goto LABEL_6;\n      case 19LL:\n        v15 = *qword_A2F8++ < qword_A2F0;\n        qword_A2F0 = v15;\n        v0 = pc;\n        goto LABEL_6;\n      case 20LL:\n        v14 = *qword_A2F8++ > qword_A2F0;\n        qword_A2F0 = v14;\n        v0 = pc;\n        goto LABEL_6;\n      case 21LL:\n        v13 = *qword_A2F8++ <= qword_A2F0;\n        qword_A2F0 = v13;\n        v0 = pc;\n        goto LABEL_6;\n      case 22LL:\n        v12 = *qword_A2F8++ >= qword_A2F0;\n        qword_A2F0 = v12;\n        v0 = pc;\n        goto LABEL_6;\n      case 23LL:\n        v11 = *qword_A2F8++;\n        qword_A2F0 = v11 << qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 24LL:\n        v10 = *qword_A2F8++;\n        qword_A2F0 = v10 >> qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 25LL:\n        qword_A2F0 += *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 26LL:\n        qword_A2F0 = *qword_A2F8 - qword_A2F0;\n        v0 = pc;\n        ++qword_A2F8;\n        goto LABEL_6;\n      case 27LL:\n        v9 = qword_A2F8++;\n        qword_A2F0 *= *v9;\n        v0 = pc;\n        goto LABEL_6;\n      case 28LL:\n        v8 = *qword_A2F8++;\n        qword_A2F0 = v8 / qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 29LL:\n        v6 = *qword_A2F8++;\n        v7 = v6 % qword_A2F0;\n        v0 = pc;\n        qword_A2F0 = v7;\n        goto LABEL_6;\n      case 33LL:\n        v5 = &qword_A2F8[pc[1]];\n        qword_A2F0 = libmin_printf((char *)*(v5 - 1), *(v5 - 2), *(v5 - 3),\n                                   *(v5 - 4), *(v5 - 5), *(v5 - 6));\n        v0 = pc;\n        goto LABEL_6;\n      case 35LL:\n        qword_A2F0 = (long long)libmin_memset(\n            (void *)qword_A2F8[2], *((uint32_t *)qword_A2F8 + 2), *qword_A2F8);\n        v0 = pc;\n        goto LABEL_6;\n      case 36LL:\n        qword_A2F0 = libmin_memcmp((const void *)qword_A2F8[2],\n                                   (const void *)qword_A2F8[1], *qword_A2F8);\n        v0 = pc;\n        goto LABEL_6;\n      case 37LL:\n        libmin_printf(\"exit(%ld)\", *qword_A2F8);\n        return *qword_A2F8;\n      default:\n        break;\n    }\n  }\n  libmin_printf(\"unknown instruction:%ld\\n\", v3);\n  return -1LL;\n}", "binary": "c-interp/c-interp.host.O3", "assembly": "<eval>:\nendbr64\nmov    0x645d(%rip),%rax\npush   %r14\nxor    %esi,%esi\npush   %r13\nlea    0x32f9(%rip),%r13\npush   %r12\nlea    0x32f7(%rip),%r12\npush   %rbp\nlea    0x3281(%rip),%rbp\npush   %rbx\nlea    0x38b7(%rip),%rbx\nnopl   0x0(%rax)\nadd    $0x1,%rsi\nlea    0x8(%rax),%rdx\ncmpq   $0x0,0x6478(%rip)\nmov    %rsi,0x63f9(%rip)\nmov    (%rax),%r14\nmov    %rdx,0x640f(%rip)\njne    3f40 <eval+0xa0>\ncmp    $0x1,%r14\nje     3f18 <eval+0x78>\ncmp    $0x25,%r14\nja     3f8c <eval+0xec>\nmovslq (%rbx,%r14,4),%rax\nadd    %rbx,%rax\nnotrack jmp *%rax\nnopl   (%rax)\nmov    0x63e9(%rip),%rdx\nlea    0x8(%rdx),%rax\nmov    (%rdx),%rdx\nmov    %rdx,0x63c3(%rip)\nmov    0x63b4(%rip),%rsi\njmp    3ed8 <eval+0x38>\ncs nopw 0x0(%rax,%rax,1)\nlea    (%r14,%r14,4),%rdx\nxor    %eax,%eax\nmov    %rbp,%rdi\nadd    %r12,%rdx\ncall   6c80 <libmin_printf>\ncmp    $0x7,%r14\njg     3f78 <eval+0xd8>\nmov    0x63aa(%rip),%rax\nlea    0x30c3(%rip),%rdi\nmov    (%rax),%rsi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\njmp    3efb <eval+0x5b>\nnopl   0x0(%rax)\nxor    %eax,%eax\nmov    %r13,%rdi\ncall   6c80 <libmin_printf>\ncmp    $0x25,%r14\njbe    3f0b <eval+0x6b>\nmov    %r14,%rsi\nlea    0x31c8(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\npop    %rbx\nmov    $0xffffffffffffffff,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   (%rax)\nmov    0x6341(%rip),%rax\nlea    0x3196(%rip),%rdi\nmov    (%rax),%rsi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    0x6329(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\nmov    (%rax),%rax\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nmov    0x6311(%rip),%rax\nmov    0x8(%rax),%rsi\nmov    0x10(%rax),%rdi\nmov    (%rax),%rdx\ncall   4ac0 <libmin_memcmp>\ncltq\nmov    %rax,0x62f0(%rip)\nmov    0x6301(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   0x0(%rax)\nmov    0x62e1(%rip),%rax\nmov    0x10(%rax),%rdi\nmov    (%rax),%rdx\nmov    0x8(%rax),%esi\ncall   4c40 <libmin_memset>\nmov    %rax,0x62c3(%rip)\nmov    0x62d4(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   0x0(%rax)\nmov    0x62c1(%rip),%rax\nmov    0x8(%rax),%rdx\nmov    0x62a6(%rip),%rax\nlea    (%rax,%rdx,8),%rax\nmov    -0x20(%rax),%rcx\nmov    -0x18(%rax),%rdx\nmov    -0x10(%rax),%rsi\nmov    -0x8(%rax),%rdi\nmov    -0x30(%rax),%r9\nmov    -0x28(%rax),%r8\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\ncltq\nmov    %rax,0x6272(%rip)\nmov    0x6283(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopw   0x0(%rax,%rax,1)\nmov    0x6261(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rdx,0x6253(%rip)\ncqto\nidivq  0x6242(%rip)\nmov    0x6253(%rip),%rax\nmov    %rdx,0x6234(%rip)\njmp    3f2d <eval+0x8d>\nnopl   0x0(%rax)\nmov    0x6229(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rdx,0x621b(%rip)\ncqto\nidivq  0x620a(%rip)\nmov    %rax,0x6203(%rip)\nmov    0x6214(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   0x0(%rax)\nmov    0x61f1(%rip),%rdx\nlea    0x8(%rdx),%rax\nmov    %rax,0x61e6(%rip)\nmov    0x61d7(%rip),%rax\nimul   (%rdx),%rax\nmov    %rax,0x61cc(%rip)\nmov    0x61dd(%rip),%rax\njmp    3f2d <eval+0x8d>\nmov    0x61c1(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nsub    0x61ab(%rip),%rax\nmov    %rax,0x61a4(%rip)\nmov    0x61b5(%rip),%rax\nmov    %rdx,0x619e(%rip)\njmp    3f2d <eval+0x8d>\nnop\nmov    0x6191(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nadd    %rax,0x617b(%rip)\nmov    %rdx,0x617c(%rip)\nmov    0x6185(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   0x0(%rax,%rax,1)\nmov    0x6161(%rip),%rax\nmov    0x6152(%rip),%rcx\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rdx,0x614c(%rip)\nsar    %cl,%rax\nmov    %rax,0x613a(%rip)\nmov    0x614b(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopw   0x0(%rax,%rax,1)\nmov    0x6129(%rip),%rax\nmov    0x611a(%rip),%rcx\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rdx,0x6114(%rip)\nshl    %cl,%rax\nmov    %rax,0x6102(%rip)\nmov    0x6113(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopw   0x0(%rax,%rax,1)\nmov    0x60f1(%rip),%rax\nmov    0x60e2(%rip),%rcx\ncmp    %rcx,(%rax)\nlea    0x8(%rax),%rdx\nsetge  %al\nmov    %rdx,0x60d9(%rip)\nmovzbl %al,%eax\nmov    %rax,0x60c7(%rip)\nmov    0x60d8(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   (%rax)\nmov    0x60b9(%rip),%rax\nmov    0x60aa(%rip),%rcx\ncmp    %rcx,(%rax)\nlea    0x8(%rax),%rdx\nsetle  %al\nmov    %rdx,0x60a1(%rip)\nmovzbl %al,%eax\nmov    %rax,0x608f(%rip)\nmov    0x60a0(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   (%rax)\nmov    0x6081(%rip),%rax\nmov    0x6072(%rip),%rcx\ncmp    %rcx,(%rax)\nlea    0x8(%rax),%rdx\nsetg   %al\nmov    %rdx,0x6069(%rip)\nmovzbl %al,%eax\nmov    %rax,0x6057(%rip)\nmov    0x6068(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   (%rax)\nmov    0x6049(%rip),%rax\nmov    0x603a(%rip),%rcx\ncmp    %rcx,(%rax)\nlea    0x8(%rax),%rdx\nsetl   %al\nmov    %rdx,0x6031(%rip)\nmovzbl %al,%eax\nmov    %rax,0x601f(%rip)\nmov    0x6030(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   (%rax)\nmov    0x6011(%rip),%rax\nmov    0x6002(%rip),%rcx\ncmp    %rcx,(%rax)\nlea    0x8(%rax),%rdx\nsetne  %al\nmov    %rdx,0x5ff9(%rip)\nmovzbl %al,%eax\nmov    %rax,0x5fe7(%rip)\nmov    0x5ff8(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   (%rax)\nmov    0x5fd9(%rip),%rax\nmov    0x5fca(%rip),%rcx\ncmp    %rcx,(%rax)\nlea    0x8(%rax),%rdx\nsete   %al\nmov    %rdx,0x5fc1(%rip)\nmovzbl %al,%eax\nmov    %rax,0x5faf(%rip)\nmov    0x5fc0(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   (%rax)\nmov    0x5fa1(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nand    %rax,0x5f8b(%rip)\nmov    %rdx,0x5f8c(%rip)\nmov    0x5f95(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   0x0(%rax,%rax,1)\nmov    0x5f71(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nxor    %rax,0x5f5b(%rip)\nmov    %rdx,0x5f5c(%rip)\nmov    0x5f65(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   0x0(%rax,%rax,1)\nmov    0x5f41(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nor     %rax,0x5f2b(%rip)\nmov    %rdx,0x5f2c(%rip)\nmov    0x5f35(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   0x0(%rax,%rax,1)\nmov    0x5f11(%rip),%rax\nlea    -0x8(%rax),%rdx\nmov    %rdx,0x5f06(%rip)\nmov    0x5ef7(%rip),%rdx\nmov    %rdx,-0x8(%rax)\nmov    0x5f04(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   0x0(%rax)\nmov    0x5ee1(%rip),%rdx\nmov    0x5ed2(%rip),%rax\nlea    0x8(%rdx),%rcx\nmov    (%rdx),%rdx\nmov    %rcx,0x5ecc(%rip)\nmov    %al,(%rdx)\nmovsbq %al,%rax\nmov    %rax,0x5eb7(%rip)\nmov    0x5ec8(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   (%rax)\nmov    0x5ea9(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rdx,0x5e9b(%rip)\nmov    0x5e8c(%rip),%rdx\nmov    %rdx,(%rax)\nmov    0x5e9a(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   0x0(%rax,%rax,1)\nmov    0x5e71(%rip),%rax\nmovsbq (%rax),%rax\nmov    %rax,0x5e66(%rip)\nmov    0x5e77(%rip),%rax\njmp    3f2d <eval+0x8d>\ncs nopw 0x0(%rax,%rax,1)\nmov    0x5e49(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x5e3f(%rip)\nmov    0x5e50(%rip),%rax\njmp    3f2d <eval+0x8d>\nnopl   (%rax)\nmov    0x5e39(%rip),%rax\nmov    (%rax),%rdx\nmov    %rdx,0x5e2f(%rip)\nlea    0x10(%rax),%rdx\nmov    0x8(%rax),%rax\nmov    %rdx,0x5e18(%rip)\njmp    3f2d <eval+0x8d>\nnopl   (%rax)\nmov    0x5e19(%rip),%rdx\nlea    0x8(%rdx),%rax\nmov    (%rdx),%rdx\nshl    $0x3,%rdx\nadd    %rdx,0x5df7(%rip)\njmp    3f2d <eval+0x8d>\ncs nopw 0x0(%rax,%rax,1)\nmov    0x5de1(%rip),%rax\nmov    0x5de2(%rip),%rcx\nmov    %rcx,-0x8(%rax)\nmov    0x5ddf(%rip),%rcx\nlea    -0x8(%rax),%rdx\nmov    %rdx,0x5dcc(%rip)\nlea    0x8(%rcx),%rax\nmov    (%rcx),%rcx\nshl    $0x3,%rcx\nsub    %rcx,%rdx\nmov    %rdx,0x5daf(%rip)\njmp    3f2d <eval+0x8d>\nxchg   %ax,%ax\nmov    0x5db1(%rip),%rdx\ncmpq   $0x0,0x5d91(%rip)\nlea    0x8(%rdx),%rax\nje     3f2d <eval+0x8d>\nmov    (%rdx),%rax\njmp    3f2d <eval+0x8d>\nnopl   0x0(%rax)\ncmpq   $0x0,0x5d70(%rip)\nmov    0x5d81(%rip),%rax\nje     45b9 <eval+0x719>\nadd    $0x8,%rax\njmp    3f2d <eval+0x8d>\nnopw   0x0(%rax,%rax,1)\nmov    0x5d59(%rip),%rdx\nmov    0x5d62(%rip),%rax\nlea    -0x8(%rdx),%rcx\nmov    %rcx,0x5d47(%rip)\nlea    0x8(%rax),%rcx\nmov    %rcx,-0x8(%rdx)\nmov    (%rax),%rax\njmp    3f2d <eval+0x8d>\nnopl   0x0(%rax)\nmov    0x5d39(%rip),%rax\nmov    (%rax),%rax\njmp    3f2d <eval+0x8d>\nnopw   0x0(%rax,%rax,1)\nmov    0x5d21(%rip),%rdx\nmov    (%rdx),%rcx\nlea    0x8(%rdx),%rax\nmov    0x5d0b(%rip),%rdx\nlea    (%rdx,%rcx,8),%rdx\nmov    %rdx,0x5cf0(%rip)\njmp    3f2d <eval+0x8d>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "expression", "content": "void expression(long level) {\n    // expressions have various format.\n    // but majorly can be divided into two parts: unit and operator\n    // for example `(char) *a[10] = (int *) func(b > 0 ? 10 : 20);\n    // `a[10]` is an unit while `*` is an operator.\n    // `func(...)` in total is an unit.\n    // so we should first parse those unit and unary operators\n    // and then the binary ones\n    //\n    // also the expression can be in the following types:\n    //\n    // 1. unit_unary ::= unit | unit unary_op | unary_op unit\n    // 2. expr ::= unit_unary (bin_op unit_unary ...)\n\n    // unit_unary()\n    long *id;\n    long tmp;\n    long *addr;\n    {\n        if (!token) {\n            libmin_printf(\"%ld: unexpected token EOF of expression\\n\", line);\n            libmin_fail(-1);\n        }\n        if (token == Num) {\n            match(Num);\n\n            // emit code\n            *++text = IMM;\n            *++text = token_val;\n            expr_type = INT;\n        }\n        else if (token == '\"') {\n            // continous string \"abc\" \"abc\"\n\n\n            // emit code\n            *++text = IMM;\n            *++text = token_val;\n\n            match('\"');\n            // store the rest strings\n            while (token == '\"') {\n                match('\"');\n            }\n\n            // append the end of string character '\\0', all the data are default\n            // to 0, so just move data one position forward.\n            data = (char *)(((long)data + sizeof(long)) & (-sizeof(long)));\n            expr_type = PTR;\n        }\n        else if (token == Sizeof) {\n            // sizeof is actually an unary operator\n            // now only `sizeof(int)`, `sizeof(char)` and `sizeof(*...)` are\n            // supported.\n            match(Sizeof);\n            match('(');\n            expr_type = INT;\n\n            if (token == Int) {\n                match(Int);\n            } else if (token == Char) {\n                match(Char);\n                expr_type = CHAR;\n            }\n\n            while (token == Mul) {\n                match(Mul);\n                expr_type = expr_type + PTR;\n            }\n\n            match(')');\n\n            // emit code\n            *++text = IMM;\n            *++text = (expr_type == CHAR) ? sizeof(char) : sizeof(long);\n\n            expr_type = INT;\n        }\n        else if (token == Id) {\n            // there are several type when occurs to Id\n            // but this is unit, so it can only be\n            // 1. function call\n            // 2. Enum variable\n            // 3. global/local variable\n            match(Id);\n\n            id = current_id;\n\n            if (token == '(') {\n                // function call\n                match('(');\n\n                // pass in arguments\n                tmp = 0; // number of arguments\n                while (token != ')') {\n                    expression(Assign);\n                    *++text = PUSH;\n                    tmp ++;\n\n                    if (token == ',') {\n                        match(',');\n                    }\n\n                }\n                match(')');\n\n                // emit code\n                if (id[Class] == Sys) {\n                    // system functions\n                    *++text = id[Value];\n                }\n                else if (id[Class] == Fun) {\n                    // function call\n                    *++text = CALL;\n                    *++text = id[Value];\n                }\n                else {\n                    libmin_printf(\"%ld: bad function call\\n\", line);\n                    libmin_fail(-1);\n                }\n\n                // clean the stack for arguments\n                if (tmp > 0) {\n                    *++text = ADJ;\n                    *++text = tmp;\n                }\n                expr_type = id[Type];\n            }\n            else if (id[Class] == Num) {\n                // enum variable\n                *++text = IMM;\n                *++text = id[Value];\n                expr_type = INT;\n            }\n            else {\n                // variable\n                if (id[Class] == Loc) {\n                    *++text = LEA;\n                    *++text = index_of_bp - id[Value];\n                }\n                else if (id[Class] == Glo) {\n                    *++text = IMM;\n                    *++text = id[Value];\n                }\n                else {\n                    libmin_printf(\"%ld: undefined variable\\n\", line);\n                    libmin_fail(-1);\n                }\n\n                // emit code, default behaviour is to load the value of the\n                // address which is stored in `ax`\n                expr_type = id[Type];\n                *++text = (expr_type == CHAR) ? LC : LI;\n            }\n        }\n        else if (token == '(') {\n            // cast or parenthesis\n            match('(');\n            if (token == Int || token == Char) {\n                tmp = (token == Char) ? CHAR : INT; // cast type\n                match(token);\n                while (token == Mul) {\n                    match(Mul);\n                    tmp = tmp + PTR;\n                }\n\n                match(')');\n\n                expression(Inc); // cast has precedence as Inc(++)\n\n                expr_type  = tmp;\n            } else {\n                // normal parenthesis\n                expression(Assign);\n                match(')');\n            }\n        }\n        else if (token == Mul) {\n            // dereference *<addr>\n            match(Mul);\n            expression(Inc); // dereference has the same precedence as Inc(++)\n\n            if (expr_type >= PTR) {\n                expr_type = expr_type - PTR;\n            } else {\n                libmin_printf(\"%ld: bad dereference\\n\", line);\n                libmin_fail(-1);\n            }\n\n            *++text = (expr_type == CHAR) ? LC : LI;\n        }\n        else if (token == And) {\n            // get the address of\n            match(And);\n            expression(Inc); // get the address of\n            if (*text == LC || *text == LI) {\n                text --;\n            } else {\n                libmin_printf(\"%ld: bad address of\\n\", line);\n                libmin_fail(-1);\n            }\n\n            expr_type = expr_type + PTR;\n        }\n        else if (token == '!') {\n            // not\n            match('!');\n            expression(Inc);\n\n            // emit code, use <expr> == 0\n            *++text = PUSH;\n            *++text = IMM;\n            *++text = 0;\n            *++text = EQ;\n\n            expr_type = INT;\n        }\n        else if (token == '~') {\n            // bitwise not\n            match('~');\n            expression(Inc);\n\n            // emit code, use <expr> XOR -1\n            *++text = PUSH;\n            *++text = IMM;\n            *++text = -1;\n            *++text = XOR;\n\n            expr_type = INT;\n        }\n        else if (token == Add) {\n            // +var, do nothing\n            match(Add);\n            expression(Inc);\n\n            expr_type = INT;\n        }\n        else if (token == Sub) {\n            // -var\n            match(Sub);\n\n            if (token == Num) {\n                *++text = IMM;\n                *++text = -token_val;\n                match(Num);\n            } else {\n\n                *++text = IMM;\n                *++text = -1;\n                *++text = PUSH;\n                expression(Inc);\n                *++text = MUL;\n            }\n\n            expr_type = INT;\n        }\n        else if (token == Inc || token == Dec) {\n            tmp = token;\n            match(token);\n            expression(Inc);\n            if (*text == LC) {\n                *text = PUSH;  // to duplicate the address\n                *++text = LC;\n            } else if (*text == LI) {\n                *text = PUSH;\n                *++text = LI;\n            } else {\n                libmin_printf(\"%ld: bad lvalue of pre-increment\\n\", line);\n                libmin_fail(-1);\n            }\n            *++text = PUSH;\n            *++text = IMM;\n            *++text = (expr_type > PTR) ? sizeof(long) : sizeof(char);\n            *++text = (tmp == Inc) ? ADD : SUB;\n            *++text = (expr_type == CHAR) ? SC : SI;\n        }\n        else {\n            libmin_printf(\"%ld: bad expression\\n\", line);\n            libmin_fail(-1);\n        }\n    }\n\n    // binary operator and postfix operators.\n    {\n        while (token >= level) {\n            // handle according to current operator's precedence\n            tmp = expr_type;\n            if (token == Assign) {\n                // var = expr;\n                match(Assign);\n                if (*text == LC || *text == LI) {\n                    *text = PUSH; // save the lvalue's pointer\n                } else {\n                    libmin_printf(\"%ld: bad lvalue in assignment\\n\", line);\n                    libmin_fail(-1);\n                }\n                expression(Assign);\n\n                expr_type = tmp;\n                *++text = (expr_type == CHAR) ? SC : SI;\n            }\n            else if (token == Cond) {\n                // expr ? a : b;\n                match(Cond);\n                *++text = JZ;\n                addr = ++text;\n                expression(Assign);\n                if (token == ':') {\n                    match(':');\n                } else {\n                    libmin_printf(\"%ld: missing colon in conditional\\n\", line);\n                    libmin_fail(-1);\n                }\n                *addr = (long)(text + 3);\n                *++text = JMP;\n                addr = ++text;\n                expression(Cond);\n                *addr = (long)(text + 1);\n            }\n            else if (token == Lor) {\n                // logic or\n                match(Lor);\n                *++text = JNZ;\n                addr = ++text;\n                expression(Lan);\n                *addr = (long)(text + 1);\n                expr_type = INT;\n            }\n            else if (token == Lan) {\n                // logic and\n                match(Lan);\n                *++text = JZ;\n                addr = ++text;\n                expression(Or);\n                *addr = (long)(text + 1);\n                expr_type = INT;\n            }\n            else if (token == Or) {\n                // bitwise or\n                match(Or);\n                *++text = PUSH;\n                expression(Xor);\n                *++text = OR;\n                expr_type = INT;\n            }\n            else if (token == Xor) {\n                // bitwise xor\n                match(Xor);\n                *++text = PUSH;\n                expression(And);\n                *++text = XOR;\n                expr_type = INT;\n            }\n            else if (token == And) {\n                // bitwise and\n                match(And);\n                *++text = PUSH;\n                expression(Eq);\n                *++text = AND;\n                expr_type = INT;\n            }\n            else if (token == Eq) {\n                // equal ==\n                match(Eq);\n                *++text = PUSH;\n                expression(Ne);\n                *++text = EQ;\n                expr_type = INT;\n            }\n            else if (token == Ne) {\n                // not equal !=\n                match(Ne);\n                *++text = PUSH;\n                expression(Lt);\n                *++text = NE;\n                expr_type = INT;\n            }\n            else if (token == Lt) {\n                // less than\n                match(Lt);\n                *++text = PUSH;\n                expression(Shl);\n                *++text = LT;\n                expr_type = INT;\n            }\n            else if (token == Gt) {\n                // greater than\n                match(Gt);\n                *++text = PUSH;\n                expression(Shl);\n                *++text = GT;\n                expr_type = INT;\n            }\n            else if (token == Le) {\n                // less than or equal to\n                match(Le);\n                *++text = PUSH;\n                expression(Shl);\n                *++text = LE;\n                expr_type = INT;\n            }\n            else if (token == Ge) {\n                // greater than or equal to\n                match(Ge);\n                *++text = PUSH;\n                expression(Shl);\n                *++text = GE;\n                expr_type = INT;\n            }\n            else if (token == Shl) {\n                // shift left\n                match(Shl);\n                *++text = PUSH;\n                expression(Add);\n                *++text = SHL;\n                expr_type = INT;\n            }\n            else if (token == Shr) {\n                // shift right\n                match(Shr);\n                *++text = PUSH;\n                expression(Add);\n                *++text = SHR;\n                expr_type = INT;\n            }\n            else if (token == Add) {\n                // add\n                match(Add);\n                *++text = PUSH;\n                expression(Mul);\n\n                expr_type = tmp;\n                if (expr_type > PTR) {\n                    // pointer type, and not `char *`\n                    *++text = PUSH;\n                    *++text = IMM;\n                    *++text = sizeof(long);\n                    *++text = MUL;\n                }\n                *++text = ADD;\n            }\n            else if (token == Sub) {\n                // sub\n                match(Sub);\n                *++text = PUSH;\n                expression(Mul);\n                if (tmp > PTR && tmp == expr_type) {\n                    // pointer subtraction\n                    *++text = SUB;\n                    *++text = PUSH;\n                    *++text = IMM;\n                    *++text = sizeof(long);\n                    *++text = DIV;\n                    expr_type = INT;\n                } else if (tmp > PTR) {\n                    // pointer movement\n                    *++text = PUSH;\n                    *++text = IMM;\n                    *++text = sizeof(long);\n                    *++text = MUL;\n                    *++text = SUB;\n                    expr_type = tmp;\n                } else {\n                    // numeral subtraction\n                    *++text = SUB;\n                    expr_type = tmp;\n                }\n            }\n            else if (token == Mul) {\n                // multiply\n                match(Mul);\n                *++text = PUSH;\n                expression(Inc);\n                *++text = MUL;\n                expr_type = tmp;\n            }\n            else if (token == Div) {\n                // divide\n                match(Div);\n                *++text = PUSH;\n                expression(Inc);\n                *++text = DIV;\n                expr_type = tmp;\n            }\n            else if (token == Mod) {\n                // Modulo\n                match(Mod);\n                *++text = PUSH;\n                expression(Inc);\n                *++text = MOD;\n                expr_type = tmp;\n            }\n            else if (token == Inc || token == Dec) {\n                // postfix inc(++) and dec(--)\n                // we will increase the value to the variable and decrease it\n                // on `ax` to get its original value.\n                if (*text == LI) {\n                    *text = PUSH;\n                    *++text = LI;\n                }\n                else if (*text == LC) {\n                    *text = PUSH;\n                    *++text = LC;\n                }\n                else {\n                    libmin_printf(\"%ld: bad value in increment\\n\", line);\n                    libmin_fail(-1);\n                }\n\n                *++text = PUSH;\n                *++text = IMM;\n                *++text = (expr_type > PTR) ? sizeof(long) : sizeof(char);\n                *++text = (token == Inc) ? ADD : SUB;\n                *++text = (expr_type == CHAR) ? SC : SI;\n                *++text = PUSH;\n                *++text = IMM;\n                *++text = (expr_type > PTR) ? sizeof(long) : sizeof(char);\n                *++text = (token == Inc) ? SUB : ADD;\n                match(token);\n            }\n            else if (token == Brak) {\n                // array access var[xx]\n                match(Brak);\n                *++text = PUSH;\n                expression(Assign);\n                match(']');\n\n                if (tmp > PTR) {\n                    // pointer, `not char *`\n                    *++text = PUSH;\n                    *++text = IMM;\n                    *++text = sizeof(long);\n                    *++text = MUL;\n                }\n                else if (tmp < PTR) {\n                    libmin_printf(\"%ld: pointer type expected\\n\", line);\n                    libmin_fail(-1);\n                }\n                expr_type = tmp - PTR;\n                *++text = ADD;\n                *++text = (expr_type == CHAR) ? LC : LI;\n            }\n            else {\n                libmin_printf(\"%ld: compiler error, token = %ld\\n\", line, token);\n                libmin_fail(-1);\n            }\n        }\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O3.pseudo", "function_name": "expression", "address": "0x1d70", "label": "expression", "content": "void __fastcall expression(__int64 level)\n{\n  __int64 v1; // rbp\n  __int64 v3; // rbp\n  __int64 i; // rax\n  __int64 v5; // rbp\n  _QWORD *v6; // rax\n  char *v7; // rdx\n  __int64 v8; // rdx\n  char *v9; // rcx\n  _QWORD *v10; // rax\n  char *v11; // rdx\n  _QWORD *v12; // rdx\n  char *v13; // rax\n  __int64 v14; // rcx\n  __int64 v15; // rdx\n  __m128i v16; // xmm1\n  bool v17; // cc\n  bool v18; // zf\n  __int64 v19; // rdi\n  __int64 v20; // rsi\n  char *v21; // rdx\n  char *v22; // rdx\n  char *v23; // rdx\n  char *v24; // rdx\n  char *v25; // rdx\n  _QWORD *v26; // rax\n  _QWORD *v27; // rdx\n  char *v28; // rax\n  char *v29; // rdx\n  char *v30; // rdx\n  char *v31; // rdx\n  char *v32; // rdx\n  char *v33; // rdx\n  char *v34; // rdx\n  char *v35; // rdx\n  char *v36; // rdx\n  _QWORD *v37; // rdx\n  _QWORD *v38; // rax\n  __int64 v39; // rcx\n  _QWORD *v40; // r12\n  _QWORD *v41; // rbp\n  _QWORD *v42; // rbp\n  __int64 v43; // rdi\n  char *v44; // rax\n  char *v45; // rdx\n  char *v46; // rax\n  _QWORD *v47; // rdx\n  char *v48; // rax\n  __int64 v49; // rcx\n  __int64 v50; // rdx\n  __int64 v51; // rcx\n  char *v52; // rcx\n  char *v53; // rax\n  char *v54; // rdx\n  __int64 v55; // rax\n  bool v56; // cf\n  _QWORD *v57; // rdx\n  char *v58; // rcx\n  __int64 *v59; // rbp\n  __int64 v60; // rax\n  _QWORD *v61; // rax\n  char *v62; // rcx\n  __int64 v63; // rax\n  _QWORD *v64; // rax\n  char *v65; // rdx\n  _QWORD *v66; // rax\n  char *v67; // rdx\n  __m128i v68; // xmm3\n  __m128i v69; // xmm4\n  __m128i si128; // xmm5\n  __m128i v71; // xmm0\n  _QWORD *v72; // rax\n  char *v73; // rcx\n  __int64 v74; // r12\n  char *v75; // rdx\n  __int64 v76; // rax\n  _QWORD *v77; // rax\n  char *v78; // rdx\n  _QWORD *v79; // rax\n  char *v80; // rdx\n  _QWORD *v81; // rax\n  __int64 v82; // rsi\n  _QWORD *v83; // rax\n\n  v1 = token;\n  if ( !token )\n  {\n    libmin_printf(\"%ld: unexpected token EOF of expression\\n\", line);\n    libmin_fail(-1);\n  }\n  if ( token == 128 )\n  {\n    next();\n    v10 = text;\n    expr_type = 1LL;\n    v11 = (char *)text + 16;\n    *((_QWORD *)text + 1) = 1LL;\n    text = v11;\n    v10[2] = token_val;\n    v8 = token;\n    goto LABEL_13;\n  }\n  if ( token > 163 )\n    goto LABEL_25;\n  if ( token <= 125 )\n  {\n    switch ( token )\n    {\n      case '\"':\n        v66 = text;\n        v67 = (char *)text + 16;\n        *((_QWORD *)text + 1) = 1LL;\n        text = v67;\n        v66[2] = token_val;\n        do\n        {\n          next();\n          v8 = token;\n        }\n        while ( token == 34 );\n        expr_type = 2LL;\n        data = (char *)((unsigned __int64)(data + 8) & 0xFFFFFFFFFFFFFFF8LL);\n        goto LABEL_13;\n      case '(':\n        next();\n        if ( ((token - 134) & 0xFFFFFFFFFFFFFFFBLL) != 0 )\n        {\n          expression(142LL);\n          if ( token != 41 )\n          {\n            libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n            libmin_fail(-1);\n          }\n          next();\n          v8 = token;\n        }\n        else\n        {\n          v3 = token != 134;\n          next();\n          for ( i = token; token == 159; i = token )\n          {\n            v3 += 2LL;\n            next();\n          }\n          if ( i != 41 )\n          {\n            libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n            libmin_fail(-1);\n          }\n          next();\n          expression(162LL);\n          expr_type = v3;\n          v8 = token;\n        }\n        goto LABEL_13;\n      case '!':\n        next();\n        expression(162LL);\n        v6 = text;\n        expr_type = 1LL;\n        v7 = (char *)text + 32;\n        *((_QWORD *)text + 1) = 13LL;\n        text = v7;\n        v8 = token;\n        v6[2] = 1LL;\n        v6[3] = 0LL;\n        v6[4] = 17LL;\n        goto LABEL_13;\n    }\nLABEL_25:\n    libmin_printf(\"%ld: bad expression\\n\", line);\n    libmin_fail(-1);\n  }\n  switch ( token )\n  {\n    case 126LL:\n      next();\n      expression(162LL);\n      v64 = text;\n      expr_type = 1LL;\n      v65 = (char *)text + 32;\n      *((_QWORD *)text + 1) = 13LL;\n      text = v65;\n      v8 = token;\n      v64[2] = 1LL;\n      v64[3] = -1LL;\n      v64[4] = 15LL;\n      goto LABEL_13;\n    case 133LL:\n      next();\n      v8 = token;\n      v59 = current_id;\n      if ( token != 40 )\n      {\n        v60 = current_id[4];\n        if ( v60 == 128 )\n        {\n          v72 = text;\n          expr_type = 1LL;\n          v73 = (char *)text + 16;\n          *((_QWORD *)text + 1) = 1LL;\n          text = v73;\n          v72[2] = v59[5];\n        }\n        else\n        {\n          if ( v60 == 132 )\n          {\n            v81 = text;\n            v82 = index_of_bp;\n            *((_QWORD *)text + 1) = 0LL;\n            v62 = (char *)(v81 + 2);\n            v81[2] = v82 - v59[5];\n          }\n          else\n          {\n            if ( v60 != 131 )\n            {\n              libmin_printf(\"%ld: undefined variable\\n\", line);\n              libmin_fail(-1);\n            }\n            v61 = text;\n            *((_QWORD *)text + 1) = 1LL;\n            v62 = (char *)(v61 + 2);\n            v61[2] = v59[5];\n          }\n          v63 = v59[3];\n          text = v62 + 8;\n          expr_type = v63;\n          *((_QWORD *)v62 + 1) = (v63 == 0) + 9LL;\n        }\n        goto LABEL_13;\n      }\n      v74 = 0LL;\n      next();\n      if ( token == 41 )\n        goto LABEL_122;\n      break;\n    case 140LL:\n      next();\n      if ( token != 40 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n        libmin_fail(-1);\n      }\n      next();\n      v55 = token;\n      expr_type = 1LL;\n      if ( token == 138 )\n      {\n        next();\n        v55 = token;\n      }\n      else if ( token == 134 )\n      {\n        next();\n        v55 = token;\n        expr_type = 0LL;\n      }\n      while ( v55 == 159 )\n      {\n        next();\n        expr_type += 2LL;\n        v55 = token;\n      }\n      if ( v55 != 41 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n        libmin_fail(-1);\n      }\n      next();\n      v56 = expr_type == 0;\n      v57 = text;\n      expr_type = 1LL;\n      v58 = (char *)text + 16;\n      *((_QWORD *)text + 1) = 1LL;\n      text = v58;\n      v57[2] = (-(__int64)v56 & 0xFFFFFFFFFFFFFFF9LL) + 8;\n      v8 = token;\n      goto LABEL_13;\n    case 148LL:\n      next();\n      expression(162LL);\n      if ( (unsigned __int64)(*(_QWORD *)text - 9LL) > 1 )\n      {\n        libmin_printf(\"%ld: bad address of\\n\", line);\n        libmin_fail(-1);\n      }\n      text = (char *)text - 8;\n      expr_type += 2LL;\n      v8 = token;\n      goto LABEL_13;\n    case 157LL:\n      next();\n      expression(162LL);\n      v8 = token;\n      expr_type = 1LL;\n      goto LABEL_13;\n    case 158LL:\n      next();\n      v53 = (char *)text;\n      if ( token == 128 )\n      {\n        *((_QWORD *)text + 1) = 1LL;\n        text = v53 + 16;\n        *((_QWORD *)v53 + 2) = -token_val;\n        next();\n      }\n      else\n      {\n        *((_QWORD *)text + 3) = 13LL;\n        text = v53 + 24;\n        *(__m128i *)(v53 + 8) = _mm_load_si128((const __m128i *)&xmmword_7940);\n        expression(162LL);\n        v54 = (char *)text + 8;\n        *((_QWORD *)text + 1) = 27LL;\n        text = v54;\n      }\n      expr_type = 1LL;\n      v8 = token;\n      goto LABEL_13;\n    case 159LL:\n      next();\n      expression(162LL);\n      if ( expr_type <= 1 )\n      {\n        libmin_printf(\"%ld: bad dereference\\n\", line);\n        libmin_fail(-1);\n      }\n      expr_type -= 2LL;\n      v52 = (char *)text + 8;\n      *((_QWORD *)text + 1) = (expr_type == 0) + 9LL;\n      v8 = token;\n      text = v52;\n      goto LABEL_13;\n    case 162LL:\n    case 163LL:\n      next();\n      expression(162LL);\n      v47 = text;\n      if ( *(_QWORD *)text == 10LL )\n      {\n        *(_QWORD *)text = 13LL;\n        v48 = (char *)(v47 + 1);\n        v47[1] = 10LL;\n      }\n      else\n      {\n        if ( *(_QWORD *)text != 9LL )\n        {\n          libmin_printf(\"%ld: bad lvalue of pre-increment\\n\", line);\n          libmin_fail(-1);\n        }\n        *(_QWORD *)text = 13LL;\n        v48 = (char *)(v47 + 1);\n        v47[1] = 9LL;\n      }\n      v49 = expr_type;\n      *(__m128i *)(v48 + 8) = _mm_load_si128((const __m128i *)&xmmword_7950);\n      if ( v49 > 2 )\n      {\n        *((_QWORD *)v48 + 3) = 8LL;\n        v51 = 11LL;\n        v50 = (v1 != 162) + 25LL;\n      }\n      else\n      {\n        *((_QWORD *)v48 + 3) = 1LL;\n        v50 = (v1 != 162) + 25LL;\n        v51 = 12LL - (v49 != 0);\n      }\n      *((_QWORD *)v48 + 4) = v50;\n      text = v48 + 40;\n      v8 = token;\n      *((_QWORD *)v48 + 5) = v51;\n      goto LABEL_13;\n    default:\n      goto LABEL_25;\n  }\n  do\n  {\n    while ( 1 )\n    {\n      ++v74;\n      expression(142LL);\n      v75 = (char *)text + 8;\n      *((_QWORD *)text + 1) = 13LL;\n      text = v75;\n      if ( token == 44 )\n        break;\n      if ( token == 41 )\n        goto LABEL_122;\n    }\n    next();\n  }\n  while ( token != 41 );\nLABEL_122:\n  next();\n  v76 = v59[4];\n  if ( v76 == 130 )\n  {\n    v83 = text;\n    text = (char *)text + 8;\n    v83[1] = v59[5];\n  }\n  else\n  {\n    if ( v76 != 129 )\n    {\n      libmin_printf(\"%ld: bad function call\\n\", line);\n      libmin_fail(-1);\n    }\n    v77 = text;\n    v78 = (char *)text + 16;\n    *((_QWORD *)text + 1) = 3LL;\n    text = v78;\n    v77[2] = v59[5];\n  }\n  if ( v74 )\n  {\n    v79 = text;\n    v80 = (char *)text + 16;\n    *((_QWORD *)text + 1) = 7LL;\n    text = v80;\n    v79[2] = v74;\n  }\n  v8 = token;\n  expr_type = v59[3];\nLABEL_13:\n  if ( level <= v8 )\n  {\n    do\n    {\n      v5 = expr_type;\n      if ( v8 == 142 )\n      {\n        next();\n        if ( (unsigned __int64)(*(_QWORD *)text - 9LL) > 1 )\n        {\n          libmin_printf(\"%ld: bad lvalue in assignment\\n\", line);\n          libmin_fail(-1);\n        }\n        *(_QWORD *)text = 13LL;\n        expression(142LL);\n        expr_type = v5;\n        v9 = (char *)text + 8;\n        *((_QWORD *)text + 1) = (v5 == 0) + 11LL;\n        text = v9;\n      }\n      else\n      {\n        switch ( v8 )\n        {\n          case 143LL:\n            next();\n            v40 = text;\n            *((_QWORD *)text + 1) = 4LL;\n            text = v40 + 2;\n            expression(142LL);\n            if ( token != 58 )\n            {\n              libmin_printf(\"%ld: missing colon in conditional\\n\", line);\n              libmin_fail(-1);\n            }\n            next();\n            v41 = text;\n            v40[2] = (char *)text + 24;\n            v41[1] = 2LL;\n            text = v41 + 2;\n            expression(143LL);\n            v41[2] = (char *)text + 8;\n            break;\n          case 144LL:\n            next();\n            v42 = text;\n            v43 = 145LL;\n            v46 = (char *)text + 16;\n            *((_QWORD *)text + 1) = 5LL;\n            text = v46;\n            goto LABEL_60;\n          case 145LL:\n            next();\n            v42 = text;\n            v43 = 146LL;\n            v44 = (char *)text + 16;\n            *((_QWORD *)text + 1) = 4LL;\n            text = v44;\nLABEL_60:\n            expression(v43);\n            v42[2] = (char *)text + 8;\n            expr_type = 1LL;\n            break;\n          case 146LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(147LL);\n            expr_type = 1LL;\n            v45 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 14LL;\n            text = v45;\n            break;\n          case 147LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(148LL);\n            expr_type = 1LL;\n            v29 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 15LL;\n            text = v29;\n            break;\n          case 148LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(149LL);\n            expr_type = 1LL;\n            v36 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 16LL;\n            text = v36;\n            break;\n          case 149LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(150LL);\n            expr_type = 1LL;\n            v34 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 17LL;\n            text = v34;\n            break;\n          case 150LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(151LL);\n            expr_type = 1LL;\n            v35 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 18LL;\n            text = v35;\n            break;\n          case 151LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(155LL);\n            expr_type = 1LL;\n            v30 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 19LL;\n            text = v30;\n            break;\n          case 152LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(155LL);\n            expr_type = 1LL;\n            v31 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 20LL;\n            text = v31;\n            break;\n          case 153LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(155LL);\n            expr_type = 1LL;\n            v32 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 21LL;\n            text = v32;\n            break;\n          case 154LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(155LL);\n            expr_type = 1LL;\n            v33 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 22LL;\n            text = v33;\n            break;\n          case 155LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(157LL);\n            expr_type = 1LL;\n            v24 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 23LL;\n            text = v24;\n            break;\n          case 156LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(157LL);\n            expr_type = 1LL;\n            v25 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 24LL;\n            text = v25;\n            break;\n          case 157LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(159LL);\n            expr_type = v5;\n            v26 = text;\n            if ( v5 > 2 )\n            {\n              v27 = text;\n              *((_QWORD *)text + 1) = 13LL;\n              v26 = v27 + 4;\n              v27[2] = 1LL;\n              v27[3] = 8LL;\n              v27[4] = 27LL;\n            }\n            v26[1] = 25LL;\n            text = v26 + 1;\n            break;\n          case 158LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(159LL);\n            v28 = (char *)text;\n            if ( v5 > 2 )\n            {\n              if ( expr_type == v5 )\n              {\n                si128 = _mm_load_si128((const __m128i *)&xmmword_7960);\n                v71 = _mm_load_si128((const __m128i *)&xmmword_7970);\n                text = (char *)text + 40;\n                *((_QWORD *)v28 + 5) = 28LL;\n                expr_type = 1LL;\n                *(__m128i *)(v28 + 8) = si128;\n                *(__m128i *)(v28 + 24) = v71;\n              }\n              else\n              {\n                v68 = _mm_load_si128((const __m128i *)&xmmword_7950);\n                v69 = _mm_load_si128((const __m128i *)&xmmword_7980);\n                text = (char *)text + 40;\n                *((_QWORD *)v28 + 5) = 26LL;\n                expr_type = v5;\n                *(__m128i *)(v28 + 8) = v68;\n                *(__m128i *)(v28 + 24) = v69;\n              }\n            }\n            else\n            {\n              *((_QWORD *)text + 1) = 26LL;\n              text = v28 + 8;\n              expr_type = v5;\n            }\n            break;\n          case 159LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(162LL);\n            expr_type = v5;\n            v22 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 27LL;\n            text = v22;\n            break;\n          case 160LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(162LL);\n            expr_type = v5;\n            v23 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 28LL;\n            text = v23;\n            break;\n          case 161LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(162LL);\n            expr_type = v5;\n            v21 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 29LL;\n            text = v21;\n            break;\n          case 162LL:\n          case 163LL:\n            v12 = text;\n            if ( *(_QWORD *)text == 9LL )\n            {\n              *(_QWORD *)text = 13LL;\n              v13 = (char *)(v12 + 1);\n              v12[1] = 9LL;\n            }\n            else\n            {\n              if ( *(_QWORD *)text != 10LL )\n              {\n                libmin_printf(\"%ld: bad value in increment\\n\", line);\n                libmin_fail(-1);\n              }\n              *(_QWORD *)text = 13LL;\n              v13 = (char *)(v12 + 1);\n              v12[1] = 10LL;\n            }\n            v14 = expr_type;\n            v15 = 8LL;\n            v16 = _mm_load_si128((const __m128i *)&xmmword_7950);\n            v17 = expr_type <= 2;\n            *(__m128i *)(v13 + 8) = v16;\n            if ( v17 )\n              v15 = 1LL;\n            v18 = token == 162;\n            *((_QWORD *)v13 + 3) = v15;\n            if ( v18 )\n            {\n              v19 = 25LL;\n              v20 = 26LL;\n            }\n            else\n            {\n              v19 = 26LL;\n              v20 = 25LL;\n            }\n            *((_QWORD *)v13 + 4) = v19;\n            *((_QWORD *)v13 + 5) = 12LL - (v14 != 0);\n            *((_QWORD *)v13 + 8) = v15;\n            *((_QWORD *)v13 + 9) = v20;\n            *((__m128i *)v13 + 3) = v16;\n            text = v13 + 72;\n            next();\n            break;\n          case 164LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(142LL);\n            if ( token != 93 )\n            {\n              libmin_printf(\"%ld: expected token: %ld\\n\", line, 93LL);\n              libmin_fail(-1);\n            }\n            next();\n            if ( v5 <= 2 )\n            {\n              if ( v5 != 2 )\n              {\n                libmin_printf(\"%ld: pointer type expected\\n\", line);\n                libmin_fail(-1);\n              }\n              v38 = text;\n              v39 = 10LL;\n              expr_type = 0LL;\n              *((_QWORD *)text + 1) = 25LL;\n            }\n            else\n            {\n              v37 = text;\n              *((_QWORD *)text + 1) = 13LL;\n              v38 = v37 + 4;\n              v37[2] = 1LL;\n              v37[3] = 8LL;\n              v37[4] = 27LL;\n              expr_type = v5 - 2;\n              v39 = 9LL;\n              v37[5] = 25LL;\n            }\n            v38[2] = v39;\n            text = v38 + 2;\n            break;\n          default:\n            libmin_printf(\"%ld: compiler error, token = %ld\\n\", line, v8);\n            libmin_fail(-1);\n        }\n      }\n      v8 = token;\n    }\n    while ( token >= level );\n  }\n}\n"}, "pseudo_normalize": "", "binary": "c-interp/c-interp.host.O3", "assembly": "<expression>:\nendbr64\npush   %r12\npush   %rbp\nmov    0x85d2(%rip),%rbp\npush   %rbx\nmov    %rdi,%rbx\ntest   %rbp,%rbp\nje     1fd0 <expression+0x260>\ncmp    $0x80,%rbp\nje     2003 <expression+0x293>\ncmp    $0xa3,%rbp\njg     2050 <expression+0x2e0>\ncmp    $0x7d,%rbp\njle    1dd0 <expression+0x60>\nlea    -0x7e(%rbp),%rax\ncmp    $0x25,%rax\nja     2050 <expression+0x2e0>\nlea    0x58d8(%rip),%rdx\nmovslq (%rdx,%rax,4),%rax\nadd    %rdx,%rax\nnotrack jmp *%rax\nnopw   0x0(%rax,%rax,1)\ncmp    $0x22,%rbp\nje     2cb0 <expression+0xf40>\ncmp    $0x28,%rbp\njne    1ecf <expression+0x15f>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x855e(%rip),%rax\nlea    -0x86(%rax),%rdx\ntest   $0xfffffffffffffffb,%rdx\njne    2db5 <expression+0x1045>\nxor    %ebp,%ebp\ncmp    $0x86,%rax\nsetne  %bpl\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x8530(%rip),%rax\ncmp    $0x9f,%rax\njne    1e4a <expression+0xda>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nadd    $0x2,%rbp\ncall   15a0 <next>\nmov    0x850e(%rip),%rax\ncmp    $0x9f,%rax\nje     1e30 <expression+0xc0>\ncmp    $0x29,%rax\nje     3128 <expression+0x13b8>\nmov    0x8475(%rip),%rsi\nlea    0x51b2(%rip),%rdi\nmov    $0x29,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    $0xa2,%edi\ncall   1d70 <expression>\nmov    %rbp,0x842f(%rip)\nmov    0x84c0(%rip),%rdx\ncmp    %rdx,%rbx\njg     1f9e <expression+0x22e>\nmov    0x8418(%rip),%rbp\ncmp    $0x8e,%rdx\nje     1f38 <expression+0x1c8>\nlea    -0x8f(%rdx),%rax\ncmp    $0x15,%rax\nja     2c8c <expression+0xf1c>\nlea    0x586b(%rip),%rdx\nmovslq (%rdx,%rax,4),%rax\nadd    %rdx,%rax\nnotrack jmp *%rax\ncmp    $0x21,%rbp\njne    2050 <expression+0x2e0>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    $0xa2,%edi\ncall   1d70 <expression>\nmov    0x8457(%rip),%rax\nmovq   $0x1,0x83bc(%rip)\nlea    0x20(%rax),%rdx\nmovq   $0xd,0x8(%rax)\nmov    %rdx,0x8439(%rip)\nmov    0x843a(%rip),%rdx\nmovq   $0x1,0x10(%rax)\nmovq   $0x0,0x18(%rax)\nmovq   $0x11,0x20(%rax)\njmp    1e90 <expression+0x120>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x8402(%rip),%rdx\nmov    (%rdx),%rax\nsub    $0x9,%rax\ncmp    $0x1,%rax\nja     1fa8 <expression+0x238>\nmovq   $0xd,(%rdx)\nmov    $0x8e,%edi\ncall   1d70 <expression>\nmov    0x83dd(%rip),%rdx\ncmp    $0x1,%rbp\nmov    $0xb,%eax\nadc    $0x0,%rax\nmov    %rbp,0x8339(%rip)\nlea    0x8(%rdx),%rcx\nmov    %rax,0x8(%rdx)\nmov    %rcx,0x83ba(%rip)\nmov    0x83bb(%rip),%rdx\ncmp    %rbx,%rdx\njge    1e99 <expression+0x129>\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopl   0x0(%rax,%rax,1)\nmov    0x8321(%rip),%rsi\nlea    0x531a(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\njmp    1f5a <expression+0x1ea>\nnopl   0x0(%rax)\nmov    0x82f9(%rip),%rsi\nlea    0x529a(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x835a(%rip),%rbp\ncmp    $0x80,%rbp\njne    1d98 <expression+0x28>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x8337(%rip),%rax\nmovq   $0x1,0x829c(%rip)\nlea    0x10(%rax),%rdx\nmovq   $0x1,0x8(%rax)\nmov    %rdx,0x8319(%rip)\nmov    0x8292(%rip),%rdx\nmov    %rdx,0x10(%rax)\nmov    0x830f(%rip),%rdx\njmp    1e90 <expression+0x120>\ncs nopw 0x0(%rax,%rax,1)\nmov    0x8279(%rip),%rsi\nlea    0x502c(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x82da(%rip),%rdx\njmp    1e90 <expression+0x120>\nnopl   0x0(%rax,%rax,1)\nmov    0x82c1(%rip),%rdx\nmov    (%rdx),%rax\ncmp    $0x9,%rax\nje     2f31 <expression+0x11c1>\ncmp    $0xa,%rax\njne    2d8a <expression+0x101a>\nmovq   $0xd,(%rdx)\nlea    0x8(%rdx),%rax\nmovq   $0xa,0x8(%rdx)\nmov    0x8200(%rip),%rcx\nmov    $0x8,%edx\nmov    $0x1,%esi\nmovdqa 0x5886(%rip),%xmm1\ncmp    $0x2,%rcx\nmovups %xmm1,0x8(%rax)\ncmovle %rsi,%rdx\ncmpq   $0xa2,0x826f(%rip)\nmov    %rdx,0x18(%rax)\nje     2f61 <expression+0x11f1>\nneg    %rcx\nmov    $0x1a,%edi\nmov    $0x19,%esi\nsbb    %rcx,%rcx\nmovdqa %xmm1,%xmm2\nadd    $0xc,%rcx\nmov    %rdi,0x20(%rax)\nmov    %rcx,0x28(%rax)\nmov    %rdx,0x40(%rax)\nlea    0x48(%rax),%rdx\nmov    %rsi,0x48(%rax)\nmovups %xmm2,0x30(%rax)\nxor    %eax,%eax\nmov    %rdx,0x8224(%rip)\ncall   15a0 <next>\njmp    1f8e <expression+0x21e>\nxchg   %ax,%ax\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x820a(%rip),%rax\nmov    $0xa2,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x81fa(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x81e6(%rip),%rax\nmov    %rbp,0x814f(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x1d,0x8(%rax)\nmov    %rdx,0x81cc(%rip)\njmp    1f8e <expression+0x21e>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x81b2(%rip),%rax\nmov    $0xa2,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x81a2(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x818e(%rip),%rax\nmov    %rbp,0x80f7(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x1b,0x8(%rax)\nmov    %rdx,0x8174(%rip)\njmp    1f8e <expression+0x21e>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x815a(%rip),%rax\nmov    $0xa2,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x814a(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x8136(%rip),%rax\nmov    %rbp,0x809f(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x1c,0x8(%rax)\nmov    %rdx,0x811c(%rip)\njmp    1f8e <expression+0x21e>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x8102(%rip),%rax\nmov    $0x9d,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x80f2(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x80de(%rip),%rax\nmovq   $0x1,0x8043(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x17,0x8(%rax)\nmov    %rdx,0x80c0(%rip)\njmp    1f8e <expression+0x21e>\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x80aa(%rip),%rax\nmov    $0x9d,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x809a(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x8086(%rip),%rax\nmovq   $0x1,0x7feb(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x18,0x8(%rax)\nmov    %rdx,0x8068(%rip)\njmp    1f8e <expression+0x21e>\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x8052(%rip),%rax\nmov    $0x9f,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x8042(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    %rbp,0x7f9e(%rip)\nmov    0x8027(%rip),%rax\ncmp    $0x2,%rbp\njle    2352 <expression+0x5e2>\nmov    0x801a(%rip),%rdx\nmovq   $0xd,0x8(%rdx)\nlea    0x20(%rdx),%rax\nmovq   $0x1,0x10(%rdx)\nmovq   $0x8,0x18(%rdx)\nmovq   $0x1b,0x20(%rdx)\nlea    0x8(%rax),%rdx\nmovq   $0x19,0x8(%rax)\nmov    %rdx,0x7fe3(%rip)\njmp    1f8e <expression+0x21e>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7fca(%rip),%rax\nmov    $0x9f,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7fba(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x7fa6(%rip),%rax\ncmp    $0x2,%rbp\njg     2d18 <expression+0xfa8>\nlea    0x8(%rax),%rdx\nmovq   $0x1a,0x8(%rax)\nmov    %rdx,0x7f89(%rip)\nmov    %rbp,0x7ef2(%rip)\njmp    1f8e <expression+0x21e>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7f6a(%rip),%rax\nmov    $0x94,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7f5a(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x7f46(%rip),%rax\nmovq   $0x1,0x7eab(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0xf,0x8(%rax)\nmov    %rdx,0x7f28(%rip)\njmp    1f8e <expression+0x21e>\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7f12(%rip),%rax\nmov    $0x9b,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7f02(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x7eee(%rip),%rax\nmovq   $0x1,0x7e53(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x13,0x8(%rax)\nmov    %rdx,0x7ed0(%rip)\njmp    1f8e <expression+0x21e>\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7eba(%rip),%rax\nmov    $0x9b,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7eaa(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x7e96(%rip),%rax\nmovq   $0x1,0x7dfb(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x14,0x8(%rax)\nmov    %rdx,0x7e78(%rip)\njmp    1f8e <expression+0x21e>\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7e62(%rip),%rax\nmov    $0x9b,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7e52(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x7e3e(%rip),%rax\nmovq   $0x1,0x7da3(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x15,0x8(%rax)\nmov    %rdx,0x7e20(%rip)\njmp    1f8e <expression+0x21e>\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7e0a(%rip),%rax\nmov    $0x9b,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7dfa(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x7de6(%rip),%rax\nmovq   $0x1,0x7d4b(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x16,0x8(%rax)\nmov    %rdx,0x7dc8(%rip)\njmp    1f8e <expression+0x21e>\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7db2(%rip),%rax\nmov    $0x96,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7da2(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x7d8e(%rip),%rax\nmovq   $0x1,0x7cf3(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x11,0x8(%rax)\nmov    %rdx,0x7d70(%rip)\njmp    1f8e <expression+0x21e>\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7d5a(%rip),%rax\nmov    $0x97,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7d4a(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x7d36(%rip),%rax\nmovq   $0x1,0x7c9b(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x12,0x8(%rax)\nmov    %rdx,0x7d18(%rip)\njmp    1f8e <expression+0x21e>\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7d02(%rip),%rax\nmov    $0x95,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7cf2(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x7cde(%rip),%rax\nmovq   $0x1,0x7c43(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x10,0x8(%rax)\nmov    %rdx,0x7cc0(%rip)\njmp    1f8e <expression+0x21e>\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7caa(%rip),%rax\nmov    $0x8e,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7c9a(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\ncmpq   $0x5d,0x7c8d(%rip)\nje     2f55 <expression+0x11e5>\nmov    0x7c00(%rip),%rsi\nlea    0x493d(%rip),%rdi\nmov    $0x5d,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nlea    -0x2(%rbp),%r12\ncmp    $0x2,%rbp\njle    2d60 <expression+0xff0>\nmov    0x7c46(%rip),%rdx\nmovq   $0xd,0x8(%rdx)\nlea    0x20(%rdx),%rax\nmovq   $0x1,0x10(%rdx)\nmovq   $0x8,0x18(%rdx)\nmovq   $0x1b,0x20(%rdx)\nmov    %r12,0x7b8b(%rip)\nmov    $0x9,%ecx\nmovq   $0x19,0x8(%rax)\nlea    0x10(%rax),%rdx\nmov    %rcx,0x10(%rax)\nmov    %rdx,0x7bff(%rip)\njmp    1f8e <expression+0x21e>\nxchg   %ax,%ax\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7bea(%rip),%r12\nmov    $0x8e,%edi\nmovq   $0x4,0x8(%r12)\nlea    0x10(%r12),%rax\nmov    %rax,0x7bd0(%rip)\ncall   1d70 <expression>\ncmpq   $0x3a,0x7bcb(%rip)\nje     2f49 <expression+0x11d9>\nmov    0x7b3e(%rip),%rsi\nlea    0x4b57(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x7b97(%rip),%rbp\nmov    $0x8f,%edi\nlea    0x18(%rbp),%rax\nmov    %rax,0x10(%r12)\nlea    0x10(%rbp),%rax\nmovq   $0x2,0x8(%rbp)\nmov    %rax,0x7b76(%rip)\ncall   1d70 <expression>\nmov    0x7b6a(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x10(%rbp)\njmp    1f8e <expression+0x21e>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7b4a(%rip),%rbp\nmov    $0x92,%edi\nlea    0x10(%rbp),%rax\nmovq   $0x4,0x8(%rbp)\nmov    %rax,0x7b32(%rip)\ncall   1d70 <expression>\nmov    0x7b26(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x10(%rbp)\nmovq   $0x1,0x7a83(%rip)\njmp    1f8e <expression+0x21e>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7afa(%rip),%rax\nmov    $0x93,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7aea(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d70 <expression>\nmov    0x7ad6(%rip),%rax\nmovq   $0x1,0x7a3b(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0xe,0x8(%rax)\nmov    %rdx,0x7ab8(%rip)\njmp    1f8e <expression+0x21e>\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7aa2(%rip),%rbp\nmov    $0x91,%edi\nlea    0x10(%rbp),%rax\nmovq   $0x5,0x8(%rbp)\nmov    %rax,0x7a8a(%rip)\njmp    2816 <expression+0xaa6>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    $0xa2,%edi\ncall   1d70 <expression>\nmov    0x7a6d(%rip),%rdx\nmov    (%rdx),%rax\ncmp    $0xa,%rax\nje     2e4c <expression+0x10dc>\ncmp    $0x9,%rax\njne    2fac <expression+0x123c>\nmovq   $0xd,(%rdx)\nlea    0x8(%rdx),%rax\nmovq   $0x9,0x8(%rdx)\nmovdqa 0x5043(%rip),%xmm0\nmov    0x79a4(%rip),%rcx\nmovups %xmm0,0x8(%rax)\ncmp    $0x2,%rcx\njg     2f7e <expression+0x120e>\nxor    %edx,%edx\ncmp    $0xa2,%rbp\nmovq   $0x1,0x18(%rax)\nsetne  %dl\nadd    $0x19,%rdx\nneg    %rcx\nsbb    %rcx,%rcx\nadd    $0xc,%rcx\nmov    %rdx,0x20(%rax)\nlea    0x28(%rax),%rdx\nmov    %rdx,0x79f5(%rip)\nmov    0x79f6(%rip),%rdx\nmov    %rcx,0x28(%rax)\njmp    1e90 <expression+0x120>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    $0xa2,%edi\ncall   1d70 <expression>\nmov    0x793d(%rip),%rax\ncmp    $0x1,%rax\njle    2f06 <expression+0x1196>\nsub    $0x2,%rax\nmov    %rax,0x7928(%rip)\nmov    0x79b1(%rip),%rdx\ncmp    $0x1,%rax\nmov    $0x9,%eax\nadc    $0x0,%rax\nlea    0x8(%rdx),%rcx\nmov    %rax,0x8(%rdx)\nmov    0x799d(%rip),%rdx\nmov    %rcx,0x798e(%rip)\njmp    1e90 <expression+0x120>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x797b(%rip),%rax\ncmpq   $0x80,0x7978(%rip)\nje     2e64 <expression+0x10f4>\nmovq   $0xd,0x18(%rax)\nlea    0x18(%rax),%rdx\nmov    $0xa2,%edi\nmovdqa 0x4f49(%rip),%xmm0\nmov    %rdx,0x794a(%rip)\nmovups %xmm0,0x8(%rax)\ncall   1d70 <expression>\nmov    0x793a(%rip),%rax\nlea    0x8(%rax),%rdx\nmovq   $0x1b,0x8(%rax)\nmov    %rdx,0x7927(%rip)\nmovq   $0x1,0x788c(%rip)\nmov    0x791d(%rip),%rdx\njmp    1e90 <expression+0x120>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    $0xa2,%edi\ncall   1d70 <expression>\nmov    0x7900(%rip),%rdx\nmovq   $0x1,0x785d(%rip)\njmp    1e90 <expression+0x120>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    $0xa2,%edi\ncall   1d70 <expression>\nmov    0x78d0(%rip),%rdx\nmov    (%rdx),%rax\nsub    $0x9,%rax\ncmp    $0x1,%rax\nja     2e28 <expression+0x10b8>\nsub    $0x8,%rdx\nmov    %rdx,0x78b4(%rip)\naddq   $0x2,0x781c(%rip)\nmov    0x78ad(%rip),%rdx\njmp    1e90 <expression+0x120>\nxor    %eax,%eax\ncall   15a0 <next>\ncmpq   $0x28,0x7899(%rip)\nje     2e91 <expression+0x1121>\nmov    0x780c(%rip),%rsi\nlea    0x4549(%rip),%rdi\nmov    $0x28,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x7868(%rip),%rax\nmovq   $0x1,0x77c5(%rip)\ncmp    $0x8a,%rax\nje     30a9 <expression+0x1339>\ncmp    $0x86,%rax\njne    2b26 <expression+0xdb6>\njmp    3134 <expression+0x13c4>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\naddq   $0x2,0x7799(%rip)\nmov    0x782a(%rip),%rax\ncmp    $0x9f,%rax\nje     2b10 <expression+0xda0>\ncmp    $0x29,%rax\nje     2fa0 <expression+0x1230>\nmov    0x7791(%rip),%rsi\nlea    0x44ce(%rip),%rdi\nmov    $0x29,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\ncmpq   $0x1,0x7754(%rip)\nmov    0x77dd(%rip),%rdx\nmovq   $0x1,0x7742(%rip)\nsbb    %rax,%rax\nand    $0xfffffffffffffff9,%rax\nlea    0x10(%rdx),%rcx\nmovq   $0x1,0x8(%rdx)\nadd    $0x8,%rax\nmov    %rcx,0x77b4(%rip)\nmov    %rax,0x10(%rdx)\nmov    0x77b1(%rip),%rdx\njmp    1e90 <expression+0x120>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x779e(%rip),%rdx\nmov    0x7727(%rip),%rbp\ncmp    $0x28,%rdx\nje     2fd7 <expression+0x1267>\nmov    0x20(%rbp),%rax\ncmp    $0x80,%rax\nje     2ed4 <expression+0x1164>\ncmp    $0x84,%rax\nje     30bc <expression+0x134c>\ncmp    $0x83,%rax\njne    30e3 <expression+0x1373>\nmov    0x7756(%rip),%rax\nmovq   $0x1,0x8(%rax)\nmov    0x28(%rbp),%rsi\nlea    0x10(%rax),%rcx\nmov    %rsi,0x10(%rax)\nmov    0x18(%rbp),%rax\nlea    0x8(%rcx),%rsi\nmov    %rsi,0x7733(%rip)\ncmp    $0x1,%rax\nmov    %rax,0x7698(%rip)\nmov    $0x9,%eax\nadc    $0x0,%rax\nmov    %rax,0x8(%rcx)\njmp    1e90 <expression+0x120>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    $0xa2,%edi\ncall   1d70 <expression>\nmov    0x76fe(%rip),%rax\nmovq   $0x1,0x7663(%rip)\nlea    0x20(%rax),%rdx\nmovq   $0xd,0x8(%rax)\nmov    %rdx,0x76e0(%rip)\nmov    0x76e1(%rip),%rdx\nmovq   $0x1,0x10(%rax)\nmovq   $0xffffffffffffffff,0x18(%rax)\nmovq   $0xf,0x20(%rax)\njmp    1e90 <expression+0x120>\nmov    0x763d(%rip),%rsi\nlea    0x467e(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\njmp    1f8e <expression+0x21e>\nmov    0x7691(%rip),%rax\nlea    0x10(%rax),%rdx\nmovq   $0x1,0x8(%rax)\nmov    %rdx,0x767e(%rip)\nmov    0x75f7(%rip),%rdx\nmov    %rdx,0x10(%rax)\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x766a(%rip),%rdx\ncmp    $0x22,%rdx\nje     2cd8 <expression+0xf68>\nmov    0x763d(%rip),%rax\nmovq   $0x2,0x75ba(%rip)\nadd    $0x8,%rax\nand    $0xfffffffffffffff8,%rax\nmov    %rax,0x7623(%rip)\njmp    1e90 <expression+0x120>\nnopw   0x0(%rax,%rax,1)\ncmp    %rbp,0x7599(%rip)\nlea    0x28(%rax),%rdx\nje     2e9d <expression+0x112d>\nmovdqa 0x4c1f(%rip),%xmm3\nmovdqa 0x4c47(%rip),%xmm4\nmov    %rdx,0x7608(%rip)\nmovq   $0x1a,0x28(%rax)\nmov    %rbp,0x7569(%rip)\nmovups %xmm3,0x8(%rax)\nmovups %xmm4,0x18(%rax)\njmp    1f8e <expression+0x21e>\nnopl   0x0(%rax)\njne    2dfd <expression+0x108d>\nmov    0x75db(%rip),%rax\nmov    $0xa,%ecx\nmovq   $0x0,0x753b(%rip)\nmovq   $0x19,0x8(%rax)\njmp    273a <expression+0x9ca>\nmov    0x753f(%rip),%rsi\nlea    0x4307(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x7598(%rip),%rax\njmp    20b1 <expression+0x341>\nmov    $0x8e,%edi\ncall   1d70 <expression>\ncmpq   $0x29,0x7589(%rip)\nje     3115 <expression+0x13a5>\nmov    0x74fc(%rip),%rsi\nmov    $0x29,%edx\nlea    0x4234(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x7558(%rip),%rdx\njmp    1e90 <expression+0x120>\nmov    0x74cc(%rip),%rsi\nlea    0x42b1(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x7525(%rip),%rax\njmp    2726 <expression+0x9b6>\nmov    0x74a1(%rip),%rsi\nlea    0x423f(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\njmp    2a94 <expression+0xd24>\nmovq   $0xd,(%rdx)\nlea    0x8(%rdx),%rax\nmovq   $0xa,0x8(%rdx)\njmp    2905 <expression+0xb95>\nlea    0x10(%rax),%rdx\nmovq   $0x1,0x8(%rax)\nmov    %rdx,0x74d1(%rip)\nmov    0x744a(%rip),%rdx\nneg    %rdx\nmov    %rdx,0x10(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\njmp    2a21 <expression+0xcb1>\nxor    %eax,%eax\ncall   15a0 <next>\njmp    2ae1 <expression+0xd71>\nmovdqa 0x4abb(%rip),%xmm5\nmovdqa 0x4ac3(%rip),%xmm0\nmov    %rdx,0x7494(%rip)\nmovq   $0x1c,0x28(%rax)\nmovq   $0x1,0x73f1(%rip)\nmovups %xmm5,0x8(%rax)\nmovups %xmm0,0x18(%rax)\njmp    1f8e <expression+0x21e>\nmov    0x746d(%rip),%rax\nmovq   $0x1,0x73d2(%rip)\nlea    0x10(%rax),%rcx\nmovq   $0x1,0x8(%rax)\nmov    %rcx,0x744f(%rip)\nmov    0x28(%rbp),%rcx\nmov    %rcx,0x10(%rax)\njmp    1e90 <expression+0x120>\nmov    0x73c3(%rip),%rsi\nlea    0x414b(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x738c(%rip),%rax\njmp    2990 <expression+0xc20>\nmovq   $0xd,(%rdx)\nlea    0x8(%rdx),%rax\nmovq   $0x9,0x8(%rdx)\njmp    20b1 <expression+0x341>\nxor    %eax,%eax\ncall   15a0 <next>\njmp    27aa <expression+0xa3a>\nxor    %eax,%eax\ncall   15a0 <next>\njmp    26ed <expression+0x97d>\nneg    %rcx\nmov    $0x19,%edi\nmov    $0x1a,%esi\nsbb    %rcx,%rcx\nmovdqa %xmm1,%xmm2\nadd    $0xc,%rcx\njmp    2103 <expression+0x393>\nxor    %edx,%edx\ncmp    $0xa2,%rbp\nmovq   $0x8,0x18(%rax)\nmov    $0xb,%ecx\nsetne  %dl\nadd    $0x19,%rdx\njmp    2944 <expression+0xbd4>\nxor    %eax,%eax\ncall   15a0 <next>\njmp    2b5c <expression+0xdec>\nmov    0x731d(%rip),%rsi\nlea    0x42ee(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x7376(%rip),%rax\njmp    2905 <expression+0xb95>\nxor    %eax,%eax\nxor    %r12d,%r12d\ncall   15a0 <next>\ncmpq   $0x29,0x7367(%rip)\nje     302a <expression+0x12ba>\nmov    $0x8e,%edi\nadd    $0x1,%r12\ncall   1d70 <expression>\nmov    0x7348(%rip),%rax\nlea    0x8(%rax),%rdx\nmovq   $0xd,0x8(%rax)\nmov    0x733d(%rip),%rax\nmov    %rdx,0x732e(%rip)\ncmp    $0x2c,%rax\nje     3152 <expression+0x13e2>\ncmp    $0x29,%rax\njne    2feb <expression+0x127b>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x20(%rbp),%rax\ncmp    $0x82,%rax\nje     3190 <expression+0x1420>\ncmp    $0x81,%rax\njne    316c <expression+0x13fc>\nmov    0x72f4(%rip),%rax\nlea    0x10(%rax),%rdx\nmovq   $0x3,0x8(%rax)\nmov    %rdx,0x72e1(%rip)\nmov    0x28(%rbp),%rdx\nmov    %rdx,0x10(%rax)\ntest   %r12,%r12\nje     3092 <expression+0x1322>\nmov    0x72cd(%rip),%rax\nlea    0x10(%rax),%rdx\nmovq   $0x7,0x8(%rax)\nmov    %rdx,0x72ba(%rip)\nmov    %r12,0x10(%rax)\nmov    0x18(%rbp),%rax\nmov    0x72b3(%rip),%rdx\nmov    %rax,0x7214(%rip)\njmp    1e90 <expression+0x120>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7299(%rip),%rax\njmp    2b26 <expression+0xdb6>\nmov    0x7285(%rip),%rax\nmov    0x71e6(%rip),%rsi\nmovq   $0x0,0x8(%rax)\nsub    0x28(%rbp),%rsi\nlea    0x10(%rax),%rcx\nmov    %rsi,0x10(%rax)\njmp    2c06 <expression+0xe96>\nmov    0x71e6(%rip),%rsi\nlea    0x3f55(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x723f(%rip),%rcx\nmov    0x7240(%rip),%rdx\njmp    2c06 <expression+0xe96>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x722d(%rip),%rdx\njmp    1e90 <expression+0x120>\nxor    %eax,%eax\ncall   15a0 <next>\njmp    1e78 <expression+0x108>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x720e(%rip),%rax\nmovq   $0x0,0x716b(%rip)\njmp    2b26 <expression+0xdb6>\nxor    %eax,%eax\ncall   15a0 <next>\ncmpq   $0x29,0x71ef(%rip)\njne    2feb <expression+0x127b>\njmp    302a <expression+0x12ba>\nmov    0x715d(%rip),%rsi\nlea    0x3eb4(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\njmp    306f <expression+0x12ff>\nmov    0x71b1(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x71a6(%rip)\nmov    0x28(%rbp),%rdx\nmov    %rdx,0x8(%rax)\njmp    306f <expression+0x12ff>\nnop\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "function_body", "content": "void function_body() {\n    // type func_name (...) {...}\n    //                   -->|   |<--\n\n    // ... {\n    // 1. local declarations\n    // 2. statements\n    // }\n\n    long pos_local; // position of local variables on the stack.\n    long type;\n    pos_local = index_of_bp;\n\n    while (token == Int || token == Char) {\n        // local variable declaration, just like global ones.\n        basetype = (token == Int) ? INT : CHAR;\n        match(token);\n\n        while (token != ';') {\n            type = basetype;\n            while (token == Mul) {\n                match(Mul);\n                type = type + PTR;\n            }\n\n            if (token != Id) {\n                // invalid declaration\n                libmin_printf(\"%ld: bad local declaration\\n\", line);\n                libmin_fail(-1);\n            }\n            if (current_id[Class] == Loc) {\n                // identifier exists\n                libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n                libmin_fail(-1);\n            }\n            match(Id);\n\n            // store the local variable\n            current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;\n            current_id[BType]  = current_id[Type];  current_id[Type]   = type;\n            current_id[BValue] = current_id[Value]; current_id[Value]  = ++pos_local;   // index of current parameter\n\n            if (token == ',') {\n                match(',');\n            }\n        }\n        match(';');\n    }\n\n    // save the stack size for local variables\n    *++text = ENT;\n    *++text = pos_local - index_of_bp;\n\n    // statements\n    while (token != '}') {\n        statement();\n    }\n\n    // emit code for leaving the sub function\n    *++text = LEV;\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O3.pseudo", "function_name": "function_body", "address": "0x37f0", "label": "function_body", "content": "void __cdecl function_body()\n{\n  __int64 v0; // rdx\n  bool v1; // al\n  __int64 v2; // rbp\n  __int64 v3; // rax\n  __int64 v4; // rbx\n  __int64 *v5; // rax\n  __int64 v6; // rdx\n  __int64 v7; // rdx\n  __int64 v8; // rdx\n  __int64 v9; // rbp\n  _QWORD *v10; // rcx\n  _QWORD *v11; // rax\n\n  v0 = token;\n  v1 = token == 138;\n  v2 = index_of_bp;\n  if ( ((token - 134) & 0xFFFFFFFFFFFFFFFBLL) != 0 )\n  {\n    v9 = 0LL;\n  }\n  else\n  {\n    do\n    {\n      basetype = v1;\n      while ( 1 )\n      {\n        next();\n        v3 = token;\n        if ( token == 59 )\n          break;\n        while ( 1 )\n        {\n          v4 = basetype;\n          if ( v3 == 159 )\n          {\n            do\n            {\n              v4 += 2LL;\n              next();\n              v3 = token;\n            }\n            while ( token == 159 );\n          }\n          if ( v3 != 133 )\n          {\n            libmin_printf(\"%ld: bad local declaration\\n\", line);\n            libmin_fail(-1);\n          }\n          if ( current_id[4] == 132 )\n          {\n            libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n            libmin_fail(-1);\n          }\n          if ( token != 133 )\n          {\n            libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n            libmin_fail(-1);\n          }\n          next();\n          v5 = current_id;\n          ++v2;\n          v6 = current_id[4];\n          current_id[4] = 132LL;\n          v5[7] = v6;\n          v7 = v5[3];\n          v5[3] = v4;\n          v5[6] = v7;\n          v8 = v5[5];\n          v5[5] = v2;\n          v5[8] = v8;\n          v3 = token;\n          if ( token == 44 )\n            break;\n          if ( token == 59 )\n            goto LABEL_13;\n        }\n      }\nLABEL_13:\n      next();\n      v0 = token;\n      v1 = token == 138;\n    }\n    while ( ((token - 134) & 0xFFFFFFFFFFFFFFFBLL) == 0 );\n    v9 = v2 - index_of_bp;\n  }\n  v10 = text;\n  v11 = (char *)text + 16;\n  *((_QWORD *)text + 1) = 6LL;\n  text = v11;\n  v10[2] = v9;\n  if ( v0 != 125 )\n  {\n    do\n      statement();\n    while ( token != 125 );\n    v11 = text;\n  }\n  v11[1] = 8LL;\n  text = v11 + 1;\n}\n"}, "pseudo_normalize": "void function_body() {\n  long long v0;\n  bool v1;\n  long long v2;\n  long long v3;\n  long long v4;\n  long long *v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  uint64_t *v10;\n  uint64_t *v11;\n  v0 = token;\n  v1 = token == 138;\n  v2 = index_of_bp;\n  if (((token - 134) & 18446744073709551611LL) != 0) {\n    v9 = 0LL;\n  } else {\n    do {\n      basetype = v1;\n      while (1) {\n        next();\n        v3 = token;\n        if (token == 59) break;\n        while (1) {\n          v4 = basetype;\n          if (v3 == 159) {\n            do {\n              v4 += 2LL;\n              next();\n              v3 = token;\n            } while (token == 159);\n          }\n          if (v3 != 133) {\n            libmin_printf(\"%ld: bad local declaration\\n\", line);\n            libmin_fail(-1);\n          }\n          if (current_id[4] == 132) {\n            libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n            libmin_fail(-1);\n          }\n          if (token != 133) {\n            libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n            libmin_fail(-1);\n          }\n          next();\n          v5 = current_id;\n          ++v2;\n          v6 = current_id[4];\n          current_id[4] = 132LL;\n          v5[7] = v6;\n          v7 = v5[3];\n          v5[3] = v4;\n          v5[6] = v7;\n          v8 = v5[5];\n          v5[5] = v2;\n          v5[8] = v8;\n          v3 = token;\n          if (token == 44) break;\n          if (token == 59) goto LABEL_13;\n        }\n      }\n    LABEL_13:\n      next();\n      v0 = token;\n      v1 = token == 138;\n    } while (((token - 134) & 18446744073709551611LL) == 0);\n    v9 = v2 - index_of_bp;\n  }\n  v10 = text;\n  v11 = (char *)text + 16;\n  *((uint64_t *)text + 1) = 6LL;\n  text = v11;\n  v10[2] = v9;\n  if (v0 != 125) {\n    do statement();\n    while (token != 125);\n    v11 = text;\n  }\n  v11[1] = 8LL;\n  text = v11 + 1;\n}", "binary": "c-interp/c-interp.host.O3", "assembly": "<function_body>:\nendbr64\nmov    0x6b55(%rip),%rdx\npush   %r14\npush   %r13\ncmp    $0x8a,%rdx\nlea    -0x86(%rdx),%rcx\npush   %r12\nsete   %al\npush   %rbp\nmov    0x6a96(%rip),%rbp\npush   %rbx\ntest   $0xfffffffffffffffb,%rcx\njne    3a08 <function_body+0x218>\nlea    0x38e2(%rip),%r13\nlea    0x3b52(%rip),%r14\nlea    0x37d7(%rip),%r12\nnopl   (%rax)\nmovzbl %al,%eax\nmov    %rax,0x6a76(%rip)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x6af8(%rip),%rax\ncmp    $0x3b,%rax\nje     3949 <function_body+0x159>\nmov    0x6a57(%rip),%rbx\ncmp    $0x9f,%rax\njne    3892 <function_body+0xa2>\nnopl   0x0(%rax)\nxor    %eax,%eax\nadd    $0x2,%rbx\ncall   15a0 <next>\nmov    0x6ac6(%rip),%rax\ncmp    $0x9f,%rax\nje     3878 <function_body+0x88>\ncmp    $0x85,%rax\nje     38b5 <function_body+0xc5>\nmov    0x6a2f(%rip),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x6a24(%rip),%rax\ncmpq   $0x84,0x20(%rax)\nje     39e8 <function_body+0x1f8>\ncmpq   $0x85,0x6a7b(%rip)\nje     39d8 <function_body+0x1e8>\nmov    0x69ee(%rip),%rsi\nmov    %r12,%rdi\nmov    $0x85,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x69de(%rip),%rax\nadd    $0x1,%rbp\nmov    0x20(%rax),%rdx\nmovq   $0x84,0x20(%rax)\nmov    %rdx,0x38(%rax)\nmov    0x18(%rax),%rdx\nmov    %rbx,0x18(%rax)\nmov    %rdx,0x30(%rax)\nmov    0x28(%rax),%rdx\nmov    %rbp,0x28(%rax)\nmov    %rdx,0x40(%rax)\nmov    0x6a1b(%rip),%rax\ncmp    $0x2c,%rax\nje     384a <function_body+0x5a>\ncmp    $0x3b,%rax\njne    3862 <function_body+0x72>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x69f9(%rip),%rdx\ncmp    $0x8a,%rdx\nlea    -0x86(%rdx),%rcx\nsete   %al\ntest   $0xfffffffffffffffb,%rcx\nje     3840 <function_body+0x50>\nsub    0x6934(%rip),%rbp\nmov    0x69c5(%rip),%rcx\nlea    0x10(%rcx),%rax\nmovq   $0x6,0x8(%rcx)\nmov    %rax,0x69b2(%rip)\nmov    %rbp,0x10(%rcx)\ncmp    $0x7d,%rdx\nje     39b8 <function_body+0x1c8>\nxor    %eax,%eax\ncall   31b0 <statement>\ncmpq   $0x7d,0x69a1(%rip)\njne    39a0 <function_body+0x1b0>\nmov    0x6990(%rip),%rax\nlea    0x8(%rax),%rdx\nmovq   $0x8,0x8(%rax)\npop    %rbx\nmov    %rdx,0x697c(%rip)\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\njmp    38fb <function_body+0x10b>\nnopl   0x0(%rax)\nmov    0x68e1(%rip),%rsi\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\njmp    38ca <function_body+0xda>\nxor    %ebp,%ebp\njmp    397c <function_body+0x18c>\nnop\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "function_declaration", "content": "void function_declaration() {\n    // type func_name (...) {...}\n    //               | this part\n\n    match('(');\n    function_parameter();\n    match(')');\n    match('{');\n    function_body();\n    //match('}');\n\n    // unwind local variable declarations for all local variables.\n    current_id = symbols;\n    while (current_id[Token]) {\n        if (current_id[Class] == Loc) {\n            current_id[Class] = current_id[BClass];\n            current_id[Type]  = current_id[BType];\n            current_id[Value] = current_id[BValue];\n        }\n        current_id = current_id + IdSize;\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O3.pseudo", "function_name": "function_declaration", "address": "0x3a10", "label": "function_declaration", "content": "void __cdecl function_declaration()\n{\n  bool v0; // zf\n  __int64 *v1; // rax\n  __int64 *v2; // rdx\n  __m128i v3; // xmm0\n  __int64 v4; // rcx\n\n  if ( token != 40 )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n    libmin_fail(-1);\n  }\n  next();\n  function_parameter();\n  if ( token != 41 )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n    libmin_fail(-1);\n  }\n  next();\n  if ( token != 123 )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, 123LL);\n    libmin_fail(-1);\n  }\n  next();\n  function_body();\n  v0 = *(_QWORD *)symbols == 0LL;\n  current_id = (__int64 *)symbols;\n  if ( !v0 )\n  {\n    v1 = (__int64 *)((char *)symbols + 72);\n    do\n    {\n      while ( 1 )\n      {\n        v2 = v1;\n        if ( *(v1 - 5) == 132 )\n          break;\n        v1 += 9;\n        if ( !*(v1 - 9) )\n          goto LABEL_11;\n      }\n      v3 = _mm_loadu_si128((const __m128i *)(v1 - 3));\n      v4 = *(v1 - 1);\n      v1 += 9;\n      *(__m128i *)(v1 - 15) = v3;\n      *(v1 - 13) = v4;\n    }\n    while ( *(v1 - 9) );\nLABEL_11:\n    current_id = v2;\n  }\n}\n"}, "pseudo_normalize": "void function_declaration() {\n  bool v0;\n  long long *v1;\n  long long *v2;\n  __m128i v3;\n  long long v4;\n  if (token != 40) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n    libmin_fail(-1);\n  }\n  next();\n  function_parameter();\n  if (token != 41) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n    libmin_fail(-1);\n  }\n  next();\n  if (token != 123) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, 123LL);\n    libmin_fail(-1);\n  }\n  next();\n  function_body();\n  v0 = *(uint64_t *)symbols == 0LL;\n  current_id = (long long *)symbols;\n  if (!v0) {\n    v1 = (long long *)((char *)symbols + 72);\n    do {\n      while (1) {\n        v2 = v1;\n        if (*(v1 - 5) == 132) break;\n        v1 += 9;\n        if (!*(v1 - 9)) goto LABEL_11;\n      }\n      v3 = _mm_loadu_si128((const __m128i *)(v1 - 3));\n      v4 = *(v1 - 1);\n      v1 += 9;\n      *(__m128i *)(v1 - 15) = v3;\n      *(v1 - 13) = v4;\n    } while (*(v1 - 9));\n  LABEL_11:\n    current_id = v2;\n  }\n}", "binary": "c-interp/c-interp.host.O3", "assembly": "<function_declaration>:\nendbr64\nsub    $0x8,%rsp\ncmpq   $0x28,0x6930(%rip)\nje     3b20 <function_declaration+0x110>\nmov    0x68a3(%rip),%rsi\nlea    0x35e0(%rip),%rdi\nmov    $0x28,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nxor    %eax,%eax\ncall   3610 <function_parameter>\ncmpq   $0x29,0x68f7(%rip)\nje     3b40 <function_declaration+0x130>\nmov    0x686a(%rip),%rsi\nlea    0x35a7(%rip),%rdi\nmov    $0x29,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\ncmpq   $0x7b,0x68c5(%rip)\nje     3b30 <function_declaration+0x120>\nmov    0x6838(%rip),%rsi\nlea    0x3575(%rip),%rdi\nmov    $0x7b,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nxor    %eax,%eax\ncall   37f0 <function_body>\nmov    0x6815(%rip),%rax\ncmpq   $0x0,(%rax)\nmov    %rax,0x6812(%rip)\nje     3af7 <function_declaration+0xe7>\nadd    $0x48,%rax\nnopl   0x0(%rax)\ncmpq   $0x84,-0x28(%rax)\nmov    %rax,%rdx\nje     3b00 <function_declaration+0xf0>\nadd    $0x48,%rax\ncmpq   $0x0,-0x48(%rax)\njne    3ad8 <function_declaration+0xc8>\nmov    %rdx,0x67e9(%rip)\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\nmovdqu -0x18(%rax),%xmm0\nmov    -0x8(%rax),%rcx\nadd    $0x48,%rax\nmovups %xmm0,-0x78(%rax)\nmov    %rcx,-0x68(%rax)\ncmpq   $0x0,-0x48(%rax)\njne    3ad8 <function_declaration+0xc8>\njmp    3af0 <function_declaration+0xe0>\nxchg   %ax,%ax\nxor    %eax,%eax\ncall   15a0 <next>\njmp    3a4a <function_declaration+0x3a>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\njmp    3ab5 <function_declaration+0xa5>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\njmp    3a83 <function_declaration+0x73>\nnopl   0x0(%rax)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "function_parameter", "content": "void function_parameter() {\n    long type;\n    long params;\n    params = 0;\n    while (token != ')') {\n        // int name, ...\n        type = INT;\n        if (token == Int) {\n            match(Int);\n        } else if (token == Char) {\n            type = CHAR;\n            match(Char);\n        }\n\n        // pointer type\n        while (token == Mul) {\n            match(Mul);\n            type = type + PTR;\n        }\n\n        // parameter name\n        if (token != Id) {\n            libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        if (current_id[Class] == Loc) {\n            libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n            libmin_fail(-1);\n        }\n\n        match(Id);\n        // store the local variable\n        current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;\n        current_id[BType]  = current_id[Type];  current_id[Type]   = type;\n        current_id[BValue] = current_id[Value]; current_id[Value]  = params++;   // index of current parameter\n\n        if (token == ',') {\n            match(',');\n        }\n    }\n    index_of_bp = params+1;\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O3.pseudo", "function_name": "function_parameter", "address": "0x3610", "label": "function_parameter", "content": "void __cdecl function_parameter()\n{\n  __int64 v0; // rax\n  __int64 v1; // rbp\n  __int64 v2; // rbx\n  __int64 *v3; // rax\n  __int64 v4; // rdx\n  __int64 v5; // rdx\n  __int64 v6; // rdx\n\n  v0 = token;\n  if ( token != 41 )\n  {\n    v1 = 0LL;\n    if ( token == 138 )\n      goto LABEL_15;\nLABEL_3:\n    v2 = 1LL;\n    if ( v0 == 134 )\n    {\n      v2 = 0LL;\n      next();\n      v0 = token;\n    }\n    while ( 1 )\n    {\n      while ( v0 == 159 )\n      {\n        v2 += 2LL;\n        next();\n        v0 = token;\n      }\n      if ( v0 != 133 )\n      {\n        libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] == 132 )\n      {\n        libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( token != 133 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n        libmin_fail(-1);\n      }\n      next();\n      v3 = current_id;\n      v4 = current_id[4];\n      current_id[4] = 132LL;\n      v3[7] = v4;\n      v5 = v3[3];\n      v3[3] = v2;\n      v3[6] = v5;\n      v6 = v3[5];\n      v3[5] = v1;\n      v3[8] = v6;\n      v0 = token;\n      if ( token == 44 )\n      {\n        next();\n        v0 = token;\n        if ( token == 41 )\n        {\nLABEL_19:\n          index_of_bp = v1 + 2;\n          return;\n        }\n      }\n      else if ( token == 41 )\n      {\n        goto LABEL_19;\n      }\n      ++v1;\n      if ( v0 != 138 )\n        goto LABEL_3;\nLABEL_15:\n      v2 = 1LL;\n      next();\n      v0 = token;\n    }\n  }\n  index_of_bp = 1LL;\n}\n"}, "pseudo_normalize": "void function_parameter() {\n  long long v0;\n  long long v1;\n  long long v2;\n  long long *v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  v0 = token;\n  if (token != 41) {\n    v1 = 0LL;\n    if (token == 138) goto LABEL_15;\n  LABEL_3:\n    v2 = 1LL;\n    if (v0 == 134) {\n      v2 = 0LL;\n      next();\n      v0 = token;\n    }\n    while (1) {\n      while (v0 == 159) {\n        v2 += 2LL;\n        next();\n        v0 = token;\n      }\n      if (v0 != 133) {\n        libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4] == 132) {\n        libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (token != 133) {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n        libmin_fail(-1);\n      }\n      next();\n      v3 = current_id;\n      v4 = current_id[4];\n      current_id[4] = 132LL;\n      v3[7] = v4;\n      v5 = v3[3];\n      v3[3] = v2;\n      v3[6] = v5;\n      v6 = v3[5];\n      v3[5] = v1;\n      v3[8] = v6;\n      v0 = token;\n      if (token == 44) {\n        next();\n        v0 = token;\n        if (token == 41) {\n        LABEL_19:\n          index_of_bp = v1 + 2;\n          return;\n        }\n      } else if (token == 41) {\n        goto LABEL_19;\n      }\n      ++v1;\n      if (v0 != 138) goto LABEL_3;\n    LABEL_15:\n      v2 = 1LL;\n      next();\n      v0 = token;\n    }\n  }\n  index_of_bp = 1LL;\n}", "binary": "c-interp/c-interp.host.O3", "assembly": "<function_parameter>:\nendbr64\nmov    0x6d35(%rip),%rax\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ncmp    $0x29,%rax\nje     37d5 <function_parameter+0x1c5>\nxor    %ebp,%ebp\nlea    0x3d0a(%rip),%r13\nlea    0x3d23(%rip),%r14\nlea    0x39d0(%rip),%r12\ncmp    $0x8a,%rax\nje     3740 <function_parameter+0x130>\nmov    $0x1,%ebx\ncmp    $0x86,%rax\njne    367a <function_parameter+0x6a>\njmp    37c0 <function_parameter+0x1b0>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nadd    $0x2,%rbx\ncall   15a0 <next>\nmov    0x6cd6(%rip),%rax\ncmp    $0x9f,%rax\nje     3668 <function_parameter+0x58>\ncmp    $0x85,%rax\nje     36a5 <function_parameter+0x95>\nmov    0x6c3f(%rip),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x6c34(%rip),%rax\ncmpq   $0x84,0x20(%rax)\nje     3770 <function_parameter+0x160>\ncmpq   $0x85,0x6c8b(%rip)\nje     3760 <function_parameter+0x150>\nmov    0x6bfe(%rip),%rsi\nmov    %r12,%rdi\nmov    $0x85,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x6bee(%rip),%rax\nmov    0x20(%rax),%rdx\nmovq   $0x84,0x20(%rax)\nmov    %rdx,0x38(%rax)\nmov    0x18(%rax),%rdx\nmov    %rbx,0x18(%rax)\nlea    0x1(%rbp),%rbx\nmov    %rdx,0x30(%rax)\nmov    0x28(%rax),%rdx\nmov    %rbp,0x28(%rax)\nmov    %rdx,0x40(%rax)\nmov    0x6c2b(%rip),%rax\ncmp    $0x2c,%rax\nje     3790 <function_parameter+0x180>\ncmp    $0x29,%rax\nje     37a4 <function_parameter+0x194>\nmov    %rbx,%rbp\ncmp    $0x8a,%rax\njne    3650 <function_parameter+0x40>\nxor    %eax,%eax\nmov    $0x1,%ebx\ncall   15a0 <next>\nmov    0x6bfd(%rip),%rax\njmp    367a <function_parameter+0x6a>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   15a0 <next>\njmp    36eb <function_parameter+0xdb>\nnopl   0x0(%rax)\nmov    0x6b59(%rip),%rsi\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\njmp    36ba <function_parameter+0xaa>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x6bb2(%rip),%rax\ncmp    $0x29,%rax\njne    3731 <function_parameter+0x121>\nadd    $0x2,%rbp\npop    %rbx\nmov    %rbp,0x6b00(%rip)\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nxor    %ebx,%ebx\ncall   15a0 <next>\nmov    0x6b80(%rip),%rax\njmp    367a <function_parameter+0x6a>\nmov    $0x1,%ebp\npop    %rbx\nmov    %rbp,0x6ace(%rip)\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "global_declaration", "content": "void global_declaration() {\n    // long [*]id [; | (...) {...}]\n\n\n    long type; // tmp, actual type for variable\n\n    basetype = INT;\n\n    // parse enum, this should be treated alone.\n    if (token == Enum) {\n        // enum [id] { a = 10, b = 20, ... }\n        match(Enum);\n        if (token != '{') {\n            match(Id); // skip the [id] part\n        }\n        if (token == '{') {\n            // parse the assign part\n            match('{');\n            enum_declaration();\n            match('}');\n        }\n\n        match(';');\n        return;\n    }\n\n    // parse type information\n    if (token == Int) {\n        match(Int);\n    }\n    else if (token == Char) {\n        match(Char);\n        basetype = CHAR;\n    }\n\n    // parse the comma seperated variable declaration.\n    while (token != ';' && token != '}') {\n        type = basetype;\n        // parse pointer type, note that there may exist `int ****x;`\n        while (token == Mul) {\n            match(Mul);\n            type = type + PTR;\n        }\n\n        if (token != Id) {\n            // invalid declaration\n            libmin_printf(\"%ld: bad global declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        if (current_id[Class]) {\n            // identifier exists\n            libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        match(Id);\n        current_id[Type] = type;\n\n        if (token == '(') {\n            current_id[Class] = Fun;\n            current_id[Value] = (long)(text + 1); // the memory address of function\n            function_declaration();\n        } else {\n            // variable declaration\n            current_id[Class] = Glo; // global variable\n            current_id[Value] = (long)data; // assign memory address\n            data = data + sizeof(long);\n        }\n\n        if (token == ',') {\n            match(',');\n        }\n    }\n    next();\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O3.pseudo", "function_name": "global_declaration", "address": "0x3b50", "label": "global_declaration", "content": "void __cdecl global_declaration()\n{\n  __int64 v0; // rax\n  __int64 v1; // rbx\n  __int64 *v2; // rdx\n  char *v3; // rcx\n  void *v4; // rax\n  __int64 v5; // rax\n\n  v0 = token;\n  basetype = 1LL;\n  if ( token == 136 )\n  {\n    next();\n    if ( token == 123 )\n      goto LABEL_29;\n    if ( token != 133 )\n    {\n      libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n      libmin_fail(-1);\n    }\n    next();\n    v5 = token;\n    if ( token == 123 )\n    {\nLABEL_29:\n      next();\n      enum_declaration();\n      if ( token != 125 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 125LL);\n        libmin_fail(-1);\n      }\n      next();\n      v5 = token;\n    }\n    if ( v5 != 59 )\n    {\n      libmin_printf(\"%ld: expected token: %ld\\n\", line, 59LL);\n      libmin_fail(-1);\n    }\n  }\n  else\n  {\n    if ( token == 138 )\n    {\n      next();\n      v0 = token;\n    }\n    else if ( token == 134 )\n    {\n      next();\n      v0 = token;\n      basetype = 0LL;\n    }\nLABEL_5:\n    if ( v0 != 59 )\n    {\n      while ( v0 != 125 )\n      {\n        v1 = basetype;\n        if ( v0 == 159 )\n        {\n          do\n          {\n            v1 += 2LL;\n            next();\n            v0 = token;\n          }\n          while ( token == 159 );\n        }\n        if ( v0 != 133 )\n        {\n          libmin_printf(\"%ld: bad global declaration\\n\", line);\n          libmin_fail(-1);\n        }\n        if ( current_id[4] )\n        {\n          libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n          libmin_fail(-1);\n        }\n        if ( token != 133 )\n        {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n          libmin_fail(-1);\n        }\n        next();\n        v2 = current_id;\n        v0 = token;\n        current_id[3] = v1;\n        if ( v0 == 40 )\n        {\n          v4 = text;\n          v2[4] = 129LL;\n          v2[5] = (__int64)v4 + 8;\n          function_declaration();\n          v0 = token;\n          if ( token != 44 )\n            goto LABEL_5;\n        }\n        else\n        {\n          v3 = data;\n          v2[4] = 131LL;\n          v2[5] = (__int64)v3;\n          data = v3 + 8;\n          if ( v0 != 44 )\n            goto LABEL_5;\n        }\n        next();\n        v0 = token;\n        if ( token == 59 )\n          break;\n      }\n    }\n  }\n  next();\n}\n"}, "pseudo_normalize": "void global_declaration() {\n  long long v0;\n  long long v1;\n  long long *v2;\n  char *v3;\n  void *v4;\n  long long v5;\n  v0 = token;\n  basetype = 1LL;\n  if (token == 136) {\n    next();\n    if (token == 123) goto LABEL_29;\n    if (token != 133) {\n      libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n      libmin_fail(-1);\n    }\n    next();\n    v5 = token;\n    if (token == 123) {\n    LABEL_29:\n      next();\n      enum_declaration();\n      if (token != 125) {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 125LL);\n        libmin_fail(-1);\n      }\n      next();\n      v5 = token;\n    }\n    if (v5 != 59) {\n      libmin_printf(\"%ld: expected token: %ld\\n\", line, 59LL);\n      libmin_fail(-1);\n    }\n  } else {\n    if (token == 138) {\n      next();\n      v0 = token;\n    } else if (token == 134) {\n      next();\n      v0 = token;\n      basetype = 0LL;\n    }\n  LABEL_5:\n    if (v0 != 59) {\n      while (v0 != 125) {\n        v1 = basetype;\n        if (v0 == 159) {\n          do {\n            v1 += 2LL;\n            next();\n            v0 = token;\n          } while (token == 159);\n        }\n        if (v0 != 133) {\n          libmin_printf(\"%ld: bad global declaration\\n\", line);\n          libmin_fail(-1);\n        }\n        if (current_id[4]) {\n          libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n          libmin_fail(-1);\n        }\n        if (token != 133) {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n          libmin_fail(-1);\n        }\n        next();\n        v2 = current_id;\n        v0 = token;\n        current_id[3] = v1;\n        if (v0 == 40) {\n          v4 = text;\n          v2[4] = 129LL;\n          v2[5] = (long long)v4 + 8;\n          function_declaration();\n          v0 = token;\n          if (token != 44) goto LABEL_5;\n        } else {\n          v3 = data;\n          v2[4] = 131LL;\n          v2[5] = (long long)v3;\n          data = v3 + 8;\n          if (v0 != 44) goto LABEL_5;\n        }\n        next();\n        v0 = token;\n        if (token == 59) break;\n      }\n    }\n  }\n  next();\n}", "binary": "c-interp/c-interp.host.O3", "assembly": "<global_declaration>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x67eb(%rip),%rax\nmovq   $0x1,0x6750(%rip)\ncmp    $0x88,%rax\nje     3d73 <global_declaration+0x223>\ncmp    $0x8a,%rax\nje     3d42 <global_declaration+0x1f2>\ncmp    $0x86,%rax\nje     3d55 <global_declaration+0x205>\nlea    0x3592(%rip),%r12\nlea    0x380e(%rip),%r13\nlea    0x346b(%rip),%rbp\nnopl   0x0(%rax)\ncmp    $0x3b,%rax\nje     3cb4 <global_declaration+0x164>\ncmp    $0x7d,%rax\nje     3cb4 <global_declaration+0x164>\nmov    0x66f5(%rip),%rbx\ncmp    $0x9f,%rax\njne    3bf2 <global_declaration+0xa2>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nadd    $0x2,%rbx\ncall   15a0 <next>\nmov    0x6766(%rip),%rax\ncmp    $0x9f,%rax\nje     3bd8 <global_declaration+0x88>\ncmp    $0x85,%rax\nje     3c15 <global_declaration+0xc5>\nmov    0x66cf(%rip),%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x66c4(%rip),%rax\ncmpq   $0x0,0x20(%rax)\njne    3cd8 <global_declaration+0x188>\ncmpq   $0x85,0x671e(%rip)\nje     3cc8 <global_declaration+0x178>\nmov    0x6691(%rip),%rsi\nmov    %rbp,%rdi\nmov    $0x85,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x6681(%rip),%rdx\nmov    0x66ea(%rip),%rax\nmov    %rbx,0x18(%rdx)\ncmp    $0x28,%rax\nje     3d00 <global_declaration+0x1b0>\nmov    0x66b5(%rip),%rcx\nmovq   $0x83,0x20(%rdx)\nmov    %rcx,0x28(%rdx)\nadd    $0x8,%rcx\nmov    %rcx,0x669e(%rip)\ncmp    $0x2c,%rax\njne    3bb0 <global_declaration+0x60>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x66a6(%rip),%rax\ncmp    $0x3b,%rax\njne    3bba <global_declaration+0x6a>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    15a0 <next>\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\njmp    3c58 <global_declaration+0x108>\nnopl   0x0(%rax)\nmov    0x65f1(%rip),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\njmp    3c27 <global_declaration+0xd7>\nnopl   0x0(%rax,%rax,1)\nmov    0x6641(%rip),%rax\nmovq   $0x81,0x20(%rdx)\nadd    $0x8,%rax\nmov    %rax,0x28(%rdx)\nxor    %eax,%eax\ncall   3a10 <function_declaration>\nmov    0x662b(%rip),%rax\ncmp    $0x2c,%rax\njne    3bb0 <global_declaration+0x60>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x6613(%rip),%rax\njmp    3caa <global_declaration+0x15a>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x6600(%rip),%rax\njmp    3b94 <global_declaration+0x44>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x65ed(%rip),%rax\nmovq   $0x0,0x6552(%rip)\njmp    3b94 <global_declaration+0x44>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x65cf(%rip),%rax\ncmp    $0x7b,%rax\nje     3dfc <global_declaration+0x2ac>\ncmp    $0x85,%rax\nje     3e41 <global_declaration+0x2f1>\nmov    0x6536(%rip),%rsi\nlea    0x3273(%rip),%rdi\nmov    $0x85,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x6592(%rip),%rax\ncmp    $0x7b,%rax\nje     3dfc <global_declaration+0x2ac>\ncmp    $0x3b,%rax\nje     3cb4 <global_declaration+0x164>\nmov    0x64fb(%rip),%rsi\nlea    0x3238(%rip),%rdi\nmov    $0x3b,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nadd    $0x8,%rsp\nmov    $0xffffffff,%edi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    47f0 <libmin_fail>\nxor    %eax,%eax\ncall   15a0 <next>\nxor    %eax,%eax\ncall   34f0 <enum_declaration>\ncmpq   $0x7d,0x653e(%rip)\nje     3e4d <global_declaration+0x2fd>\nmov    0x64b5(%rip),%rsi\nmov    $0x7d,%edx\nlea    0x31ed(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x6511(%rip),%rax\njmp    3dc4 <global_declaration+0x274>\nxor    %eax,%eax\ncall   15a0 <next>\njmp    3db7 <global_declaration+0x267>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x64f5(%rip),%rax\njmp    3dc4 <global_declaration+0x274>\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "main", "content": "int main(int _argc, char **_argv)\n{\n\n    long i;\n    long *tmp;\n\n    int argc = 2;\n    char *myargv[2] = { \"c-interp\", \"hello.c\" };\n    char **argv = myargv;\n\n    argc--;\n    argv++;\n\n#if 0\n    // parse arguments\n    if (argc > 0 && **argv == '-' && (*argv)[1] == 's') {\n        assembly = 1;\n        --argc;\n        ++argv;\n    }\n    if (argc > 0 && **argv == '-' && (*argv)[1] == 'd') {\n        debug = 1;\n        --argc;\n        ++argv;\n    }\n    if (argc < 1) {\n        libmin_printf(\"usage: xc [-s] [-d] file ...\\n\");\n        return -1;\n    }\n#endif\n\n    libmin_mopen(mhello, \"r\");\n\n    poolsize = 256 * 1024; // arbitrary size\n    line = 1;\n\n    // allocate memory\n    if (!(text = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n        return -1;\n    }\n    if (!(data = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n        return -1;\n    }\n    if (!(stack = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n    }\n    if (!(symbols = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n        return -1;\n    }\n\n    libmin_memset(text, 0, poolsize);\n    libmin_memset(data, 0, poolsize);\n    libmin_memset(stack, 0, poolsize);\n    libmin_memset(symbols, 0, poolsize);\n\n    old_text = text;\n\n    src = \"char else enum if int return sizeof while \"\n          \"open read close printf malloc memset memcmp exit void main\";\n\n     // add keywords to symbol table\n    i = Char;\n    while (i <= While) {\n        next();\n        current_id[Token] = i++;\n    }\n\n    // add library to symbol table\n    i = OPEN;\n    while (i <= EXIT) {\n        next();\n        current_id[Class] = Sys;\n        current_id[Type] = INT;\n        current_id[Value] = i++;\n    }\n\n    next(); current_id[Token] = Char; // handle void type\n    next(); idmain = current_id; // keep track of main\n\n    if (!(src = old_src = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n        return -1;\n    }\n    // read the source file\n    if ((i = libmin_mread(src, poolsize-1, mhello)) <= 0) {\n        libmin_printf(\"read() returned %ld\\n\", i);\n        return -1;\n    }\n    src[i] = 0; // add EOF character\n    libmin_mclose(mhello);\n\n    program();\n\n    if (!(pc = (long *)idmain[Value])) {\n        libmin_printf(\"main() not defined\\n\");\n        return -1;\n    }\n\n    // dump_text();\n    if (assembly) {\n        // only for compile\n        return 0;\n    }\n\n    // setup stack\n    sp = (long *)((long)stack + poolsize);\n    *--sp = EXIT; // call exit if main returns\n    *--sp = PUSH; tmp = sp;\n    *--sp = 1;\n    *--sp = (long)argv;\n    *--sp = (long)tmp;\n\n    (void)eval();\n\n    libmin_success();\n    return 9;\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  __int64 v4; // rdx\n  __int64 i; // rbx\n  __int64 *v6; // rax\n  __m128i si128; // xmm1\n  __int64 v8; // rdx\n  signed __int64 v9; // rax\n  int result; // eax\n  __m128i v11; // xmm0\n  char *v12; // rax\n  __m128i myargv; // [rsp+0h] [rbp-28h] BYREF\n  unsigned __int64 v14; // [rsp+18h] [rbp-10h]\n\n  v14 = __readfsqword(0x28u);\n  myargv = _mm_unpacklo_epi64((__m128i)(unsigned __int64)\"c-interp\", (__m128i)(unsigned __int64)\"hello.c\");\n  libmin_mopen(mhello, \"r\");\n  poolsize = 0x40000LL;\n  line = 1LL;\n  text = libmin_malloc(0x40000uLL);\n  if ( text )\n  {\n    data = (char *)libmin_malloc(poolsize);\n    if ( data )\n    {\n      stack = libmin_malloc(poolsize);\n      if ( stack )\n      {\n        symbols = libmin_malloc(poolsize);\n        if ( symbols )\n        {\n          v3 = 134LL;\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (__int64 *)text;\n          src = \"char else enum if int return sizeof while open read close printf malloc memset memcmp exit void main\";\n          do\n          {\n            next();\n            v4 = v3++;\n            *current_id = v4;\n          }\n          while ( v3 != 142 );\n          for ( i = 30LL; i != 38; ++i )\n          {\n            next();\n            v6 = current_id;\n            si128 = _mm_load_si128((const __m128i *)&xmmword_79A0);\n            v8 = i;\n            current_id[5] = v8;\n            *(__m128i *)(v6 + 3) = si128;\n          }\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          old_src = (char *)libmin_malloc(poolsize);\n          src = old_src;\n          if ( old_src )\n          {\n            v9 = libmin_mread(old_src, poolsize - 1, mhello);\n            if ( v9 <= 0 )\n            {\n              libmin_printf(\"read() returned %ld\\n\", v9);\n              return -1;\n            }\n            else\n            {\n              src[v9] = 0;\n              libmin_mclose(mhello);\n              next();\n              while ( token > 0 )\n                global_declaration();\n              pc = (__int64 *)idmain[5];\n              if ( pc )\n              {\n                result = 0;\n                if ( !assembly )\n                {\n                  v11 = _mm_load_si128((const __m128i *)&xmmword_79B0);\n                  v12 = (char *)stack + poolsize;\n                  *((_QWORD *)v12 - 4) = &myargv.m128i_i64[1];\n                  *(__m128i *)(v12 - 24) = v11;\n                  *((_QWORD *)v12 - 1) = 37LL;\n                  qword_A2F8 = (__int64 *)(v12 - 40);\n                  *((_QWORD *)v12 - 5) = v12 - 16;\n                  eval();\n                  libmin_success();\n                }\n              }\n              else\n              {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            }\n          }\n          else\n          {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        }\n        else\n        {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      }\n      else\n      {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    }\n    else\n    {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  }\n  else\n  {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long i;\n  long long *v6;\n  __m128i si128;\n  long long v8;\n  signed long long v9;\n  int result;\n  __m128i v11;\n  char *v12;\n  __m128i myargv;\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  myargv = _mm_unpacklo_epi64((__m128i)(unsigned long long)\"c-interp\",\n                              (__m128i)(unsigned long long)\"hello.c\");\n  libmin_mopen(mhello, \"r\");\n  poolsize = 262144LL;\n  line = 1LL;\n  text = libmin_malloc(262144uLL);\n  if (text) {\n    data = (char *)libmin_malloc(poolsize);\n    if (data) {\n      stack = libmin_malloc(poolsize);\n      if (stack) {\n        symbols = libmin_malloc(poolsize);\n        if (symbols) {\n          v3 = 134LL;\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (long long *)text;\n          src =\n              \"char else enum if int return sizeof while open read close \"\n              \"printf malloc memset memcmp exit void main\";\n          do {\n            next();\n            v4 = v3++;\n            *current_id = v4;\n          } while (v3 != 142);\n          for (i = 30LL; i != 38; ++i) {\n            next();\n            v6 = current_id;\n            si128 = _mm_load_si128((const __m128i *)&xmmword_79A0);\n            v8 = i;\n            current_id[5] = v8;\n            *(__m128i *)(v6 + 3) = si128;\n          }\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          old_src = (char *)libmin_malloc(poolsize);\n          src = old_src;\n          if (old_src) {\n            v9 = libmin_mread(old_src, poolsize - 1, mhello);\n            if (v9 <= 0) {\n              libmin_printf(\"read() returned %ld\\n\", v9);\n              return -1;\n            } else {\n              src[v9] = 0;\n              libmin_mclose(mhello);\n              next();\n              while (token > 0) global_declaration();\n              pc = (long long *)idmain[5];\n              if (pc) {\n                result = 0;\n                if (!assembly) {\n                  v11 = _mm_load_si128((const __m128i *)&xmmword_79B0);\n                  v12 = (char *)stack + poolsize;\n                  *((uint64_t *)v12 - 4) = &myargv.m128i_i64[1];\n                  *(__m128i *)(v12 - 24) = v11;\n                  *((uint64_t *)v12 - 1) = 37LL;\n                  qword_A2F8 = (long long *)(v12 - 40);\n                  *((uint64_t *)v12 - 5) = v12 - 16;\n                  eval();\n                  libmin_success();\n                }\n              } else {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            }\n          } else {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        } else {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      } else {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    } else {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  } else {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n  return result;\n}", "binary": "c-interp/c-interp.host.O3", "assembly": "<main>:\nendbr64\npush   %rbx\nlea    0x604b(%rip),%rcx\nlea    0x6055(%rip),%rsi\nmovq   %rcx,%xmm0\nsub    $0x20,%rsp\nmov    0x8edd(%rip),%rdi\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nlea    0x6028(%rip),%rax\nmovq   %rax,%xmm2\npunpcklqdq %xmm2,%xmm0\nmovaps %xmm0,(%rsp)\ncall   4cb0 <libmin_mopen>\nmov    $0x40000,%edi\nmovq   $0x40000,0x9196(%rip)\nmovq   $0x1,0x914b(%rip)\ncall   4810 <libmin_malloc>\nmov    %rax,0x91b7(%rip)\ntest   %rax,%rax\nje     1474 <main+0x354>\nmov    0x916f(%rip),%rdi\ncall   4810 <libmin_malloc>\nmov    %rax,0x9183(%rip)\ntest   %rax,%rax\nje     1459 <main+0x339>\nmov    0x9153(%rip),%rdi\ncall   4810 <libmin_malloc>\nmov    %rax,0x9177(%rip)\ntest   %rax,%rax\nje     1441 <main+0x321>\nmov    0x9137(%rip),%rdi\ncall   4810 <libmin_malloc>\nmov    %rax,0x90f3(%rip)\ntest   %rax,%rax\nje     1429 <main+0x309>\nmov    0x911b(%rip),%rdx\nmov    0x914c(%rip),%rdi\nxor    %esi,%esi\nmov    $0x86,%ebx\ncall   4c40 <libmin_memset>\nmov    0x9101(%rip),%rdx\nmov    0x911a(%rip),%rdi\nxor    %esi,%esi\ncall   4c40 <libmin_memset>\nmov    0x90ec(%rip),%rdx\nmov    0x9115(%rip),%rdi\nxor    %esi,%esi\ncall   4c40 <libmin_memset>\nmov    0x90d7(%rip),%rdx\nmov    0x9098(%rip),%rdi\nxor    %esi,%esi\ncall   4c40 <libmin_memset>\nmov    0x90fa(%rip),%rax\nmov    %rax,0x90e3(%rip)\nlea    0x621c(%rip),%rax\nmov    %rax,0x90bd(%rip)\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x906a(%rip),%rax\nmov    %rbx,%rdx\nadd    $0x1,%rbx\nmov    %rdx,(%rax)\ncmp    $0x8e,%rbx\njne    1268 <main+0x148>\nmov    $0x1e,%ebx\nxchg   %ax,%ax\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x9042(%rip),%rax\nmovdqa 0x66fa(%rip),%xmm1\nmov    %rbx,%rdx\nadd    $0x1,%rbx\nmov    %rdx,0x28(%rax)\nmovups %xmm1,0x18(%rax)\ncmp    $0x26,%rbx\njne    1290 <main+0x170>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x9017(%rip),%rax\nmovq   $0x86,(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x9002(%rip),%rax\nmov    0x902b(%rip),%rdi\nmov    %rax,0x903c(%rip)\ncall   4810 <libmin_malloc>\nmov    %rax,0x9020(%rip)\nmov    %rax,%rdi\nmov    %rax,0x901e(%rip)\ntest   %rax,%rax\nje     140f <main+0x2ef>\nmov    0x8ffe(%rip),%rax\nmov    0x8d07(%rip),%rdx\nlea    -0x1(%rax),%rsi\ncall   4d00 <libmin_mread>\ntest   %rax,%rax\njle    13f9 <main+0x2d9>\nmov    0x8fee(%rip),%rdx\nmovb   $0x0,(%rdx,%rax,1)\nmov    0x8ce3(%rip),%rdi\ncall   4ab0 <libmin_mclose>\nxor    %eax,%eax\ncall   15a0 <next>\ncmpq   $0x0,0x8fff(%rip)\njle    1369 <main+0x249>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   3b50 <global_declaration>\ncmpq   $0x0,0x8fe9(%rip)\njg     1358 <main+0x238>\nmov    0x8fb8(%rip),%rax\nmov    0x28(%rax),%rax\nmov    %rax,0x8f8d(%rip)\ntest   %rax,%rax\nje     148f <main+0x36f>\nxor    %eax,%eax\ncmpq   $0x0,0x8fca(%rip)\njne    13df <main+0x2bf>\nmov    0x8f79(%rip),%rax\nmovdqa 0x6611(%rip),%xmm0\nlea    0x8(%rsp),%rdx\nadd    0x8f95(%rip),%rax\nmov    %rdx,-0x20(%rax)\nlea    -0x28(%rax),%rdx\nmovups %xmm0,-0x18(%rax)\nmovq   $0x25,-0x8(%rax)\nmov    %rdx,0x8f32(%rip)\nlea    -0x10(%rax),%rdx\nmov    %rdx,-0x28(%rax)\nxor    %eax,%eax\ncall   3ea0 <eval>\ncall   6f20 <libmin_success>\nmov    $0x9,%eax\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    14a3 <main+0x383>\nadd    $0x20,%rsp\npop    %rbx\nret\nmov    %rax,%rsi\nlea    0x5d87(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13df <main+0x2bf>\nmov    0x8efa(%rip),%rsi\nlea    0x60c3(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13df <main+0x2bf>\nmov    0x8ee0(%rip),%rsi\nlea    0x6019(%rip),%rdi\ncall   6c80 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13df <main+0x2bf>\nmov    0x8ec8(%rip),%rsi\nlea    0x5fd9(%rip),%rdi\ncall   6c80 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13df <main+0x2bf>\nmov    0x8eb0(%rip),%rsi\nlea    0x5f99(%rip),%rdi\ncall   6c80 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13df <main+0x2bf>\nmov    0x8e95(%rip),%rsi\nlea    0x5f56(%rip),%rdi\ncall   6c80 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13df <main+0x2bf>\nlea    0x5d09(%rip),%rdi\ncall   6c80 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13df <main+0x2bf>\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "match", "content": "void match(long tk) {\n    if (token == tk) {\n        next();\n    } else {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n        libmin_fail(-1);\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O3.pseudo", "function_name": "match", "address": "0x1d20", "label": "match", "content": "void __fastcall match(__int64 tk)\n{\n  if ( token != tk )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}\n"}, "pseudo_normalize": "void match(long long tk) {\n  if (token != tk) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}", "binary": "c-interp/c-interp.host.O3", "assembly": "<match>:\nendbr64\ncmp    %rdi,0x8625(%rip)\nje     1d60 <match+0x40>\nsub    $0x8,%rsp\nmov    0x8598(%rip),%rsi\nmov    %rdi,%rdx\nxor    %eax,%eax\nlea    0x52d0(%rip),%rdi\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\nadd    $0x8,%rsp\njmp    47f0 <libmin_fail>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\njmp    15a0 <next>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "next", "content": " // index of bp pointer on stack\n\nvoid next() {\n    char *last_pos;\n    long hash;\n\n    while ((token = *src) != 0) {\n        ++src;\n\n        if (token == '\\n') {\n            if (assembly) {\n                // print compile info\n                libmin_printf(\"%ld: %.*s\", line, (int)(src-old_src), old_src);\n                old_src = src;\n\n                while (old_text < text) {\n                    libmin_printf(\"%8.4s\", & \"LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,\"\n                                      \"OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\"\n                                      \"OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT\"[*++old_text * 5]);\n\n                    if (*old_text <= ADJ)\n                        libmin_printf(\" %ld\\n\", *++old_text);\n                    else\n                        libmin_printf(\"\\n\");\n                }\n            }\n            ++line;\n        }\n        else if (token == '#') {\n            // skip macro, because we will not support it\n            while (*src != 0 && *src != '\\n') {\n                src++;\n            }\n        }\n        else if ((token >= 'a' && token <= 'z') || (token >= 'A' && token <= 'Z') || (token == '_')) {\n\n            // parse identifier\n            last_pos = src - 1;\n            hash = token;\n\n            while ((*src >= 'a' && *src <= 'z') || (*src >= 'A' && *src <= 'Z') || (*src >= '0' && *src <= '9') || (*src == '_')) {\n                hash = hash * 147 + *src;\n                src++;\n            }\n\n            // look for existing identifier, linear search\n            current_id = symbols;\n            while (current_id[Token]) {\n                if (current_id[Hash] == hash && !libmin_memcmp((char *)current_id[Name], last_pos, src - last_pos)) {\n                    //found one, return\n                    token = current_id[Token];\n                    return;\n                }\n                current_id = current_id + IdSize;\n            }\n\n\n            // store new ID\n            current_id[Name] = (long)last_pos;\n            current_id[Hash] = hash;\n            token = current_id[Token] = Id;\n            return;\n        }\n        else if (token >= '0' && token <= '9') {\n            // parse number, three kinds: dec(123) hex(0x123) oct(017)\n            token_val = token - '0';\n            if (token_val > 0) {\n                // dec, starts with [1-9]\n                while (*src >= '0' && *src <= '9') {\n                    token_val = token_val*10 + *src++ - '0';\n                }\n            } else {\n                // starts with number 0\n                if (*src == 'x' || *src == 'X') {\n                    //hex\n                    token = *++src;\n                    while ((token >= '0' && token <= '9') || (token >= 'a' && token <= 'f') || (token >= 'A' && token <= 'F')) {\n                        token_val = token_val * 16 + (token & 15) + (token >= 'A' ? 9 : 0);\n                        token = *++src;\n                    }\n                } else {\n                    // oct\n                    while (*src >= '0' && *src <= '7') {\n                        token_val = token_val*8 + *src++ - '0';\n                    }\n                }\n            }\n\n            token = Num;\n            return;\n        }\n        else if (token == '/') {\n            if (*src == '/') {\n                // skip comments\n                while (*src != 0 && *src != '\\n') {\n                    ++src;\n                }\n            } else {\n                // divide operator\n                token = Div;\n                return;\n            }\n        }\n        else if (token == '\"' || token == '\\'') {\n            // parse string literal, currently, the only supported escape\n            // character is '\\n', store the string literal into data.\n            last_pos = data;\n            while (*src != 0 && *src != token) {\n                token_val = *src++;\n                if (token_val == '\\\\') {\n                    // escape character\n                    token_val = *src++;\n                    if (token_val == 'n') {\n                        token_val = '\\n';\n                    }\n                }\n\n                if (token == '\"') {\n                    *data++ = token_val;\n                }\n            }\n\n            src++;\n            // if it is a single character, return Num token\n            if (token == '\"') {\n                token_val = (long)last_pos;\n            } else {\n                token = Num;\n            }\n\n            return;\n        }\n        else if (token == '=') {\n            // parse '==' and '='\n            if (*src == '=') {\n                src ++;\n                token = Eq;\n            } else {\n                token = Assign;\n            }\n            return;\n        }\n        else if (token == '+') {\n            // parse '+' and '++'\n            if (*src == '+') {\n                src ++;\n                token = Inc;\n            } else {\n                token = Add;\n            }\n            return;\n        }\n        else if (token == '-') {\n            // parse '-' and '--'\n            if (*src == '-') {\n                src ++;\n                token = Dec;\n            } else {\n                token = Sub;\n            }\n            return;\n        }\n        else if (token == '!') {\n            // parse '!='\n            if (*src == '=') {\n                src++;\n                token = Ne;\n            }\n            return;\n        }\n        else if (token == '<') {\n            // parse '<=', '<<' or '<'\n            if (*src == '=') {\n                src ++;\n                token = Le;\n            } else if (*src == '<') {\n                src ++;\n                token = Shl;\n            } else {\n                token = Lt;\n            }\n            return;\n        }\n        else if (token == '>') {\n            // parse '>=', '>>' or '>'\n            if (*src == '=') {\n                src ++;\n                token = Ge;\n            } else if (*src == '>') {\n                src ++;\n                token = Shr;\n            } else {\n                token = Gt;\n            }\n            return;\n        }\n        else if (token == '|') {\n            // parse '|' or '||'\n            if (*src == '|') {\n                src ++;\n                token = Lor;\n            } else {\n                token = Or;\n            }\n            return;\n        }\n        else if (token == '&') {\n            // parse '&' and '&&'\n            if (*src == '&') {\n                src ++;\n                token = Lan;\n            } else {\n                token = And;\n            }\n            return;\n        }\n        else if (token == '^') {\n            token = Xor;\n            return;\n        }\n        else if (token == '%') {\n            token = Mod;\n            return;\n        }\n        else if (token == '*') {\n            token = Mul;\n            return;\n        }\n        else if (token == '[') {\n            token = Brak;\n            return;\n        }\n        else if (token == '?') {\n            token = Cond;\n            return;\n        }\n        else if (token == '~' || token == ';' || token == '{' || token == '}' || token == '(' || token == ')' || token == ']' || token == ',' || token == ':') {\n            // directly return the character as token;\n            return;\n        }\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O3.pseudo", "function_name": "next", "address": "0x15a0", "label": "next", "content": "void __cdecl next()\n{\n  char *v0; // r14\n  __int64 v1; // rbx\n  char v2; // dl\n  char *v3; // rax\n  __int64 v4; // rdx\n  void *v5; // rax\n  bool v6; // zf\n  __int64 *v7; // rdx\n  char *v8; // rax\n  __int64 v9; // rbx\n  char v10; // al\n  char *v11; // r14\n  __int64 v12; // rdx\n  char *v13; // rax\n  char *v14; // rdi\n  __int64 v15; // rdx\n  char v16; // dl\n  char *v17; // rcx\n  __int64 v18; // rax\n  char v19; // al\n  char v20; // al\n  char *v21; // rax\n  __int64 *v22; // rdx\n  __int64 v23; // rsi\n  char *v24; // r14\n  __int64 v25; // rdx\n  char *v26; // rax\n  char *v27; // rax\n  char *v28; // rax\n  char *v29; // r14\n  __int64 i; // rax\n\n  v0 = src;\n  v1 = *src;\n  token = v1;\n  if ( v1 )\n  {\n    v2 = v1;\n    do\n    {\n      v3 = v0 + 1;\n      src = v0 + 1;\n      if ( v1 == 10 )\n      {\n        if ( assembly )\n        {\n          libmin_printf(\"%ld: %.*s\", line, (_DWORD)v3 - (_DWORD)old_src, old_src);\n          v3 = src;\n          v22 = old_text;\n          old_src = src;\n          if ( text > old_text )\n          {\n            do\n            {\n              while ( 1 )\n              {\n                old_text = v22 + 1;\n                libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * v22[1]]);\n                if ( *old_text > 7 )\n                  break;\n                v23 = old_text[1];\n                ++old_text;\n                libmin_printf((char *)\" %ld\\n\", v23);\n                v22 = old_text;\n                if ( old_text >= text )\n                  goto LABEL_76;\n              }\n              libmin_printf((char *)\"\\n\");\n              v22 = old_text;\n            }\n            while ( old_text < text );\nLABEL_76:\n            v3 = src;\n          }\n        }\n        ++line;\n        v2 = *v3;\n        v0 = v3;\n      }\n      else if ( v1 == 35 )\n      {\n        v2 = v0[1];\n        if ( v2 == 10 || !v2 )\n        {\n          ++v0;\n        }\n        else\n        {\n          v8 = v0 + 2;\n          do\n          {\n            src = v8;\n            v2 = *v8;\n            v0 = v8++;\n          }\n          while ( v2 && v2 != 10 );\n        }\n      }\n      else\n      {\n        if ( (unsigned __int8)((v2 & 0xDF) - 65) <= 0x19u )\n        {\nLABEL_8:\n          while ( 1 )\n          {\n            v4 = *v3;\n            if ( (unsigned __int8)((*v3 & 0xDF) - 65) > 0x19u && (unsigned __int8)(v4 - 48) > 9u && (_BYTE)v4 != 95 )\n              break;\n            src = ++v3;\n            v1 = v4 + 147 * v1;\n          }\n          v5 = symbols;\n          v6 = *(_QWORD *)symbols == 0LL;\n          current_id = (__int64 *)symbols;\n          if ( v6 )\n          {\nLABEL_80:\n            *(_QWORD *)v5 = 133LL;\n            *((_QWORD *)v5 + 2) = v0;\n            *((_QWORD *)v5 + 1) = v1;\n            token = 133LL;\n            return;\n          }\n          while ( 1 )\n          {\n            v7 = (__int64 *)v5;\n            if ( *((_QWORD *)v5 + 1) == v1 )\n            {\n              if ( !libmin_memcmp(*((const void **)v5 + 2), v0, src - v0) )\n              {\n                token = *current_id;\n                return;\n              }\n              v7 = current_id;\n            }\n            v5 = v7 + 9;\n            v6 = v7[9] == 0;\n            current_id = v7 + 9;\n            if ( v6 )\n              goto LABEL_80;\n          }\n        }\n        switch ( v2 )\n        {\n          case '!':\n            if ( v0[1] == 61 )\n            {\n              token = 150LL;\n              src = v0 + 2;\n            }\n            return;\n          case '\"':\n          case '\\'':\n            v14 = data;\n            while ( 1 )\n            {\n              v15 = *v3;\n              src = v3 + 1;\n              if ( !(_BYTE)v15 || v15 == v1 )\n                break;\n              token_val = *v3;\n              v16 = token_val;\n              if ( token_val == 92 )\n              {\n                v17 = v3 + 2;\n                src = v3 + 2;\n                v18 = v3[1];\n                v16 = v18;\n                if ( (_BYTE)v18 == 110 )\n                {\n                  token_val = 10LL;\n                  v3 = v17;\n                  v16 = 10;\n                }\n                else\n                {\n                  token_val = v18;\n                  v3 = v17;\n                }\n              }\n              else\n              {\n                ++v3;\n              }\n              if ( v1 == 34 )\n              {\n                v27 = data++;\n                *v27 = v16;\n                v1 = token;\n                v3 = src;\n              }\n            }\n            if ( v1 != 34 )\n              goto LABEL_18;\n            token_val = (__int64)v14;\n            return;\n          case '%':\n            token = 161LL;\n            return;\n          case '&':\n            if ( v0[1] == 38 )\n            {\n              token = 145LL;\n              src = v0 + 2;\n            }\n            else\n            {\n              token = 148LL;\n            }\n            return;\n          case '(':\n          case ')':\n          case ',':\n          case ':':\n          case ';':\n          case ']':\n          case '{':\n          case '}':\n          case '~':\n            return;\n          case '*':\n            token = 159LL;\n            return;\n          case '+':\n            if ( v0[1] == 43 )\n            {\n              token = 162LL;\n              src = v0 + 2;\n            }\n            else\n            {\n              token = 157LL;\n            }\n            return;\n          case '-':\n            if ( v0[1] == 45 )\n            {\n              token = 163LL;\n              src = v0 + 2;\n            }\n            else\n            {\n              token = 158LL;\n            }\n            return;\n          case '/':\n            if ( v0[1] != 47 )\n            {\n              token = 160LL;\n              return;\n            }\n            v21 = v0 + 2;\n            do\n            {\n              src = v21;\n              v2 = *v21;\n              v0 = v21++;\n            }\n            while ( v2 && v2 != 10 );\n            break;\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            v9 = v1 - 48;\n            token_val = v9;\n            v10 = v0[1];\n            if ( v9 )\n            {\n              v24 = v0 + 2;\n              if ( (unsigned __int8)(v10 - 48) <= 9u )\n              {\n                do\n                {\n                  src = v24;\n                  v25 = *(v24 - 1);\n                  v26 = v24++;\n                  v9 = v25 + 10 * v9 - 48;\n                  token_val = v9;\n                }\n                while ( (unsigned __int8)(*v26 - 48) <= 9u );\n              }\n            }\n            else\n            {\n              if ( (v10 & 0xDF) == 0x58 )\n              {\n                v28 = v0 + 2;\n                v29 = v0 + 3;\n                src = v28;\n                for ( i = *(v29 - 1); ; i = *(v29 - 1) )\n                {\n                  token = i;\n                  if ( (unsigned __int64)(i - 48) > 9 )\n                  {\n                    if ( (i & 0xFFFFFFFFFFFFFFDFLL) - 65 > 5 )\n                      goto LABEL_18;\n                    v9 = (i & 0xF) + 16 * v9;\n                    if ( i > 64 )\n                      v9 += 9LL;\n                  }\n                  else\n                  {\n                    v9 = (i & 0xF) + 16 * v9;\n                  }\n                  src = v29++;\n                  token_val = v9;\n                }\n              }\n              v11 = v0 + 2;\n              if ( (unsigned __int8)(v10 - 48) <= 7u )\n              {\n                do\n                {\n                  src = v11;\n                  v12 = *(v11 - 1);\n                  v13 = v11++;\n                  v9 = v12 + 8 * v9 - 48;\n                  token_val = v9;\n                }\n                while ( (unsigned __int8)(*v13 - 48) <= 7u );\n              }\n            }\nLABEL_18:\n            token = 128LL;\n            return;\n          case '<':\n            v20 = v0[1];\n            if ( v20 == 61 )\n            {\n              token = 153LL;\n              src = v0 + 2;\n            }\n            else if ( v20 == 60 )\n            {\n              token = 155LL;\n              src = v0 + 2;\n            }\n            else\n            {\n              token = 151LL;\n            }\n            return;\n          case '=':\n            if ( v0[1] == 61 )\n            {\n              token = 149LL;\n              src = v0 + 2;\n            }\n            else\n            {\n              token = 142LL;\n            }\n            return;\n          case '>':\n            v19 = v0[1];\n            if ( v19 == 61 )\n            {\n              token = 154LL;\n              src = v0 + 2;\n            }\n            else if ( v19 == 62 )\n            {\n              token = 156LL;\n              src = v0 + 2;\n            }\n            else\n            {\n              token = 152LL;\n            }\n            return;\n          case '?':\n            token = 143LL;\n            return;\n          case '[':\n            token = 164LL;\n            return;\n          case '^':\n            token = 147LL;\n            return;\n          case '_':\n            v1 = 95LL;\n            goto LABEL_8;\n          case '|':\n            if ( v0[1] == 124 )\n            {\n              token = 144LL;\n              src = v0 + 2;\n            }\n            else\n            {\n              token = 146LL;\n            }\n            return;\n          default:\n            v2 = *++v0;\n            break;\n        }\n      }\n      v1 = v2;\n      token = v2;\n    }\n    while ( v2 );\n  }\n}\n"}, "pseudo_normalize": "void next() {\n  char *v0;\n  long long v1;\n  char v2;\n  char *v3;\n  long long v4;\n  void *v5;\n  bool v6;\n  long long *v7;\n  char *v8;\n  long long v9;\n  char v10;\n  char *v11;\n  long long v12;\n  char *v13;\n  char *v14;\n  long long v15;\n  char v16;\n  char *v17;\n  long long v18;\n  char v19;\n  char v20;\n  char *v21;\n  long long *v22;\n  long long v23;\n  char *v24;\n  long long v25;\n  char *v26;\n  char *v27;\n  char *v28;\n  char *v29;\n  long long i;\n  v0 = src;\n  v1 = *src;\n  token = v1;\n  if (v1) {\n    v2 = v1;\n    do {\n      v3 = v0 + 1;\n      src = v0 + 1;\n      if (v1 == 10) {\n        if (assembly) {\n          libmin_printf(\"%ld: %.*s\", line, (uint32_t)v3 - (uint32_t)old_src,\n                        old_src);\n          v3 = src;\n          v22 = old_text;\n          old_src = src;\n          if (text > old_text) {\n            do {\n              while (1) {\n                old_text = v22 + 1;\n                libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * v22[1]]);\n                if (*old_text > 7) break;\n                v23 = old_text[1];\n                ++old_text;\n                libmin_printf((char *)\" %ld\\n\", v23);\n                v22 = old_text;\n                if (old_text >= text) goto LABEL_76;\n              }\n              libmin_printf((char *)\"\\n\");\n              v22 = old_text;\n            } while (old_text < text);\n          LABEL_76:\n            v3 = src;\n          }\n        }\n        ++line;\n        v2 = *v3;\n        v0 = v3;\n      } else if (v1 == 35) {\n        v2 = v0[1];\n        if (v2 == 10 || !v2) {\n          ++v0;\n        } else {\n          v8 = v0 + 2;\n          do {\n            src = v8;\n            v2 = *v8;\n            v0 = v8++;\n          } while (v2 && v2 != 10);\n        }\n      } else {\n        if ((unsigned char)((v2 & 223) - 65) <= 25u) {\n        LABEL_8:\n          while (1) {\n            v4 = *v3;\n            if ((unsigned char)((*v3 & 223) - 65) > 25u &&\n                (unsigned char)(v4 - 48) > 9u && (uint8_t)v4 != 95)\n              break;\n            src = ++v3;\n            v1 = v4 + 147 * v1;\n          }\n          v5 = symbols;\n          v6 = *(uint64_t *)symbols == 0LL;\n          current_id = (long long *)symbols;\n          if (v6) {\n          LABEL_80:\n            *(uint64_t *)v5 = 133LL;\n            *((uint64_t *)v5 + 2) = v0;\n            *((uint64_t *)v5 + 1) = v1;\n            token = 133LL;\n            return;\n          }\n          while (1) {\n            v7 = (long long *)v5;\n            if (*((uint64_t *)v5 + 1) == v1) {\n              if (!libmin_memcmp(*((const void **)v5 + 2), v0, src - v0)) {\n                token = *current_id;\n                return;\n              }\n              v7 = current_id;\n            }\n            v5 = v7 + 9;\n            v6 = v7[9] == 0;\n            current_id = v7 + 9;\n            if (v6) goto LABEL_80;\n          }\n        }\n        switch (v2) {\n          case '!':\n            if (v0[1] == 61) {\n              token = 150LL;\n              src = v0 + 2;\n            }\n            return;\n          case '\"':\n          case '\\'':\n            v14 = data;\n            while (1) {\n              v15 = *v3;\n              src = v3 + 1;\n              if (!(uint8_t)v15 || v15 == v1) break;\n              token_val = *v3;\n              v16 = token_val;\n              if (token_val == 92) {\n                v17 = v3 + 2;\n                src = v3 + 2;\n                v18 = v3[1];\n                v16 = v18;\n                if ((uint8_t)v18 == 110) {\n                  token_val = 10LL;\n                  v3 = v17;\n                  v16 = 10;\n                } else {\n                  token_val = v18;\n                  v3 = v17;\n                }\n              } else {\n                ++v3;\n              }\n              if (v1 == 34) {\n                v27 = data++;\n                *v27 = v16;\n                v1 = token;\n                v3 = src;\n              }\n            }\n            if (v1 != 34) goto LABEL_18;\n            token_val = (long long)v14;\n            return;\n          case '%':\n            token = 161LL;\n            return;\n          case '&':\n            if (v0[1] == 38) {\n              token = 145LL;\n              src = v0 + 2;\n            } else {\n              token = 148LL;\n            }\n            return;\n          case '(':\n          case ')':\n          case ',':\n          case ':':\n          case ';':\n          case ']':\n          case '{':\n          case '}':\n          case '~':\n            return;\n          case '*':\n            token = 159LL;\n            return;\n          case '+':\n            if (v0[1] == 43) {\n              token = 162LL;\n              src = v0 + 2;\n            } else {\n              token = 157LL;\n            }\n            return;\n          case '-':\n            if (v0[1] == 45) {\n              token = 163LL;\n              src = v0 + 2;\n            } else {\n              token = 158LL;\n            }\n            return;\n          case '/':\n            if (v0[1] != 47) {\n              token = 160LL;\n              return;\n            }\n            v21 = v0 + 2;\n            do {\n              src = v21;\n              v2 = *v21;\n              v0 = v21++;\n            } while (v2 && v2 != 10);\n            break;\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            v9 = v1 - 48;\n            token_val = v9;\n            v10 = v0[1];\n            if (v9) {\n              v24 = v0 + 2;\n              if ((unsigned char)(v10 - 48) <= 9u) {\n                do {\n                  src = v24;\n                  v25 = *(v24 - 1);\n                  v26 = v24++;\n                  v9 = v25 + 10 * v9 - 48;\n                  token_val = v9;\n                } while ((unsigned char)(*v26 - 48) <= 9u);\n              }\n            } else {\n              if ((v10 & 223) == 88) {\n                v28 = v0 + 2;\n                v29 = v0 + 3;\n                src = v28;\n                for (i = *(v29 - 1);; i = *(v29 - 1)) {\n                  token = i;\n                  if ((unsigned long long)(i - 48) > 9) {\n                    if ((i & 18446744073709551583LL) - 65 > 5) goto LABEL_18;\n                    v9 = (i & 15) + 16 * v9;\n                    if (i > 64) v9 += 9LL;\n                  } else {\n                    v9 = (i & 15) + 16 * v9;\n                  }\n                  src = v29++;\n                  token_val = v9;\n                }\n              }\n              v11 = v0 + 2;\n              if ((unsigned char)(v10 - 48) <= 7u) {\n                do {\n                  src = v11;\n                  v12 = *(v11 - 1);\n                  v13 = v11++;\n                  v9 = v12 + 8 * v9 - 48;\n                  token_val = v9;\n                } while ((unsigned char)(*v13 - 48) <= 7u);\n              }\n            }\n          LABEL_18:\n            token = 128LL;\n            return;\n          case '<':\n            v20 = v0[1];\n            if (v20 == 61) {\n              token = 153LL;\n              src = v0 + 2;\n            } else if (v20 == 60) {\n              token = 155LL;\n              src = v0 + 2;\n            } else {\n              token = 151LL;\n            }\n            return;\n          case '=':\n            if (v0[1] == 61) {\n              token = 149LL;\n              src = v0 + 2;\n            } else {\n              token = 142LL;\n            }\n            return;\n          case '>':\n            v19 = v0[1];\n            if (v19 == 61) {\n              token = 154LL;\n              src = v0 + 2;\n            } else if (v19 == 62) {\n              token = 156LL;\n              src = v0 + 2;\n            } else {\n              token = 152LL;\n            }\n            return;\n          case '?':\n            token = 143LL;\n            return;\n          case '[':\n            token = 164LL;\n            return;\n          case '^':\n            token = 147LL;\n            return;\n          case '_':\n            v1 = 95LL;\n            goto LABEL_8;\n          case '|':\n            if (v0[1] == 124) {\n              token = 144LL;\n              src = v0 + 2;\n            } else {\n              token = 146LL;\n            }\n            return;\n          default:\n            v2 = *++v0;\n            break;\n        }\n      }\n      v1 = v2;\n      token = v2;\n    } while (v2);\n  }\n}", "binary": "c-interp/c-interp.host.O3", "assembly": "<next>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x8d67(%rip),%r14\nmovsbq (%r14),%rbx\nmov    %rbx,0x8d8c(%rip)\ntest   %rbx,%rbx\nje     16e5 <next+0x145>\nmov    %rbx,%rdx\nlea    0x5f49(%rip),%rbp\nlea    0x5a26(%rip),%r13\nlea    0x5bcc(%rip),%r12\nlea    0x1(%r14),%rax\nmov    %rax,0x8d30(%rip)\ncmp    $0xa,%rbx\nje     16f8 <next+0x158>\ncmp    $0x23,%rbx\nje     1730 <next+0x190>\nmov    %edx,%ecx\nand    $0xffffffdf,%ecx\nsub    $0x41,%ecx\ncmp    $0x19,%cl\njbe    164a <next+0xaa>\nsub    $0x21,%edx\ncmp    $0x5d,%dl\nja     1770 <next+0x1d0>\nmovzbl %dl,%edx\nmovslq 0x0(%rbp,%rdx,4),%rdx\nadd    %rbp,%rdx\nnotrack jmp *%rdx\nnopl   0x0(%rax,%rax,1)\nlea    (%rbx,%rbx,8),%rcx\nadd    $0x1,%rax\nlea    (%rbx,%rcx,8),%rcx\nmov    %rax,0x8cdd(%rip)\nlea    (%rbx,%rcx,2),%rbx\nadd    %rdx,%rbx\nmovsbq (%rax),%rdx\nmov    %edx,%ecx\nand    $0xffffffdf,%ecx\nsub    $0x41,%ecx\ncmp    $0x19,%cl\njbe    1630 <next+0x90>\nlea    -0x30(%rdx),%ecx\ncmp    $0x9,%cl\njbe    1630 <next+0x90>\ncmp    $0x5f,%dl\nje     1630 <next+0x90>\nmov    0x8c69(%rip),%rax\ncmpq   $0x0,(%rax)\nmov    %rax,0x8c66(%rip)\njne    169e <next+0xfe>\njmp    1ae0 <next+0x540>\nnopl   0x0(%rax)\nlea    0x48(%rdx),%rax\ncmpq   $0x0,0x48(%rdx)\nmov    %rax,0x8c48(%rip)\nje     1ae0 <next+0x540>\nmov    %rax,%rdx\ncmp    %rbx,0x8(%rax)\njne    1688 <next+0xe8>\nmov    0x8c72(%rip),%rdx\nmov    0x10(%rax),%rdi\nmov    %r14,%rsi\nsub    %r14,%rdx\ncall   4ac0 <libmin_memcmp>\ntest   %eax,%eax\nje     1cc0 <next+0x720>\nmov    0x8c14(%rip),%rdx\njmp    1688 <next+0xe8>\nxchg   %ax,%ax\ncmp    $0x22,%rbx\nje     1b5d <next+0x5bd>\nmovq   $0x80,0x8c6b(%rip)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\ncmpq   $0x0,0x8c58(%rip)\njne    19d8 <next+0x438>\naddq   $0x1,0x8bc2(%rip)\nmovzbl (%rax),%edx\nmov    %rax,%r14\nmovsbq %dl,%rbx\nmov    %rbx,0x8c31(%rip)\ntest   %rbx,%rbx\njne    15e5 <next+0x45>\njmp    16e5 <next+0x145>\nnopw   0x0(%rax,%rax,1)\nmovzbl 0x1(%r14),%edx\ncmp    $0xa,%dl\nje     1c0b <next+0x66b>\ntest   %dl,%dl\nje     1c0b <next+0x66b>\nlea    0x2(%r14),%rax\nnopw   0x0(%rax,%rax,1)\nmov    %rax,0x8bc9(%rip)\nmovzbl (%rax),%edx\nmov    %rax,%r14\nadd    $0x1,%rax\ntest   %dl,%dl\nje     1714 <next+0x174>\ncmp    $0xa,%dl\njne    1750 <next+0x1b0>\njmp    1714 <next+0x174>\nnopl   0x0(%rax)\nmovzbl 0x1(%r14),%edx\nmov    %rax,%r14\njmp    1714 <next+0x174>\nnopw   0x0(%rax,%rax,1)\nsub    $0x30,%rbx\nmov    %rbx,0x8b3d(%rip)\nmovzbl 0x1(%r14),%eax\njne    1aff <next+0x55f>\nmov    %eax,%edx\nand    $0xffffffdf,%edx\ncmp    $0x58,%dl\nje     1c44 <next+0x6a4>\nsub    $0x30,%eax\nadd    $0x2,%r14\ncmp    $0x7,%al\nja     16da <next+0x13a>\nnopl   0x0(%rax,%rax,1)\nmov    %r14,0x8b61(%rip)\nmovsbq -0x1(%r14),%rdx\nmov    %r14,%rax\nadd    $0x1,%r14\nlea    -0x30(%rdx,%rbx,8),%rbx\nmov    %rbx,0x8af1(%rip)\nmovzbl (%rax),%eax\nsub    $0x30,%eax\ncmp    $0x7,%al\njbe    17b8 <next+0x218>\njmp    16da <next+0x13a>\nmov    0x8b43(%rip),%rdi\njmp    17fd <next+0x25d>\nnop\nmov    %rsi,%rax\ncmp    $0x22,%rbx\nje     1c1d <next+0x67d>\nmovsbq (%rax),%rdx\nlea    0x1(%rax),%rsi\nmov    %rsi,0x8b14(%rip)\ntest   %dl,%dl\nje     16d0 <next+0x130>\ncmp    %rbx,%rdx\nje     16d0 <next+0x130>\nmovsbq (%rax),%rcx\nmov    %rcx,0x8aa0(%rip)\nmov    %rcx,%rdx\ncmp    $0x5c,%rcx\njne    17f0 <next+0x250>\nlea    0x2(%rax),%rcx\nmov    %rcx,0x8ae4(%rip)\nmovsbq 0x1(%rax),%rax\nmov    %rax,%rdx\ncmp    $0x6e,%al\nje     1ac0 <next+0x520>\nmov    %rax,0x8a75(%rip)\nmov    %rcx,%rax\njmp    17f3 <next+0x253>\ncmpb   $0x3d,0x1(%r14)\njne    16e5 <next+0x145>\nmovq   $0x96,0x8ae2(%rip)\nadd    $0x2,%r14\nmov    %r14,0x8aa7(%rip)\njmp    16e5 <next+0x145>\nmovq   $0x8f,0x8ac7(%rip)\njmp    16e5 <next+0x145>\nmovq   $0xa1,0x8ab7(%rip)\njmp    16e5 <next+0x145>\ncmpb   $0x26,0x1(%r14)\nje     1b9f <next+0x5ff>\nmovq   $0x94,0x8a9c(%rip)\njmp    16e5 <next+0x145>\ncmpb   $0x3d,0x1(%r14)\nje     1b84 <next+0x5e4>\nmovq   $0x8e,0x8a81(%rip)\njmp    16e5 <next+0x145>\nmovzbl 0x1(%r14),%eax\ncmp    $0x3d,%al\nje     1b42 <next+0x5a2>\ncmp    $0x3e,%al\nje     1cd6 <next+0x736>\nmovq   $0x98,0x8a5c(%rip)\njmp    16e5 <next+0x145>\nmovq   $0xa4,0x8a4c(%rip)\njmp    16e5 <next+0x145>\nmovq   $0x93,0x8a3c(%rip)\njmp    16e5 <next+0x145>\ncmpb   $0x7c,0x1(%r14)\nje     1b69 <next+0x5c9>\nmovq   $0x92,0x8a21(%rip)\njmp    16e5 <next+0x145>\nmovzbl 0x1(%r14),%eax\ncmp    $0x3d,%al\nje     1bf0 <next+0x650>\ncmp    $0x3c,%al\nje     1cf1 <next+0x751>\nmovq   $0x97,0x89fc(%rip)\njmp    16e5 <next+0x145>\nmovq   $0x9f,0x89ec(%rip)\njmp    16e5 <next+0x145>\ncmpb   $0x2b,0x1(%r14)\nje     1bd5 <next+0x635>\nmovq   $0x9d,0x89d1(%rip)\njmp    16e5 <next+0x145>\ncmpb   $0x2d,0x1(%r14)\nje     1bba <next+0x61a>\nmovq   $0x9e,0x89b6(%rip)\njmp    16e5 <next+0x145>\ncmpb   $0x2f,0x1(%r14)\njne    1d0c <next+0x76c>\nlea    0x2(%r14),%rax\njmp    19b9 <next+0x419>\ncmp    $0xa,%dl\nje     1714 <next+0x174>\nmov    %rax,0x8960(%rip)\nmovzbl (%rax),%edx\nmov    %rax,%r14\nadd    $0x1,%rax\ntest   %dl,%dl\njne    19b0 <next+0x410>\njmp    1714 <next+0x174>\nnopl   0x0(%rax,%rax,1)\nmov    0x8939(%rip),%rcx\nmov    0x88ea(%rip),%rsi\nmov    %eax,%edx\nmov    %r13,%rdi\nsub    0x8927(%rip),%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    0x8921(%rip),%rax\nmov    0x8932(%rip),%rdx\ncmp    %rdx,0x893b(%rip)\nmov    %rax,0x8904(%rip)\njbe    1706 <next+0x166>\nlea    0x5797(%rip),%r14\nlea    0x55e6(%rip),%rbx\nlea    0x55f9(%rip),%r15\nnop\nlea    0x8(%rdx),%rax\nmov    %rbx,%rdi\nmov    %rax,0x88fa(%rip)\nmov    0x8(%rdx),%rax\nlea    (%rax,%rax,4),%rsi\nxor    %eax,%eax\nadd    %r14,%rsi\ncall   6c80 <libmin_printf>\nmov    0x88e1(%rip),%rax\ncmpq   $0x7,(%rax)\njg     1a98 <next+0x4f8>\nmov    0x8(%rax),%rsi\nlea    0x8(%rax),%rdx\nmov    %r15,%rdi\nxor    %eax,%eax\nmov    %rdx,0x88c7(%rip)\ncall   6c80 <libmin_printf>\nmov    0x88bb(%rip),%rdx\ncmp    0x88c4(%rip),%rdx\njb     1a30 <next+0x490>\nmov    0x8893(%rip),%rax\njmp    1706 <next+0x166>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nmov    %r12,%rdi\ncall   6c80 <libmin_printf>\nmov    0x888f(%rip),%rdx\ncmp    0x8898(%rip),%rdx\njb     1a30 <next+0x490>\njmp    1a86 <next+0x4e6>\nnopl   0x0(%rax,%rax,1)\nmovq   $0xa,0x87fd(%rip)\nmov    %rcx,%rax\nmov    $0xa,%edx\njmp    17f3 <next+0x253>\nnopl   0x0(%rax,%rax,1)\nmovq   $0x85,(%rax)\nmov    %r14,0x10(%rax)\nmov    %rbx,0x8(%rax)\nmovq   $0x85,0x8856(%rip)\njmp    16e5 <next+0x145>\nsub    $0x30,%eax\nadd    $0x2,%r14\ncmp    $0x9,%al\nja     16da <next+0x13a>\nxchg   %ax,%ax\nmov    %r14,0x8809(%rip)\nmovsbq -0x1(%r14),%rdx\nlea    (%rbx,%rbx,4),%rcx\nmov    %r14,%rax\nadd    $0x1,%r14\nlea    -0x30(%rdx,%rcx,2),%rbx\nmov    %rbx,0x8795(%rip)\nmovzbl (%rax),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\njbe    1b10 <next+0x570>\njmp    16da <next+0x13a>\nmovq   $0x9a,0x8803(%rip)\nadd    $0x2,%r14\nmov    %r14,0x87c8(%rip)\njmp    16e5 <next+0x145>\nmov    %rdi,0x8764(%rip)\njmp    16e5 <next+0x145>\nmovq   $0x90,0x87dc(%rip)\nadd    $0x2,%r14\nmov    %r14,0x87a1(%rip)\njmp    16e5 <next+0x145>\nmovq   $0x95,0x87c1(%rip)\nadd    $0x2,%r14\nmov    %r14,0x8786(%rip)\njmp    16e5 <next+0x145>\nmovq   $0x91,0x87a6(%rip)\nadd    $0x2,%r14\nmov    %r14,0x876b(%rip)\njmp    16e5 <next+0x145>\nmovq   $0xa3,0x878b(%rip)\nadd    $0x2,%r14\nmov    %r14,0x8750(%rip)\njmp    16e5 <next+0x145>\nmovq   $0xa2,0x8770(%rip)\nadd    $0x2,%r14\nmov    %r14,0x8735(%rip)\njmp    16e5 <next+0x145>\nmovq   $0x99,0x8755(%rip)\nadd    $0x2,%r14\nmov    %r14,0x871a(%rip)\njmp    16e5 <next+0x145>\nmov    %rax,%r14\njmp    1714 <next+0x174>\nmov    $0x5f,%ebx\njmp    164a <next+0xaa>\nmov    0x870c(%rip),%rax\nlea    0x1(%rax),%rcx\nmov    %rcx,0x8701(%rip)\nmov    %dl,(%rax)\nmov    0x8718(%rip),%rbx\nmov    0x86e1(%rip),%rax\njmp    17fd <next+0x25d>\nlea    0x2(%r14),%rax\nadd    $0x3,%r14\nmov    %rax,0x86cd(%rip)\nmovsbq -0x1(%r14),%rax\njmp    1ca3 <next+0x703>\nnopw   0x0(%rax,%rax,1)\nmov    %rax,%rdx\nand    $0xffffffffffffffdf,%rdx\nsub    $0x41,%rdx\ncmp    $0x5,%rdx\nja     16da <next+0x13a>\nmov    %rax,%rdx\nshl    $0x4,%rbx\nand    $0xf,%edx\nadd    %rdx,%rbx\ncmp    $0x40,%rax\njle    1c8c <next+0x6ec>\nadd    $0x9,%rbx\nmov    %r14,0x868d(%rip)\nadd    $0x1,%r14\nmov    %rbx,0x862a(%rip)\nmovsbq -0x1(%r14),%rax\nlea    -0x30(%rax),%rdx\nmov    %rax,0x86a2(%rip)\ncmp    $0x9,%rdx\nja     1c60 <next+0x6c0>\nand    $0xf,%eax\nshl    $0x4,%rbx\nadd    %rax,%rbx\njmp    1c8c <next+0x6ec>\nmov    0x8619(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x867f(%rip)\njmp    16e5 <next+0x145>\nmovq   $0x9c,0x866f(%rip)\nadd    $0x2,%r14\nmov    %r14,0x8634(%rip)\njmp    16e5 <next+0x145>\nmovq   $0x9b,0x8654(%rip)\nadd    $0x2,%r14\nmov    %r14,0x8619(%rip)\njmp    16e5 <next+0x145>\nmovq   $0xa0,0x8639(%rip)\njmp    16e5 <next+0x145>\nnopl   0x0(%rax)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "program", "content": "void program() {\n    // get next token\n    next();\n    while (token > 0) {\n        global_declaration();\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O3.pseudo", "function_name": "program", "address": "0x3e60", "label": "program", "content": "void __cdecl program()\n{\n  next();\n  while ( token > 0 )\n    global_declaration();\n}\n"}, "pseudo_normalize": "", "binary": "c-interp/c-interp.host.O3", "assembly": "<program>:\nendbr64\nsub    $0x8,%rsp\nxor    %eax,%eax\ncall   15a0 <next>\ncmpq   $0x0,0x64d9(%rip)\njle    3e91 <program+0x31>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   3b50 <global_declaration>\ncmpq   $0x0,0x64c1(%rip)\njg     3e80 <program+0x20>\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "statement", "content": "void statement() {\n    // there are 8 kinds of statements here:\n    // 1. if (...) <statement> [else <statement>]\n    // 2. while (...) <statement>\n    // 3. { <statement> }\n    // 4. return xxx;\n    // 5. <empty statement>;\n    // 6. expression; (expression end with semicolon)\n\n    long *a, *b; // bess for branch control\n\n    if (token == If) {\n        // if (...) <statement> [else <statement>]\n        //\n        //   if (...)           <cond>\n        //                      JZ a\n        //     <statement>      <statement>\n        //   else:              JMP b\n        // a:\n        //     <statement>      <statement>\n        // b:                   b:\n        //\n        //\n        match(If);\n        match('(');\n        expression(Assign);  // parse condition\n        match(')');\n\n        // emit code for if\n        *++text = JZ;\n        b = ++text;\n\n        statement();         // parse statement\n        if (token == Else) { // parse else\n            match(Else);\n\n            // emit code for JMP B\n            *b = (long)(text + 3);\n            *++text = JMP;\n            b = ++text;\n\n            statement();\n        }\n\n        *b = (long)(text + 1);\n    }\n    else if (token == While) {\n        //\n        // a:                     a:\n        //    while (<cond>)        <cond>\n        //                          JZ b\n        //     <statement>          <statement>\n        //                          JMP a\n        // b:                     b:\n        match(While);\n\n        a = text + 1;\n\n        match('(');\n        expression(Assign);\n        match(')');\n\n        *++text = JZ;\n        b = ++text;\n\n        statement();\n\n        *++text = JMP;\n        *++text = (long)a;\n        *b = (long)(text + 1);\n    }\n    else if (token == '{') {\n        // { <statement> ... }\n        match('{');\n\n        while (token != '}') {\n            statement();\n        }\n\n        match('}');\n    }\n    else if (token == Return) {\n        // return [expression];\n        match(Return);\n\n        if (token != ';') {\n            expression(Assign);\n        }\n\n        match(';');\n\n        // emit code for return\n        *++text = LEV;\n    }\n    else if (token == ';') {\n        // empty statement\n        match(';');\n    }\n    else {\n        // a = b; or function_call();\n        expression(Assign);\n        match(';');\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O3.pseudo", "function_name": "statement", "address": "0x31b0", "label": "statement", "content": "void __cdecl statement()\n{\n  _QWORD *v0; // rbp\n  _QWORD *v1; // rbx\n  char *v2; // rdx\n  char *v3; // rbp\n  _QWORD *v4; // rbx\n  _QWORD *v5; // rax\n  void *v6; // rdx\n\n  switch ( token )\n  {\n    case 137LL:\n      next();\n      if ( token != 40 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n        libmin_fail(-1);\n      }\n      next();\n      expression(142LL);\n      if ( token != 41 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n        libmin_fail(-1);\n      }\n      next();\n      v0 = text;\n      *((_QWORD *)text + 1) = 4LL;\n      v1 = v0 + 2;\n      text = v0 + 2;\n      statement();\n      if ( token == 135 )\n      {\n        next();\n        v1 = (char *)text + 16;\n        v0[2] = (char *)text + 24;\n        *(v1 - 1) = 2LL;\n        text = v1;\n        statement();\n      }\n      *v1 = (char *)text + 8;\n      break;\n    case 141LL:\n      next();\n      v3 = (char *)text + 8;\n      if ( token != 40 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n        libmin_fail(-1);\n      }\n      next();\n      expression(142LL);\n      if ( token != 41 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n        libmin_fail(-1);\n      }\n      next();\n      v4 = text;\n      *((_QWORD *)text + 1) = 4LL;\n      text = v4 + 2;\n      statement();\n      v5 = text;\n      *((_QWORD *)text + 1) = 2LL;\n      v6 = v5 + 2;\n      v5 += 3;\n      *(v5 - 1) = v3;\n      text = v6;\n      v4[2] = v5;\n      break;\n    case 123LL:\n      next();\n      while ( token != 125 )\n        statement();\n      goto LABEL_10;\n    case 139LL:\n      next();\n      if ( token != 59 )\n      {\n        expression(142LL);\n        if ( token != 59 )\n        {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 59LL);\n          libmin_fail(-1);\n        }\n      }\n      next();\n      v2 = (char *)text + 8;\n      *((_QWORD *)text + 1) = 8LL;\n      text = v2;\n      break;\n    default:\n      if ( token != 59 )\n      {\n        expression(142LL);\n        if ( token != 59 )\n        {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 59LL);\n          libmin_fail(-1);\n        }\n      }\nLABEL_10:\n      next();\n      return;\n  }\n}\n"}, "pseudo_normalize": "void statement() {\n  uint64_t *v0;\n  uint64_t *v1;\n  char *v2;\n  char *v3;\n  uint64_t *v4;\n  uint64_t *v5;\n  void *v6;\n  switch (token) {\n    case 137LL:\n      next();\n      if (token != 40) {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n        libmin_fail(-1);\n      }\n      next();\n      expression(142LL);\n      if (token != 41) {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n        libmin_fail(-1);\n      }\n      next();\n      v0 = text;\n      *((uint64_t *)text + 1) = 4LL;\n      v1 = v0 + 2;\n      text = v0 + 2;\n      statement();\n      if (token == 135) {\n        next();\n        v1 = (char *)text + 16;\n        v0[2] = (char *)text + 24;\n        *(v1 - 1) = 2LL;\n        text = v1;\n        statement();\n      }\n      *v1 = (char *)text + 8;\n      break;\n    case 141LL:\n      next();\n      v3 = (char *)text + 8;\n      if (token != 40) {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n        libmin_fail(-1);\n      }\n      next();\n      expression(142LL);\n      if (token != 41) {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n        libmin_fail(-1);\n      }\n      next();\n      v4 = text;\n      *((uint64_t *)text + 1) = 4LL;\n      text = v4 + 2;\n      statement();\n      v5 = text;\n      *((uint64_t *)text + 1) = 2LL;\n      v6 = v5 + 2;\n      v5 += 3;\n      *(v5 - 1) = v3;\n      text = v6;\n      v4[2] = v5;\n      break;\n    case 123LL:\n      next();\n      while (token != 125) statement();\n      goto LABEL_10;\n    case 139LL:\n      next();\n      if (token != 59) {\n        expression(142LL);\n        if (token != 59) {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 59LL);\n          libmin_fail(-1);\n        }\n      }\n      next();\n      v2 = (char *)text + 8;\n      *((uint64_t *)text + 1) = 8LL;\n      text = v2;\n      break;\n    default:\n      if (token != 59) {\n        expression(142LL);\n        if (token != 59) {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 59LL);\n          libmin_fail(-1);\n        }\n      }\n    LABEL_10:\n      next();\n      return;\n  }\n}", "binary": "c-interp/c-interp.host.O3", "assembly": "<statement>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x718f(%rip),%rax\ncmp    $0x89,%rax\nje     3260 <statement+0xb0>\ncmp    $0x8d,%rax\nje     3370 <statement+0x1c0>\ncmp    $0x7b,%rax\nje     3230 <statement+0x80>\ncmp    $0x8b,%rax\nje     3320 <statement+0x170>\ncmp    $0x3b,%rax\nje     3252 <statement+0xa2>\nmov    $0x8e,%edi\ncall   1d70 <expression>\ncmpq   $0x3b,0x714d(%rip)\nje     3252 <statement+0xa2>\nmov    0x70c4(%rip),%rsi\nlea    0x3e01(%rip),%rdi\nmov    $0x3b,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nadd    $0x8,%rsp\nmov    $0xffffffff,%edi\npop    %rbx\npop    %rbp\njmp    47f0 <libmin_fail>\nnop\nxor    %eax,%eax\ncall   15a0 <next>\ncmpq   $0x7d,0x7111(%rip)\nje     3252 <statement+0xa2>\nxor    %eax,%eax\ncall   31b0 <statement>\ncmpq   $0x7d,0x7100(%rip)\njne    3241 <statement+0x91>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\njmp    15a0 <next>\nnop\nxor    %eax,%eax\ncall   15a0 <next>\ncmpq   $0x28,0x70e1(%rip)\nje     3360 <statement+0x1b0>\nmov    0x7054(%rip),%rsi\nlea    0x3d91(%rip),%rdi\nmov    $0x28,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    $0x8e,%edi\ncall   1d70 <expression>\ncmpq   $0x29,0x70a5(%rip)\nje     3440 <statement+0x290>\nmov    0x7018(%rip),%rsi\nlea    0x3d55(%rip),%rdi\nmov    $0x29,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x706c(%rip),%rbp\nxor    %eax,%eax\nmovq   $0x4,0x8(%rbp)\nlea    0x10(%rbp),%rbx\nmov    %rbx,0x7057(%rip)\ncall   31b0 <statement>\ncmpq   $0x87,0x704f(%rip)\nje     34b8 <statement+0x308>\nmov    0x703a(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,(%rbx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\ncmpq   $0x3b,0x7021(%rip)\njne    3450 <statement+0x2a0>\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x7005(%rip),%rax\nlea    0x8(%rax),%rdx\nmovq   $0x8,0x8(%rax)\nmov    %rdx,0x6ff2(%rip)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   (%rax)\nxor    %eax,%eax\ncall   15a0 <next>\njmp    3299 <statement+0xe9>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x6fca(%rip),%rax\ncmpq   $0x28,0x6fca(%rip)\nlea    0x8(%rax),%rbp\nje     34a8 <statement+0x2f8>\nmov    0x6f39(%rip),%rsi\nlea    0x3c76(%rip),%rdi\nmov    $0x28,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    $0x8e,%edi\ncall   1d70 <expression>\ncmpq   $0x29,0x6f8a(%rip)\nje     3498 <statement+0x2e8>\nmov    0x6efd(%rip),%rsi\nlea    0x3c3a(%rip),%rdi\nmov    $0x29,%edx\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\nmov    0x6f51(%rip),%rbx\nmovq   $0x4,0x8(%rbx)\nlea    0x10(%rbx),%rax\nmov    %rax,0x6f3e(%rip)\nxor    %eax,%eax\ncall   31b0 <statement>\nmov    0x6f30(%rip),%rax\nmovq   $0x2,0x8(%rax)\nlea    0x10(%rax),%rdx\nadd    $0x18,%rax\nmov    %rbp,-0x8(%rax)\nmov    %rdx,0x6f15(%rip)\nmov    %rax,0x10(%rbx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nxchg   %ax,%ax\nxor    %eax,%eax\ncall   15a0 <next>\njmp    32d5 <statement+0x125>\nnopl   0x0(%rax)\nmov    $0x8e,%edi\ncall   1d70 <expression>\ncmpq   $0x3b,0x6eee(%rip)\nje     3335 <statement+0x185>\nmov    0x6e61(%rip),%rsi\nmov    $0x3b,%edx\nlea    0x3b99(%rip),%rdi\nxor    %eax,%eax\ncall   6c80 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47f0 <libmin_fail>\njmp    333c <statement+0x18c>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\njmp    33f0 <statement+0x240>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\njmp    33b4 <statement+0x204>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   15a0 <next>\nmov    0x6e82(%rip),%rbx\nlea    0x18(%rbx),%rax\nadd    $0x10,%rbx\nmov    %rax,0x10(%rbp)\nxor    %eax,%eax\nmovq   $0x2,-0x8(%rbx)\nmov    %rbx,0x6e65(%rip)\ncall   31b0 <statement>\njmp    3307 <statement+0x157>\nnopl   (%rax)\n"}
{"source": {"path": "ccmac/ccmac.c", "function_name": "main", "content": " // [0,1)\n\nint\nmain(void)\n{\n  const size_t n = (size_t)N_ELEMS, stride = (size_t)STRIDE;\n  rng = (SEED?SEED:1);\n\n  // Inputs and outputs\n  double *x = (double*)libmin_malloc(n*sizeof(double));\n  double *y = (double*)libmin_malloc(n*sizeof(double));\n  if(!x || !y){ libmin_printf(\"alloc failed\\n\"); libmin_fail(1); }\n\n  // Coefficients c[0..DEGREE] in a reasonable range\n  double *c = (double*)libmin_malloc((DEGREE+1)*sizeof(double));\n  if(!c){ libmin_printf(\"alloc failed\\n\"); libmin_fail(1); }\n  for(int k=0;k<=DEGREE;k++){ c[k] = -1.0 + 2.0*urand01(); }\n\n  // Inputs in [-1,1] to keep values bounded\n  for(size_t i=0, idx=0;i<n;i++, idx=(idx+stride)%n){\n    x[idx] = -1.0 + 2.0*urand01();\n    y[idx] = 0.0;\n  }\n\n  volatile double sink = 0.0;\n\n  for(uint64_t it=0; it<(uint64_t)N_ITER; ++it){\n    for(size_t i=0, idx=0;i<n;i++, idx=(idx+stride)%n){\n      double acc = c[DEGREE];\n      // Horner loop: DEGREE FMAs (or mul+add if fma not used)\n      for(int k=DEGREE-1;k>=0;k--)\n        acc = fma(acc, x[idx], c[k]);\n      y[idx] = acc;\n      sink += acc * 1e-16;\n    }\n  }\n\n  // Report\n  const double ops = (double)N_ITER * (double)n * (double)(2*DEGREE); // FMA counted as 2 flops\n  double checksum = 0.0; for(size_t i=0;i<n;i++) checksum += y[i];\n\n  libmin_printf(\"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n         DEGREE, (unsigned)N_ITER, n, stride, ops, checksum);\n\n  libmin_free(c); libmin_free((void*)x); libmin_free((void*)y);\n\n  libmin_success();\n}\n"}, "pseudo": {"path": "ccmac/ccmac.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double *v3; // r13\n  double *v4; // rax\n  double *v5; // r12\n  __m128d *v6; // rbp\n  __m128d v7; // xmm0\n  __m128d v8; // xmm1\n  __m128d v9; // xmm3\n  uint64_t v10; // rbx\n  uint64_t v11; // r11\n  uint64_t v12; // rax\n  uint64_t v13; // r10\n  unsigned __int64 v14; // r9\n  unsigned __int64 v15; // r8\n  unsigned __int64 v16; // rdi\n  unsigned __int64 v17; // rsi\n  unsigned __int64 v18; // rcx\n  unsigned __int64 v19; // rdx\n  unsigned __int64 v20; // rax\n  unsigned __int64 v21; // r15\n  unsigned __int64 v22; // r14\n  unsigned __int64 v23; // r14\n  __m128d v24; // xmm0\n  __m128d v25; // xmm0\n  __m128d v26; // xmm0\n  __m128d v27; // xmm3\n  __m128d v28; // xmm0\n  __m128d v29; // xmm0\n  __m128d v30; // xmm0\n  __m128d v31; // xmm3\n  __m128d v32; // xmm0\n  __int64 v33; // rcx\n  __m128d v34; // xmm0\n  __int64 v35; // rsi\n  __m128d v36; // xmm0\n  __m128d v37; // xmm3\n  __m128d v38; // xmm0\n  __m128d v39; // xmm0\n  __m128d v40; // xmm0\n  __m128d v41; // xmm3\n  __m128d v42; // xmm0\n  __m128d v43; // xmm0\n  __m128d v44; // xmm0\n  __m128d v45; // xmm3\n  __m128d v46; // xmm0\n  __m128d v47; // xmm0\n  __m128d v48; // xmm0\n  __m128d v49; // xmm3\n  __m128d v50; // xmm0\n  __m128d v51; // xmm0\n  __m128d v52; // xmm0\n  uint64_t v53; // rax\n  uint64_t v54; // r8\n  __int64 v55; // rax\n  double *v56; // rdi\n  double v57; // xmm0_8\n  __int64 v58; // rcx\n  __int64 v59; // rax\n  __int64 v60; // rdx\n  double v61; // xmm2_8\n  double v62; // xmm0_8\n  double *v63; // rax\n  double v64; // xmm1_8\n  double v65; // xmm0_8\n  unsigned __int64 v66; // [rsp+8h] [rbp-70h]\n  unsigned __int64 v67; // [rsp+10h] [rbp-68h]\n  unsigned __int64 v68; // [rsp+18h] [rbp-60h]\n  unsigned __int64 v69; // [rsp+20h] [rbp-58h]\n  double sink; // [rsp+38h] [rbp-40h]\n\n  rng = 1LL;\n  v3 = (double *)libmin_malloc(0x200uLL);\n  v4 = (double *)libmin_malloc(0x200uLL);\n  v5 = v4;\n  if ( v3 && v4 )\n  {\n    v6 = (__m128d *)libmin_malloc(0x88uLL);\n    if ( v6 )\n    {\n      v7 = 0LL;\n      v8 = 0LL;\n      v9 = 0LL;\n      v10 = ((rng ^ (rng << 13)) >> 7) ^ rng ^ (rng << 13) ^ ((((rng ^ (rng << 13)) >> 7) ^ rng ^ (rng << 13)) << 17);\n      v11 = v10 ^ (v10 << 13) ^ ((v10 ^ (v10 << 13)) >> 7) ^ ((v10 ^ (v10 << 13) ^ ((v10 ^ (v10 << 13)) >> 7)) << 17);\n      v12 = v11 ^ (v11 << 13) ^ ((v11 ^ (v11 << 13)) >> 7);\n      v13 = v12 ^ (v12 << 17);\n      v14 = v13 ^ (v13 << 13) ^ ((v13 ^ (v13 << 13)) >> 7) ^ ((v13 ^ (v13 << 13) ^ ((v13 ^ (v13 << 13)) >> 7)) << 17);\n      v15 = v14 ^ (v14 << 13) ^ ((v14 ^ (v14 << 13)) >> 7) ^ ((v14 ^ (v14 << 13) ^ ((v14 ^ (v14 << 13)) >> 7)) << 17);\n      v16 = v15 ^ (v15 << 13) ^ ((v15 ^ (v15 << 13)) >> 7) ^ ((v15 ^ (v15 << 13) ^ ((v15 ^ (v15 << 13)) >> 7)) << 17);\n      v17 = v16 ^ (v16 << 13) ^ ((v16 ^ (v16 << 13)) >> 7) ^ ((v16 ^ (v16 << 13) ^ ((v16 ^ (v16 << 13)) >> 7)) << 17);\n      v18 = v17 ^ (v17 << 13) ^ ((v17 ^ (v17 << 13)) >> 7) ^ ((v17 ^ (v17 << 13) ^ ((v17 ^ (v17 << 13)) >> 7)) << 17);\n      v19 = v18 ^ (v18 << 13) ^ ((v18 ^ (v18 << 13)) >> 7) ^ ((v18 ^ (v18 << 13) ^ ((v18 ^ (v18 << 13)) >> 7)) << 17);\n      v20 = v19 ^ (v19 << 13) ^ ((v19 ^ (v19 << 13)) >> 7) ^ ((v19 ^ (v19 << 13) ^ ((v19 ^ (v19 << 13)) >> 7)) << 17);\n      v21 = v20 ^ (v20 << 13) ^ ((v20 ^ (v20 << 13)) >> 7) ^ ((v20 ^ (v20 << 13) ^ ((v20 ^ (v20 << 13)) >> 7)) << 17);\n      v69 = ((v21 ^ (v21 << 13)) >> 7) ^ v21 ^ (v21 << 13) ^ ((((v21 ^ (v21 << 13)) >> 7) ^ v21 ^ (v21 << 13)) << 17);\n      v68 = ((v69 ^ (v69 << 13)) >> 7) ^ v69 ^ (v69 << 13) ^ ((((v69 ^ (v69 << 13)) >> 7) ^ v69 ^ (v69 << 13)) << 17);\n      v67 = ((v68 ^ (v68 << 13)) >> 7) ^ v68 ^ (v68 << 13) ^ ((((v68 ^ (v68 << 13)) >> 7) ^ v68 ^ (v68 << 13)) << 17);\n      v66 = ((v67 ^ (v67 << 13)) >> 7) ^ v67 ^ (v67 << 13) ^ ((((v67 ^ (v67 << 13)) >> 7) ^ v67 ^ (v67 << 13)) << 17);\n      v22 = v66 ^ (v66 << 13) ^ ((v66 ^ (v66 << 13)) >> 7);\n      v23 = (v22 << 17) ^ v22;\n      v7.m128d_f64[0] = (double)(int)(v10 >> 11);\n      v8.m128d_f64[0] = (double)(int)(v11 >> 11);\n      v9.m128d_f64[0] = (double)(int)(v14 >> 11);\n      v24 = _mm_mul_pd(_mm_unpacklo_pd(v7, v8), (__m128d)xmmword_5060);\n      *v6 = _mm_add_pd(_mm_add_pd(v24, v24), (__m128d)xmmword_5070);\n      v25 = 0LL;\n      v25.m128d_f64[0] = (double)(int)(v13 >> 11);\n      v26 = _mm_unpacklo_pd(v25, v9);\n      v27 = 0LL;\n      v28 = _mm_mul_pd(v26, (__m128d)xmmword_5060);\n      v27.m128d_f64[0] = (double)(int)(v16 >> 11);\n      v6[1] = _mm_add_pd(_mm_add_pd(v28, v28), (__m128d)xmmword_5070);\n      v29 = 0LL;\n      v29.m128d_f64[0] = (double)(int)(v15 >> 11);\n      v30 = _mm_unpacklo_pd(v29, v27);\n      v31 = 0LL;\n      v32 = _mm_mul_pd(v30, (__m128d)xmmword_5060);\n      v31.m128d_f64[0] = (double)(int)(v18 >> 11);\n      v33 = 0LL;\n      v6[2] = _mm_add_pd(_mm_add_pd(v32, v32), (__m128d)xmmword_5070);\n      v34 = 0LL;\n      v34.m128d_f64[0] = (double)(int)(v17 >> 11);\n      v35 = 64LL;\n      v36 = _mm_unpacklo_pd(v34, v31);\n      v37 = 0LL;\n      v38 = _mm_mul_pd(v36, (__m128d)xmmword_5060);\n      v37.m128d_f64[0] = (double)(int)(v20 >> 11);\n      v6[3] = _mm_add_pd(_mm_add_pd(v38, v38), (__m128d)xmmword_5070);\n      v39 = 0LL;\n      v39.m128d_f64[0] = (double)(int)(v19 >> 11);\n      v40 = _mm_unpacklo_pd(v39, v37);\n      v41 = 0LL;\n      v42 = _mm_mul_pd(v40, (__m128d)xmmword_5060);\n      v6[4] = _mm_add_pd(_mm_add_pd(v42, v42), (__m128d)xmmword_5070);\n      v43 = 0LL;\n      v43.m128d_f64[0] = (double)(int)(v21 >> 11);\n      v41.m128d_f64[0] = (double)(int)(v69 >> 11);\n      v44 = _mm_unpacklo_pd(v43, v41);\n      v45 = 0LL;\n      v46 = _mm_mul_pd(v44, (__m128d)xmmword_5060);\n      v6[5] = _mm_add_pd(_mm_add_pd(v46, v46), (__m128d)xmmword_5070);\n      v47 = 0LL;\n      v47.m128d_f64[0] = (double)(int)(v68 >> 11);\n      v45.m128d_f64[0] = (double)(int)(v67 >> 11);\n      v48 = _mm_unpacklo_pd(v47, v45);\n      v49 = 0LL;\n      v50 = _mm_mul_pd(v48, (__m128d)xmmword_5060);\n      v6[6] = _mm_add_pd(_mm_add_pd(v50, v50), (__m128d)xmmword_5070);\n      v51 = 0LL;\n      v51.m128d_f64[0] = (double)(int)(v66 >> 11);\n      v49.m128d_f64[0] = (double)(int)(v23 >> 11);\n      v52 = _mm_mul_pd(_mm_unpacklo_pd(v51, v49), (__m128d)xmmword_5060);\n      v53 = ((((v23 ^ (v23 << 13)) >> 7) ^ v23 ^ (v23 << 13)) << 17) ^ ((v23 ^ (v23 << 13)) >> 7) ^ v23 ^ (v23 << 13);\n      v54 = v53;\n      v6[7] = _mm_add_pd(_mm_add_pd(v52, v52), (__m128d)xmmword_5070);\n      v6[8].m128d_f64[0] = (double)(int)(v53 >> 11) * 1.110223024625157e-16\n                         + (double)(int)(v53 >> 11) * 1.110223024625157e-16\n                         - 1.0;\n      do\n      {\n        v54 ^= ((v54 ^ (v54 << 13)) >> 7) ^ (v54 << 13) ^ ((((v54 ^ (v54 << 13)) >> 7) ^ v54 ^ (v54 << 13)) << 17);\n        v55 = v33;\n        v56 = &v3[v33];\n        v33 = ((_BYTE)v33 + 1) & 0x3F;\n        v57 = (double)(int)(v54 >> 11) * 1.110223024625157e-16 + (double)(int)(v54 >> 11) * 1.110223024625157e-16 - 1.0;\n        v3[v55] = v57;\n        v5[v55] = 0.0;\n        --v35;\n      }\n      while ( v35 );\n      *v56 = v57;\n      v58 = 100LL;\n      rng = v54;\n      v5[v55] = 0.0;\n      sink = 0.0;\n      do\n      {\n        v59 = 0LL;\n        v60 = 64LL;\n        do\n        {\n          v61 = v3[v59];\n          v62 = (((((((((((((((v6[8].m128d_f64[0] * v61 + v6[7].m128d_f64[1]) * v61 + v6[7].m128d_f64[0]) * v61\n                           + v6[6].m128d_f64[1])\n                          * v61\n                          + v6[6].m128d_f64[0])\n                         * v61\n                         + v6[5].m128d_f64[1])\n                        * v61\n                        + v6[5].m128d_f64[0])\n                       * v61\n                       + v6[4].m128d_f64[1])\n                      * v61\n                      + v6[4].m128d_f64[0])\n                     * v61\n                     + v6[3].m128d_f64[1])\n                    * v61\n                    + v6[3].m128d_f64[0])\n                   * v61\n                   + v6[2].m128d_f64[1])\n                  * v61\n                  + v6[2].m128d_f64[0])\n                 * v61\n                 + v6[1].m128d_f64[1])\n                * v61\n                + v6[1].m128d_f64[0])\n               * v61\n               + v6->m128d_f64[1])\n              * v61\n              + v6->m128d_f64[0];\n          v5[v59] = v62;\n          v59 = ((_BYTE)v59 + 1) & 0x3F;\n          sink = v62 * 1.0e-16 + sink;\n          --v60;\n        }\n        while ( v60 );\n        --v58;\n      }\n      while ( v58 );\n      v63 = v5;\n      v64 = 0.0;\n      do\n      {\n        v65 = *v63;\n        v63 += 2;\n        v64 = v64 + v65 + *(v63 - 1);\n      }\n      while ( v63 != v5 + 64 );\n      libmin_printf(\"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\", 16, 100, 64, 1, 204800.0, v64);\n      libmin_free(v6);\n      libmin_free(v3);\n      libmin_free(v5);\n      libmin_success();\n    }\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  libmin_printf(\"alloc failed\\n\", argv);\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double *v3;\n  double *v4;\n  double *v5;\n  __m128d *v6;\n  __m128d v7;\n  __m128d v8;\n  __m128d v9;\n  uint64_t v10;\n  uint64_t v11;\n  uint64_t v12;\n  uint64_t v13;\n  unsigned long long v14;\n  unsigned long long v15;\n  unsigned long long v16;\n  unsigned long long v17;\n  unsigned long long v18;\n  unsigned long long v19;\n  unsigned long long v20;\n  unsigned long long v21;\n  unsigned long long v22;\n  unsigned long long v23;\n  __m128d v24;\n  __m128d v25;\n  __m128d v26;\n  __m128d v27;\n  __m128d v28;\n  __m128d v29;\n  __m128d v30;\n  __m128d v31;\n  __m128d v32;\n  long long v33;\n  __m128d v34;\n  long long v35;\n  __m128d v36;\n  __m128d v37;\n  __m128d v38;\n  __m128d v39;\n  __m128d v40;\n  __m128d v41;\n  __m128d v42;\n  __m128d v43;\n  __m128d v44;\n  __m128d v45;\n  __m128d v46;\n  __m128d v47;\n  __m128d v48;\n  __m128d v49;\n  __m128d v50;\n  __m128d v51;\n  __m128d v52;\n  uint64_t v53;\n  uint64_t v54;\n  long long v55;\n  double *v56;\n  double v57;\n  long long v58;\n  long long v59;\n  long long v60;\n  double v61;\n  double v62;\n  double *v63;\n  double v64;\n  double v65;\n  unsigned long long v66;\n  unsigned long long v67;\n  unsigned long long v68;\n  unsigned long long v69;\n  double sink;\n  rng = 1LL;\n  v3 = (double *)libmin_malloc(512uLL);\n  v4 = (double *)libmin_malloc(512uLL);\n  v5 = v4;\n  if (v3 && v4) {\n    v6 = (__m128d *)libmin_malloc(136uLL);\n    if (v6) {\n      v7 = 0LL;\n      v8 = 0LL;\n      v9 = 0LL;\n      v10 = ((rng ^ (rng << 13)) >> 7) ^ rng ^ (rng << 13) ^\n            ((((rng ^ (rng << 13)) >> 7) ^ rng ^ (rng << 13)) << 17);\n      v11 = v10 ^ (v10 << 13) ^ ((v10 ^ (v10 << 13)) >> 7) ^\n            ((v10 ^ (v10 << 13) ^ ((v10 ^ (v10 << 13)) >> 7)) << 17);\n      v12 = v11 ^ (v11 << 13) ^ ((v11 ^ (v11 << 13)) >> 7);\n      v13 = v12 ^ (v12 << 17);\n      v14 = v13 ^ (v13 << 13) ^ ((v13 ^ (v13 << 13)) >> 7) ^\n            ((v13 ^ (v13 << 13) ^ ((v13 ^ (v13 << 13)) >> 7)) << 17);\n      v15 = v14 ^ (v14 << 13) ^ ((v14 ^ (v14 << 13)) >> 7) ^\n            ((v14 ^ (v14 << 13) ^ ((v14 ^ (v14 << 13)) >> 7)) << 17);\n      v16 = v15 ^ (v15 << 13) ^ ((v15 ^ (v15 << 13)) >> 7) ^\n            ((v15 ^ (v15 << 13) ^ ((v15 ^ (v15 << 13)) >> 7)) << 17);\n      v17 = v16 ^ (v16 << 13) ^ ((v16 ^ (v16 << 13)) >> 7) ^\n            ((v16 ^ (v16 << 13) ^ ((v16 ^ (v16 << 13)) >> 7)) << 17);\n      v18 = v17 ^ (v17 << 13) ^ ((v17 ^ (v17 << 13)) >> 7) ^\n            ((v17 ^ (v17 << 13) ^ ((v17 ^ (v17 << 13)) >> 7)) << 17);\n      v19 = v18 ^ (v18 << 13) ^ ((v18 ^ (v18 << 13)) >> 7) ^\n            ((v18 ^ (v18 << 13) ^ ((v18 ^ (v18 << 13)) >> 7)) << 17);\n      v20 = v19 ^ (v19 << 13) ^ ((v19 ^ (v19 << 13)) >> 7) ^\n            ((v19 ^ (v19 << 13) ^ ((v19 ^ (v19 << 13)) >> 7)) << 17);\n      v21 = v20 ^ (v20 << 13) ^ ((v20 ^ (v20 << 13)) >> 7) ^\n            ((v20 ^ (v20 << 13) ^ ((v20 ^ (v20 << 13)) >> 7)) << 17);\n      v69 = ((v21 ^ (v21 << 13)) >> 7) ^ v21 ^ (v21 << 13) ^\n            ((((v21 ^ (v21 << 13)) >> 7) ^ v21 ^ (v21 << 13)) << 17);\n      v68 = ((v69 ^ (v69 << 13)) >> 7) ^ v69 ^ (v69 << 13) ^\n            ((((v69 ^ (v69 << 13)) >> 7) ^ v69 ^ (v69 << 13)) << 17);\n      v67 = ((v68 ^ (v68 << 13)) >> 7) ^ v68 ^ (v68 << 13) ^\n            ((((v68 ^ (v68 << 13)) >> 7) ^ v68 ^ (v68 << 13)) << 17);\n      v66 = ((v67 ^ (v67 << 13)) >> 7) ^ v67 ^ (v67 << 13) ^\n            ((((v67 ^ (v67 << 13)) >> 7) ^ v67 ^ (v67 << 13)) << 17);\n      v22 = v66 ^ (v66 << 13) ^ ((v66 ^ (v66 << 13)) >> 7);\n      v23 = (v22 << 17) ^ v22;\n      v7.m128d_f64[0] = (double)(int)(v10 >> 11);\n      v8.m128d_f64[0] = (double)(int)(v11 >> 11);\n      v9.m128d_f64[0] = (double)(int)(v14 >> 11);\n      v24 = _mm_mul_pd(_mm_unpacklo_pd(v7, v8), (__m128d)xmmword_5060);\n      *v6 = _mm_add_pd(_mm_add_pd(v24, v24), (__m128d)xmmword_5070);\n      v25 = 0LL;\n      v25.m128d_f64[0] = (double)(int)(v13 >> 11);\n      v26 = _mm_unpacklo_pd(v25, v9);\n      v27 = 0LL;\n      v28 = _mm_mul_pd(v26, (__m128d)xmmword_5060);\n      v27.m128d_f64[0] = (double)(int)(v16 >> 11);\n      v6[1] = _mm_add_pd(_mm_add_pd(v28, v28), (__m128d)xmmword_5070);\n      v29 = 0LL;\n      v29.m128d_f64[0] = (double)(int)(v15 >> 11);\n      v30 = _mm_unpacklo_pd(v29, v27);\n      v31 = 0LL;\n      v32 = _mm_mul_pd(v30, (__m128d)xmmword_5060);\n      v31.m128d_f64[0] = (double)(int)(v18 >> 11);\n      v33 = 0LL;\n      v6[2] = _mm_add_pd(_mm_add_pd(v32, v32), (__m128d)xmmword_5070);\n      v34 = 0LL;\n      v34.m128d_f64[0] = (double)(int)(v17 >> 11);\n      v35 = 64LL;\n      v36 = _mm_unpacklo_pd(v34, v31);\n      v37 = 0LL;\n      v38 = _mm_mul_pd(v36, (__m128d)xmmword_5060);\n      v37.m128d_f64[0] = (double)(int)(v20 >> 11);\n      v6[3] = _mm_add_pd(_mm_add_pd(v38, v38), (__m128d)xmmword_5070);\n      v39 = 0LL;\n      v39.m128d_f64[0] = (double)(int)(v19 >> 11);\n      v40 = _mm_unpacklo_pd(v39, v37);\n      v41 = 0LL;\n      v42 = _mm_mul_pd(v40, (__m128d)xmmword_5060);\n      v6[4] = _mm_add_pd(_mm_add_pd(v42, v42), (__m128d)xmmword_5070);\n      v43 = 0LL;\n      v43.m128d_f64[0] = (double)(int)(v21 >> 11);\n      v41.m128d_f64[0] = (double)(int)(v69 >> 11);\n      v44 = _mm_unpacklo_pd(v43, v41);\n      v45 = 0LL;\n      v46 = _mm_mul_pd(v44, (__m128d)xmmword_5060);\n      v6[5] = _mm_add_pd(_mm_add_pd(v46, v46), (__m128d)xmmword_5070);\n      v47 = 0LL;\n      v47.m128d_f64[0] = (double)(int)(v68 >> 11);\n      v45.m128d_f64[0] = (double)(int)(v67 >> 11);\n      v48 = _mm_unpacklo_pd(v47, v45);\n      v49 = 0LL;\n      v50 = _mm_mul_pd(v48, (__m128d)xmmword_5060);\n      v6[6] = _mm_add_pd(_mm_add_pd(v50, v50), (__m128d)xmmword_5070);\n      v51 = 0LL;\n      v51.m128d_f64[0] = (double)(int)(v66 >> 11);\n      v49.m128d_f64[0] = (double)(int)(v23 >> 11);\n      v52 = _mm_mul_pd(_mm_unpacklo_pd(v51, v49), (__m128d)xmmword_5060);\n      v53 = ((((v23 ^ (v23 << 13)) >> 7) ^ v23 ^ (v23 << 13)) << 17) ^\n            ((v23 ^ (v23 << 13)) >> 7) ^ v23 ^ (v23 << 13);\n      v54 = v53;\n      v6[7] = _mm_add_pd(_mm_add_pd(v52, v52), (__m128d)xmmword_5070);\n      v6[8].m128d_f64[0] = (double)(int)(v53 >> 11) * 1.110223024625157e-16 +\n                           (double)(int)(v53 >> 11) * 1.110223024625157e-16 -\n                           1.0;\n      do {\n        v54 ^= ((v54 ^ (v54 << 13)) >> 7) ^ (v54 << 13) ^\n               ((((v54 ^ (v54 << 13)) >> 7) ^ v54 ^ (v54 << 13)) << 17);\n        v55 = v33;\n        v56 = &v3[v33];\n        v33 = ((uint8_t)v33 + 1) & 63;\n        v57 = (double)(int)(v54 >> 11) * 1.110223024625157e-16 +\n              (double)(int)(v54 >> 11) * 1.110223024625157e-16 - 1.0;\n        v3[v55] = v57;\n        v5[v55] = 0.0;\n        --v35;\n      } while (v35);\n      *v56 = v57;\n      v58 = 100LL;\n      rng = v54;\n      v5[v55] = 0.0;\n      sink = 0.0;\n      do {\n        v59 = 0LL;\n        v60 = 64LL;\n        do {\n          v61 = v3[v59];\n          v62 = (((((((((((((((v6[8].m128d_f64[0] * v61 + v6[7].m128d_f64[1]) *\n                                  v61 +\n                              v6[7].m128d_f64[0]) *\n                                 v61 +\n                             v6[6].m128d_f64[1]) *\n                                v61 +\n                            v6[6].m128d_f64[0]) *\n                               v61 +\n                           v6[5].m128d_f64[1]) *\n                              v61 +\n                          v6[5].m128d_f64[0]) *\n                             v61 +\n                         v6[4].m128d_f64[1]) *\n                            v61 +\n                        v6[4].m128d_f64[0]) *\n                           v61 +\n                       v6[3].m128d_f64[1]) *\n                          v61 +\n                      v6[3].m128d_f64[0]) *\n                         v61 +\n                     v6[2].m128d_f64[1]) *\n                        v61 +\n                    v6[2].m128d_f64[0]) *\n                       v61 +\n                   v6[1].m128d_f64[1]) *\n                      v61 +\n                  v6[1].m128d_f64[0]) *\n                     v61 +\n                 v6->m128d_f64[1]) *\n                    v61 +\n                v6->m128d_f64[0];\n          v5[v59] = v62;\n          v59 = ((uint8_t)v59 + 1) & 63;\n          sink = v62 * 1.0e-16 + sink;\n          --v60;\n        } while (v60);\n        --v58;\n      } while (v58);\n      v63 = v5;\n      v64 = 0.0;\n      do {\n        v65 = *v63;\n        v63 += 2;\n        v64 = v64 + v65 + *(v63 - 1);\n      } while (v63 != v5 + 64);\n      libmin_printf(\n          \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n          16, 100, 64, 1, 204800.0, v64);\n      libmin_free(v6);\n      libmin_free(v3);\n      libmin_free(v5);\n      libmin_success();\n    }\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  libmin_printf(\"alloc failed\\n\", argv);\n  libmin_fail(1);\n}", "binary": "ccmac/ccmac.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x200,%edi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmovq   $0x1,0x612e(%rip)\ncall   1aa0 <libmin_malloc>\nmov    $0x200,%edi\nmov    %rax,%r13\ncall   1aa0 <libmin_malloc>\nmov    %rax,%r12\ntest   %r13,%r13\nje     1769 <main+0x649>\ntest   %rax,%rax\nje     1769 <main+0x649>\nmov    $0x88,%edi\ncall   1aa0 <libmin_malloc>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     1786 <main+0x666>\nmov    0x60ea(%rip),%rdx\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\nmovapd 0x3eca(%rip),%xmm2\npxor   %xmm3,%xmm3\nmov    %rdx,%rax\nshl    $0xd,%rax\nxor    %rdx,%rax\nmov    %rax,%rdx\nshr    $0x7,%rdx\nxor    %rdx,%rax\nmov    %rax,%rbx\nshl    $0x11,%rbx\nxor    %rax,%rbx\nmov    %rbx,%rdx\nshl    $0xd,%rdx\nxor    %rbx,%rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nxor    %rdx,%rax\nmov    %rax,%r11\nshl    $0x11,%r11\nxor    %rax,%r11\nmov    %r11,%rdx\nshl    $0xd,%rdx\nxor    %r11,%rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nxor    %rdx,%rax\nmov    %rax,%r10\nshl    $0x11,%r10\nxor    %rax,%r10\nmov    %r10,%rdx\nshl    $0xd,%rdx\nxor    %r10,%rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nxor    %rdx,%rax\nmov    %rax,%r9\nshl    $0x11,%r9\nxor    %rax,%r9\nmov    %r9,%rdx\nshl    $0xd,%rdx\nxor    %r9,%rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nxor    %rdx,%rax\nmov    %rax,%r8\nshl    $0x11,%r8\nxor    %rax,%r8\nmov    %r8,%rdx\nshl    $0xd,%rdx\nxor    %r8,%rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nxor    %rdx,%rax\nmov    %rax,%rdi\nshl    $0x11,%rdi\nxor    %rax,%rdi\nmov    %rdi,%rdx\nshl    $0xd,%rdx\nxor    %rdi,%rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nxor    %rdx,%rax\nmov    %rax,%rsi\nshl    $0x11,%rsi\nxor    %rax,%rsi\nmov    %rsi,%rdx\nshl    $0xd,%rdx\nxor    %rsi,%rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nxor    %rdx,%rax\nmov    %rax,%rcx\nshl    $0x11,%rcx\nxor    %rax,%rcx\nmov    %rcx,%rdx\nshl    $0xd,%rdx\nxor    %rcx,%rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nxor    %rdx,%rax\nmov    %rax,%rdx\nshl    $0x11,%rdx\nxor    %rax,%rdx\nmov    %rdx,%rax\nshl    $0xd,%rax\nxor    %rdx,%rax\nmov    %rax,%r14\nshr    $0x7,%r14\nxor    %rax,%r14\nmov    %r14,%rax\nshl    $0x11,%rax\nxor    %r14,%rax\nmov    %rax,%r15\nshl    $0xd,%r15\nxor    %rax,%r15\nmov    %r15,%r14\nshr    $0x7,%r14\nxor    %r15,%r14\nmov    %r14,%r15\nshl    $0x11,%r15\nxor    %r14,%r15\nmov    %r15,%r14\nmov    %r15,0x28(%rsp)\nshl    $0xd,%r14\nxor    %r15,%r14\nmov    %r14,%r15\nshr    $0x7,%r15\nxor    %r15,%r14\nmov    %r14,%r15\nshl    $0x11,%r15\nxor    %r14,%r15\nmov    %r15,%r14\nmov    %r15,0x20(%rsp)\nshl    $0xd,%r14\nxor    %r15,%r14\nmov    %r14,%r15\nshr    $0x7,%r15\nxor    %r15,%r14\nmov    %r14,%r15\nshl    $0x11,%r15\nxor    %r14,%r15\nmov    %r15,%r14\nmov    %r15,0x18(%rsp)\nshl    $0xd,%r14\nxor    %r15,%r14\nmov    %r14,%r15\nshr    $0x7,%r15\nxor    %r15,%r14\nmov    %r14,%r15\nshl    $0x11,%r15\nxor    %r14,%r15\nmov    %r15,%r14\nmov    %r15,0x10(%rsp)\nshl    $0xd,%r14\nxor    %r15,%r14\nmov    %r14,%r15\nshr    $0x7,%r15\nxor    %r15,%r14\nmov    %r14,%r15\nshl    $0x11,%r15\nxor    %r14,%r15\nmov    %r15,%r14\nshl    $0xd,%r15\nxor    %r14,%r15\nmov    %r14,0x8(%rsp)\nmov    %r15,%r14\nshr    $0x7,%r14\nxor    %r15,%r14\nmov    %r14,%r15\nshl    $0x11,%r15\nxor    %r15,%r14\nshr    $0xb,%rbx\nshr    $0xb,%r11\ncvtsi2sd %rbx,%xmm0\nshr    $0xb,%r10\ncvtsi2sd %r11,%xmm1\nshr    $0xb,%r9\nshr    $0xb,%r8\ncvtsi2sd %r9,%xmm3\nshr    $0xb,%rdi\nshr    $0xb,%rsi\nshr    $0xb,%rcx\nshr    $0xb,%rdx\nshr    $0xb,%rax\nunpcklpd %xmm1,%xmm0\nmovapd 0x3c9a(%rip),%xmm1\nmulpd  %xmm2,%xmm0\naddpd  %xmm0,%xmm0\naddpd  %xmm1,%xmm0\nmovups %xmm0,0x0(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sd %r10,%xmm0\nunpcklpd %xmm3,%xmm0\npxor   %xmm3,%xmm3\nmulpd  %xmm2,%xmm0\ncvtsi2sd %rdi,%xmm3\naddpd  %xmm0,%xmm0\naddpd  %xmm1,%xmm0\nmovups %xmm0,0x10(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sd %r8,%xmm0\nunpcklpd %xmm3,%xmm0\npxor   %xmm3,%xmm3\nmulpd  %xmm2,%xmm0\ncvtsi2sd %rcx,%xmm3\nxor    %ecx,%ecx\naddpd  %xmm0,%xmm0\naddpd  %xmm1,%xmm0\nmovups %xmm0,0x20(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sd %rsi,%xmm0\nmov    $0x40,%esi\nunpcklpd %xmm3,%xmm0\npxor   %xmm3,%xmm3\nmulpd  %xmm2,%xmm0\ncvtsi2sd %rax,%xmm3\nmov    0x28(%rsp),%rax\nshr    $0xb,%rax\naddpd  %xmm0,%xmm0\naddpd  %xmm1,%xmm0\nmovups %xmm0,0x30(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\nunpcklpd %xmm3,%xmm0\npxor   %xmm3,%xmm3\nmulpd  %xmm2,%xmm0\naddpd  %xmm0,%xmm0\naddpd  %xmm1,%xmm0\nmovups %xmm0,0x40(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\nmov    0x20(%rsp),%rax\nshr    $0xb,%rax\ncvtsi2sd %rax,%xmm3\nmov    0x18(%rsp),%rax\nshr    $0xb,%rax\nunpcklpd %xmm3,%xmm0\npxor   %xmm3,%xmm3\nmulpd  %xmm2,%xmm0\naddpd  %xmm0,%xmm0\naddpd  %xmm1,%xmm0\nmovups %xmm0,0x50(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\nmov    0x10(%rsp),%rax\nshr    $0xb,%rax\ncvtsi2sd %rax,%xmm3\nmov    0x8(%rsp),%rax\nshr    $0xb,%rax\nunpcklpd %xmm3,%xmm0\npxor   %xmm3,%xmm3\nmulpd  %xmm2,%xmm0\naddpd  %xmm0,%xmm0\naddpd  %xmm1,%xmm0\nmovups %xmm0,0x60(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\nmov    %r14,%rax\nshr    $0xb,%rax\ncvtsi2sd %rax,%xmm3\nmov    %r14,%rax\nshl    $0xd,%rax\nxor    %r14,%rax\nmov    %rax,%rdx\nunpcklpd %xmm3,%xmm0\nshr    $0x7,%rdx\nmulpd  %xmm2,%xmm0\nxor    %rdx,%rax\nmovsd  0x3b2e(%rip),%xmm2\nmov    %rax,%rdx\nshl    $0x11,%rdx\nxor    %rdx,%rax\nmov    %rax,%rdx\nmov    %rax,%r8\naddpd  %xmm0,%xmm0\nshr    $0xb,%rdx\naddpd  %xmm1,%xmm0\nmovsd  0x3b2a(%rip),%xmm1\nmovups %xmm0,0x70(%rbp)\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,0x80(%rbp)\nmov    %r8,%rax\npxor   %xmm0,%xmm0\nshl    $0xd,%rax\nxor    %r8,%rax\nmov    %rax,%rdx\nshr    $0x7,%rdx\nxor    %rdx,%rax\nmov    %rax,%r8\nshl    $0x11,%r8\nxor    %rax,%r8\nlea    0x0(,%rcx,8),%rax\nadd    $0x1,%rcx\nmov    %r8,%rdx\nlea    0x0(%r13,%rax,1),%rdi\nand    $0x3f,%ecx\nshr    $0xb,%rdx\ncvtsi2sd %rdx,%xmm0\nlea    (%r12,%rax,1),%rdx\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rdi)\nmovq   $0x0,(%rdx)\nsub    $0x1,%rsi\njne    1577 <main+0x457>\nmovsd  %xmm0,(%rdi)\nmovsd  0x3aa2(%rip),%xmm1\nmov    $0x64,%ecx\nmov    %r8,0x5c7e(%rip)\nmovq   $0x0,(%rdx)\nmovq   $0x0,0x38(%rsp)\nxor    %eax,%eax\nmov    $0x40,%edx\nnopl   0x0(%rax)\nmovsd  0x0(%r13,%rax,8),%xmm2\nmovsd  0x80(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x78(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x70(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x68(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x60(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x58(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x50(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x48(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x40(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x38(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x30(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x28(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x20(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x18(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x10(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  0x8(%rbp),%xmm0\nmulsd  %xmm2,%xmm0\nmovsd  0x38(%rsp),%xmm2\naddsd  0x0(%rbp),%xmm0\nmovsd  %xmm0,(%r12,%rax,8)\nmulsd  %xmm1,%xmm0\nadd    $0x1,%rax\nand    $0x3f,%eax\naddsd  %xmm2,%xmm0\nmovsd  %xmm0,0x38(%rsp)\nsub    $0x1,%rdx\njne    1610 <main+0x4f0>\nsub    $0x1,%rcx\njne    1602 <main+0x4e2>\nmov    %r12,%rax\nlea    0x200(%r12),%rdx\npxor   %xmm1,%xmm1\nmovsd  (%rax),%xmm0\nadd    $0x10,%rax\naddsd  %xmm0,%xmm1\nmovsd  -0x8(%rax),%xmm0\naddsd  %xmm0,%xmm1\ncmp    %rdx,%rax\njne    16f3 <main+0x5d3>\nmov    $0x1,%r8d\nmov    $0x40,%ecx\nmov    $0x64,%edx\nmovsd  0x396b(%rip),%xmm0\nmov    $0x10,%esi\nlea    0x38e7(%rip),%rdi\nmov    $0x2,%eax\ncall   3de0 <libmin_printf>\nmov    %rbp,%rdi\ncall   1b50 <libmin_free>\nmov    %r13,%rdi\ncall   1b50 <libmin_free>\nmov    %r12,%rdi\ncall   1b50 <libmin_free>\ncall   4020 <libmin_success>\nadd    $0x48,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x3894(%rip),%rdi\nxor    %eax,%eax\ncall   3de0 <libmin_printf>\nmov    $0x1,%edi\ncall   1a80 <libmin_fail>\njmp    1169 <main+0x49>\nlea    0x3877(%rip),%rdi\nxor    %eax,%eax\ncall   3de0 <libmin_printf>\nmov    $0x1,%edi\ncall   1a80 <libmin_fail>\njmp    117f <main+0x5f>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "all_possible_moves", "content": "// function which returns the number of valid target squares a piece at \n// source defined by col/row can make, given a board_t input. \n// Also writes each into a static variable of type valid_moves_t\n\t// sorry for lack of abstraction, very confusing  with different static \n\t// and local variables when abstracted into a function\n\t// so ultimately deemed better in this format\nint all_possible_moves(board_t board_input, char col, char row, \n\tvalid_moves_t valid_moves, int black_action) {\n\tint num_possibles = 0, is_tower = 0;\n\tif ((piece_at_location(board_input, col, row) == CELL_BTOWER)\n\t\t|| (piece_at_location(board_input, col, row) == CELL_WTOWER)) {\n\t\tis_tower = 1;\n\t}\n\t\n\t// iterate through possible tower movement vectors\n\tif (is_tower) {\n\t\tfor (int i=0; i<NUM_TOWER_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + tower_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + tower_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t// otherwise, if target cell occupied by opposing piece, \n\t\t\t\t// capture move possible\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * tower_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * tower_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// iterate through possible black piece movement vectors\n\tif (piece_at_location(board_input, col, row) == CELL_BPIECE) {\n\t\tfor (int i=0; i<NUM_PIECE_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + black_piece_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + black_piece_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * black_piece_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * black_piece_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// iterate through possible white piece movement vectors\n\tif (piece_at_location(board_input, col, row) == CELL_WPIECE) {\n\t\tfor (int i=0; i<NUM_PIECE_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + white_piece_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + white_piece_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * white_piece_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * white_piece_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn num_possibles;\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "all_possible_moves", "address": "0x22b0", "label": "all_possible_moves", "content": "int __fastcall all_possible_moves(\n        unsigned __int8 (*board_input)[8],\n        char col,\n        char row,\n        square_t *valid_moves,\n        int black_action)\n{\n  int v5; // r9d\n  int v6; // r14d\n  unsigned __int8 v7; // r11\n  int v8; // r10d\n  char v10; // r12\n  bool v11; // r15\n  char v12; // r10\n  char v13; // bp\n  char v14; // bl\n  char v15; // al\n  char v16; // cl\n  char v17; // r13\n  char v18; // bp\n  char v19; // bl\n  char v20; // al\n  char v21; // cl\n  char v22; // r13\n  char v23; // bl\n  char v24; // bp\n  char v25; // al\n  char v26; // cl\n  char v27; // r12\n  char v28; // r13\n  unsigned __int8 v29; // r12\n  unsigned __int8 v30; // r13\n  unsigned __int8 v31; // r8\n  char v32; // al\n  __int64 v33; // rax\n  char *v34; // rax\n  char v35; // r15\n  char v36; // bl\n  char v37; // bp\n  char v38; // r13\n  char v39; // r12\n  int v40; // eax\n  int v41; // r9d\n  int v42; // r10d\n  char v43; // r11\n  char v44; // dl\n  char *v45; // rax\n  char v46; // bp\n  char v47; // bl\n  char v48; // r13\n  char v49; // r12\n  int v50; // eax\n  char v51; // r11\n  __int64 v52; // rax\n  char *v53; // rax\n  char v54; // r15\n  char v55; // bl\n  char v56; // bp\n  char v57; // r13\n  char v58; // r12\n  int v59; // eax\n  int v60; // r9d\n  int v61; // r10d\n  char v62; // r11\n  char v63; // dl\n  char *v64; // rax\n  char v65; // bl\n  char v66; // r12\n  char v67; // r13\n  char v68; // bp\n  int v69; // r15d\n  int v70; // eax\n  int v71; // r9d\n  char v72; // r11\n  __int64 v73; // rax\n  char *v74; // rax\n  char v75; // al\n  char v76; // bp\n  char v77; // bl\n  int v78; // eax\n  int v79; // r10d\n  char *v80; // rax\n  char v81; // al\n  char v82; // bp\n  char v83; // bl\n  int v84; // eax\n  int v85; // r10d\n  char *v86; // rax\n  char v87; // al\n  char v88; // bl\n  char v89; // r11\n  __int64 v90; // rax\n  char *v91; // rax\n  char v92; // al\n  char v93; // bl\n  char v94; // bp\n  int v95; // eax\n  __int64 v96; // rax\n  char *v97; // rax\n  unsigned __int8 v98; // r8\n  char v99; // al\n  char *v100; // rax\n  char v101; // bl\n  char v102; // r8\n  int v103; // eax\n  char v104; // r10\n  char v105; // r8\n  char v106; // bl\n  char v107; // bp\n  int v108; // eax\n  __int64 v109; // rax\n  char *v110; // rax\n  unsigned __int8 v111; // r8\n  char v112; // al\n  char *v113; // rax\n  char v114; // bl\n  char v115; // r8\n  char v116; // bp\n  int v117; // eax\n  unsigned __int8 v118; // r8\n  char v119; // al\n  char *v120; // rax\n  char v121; // bl\n  char v122; // r8\n  char v123; // bp\n  int v124; // eax\n  unsigned __int8 *v126; // [rsp+8h] [rbp-60h]\n  char v127[8]; // [rsp+10h] [rbp-58h]\n  char v128; // [rsp+10h] [rbp-58h]\n  char v129; // [rsp+10h] [rbp-58h]\n  char col1; // [rsp+1Ch] [rbp-4Ch]\n  char col1a; // [rsp+1Ch] [rbp-4Ch]\n  char row1; // [rsp+20h] [rbp-48h]\n  char row1a; // [rsp+20h] [rbp-48h]\n  int row1b; // [rsp+20h] [rbp-48h]\n  char row1c; // [rsp+20h] [rbp-48h]\n  char row1d; // [rsp+20h] [rbp-48h]\n  char row1e; // [rsp+20h] [rbp-48h]\n  char row1f; // [rsp+20h] [rbp-48h]\n  char v139; // [rsp+28h] [rbp-40h]\n  int v140; // [rsp+30h] [rbp-38h]\n  char v141; // [rsp+30h] [rbp-38h]\n  char v142; // [rsp+34h] [rbp-34h]\n\n  v5 = black_action;\n  v6 = col - 64;\n  v126 = &(*board_input)[8 * v6 - 8];\n  v7 = v126[row - 49];\n  *(_QWORD *)v127 = row - 49;\n  if ( v7 != 87 )\n  {\n    v8 = 0;\n    if ( v7 != 66 )\n      goto LABEL_3;\n  }\n  v10 = row - 48;\n  v11 = (unsigned __int8)(col - 65) > 7u || (unsigned __int8)(row - 49) > 7u;\n  v12 = v6 + LOBYTE(tower_movements[0][0]);\n  if ( v11\n    || (unsigned __int8)(v6 + LOBYTE(tower_movements[0][0]) - 1) > 7u\n    || (unsigned __int8)(LOBYTE(tower_movements[0][1]) + row - 48 - 1) > 7u )\n  {\n    v8 = 0;\nLABEL_9:\n    v13 = tower_movements[1][0];\n    v14 = tower_movements[1][1];\n    v15 = v6 + LOBYTE(tower_movements[1][0]);\n    v16 = LOBYTE(tower_movements[1][1]) + v10;\n    col1 = v6 + LOBYTE(tower_movements[1][0]);\n    v17 = LOBYTE(tower_movements[1][1]) + v10;\n    if ( v11\n      || (unsigned __int8)(v6 + LOBYTE(tower_movements[1][0]) - 1) > 7u\n      || (unsigned __int8)(v16 - 1) > 7u\n      || v7 == 48 )\n    {\n      goto LABEL_11;\n    }\nLABEL_73:\n    v111 = (*board_input)[8 * (unsigned __int8)(col1 + 64) - 569 + (unsigned __int8)(v17 + 48)];\n    if ( v111 == 48 )\n    {\n      v112 = v7 & 0xDF;\n      if ( v5 )\n      {\n        if ( v112 != 87 )\n        {\nLABEL_76:\n          v113 = &(*valid_moves)[2 * v8];\n          *v113 = col1 + 64;\n          v114 = v17 + 48;\nLABEL_77:\n          v113[1] = v114;\n          ++v8;\n          v7 = v126[*(_QWORD *)v127];\n          goto LABEL_11;\n        }\n      }\n      else if ( v112 != 66 )\n      {\n        goto LABEL_76;\n      }\n    }\n    else\n    {\n      v115 = v111 & 0xDF;\n      if ( v5 )\n      {\n        if ( v115 != 87 )\n          goto LABEL_83;\n      }\n      else if ( v115 != 66 )\n      {\n        goto LABEL_83;\n      }\n      v116 = v13 + v15 + 64;\n      v114 = v14 + v16 + 48;\n      row1e = row;\n      v117 = check_move_error_1_to_5(board_input, col, row, v116, v114, v5);\n      row = row1e;\n      if ( !v117 )\n      {\n        v113 = &(*valid_moves)[2 * v8];\n        *v113 = v116;\n        goto LABEL_77;\n      }\n    }\nLABEL_83:\n    v18 = tower_movements[2][0];\n    v19 = tower_movements[2][1];\n    v20 = v6 + LOBYTE(tower_movements[2][0]);\n    v21 = v10 + LOBYTE(tower_movements[2][1]);\n    col1a = v6 + LOBYTE(tower_movements[2][0]);\n    v22 = v10 + LOBYTE(tower_movements[2][1]);\n    if ( v11 || (unsigned __int8)(v6 + LOBYTE(tower_movements[2][0]) - 1) > 7u || (unsigned __int8)(v21 - 1) > 7u )\n      goto LABEL_13;\n    goto LABEL_85;\n  }\n  v98 = (*board_input)[8 * (unsigned __int8)(v12 + 64) - 569 + (unsigned __int8)(LOBYTE(tower_movements[0][1]) + row)];\n  if ( v98 == 48 )\n  {\n    v99 = v7 & 0xDF;\n    if ( v5 )\n    {\n      if ( v99 != 87 )\n      {\nLABEL_60:\n        v100 = (char *)valid_moves;\n        v101 = LOBYTE(tower_movements[0][1]) + row;\n        (*valid_moves)[0] = v12 + 64;\nLABEL_61:\n        v100[1] = v101;\n        v8 = 1;\n        v7 = v126[*(_QWORD *)v127];\n        goto LABEL_9;\n      }\n    }\n    else if ( v99 != 66 )\n    {\n      goto LABEL_60;\n    }\n  }\n  else\n  {\n    v102 = v98 & 0xDF;\n    if ( v5 )\n    {\n      if ( v102 != 87 )\n        goto LABEL_71;\n    }\n    else if ( v102 != 66 )\n    {\n      goto LABEL_71;\n    }\n    v101 = LOBYTE(tower_movements[0][1]) + row + LOBYTE(tower_movements[0][1]);\n    row1c = row;\n    v103 = check_move_error_1_to_5(board_input, col, row, v12 + LOBYTE(tower_movements[0][0]) + 64, v101, v5);\n    row = row1c;\n    if ( !v103 )\n    {\n      v100 = (char *)valid_moves;\n      (*valid_moves)[0] = v104;\n      goto LABEL_61;\n    }\n  }\nLABEL_71:\n  v13 = tower_movements[1][0];\n  v14 = tower_movements[1][1];\n  v15 = v6 + LOBYTE(tower_movements[1][0]);\n  v16 = v10 + LOBYTE(tower_movements[1][1]);\n  col1 = v6 + LOBYTE(tower_movements[1][0]);\n  v17 = v10 + LOBYTE(tower_movements[1][1]);\n  v8 = 0;\n  if ( !v11 && (unsigned __int8)(v6 + LOBYTE(tower_movements[1][0]) - 1) <= 7u && (unsigned __int8)(v16 - 1) <= 7u )\n    goto LABEL_73;\nLABEL_11:\n  v18 = tower_movements[2][0];\n  v19 = tower_movements[2][1];\n  v20 = v6 + LOBYTE(tower_movements[2][0]);\n  v21 = LOBYTE(tower_movements[2][1]) + v10;\n  col1a = v6 + LOBYTE(tower_movements[2][0]);\n  v22 = LOBYTE(tower_movements[2][1]) + v10;\n  if ( v11\n    || (unsigned __int8)(v6 + LOBYTE(tower_movements[2][0]) - 1) > 7u\n    || (unsigned __int8)(v21 - 1) > 7u\n    || v7 == 48 )\n  {\n    goto LABEL_13;\n  }\nLABEL_85:\n  v118 = (*board_input)[8 * (unsigned __int8)(col1a + 64) - 569 + (unsigned __int8)(v22 + 48)];\n  if ( v118 == 48 )\n  {\n    v119 = v7 & 0xDF;\n    if ( v5 )\n    {\n      if ( v119 != 87 )\n      {\nLABEL_88:\n        v120 = &(*valid_moves)[2 * v8];\n        *v120 = col1a + 64;\n        v121 = v22 + 48;\nLABEL_89:\n        v120[1] = v121;\n        ++v8;\n        v7 = v126[*(_QWORD *)v127];\nLABEL_13:\n        v23 = tower_movements[3][0];\n        v24 = tower_movements[3][1];\n        v25 = LOBYTE(tower_movements[3][0]) + v6;\n        v26 = LOBYTE(tower_movements[3][1]) + v10;\n        v27 = LOBYTE(tower_movements[3][0]) + v6;\n        v28 = v26;\n        if ( v11 || (unsigned __int8)(LOBYTE(tower_movements[3][0]) + v6 - 1) > 7u || (unsigned __int8)(v26 - 1) > 7u )\n          goto LABEL_3;\n        if ( v7 == 48 )\n          return v8;\n        goto LABEL_16;\n      }\n    }\n    else if ( v119 != 66 )\n    {\n      goto LABEL_88;\n    }\n  }\n  else\n  {\n    v122 = v118 & 0xDF;\n    if ( v5 )\n    {\n      if ( v122 != 87 )\n        goto LABEL_95;\n    }\n    else if ( v122 != 66 )\n    {\n      goto LABEL_95;\n    }\n    v123 = v18 + v20 + 64;\n    v121 = v19 + v21 + 48;\n    row1f = row;\n    v124 = check_move_error_1_to_5(board_input, col, row, v123, v121, v5);\n    row = row1f;\n    if ( !v124 )\n    {\n      v120 = &(*valid_moves)[2 * v8];\n      *v120 = v123;\n      goto LABEL_89;\n    }\n  }\nLABEL_95:\n  v23 = tower_movements[3][0];\n  v24 = tower_movements[3][1];\n  v25 = v6 + LOBYTE(tower_movements[3][0]);\n  v26 = v10 + LOBYTE(tower_movements[3][1]);\n  v27 = v6 + LOBYTE(tower_movements[3][0]);\n  v28 = v26;\n  if ( v11 || (unsigned __int8)(v6 + LOBYTE(tower_movements[3][0]) - 1) > 7u || (unsigned __int8)(v26 - 1) > 7u )\n    goto LABEL_3;\nLABEL_16:\n  v29 = v27 + 64;\n  v30 = v28 + 48;\n  v31 = (*board_input)[8 * v29 - 569 + v30];\n  if ( v31 != 48 )\n  {\n    v105 = v31 & 0xDF;\n    if ( v5 )\n    {\n      if ( v105 != 87 )\n        goto LABEL_3;\n    }\n    else if ( v105 != 66 )\n    {\n      goto LABEL_3;\n    }\n    v106 = v23 + v25 + 64;\n    v107 = v24 + v26 + 48;\n    row1d = row;\n    v108 = check_move_error_1_to_5(board_input, col, row, v106, v107, v5);\n    row = row1d;\n    if ( !v108 )\n    {\n      v109 = v8++;\n      v110 = &(*valid_moves)[2 * v109];\n      *v110 = v106;\n      v110[1] = v107;\n      v7 = v126[*(_QWORD *)v127];\n    }\nLABEL_3:\n    if ( v7 != 98 )\n      goto LABEL_4;\nLABEL_20:\n    v35 = black_piece_movements[0][0];\n    row1 = row;\n    v36 = LOBYTE(black_piece_movements[0][1]) + row - 48;\n    v37 = v6 + LOBYTE(black_piece_movements[0][0]);\n    v142 = black_piece_movements[0][1];\n    v38 = col + LOBYTE(black_piece_movements[0][0]);\n    v39 = LOBYTE(black_piece_movements[0][1]) + row;\n    v140 = (char)(LOBYTE(black_piece_movements[0][1]) + row);\n    v40 = check_move_error_1_to_5(\n            board_input,\n            col,\n            row,\n            col + LOBYTE(black_piece_movements[0][0]),\n            LOBYTE(black_piece_movements[0][1]) + row,\n            v5);\n    v44 = row1;\n    if ( !v40 )\n    {\n      v45 = &(*valid_moves)[2 * v42];\n      *v45 = v38;\n      v45[1] = v39;\n      goto LABEL_22;\n    }\n    if ( v40 == 4 )\n    {\n      v75 = (*board_input)[8 * v38 - 569 + v140] & 0xDF;\n      if ( v41 )\n      {\n        if ( v75 != 87 )\n          goto LABEL_22;\n      }\n      else if ( v75 != 66 )\n      {\n        goto LABEL_22;\n      }\n      v76 = v37 + v35 + 64;\n      v77 = v36 + v142 + 48;\n      v78 = check_move_error_1_to_5(board_input, col, row1, v76, v77, v41);\n      v44 = row1;\n      if ( !v78 )\n      {\n        v80 = &(*valid_moves)[2 * v79];\n        *v80 = v76;\n        v80[1] = v77;\n      }\n    }\nLABEL_22:\n    v46 = black_piece_movements[1][0];\n    v47 = black_piece_movements[1][1];\n    row1a = v44;\n    v48 = LOBYTE(black_piece_movements[1][0]) + col;\n    v49 = LOBYTE(black_piece_movements[1][1]) + v43 + 48;\n    v141 = LOBYTE(black_piece_movements[1][0]) + v6;\n    v50 = check_move_error_1_to_5(board_input, col, v44, LOBYTE(black_piece_movements[1][0]) + col, v49, v41);\n    row = row1a;\n    if ( !v50 )\n    {\n      v52 = v8++;\n      v53 = &(*valid_moves)[2 * v52];\n      *v53 = v48;\n      v53[1] = v49;\n      goto LABEL_24;\n    }\n    if ( v50 == 4 )\n    {\n      v92 = (*board_input)[8 * v48 - 569 + v49] & 0xDF;\n      if ( v5 )\n      {\n        if ( v92 != 87 )\n          goto LABEL_24;\n      }\n      else if ( v92 != 66 )\n      {\n        goto LABEL_24;\n      }\n      v93 = v47 + v51 + 48;\n      v94 = v46 + v141 + 64;\n      v95 = check_move_error_1_to_5(board_input, col, row1a, v94, v93, v5);\n      row = row1a;\n      if ( !v95 )\n      {\n        v96 = v8++;\n        v97 = &(*valid_moves)[2 * v96];\n        *v97 = v94;\n        v97[1] = v93;\n      }\n    }\nLABEL_24:\n    if ( v126[*(_QWORD *)v127] != 119 )\n      return v8;\n    goto LABEL_25;\n  }\n  v32 = v7 & 0xDF;\n  if ( v5 )\n  {\n    if ( v32 == 87 )\n      goto LABEL_3;\n  }\n  else if ( v32 == 66 )\n  {\n    goto LABEL_3;\n  }\n  v33 = v8++;\n  v34 = &(*valid_moves)[2 * v33];\n  *v34 = v29;\n  v34[1] = v30;\n  v7 = v126[*(_QWORD *)v127];\n  if ( v7 == 98 )\n    goto LABEL_20;\nLABEL_4:\n  if ( v7 != 119 )\n    return v8;\nLABEL_25:\n  v54 = white_piece_movements[0][0];\n  v128 = row;\n  v55 = row - 48 + LOBYTE(white_piece_movements[0][1]);\n  v56 = v6 + LOBYTE(white_piece_movements[0][0]);\n  v139 = white_piece_movements[0][1];\n  v57 = col + LOBYTE(white_piece_movements[0][0]);\n  v58 = row + LOBYTE(white_piece_movements[0][1]);\n  row1b = (char)(row + LOBYTE(white_piece_movements[0][1]));\n  v59 = check_move_error_1_to_5(\n          board_input,\n          col,\n          row,\n          col + LOBYTE(white_piece_movements[0][0]),\n          row + LOBYTE(white_piece_movements[0][1]),\n          v5);\n  v63 = v128;\n  if ( !v59 )\n  {\n    v64 = &(*valid_moves)[2 * v61];\n    *v64 = v57;\n    v64[1] = v58;\n    goto LABEL_27;\n  }\n  if ( v59 == 4 )\n  {\n    v81 = (*board_input)[8 * v57 - 569 + row1b] & 0xDF;\n    if ( v60 )\n    {\n      if ( v81 != 87 )\n        goto LABEL_27;\n    }\n    else if ( v81 != 66 )\n    {\n      goto LABEL_27;\n    }\n    v82 = v56 + v54 + 64;\n    v83 = v55 + v139 + 48;\n    v84 = check_move_error_1_to_5(board_input, col, v128, v82, v83, v60);\n    v63 = v128;\n    if ( !v84 )\n    {\n      v86 = &(*valid_moves)[2 * v85];\n      *v86 = v82;\n      v86[1] = v83;\n    }\n  }\nLABEL_27:\n  v65 = white_piece_movements[1][0];\n  v66 = white_piece_movements[1][1];\n  v129 = v63;\n  v67 = LOBYTE(white_piece_movements[1][0]) + v6;\n  v68 = LOBYTE(white_piece_movements[1][1]) + v62 + 48;\n  v69 = (char)(LOBYTE(white_piece_movements[1][0]) + col);\n  v70 = check_move_error_1_to_5(board_input, col, v63, LOBYTE(white_piece_movements[1][0]) + col, v68, v60);\n  if ( v70 )\n  {\n    if ( v70 == 4 )\n    {\n      v87 = (*board_input)[8 * v69 - 569 + v68] & 0xDF;\n      if ( v71 )\n      {\n        if ( v87 != 87 )\n          return v8;\n      }\n      else if ( v87 != 66 )\n      {\n        return v8;\n      }\n      v88 = v65 + v67 + 64;\n      if ( !check_move_error_1_to_5(board_input, col, v129, v88, v66 + v72 + 48, v71) )\n      {\n        v90 = v8++;\n        v91 = &(*valid_moves)[2 * v90];\n        *v91 = v88;\n        v91[1] = v89;\n      }\n    }\n  }\n  else\n  {\n    v73 = v8++;\n    v74 = &(*valid_moves)[2 * v73];\n    *v74 = v67 + 64;\n    v74[1] = v68;\n  }\n  return v8;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O3", "assembly": "<all_possible_moves>:\nendbr64\npush   %r15\nmov    %esi,%eax\nmovsbl %sil,%esi\nmov    %r8d,%r9d\npush   %r14\nlea    -0x40(%rsi),%r14d\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edx,%ebx\nmovsbl %dl,%edx\nsub    $0x38,%rsp\nmov    %rcx,(%rsp)\nmovslq %r14d,%rcx\nlea    -0x8(%rdi,%rcx,8),%r15\nlea    -0x31(%rdx),%ecx\nmovslq %ecx,%rcx\nmov    %r15,0x8(%rsp)\nmovzbl (%r15,%rcx,1),%r11d\nmov    %rcx,0x10(%rsp)\ncmp    $0x57,%r11b\nje     2330 <all_possible_moves+0x80>\nxor    %r10d,%r10d\ncmp    $0x42,%r11b\nje     2330 <all_possible_moves+0x80>\ncmp    $0x62,%r11b\nje     24b4 <all_possible_moves+0x204>\ncmp    $0x77,%r11b\nje     259e <all_possible_moves+0x2ee>\nadd    $0x38,%rsp\nmov    %r10d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nsub    $0x31,%ebx\nlea    -0x30(%rdx),%r12d\ncmp    $0x7,%bl\nseta   %cl\nsub    $0x41,%eax\ncmp    $0x7,%al\nseta   %al\nor     %eax,%ecx\nmov    0xad17(%rip),%eax\nmov    %ecx,%r15d\nmov    0xad0a(%rip),%ecx\nlea    (%rax,%r12,1),%ebx\nlea    (%r14,%rcx,1),%r10d\nlea    -0x1(%r10),%r8d\ncmp    $0x7,%r8b\nseta   %r8b\nor     %r15b,%r8b\njne    237d <all_possible_moves+0xcd>\nlea    -0x1(%rbx),%r8d\ncmp    $0x7,%r8b\njbe    28bd <all_possible_moves+0x60d>\nxor    %r10d,%r10d\nmov    0xace2(%rip),%ebp\nmov    0xace0(%rip),%ebx\nlea    (%r14,%rbp,1),%eax\nlea    (%rbx,%r12,1),%ecx\nlea    -0x1(%rax),%r8d\nmov    %al,0x1c(%rsp)\nmov    %ecx,%r13d\ncmp    $0x7,%r8b\nseta   %r8b\nor     %r15b,%r8b\njne    23ba <all_possible_moves+0x10a>\nlea    -0x1(%rcx),%r8d\ncmp    $0x7,%r8b\njbe    2cae <all_possible_moves+0x9fe>\nmov    0xacb0(%rip),%ebp\nmov    0xacae(%rip),%ebx\nlea    (%r14,%rbp,1),%eax\nlea    (%rbx,%r12,1),%ecx\nlea    -0x1(%rax),%r8d\nmov    %al,0x1c(%rsp)\nmov    %ecx,%r13d\ncmp    $0x7,%r8b\nseta   %r8b\nor     %r15b,%r8b\njne    23f4 <all_possible_moves+0x144>\nlea    -0x1(%rcx),%r8d\ncmp    $0x7,%r8b\njbe    2c9f <all_possible_moves+0x9ef>\nmov    0xac7e(%rip),%ebx\nmov    0xac7c(%rip),%ebp\nlea    (%rbx,%r14,1),%eax\nlea    0x0(%rbp,%r12,1),%ecx\nlea    -0x1(%rax),%r8d\nmov    %eax,%r12d\nmov    %ecx,%r13d\ncmp    $0x7,%r8b\nseta   %r8b\nor     %r15b,%r8b\njne    2304 <all_possible_moves+0x54>\nlea    -0x1(%rcx),%r8d\ncmp    $0x7,%r8b\nja     2304 <all_possible_moves+0x54>\ncmp    $0x30,%r11b\nje     2318 <all_possible_moves+0x68>\nadd    $0x40,%r12d\nadd    $0x30,%r13d\nmovzbl %r12b,%r8d\nsub    $0x40,%r8d\nmovslq %r8d,%r15\nmovzbl %r13b,%r8d\nsub    $0x31,%r8d\nlea    (%rdi,%r15,8),%r15\nmovslq %r8d,%r8\nmovzbl -0x8(%r8,%r15,1),%r8d\ncmp    $0x30,%r8b\njne    2994 <all_possible_moves+0x6e4>\nmov    %r11d,%eax\nand    $0xffffffdf,%eax\ntest   %r9d,%r9d\nje     2ce4 <all_possible_moves+0xa34>\ncmp    $0x57,%al\nje     2304 <all_possible_moves+0x54>\nmov    (%rsp),%rbx\nmovslq %r10d,%rax\nadd    $0x1,%r10d\nlea    (%rbx,%rax,2),%rax\nmov    0x10(%rsp),%rbx\nmov    %r12b,(%rax)\nmov    %r13b,0x1(%rax)\nmov    0x8(%rsp),%rax\nmovzbl (%rax,%rbx,1),%r11d\ncmp    $0x62,%r11b\njne    230e <all_possible_moves+0x5e>\nmov    0xabda(%rip),%eax\nmov    0xabcf(%rip),%r15d\nlea    -0x30(%rdx),%r11d\nmov    %edx,0x20(%rsp)\nmov    %esi,0x1c(%rsp)\nlea    (%rax,%r11,1),%ebx\nlea    (%r14,%r15,1),%ebp\nmov    %eax,0x34(%rsp)\nlea    0x40(%rbp),%r13d\nlea    0x30(%rbx),%r12d\nmovsbl %r12b,%r8d\nmovsbl %r13b,%ecx\nmov    %r8d,0x30(%rsp)\nmov    %ecx,0x28(%rsp)\ncall   20c0 <check_move_error_1_to_5>\nmov    0x1c(%rsp),%esi\nmov    0x20(%rsp),%edx\ntest   %eax,%eax\njne    2670 <all_possible_moves+0x3c0>\nmov    (%rsp),%rbx\nmovslq %r10d,%rax\nadd    $0x1,%r10d\nlea    (%rbx,%rax,2),%rax\nmov    %r13b,(%rax)\nmov    %r12b,0x1(%rax)\nmov    0xab75(%rip),%ebp\nmov    0xab73(%rip),%ebx\nmov    %edx,0x20(%rsp)\nmov    %esi,0x1c(%rsp)\nlea    0x0(%rbp,%r14,1),%eax\nadd    %ebx,%r11d\nlea    0x40(%rax),%r13d\nlea    0x30(%r11),%r12d\nmov    %eax,0x30(%rsp)\nmovsbl %r13b,%r15d\nmovsbl %r12b,%r8d\nmov    %r15d,%ecx\nmov    %r8d,0x28(%rsp)\ncall   20c0 <check_move_error_1_to_5>\nmov    0x1c(%rsp),%esi\nmov    0x20(%rsp),%edx\ntest   %eax,%eax\nmov    0x28(%rsp),%r8d\njne    2800 <all_possible_moves+0x550>\nmov    (%rsp),%rbx\nmovslq %r10d,%rax\nadd    $0x1,%r10d\nlea    (%rbx,%rax,2),%rax\nmov    %r13b,(%rax)\nmov    %r12b,0x1(%rax)\nmov    0x8(%rsp),%rax\nmov    0x10(%rsp),%rbx\nmovzbl (%rax,%rbx,1),%r11d\ncmp    $0x77,%r11b\njne    2318 <all_possible_moves+0x68>\nmov    0xaae0(%rip),%eax\nmov    0xaad5(%rip),%r15d\nlea    -0x30(%rdx),%r11d\nmov    %edx,0x10(%rsp)\nmov    %esi,0x8(%rsp)\nlea    (%r11,%rax,1),%ebx\nlea    (%r14,%r15,1),%ebp\nmov    %eax,0x28(%rsp)\nlea    0x40(%rbp),%r13d\nlea    0x30(%rbx),%r12d\nmovsbl %r12b,%r8d\nmovsbl %r13b,%ecx\nmov    %r8d,0x20(%rsp)\nmov    %ecx,0x1c(%rsp)\ncall   20c0 <check_move_error_1_to_5>\nmov    0x8(%rsp),%esi\nmov    0x10(%rsp),%edx\ntest   %eax,%eax\njne    2700 <all_possible_moves+0x450>\nmov    (%rsp),%rbx\nmovslq %r10d,%rax\nadd    $0x1,%r10d\nlea    (%rbx,%rax,2),%rax\nmov    %r13b,(%rax)\nmov    %r12b,0x1(%rax)\nmov    0xaa7b(%rip),%ebx\nmov    0xaa78(%rip),%r12d\nmov    %edx,0x10(%rsp)\nmov    %esi,0x8(%rsp)\nlea    (%rbx,%r14,1),%r13d\nadd    %r12d,%r11d\nlea    0x40(%r13),%r14d\nlea    0x30(%r11),%ebp\nmovsbl %r14b,%r15d\nmovsbl %bpl,%r8d\nmov    %r15d,%ecx\nmov    %r8d,0x1c(%rsp)\ncall   20c0 <check_move_error_1_to_5>\nmov    0x8(%rsp),%esi\nmov    0x10(%rsp),%edx\ntest   %eax,%eax\nmov    0x1c(%rsp),%r8d\njne    2790 <all_possible_moves+0x4e0>\nmov    (%rsp),%rdi\nmovslq %r10d,%rax\nadd    $0x1,%r10d\nlea    (%rdi,%rax,2),%rax\nmov    %r14b,(%rax)\nmov    %bpl,0x1(%rax)\njmp    2318 <all_possible_moves+0x68>\ncmp    $0x4,%eax\njne    251d <all_possible_moves+0x26d>\nmov    0x28(%rsp),%ecx\nmov    0x30(%rsp),%r8d\nsub    $0x40,%ecx\nsub    $0x31,%r8d\nmovslq %ecx,%rcx\nmovslq %r8d,%r8\nlea    (%rdi,%rcx,8),%rax\nmovzbl -0x8(%r8,%rax,1),%eax\nand    $0xffffffdf,%eax\ntest   %r9d,%r9d\nje     28b0 <all_possible_moves+0x600>\ncmp    $0x57,%al\njne    251d <all_possible_moves+0x26d>\nmovzbl 0x34(%rsp),%eax\nlea    0x40(%rbp,%r15,1),%ebp\nmov    %edx,0x20(%rsp)\nmovsbl %bpl,%ecx\nmov    %esi,0x1c(%rsp)\nlea    0x30(%rbx,%rax,1),%ebx\nmovsbl %bl,%r8d\ncall   20c0 <check_move_error_1_to_5>\nmov    0x1c(%rsp),%esi\nmov    0x20(%rsp),%edx\ntest   %eax,%eax\njne    251d <all_possible_moves+0x26d>\nmov    (%rsp),%rcx\nmovslq %r10d,%rax\nadd    $0x1,%r10d\nlea    (%rcx,%rax,2),%rax\nmov    %bpl,(%rax)\nmov    %bl,0x1(%rax)\njmp    251d <all_possible_moves+0x26d>\nnopw   0x0(%rax,%rax,1)\ncmp    $0x4,%eax\njne    2607 <all_possible_moves+0x357>\nmov    0x1c(%rsp),%ecx\nmov    0x20(%rsp),%r8d\nsub    $0x40,%ecx\nsub    $0x31,%r8d\nmovslq %ecx,%rcx\nmovslq %r8d,%r8\nlea    (%rdi,%rcx,8),%rax\nmovzbl -0x8(%r8,%rax,1),%eax\nand    $0xffffffdf,%eax\ntest   %r9d,%r9d\nje     2890 <all_possible_moves+0x5e0>\ncmp    $0x57,%al\njne    2607 <all_possible_moves+0x357>\nmovzbl 0x28(%rsp),%eax\nlea    0x40(%rbp,%r15,1),%ebp\nmov    %edx,0x10(%rsp)\nmovsbl %bpl,%ecx\nmov    %esi,0x8(%rsp)\nlea    0x30(%rbx,%rax,1),%ebx\nmovsbl %bl,%r8d\ncall   20c0 <check_move_error_1_to_5>\nmov    0x8(%rsp),%esi\nmov    0x10(%rsp),%edx\ntest   %eax,%eax\njne    2607 <all_possible_moves+0x357>\nmov    (%rsp),%rcx\nmovslq %r10d,%rax\nadd    $0x1,%r10d\nlea    (%rcx,%rax,2),%rax\nmov    %bpl,(%rax)\nmov    %bl,0x1(%rax)\njmp    2607 <all_possible_moves+0x357>\nnopw   0x0(%rax,%rax,1)\ncmp    $0x4,%eax\njne    2318 <all_possible_moves+0x68>\nsub    $0x40,%r15d\nsub    $0x31,%r8d\nmovslq %r15d,%r15\nmovslq %r8d,%r8\nlea    (%rdi,%r15,8),%rax\nmovzbl -0x8(%r8,%rax,1),%eax\nand    $0xffffffdf,%eax\ntest   %r9d,%r9d\nje     28a0 <all_possible_moves+0x5f0>\ncmp    $0x57,%al\njne    2318 <all_possible_moves+0x68>\nlea    0x40(%rbx,%r13,1),%ebx\nlea    0x30(%r12,%r11,1),%r11d\nmovsbl %bl,%ecx\nmovsbl %r11b,%r8d\ncall   20c0 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    2318 <all_possible_moves+0x68>\nmov    (%rsp),%rdi\nmovslq %r10d,%rax\nadd    $0x1,%r10d\nlea    (%rdi,%rax,2),%rax\nmov    %bl,(%rax)\nmov    %r11b,0x1(%rax)\njmp    2318 <all_possible_moves+0x68>\nnopl   (%rax)\ncmp    $0x4,%eax\njne    2585 <all_possible_moves+0x2d5>\nsub    $0x40,%r15d\nsub    $0x31,%r8d\nmovslq %r15d,%r15\nmovslq %r8d,%r8\nlea    (%rdi,%r15,8),%rax\nmovzbl -0x8(%r8,%rax,1),%eax\nand    $0xffffffdf,%eax\ntest   %r9d,%r9d\nje     2880 <all_possible_moves+0x5d0>\ncmp    $0x57,%al\njne    2585 <all_possible_moves+0x2d5>\nmovzbl 0x30(%rsp),%eax\nlea    0x30(%rbx,%r11,1),%ebx\nmov    %edx,0x20(%rsp)\nmovsbl %bl,%r8d\nmov    %esi,0x1c(%rsp)\nlea    0x40(%rbp,%rax,1),%ebp\nmovsbl %bpl,%ecx\ncall   20c0 <check_move_error_1_to_5>\nmov    0x1c(%rsp),%esi\nmov    0x20(%rsp),%edx\ntest   %eax,%eax\njne    2585 <all_possible_moves+0x2d5>\nmov    (%rsp),%rcx\nmovslq %r10d,%rax\nadd    $0x1,%r10d\nlea    (%rcx,%rax,2),%rax\nmov    %bpl,(%rax)\nmov    %bl,0x1(%rax)\njmp    2585 <all_possible_moves+0x2d5>\nxchg   %ax,%ax\ncmp    $0x42,%al\nje     2831 <all_possible_moves+0x581>\njmp    2585 <all_possible_moves+0x2d5>\nnopl   0x0(%rax)\ncmp    $0x42,%al\nje     273d <all_possible_moves+0x48d>\njmp    2607 <all_possible_moves+0x357>\nnopl   (%rax)\ncmp    $0x42,%al\nje     27c5 <all_possible_moves+0x515>\njmp    2318 <all_possible_moves+0x68>\nnopl   (%rax)\ncmp    $0x42,%al\nje     26ad <all_possible_moves+0x3fd>\njmp    251d <all_possible_moves+0x26d>\ncmp    $0x30,%r11b\nje     237d <all_possible_moves+0xcd>\nlea    0x30(%rbx),%r8d\nlea    0x40(%r10),%r13d\nmov    %r8b,0x1c(%rsp)\nmovzbl %r13b,%r8d\nsub    $0x40,%r8d\nmovslq %r8d,%r8\nmov    %r8,0x20(%rsp)\nmovzbl 0x1c(%rsp),%r8d\nsub    $0x31,%r8d\nmovslq %r8d,%rbp\nmov    0x20(%rsp),%r8\nlea    (%rdi,%r8,8),%r8\nmovzbl -0x8(%rbp,%r8,1),%r8d\ncmp    $0x30,%r8b\njne    2946 <all_possible_moves+0x696>\nmov    %r11d,%eax\nand    $0xffffffdf,%eax\ntest   %r9d,%r9d\nje     2cbd <all_possible_moves+0xa0d>\ncmp    $0x57,%al\nje     2a0a <all_possible_moves+0x75a>\nmov    (%rsp),%rax\nmovzbl 0x1c(%rsp),%ebx\nmov    %r13b,(%rax)\nmov    %bl,0x1(%rax)\nmov    0x8(%rsp),%rax\nmov    $0x1,%r10d\nmov    0x10(%rsp),%rbx\nmovzbl (%rax,%rbx,1),%r11d\njmp    2380 <all_possible_moves+0xd0>\nand    $0xffffffdf,%r8d\ntest   %r9d,%r9d\nje     2a00 <all_possible_moves+0x750>\ncmp    $0x57,%r8b\njne    2a0a <all_possible_moves+0x75a>\nlea    0x30(%rbx,%rax,1),%ebx\nlea    0x40(%r10,%rcx,1),%r10d\nmov    %edx,0x20(%rsp)\nmovsbl %r10b,%ecx\nmovsbl %bl,%r8d\nmov    %esi,0x1c(%rsp)\ncall   20c0 <check_move_error_1_to_5>\nmov    0x1c(%rsp),%esi\nmov    0x20(%rsp),%edx\ntest   %eax,%eax\njne    2a0a <all_possible_moves+0x75a>\nmov    (%rsp),%rax\nmov    %r10b,(%rax)\njmp    2929 <all_possible_moves+0x679>\nand    $0xffffffdf,%r8d\ntest   %r9d,%r9d\nje     2c90 <all_possible_moves+0x9e0>\ncmp    $0x57,%r8b\njne    2304 <all_possible_moves+0x54>\nlea    0x40(%rbx,%rax,1),%ebx\nlea    0x30(%rbp,%rcx,1),%ebp\nmov    %edx,0x20(%rsp)\nmovsbl %bl,%ecx\nmovsbl %bpl,%r8d\nmov    %esi,0x1c(%rsp)\ncall   20c0 <check_move_error_1_to_5>\nmov    0x1c(%rsp),%esi\nmov    0x20(%rsp),%edx\ntest   %eax,%eax\njne    2304 <all_possible_moves+0x54>\nmov    (%rsp),%rcx\nmovslq %r10d,%rax\nadd    $0x1,%r10d\nlea    (%rcx,%rax,2),%rax\nmov    %bl,(%rax)\nmov    0x10(%rsp),%rbx\nmov    %bpl,0x1(%rax)\nmov    0x8(%rsp),%rax\nmovzbl (%rax,%rbx,1),%r11d\njmp    2304 <all_possible_moves+0x54>\ncmp    $0x42,%r8b\nje     295d <all_possible_moves+0x6ad>\nmov    0xa658(%rip),%ebp\nmov    0xa656(%rip),%ebx\nlea    (%r14,%rbp,1),%eax\nlea    (%r12,%rbx,1),%ecx\nlea    -0x1(%rax),%r8d\nmov    %al,0x1c(%rsp)\nmov    %ecx,%r13d\ncmp    $0x7,%r8b\nseta   %r8b\nxor    %r10d,%r10d\nor     %r15b,%r8b\njne    23ba <all_possible_moves+0x10a>\nlea    -0x1(%rcx),%r8d\ncmp    $0x7,%r8b\nja     23ba <all_possible_moves+0x10a>\nmovzbl 0x1c(%rsp),%r8d\nadd    $0x30,%r13d\nmov    %r13b,0x1c(%rsp)\nadd    $0x40,%r8d\nmov    %r8b,0x20(%rsp)\nmovzbl %r8b,%r8d\nsub    $0x40,%r8d\nmovslq %r8d,%r8\nmov    %r8,0x28(%rsp)\nmovzbl %r13b,%r8d\nsub    $0x31,%r8d\nmovslq %r8d,%r13\nmov    0x28(%rsp),%r8\nlea    (%rdi,%r8,8),%r8\nmovzbl -0x8(%r13,%r8,1),%r8d\ncmp    $0x30,%r8b\njne    2adc <all_possible_moves+0x82c>\nmov    %r11d,%eax\nand    $0xffffffdf,%eax\ntest   %r9d,%r9d\nje     2cca <all_possible_moves+0xa1a>\ncmp    $0x57,%al\nje     2b2e <all_possible_moves+0x87e>\nmov    (%rsp),%rbx\nmovslq %r10d,%rax\nlea    (%rbx,%rax,2),%rax\nmovzbl 0x20(%rsp),%ebx\nmov    %bl,(%rax)\nmovzbl 0x1c(%rsp),%ebx\nmov    %bl,0x1(%rax)\nmov    0x8(%rsp),%rax\nadd    $0x1,%r10d\nmov    0x10(%rsp),%rbx\nmovzbl (%rax,%rbx,1),%r11d\njmp    23ba <all_possible_moves+0x10a>\nand    $0xffffffdf,%r8d\ntest   %r9d,%r9d\nje     2b28 <all_possible_moves+0x878>\ncmp    $0x57,%r8b\njne    2b2e <all_possible_moves+0x87e>\nlea    0x40(%rbp,%rax,1),%ebp\nlea    0x30(%rbx,%rcx,1),%ebx\nmov    %edx,0x20(%rsp)\nmovsbl %bpl,%ecx\nmovsbl %bl,%r8d\nmov    %esi,0x1c(%rsp)\ncall   20c0 <check_move_error_1_to_5>\nmov    0x1c(%rsp),%esi\nmov    0x20(%rsp),%edx\ntest   %eax,%eax\njne    2b2e <all_possible_moves+0x87e>\nmov    (%rsp),%rcx\nmovslq %r10d,%rax\nlea    (%rcx,%rax,2),%rax\nmov    %bpl,(%rax)\njmp    2ac1 <all_possible_moves+0x811>\nnopl   0x0(%rax)\ncmp    $0x42,%r8b\nje     2aeb <all_possible_moves+0x83b>\nmov    0xa53c(%rip),%ebp\nmov    0xa53a(%rip),%ebx\nlea    (%r14,%rbp,1),%eax\nlea    (%r12,%rbx,1),%ecx\nlea    -0x1(%rax),%r8d\nmov    %al,0x1c(%rsp)\nmov    %ecx,%r13d\ncmp    $0x7,%r8b\nseta   %r8b\nor     %r15b,%r8b\njne    23f4 <all_possible_moves+0x144>\nlea    -0x1(%rcx),%r8d\ncmp    $0x7,%r8b\nja     23f4 <all_possible_moves+0x144>\nmovzbl 0x1c(%rsp),%r8d\nadd    $0x30,%r13d\nmov    %r13b,0x1c(%rsp)\nadd    $0x40,%r8d\nmov    %r8b,0x20(%rsp)\nmovzbl %r8b,%r8d\nsub    $0x40,%r8d\nmovslq %r8d,%r8\nmov    %r8,0x28(%rsp)\nmovzbl %r13b,%r8d\nsub    $0x31,%r8d\nmovslq %r8d,%r13\nmov    0x28(%rsp),%r8\nlea    (%rdi,%r8,8),%r8\nmovzbl -0x8(%r13,%r8,1),%r8d\ncmp    $0x30,%r8b\njne    2bfd <all_possible_moves+0x94d>\nmov    %r11d,%eax\nand    $0xffffffdf,%eax\ntest   %r9d,%r9d\nje     2cd7 <all_possible_moves+0xa27>\ncmp    $0x57,%al\nje     2c4e <all_possible_moves+0x99e>\nmov    (%rsp),%rbx\nmovslq %r10d,%rax\nlea    (%rbx,%rax,2),%rax\nmovzbl 0x20(%rsp),%ebx\nmov    %bl,(%rax)\nmovzbl 0x1c(%rsp),%ebx\nmov    %bl,0x1(%rax)\nmov    0x8(%rsp),%rax\nadd    $0x1,%r10d\nmov    0x10(%rsp),%rbx\nmovzbl (%rax,%rbx,1),%r11d\njmp    23f4 <all_possible_moves+0x144>\nand    $0xffffffdf,%r8d\ntest   %r9d,%r9d\nje     2c48 <all_possible_moves+0x998>\ncmp    $0x57,%r8b\njne    2c4e <all_possible_moves+0x99e>\nlea    0x40(%rbp,%rax,1),%ebp\nlea    0x30(%rbx,%rcx,1),%ebx\nmov    %edx,0x20(%rsp)\nmovsbl %bpl,%ecx\nmovsbl %bl,%r8d\nmov    %esi,0x1c(%rsp)\ncall   20c0 <check_move_error_1_to_5>\nmov    0x1c(%rsp),%esi\nmov    0x20(%rsp),%edx\ntest   %eax,%eax\njne    2c4e <all_possible_moves+0x99e>\nmov    (%rsp),%rcx\nmovslq %r10d,%rax\nlea    (%rcx,%rax,2),%rax\nmov    %bpl,(%rax)\njmp    2be2 <all_possible_moves+0x932>\nnopl   (%rax)\ncmp    $0x42,%r8b\nje     2c0c <all_possible_moves+0x95c>\nmov    0xa424(%rip),%ebx\nmov    0xa422(%rip),%ebp\nlea    (%r14,%rbx,1),%eax\nlea    (%r12,%rbp,1),%ecx\nlea    -0x1(%rax),%r8d\nmov    %eax,%r12d\nmov    %ecx,%r13d\ncmp    $0x7,%r8b\nseta   %r8b\nor     %r15b,%r8b\njne    2304 <all_possible_moves+0x54>\nlea    -0x1(%rcx),%r8d\ncmp    $0x7,%r8b\nja     2304 <all_possible_moves+0x54>\njmp    243c <all_possible_moves+0x18c>\ncmp    $0x42,%r8b\nje     29ab <all_possible_moves+0x6fb>\njmp    2304 <all_possible_moves+0x54>\ncmp    $0x30,%r11b\njne    2b6c <all_possible_moves+0x8bc>\njmp    23f4 <all_possible_moves+0x144>\ncmp    $0x30,%r11b\njne    2a4b <all_possible_moves+0x79b>\njmp    23ba <all_possible_moves+0x10a>\ncmp    $0x42,%al\njne    291d <all_possible_moves+0x66d>\njmp    2a0a <all_possible_moves+0x75a>\ncmp    $0x42,%al\njne    2aaa <all_possible_moves+0x7fa>\njmp    2b2e <all_possible_moves+0x87e>\ncmp    $0x42,%al\njne    2bcb <all_possible_moves+0x91b>\njmp    2c4e <all_possible_moves+0x99e>\ncmp    $0x42,%al\njne    2485 <all_possible_moves+0x1d5>\njmp    2304 <all_possible_moves+0x54>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "board_cost", "content": "// function to return board cost for board_t input\nint board_cost(board_t board_input) {\n\tint b_count=0, B_count=0, w_count=0, W_count=0;\n\tfor (int i=0; i<BOARD_SIZE;i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\tif (board_input[i][j] == CELL_BPIECE) {\n\t\t\t\tb_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_BTOWER) {\n\t\t\t\tB_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_WPIECE) {\n\t\t\t\tw_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_WTOWER) {\n\t\t\t\tW_count += 1;\n\t\t\t}\n\t\t}\n\t}\n\tint cost = b_count + (3 * B_count) - w_count - (3 * W_count);\n\treturn cost;\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "board_cost", "address": "0x2dc0", "label": "board_cost", "content": "int __fastcall board_cost(unsigned __int8 (*board_input)[8])\n{\n  unsigned __int8 *v1; // r9\n  int v2; // eax\n  int v3; // ecx\n  int v4; // edx\n  int v5; // esi\n  unsigned __int8 v6; // r8\n  unsigned __int8 v7; // r8\n  unsigned __int8 v8; // r8\n  unsigned __int8 v9; // r8\n  unsigned __int8 v10; // r8\n  unsigned __int8 v11; // r8\n  unsigned __int8 v12; // r8\n  unsigned __int8 v13; // r8\n\n  v1 = &(*board_input)[64];\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  do\n  {\n    while ( 1 )\n    {\n      v13 = (*board_input)[0];\n      if ( (*board_input)[0] != 98 )\n        break;\n      v6 = (*board_input)[1];\n      ++v5;\n      if ( v6 == 98 )\n        goto LABEL_36;\nLABEL_6:\n      switch ( v6 )\n      {\n        case 'B':\n          ++v4;\n          break;\n        case 'w':\n          ++v3;\n          break;\n        case 'W':\n          ++v2;\n          break;\n      }\n      v7 = (*board_input)[2];\n      if ( v7 != 98 )\n        goto LABEL_10;\nLABEL_37:\n      v8 = (*board_input)[3];\n      ++v5;\n      if ( v8 == 98 )\n        goto LABEL_38;\nLABEL_14:\n      switch ( v8 )\n      {\n        case 'B':\n          ++v4;\n          break;\n        case 'w':\n          ++v3;\n          break;\n        case 'W':\n          ++v2;\n          break;\n      }\n      v9 = (*board_input)[4];\n      if ( v9 != 98 )\n        goto LABEL_18;\nLABEL_39:\n      v10 = (*board_input)[5];\n      ++v5;\n      if ( v10 == 98 )\n        goto LABEL_40;\nLABEL_22:\n      switch ( v10 )\n      {\n        case 'B':\n          ++v4;\n          break;\n        case 'w':\n          ++v3;\n          break;\n        case 'W':\n          ++v2;\n          break;\n      }\n      v11 = (*board_input)[6];\n      if ( v11 != 98 )\n        goto LABEL_26;\nLABEL_41:\n      v12 = (*board_input)[7];\n      ++v5;\n      if ( v12 != 98 )\n        goto LABEL_30;\nLABEL_42:\n      ++board_input;\n      ++v5;\n      if ( v1 == (unsigned __int8 *)board_input )\n        return v5 + 3 * v4 - v3 - 3 * v2;\n    }\n    switch ( v13 )\n    {\n      case 'B':\n        ++v4;\n        break;\n      case 'w':\n        ++v3;\n        break;\n      case 'W':\n        ++v2;\n        break;\n    }\n    v6 = (*board_input)[1];\n    if ( v6 != 98 )\n      goto LABEL_6;\nLABEL_36:\n    v7 = (*board_input)[2];\n    ++v5;\n    if ( v7 == 98 )\n      goto LABEL_37;\nLABEL_10:\n    switch ( v7 )\n    {\n      case 'B':\n        ++v4;\n        break;\n      case 'w':\n        ++v3;\n        break;\n      case 'W':\n        ++v2;\n        break;\n    }\n    v8 = (*board_input)[3];\n    if ( v8 != 98 )\n      goto LABEL_14;\nLABEL_38:\n    v9 = (*board_input)[4];\n    ++v5;\n    if ( v9 == 98 )\n      goto LABEL_39;\nLABEL_18:\n    switch ( v9 )\n    {\n      case 'B':\n        ++v4;\n        break;\n      case 'w':\n        ++v3;\n        break;\n      case 'W':\n        ++v2;\n        break;\n    }\n    v10 = (*board_input)[5];\n    if ( v10 != 98 )\n      goto LABEL_22;\nLABEL_40:\n    v11 = (*board_input)[6];\n    ++v5;\n    if ( v11 == 98 )\n      goto LABEL_41;\nLABEL_26:\n    switch ( v11 )\n    {\n      case 'B':\n        ++v4;\n        break;\n      case 'w':\n        ++v3;\n        break;\n      case 'W':\n        ++v2;\n        break;\n    }\n    v12 = (*board_input)[7];\n    if ( v12 == 98 )\n      goto LABEL_42;\nLABEL_30:\n    switch ( v12 )\n    {\n      case 'B':\n        ++v4;\n        break;\n      case 'w':\n        ++v3;\n        break;\n      case 'W':\n        ++v2;\n        break;\n    }\n    ++board_input;\n  }\n  while ( v1 != (unsigned __int8 *)board_input );\n  return v5 + 3 * v4 - v3 - 3 * v2;\n}\n"}, "pseudo_normalize": "int board_cost(unsigned char (*board_input)[8]) {\n  unsigned char *v1;\n  int v2;\n  int v3;\n  int v4;\n  int v5;\n  unsigned char v6;\n  unsigned char v7;\n  unsigned char v8;\n  unsigned char v9;\n  unsigned char v10;\n  unsigned char v11;\n  unsigned char v12;\n  unsigned char v13;\n  v1 = &(*board_input)[64];\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  do {\n    while (1) {\n      v13 = (*board_input)[0];\n      if ((*board_input)[0] != 98) break;\n      v6 = (*board_input)[1];\n      ++v5;\n      if (v6 == 98) goto LABEL_36;\n    LABEL_6:\n      switch (v6) {\n        case 'B':\n          ++v4;\n          break;\n        case 'w':\n          ++v3;\n          break;\n        case 'W':\n          ++v2;\n          break;\n      }\n      v7 = (*board_input)[2];\n      if (v7 != 98) goto LABEL_10;\n    LABEL_37:\n      v8 = (*board_input)[3];\n      ++v5;\n      if (v8 == 98) goto LABEL_38;\n    LABEL_14:\n      switch (v8) {\n        case 'B':\n          ++v4;\n          break;\n        case 'w':\n          ++v3;\n          break;\n        case 'W':\n          ++v2;\n          break;\n      }\n      v9 = (*board_input)[4];\n      if (v9 != 98) goto LABEL_18;\n    LABEL_39:\n      v10 = (*board_input)[5];\n      ++v5;\n      if (v10 == 98) goto LABEL_40;\n    LABEL_22:\n      switch (v10) {\n        case 'B':\n          ++v4;\n          break;\n        case 'w':\n          ++v3;\n          break;\n        case 'W':\n          ++v2;\n          break;\n      }\n      v11 = (*board_input)[6];\n      if (v11 != 98) goto LABEL_26;\n    LABEL_41:\n      v12 = (*board_input)[7];\n      ++v5;\n      if (v12 != 98) goto LABEL_30;\n    LABEL_42:\n      ++board_input;\n      ++v5;\n      if (v1 == (unsigned char *)board_input) return v5 + 3 * v4 - v3 - 3 * v2;\n    }\n    switch (v13) {\n      case 'B':\n        ++v4;\n        break;\n      case 'w':\n        ++v3;\n        break;\n      case 'W':\n        ++v2;\n        break;\n    }\n    v6 = (*board_input)[1];\n    if (v6 != 98) goto LABEL_6;\n  LABEL_36:\n    v7 = (*board_input)[2];\n    ++v5;\n    if (v7 == 98) goto LABEL_37;\n  LABEL_10:\n    switch (v7) {\n      case 'B':\n        ++v4;\n        break;\n      case 'w':\n        ++v3;\n        break;\n      case 'W':\n        ++v2;\n        break;\n    }\n    v8 = (*board_input)[3];\n    if (v8 != 98) goto LABEL_14;\n  LABEL_38:\n    v9 = (*board_input)[4];\n    ++v5;\n    if (v9 == 98) goto LABEL_39;\n  LABEL_18:\n    switch (v9) {\n      case 'B':\n        ++v4;\n        break;\n      case 'w':\n        ++v3;\n        break;\n      case 'W':\n        ++v2;\n        break;\n    }\n    v10 = (*board_input)[5];\n    if (v10 != 98) goto LABEL_22;\n  LABEL_40:\n    v11 = (*board_input)[6];\n    ++v5;\n    if (v11 == 98) goto LABEL_41;\n  LABEL_26:\n    switch (v11) {\n      case 'B':\n        ++v4;\n        break;\n      case 'w':\n        ++v3;\n        break;\n      case 'W':\n        ++v2;\n        break;\n    }\n    v12 = (*board_input)[7];\n    if (v12 == 98) goto LABEL_42;\n  LABEL_30:\n    switch (v12) {\n      case 'B':\n        ++v4;\n        break;\n      case 'w':\n        ++v3;\n        break;\n      case 'W':\n        ++v2;\n        break;\n    }\n    ++board_input;\n  } while (v1 != (unsigned char *)board_input);\n  return v5 + 3 * v4 - v3 - 3 * v2;\n}", "binary": "checkers/checkers.host.O3", "assembly": "<board_cost>:\nendbr64\nlea    0x40(%rdi),%r9\nxor    %eax,%eax\nxor    %ecx,%ecx\nxor    %edx,%edx\nxor    %esi,%esi\njmp    2f06 <board_cost+0x146>\nnopl   (%rax)\ncmp    $0x42,%r8b\nje     30b0 <board_cost+0x2f0>\ncmp    $0x77,%r8b\njne    3098 <board_cost+0x2d8>\nadd    $0x1,%ecx\nmovzbl 0x1(%rdi),%r8d\ncmp    $0x62,%r8b\nje     2f26 <board_cost+0x166>\ncmp    $0x42,%r8b\nje     3090 <board_cost+0x2d0>\ncmp    $0x77,%r8b\njne    3078 <board_cost+0x2b8>\nadd    $0x1,%ecx\nmovzbl 0x2(%rdi),%r8d\ncmp    $0x62,%r8b\nje     2f38 <board_cost+0x178>\ncmp    $0x42,%r8b\nje     3070 <board_cost+0x2b0>\ncmp    $0x77,%r8b\njne    3058 <board_cost+0x298>\nadd    $0x1,%ecx\nmovzbl 0x3(%rdi),%r8d\ncmp    $0x62,%r8b\nje     2f4a <board_cost+0x18a>\ncmp    $0x42,%r8b\nje     3050 <board_cost+0x290>\ncmp    $0x77,%r8b\njne    3038 <board_cost+0x278>\nadd    $0x1,%ecx\nmovzbl 0x4(%rdi),%r8d\ncmp    $0x62,%r8b\nje     2f5c <board_cost+0x19c>\ncmp    $0x42,%r8b\nje     3030 <board_cost+0x270>\ncmp    $0x77,%r8b\njne    3018 <board_cost+0x258>\nadd    $0x1,%ecx\nmovzbl 0x5(%rdi),%r8d\ncmp    $0x62,%r8b\nje     2f6e <board_cost+0x1ae>\ncmp    $0x42,%r8b\nje     3010 <board_cost+0x250>\ncmp    $0x77,%r8b\njne    2ff8 <board_cost+0x238>\nadd    $0x1,%ecx\nmovzbl 0x6(%rdi),%r8d\ncmp    $0x62,%r8b\nje     2f80 <board_cost+0x1c0>\ncmp    $0x42,%r8b\nje     2ff0 <board_cost+0x230>\ncmp    $0x77,%r8b\njne    2fd8 <board_cost+0x218>\nadd    $0x1,%ecx\nmovzbl 0x7(%rdi),%r8d\ncmp    $0x62,%r8b\nje     2f92 <board_cost+0x1d2>\ncmp    $0x42,%r8b\nje     2fd0 <board_cost+0x210>\ncmp    $0x77,%r8b\njne    2fb5 <board_cost+0x1f5>\nadd    $0x1,%ecx\nadd    $0x8,%rdi\ncmp    %rdi,%r9\nje     2fa2 <board_cost+0x1e2>\nmovzbl (%rdi),%r8d\ncmp    $0x62,%r8b\njne    2dd8 <board_cost+0x18>\nmovzbl 0x1(%rdi),%r8d\nadd    $0x1,%esi\ncmp    $0x62,%r8b\njne    2dfe <board_cost+0x3e>\nmovzbl 0x2(%rdi),%r8d\nadd    $0x1,%esi\ncmp    $0x62,%r8b\njne    2e24 <board_cost+0x64>\nmovzbl 0x3(%rdi),%r8d\nadd    $0x1,%esi\ncmp    $0x62,%r8b\njne    2e4a <board_cost+0x8a>\nmovzbl 0x4(%rdi),%r8d\nadd    $0x1,%esi\ncmp    $0x62,%r8b\njne    2e70 <board_cost+0xb0>\nmovzbl 0x5(%rdi),%r8d\nadd    $0x1,%esi\ncmp    $0x62,%r8b\njne    2e96 <board_cost+0xd6>\nmovzbl 0x6(%rdi),%r8d\nadd    $0x1,%esi\ncmp    $0x62,%r8b\njne    2ebc <board_cost+0xfc>\nmovzbl 0x7(%rdi),%r8d\nadd    $0x1,%esi\ncmp    $0x62,%r8b\njne    2ee2 <board_cost+0x122>\nadd    $0x8,%rdi\nadd    $0x1,%esi\ncmp    %rdi,%r9\njne    2f06 <board_cost+0x146>\nlea    (%rdx,%rdx,2),%edx\nadd    %esi,%edx\nsub    %ecx,%edx\nlea    0x0(,%rax,4),%ecx\nsub    %ecx,%eax\nadd    %edx,%eax\nret\ncmp    $0x57,%r8b\njne    2ef9 <board_cost+0x139>\nadd    $0x1,%eax\njmp    2ef9 <board_cost+0x139>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%edx\njmp    2ef9 <board_cost+0x139>\ncmp    $0x57,%r8b\njne    2ed3 <board_cost+0x113>\nadd    $0x1,%eax\njmp    2ed3 <board_cost+0x113>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%edx\njmp    2ed3 <board_cost+0x113>\ncmp    $0x57,%r8b\njne    2ead <board_cost+0xed>\nadd    $0x1,%eax\njmp    2ead <board_cost+0xed>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%edx\njmp    2ead <board_cost+0xed>\ncmp    $0x57,%r8b\njne    2e87 <board_cost+0xc7>\nadd    $0x1,%eax\njmp    2e87 <board_cost+0xc7>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%edx\njmp    2e87 <board_cost+0xc7>\ncmp    $0x57,%r8b\njne    2e61 <board_cost+0xa1>\nadd    $0x1,%eax\njmp    2e61 <board_cost+0xa1>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%edx\njmp    2e61 <board_cost+0xa1>\ncmp    $0x57,%r8b\njne    2e3b <board_cost+0x7b>\nadd    $0x1,%eax\njmp    2e3b <board_cost+0x7b>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%edx\njmp    2e3b <board_cost+0x7b>\ncmp    $0x57,%r8b\njne    2e15 <board_cost+0x55>\nadd    $0x1,%eax\njmp    2e15 <board_cost+0x55>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%edx\njmp    2e15 <board_cost+0x55>\ncmp    $0x57,%r8b\njne    2def <board_cost+0x2f>\nadd    $0x1,%eax\njmp    2def <board_cost+0x2f>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%edx\njmp    2def <board_cost+0x2f>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "change_board", "content": "// adjust a board_t variable with a given input move\nvoid change_board(board_t* board, char col1, char row1, char col2, char row2) {\n\tchar being_moved_temp = piece_at_location(*board, col1, row1);\n\t\n\t// make source cell empty\n\t(*board)[char_to_col(col1) - 1][char_to_row(row1) - 1] = CELL_EMPTY;\n\t\n\t// consider, if piece reached end, it must be promoted\n\tif ((being_moved_temp == CELL_BPIECE) && (row2 == END_ROW_BLACK)) {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1]\n\t\t\t= CELL_BTOWER;\n\t}\n\telse if ((being_moved_temp == CELL_WPIECE) && (row2 == END_ROW_WHITE)) {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1]\n\t\t\t= CELL_WTOWER;\n\t}\n\t// otherwise make target cell the piece being moved\n\telse {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1] \n\t\t\t= being_moved_temp;\n\t}\n\t// if capturing, captured middle piece must be removed as well\n\tif (libmin_abs(char_to_col(col2) - char_to_col(col1)) == CAPTURE_JUMP) {\n\t\tint middle_col = min(char_to_col(col1), char_to_col(col2)) + 1;\n\t\tint middle_row = min(char_to_row(row1), char_to_row(row2)) + 1;\n\t\t(*board)[middle_col - 1][middle_row - 1] = CELL_EMPTY;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "change_board", "address": "0x21b0", "label": "change_board", "content": "void __fastcall change_board(board_t *board, char col1, char row1, char col2, char row2)\n{\n  int v6; // esi\n  __int64 v9; // rax\n  int v11; // ebx\n  unsigned __int8 v12; // r8\n  int v13; // eax\n  int v14; // eax\n  __int64 v15; // rcx\n  __int64 v16; // rbx\n  int v17; // esi\n  int v18; // eax\n\n  v6 = row1;\n  v9 = row1 - 49;\n  v11 = col2;\n  v12 = (*board)[col1 - 65][v9];\n  (*board)[col1 - 65][v9] = 48;\n  v13 = col2 - 65;\n  if ( v12 == 98 && row2 == 49 )\n  {\n    (*board)[v13][0] = 66;\n  }\n  else if ( v12 == 119 && row2 == 56 )\n  {\n    (*board)[v13][7] = 87;\n  }\n  else\n  {\n    (*board)[v13 - 6][row2 - 1] = v12;\n  }\n  v14 = libmin_abs(col2 - col1);\n  v15 = col1 - 64;\n  if ( v14 == 2 )\n  {\n    v16 = v11 - 64;\n    if ( col1 >= col2 )\n      v15 = v16;\n    v17 = v6 - 48;\n    v18 = row2 - 48;\n    if ( row1 < row2 )\n      v18 = v17;\n    (*board)[v15][v18] = 48;\n  }\n}\n"}, "pseudo_normalize": "void change_board(board_t *board, char col1, char row1, char col2, char row2) {\n  int v6;\n  long long v9;\n  int v11;\n  unsigned char v12;\n  int v13;\n  int v14;\n  long long v15;\n  long long v16;\n  int v17;\n  int v18;\n  v6 = row1;\n  v9 = row1 - 49;\n  v11 = col2;\n  v12 = (*board)[col1 - 65][v9];\n  (*board)[col1 - 65][v9] = 48;\n  v13 = col2 - 65;\n  if (v12 == 98 && row2 == 49) {\n    (*board)[v13][0] = 66;\n  } else if (v12 == 119 && row2 == 56) {\n    (*board)[v13][7] = 87;\n  } else {\n    (*board)[v13 - 6][row2 - 1] = v12;\n  }\n  v14 = libmin_abs(col2 - col1);\n  v15 = col1 - 64;\n  if (v14 == 2) {\n    v16 = v11 - 64;\n    if (col1 >= col2) v15 = v16;\n    v17 = v6 - 48;\n    v18 = row2 - 48;\n    if (row1 < row2) v18 = v17;\n    (*board)[v15][v18] = 48;\n  }\n}", "binary": "checkers/checkers.host.O3", "assembly": "<change_board>:\nendbr64\npush   %r15\nmov    %esi,%r15d\nmovsbl %dl,%esi\npush   %r14\nlea    -0x31(%rsi),%eax\nmov    %ecx,%r14d\npush   %r13\nmov    %edx,%r13d\nmovsbl %r15b,%edx\ncltq\npush   %r12\nmov    %r8d,%r12d\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nlea    -0x40(%rdx),%ebx\nmovslq %ebx,%rcx\nmovsbl %r14b,%ebx\nlea    (%rdi,%rcx,8),%rdi\nsub    $0x18,%rsp\nmovzbl -0x8(%rax,%rdi,1),%r8d\nlea    -0x41(%rdx),%edi\nmovslq %edi,%rdi\nlea    0x0(%rbp,%rdi,8),%rdi\nmovb   $0x30,(%rdi,%rax,1)\nlea    -0x41(%rbx),%eax\ncmp    $0x62,%r8b\njne    2270 <change_board+0xc0>\ncmp    $0x31,%r12b\njne    2270 <change_board+0xc0>\ncltq\nmovb   $0x42,0x0(%rbp,%rax,8)\nmov    %ebx,%edi\nmov    %rcx,0x8(%rsp)\nsub    %edx,%edi\nmov    %esi,0x4(%rsp)\ncall   6790 <libmin_abs>\nmov    0x4(%rsp),%esi\nmov    0x8(%rsp),%rcx\ncmp    $0x2,%eax\njne    225e <change_board+0xae>\nsub    $0x40,%ebx\nmovsbl %r12b,%eax\ncmp    %r14b,%r15b\nmovslq %ebx,%rbx\ncmovge %rbx,%rcx\nsub    $0x30,%esi\nsub    $0x30,%eax\ncmp    %r12b,%r13b\ncmovl  %esi,%eax\nlea    0x0(%rbp,%rcx,8),%rdx\ncltq\nmovb   $0x30,(%rdx,%rax,1)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\ncmp    $0x77,%r8b\njne    2288 <change_board+0xd8>\ncmp    $0x38,%r12b\njne    2288 <change_board+0xd8>\ncltq\nmovb   $0x57,0x7(%rbp,%rax,8)\njmp    2216 <change_board+0x66>\nnopl   (%rax)\nmovsbl %r12b,%edi\ncltq\nsub    $0x31,%edi\nlea    0x0(%rbp,%rax,8),%rax\nmovslq %edi,%rdi\nmov    %r8b,(%rax,%rdi,1)\njmp    2216 <change_board+0x66>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "char_to_col", "content": "// convert column coordinate character position into column number\n// offset from A + 1 to give col number\nint char_to_col(char col) { \n\tint ascii_value = (int) col;\n\treturn ascii_value - ASCII_A + 1;}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "char_to_col", "address": "0x1fb0", "label": "char_to_col", "content": "int __fastcall char_to_col(char col)\n{\n  return col - 64;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O3", "assembly": "<char_to_col>:\nendbr64\nmovsbl %dil,%eax\nsub    $0x40,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "char_to_row", "content": "// convert row coordinate character position into row number\n// offset from 1 + 1 to give row number\nint char_to_row(char row) { \n\tint ascii_value = (int) row;\n\treturn ascii_value - ASCII_1 + 1;}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "char_to_row", "address": "0x1fc0", "label": "char_to_row", "content": "int __fastcall char_to_row(char row)\n{\n  return row - 48;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O3", "assembly": "<char_to_row>:\nendbr64\nmovsbl %dil,%eax\nsub    $0x30,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "check_move_error_1_to_5", "content": "// lazy evaluation, systematically check for move errors 1-5\n\t// if any found, print error message and return error code\nint check_move_error_1_to_5(board_t board_input, \n\tchar col1, char row1, char col2, char row2, int black_action) {\n\t// error 1\n\tif (outside_of_board(col1, row1)) {\n\t\treturn 1;\n\t}\n\t// error 2\n\tif (outside_of_board(col2, row2)) {\n\t\treturn 2;\n\t}\n\t// error 3\n\tif (piece_at_location(board_input, col1, row1) == CELL_EMPTY) {\n\t\treturn 3;\n\t}\n\t// error 4\n\tif (piece_at_location(board_input, col2, row2) != CELL_EMPTY) {\n\t\treturn 4;\n\t}\n\t// error 5 \n\tif (black_action) {\n\t\tif ((piece_at_location(board_input, col1, row1) == CELL_WPIECE)\n\t\t\t|| \n\t\t(piece_at_location(board_input, col1, row1) == CELL_WTOWER)) {\n\t\t\treturn 5;\n\t\t}\n\t}\n\telse {\n\t\tif ((piece_at_location(board_input, col1, row1) == CELL_BPIECE)\n\t\t\t|| \n\t\t(piece_at_location(board_input, col1, row1) == CELL_BTOWER)) {\n\t\t\treturn 5;\n\t\t}\n\t}\n\treturn NO_ERRORS_1_TO_5;\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "check_move_error_1_to_5", "address": "0x20c0", "label": "check_move_error_1_to_5", "content": "int __fastcall check_move_error_1_to_5(\n        unsigned __int8 (*board_input)[8],\n        char col1,\n        char row1,\n        char col2,\n        char row2,\n        int black_action)\n{\n  unsigned __int8 v6; // dl\n  int result; // eax\n  unsigned __int8 v8; // r8\n  unsigned __int8 v9; // dl\n  char v10; // dl\n\n  if ( (unsigned __int8)(col1 - 65) > 7u )\n    return 1;\n  v6 = row1 - 49;\n  if ( v6 > 7u )\n    return 1;\n  if ( (unsigned __int8)(col2 - 65) > 7u )\n    return 2;\n  v8 = row2 - 49;\n  if ( v8 > 7u )\n    return 2;\n  v9 = (*board_input)[8 * (char)(col1 - 64) - 8 + (char)v6];\n  if ( v9 == 48 )\n    return 3;\n  result = 4;\n  if ( (*board_input)[8 * (char)(col2 - 64) - 8 + (char)v8] == 48 )\n  {\n    v10 = v9 & 0xDF;\n    if ( black_action )\n      return 5 * (v10 == 87);\n    else\n      return 5 * (v10 == 66);\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int check_move_error_1_to_5(unsigned char (*board_input)[8], char col1,\n                            char row1, char col2, char row2, int black_action) {\n  unsigned char v6;\n  int result;\n  unsigned char v8;\n  unsigned char v9;\n  char v10;\n  if ((unsigned char)(col1 - 65) > 7u) return 1;\n  v6 = row1 - 49;\n  if (v6 > 7u) return 1;\n  if ((unsigned char)(col2 - 65) > 7u) return 2;\n  v8 = row2 - 49;\n  if (v8 > 7u) return 2;\n  v9 = (*board_input)[8 * (char)(col1 - 64) - 8 + (char)v6];\n  if (v9 == 48) return 3;\n  result = 4;\n  if ((*board_input)[8 * (char)(col2 - 64) - 8 + (char)v8] == 48) {\n    v10 = v9 & 223;\n    if (black_action)\n      return 5 * (v10 == 87);\n    else\n      return 5 * (v10 == 66);\n  }\n  return result;\n}", "binary": "checkers/checkers.host.O3", "assembly": "<check_move_error_1_to_5>:\nendbr64\nmov    %esi,%eax\nlea    -0x41(%rsi),%esi\ncmp    $0x7,%sil\nja     20d7 <check_move_error_1_to_5+0x17>\nsub    $0x31,%edx\ncmp    $0x7,%dl\njbe    20e0 <check_move_error_1_to_5+0x20>\nmov    $0x1,%eax\nret\nnopl   (%rax)\nlea    -0x41(%rcx),%esi\ncmp    $0x7,%sil\nja     20f3 <check_move_error_1_to_5+0x33>\nsub    $0x31,%r8d\ncmp    $0x7,%r8b\njbe    2100 <check_move_error_1_to_5+0x40>\nmov    $0x2,%eax\nret\nnopl   0x0(%rax)\nsub    $0x40,%eax\nmovsbq %dl,%rdx\nmovsbq %al,%rax\nlea    (%rdi,%rax,8),%rax\nmovzbl -0x8(%rdx,%rax,1),%edx\ncmp    $0x30,%dl\nje     2149 <check_move_error_1_to_5+0x89>\nsub    $0x40,%ecx\nmovsbq %r8b,%r8\nmov    $0x4,%eax\nmovsbq %cl,%rcx\nlea    (%rdi,%rcx,8),%rcx\ncmpb   $0x30,-0x8(%r8,%rcx,1)\njne    214e <check_move_error_1_to_5+0x8e>\nand    $0xffffffdf,%edx\ntest   %r9d,%r9d\nje     214f <check_move_error_1_to_5+0x8f>\nxor    %eax,%eax\ncmp    $0x57,%dl\nsete   %al\nlea    (%rax,%rax,4),%eax\nret\nmov    $0x3,%eax\nret\nxor    %eax,%eax\ncmp    $0x42,%dl\nsete   %al\nlea    (%rax,%rax,4),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "col_to_char", "content": "// reverse char_to_col\nchar col_to_char(int col) {return (char) (ASCII_A + col - 1);}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "col_to_char", "address": "0x1fd0", "label": "col_to_char", "content": "char __fastcall col_to_char(int col)\n{\n  return col + 64;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O3", "assembly": "<col_to_char>:\nendbr64\nlea    0x40(%rdi),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "fill_print_initial", "content": "#include \"libmin.h\"\n\n#include \"consttypes.h\"\n#include \"functions.h\"\n\n// fill and print information on the initial board configuration\nvoid fill_print_initial(board_t* board) {\n\t// specify initial setup \n\tlibmin_printf(\"BOARD SIZE: %dx%d\\n\", BOARD_SIZE, BOARD_SIZE);\n\tlibmin_printf(\"#BLACK PIECES: %d\\n\", ORIGINAL_PIECES_COUNT);\n\tlibmin_printf(\"#WHITE PIECES: %d\\n\", ORIGINAL_PIECES_COUNT);\n\t\n\t// fill board with the original board configuration\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\tint filled = 0; \n\t\t\tfor (int k=0; k<ORIGINAL_PIECES_COUNT; k++) {\n\t\t\t\tif ((char_to_col(white_initial_squares[k][0]) == i + 1) && \n\t\t\t\t\t(char_to_row(white_initial_squares[k][1]) == j + 1)) {\n\t\t\t\t\t\t(*board)[i][j] = CELL_WPIECE;\n\t\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k=0; k<ORIGINAL_PIECES_COUNT; k++) {\n\t\t\t\tif ((char_to_col(black_initial_squares[k][0]) == i + 1) && \n\t\t\t\t\t(char_to_row(black_initial_squares[k][1]) == j + 1)) {\n\t\t\t\t\t\t(*board)[i][j] = CELL_BPIECE;\n\t\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (filled == 0) {\n\t\t\t\t(*board)[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "fill_print_initial", "address": "0x18e0", "label": "fill_print_initial", "content": "void __fastcall fill_print_initial(board_t *board)\n{\n  int v2; // eax\n  unsigned __int8 *v3; // rcx\n  int v4; // edx\n  int v5; // esi\n\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  v2 = 0;\n  do\n  {\n    ++v2;\n    v3 = (unsigned __int8 *)board;\n    v4 = 0;\n    do\n    {\n      while ( 1 )\n      {\n        ++v4;\n        v5 = 0;\n        if ( white_initial_squares[0] - 64 == v2 && white_initial_squares[1] - 48 == v4 )\n        {\n          *v3 = 119;\n          v5 = 1;\n          if ( white_initial_squares[2] - 64 != v2 )\n            goto LABEL_4;\n        }\n        else if ( white_initial_squares[2] - 64 != v2 )\n        {\n          goto LABEL_4;\n        }\n        if ( white_initial_squares[3] - 48 != v4 )\n        {\nLABEL_4:\n          if ( white_initial_squares[4] - 64 != v2 )\n            goto LABEL_5;\n          goto LABEL_34;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if ( white_initial_squares[4] - 64 != v2 )\n          goto LABEL_5;\nLABEL_34:\n        if ( white_initial_squares[5] - 48 != v4 )\n        {\nLABEL_5:\n          if ( white_initial_squares[6] - 64 != v2 )\n            goto LABEL_6;\n          goto LABEL_36;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if ( white_initial_squares[6] - 64 != v2 )\n          goto LABEL_6;\nLABEL_36:\n        if ( white_initial_squares[7] - 48 != v4 )\n        {\nLABEL_6:\n          if ( white_initial_squares[8] - 64 != v2 )\n            goto LABEL_7;\n          goto LABEL_38;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if ( white_initial_squares[8] - 64 != v2 )\n          goto LABEL_7;\nLABEL_38:\n        if ( white_initial_squares[9] - 48 != v4 )\n        {\nLABEL_7:\n          if ( white_initial_squares[10] - 64 != v2 )\n            goto LABEL_8;\n          goto LABEL_40;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if ( white_initial_squares[10] - 64 != v2 )\n          goto LABEL_8;\nLABEL_40:\n        if ( white_initial_squares[11] - 48 != v4 )\n        {\nLABEL_8:\n          if ( white_initial_squares[12] - 64 != v2 )\n            goto LABEL_9;\n          goto LABEL_42;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if ( white_initial_squares[12] - 64 != v2 )\n          goto LABEL_9;\nLABEL_42:\n        if ( white_initial_squares[13] - 48 != v4 )\n        {\nLABEL_9:\n          if ( white_initial_squares[14] - 64 != v2 )\n            goto LABEL_10;\n          goto LABEL_44;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if ( white_initial_squares[14] - 64 != v2 )\n          goto LABEL_10;\nLABEL_44:\n        if ( white_initial_squares[15] - 48 != v4 )\n        {\nLABEL_10:\n          if ( white_initial_squares[16] - 64 != v2 )\n            goto LABEL_11;\n          goto LABEL_46;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if ( white_initial_squares[16] - 64 != v2 )\n          goto LABEL_11;\nLABEL_46:\n        if ( white_initial_squares[17] - 48 != v4 )\n        {\nLABEL_11:\n          if ( white_initial_squares[18] - 64 != v2 )\n            goto LABEL_12;\n          goto LABEL_48;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if ( white_initial_squares[18] - 64 != v2 )\n          goto LABEL_12;\nLABEL_48:\n        if ( white_initial_squares[19] - 48 != v4 )\n        {\nLABEL_12:\n          if ( white_initial_squares[20] - 64 != v2 )\n            goto LABEL_13;\n          goto LABEL_50;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if ( white_initial_squares[20] - 64 != v2 )\n          goto LABEL_13;\nLABEL_50:\n        if ( white_initial_squares[21] - 48 != v4 )\n        {\nLABEL_13:\n          if ( white_initial_squares[22] - 64 != v2 )\n            goto LABEL_14;\n          goto LABEL_52;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if ( white_initial_squares[22] - 64 != v2 )\n          goto LABEL_14;\nLABEL_52:\n        if ( white_initial_squares[23] - 48 != v4 )\n        {\nLABEL_14:\n          if ( black_initial_squares[0] - 64 != v2 )\n            goto LABEL_15;\n          goto LABEL_54;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if ( black_initial_squares[0] - 64 != v2 )\n          goto LABEL_15;\nLABEL_54:\n        if ( black_initial_squares[1] - 48 != v4 )\n        {\nLABEL_15:\n          if ( black_initial_squares[2] - 64 != v2 )\n            goto LABEL_16;\n          goto LABEL_56;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if ( black_initial_squares[2] - 64 != v2 )\n          goto LABEL_16;\nLABEL_56:\n        if ( black_initial_squares[3] - 48 != v4 )\n        {\nLABEL_16:\n          if ( black_initial_squares[4] - 64 != v2 )\n            goto LABEL_17;\n          goto LABEL_58;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if ( black_initial_squares[4] - 64 != v2 )\n          goto LABEL_17;\nLABEL_58:\n        if ( black_initial_squares[5] - 48 != v4 )\n        {\nLABEL_17:\n          if ( black_initial_squares[6] - 64 != v2 )\n            goto LABEL_18;\n          goto LABEL_60;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if ( black_initial_squares[6] - 64 != v2 )\n          goto LABEL_18;\nLABEL_60:\n        if ( black_initial_squares[7] - 48 != v4 )\n        {\nLABEL_18:\n          if ( black_initial_squares[8] - 64 != v2 )\n            goto LABEL_19;\n          goto LABEL_62;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if ( black_initial_squares[8] - 64 != v2 )\n          goto LABEL_19;\nLABEL_62:\n        if ( black_initial_squares[9] - 48 != v4 )\n        {\nLABEL_19:\n          if ( black_initial_squares[10] - 64 != v2 )\n            goto LABEL_20;\n          goto LABEL_64;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if ( black_initial_squares[10] - 64 != v2 )\n          goto LABEL_20;\nLABEL_64:\n        if ( black_initial_squares[11] - 48 != v4 )\n        {\nLABEL_20:\n          if ( black_initial_squares[12] - 64 != v2 )\n            goto LABEL_21;\n          goto LABEL_66;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if ( black_initial_squares[12] - 64 != v2 )\n          goto LABEL_21;\nLABEL_66:\n        if ( black_initial_squares[13] - 48 != v4 )\n        {\nLABEL_21:\n          if ( black_initial_squares[14] - 64 != v2 )\n            goto LABEL_22;\n          goto LABEL_68;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if ( black_initial_squares[14] - 64 != v2 )\n          goto LABEL_22;\nLABEL_68:\n        if ( black_initial_squares[15] - 48 != v4 )\n        {\nLABEL_22:\n          if ( black_initial_squares[16] - 64 != v2 )\n            goto LABEL_23;\n          goto LABEL_70;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if ( black_initial_squares[16] - 64 != v2 )\n          goto LABEL_23;\nLABEL_70:\n        if ( black_initial_squares[17] - 48 != v4 )\n        {\nLABEL_23:\n          if ( black_initial_squares[18] - 64 != v2 )\n            break;\n          goto LABEL_72;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if ( black_initial_squares[18] - 64 != v2 )\n          break;\nLABEL_72:\n        if ( black_initial_squares[19] - 48 != v4 )\n          break;\n        *v3 = 98;\n        v5 = 1;\n        if ( black_initial_squares[20] - 64 != v2 )\n          goto LABEL_25;\nLABEL_74:\n        if ( black_initial_squares[21] - 48 != v4 )\n          goto LABEL_25;\n        *v3 = 98;\n        if ( black_initial_squares[22] - 64 == v2 && black_initial_squares[23] - 48 == v4 )\n        {\n          *v3 = 98;\n          goto LABEL_78;\n        }\nLABEL_28:\n        ++v3;\n        if ( v4 == 8 )\n          goto LABEL_79;\n      }\n      if ( black_initial_squares[20] - 64 == v2 )\n        goto LABEL_74;\nLABEL_25:\n      if ( black_initial_squares[22] - 64 != v2 || black_initial_squares[23] - 48 != v4 )\n      {\n        if ( !v5 )\n          *v3 = 48;\n        goto LABEL_28;\n      }\n      *v3 = 98;\nLABEL_78:\n      ++v3;\n    }\n    while ( v4 != 8 );\nLABEL_79:\n    board = (board_t *)((char *)board + 8);\n  }\n  while ( v2 != 8 );\n}\n"}, "pseudo_normalize": "void fill_print_initial(board_t *board) {\n  int v2;\n  unsigned char *v3;\n  int v4;\n  int v5;\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  v2 = 0;\n  do {\n    ++v2;\n    v3 = (unsigned char *)board;\n    v4 = 0;\n    do {\n      while (1) {\n        ++v4;\n        v5 = 0;\n        if (white_initial_squares[0] - 64 == v2 &&\n            white_initial_squares[1] - 48 == v4) {\n          *v3 = 119;\n          v5 = 1;\n          if (white_initial_squares[2] - 64 != v2) goto LABEL_4;\n        } else if (white_initial_squares[2] - 64 != v2) {\n          goto LABEL_4;\n        }\n        if (white_initial_squares[3] - 48 != v4) {\n        LABEL_4:\n          if (white_initial_squares[4] - 64 != v2) goto LABEL_5;\n          goto LABEL_34;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if (white_initial_squares[4] - 64 != v2) goto LABEL_5;\n      LABEL_34:\n        if (white_initial_squares[5] - 48 != v4) {\n        LABEL_5:\n          if (white_initial_squares[6] - 64 != v2) goto LABEL_6;\n          goto LABEL_36;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if (white_initial_squares[6] - 64 != v2) goto LABEL_6;\n      LABEL_36:\n        if (white_initial_squares[7] - 48 != v4) {\n        LABEL_6:\n          if (white_initial_squares[8] - 64 != v2) goto LABEL_7;\n          goto LABEL_38;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if (white_initial_squares[8] - 64 != v2) goto LABEL_7;\n      LABEL_38:\n        if (white_initial_squares[9] - 48 != v4) {\n        LABEL_7:\n          if (white_initial_squares[10] - 64 != v2) goto LABEL_8;\n          goto LABEL_40;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if (white_initial_squares[10] - 64 != v2) goto LABEL_8;\n      LABEL_40:\n        if (white_initial_squares[11] - 48 != v4) {\n        LABEL_8:\n          if (white_initial_squares[12] - 64 != v2) goto LABEL_9;\n          goto LABEL_42;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if (white_initial_squares[12] - 64 != v2) goto LABEL_9;\n      LABEL_42:\n        if (white_initial_squares[13] - 48 != v4) {\n        LABEL_9:\n          if (white_initial_squares[14] - 64 != v2) goto LABEL_10;\n          goto LABEL_44;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if (white_initial_squares[14] - 64 != v2) goto LABEL_10;\n      LABEL_44:\n        if (white_initial_squares[15] - 48 != v4) {\n        LABEL_10:\n          if (white_initial_squares[16] - 64 != v2) goto LABEL_11;\n          goto LABEL_46;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if (white_initial_squares[16] - 64 != v2) goto LABEL_11;\n      LABEL_46:\n        if (white_initial_squares[17] - 48 != v4) {\n        LABEL_11:\n          if (white_initial_squares[18] - 64 != v2) goto LABEL_12;\n          goto LABEL_48;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if (white_initial_squares[18] - 64 != v2) goto LABEL_12;\n      LABEL_48:\n        if (white_initial_squares[19] - 48 != v4) {\n        LABEL_12:\n          if (white_initial_squares[20] - 64 != v2) goto LABEL_13;\n          goto LABEL_50;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if (white_initial_squares[20] - 64 != v2) goto LABEL_13;\n      LABEL_50:\n        if (white_initial_squares[21] - 48 != v4) {\n        LABEL_13:\n          if (white_initial_squares[22] - 64 != v2) goto LABEL_14;\n          goto LABEL_52;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if (white_initial_squares[22] - 64 != v2) goto LABEL_14;\n      LABEL_52:\n        if (white_initial_squares[23] - 48 != v4) {\n        LABEL_14:\n          if (black_initial_squares[0] - 64 != v2) goto LABEL_15;\n          goto LABEL_54;\n        }\n        *v3 = 119;\n        v5 = 1;\n        if (black_initial_squares[0] - 64 != v2) goto LABEL_15;\n      LABEL_54:\n        if (black_initial_squares[1] - 48 != v4) {\n        LABEL_15:\n          if (black_initial_squares[2] - 64 != v2) goto LABEL_16;\n          goto LABEL_56;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if (black_initial_squares[2] - 64 != v2) goto LABEL_16;\n      LABEL_56:\n        if (black_initial_squares[3] - 48 != v4) {\n        LABEL_16:\n          if (black_initial_squares[4] - 64 != v2) goto LABEL_17;\n          goto LABEL_58;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if (black_initial_squares[4] - 64 != v2) goto LABEL_17;\n      LABEL_58:\n        if (black_initial_squares[5] - 48 != v4) {\n        LABEL_17:\n          if (black_initial_squares[6] - 64 != v2) goto LABEL_18;\n          goto LABEL_60;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if (black_initial_squares[6] - 64 != v2) goto LABEL_18;\n      LABEL_60:\n        if (black_initial_squares[7] - 48 != v4) {\n        LABEL_18:\n          if (black_initial_squares[8] - 64 != v2) goto LABEL_19;\n          goto LABEL_62;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if (black_initial_squares[8] - 64 != v2) goto LABEL_19;\n      LABEL_62:\n        if (black_initial_squares[9] - 48 != v4) {\n        LABEL_19:\n          if (black_initial_squares[10] - 64 != v2) goto LABEL_20;\n          goto LABEL_64;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if (black_initial_squares[10] - 64 != v2) goto LABEL_20;\n      LABEL_64:\n        if (black_initial_squares[11] - 48 != v4) {\n        LABEL_20:\n          if (black_initial_squares[12] - 64 != v2) goto LABEL_21;\n          goto LABEL_66;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if (black_initial_squares[12] - 64 != v2) goto LABEL_21;\n      LABEL_66:\n        if (black_initial_squares[13] - 48 != v4) {\n        LABEL_21:\n          if (black_initial_squares[14] - 64 != v2) goto LABEL_22;\n          goto LABEL_68;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if (black_initial_squares[14] - 64 != v2) goto LABEL_22;\n      LABEL_68:\n        if (black_initial_squares[15] - 48 != v4) {\n        LABEL_22:\n          if (black_initial_squares[16] - 64 != v2) goto LABEL_23;\n          goto LABEL_70;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if (black_initial_squares[16] - 64 != v2) goto LABEL_23;\n      LABEL_70:\n        if (black_initial_squares[17] - 48 != v4) {\n        LABEL_23:\n          if (black_initial_squares[18] - 64 != v2) break;\n          goto LABEL_72;\n        }\n        *v3 = 98;\n        v5 = 1;\n        if (black_initial_squares[18] - 64 != v2) break;\n      LABEL_72:\n        if (black_initial_squares[19] - 48 != v4) break;\n        *v3 = 98;\n        v5 = 1;\n        if (black_initial_squares[20] - 64 != v2) goto LABEL_25;\n      LABEL_74:\n        if (black_initial_squares[21] - 48 != v4) goto LABEL_25;\n        *v3 = 98;\n        if (black_initial_squares[22] - 64 == v2 &&\n            black_initial_squares[23] - 48 == v4) {\n          *v3 = 98;\n          goto LABEL_78;\n        }\n      LABEL_28:\n        ++v3;\n        if (v4 == 8) goto LABEL_79;\n      }\n      if (black_initial_squares[20] - 64 == v2) goto LABEL_74;\n    LABEL_25:\n      if (black_initial_squares[22] - 64 != v2 ||\n          black_initial_squares[23] - 48 != v4) {\n        if (!v5) *v3 = 48;\n        goto LABEL_28;\n      }\n      *v3 = 98;\n    LABEL_78:\n      ++v3;\n    } while (v4 != 8);\n  LABEL_79:\n    board = (board_t *)((char *)board + 8);\n  } while (v2 != 8);\n}", "binary": "checkers/checkers.host.O3", "assembly": "<fill_print_initial>:\nendbr64\npush   %rbx\nmov    $0x8,%edx\nmov    %rdi,%rbx\nmov    $0x8,%esi\nlea    0x8765(%rip),%rdi\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\nmov    $0xc,%esi\nlea    0x8765(%rip),%rdi\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\nmov    $0xc,%esi\nlea    0x8765(%rip),%rdi\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\nmov    %rbx,%r10\nxor    %eax,%eax\nlea    0xb77e(%rip),%r9\nlea    0xb797(%rip),%r8\nadd    $0x1,%eax\nmov    %r10,%rcx\nxor    %edx,%edx\njmp    1aff <fill_print_initial+0x21f>\ncs nopw 0x0(%rax,%rax,1)\nmovsbl 0xb77b(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1b40 <fill_print_initial+0x260>\nmovsbl 0xb76b(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1b70 <fill_print_initial+0x290>\nmovsbl 0xb75b(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1ba0 <fill_print_initial+0x2c0>\nmovsbl 0xb74b(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1bd0 <fill_print_initial+0x2f0>\nmovsbl 0xb73b(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1c00 <fill_print_initial+0x320>\nmovsbl 0xb72b(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1c30 <fill_print_initial+0x350>\nmovsbl 0xb71b(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1c60 <fill_print_initial+0x380>\nmovsbl 0xb70b(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1c90 <fill_print_initial+0x3b0>\nmovsbl 0xb6fb(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1cc0 <fill_print_initial+0x3e0>\nmovsbl 0xb6eb(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1cf0 <fill_print_initial+0x410>\nmovsbl 0xb6db(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1d20 <fill_print_initial+0x440>\nmovsbl (%r9),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1d50 <fill_print_initial+0x470>\nmovsbl 0xb686(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1d80 <fill_print_initial+0x4a0>\nmovsbl 0xb676(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1db0 <fill_print_initial+0x4d0>\nmovsbl 0xb666(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1de0 <fill_print_initial+0x500>\nmovsbl 0xb656(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1e10 <fill_print_initial+0x530>\nmovsbl 0xb646(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1e40 <fill_print_initial+0x560>\nmovsbl 0xb636(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1e70 <fill_print_initial+0x590>\nmovsbl 0xb626(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1ea0 <fill_print_initial+0x5c0>\nmovsbl 0xb616(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1ed0 <fill_print_initial+0x5f0>\nmovsbl 0xb606(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1f00 <fill_print_initial+0x620>\nmovsbl 0xb5f6(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1f30 <fill_print_initial+0x650>\nmovsbl 0xb5e6(%rip),%edi\nsub    $0x40,%edi\ncmp    %eax,%edi\nje     1f90 <fill_print_initial+0x6b0>\ntest   %esi,%esi\njne    1af2 <fill_print_initial+0x212>\nmovb   $0x30,(%rcx)\nadd    $0x1,%rcx\ncmp    $0x8,%edx\nje     1f79 <fill_print_initial+0x699>\nmovsbl (%r8),%edi\nadd    $0x1,%edx\nxor    %esi,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1950 <fill_print_initial+0x70>\nmovsbl 0xb5b7(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1950 <fill_print_initial+0x70>\nmovb   $0x77,(%rcx)\nmovsbl 0xb5a3(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1962 <fill_print_initial+0x82>\nnop\nmovsbl 0xb58c(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1962 <fill_print_initial+0x82>\nmovb   $0x77,(%rcx)\nmovsbl 0xb578(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1974 <fill_print_initial+0x94>\nnopl   0x0(%rax)\nmovsbl 0xb55e(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1974 <fill_print_initial+0x94>\nmovb   $0x77,(%rcx)\nmovsbl 0xb54a(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1986 <fill_print_initial+0xa6>\nnopl   0x0(%rax)\nmovsbl 0xb530(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1986 <fill_print_initial+0xa6>\nmovb   $0x77,(%rcx)\nmovsbl 0xb51c(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1998 <fill_print_initial+0xb8>\nnopl   0x0(%rax)\nmovsbl 0xb502(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1998 <fill_print_initial+0xb8>\nmovb   $0x77,(%rcx)\nmovsbl 0xb4ee(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    19aa <fill_print_initial+0xca>\nnopl   0x0(%rax)\nmovsbl 0xb4d4(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    19aa <fill_print_initial+0xca>\nmovb   $0x77,(%rcx)\nmovsbl 0xb4c0(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    19bc <fill_print_initial+0xdc>\nnopl   0x0(%rax)\nmovsbl 0xb4a6(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    19bc <fill_print_initial+0xdc>\nmovb   $0x77,(%rcx)\nmovsbl 0xb492(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    19ce <fill_print_initial+0xee>\nnopl   0x0(%rax)\nmovsbl 0xb478(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    19ce <fill_print_initial+0xee>\nmovb   $0x77,(%rcx)\nmovsbl 0xb464(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    19e0 <fill_print_initial+0x100>\nnopl   0x0(%rax)\nmovsbl 0xb44a(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    19e0 <fill_print_initial+0x100>\nmovb   $0x77,(%rcx)\nmovsbl 0xb436(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    19f2 <fill_print_initial+0x112>\nnopl   0x0(%rax)\nmovsbl 0xb41c(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    19f2 <fill_print_initial+0x112>\nmovb   $0x77,(%rcx)\nmovsbl 0xb408(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1a04 <fill_print_initial+0x124>\nnopl   0x0(%rax)\nmovsbl 0xb3ee(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1a04 <fill_print_initial+0x124>\nmovb   $0x77,(%rcx)\nmovsbl 0xb3da(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1a16 <fill_print_initial+0x136>\nnopl   0x0(%rax)\nmovsbl 0xb3c0(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1a16 <fill_print_initial+0x136>\nmovb   $0x77,(%rcx)\nmovsbl (%r9),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1a25 <fill_print_initial+0x145>\nnopl   0x0(%rax)\nmovsbl 0xb35a(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1a25 <fill_print_initial+0x145>\nmovb   $0x62,(%rcx)\nmovsbl 0xb346(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1a37 <fill_print_initial+0x157>\nnopl   0x0(%rax)\nmovsbl 0xb32c(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1a37 <fill_print_initial+0x157>\nmovb   $0x62,(%rcx)\nmovsbl 0xb318(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1a49 <fill_print_initial+0x169>\nnopl   0x0(%rax)\nmovsbl 0xb2fe(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1a49 <fill_print_initial+0x169>\nmovb   $0x62,(%rcx)\nmovsbl 0xb2ea(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1a5b <fill_print_initial+0x17b>\nnopl   0x0(%rax)\nmovsbl 0xb2d0(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1a5b <fill_print_initial+0x17b>\nmovb   $0x62,(%rcx)\nmovsbl 0xb2bc(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1a6d <fill_print_initial+0x18d>\nnopl   0x0(%rax)\nmovsbl 0xb2a2(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1a6d <fill_print_initial+0x18d>\nmovb   $0x62,(%rcx)\nmovsbl 0xb28e(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1a7f <fill_print_initial+0x19f>\nnopl   0x0(%rax)\nmovsbl 0xb274(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1a7f <fill_print_initial+0x19f>\nmovb   $0x62,(%rcx)\nmovsbl 0xb260(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1a91 <fill_print_initial+0x1b1>\nnopl   0x0(%rax)\nmovsbl 0xb246(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1a91 <fill_print_initial+0x1b1>\nmovb   $0x62,(%rcx)\nmovsbl 0xb232(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1aa3 <fill_print_initial+0x1c3>\nnopl   0x0(%rax)\nmovsbl 0xb218(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1aa3 <fill_print_initial+0x1c3>\nmovb   $0x62,(%rcx)\nmovsbl 0xb204(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1ab5 <fill_print_initial+0x1d5>\nnopl   0x0(%rax)\nmovsbl 0xb1ea(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1ab5 <fill_print_initial+0x1d5>\nmovb   $0x62,(%rcx)\nmovsbl 0xb1d6(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1ac7 <fill_print_initial+0x1e7>\nnopl   0x0(%rax)\nmovsbl 0xb1bc(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1ac7 <fill_print_initial+0x1e7>\nmovb   $0x62,(%rcx)\nmovsbl 0xb1a8(%rip),%edi\nmov    $0x1,%esi\nsub    $0x40,%edi\ncmp    %eax,%edi\njne    1ad9 <fill_print_initial+0x1f9>\nnopl   0x0(%rax)\nmovsbl 0xb18e(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1ad9 <fill_print_initial+0x1f9>\nmovb   $0x62,(%rcx)\nmovsbl 0xb17a(%rip),%esi\nsub    $0x40,%esi\ncmp    %eax,%esi\njne    1af2 <fill_print_initial+0x212>\nmovsbl 0xb169(%rip),%esi\nsub    $0x30,%esi\ncmp    %edx,%esi\njne    1af2 <fill_print_initial+0x212>\nmovb   $0x62,(%rcx)\nadd    $0x1,%rcx\ncmp    $0x8,%edx\njne    1aff <fill_print_initial+0x21f>\nadd    $0x8,%r10\ncmp    $0x8,%eax\njne    1939 <fill_print_initial+0x59>\npop    %rbx\nret\nnopl   0x0(%rax,%rax,1)\nmovsbl 0xb130(%rip),%edi\nsub    $0x30,%edi\ncmp    %edx,%edi\njne    1aeb <fill_print_initial+0x20b>\nmovb   $0x62,(%rcx)\njmp    1f6c <fill_print_initial+0x68c>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "free_tree", "content": "// free up the space taken by the tree, and the linked lists in the nodes\n\t// done recursively\nvoid free_tree(tree_node_t* node) {\n\t// base case, node is leaf\n\tif (node->children_count == 0) {\n\t\tlibmin_free(node);\n\t}\n\t// recursive case, have to recurse down to the leaf of the node first\n\telse {\n\t\t// we need to kill each child node...that sounds horrible...\n\t\t\t// 'free' each child node...better...\n\t\tlinked_list_member_t* list_member = (node->children_list).first;\n\t\t\t// list_member is used as an iterating item\n\t\ttree_node_t* child_node;\n\t\tfor (int i=0; i<(node->children_count); i++) {\n\t\t\tchild_node = (tree_node_t*)(list_member->child_node);\n\t\t\tfree_tree(child_node);\n\t\t\t\n\t\t\t// once we free the subtree fathered by the child\n\t\t\t\t// we are free to unlink the list member too\n\t\t\tlinked_list_member_t* redundant_list_member = list_member;\n\t\t\tlist_member = list_member->next;\n\t\t\tlibmin_free(redundant_list_member);\n\t\t}\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "free_tree", "address": "0x6210", "label": "free_tree", "content": "void __fastcall free_tree(tree_node_t *node)\n{\n  int children_count; // r11d\n  linked_list_member_t *first; // rax\n  tree_node_t *v3; // rax\n  int v4; // r10d\n  linked_list_member_t *v5; // rax\n  _DWORD *v6; // rax\n  int v7; // r9d\n  _QWORD *v8; // rax\n  __int64 v9; // rax\n  int v10; // r8d\n  _QWORD *v11; // rax\n  __int64 v12; // rax\n  int v13; // edi\n  _QWORD *v14; // rax\n  __int64 v15; // rax\n  int v16; // esi\n  _QWORD *v17; // r15\n  _QWORD *v18; // r12\n  int v19; // ecx\n  bool v20; // cc\n  __int64 *v21; // r13\n  __int64 v22; // rbp\n  int v23; // edx\n  _QWORD *v24; // r12\n  int v25; // ebx\n  __int64 v26; // r14\n  int v27; // eax\n  bool v28; // cc\n  __int64 v29; // r15\n  int v30; // eax\n  __int64 v31; // rbx\n  int v32; // r14d\n  void *v33; // rdi\n  _QWORD *v34; // r14\n  int v35; // eax\n  _QWORD *v36; // rbx\n  int v37; // ecx\n  __int64 *v38; // rbx\n  _QWORD *v39; // rbx\n  _QWORD *v40; // rbx\n  _QWORD *v41; // rbx\n  linked_list_member_t *next; // rbx\n  linked_list_member_t *v43; // rbx\n  __int64 v44; // [rsp+8h] [rbp-C0h]\n  int v45; // [rsp+10h] [rbp-B8h]\n  int v46; // [rsp+14h] [rbp-B4h]\n  _QWORD *block; // [rsp+18h] [rbp-B0h]\n  _QWORD *v48; // [rsp+20h] [rbp-A8h]\n  int v49; // [rsp+28h] [rbp-A0h]\n  int v50; // [rsp+2Ch] [rbp-9Ch]\n  __int64 v51; // [rsp+30h] [rbp-98h]\n  _QWORD *v52; // [rsp+38h] [rbp-90h]\n  _QWORD *v53; // [rsp+40h] [rbp-88h]\n  __int64 v54; // [rsp+48h] [rbp-80h]\n  int v55; // [rsp+50h] [rbp-78h]\n  int v56; // [rsp+54h] [rbp-74h]\n  _QWORD *v57; // [rsp+58h] [rbp-70h]\n  _DWORD *v58; // [rsp+60h] [rbp-68h]\n  linked_list_member_t *redundant_list_member; // [rsp+68h] [rbp-60h]\n  tree_node_t *child_node; // [rsp+70h] [rbp-58h]\n  linked_list_member_t *v61; // [rsp+78h] [rbp-50h]\n  int i; // [rsp+80h] [rbp-48h]\n  int v63; // [rsp+84h] [rbp-44h]\n\n  children_count = node->children_count;\n  if ( children_count )\n  {\n    if ( children_count > 0 )\n    {\n      i = 0;\n      first = node->children_list.first;\n      redundant_list_member = first;\n      while ( 1 )\n      {\n        v3 = (tree_node_t *)first->child_node;\n        v4 = v3->children_count;\n        child_node = v3;\n        if ( v4 )\n        {\n          if ( v4 > 0 )\n          {\n            v63 = 0;\n            v5 = v3->children_list.first;\n            v61 = v5;\n            while ( 1 )\n            {\n              v6 = v5->child_node;\n              v7 = v6[19];\n              v58 = v6;\n              if ( v7 )\n              {\n                if ( v7 > 0 )\n                {\n                  v8 = (_QWORD *)*((_QWORD *)v6 + 10);\n                  v56 = 0;\n                  v57 = v8;\n                  while ( 1 )\n                  {\n                    v9 = *v8;\n                    v10 = *(_DWORD *)(v9 + 76);\n                    v54 = v9;\n                    if ( v10 )\n                    {\n                      if ( v10 > 0 )\n                      {\n                        v11 = *(_QWORD **)(v9 + 80);\n                        v55 = 0;\n                        v53 = v11;\n                        while ( 1 )\n                        {\n                          v12 = *v11;\n                          v13 = *(_DWORD *)(v12 + 76);\n                          v51 = v12;\n                          if ( v13 )\n                          {\n                            if ( v13 > 0 )\n                            {\n                              v14 = *(_QWORD **)(v12 + 80);\n                              v46 = 0;\n                              block = v14;\n                              while ( 1 )\n                              {\n                                v15 = *v14;\n                                v16 = *(_DWORD *)(v15 + 76);\n                                v44 = v15;\n                                if ( v16 )\n                                {\n                                  if ( v16 > 0 )\n                                  {\n                                    v17 = *(_QWORD **)(v15 + 80);\n                                    v45 = 0;\n                                    v18 = (_QWORD *)*v17;\n                                    v19 = *(_DWORD *)(*v17 + 76LL);\n                                    v20 = v19 <= 0;\n                                    if ( v19 )\n                                    {\nLABEL_19:\n                                      if ( v20 )\n                                        goto LABEL_32;\n                                      v49 = 0;\n                                      v21 = (__int64 *)v18[10];\n                                      v48 = v17;\n                                      v52 = v18;\n                                      while ( 1 )\n                                      {\n                                        v22 = *v21;\n                                        v23 = *(_DWORD *)(*v21 + 76);\n                                        if ( v23 )\n                                        {\n                                          if ( v23 > 0 )\n                                          {\n                                            v24 = *(_QWORD **)(v22 + 80);\n                                            v25 = 0;\n                                            v26 = *v24;\n                                            v27 = *(_DWORD *)(*v24 + 76LL);\n                                            v28 = v27 <= 0;\n                                            if ( v27 )\n                                            {\nLABEL_24:\n                                              if ( !v28 )\n                                              {\n                                                v29 = *(_QWORD *)(v26 + 80);\n                                                v30 = v25;\n                                                v31 = v26;\n                                                v32 = 0;\n                                                do\n                                                {\n                                                  v50 = v30;\n                                                  ++v32;\n                                                  free_tree(*(tree_node_t **)v29);\n                                                  v33 = (void *)v29;\n                                                  v29 = *(_QWORD *)(v29 + 8);\n                                                  libmin_free(v33);\n                                                  v30 = v50;\n                                                }\n                                                while ( v32 < *(_DWORD *)(v31 + 76) );\n                                                v25 = v50;\n                                              }\n                                              goto LABEL_28;\n                                            }\n                                            while ( 1 )\n                                            {\n                                              libmin_free((void *)v26);\nLABEL_28:\n                                              v34 = (_QWORD *)v24[1];\n                                              ++v25;\n                                              libmin_free(v24);\n                                              if ( v25 >= *(_DWORD *)(v22 + 76) )\n                                                break;\n                                              v24 = v34;\n                                              v26 = *v34;\n                                              v35 = *(_DWORD *)(v26 + 76);\n                                              v28 = v35 <= 0;\n                                              if ( v35 )\n                                                goto LABEL_24;\n                                            }\n                                          }\n                                        }\n                                        else\n                                        {\n                                          libmin_free((void *)*v21);\n                                        }\n                                        v38 = (__int64 *)v21[1];\n                                        libmin_free(v21);\n                                        if ( ++v49 >= *((_DWORD *)v52 + 19) )\n                                        {\n                                          v17 = v48;\n                                          goto LABEL_32;\n                                        }\n                                        v21 = v38;\n                                      }\n                                    }\n                                    while ( 1 )\n                                    {\n                                      libmin_free(v18);\nLABEL_32:\n                                      v36 = (_QWORD *)v17[1];\n                                      libmin_free(v17);\n                                      if ( ++v45 >= *(_DWORD *)(v44 + 76) )\n                                        break;\n                                      v17 = v36;\n                                      v18 = (_QWORD *)*v36;\n                                      v37 = *(_DWORD *)(*v36 + 76LL);\n                                      v20 = v37 <= 0;\n                                      if ( v37 )\n                                        goto LABEL_19;\n                                    }\n                                  }\n                                }\n                                else\n                                {\n                                  libmin_free((void *)v15);\n                                }\n                                v39 = (_QWORD *)block[1];\n                                libmin_free(block);\n                                if ( ++v46 >= *(_DWORD *)(v51 + 76) )\n                                  break;\n                                block = v39;\n                                v14 = v39;\n                              }\n                            }\n                          }\n                          else\n                          {\n                            libmin_free((void *)v12);\n                          }\n                          v40 = (_QWORD *)v53[1];\n                          libmin_free(v53);\n                          if ( ++v55 >= *(_DWORD *)(v54 + 76) )\n                            break;\n                          v53 = v40;\n                          v11 = v40;\n                        }\n                      }\n                    }\n                    else\n                    {\n                      libmin_free((void *)v9);\n                    }\n                    v41 = (_QWORD *)v57[1];\n                    libmin_free(v57);\n                    if ( ++v56 >= v58[19] )\n                      break;\n                    v57 = v41;\n                    v8 = v41;\n                  }\n                }\n              }\n              else\n              {\n                libmin_free(v6);\n              }\n              next = v61->next;\n              libmin_free(v61);\n              if ( ++v63 >= child_node->children_count )\n                break;\n              v61 = next;\n              v5 = next;\n            }\n          }\n        }\n        else\n        {\n          libmin_free(v3);\n        }\n        v43 = redundant_list_member->next;\n        libmin_free(redundant_list_member);\n        if ( node->children_count <= ++i )\n          break;\n        redundant_list_member = v43;\n        first = v43;\n      }\n    }\n  }\n  else\n  {\n    libmin_free(node);\n  }\n}\n"}, "pseudo_normalize": "void free_tree(tree_node_t *node) {\n  int children_count;\n  linked_list_member_t *first;\n  tree_node_t *v3;\n  int v4;\n  linked_list_member_t *v5;\n  uint32_t *v6;\n  int v7;\n  uint64_t *v8;\n  long long v9;\n  int v10;\n  uint64_t *v11;\n  long long v12;\n  int v13;\n  uint64_t *v14;\n  long long v15;\n  int v16;\n  uint64_t *v17;\n  uint64_t *v18;\n  int v19;\n  bool v20;\n  long long *v21;\n  long long v22;\n  int v23;\n  uint64_t *v24;\n  int v25;\n  long long v26;\n  int v27;\n  bool v28;\n  long long v29;\n  int v30;\n  long long v31;\n  int v32;\n  void *v33;\n  uint64_t *v34;\n  int v35;\n  uint64_t *v36;\n  int v37;\n  long long *v38;\n  uint64_t *v39;\n  uint64_t *v40;\n  uint64_t *v41;\n  linked_list_member_t *next;\n  linked_list_member_t *v43;\n  long long v44;\n  int v45;\n  int v46;\n  uint64_t *block;\n  uint64_t *v48;\n  int v49;\n  int v50;\n  long long v51;\n  uint64_t *v52;\n  uint64_t *v53;\n  long long v54;\n  int v55;\n  int v56;\n  uint64_t *v57;\n  uint32_t *v58;\n  linked_list_member_t *redundant_list_member;\n  tree_node_t *child_node;\n  linked_list_member_t *v61;\n  int i;\n  int v63;\n  children_count = node->children_count;\n  if (children_count) {\n    if (children_count > 0) {\n      i = 0;\n      first = node->children_list.first;\n      redundant_list_member = first;\n      while (1) {\n        v3 = (tree_node_t *)first->child_node;\n        v4 = v3->children_count;\n        child_node = v3;\n        if (v4) {\n          if (v4 > 0) {\n            v63 = 0;\n            v5 = v3->children_list.first;\n            v61 = v5;\n            while (1) {\n              v6 = v5->child_node;\n              v7 = v6[19];\n              v58 = v6;\n              if (v7) {\n                if (v7 > 0) {\n                  v8 = (uint64_t *)*((uint64_t *)v6 + 10);\n                  v56 = 0;\n                  v57 = v8;\n                  while (1) {\n                    v9 = *v8;\n                    v10 = *(uint32_t *)(v9 + 76);\n                    v54 = v9;\n                    if (v10) {\n                      if (v10 > 0) {\n                        v11 = *(uint64_t **)(v9 + 80);\n                        v55 = 0;\n                        v53 = v11;\n                        while (1) {\n                          v12 = *v11;\n                          v13 = *(uint32_t *)(v12 + 76);\n                          v51 = v12;\n                          if (v13) {\n                            if (v13 > 0) {\n                              v14 = *(uint64_t **)(v12 + 80);\n                              v46 = 0;\n                              block = v14;\n                              while (1) {\n                                v15 = *v14;\n                                v16 = *(uint32_t *)(v15 + 76);\n                                v44 = v15;\n                                if (v16) {\n                                  if (v16 > 0) {\n                                    v17 = *(uint64_t **)(v15 + 80);\n                                    v45 = 0;\n                                    v18 = (uint64_t *)*v17;\n                                    v19 = *(uint32_t *)(*v17 + 76LL);\n                                    v20 = v19 <= 0;\n                                    if (v19) {\n                                    LABEL_19:\n                                      if (v20) goto LABEL_32;\n                                      v49 = 0;\n                                      v21 = (long long *)v18[10];\n                                      v48 = v17;\n                                      v52 = v18;\n                                      while (1) {\n                                        v22 = *v21;\n                                        v23 = *(uint32_t *)(*v21 + 76);\n                                        if (v23) {\n                                          if (v23 > 0) {\n                                            v24 = *(uint64_t **)(v22 + 80);\n                                            v25 = 0;\n                                            v26 = *v24;\n                                            v27 = *(uint32_t *)(*v24 + 76LL);\n                                            v28 = v27 <= 0;\n                                            if (v27) {\n                                            LABEL_24:\n                                              if (!v28) {\n                                                v29 = *(uint64_t *)(v26 + 80);\n                                                v30 = v25;\n                                                v31 = v26;\n                                                v32 = 0;\n                                                do {\n                                                  v50 = v30;\n                                                  ++v32;\n                                                  free_tree(\n                                                      *(tree_node_t **)v29);\n                                                  v33 = (void *)v29;\n                                                  v29 = *(uint64_t *)(v29 + 8);\n                                                  libmin_free(v33);\n                                                  v30 = v50;\n                                                } while (\n                                                    v32 <\n                                                    *(uint32_t *)(v31 + 76));\n                                                v25 = v50;\n                                              }\n                                              goto LABEL_28;\n                                            }\n                                            while (1) {\n                                              libmin_free((void *)v26);\n                                            LABEL_28:\n                                              v34 = (uint64_t *)v24[1];\n                                              ++v25;\n                                              libmin_free(v24);\n                                              if (v25 >=\n                                                  *(uint32_t *)(v22 + 76))\n                                                break;\n                                              v24 = v34;\n                                              v26 = *v34;\n                                              v35 = *(uint32_t *)(v26 + 76);\n                                              v28 = v35 <= 0;\n                                              if (v35) goto LABEL_24;\n                                            }\n                                          }\n                                        } else {\n                                          libmin_free((void *)*v21);\n                                        }\n                                        v38 = (long long *)v21[1];\n                                        libmin_free(v21);\n                                        if (++v49 >= *((uint32_t *)v52 + 19)) {\n                                          v17 = v48;\n                                          goto LABEL_32;\n                                        }\n                                        v21 = v38;\n                                      }\n                                    }\n                                    while (1) {\n                                      libmin_free(v18);\n                                    LABEL_32:\n                                      v36 = (uint64_t *)v17[1];\n                                      libmin_free(v17);\n                                      if (++v45 >= *(uint32_t *)(v44 + 76))\n                                        break;\n                                      v17 = v36;\n                                      v18 = (uint64_t *)*v36;\n                                      v37 = *(uint32_t *)(*v36 + 76LL);\n                                      v20 = v37 <= 0;\n                                      if (v37) goto LABEL_19;\n                                    }\n                                  }\n                                } else {\n                                  libmin_free((void *)v15);\n                                }\n                                v39 = (uint64_t *)block[1];\n                                libmin_free(block);\n                                if (++v46 >= *(uint32_t *)(v51 + 76)) break;\n                                block = v39;\n                                v14 = v39;\n                              }\n                            }\n                          } else {\n                            libmin_free((void *)v12);\n                          }\n                          v40 = (uint64_t *)v53[1];\n                          libmin_free(v53);\n                          if (++v55 >= *(uint32_t *)(v54 + 76)) break;\n                          v53 = v40;\n                          v11 = v40;\n                        }\n                      }\n                    } else {\n                      libmin_free((void *)v9);\n                    }\n                    v41 = (uint64_t *)v57[1];\n                    libmin_free(v57);\n                    if (++v56 >= v58[19]) break;\n                    v57 = v41;\n                    v8 = v41;\n                  }\n                }\n              } else {\n                libmin_free(v6);\n              }\n              next = v61->next;\n              libmin_free(v61);\n              if (++v63 >= child_node->children_count) break;\n              v61 = next;\n              v5 = next;\n            }\n          }\n        } else {\n          libmin_free(v3);\n        }\n        v43 = redundant_list_member->next;\n        libmin_free(redundant_list_member);\n        if (node->children_count <= ++i) break;\n        redundant_list_member = v43;\n        first = v43;\n      }\n    }\n  } else {\n    libmin_free(node);\n  }\n}", "binary": "checkers/checkers.host.O3", "assembly": "<free_tree>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x98,%rsp\nmov    0x4c(%rdi),%r11d\nmov    %rdi,0x88(%rsp)\ntest   %r11d,%r11d\nje     658e <free_tree+0x37e>\njle    657c <free_tree+0x36c>\nmovl   $0x0,0x80(%rsp)\nmov    0x50(%rdi),%rax\nmov    %rax,0x68(%rsp)\nmov    (%rax),%rax\nmov    0x4c(%rax),%r10d\nmov    %rax,0x70(%rsp)\ntest   %r10d,%r10d\nje     653d <free_tree+0x32d>\njle    6545 <free_tree+0x335>\nmovl   $0x0,0x84(%rsp)\nmov    0x50(%rax),%rax\nmov    %rax,0x78(%rsp)\nmov    (%rax),%rax\nmov    0x4c(%rax),%r9d\nmov    %rax,0x60(%rsp)\ntest   %r9d,%r9d\nje     6501 <free_tree+0x2f1>\njle    6509 <free_tree+0x2f9>\nmov    0x50(%rax),%rax\nmovl   $0x0,0x54(%rsp)\nmov    %rax,0x58(%rsp)\nmov    (%rax),%rax\nmov    0x4c(%rax),%r8d\nmov    %rax,0x48(%rsp)\ntest   %r8d,%r8d\nje     64cb <free_tree+0x2bb>\njle    64d3 <free_tree+0x2c3>\nmov    0x50(%rax),%rax\nmovl   $0x0,0x50(%rsp)\nmov    %rax,0x40(%rsp)\nmov    (%rax),%rax\nmov    0x4c(%rax),%edi\nmov    %rax,0x30(%rsp)\ntest   %edi,%edi\nje     6495 <free_tree+0x285>\njle    649d <free_tree+0x28d>\nmov    0x50(%rax),%rax\nmovl   $0x0,0x14(%rsp)\nmov    %rax,0x18(%rsp)\nmov    (%rax),%rax\nmov    0x4c(%rax),%esi\nmov    %rax,0x8(%rsp)\ntest   %esi,%esi\nje     645f <free_tree+0x24f>\njle    6467 <free_tree+0x257>\nmov    0x50(%rax),%r15\nmovl   $0x0,0x10(%rsp)\nmov    (%r15),%r12\nmov    0x4c(%r12),%ecx\ntest   %ecx,%ecx\nje     641f <free_tree+0x20f>\njle    63ed <free_tree+0x1dd>\nmovl   $0x0,0x28(%rsp)\nmov    0x50(%r12),%r13\nmov    %r15,0x20(%rsp)\nmov    %r12,0x38(%rsp)\nmov    0x0(%r13),%rbp\nmov    0x4c(%rbp),%edx\ntest   %edx,%edx\nje     6430 <free_tree+0x220>\njle    6438 <free_tree+0x228>\nmov    0x50(%rbp),%r12\nxor    %ebx,%ebx\nmov    (%r12),%r14\nmov    0x4c(%r14),%eax\ntest   %eax,%eax\nje     63da <free_tree+0x1ca>\njle    63b6 <free_tree+0x1a6>\nxor    %ecx,%ecx\nmov    0x50(%r14),%r15\nmov    %ebx,%eax\nmov    %r14,%rbx\nmov    %ecx,%r14d\nmov    (%r15),%rdi\nmov    %eax,0x2c(%rsp)\nadd    $0x1,%r14d\ncall   6210 <free_tree>\nmov    %r15,%rdi\nmov    0x8(%r15),%r15\ncall   6870 <libmin_free>\ncmp    0x4c(%rbx),%r14d\nmov    0x2c(%rsp),%eax\njl     638e <free_tree+0x17e>\nmov    %eax,%ebx\nmov    %r12,%rdi\nmov    0x8(%r12),%r14\nadd    $0x1,%ebx\ncall   6870 <libmin_free>\ncmp    0x4c(%rbp),%ebx\njge    6438 <free_tree+0x228>\nmov    %r14,%r12\nmov    (%r12),%r14\nmov    0x4c(%r14),%eax\ntest   %eax,%eax\njne    637e <free_tree+0x16e>\nmov    %r14,%rdi\ncall   6870 <libmin_free>\njmp    63b6 <free_tree+0x1a6>\nnopl   0x0(%rax)\nmov    0x20(%rsp),%r15\nmov    %r15,%rdi\nmov    0x8(%r15),%rbx\ncall   6870 <libmin_free>\nmov    0x8(%rsp),%rdx\naddl   $0x1,0x10(%rsp)\nmov    0x10(%rsp),%eax\ncmp    0x4c(%rdx),%eax\njge    6467 <free_tree+0x257>\nmov    %rbx,%r15\nmov    (%r15),%r12\nmov    0x4c(%r12),%ecx\ntest   %ecx,%ecx\njne    633a <free_tree+0x12a>\nmov    %r12,%rdi\ncall   6870 <libmin_free>\njmp    63ed <free_tree+0x1dd>\nnopl   0x0(%rax)\nmov    %rbp,%rdi\ncall   6870 <libmin_free>\nmov    %r13,%rdi\nmov    0x8(%r13),%rbx\ncall   6870 <libmin_free>\nmov    0x38(%rsp),%rsi\naddl   $0x1,0x28(%rsp)\nmov    0x28(%rsp),%eax\ncmp    0x4c(%rsi),%eax\njge    63e8 <free_tree+0x1d8>\nmov    %rbx,%r13\njmp    6357 <free_tree+0x147>\nmov    %rax,%rdi\ncall   6870 <libmin_free>\nmov    0x18(%rsp),%rdi\nmov    0x8(%rdi),%rbx\ncall   6870 <libmin_free>\nmov    0x30(%rsp),%rsi\naddl   $0x1,0x14(%rsp)\nmov    0x14(%rsp),%eax\ncmp    0x4c(%rsi),%eax\njge    649d <free_tree+0x28d>\nmov    %rbx,0x18(%rsp)\nmov    %rbx,%rax\njmp    6305 <free_tree+0xf5>\nmov    %rax,%rdi\ncall   6870 <libmin_free>\nmov    0x40(%rsp),%rdi\nmov    0x8(%rdi),%rbx\ncall   6870 <libmin_free>\nmov    0x48(%rsp),%rsi\naddl   $0x1,0x50(%rsp)\nmov    0x50(%rsp),%eax\ncmp    0x4c(%rsi),%eax\njge    64d3 <free_tree+0x2c3>\nmov    %rbx,0x40(%rsp)\nmov    %rbx,%rax\njmp    62db <free_tree+0xcb>\nmov    %rax,%rdi\ncall   6870 <libmin_free>\nmov    0x58(%rsp),%rdi\nmov    0x8(%rdi),%rbx\ncall   6870 <libmin_free>\nmov    0x60(%rsp),%rcx\naddl   $0x1,0x54(%rsp)\nmov    0x54(%rsp),%eax\ncmp    0x4c(%rcx),%eax\njge    6509 <free_tree+0x2f9>\nmov    %rbx,0x58(%rsp)\nmov    %rbx,%rax\njmp    62af <free_tree+0x9f>\nmov    %rax,%rdi\ncall   6870 <libmin_free>\nmov    0x78(%rsp),%rdi\nmov    0x8(%rdi),%rbx\ncall   6870 <libmin_free>\nmov    0x70(%rsp),%rsi\naddl   $0x1,0x84(%rsp)\nmov    0x84(%rsp),%eax\ncmp    0x4c(%rsi),%eax\njge    6545 <free_tree+0x335>\nmov    %rbx,0x78(%rsp)\nmov    %rbx,%rax\njmp    6283 <free_tree+0x73>\nmov    %rax,%rdi\ncall   6870 <libmin_free>\nmov    0x68(%rsp),%rdi\nmov    0x8(%rdi),%rbx\ncall   6870 <libmin_free>\nmov    0x88(%rsp),%rsi\naddl   $0x1,0x80(%rsp)\nmov    0x80(%rsp),%eax\ncmp    %eax,0x4c(%rsi)\njle    657c <free_tree+0x36c>\nmov    %rbx,0x68(%rsp)\nmov    %rbx,%rax\njmp    6254 <free_tree+0x44>\nadd    $0x98,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nadd    $0x98,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    6870 <libmin_free>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "checkers/functions.c", "function_name": "generate_node_children", "content": "// find and link node children for a given tree/subtree root \nvoid generate_node_children(tree_node_t* node, int depth) {\n\t// iterate through board to find checkers belonging to the player \n\t\t// note: done in row-major order\n\tint generated_children = 0;\n\tfor (int j=0; j<BOARD_SIZE;j++) {\n\t\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\t\tchar checker = (node->board_state)[i][j];\n\t\t\tif (movable_checker(node->black_action, checker)) {\n\t\t\t\t// if a checker belonging to the colour with action is found\n\t\t\t\t\t// generate all valid moves and create a tree node for each\n\t\t\t\tstatic valid_moves_t valid_moves; \n\t\t\t\tchar col = col_to_char(i+1);\n\t\t\t\tchar row = row_to_char(j+1);\n\t\t\t\tint num_possibles = all_possible_moves((node->board_state), \n\t\t\t\t\tcol, row, valid_moves, (node->black_action));\n\t\t\t\tfor (int k=0; k<num_possibles; k++) {\n\t\t\t\t\t// define the source cell and target cell\n\t\t\t\t\tchar col1 = col;\n\t\t\t\t\tchar row1 = row;\n\t\t\t\t\tchar col2 = valid_moves[k][0];\n\t\t\t\t\tchar row2 = valid_moves[k][1];\n\t\t\t\t\t\n\t\t\t\t\tlink_new_node(node, col1, row1, col2, row2, depth);\n\t\t\t\t\tgenerated_children += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnode->children_count = generated_children;\n\t\t// update children count; useful for accessing tree later\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "generate_node_children", "address": "0x35d0", "label": "generate_node_children", "content": "void __fastcall generate_node_children(tree_node_t *node, int depth)\n{\n  char v3; // r13\n  tree_node_t *v4; // rbx\n  __int64 v5; // r12\n  int black_action; // r8d\n  char v7; // al\n  char v8; // bp\n  int v9; // eax\n  char *v10; // r14\n  int v11; // r12d\n  tree_node_t *v12; // r15\n  char *v13; // rbx\n  char v14; // cl\n  char v15; // r8\n  tree_node_t *v16; // [rsp+0h] [rbp-58h]\n  __int64 v17; // [rsp+8h] [rbp-50h]\n  unsigned __int8 *board_input; // [rsp+10h] [rbp-48h]\n  int num_possibles; // [rsp+18h] [rbp-40h]\n  int generated_children; // [rsp+1Ch] [rbp-3Ch]\n\n  v3 = 49;\n  v4 = node;\n  v16 = node;\n  board_input = node->board_state[0];\n  generated_children = 0;\n  do\n  {\n    v5 = 1LL;\n    do\n    {\n      while ( 1 )\n      {\n        black_action = v4->black_action;\n        v7 = *(_BYTE *)(&v16->depth + 2 * v5) & 0xDF;\n        if ( !black_action )\n          break;\n        if ( v7 == 66 )\n          goto LABEL_7;\nLABEL_4:\n        if ( ++v5 == 9 )\n          goto LABEL_11;\n      }\n      if ( v7 != 87 )\n        goto LABEL_4;\nLABEL_7:\n      v8 = v5 + 64;\n      v9 = all_possible_moves(\n             (unsigned __int8 (*)[8])board_input,\n             v5 + 64,\n             v3,\n             (square_t *)valid_moves_0_0,\n             black_action);\n      num_possibles = v9;\n      if ( v9 <= 0 )\n        goto LABEL_4;\n      v10 = valid_moves_0_0;\n      v17 = v5;\n      v11 = depth;\n      v12 = v4;\n      v13 = &valid_moves_0_0[2 * (v9 - 1) + 2];\n      do\n      {\n        v14 = *v10;\n        v15 = v10[1];\n        v10 += 2;\n        link_new_node(v12, v8, v3, v14, v15, v11);\n      }\n      while ( v10 != v13 );\n      v4 = v12;\n      depth = v11;\n      generated_children += num_possibles;\n      v5 = v17 + 1;\n    }\n    while ( v17 != 8 );\nLABEL_11:\n    v16 = (tree_node_t *)((char *)v16 + 1);\n    ++v3;\n  }\n  while ( v16 != (tree_node_t *)board_input );\n  v4->children_count = generated_children;\n}\n"}, "pseudo_normalize": "void generate_node_children(tree_node_t *node, int depth) {\n  char v3;\n  tree_node_t *v4;\n  long long v5;\n  int black_action;\n  char v7;\n  char v8;\n  int v9;\n  char *v10;\n  int v11;\n  tree_node_t *v12;\n  char *v13;\n  char v14;\n  char v15;\n  tree_node_t *v16;\n  long long v17;\n  unsigned char *board_input;\n  int num_possibles;\n  int generated_children;\n  v3 = 49;\n  v4 = node;\n  v16 = node;\n  board_input = node->board_state[0];\n  generated_children = 0;\n  do {\n    v5 = 1LL;\n    do {\n      while (1) {\n        black_action = v4->black_action;\n        v7 = *(uint8_t *)(&v16->depth + 2 * v5) & 223;\n        if (!black_action) break;\n        if (v7 == 66) goto LABEL_7;\n      LABEL_4:\n        if (++v5 == 9) goto LABEL_11;\n      }\n      if (v7 != 87) goto LABEL_4;\n    LABEL_7:\n      v8 = v5 + 64;\n      v9 = all_possible_moves((unsigned char(*)[8])board_input, v5 + 64, v3,\n                              (square_t *)valid_moves_0_0, black_action);\n      num_possibles = v9;\n      if (v9 <= 0) goto LABEL_4;\n      v10 = valid_moves_0_0;\n      v17 = v5;\n      v11 = depth;\n      v12 = v4;\n      v13 = &valid_moves_0_0[2 * (v9 - 1) + 2];\n      do {\n        v14 = *v10;\n        v15 = v10[1];\n        v10 += 2;\n        link_new_node(v12, v8, v3, v14, v15, v11);\n      } while (v10 != v13);\n      v4 = v12;\n      depth = v11;\n      generated_children += num_possibles;\n      v5 = v17 + 1;\n    } while (v17 != 8);\n  LABEL_11:\n    v16 = (tree_node_t *)((char *)v16 + 1);\n    ++v3;\n  } while (v16 != (tree_node_t *)board_input);\n  v4->children_count = generated_children;\n}", "binary": "checkers/checkers.host.O3", "assembly": "<generate_node_children>:\nendbr64\npush   %r15\nlea    0x8(%rdi),%rax\nmov    %esi,%r15d\npush   %r14\npush   %r13\nmov    $0x31,%r13d\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x28,%rsp\nmov    %rdi,(%rsp)\nmov    %rax,0x10(%rsp)\nmovl   $0x0,0x1c(%rsp)\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%r12d\njmp    3622 <generate_node_children+0x52>\ncmp    $0x42,%al\nje     363f <generate_node_children+0x6f>\nadd    $0x1,%r12\ncmp    $0x9,%r12\nje     36c5 <generate_node_children+0xf5>\nmov    (%rsp),%rax\nmov    0x48(%rbx),%r8d\nmovzbl (%rax,%r12,8),%eax\nmov    %al,0x18(%rsp)\nand    $0xffffffdf,%eax\ntest   %r8d,%r8d\njne    3610 <generate_node_children+0x40>\ncmp    $0x57,%al\njne    3614 <generate_node_children+0x44>\nmov    0x10(%rsp),%rdi\nlea    0x40(%r12),%ebp\nlea    0x9d20(%rip),%rcx\nmov    %r13d,%edx\nmov    %ebp,%esi\ncall   22b0 <all_possible_moves>\nmov    %eax,0x18(%rsp)\ntest   %eax,%eax\njle    3614 <generate_node_children+0x44>\nlea    0x9d07(%rip),%r14\nlea    -0x1(%rax),%edx\nmov    %r12,0x8(%rsp)\nmov    %r15d,%r12d\nlea    0x2(%r14),%rax\nmov    %rbx,%r15\nlea    (%rax,%rdx,2),%rax\nmov    %rax,%rbx\nmovsbl (%r14),%ecx\nmovsbl 0x1(%r14),%r8d\nmov    %r12d,%r9d\nmov    %r13d,%edx\nmov    %ebp,%esi\nmov    %r15,%rdi\nadd    $0x2,%r14\ncall   34c0 <link_new_node>\ncmp    %rbx,%r14\njne    3682 <generate_node_children+0xb2>\nmov    %r15,%rbx\nmov    %r12d,%r15d\nmov    0x8(%rsp),%r12\nmov    0x18(%rsp),%esi\nadd    %esi,0x1c(%rsp)\nadd    $0x1,%r12\ncmp    $0x9,%r12\njne    3622 <generate_node_children+0x52>\naddq   $0x1,(%rsp)\nadd    $0x1,%r13d\nmov    (%rsp),%rax\ncmp    0x10(%rsp),%rax\njne    3608 <generate_node_children+0x38>\nmov    0x1c(%rsp),%eax\nmov    %eax,0x4c(%rbx)\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "checkers/functions.c", "function_name": "generate_tree_depth_3", "content": "// generate a tree of depth 3 containing the tree_node's \nvoid generate_tree_depth_3(tree_node_t* level_0_node) {\n\t// generate the first generation children\n\tgenerate_node_children(level_0_node, 1);\n\t\n\t// generate second generation children for each first generation child\n\tlinked_list_member_t* list_member_1 = (level_0_node->children_list).first;\n\ttree_node_t* level_1_node;\n\tfor (int i=0; i<(level_0_node->children_count); i++) {\n\t\tlevel_1_node = (tree_node_t*)(list_member_1->child_node);\n\t\tgenerate_node_children(level_1_node, 2);\n\t\t\n\t\t// generate third generation children for each second generation child\n\t\tlinked_list_member_t* list_member_2 \n\t\t\t= (level_1_node->children_list).first;\n\t\ttree_node_t* level_2_node;\n\t\tfor (int j=0; j<(level_1_node->children_count); j++) {\n\t\t\tlevel_2_node = (tree_node_t*)(list_member_2->child_node);\n\t\t\tgenerate_node_children(level_2_node, 3);\n\t\t\tlist_member_2 = list_member_2->next;\n\t\t}\n\t\t\n\t\tlist_member_1 = list_member_1->next;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "generate_tree_depth_3", "address": "0x3700", "label": "generate_tree_depth_3", "content": "void __fastcall generate_tree_depth_3(tree_node_t *level_0_node)\n{\n  unsigned __int8 *v1; // r14\n  int v2; // r15d\n  int v3; // r15d\n  int black_action; // r8d\n  char v5; // al\n  int v6; // eax\n  int v7; // r9d\n  char *v8; // r13\n  char *v9; // r14\n  unsigned __int16 v10; // ax\n  int v11; // ebp\n  char *v12; // rax\n  __m128i *v13; // rbx\n  __m128i v14; // xmm1\n  __m128i v15; // xmm0\n  __m128i v16; // xmm5\n  int v17; // esi\n  __m128i v18; // xmm6\n  linked_list_member_t *v19; // rax\n  bool v20; // zf\n  linked_list_member_t *last; // rdx\n  unsigned __int8 *v22; // r14\n  int v23; // ebp\n  char *child_node; // r12\n  int v25; // r14d\n  _BYTE *v26; // r10\n  int v27; // r13d\n  int v28; // r8d\n  char v29; // al\n  int v30; // eax\n  int v31; // r9d\n  char *v32; // rbp\n  char *v33; // r11\n  unsigned __int16 v34; // ax\n  int v35; // r15d\n  char *v36; // rax\n  __m128i *v37; // rbx\n  __m128i v38; // xmm1\n  __m128i v39; // xmm0\n  __m128i v40; // xmm7\n  int v41; // ecx\n  __m128i v42; // xmm5\n  _QWORD *v43; // rax\n  __int64 v44; // rdx\n  int v45; // r13d\n  char *v46; // r12\n  int v47; // ebp\n  int v48; // r8d\n  char v49; // al\n  int v50; // eax\n  char *v51; // r15\n  unsigned __int16 v52; // ax\n  int v53; // r14d\n  char *v54; // rax\n  __m128i *v55; // rbx\n  __m128i v56; // xmm1\n  __m128i v57; // xmm0\n  __m128i v58; // xmm3\n  int v59; // edx\n  __m128i v60; // xmm4\n  _QWORD *v61; // rax\n  __int64 v62; // rdx\n  int row; // [rsp+8h] [rbp-B0h]\n  char rowa[8]; // [rsp+8h] [rbp-B0h]\n  unsigned __int8 rowb; // [rsp+8h] [rbp-B0h]\n  int v66; // [rsp+14h] [rbp-A4h]\n  int v67; // [rsp+14h] [rbp-A4h]\n  char v68; // [rsp+14h] [rbp-A4h]\n  unsigned __int8 *v69; // [rsp+18h] [rbp-A0h]\n  _BYTE *v70; // [rsp+18h] [rbp-A0h]\n  unsigned __int8 *v71; // [rsp+20h] [rbp-98h]\n  unsigned __int8 *v72; // [rsp+20h] [rbp-98h]\n  char v73; // [rsp+28h] [rbp-90h]\n  char *v74; // [rsp+28h] [rbp-90h]\n  unsigned __int8 board_input; // [rsp+30h] [rbp-88h]\n  linked_list_member_t *list_member_1; // [rsp+38h] [rbp-80h]\n  linked_list_member_t *list_member_1a; // [rsp+38h] [rbp-80h]\n  char v78; // [rsp+40h] [rbp-78h]\n  char v79; // [rsp+40h] [rbp-78h]\n  int v80; // [rsp+40h] [rbp-78h]\n  unsigned __int8 ia; // [rsp+44h] [rbp-74h]\n  int i; // [rsp+44h] [rbp-74h]\n  char list_member_2b; // [rsp+48h] [rbp-70h]\n  int list_member_2; // [rsp+48h] [rbp-70h]\n  linked_list_member_t *list_member_2a; // [rsp+48h] [rbp-70h]\n  int j; // [rsp+50h] [rbp-68h]\n  _BYTE *ja; // [rsp+50h] [rbp-68h]\n  int jb; // [rsp+50h] [rbp-68h]\n  char *v89; // [rsp+58h] [rbp-60h]\n  int v90; // [rsp+58h] [rbp-60h]\n  unsigned __int8 *v91; // [rsp+60h] [rbp-58h]\n  tree_node_t *level_1_node; // [rsp+68h] [rbp-50h]\n  unsigned __int8 *v93; // [rsp+70h] [rbp-48h]\n\n  v1 = level_0_node->board_state[0];\n  v2 = 49;\n  v66 = 0;\n  do\n  {\n    v78 = v2;\n    row = v2;\n    v3 = 65;\n    list_member_1 = (linked_list_member_t *)v1;\n    do\n    {\n      while ( 1 )\n      {\n        black_action = level_0_node->black_action;\n        v5 = *v1 & 0xDF;\n        if ( !black_action )\n          break;\n        if ( v5 == 66 )\n          goto LABEL_7;\nLABEL_4:\n        ++v3;\n        v1 += 8;\n        if ( v3 == 73 )\n          goto LABEL_14;\n      }\n      if ( v5 != 87 )\n        goto LABEL_4;\nLABEL_7:\n      v6 = all_possible_moves(level_0_node->board_state, v3, row, (square_t *)valid_moves_0_0, black_action);\n      v7 = v6;\n      if ( v6 <= 0 )\n        goto LABEL_4;\n      v8 = valid_moves_0_0;\n      v69 = v1;\n      v9 = &valid_moves_0_0[2 * (v6 - 1) + 2];\n      do\n      {\n        while ( 1 )\n        {\n          LOBYTE(v10) = v3;\n          j = v7;\n          list_member_2b = *v8;\n          HIBYTE(v10) = v78;\n          ia = v8[1];\n          v11 = (ia << 24) | ((unsigned __int8)*v8 << 16) | v10;\n          v12 = (char *)libmin_malloc(0x60uLL);\n          *(_DWORD *)v12 = 1;\n          v13 = (__m128i *)v12;\n          v14 = _mm_loadu_si128((const __m128i *)level_0_node->board_state[4]);\n          v15 = _mm_loadu_si128((const __m128i *)level_0_node->board_state[6]);\n          v16 = _mm_loadu_si128((const __m128i *)level_0_node->board_state);\n          *(__m128i *)(v12 + 24) = _mm_loadu_si128((const __m128i *)level_0_node->board_state[2]);\n          *(__m128i *)(v12 + 40) = v14;\n          *(__m128i *)(v12 + 8) = v16;\n          *(__m128i *)(v12 + 56) = v15;\n          change_board((board_t *)(v12 + 8), v3, row, list_member_2b, ia);\n          v13->m128i_i32[1] = v11;\n          v17 = level_0_node->black_action;\n          v18 = _mm_loadu_si128((const __m128i *)&initial_children);\n          v13[4].m128i_i32[3] = 0;\n          v13[5] = v18;\n          v13[4].m128i_i32[2] = v17 == 0;\n          v19 = (linked_list_member_t *)libmin_malloc(0x10uLL);\n          v20 = level_0_node->children_list.first == 0LL;\n          v7 = j;\n          v19->child_node = v13;\n          v19->next = 0LL;\n          if ( v20 )\n            break;\n          last = level_0_node->children_list.last;\n          if ( !last )\n            goto LABEL_49;\nLABEL_11:\n          v8 += 2;\n          last->next = v19;\n          level_0_node->children_list.last = v19;\n          if ( v8 == v9 )\n          {\n            v66 += j;\n            v22 = v69;\n            goto LABEL_13;\n          }\n        }\n        last = level_0_node->children_list.last;\n        level_0_node->children_list.first = v19;\n        if ( last )\n          goto LABEL_11;\nLABEL_49:\n        v8 += 2;\n        level_0_node->children_list.last = v19;\n      }\n      while ( v9 != v8 );\n      v66 += j;\n      v22 = v69;\nLABEL_13:\n      ++v3;\n      v1 = v22 + 8;\n    }\n    while ( v3 != 73 );\nLABEL_14:\n    v1 = (unsigned __int8 *)&list_member_1->child_node + 1;\n    v2 = row + 1;\n  }\n  while ( level_0_node->board_state[1] != (unsigned __int8 *)((char *)&list_member_1->child_node + 1) );\n  i = 0;\n  level_0_node->children_count = v66;\n  list_member_1a = level_0_node->children_list.first;\n  if ( !v66 )\n    return;\n  do\n  {\n    v23 = 49;\n    v67 = 0;\n    child_node = (char *)list_member_1a->child_node;\n    level_1_node = (tree_node_t *)list_member_1a->child_node;\n    v71 = (unsigned __int8 *)list_member_1a->child_node + 8;\n    *(_QWORD *)rowa = v71;\n    do\n    {\n      v73 = v23;\n      v25 = 65;\n      v26 = *(_BYTE **)rowa;\n      v27 = v23;\n      do\n      {\n        while ( 1 )\n        {\n          v28 = *((_DWORD *)child_node + 18);\n          v29 = *v26 & 0xDF;\n          if ( !v28 )\n            break;\n          if ( v29 == 66 )\n            goto LABEL_22;\nLABEL_19:\n          ++v25;\n          v26 += 8;\n          if ( v25 == 73 )\n            goto LABEL_29;\n        }\n        if ( v29 != 87 )\n          goto LABEL_19;\nLABEL_22:\n        v70 = v26;\n        v30 = all_possible_moves((unsigned __int8 (*)[8])v71, v25, v27, (square_t *)valid_moves_0_0, v28);\n        v26 = v70;\n        v31 = v30;\n        if ( v30 <= 0 )\n          goto LABEL_19;\n        v32 = valid_moves_0_0;\n        v33 = &valid_moves_0_0[2 * (v30 - 1) + 2];\n        do\n        {\n          while ( 1 )\n          {\n            LOBYTE(v34) = v25;\n            v89 = v33;\n            ja = v26;\n            HIBYTE(v34) = v73;\n            list_member_2 = v31;\n            v79 = *v32;\n            board_input = v32[1];\n            v35 = (board_input << 24) | ((unsigned __int8)*v32 << 16) | v34;\n            v36 = (char *)libmin_malloc(0x60uLL);\n            *(_DWORD *)v36 = 2;\n            v37 = (__m128i *)v36;\n            v38 = _mm_loadu_si128((const __m128i *)(child_node + 40));\n            v39 = _mm_loadu_si128((const __m128i *)(child_node + 56));\n            v40 = _mm_loadu_si128((const __m128i *)(child_node + 8));\n            *(__m128i *)(v36 + 24) = _mm_loadu_si128((const __m128i *)(child_node + 24));\n            *(__m128i *)(v36 + 40) = v38;\n            *(__m128i *)(v36 + 8) = v40;\n            *(__m128i *)(v36 + 56) = v39;\n            change_board((board_t *)(v36 + 8), v25, v27, v79, board_input);\n            v37->m128i_i32[1] = v35;\n            v41 = *((_DWORD *)child_node + 18);\n            v42 = _mm_loadu_si128((const __m128i *)&initial_children);\n            v37[4].m128i_i32[3] = 0;\n            v37[5] = v42;\n            v37[4].m128i_i32[2] = v41 == 0;\n            v43 = libmin_malloc(0x10uLL);\n            v20 = *((_QWORD *)child_node + 10) == 0LL;\n            v31 = list_member_2;\n            v26 = ja;\n            v33 = v89;\n            *v43 = v37;\n            v43[1] = 0LL;\n            if ( v20 )\n              *((_QWORD *)child_node + 10) = v43;\n            v44 = *((_QWORD *)child_node + 11);\n            if ( !v44 )\n              break;\n            v32 += 2;\n            *(_QWORD *)(v44 + 8) = v43;\n            *((_QWORD *)child_node + 11) = v43;\n            if ( v32 == v89 )\n              goto LABEL_28;\n          }\n          v32 += 2;\n          *((_QWORD *)child_node + 11) = v43;\n        }\n        while ( v89 != v32 );\nLABEL_28:\n        ++v25;\n        v67 += list_member_2;\n        v26 = ja + 8;\n      }\n      while ( v25 != 73 );\nLABEL_29:\n      ++*(_QWORD *)rowa;\n      v23 = v27 + 1;\n    }\n    while ( v27 != 56 );\n    jb = 0;\n    level_1_node->children_count = v67;\n    list_member_2a = level_1_node->children_list.first;\n    if ( !v67 )\n      goto LABEL_46;\n    while ( 2 )\n    {\n      v90 = 0;\n      v45 = 49;\n      v46 = (char *)list_member_2a->child_node;\n      v91 = (unsigned __int8 *)list_member_2a->child_node + 8;\n      v93 = v91;\n      while ( 2 )\n      {\n        v47 = 65;\n        v72 = v93;\n        while ( 2 )\n        {\n          while ( 2 )\n          {\n            v48 = *((_DWORD *)v46 + 18);\n            v49 = *v72 & 0xDF;\n            if ( v48 )\n            {\n              if ( v49 == 66 )\n                goto LABEL_37;\nLABEL_34:\n              ++v47;\n              v72 += 8;\n              if ( v47 == 73 )\n                goto LABEL_44;\n              continue;\n            }\n            break;\n          }\n          if ( v49 != 87 )\n            goto LABEL_34;\nLABEL_37:\n          v50 = all_possible_moves((unsigned __int8 (*)[8])v91, v47, v45, (square_t *)valid_moves_0_0, v48);\n          v80 = v50;\n          if ( v50 <= 0 )\n            goto LABEL_34;\n          v51 = valid_moves_0_0;\n          v74 = &valid_moves_0_0[2 * (v50 - 1) + 2];\n          do\n          {\n            while ( 1 )\n            {\n              LOBYTE(v52) = v47;\n              v68 = *v51;\n              HIBYTE(v52) = v45;\n              rowb = v51[1];\n              v53 = (rowb << 24) | ((unsigned __int8)*v51 << 16) | v52;\n              v54 = (char *)libmin_malloc(0x60uLL);\n              *(_DWORD *)v54 = 3;\n              v55 = (__m128i *)v54;\n              v56 = _mm_loadu_si128((const __m128i *)(v46 + 40));\n              v57 = _mm_loadu_si128((const __m128i *)(v46 + 56));\n              v58 = _mm_loadu_si128((const __m128i *)(v46 + 8));\n              *(__m128i *)(v54 + 24) = _mm_loadu_si128((const __m128i *)(v46 + 24));\n              *(__m128i *)(v54 + 40) = v56;\n              *(__m128i *)(v54 + 8) = v58;\n              *(__m128i *)(v54 + 56) = v57;\n              change_board((board_t *)(v54 + 8), v47, v45, v68, rowb);\n              v55->m128i_i32[1] = v53;\n              v59 = *((_DWORD *)v46 + 18);\n              v60 = _mm_loadu_si128((const __m128i *)&initial_children);\n              v55[4].m128i_i32[3] = 0;\n              v55[5] = v60;\n              v55[4].m128i_i32[2] = v59 == 0;\n              v61 = libmin_malloc(0x10uLL);\n              v20 = *((_QWORD *)v46 + 10) == 0LL;\n              *v61 = v55;\n              v61[1] = 0LL;\n              if ( v20 )\n                *((_QWORD *)v46 + 10) = v61;\n              v62 = *((_QWORD *)v46 + 11);\n              if ( !v62 )\n                break;\n              *(_QWORD *)(v62 + 8) = v61;\n              v51 += 2;\n              *((_QWORD *)v46 + 11) = v61;\n              if ( v51 == v74 )\n                goto LABEL_43;\n            }\n            *((_QWORD *)v46 + 11) = v61;\n            v51 += 2;\n          }\n          while ( v51 != v74 );\nLABEL_43:\n          ++v47;\n          v72 += 8;\n          v90 += v80;\n          if ( v47 != 73 )\n            continue;\n          break;\n        }\nLABEL_44:\n        ++v45;\n        ++v93;\n        if ( v45 != 57 )\n          continue;\n        break;\n      }\n      ++jb;\n      *((_DWORD *)v46 + 19) = v90;\n      list_member_2a = list_member_2a->next;\n      if ( level_1_node->children_count > jb )\n        continue;\n      break;\n    }\nLABEL_46:\n    ++i;\n    list_member_1a = list_member_1a->next;\n  }\n  while ( level_0_node->children_count > i );\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O3", "assembly": "<generate_tree_depth_3>:\nendbr64\npush   %r15\nlea    0x8(%rdi),%rax\npush   %r14\nmov    %rax,%r14\npush   %r13\nxor    %r13d,%r13d\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    $0x31,%ebp\npush   %rbx\nmov    %ebp,%r15d\nsub    $0x88,%rsp\nmov    %rax,0x30(%rsp)\nlea    0x10(%rdi),%rax\nmov    %rdi,0x78(%rsp)\nmov    %rax,0x28(%rsp)\nmov    %r13d,0x14(%rsp)\nmov    $0x41,%r13d\nmov    %r15b,0x40(%rsp)\nmov    %r15d,0x8(%rsp)\nmov    %r13d,%r15d\nmov    %r14,0x38(%rsp)\njmp    3772 <generate_tree_depth_3+0x72>\ncmp    $0x42,%al\nje     3787 <generate_tree_depth_3+0x87>\nadd    $0x1,%r15d\nadd    $0x8,%r14\ncmp    $0x49,%r15d\nje     38e1 <generate_tree_depth_3+0x1e1>\nmovzbl (%r14),%eax\nmov    0x48(%r12),%r8d\nand    $0xffffffdf,%eax\ntest   %r8d,%r8d\njne    375c <generate_tree_depth_3+0x5c>\ncmp    $0x57,%al\njne    3760 <generate_tree_depth_3+0x60>\nmov    0x8(%rsp),%edx\nmov    0x30(%rsp),%rdi\nlea    0x9bd9(%rip),%rcx\nmov    %r15d,%esi\ncall   22b0 <all_possible_moves>\nmov    %eax,%r9d\ntest   %eax,%eax\njle    3760 <generate_tree_depth_3+0x60>\nlea    0x9bc3(%rip),%r13\nlea    -0x1(%rax),%eax\nmov    %r15b,0x20(%rsp)\nlea    0x2(%r13),%rsi\nmov    %r14,0x18(%rsp)\nlea    (%rsi,%rax,2),%r11\nmov    %r11,%r14\nmovzbl 0x0(%r13),%edx\nmov    0x40(%rsp),%ecx\nxor    %eax,%eax\nmov    $0x60,%edi\nmov    0x20(%rsp),%al\nmovzbl 0x1(%r13),%r8d\nmov    %r9d,0x50(%rsp)\nmov    %dl,0x48(%rsp)\nmov    %cl,%ah\nmovzbl %dl,%ecx\nmov    %r8b,0x44(%rsp)\nshl    $0x10,%ecx\nmovzwl %ax,%ebp\nmov    %r8d,%eax\nor     %ecx,%ebp\nshl    $0x18,%eax\nor     %eax,%ebp\ncall   67c0 <libmin_malloc>\nmovsbl 0x48(%rsp),%ecx\nmov    0x8(%rsp),%edx\nmov    %r15d,%esi\nmovl   $0x1,(%rax)\nmovdqu 0x18(%r12),%xmm2\nmov    %rax,%rbx\nlea    0x8(%rax),%rdi\nmovdqu 0x28(%r12),%xmm1\nmovdqu 0x38(%r12),%xmm0\nmovdqu 0x8(%r12),%xmm5\nmovsbl 0x44(%rsp),%r8d\nmovups %xmm2,0x18(%rax)\nmovups %xmm1,0x28(%rax)\nmovups %xmm5,0x8(%rax)\nmovups %xmm0,0x38(%rax)\ncall   21b0 <change_board>\nmov    %ebp,0x4(%rbx)\nmov    0x48(%r12),%esi\nxor    %eax,%eax\nmovdqu 0x9af8(%rip),%xmm6\nmovl   $0x0,0x4c(%rbx)\nmov    $0x10,%edi\ntest   %esi,%esi\nsete   %al\nmovups %xmm6,0x50(%rbx)\nmov    %eax,0x48(%rbx)\ncall   67c0 <libmin_malloc>\ncmpq   $0x0,0x50(%r12)\nmov    0x50(%rsp),%r9d\nmov    %rbx,(%rax)\nmovq   $0x0,0x8(%rax)\nje     3d74 <generate_tree_depth_3+0x674>\nmov    0x58(%r12),%rdx\ntest   %rdx,%rdx\nje     3d87 <generate_tree_depth_3+0x687>\nadd    $0x2,%r13\nmov    %rax,0x8(%rdx)\nmov    %rax,0x58(%r12)\ncmp    %r14,%r13\njne    37c5 <generate_tree_depth_3+0xc5>\nadd    %r9d,0x14(%rsp)\nmov    0x18(%rsp),%r14\nadd    $0x1,%r15d\nadd    $0x8,%r14\ncmp    $0x49,%r15d\njne    3772 <generate_tree_depth_3+0x72>\nmov    0x38(%rsp),%r14\nmov    0x8(%rsp),%r15d\nadd    $0x1,%r14\nadd    $0x1,%r15d\ncmp    %r14,0x28(%rsp)\njne    3742 <generate_tree_depth_3+0x42>\nmov    0x78(%rsp),%rax\nmov    0x14(%rsp),%r13d\nmovl   $0x0,0x44(%rsp)\nmov    %r13d,0x4c(%rax)\nmov    0x50(%rax),%rax\nmov    %rax,0x38(%rsp)\ntest   %r13d,%r13d\nje     3d62 <generate_tree_depth_3+0x662>\nmov    0x38(%rsp),%rax\nxor    %r13d,%r13d\nmov    $0x31,%ebp\nmov    %r13d,0x14(%rsp)\nmov    (%rax),%r12\nlea    0x8(%r12),%rax\nmov    %r12,0x68(%rsp)\nmov    %rax,0x20(%rsp)\nmov    %rax,0x8(%rsp)\nmov    0x8(%rsp),%r13\nmov    %bpl,0x28(%rsp)\nmov    $0x41,%r14d\nmov    %r13,%r10\nmov    %ebp,%r13d\njmp    397d <generate_tree_depth_3+0x27d>\ncmp    $0x42,%al\nje     3992 <generate_tree_depth_3+0x292>\nadd    $0x1,%r14d\nadd    $0x8,%r10\ncmp    $0x49,%r14d\nje     3afe <generate_tree_depth_3+0x3fe>\nmovzbl (%r10),%eax\nmov    0x48(%r12),%r8d\nand    $0xffffffdf,%eax\ntest   %r8d,%r8d\njne    3967 <generate_tree_depth_3+0x267>\ncmp    $0x57,%al\njne    396b <generate_tree_depth_3+0x26b>\nmov    0x20(%rsp),%rdi\nmov    %r13d,%edx\nmov    %r14d,%esi\nmov    %r10,0x18(%rsp)\nlea    0x99c7(%rip),%rcx\ncall   22b0 <all_possible_moves>\nmov    0x18(%rsp),%r10\ntest   %eax,%eax\nmov    %eax,%r9d\njle    396b <generate_tree_depth_3+0x26b>\nlea    0x99af(%rip),%rbp\nmov    %r14b,0x18(%rsp)\nlea    -0x1(%rax),%eax\nlea    0x2(%rbp),%rsi\nlea    (%rsi,%rax,2),%r11\nmovzbl 0x0(%rbp),%edx\nmov    0x28(%rsp),%ecx\nxor    %eax,%eax\nmov    $0x60,%edi\nmov    0x18(%rsp),%al\nmovzbl 0x1(%rbp),%r8d\nmov    %r11,0x58(%rsp)\nmov    %r10,0x50(%rsp)\nmov    %cl,%ah\nmovzbl %dl,%ecx\nmov    %r9d,0x48(%rsp)\nshl    $0x10,%ecx\nmovzwl %ax,%r15d\nmov    %r8d,%eax\nmov    %dl,0x40(%rsp)\nor     %ecx,%r15d\nshl    $0x18,%eax\nmov    %r8b,0x30(%rsp)\nor     %eax,%r15d\ncall   67c0 <libmin_malloc>\nmovsbl 0x40(%rsp),%ecx\nmov    %r13d,%edx\nmov    %r14d,%esi\nmovl   $0x2,(%rax)\nmovdqu 0x18(%r12),%xmm2\nmov    %rax,%rbx\nlea    0x8(%rax),%rdi\nmovdqu 0x28(%r12),%xmm1\nmovdqu 0x38(%r12),%xmm0\nmovdqu 0x8(%r12),%xmm7\nmovsbl 0x30(%rsp),%r8d\nmovups %xmm2,0x18(%rax)\nmovups %xmm1,0x28(%rax)\nmovups %xmm7,0x8(%rax)\nmovups %xmm0,0x38(%rax)\ncall   21b0 <change_board>\nmov    %r15d,0x4(%rbx)\nmov    0x48(%r12),%ecx\nxor    %eax,%eax\nmovdqu 0x98e0(%rip),%xmm5\nmovl   $0x0,0x4c(%rbx)\nmov    $0x10,%edi\ntest   %ecx,%ecx\nsete   %al\nmovups %xmm5,0x50(%rbx)\nmov    %eax,0x48(%rbx)\ncall   67c0 <libmin_malloc>\ncmpq   $0x0,0x50(%r12)\nmov    0x48(%rsp),%r9d\nmov    0x50(%rsp),%r10\nmov    0x58(%rsp),%r11\nmov    %rbx,(%rax)\nmovq   $0x0,0x8(%rax)\nje     3dbf <generate_tree_depth_3+0x6bf>\nmov    0x58(%r12),%rdx\ntest   %rdx,%rdx\nje     3da8 <generate_tree_depth_3+0x6a8>\nadd    $0x2,%rbp\nmov    %rax,0x8(%rdx)\nmov    %rax,0x58(%r12)\ncmp    %r11,%rbp\njne    39d1 <generate_tree_depth_3+0x2d1>\nadd    $0x1,%r14d\nadd    %r9d,0x14(%rsp)\nadd    $0x8,%r10\ncmp    $0x49,%r14d\njne    397d <generate_tree_depth_3+0x27d>\nmov    %r13d,%ebp\naddq   $0x1,0x8(%rsp)\nadd    $0x1,%ebp\ncmp    $0x39,%ebp\njne    394f <generate_tree_depth_3+0x24f>\nmov    0x68(%rsp),%rax\nmov    0x14(%rsp),%r13d\nmovl   $0x0,0x50(%rsp)\nmov    %r13d,0x4c(%rax)\nmov    0x50(%rax),%rax\nmov    %rax,0x48(%rsp)\ntest   %r13d,%r13d\nje     3d3d <generate_tree_depth_3+0x63d>\nmov    0x48(%rsp),%rax\nmovl   $0x0,0x58(%rsp)\nmov    $0x31,%r13d\nmov    (%rax),%r15\nlea    0x8(%r15),%rax\nmov    %r15,%r12\nmov    %rax,0x60(%rsp)\nmov    %rax,0x70(%rsp)\nmov    0x70(%rsp),%rax\nmov    %r13b,0x30(%rsp)\nmov    $0x41,%ebp\nmov    %rax,0x20(%rsp)\njmp    3b8e <generate_tree_depth_3+0x48e>\ncmp    $0x42,%al\nje     3bab <generate_tree_depth_3+0x4ab>\nadd    $0x1,%ebp\naddq   $0x8,0x20(%rsp)\ncmp    $0x49,%ebp\nje     3cfb <generate_tree_depth_3+0x5fb>\nmov    0x20(%rsp),%rax\nmov    0x48(%r12),%r8d\nmovzbl (%rax),%eax\nmov    %al,0x8(%rsp)\nand    $0xffffffdf,%eax\ntest   %r8d,%r8d\njne    3b78 <generate_tree_depth_3+0x478>\ncmp    $0x57,%al\njne    3b7c <generate_tree_depth_3+0x47c>\nmov    0x60(%rsp),%rdi\nlea    0x97b9(%rip),%rcx\nmov    %r13d,%edx\nmov    %ebp,%esi\ncall   22b0 <all_possible_moves>\nmov    %eax,0x40(%rsp)\ntest   %eax,%eax\njle    3b7c <generate_tree_depth_3+0x47c>\nlea    0x97a0(%rip),%r15\nsub    $0x1,%eax\nmov    %bpl,0x18(%rsp)\nlea    0x2(%r15),%rsi\nlea    (%rsi,%rax,2),%rax\nmov    %rax,0x28(%rsp)\nnopl   (%rax)\nmovzbl (%r15),%edx\nmov    0x30(%rsp),%ecx\nxor    %eax,%eax\nmov    $0x60,%edi\nmov    0x18(%rsp),%al\nmovzbl 0x1(%r15),%r8d\nmov    %dl,0x14(%rsp)\nmov    %cl,%ah\nmovzbl %dl,%ecx\nmov    %r8b,0x8(%rsp)\nshl    $0x10,%ecx\nmovzwl %ax,%r14d\nmov    %r8d,%eax\nor     %ecx,%r14d\nshl    $0x18,%eax\nor     %eax,%r14d\ncall   67c0 <libmin_malloc>\nmovsbl 0x14(%rsp),%ecx\nmov    %r13d,%edx\nmov    %ebp,%esi\nmovl   $0x3,(%rax)\nmovdqu 0x18(%r12),%xmm2\nmov    %rax,%rbx\nlea    0x8(%rax),%rdi\nmovdqu 0x28(%r12),%xmm1\nmovdqu 0x38(%r12),%xmm0\nmovdqu 0x8(%r12),%xmm3\nmovsbl 0x8(%rsp),%r8d\nmovups %xmm2,0x18(%rax)\nmovups %xmm1,0x28(%rax)\nmovups %xmm3,0x8(%rax)\nmovups %xmm0,0x38(%rax)\ncall   21b0 <change_board>\nmov    %r14d,0x4(%rbx)\nmov    0x48(%r12),%edx\nxor    %eax,%eax\nmovdqu 0x96d9(%rip),%xmm4\nmovl   $0x0,0x4c(%rbx)\nmov    $0x10,%edi\ntest   %edx,%edx\nsete   %al\nmovups %xmm4,0x50(%rbx)\nmov    %eax,0x48(%rbx)\ncall   67c0 <libmin_malloc>\ncmpq   $0x0,0x50(%r12)\nmov    %rbx,(%rax)\nmovq   $0x0,0x8(%rax)\nje     3de2 <generate_tree_depth_3+0x6e2>\nmov    0x58(%r12),%rdx\ntest   %rdx,%rdx\nje     3dc9 <generate_tree_depth_3+0x6c9>\nmov    %rax,0x8(%rdx)\nadd    $0x2,%r15\nmov    %rax,0x58(%r12)\ncmp    0x28(%rsp),%r15\njne    3be8 <generate_tree_depth_3+0x4e8>\nadd    $0x1,%ebp\nmov    0x40(%rsp),%esi\naddq   $0x8,0x20(%rsp)\nadd    %esi,0x58(%rsp)\ncmp    $0x49,%ebp\njne    3b8e <generate_tree_depth_3+0x48e>\nadd    $0x1,%r13d\naddq   $0x1,0x70(%rsp)\ncmp    $0x39,%r13d\njne    3b62 <generate_tree_depth_3+0x462>\nmov    0x58(%rsp),%eax\nmov    0x68(%rsp),%rsi\naddl   $0x1,0x50(%rsp)\nmov    %eax,0x4c(%r12)\nmov    0x48(%rsp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0x48(%rsp)\nmov    0x50(%rsp),%eax\ncmp    %eax,0x4c(%rsi)\njg     3b3b <generate_tree_depth_3+0x43b>\nmov    0x38(%rsp),%rax\nmov    0x78(%rsp),%rsi\naddl   $0x1,0x44(%rsp)\nmov    0x8(%rax),%rax\nmov    %rax,0x38(%rsp)\nmov    0x44(%rsp),%eax\ncmp    %eax,0x4c(%rsi)\njg     3926 <generate_tree_depth_3+0x226>\nadd    $0x88,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    0x58(%r12),%rdx\nmov    %rax,0x50(%r12)\ntest   %rdx,%rdx\njne    38af <generate_tree_depth_3+0x1af>\nadd    $0x2,%r13\nmov    %rax,0x58(%r12)\ncmp    %r13,%r14\njne    37c5 <generate_tree_depth_3+0xc5>\nadd    %r9d,0x14(%rsp)\nmov    0x18(%rsp),%r14\njmp    38cf <generate_tree_depth_3+0x1cf>\nadd    $0x2,%rbp\nmov    %rax,0x58(%r12)\ncmp    %rbp,%r11\njne    39d1 <generate_tree_depth_3+0x2d1>\njmp    3ae7 <generate_tree_depth_3+0x3e7>\nmov    %rax,0x50(%r12)\njmp    3ac3 <generate_tree_depth_3+0x3c3>\nmov    %rax,0x58(%r12)\nadd    $0x2,%r15\ncmp    0x28(%rsp),%r15\njne    3be8 <generate_tree_depth_3+0x4e8>\njmp    3ce1 <generate_tree_depth_3+0x5e1>\nmov    %rax,0x50(%r12)\njmp    3cbb <generate_tree_depth_3+0x5bb>\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "link_new_node", "content": "void link_new_node(tree_node_t* parent_node,\n\tchar col1, char row1, char col2, char row2, int depth) {\n\t// create a new tree node ready to link\n\t\t// first copy over new board after move is made\n\ttree_node_t* new_node = (tree_node_t*)libmin_malloc(sizeof(tree_node_t));\n\tnew_node->depth = depth;\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\t(new_node->board_state)[i][j] = (parent_node->board_state)[i][j];\n\t\t}\n\t}\n\tchange_board((board_t*)(&(new_node->board_state)), col1, row1, col2, row2);\n\t\n\tnew_node->move_info[0][0] = col1;\n\tnew_node->move_info[0][1] = row1;\n\tnew_node->move_info[1][0] = col2;\n\tnew_node->move_info[1][1] = row2;\n\tnew_node->black_action = !(parent_node->black_action);\n\t\t// change of turn\n\tnew_node->children_list = initial_children;\n\tnew_node->children_count = 0;\n\t\n\t// create a list member to contain the address of the new node, \n\t\t// which is dynamically linked to children_list of the parent node\n\tlinked_list_member_t* new_list_member\n\t\t= (linked_list_member_t*)libmin_malloc(sizeof(linked_list_member_t));\n\tnew_list_member->child_node = (void*)new_node; // raw address of new node\n\tnew_list_member->next = NULL;\n\t\n\t// link the new list member to the parent node children_list\n\tif ((parent_node->children_list).first == NULL) {\n\t\t(parent_node->children_list).first = new_list_member;\n\t}\n\t\n\tif ((parent_node->children_list).last == NULL) {\n\t\t(parent_node->children_list).last = new_list_member;\n\t}\n\telse {\n\t\t((parent_node->children_list).last)->next = new_list_member;\n\t\t(parent_node->children_list).last = new_list_member;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "link_new_node", "address": "0x34c0", "label": "link_new_node", "content": "void __fastcall link_new_node(tree_node_t *parent_node, char col1, char row1, char col2, char row2, int depth)\n{\n  unsigned __int16 v7; // ax\n  int v9; // r12d\n  char *v10; // rbx\n  int black_action; // edx\n  __m128i v12; // xmm4\n  linked_list_member_t *v13; // rax\n  bool v14; // zf\n  linked_list_member_t *last; // rdx\n\n  LOBYTE(v7) = col1;\n  HIBYTE(v7) = row1;\n  v9 = (row2 << 24) | ((unsigned __int8)col2 << 16) | v7;\n  v10 = (char *)libmin_malloc(0x60uLL);\n  *(_DWORD *)v10 = depth;\n  *(__m128i *)(v10 + 8) = _mm_loadu_si128((const __m128i *)parent_node->board_state);\n  *(__m128i *)(v10 + 24) = _mm_loadu_si128((const __m128i *)parent_node->board_state[2]);\n  *(__m128i *)(v10 + 40) = _mm_loadu_si128((const __m128i *)parent_node->board_state[4]);\n  *(__m128i *)(v10 + 56) = _mm_loadu_si128((const __m128i *)parent_node->board_state[6]);\n  change_board((board_t *)(v10 + 8), col1, row1, col2, row2);\n  *((_DWORD *)v10 + 1) = v9;\n  black_action = parent_node->black_action;\n  v12 = _mm_loadu_si128((const __m128i *)&initial_children);\n  *((_DWORD *)v10 + 19) = 0;\n  *((__m128i *)v10 + 5) = v12;\n  *((_DWORD *)v10 + 18) = black_action == 0;\n  v13 = (linked_list_member_t *)libmin_malloc(0x10uLL);\n  v14 = parent_node->children_list.first == 0LL;\n  v13->child_node = v10;\n  v13->next = 0LL;\n  if ( v14 )\n    parent_node->children_list.first = v13;\n  last = parent_node->children_list.last;\n  if ( last )\n    last->next = v13;\n  parent_node->children_list.last = v13;\n}\n"}, "pseudo_normalize": "void link_new_node(tree_node_t *parent_node, char col1, char row1, char col2,\n                   char row2, int depth) {\n  unsigned short v7;\n  int v9;\n  char *v10;\n  int black_action;\n  __m128i v12;\n  linked_list_member_t *v13;\n  bool v14;\n  linked_list_member_t *last;\n  LOBYTE(v7) = col1;\n  HIBYTE(v7) = row1;\n  v9 = (row2 << 24) | ((unsigned char)col2 << 16) | v7;\n  v10 = (char *)libmin_malloc(96uLL);\n  *(uint32_t *)v10 = depth;\n  *(__m128i *)(v10 + 8) =\n      _mm_loadu_si128((const __m128i *)parent_node->board_state);\n  *(__m128i *)(v10 + 24) =\n      _mm_loadu_si128((const __m128i *)parent_node->board_state[2]);\n  *(__m128i *)(v10 + 40) =\n      _mm_loadu_si128((const __m128i *)parent_node->board_state[4]);\n  *(__m128i *)(v10 + 56) =\n      _mm_loadu_si128((const __m128i *)parent_node->board_state[6]);\n  change_board((board_t *)(v10 + 8), col1, row1, col2, row2);\n  *((uint32_t *)v10 + 1) = v9;\n  black_action = parent_node->black_action;\n  v12 = _mm_loadu_si128((const __m128i *)&initial_children);\n  *((uint32_t *)v10 + 19) = 0;\n  *((__m128i *)v10 + 5) = v12;\n  *((uint32_t *)v10 + 18) = black_action == 0;\n  v13 = (linked_list_member_t *)libmin_malloc(16uLL);\n  v14 = parent_node->children_list.first == 0LL;\n  v13->child_node = v10;\n  v13->next = 0LL;\n  if (v14) parent_node->children_list.first = v13;\n  last = parent_node->children_list.last;\n  if (last) last->next = v13;\n  parent_node->children_list.last = v13;\n}", "binary": "checkers/checkers.host.O3", "assembly": "<link_new_node>:\nendbr64\nxor    %eax,%eax\npush   %r15\nmov    %ecx,%r15d\npush   %r14\nmov    %sil,%al\nmov    %edx,%r14d\npush   %r13\nmov    %dl,%ah\nmovzbl %cl,%edx\nmov    %esi,%r13d\npush   %r12\nshl    $0x10,%edx\nmovzwl %ax,%r12d\nmov    %r8d,%eax\npush   %rbp\nor     %edx,%r12d\nmov    %rdi,%rbp\nshl    $0x18,%eax\npush   %rbx\nmov    $0x60,%edi\nor     %eax,%r12d\nsub    $0x18,%rsp\nmov    %r9d,0xc(%rsp)\nmov    %r8d,0x8(%rsp)\ncall   67c0 <libmin_malloc>\nmov    0xc(%rsp),%r9d\nmov    0x8(%rsp),%r8d\nmovsbl %r15b,%ecx\nmov    %rax,%rbx\nlea    0x8(%rax),%rdi\nmovsbl %r14b,%edx\nmovsbl %r13b,%esi\nmov    %r9d,(%rax)\nmovdqu 0x8(%rbp),%xmm0\nmovsbl %r8b,%r8d\nmovups %xmm0,0x8(%rax)\nmovdqu 0x18(%rbp),%xmm1\nmovups %xmm1,0x18(%rax)\nmovdqu 0x28(%rbp),%xmm2\nmovups %xmm2,0x28(%rax)\nmovdqu 0x38(%rbp),%xmm3\nmovups %xmm3,0x38(%rax)\ncall   21b0 <change_board>\nmov    %r12d,0x4(%rbx)\nmov    0x48(%rbp),%edx\nxor    %eax,%eax\nmovdqu 0x9df3(%rip),%xmm4\nmovl   $0x0,0x4c(%rbx)\nmov    $0x10,%edi\ntest   %edx,%edx\nsete   %al\nmovups %xmm4,0x50(%rbx)\nmov    %eax,0x48(%rbx)\ncall   67c0 <libmin_malloc>\ncmpq   $0x0,0x50(%rbp)\nmov    %rbx,(%rax)\nmovq   $0x0,0x8(%rax)\nje     35bc <link_new_node+0xfc>\nmov    0x58(%rbp),%rdx\ntest   %rdx,%rdx\nje     35a9 <link_new_node+0xe9>\nmov    %rax,0x8(%rdx)\nmov    %rax,0x58(%rbp)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %rax,0x50(%rbp)\njmp    359c <link_new_node+0xdc>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "checkers/checkers.c", "function_name": "main", "content": "int\nmain(int argc, char *argv[])\n{\n  libmin_mopen(infile, \"r\");\n\n  board_t* board = (board_t*)libmin_malloc(sizeof(board_t)); // main board pointer\n\n  fill_print_initial(board);\n  print_board(board);\n    \n  int black_action = 1, action = 1, error; //, board_cost;\n  char col1, row1, col2, row2; \n\t// col1/row1 is source cell,  col2/row2 is target cell\n\t// deliberately kept separate, square_t type not used\n\t\n\t// scan input moves\n\tchar buf[64];\n\tlibmin_mgets(buf, 64, infile);\n\twhile (libmin_sscanf(buf, \"%c%c-%c%c\\n\", &col1, &row1, &col2, &row2)==4) {\n\t\t// check errors 1-5, terminate function if any found\n\t\terror = check_move_error_1_to_5(*board, col1, row1, col2, row2, \n\t\t\tblack_action);\n\t\tif (error) {\n\t\t\tprint_error_message(error);\n\t\t\tlibmin_fail(error);\n\t\t}\n\t\t// check error 6\n\t\t\t// all the possible moves of the source cell are generated\n\t\t\t// and the target cell is checked against those\n\t\tstatic valid_moves_t valid_moves;\n\t\tint num_possibles = all_possible_moves(*board, col1, row1, valid_moves, \n\t\t\tblack_action);\n\t\tint illegal = 1;\n\t\tfor (int i=0;i<num_possibles;i++) {\n\t\t\tif ((valid_moves[i][0] == col2) && (valid_moves[i][1] == row2)) {\n\t\t\t\tillegal = 0;\n\t\t\t}\n\t\t}\n\t\t// if target_cell input is not in all legal moves, it must be illegal\n\t\t\t// return main function with error exit code 6\n\t\tif (illegal) {\n\t\t\tprint_error_message(6);\n\t\t\tlibmin_fail(6);\n\t\t}\n\t\t\n\t\tchange_board(board, col1, row1, col2, row2);\n\t\t\n\t\tprint_move_information(0, black_action, *board, col1, row1, col2, row2, \n\t\t\taction);\n\t\t\n\t\tprint_board(board);\n\t\t\n\t\t// change the action to opposite colour, iterate the move counts\n\t\tblack_action = !black_action;\n\t\taction += 1;\n\n    // get the next move\n    libmin_mgets(buf, 64, infile);\n\t}\n\t\n\tchar next_action = col1;\n\t\t// on last scanf call, col1 will pickup any trailing P or A instruction\n\t\t\t// naming isn't great, hence a reassignment to better variable name\n\t\n\t// stages 1 and 2\n\tint repititions=0; \n\tif (next_action == 'A') { // stage 1\n\t\trepititions = 1;\n\t}\n\tif (next_action == 'P') { // stage 2\n\t\trepititions = 100;\n\t}\n\t\t\t\n\tfor (int i=0; i<repititions; i++) {\n\t\t// stage 1\n\t\t\t// create the level 0 node first, and fill with relevent info.\n\t\ttree_node_t* level_0_node = (tree_node_t*)libmin_malloc(sizeof(tree_node_t));\n\t\tlevel_0_node->depth = 0;\n\t\tfor (int i=0; i<BOARD_SIZE;i++) {\n\t\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\t\t(level_0_node->board_state)[i][j] = (*board)[i][j];\n\t\t\t}\n\t\t}\n\t\tlevel_0_node->black_action = black_action;\n\t\tlevel_0_node->children_count = 0;\n\t\tlevel_0_node->children_list = initial_children;\n\t\t\n\t\tgenerate_tree_depth_3(level_0_node);\n\t\t\n\t\t// check if there isn't any possible moves, indicating game over\n\t\tif (level_0_node->children_count == 0) {\n\t\t\tif (black_action) {\n\t\t\t\tlibmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlibmin_printf(\"%s WIN!\\n\", BLACK);\n        libmin_success();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// now we journey into the tree, and implement the minimax decision rule\n\t\tint best_score = move_score_forced(level_0_node); \n\t\t\t// this is the best possible score we can have\n\t\t\n\t\t// find the choice node which yields this score\n\t\tlinked_list_member_t* list_member = (level_0_node->children_list).first;\n\t\ttree_node_t* choice_node = NULL;\n\t\tfor (int i=0; i<(level_0_node->children_count); i++) {\n\t\t\tchoice_node = (tree_node_t*)(list_member->child_node);\n\t\t\tif (move_score_forced(choice_node) == best_score) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_member = list_member->next;\n\t\t}\n\t\t\n\t\tchange_board(board, \n\t\t\t(choice_node->move_info)[0][0], \n\t\t\t(choice_node->move_info)[0][1],\n\t\t\t(choice_node->move_info)[1][0],\n\t\t\t(choice_node->move_info)[1][1]);\n\t\t\n\t\tprint_move_information(1, black_action, *board, \n\t\t\t(choice_node->move_info)[0][0], \n\t\t\t(choice_node->move_info)[0][1], \n\t\t\t(choice_node->move_info)[1][0], \n\t\t\t(choice_node->move_info)[1][1], \n\t\t\taction);\n\t\t\n\t\tprint_board(board);\n\t\t\n\t\tblack_action = !black_action;\n\t\taction += 1;\n\t\t\n\t\tfree_tree(level_0_node); // free space occupied by the tree\n\t\t\t// no need for it anymore\n\t}\n\t\n\tlibmin_free(board);\n  libmin_success(); // exit program with the success code\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "main", "address": "0x1130", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r12d\n  int v4; // ebp\n  unsigned __int8 *v5; // r15\n  int i; // eax\n  int v7; // eax\n  int v8; // ecx\n  int v9; // esi\n  int v10; // eax\n  int v11; // r13d\n  __m128i *v12; // r12\n  __m128i v13; // xmm0\n  int v14; // eax\n  __int64 v15; // rbp\n  int v16; // ebx\n  __int32 v17; // r13d\n  char *v18; // r14\n  int v19; // [rsp-8h] [rbp-C0h]\n  unsigned int black_action; // [rsp+0h] [rbp-B8h]\n  int action; // [rsp+8h] [rbp-B0h]\n  int v22; // [rsp+10h] [rbp-A8h]\n  int code; // [rsp+1Ch] [rbp-9Ch]\n  char v24; // [rsp+2Ch] [rbp-8Ch] BYREF\n  char v25; // [rsp+2Dh] [rbp-8Bh] BYREF\n  char v26; // [rsp+2Eh] [rbp-8Ah] BYREF\n  char v27; // [rsp+2Fh] [rbp-89h] BYREF\n  char s[72]; // [rsp+30h] [rbp-88h] BYREF\n  unsigned __int64 v29; // [rsp+78h] [rbp-40h]\n\n  v3 = 1;\n  v4 = 1;\n  v29 = __readfsqword(0x28u);\n  libmin_mopen(infile, \"r\");\n  v5 = (unsigned __int8 *)libmin_malloc(0x40uLL);\n  fill_print_initial((board_t *)v5);\n  print_board((board_t *)v5);\n  libmin_mgets(s, 0x40uLL, infile);\n  for ( i = libmin_sscanf(s, \"%c%c-%c%c\\n\", &v24, &v25, &v26, &v27);\n        ;\n        i = libmin_sscanf(s, \"%c%c-%c%c\\n\", &v24, &v25, &v26, &v27) )\n  {\n    if ( i != 4 )\n    {\n      action = v3;\n      if ( v24 != 65 )\n      {\n        v11 = 100;\n        if ( v24 == 80 )\n        {\nLABEL_26:\n          black_action = v4;\n          v22 = v3 + v11;\n          do\n          {\n            v12 = (__m128i *)libmin_malloc(0x60uLL);\n            v12->m128i_i32[0] = 0;\n            v12->m128i_i8[8] = *v5;\n            v12->m128i_i8[9] = v5[1];\n            v12->m128i_i8[10] = v5[2];\n            v12->m128i_i8[11] = v5[3];\n            v12->m128i_i8[12] = v5[4];\n            v12->m128i_i8[13] = v5[5];\n            v12->m128i_i8[14] = v5[6];\n            v12->m128i_i8[15] = v5[7];\n            v12[1].m128i_i8[0] = v5[8];\n            v12[1].m128i_i8[1] = v5[9];\n            v12[1].m128i_i8[2] = v5[10];\n            v12[1].m128i_i8[3] = v5[11];\n            v12[1].m128i_i8[4] = v5[12];\n            v12[1].m128i_i8[5] = v5[13];\n            v12[1].m128i_i8[6] = v5[14];\n            v12[1].m128i_i8[7] = v5[15];\n            v12[1].m128i_i8[8] = v5[16];\n            v12[1].m128i_i8[9] = v5[17];\n            v12[1].m128i_i8[10] = v5[18];\n            v12[1].m128i_i8[11] = v5[19];\n            v12[1].m128i_i8[12] = v5[20];\n            v12[1].m128i_i8[13] = v5[21];\n            v12[1].m128i_i8[14] = v5[22];\n            v12[1].m128i_i8[15] = v5[23];\n            v12[2].m128i_i8[0] = v5[24];\n            v12[2].m128i_i8[1] = v5[25];\n            v12[2].m128i_i8[2] = v5[26];\n            v12[2].m128i_i8[3] = v5[27];\n            v12[2].m128i_i8[4] = v5[28];\n            v12[2].m128i_i8[5] = v5[29];\n            v12[2].m128i_i8[6] = v5[30];\n            v12[2].m128i_i8[7] = v5[31];\n            v12[2].m128i_i8[8] = v5[32];\n            v12[2].m128i_i8[9] = v5[33];\n            v12[2].m128i_i8[10] = v5[34];\n            v12[2].m128i_i8[11] = v5[35];\n            v12[2].m128i_i8[12] = v5[36];\n            v12[2].m128i_i8[13] = v5[37];\n            v12[2].m128i_i8[14] = v5[38];\n            v12[2].m128i_i8[15] = v5[39];\n            v12[3].m128i_i8[0] = v5[40];\n            v12[3].m128i_i8[1] = v5[41];\n            v12[3].m128i_i8[2] = v5[42];\n            v12[3].m128i_i8[3] = v5[43];\n            v12[3].m128i_i8[4] = v5[44];\n            v12[3].m128i_i8[5] = v5[45];\n            v12[3].m128i_i8[6] = v5[46];\n            v12[3].m128i_i8[7] = v5[47];\n            v12[3].m128i_i8[8] = v5[48];\n            v12[3].m128i_i8[9] = v5[49];\n            v12[3].m128i_i8[10] = v5[50];\n            v12[3].m128i_i8[11] = v5[51];\n            v12[3].m128i_i8[12] = v5[52];\n            v12[3].m128i_i8[13] = v5[53];\n            v12[3].m128i_i8[14] = v5[54];\n            v12[3].m128i_i8[15] = v5[55];\n            v12[4].m128i_i8[0] = v5[56];\n            v12[4].m128i_i8[1] = v5[57];\n            v12[4].m128i_i8[2] = v5[58];\n            v12[4].m128i_i8[3] = v5[59];\n            v12[4].m128i_i8[4] = v5[60];\n            v12[4].m128i_i8[5] = v5[61];\n            v12[4].m128i_i8[6] = v5[62];\n            v12[4].m128i_i8[7] = v5[63];\n            v13 = _mm_loadu_si128((const __m128i *)&initial_children);\n            v12[4].m128i_i64[1] = black_action;\n            v12[5] = v13;\n            generate_tree_depth_3((tree_node_t *)v12);\n            if ( !v12[4].m128i_i32[3] )\n            {\n              if ( black_action )\n              {\n                libmin_printf(\"%s WIN!\\n\", WHITE);\n                libmin_success();\n              }\n              libmin_printf(\"%s WIN!\\n\", BLACK);\n              libmin_success();\n            }\n            v14 = move_score_forced((tree_node_t *)v12);\n            v15 = v12[5].m128i_i64[0];\n            v16 = v14;\n            if ( v12[4].m128i_i32[3] <= 0 )\n              main_cold();\n            v17 = 0;\n            do\n            {\n              v18 = *(char **)v15;\n              if ( move_score_forced(*(tree_node_t **)v15) == v16 )\n                break;\n              v15 = *(_QWORD *)(v15 + 8);\n              ++v17;\n            }\n            while ( v12[4].m128i_i32[3] > v17 );\n            change_board((board_t *)v5, v18[4], v18[5], v18[6], v18[7]);\n            print_move_information(1, black_action, (unsigned __int8 (*)[8])v5, v18[4], v18[5], v18[6], v18[7], action);\n            print_board((board_t *)v5);\n            ++action;\n            black_action ^= 1u;\n            free_tree((tree_node_t *)v12);\n          }\n          while ( v22 != action );\n        }\n        libmin_free(v5);\n        libmin_success();\n      }\n      v11 = 1;\n      goto LABEL_26;\n    }\n    v10 = check_move_error_1_to_5((unsigned __int8 (*)[8])v5, v24, v25, v26, v27, v4);\n    if ( v10 )\n    {\n      code = v10;\n      print_error_message(v10);\n      libmin_fail(code);\n    }\n    v7 = all_possible_moves((unsigned __int8 (*)[8])v5, v24, v25, (square_t *)valid_moves_0, v4);\n    if ( v7 <= 0 )\n    {\nLABEL_15:\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    if ( v26 == valid_moves_0[0] && valid_moves_0[1] == v27 )\n    {\n      if ( v7 == 1 )\n        goto LABEL_11;\n      v8 = 0;\n    }\n    else\n    {\n      v8 = 1;\n      if ( v7 == 1 )\n        goto LABEL_15;\n    }\n    if ( v26 == byte_D352 && v27 == byte_D353 )\n      break;\n    if ( v7 != 2 )\n      goto LABEL_7;\nLABEL_10:\n    if ( v8 )\n      goto LABEL_15;\nLABEL_11:\n    change_board((board_t *)v5, v24, v25, v26, v27);\n    v19 = v3;\n    v9 = v4;\n    v4 ^= 1u;\n    ++v3;\n    print_move_information(0, v9, (unsigned __int8 (*)[8])v5, v24, v25, v26, v27, v19);\n    print_board((board_t *)v5);\n    libmin_mgets(s, 0x40uLL, infile);\n  }\n  v8 = 0;\n  if ( v7 == 2 )\n    goto LABEL_11;\nLABEL_7:\n  if ( v26 == byte_D354 && v27 == byte_D355 || v7 != 3 && v26 == byte_D356 && v27 == byte_D357 )\n    goto LABEL_11;\n  goto LABEL_10;\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  unsigned char *v5;\n  int i;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  __m128i *v12;\n  __m128i v13;\n  int v14;\n  long long v15;\n  int v16;\n  int v17;\n  char *v18;\n  int v19;\n  unsigned int black_action;\n  int action;\n  int v22;\n  int code;\n  char v24;\n  char v25;\n  char v26;\n  char v27;\n  char s[72];\n  unsigned long long v29;\n  v3 = 1;\n  v4 = 1;\n  v29 = __readfsqword(40u);\n  libmin_mopen(infile, \"r\");\n  v5 = (unsigned char *)libmin_malloc(64uLL);\n  fill_print_initial((board_t *)v5);\n  print_board((board_t *)v5);\n  libmin_mgets(s, 64uLL, infile);\n  for (i = libmin_sscanf(s, \"%c%c-%c%c\\n\", &v24, &v25, &v26, &v27);;\n       i = libmin_sscanf(s, \"%c%c-%c%c\\n\", &v24, &v25, &v26, &v27)) {\n    if (i != 4) {\n      action = v3;\n      if (v24 != 65) {\n        v11 = 100;\n        if (v24 == 80) {\n        LABEL_26:\n          black_action = v4;\n          v22 = v3 + v11;\n          do {\n            v12 = (__m128i *)libmin_malloc(96uLL);\n            v12->m128i_i32[0] = 0;\n            v12->m128i_i8[8] = *v5;\n            v12->m128i_i8[9] = v5[1];\n            v12->m128i_i8[10] = v5[2];\n            v12->m128i_i8[11] = v5[3];\n            v12->m128i_i8[12] = v5[4];\n            v12->m128i_i8[13] = v5[5];\n            v12->m128i_i8[14] = v5[6];\n            v12->m128i_i8[15] = v5[7];\n            v12[1].m128i_i8[0] = v5[8];\n            v12[1].m128i_i8[1] = v5[9];\n            v12[1].m128i_i8[2] = v5[10];\n            v12[1].m128i_i8[3] = v5[11];\n            v12[1].m128i_i8[4] = v5[12];\n            v12[1].m128i_i8[5] = v5[13];\n            v12[1].m128i_i8[6] = v5[14];\n            v12[1].m128i_i8[7] = v5[15];\n            v12[1].m128i_i8[8] = v5[16];\n            v12[1].m128i_i8[9] = v5[17];\n            v12[1].m128i_i8[10] = v5[18];\n            v12[1].m128i_i8[11] = v5[19];\n            v12[1].m128i_i8[12] = v5[20];\n            v12[1].m128i_i8[13] = v5[21];\n            v12[1].m128i_i8[14] = v5[22];\n            v12[1].m128i_i8[15] = v5[23];\n            v12[2].m128i_i8[0] = v5[24];\n            v12[2].m128i_i8[1] = v5[25];\n            v12[2].m128i_i8[2] = v5[26];\n            v12[2].m128i_i8[3] = v5[27];\n            v12[2].m128i_i8[4] = v5[28];\n            v12[2].m128i_i8[5] = v5[29];\n            v12[2].m128i_i8[6] = v5[30];\n            v12[2].m128i_i8[7] = v5[31];\n            v12[2].m128i_i8[8] = v5[32];\n            v12[2].m128i_i8[9] = v5[33];\n            v12[2].m128i_i8[10] = v5[34];\n            v12[2].m128i_i8[11] = v5[35];\n            v12[2].m128i_i8[12] = v5[36];\n            v12[2].m128i_i8[13] = v5[37];\n            v12[2].m128i_i8[14] = v5[38];\n            v12[2].m128i_i8[15] = v5[39];\n            v12[3].m128i_i8[0] = v5[40];\n            v12[3].m128i_i8[1] = v5[41];\n            v12[3].m128i_i8[2] = v5[42];\n            v12[3].m128i_i8[3] = v5[43];\n            v12[3].m128i_i8[4] = v5[44];\n            v12[3].m128i_i8[5] = v5[45];\n            v12[3].m128i_i8[6] = v5[46];\n            v12[3].m128i_i8[7] = v5[47];\n            v12[3].m128i_i8[8] = v5[48];\n            v12[3].m128i_i8[9] = v5[49];\n            v12[3].m128i_i8[10] = v5[50];\n            v12[3].m128i_i8[11] = v5[51];\n            v12[3].m128i_i8[12] = v5[52];\n            v12[3].m128i_i8[13] = v5[53];\n            v12[3].m128i_i8[14] = v5[54];\n            v12[3].m128i_i8[15] = v5[55];\n            v12[4].m128i_i8[0] = v5[56];\n            v12[4].m128i_i8[1] = v5[57];\n            v12[4].m128i_i8[2] = v5[58];\n            v12[4].m128i_i8[3] = v5[59];\n            v12[4].m128i_i8[4] = v5[60];\n            v12[4].m128i_i8[5] = v5[61];\n            v12[4].m128i_i8[6] = v5[62];\n            v12[4].m128i_i8[7] = v5[63];\n            v13 = _mm_loadu_si128((const __m128i *)&initial_children);\n            v12[4].m128i_i64[1] = black_action;\n            v12[5] = v13;\n            generate_tree_depth_3((tree_node_t *)v12);\n            if (!v12[4].m128i_i32[3]) {\n              if (black_action) {\n                libmin_printf(\"%s WIN!\\n\", WHITE);\n                libmin_success();\n              }\n              libmin_printf(\"%s WIN!\\n\", BLACK);\n              libmin_success();\n            }\n            v14 = move_score_forced((tree_node_t *)v12);\n            v15 = v12[5].m128i_i64[0];\n            v16 = v14;\n            if (v12[4].m128i_i32[3] <= 0) main_cold();\n            v17 = 0;\n            do {\n              v18 = *(char **)v15;\n              if (move_score_forced(*(tree_node_t **)v15) == v16) break;\n              v15 = *(uint64_t *)(v15 + 8);\n              ++v17;\n            } while (v12[4].m128i_i32[3] > v17);\n            change_board((board_t *)v5, v18[4], v18[5], v18[6], v18[7]);\n            print_move_information(1, black_action, (unsigned char(*)[8])v5,\n                                   v18[4], v18[5], v18[6], v18[7], action);\n            print_board((board_t *)v5);\n            ++action;\n            black_action ^= 1u;\n            free_tree((tree_node_t *)v12);\n          } while (v22 != action);\n        }\n        libmin_free(v5);\n        libmin_success();\n      }\n      v11 = 1;\n      goto LABEL_26;\n    }\n    v10 = check_move_error_1_to_5((unsigned char(*)[8])v5, v24, v25, v26, v27,\n                                  v4);\n    if (v10) {\n      code = v10;\n      print_error_message(v10);\n      libmin_fail(code);\n    }\n    v7 = all_possible_moves((unsigned char(*)[8])v5, v24, v25,\n                            (square_t *)valid_moves_0, v4);\n    if (v7 <= 0) {\n    LABEL_15:\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    if (v26 == valid_moves_0[0] && valid_moves_0[1] == v27) {\n      if (v7 == 1) goto LABEL_11;\n      v8 = 0;\n    } else {\n      v8 = 1;\n      if (v7 == 1) goto LABEL_15;\n    }\n    if (v26 == byte_D352 && v27 == byte_D353) break;\n    if (v7 != 2) goto LABEL_7;\n  LABEL_10:\n    if (v8) goto LABEL_15;\n  LABEL_11:\n    change_board((board_t *)v5, v24, v25, v26, v27);\n    v19 = v3;\n    v9 = v4;\n    v4 ^= 1u;\n    ++v3;\n    print_move_information(0, v9, (unsigned char(*)[8])v5, v24, v25, v26, v27,\n                           v19);\n    print_board((board_t *)v5);\n    libmin_mgets(s, 64uLL, infile);\n  }\n  v8 = 0;\n  if (v7 == 2) goto LABEL_11;\nLABEL_7:\n  if (v26 == byte_D354 && v27 == byte_D355 ||\n      v7 != 3 && v26 == byte_D356 && v27 == byte_D357)\n    goto LABEL_11;\n  goto LABEL_10;\n}", "binary": "checkers/checkers.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nlea    0x8ec7(%rip),%rsi\npush   %r14\npush   %r13\nlea    0xc208(%rip),%r13\npush   %r12\nmov    $0x1,%r12d\npush   %rbp\nmov    $0x1,%ebp\npush   %rbx\nsub    $0x88,%rsp\nmov    0xbebb(%rip),%rdi\nmov    %fs:0x28,%rax\nmov    %rax,0x78(%rsp)\nxor    %eax,%eax\nlea    0x30(%rsp),%rbx\nlea    0x2e(%rsp),%r14\ncall   6df0 <libmin_mopen>\nmov    $0x40,%edi\ncall   67c0 <libmin_malloc>\nmov    %rax,%r15\nmov    %rax,%rdi\ncall   18e0 <fill_print_initial>\nmov    %r15,%rdi\ncall   1ff0 <print_board>\nmov    0xbe78(%rip),%rdx\nmov    $0x40,%esi\nmov    %rbx,%rdi\ncall   6c10 <libmin_mgets>\nlea    0x2f(%rsp),%rax\nmov    %rax,0x10(%rsp)\nlea    0x2d(%rsp),%rax\nmov    %rax,0x8(%rsp)\nlea    0x2c(%rsp),%rax\nmov    %rax,(%rsp)\njmp    12b9 <main+0x189>\nnopw   0x0(%rax,%rax,1)\nmovsbl 0x2d(%rsp),%edx\nmovsbl 0x2c(%rsp),%esi\nmov    %ebp,%r8d\nmov    %r13,%rcx\nmov    %r15,%rdi\ncall   22b0 <all_possible_moves>\ntest   %eax,%eax\njle    1325 <main+0x1f5>\nmovzbl 0x2e(%rsp),%edx\nmovsbl 0x2f(%rsp),%r8d\ncmp    0x0(%r13),%dl\nje     1349 <main+0x219>\nmov    $0x1,%ecx\ncmp    $0x1,%eax\nje     1325 <main+0x1f5>\ncmp    0xc129(%rip),%dl\nje     1370 <main+0x240>\ncmp    $0x2,%eax\nje     1251 <main+0x121>\ncmp    0xc11a(%rip),%dl\nje     1390 <main+0x260>\ncmp    $0x3,%eax\nje     1251 <main+0x121>\ncmp    0xc10b(%rip),%dl\nje     17bf <main+0x68f>\ntest   %ecx,%ecx\njne    1325 <main+0x1f5>\nmovsbl 0x2c(%rsp),%esi\nmovsbl %dl,%ecx\nmovsbl 0x2d(%rsp),%edx\nmov    %r15,%rdi\ncall   21b0 <change_board>\nmovsbl 0x2c(%rsp),%ecx\npush   %r12\nmov    %ebp,%esi\nmovsbl 0x37(%rsp),%eax\nmov    %r15,%rdx\nxor    %edi,%edi\nxor    $0x1,%ebp\nadd    $0x1,%r12d\npush   %rax\nmovsbl 0x3e(%rsp),%r9d\nmovsbl 0x3d(%rsp),%r8d\ncall   30c0 <print_move_information>\nmov    %r15,%rdi\ncall   1ff0 <print_board>\nmov    0xbd77(%rip),%rdx\nmov    %rbx,%rdi\nmov    $0x40,%esi\ncall   6c10 <libmin_mgets>\npop    %rdi\npop    %r8\nmov    0x10(%rsp),%r9\nmov    0x8(%rsp),%rcx\nxor    %eax,%eax\nmov    %r14,%r8\nmov    (%rsp),%rdx\nlea    0x8e1f(%rip),%rsi\nmov    %rbx,%rdi\ncall   8f40 <libmin_sscanf>\ncmp    $0x4,%eax\njne    13a2 <main+0x272>\nmovsbl 0x2e(%rsp),%ecx\nmovsbl 0x2d(%rsp),%edx\nmov    %r15,%rdi\nmov    %ebp,%r9d\nmovsbl 0x2c(%rsp),%esi\nmovsbl 0x2f(%rsp),%r8d\ncall   20c0 <check_move_error_1_to_5>\nmov    %eax,%edi\ntest   %eax,%eax\nje     11e0 <main+0xb0>\nmov    %eax,0x1c(%rsp)\ncall   2d10 <print_error_message>\nmov    0x1c(%rsp),%edi\ncall   67a0 <libmin_fail>\njmp    11e0 <main+0xb0>\nmov    $0x6,%edi\ncall   2d10 <print_error_message>\nmov    $0x6,%edi\ncall   67a0 <libmin_fail>\nmovsbl 0x2f(%rsp),%r8d\nmovzbl 0x2e(%rsp),%edx\njmp    1259 <main+0x129>\ncmp    %r8b,0xc001(%rip)\njne    1215 <main+0xe5>\ncmp    $0x1,%eax\nje     1259 <main+0x129>\nxor    %ecx,%ecx\njmp    1223 <main+0xf3>\ncs nopw 0x0(%rax,%rax,1)\ncmp    0xbfdc(%rip),%r8b\njne    122f <main+0xff>\nxor    %ecx,%ecx\ncmp    $0x2,%eax\njne    1234 <main+0x104>\njmp    1259 <main+0x129>\nnopl   (%rax)\ncmp    0xbfbe(%rip),%r8b\njne    1240 <main+0x110>\njmp    1259 <main+0x129>\nmovzbl 0x2c(%rsp),%eax\nmov    %r12d,0x8(%rsp)\ncmp    $0x41,%al\nje     17d1 <main+0x6a1>\nmov    $0x64,%r13d\ncmp    $0x50,%al\njne    176f <main+0x63f>\nadd    0x8(%rsp),%r13d\nmov    %ebp,(%rsp)\nmov    %r13d,0x10(%rsp)\nnop\nmov    $0x60,%edi\ncall   67c0 <libmin_malloc>\nmov    %rax,%r12\nmovl   $0x0,(%rax)\nmovzbl (%r15),%eax\nmov    %r12,%rdi\nmov    %al,0x8(%r12)\nmovzbl 0x1(%r15),%eax\nmov    %al,0x9(%r12)\nmovzbl 0x2(%r15),%eax\nmov    %al,0xa(%r12)\nmovzbl 0x3(%r15),%eax\nmov    %al,0xb(%r12)\nmovzbl 0x4(%r15),%eax\nmov    %al,0xc(%r12)\nmovzbl 0x5(%r15),%eax\nmov    %al,0xd(%r12)\nmovzbl 0x6(%r15),%eax\nmov    %al,0xe(%r12)\nmovzbl 0x7(%r15),%eax\nmov    %al,0xf(%r12)\nmovzbl 0x8(%r15),%eax\nmov    %al,0x10(%r12)\nmovzbl 0x9(%r15),%eax\nmov    %al,0x11(%r12)\nmovzbl 0xa(%r15),%eax\nmov    %al,0x12(%r12)\nmovzbl 0xb(%r15),%eax\nmov    %al,0x13(%r12)\nmovzbl 0xc(%r15),%eax\nmov    %al,0x14(%r12)\nmovzbl 0xd(%r15),%eax\nmov    %al,0x15(%r12)\nmovzbl 0xe(%r15),%eax\nmov    %al,0x16(%r12)\nmovzbl 0xf(%r15),%eax\nmov    %al,0x17(%r12)\nmovzbl 0x10(%r15),%eax\nmov    %al,0x18(%r12)\nmovzbl 0x11(%r15),%eax\nmov    %al,0x19(%r12)\nmovzbl 0x12(%r15),%eax\nmov    %al,0x1a(%r12)\nmovzbl 0x13(%r15),%eax\nmov    %al,0x1b(%r12)\nmovzbl 0x14(%r15),%eax\nmov    %al,0x1c(%r12)\nmovzbl 0x15(%r15),%eax\nmov    %al,0x1d(%r12)\nmovzbl 0x16(%r15),%eax\nmov    %al,0x1e(%r12)\nmovzbl 0x17(%r15),%eax\nmov    %al,0x1f(%r12)\nmovzbl 0x18(%r15),%eax\nmov    %al,0x20(%r12)\nmovzbl 0x19(%r15),%eax\nmov    %al,0x21(%r12)\nmovzbl 0x1a(%r15),%eax\nmov    %al,0x22(%r12)\nmovzbl 0x1b(%r15),%eax\nmov    %al,0x23(%r12)\nmovzbl 0x1c(%r15),%eax\nmov    %al,0x24(%r12)\nmovzbl 0x1d(%r15),%eax\nmov    %al,0x25(%r12)\nmovzbl 0x1e(%r15),%eax\nmov    %al,0x26(%r12)\nmovzbl 0x1f(%r15),%eax\nmov    %al,0x27(%r12)\nmovzbl 0x20(%r15),%eax\nmov    %al,0x28(%r12)\nmovzbl 0x21(%r15),%eax\nmov    %al,0x29(%r12)\nmovzbl 0x22(%r15),%eax\nmov    %al,0x2a(%r12)\nmovzbl 0x23(%r15),%eax\nmov    %al,0x2b(%r12)\nmovzbl 0x24(%r15),%eax\nmov    %al,0x2c(%r12)\nmovzbl 0x25(%r15),%eax\nmov    %al,0x2d(%r12)\nmovzbl 0x26(%r15),%eax\nmov    %al,0x2e(%r12)\nmovzbl 0x27(%r15),%eax\nmov    %al,0x2f(%r12)\nmovzbl 0x28(%r15),%eax\nmov    %al,0x30(%r12)\nmovzbl 0x29(%r15),%eax\nmov    %al,0x31(%r12)\nmovzbl 0x2a(%r15),%eax\nmov    %al,0x32(%r12)\nmovzbl 0x2b(%r15),%eax\nmov    %al,0x33(%r12)\nmovzbl 0x2c(%r15),%eax\nmov    %al,0x34(%r12)\nmovzbl 0x2d(%r15),%eax\nmov    %al,0x35(%r12)\nmovzbl 0x2e(%r15),%eax\nmov    %al,0x36(%r12)\nmovzbl 0x2f(%r15),%eax\nmov    %al,0x37(%r12)\nmovzbl 0x30(%r15),%eax\nmov    %al,0x38(%r12)\nmovzbl 0x31(%r15),%eax\nmov    %al,0x39(%r12)\nmovzbl 0x32(%r15),%eax\nmov    %al,0x3a(%r12)\nmovzbl 0x33(%r15),%eax\nmov    %al,0x3b(%r12)\nmovzbl 0x34(%r15),%eax\nmov    %al,0x3c(%r12)\nmovzbl 0x35(%r15),%eax\nmov    %al,0x3d(%r12)\nmovzbl 0x36(%r15),%eax\nmov    %al,0x3e(%r12)\nmovzbl 0x37(%r15),%eax\nmov    %al,0x3f(%r12)\nmovzbl 0x38(%r15),%eax\nmov    %al,0x40(%r12)\nmovzbl 0x39(%r15),%eax\nmov    %al,0x41(%r12)\nmovzbl 0x3a(%r15),%eax\nmov    %al,0x42(%r12)\nmovzbl 0x3b(%r15),%eax\nmov    %al,0x43(%r12)\nmovzbl 0x3c(%r15),%eax\nmov    %al,0x44(%r12)\nmovzbl 0x3d(%r15),%eax\nmov    %al,0x45(%r12)\nmovzbl 0x3e(%r15),%eax\nmov    %al,0x46(%r12)\nmovzbl 0x3f(%r15),%eax\nmov    %al,0x47(%r12)\nmov    (%rsp),%ebx\nmovdqu 0xbcf0(%rip),%xmm0\nmovl   $0x0,0x4c(%r12)\nmov    %ebx,0x48(%r12)\nmovups %xmm0,0x50(%r12)\ncall   3700 <generate_tree_depth_3>\nmov    0x4c(%r12),%esi\ntest   %esi,%esi\njne    16b4 <main+0x584>\ntest   %ebx,%ebx\nje     17a0 <main+0x670>\nlea    0xb9ff(%rip),%rsi\nlea    0x895e(%rip),%rdi\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\ncall   94c0 <libmin_success>\nmov    %r12,%rdi\ncall   3df0 <move_score_forced>\nmov    0x4c(%r12),%ecx\nmov    0x50(%r12),%rbp\nmov    %eax,%ebx\ntest   %ecx,%ecx\njle    1120 <main.cold>\nxor    %r13d,%r13d\njmp    16e7 <main+0x5b7>\nnopl   (%rax)\nmov    0x8(%rbp),%rbp\nadd    $0x1,%r13d\ncmp    %r13d,0x4c(%r12)\njle    16f7 <main+0x5c7>\nmov    0x0(%rbp),%r14\nmov    %r14,%rdi\ncall   3df0 <move_score_forced>\ncmp    %ebx,%eax\njne    16d8 <main+0x5a8>\nmovsbl 0x6(%r14),%ecx\nmovsbl 0x5(%r14),%edx\nmov    %r15,%rdi\nmovsbl 0x4(%r14),%esi\nmovsbl 0x7(%r14),%r8d\ncall   21b0 <change_board>\nmov    0x8(%rsp),%ebx\nmovsbl 0x6(%r14),%r9d\nmov    %r15,%rdx\nmovsbl 0x5(%r14),%r8d\nmovsbl 0x4(%r14),%ecx\nmov    $0x1,%edi\npush   %rbx\nmovsbl 0x7(%r14),%eax\nadd    $0x1,%ebx\npush   %rax\nmov    0x10(%rsp),%r14d\nmov    %r14d,%esi\ncall   30c0 <print_move_information>\nmov    %r15,%rdi\ncall   1ff0 <print_board>\nmov    %r14d,%eax\nmov    %r12,%rdi\nmov    %ebx,0x18(%rsp)\nxor    $0x1,%eax\nmov    %eax,0x10(%rsp)\ncall   6210 <free_tree>\npop    %rax\npop    %rdx\ncmp    %ebx,0x10(%rsp)\njne    13d0 <main+0x2a0>\nmov    %r15,%rdi\ncall   6870 <libmin_free>\ncall   94c0 <libmin_success>\nmov    0x78(%rsp),%rax\nsub    %fs:0x28,%rax\njne    17dc <main+0x6ac>\nadd    $0x88,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0xb8ff(%rip),%rsi\nlea    0x8858(%rip),%rdi\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\ncall   94c0 <libmin_success>\njmp    16b4 <main+0x584>\ncmp    0xbb91(%rip),%r8b\njne    1251 <main+0x121>\njmp    1259 <main+0x129>\nmov    $0x1,%r13d\njmp    13c2 <main+0x292>\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "min", "content": "// simple function to return the smaller of two integers, \n\t// if it is the same, it returns the number\nint min(int a, int b) {\n\tif (a < b) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn b;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "min", "address": "0x2d00", "label": "min", "content": "int __fastcall min(int a, int b)\n{\n  int result; // eax\n\n  result = b;\n  if ( a <= b )\n    return a;\n  return result;\n}\n"}, "pseudo_normalize": "int min(int a, int b) {\n  int result;\n  result = b;\n  if (a <= b) return a;\n  return result;\n}", "binary": "checkers/checkers.host.O3", "assembly": "<min>:\nendbr64\ncmp    %esi,%edi\nmov    %esi,%eax\ncmovle %edi,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "movable_checker", "content": "// check whether a given square contains a movable checker depending on the turn\nint movable_checker(int black_action, char checker) {\n\tif ((black_action) && ((checker == CELL_BPIECE) || \n\t\t\t(checker == CELL_BTOWER))) {\n\t\treturn 1;\n\t}\n\telse if ((!black_action) && ((checker == CELL_WPIECE) || \n\t\t\t(checker == CELL_WTOWER))) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "movable_checker", "address": "0x3490", "label": "movable_checker", "content": "int __fastcall movable_checker(int black_action, char checker)\n{\n  char v2; // si\n\n  v2 = checker & 0xDF;\n  if ( black_action )\n    return v2 == 66;\n  else\n    return v2 == 87;\n}\n"}, "pseudo_normalize": "int movable_checker(int black_action, char checker) {\n  char v2;\n  v2 = checker & 223;\n  if (black_action)\n    return v2 == 66;\n  else\n    return v2 == 87;\n}", "binary": "checkers/checkers.host.O3", "assembly": "<movable_checker>:\nendbr64\nand    $0xffffffdf,%esi\ntest   %edi,%edi\nje     34a8 <movable_checker+0x18>\nxor    %eax,%eax\ncmp    $0x42,%sil\nsete   %al\nret\nnopl   (%rax)\nxor    %eax,%eax\ncmp    $0x57,%sil\nsete   %al\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "move_score_forced", "content": "// recursively find the forced best score of an option branch\n\t// applies the minimax decision rule and assumes player rationality\n\t// according to this rule\nint move_score_forced(tree_node_t* node) {\n\t// base case, we have reached a leaf\n\tif (node->children_count == 0) {\n\t\t// note: if the leaf is less than depth 3, we return int_min/max\n\t\t\t// as specified in the assignment\n\t\tif (node->depth != 3) {\n\t\t\tif (node->black_action) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint leaf_cost = board_cost(node->board_state);\n\t\treturn leaf_cost;\n\t}\n\t\n\t// recursive case\n\telse {\n\t\tint max_score = INT_MIN, min_score = INT_MAX;\n\t\tlinked_list_member_t* list_member = (node->children_list).first;\n\t\ttree_node_t* child_node;\n\t\t// iterate through children to find scores\n\t\tfor (int i=0; i<(node->children_count); i++) {\n\t\t\tchild_node = (tree_node_t*)(list_member->child_node);\n\t\t\tint child_score = move_score_forced(child_node);\n\t\t\tif (child_score > max_score) {\n\t\t\t\tmax_score = child_score;\n\t\t\t}\n\t\t\tif (child_score < min_score) {\n\t\t\t\tmin_score = child_score;\n\t\t\t}\n\t\t\tlist_member = list_member->next;\n\t\t}\n\t\t\n\t\t// black and white make rational actions!!\n\t\tif (node->black_action) {\n\t\t\treturn max_score;\n\t\t}\n\t\telse {\n\t\t\treturn min_score;\n\t\t}\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "move_score_forced", "address": "0x3df0", "label": "move_score_forced", "content": "int __fastcall move_score_forced(tree_node_t *node)\n{\n  int children_count; // esi\n  int result; // eax\n  linked_list_member_t *first; // rax\n  char *child_node; // rax\n  int v6; // edx\n  bool v7; // zf\n  int v8; // eax\n  unsigned int v9; // eax\n  _QWORD *v10; // rax\n  __int64 v11; // rax\n  int v12; // edx\n  bool v13; // zf\n  int v14; // eax\n  unsigned int v15; // eax\n  _QWORD *v16; // rax\n  __int64 v17; // rax\n  int v18; // esi\n  int v19; // r15d\n  int v20; // eax\n  unsigned int v21; // eax\n  _QWORD *v22; // rax\n  __int64 v23; // rax\n  int v24; // ebx\n  int v25; // r14d\n  int v26; // eax\n  unsigned int v27; // eax\n  _QWORD *v28; // rax\n  __int64 v29; // rax\n  int v30; // ecx\n  int v31; // r13d\n  int v32; // eax\n  unsigned int v33; // eax\n  _QWORD *v34; // rax\n  __int64 v35; // rax\n  int v36; // ebx\n  int v37; // r12d\n  int v38; // eax\n  unsigned int v39; // eax\n  _QWORD *v40; // rax\n  __int64 v41; // rax\n  int v42; // esi\n  int v43; // ebp\n  int v44; // eax\n  unsigned int v45; // eax\n  __int64 *v46; // rax\n  __int64 v47; // rbp\n  int v48; // r15d\n  bool j; // cc\n  int v50; // ebx\n  int v51; // eax\n  unsigned int v52; // eax\n  __int64 v53; // r13\n  int v54; // ebx\n  int v55; // r14d\n  signed int v56; // r12d\n  int v57; // eax\n  signed int v58; // eax\n  signed int v59; // eax\n  signed int v60; // edx\n  signed int v61; // eax\n  signed int v62; // edx\n  signed int v63; // eax\n  signed int v64; // edx\n  int v65; // eax\n  signed int v66; // ebx\n  char *v67; // rax\n  char *v68; // r8\n  int v69; // edx\n  int v70; // esi\n  int v71; // ecx\n  char v72; // di\n  char v73; // di\n  char v74; // di\n  char v75; // di\n  char v76; // di\n  char v77; // di\n  char v78; // di\n  char v79; // di\n  int v80; // eax\n  signed int v81; // esi\n  signed int v82; // eax\n  int v83; // eax\n  signed int v84; // ecx\n  __int64 v85; // rcx\n  int v86; // r8d\n  char *v87; // rax\n  int v88; // edi\n  char *v89; // r14\n  int v90; // esi\n  int v91; // ecx\n  char v92; // dl\n  char v93; // dl\n  char v94; // dl\n  char v95; // dl\n  char v96; // dl\n  char v97; // dl\n  signed int v98; // eax\n  signed int v99; // ecx\n  int v100; // eax\n  signed int v101; // esi\n  __int64 v102; // rbx\n  int v103; // edi\n  char *v104; // rax\n  int v105; // edx\n  char *v106; // r8\n  int v107; // esi\n  int v108; // ecx\n  char v109; // r9\n  char v110; // r9\n  char v111; // r9\n  char v112; // r9\n  char v113; // r9\n  char v114; // r9\n  char v115; // r9\n  char v116; // r9\n  int v117; // ebx\n  int v118; // eax\n  signed int v119; // eax\n  signed int v120; // ebx\n  int v121; // eax\n  signed int v122; // edx\n  __int64 v123; // rsi\n  int v124; // edi\n  char *v125; // rax\n  int v126; // edx\n  char *v127; // r8\n  int v128; // ecx\n  int v129; // esi\n  char v130; // r9\n  char v131; // r9\n  char v132; // r9\n  char v133; // r9\n  char v134; // r9\n  char v135; // r9\n  char v136; // r9\n  char v137; // r9\n  int v138; // eax\n  signed int v139; // esi\n  signed int v140; // eax\n  signed int v141; // eax\n  signed int v142; // ecx\n  int v143; // eax\n  signed int v144; // edx\n  __int64 v145; // rcx\n  int v146; // edi\n  char *v147; // rax\n  int v148; // edx\n  char *v149; // r8\n  int v150; // esi\n  int v151; // ecx\n  char v152; // r9\n  char v153; // r9\n  char v154; // r9\n  char v155; // r9\n  char v156; // r9\n  char v157; // r9\n  char v158; // r9\n  char v159; // r9\n  int v160; // eax\n  signed int v161; // esi\n  signed int v162; // eax\n  signed int v163; // eax\n  int v164; // ebx\n  int v165; // eax\n  signed int v166; // esi\n  __int64 v167; // rbx\n  int v168; // edi\n  char *v169; // rax\n  int v170; // edx\n  char *v171; // r8\n  int v172; // esi\n  int v173; // ecx\n  char v174; // r9\n  char v175; // r9\n  char v176; // r9\n  char v177; // r9\n  char v178; // r9\n  char v179; // r9\n  char v180; // r9\n  char v181; // r9\n  int v182; // eax\n  signed int v183; // ecx\n  int v184; // eax\n  signed int v185; // eax\n  int v186; // edx\n  __int64 v187; // rcx\n  int v188; // edi\n  char *v189; // rax\n  int v190; // edx\n  char *v191; // r8\n  int v192; // esi\n  int v193; // ecx\n  char v194; // r9\n  char v195; // r9\n  char v196; // r9\n  char v197; // r9\n  char v198; // r9\n  char v199; // r9\n  char v200; // r9\n  char v201; // r9\n  int v202; // eax\n  signed int v203; // edx\n  char v204; // dl\n  char v205; // dl\n  int v206; // eax\n  signed int v207; // ecx\n  int v208; // edi\n  int *p_black_action; // r8\n  unsigned __int8 *v210; // rsi\n  int v211; // ecx\n  int v212; // eax\n  int v213; // edx\n  unsigned __int8 v214; // r9\n  unsigned __int8 v215; // r9\n  unsigned __int8 v216; // r9\n  unsigned __int8 v217; // r9\n  unsigned __int8 v218; // r9\n  unsigned __int8 v219; // r9\n  unsigned __int8 v220; // r9\n  unsigned __int8 v221; // r9\n  char *v222; // rbx\n  int v223; // edi\n  char *v224; // rax\n  int v225; // edx\n  char *v226; // r8\n  int v227; // esi\n  int v228; // ecx\n  char v229; // r9\n  char v230; // r9\n  char v231; // r9\n  char v232; // r9\n  char v233; // r9\n  char v234; // r9\n  char v235; // r9\n  char v236; // r9\n  int v237; // eax\n  int v238; // ecx\n  int v239; // eax\n  __int64 *v240; // [rsp+0h] [rbp-138h]\n  int v241; // [rsp+8h] [rbp-130h]\n  signed int v242; // [rsp+Ch] [rbp-12Ch]\n  int v243; // [rsp+10h] [rbp-128h]\n  int v244; // [rsp+14h] [rbp-124h]\n  _QWORD *v245; // [rsp+18h] [rbp-120h]\n  int v246; // [rsp+20h] [rbp-118h]\n  signed int v247; // [rsp+24h] [rbp-114h]\n  __int64 v248; // [rsp+28h] [rbp-110h]\n  int v249; // [rsp+30h] [rbp-108h]\n  int v250; // [rsp+34h] [rbp-104h]\n  _QWORD *v251; // [rsp+38h] [rbp-100h]\n  int v252; // [rsp+40h] [rbp-F8h]\n  signed int v253; // [rsp+44h] [rbp-F4h]\n  __int64 v254; // [rsp+48h] [rbp-F0h]\n  int v255; // [rsp+50h] [rbp-E8h]\n  int v256; // [rsp+54h] [rbp-E4h]\n  _QWORD *v257; // [rsp+58h] [rbp-E0h]\n  int v258; // [rsp+60h] [rbp-D8h]\n  int v259; // [rsp+64h] [rbp-D4h]\n  __int64 v260; // [rsp+68h] [rbp-D0h]\n  signed int v261; // [rsp+70h] [rbp-C8h]\n  int v262; // [rsp+74h] [rbp-C4h]\n  _QWORD *v263; // [rsp+78h] [rbp-C0h]\n  int v264; // [rsp+80h] [rbp-B8h]\n  signed int v265; // [rsp+84h] [rbp-B4h]\n  __int64 v266; // [rsp+88h] [rbp-B0h]\n  int v267; // [rsp+90h] [rbp-A8h]\n  int v268; // [rsp+94h] [rbp-A4h]\n  _QWORD *v269; // [rsp+98h] [rbp-A0h]\n  int v270; // [rsp+A0h] [rbp-98h]\n  signed int v271; // [rsp+A4h] [rbp-94h]\n  int v272; // [rsp+A8h] [rbp-90h]\n  signed int max_score; // [rsp+ACh] [rbp-8Ch]\n  __int64 v274; // [rsp+B0h] [rbp-88h]\n  int v275; // [rsp+B8h] [rbp-80h]\n  int v276; // [rsp+BCh] [rbp-7Ch]\n  _QWORD *v277; // [rsp+C0h] [rbp-78h]\n  int min_score; // [rsp+C8h] [rbp-70h]\n  int v279; // [rsp+CCh] [rbp-6Ch]\n  __int64 v280; // [rsp+D0h] [rbp-68h]\n  signed int v281; // [rsp+D8h] [rbp-60h]\n  int i; // [rsp+DCh] [rbp-5Ch]\n  char *v283; // [rsp+E0h] [rbp-58h]\n  tree_node_t **p_child_node; // [rsp+E8h] [rbp-50h]\n  int v285; // [rsp+F0h] [rbp-48h]\n  int v286; // [rsp+F4h] [rbp-44h]\n\n  children_count = node->children_count;\n  v286 = children_count;\n  if ( !children_count )\n  {\n    if ( node->depth != 3 )\n      return 0x7FFFFFFF - ((node->black_action == 0) - 1);\n    v208 = 0;\n    p_black_action = &node->black_action;\n    v210 = node->board_state[0];\n    v211 = 0;\n    v212 = 0;\n    v213 = 0;\n    while ( 1 )\n    {\n      v221 = *v210;\n      if ( *v210 == 98 )\n      {\n        v214 = v210[1];\n        ++v208;\n        if ( v214 == 98 )\n          goto LABEL_717;\nLABEL_687:\n        switch ( v214 )\n        {\n          case 'B':\n            ++v213;\n            break;\n          case 'w':\n            ++v211;\n            break;\n          case 'W':\n            ++v212;\n            break;\n        }\n        v215 = v210[2];\n        if ( v215 != 98 )\n          goto LABEL_691;\nLABEL_718:\n        v216 = v210[3];\n        ++v208;\n        if ( v216 == 98 )\n          goto LABEL_719;\nLABEL_695:\n        switch ( v216 )\n        {\n          case 'B':\n            ++v213;\n            break;\n          case 'w':\n            ++v211;\n            break;\n          case 'W':\n            ++v212;\n            break;\n        }\n        v217 = v210[4];\n        if ( v217 != 98 )\n          goto LABEL_699;\nLABEL_720:\n        v218 = v210[5];\n        ++v208;\n        if ( v218 == 98 )\n          goto LABEL_721;\nLABEL_703:\n        switch ( v218 )\n        {\n          case 'B':\n            ++v213;\n            break;\n          case 'w':\n            ++v211;\n            break;\n          case 'W':\n            ++v212;\n            break;\n        }\n        v219 = v210[6];\n        if ( v219 != 98 )\n          goto LABEL_707;\nLABEL_722:\n        v220 = v210[7];\n        ++v208;\n        if ( v220 != 98 )\n          goto LABEL_711;\nLABEL_723:\n        v210 += 8;\n        ++v208;\n        if ( p_black_action == (int *)v210 )\n          return v208 + 3 * v213 - v211 - 3 * v212;\n      }\n      else\n      {\n        switch ( v221 )\n        {\n          case 'B':\n            ++v213;\n            break;\n          case 'w':\n            ++v211;\n            break;\n          case 'W':\n            ++v212;\n            break;\n        }\n        v214 = v210[1];\n        if ( v214 != 98 )\n          goto LABEL_687;\nLABEL_717:\n        v215 = v210[2];\n        ++v208;\n        if ( v215 == 98 )\n          goto LABEL_718;\nLABEL_691:\n        switch ( v215 )\n        {\n          case 'B':\n            ++v213;\n            break;\n          case 'w':\n            ++v211;\n            break;\n          case 'W':\n            ++v212;\n            break;\n        }\n        v216 = v210[3];\n        if ( v216 != 98 )\n          goto LABEL_695;\nLABEL_719:\n        v217 = v210[4];\n        ++v208;\n        if ( v217 == 98 )\n          goto LABEL_720;\nLABEL_699:\n        switch ( v217 )\n        {\n          case 'B':\n            ++v213;\n            break;\n          case 'w':\n            ++v211;\n            break;\n          case 'W':\n            ++v212;\n            break;\n        }\n        v218 = v210[5];\n        if ( v218 != 98 )\n          goto LABEL_703;\nLABEL_721:\n        v219 = v210[6];\n        ++v208;\n        if ( v219 == 98 )\n          goto LABEL_722;\nLABEL_707:\n        switch ( v219 )\n        {\n          case 'B':\n            ++v213;\n            break;\n          case 'w':\n            ++v211;\n            break;\n          case 'W':\n            ++v212;\n            break;\n        }\n        v220 = v210[7];\n        if ( v220 == 98 )\n          goto LABEL_723;\nLABEL_711:\n        switch ( v220 )\n        {\n          case 'B':\n            ++v213;\n            break;\n          case 'w':\n            ++v211;\n            break;\n          case 'W':\n            ++v212;\n            break;\n        }\n        v210 += 8;\n        if ( p_black_action == (int *)v210 )\n          return v208 + 3 * v213 - v211 - 3 * v212;\n      }\n    }\n  }\n  if ( children_count > 0 )\n  {\n    i = 0;\n    first = node->children_list.first;\n    min_score = 0x7FFFFFFF;\n    p_child_node = (tree_node_t **)first;\n    max_score = 0x80000000;\n    while ( 1 )\n    {\n      child_node = (char *)first->child_node;\n      v6 = *((_DWORD *)child_node + 19);\n      v283 = child_node;\n      v285 = v6;\n      if ( !v6 )\n        break;\n      if ( v6 > 0 )\n      {\n        v275 = 0;\n        v10 = (_QWORD *)*((_QWORD *)child_node + 10);\n        v279 = 0x7FFFFFFF;\n        v277 = v10;\n        v281 = 0x80000000;\n        while ( 1 )\n        {\n          v11 = *v10;\n          v12 = *(_DWORD *)(v11 + 76);\n          v280 = v11;\n          v276 = v12;\n          if ( !v12 )\n            break;\n          if ( v12 > 0 )\n          {\n            v268 = 0;\n            v16 = *(_QWORD **)(v11 + 80);\n            v272 = 0x7FFFFFFF;\n            v269 = v16;\n            v271 = 0x80000000;\n            while ( 1 )\n            {\n              v17 = *v16;\n              v18 = *(_DWORD *)(v17 + 76);\n              v274 = v17;\n              v270 = v18;\n              if ( !v18 )\n                break;\n              if ( v18 > 0 )\n              {\n                v22 = *(_QWORD **)(v17 + 80);\n                v262 = 0;\n                v267 = 0x7FFFFFFF;\n                v263 = v22;\n                v265 = 0x80000000;\n                while ( 1 )\n                {\n                  v23 = *v22;\n                  v24 = *(_DWORD *)(v23 + 76);\n                  v266 = v23;\n                  v264 = v24;\n                  if ( !v24 )\n                    break;\n                  if ( v24 > 0 )\n                  {\n                    v28 = *(_QWORD **)(v23 + 80);\n                    v256 = 0;\n                    v259 = 0x7FFFFFFF;\n                    v257 = v28;\n                    v261 = 0x80000000;\n                    while ( 1 )\n                    {\n                      v29 = *v28;\n                      v30 = *(_DWORD *)(v29 + 76);\n                      v260 = v29;\n                      v258 = v30;\n                      if ( !v30 )\n                        break;\n                      if ( v30 > 0 )\n                      {\n                        v34 = *(_QWORD **)(v29 + 80);\n                        v250 = 0;\n                        v255 = 0x7FFFFFFF;\n                        v251 = v34;\n                        v253 = 0x80000000;\n                        while ( 1 )\n                        {\n                          v35 = *v34;\n                          v36 = *(_DWORD *)(v35 + 76);\n                          v254 = v35;\n                          v252 = v36;\n                          if ( !v36 )\n                            break;\n                          if ( v36 > 0 )\n                          {\n                            v40 = *(_QWORD **)(v35 + 80);\n                            v244 = 0;\n                            v249 = 0x7FFFFFFF;\n                            v245 = v40;\n                            v247 = 0x80000000;\n                            while ( 1 )\n                            {\n                              v41 = *v40;\n                              v42 = *(_DWORD *)(v41 + 76);\n                              v248 = v41;\n                              v246 = v42;\n                              if ( !v42 )\n                                break;\n                              if ( v42 > 0 )\n                              {\n                                v46 = *(__int64 **)(v41 + 80);\n                                v241 = 0;\n                                v243 = 0x7FFFFFFF;\n                                v47 = *v46;\n                                v240 = v46;\n                                v242 = 0x80000000;\n                                v48 = *(_DWORD *)(*v46 + 76);\n                                for ( j = v48 <= 0; v48; j = v48 <= 0 )\n                                {\n                                  if ( j )\n                                  {\n                                    v55 = 0x7FFFFFFF;\n                                    v56 = 0x80000000;\n                                  }\n                                  else\n                                  {\n                                    v53 = *(_QWORD *)(v47 + 80);\n                                    v54 = 0;\n                                    v55 = 0x7FFFFFFF;\n                                    v56 = 0x80000000;\n                                    while ( 1 )\n                                    {\n                                      v57 = move_score_forced(*(tree_node_t **)v53);\n                                      if ( v56 < v57 )\n                                        v56 = v57;\n                                      if ( v55 > v57 )\n                                        v55 = v57;\n                                      if ( v48 == ++v54 )\n                                        break;\n                                      v53 = *(_QWORD *)(v53 + 8);\n                                    }\n                                  }\n                                  v58 = v242;\n                                  if ( *(_DWORD *)(v47 + 72) )\n                                  {\n                                    if ( v242 < v56 )\n                                      v58 = v56;\n                                    v242 = v58;\n                                    if ( v243 <= v56 )\n                                      v56 = v243;\n                                    ++v241;\n                                    v243 = v56;\n                                    if ( v246 == v241 )\n                                      goto LABEL_106;\n                                  }\n                                  else\n                                  {\n                                    if ( v242 < v55 )\n                                      v58 = v55;\n                                    v242 = v58;\n                                    if ( v243 <= v55 )\n                                      v55 = v243;\n                                    v243 = v55;\nLABEL_89:\n                                    if ( v246 == ++v241 )\n                                      goto LABEL_106;\n                                  }\n                                  v47 = *(_QWORD *)v240[1];\n                                  v240 = (__int64 *)v240[1];\n                                  v48 = *(_DWORD *)(v47 + 76);\n                                }\n                                if ( *(_DWORD *)v47 != 3 )\n                                {\n                                  v50 = *(_DWORD *)(v47 + 72);\n                                  v51 = 0x7FFFFFFF;\n                                  if ( v50 )\n                                    v51 = v242;\n                                  v242 = v51;\n                                  v52 = 0x80000000;\n                                  if ( !v50 )\n                                    v52 = v243;\n                                  v243 = v52;\n                                  goto LABEL_89;\n                                }\n                                v67 = (char *)(v47 + 8);\n                                v68 = (char *)(v47 + 72);\n                                v69 = 0;\n                                v70 = 0;\n                                v71 = 0;\n                                while ( 2 )\n                                {\n                                  v79 = *v67;\n                                  if ( *v67 == 98 )\n                                  {\n                                    ++v48;\n                                  }\n                                  else\n                                  {\n                                    switch ( v79 )\n                                    {\n                                      case 'B':\n                                        v72 = v67[1];\n                                        ++v71;\n                                        if ( v72 == 98 )\n                                        {\nLABEL_169:\n                                          v73 = v67[2];\n                                          ++v48;\n                                          if ( v73 == 98 )\n                                            goto LABEL_170;\nLABEL_142:\n                                          switch ( v73 )\n                                          {\n                                            case 'B':\n                                              ++v71;\n                                              break;\n                                            case 'w':\n                                              ++v70;\n                                              break;\n                                            case 'W':\n                                              ++v69;\n                                              break;\n                                          }\n                                          v74 = v67[3];\n                                          if ( v74 != 98 )\n                                            goto LABEL_146;\nLABEL_171:\n                                          v75 = v67[4];\n                                          ++v48;\n                                          if ( v75 == 98 )\n                                            goto LABEL_172;\nLABEL_150:\n                                          switch ( v75 )\n                                          {\n                                            case 'B':\n                                              ++v71;\n                                              break;\n                                            case 'w':\n                                              ++v70;\n                                              break;\n                                            case 'W':\n                                              ++v69;\n                                              break;\n                                          }\n                                          v76 = v67[5];\n                                          if ( v76 != 98 )\n                                            goto LABEL_154;\nLABEL_173:\n                                          v77 = v67[6];\n                                          ++v48;\n                                          if ( v77 == 98 )\n                                            goto LABEL_174;\nLABEL_158:\n                                          switch ( v77 )\n                                          {\n                                            case 'B':\n                                              ++v71;\n                                              break;\n                                            case 'w':\n                                              ++v70;\n                                              break;\n                                            case 'W':\n                                              ++v69;\n                                              break;\n                                          }\n                                          v78 = v67[7];\n                                          if ( v78 == 98 )\n                                          {\nLABEL_175:\n                                            v67 += 8;\n                                            ++v48;\n                                            if ( v67 == v68 )\n                                              goto LABEL_176;\n                                            continue;\n                                          }\n                                          goto LABEL_162;\n                                        }\nLABEL_138:\n                                        switch ( v72 )\n                                        {\n                                          case 'B':\n                                            ++v71;\n                                            break;\n                                          case 'w':\n                                            ++v70;\n                                            break;\n                                          case 'W':\n                                            ++v69;\n                                            break;\n                                        }\n                                        v73 = v67[2];\n                                        if ( v73 != 98 )\n                                          goto LABEL_142;\nLABEL_170:\n                                        v74 = v67[3];\n                                        ++v48;\n                                        if ( v74 == 98 )\n                                          goto LABEL_171;\nLABEL_146:\n                                        switch ( v74 )\n                                        {\n                                          case 'B':\n                                            ++v71;\n                                            break;\n                                          case 'w':\n                                            ++v70;\n                                            break;\n                                          case 'W':\n                                            ++v69;\n                                            break;\n                                        }\n                                        v75 = v67[4];\n                                        if ( v75 != 98 )\n                                          goto LABEL_150;\nLABEL_172:\n                                        v76 = v67[5];\n                                        ++v48;\n                                        if ( v76 == 98 )\n                                          goto LABEL_173;\nLABEL_154:\n                                        switch ( v76 )\n                                        {\n                                          case 'B':\n                                            ++v71;\n                                            break;\n                                          case 'w':\n                                            ++v70;\n                                            break;\n                                          case 'W':\n                                            ++v69;\n                                            break;\n                                        }\n                                        v77 = v67[6];\n                                        if ( v77 != 98 )\n                                          goto LABEL_158;\nLABEL_174:\n                                        v78 = v67[7];\n                                        ++v48;\n                                        if ( v78 == 98 )\n                                          goto LABEL_175;\nLABEL_162:\n                                        switch ( v78 )\n                                        {\n                                          case 'B':\n                                            ++v71;\n                                            break;\n                                          case 'w':\n                                            ++v70;\n                                            break;\n                                          case 'W':\n                                            ++v69;\n                                            break;\n                                        }\n                                        v67 += 8;\n                                        if ( v67 == v68 )\n                                        {\nLABEL_176:\n                                          v80 = v48 + 3 * v71 - v70;\n                                          v81 = v242;\n                                          v82 = -3 * v69 + v80;\n                                          if ( v242 < v82 )\n                                            v81 = v82;\n                                          v242 = v81;\n                                          if ( v243 <= v82 )\n                                            v82 = v243;\n                                          v243 = v82;\n                                          goto LABEL_89;\n                                        }\n                                        continue;\n                                      case 'w':\n                                        ++v70;\n                                        break;\n                                      case 'W':\n                                        ++v69;\n                                        break;\n                                    }\n                                  }\n                                  break;\n                                }\n                                v72 = v67[1];\n                                if ( v72 == 98 )\n                                  goto LABEL_169;\n                                goto LABEL_138;\n                              }\n                              v243 = 0x7FFFFFFF;\n                              v242 = 0x80000000;\nLABEL_106:\n                              if ( *(_DWORD *)(v248 + 72) )\n                              {\n                                v59 = v242;\n                                v60 = v247;\n                                if ( v247 < v242 )\n                                  v60 = v242;\n                                v247 = v60;\n                                if ( v249 <= v242 )\n                                  v59 = v249;\n                                ++v244;\n                                v249 = v59;\n                                if ( v252 == v244 )\n                                  goto LABEL_112;\n                              }\n                              else\n                              {\n                                v65 = v243;\n                                v66 = v247;\n                                if ( v247 < v243 )\n                                  v66 = v243;\n                                v247 = v66;\n                                if ( v249 <= v243 )\n                                  v65 = v249;\n                                v249 = v65;\nLABEL_79:\n                                if ( v252 == ++v244 )\n                                  goto LABEL_112;\n                              }\n                              v40 = (_QWORD *)v245[1];\n                              v245 = v40;\n                            }\n                            if ( *(_DWORD *)v41 != 3 )\n                            {\n                              v43 = *(_DWORD *)(v41 + 72);\n                              v44 = 0x7FFFFFFF;\n                              if ( v43 )\n                                v44 = v247;\n                              v247 = v44;\n                              v45 = 0x80000000;\n                              if ( !v43 )\n                                v45 = v249;\n                              v249 = v45;\n                              goto LABEL_79;\n                            }\n                            v85 = v41;\n                            v86 = 0;\n                            v87 = (char *)(v41 + 8);\n                            v88 = 0;\n                            v89 = (char *)(v85 + 72);\n                            v90 = 0;\n                            v91 = 0;\n                            while ( 2 )\n                            {\n                              v92 = *v87;\n                              if ( *v87 == 98 )\n                              {\n                                v93 = v87[1];\n                                ++v86;\n                                if ( v93 != 98 )\n                                  goto LABEL_217;\n                              }\n                              else\n                              {\n                                switch ( v92 )\n                                {\n                                  case 'B':\n                                    ++v90;\n                                    break;\n                                  case 'w':\n                                    ++v88;\n                                    break;\n                                  case 'W':\n                                    ++v91;\n                                    break;\n                                }\n                                v93 = v87[1];\n                                if ( v93 != 98 )\n                                {\nLABEL_217:\n                                  switch ( v93 )\n                                  {\n                                    case 'B':\n                                      ++v90;\n                                      break;\n                                    case 'w':\n                                      ++v88;\n                                      break;\n                                    case 'W':\n                                      ++v91;\n                                      break;\n                                  }\n                                  v94 = v87[2];\n                                  if ( v94 != 98 )\n                                  {\nLABEL_221:\n                                    switch ( v94 )\n                                    {\n                                      case 'B':\n                                        ++v90;\n                                        break;\n                                      case 'w':\n                                        ++v88;\n                                        break;\n                                      case 'W':\n                                        ++v91;\n                                        break;\n                                    }\n                                    v95 = v87[3];\n                                    if ( v95 != 98 )\n                                    {\nLABEL_225:\n                                      switch ( v95 )\n                                      {\n                                        case 'B':\n                                          ++v90;\n                                          break;\n                                        case 'w':\n                                          ++v88;\n                                          break;\n                                        case 'W':\n                                          ++v91;\n                                          break;\n                                      }\n                                      v96 = v87[4];\n                                      if ( v96 != 98 )\n                                      {\nLABEL_229:\n                                        switch ( v96 )\n                                        {\n                                          case 'B':\n                                            v97 = v87[5];\n                                            ++v90;\n                                            if ( v97 == 98 )\n                                              goto LABEL_231;\nLABEL_666:\n                                            switch ( v97 )\n                                            {\n                                              case 'B':\n                                                ++v90;\n                                                break;\n                                              case 'w':\n                                                ++v88;\n                                                break;\n                                              case 'W':\n                                                ++v91;\n                                                break;\n                                            }\n                                            goto LABEL_668;\n                                          case 'w':\n                                            ++v88;\n                                            break;\n                                          case 'W':\n                                            ++v91;\n                                            break;\n                                        }\nLABEL_665:\n                                        v97 = v87[5];\n                                        if ( v97 != 98 )\n                                          goto LABEL_666;\nLABEL_231:\n                                        ++v86;\nLABEL_668:\n                                        v204 = v87[6];\n                                        switch ( v204 )\n                                        {\n                                          case 'b':\n                                            ++v86;\n                                            break;\n                                          case 'B':\n                                            ++v90;\n                                            break;\n                                          case 'w':\n                                            ++v88;\n                                            break;\n                                          case 'W':\n                                            ++v91;\n                                            break;\n                                        }\n                                        v205 = v87[7];\n                                        switch ( v205 )\n                                        {\n                                          case 'b':\n                                            ++v86;\n                                            break;\n                                          case 'B':\n                                            ++v90;\n                                            break;\n                                          case 'w':\n                                            ++v88;\n                                            break;\n                                          case 'W':\n                                            ++v91;\n                                            break;\n                                        }\n                                        v87 += 8;\n                                        if ( v89 == v87 )\n                                        {\n                                          v206 = -3 * v91 + v86 + 3 * v90 - v88;\n                                          v207 = v247;\n                                          if ( v247 < v206 )\n                                            v207 = v206;\n                                          if ( v249 <= v206 )\n                                            v206 = v249;\n                                          v247 = v207;\n                                          v249 = v206;\n                                          goto LABEL_79;\n                                        }\n                                        continue;\n                                      }\nLABEL_236:\n                                      ++v86;\n                                      goto LABEL_665;\n                                    }\nLABEL_235:\n                                    v96 = v87[4];\n                                    ++v86;\n                                    if ( v96 != 98 )\n                                      goto LABEL_229;\n                                    goto LABEL_236;\n                                  }\nLABEL_234:\n                                  v95 = v87[3];\n                                  ++v86;\n                                  if ( v95 != 98 )\n                                    goto LABEL_225;\n                                  goto LABEL_235;\n                                }\n                              }\n                              break;\n                            }\n                            v94 = v87[2];\n                            ++v86;\n                            if ( v94 != 98 )\n                              goto LABEL_221;\n                            goto LABEL_234;\n                          }\n                          v249 = 0x7FFFFFFF;\n                          v247 = 0x80000000;\nLABEL_112:\n                          if ( *(_DWORD *)(v254 + 72) )\n                          {\n                            v61 = v247;\n                            v62 = v253;\n                            if ( v253 < v247 )\n                              v62 = v247;\n                            if ( v255 <= v247 )\n                              v61 = v255;\n                            ++v250;\n                            v253 = v62;\n                            v255 = v61;\n                            if ( v258 == v250 )\n                              goto LABEL_118;\n                          }\n                          else\n                          {\n                            v83 = v249;\n                            v84 = v253;\n                            if ( v253 < v249 )\n                              v84 = v249;\n                            if ( v255 <= v249 )\n                              v83 = v255;\n                            v253 = v84;\n                            v255 = v83;\nLABEL_68:\n                            if ( v258 == ++v250 )\n                              goto LABEL_118;\n                          }\n                          v34 = (_QWORD *)v251[1];\n                          v251 = v34;\n                        }\n                        if ( *(_DWORD *)v35 != 3 )\n                        {\n                          v37 = *(_DWORD *)(v35 + 72);\n                          v38 = 0x7FFFFFFF;\n                          if ( v37 )\n                            v38 = v253;\n                          v253 = v38;\n                          v39 = 0x80000000;\n                          if ( !v37 )\n                            v39 = v255;\n                          v255 = v39;\n                          goto LABEL_68;\n                        }\n                        v102 = v35;\n                        v103 = 0;\n                        v104 = (char *)(v35 + 8);\n                        v105 = 0;\n                        v106 = (char *)(v102 + 72);\n                        v107 = 0;\n                        v108 = 0;\n                        while ( 2 )\n                        {\n                          v116 = *v104;\n                          if ( *v104 == 98 )\n                          {\n                            ++v103;\n                          }\n                          else\n                          {\n                            switch ( v116 )\n                            {\n                              case 'B':\n                                v109 = v104[1];\n                                ++v108;\n                                if ( v109 == 98 )\n                                {\nLABEL_291:\n                                  v110 = v104[2];\n                                  ++v103;\n                                  if ( v110 == 98 )\n                                    goto LABEL_292;\nLABEL_264:\n                                  switch ( v110 )\n                                  {\n                                    case 'B':\n                                      ++v108;\n                                      break;\n                                    case 'w':\n                                      ++v107;\n                                      break;\n                                    case 'W':\n                                      ++v105;\n                                      break;\n                                  }\n                                  v111 = v104[3];\n                                  if ( v111 != 98 )\n                                    goto LABEL_268;\nLABEL_293:\n                                  v112 = v104[4];\n                                  ++v103;\n                                  if ( v112 == 98 )\n                                    goto LABEL_294;\nLABEL_272:\n                                  switch ( v112 )\n                                  {\n                                    case 'B':\n                                      ++v108;\n                                      break;\n                                    case 'w':\n                                      ++v107;\n                                      break;\n                                    case 'W':\n                                      ++v105;\n                                      break;\n                                  }\n                                  v113 = v104[5];\n                                  if ( v113 != 98 )\n                                    goto LABEL_276;\nLABEL_295:\n                                  v114 = v104[6];\n                                  ++v103;\n                                  if ( v114 == 98 )\n                                    goto LABEL_296;\nLABEL_280:\n                                  switch ( v114 )\n                                  {\n                                    case 'B':\n                                      ++v108;\n                                      break;\n                                    case 'w':\n                                      ++v107;\n                                      break;\n                                    case 'W':\n                                      ++v105;\n                                      break;\n                                  }\n                                  v115 = v104[7];\n                                  if ( v115 == 98 )\n                                  {\nLABEL_297:\n                                    v104 += 8;\n                                    ++v103;\n                                    if ( v106 == v104 )\n                                      goto LABEL_298;\n                                    continue;\n                                  }\n                                  goto LABEL_284;\n                                }\nLABEL_260:\n                                switch ( v109 )\n                                {\n                                  case 'B':\n                                    ++v108;\n                                    break;\n                                  case 'w':\n                                    ++v107;\n                                    break;\n                                  case 'W':\n                                    ++v105;\n                                    break;\n                                }\n                                v110 = v104[2];\n                                if ( v110 != 98 )\n                                  goto LABEL_264;\nLABEL_292:\n                                v111 = v104[3];\n                                ++v103;\n                                if ( v111 == 98 )\n                                  goto LABEL_293;\nLABEL_268:\n                                switch ( v111 )\n                                {\n                                  case 'B':\n                                    ++v108;\n                                    break;\n                                  case 'w':\n                                    ++v107;\n                                    break;\n                                  case 'W':\n                                    ++v105;\n                                    break;\n                                }\n                                v112 = v104[4];\n                                if ( v112 != 98 )\n                                  goto LABEL_272;\nLABEL_294:\n                                v113 = v104[5];\n                                ++v103;\n                                if ( v113 == 98 )\n                                  goto LABEL_295;\nLABEL_276:\n                                switch ( v113 )\n                                {\n                                  case 'B':\n                                    ++v108;\n                                    break;\n                                  case 'w':\n                                    ++v107;\n                                    break;\n                                  case 'W':\n                                    ++v105;\n                                    break;\n                                }\n                                v114 = v104[6];\n                                if ( v114 != 98 )\n                                  goto LABEL_280;\nLABEL_296:\n                                v115 = v104[7];\n                                ++v103;\n                                if ( v115 == 98 )\n                                  goto LABEL_297;\nLABEL_284:\n                                switch ( v115 )\n                                {\n                                  case 'B':\n                                    ++v108;\n                                    break;\n                                  case 'w':\n                                    ++v107;\n                                    break;\n                                  case 'W':\n                                    ++v105;\n                                    break;\n                                }\n                                v104 += 8;\n                                if ( v106 == v104 )\n                                {\nLABEL_298:\n                                  v117 = v253;\n                                  v118 = -3 * v105 + v103 + 3 * v108 - v107;\n                                  if ( v253 < v118 )\n                                    v117 = -3 * v105 + v103 + 3 * v108 - v107;\n                                  if ( v255 <= v118 )\n                                    v118 = v255;\n                                  v253 = v117;\n                                  v255 = v118;\n                                  goto LABEL_68;\n                                }\n                                continue;\n                              case 'w':\n                                ++v107;\n                                break;\n                              case 'W':\n                                ++v105;\n                                break;\n                            }\n                          }\n                          break;\n                        }\n                        v109 = v104[1];\n                        if ( v109 == 98 )\n                          goto LABEL_291;\n                        goto LABEL_260;\n                      }\n                      v255 = 0x7FFFFFFF;\n                      v253 = 0x80000000;\nLABEL_118:\n                      if ( *(_DWORD *)(v260 + 72) )\n                      {\n                        v63 = v253;\n                        v64 = v261;\n                        if ( v261 < v253 )\n                          v64 = v253;\n                        if ( v259 <= v253 )\n                          v63 = v259;\n                        v261 = v64;\n                        v259 = v63;\n                      }\n                      else\n                      {\n                        v100 = v255;\n                        v101 = v261;\n                        if ( v261 < v255 )\n                          v101 = v255;\n                        if ( v259 <= v255 )\n                          v100 = v259;\n                        v261 = v101;\n                        v259 = v100;\n                      }\nLABEL_57:\n                      if ( v264 == ++v256 )\n                        goto LABEL_241;\n                      v28 = (_QWORD *)v257[1];\n                      v257 = v28;\n                    }\n                    if ( *(_DWORD *)v29 != 3 )\n                    {\n                      v31 = *(_DWORD *)(v29 + 72);\n                      v32 = 0x7FFFFFFF;\n                      if ( v31 )\n                        v32 = v261;\n                      v261 = v32;\n                      v33 = 0x80000000;\n                      if ( !v31 )\n                        v33 = v259;\n                      v259 = v33;\n                      goto LABEL_57;\n                    }\n                    v123 = v29;\n                    v124 = 0;\n                    v125 = (char *)(v29 + 8);\n                    v126 = 0;\n                    v127 = (char *)(v123 + 72);\n                    v128 = 0;\n                    v129 = 0;\n                    while ( 2 )\n                    {\n                      while ( 2 )\n                      {\n                        v136 = *v125;\n                        if ( *v125 == 98 )\n                        {\n                          ++v124;\n                        }\n                        else\n                        {\n                          switch ( v136 )\n                          {\n                            case 'B':\n                              ++v128;\n                              break;\n                            case 'w':\n                              ++v129;\n                              break;\n                            case 'W':\n                              ++v126;\n                              break;\n                          }\n                        }\n                        v137 = v125[1];\n                        if ( v137 == 98 )\n                        {\n                          v130 = v125[2];\n                          ++v124;\n                          if ( v130 == 98 )\n                            goto LABEL_375;\nLABEL_345:\n                          switch ( v130 )\n                          {\n                            case 'B':\n                              ++v128;\n                              break;\n                            case 'w':\n                              ++v129;\n                              break;\n                            case 'W':\n                              ++v126;\n                              break;\n                          }\n                          v131 = v125[3];\n                          if ( v131 != 98 )\n                            goto LABEL_349;\nLABEL_376:\n                          v132 = v125[4];\n                          ++v124;\n                          if ( v132 == 98 )\n                            goto LABEL_377;\nLABEL_353:\n                          switch ( v132 )\n                          {\n                            case 'B':\n                              ++v128;\n                              break;\n                            case 'w':\n                              ++v129;\n                              break;\n                            case 'W':\n                              ++v126;\n                              break;\n                          }\n                          v133 = v125[5];\n                          if ( v133 != 98 )\n                            goto LABEL_357;\nLABEL_378:\n                          v134 = v125[6];\n                          ++v124;\n                          if ( v134 == 98 )\n                            goto LABEL_379;\nLABEL_361:\n                          switch ( v134 )\n                          {\n                            case 'B':\n                              ++v128;\n                              break;\n                            case 'w':\n                              ++v129;\n                              break;\n                            case 'W':\n                              ++v126;\n                              break;\n                          }\n                          v135 = v125[7];\n                          if ( v135 == 98 )\n                          {\nLABEL_380:\n                            v125 += 8;\n                            ++v124;\n                            if ( v125 == v127 )\n                              goto LABEL_381;\n                            continue;\n                          }\n                        }\n                        else\n                        {\n                          switch ( v137 )\n                          {\n                            case 'B':\n                              ++v128;\n                              break;\n                            case 'w':\n                              ++v129;\n                              break;\n                            case 'W':\n                              ++v126;\n                              break;\n                          }\n                          v130 = v125[2];\n                          if ( v130 != 98 )\n                            goto LABEL_345;\nLABEL_375:\n                          v131 = v125[3];\n                          ++v124;\n                          if ( v131 == 98 )\n                            goto LABEL_376;\nLABEL_349:\n                          switch ( v131 )\n                          {\n                            case 'B':\n                              ++v128;\n                              break;\n                            case 'w':\n                              ++v129;\n                              break;\n                            case 'W':\n                              ++v126;\n                              break;\n                          }\n                          v132 = v125[4];\n                          if ( v132 != 98 )\n                            goto LABEL_353;\nLABEL_377:\n                          v133 = v125[5];\n                          ++v124;\n                          if ( v133 == 98 )\n                            goto LABEL_378;\nLABEL_357:\n                          switch ( v133 )\n                          {\n                            case 'B':\n                              ++v128;\n                              break;\n                            case 'w':\n                              ++v129;\n                              break;\n                            case 'W':\n                              ++v126;\n                              break;\n                          }\n                          v134 = v125[6];\n                          if ( v134 != 98 )\n                            goto LABEL_361;\nLABEL_379:\n                          v135 = v125[7];\n                          ++v124;\n                          if ( v135 == 98 )\n                            goto LABEL_380;\n                        }\n                        break;\n                      }\n                      switch ( v135 )\n                      {\n                        case 'B':\n                          ++v128;\n                          break;\n                        case 'w':\n                          ++v129;\n                          break;\n                        case 'W':\n                          ++v126;\n                          break;\n                      }\n                      v125 += 8;\n                      if ( v125 == v127 )\n                      {\nLABEL_381:\n                        v138 = v124 + 3 * v128 - v129;\n                        v139 = v261;\n                        v140 = -3 * v126 + v138;\n                        if ( v261 < v140 )\n                          v139 = v140;\n                        if ( v259 <= v140 )\n                          v140 = v259;\n                        v261 = v139;\n                        v259 = v140;\n                        goto LABEL_57;\n                      }\n                      continue;\n                    }\n                  }\n                  v259 = 0x7FFFFFFF;\n                  v261 = 0x80000000;\nLABEL_241:\n                  if ( *(_DWORD *)(v266 + 72) )\n                  {\n                    v98 = v261;\n                    v99 = v265;\n                    if ( v265 < v261 )\n                      v99 = v261;\n                    if ( v267 <= v261 )\n                      v98 = v267;\n                    v265 = v99;\n                    v267 = v98;\n                  }\n                  else\n                  {\n                    v121 = v259;\n                    v122 = v265;\n                    if ( v265 < v259 )\n                      v122 = v259;\n                    if ( v267 <= v259 )\n                      v121 = v267;\n                    v265 = v122;\n                    v267 = v121;\n                  }\nLABEL_46:\n                  if ( v270 == ++v262 )\n                    goto LABEL_328;\n                  v22 = (_QWORD *)v263[1];\n                  v263 = v22;\n                }\n                if ( *(_DWORD *)v23 != 3 )\n                {\n                  v25 = *(_DWORD *)(v23 + 72);\n                  v26 = 0x7FFFFFFF;\n                  if ( v25 )\n                    v26 = v265;\n                  v265 = v26;\n                  v27 = 0x80000000;\n                  if ( !v25 )\n                    v27 = v267;\n                  v267 = v27;\n                  goto LABEL_46;\n                }\n                v145 = v23;\n                v146 = 0;\n                v147 = (char *)(v23 + 8);\n                v148 = 0;\n                v149 = (char *)(v145 + 72);\n                v150 = 0;\n                v151 = 0;\n                while ( 2 )\n                {\n                  v159 = *v147;\n                  if ( *v147 == 98 )\n                  {\n                    ++v146;\n                  }\n                  else\n                  {\n                    switch ( v159 )\n                    {\n                      case 'B':\n                        v152 = v147[1];\n                        ++v151;\n                        if ( v152 == 98 )\n                        {\nLABEL_461:\n                          v153 = v147[2];\n                          ++v146;\n                          if ( v153 == 98 )\n                            goto LABEL_462;\nLABEL_434:\n                          switch ( v153 )\n                          {\n                            case 'B':\n                              ++v151;\n                              break;\n                            case 'w':\n                              ++v150;\n                              break;\n                            case 'W':\n                              ++v148;\n                              break;\n                          }\n                          v154 = v147[3];\n                          if ( v154 != 98 )\n                            goto LABEL_438;\nLABEL_463:\n                          v155 = v147[4];\n                          ++v146;\n                          if ( v155 == 98 )\n                            goto LABEL_464;\nLABEL_442:\n                          switch ( v155 )\n                          {\n                            case 'B':\n                              ++v151;\n                              break;\n                            case 'w':\n                              ++v150;\n                              break;\n                            case 'W':\n                              ++v148;\n                              break;\n                          }\n                          v156 = v147[5];\n                          if ( v156 != 98 )\n                            goto LABEL_446;\nLABEL_465:\n                          v157 = v147[6];\n                          ++v146;\n                          if ( v157 == 98 )\n                            goto LABEL_466;\nLABEL_450:\n                          switch ( v157 )\n                          {\n                            case 'B':\n                              ++v151;\n                              break;\n                            case 'w':\n                              ++v150;\n                              break;\n                            case 'W':\n                              ++v148;\n                              break;\n                          }\n                          v158 = v147[7];\n                          if ( v158 == 98 )\n                          {\nLABEL_467:\n                            v147 += 8;\n                            ++v146;\n                            if ( v147 == v149 )\n                              goto LABEL_468;\n                            continue;\n                          }\n                          goto LABEL_454;\n                        }\nLABEL_430:\n                        switch ( v152 )\n                        {\n                          case 'B':\n                            ++v151;\n                            break;\n                          case 'w':\n                            ++v150;\n                            break;\n                          case 'W':\n                            ++v148;\n                            break;\n                        }\n                        v153 = v147[2];\n                        if ( v153 != 98 )\n                          goto LABEL_434;\nLABEL_462:\n                        v154 = v147[3];\n                        ++v146;\n                        if ( v154 == 98 )\n                          goto LABEL_463;\nLABEL_438:\n                        switch ( v154 )\n                        {\n                          case 'B':\n                            ++v151;\n                            break;\n                          case 'w':\n                            ++v150;\n                            break;\n                          case 'W':\n                            ++v148;\n                            break;\n                        }\n                        v155 = v147[4];\n                        if ( v155 != 98 )\n                          goto LABEL_442;\nLABEL_464:\n                        v156 = v147[5];\n                        ++v146;\n                        if ( v156 == 98 )\n                          goto LABEL_465;\nLABEL_446:\n                        switch ( v156 )\n                        {\n                          case 'B':\n                            ++v151;\n                            break;\n                          case 'w':\n                            ++v150;\n                            break;\n                          case 'W':\n                            ++v148;\n                            break;\n                        }\n                        v157 = v147[6];\n                        if ( v157 != 98 )\n                          goto LABEL_450;\nLABEL_466:\n                        v158 = v147[7];\n                        ++v146;\n                        if ( v158 == 98 )\n                          goto LABEL_467;\nLABEL_454:\n                        switch ( v158 )\n                        {\n                          case 'B':\n                            ++v151;\n                            break;\n                          case 'w':\n                            ++v150;\n                            break;\n                          case 'W':\n                            ++v148;\n                            break;\n                        }\n                        v147 += 8;\n                        if ( v147 == v149 )\n                        {\nLABEL_468:\n                          v160 = v146 + 3 * v151 - v150;\n                          v161 = v265;\n                          v162 = -3 * v148 + v160;\n                          if ( v265 < v162 )\n                            v161 = v162;\n                          v265 = v161;\n                          if ( v267 <= v162 )\n                            v162 = v267;\n                          v267 = v162;\n                          goto LABEL_46;\n                        }\n                        continue;\n                      case 'w':\n                        ++v150;\n                        break;\n                      case 'W':\n                        ++v148;\n                        break;\n                    }\n                  }\n                  break;\n                }\n                v152 = v147[1];\n                if ( v152 == 98 )\n                  goto LABEL_461;\n                goto LABEL_430;\n              }\n              v267 = 0x7FFFFFFF;\n              v265 = 0x80000000;\nLABEL_328:\n              if ( *(_DWORD *)(v274 + 72) )\n              {\n                v119 = v265;\n                v120 = v271;\n                if ( v271 < v265 )\n                  v120 = v265;\n                v271 = v120;\n                if ( v272 <= v265 )\n                  v119 = v272;\n                v272 = v119;\n              }\n              else\n              {\n                v143 = v267;\n                v144 = v271;\n                if ( v271 < v267 )\n                  v144 = v267;\n                v271 = v144;\n                if ( v272 <= v267 )\n                  v143 = v272;\n                v272 = v143;\n              }\nLABEL_35:\n              if ( v276 == ++v268 )\n                goto LABEL_412;\n              v16 = (_QWORD *)v269[1];\n              v269 = v16;\n            }\n            if ( *(_DWORD *)v17 != 3 )\n            {\n              v19 = *(_DWORD *)(v17 + 72);\n              v20 = 0x7FFFFFFF;\n              if ( v19 )\n                v20 = v271;\n              v271 = v20;\n              v21 = 0x80000000;\n              if ( !v19 )\n                v21 = v272;\n              v272 = v21;\n              goto LABEL_35;\n            }\n            v167 = v17;\n            v168 = 0;\n            v169 = (char *)(v17 + 8);\n            v170 = 0;\n            v171 = (char *)(v167 + 72);\n            v172 = 0;\n            v173 = 0;\n            while ( 2 )\n            {\n              v181 = *v169;\n              if ( *v169 == 98 )\n              {\n                ++v168;\n              }\n              else\n              {\n                switch ( v181 )\n                {\n                  case 'B':\n                    v174 = v169[1];\n                    ++v173;\n                    if ( v174 == 98 )\n                    {\nLABEL_544:\n                      v175 = v169[2];\n                      ++v168;\n                      if ( v175 == 98 )\n                        goto LABEL_545;\nLABEL_517:\n                      switch ( v175 )\n                      {\n                        case 'B':\n                          ++v173;\n                          break;\n                        case 'w':\n                          ++v172;\n                          break;\n                        case 'W':\n                          ++v170;\n                          break;\n                      }\n                      v176 = v169[3];\n                      if ( v176 != 98 )\n                        goto LABEL_521;\nLABEL_546:\n                      v177 = v169[4];\n                      ++v168;\n                      if ( v177 == 98 )\n                        goto LABEL_547;\nLABEL_525:\n                      switch ( v177 )\n                      {\n                        case 'B':\n                          ++v173;\n                          break;\n                        case 'w':\n                          ++v172;\n                          break;\n                        case 'W':\n                          ++v170;\n                          break;\n                      }\n                      v178 = v169[5];\n                      if ( v178 != 98 )\n                        goto LABEL_529;\nLABEL_548:\n                      v179 = v169[6];\n                      ++v168;\n                      if ( v179 == 98 )\n                        goto LABEL_549;\nLABEL_533:\n                      switch ( v179 )\n                      {\n                        case 'B':\n                          ++v173;\n                          break;\n                        case 'w':\n                          ++v172;\n                          break;\n                        case 'W':\n                          ++v170;\n                          break;\n                      }\n                      v180 = v169[7];\n                      if ( v180 == 98 )\n                      {\nLABEL_550:\n                        v169 += 8;\n                        ++v168;\n                        if ( v169 == v171 )\n                          goto LABEL_551;\n                        continue;\n                      }\n                      goto LABEL_537;\n                    }\nLABEL_513:\n                    switch ( v174 )\n                    {\n                      case 'B':\n                        ++v173;\n                        break;\n                      case 'w':\n                        ++v172;\n                        break;\n                      case 'W':\n                        ++v170;\n                        break;\n                    }\n                    v175 = v169[2];\n                    if ( v175 != 98 )\n                      goto LABEL_517;\nLABEL_545:\n                    v176 = v169[3];\n                    ++v168;\n                    if ( v176 == 98 )\n                      goto LABEL_546;\nLABEL_521:\n                    switch ( v176 )\n                    {\n                      case 'B':\n                        ++v173;\n                        break;\n                      case 'w':\n                        ++v172;\n                        break;\n                      case 'W':\n                        ++v170;\n                        break;\n                    }\n                    v177 = v169[4];\n                    if ( v177 != 98 )\n                      goto LABEL_525;\nLABEL_547:\n                    v178 = v169[5];\n                    ++v168;\n                    if ( v178 == 98 )\n                      goto LABEL_548;\nLABEL_529:\n                    switch ( v178 )\n                    {\n                      case 'B':\n                        ++v173;\n                        break;\n                      case 'w':\n                        ++v172;\n                        break;\n                      case 'W':\n                        ++v170;\n                        break;\n                    }\n                    v179 = v169[6];\n                    if ( v179 != 98 )\n                      goto LABEL_533;\nLABEL_549:\n                    v180 = v169[7];\n                    ++v168;\n                    if ( v180 == 98 )\n                      goto LABEL_550;\nLABEL_537:\n                    switch ( v180 )\n                    {\n                      case 'B':\n                        ++v173;\n                        break;\n                      case 'w':\n                        ++v172;\n                        break;\n                      case 'W':\n                        ++v170;\n                        break;\n                    }\n                    v169 += 8;\n                    if ( v169 == v171 )\n                    {\nLABEL_551:\n                      v182 = 3 * v173;\n                      v183 = v271;\n                      v184 = -3 * v170 + v168 + v182 - v172;\n                      if ( v271 < v184 )\n                        v183 = v184;\n                      if ( v272 <= v184 )\n                        v184 = v272;\n                      v271 = v183;\n                      v272 = v184;\n                      goto LABEL_35;\n                    }\n                    continue;\n                  case 'w':\n                    ++v172;\n                    break;\n                  case 'W':\n                    ++v170;\n                    break;\n                }\n              }\n              break;\n            }\n            v174 = v169[1];\n            if ( v174 == 98 )\n              goto LABEL_544;\n            goto LABEL_513;\n          }\n          v272 = 0x7FFFFFFF;\n          v271 = 0x80000000;\nLABEL_412:\n          if ( *(_DWORD *)(v280 + 72) )\n          {\n            v141 = v271;\n            v142 = v281;\n            if ( v281 < v271 )\n              v142 = v271;\n            v281 = v142;\n            if ( v279 <= v271 )\n              v141 = v279;\n            v279 = v141;\n          }\n          else\n          {\n            v165 = v272;\n            v166 = v281;\n            if ( v281 < v272 )\n              v166 = v272;\n            v281 = v166;\n            if ( v279 <= v272 )\n              v165 = v279;\n            v279 = v165;\n          }\nLABEL_24:\n          if ( v285 == ++v275 )\n            goto LABEL_498;\n          v10 = (_QWORD *)v277[1];\n          v277 = v10;\n        }\n        if ( *(_DWORD *)v11 != 3 )\n        {\n          v13 = *(_DWORD *)(v11 + 72) == 0;\n          v14 = 0x7FFFFFFF;\n          if ( !v13 )\n            v14 = v281;\n          v281 = v14;\n          v15 = 0x80000000;\n          if ( v13 )\n            v15 = v279;\n          v279 = v15;\n          goto LABEL_24;\n        }\n        v187 = v11;\n        v188 = 0;\n        v189 = (char *)(v11 + 8);\n        v190 = 0;\n        v191 = (char *)(v187 + 72);\n        v192 = 0;\n        v193 = 0;\n        while ( 2 )\n        {\n          while ( 2 )\n          {\n            v201 = *v189;\n            if ( *v189 == 98 )\n            {\n              v194 = v189[1];\n              ++v188;\n              if ( v194 == 98 )\n                goto LABEL_627;\nLABEL_597:\n              switch ( v194 )\n              {\n                case 'B':\n                  ++v193;\n                  break;\n                case 'w':\n                  ++v192;\n                  break;\n                case 'W':\n                  ++v190;\n                  break;\n              }\n              v195 = v189[2];\n              if ( v195 != 98 )\n                goto LABEL_601;\nLABEL_628:\n              v196 = v189[3];\n              ++v188;\n              if ( v196 == 98 )\n                goto LABEL_629;\nLABEL_605:\n              switch ( v196 )\n              {\n                case 'B':\n                  ++v193;\n                  break;\n                case 'w':\n                  ++v192;\n                  break;\n                case 'W':\n                  ++v190;\n                  break;\n              }\n              v197 = v189[4];\n              if ( v197 != 98 )\n                goto LABEL_609;\nLABEL_630:\n              v198 = v189[5];\n              ++v188;\n              if ( v198 == 98 )\n                goto LABEL_631;\nLABEL_613:\n              switch ( v198 )\n              {\n                case 'B':\n                  ++v193;\n                  break;\n                case 'w':\n                  ++v192;\n                  break;\n                case 'W':\n                  ++v190;\n                  break;\n              }\n              v199 = v189[6];\n              if ( v199 != 98 )\n                goto LABEL_617;\nLABEL_632:\n              v200 = v189[7];\n              ++v188;\n              if ( v200 == 98 )\n                goto LABEL_633;\n            }\n            else\n            {\n              switch ( v201 )\n              {\n                case 'B':\n                  ++v193;\n                  break;\n                case 'w':\n                  ++v192;\n                  break;\n                case 'W':\n                  ++v190;\n                  break;\n              }\n              v194 = v189[1];\n              if ( v194 != 98 )\n                goto LABEL_597;\nLABEL_627:\n              v195 = v189[2];\n              ++v188;\n              if ( v195 == 98 )\n                goto LABEL_628;\nLABEL_601:\n              switch ( v195 )\n              {\n                case 'B':\n                  ++v193;\n                  break;\n                case 'w':\n                  ++v192;\n                  break;\n                case 'W':\n                  ++v190;\n                  break;\n              }\n              v196 = v189[3];\n              if ( v196 != 98 )\n                goto LABEL_605;\nLABEL_629:\n              v197 = v189[4];\n              ++v188;\n              if ( v197 == 98 )\n                goto LABEL_630;\nLABEL_609:\n              switch ( v197 )\n              {\n                case 'B':\n                  ++v193;\n                  break;\n                case 'w':\n                  ++v192;\n                  break;\n                case 'W':\n                  ++v190;\n                  break;\n              }\n              v198 = v189[5];\n              if ( v198 != 98 )\n                goto LABEL_613;\nLABEL_631:\n              v199 = v189[6];\n              ++v188;\n              if ( v199 == 98 )\n                goto LABEL_632;\nLABEL_617:\n              switch ( v199 )\n              {\n                case 'B':\n                  ++v193;\n                  break;\n                case 'w':\n                  ++v192;\n                  break;\n                case 'W':\n                  ++v190;\n                  break;\n              }\n              v200 = v189[7];\n              if ( v200 == 98 )\n              {\nLABEL_633:\n                v189 += 8;\n                ++v188;\n                if ( v189 == v191 )\n                  goto LABEL_634;\n                continue;\n              }\n            }\n            break;\n          }\n          switch ( v200 )\n          {\n            case 'B':\n              ++v193;\n              break;\n            case 'w':\n              ++v192;\n              break;\n            case 'W':\n              ++v190;\n              break;\n          }\n          v189 += 8;\n          if ( v189 == v191 )\n          {\nLABEL_634:\n            v202 = -3 * v190 + v188 + 3 * v193 - v192;\n            v203 = v281;\n            if ( v281 < v202 )\n              v203 = v202;\n            if ( v279 <= v202 )\n              v202 = v279;\n            v281 = v203;\n            v279 = v202;\n            goto LABEL_24;\n          }\n          continue;\n        }\n      }\n      v279 = 0x7FFFFFFF;\n      v281 = 0x80000000;\nLABEL_498:\n      if ( *((_DWORD *)v283 + 18) )\n      {\n        v163 = v281;\n        v164 = min_score;\n        if ( min_score > v281 )\n          v164 = v281;\n        min_score = v164;\n        if ( max_score >= v281 )\n          v163 = max_score;\n        max_score = v163;\n      }\n      else\n      {\n        v185 = v279;\n        v186 = min_score;\n        if ( min_score > v279 )\n          v186 = v279;\n        min_score = v186;\n        if ( max_score >= v279 )\n          v185 = max_score;\n        max_score = v185;\n      }\nLABEL_13:\n      if ( v286 == ++i )\n        goto LABEL_581;\n      first = (linked_list_member_t *)p_child_node[1];\n      p_child_node = (tree_node_t **)first;\n    }\n    if ( *(_DWORD *)child_node != 3 )\n    {\n      v7 = *((_DWORD *)child_node + 18) == 0;\n      v8 = 0x7FFFFFFF;\n      if ( !v7 )\n        v8 = max_score;\n      max_score = v8;\n      v9 = 0x80000000;\n      if ( v7 )\n        v9 = min_score;\n      min_score = v9;\n      goto LABEL_13;\n    }\n    v222 = child_node;\n    v223 = 0;\n    v224 = child_node + 8;\n    v225 = 0;\n    v226 = v222 + 72;\n    v227 = 0;\n    v228 = 0;\n    while ( 1 )\n    {\n      v236 = *v224;\n      if ( *v224 == 98 )\n      {\n        v229 = v224[1];\n        ++v223;\n        if ( v229 == 98 )\n          goto LABEL_784;\nLABEL_754:\n        switch ( v229 )\n        {\n          case 'B':\n            ++v228;\n            break;\n          case 'w':\n            ++v227;\n            break;\n          case 'W':\n            ++v225;\n            break;\n        }\n        v230 = v224[2];\n        if ( v230 != 98 )\n          goto LABEL_758;\nLABEL_785:\n        v231 = v224[3];\n        ++v223;\n        if ( v231 == 98 )\n          goto LABEL_786;\nLABEL_762:\n        switch ( v231 )\n        {\n          case 'B':\n            ++v228;\n            break;\n          case 'w':\n            ++v227;\n            break;\n          case 'W':\n            ++v225;\n            break;\n        }\n        v232 = v224[4];\n        if ( v232 != 98 )\n          goto LABEL_766;\nLABEL_787:\n        v233 = v224[5];\n        ++v223;\n        if ( v233 == 98 )\n          goto LABEL_788;\nLABEL_770:\n        switch ( v233 )\n        {\n          case 'B':\n            ++v228;\n            break;\n          case 'w':\n            ++v227;\n            break;\n          case 'W':\n            ++v225;\n            break;\n        }\n        v234 = v224[6];\n        if ( v234 != 98 )\n          goto LABEL_774;\nLABEL_789:\n        v235 = v224[7];\n        ++v223;\n        if ( v235 != 98 )\n          goto LABEL_778;\nLABEL_790:\n        v224 += 8;\n        ++v223;\n        if ( v224 == v226 )\n          goto LABEL_791;\n      }\n      else\n      {\n        switch ( v236 )\n        {\n          case 'B':\n            ++v228;\n            break;\n          case 'w':\n            ++v227;\n            break;\n          case 'W':\n            ++v225;\n            break;\n        }\n        v229 = v224[1];\n        if ( v229 != 98 )\n          goto LABEL_754;\nLABEL_784:\n        v230 = v224[2];\n        ++v223;\n        if ( v230 == 98 )\n          goto LABEL_785;\nLABEL_758:\n        switch ( v230 )\n        {\n          case 'B':\n            ++v228;\n            break;\n          case 'w':\n            ++v227;\n            break;\n          case 'W':\n            ++v225;\n            break;\n        }\n        v231 = v224[3];\n        if ( v231 != 98 )\n          goto LABEL_762;\nLABEL_786:\n        v232 = v224[4];\n        ++v223;\n        if ( v232 == 98 )\n          goto LABEL_787;\nLABEL_766:\n        switch ( v232 )\n        {\n          case 'B':\n            ++v228;\n            break;\n          case 'w':\n            ++v227;\n            break;\n          case 'W':\n            ++v225;\n            break;\n        }\n        v233 = v224[5];\n        if ( v233 != 98 )\n          goto LABEL_770;\nLABEL_788:\n        v234 = v224[6];\n        ++v223;\n        if ( v234 == 98 )\n          goto LABEL_789;\nLABEL_774:\n        switch ( v234 )\n        {\n          case 'B':\n            ++v228;\n            break;\n          case 'w':\n            ++v227;\n            break;\n          case 'W':\n            ++v225;\n            break;\n        }\n        v235 = v224[7];\n        if ( v235 == 98 )\n          goto LABEL_790;\nLABEL_778:\n        switch ( v235 )\n        {\n          case 'B':\n            ++v228;\n            break;\n          case 'w':\n            ++v227;\n            break;\n          case 'W':\n            ++v225;\n            break;\n        }\n        v224 += 8;\n        if ( v224 == v226 )\n        {\nLABEL_791:\n          v237 = 3 * v228;\n          v238 = min_score;\n          v239 = -3 * v225 + v223 + v237 - v227;\n          if ( min_score > v239 )\n            v238 = v239;\n          if ( max_score >= v239 )\n            v239 = max_score;\n          min_score = v238;\n          max_score = v239;\n          goto LABEL_13;\n        }\n      }\n    }\n  }\n  min_score = 0x7FFFFFFF;\n  max_score = 0x80000000;\nLABEL_581:\n  result = min_score;\n  if ( node->black_action )\n    return max_score;\n  return result;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O3", "assembly": "<move_score_forced>:\nendbr64\npush   %r15\nmov    %rdi,%rax\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x108,%rsp\nmov    0x4c(%rdi),%esi\nmov    %rdi,0xf8(%rsp)\nmov    %esi,0xf4(%rsp)\ntest   %esi,%esi\njne    3e4c <move_score_forced+0x5c>\ncmpl   $0x3,(%rdi)\nje     5bd2 <move_score_forced+0x1de2>\ncmpl   $0x1,0x48(%rdi)\nmov    $0x7fffffff,%eax\nsbb    $0xffffffff,%eax\nmov    %eax,0xac(%rsp)\nadd    $0x108,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\njle    57b2 <move_score_forced+0x19c2>\nmovl   $0x0,0xdc(%rsp)\nmov    0x50(%rdi),%rax\nmovl   $0x7fffffff,0xc8(%rsp)\nmov    %rax,0xe8(%rsp)\nmovl   $0x80000000,0xac(%rsp)\nmov    (%rax),%rax\nmov    0x4c(%rax),%edx\nmov    %rax,0xe0(%rsp)\nmov    %edx,0xf0(%rsp)\ntest   %edx,%edx\njne    3f03 <move_score_forced+0x113>\ncmpl   $0x3,(%rax)\nje     5e9f <move_score_forced+0x20af>\nmov    0x48(%rax),%eax\ntest   %eax,%eax\nmov    $0x7fffffff,%eax\ncmovne 0xac(%rsp),%eax\nmov    %eax,0xac(%rsp)\nmov    $0x80000000,%eax\ncmove  0xc8(%rsp),%eax\nmov    %eax,0xc8(%rsp)\naddl   $0x1,0xdc(%rsp)\nmov    0xdc(%rsp),%eax\ncmp    %eax,0xf4(%rsp)\nje     57c8 <move_score_forced+0x19d8>\nmov    0xe8(%rsp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0xe8(%rsp)\njmp    3e7f <move_score_forced+0x8f>\njle    5436 <move_score_forced+0x1646>\nmovl   $0x0,0xb8(%rsp)\nmov    0x50(%rax),%rax\nmovl   $0x7fffffff,0xcc(%rsp)\nmov    %rax,0xc0(%rsp)\nmovl   $0x80000000,0xd8(%rsp)\nmov    (%rax),%rax\nmov    0x4c(%rax),%edx\nmov    %rax,0xd0(%rsp)\nmov    %edx,0xbc(%rsp)\ntest   %edx,%edx\njne    3fba <move_score_forced+0x1ca>\ncmpl   $0x3,(%rax)\nje     583b <move_score_forced+0x1a4b>\nmov    0x48(%rax),%eax\ntest   %eax,%eax\nmov    $0x7fffffff,%eax\ncmovne 0xd8(%rsp),%eax\nmov    %eax,0xd8(%rsp)\nmov    $0x80000000,%eax\ncmove  0xcc(%rsp),%eax\nmov    %eax,0xcc(%rsp)\naddl   $0x1,0xb8(%rsp)\nmov    0xb8(%rsp),%eax\ncmp    %eax,0xf0(%rsp)\nje     544c <move_score_forced+0x165c>\nmov    0xc0(%rsp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0xc0(%rsp)\njmp    3f36 <move_score_forced+0x146>\njle    50a1 <move_score_forced+0x12b1>\nmovl   $0x0,0x94(%rsp)\nmov    0x50(%rax),%rax\nmovl   $0x7fffffff,0xa8(%rsp)\nmov    %rax,0x98(%rsp)\nmovl   $0x80000000,0xa4(%rsp)\nmov    (%rax),%rax\nmov    0x4c(%rax),%esi\nmov    %rax,0xb0(%rsp)\nmov    %esi,0xa0(%rsp)\ntest   %esi,%esi\njne    4073 <move_score_forced+0x283>\ncmpl   $0x3,(%rax)\nje     54c3 <move_score_forced+0x16d3>\nmov    0x48(%rax),%r15d\nmov    $0x7fffffff,%eax\ntest   %r15d,%r15d\ncmovne 0xa4(%rsp),%eax\nmov    %eax,0xa4(%rsp)\nmov    $0x80000000,%eax\ncmove  0xa8(%rsp),%eax\nmov    %eax,0xa8(%rsp)\naddl   $0x1,0x94(%rsp)\nmov    0x94(%rsp),%eax\ncmp    %eax,0xbc(%rsp)\nje     50b7 <move_score_forced+0x12c7>\nmov    0x98(%rsp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0x98(%rsp)\njmp    3fed <move_score_forced+0x1fd>\njle    4d22 <move_score_forced+0xf32>\nmov    0x50(%rax),%rax\nmovl   $0x0,0x74(%rsp)\nmovl   $0x7fffffff,0x90(%rsp)\nmov    %rax,0x78(%rsp)\nmovl   $0x80000000,0x84(%rsp)\nmov    (%rax),%rax\nmov    0x4c(%rax),%ebx\nmov    %rax,0x88(%rsp)\nmov    %ebx,0x80(%rsp)\ntest   %ebx,%ebx\njne    4117 <move_score_forced+0x327>\ncmpl   $0x3,(%rax)\nje     5147 <move_score_forced+0x1357>\nmov    0x48(%rax),%r14d\nmov    $0x7fffffff,%eax\ntest   %r14d,%r14d\ncmovne 0x84(%rsp),%eax\nmov    %eax,0x84(%rsp)\nmov    $0x80000000,%eax\ncmove  0x90(%rsp),%eax\nmov    %eax,0x90(%rsp)\naddl   $0x1,0x74(%rsp)\nmov    0x74(%rsp),%eax\ncmp    %eax,0xa0(%rsp)\nje     4d38 <move_score_forced+0xf48>\nmov    0x78(%rsp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0x78(%rsp)\njmp    40a0 <move_score_forced+0x2b0>\njle    4968 <move_score_forced+0xb78>\nmov    0x50(%rax),%rax\nmovl   $0x0,0x54(%rsp)\nmovl   $0x7fffffff,0x64(%rsp)\nmov    %rax,0x58(%rsp)\nmovl   $0x80000000,0x70(%rsp)\nmov    (%rax),%rax\nmov    0x4c(%rax),%ecx\nmov    %rax,0x68(%rsp)\nmov    %ecx,0x60(%rsp)\ntest   %ecx,%ecx\njne    41a8 <move_score_forced+0x3b8>\ncmpl   $0x3,(%rax)\nje     4dc1 <move_score_forced+0xfd1>\nmov    0x48(%rax),%r13d\nmov    $0x7fffffff,%eax\ntest   %r13d,%r13d\ncmovne 0x70(%rsp),%eax\nmov    %eax,0x70(%rsp)\nmov    $0x80000000,%eax\ncmove  0x64(%rsp),%eax\nmov    %eax,0x64(%rsp)\naddl   $0x1,0x54(%rsp)\nmov    0x54(%rsp),%eax\ncmp    %eax,0x80(%rsp)\nje     4978 <move_score_forced+0xb88>\nmov    0x58(%rsp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0x58(%rsp)\njmp    413e <move_score_forced+0x34e>\nnopl   0x0(%rax,%rax,1)\njle    4dac <move_score_forced+0xfbc>\nmov    0x50(%rax),%rax\nmovl   $0x0,0x34(%rsp)\nmovl   $0x7fffffff,0x50(%rsp)\nmov    %rax,0x38(%rsp)\nmovl   $0x80000000,0x44(%rsp)\nmov    (%rax),%rax\nmov    0x4c(%rax),%ebx\nmov    %rax,0x48(%rsp)\nmov    %ebx,0x40(%rsp)\ntest   %ebx,%ebx\njne    4238 <move_score_forced+0x448>\ncmpl   $0x3,(%rax)\nje     4a0b <move_score_forced+0xc1b>\nmov    0x48(%rax),%r12d\nmov    $0x7fffffff,%eax\ntest   %r12d,%r12d\ncmovne 0x44(%rsp),%eax\nmov    %eax,0x44(%rsp)\nmov    $0x80000000,%eax\ncmove  0x50(%rsp),%eax\nmov    %eax,0x50(%rsp)\naddl   $0x1,0x34(%rsp)\nmov    0x34(%rsp),%eax\ncmp    %eax,0x60(%rsp)\nje     4468 <move_score_forced+0x678>\nmov    0x38(%rsp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0x38(%rsp)\njmp    41cf <move_score_forced+0x3df>\nnopl   0x0(%rax)\njle    49f6 <move_score_forced+0xc06>\nmov    0x50(%rax),%rax\nmovl   $0x0,0x14(%rsp)\nmovl   $0x7fffffff,0x30(%rsp)\nmov    %rax,0x18(%rsp)\nmovl   $0x80000000,0x24(%rsp)\nmov    (%rax),%rax\nmov    0x4c(%rax),%esi\nmov    %rax,0x28(%rsp)\nmov    %esi,0x20(%rsp)\ntest   %esi,%esi\njne    42c0 <move_score_forced+0x4d0>\ncmpl   $0x3,(%rax)\nje     4830 <move_score_forced+0xa40>\nmov    0x48(%rax),%ebp\nmov    $0x7fffffff,%eax\ntest   %ebp,%ebp\ncmovne 0x24(%rsp),%eax\nmov    %eax,0x24(%rsp)\nmov    $0x80000000,%eax\ncmove  0x30(%rsp),%eax\nmov    %eax,0x30(%rsp)\naddl   $0x1,0x14(%rsp)\nmov    0x14(%rsp),%eax\ncmp    %eax,0x40(%rsp)\nje     4420 <move_score_forced+0x630>\nmov    0x18(%rsp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0x18(%rsp)\njmp    425f <move_score_forced+0x46f>\nnop\njle    481b <move_score_forced+0xa2b>\nmov    0x50(%rax),%rax\nmovl   $0x0,0x8(%rsp)\nmovl   $0x7fffffff,0x10(%rsp)\nmov    (%rax),%rbp\nmov    %rax,(%rsp)\nmovl   $0x80000000,0xc(%rsp)\nmov    0x4c(%rbp),%r15d\ntest   %r15d,%r15d\njne    4348 <move_score_forced+0x558>\ncmpl   $0x3,0x0(%rbp)\nje     44e8 <move_score_forced+0x6f8>\nmov    0x48(%rbp),%ebx\nmov    $0x7fffffff,%eax\ntest   %ebx,%ebx\ncmovne 0xc(%rsp),%eax\nmov    %eax,0xc(%rsp)\nmov    $0x80000000,%eax\ncmove  0x10(%rsp),%eax\nmov    %eax,0x10(%rsp)\naddl   $0x1,0x8(%rsp)\nmov    0x8(%rsp),%eax\ncmp    %eax,0x20(%rsp)\nje     43d8 <move_score_forced+0x5e8>\nmov    (%rsp),%rax\nmov    0x8(%rax),%rax\nmov    (%rax),%rbp\nmov    %rax,(%rsp)\nmov    0x4c(%rbp),%r15d\ntest   %r15d,%r15d\nje     42f2 <move_score_forced+0x502>\njle    4388 <move_score_forced+0x598>\nmov    0x50(%rbp),%r13\nxor    %ebx,%ebx\nmov    $0x7fffffff,%r14d\nmov    $0x80000000,%r12d\nmov    0x0(%r13),%rdi\ncall   3df0 <move_score_forced>\ncmp    %eax,%r12d\ncmovl  %eax,%r12d\ncmp    %eax,%r14d\ncmovg  %eax,%r14d\nadd    $0x1,%ebx\ncmp    %ebx,%r15d\nje     4394 <move_score_forced+0x5a4>\nmov    0x8(%r13),%r13\njmp    435c <move_score_forced+0x56c>\nnopl   0x0(%rax)\nmov    $0x7fffffff,%r14d\nmov    $0x80000000,%r12d\nmov    0x48(%rbp),%r11d\nmov    0xc(%rsp),%eax\ntest   %r11d,%r11d\nje     44a0 <move_score_forced+0x6b0>\ncmp    %r12d,%eax\ncmovl  %r12d,%eax\nmov    %eax,0xc(%rsp)\nmov    0x10(%rsp),%eax\ncmp    %r12d,%eax\ncmovle %eax,%r12d\naddl   $0x1,0x8(%rsp)\nmov    0x8(%rsp),%eax\nmov    %r12d,0x10(%rsp)\ncmp    %eax,0x20(%rsp)\njne    4330 <move_score_forced+0x540>\nnopl   0x0(%rax,%rax,1)\nmov    0x28(%rsp),%rax\nmov    0x48(%rax),%r10d\ntest   %r10d,%r10d\nje     44c0 <move_score_forced+0x6d0>\nmov    0xc(%rsp),%eax\nmov    0x24(%rsp),%edx\ncmp    %eax,%edx\ncmovl  %eax,%edx\nmov    %edx,0x24(%rsp)\nmov    0x30(%rsp),%edx\ncmp    %eax,%edx\ncmovle %edx,%eax\naddl   $0x1,0x14(%rsp)\nmov    %eax,0x30(%rsp)\nmov    0x14(%rsp),%eax\ncmp    %eax,0x40(%rsp)\njne    42af <move_score_forced+0x4bf>\nnopl   0x0(%rax,%rax,1)\nmov    0x48(%rsp),%rax\nmov    0x48(%rax),%r9d\ntest   %r9d,%r9d\nje     47f8 <move_score_forced+0xa08>\nmov    0x24(%rsp),%eax\nmov    0x44(%rsp),%edx\nmov    0x50(%rsp),%ebx\ncmp    %eax,%edx\ncmovl  %eax,%edx\ncmp    %eax,%ebx\ncmovle %ebx,%eax\naddl   $0x1,0x34(%rsp)\nmov    %edx,0x44(%rsp)\nmov    %eax,0x50(%rsp)\nmov    0x34(%rsp),%eax\ncmp    %eax,0x60(%rsp)\njne    4221 <move_score_forced+0x431>\nnopl   0x0(%rax,%rax,1)\nmov    0x68(%rsp),%rax\nmov    0x48(%rax),%r8d\ntest   %r8d,%r8d\nje     49d3 <move_score_forced+0xbe3>\nmov    0x44(%rsp),%eax\nmov    0x70(%rsp),%edx\nmov    0x64(%rsp),%esi\ncmp    %eax,%edx\ncmovl  %eax,%edx\ncmp    %eax,%esi\ncmovle %esi,%eax\nmov    %edx,0x70(%rsp)\nmov    %eax,0x64(%rsp)\njmp    417d <move_score_forced+0x38d>\nnopl   (%rax)\ncmp    %r14d,%eax\ncmovl  %r14d,%eax\nmov    %eax,0xc(%rsp)\nmov    0x10(%rsp),%eax\ncmp    %r14d,%eax\ncmovle %eax,%r14d\nmov    %r14d,0x10(%rsp)\njmp    431d <move_score_forced+0x52d>\nmov    0x10(%rsp),%eax\nmov    0x24(%rsp),%ebx\ncmp    %eax,%ebx\ncmovl  %eax,%ebx\nmov    %ebx,0x24(%rsp)\nmov    0x30(%rsp),%ebx\ncmp    %eax,%ebx\ncmovle %ebx,%eax\nmov    %eax,0x30(%rsp)\njmp    429c <move_score_forced+0x4ac>\nnopl   0x0(%rax,%rax,1)\nlea    0x8(%rbp),%rax\nlea    0x48(%rbp),%r8\nxor    %edx,%edx\nxor    %esi,%esi\nxor    %ecx,%ecx\njmp    461d <move_score_forced+0x82d>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x77,%dil\njne    47e0 <move_score_forced+0x9f0>\nadd    $0x1,%esi\nmovzbl 0x1(%rax),%edi\ncmp    $0x62,%dil\nje     4645 <move_score_forced+0x855>\ncmp    $0x42,%dil\nje     47d8 <move_score_forced+0x9e8>\ncmp    $0x77,%dil\njne    47c0 <move_score_forced+0x9d0>\nadd    $0x1,%esi\nmovzbl 0x2(%rax),%edi\ncmp    $0x62,%dil\nje     4657 <move_score_forced+0x867>\ncmp    $0x42,%dil\nje     47b8 <move_score_forced+0x9c8>\ncmp    $0x77,%dil\njne    47a0 <move_score_forced+0x9b0>\nadd    $0x1,%esi\nmovzbl 0x3(%rax),%edi\ncmp    $0x62,%dil\nje     4669 <move_score_forced+0x879>\ncmp    $0x42,%dil\nje     4798 <move_score_forced+0x9a8>\ncmp    $0x77,%dil\njne    4780 <move_score_forced+0x990>\nadd    $0x1,%esi\nmovzbl 0x4(%rax),%edi\ncmp    $0x62,%dil\nje     467b <move_score_forced+0x88b>\ncmp    $0x42,%dil\nje     4778 <move_score_forced+0x988>\ncmp    $0x77,%dil\njne    4760 <move_score_forced+0x970>\nadd    $0x1,%esi\nmovzbl 0x5(%rax),%edi\ncmp    $0x62,%dil\nje     468d <move_score_forced+0x89d>\ncmp    $0x42,%dil\nje     4758 <move_score_forced+0x968>\ncmp    $0x77,%dil\njne    4740 <move_score_forced+0x950>\nadd    $0x1,%esi\nmovzbl 0x6(%rax),%edi\ncmp    $0x62,%dil\nje     469f <move_score_forced+0x8af>\ncmp    $0x42,%dil\nje     4738 <move_score_forced+0x948>\ncmp    $0x77,%dil\njne    4720 <move_score_forced+0x930>\nadd    $0x1,%esi\nmovzbl 0x7(%rax),%edi\ncmp    $0x62,%dil\nje     46b1 <move_score_forced+0x8c1>\ncmp    $0x42,%dil\nje     4718 <move_score_forced+0x928>\ncmp    $0x77,%dil\njne    4701 <move_score_forced+0x911>\nadd    $0x1,%esi\nadd    $0x8,%rax\ncmp    %r8,%rax\nje     46c2 <move_score_forced+0x8d2>\nmovzbl (%rax),%edi\ncmp    $0x62,%dil\nje     46f8 <move_score_forced+0x908>\ncmp    $0x42,%dil\njne    4500 <move_score_forced+0x710>\nmovzbl 0x1(%rax),%edi\nadd    $0x1,%ecx\ncmp    $0x62,%dil\njne    451b <move_score_forced+0x72b>\nmovzbl 0x2(%rax),%edi\nadd    $0x1,%r15d\ncmp    $0x62,%dil\njne    4540 <move_score_forced+0x750>\nmovzbl 0x3(%rax),%edi\nadd    $0x1,%r15d\ncmp    $0x62,%dil\njne    4565 <move_score_forced+0x775>\nmovzbl 0x4(%rax),%edi\nadd    $0x1,%r15d\ncmp    $0x62,%dil\njne    458a <move_score_forced+0x79a>\nmovzbl 0x5(%rax),%edi\nadd    $0x1,%r15d\ncmp    $0x62,%dil\njne    45af <move_score_forced+0x7bf>\nmovzbl 0x6(%rax),%edi\nadd    $0x1,%r15d\ncmp    $0x62,%dil\njne    45d4 <move_score_forced+0x7e4>\nmovzbl 0x7(%rax),%edi\nadd    $0x1,%r15d\ncmp    $0x62,%dil\njne    45f9 <move_score_forced+0x809>\nadd    $0x8,%rax\nadd    $0x1,%r15d\ncmp    %r8,%rax\njne    461d <move_score_forced+0x82d>\nlea    (%rcx,%rcx,2),%eax\nlea    0x0(,%rdx,4),%ecx\nadd    %r15d,%eax\nsub    %ecx,%edx\nsub    %esi,%eax\nmov    0xc(%rsp),%esi\nadd    %edx,%eax\ncmp    %eax,%esi\ncmovl  %eax,%esi\nmov    %esi,0xc(%rsp)\nmov    0x10(%rsp),%esi\ncmp    %eax,%esi\ncmovle %esi,%eax\nmov    %eax,0x10(%rsp)\njmp    431d <move_score_forced+0x52d>\nnopl   0x0(%rax)\nadd    $0x1,%r15d\njmp    450d <move_score_forced+0x71d>\ncmp    $0x57,%dil\njne    4610 <move_score_forced+0x820>\nadd    $0x1,%edx\njmp    4610 <move_score_forced+0x820>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    4610 <move_score_forced+0x820>\ncmp    $0x57,%dil\njne    45eb <move_score_forced+0x7fb>\nadd    $0x1,%edx\njmp    45eb <move_score_forced+0x7fb>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    45eb <move_score_forced+0x7fb>\ncmp    $0x57,%dil\njne    45c6 <move_score_forced+0x7d6>\nadd    $0x1,%edx\njmp    45c6 <move_score_forced+0x7d6>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    45c6 <move_score_forced+0x7d6>\ncmp    $0x57,%dil\njne    45a1 <move_score_forced+0x7b1>\nadd    $0x1,%edx\njmp    45a1 <move_score_forced+0x7b1>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    45a1 <move_score_forced+0x7b1>\ncmp    $0x57,%dil\njne    457c <move_score_forced+0x78c>\nadd    $0x1,%edx\njmp    457c <move_score_forced+0x78c>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    457c <move_score_forced+0x78c>\ncmp    $0x57,%dil\njne    4557 <move_score_forced+0x767>\nadd    $0x1,%edx\njmp    4557 <move_score_forced+0x767>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    4557 <move_score_forced+0x767>\ncmp    $0x57,%dil\njne    4532 <move_score_forced+0x742>\nadd    $0x1,%edx\njmp    4532 <move_score_forced+0x742>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    4532 <move_score_forced+0x742>\ncmp    $0x57,%dil\njne    450d <move_score_forced+0x71d>\nadd    $0x1,%edx\njmp    450d <move_score_forced+0x71d>\nnopw   0x0(%rax,%rax,1)\nmov    0x30(%rsp),%eax\nmov    0x44(%rsp),%ecx\nmov    0x50(%rsp),%edx\ncmp    %eax,%ecx\ncmovl  %eax,%ecx\ncmp    %eax,%edx\ncmovle %edx,%eax\nmov    %ecx,0x44(%rsp)\nmov    %eax,0x50(%rsp)\njmp    420e <move_score_forced+0x41e>\nmovl   $0x7fffffff,0x10(%rsp)\nmovl   $0x80000000,0xc(%rsp)\njmp    43d8 <move_score_forced+0x5e8>\nmov    %rax,%rcx\nmov    %esi,%r8d\nlea    0x8(%rax),%rax\nxor    %edi,%edi\nlea    0x48(%rcx),%r14\nxor    %esi,%esi\nxor    %ecx,%ecx\nnopl   0x0(%rax)\nmovzbl (%rax),%edx\ncmp    $0x62,%dl\nje     4900 <move_score_forced+0xb10>\ncmp    $0x42,%dl\nje     4960 <move_score_forced+0xb70>\ncmp    $0x77,%dl\njne    4948 <move_score_forced+0xb58>\nadd    $0x1,%edi\nmovzbl 0x1(%rax),%edx\ncmp    $0x62,%dl\nje     4911 <move_score_forced+0xb21>\ncmp    $0x42,%dl\nje     49cb <move_score_forced+0xbdb>\ncmp    $0x77,%dl\njne    49ba <move_score_forced+0xbca>\nadd    $0x1,%edi\nmovzbl 0x2(%rax),%edx\ncmp    $0x62,%dl\nje     4922 <move_score_forced+0xb32>\ncmp    $0x42,%dl\nje     513f <move_score_forced+0x134f>\ncmp    $0x77,%dl\njne    50fc <move_score_forced+0x130c>\nadd    $0x1,%edi\nmovzbl 0x3(%rax),%edx\ncmp    $0x62,%dl\nje     492f <move_score_forced+0xb3f>\ncmp    $0x42,%dl\nje     5833 <move_score_forced+0x1a43>\ncmp    $0x77,%dl\njne    5822 <move_score_forced+0x1a32>\nadd    $0x1,%edi\nmovzbl 0x4(%rax),%edx\ncmp    $0x62,%dl\nje     493c <move_score_forced+0xb4c>\ncmp    $0x42,%dl\njne    5b2a <move_score_forced+0x1d3a>\nmovzbl 0x5(%rax),%edx\nadd    $0x1,%esi\ncmp    $0x62,%dl\njne    5b43 <move_score_forced+0x1d53>\nadd    $0x1,%r8d\njmp    5b4f <move_score_forced+0x1d5f>\ncs nopw 0x0(%rax,%rax,1)\nmovzbl 0x1(%rax),%edx\nadd    $0x1,%r8d\ncmp    $0x62,%dl\njne    4876 <move_score_forced+0xa86>\nmovzbl 0x2(%rax),%edx\nadd    $0x1,%r8d\ncmp    $0x62,%dl\njne    4898 <move_score_forced+0xaa8>\nmovzbl 0x3(%rax),%edx\nadd    $0x1,%r8d\ncmp    $0x62,%dl\njne    48b6 <move_score_forced+0xac6>\nmovzbl 0x4(%rax),%edx\nadd    $0x1,%r8d\ncmp    $0x62,%dl\njne    48d4 <move_score_forced+0xae4>\nadd    $0x1,%r8d\njmp    5b36 <move_score_forced+0x1d46>\nnopl   (%rax)\ncmp    $0x57,%dl\njne    4869 <move_score_forced+0xa79>\nadd    $0x1,%ecx\njmp    4869 <move_score_forced+0xa79>\nnopl   0x0(%rax)\nadd    $0x1,%esi\njmp    4869 <move_score_forced+0xa79>\nmovl   $0x7fffffff,0x64(%rsp)\nmovl   $0x80000000,0x70(%rsp)\nmov    0x88(%rsp),%rax\nmov    0x48(%rax),%edi\ntest   %edi,%edi\nje     4d7d <move_score_forced+0xf8d>\nmov    0x70(%rsp),%eax\nmov    0x84(%rsp),%ecx\nmov    0x90(%rsp),%ebx\ncmp    %eax,%ecx\ncmovl  %eax,%ecx\ncmp    %eax,%ebx\ncmovle %ebx,%eax\nmov    %ecx,0x84(%rsp)\nmov    %eax,0x90(%rsp)\njmp    40f1 <move_score_forced+0x301>\ncmp    $0x57,%dl\njne    488b <move_score_forced+0xa9b>\nadd    $0x1,%ecx\njmp    488b <move_score_forced+0xa9b>\nadd    $0x1,%esi\njmp    488b <move_score_forced+0xa9b>\nmov    0x50(%rsp),%eax\nmov    0x70(%rsp),%esi\nmov    0x64(%rsp),%ecx\ncmp    %eax,%esi\ncmovl  %eax,%esi\ncmp    %eax,%ecx\ncmovle %ecx,%eax\nmov    %esi,0x70(%rsp)\nmov    %eax,0x64(%rsp)\njmp    417d <move_score_forced+0x38d>\nmovl   $0x7fffffff,0x30(%rsp)\nmovl   $0x80000000,0x24(%rsp)\njmp    4420 <move_score_forced+0x630>\nmov    %rax,%rbx\nmov    0x40(%rsp),%edi\nlea    0x8(%rax),%rax\nxor    %edx,%edx\nlea    0x48(%rbx),%r8\nxor    %esi,%esi\nxor    %ecx,%ecx\njmp    4b4c <move_score_forced+0xd5c>\nnopl   (%rax)\ncmp    $0x77,%r9b\njne    4d10 <move_score_forced+0xf20>\nadd    $0x1,%esi\nmovzbl 0x1(%rax),%r9d\ncmp    $0x62,%r9b\nje     4b76 <move_score_forced+0xd86>\ncmp    $0x42,%r9b\nje     4d08 <move_score_forced+0xf18>\ncmp    $0x77,%r9b\njne    4cf0 <move_score_forced+0xf00>\nadd    $0x1,%esi\nmovzbl 0x2(%rax),%r9d\ncmp    $0x62,%r9b\nje     4b88 <move_score_forced+0xd98>\ncmp    $0x42,%r9b\nje     4ce8 <move_score_forced+0xef8>\ncmp    $0x77,%r9b\njne    4cd0 <move_score_forced+0xee0>\nadd    $0x1,%esi\nmovzbl 0x3(%rax),%r9d\ncmp    $0x62,%r9b\nje     4b9a <move_score_forced+0xdaa>\ncmp    $0x42,%r9b\nje     4cc8 <move_score_forced+0xed8>\ncmp    $0x77,%r9b\njne    4cb0 <move_score_forced+0xec0>\nadd    $0x1,%esi\nmovzbl 0x4(%rax),%r9d\ncmp    $0x62,%r9b\nje     4bac <move_score_forced+0xdbc>\ncmp    $0x42,%r9b\nje     4ca8 <move_score_forced+0xeb8>\ncmp    $0x77,%r9b\njne    4c90 <move_score_forced+0xea0>\nadd    $0x1,%esi\nmovzbl 0x5(%rax),%r9d\ncmp    $0x62,%r9b\nje     4bbe <move_score_forced+0xdce>\ncmp    $0x42,%r9b\nje     4c88 <move_score_forced+0xe98>\ncmp    $0x77,%r9b\njne    4c70 <move_score_forced+0xe80>\nadd    $0x1,%esi\nmovzbl 0x6(%rax),%r9d\ncmp    $0x62,%r9b\nje     4bd0 <move_score_forced+0xde0>\ncmp    $0x42,%r9b\nje     4c68 <move_score_forced+0xe78>\ncmp    $0x77,%r9b\njne    4c50 <move_score_forced+0xe60>\nadd    $0x1,%esi\nmovzbl 0x7(%rax),%r9d\ncmp    $0x62,%r9b\nje     4be2 <move_score_forced+0xdf2>\ncmp    $0x42,%r9b\nje     4c48 <move_score_forced+0xe58>\ncmp    $0x77,%r9b\njne    4c30 <move_score_forced+0xe40>\nadd    $0x1,%esi\nadd    $0x8,%rax\ncmp    %rax,%r8\nje     4bf2 <move_score_forced+0xe02>\nmovzbl (%rax),%r9d\ncmp    $0x62,%r9b\nje     4c28 <move_score_forced+0xe38>\ncmp    $0x42,%r9b\njne    4a28 <move_score_forced+0xc38>\nmovzbl 0x1(%rax),%r9d\nadd    $0x1,%ecx\ncmp    $0x62,%r9b\njne    4a44 <move_score_forced+0xc54>\nmovzbl 0x2(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    4a6a <move_score_forced+0xc7a>\nmovzbl 0x3(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    4a90 <move_score_forced+0xca0>\nmovzbl 0x4(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    4ab6 <move_score_forced+0xcc6>\nmovzbl 0x5(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    4adc <move_score_forced+0xcec>\nmovzbl 0x6(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    4b02 <move_score_forced+0xd12>\nmovzbl 0x7(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    4b28 <move_score_forced+0xd38>\nadd    $0x8,%rax\nadd    $0x1,%edi\ncmp    %rax,%r8\njne    4b4c <move_score_forced+0xd5c>\nlea    (%rcx,%rcx,2),%eax\nlea    0x0(,%rdx,4),%ecx\nmov    0x44(%rsp),%ebx\nadd    %edi,%eax\nsub    %ecx,%edx\nsub    %esi,%eax\nmov    0x50(%rsp),%esi\nadd    %edx,%eax\ncmp    %eax,%ebx\ncmovl  %eax,%ebx\ncmp    %eax,%esi\ncmovle %esi,%eax\nmov    %ebx,0x44(%rsp)\nmov    %eax,0x50(%rsp)\njmp    420e <move_score_forced+0x41e>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%edi\njmp    4a35 <move_score_forced+0xc45>\ncmp    $0x57,%r9b\njne    4b3f <move_score_forced+0xd4f>\nadd    $0x1,%edx\njmp    4b3f <move_score_forced+0xd4f>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    4b3f <move_score_forced+0xd4f>\ncmp    $0x57,%r9b\njne    4b19 <move_score_forced+0xd29>\nadd    $0x1,%edx\njmp    4b19 <move_score_forced+0xd29>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    4b19 <move_score_forced+0xd29>\ncmp    $0x57,%r9b\njne    4af3 <move_score_forced+0xd03>\nadd    $0x1,%edx\njmp    4af3 <move_score_forced+0xd03>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    4af3 <move_score_forced+0xd03>\ncmp    $0x57,%r9b\njne    4acd <move_score_forced+0xcdd>\nadd    $0x1,%edx\njmp    4acd <move_score_forced+0xcdd>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    4acd <move_score_forced+0xcdd>\ncmp    $0x57,%r9b\njne    4aa7 <move_score_forced+0xcb7>\nadd    $0x1,%edx\njmp    4aa7 <move_score_forced+0xcb7>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    4aa7 <move_score_forced+0xcb7>\ncmp    $0x57,%r9b\njne    4a81 <move_score_forced+0xc91>\nadd    $0x1,%edx\njmp    4a81 <move_score_forced+0xc91>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    4a81 <move_score_forced+0xc91>\ncmp    $0x57,%r9b\njne    4a5b <move_score_forced+0xc6b>\nadd    $0x1,%edx\njmp    4a5b <move_score_forced+0xc6b>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    4a5b <move_score_forced+0xc6b>\ncmp    $0x57,%r9b\njne    4a35 <move_score_forced+0xc45>\nadd    $0x1,%edx\njmp    4a35 <move_score_forced+0xc45>\nmovl   $0x7fffffff,0x90(%rsp)\nmovl   $0x80000000,0x84(%rsp)\nmov    0xb0(%rsp),%rax\nmov    0x48(%rax),%esi\ntest   %esi,%esi\nje     510d <move_score_forced+0x131d>\nmov    0x84(%rsp),%eax\nmov    0xa4(%rsp),%ebx\ncmp    %eax,%ebx\ncmovl  %eax,%ebx\nmov    %ebx,0xa4(%rsp)\nmov    0xa8(%rsp),%ebx\ncmp    %eax,%ebx\ncmovle %ebx,%eax\nmov    %eax,0xa8(%rsp)\njmp    403e <move_score_forced+0x24e>\nmov    0x64(%rsp),%eax\nmov    0x84(%rsp),%edx\nmov    0x90(%rsp),%ecx\ncmp    %eax,%edx\ncmovl  %eax,%edx\ncmp    %eax,%ecx\ncmovle %ecx,%eax\nmov    %edx,0x84(%rsp)\nmov    %eax,0x90(%rsp)\njmp    40f1 <move_score_forced+0x301>\nmovl   $0x7fffffff,0x50(%rsp)\nmovl   $0x80000000,0x44(%rsp)\njmp    4468 <move_score_forced+0x678>\nmov    %rax,%rsi\nmov    %ecx,%edi\nlea    0x8(%rax),%rax\nxor    %edx,%edx\nlea    0x48(%rsi),%r8\nxor    %ecx,%ecx\nxor    %esi,%esi\njmp    4ee8 <move_score_forced+0x10f8>\nnopl   0x0(%rax)\ncmp    $0x42,%r9b\nje     5099 <move_score_forced+0x12a9>\ncmp    $0x77,%r9b\njne    5087 <move_score_forced+0x1297>\nadd    $0x1,%esi\nmovzbl 0x2(%rax),%r9d\ncmp    $0x62,%r9b\nje     4f2e <move_score_forced+0x113e>\ncmp    $0x42,%r9b\nje     507f <move_score_forced+0x128f>\ncmp    $0x77,%r9b\njne    506d <move_score_forced+0x127d>\nadd    $0x1,%esi\nmovzbl 0x3(%rax),%r9d\ncmp    $0x62,%r9b\nje     4f40 <move_score_forced+0x1150>\ncmp    $0x42,%r9b\nje     5065 <move_score_forced+0x1275>\ncmp    $0x77,%r9b\njne    5053 <move_score_forced+0x1263>\nadd    $0x1,%esi\nmovzbl 0x4(%rax),%r9d\ncmp    $0x62,%r9b\nje     4f52 <move_score_forced+0x1162>\ncmp    $0x42,%r9b\nje     504b <move_score_forced+0x125b>\ncmp    $0x77,%r9b\njne    5039 <move_score_forced+0x1249>\nadd    $0x1,%esi\nmovzbl 0x5(%rax),%r9d\ncmp    $0x62,%r9b\nje     4f64 <move_score_forced+0x1174>\ncmp    $0x42,%r9b\nje     5031 <move_score_forced+0x1241>\ncmp    $0x77,%r9b\njne    501f <move_score_forced+0x122f>\nadd    $0x1,%esi\nmovzbl 0x6(%rax),%r9d\ncmp    $0x62,%r9b\nje     4f76 <move_score_forced+0x1186>\ncmp    $0x42,%r9b\nje     5017 <move_score_forced+0x1227>\ncmp    $0x77,%r9b\njne    5005 <move_score_forced+0x1215>\nadd    $0x1,%esi\nmovzbl 0x7(%rax),%r9d\ncmp    $0x62,%r9b\nje     4f88 <move_score_forced+0x1198>\ncmp    $0x42,%r9b\nje     4ffd <move_score_forced+0x120d>\ncmp    $0x77,%r9b\njne    4feb <move_score_forced+0x11fb>\nadd    $0x1,%esi\nadd    $0x8,%rax\ncmp    %r8,%rax\nje     4f98 <move_score_forced+0x11a8>\nmovzbl (%rax),%r9d\ncmp    $0x62,%r9b\nje     4fe3 <move_score_forced+0x11f3>\ncmp    $0x42,%r9b\nje     4fdb <move_score_forced+0x11eb>\ncmp    $0x77,%r9b\njne    4fc9 <move_score_forced+0x11d9>\nadd    $0x1,%esi\nmovzbl 0x1(%rax),%r9d\ncmp    $0x62,%r9b\njne    4de0 <move_score_forced+0xff0>\nmovzbl 0x2(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    4e06 <move_score_forced+0x1016>\nmovzbl 0x3(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    4e2c <move_score_forced+0x103c>\nmovzbl 0x4(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    4e52 <move_score_forced+0x1062>\nmovzbl 0x5(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    4e78 <move_score_forced+0x1088>\nmovzbl 0x6(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    4e9e <move_score_forced+0x10ae>\nmovzbl 0x7(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    4ec4 <move_score_forced+0x10d4>\nadd    $0x8,%rax\nadd    $0x1,%edi\ncmp    %r8,%rax\njne    4ee8 <move_score_forced+0x10f8>\nlea    (%rcx,%rcx,2),%eax\nlea    0x0(,%rdx,4),%ecx\nmov    0x64(%rsp),%ebx\nadd    %edi,%eax\nsub    %ecx,%edx\nsub    %esi,%eax\nmov    0x70(%rsp),%esi\nadd    %edx,%eax\ncmp    %eax,%esi\ncmovl  %eax,%esi\ncmp    %eax,%ebx\ncmovle %ebx,%eax\nmov    %esi,0x70(%rsp)\nmov    %eax,0x64(%rsp)\njmp    417d <move_score_forced+0x38d>\ncmp    $0x57,%r9b\njne    4f0d <move_score_forced+0x111d>\nadd    $0x1,%edx\njmp    4f0d <move_score_forced+0x111d>\nadd    $0x1,%ecx\njmp    4f0d <move_score_forced+0x111d>\nadd    $0x1,%edi\njmp    4f0d <move_score_forced+0x111d>\ncmp    $0x57,%r9b\njne    4edb <move_score_forced+0x10eb>\nadd    $0x1,%edx\njmp    4edb <move_score_forced+0x10eb>\nadd    $0x1,%ecx\njmp    4edb <move_score_forced+0x10eb>\ncmp    $0x57,%r9b\njne    4eb5 <move_score_forced+0x10c5>\nadd    $0x1,%edx\njmp    4eb5 <move_score_forced+0x10c5>\nadd    $0x1,%ecx\njmp    4eb5 <move_score_forced+0x10c5>\ncmp    $0x57,%r9b\njne    4e8f <move_score_forced+0x109f>\nadd    $0x1,%edx\njmp    4e8f <move_score_forced+0x109f>\nadd    $0x1,%ecx\njmp    4e8f <move_score_forced+0x109f>\ncmp    $0x57,%r9b\njne    4e69 <move_score_forced+0x1079>\nadd    $0x1,%edx\njmp    4e69 <move_score_forced+0x1079>\nadd    $0x1,%ecx\njmp    4e69 <move_score_forced+0x1079>\ncmp    $0x57,%r9b\njne    4e43 <move_score_forced+0x1053>\nadd    $0x1,%edx\njmp    4e43 <move_score_forced+0x1053>\nadd    $0x1,%ecx\njmp    4e43 <move_score_forced+0x1053>\ncmp    $0x57,%r9b\njne    4e1d <move_score_forced+0x102d>\nadd    $0x1,%edx\njmp    4e1d <move_score_forced+0x102d>\nadd    $0x1,%ecx\njmp    4e1d <move_score_forced+0x102d>\ncmp    $0x57,%r9b\njne    4df7 <move_score_forced+0x1007>\nadd    $0x1,%edx\njmp    4df7 <move_score_forced+0x1007>\nadd    $0x1,%ecx\njmp    4df7 <move_score_forced+0x1007>\nmovl   $0x7fffffff,0xa8(%rsp)\nmovl   $0x80000000,0xa4(%rsp)\nmov    0xd0(%rsp),%rax\nmov    0x48(%rax),%ecx\ntest   %ecx,%ecx\nje     5491 <move_score_forced+0x16a1>\nmov    0xa4(%rsp),%eax\nmov    0xd8(%rsp),%ecx\ncmp    %eax,%ecx\ncmovl  %eax,%ecx\nmov    %ecx,0xd8(%rsp)\nmov    0xcc(%rsp),%ecx\ncmp    %eax,%ecx\ncmovle %ecx,%eax\nmov    %eax,0xcc(%rsp)\njmp    3f85 <move_score_forced+0x195>\ncmp    $0x57,%dl\njne    48ad <move_score_forced+0xabd>\nadd    $0x1,%ecx\njmp    48ad <move_score_forced+0xabd>\nmov    0x90(%rsp),%eax\nmov    0xa4(%rsp),%edx\ncmp    %eax,%edx\ncmovl  %eax,%edx\nmov    %edx,0xa4(%rsp)\nmov    0xa8(%rsp),%edx\ncmp    %eax,%edx\ncmovle %edx,%eax\nmov    %eax,0xa8(%rsp)\njmp    403e <move_score_forced+0x24e>\nadd    $0x1,%esi\njmp    48ad <move_score_forced+0xabd>\nmov    %rax,%rcx\nmov    %ebx,%edi\nlea    0x8(%rax),%rax\nxor    %edx,%edx\nlea    0x48(%rcx),%r8\nxor    %esi,%esi\nxor    %ecx,%ecx\njmp    5283 <move_score_forced+0x1493>\ncmp    $0x77,%r9b\njne    5424 <move_score_forced+0x1634>\nadd    $0x1,%esi\nmovzbl 0x1(%rax),%r9d\ncmp    $0x62,%r9b\nje     52ad <move_score_forced+0x14bd>\ncmp    $0x42,%r9b\nje     541c <move_score_forced+0x162c>\ncmp    $0x77,%r9b\njne    540a <move_score_forced+0x161a>\nadd    $0x1,%esi\nmovzbl 0x2(%rax),%r9d\ncmp    $0x62,%r9b\nje     52bf <move_score_forced+0x14cf>\ncmp    $0x42,%r9b\nje     5402 <move_score_forced+0x1612>\ncmp    $0x77,%r9b\njne    53f0 <move_score_forced+0x1600>\nadd    $0x1,%esi\nmovzbl 0x3(%rax),%r9d\ncmp    $0x62,%r9b\nje     52d1 <move_score_forced+0x14e1>\ncmp    $0x42,%r9b\nje     53e8 <move_score_forced+0x15f8>\ncmp    $0x77,%r9b\njne    53d6 <move_score_forced+0x15e6>\nadd    $0x1,%esi\nmovzbl 0x4(%rax),%r9d\ncmp    $0x62,%r9b\nje     52e3 <move_score_forced+0x14f3>\ncmp    $0x42,%r9b\nje     53ce <move_score_forced+0x15de>\ncmp    $0x77,%r9b\njne    53bc <move_score_forced+0x15cc>\nadd    $0x1,%esi\nmovzbl 0x5(%rax),%r9d\ncmp    $0x62,%r9b\nje     52f5 <move_score_forced+0x1505>\ncmp    $0x42,%r9b\nje     53b4 <move_score_forced+0x15c4>\ncmp    $0x77,%r9b\njne    53a2 <move_score_forced+0x15b2>\nadd    $0x1,%esi\nmovzbl 0x6(%rax),%r9d\ncmp    $0x62,%r9b\nje     5307 <move_score_forced+0x1517>\ncmp    $0x42,%r9b\nje     539a <move_score_forced+0x15aa>\ncmp    $0x77,%r9b\njne    5388 <move_score_forced+0x1598>\nadd    $0x1,%esi\nmovzbl 0x7(%rax),%r9d\ncmp    $0x62,%r9b\nje     5319 <move_score_forced+0x1529>\ncmp    $0x42,%r9b\nje     5380 <move_score_forced+0x1590>\ncmp    $0x77,%r9b\njne    536e <move_score_forced+0x157e>\nadd    $0x1,%esi\nadd    $0x8,%rax\ncmp    %r8,%rax\nje     5329 <move_score_forced+0x1539>\nmovzbl (%rax),%r9d\ncmp    $0x62,%r9b\nje     5366 <move_score_forced+0x1576>\ncmp    $0x42,%r9b\njne    515f <move_score_forced+0x136f>\nmovzbl 0x1(%rax),%r9d\nadd    $0x1,%ecx\ncmp    $0x62,%r9b\njne    517b <move_score_forced+0x138b>\nmovzbl 0x2(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    51a1 <move_score_forced+0x13b1>\nmovzbl 0x3(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    51c7 <move_score_forced+0x13d7>\nmovzbl 0x4(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    51ed <move_score_forced+0x13fd>\nmovzbl 0x5(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5213 <move_score_forced+0x1423>\nmovzbl 0x6(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5239 <move_score_forced+0x1449>\nmovzbl 0x7(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    525f <move_score_forced+0x146f>\nadd    $0x8,%rax\nadd    $0x1,%edi\ncmp    %r8,%rax\njne    5283 <move_score_forced+0x1493>\nlea    (%rcx,%rcx,2),%eax\nlea    0x0(,%rdx,4),%ecx\nadd    %edi,%eax\nsub    %ecx,%edx\nsub    %esi,%eax\nmov    0x84(%rsp),%esi\nadd    %edx,%eax\ncmp    %eax,%esi\ncmovl  %eax,%esi\nmov    %esi,0x84(%rsp)\nmov    0x90(%rsp),%esi\ncmp    %eax,%esi\ncmovle %esi,%eax\nmov    %eax,0x90(%rsp)\njmp    40f1 <move_score_forced+0x301>\nadd    $0x1,%edi\njmp    516c <move_score_forced+0x137c>\ncmp    $0x57,%r9b\njne    5276 <move_score_forced+0x1486>\nadd    $0x1,%edx\njmp    5276 <move_score_forced+0x1486>\nadd    $0x1,%ecx\njmp    5276 <move_score_forced+0x1486>\ncmp    $0x57,%r9b\njne    5250 <move_score_forced+0x1460>\nadd    $0x1,%edx\njmp    5250 <move_score_forced+0x1460>\nadd    $0x1,%ecx\njmp    5250 <move_score_forced+0x1460>\ncmp    $0x57,%r9b\njne    522a <move_score_forced+0x143a>\nadd    $0x1,%edx\njmp    522a <move_score_forced+0x143a>\nadd    $0x1,%ecx\njmp    522a <move_score_forced+0x143a>\ncmp    $0x57,%r9b\njne    5204 <move_score_forced+0x1414>\nadd    $0x1,%edx\njmp    5204 <move_score_forced+0x1414>\nadd    $0x1,%ecx\njmp    5204 <move_score_forced+0x1414>\ncmp    $0x57,%r9b\njne    51de <move_score_forced+0x13ee>\nadd    $0x1,%edx\njmp    51de <move_score_forced+0x13ee>\nadd    $0x1,%ecx\njmp    51de <move_score_forced+0x13ee>\ncmp    $0x57,%r9b\njne    51b8 <move_score_forced+0x13c8>\nadd    $0x1,%edx\njmp    51b8 <move_score_forced+0x13c8>\nadd    $0x1,%ecx\njmp    51b8 <move_score_forced+0x13c8>\ncmp    $0x57,%r9b\njne    5192 <move_score_forced+0x13a2>\nadd    $0x1,%edx\njmp    5192 <move_score_forced+0x13a2>\nadd    $0x1,%ecx\njmp    5192 <move_score_forced+0x13a2>\ncmp    $0x57,%r9b\njne    516c <move_score_forced+0x137c>\nadd    $0x1,%edx\njmp    516c <move_score_forced+0x137c>\nmovl   $0x7fffffff,0xcc(%rsp)\nmovl   $0x80000000,0xd8(%rsp)\nmov    0xe0(%rsp),%rax\nmov    0x48(%rax),%edx\ntest   %edx,%edx\nje     57f0 <move_score_forced+0x1a00>\nmov    0xd8(%rsp),%eax\nmov    0xc8(%rsp),%ebx\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\nmov    %ebx,0xc8(%rsp)\nmov    0xac(%rsp),%ebx\ncmp    %eax,%ebx\ncmovge %ebx,%eax\nmov    %eax,0xac(%rsp)\njmp    3ece <move_score_forced+0xde>\nmov    0xa8(%rsp),%eax\nmov    0xd8(%rsp),%esi\ncmp    %eax,%esi\ncmovl  %eax,%esi\nmov    %esi,0xd8(%rsp)\nmov    0xcc(%rsp),%esi\ncmp    %eax,%esi\ncmovle %esi,%eax\nmov    %eax,0xcc(%rsp)\njmp    3f85 <move_score_forced+0x195>\nmov    %rax,%rbx\nmov    %esi,%edi\nlea    0x8(%rax),%rax\nxor    %edx,%edx\nlea    0x48(%rbx),%r8\nxor    %esi,%esi\nxor    %ecx,%ecx\njmp    55ff <move_score_forced+0x180f>\ncmp    $0x77,%r9b\njne    57a0 <move_score_forced+0x19b0>\nadd    $0x1,%esi\nmovzbl 0x1(%rax),%r9d\ncmp    $0x62,%r9b\nje     5629 <move_score_forced+0x1839>\ncmp    $0x42,%r9b\nje     5798 <move_score_forced+0x19a8>\ncmp    $0x77,%r9b\njne    5786 <move_score_forced+0x1996>\nadd    $0x1,%esi\nmovzbl 0x2(%rax),%r9d\ncmp    $0x62,%r9b\nje     563b <move_score_forced+0x184b>\ncmp    $0x42,%r9b\nje     577e <move_score_forced+0x198e>\ncmp    $0x77,%r9b\njne    576c <move_score_forced+0x197c>\nadd    $0x1,%esi\nmovzbl 0x3(%rax),%r9d\ncmp    $0x62,%r9b\nje     564d <move_score_forced+0x185d>\ncmp    $0x42,%r9b\nje     5764 <move_score_forced+0x1974>\ncmp    $0x77,%r9b\njne    5752 <move_score_forced+0x1962>\nadd    $0x1,%esi\nmovzbl 0x4(%rax),%r9d\ncmp    $0x62,%r9b\nje     565f <move_score_forced+0x186f>\ncmp    $0x42,%r9b\nje     574a <move_score_forced+0x195a>\ncmp    $0x77,%r9b\njne    5738 <move_score_forced+0x1948>\nadd    $0x1,%esi\nmovzbl 0x5(%rax),%r9d\ncmp    $0x62,%r9b\nje     5671 <move_score_forced+0x1881>\ncmp    $0x42,%r9b\nje     5730 <move_score_forced+0x1940>\ncmp    $0x77,%r9b\njne    571e <move_score_forced+0x192e>\nadd    $0x1,%esi\nmovzbl 0x6(%rax),%r9d\ncmp    $0x62,%r9b\nje     5683 <move_score_forced+0x1893>\ncmp    $0x42,%r9b\nje     5716 <move_score_forced+0x1926>\ncmp    $0x77,%r9b\njne    5704 <move_score_forced+0x1914>\nadd    $0x1,%esi\nmovzbl 0x7(%rax),%r9d\ncmp    $0x62,%r9b\nje     5695 <move_score_forced+0x18a5>\ncmp    $0x42,%r9b\nje     56fc <move_score_forced+0x190c>\ncmp    $0x77,%r9b\njne    56ea <move_score_forced+0x18fa>\nadd    $0x1,%esi\nadd    $0x8,%rax\ncmp    %r8,%rax\nje     56a5 <move_score_forced+0x18b5>\nmovzbl (%rax),%r9d\ncmp    $0x62,%r9b\nje     56e2 <move_score_forced+0x18f2>\ncmp    $0x42,%r9b\njne    54db <move_score_forced+0x16eb>\nmovzbl 0x1(%rax),%r9d\nadd    $0x1,%ecx\ncmp    $0x62,%r9b\njne    54f7 <move_score_forced+0x1707>\nmovzbl 0x2(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    551d <move_score_forced+0x172d>\nmovzbl 0x3(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5543 <move_score_forced+0x1753>\nmovzbl 0x4(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5569 <move_score_forced+0x1779>\nmovzbl 0x5(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    558f <move_score_forced+0x179f>\nmovzbl 0x6(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    55b5 <move_score_forced+0x17c5>\nmovzbl 0x7(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    55db <move_score_forced+0x17eb>\nadd    $0x8,%rax\nadd    $0x1,%edi\ncmp    %r8,%rax\njne    55ff <move_score_forced+0x180f>\nlea    (%rcx,%rcx,2),%eax\nlea    0x0(,%rdx,4),%ecx\nadd    %edi,%eax\nsub    %ecx,%edx\nmov    0xa4(%rsp),%ecx\nsub    %esi,%eax\nadd    %edx,%eax\nmov    0xa8(%rsp),%edx\ncmp    %eax,%ecx\ncmovl  %eax,%ecx\ncmp    %eax,%edx\ncmovle %edx,%eax\nmov    %ecx,0xa4(%rsp)\nmov    %eax,0xa8(%rsp)\njmp    403e <move_score_forced+0x24e>\nadd    $0x1,%edi\njmp    54e8 <move_score_forced+0x16f8>\ncmp    $0x57,%r9b\njne    55f2 <move_score_forced+0x1802>\nadd    $0x1,%edx\njmp    55f2 <move_score_forced+0x1802>\nadd    $0x1,%ecx\njmp    55f2 <move_score_forced+0x1802>\ncmp    $0x57,%r9b\njne    55cc <move_score_forced+0x17dc>\nadd    $0x1,%edx\njmp    55cc <move_score_forced+0x17dc>\nadd    $0x1,%ecx\njmp    55cc <move_score_forced+0x17dc>\ncmp    $0x57,%r9b\njne    55a6 <move_score_forced+0x17b6>\nadd    $0x1,%edx\njmp    55a6 <move_score_forced+0x17b6>\nadd    $0x1,%ecx\njmp    55a6 <move_score_forced+0x17b6>\ncmp    $0x57,%r9b\njne    5580 <move_score_forced+0x1790>\nadd    $0x1,%edx\njmp    5580 <move_score_forced+0x1790>\nadd    $0x1,%ecx\njmp    5580 <move_score_forced+0x1790>\ncmp    $0x57,%r9b\njne    555a <move_score_forced+0x176a>\nadd    $0x1,%edx\njmp    555a <move_score_forced+0x176a>\nadd    $0x1,%ecx\njmp    555a <move_score_forced+0x176a>\ncmp    $0x57,%r9b\njne    5534 <move_score_forced+0x1744>\nadd    $0x1,%edx\njmp    5534 <move_score_forced+0x1744>\nadd    $0x1,%ecx\njmp    5534 <move_score_forced+0x1744>\ncmp    $0x57,%r9b\njne    550e <move_score_forced+0x171e>\nadd    $0x1,%edx\njmp    550e <move_score_forced+0x171e>\nadd    $0x1,%ecx\njmp    550e <move_score_forced+0x171e>\ncmp    $0x57,%r9b\njne    54e8 <move_score_forced+0x16f8>\nadd    $0x1,%edx\njmp    54e8 <move_score_forced+0x16f8>\nmovl   $0x7fffffff,0xc8(%rsp)\nmovl   $0x80000000,0xac(%rsp)\nmov    0xf8(%rsp),%rax\nmov    0x48(%rax),%eax\ntest   %eax,%eax\nmov    0xc8(%rsp),%eax\ncmovne 0xac(%rsp),%eax\nmov    %eax,0xac(%rsp)\njmp    3e3a <move_score_forced+0x4a>\nmov    0xcc(%rsp),%eax\nmov    0xc8(%rsp),%edx\ncmp    %eax,%edx\ncmovg  %eax,%edx\nmov    %edx,0xc8(%rsp)\nmov    0xac(%rsp),%edx\ncmp    %eax,%edx\ncmovge %edx,%eax\nmov    %eax,0xac(%rsp)\njmp    3ece <move_score_forced+0xde>\ncmp    $0x57,%dl\njne    48cb <move_score_forced+0xadb>\nadd    $0x1,%ecx\njmp    48cb <move_score_forced+0xadb>\nadd    $0x1,%esi\njmp    48cb <move_score_forced+0xadb>\nmov    %rax,%rcx\nmov    %edx,%edi\nlea    0x8(%rax),%rax\nxor    %edx,%edx\nlea    0x48(%rcx),%r8\nxor    %esi,%esi\nxor    %ecx,%ecx\njmp    5981 <move_score_forced+0x1b91>\ncmp    $0x42,%r9b\nje     5b22 <move_score_forced+0x1d32>\ncmp    $0x77,%r9b\njne    5b10 <move_score_forced+0x1d20>\nadd    $0x1,%esi\nmovzbl 0x1(%rax),%r9d\ncmp    $0x62,%r9b\nje     59a1 <move_score_forced+0x1bb1>\ncmp    $0x42,%r9b\nje     5b08 <move_score_forced+0x1d18>\ncmp    $0x77,%r9b\njne    5af6 <move_score_forced+0x1d06>\nadd    $0x1,%esi\nmovzbl 0x2(%rax),%r9d\ncmp    $0x62,%r9b\nje     59b3 <move_score_forced+0x1bc3>\ncmp    $0x42,%r9b\nje     5aee <move_score_forced+0x1cfe>\ncmp    $0x77,%r9b\njne    5adc <move_score_forced+0x1cec>\nadd    $0x1,%esi\nmovzbl 0x3(%rax),%r9d\ncmp    $0x62,%r9b\nje     59c5 <move_score_forced+0x1bd5>\ncmp    $0x42,%r9b\nje     5ad4 <move_score_forced+0x1ce4>\ncmp    $0x77,%r9b\njne    5ac2 <move_score_forced+0x1cd2>\nadd    $0x1,%esi\nmovzbl 0x4(%rax),%r9d\ncmp    $0x62,%r9b\nje     59d7 <move_score_forced+0x1be7>\ncmp    $0x42,%r9b\nje     5aba <move_score_forced+0x1cca>\ncmp    $0x77,%r9b\njne    5aa8 <move_score_forced+0x1cb8>\nadd    $0x1,%esi\nmovzbl 0x5(%rax),%r9d\ncmp    $0x62,%r9b\nje     59e9 <move_score_forced+0x1bf9>\ncmp    $0x42,%r9b\nje     5aa0 <move_score_forced+0x1cb0>\ncmp    $0x77,%r9b\njne    5a8e <move_score_forced+0x1c9e>\nadd    $0x1,%esi\nmovzbl 0x6(%rax),%r9d\ncmp    $0x62,%r9b\nje     59fb <move_score_forced+0x1c0b>\ncmp    $0x42,%r9b\nje     5a86 <move_score_forced+0x1c96>\ncmp    $0x77,%r9b\njne    5a74 <move_score_forced+0x1c84>\nadd    $0x1,%esi\nmovzbl 0x7(%rax),%r9d\ncmp    $0x62,%r9b\nje     5a0d <move_score_forced+0x1c1d>\ncmp    $0x42,%r9b\nje     5a6c <move_score_forced+0x1c7c>\ncmp    $0x77,%r9b\njne    5a5a <move_score_forced+0x1c6a>\nadd    $0x1,%esi\nadd    $0x8,%rax\ncmp    %r8,%rax\nje     5a1d <move_score_forced+0x1c2d>\nmovzbl (%rax),%r9d\ncmp    $0x62,%r9b\njne    5853 <move_score_forced+0x1a63>\nmovzbl 0x1(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5879 <move_score_forced+0x1a89>\nmovzbl 0x2(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    589f <move_score_forced+0x1aaf>\nmovzbl 0x3(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    58c5 <move_score_forced+0x1ad5>\nmovzbl 0x4(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    58eb <move_score_forced+0x1afb>\nmovzbl 0x5(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5911 <move_score_forced+0x1b21>\nmovzbl 0x6(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5937 <move_score_forced+0x1b47>\nmovzbl 0x7(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    595d <move_score_forced+0x1b6d>\nadd    $0x8,%rax\nadd    $0x1,%edi\ncmp    %r8,%rax\njne    5981 <move_score_forced+0x1b91>\nlea    (%rcx,%rcx,2),%eax\nlea    0x0(,%rdx,4),%ecx\nadd    %edi,%eax\nsub    %ecx,%edx\nsub    %esi,%eax\nmov    0xcc(%rsp),%esi\nadd    %edx,%eax\nmov    0xd8(%rsp),%edx\ncmp    %eax,%edx\ncmovl  %eax,%edx\ncmp    %eax,%esi\ncmovle %esi,%eax\nmov    %edx,0xd8(%rsp)\nmov    %eax,0xcc(%rsp)\njmp    3f85 <move_score_forced+0x195>\ncmp    $0x57,%r9b\njne    5974 <move_score_forced+0x1b84>\nadd    $0x1,%edx\njmp    5974 <move_score_forced+0x1b84>\nadd    $0x1,%ecx\njmp    5974 <move_score_forced+0x1b84>\ncmp    $0x57,%r9b\njne    594e <move_score_forced+0x1b5e>\nadd    $0x1,%edx\njmp    594e <move_score_forced+0x1b5e>\nadd    $0x1,%ecx\njmp    594e <move_score_forced+0x1b5e>\ncmp    $0x57,%r9b\njne    5928 <move_score_forced+0x1b38>\nadd    $0x1,%edx\njmp    5928 <move_score_forced+0x1b38>\nadd    $0x1,%ecx\njmp    5928 <move_score_forced+0x1b38>\ncmp    $0x57,%r9b\njne    5902 <move_score_forced+0x1b12>\nadd    $0x1,%edx\njmp    5902 <move_score_forced+0x1b12>\nadd    $0x1,%ecx\njmp    5902 <move_score_forced+0x1b12>\ncmp    $0x57,%r9b\njne    58dc <move_score_forced+0x1aec>\nadd    $0x1,%edx\njmp    58dc <move_score_forced+0x1aec>\nadd    $0x1,%ecx\njmp    58dc <move_score_forced+0x1aec>\ncmp    $0x57,%r9b\njne    58b6 <move_score_forced+0x1ac6>\nadd    $0x1,%edx\njmp    58b6 <move_score_forced+0x1ac6>\nadd    $0x1,%ecx\njmp    58b6 <move_score_forced+0x1ac6>\ncmp    $0x57,%r9b\njne    5890 <move_score_forced+0x1aa0>\nadd    $0x1,%edx\njmp    5890 <move_score_forced+0x1aa0>\nadd    $0x1,%ecx\njmp    5890 <move_score_forced+0x1aa0>\ncmp    $0x57,%r9b\njne    586a <move_score_forced+0x1a7a>\nadd    $0x1,%edx\njmp    586a <move_score_forced+0x1a7a>\nadd    $0x1,%ecx\njmp    586a <move_score_forced+0x1a7a>\ncmp    $0x77,%dl\njne    618e <move_score_forced+0x239e>\nadd    $0x1,%edi\nmovzbl 0x5(%rax),%edx\ncmp    $0x62,%dl\nje     48ed <move_score_forced+0xafd>\ncmp    $0x42,%dl\njne    619f <move_score_forced+0x23af>\nadd    $0x1,%esi\nmovzbl 0x6(%rax),%edx\ncmp    $0x62,%dl\nje     61f8 <move_score_forced+0x2408>\ncmp    $0x42,%dl\nje     61f0 <move_score_forced+0x2400>\ncmp    $0x77,%dl\njne    61df <move_score_forced+0x23ef>\nadd    $0x1,%edi\nmovzbl 0x7(%rax),%edx\ncmp    $0x62,%dl\nje     61d6 <move_score_forced+0x23e6>\ncmp    $0x42,%dl\nje     61ce <move_score_forced+0x23de>\ncmp    $0x77,%dl\njne    61bd <move_score_forced+0x23cd>\nadd    $0x1,%edi\nadd    $0x8,%rax\ncmp    %rax,%r14\njne    4848 <move_score_forced+0xa58>\nlea    (%rsi,%rsi,2),%eax\nlea    0x0(,%rcx,4),%edx\nmov    0x30(%rsp),%ebx\nadd    %r8d,%eax\nsub    %edx,%ecx\nsub    %edi,%eax\nadd    %ecx,%eax\nmov    0x24(%rsp),%ecx\ncmp    %eax,%ecx\ncmovl  %eax,%ecx\ncmp    %eax,%ebx\ncmovle %ebx,%eax\nmov    %ecx,0x24(%rsp)\nmov    %eax,0x30(%rsp)\njmp    429c <move_score_forced+0x4ac>\nmov    %esi,%edi\nlea    0x48(%rax),%r8\nlea    0x8(%rax),%rsi\nxor    %ecx,%ecx\nxor    %eax,%eax\nxor    %edx,%edx\njmp    5d15 <move_score_forced+0x1f25>\ncmp    $0x42,%r9b\nje     5e97 <move_score_forced+0x20a7>\ncmp    $0x77,%r9b\njne    5e85 <move_score_forced+0x2095>\nadd    $0x1,%ecx\nmovzbl 0x1(%rsi),%r9d\ncmp    $0x62,%r9b\nje     5d35 <move_score_forced+0x1f45>\ncmp    $0x42,%r9b\nje     5e7d <move_score_forced+0x208d>\ncmp    $0x77,%r9b\njne    5e6b <move_score_forced+0x207b>\nadd    $0x1,%ecx\nmovzbl 0x2(%rsi),%r9d\ncmp    $0x62,%r9b\nje     5d47 <move_score_forced+0x1f57>\ncmp    $0x42,%r9b\nje     5e63 <move_score_forced+0x2073>\ncmp    $0x77,%r9b\njne    5e51 <move_score_forced+0x2061>\nadd    $0x1,%ecx\nmovzbl 0x3(%rsi),%r9d\ncmp    $0x62,%r9b\nje     5d59 <move_score_forced+0x1f69>\ncmp    $0x42,%r9b\nje     5e49 <move_score_forced+0x2059>\ncmp    $0x77,%r9b\njne    5e37 <move_score_forced+0x2047>\nadd    $0x1,%ecx\nmovzbl 0x4(%rsi),%r9d\ncmp    $0x62,%r9b\nje     5d6b <move_score_forced+0x1f7b>\ncmp    $0x42,%r9b\nje     5e2f <move_score_forced+0x203f>\ncmp    $0x77,%r9b\njne    5e1d <move_score_forced+0x202d>\nadd    $0x1,%ecx\nmovzbl 0x5(%rsi),%r9d\ncmp    $0x62,%r9b\nje     5d7d <move_score_forced+0x1f8d>\ncmp    $0x42,%r9b\nje     5e15 <move_score_forced+0x2025>\ncmp    $0x77,%r9b\njne    5e03 <move_score_forced+0x2013>\nadd    $0x1,%ecx\nmovzbl 0x6(%rsi),%r9d\ncmp    $0x62,%r9b\nje     5d8f <move_score_forced+0x1f9f>\ncmp    $0x42,%r9b\nje     5dfb <move_score_forced+0x200b>\ncmp    $0x77,%r9b\njne    5de9 <move_score_forced+0x1ff9>\nadd    $0x1,%ecx\nmovzbl 0x7(%rsi),%r9d\ncmp    $0x62,%r9b\nje     5da1 <move_score_forced+0x1fb1>\ncmp    $0x42,%r9b\nje     5de1 <move_score_forced+0x1ff1>\ncmp    $0x77,%r9b\njne    5dcf <move_score_forced+0x1fdf>\nadd    $0x1,%ecx\nadd    $0x8,%rsi\ncmp    %rsi,%r8\nje     5db1 <move_score_forced+0x1fc1>\nmovzbl (%rsi),%r9d\ncmp    $0x62,%r9b\njne    5be7 <move_score_forced+0x1df7>\nmovzbl 0x1(%rsi),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5c0d <move_score_forced+0x1e1d>\nmovzbl 0x2(%rsi),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5c33 <move_score_forced+0x1e43>\nmovzbl 0x3(%rsi),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5c59 <move_score_forced+0x1e69>\nmovzbl 0x4(%rsi),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5c7f <move_score_forced+0x1e8f>\nmovzbl 0x5(%rsi),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5ca5 <move_score_forced+0x1eb5>\nmovzbl 0x6(%rsi),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5ccb <move_score_forced+0x1edb>\nmovzbl 0x7(%rsi),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5cf1 <move_score_forced+0x1f01>\nadd    $0x8,%rsi\nadd    $0x1,%edi\ncmp    %rsi,%r8\njne    5d15 <move_score_forced+0x1f25>\nlea    (%rdx,%rdx,2),%edx\nadd    %edi,%edx\nsub    %ecx,%edx\nlea    0x0(,%rax,4),%ecx\nsub    %ecx,%eax\nadd    %edx,%eax\nmov    %eax,0xac(%rsp)\njmp    3e3a <move_score_forced+0x4a>\ncmp    $0x57,%r9b\njne    5d08 <move_score_forced+0x1f18>\nadd    $0x1,%eax\njmp    5d08 <move_score_forced+0x1f18>\nadd    $0x1,%edx\njmp    5d08 <move_score_forced+0x1f18>\ncmp    $0x57,%r9b\njne    5ce2 <move_score_forced+0x1ef2>\nadd    $0x1,%eax\njmp    5ce2 <move_score_forced+0x1ef2>\nadd    $0x1,%edx\njmp    5ce2 <move_score_forced+0x1ef2>\ncmp    $0x57,%r9b\njne    5cbc <move_score_forced+0x1ecc>\nadd    $0x1,%eax\njmp    5cbc <move_score_forced+0x1ecc>\nadd    $0x1,%edx\njmp    5cbc <move_score_forced+0x1ecc>\ncmp    $0x57,%r9b\njne    5c96 <move_score_forced+0x1ea6>\nadd    $0x1,%eax\njmp    5c96 <move_score_forced+0x1ea6>\nadd    $0x1,%edx\njmp    5c96 <move_score_forced+0x1ea6>\ncmp    $0x57,%r9b\njne    5c70 <move_score_forced+0x1e80>\nadd    $0x1,%eax\njmp    5c70 <move_score_forced+0x1e80>\nadd    $0x1,%edx\njmp    5c70 <move_score_forced+0x1e80>\ncmp    $0x57,%r9b\njne    5c4a <move_score_forced+0x1e5a>\nadd    $0x1,%eax\njmp    5c4a <move_score_forced+0x1e5a>\nadd    $0x1,%edx\njmp    5c4a <move_score_forced+0x1e5a>\ncmp    $0x57,%r9b\njne    5c24 <move_score_forced+0x1e34>\nadd    $0x1,%eax\njmp    5c24 <move_score_forced+0x1e34>\nadd    $0x1,%edx\njmp    5c24 <move_score_forced+0x1e34>\ncmp    $0x57,%r9b\njne    5bfe <move_score_forced+0x1e0e>\nadd    $0x1,%eax\njmp    5bfe <move_score_forced+0x1e0e>\nadd    $0x1,%edx\njmp    5bfe <move_score_forced+0x1e0e>\nmov    %rax,%rbx\nmov    %edx,%edi\nlea    0x8(%rax),%rax\nxor    %edx,%edx\nlea    0x48(%rbx),%r8\nxor    %esi,%esi\nxor    %ecx,%ecx\njmp    5fe5 <move_score_forced+0x21f5>\ncmp    $0x42,%r9b\nje     6186 <move_score_forced+0x2396>\ncmp    $0x77,%r9b\njne    6174 <move_score_forced+0x2384>\nadd    $0x1,%esi\nmovzbl 0x1(%rax),%r9d\ncmp    $0x62,%r9b\nje     6005 <move_score_forced+0x2215>\ncmp    $0x42,%r9b\nje     616c <move_score_forced+0x237c>\ncmp    $0x77,%r9b\njne    615a <move_score_forced+0x236a>\nadd    $0x1,%esi\nmovzbl 0x2(%rax),%r9d\ncmp    $0x62,%r9b\nje     6017 <move_score_forced+0x2227>\ncmp    $0x42,%r9b\nje     6152 <move_score_forced+0x2362>\ncmp    $0x77,%r9b\njne    6140 <move_score_forced+0x2350>\nadd    $0x1,%esi\nmovzbl 0x3(%rax),%r9d\ncmp    $0x62,%r9b\nje     6029 <move_score_forced+0x2239>\ncmp    $0x42,%r9b\nje     6138 <move_score_forced+0x2348>\ncmp    $0x77,%r9b\njne    6126 <move_score_forced+0x2336>\nadd    $0x1,%esi\nmovzbl 0x4(%rax),%r9d\ncmp    $0x62,%r9b\nje     603b <move_score_forced+0x224b>\ncmp    $0x42,%r9b\nje     611e <move_score_forced+0x232e>\ncmp    $0x77,%r9b\njne    610c <move_score_forced+0x231c>\nadd    $0x1,%esi\nmovzbl 0x5(%rax),%r9d\ncmp    $0x62,%r9b\nje     604d <move_score_forced+0x225d>\ncmp    $0x42,%r9b\nje     6104 <move_score_forced+0x2314>\ncmp    $0x77,%r9b\njne    60f2 <move_score_forced+0x2302>\nadd    $0x1,%esi\nmovzbl 0x6(%rax),%r9d\ncmp    $0x62,%r9b\nje     605f <move_score_forced+0x226f>\ncmp    $0x42,%r9b\nje     60ea <move_score_forced+0x22fa>\ncmp    $0x77,%r9b\njne    60d8 <move_score_forced+0x22e8>\nadd    $0x1,%esi\nmovzbl 0x7(%rax),%r9d\ncmp    $0x62,%r9b\nje     6071 <move_score_forced+0x2281>\ncmp    $0x42,%r9b\nje     60d0 <move_score_forced+0x22e0>\ncmp    $0x77,%r9b\njne    60be <move_score_forced+0x22ce>\nadd    $0x1,%esi\nadd    $0x8,%rax\ncmp    %r8,%rax\nje     6081 <move_score_forced+0x2291>\nmovzbl (%rax),%r9d\ncmp    $0x62,%r9b\njne    5eb7 <move_score_forced+0x20c7>\nmovzbl 0x1(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5edd <move_score_forced+0x20ed>\nmovzbl 0x2(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5f03 <move_score_forced+0x2113>\nmovzbl 0x3(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5f29 <move_score_forced+0x2139>\nmovzbl 0x4(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5f4f <move_score_forced+0x215f>\nmovzbl 0x5(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5f75 <move_score_forced+0x2185>\nmovzbl 0x6(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5f9b <move_score_forced+0x21ab>\nmovzbl 0x7(%rax),%r9d\nadd    $0x1,%edi\ncmp    $0x62,%r9b\njne    5fc1 <move_score_forced+0x21d1>\nadd    $0x8,%rax\nadd    $0x1,%edi\ncmp    %r8,%rax\njne    5fe5 <move_score_forced+0x21f5>\nlea    (%rcx,%rcx,2),%eax\nlea    0x0(,%rdx,4),%ecx\nadd    %edi,%eax\nsub    %ecx,%edx\nmov    0xc8(%rsp),%ecx\nsub    %esi,%eax\nadd    %edx,%eax\nmov    0xac(%rsp),%edx\ncmp    %eax,%ecx\ncmovg  %eax,%ecx\ncmp    %eax,%edx\ncmovge %edx,%eax\nmov    %ecx,0xc8(%rsp)\nmov    %eax,0xac(%rsp)\njmp    3ece <move_score_forced+0xde>\ncmp    $0x57,%r9b\njne    5fd8 <move_score_forced+0x21e8>\nadd    $0x1,%edx\njmp    5fd8 <move_score_forced+0x21e8>\nadd    $0x1,%ecx\njmp    5fd8 <move_score_forced+0x21e8>\ncmp    $0x57,%r9b\njne    5fb2 <move_score_forced+0x21c2>\nadd    $0x1,%edx\njmp    5fb2 <move_score_forced+0x21c2>\nadd    $0x1,%ecx\njmp    5fb2 <move_score_forced+0x21c2>\ncmp    $0x57,%r9b\njne    5f8c <move_score_forced+0x219c>\nadd    $0x1,%edx\njmp    5f8c <move_score_forced+0x219c>\nadd    $0x1,%ecx\njmp    5f8c <move_score_forced+0x219c>\ncmp    $0x57,%r9b\njne    5f66 <move_score_forced+0x2176>\nadd    $0x1,%edx\njmp    5f66 <move_score_forced+0x2176>\nadd    $0x1,%ecx\njmp    5f66 <move_score_forced+0x2176>\ncmp    $0x57,%r9b\njne    5f40 <move_score_forced+0x2150>\nadd    $0x1,%edx\njmp    5f40 <move_score_forced+0x2150>\nadd    $0x1,%ecx\njmp    5f40 <move_score_forced+0x2150>\ncmp    $0x57,%r9b\njne    5f1a <move_score_forced+0x212a>\nadd    $0x1,%edx\njmp    5f1a <move_score_forced+0x212a>\nadd    $0x1,%ecx\njmp    5f1a <move_score_forced+0x212a>\ncmp    $0x57,%r9b\njne    5ef4 <move_score_forced+0x2104>\nadd    $0x1,%edx\njmp    5ef4 <move_score_forced+0x2104>\nadd    $0x1,%ecx\njmp    5ef4 <move_score_forced+0x2104>\ncmp    $0x57,%r9b\njne    5ece <move_score_forced+0x20de>\nadd    $0x1,%edx\njmp    5ece <move_score_forced+0x20de>\nadd    $0x1,%ecx\njmp    5ece <move_score_forced+0x20de>\ncmp    $0x57,%dl\njne    5b36 <move_score_forced+0x1d46>\nadd    $0x1,%ecx\njmp    5b36 <move_score_forced+0x1d46>\ncmp    $0x77,%dl\njne    61ac <move_score_forced+0x23bc>\nadd    $0x1,%edi\njmp    5b4f <move_score_forced+0x1d5f>\ncmp    $0x57,%dl\njne    5b4f <move_score_forced+0x1d5f>\nadd    $0x1,%ecx\njmp    5b4f <move_score_forced+0x1d5f>\ncmp    $0x57,%dl\njne    5b93 <move_score_forced+0x1da3>\nadd    $0x1,%ecx\njmp    5b93 <move_score_forced+0x1da3>\nadd    $0x1,%esi\njmp    5b93 <move_score_forced+0x1da3>\nadd    $0x1,%r8d\njmp    5b93 <move_score_forced+0x1da3>\ncmp    $0x57,%dl\njne    5b71 <move_score_forced+0x1d81>\nadd    $0x1,%ecx\njmp    5b71 <move_score_forced+0x1d81>\nadd    $0x1,%esi\njmp    5b71 <move_score_forced+0x1d81>\nadd    $0x1,%r8d\njmp    5b71 <move_score_forced+0x1d81>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "outside_of_board", "content": "// check if a col/row input is outside of the board\nint outside_of_board(char col, char row) {\n\tif ((char_to_col(col) < 1) || (char_to_col(col) > BOARD_SIZE) \n\t\t|| (char_to_row(row) < 1) || (char_to_row(row) > BOARD_SIZE)) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "outside_of_board", "address": "0x2160", "label": "outside_of_board", "content": "int __fastcall outside_of_board(char col, char row)\n{\n  return (unsigned __int8)(row - 49) > 7u || (unsigned __int8)(col - 65) > 7u;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O3", "assembly": "<outside_of_board>:\nendbr64\nsub    $0x41,%edi\ncmp    $0x7,%dil\nseta   %al\nsub    $0x31,%esi\ncmp    $0x7,%sil\nseta   %dl\nor     %edx,%eax\nmovzbl %al,%eax\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "checkers/functions.c", "function_name": "piece_at_location", "content": "// return piece at a given character col/row input for a board_t input\nchar piece_at_location(board_t board_input, char col, char row) {\n\treturn board_input[char_to_col(col) - 1][char_to_row(row) - 1];\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "piece_at_location", "address": "0x2180", "label": "piece_at_location", "content": "char __fastcall piece_at_location(unsigned __int8 (*board_input)[8], char col, char row)\n{\n  return (*board_input)[8 * col - 569 + row];\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O3", "assembly": "<piece_at_location>:\nendbr64\nmovsbl %sil,%esi\nmovsbl %dl,%edx\nsub    $0x40,%esi\nsub    $0x31,%edx\nmovslq %esi,%rsi\nmovslq %edx,%rdx\nlea    (%rdi,%rsi,8),%rax\nmovzbl -0x8(%rdx,%rax,1),%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "print_board", "content": "// print a nice visual representation of the board given a board_t input\nvoid print_board(board_t* board_input) {\n\tlibmin_printf(\"     A   B   C   D   E   F   G   H\"); \n\t// note: main loop iterating through board row, sub loop iterates column\n\t\t// hence switched around iterating variables for clarity\n\tfor (int j=0; j<BOARD_SIZE; j++) {//row\n\t\tfor (int i=0; i<BOARD_SIZE; i++) {//column\n\t\t\tif (i==0) { \n\t\t\t\tlibmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n\t\t\t\tlibmin_printf(\" %d |\", j + 1);\n\t\t\t}\n\t\t\tif ((*board_input)[i][j] == CELL_EMPTY) {\n\t\t\t\tlibmin_printf(\" . |\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlibmin_printf(\" %c |\", (*board_input)[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tlibmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "print_board", "address": "0x1ff0", "label": "print_board", "content": "void __fastcall print_board(board_t *board_input)\n{\n  int v1; // r12d\n  __int64 i; // r15\n  __int64 v4; // rsi\n\n  v1 = 0;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  do\n  {\n    ++v1;\n    for ( i = 0LL; i != 8; ++i )\n    {\n      while ( 1 )\n      {\n        if ( !i )\n        {\n          libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n          libmin_printf(\" %d |\", v1);\n        }\n        v4 = (*board_input)[i][0];\n        if ( (_BYTE)v4 == 48 )\n          break;\n        ++i;\n        libmin_printf(\" %c |\", v4);\n        if ( i == 8 )\n          goto LABEL_8;\n      }\n      libmin_printf(\" . |\");\n    }\nLABEL_8:\n    board_input = (board_t *)((char *)board_input + 1);\n  }\n  while ( v1 != 8 );\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}\n"}, "pseudo_normalize": "void print_board(board_t *board_input) {\n  int v1;\n  long long i;\n  long long v4;\n  v1 = 0;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  do {\n    ++v1;\n    for (i = 0LL; i != 8; ++i) {\n      while (1) {\n        if (!i) {\n          libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n          libmin_printf(\" %d |\", v1);\n        }\n        v4 = (*board_input)[i][0];\n        if ((uint8_t)v4 == 48) break;\n        ++i;\n        libmin_printf(\" %c |\", v4);\n        if (i == 8) goto LABEL_8;\n      }\n      libmin_printf(\" . |\");\n    }\n  LABEL_8:\n    board_input = (board_t *)((char *)board_input + 1);\n  } while (v1 != 8);\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}", "binary": "checkers/checkers.host.O3", "assembly": "<print_board>:\nendbr64\npush   %r15\nxor    %eax,%eax\npush   %r14\nlea    0x8137(%rip),%r14\npush   %r13\nlea    0x8093(%rip),%r13\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nlea    0x808b(%rip),%rbp\npush   %rbx\nmov    %rdi,%rbx\nlea    0x80ee(%rip),%rdi\nsub    $0x8,%rsp\ncall   8d30 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r12d\nxor    %r15d,%r15d\njmp    2054 <print_board+0x64>\nnopl   0x0(%rax)\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x1,%r15\ncall   8d30 <libmin_printf>\ncmp    $0x8,%r15\nje     2078 <print_board+0x88>\ntest   %r15,%r15\nje     20a0 <print_board+0xb0>\nmovzbl (%rbx,%r15,8),%esi\ncmp    $0x30,%sil\njne    2040 <print_board+0x50>\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%r15\ncall   8d30 <libmin_printf>\ncmp    $0x8,%r15\njne    2054 <print_board+0x64>\nadd    $0x1,%rbx\ncmp    $0x8,%r12d\njne    2030 <print_board+0x40>\nadd    $0x8,%rsp\nmov    %r14,%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    8d30 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\nmov    %r12d,%esi\nlea    0x7fe3(%rip),%rdi\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\njmp    2059 <print_board+0x69>\nnopl   (%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "print_error_message", "content": "// simple function to print various error messages\nvoid print_error_message(int error_code) {\n\tif (error_code == 1) {\n\t\tlibmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n\t}\n\tif (error_code == 2) {\n\t\tlibmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n\t}\n\tif (error_code == 3) {\n\t\tlibmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n\t}\n\tif (error_code == 4) {\n\t\tlibmin_printf(\"ERROR: Target cell is not empty.\\n\");\n\t}\n\tif (error_code == 5) {\n\t\tlibmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n\t}\n\tif (error_code == 6) {\n\t\tlibmin_printf(\"ERROR: Illegal action.\\n\");\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "print_error_message", "address": "0x2d10", "label": "print_error_message", "content": "void __fastcall print_error_message(int error_code)\n{\n  switch ( error_code )\n  {\n    case 1:\n      libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n      break;\n    case 2:\n      libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n      break;\n    case 3:\n      libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n      break;\n    case 4:\n      libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n      break;\n    case 5:\n      libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n      break;\n    case 6:\n      libmin_printf(\"ERROR: Illegal action.\\n\");\n      break;\n  }\n}\n"}, "pseudo_normalize": "void print_error_message(int error_code) {\n  switch (error_code) {\n    case 1:\n      libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n      break;\n    case 2:\n      libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n      break;\n    case 3:\n      libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n      break;\n    case 4:\n      libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n      break;\n    case 5:\n      libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n      break;\n    case 6:\n      libmin_printf(\"ERROR: Illegal action.\\n\");\n      break;\n  }\n}", "binary": "checkers/checkers.host.O3", "assembly": "<print_error_message>:\nendbr64\nsub    $0x8,%rsp\ncmp    $0x1,%edi\nje     2da8 <print_error_message+0x98>\ncmp    $0x2,%edi\nje     2d90 <print_error_message+0x80>\ncmp    $0x3,%edi\nje     2d48 <print_error_message+0x38>\ncmp    $0x4,%edi\njne    2d60 <print_error_message+0x50>\nlea    0x7489(%rip),%rdi\nxor    %eax,%eax\nadd    $0x8,%rsp\njmp    8d30 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\nlea    0x7359(%rip),%rdi\nxor    %eax,%eax\nadd    $0x8,%rsp\njmp    8d30 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\ncmp    $0x5,%edi\njne    2d77 <print_error_message+0x67>\nlea    0x747c(%rip),%rdi\nxor    %eax,%eax\nadd    $0x8,%rsp\njmp    8d30 <libmin_printf>\ncmp    $0x6,%edi\njne    2d9e <print_error_message+0x8e>\nlea    0x7343(%rip),%rdi\nxor    %eax,%eax\nadd    $0x8,%rsp\njmp    8d30 <libmin_printf>\nxchg   %ax,%ax\nlea    0x73f9(%rip),%rdi\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\nlea    0x73b1(%rip),%rdi\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "print_move_information", "content": "//print some headers regarding move information\nvoid print_move_information(int generated_move, int black_action, \n\tboard_t board_input, int col1, int row1, int col2, int row2, int action) {\n\tlibmin_printf(\"=====================================\\n\");\n\tif (generated_move) {\n\t\tlibmin_printf(\"*** \");\n\t}\n\tif (black_action) {\n\t\tlibmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", \n\t\t\tBLACK, action, col1, row1, col2, row2);\n\t}\n\telse {\n\t\tlibmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", \n\t\t\tWHITE, action, col1, row1, col2, row2);\n\t}\n\tlibmin_printf(\"BOARD COST: %d\\n\", board_cost(board_input));\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "print_move_information", "address": "0x30c0", "label": "print_move_information", "content": "void __fastcall print_move_information(\n        int generated_move,\n        int black_action,\n        unsigned __int8 (*board_input)[8],\n        int col1,\n        int row1,\n        int col2,\n        int row2,\n        int action)\n{\n  unsigned __int8 *v11; // rax\n  int v12; // edx\n  int v13; // esi\n  int v14; // ecx\n  int v15; // edi\n  unsigned __int8 *v16; // r9\n  unsigned __int8 v17; // r8\n  unsigned __int8 v18; // r8\n  unsigned __int8 v19; // r8\n  unsigned __int8 v20; // r8\n  unsigned __int8 v21; // r8\n  unsigned __int8 v22; // r8\n  unsigned __int8 v23; // r8\n  unsigned __int8 v24; // r8\n\n  libmin_printf(\"=====================================\\n\");\n  if ( generated_move )\n    libmin_printf(\"*** \");\n  if ( black_action )\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      BLACK,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  else\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      WHITE,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  v11 = (unsigned __int8 *)board_input;\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  v15 = 0;\n  v16 = &(*board_input)[64];\n  do\n  {\n    while ( 1 )\n    {\n      v24 = *v11;\n      if ( *v11 != 98 )\n        break;\n      v17 = v11[1];\n      ++v15;\n      if ( v17 == 98 )\n        goto LABEL_40;\nLABEL_10:\n      switch ( v17 )\n      {\n        case 'B':\n          ++v14;\n          break;\n        case 'w':\n          ++v13;\n          break;\n        case 'W':\n          ++v12;\n          break;\n      }\n      v18 = v11[2];\n      if ( v18 != 98 )\n        goto LABEL_14;\nLABEL_41:\n      v19 = v11[3];\n      ++v15;\n      if ( v19 == 98 )\n        goto LABEL_42;\nLABEL_18:\n      switch ( v19 )\n      {\n        case 'B':\n          ++v14;\n          break;\n        case 'w':\n          ++v13;\n          break;\n        case 'W':\n          ++v12;\n          break;\n      }\n      v20 = v11[4];\n      if ( v20 != 98 )\n        goto LABEL_22;\nLABEL_43:\n      v21 = v11[5];\n      ++v15;\n      if ( v21 == 98 )\n        goto LABEL_44;\nLABEL_26:\n      switch ( v21 )\n      {\n        case 'B':\n          ++v14;\n          break;\n        case 'w':\n          ++v13;\n          break;\n        case 'W':\n          ++v12;\n          break;\n      }\n      v22 = v11[6];\n      if ( v22 != 98 )\n        goto LABEL_30;\nLABEL_45:\n      v23 = v11[7];\n      ++v15;\n      if ( v23 != 98 )\n        goto LABEL_34;\nLABEL_46:\n      v11 += 8;\n      ++v15;\n      if ( v16 == v11 )\n        goto LABEL_47;\n    }\n    switch ( v24 )\n    {\n      case 'B':\n        ++v14;\n        break;\n      case 'w':\n        ++v13;\n        break;\n      case 'W':\n        ++v12;\n        break;\n    }\n    v17 = v11[1];\n    if ( v17 != 98 )\n      goto LABEL_10;\nLABEL_40:\n    v18 = v11[2];\n    ++v15;\n    if ( v18 == 98 )\n      goto LABEL_41;\nLABEL_14:\n    switch ( v18 )\n    {\n      case 'B':\n        ++v14;\n        break;\n      case 'w':\n        ++v13;\n        break;\n      case 'W':\n        ++v12;\n        break;\n    }\n    v19 = v11[3];\n    if ( v19 != 98 )\n      goto LABEL_18;\nLABEL_42:\n    v20 = v11[4];\n    ++v15;\n    if ( v20 == 98 )\n      goto LABEL_43;\nLABEL_22:\n    switch ( v20 )\n    {\n      case 'B':\n        ++v14;\n        break;\n      case 'w':\n        ++v13;\n        break;\n      case 'W':\n        ++v12;\n        break;\n    }\n    v21 = v11[5];\n    if ( v21 != 98 )\n      goto LABEL_26;\nLABEL_44:\n    v22 = v11[6];\n    ++v15;\n    if ( v22 == 98 )\n      goto LABEL_45;\nLABEL_30:\n    switch ( v22 )\n    {\n      case 'B':\n        ++v14;\n        break;\n      case 'w':\n        ++v13;\n        break;\n      case 'W':\n        ++v12;\n        break;\n    }\n    v23 = v11[7];\n    if ( v23 == 98 )\n      goto LABEL_46;\nLABEL_34:\n    switch ( v23 )\n    {\n      case 'B':\n        ++v14;\n        break;\n      case 'w':\n        ++v13;\n        break;\n      case 'W':\n        ++v12;\n        break;\n    }\n    v11 += 8;\n  }\n  while ( v16 != v11 );\nLABEL_47:\n  libmin_printf(\"BOARD COST: %d\\n\", v15 + 3 * v14 - v13 - 3 * v12);\n}\n"}, "pseudo_normalize": "void print_move_information(int generated_move, int black_action,\n                            unsigned char (*board_input)[8], int col1, int row1,\n                            int col2, int row2, int action) {\n  unsigned char *v11;\n  int v12;\n  int v13;\n  int v14;\n  int v15;\n  unsigned char *v16;\n  unsigned char v17;\n  unsigned char v18;\n  unsigned char v19;\n  unsigned char v20;\n  unsigned char v21;\n  unsigned char v22;\n  unsigned char v23;\n  unsigned char v24;\n  libmin_printf(\"=====================================\\n\");\n  if (generated_move) libmin_printf(\"*** \");\n  if (black_action)\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", BLACK, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  else\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", WHITE, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  v11 = (unsigned char *)board_input;\n  v12 = 0;\n  v13 = 0;\n  v14 = 0;\n  v15 = 0;\n  v16 = &(*board_input)[64];\n  do {\n    while (1) {\n      v24 = *v11;\n      if (*v11 != 98) break;\n      v17 = v11[1];\n      ++v15;\n      if (v17 == 98) goto LABEL_40;\n    LABEL_10:\n      switch (v17) {\n        case 'B':\n          ++v14;\n          break;\n        case 'w':\n          ++v13;\n          break;\n        case 'W':\n          ++v12;\n          break;\n      }\n      v18 = v11[2];\n      if (v18 != 98) goto LABEL_14;\n    LABEL_41:\n      v19 = v11[3];\n      ++v15;\n      if (v19 == 98) goto LABEL_42;\n    LABEL_18:\n      switch (v19) {\n        case 'B':\n          ++v14;\n          break;\n        case 'w':\n          ++v13;\n          break;\n        case 'W':\n          ++v12;\n          break;\n      }\n      v20 = v11[4];\n      if (v20 != 98) goto LABEL_22;\n    LABEL_43:\n      v21 = v11[5];\n      ++v15;\n      if (v21 == 98) goto LABEL_44;\n    LABEL_26:\n      switch (v21) {\n        case 'B':\n          ++v14;\n          break;\n        case 'w':\n          ++v13;\n          break;\n        case 'W':\n          ++v12;\n          break;\n      }\n      v22 = v11[6];\n      if (v22 != 98) goto LABEL_30;\n    LABEL_45:\n      v23 = v11[7];\n      ++v15;\n      if (v23 != 98) goto LABEL_34;\n    LABEL_46:\n      v11 += 8;\n      ++v15;\n      if (v16 == v11) goto LABEL_47;\n    }\n    switch (v24) {\n      case 'B':\n        ++v14;\n        break;\n      case 'w':\n        ++v13;\n        break;\n      case 'W':\n        ++v12;\n        break;\n    }\n    v17 = v11[1];\n    if (v17 != 98) goto LABEL_10;\n  LABEL_40:\n    v18 = v11[2];\n    ++v15;\n    if (v18 == 98) goto LABEL_41;\n  LABEL_14:\n    switch (v18) {\n      case 'B':\n        ++v14;\n        break;\n      case 'w':\n        ++v13;\n        break;\n      case 'W':\n        ++v12;\n        break;\n    }\n    v19 = v11[3];\n    if (v19 != 98) goto LABEL_18;\n  LABEL_42:\n    v20 = v11[4];\n    ++v15;\n    if (v20 == 98) goto LABEL_43;\n  LABEL_22:\n    switch (v20) {\n      case 'B':\n        ++v14;\n        break;\n      case 'w':\n        ++v13;\n        break;\n      case 'W':\n        ++v12;\n        break;\n    }\n    v21 = v11[5];\n    if (v21 != 98) goto LABEL_26;\n  LABEL_44:\n    v22 = v11[6];\n    ++v15;\n    if (v22 == 98) goto LABEL_45;\n  LABEL_30:\n    switch (v22) {\n      case 'B':\n        ++v14;\n        break;\n      case 'w':\n        ++v13;\n        break;\n      case 'W':\n        ++v12;\n        break;\n    }\n    v23 = v11[7];\n    if (v23 == 98) goto LABEL_46;\n  LABEL_34:\n    switch (v23) {\n      case 'B':\n        ++v14;\n        break;\n      case 'w':\n        ++v13;\n        break;\n      case 'W':\n        ++v12;\n        break;\n    }\n    v11 += 8;\n  } while (v16 != v11);\nLABEL_47:\n  libmin_printf(\"BOARD COST: %d\\n\", v15 + 3 * v14 - v13 - 3 * v12);\n}", "binary": "checkers/checkers.host.O3", "assembly": "<print_move_information>:\nendbr64\npush   %r15\npush   %r14\nmov    %r9d,%r14d\npush   %r13\nmov    %r8d,%r13d\npush   %r12\nmov    %ecx,%r12d\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmov    %edi,%ebx\nlea    0x713e(%rip),%rdi\nsub    $0x18,%rsp\nmov    0x50(%rsp),%eax\nmov    0x58(%rsp),%r15d\nmov    %rdx,(%rsp)\nmov    %eax,0xc(%rsp)\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\ntest   %ebx,%ebx\njne    3479 <print_move_information+0x3b9>\ntest   %ebp,%ebp\nje     3448 <print_move_information+0x388>\nsub    $0x8,%rsp\nmov    %r12d,%ecx\nmov    %r14d,%r9d\nmov    %r13d,%r8d\nmov    0x14(%rsp),%eax\nlea    0x9f80(%rip),%rsi\nmov    %r15d,%edx\nlea    0x6fb3(%rip),%rdi\npush   %rax\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\npop    %rcx\npop    %rsi\nmov    (%rsp),%rax\nxor    %edx,%edx\nxor    %esi,%esi\nxor    %ecx,%ecx\nxor    %edi,%edi\nlea    0x40(%rax),%r9\njmp    327e <print_move_information+0x1be>\nnop\ncmp    $0x42,%r8b\nje     3440 <print_move_information+0x380>\ncmp    $0x77,%r8b\njne    3428 <print_move_information+0x368>\nadd    $0x1,%esi\nmovzbl 0x1(%rax),%r8d\ncmp    $0x62,%r8b\nje     329e <print_move_information+0x1de>\ncmp    $0x42,%r8b\nje     3420 <print_move_information+0x360>\ncmp    $0x77,%r8b\njne    3408 <print_move_information+0x348>\nadd    $0x1,%esi\nmovzbl 0x2(%rax),%r8d\ncmp    $0x62,%r8b\nje     32b0 <print_move_information+0x1f0>\ncmp    $0x42,%r8b\nje     3400 <print_move_information+0x340>\ncmp    $0x77,%r8b\njne    33e8 <print_move_information+0x328>\nadd    $0x1,%esi\nmovzbl 0x3(%rax),%r8d\ncmp    $0x62,%r8b\nje     32c2 <print_move_information+0x202>\ncmp    $0x42,%r8b\nje     33e0 <print_move_information+0x320>\ncmp    $0x77,%r8b\njne    33c8 <print_move_information+0x308>\nadd    $0x1,%esi\nmovzbl 0x4(%rax),%r8d\ncmp    $0x62,%r8b\nje     32d4 <print_move_information+0x214>\ncmp    $0x42,%r8b\nje     33c0 <print_move_information+0x300>\ncmp    $0x77,%r8b\njne    33a8 <print_move_information+0x2e8>\nadd    $0x1,%esi\nmovzbl 0x5(%rax),%r8d\ncmp    $0x62,%r8b\nje     32e6 <print_move_information+0x226>\ncmp    $0x42,%r8b\nje     33a0 <print_move_information+0x2e0>\ncmp    $0x77,%r8b\njne    3388 <print_move_information+0x2c8>\nadd    $0x1,%esi\nmovzbl 0x6(%rax),%r8d\ncmp    $0x62,%r8b\nje     32f8 <print_move_information+0x238>\ncmp    $0x42,%r8b\nje     3380 <print_move_information+0x2c0>\ncmp    $0x77,%r8b\njne    3368 <print_move_information+0x2a8>\nadd    $0x1,%esi\nmovzbl 0x7(%rax),%r8d\ncmp    $0x62,%r8b\nje     330a <print_move_information+0x24a>\ncmp    $0x42,%r8b\nje     3360 <print_move_information+0x2a0>\ncmp    $0x77,%r8b\njne    3349 <print_move_information+0x289>\nadd    $0x1,%esi\nadd    $0x8,%rax\ncmp    %rax,%r9\nje     331a <print_move_information+0x25a>\nmovzbl (%rax),%r8d\ncmp    $0x62,%r8b\njne    3150 <print_move_information+0x90>\nmovzbl 0x1(%rax),%r8d\nadd    $0x1,%edi\ncmp    $0x62,%r8b\njne    3176 <print_move_information+0xb6>\nmovzbl 0x2(%rax),%r8d\nadd    $0x1,%edi\ncmp    $0x62,%r8b\njne    319c <print_move_information+0xdc>\nmovzbl 0x3(%rax),%r8d\nadd    $0x1,%edi\ncmp    $0x62,%r8b\njne    31c2 <print_move_information+0x102>\nmovzbl 0x4(%rax),%r8d\nadd    $0x1,%edi\ncmp    $0x62,%r8b\njne    31e8 <print_move_information+0x128>\nmovzbl 0x5(%rax),%r8d\nadd    $0x1,%edi\ncmp    $0x62,%r8b\njne    320e <print_move_information+0x14e>\nmovzbl 0x6(%rax),%r8d\nadd    $0x1,%edi\ncmp    $0x62,%r8b\njne    3234 <print_move_information+0x174>\nmovzbl 0x7(%rax),%r8d\nadd    $0x1,%edi\ncmp    $0x62,%r8b\njne    325a <print_move_information+0x19a>\nadd    $0x8,%rax\nadd    $0x1,%edi\ncmp    %rax,%r9\njne    327e <print_move_information+0x1be>\nlea    (%rcx,%rcx,2),%eax\nlea    0x0(,%rdx,4),%ecx\nadd    $0x18,%rsp\nadd    %edi,%eax\nsub    %ecx,%edx\nlea    0x6dca(%rip),%rdi\npop    %rbx\nsub    %esi,%eax\npop    %rbp\npop    %r12\nlea    (%rax,%rdx,1),%esi\npop    %r13\nxor    %eax,%eax\npop    %r14\npop    %r15\njmp    8d30 <libmin_printf>\ncmp    $0x57,%r8b\njne    3271 <print_move_information+0x1b1>\nadd    $0x1,%edx\njmp    3271 <print_move_information+0x1b1>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    3271 <print_move_information+0x1b1>\ncmp    $0x57,%r8b\njne    324b <print_move_information+0x18b>\nadd    $0x1,%edx\njmp    324b <print_move_information+0x18b>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    324b <print_move_information+0x18b>\ncmp    $0x57,%r8b\njne    3225 <print_move_information+0x165>\nadd    $0x1,%edx\njmp    3225 <print_move_information+0x165>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    3225 <print_move_information+0x165>\ncmp    $0x57,%r8b\njne    31ff <print_move_information+0x13f>\nadd    $0x1,%edx\njmp    31ff <print_move_information+0x13f>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    31ff <print_move_information+0x13f>\ncmp    $0x57,%r8b\njne    31d9 <print_move_information+0x119>\nadd    $0x1,%edx\njmp    31d9 <print_move_information+0x119>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    31d9 <print_move_information+0x119>\ncmp    $0x57,%r8b\njne    31b3 <print_move_information+0xf3>\nadd    $0x1,%edx\njmp    31b3 <print_move_information+0xf3>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    31b3 <print_move_information+0xf3>\ncmp    $0x57,%r8b\njne    318d <print_move_information+0xcd>\nadd    $0x1,%edx\njmp    318d <print_move_information+0xcd>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    318d <print_move_information+0xcd>\ncmp    $0x57,%r8b\njne    3167 <print_move_information+0xa7>\nadd    $0x1,%edx\njmp    3167 <print_move_information+0xa7>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%ecx\njmp    3167 <print_move_information+0xa7>\nsub    $0x8,%rsp\nmov    %r15d,%edx\nmov    %r14d,%r9d\nmov    %r13d,%r8d\nmov    0x14(%rsp),%eax\nmov    %r12d,%ecx\nlea    0x9c3d(%rip),%rsi\nlea    0x6c79(%rip),%rdi\npush   %rax\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\npop    %rax\npop    %rdx\njmp    313a <print_move_information+0x7a>\nlea    0x6c5e(%rip),%rdi\nxor    %eax,%eax\ncall   8d30 <libmin_printf>\njmp    3106 <print_move_information+0x46>\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "row_to_char", "content": "// reverse char_to_row\nchar row_to_char(int row) {return (char) (ASCII_1 + row - 1);}\n"}, "pseudo": {"path": "checkers/checkers.host.O3.pseudo", "function_name": "row_to_char", "address": "0x1fe0", "label": "row_to_char", "content": "char __fastcall row_to_char(int row)\n{\n  return row + 48;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O3", "assembly": "<row_to_char>:\nendbr64\nlea    0x30(%rdi),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "cipher/cipher.c", "function_name": "decipher", "content": "void\ndecipher(uint32_t *const in,\n\t uint32_t *const out,\n\t const uint32_t *const key)\n{\n  uint32_t y=in[0], z=in[1], sum=0xC6EF3720, delta=0x9E3779B9;\n  uint32_t a=key[0], b=key[1], c=key[2], d=key[3], n=32;\n\n  /* sum = delta<<5, in general sum = delta * n */\n  while (n-->0)\n    {\n      z -= ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);\n      y -= ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);\n      sum -= delta;\n    }\n  out[0]=y; out[1]=z;\n}\n"}, "pseudo": {"path": "cipher/cipher.host.O3.pseudo", "function_name": "decipher", "address": "0x1360", "label": "decipher", "content": "void __fastcall decipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t v4; // ecx\n  uint32_t v5; // esi\n  uint32_t v6; // r11d\n  uint32_t v7; // r9d\n  uint32_t v8; // r8d\n  uint32_t v9; // edi\n  int v10; // edx\n\n  v4 = in[1];\n  v5 = *in;\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  v10 = -957401312;\n  do\n  {\n    v4 -= (v5 + v10) ^ (v9 + (v5 >> 5)) ^ (v8 + 16 * v5);\n    v5 -= (v4 + v10) ^ (v7 + (v4 >> 5)) ^ (v6 + 16 * v4);\n    v10 += 1640531527;\n  }\n  while ( v10 );\n  *out = v5;\n  out[1] = v4;\n}\n"}, "pseudo_normalize": "void decipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint32_t v7;\n  uint32_t v8;\n  uint32_t v9;\n  int v10;\n  v4 = in[1];\n  v5 = *in;\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  v10 = -957401312;\n  do {\n    v4 -= (v5 + v10) ^ (v9 + (v5 >> 5)) ^ (v8 + 16 * v5);\n    v5 -= (v4 + v10) ^ (v7 + (v4 >> 5)) ^ (v6 + 16 * v4);\n    v10 += 1640531527;\n  } while (v10);\n  *out = v5;\n  out[1] = v4;\n}", "binary": "cipher/cipher.host.O3", "assembly": "<decipher>:\nendbr64\npush   %rbx\nmov    %rsi,%r10\nmov    0x4(%rdi),%ecx\nmov    (%rdi),%esi\nmov    (%rdx),%r11d\nmov    0x4(%rdx),%r9d\nmov    0x8(%rdx),%r8d\nmov    0xc(%rdx),%edi\nmov    $0xc6ef3720,%edx\nmov    %esi,%eax\nmov    %esi,%ebx\nshl    $0x4,%eax\nshr    $0x5,%ebx\nadd    %edi,%ebx\nadd    %r8d,%eax\nxor    %ebx,%eax\nlea    (%rsi,%rdx,1),%ebx\nxor    %ebx,%eax\nsub    %eax,%ecx\nmov    %ecx,%eax\nmov    %ecx,%ebx\nshl    $0x4,%eax\nshr    $0x5,%ebx\nadd    %r9d,%ebx\nadd    %r11d,%eax\nxor    %ebx,%eax\nlea    (%rcx,%rdx,1),%ebx\nxor    %ebx,%eax\nsub    %eax,%esi\nadd    $0x61c88647,%edx\njne    1380 <decipher+0x20>\nmov    %esi,(%r10)\npop    %rbx\nmov    %ecx,0x4(%r10)\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "cipher/cipher.c", "function_name": "encipher", "content": "#include \"libmin.h\"\n\nvoid\nencipher(uint32_t *const in,\n\t uint32_t *const out,\n\t const uint32_t *const key)\n{\n  uint32_t y=in[0], z=in[1], sum=0, delta=0x9E3779B9;\n  uint32_t a=key[0], b=key[1], c=key[2], d=key[3], n=32;\n\n  while (n-->0)\n    {\n      sum += delta;\n      y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);\n      z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);\n    }\n  out[0]=y; out[1]=z;\n}\n"}, "pseudo": {"path": "cipher/cipher.host.O3.pseudo", "function_name": "encipher", "address": "0x12f0", "label": "encipher", "content": "void __fastcall encipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t v4; // ecx\n  uint32_t v5; // esi\n  uint32_t v6; // r11d\n  uint32_t v7; // r9d\n  uint32_t v8; // r8d\n  uint32_t v9; // edi\n  int i; // edx\n\n  v4 = in[1];\n  v5 = *in;\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  for ( i = 0; i != -957401312; v4 += (i + v5) ^ (v9 + (v5 >> 5)) ^ (v8 + 16 * v5) )\n  {\n    i -= 1640531527;\n    v5 += (i + v4) ^ (v7 + (v4 >> 5)) ^ (v6 + 16 * v4);\n  }\n  *out = v5;\n  out[1] = v4;\n}\n"}, "pseudo_normalize": "void encipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint32_t v7;\n  uint32_t v8;\n  uint32_t v9;\n  int i;\n  v4 = in[1];\n  v5 = *in;\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  for (i = 0; i != -957401312;\n       v4 += (i + v5) ^ (v9 + (v5 >> 5)) ^ (v8 + 16 * v5)) {\n    i -= 1640531527;\n    v5 += (i + v4) ^ (v7 + (v4 >> 5)) ^ (v6 + 16 * v4);\n  }\n  *out = v5;\n  out[1] = v4;\n}", "binary": "cipher/cipher.host.O3", "assembly": "<encipher>:\nendbr64\npush   %rbx\nmov    %rsi,%r10\nmov    0x4(%rdi),%ecx\nmov    (%rdi),%esi\nmov    (%rdx),%r11d\nmov    0x4(%rdx),%r9d\nmov    0x8(%rdx),%r8d\nmov    0xc(%rdx),%edi\nxor    %edx,%edx\nnopl   (%rax)\nmov    %ecx,%eax\nmov    %ecx,%ebx\nsub    $0x61c88647,%edx\nshl    $0x4,%eax\nshr    $0x5,%ebx\nadd    %r9d,%ebx\nadd    %r11d,%eax\nxor    %ebx,%eax\nlea    (%rdx,%rcx,1),%ebx\nxor    %ebx,%eax\nadd    %eax,%esi\nmov    %esi,%eax\nmov    %esi,%ebx\nshl    $0x4,%eax\nshr    $0x5,%ebx\nadd    %edi,%ebx\nadd    %r8d,%eax\nxor    %ebx,%eax\nlea    (%rdx,%rsi,1),%ebx\nxor    %ebx,%eax\nadd    %eax,%ecx\ncmp    $0xc6ef3720,%edx\njne    1310 <encipher+0x20>\nmov    %esi,(%r10)\npop    %rbx\nmov    %ecx,0x4(%r10)\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "cipher/cipher.c", "function_name": "main", "content": "int\nmain(void)\n{\n\n  encipher(plaintext, ciphertext, keytext);\n  if (ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1])\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if (newplain[0] != plaintext[0] || newplain[1] != plaintext[1])\n    libmin_fail(2);\n  \n  libmin_printf(\"TEA Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n  libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0], ciphertext[1]);\n  libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "cipher/cipher.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  encipher(plaintext, ciphertext, keytext);\n  if ( ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1] )\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if ( newplain[0] == plaintext[0] && newplain[1] == plaintext[1] )\n  {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0], ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  encipher(plaintext, ciphertext, keytext);\n  if (ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1])\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if (newplain[0] == plaintext[0] && newplain[1] == plaintext[1]) {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0],\n                  ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}", "binary": "cipher/cipher.host.O3", "assembly": "<main>:\nendbr64\npush   %r12\nlea    0x4f13(%rip),%r12\nlea    0x4f04(%rip),%rdi\npush   %rbp\nlea    0x517c(%rip),%rbp\nmov    %r12,%rdx\nmov    %rbp,%rsi\nsub    $0x8,%rsp\ncall   12f0 <encipher>\nmov    0x4edf(%rip),%eax\ncmp    %eax,0x5161(%rip)\njne    1147 <main+0x47>\nmov    0x4ed5(%rip),%eax\ncmp    %eax,0x5157(%rip)\nje     1151 <main+0x51>\nmov    $0x1,%edi\ncall   15b0 <libmin_fail>\nmov    %r12,%rdx\nlea    0x5135(%rip),%rsi\nmov    %rbp,%rdi\ncall   1360 <decipher>\nmov    0x4eaf(%rip),%eax\ncmp    %eax,0x5121(%rip)\njne    117f <main+0x7f>\nmov    0x4ea5(%rip),%eax\ncmp    %eax,0x5117(%rip)\nje     1189 <main+0x89>\nmov    $0x2,%edi\ncall   15b0 <libmin_fail>\nlea    0x2e74(%rip),%rdi\nxor    %eax,%eax\ncall   34c0 <libmin_printf>\nmov    0x4e7f(%rip),%edx\nmov    0x4e75(%rip),%esi\nxor    %eax,%eax\nlea    0x2e6d(%rip),%rdi\ncall   34c0 <libmin_printf>\nmov    0x50e5(%rip),%edx\nmov    0x50db(%rip),%esi\nxor    %eax,%eax\nlea    0x2e70(%rip),%rdi\ncall   34c0 <libmin_printf>\nmov    0x50c3(%rip),%edx\nmov    0x50b9(%rip),%esi\nxor    %eax,%eax\nlea    0x2e73(%rip),%rdi\ncall   34c0 <libmin_printf>\ncall   3700 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "congrad/congrad.c", "function_name": "main", "content": "int main(void) {\n    cg_build_matrix(CG_N);\n    cg_solve(CG_N);\n    uint64_t sum = cg_checksum(CG_N*CG_N);\n\n    libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\",\n           CG_N, CG_ITERS, (uint32_t)(sum >> 32), (uint32_t)sum);\n\n    libmin_success();\n}\n"}, "pseudo": {"path": "congrad/congrad.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // edx\n  int v4; // r8d\n  int v5; // eax\n  __int64 v6; // rcx\n  __int64 v7; // rcx\n  int v8; // ecx\n  __int64 v9; // rdi\n  int v10; // edi\n  int v11; // edx\n  int v12; // edi\n  int i; // eax\n  __int64 v14; // rsi\n  __int64 v15; // rsi\n  __int64 v16; // rsi\n  int v17; // esi\n  int *v18; // rcx\n  int v19; // edx\n  int v20; // esi\n  int v21; // eax\n  int v22; // edi\n  int v23; // eax\n  int v24; // eax\n  int v25; // edx\n  double *v26; // rax\n  int *v27; // r11\n  double *v28; // rbx\n  double *v29; // r10\n  __int64 v30; // rax\n  double j; // xmm1_8\n  double v32; // xmm0_8\n  __int64 k; // rax\n  __m128d v34; // xmm0\n  __int128 v35; // xmm4\n  double *v36; // rax\n  __m128d v37; // xmm0\n  __m128d v38; // xmm0\n  __m128d v39; // xmm6\n  int v40; // r15d\n  int *v41; // r9\n  double *v42; // rcx\n  __int64 v43; // rax\n  double m; // xmm1_8\n  double v45; // xmm0_8\n  __int64 v46; // rax\n  double v47; // xmm1_8\n  __m128d v48; // xmm0\n  double *v49; // rcx\n  __m128d v50; // xmm2\n  double *v51; // rdx\n  double *v52; // r9\n  double *v53; // rax\n  __m128d v54; // xmm1\n  __m128d v55; // xmm0\n  __m128d v56; // xmm2\n  double *v57; // r9\n  double *v58; // rax\n  __m128d v59; // xmm1\n  __m128d v60; // xmm0\n  double *v61; // rax\n  __int128 v62; // xmm1\n  __m128d v63; // xmm0\n  __m128d v64; // xmm0\n  __m128d v65; // xmm2\n  double *v66; // rax\n  __m128d v67; // xmm2\n  __m128d v68; // xmm0\n  unsigned __int64 v69; // rax\n  double v70; // xmm0_8\n\n  v3 = 0;\n  v4 = 0;\n  v5 = 1;\n  row_ptr[0] = 0;\n  col_idx[0] = 0;\n  val[0] = 4.0;\n  while ( 1 )\n  {\n    if ( v3 <= 991 )\n    {\n      v6 = v5++;\n      col_idx[v6] = v3 + 32;\n    }\n    if ( (v3 & 0x1F) != 0 )\n    {\n      v7 = v5++;\n      col_idx[v7] = v3 - 1;\n    }\n    v8 = v3 + 1;\n    if ( v4 != 31 )\n    {\n      v9 = v5++;\n      col_idx[v9] = v8;\n    }\n    if ( v3 == 1023 )\n      break;\n    col_idx[v5] = v8;\n    v4 = v8 & 0x1F;\n    v10 = v5 + 1;\n    if ( v8 <= 31 )\n    {\n      ++v5;\n    }\n    else\n    {\n      v5 += 2;\n      col_idx[v10] = v3 - 31;\n    }\n    ++v3;\n  }\n  v11 = 0;\n  v12 = 0;\n  for ( i = 1; ; ++i )\n  {\nLABEL_14:\n    v14 = i++;\n    val[v14] = -1.0;\n    while ( 1 )\n    {\n      if ( (v11 & 0x1F) != 0 )\n      {\n        v15 = i++;\n        val[v15] = -1.0;\n      }\n      ++v11;\n      if ( v12 != 31 )\n      {\n        v16 = i++;\n        val[v16] = -1.0;\n      }\n      if ( v11 == 1024 )\n      {\n        v18 = &row_ptr[1];\n        v19 = 0;\n        v20 = 0;\n        v21 = 1;\n        while ( 1 )\n        {\n          v23 = (v19 < 992) + v21 - (((v19 & 0x1F) == 0) - 1);\n          ++v19;\n          v24 = (v20 != 31) + v23;\n          if ( v19 == 1024 )\n            break;\n          *v18 = v24;\n          v22 = v24 + 1;\n          v21 = v24 + 2;\n          v20 = v19 & 0x1F;\n          if ( v19 <= 31 )\n            v21 = v22;\n          ++v18;\n        }\n        row_ptr[1024] = v24;\n        v25 = cg_rng;\n        memset(x, 0, sizeof(x));\n        v26 = b;\n        do\n        {\n          ++v26;\n          v25 = 1664525 * v25 + 1013904223;\n          *(v26 - 1) = (double)(v25 & 0xFFFFFF) * 0.00000005960464477539062;\n        }\n        while ( &b[1024] != v26 );\n        cg_rng = v25;\n        v27 = &row_ptr[1];\n        v28 = &Ap[1024];\n        v29 = Ap;\n        while ( 1 )\n        {\n          v30 = *(v27 - 1);\n          for ( j = 0.0; *v27 > (int)v30; j = j + v32 )\n          {\n            v32 = x[col_idx[v30]] * val[v30];\n            ++v30;\n          }\n          *v29++ = j;\n          ++v27;\n          if ( v28 == v29 )\n          {\n            for ( k = 0LL; k != 1024; k += 2LL )\n            {\n              v34 = _mm_sub_pd(*(__m128d *)&b[k], *(__m128d *)&Ap[k]);\n              *(__m128d *)&r[k] = v34;\n              *(__m128d *)&p[k] = v34;\n            }\n            v35 = 0LL;\n            v36 = &b[-1024];\n            do\n            {\n              v37 = *(__m128d *)v36;\n              v36 += 2;\n              v38 = _mm_mul_pd(v37, v37);\n              *(double *)&v35 = *(double *)&v35 + v38.m128d_f64[0] + _mm_unpackhi_pd(v38, v38).m128d_f64[0];\n            }\n            while ( b != v36 );\n            v39 = (__m128d)_mm_loadl_epi64((const __m128i *)&qword_4060);\n            v40 = 25;\n            while ( 1 )\n            {\n              v41 = &row_ptr[1];\n              v42 = Ap;\n              do\n              {\n                v43 = *(v41 - 1);\n                for ( m = 0.0; *v41 > (int)v43; m = m + v45 )\n                {\n                  v45 = p[col_idx[v43]] * val[v43];\n                  ++v43;\n                }\n                *v42++ = m;\n                ++v41;\n              }\n              while ( v42 != v28 );\n              v46 = 0LL;\n              v47 = 0.0;\n              do\n              {\n                v48 = _mm_mul_pd(*(__m128d *)&Ap[v46], *(__m128d *)&p[v46]);\n                v46 += 2LL;\n                v47 = v47 + v48.m128d_f64[0] + _mm_unpackhi_pd(v48, v48).m128d_f64[0];\n              }\n              while ( v46 != 1024 );\n              v50.m128d_f64[1] = *((double *)&v35 + 1);\n              v49 = x;\n              v50.m128d_f64[0] = *(double *)&v35 / v47;\n              v51 = p;\n              v52 = p;\n              v53 = x;\n              v54 = _mm_unpacklo_pd(v50, v50);\n              do\n              {\n                v55 = *(__m128d *)v52;\n                v53 += 2;\n                v52 += 2;\n                *((__m128d *)v53 - 1) = _mm_add_pd(_mm_mul_pd(v55, v54), *(__m128d *)(v53 - 2));\n              }\n              while ( v53 != val );\n              v56 = _mm_xor_pd(v50, v39);\n              v57 = Ap;\n              v58 = r;\n              v59 = _mm_unpacklo_pd(v56, v56);\n              do\n              {\n                v60 = *(__m128d *)v57;\n                v58 += 2;\n                v57 += 2;\n                *((__m128d *)v58 - 1) = _mm_add_pd(_mm_mul_pd(v60, v59), *(__m128d *)(v58 - 2));\n              }\n              while ( v58 != b );\n              v61 = r;\n              v62 = 0LL;\n              do\n              {\n                v63 = *(__m128d *)v61;\n                v61 += 2;\n                v64 = _mm_mul_pd(v63, v63);\n                *(double *)&v62 = *(double *)&v62 + v64.m128d_f64[0] + _mm_unpackhi_pd(v64, v64).m128d_f64[0];\n              }\n              while ( v61 != b );\n              if ( *(double *)&v62 < 1.0e-12 )\n                goto LABEL_57;\n              v65.m128d_f64[1] = 0.0;\n              v66 = r;\n              v65.m128d_f64[0] = *(double *)&v62 / *(double *)&v35;\n              v67 = _mm_unpacklo_pd(v65, v65);\n              do\n              {\n                v68 = *(__m128d *)v51;\n                v51 += 2;\n                v66 += 2;\n                *((__m128d *)v51 - 1) = _mm_add_pd(_mm_mul_pd(v68, v67), *(__m128d *)(v66 - 2));\n              }\n              while ( v51 != r );\n              if ( !--v40 )\n              {\nLABEL_57:\n                v69 = 0x9E3779B97F4A7C15LL;\n                do\n                {\n                  v70 = *v49++;\n                  v69 ^= (v69 >> 2) + (v69 << 6) + (unsigned int)(int)(v70 * 1000000.0);\n                }\n                while ( v49 != val );\n                libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25, HIDWORD(v69), v69);\n                libmin_success();\n              }\n              v35 = v62;\n            }\n          }\n        }\n      }\n      v17 = i + 1;\n      v12 = v11 & 0x1F;\n      val[i] = 4.0;\n      if ( v11 <= 31 )\n        break;\n      i += 2;\n      val[v17] = -1.0;\n      if ( v11 <= 991 )\n        goto LABEL_14;\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  long long v6;\n  long long v7;\n  int v8;\n  long long v9;\n  int v10;\n  int v11;\n  int v12;\n  int i;\n  long long v14;\n  long long v15;\n  long long v16;\n  int v17;\n  int *v18;\n  int v19;\n  int v20;\n  int v21;\n  int v22;\n  int v23;\n  int v24;\n  int v25;\n  double *v26;\n  int *v27;\n  double *v28;\n  double *v29;\n  long long v30;\n  double j;\n  double v32;\n  long long k;\n  __m128d v34;\n  __int128 v35;\n  double *v36;\n  __m128d v37;\n  __m128d v38;\n  __m128d v39;\n  int v40;\n  int *v41;\n  double *v42;\n  long long v43;\n  double m;\n  double v45;\n  long long v46;\n  double v47;\n  __m128d v48;\n  double *v49;\n  __m128d v50;\n  double *v51;\n  double *v52;\n  double *v53;\n  __m128d v54;\n  __m128d v55;\n  __m128d v56;\n  double *v57;\n  double *v58;\n  __m128d v59;\n  __m128d v60;\n  double *v61;\n  __int128 v62;\n  __m128d v63;\n  __m128d v64;\n  __m128d v65;\n  double *v66;\n  __m128d v67;\n  __m128d v68;\n  unsigned long long v69;\n  double v70;\n  v3 = 0;\n  v4 = 0;\n  v5 = 1;\n  row_ptr[0] = 0;\n  col_idx[0] = 0;\n  val[0] = 4.0;\n  while (1) {\n    if (v3 <= 991) {\n      v6 = v5++;\n      col_idx[v6] = v3 + 32;\n    }\n    if ((v3 & 31) != 0) {\n      v7 = v5++;\n      col_idx[v7] = v3 - 1;\n    }\n    v8 = v3 + 1;\n    if (v4 != 31) {\n      v9 = v5++;\n      col_idx[v9] = v8;\n    }\n    if (v3 == 1023) break;\n    col_idx[v5] = v8;\n    v4 = v8 & 31;\n    v10 = v5 + 1;\n    if (v8 <= 31) {\n      ++v5;\n    } else {\n      v5 += 2;\n      col_idx[v10] = v3 - 31;\n    }\n    ++v3;\n  }\n  v11 = 0;\n  v12 = 0;\n  for (i = 1;; ++i) {\n  LABEL_14:\n    v14 = i++;\n    val[v14] = -1.0;\n    while (1) {\n      if ((v11 & 31) != 0) {\n        v15 = i++;\n        val[v15] = -1.0;\n      }\n      ++v11;\n      if (v12 != 31) {\n        v16 = i++;\n        val[v16] = -1.0;\n      }\n      if (v11 == 1024) {\n        v18 = &row_ptr[1];\n        v19 = 0;\n        v20 = 0;\n        v21 = 1;\n        while (1) {\n          v23 = (v19 < 992) + v21 - (((v19 & 31) == 0) - 1);\n          ++v19;\n          v24 = (v20 != 31) + v23;\n          if (v19 == 1024) break;\n          *v18 = v24;\n          v22 = v24 + 1;\n          v21 = v24 + 2;\n          v20 = v19 & 31;\n          if (v19 <= 31) v21 = v22;\n          ++v18;\n        }\n        row_ptr[1024] = v24;\n        v25 = cg_rng;\n        memset(x, 0, sizeof(x));\n        v26 = b;\n        do {\n          ++v26;\n          v25 = 1664525 * v25 + 1013904223;\n          *(v26 - 1) = (double)(v25 & 16777215) * 0.00000005960464477539062;\n        } while (&b[1024] != v26);\n        cg_rng = v25;\n        v27 = &row_ptr[1];\n        v28 = &Ap[1024];\n        v29 = Ap;\n        while (1) {\n          v30 = *(v27 - 1);\n          for (j = 0.0; *v27 > (int)v30; j = j + v32) {\n            v32 = x[col_idx[v30]] * val[v30];\n            ++v30;\n          }\n          *v29++ = j;\n          ++v27;\n          if (v28 == v29) {\n            for (k = 0LL; k != 1024; k += 2LL) {\n              v34 = _mm_sub_pd(*(__m128d *)&b[k], *(__m128d *)&Ap[k]);\n              *(__m128d *)&r[k] = v34;\n              *(__m128d *)&p[k] = v34;\n            }\n            v35 = 0LL;\n            v36 = &b[-1024];\n            do {\n              v37 = *(__m128d *)v36;\n              v36 += 2;\n              v38 = _mm_mul_pd(v37, v37);\n              *(double *)&v35 = *(double *)&v35 + v38.m128d_f64[0] +\n                                _mm_unpackhi_pd(v38, v38).m128d_f64[0];\n            } while (b != v36);\n            v39 = (__m128d)_mm_loadl_epi64((const __m128i *)&qword_4060);\n            v40 = 25;\n            while (1) {\n              v41 = &row_ptr[1];\n              v42 = Ap;\n              do {\n                v43 = *(v41 - 1);\n                for (m = 0.0; *v41 > (int)v43; m = m + v45) {\n                  v45 = p[col_idx[v43]] * val[v43];\n                  ++v43;\n                }\n                *v42++ = m;\n                ++v41;\n              } while (v42 != v28);\n              v46 = 0LL;\n              v47 = 0.0;\n              do {\n                v48 = _mm_mul_pd(*(__m128d *)&Ap[v46], *(__m128d *)&p[v46]);\n                v46 += 2LL;\n                v47 = v47 + v48.m128d_f64[0] +\n                      _mm_unpackhi_pd(v48, v48).m128d_f64[0];\n              } while (v46 != 1024);\n              v50.m128d_f64[1] = *((double *)&v35 + 1);\n              v49 = x;\n              v50.m128d_f64[0] = *(double *)&v35 / v47;\n              v51 = p;\n              v52 = p;\n              v53 = x;\n              v54 = _mm_unpacklo_pd(v50, v50);\n              do {\n                v55 = *(__m128d *)v52;\n                v53 += 2;\n                v52 += 2;\n                *((__m128d *)v53 - 1) =\n                    _mm_add_pd(_mm_mul_pd(v55, v54), *(__m128d *)(v53 - 2));\n              } while (v53 != val);\n              v56 = _mm_xor_pd(v50, v39);\n              v57 = Ap;\n              v58 = r;\n              v59 = _mm_unpacklo_pd(v56, v56);\n              do {\n                v60 = *(__m128d *)v57;\n                v58 += 2;\n                v57 += 2;\n                *((__m128d *)v58 - 1) =\n                    _mm_add_pd(_mm_mul_pd(v60, v59), *(__m128d *)(v58 - 2));\n              } while (v58 != b);\n              v61 = r;\n              v62 = 0LL;\n              do {\n                v63 = *(__m128d *)v61;\n                v61 += 2;\n                v64 = _mm_mul_pd(v63, v63);\n                *(double *)&v62 = *(double *)&v62 + v64.m128d_f64[0] +\n                                  _mm_unpackhi_pd(v64, v64).m128d_f64[0];\n              } while (v61 != b);\n              if (*(double *)&v62 < 1.0e-12) goto LABEL_57;\n              v65.m128d_f64[1] = 0.0;\n              v66 = r;\n              v65.m128d_f64[0] = *(double *)&v62 / *(double *)&v35;\n              v67 = _mm_unpacklo_pd(v65, v65);\n              do {\n                v68 = *(__m128d *)v51;\n                v51 += 2;\n                v66 += 2;\n                *((__m128d *)v51 - 1) =\n                    _mm_add_pd(_mm_mul_pd(v68, v67), *(__m128d *)(v66 - 2));\n              } while (v51 != r);\n              if (!--v40) {\n              LABEL_57:\n                v69 = 11400714819323198485LL;\n                do {\n                  v70 = *v49++;\n                  v69 ^= (v69 >> 2) + (v69 << 6) +\n                         (unsigned int)(int)(v70 * 1000000.0);\n                } while (v49 != val);\n                libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25,\n                              HIDWORD(v69), v69);\n                libmin_success();\n              }\n              v35 = v62;\n            }\n          }\n        }\n      }\n      v17 = i + 1;\n      v12 = v11 & 31;\n      val[i] = 4.0;\n      if (v11 <= 31) break;\n      i += 2;\n      val[v17] = -1.0;\n      if (v11 <= 991) goto LABEL_14;\n    }\n  }\n}", "binary": "congrad/congrad.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nxor    %edx,%edx\nxor    %r8d,%r8d\nmov    $0x1,%eax\npush   %r14\nlea    0x19187(%rip),%rsi\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovsd  0x2f05(%rip),%xmm1\nmovl   $0x0,0x1e16b(%rip)\nmovl   $0x0,0x19161(%rip)\nmovsd  %xmm1,0xf159(%rip)\nnopw   0x0(%rax,%rax,1)\ncmp    $0x3df,%edx\njg     1164 <main+0x64>\nmovslq %eax,%rcx\nlea    0x20(%rdx),%edi\nadd    $0x1,%eax\nmov    %edi,(%rsi,%rcx,4)\ntest   $0x1f,%dl\nje     1175 <main+0x75>\nmovslq %eax,%rcx\nlea    -0x1(%rdx),%edi\nadd    $0x1,%eax\nmov    %edi,(%rsi,%rcx,4)\nlea    0x1(%rdx),%ecx\ncmp    $0x1f,%r8d\nje     1187 <main+0x87>\nmovslq %eax,%rdi\nadd    $0x1,%eax\nmov    %ecx,(%rsi,%rdi,4)\ncmp    $0x400,%ecx\nje     11ba <main+0xba>\nmovslq %eax,%rdi\nmov    %ecx,%r8d\nmov    %ecx,(%rsi,%rdi,4)\nand    $0x1f,%r8d\nlea    0x1(%rax),%edi\ncmp    $0x1f,%ecx\njle    11b4 <main+0xb4>\nsub    $0x1f,%edx\nmovslq %edi,%rdi\nadd    $0x2,%eax\nmov    %edx,(%rsi,%rdi,4)\nmov    %ecx,%edx\njmp    1150 <main+0x50>\nmov    %edi,%eax\nmov    %ecx,%edx\njmp    1150 <main+0x50>\nxor    %edx,%edx\nxor    %edi,%edi\nlea    0xf0db(%rip),%rcx\nmov    $0x1,%eax\nmovsd  0x2e66(%rip),%xmm0\ncmp    $0x3df,%edx\njg     11e5 <main+0xe5>\nmovslq %eax,%rsi\nadd    $0x1,%eax\nmovsd  %xmm0,(%rcx,%rsi,8)\ntest   $0x1f,%dl\nje     11f5 <main+0xf5>\nmovslq %eax,%rsi\nadd    $0x1,%eax\nmovsd  %xmm0,(%rcx,%rsi,8)\nadd    $0x1,%edx\ncmp    $0x1f,%edi\nje     1208 <main+0x108>\nmovslq %eax,%rsi\nadd    $0x1,%eax\nmovsd  %xmm0,(%rcx,%rsi,8)\ncmp    $0x400,%edx\nje     123f <main+0x13f>\nmov    %edx,%edi\nmovslq %eax,%r8\nlea    0x1(%rax),%esi\nand    $0x1f,%edi\nmovsd  %xmm1,(%rcx,%r8,8)\ncmp    $0x1f,%edx\njle    123b <main+0x13b>\nmovslq %esi,%rsi\nadd    $0x2,%eax\nmovsd  %xmm0,(%rcx,%rsi,8)\ncmp    $0x3df,%edx\njle    11da <main+0xda>\njmp    11e5 <main+0xe5>\nmov    %esi,%eax\njmp    11d2 <main+0xd2>\nlea    0x1e05e(%rip),%rcx\nxor    %edx,%edx\nxor    %esi,%esi\nmov    $0x1,%eax\njmp    1268 <main+0x168>\nmov    %edx,%esi\nmov    %eax,(%rcx)\nlea    0x1(%rax),%edi\nadd    $0x2,%eax\nand    $0x1f,%esi\ncmp    $0x1f,%edx\ncmovle %edi,%eax\nadd    $0x4,%rcx\nxor    %edi,%edi\ncmp    $0x3e0,%edx\nsetl   %dil\nadd    %edi,%eax\nmov    %edx,%edi\nand    $0x1f,%edi\ncmp    $0x1,%edi\nsbb    $0xffffffff,%eax\nadd    $0x1,%edx\ncmp    $0x1f,%esi\nsetne  %sil\nmovzbl %sil,%esi\nadd    %esi,%eax\ncmp    $0x400,%edx\njne    1251 <main+0x151>\nlea    0xd000(%rip),%rsi\nmov    %eax,0x1effa(%rip)\nmov    $0x400,%ecx\nxor    %eax,%eax\nlea    0xafec(%rip),%r9\nmov    %rsi,%rdi\nmov    0x4d53(%rip),%edx\nmovsd  0x2d7b(%rip),%xmm1\nrep stos %rax,%es:(%rdi)\nmov    %r9,%rax\nlea    0x2000(%r9),%rdi\nnopw   0x0(%rax,%rax,1)\nimul   $0x19660d,%edx,%edx\npxor   %xmm0,%xmm0\nadd    $0x8,%rax\nadd    $0x3c6ef35f,%edx\nmov    %edx,%ecx\nand    $0xffffff,%ecx\ncvtsi2sd %ecx,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rax)\ncmp    %rax,%rdi\njne    12d8 <main+0x1d8>\nmov    %edx,0x4d04(%rip)\nlea    0x4f8d(%rip),%rbp\npxor   %xmm3,%xmm3\nlea    0x1df86(%rip),%r11\nlea    0x2000(%rbp),%rbx\nmov    %rbp,%r10\nlea    0x18f71(%rip),%r8\nlea    0xef6a(%rip),%rdi\ncs nopw 0x0(%rax,%rax,1)\nmovslq -0x4(%r11),%rax\nmov    (%r11),%ecx\nmovapd %xmm3,%xmm1\ncmp    %ecx,%eax\njge    136a <main+0x26a>\nnop\nmovslq (%r8,%rax,4),%rdx\nmovsd  (%rsi,%rdx,8),%xmm0\nmulsd  (%rdi,%rax,8),%xmm0\nadd    $0x1,%rax\naddsd  %xmm0,%xmm1\ncmp    %eax,%ecx\njg     1350 <main+0x250>\nmovsd  %xmm1,(%r10)\nadd    $0x8,%r10\nadd    $0x4,%r11\ncmp    %r10,%rbx\njne    1340 <main+0x240>\nxor    %eax,%eax\nlea    0x8f1b(%rip),%r14\nlea    0x6f14(%rip),%rsi\nmovapd (%r9,%rax,1),%xmm0\nsubpd  0x0(%rbp,%rax,1),%xmm0\nmovaps %xmm0,(%r14,%rax,1)\nmovaps %xmm0,(%rsi,%rax,1)\nadd    $0x10,%rax\ncmp    $0x2000,%rax\njne    138c <main+0x28c>\nlea    0xaeec(%rip),%r11\nmovapd %xmm3,%xmm4\nlea    -0x2000(%r11),%rax\nmovapd (%rax),%xmm0\nadd    $0x10,%rax\nmulpd  %xmm0,%xmm0\naddsd  %xmm0,%xmm4\nunpckhpd %xmm0,%xmm0\naddsd  %xmm0,%xmm4\ncmp    %rax,%r11\njne    13bf <main+0x2bf>\nmovq   0x2c7c(%rip),%xmm6\nmovsd  0x2c5c(%rip),%xmm5\nmov    $0x19,%r15d\nlea    0xeea7(%rip),%r12\nlea    0x18ea0(%rip),%r8\nlea    0xee99(%rip),%rdi\nlea    0x8e92(%rip),%r13\nxchg   %ax,%ax\nlea    0x1de8d(%rip),%r9\nmov    %rbp,%rcx\nnopw   0x0(%rax,%rax,1)\nmovslq -0x4(%r9),%rax\nmov    (%r9),%edx\nmovapd %xmm3,%xmm1\ncmp    %eax,%edx\njle    144b <main+0x34b>\nnop\nmovslq (%r8,%rax,4),%r10\nmovsd  (%rsi,%r10,8),%xmm0\nmulsd  (%rdi,%rax,8),%xmm0\nadd    $0x1,%rax\naddsd  %xmm0,%xmm1\ncmp    %eax,%edx\njg     1430 <main+0x330>\nmovsd  %xmm1,(%rcx)\nadd    $0x8,%rcx\nadd    $0x4,%r9\ncmp    %rbx,%rcx\njne    1420 <main+0x320>\nxor    %eax,%eax\nmovapd %xmm3,%xmm1\nnopw   0x0(%rax,%rax,1)\nmovapd 0x0(%rbp,%rax,1),%xmm0\nmulpd  (%rsi,%rax,1),%xmm0\nadd    $0x10,%rax\naddsd  %xmm0,%xmm1\nunpckhpd %xmm0,%xmm0\naddsd  %xmm0,%xmm1\ncmp    $0x2000,%rax\njne    1468 <main+0x368>\nmovapd %xmm4,%xmm2\nlea    0x6e0a(%rip),%rsi\nlea    0xce03(%rip),%rcx\ndivsd  %xmm1,%xmm2\nmov    %rsi,%rdx\nmov    %rsi,%r9\nmov    %rcx,%rax\nmovapd %xmm2,%xmm1\nunpcklpd %xmm1,%xmm1\nnopw   0x0(%rax,%rax,1)\nmovapd (%r9),%xmm0\nadd    $0x10,%rax\nadd    $0x10,%r9\nmulpd  %xmm1,%xmm0\naddpd  -0x10(%rax),%xmm0\nmovaps %xmm0,-0x10(%rax)\ncmp    %r12,%rax\njne    14b8 <main+0x3b8>\nxorpd  %xmm6,%xmm2\nmov    %rbp,%r9\nmov    %r14,%rax\nmovapd %xmm2,%xmm1\nunpcklpd %xmm1,%xmm1\nnopl   0x0(%rax)\nmovapd (%r9),%xmm0\nadd    $0x10,%rax\nadd    $0x10,%r9\nmulpd  %xmm1,%xmm0\naddpd  -0x10(%rax),%xmm0\nmovaps %xmm0,-0x10(%rax)\ncmp    %r11,%rax\njne    14f0 <main+0x3f0>\nmov    %r14,%rax\nmovapd %xmm3,%xmm1\ncs nopw 0x0(%rax,%rax,1)\nmovapd (%rax),%xmm0\nadd    $0x10,%rax\nmulpd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nunpckhpd %xmm0,%xmm0\naddsd  %xmm0,%xmm1\ncmp    %r11,%rax\njne    1520 <main+0x420>\ncomisd %xmm1,%xmm5\nja     1585 <main+0x485>\nmovapd %xmm1,%xmm2\nmov    %r14,%rax\ndivsd  %xmm4,%xmm2\nunpcklpd %xmm2,%xmm2\nnopw   0x0(%rax,%rax,1)\nmovapd (%rdx),%xmm0\nadd    $0x10,%rdx\nadd    $0x10,%rax\nmulpd  %xmm2,%xmm0\naddpd  -0x10(%rax),%xmm0\nmovaps %xmm0,-0x10(%rdx)\ncmp    %r13,%rdx\njne    1558 <main+0x458>\nsub    $0x1,%r15d\nje     1585 <main+0x485>\nmovapd %xmm1,%xmm4\njmp    1410 <main+0x310>\nmovsd  0x2ac3(%rip),%xmm1\nmovabs $0x9e3779b97f4a7c15,%rax\nnopw   0x0(%rax,%rax,1)\nmovsd  (%rcx),%xmm0\nmov    %rax,%rsi\nmov    %rax,%rdi\nadd    $0x8,%rcx\nshl    $0x6,%rsi\nshr    $0x2,%rdi\nmulsd  %xmm1,%xmm0\nadd    %rdi,%rsi\ncvttsd2si %xmm0,%rdx\nadd    %rsi,%rdx\nxor    %rdx,%rax\ncmp    %r12,%rcx\njne    15a0 <main+0x4a0>\nmov    %eax,%r8d\nshr    $0x20,%rax\nmov    $0x19,%edx\nmov    $0x20,%esi\nmov    %rax,%rcx\nlea    0x2a20(%rip),%rdi\nxor    %eax,%eax\ncall   37d0 <libmin_printf>\ncall   3a10 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "board_full", "content": "// Check if board is full.\nint board_full(int board[ROWS][COLS]) {\n    for (int c = 0; c < COLS; c++)\n        if (valid_move(board, c))\n            return 0;\n    return 1;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "board_full", "address": "0x1500", "label": "board_full", "content": "int __fastcall board_full(int (*board)[7])\n{\n  __int64 v1; // rax\n\n  LODWORD(v1) = (*board)[0];\n  if ( (*board)[0] )\n  {\n    LODWORD(v1) = (*board)[1];\n    if ( (_DWORD)v1 )\n    {\n      LODWORD(v1) = (*board)[2];\n      if ( (_DWORD)v1 )\n      {\n        LODWORD(v1) = (*board)[3];\n        if ( (_DWORD)v1 )\n        {\n          LODWORD(v1) = (*board)[4];\n          if ( (_DWORD)v1 )\n          {\n            LODWORD(v1) = (*board)[5];\n            if ( (_DWORD)v1 )\n              return (*board)[6] != 0;\n          }\n        }\n      }\n    }\n  }\n  return v1;\n}\n"}, "pseudo_normalize": "int board_full(int (*board)[7]) {\n  long long v1;\n  LODWORD(v1) = (*board)[0];\n  if ((*board)[0]) {\n    LODWORD(v1) = (*board)[1];\n    if ((uint32_t)v1) {\n      LODWORD(v1) = (*board)[2];\n      if ((uint32_t)v1) {\n        LODWORD(v1) = (*board)[3];\n        if ((uint32_t)v1) {\n          LODWORD(v1) = (*board)[4];\n          if ((uint32_t)v1) {\n            LODWORD(v1) = (*board)[5];\n            if ((uint32_t)v1) return (*board)[6] != 0;\n          }\n        }\n      }\n    }\n  }\n  return v1;\n}", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<board_full>:\nendbr64\nmov    (%rdi),%eax\ntest   %eax,%eax\nje     1537 <board_full+0x37>\nmov    0x4(%rdi),%eax\ntest   %eax,%eax\nje     1537 <board_full+0x37>\nmov    0x8(%rdi),%eax\ntest   %eax,%eax\nje     1537 <board_full+0x37>\nmov    0xc(%rdi),%eax\ntest   %eax,%eax\nje     1537 <board_full+0x37>\nmov    0x10(%rdi),%eax\ntest   %eax,%eax\nje     1537 <board_full+0x37>\nmov    0x14(%rdi),%eax\ntest   %eax,%eax\nje     1537 <board_full+0x37>\nmov    0x18(%rdi),%edx\nxor    %eax,%eax\ntest   %edx,%edx\nsetne  %al\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "check_win", "content": "// -------------------------------------------------\n// Game Evaluation: Check for win.\n// -------------------------------------------------\n\n// Check horizontal, vertical, and two diagonals for four in a row.\nint check_win(int board[ROWS][COLS], int player) {\n    // Horizontal check\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r][c+1] == player &&\n                board[r][c+2] == player && board[r][c+3] == player)\n                return 1;\n        }\n    }\n    // Vertical check\n    for (int c = 0; c < COLS; c++) {\n        for (int r = 0; r < ROWS - 3; r++) {\n            if (board[r][c] == player && board[r+1][c] == player &&\n                board[r+2][c] == player && board[r+3][c] == player)\n                return 1;\n        }\n    }\n    // Diagonal (positive slope)\n    for (int r = 3; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r-1][c+1] == player &&\n                board[r-2][c+2] == player && board[r-3][c+3] == player)\n                return 1;\n        }\n    }\n    // Diagonal (negative slope)\n    for (int r = 0; r < ROWS - 3; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r+1][c+1] == player &&\n                board[r+2][c+2] == player && board[r+3][c+3] == player)\n                return 1;\n        }\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "check_win", "address": "0x1540", "label": "check_win", "content": "int __fastcall check_win(int (*board)[7], int player)\n{\n  int v4; // r12d\n  int v5; // r11d\n  int v6; // ebp\n  int v7; // r14d\n  int v8; // r8d\n  int v9; // r10d\n  int v10; // r9d\n  int v11; // ecx\n  int v12; // edi\n  int v13; // esi\n  int v14; // r13d\n  int v15; // r8d\n  int v17; // [rsp+0h] [rbp-88h]\n  int v18; // [rsp+4h] [rbp-84h]\n  int v19; // [rsp+8h] [rbp-80h]\n  int v20; // [rsp+Ch] [rbp-7Ch]\n  int v21; // [rsp+10h] [rbp-78h]\n  int v22; // [rsp+14h] [rbp-74h]\n  int v23; // [rsp+18h] [rbp-70h]\n  int v24; // [rsp+1Ch] [rbp-6Ch]\n  int v25; // [rsp+20h] [rbp-68h]\n  int v26; // [rsp+24h] [rbp-64h]\n  int v27; // [rsp+28h] [rbp-60h]\n  int v28; // [rsp+2Ch] [rbp-5Ch]\n  int v29; // [rsp+30h] [rbp-58h]\n  int v30; // [rsp+34h] [rbp-54h]\n  int v31; // [rsp+38h] [rbp-50h]\n  int v32; // [rsp+3Ch] [rbp-4Ch]\n  int v33; // [rsp+40h] [rbp-48h]\n  int v34; // [rsp+44h] [rbp-44h]\n  int v35; // [rsp+48h] [rbp-40h]\n  int v36; // [rsp+4Ch] [rbp-3Ch]\n  int v37; // [rsp+50h] [rbp-38h]\n  int v38; // [rsp+54h] [rbp-34h]\n\n  v4 = (*board)[0];\n  v5 = (*board)[3];\n  v6 = (*board)[1];\n  v7 = (*board)[2];\n  if ( player != (*board)[0] )\n  {\n    if ( player == v6 )\n    {\n      if ( player != v7 )\n        goto LABEL_4;\n      if ( v5 != player )\n        goto LABEL_5;\n      if ( v5 == (*board)[4] )\n        return 1;\n      goto LABEL_307;\n    }\nLABEL_3:\n    if ( player != v7 )\n    {\nLABEL_4:\n      if ( player != v5 || player != (*board)[4] )\n        goto LABEL_5;\n      goto LABEL_72;\n    }\n    if ( player != v5 )\n      goto LABEL_5;\nLABEL_307:\n    if ( v5 != (*board)[4] )\n      goto LABEL_5;\n    if ( v5 == (*board)[5] )\n      return 1;\nLABEL_72:\n    if ( player == (*board)[5] && player == (*board)[6] )\n      return 1;\n    goto LABEL_5;\n  }\n  if ( player != v6 )\n    goto LABEL_3;\n  if ( player != v7 )\n    goto LABEL_4;\n  if ( player == v5 )\n    return 1;\nLABEL_5:\n  v8 = (*board)[10];\n  v9 = (*board)[8];\n  v10 = (*board)[9];\n  v25 = (*board)[7];\n  if ( player != v25 )\n  {\n    if ( player == v9 )\n    {\n      if ( player != v10 )\n        goto LABEL_8;\n      if ( v8 != player )\n        goto LABEL_9;\n      if ( player == (*board)[11] )\n        return 1;\n      goto LABEL_315;\n    }\nLABEL_7:\n    if ( player != v10 )\n    {\nLABEL_8:\n      if ( player != v8 || player != (*board)[11] )\n        goto LABEL_9;\n      goto LABEL_88;\n    }\n    if ( player != v8 )\n      goto LABEL_9;\nLABEL_315:\n    if ( v8 != (*board)[11] )\n      goto LABEL_9;\n    if ( v8 == (*board)[12] )\n      return 1;\nLABEL_88:\n    if ( player == (*board)[12] && player == (*board)[13] )\n      return 1;\n    goto LABEL_9;\n  }\n  if ( player != v9 )\n    goto LABEL_7;\n  if ( player != v10 )\n    goto LABEL_8;\n  if ( player == v8 )\n    return 1;\nLABEL_9:\n  v11 = (*board)[17];\n  v12 = (*board)[15];\n  v13 = (*board)[16];\n  v27 = (*board)[14];\n  if ( player != v27 )\n  {\n    if ( player == v12 )\n    {\n      if ( player != v13 )\n        goto LABEL_12;\n      if ( v11 != player )\n        goto LABEL_13;\n      if ( player == (*board)[18] )\n        return 1;\n      goto LABEL_311;\n    }\nLABEL_11:\n    if ( player != v13 )\n    {\nLABEL_12:\n      if ( player != v11 || player != (*board)[18] )\n        goto LABEL_13;\n      goto LABEL_80;\n    }\n    if ( player != v11 )\n      goto LABEL_13;\nLABEL_311:\n    if ( v11 != (*board)[18] )\n      goto LABEL_13;\n    if ( v11 == (*board)[19] )\n      return 1;\nLABEL_80:\n    if ( player == (*board)[19] && player == (*board)[20] )\n      return 1;\n    goto LABEL_13;\n  }\n  if ( player != v12 )\n    goto LABEL_11;\n  if ( player != v13 )\n    goto LABEL_12;\n  if ( player == v11 )\n    return 1;\nLABEL_13:\n  v14 = (*board)[24];\n  v18 = (*board)[22];\n  v30 = (*board)[21];\n  v17 = (*board)[23];\n  if ( player != v30 )\n  {\n    if ( player == v18 )\n    {\n      if ( player != v17 )\n        goto LABEL_16;\n      if ( v14 != player )\n        goto LABEL_17;\n      if ( player == (*board)[25] )\n        return 1;\n      goto LABEL_319;\n    }\nLABEL_15:\n    if ( player != v17 )\n    {\nLABEL_16:\n      if ( player != v14 || player != (*board)[25] )\n        goto LABEL_17;\n      goto LABEL_100;\n    }\n    if ( player != v14 )\n      goto LABEL_17;\nLABEL_319:\n    if ( v14 != (*board)[25] )\n      goto LABEL_17;\n    if ( v14 == (*board)[26] )\n      return 1;\nLABEL_100:\n    if ( player == (*board)[26] && player == (*board)[27] )\n      return 1;\n    goto LABEL_17;\n  }\n  if ( player != v18 )\n    goto LABEL_15;\n  if ( player != v17 )\n    goto LABEL_16;\n  if ( player == v14 )\n    return 1;\nLABEL_17:\n  v19 = (*board)[31];\n  v32 = (*board)[28];\n  v21 = (*board)[29];\n  v20 = (*board)[30];\n  if ( player != v32 )\n  {\n    if ( player == v21 )\n    {\n      if ( player != v20 )\n        goto LABEL_20;\n      if ( v19 != player )\n        goto LABEL_21;\n      if ( player == (*board)[32] )\n        return 1;\n      goto LABEL_323;\n    }\nLABEL_19:\n    if ( player != v20 )\n    {\nLABEL_20:\n      if ( player != v19 || player != (*board)[32] )\n        goto LABEL_21;\n      goto LABEL_108;\n    }\n    if ( player != v19 )\n      goto LABEL_21;\nLABEL_323:\n    if ( v19 != (*board)[32] )\n      goto LABEL_21;\n    if ( v19 == (*board)[33] )\n      return 1;\nLABEL_108:\n    if ( player == (*board)[33] && player == (*board)[34] )\n      return 1;\n    goto LABEL_21;\n  }\n  if ( player != v21 )\n    goto LABEL_19;\n  if ( player != v20 )\n    goto LABEL_20;\n  if ( player == v19 )\n    return 1;\nLABEL_21:\n  v23 = (*board)[38];\n  v34 = (*board)[35];\n  v24 = (*board)[36];\n  v26 = (*board)[37];\n  if ( player != v34 )\n  {\n    if ( player == v24 )\n    {\n      if ( player != v26 )\n        goto LABEL_24;\n      if ( v23 != player )\n        goto LABEL_25;\n      if ( player == (*board)[39] )\n        return 1;\n      goto LABEL_327;\n    }\nLABEL_23:\n    if ( player != v26 )\n    {\nLABEL_24:\n      if ( player != v23 || (*board)[39] != player )\n        goto LABEL_25;\n      goto LABEL_112;\n    }\n    if ( player != v23 )\n      goto LABEL_25;\nLABEL_327:\n    if ( v23 != (*board)[39] )\n      goto LABEL_25;\n    if ( v23 == (*board)[40] )\n      return 1;\nLABEL_112:\n    if ( player == (*board)[40] && player == (*board)[41] )\n      return 1;\n    goto LABEL_25;\n  }\n  if ( v24 != player )\n    goto LABEL_23;\n  if ( v26 != player )\n    goto LABEL_24;\n  if ( v23 == player )\n    return 1;\nLABEL_25:\n  if ( player == v4 )\n  {\n    if ( player == v25 )\n    {\n      if ( player == v27 && player == v30 )\n        return 1;\n      goto LABEL_28;\n    }\n  }\n  else if ( player == v25 )\n  {\n    if ( player == v27 && player == v30 && player == v32 )\n      return 1;\n    goto LABEL_28;\n  }\n  if ( player == v27 && player == v30 && player == v32 && v34 == player )\n    return 1;\nLABEL_28:\n  if ( player == v6 )\n  {\n    if ( player == v9 )\n    {\n      if ( player == v12 && player == v18 )\n        return 1;\n      goto LABEL_31;\n    }\n  }\n  else if ( player == v9 )\n  {\n    if ( player == v12 && player == v18 && player == v21 )\n      return 1;\n    goto LABEL_31;\n  }\n  if ( player == v12 && player == v18 && player == v21 && v24 == player )\n    return 1;\nLABEL_31:\n  if ( player == v7 )\n  {\n    if ( player == v10 )\n    {\n      if ( player == v13 && player == v17 )\n        return 1;\n      goto LABEL_34;\n    }\n  }\n  else if ( player == v10 )\n  {\n    if ( player == v13 && player == v17 && player == v20 )\n      return 1;\n    goto LABEL_34;\n  }\n  if ( player == v13 && player == v17 && player == v20 && v26 == player )\n    return 1;\nLABEL_34:\n  if ( player == v5 )\n  {\n    if ( player == v8 )\n    {\n      if ( player == v11 && player == v14 )\n        return 1;\n      goto LABEL_37;\n    }\n  }\n  else if ( player == v8 )\n  {\n    if ( player == v11 && player == v14 && player == v19 )\n      return 1;\n    goto LABEL_37;\n  }\n  if ( player == v11 && player == v14 && player == v19 && v23 == player )\n    return 1;\nLABEL_37:\n  v28 = (*board)[11];\n  v36 = (*board)[4];\n  v22 = (*board)[18];\n  if ( player == v36 )\n  {\n    if ( player != v28 )\n      goto LABEL_39;\n    if ( player != v22 )\n      goto LABEL_40;\n    if ( player == (*board)[25] )\n      return 1;\n  }\n  else\n  {\n    if ( player != v28 )\n    {\nLABEL_39:\n      if ( player != v22 || player != (*board)[25] )\n        goto LABEL_40;\n      goto LABEL_136;\n    }\n    if ( player != v22 )\n      goto LABEL_40;\n  }\n  if ( v22 != (*board)[25] )\n    goto LABEL_40;\n  if ( v22 == (*board)[32] )\n    return 1;\nLABEL_136:\n  if ( player == (*board)[32] && player == (*board)[39] )\n    return 1;\nLABEL_40:\n  v31 = (*board)[12];\n  v38 = (*board)[5];\n  v29 = (*board)[19];\n  if ( player == v38 )\n  {\n    if ( player != v31 )\n      goto LABEL_42;\n    if ( player != v29 )\n      goto LABEL_43;\n    if ( player == (*board)[26] )\n      return 1;\n  }\n  else\n  {\n    if ( player != v31 )\n    {\nLABEL_42:\n      if ( player != v29 || player != (*board)[26] )\n        goto LABEL_43;\n      goto LABEL_150;\n    }\n    if ( player != v29 )\n      goto LABEL_43;\n  }\n  if ( v29 != (*board)[26] )\n    goto LABEL_43;\n  if ( v29 == (*board)[33] )\n    return 1;\nLABEL_150:\n  if ( player == (*board)[33] && player == (*board)[40] )\n    return 1;\nLABEL_43:\n  v35 = (*board)[13];\n  v37 = (*board)[6];\n  v33 = (*board)[20];\n  if ( player != v37 )\n  {\n    if ( player != v35 )\n      goto LABEL_45;\n    if ( player != v33 )\n    {\nLABEL_46:\n      if ( player != v30 )\n        goto LABEL_47;\n      goto LABEL_159;\n    }\nLABEL_144:\n    if ( v33 == (*board)[27] )\n    {\n      if ( v33 == (*board)[34] )\n        return 1;\n      goto LABEL_146;\n    }\n    goto LABEL_46;\n  }\n  if ( v35 == player )\n  {\n    if ( v33 != player )\n      goto LABEL_46;\n    if ( player == (*board)[27] )\n      return 1;\n    goto LABEL_144;\n  }\nLABEL_45:\n  if ( player != v33 )\n    goto LABEL_46;\n  if ( player == (*board)[27] )\n  {\nLABEL_146:\n    if ( player == (*board)[34] && player == (*board)[41] )\n      return 1;\n    goto LABEL_46;\n  }\n  if ( player == v30 )\n  {\nLABEL_159:\n    if ( v12 != player || v10 != v12 || v5 != v10 )\n      goto LABEL_47;\n    return 1;\n  }\nLABEL_47:\n  if ( player == v18 && v13 == player && v8 == v13 && v36 == v8\n    || player == v17 && v11 == player && v28 == v11 && v38 == v28\n    || player == v14 && v22 == player && v31 == v22 && v37 == v31\n    || player == v32 && v18 == player && v13 == v18 && v8 == v13\n    || player == v21 && v17 == player && v11 == v17 && v28 == v11\n    || player == v20 && v14 == player && v22 == v14 && v31 == v22\n    || player == v19 && (*board)[25] == player && v29 == player && v35 == v29\n    || player == v34 && player == v21 && player == v17 && player == v11\n    || player == v24 && player == v20 && player == v14 && player == v22\n    || player == v26 && player == v19 && player == (*board)[25] && player == v29\n    || player == v23 && player == (*board)[32] && player == (*board)[26] && v33 == player\n    || player == v4 && player == v9 && player == v13 && player == v14\n    || player == v6 && player == v10 && player == v11 && (*board)[25] == player\n    || player == v7 && player == v8 && v22 == player && (*board)[26] == v22\n    || player == v5 && v28 == player && v29 == v28 && (*board)[27] == v29\n    || player == v25 && player == v12 && player == v17 && player == v19\n    || player == v9 && player == v13 && player == v14 && (*board)[32] == player\n    || player == v10 && player == v11 && (*board)[25] == player && (*board)[33] == player\n    || player == v8 && v22 == player && (*board)[26] == v22 && (*board)[34] == v22\n    || player == v27 && player == v18 && player == v20 && v23 == player\n    || player == v12 && player == v17 && player == v19 && (*board)[39] == player\n    || player == v13 && player == v14 && (*board)[32] == player && (*board)[40] == player )\n  {\n    return 1;\n  }\n  v15 = 0;\n  if ( player == v11 && (*board)[25] == player && (*board)[33] == player )\n    return (*board)[41] == player;\n  return v15;\n}\n"}, "pseudo_normalize": "", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<check_win>:\nendbr64\npush   %r15\nmov    %rdi,%rdx\nmov    %esi,%eax\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    (%rdi),%r12d\nmov    0xc(%rdi),%r11d\nmov    0x4(%rdi),%ebp\nmov    0x8(%rdi),%r14d\ncmp    %r12d,%esi\nje     1c60 <check_win+0x720>\ncmp    %ebp,%esi\nje     18e0 <check_win+0x3a0>\ncmp    %r14d,%eax\nje     21e8 <check_win+0xca8>\ncmp    %r11d,%eax\nje     18c0 <check_win+0x380>\nmov    0x1c(%rdx),%ecx\nmov    0x28(%rdx),%r8d\nmov    0x20(%rdx),%r10d\nmov    0x24(%rdx),%r9d\nmov    %ecx,-0x38(%rsp)\ncmp    %ecx,%eax\nje     1c80 <check_win+0x740>\ncmp    %r10d,%eax\nje     1970 <check_win+0x430>\ncmp    %r9d,%eax\nje     2230 <check_win+0xcf0>\ncmp    %r8d,%eax\nje     194d <check_win+0x40d>\nmov    0x38(%rdx),%r15d\nmov    0x44(%rdx),%ecx\nmov    0x3c(%rdx),%edi\nmov    0x40(%rdx),%esi\nmov    %r15d,-0x30(%rsp)\ncmp    %r15d,%eax\nje     1ca0 <check_win+0x760>\ncmp    %edi,%eax\nje     1920 <check_win+0x3e0>\ncmp    %esi,%eax\nje     2210 <check_win+0xcd0>\ncmp    %ecx,%eax\nje     1900 <check_win+0x3c0>\nmov    0x58(%rdx),%r15d\nmov    0x54(%rdx),%ebx\nmov    0x60(%rdx),%r13d\nmov    %r15d,-0x54(%rsp)\nmov    0x5c(%rdx),%r15d\nmov    %ebx,-0x24(%rsp)\nmov    %r15d,-0x58(%rsp)\ncmp    %ebx,%eax\nje     1cc0 <check_win+0x780>\ncmp    -0x54(%rsp),%eax\nje     19e0 <check_win+0x4a0>\ncmp    -0x58(%rsp),%eax\nje     2258 <check_win+0xd18>\ncmp    %r13d,%eax\nje     19b8 <check_win+0x478>\nmov    0x7c(%rdx),%r15d\nmov    0x70(%rdx),%ebx\nmov    %r15d,-0x50(%rsp)\nmov    0x74(%rdx),%r15d\nmov    %ebx,-0x1c(%rsp)\nmov    %r15d,-0x48(%rsp)\nmov    0x78(%rdx),%r15d\nmov    %r15d,-0x4c(%rsp)\ncmp    %ebx,%eax\nje     1ce8 <check_win+0x7a8>\ncmp    -0x48(%rsp),%eax\nje     1990 <check_win+0x450>\ncmp    -0x4c(%rsp),%eax\nje     2280 <check_win+0xd40>\ncmp    -0x50(%rsp),%eax\nje     1a08 <check_win+0x4c8>\nmov    0x98(%rdx),%ebx\nmov    0x8c(%rdx),%r15d\nmov    %ebx,-0x40(%rsp)\nmov    0x90(%rdx),%ebx\nmov    %r15d,-0x14(%rsp)\nmov    %ebx,-0x3c(%rsp)\nmov    0x94(%rdx),%ebx\nmov    %ebx,-0x34(%rsp)\ncmp    %r15d,%eax\nje     1d10 <check_win+0x7d0>\ncmp    -0x3c(%rsp),%eax\nje     1a68 <check_win+0x528>\ncmp    -0x34(%rsp),%eax\nje     22b0 <check_win+0xd70>\ncmp    -0x40(%rsp),%eax\nje     1a38 <check_win+0x4f8>\ncmp    %r12d,%eax\nje     1d38 <check_win+0x7f8>\ncmp    -0x38(%rsp),%eax\nje     1a90 <check_win+0x550>\ncmp    -0x30(%rsp),%eax\nje     22e0 <check_win+0xda0>\ncmp    %ebp,%eax\nje     1d60 <check_win+0x820>\ncmp    %r10d,%eax\nje     1ab8 <check_win+0x578>\ncmp    %edi,%eax\nje     2308 <check_win+0xdc8>\ncmp    %r14d,%eax\nje     1d80 <check_win+0x840>\ncmp    %r9d,%eax\nje     1ae0 <check_win+0x5a0>\ncmp    %esi,%eax\nje     2358 <check_win+0xe18>\ncmp    %r11d,%eax\nje     1da0 <check_win+0x860>\ncmp    %r8d,%eax\nje     1b08 <check_win+0x5c8>\ncmp    %ecx,%eax\nje     2330 <check_win+0xdf0>\nmov    0x2c(%rdx),%ebx\nmov    0x10(%rdx),%r15d\nmov    %ebx,-0x2c(%rsp)\nmov    0x48(%rdx),%ebx\nmov    %r15d,-0xc(%rsp)\nmov    %ebx,-0x44(%rsp)\ncmp    %r15d,%eax\nje     1dc0 <check_win+0x880>\ncmp    -0x2c(%rsp),%eax\nje     1b60 <check_win+0x620>\ncmp    -0x44(%rsp),%eax\nje     1b30 <check_win+0x5f0>\nmov    0x30(%rdx),%ebx\nmov    0x14(%rdx),%r15d\nmov    %ebx,-0x20(%rsp)\nmov    0x4c(%rdx),%ebx\nmov    %r15d,-0x4(%rsp)\nmov    %ebx,-0x28(%rsp)\ncmp    %r15d,%eax\nje     1de8 <check_win+0x8a8>\ncmp    -0x20(%rsp),%eax\nje     1c00 <check_win+0x6c0>\ncmp    -0x28(%rsp),%eax\nje     1bd0 <check_win+0x690>\nmov    0x34(%rdx),%ebx\nmov    0x18(%rdx),%r15d\nmov    %ebx,-0x10(%rsp)\nmov    0x50(%rdx),%ebx\nmov    %r15d,-0x8(%rsp)\nmov    %ebx,-0x18(%rsp)\ncmp    %r15d,%eax\nje     1e10 <check_win+0x8d0>\ncmp    -0x10(%rsp),%eax\nje     1b88 <check_win+0x648>\ncmp    -0x18(%rsp),%eax\nje     1c28 <check_win+0x6e8>\ncmp    -0x24(%rsp),%eax\nje     1c40 <check_win+0x700>\ncmp    -0x54(%rsp),%eax\nje     1e60 <check_win+0x920>\ncmp    -0x58(%rsp),%eax\nje     1e38 <check_win+0x8f8>\ncmp    %r13d,%eax\nje     1ed8 <check_win+0x998>\ncmp    -0x1c(%rsp),%eax\nje     1eb0 <check_win+0x970>\ncmp    -0x48(%rsp),%eax\nje     1e88 <check_win+0x948>\ncmp    -0x4c(%rsp),%eax\nje     1f10 <check_win+0x9d0>\ncmp    -0x50(%rsp),%eax\nje     1fe0 <check_win+0xaa0>\ncmp    -0x14(%rsp),%eax\nje     1fb8 <check_win+0xa78>\ncmp    -0x3c(%rsp),%eax\nje     1f90 <check_win+0xa50>\ncmp    -0x34(%rsp),%eax\nje     1f68 <check_win+0xa28>\ncmp    -0x40(%rsp),%eax\nje     1f40 <check_win+0xa00>\ncmp    %r12d,%eax\nje     2010 <check_win+0xad0>\ncmp    %ebp,%eax\nje     2030 <check_win+0xaf0>\ncmp    %r14d,%eax\nje     2050 <check_win+0xb10>\ncmp    %r11d,%eax\nje     2118 <check_win+0xbd8>\ncmp    -0x38(%rsp),%eax\nje     20f0 <check_win+0xbb0>\ncmp    %r10d,%eax\nje     20c8 <check_win+0xb88>\ncmp    %r9d,%eax\nje     20a0 <check_win+0xb60>\ncmp    %r8d,%eax\nje     2078 <check_win+0xb38>\ncmp    -0x30(%rsp),%eax\nje     2170 <check_win+0xc30>\ncmp    %edi,%eax\nje     21c0 <check_win+0xc80>\ncmp    %esi,%eax\nje     2198 <check_win+0xc58>\nxor    %r8d,%r8d\ncmp    %ecx,%eax\nje     2148 <check_win+0xc08>\npop    %rbx\nmov    %r8d,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncmp    0x10(%rdx),%eax\njne    1584 <check_win+0x44>\ncmp    0x14(%rdx),%eax\njne    1584 <check_win+0x44>\ncmp    0x18(%rdx),%eax\njne    1584 <check_win+0x44>\njmp    1939 <check_win+0x3f9>\nnopl   (%rax)\ncmp    %r14d,%eax\njne    157b <check_win+0x3b>\ncmp    %eax,%r11d\njne    1584 <check_win+0x44>\ncmp    0x10(%rdx),%r11d\njne    21f1 <check_win+0xcb1>\njmp    1939 <check_win+0x3f9>\nxchg   %ax,%ax\ncmp    0x48(%rdx),%eax\njne    15ed <check_win+0xad>\ncmp    0x4c(%rdx),%eax\njne    15ed <check_win+0xad>\ncmp    0x50(%rdx),%eax\njne    15ed <check_win+0xad>\njmp    1939 <check_win+0x3f9>\nnopl   (%rax)\ncmp    %esi,%eax\njne    15e5 <check_win+0xa5>\ncmp    %eax,%ecx\njne    15ed <check_win+0xad>\ncmp    0x48(%rdx),%eax\njne    2218 <check_win+0xcd8>\nmov    $0x1,%r8d\npop    %rbx\npop    %rbp\nmov    %r8d,%eax\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncmp    0x2c(%rdx),%eax\njne    15ba <check_win+0x7a>\ncmp    0x30(%rdx),%eax\njne    15ba <check_win+0x7a>\ncmp    0x34(%rdx),%eax\njne    15ba <check_win+0x7a>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    %r9d,%eax\njne    15b1 <check_win+0x71>\ncmp    %eax,%r8d\njne    15ba <check_win+0x7a>\ncmp    0x2c(%rdx),%eax\njne    2239 <check_win+0xcf9>\njmp    1939 <check_win+0x3f9>\nnopl   (%rax)\ncmp    -0x4c(%rsp),%eax\njne    166d <check_win+0x12d>\ncmp    %eax,-0x50(%rsp)\njne    1677 <check_win+0x137>\ncmp    0x80(%rdx),%eax\njne    228a <check_win+0xd4a>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    0x64(%rdx),%eax\njne    162f <check_win+0xef>\ncmp    0x68(%rdx),%eax\njne    162f <check_win+0xef>\ncmp    0x6c(%rdx),%eax\njne    162f <check_win+0xef>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    -0x58(%rsp),%eax\njne    1626 <check_win+0xe6>\ncmp    %eax,%r13d\njne    162f <check_win+0xef>\ncmp    0x64(%rdx),%eax\njne    2261 <check_win+0xd21>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    0x80(%rdx),%eax\njne    1677 <check_win+0x137>\ncmp    0x84(%rdx),%eax\njne    1677 <check_win+0x137>\ncmp    0x88(%rdx),%eax\njne    1677 <check_win+0x137>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    %eax,0x9c(%rdx)\njne    16c8 <check_win+0x188>\ncmp    0xa0(%rdx),%eax\njne    16c8 <check_win+0x188>\ncmp    0xa4(%rdx),%eax\njne    16c8 <check_win+0x188>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    -0x34(%rsp),%eax\njne    16be <check_win+0x17e>\ncmp    %eax,-0x40(%rsp)\njne    16c8 <check_win+0x188>\ncmp    0x9c(%rdx),%eax\njne    22ba <check_win+0xd7a>\njmp    1939 <check_win+0x3f9>\nnopl   (%rax)\ncmp    -0x30(%rsp),%eax\njne    16e5 <check_win+0x1a5>\ncmp    -0x24(%rsp),%eax\njne    16e5 <check_win+0x1a5>\ncmp    -0x1c(%rsp),%eax\njne    16e5 <check_win+0x1a5>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    %edi,%eax\njne    16fe <check_win+0x1be>\ncmp    -0x54(%rsp),%eax\njne    16fe <check_win+0x1be>\ncmp    -0x48(%rsp),%eax\njne    16fe <check_win+0x1be>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    %esi,%eax\njne    1718 <check_win+0x1d8>\ncmp    -0x58(%rsp),%eax\njne    1718 <check_win+0x1d8>\ncmp    -0x4c(%rsp),%eax\njne    1718 <check_win+0x1d8>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    %ecx,%eax\njne    1732 <check_win+0x1f2>\ncmp    %r13d,%eax\njne    1732 <check_win+0x1f2>\ncmp    -0x50(%rsp),%eax\njne    1732 <check_win+0x1f2>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    0x64(%rdx),%eax\njne    1766 <check_win+0x226>\ncmp    0x80(%rdx),%eax\njne    1766 <check_win+0x226>\ncmp    0x9c(%rdx),%eax\njne    1766 <check_win+0x226>\njmp    1939 <check_win+0x3f9>\ncs nopw 0x0(%rax,%rax,1)\ncmp    -0x44(%rsp),%eax\njne    1766 <check_win+0x226>\nmov    -0x44(%rsp),%ebx\ncmp    0x64(%rdx),%ebx\njne    1766 <check_win+0x226>\ncmp    0x80(%rdx),%ebx\njne    1b39 <check_win+0x5f9>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    -0x18(%rsp),%eax\njne    17ce <check_win+0x28e>\nmov    -0x18(%rsp),%ebx\ncmp    0x6c(%rdx),%ebx\njne    17ce <check_win+0x28e>\ncmp    0x88(%rdx),%ebx\nje     1939 <check_win+0x3f9>\ncmp    0x88(%rdx),%eax\njne    17ce <check_win+0x28e>\ncmp    0xa4(%rdx),%eax\njne    17ce <check_win+0x28e>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    0x68(%rdx),%eax\njne    179a <check_win+0x25a>\ncmp    0x84(%rdx),%eax\njne    179a <check_win+0x25a>\ncmp    0xa0(%rdx),%eax\njne    179a <check_win+0x25a>\njmp    1939 <check_win+0x3f9>\ncs nopw 0x0(%rax,%rax,1)\ncmp    -0x28(%rsp),%eax\njne    179a <check_win+0x25a>\nmov    -0x28(%rsp),%ebx\ncmp    0x68(%rdx),%ebx\njne    179a <check_win+0x25a>\ncmp    0x84(%rdx),%ebx\njne    1bd9 <check_win+0x699>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    0x6c(%rdx),%eax\nje     1bab <check_win+0x66b>\ncmp    -0x24(%rsp),%eax\njne    17d8 <check_win+0x298>\nnopl   0x0(%rax,%rax,1)\ncmp    %eax,%edi\njne    17d8 <check_win+0x298>\ncmp    %edi,%r9d\njne    17d8 <check_win+0x298>\ncmp    %r9d,%r11d\njne    17d8 <check_win+0x298>\njmp    1939 <check_win+0x3f9>\nnop\ncmp    %ebp,%esi\njne    1572 <check_win+0x32>\ncmp    %r14d,%esi\njne    157b <check_win+0x3b>\ncmp    %r11d,%esi\njne    1584 <check_win+0x44>\njmp    1939 <check_win+0x3f9>\nnop\ncmp    %r10d,%eax\njne    15a8 <check_win+0x68>\ncmp    %r9d,%eax\njne    15b1 <check_win+0x71>\ncmp    %r8d,%eax\njne    15ba <check_win+0x7a>\njmp    1939 <check_win+0x3f9>\ncmp    %edi,%eax\njne    15dd <check_win+0x9d>\ncmp    %esi,%eax\njne    15e5 <check_win+0xa5>\ncmp    %ecx,%eax\njne    15ed <check_win+0xad>\njmp    1939 <check_win+0x3f9>\nnopl   (%rax)\ncmp    -0x54(%rsp),%eax\njne    161c <check_win+0xdc>\ncmp    -0x58(%rsp),%eax\njne    1626 <check_win+0xe6>\ncmp    %r13d,%eax\njne    162f <check_win+0xef>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    -0x48(%rsp),%eax\njne    1663 <check_win+0x123>\ncmp    -0x4c(%rsp),%eax\njne    166d <check_win+0x12d>\ncmp    -0x50(%rsp),%eax\njne    1677 <check_win+0x137>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    %eax,-0x3c(%rsp)\njne    16b4 <check_win+0x174>\ncmp    %eax,-0x34(%rsp)\njne    16be <check_win+0x17e>\ncmp    %eax,-0x40(%rsp)\njne    16c8 <check_win+0x188>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    -0x38(%rsp),%eax\njne    16db <check_win+0x19b>\ncmp    -0x30(%rsp),%eax\njne    16e5 <check_win+0x1a5>\ncmp    -0x24(%rsp),%eax\njne    16e5 <check_win+0x1a5>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    %r10d,%eax\njne    16f6 <check_win+0x1b6>\ncmp    %edi,%eax\njne    16fe <check_win+0x1be>\ncmp    -0x54(%rsp),%eax\njne    16fe <check_win+0x1be>\njmp    1939 <check_win+0x3f9>\ncmp    %r9d,%eax\njne    1710 <check_win+0x1d0>\ncmp    %esi,%eax\njne    1718 <check_win+0x1d8>\ncmp    -0x58(%rsp),%eax\njne    1718 <check_win+0x1d8>\njmp    1939 <check_win+0x3f9>\ncmp    %r8d,%eax\njne    172a <check_win+0x1ea>\ncmp    %ecx,%eax\njne    1732 <check_win+0x1f2>\ncmp    %r13d,%eax\njne    1732 <check_win+0x1f2>\njmp    1939 <check_win+0x3f9>\nnop\ncmp    -0x2c(%rsp),%eax\njne    175c <check_win+0x21c>\ncmp    -0x44(%rsp),%eax\njne    1766 <check_win+0x226>\ncmp    0x64(%rdx),%eax\njne    1b6a <check_win+0x62a>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    -0x20(%rsp),%eax\njne    1790 <check_win+0x250>\ncmp    -0x28(%rsp),%eax\njne    179a <check_win+0x25a>\ncmp    0x68(%rdx),%eax\njne    1c0a <check_win+0x6ca>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    %eax,-0x10(%rsp)\njne    17c4 <check_win+0x284>\ncmp    %eax,-0x18(%rsp)\njne    17ce <check_win+0x28e>\ncmp    0x6c(%rdx),%eax\njne    1b92 <check_win+0x652>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    %eax,%ecx\njne    17ec <check_win+0x2ac>\ncmp    %ecx,-0x2c(%rsp)\njne    17ec <check_win+0x2ac>\nmov    -0x2c(%rsp),%r15d\ncmp    %r15d,-0x4(%rsp)\njne    17ec <check_win+0x2ac>\njmp    1939 <check_win+0x3f9>\nnop\ncmp    %eax,%esi\njne    17e2 <check_win+0x2a2>\ncmp    %esi,%r8d\njne    17e2 <check_win+0x2a2>\ncmp    %r8d,-0xc(%rsp)\njne    17e2 <check_win+0x2a2>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    %eax,-0x58(%rsp)\njne    1809 <check_win+0x2c9>\ncmp    -0x58(%rsp),%ecx\njne    1809 <check_win+0x2c9>\ncmp    %ecx,-0x2c(%rsp)\njne    1809 <check_win+0x2c9>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    %eax,-0x54(%rsp)\njne    17ff <check_win+0x2bf>\ncmp    -0x54(%rsp),%esi\njne    17ff <check_win+0x2bf>\ncmp    %esi,%r8d\njne    17ff <check_win+0x2bf>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    %eax,-0x44(%rsp)\njne    17f5 <check_win+0x2b5>\nmov    -0x44(%rsp),%r15d\ncmp    %r15d,-0x20(%rsp)\njne    17f5 <check_win+0x2b5>\nmov    -0x20(%rsp),%r15d\ncmp    %r15d,-0x8(%rsp)\njne    17f5 <check_win+0x2b5>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    %eax,%r13d\njne    1813 <check_win+0x2d3>\ncmp    %r13d,-0x44(%rsp)\njne    1813 <check_win+0x2d3>\nmov    -0x44(%rsp),%r15d\ncmp    %r15d,-0x20(%rsp)\njne    1813 <check_win+0x2d3>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    0x80(%rdx),%eax\njne    1845 <check_win+0x305>\ncmp    0x68(%rdx),%eax\njne    1845 <check_win+0x305>\ncmp    %eax,-0x18(%rsp)\njne    1845 <check_win+0x305>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    -0x50(%rsp),%eax\njne    183b <check_win+0x2fb>\ncmp    0x64(%rdx),%eax\njne    183b <check_win+0x2fb>\ncmp    -0x28(%rsp),%eax\njne    183b <check_win+0x2fb>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    -0x4c(%rsp),%eax\njne    1831 <check_win+0x2f1>\ncmp    %r13d,%eax\njne    1831 <check_win+0x2f1>\ncmp    -0x44(%rsp),%eax\njne    1831 <check_win+0x2f1>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    -0x48(%rsp),%eax\njne    1827 <check_win+0x2e7>\ncmp    -0x58(%rsp),%eax\njne    1827 <check_win+0x2e7>\ncmp    %ecx,%eax\njne    1827 <check_win+0x2e7>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    %eax,0x64(%rdx)\njne    181d <check_win+0x2dd>\ncmp    %eax,-0x28(%rsp)\njne    181d <check_win+0x2dd>\nmov    -0x28(%rsp),%r15d\ncmp    %r15d,-0x10(%rsp)\njne    181d <check_win+0x2dd>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    %r10d,%eax\njne    184e <check_win+0x30e>\ncmp    %esi,%eax\njne    184e <check_win+0x30e>\ncmp    %r13d,%eax\njne    184e <check_win+0x30e>\njmp    1939 <check_win+0x3f9>\nnop\ncmp    %r9d,%eax\njne    1856 <check_win+0x316>\ncmp    %ecx,%eax\njne    1856 <check_win+0x316>\ncmp    %eax,0x64(%rdx)\njne    1856 <check_win+0x316>\njmp    1939 <check_win+0x3f9>\nnop\ncmp    %r8d,%eax\njne    185f <check_win+0x31f>\ncmp    %eax,-0x44(%rsp)\njne    185f <check_win+0x31f>\nmov    -0x44(%rsp),%ebx\ncmp    %ebx,0x68(%rdx)\njne    185f <check_win+0x31f>\njmp    1939 <check_win+0x3f9>\nnopl   (%rax)\ncmp    %eax,-0x44(%rsp)\njne    188d <check_win+0x34d>\nmov    -0x44(%rsp),%ebx\ncmp    %ebx,0x68(%rdx)\njne    188d <check_win+0x34d>\ncmp    %ebx,0x88(%rdx)\njne    188d <check_win+0x34d>\njmp    1939 <check_win+0x3f9>\ncmp    %ecx,%eax\njne    1884 <check_win+0x344>\ncmp    %eax,0x64(%rdx)\njne    1884 <check_win+0x344>\ncmp    %eax,0x84(%rdx)\njne    1884 <check_win+0x344>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    %esi,%eax\njne    187b <check_win+0x33b>\ncmp    %r13d,%eax\njne    187b <check_win+0x33b>\ncmp    %eax,0x80(%rdx)\njne    187b <check_win+0x33b>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    %edi,%eax\njne    1872 <check_win+0x332>\ncmp    -0x58(%rsp),%eax\njne    1872 <check_win+0x332>\ncmp    -0x50(%rsp),%eax\njne    1872 <check_win+0x332>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    %eax,-0x2c(%rsp)\njne    1868 <check_win+0x328>\nmov    -0x2c(%rsp),%r14d\ncmp    %r14d,-0x28(%rsp)\njne    1868 <check_win+0x328>\nmov    -0x28(%rsp),%ebx\ncmp    %ebx,0x6c(%rdx)\njne    1868 <check_win+0x328>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax)\ncmp    %eax,0x64(%rdx)\njne    18b2 <check_win+0x372>\ncmp    %eax,0x84(%rdx)\njne    18b2 <check_win+0x372>\nxor    %r8d,%r8d\ncmp    %eax,0xa4(%rdx)\nsete   %r8b\njmp    18b2 <check_win+0x372>\nnop\ncmp    -0x54(%rsp),%eax\njne    1897 <check_win+0x357>\ncmp    -0x4c(%rsp),%eax\njne    1897 <check_win+0x357>\ncmp    %eax,-0x40(%rsp)\njne    1897 <check_win+0x357>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    %r13d,%eax\njne    18a7 <check_win+0x367>\ncmp    %eax,0x80(%rdx)\njne    18a7 <check_win+0x367>\ncmp    %eax,0xa0(%rdx)\njne    18a7 <check_win+0x367>\njmp    1939 <check_win+0x3f9>\nxchg   %ax,%ax\ncmp    -0x58(%rsp),%eax\njne    189f <check_win+0x35f>\ncmp    -0x50(%rsp),%eax\njne    189f <check_win+0x35f>\ncmp    %eax,0x9c(%rdx)\njne    189f <check_win+0x35f>\njmp    1939 <check_win+0x3f9>\nnopl   (%rax)\ncmp    %r11d,%eax\njne    1584 <check_win+0x44>\ncmp    0x10(%rdx),%r11d\njne    1584 <check_win+0x44>\ncmp    0x14(%rdx),%r11d\njne    18c9 <check_win+0x389>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    %ecx,%eax\njne    15ed <check_win+0xad>\ncmp    0x48(%rdx),%ecx\njne    15ed <check_win+0xad>\ncmp    0x4c(%rdx),%ecx\njne    1909 <check_win+0x3c9>\njmp    1939 <check_win+0x3f9>\nnop\ncmp    %r8d,%eax\njne    15ba <check_win+0x7a>\ncmp    0x2c(%rdx),%r8d\njne    15ba <check_win+0x7a>\ncmp    0x30(%rdx),%r8d\njne    1956 <check_win+0x416>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    %r13d,%eax\njne    162f <check_win+0xef>\ncmp    0x64(%rdx),%r13d\njne    162f <check_win+0xef>\ncmp    0x68(%rdx),%r13d\njne    19c1 <check_win+0x481>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    -0x50(%rsp),%eax\njne    1677 <check_win+0x137>\nmov    -0x50(%rsp),%ebx\ncmp    0x80(%rdx),%ebx\njne    1677 <check_win+0x137>\ncmp    0x84(%rdx),%ebx\njne    1a14 <check_win+0x4d4>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    -0x40(%rsp),%eax\njne    16c8 <check_win+0x188>\nmov    -0x40(%rsp),%ebx\ncmp    0x9c(%rdx),%ebx\njne    16c8 <check_win+0x188>\ncmp    0xa0(%rdx),%ebx\njne    1a44 <check_win+0x504>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    -0x24(%rsp),%eax\njne    16e5 <check_win+0x1a5>\ncmp    -0x1c(%rsp),%eax\njne    16e5 <check_win+0x1a5>\ncmp    %eax,-0x14(%rsp)\njne    16e5 <check_win+0x1a5>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    -0x54(%rsp),%eax\njne    16fe <check_win+0x1be>\ncmp    -0x48(%rsp),%eax\njne    16fe <check_win+0x1be>\ncmp    %eax,-0x3c(%rsp)\njne    16fe <check_win+0x1be>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\ncmp    %r13d,%eax\njne    1732 <check_win+0x1f2>\ncmp    -0x50(%rsp),%eax\njne    1732 <check_win+0x1f2>\ncmp    %eax,-0x40(%rsp)\njne    1732 <check_win+0x1f2>\njmp    1939 <check_win+0x3f9>\nnopw   0x0(%rax,%rax,1)\ncmp    -0x58(%rsp),%eax\njne    1718 <check_win+0x1d8>\ncmp    -0x4c(%rsp),%eax\njne    1718 <check_win+0x1d8>\ncmp    %eax,-0x34(%rsp)\njne    1718 <check_win+0x1d8>\njmp    1939 <check_win+0x3f9>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "evaluate_window", "content": "// -------------------------------------------------\n// Heuristic Evaluation Function\n// -------------------------------------------------\n\n// Evaluate a window of 4 cells for scoring.\nint evaluate_window(int window[4], int player) {\n    int score = 0;\n    int opp = (player == 1) ? 2 : 1;\n    int count_player = 0, count_opp = 0, count_empty = 0;\n    for (int i = 0; i < 4; i++) {\n        if (window[i] == player) count_player++;\n        else if (window[i] == opp) count_opp++;\n        else count_empty++;\n    }\n    if (count_player == 4)\n        score += 100;\n    else if (count_player == 3 && count_empty == 1)\n        score += 5;\n    else if (count_player == 2 && count_empty == 2)\n        score += 2;\n    if (count_opp == 3 && count_empty == 1)\n        score -= 4;\n    return score;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "evaluate_window", "address": "0x2380", "label": "evaluate_window", "content": "int __fastcall evaluate_window(int *window, int player)\n{\n  __m128i v2; // xmm2\n  __m128i v3; // xmm0\n  __m128i v4; // xmm4\n  __m128i v5; // xmm3\n  __m128i v6; // xmm2\n  __m128i v7; // xmm3\n  __m128i v8; // xmm1\n  __m128i si128; // xmm4\n  __m128i v10; // xmm1\n  __m128i v11; // xmm0\n  __m128i v12; // xmm2\n  __m128i v13; // xmm1\n  int v14; // edx\n  __m128i v15; // xmm1\n  int v16; // ecx\n  __m128i v17; // xmm0\n  int v18; // eax\n  int v19; // edi\n  int v20; // r8d\n\n  v2 = _mm_loadu_si128((const __m128i *)window);\n  v3 = _mm_cmpeq_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(player), 0), v2);\n  v4 = _mm_cmpeq_epi32(v3, (__m128i)0LL);\n  v5 = _mm_cmpeq_epi32(v2, _mm_shuffle_epi32(_mm_cvtsi32_si128((unsigned int)(player == 1) + 1), 0));\n  v6 = _mm_cmpeq_epi32(v5, (__m128i)0LL);\n  v7 = _mm_and_si128(v5, v4);\n  v8 = _mm_and_si128(v6, v4);\n  si128 = _mm_load_si128((const __m128i *)&xmmword_70A0);\n  v10 = _mm_and_si128(v8, si128);\n  v11 = _mm_and_si128(v3, si128);\n  v12 = _mm_and_si128(v7, si128);\n  v13 = _mm_add_epi32(v10, _mm_srli_si128(v10, 8));\n  v14 = _mm_cvtsi128_si32(_mm_add_epi32(v13, _mm_srli_si128(v13, 4)));\n  v15 = _mm_add_epi32(_mm_srli_si128(v12, 8), v12);\n  v16 = _mm_cvtsi128_si32(_mm_add_epi32(v15, _mm_srli_si128(v15, 4)));\n  v17 = _mm_add_epi32(v11, _mm_srli_si128(v11, 8));\n  v18 = _mm_cvtsi128_si32(_mm_add_epi32(v17, _mm_srli_si128(v17, 4)));\n  if ( v18 == 4 )\n  {\n    v19 = 96;\n    v20 = 100;\n  }\n  else if ( v18 != 3 || (v19 = 1, v20 = 5, v14 != 1) )\n  {\n    if ( v18 == 2 )\n    {\n      v20 = 2;\n      if ( v14 == 2 )\n        return v20;\n    }\n    v19 = -4;\n    v20 = 0;\n  }\n  if ( v16 == 3 && v14 == 1 )\n    return v19;\n  return v20;\n}\n"}, "pseudo_normalize": "int evaluate_window(int *window, int player) {\n  __m128i v2;\n  __m128i v3;\n  __m128i v4;\n  __m128i v5;\n  __m128i v6;\n  __m128i v7;\n  __m128i v8;\n  __m128i si128;\n  __m128i v10;\n  __m128i v11;\n  __m128i v12;\n  __m128i v13;\n  int v14;\n  __m128i v15;\n  int v16;\n  __m128i v17;\n  int v18;\n  int v19;\n  int v20;\n  v2 = _mm_loadu_si128((const __m128i *)window);\n  v3 = _mm_cmpeq_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(player), 0), v2);\n  v4 = _mm_cmpeq_epi32(v3, (__m128i)0LL);\n  v5 = _mm_cmpeq_epi32(\n      v2,\n      _mm_shuffle_epi32(_mm_cvtsi32_si128((unsigned int)(player == 1) + 1), 0));\n  v6 = _mm_cmpeq_epi32(v5, (__m128i)0LL);\n  v7 = _mm_and_si128(v5, v4);\n  v8 = _mm_and_si128(v6, v4);\n  si128 = _mm_load_si128((const __m128i *)&xmmword_70A0);\n  v10 = _mm_and_si128(v8, si128);\n  v11 = _mm_and_si128(v3, si128);\n  v12 = _mm_and_si128(v7, si128);\n  v13 = _mm_add_epi32(v10, _mm_srli_si128(v10, 8));\n  v14 = _mm_cvtsi128_si32(_mm_add_epi32(v13, _mm_srli_si128(v13, 4)));\n  v15 = _mm_add_epi32(_mm_srli_si128(v12, 8), v12);\n  v16 = _mm_cvtsi128_si32(_mm_add_epi32(v15, _mm_srli_si128(v15, 4)));\n  v17 = _mm_add_epi32(v11, _mm_srli_si128(v11, 8));\n  v18 = _mm_cvtsi128_si32(_mm_add_epi32(v17, _mm_srli_si128(v17, 4)));\n  if (v18 == 4) {\n    v19 = 96;\n    v20 = 100;\n  } else if (v18 != 3 || (v19 = 1, v20 = 5, v14 != 1)) {\n    if (v18 == 2) {\n      v20 = 2;\n      if (v14 == 2) return v20;\n    }\n    v19 = -4;\n    v20 = 0;\n  }\n  if (v16 == 3 && v14 == 1) return v19;\n  return v20;\n}", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<evaluate_window>:\nendbr64\nxor    %eax,%eax\ncmp    $0x1,%esi\nmovdqu (%rdi),%xmm2\nmovd   %esi,%xmm6\nsete   %al\npshufd $0x0,%xmm6,%xmm0\npxor   %xmm5,%xmm5\nadd    $0x1,%eax\npcmpeqd %xmm2,%xmm0\nmovd   %eax,%xmm7\npshufd $0x0,%xmm7,%xmm1\npcmpeqd %xmm1,%xmm2\nmovdqa %xmm0,%xmm4\npcmpeqd %xmm5,%xmm4\nmovdqa %xmm2,%xmm3\npcmpeqd %xmm5,%xmm2\npand   %xmm4,%xmm3\nmovdqa %xmm2,%xmm1\npand   %xmm4,%xmm1\nmovdqa 0x4ccb(%rip),%xmm4\npand   %xmm4,%xmm3\npand   %xmm4,%xmm1\npand   %xmm4,%xmm0\nmovdqa %xmm3,%xmm2\nmovdqa %xmm1,%xmm3\npsrldq $0x8,%xmm3\npaddd  %xmm3,%xmm1\nmovdqa %xmm1,%xmm3\npsrldq $0x4,%xmm3\npaddd  %xmm3,%xmm1\nmovd   %xmm1,%edx\nmovdqa %xmm2,%xmm1\npsrldq $0x8,%xmm1\ncmp    $0x1,%edx\npaddd  %xmm2,%xmm1\nsete   %sil\nmovdqa %xmm1,%xmm2\npsrldq $0x4,%xmm2\npaddd  %xmm2,%xmm1\nmovd   %xmm1,%ecx\nmovdqa %xmm0,%xmm1\npsrldq $0x8,%xmm1\npaddd  %xmm1,%xmm0\nmovdqa %xmm0,%xmm1\npsrldq $0x4,%xmm1\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%eax\ncmp    $0x4,%eax\nje     2490 <evaluate_window+0x110>\ncmp    $0x3,%eax\njne    2470 <evaluate_window+0xf0>\nmov    $0x1,%edi\nmov    $0x5,%r8d\ntest   %sil,%sil\nje     2470 <evaluate_window+0xf0>\ncmp    $0x3,%ecx\njne    246c <evaluate_window+0xec>\ntest   %sil,%sil\ncmovne %edi,%r8d\nmov    %r8d,%eax\nret\ncmp    $0x2,%eax\njne    2480 <evaluate_window+0x100>\nmov    $0x2,%r8d\ncmp    $0x2,%edx\nje     246c <evaluate_window+0xec>\nmov    $0xfffffffc,%edi\nxor    %r8d,%r8d\njmp    2460 <evaluate_window+0xe0>\nnopw   0x0(%rax,%rax,1)\nmov    $0x60,%edi\nmov    $0x64,%r8d\njmp    2460 <evaluate_window+0xe0>\nnopl   (%rax)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "get_next_open_row", "content": "// Returns the lowest available row in the given column (or -1 if full).\nint get_next_open_row(int board[ROWS][COLS], int col) {\n    for (int r = ROWS - 1; r >= 0; r--) {\n        if (board[r][col] == EMPTY)\n            return r;\n    }\n    return -1;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "get_next_open_row", "address": "0x1380", "label": "get_next_open_row", "content": "int __fastcall get_next_open_row(int (*board)[7], int col)\n{\n  __int64 v2; // rax\n  int result; // eax\n\n  v2 = col;\n  if ( !(*board)[v2 + 35] )\n    return 5;\n  if ( !(*board)[v2 + 28] )\n    return 4;\n  if ( !(*board)[v2 + 21] )\n    return 3;\n  if ( !(*board)[v2 + 14] )\n    return 2;\n  if ( !(*board)[v2 + 7] )\n    return 1;\n  result = (*board)[col];\n  if ( result )\n    return -1;\n  return result;\n}\n"}, "pseudo_normalize": "int get_next_open_row(int (*board)[7], int col) {\n  long long v2;\n  int result;\n  v2 = col;\n  if (!(*board)[v2 + 35]) return 5;\n  if (!(*board)[v2 + 28]) return 4;\n  if (!(*board)[v2 + 21]) return 3;\n  if (!(*board)[v2 + 14]) return 2;\n  if (!(*board)[v2 + 7]) return 1;\n  result = (*board)[col];\n  if (result) return -1;\n  return result;\n}", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<get_next_open_row>:\nendbr64\nmovslq %esi,%rsi\nmov    0x8c(%rdi,%rsi,4),%r9d\nlea    0x0(,%rsi,4),%rax\ntest   %r9d,%r9d\nje     13d0 <get_next_open_row+0x50>\nmov    0x70(%rdi,%rax,1),%r8d\ntest   %r8d,%r8d\nje     13d6 <get_next_open_row+0x56>\nmov    0x54(%rdi,%rax,1),%ecx\ntest   %ecx,%ecx\nje     13dc <get_next_open_row+0x5c>\nmov    0x38(%rdi,%rax,1),%edx\ntest   %edx,%edx\nje     13e2 <get_next_open_row+0x62>\nmov    0x1c(%rdi,%rax,1),%eax\ntest   %eax,%eax\nje     13e8 <get_next_open_row+0x68>\nmov    (%rdi,%rsi,4),%eax\nmov    $0xffffffff,%edx\ntest   %eax,%eax\ncmovne %edx,%eax\nret\nnopl   0x0(%rax)\nmov    $0x5,%eax\nret\nmov    $0x4,%eax\nret\nmov    $0x3,%eax\nret\nmov    $0x2,%eax\nret\nmov    $0x1,%eax\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "init_board", "content": "#include \"libmin.h\"\n\n#define ROWS 6\n#define COLS 7\n#define MAX_DEPTH 4\n\n// Players: 1 and 2. Board cells: 0 = empty.\n#define EMPTY 0\n\n// Scoring constants for evaluation\n#define WIN_SCORE 100000\n#define LOSS_SCORE -100000\n\n// -------------------------------------------------\n// Board Helpers\n// -------------------------------------------------\nvoid init_board(int board[ROWS][COLS]) {\n    for (int r = 0; r < ROWS; r++)\n        for (int c = 0; c < COLS; c++)\n            board[r][c] = EMPTY;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "init_board", "address": "0x1230", "label": "init_board", "content": "void __fastcall init_board(int (*board)[7])\n{\n  *(_QWORD *)&(*board)[28] = 0LL;\n  *(_QWORD *)&(*board)[30] = 0LL;\n  *(_QWORD *)&(*board)[32] = 0LL;\n  *(_QWORD *)&(*board)[34] = 0LL;\n  *(_QWORD *)&(*board)[36] = 0LL;\n  *(_QWORD *)&(*board)[38] = 0LL;\n  *(_QWORD *)&(*board)[40] = 0LL;\n  *(_OWORD *)board = 0LL;\n  *(_OWORD *)&(*board)[4] = 0LL;\n  *(_OWORD *)&(*board)[8] = 0LL;\n  *(_OWORD *)&(*board)[12] = 0LL;\n  *(_OWORD *)&(*board)[16] = 0LL;\n  *(_OWORD *)&(*board)[20] = 0LL;\n  *(_OWORD *)&(*board)[24] = 0LL;\n}\n"}, "pseudo_normalize": "void init_board(int (*board)[7]) {\n  *(uint64_t *)&(*board)[28] = 0LL;\n  *(uint64_t *)&(*board)[30] = 0LL;\n  *(uint64_t *)&(*board)[32] = 0LL;\n  *(uint64_t *)&(*board)[34] = 0LL;\n  *(uint64_t *)&(*board)[36] = 0LL;\n  *(uint64_t *)&(*board)[38] = 0LL;\n  *(uint64_t *)&(*board)[40] = 0LL;\n  *(long double *)board = 0LL;\n  *(long double *)&(*board)[4] = 0LL;\n  *(long double *)&(*board)[8] = 0LL;\n  *(long double *)&(*board)[12] = 0LL;\n  *(long double *)&(*board)[16] = 0LL;\n  *(long double *)&(*board)[20] = 0LL;\n  *(long double *)&(*board)[24] = 0LL;\n}", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<init_board>:\nendbr64\npxor   %xmm0,%xmm0\nmovq   $0x0,0x70(%rdi)\nmovq   $0x0,0x78(%rdi)\nmovq   $0x0,0x80(%rdi)\nmovq   $0x0,0x88(%rdi)\nmovq   $0x0,0x90(%rdi)\nmovq   $0x0,0x98(%rdi)\nmovq   $0x0,0xa0(%rdi)\nmovups %xmm0,(%rdi)\nmovups %xmm0,0x10(%rdi)\nmovups %xmm0,0x20(%rdi)\nmovups %xmm0,0x30(%rdi)\nmovups %xmm0,0x40(%rdi)\nmovups %xmm0,0x50(%rdi)\nmovups %xmm0,0x60(%rdi)\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "main", "content": "int main(void) {\n    libmin_srand(42);\n    libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\");\n    play_game();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x2a,%edi\ncall   6920 <libmin_srand>\nlea    0x5f57(%rip),%rdi\nxor    %eax,%eax\ncall   6710 <libmin_printf>\nxor    %eax,%eax\ncall   4260 <play_game>\ncall   6b70 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "make_move", "content": "// Make a move: drop piece for player into col. Returns row where piece lands, or -1 if invalid.\nint make_move(int board[ROWS][COLS], int col, int player) {\n    if (!valid_move(board, col))\n        return -1;\n    int row = get_next_open_row(board, col);\n    board[row][col] = player;\n    return row;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "make_move", "address": "0x13f0", "label": "make_move", "content": "int __fastcall make_move(int (*board)[7], int col, int player)\n{\n  int v3; // ecx\n  int result; // eax\n\n  if ( (*board)[col] )\n    return -1;\n  if ( (*board)[col + 35] )\n  {\n    if ( (*board)[col + 28] )\n    {\n      if ( (*board)[col + 21] )\n      {\n        if ( (*board)[col + 14] )\n        {\n          v3 = (*board)[col + 7];\n          if ( !v3 )\n            ++board;\n          result = v3 == 0;\n        }\n        else\n        {\n          board += 2;\n          result = 2;\n        }\n      }\n      else\n      {\n        board += 3;\n        result = 3;\n      }\n    }\n    else\n    {\n      board += 4;\n      result = 4;\n    }\n  }\n  else\n  {\n    board += 5;\n    result = 5;\n  }\n  (*board)[col] = player;\n  return result;\n}\n"}, "pseudo_normalize": "int make_move(int (*board)[7], int col, int player) {\n  int v3;\n  int result;\n  if ((*board)[col]) return -1;\n  if ((*board)[col + 35]) {\n    if ((*board)[col + 28]) {\n      if ((*board)[col + 21]) {\n        if ((*board)[col + 14]) {\n          v3 = (*board)[col + 7];\n          if (!v3) ++board;\n          result = v3 == 0;\n        } else {\n          board += 2;\n          result = 2;\n        }\n      } else {\n        board += 3;\n        result = 3;\n      }\n    } else {\n      board += 4;\n      result = 4;\n    }\n  } else {\n    board += 5;\n    result = 5;\n  }\n  (*board)[col] = player;\n  return result;\n}", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<make_move>:\nendbr64\nmovslq %esi,%rsi\nmov    (%rdi,%rsi,4),%eax\ntest   %eax,%eax\njne    1488 <make_move+0x98>\nmov    0x8c(%rdi,%rsi,4),%r11d\nlea    0x8c(%rdi),%rax\ntest   %r11d,%r11d\nje     1460 <make_move+0x70>\nmov    0x70(%rdi,%rsi,4),%r10d\nlea    0x70(%rdi),%rax\ntest   %r10d,%r10d\nje     146a <make_move+0x7a>\nmov    0x54(%rdi,%rsi,4),%r9d\nlea    0x54(%rdi),%rax\ntest   %r9d,%r9d\nje     1474 <make_move+0x84>\nmov    0x38(%rdi,%rsi,4),%r8d\nlea    0x38(%rdi),%rax\ntest   %r8d,%r8d\nje     147e <make_move+0x8e>\nmov    0x1c(%rdi,%rsi,4),%ecx\nlea    0x1c(%rdi),%rax\ntest   %ecx,%ecx\ncmove  %rax,%rdi\nsete   %al\nmovzbl %al,%eax\nmov    %edx,(%rdi,%rsi,4)\nret\nnopl   0x0(%rax,%rax,1)\nmov    %rax,%rdi\nmov    $0x5,%eax\njmp    1454 <make_move+0x64>\nmov    %rax,%rdi\nmov    $0x4,%eax\njmp    1454 <make_move+0x64>\nmov    %rax,%rdi\nmov    $0x3,%eax\njmp    1454 <make_move+0x64>\nmov    %rax,%rdi\nmov    $0x2,%eax\njmp    1454 <make_move+0x64>\nmov    $0xffffffff,%eax\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "minimax", "content": "// -------------------------------------------------\n// Minimax with Alpha-Beta Pruning and Random Tie-Breaking\n// -------------------------------------------------\n\n// Returns evaluation score. If at top level, best_move will be set (column index).\nint minimax(int board[ROWS][COLS], int depth, int alpha, int beta, int maximizingPlayer, int player, int *best_move) {\n    int opp = (player == 1) ? 2 : 1;\n    // Check terminal conditions or depth limit\n    if (depth == 0 || board_full(board) || check_win(board, player) || check_win(board, opp)) {\n        int ts = terminal_score(board, player);\n        if (ts == 0) { // non-terminal leaf at depth 0: use heuristic\n            return score_position(board, player);\n        } else {\n            return ts;\n        }\n    }\n    \n    int valid_cols[COLS];\n    int valid_count = 0;\n    for (int c = 0; c < COLS; c++) {\n        if (valid_move(board, c))\n            valid_cols[valid_count++] = c;\n    }\n    \n    int best_score;\n    // For random tie-breaking, we keep an array of moves with best scores.\n    int best_moves[COLS];\n    int best_moves_count = 0;\n    \n    if (maximizingPlayer) {\n        best_score = INT_MIN;\n        for (int i = 0; i < valid_count; i++) {\n            int col = valid_cols[i];\n            make_move(board, col, player);\n            int score = minimax(board, depth - 1, alpha, beta, 0, player, NULL);\n            undo_move(board, col);\n            // Random tie breaking: if equal score, record all such moves.\n            if (score > best_score) {\n                best_score = score;\n                best_moves_count = 0;\n                best_moves[best_moves_count++] = col;\n            } else if (score == best_score) {\n                best_moves[best_moves_count++] = col;\n            }\n            if (best_score > alpha)\n                alpha = best_score;\n            if (alpha >= beta)\n                break;\n        }\n    } else {\n        best_score = INT_MAX;\n        for (int i = 0; i < valid_count; i++) {\n            int col = valid_cols[i];\n            make_move(board, col, opp);\n            int score = minimax(board, depth - 1, alpha, beta, 1, player, NULL);\n            undo_move(board, col);\n            if (score < best_score) {\n                best_score = score;\n                best_moves_count = 0;\n                best_moves[best_moves_count++] = col;\n            } else if (score == best_score) {\n                best_moves[best_moves_count++] = col;\n            }\n            if (best_score < beta)\n                beta = best_score;\n            if (alpha >= beta)\n                break;\n        }\n    }\n    \n    // At top level, choose a random move from the best moves if available.\n    if (depth == MAX_DEPTH && best_moves_count > 0 && best_move != NULL) {\n        int chosen = best_moves[libmin_rand() % best_moves_count];\n        *best_move = chosen;\n    }\n    return best_score;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "minimax", "address": "0x3c30", "label": "minimax", "content": "int __fastcall minimax(\n        int (*board)[7],\n        int depth,\n        int alpha,\n        int beta,\n        int maximizingPlayer,\n        int player,\n        int *best_move)\n{\n  int v8; // ebp\n  int v12; // r12d\n  int v13; // edx\n  int v14; // eax\n  int v15; // ecx\n  __int64 v16; // rsi\n  __int64 v17; // rsi\n  __int64 v18; // rsi\n  __int64 v19; // rsi\n  __int64 v20; // rsi\n  int v21; // esi\n  int v22; // r9d\n  int *v23; // r14\n  int v24; // ebp\n  __int64 v25; // r15\n  int *v26; // rbx\n  int v27; // r10d\n  __int64 v28; // rax\n  int v29; // eax\n  int *v30; // rcx\n  int v31; // ebx\n  int *v32; // r14\n  int v33; // ebp\n  int v34; // r9d\n  __int64 v35; // r15\n  int *v36; // rbx\n  int v37; // r10d\n  __int64 v38; // rax\n  int v39; // eax\n  int *v40; // rdx\n  int best_moves_count; // [rsp+8h] [rbp-B0h]\n  int best_moves_counta; // [rsp+8h] [rbp-B0h]\n  int alphab; // [rsp+Ch] [rbp-ACh]\n  int alphac; // [rsp+Ch] [rbp-ACh]\n  int alphad; // [rsp+Ch] [rbp-ACh]\n  int betab; // [rsp+10h] [rbp-A8h]\n  int betac; // [rsp+10h] [rbp-A8h]\n  int betad; // [rsp+10h] [rbp-A8h]\n  int v51; // [rsp+14h] [rbp-A4h]\n  int v52; // [rsp+14h] [rbp-A4h]\n  int v53; // [rsp+14h] [rbp-A4h]\n  int v54; // [rsp+18h] [rbp-A0h]\n  int v55; // [rsp+20h] [rbp-98h]\n  int v56; // [rsp+28h] [rbp-90h]\n  int v57; // [rsp+28h] [rbp-90h]\n  int deptha; // [rsp+2Ch] [rbp-8Ch]\n  int valid_cols[8]; // [rsp+30h] [rbp-88h] BYREF\n  int best_moves[10]; // [rsp+50h] [rbp-68h]\n  unsigned __int64 v61; // [rsp+78h] [rbp-40h]\n\n  v61 = __readfsqword(0x28u);\n  v8 = (player == 1) + 1;\n  if ( !depth || (*board)[0] && (*board)[1] && (*board)[2] && (*board)[3] && (*board)[4] && (*board)[5] && (*board)[6] )\n  {\n    if ( check_win(board, player) )\n      return 100000;\n    if ( check_win(board, v8) )\n      return -100000;\n    return score_position(board, player);\n  }\n  v12 = 100000;\n  best_moves_count = (*board)[0];\n  if ( check_win(board, player) )\n    return v12;\n  v51 = beta;\n  v12 = -100000;\n  betab = alpha;\n  alphab = best_moves_count;\n  best_moves_counta = check_win(board, v8);\n  if ( best_moves_counta )\n    return v12;\n  v13 = betab;\n  v14 = 0;\n  v15 = v51;\n  if ( !alphab )\n  {\n    valid_cols[0] = 0;\n    v14 = 1;\n  }\n  if ( !(*board)[1] )\n  {\n    v16 = v14++;\n    valid_cols[v16] = 1;\n  }\n  if ( !(*board)[2] )\n  {\n    v17 = v14++;\n    valid_cols[v17] = 2;\n  }\n  if ( !(*board)[3] )\n  {\n    v18 = v14++;\n    valid_cols[v18] = 3;\n  }\n  if ( !(*board)[4] )\n  {\n    v19 = v14++;\n    valid_cols[v19] = 4;\n  }\n  if ( !(*board)[5] )\n  {\n    v20 = v14++;\n    valid_cols[v20] = 5;\n  }\n  if ( (*board)[6] )\n  {\n    if ( !maximizingPlayer )\n    {\n      v21 = v14;\n      v12 = 0x7FFFFFFF;\n      if ( !v14 )\n        return v12;\n      goto LABEL_30;\n    }\n    v12 = 0x80000000;\n    if ( !v14 )\n      return v12;\n    v21 = v14;\n    goto LABEL_53;\n  }\n  v21 = v14 + 1;\n  valid_cols[v14] = 6;\n  if ( maximizingPlayer )\n  {\nLABEL_53:\n    v55 = depth;\n    v32 = valid_cols;\n    v33 = betab;\n    v57 = depth - 1;\n    v12 = 0x80000000;\n    v34 = player;\n    while ( 1 )\n    {\n      v35 = *v32;\n      v36 = &(*board)[v35];\n      v37 = *v32;\n      if ( !*v36 )\n      {\n        if ( v36[35] )\n        {\n          if ( v36[28] )\n          {\n            if ( v36[21] )\n            {\n              if ( v36[14] )\n                v38 = 7LL * (v36[7] == 0);\n              else\n                v38 = 14LL;\n            }\n            else\n            {\n              v38 = 21LL;\n            }\n          }\n          else\n          {\n            v38 = 28LL;\n          }\n        }\n        else\n        {\n          v38 = 35LL;\n        }\n        (*board)[v35 + v38] = v34;\n      }\n      v53 = v37;\n      betad = v34;\n      alphad = v15;\n      v39 = minimax(board, v57, v33, v15, 0, v34, 0LL);\n      v15 = alphad;\n      v34 = betad;\n      if ( *v36 )\n        break;\n      v40 = &(*board)[7];\n      if ( v36[7] )\n        goto LABEL_84;\n      v40 = &(*board)[14];\n      if ( v36[14] )\n        goto LABEL_84;\n      v40 = &(*board)[21];\n      if ( v36[21] )\n        goto LABEL_84;\n      v40 = &(*board)[28];\n      if ( v36[28] )\n        goto LABEL_84;\n      if ( v36[35] )\n      {\n        v40 = &(*board)[35];\n        goto LABEL_84;\n      }\nLABEL_67:\n      if ( v39 <= v12 )\n      {\n        if ( v39 == v12 )\n          best_moves[best_moves_counta++] = v53;\n      }\n      else\n      {\n        best_moves[0] = v53;\n        v12 = v39;\n        best_moves_counta = 1;\n      }\n      if ( v33 < v12 )\n        v33 = v12;\n      if ( v33 < alphad && ++v32 != &valid_cols[v21 - 1 + 1] )\n        continue;\n      v31 = v55;\n      goto LABEL_74;\n    }\n    v40 = (int *)board;\nLABEL_84:\n    v40[v35] = 0;\n    goto LABEL_67;\n  }\nLABEL_30:\n  deptha = depth;\n  v22 = player;\n  v56 = depth - 1;\n  v12 = 0x7FFFFFFF;\n  v23 = valid_cols;\n  v54 = v8;\n  v24 = v51;\n  do\n  {\n    v25 = *v23;\n    v26 = &(*board)[v25];\n    v27 = *v23;\n    if ( !*v26 )\n    {\n      if ( v26[35] )\n      {\n        if ( v26[28] )\n        {\n          if ( v26[21] )\n          {\n            if ( v26[14] )\n              v28 = 7LL * (v26[7] == 0);\n            else\n              v28 = 14LL;\n          }\n          else\n          {\n            v28 = 21LL;\n          }\n        }\n        else\n        {\n          v28 = 28LL;\n        }\n      }\n      else\n      {\n        v28 = 35LL;\n      }\n      (*board)[v25 + v28] = v54;\n    }\n    v52 = v27;\n    betac = v22;\n    alphac = v13;\n    v29 = minimax(board, v56, v13, v24, 1, v22, 0LL);\n    v13 = alphac;\n    v22 = betac;\n    if ( *v26 )\n    {\n      v30 = (int *)board;\n    }\n    else\n    {\n      v30 = &(*board)[7];\n      if ( !v26[7] )\n      {\n        v30 = &(*board)[14];\n        if ( !v26[14] )\n        {\n          v30 = &(*board)[21];\n          if ( !v26[21] )\n          {\n            v30 = &(*board)[28];\n            if ( !v26[28] )\n            {\n              if ( !v26[35] )\n                goto LABEL_44;\n              v30 = &(*board)[35];\n            }\n          }\n        }\n      }\n    }\n    v30[v25] = 0;\nLABEL_44:\n    if ( v29 >= v12 )\n    {\n      if ( v29 == v12 )\n        best_moves[best_moves_counta++] = v52;\n    }\n    else\n    {\n      best_moves[0] = v52;\n      v12 = v29;\n      best_moves_counta = 1;\n    }\n    if ( v24 > v12 )\n      v24 = v12;\n    if ( v24 <= alphac )\n      break;\n    ++v23;\n  }\n  while ( &valid_cols[v21 - 1 + 1] != v23 );\n  v31 = deptha;\nLABEL_74:\n  if ( best_move != 0LL && v31 == 4 && best_moves_counta > 0 )\n    *best_move = best_moves[libmin_rand() % best_moves_counta];\n  return v12;\n}\n"}, "pseudo_normalize": "int minimax(int (*board)[7], int depth, int alpha, int beta,\n            int maximizingPlayer, int player, int *best_move) {\n  int v8;\n  int v12;\n  int v13;\n  int v14;\n  int v15;\n  long long v16;\n  long long v17;\n  long long v18;\n  long long v19;\n  long long v20;\n  int v21;\n  int v22;\n  int *v23;\n  int v24;\n  long long v25;\n  int *v26;\n  int v27;\n  long long v28;\n  int v29;\n  int *v30;\n  int v31;\n  int *v32;\n  int v33;\n  int v34;\n  long long v35;\n  int *v36;\n  int v37;\n  long long v38;\n  int v39;\n  int *v40;\n  int best_moves_count;\n  int best_moves_counta;\n  int alphab;\n  int alphac;\n  int alphad;\n  int betab;\n  int betac;\n  int betad;\n  int v51;\n  int v52;\n  int v53;\n  int v54;\n  int v55;\n  int v56;\n  int v57;\n  int deptha;\n  int valid_cols[8];\n  int best_moves[10];\n  unsigned long long v61;\n  v61 = __readfsqword(40u);\n  v8 = (player == 1) + 1;\n  if (!depth || (*board)[0] && (*board)[1] && (*board)[2] && (*board)[3] &&\n                    (*board)[4] && (*board)[5] && (*board)[6]) {\n    if (check_win(board, player)) return 100000;\n    if (check_win(board, v8)) return -100000;\n    return score_position(board, player);\n  }\n  v12 = 100000;\n  best_moves_count = (*board)[0];\n  if (check_win(board, player)) return v12;\n  v51 = beta;\n  v12 = -100000;\n  betab = alpha;\n  alphab = best_moves_count;\n  best_moves_counta = check_win(board, v8);\n  if (best_moves_counta) return v12;\n  v13 = betab;\n  v14 = 0;\n  v15 = v51;\n  if (!alphab) {\n    valid_cols[0] = 0;\n    v14 = 1;\n  }\n  if (!(*board)[1]) {\n    v16 = v14++;\n    valid_cols[v16] = 1;\n  }\n  if (!(*board)[2]) {\n    v17 = v14++;\n    valid_cols[v17] = 2;\n  }\n  if (!(*board)[3]) {\n    v18 = v14++;\n    valid_cols[v18] = 3;\n  }\n  if (!(*board)[4]) {\n    v19 = v14++;\n    valid_cols[v19] = 4;\n  }\n  if (!(*board)[5]) {\n    v20 = v14++;\n    valid_cols[v20] = 5;\n  }\n  if ((*board)[6]) {\n    if (!maximizingPlayer) {\n      v21 = v14;\n      v12 = 2147483647;\n      if (!v14) return v12;\n      goto LABEL_30;\n    }\n    v12 = 2147483648;\n    if (!v14) return v12;\n    v21 = v14;\n    goto LABEL_53;\n  }\n  v21 = v14 + 1;\n  valid_cols[v14] = 6;\n  if (maximizingPlayer) {\n  LABEL_53:\n    v55 = depth;\n    v32 = valid_cols;\n    v33 = betab;\n    v57 = depth - 1;\n    v12 = 2147483648;\n    v34 = player;\n    while (1) {\n      v35 = *v32;\n      v36 = &(*board)[v35];\n      v37 = *v32;\n      if (!*v36) {\n        if (v36[35]) {\n          if (v36[28]) {\n            if (v36[21]) {\n              if (v36[14])\n                v38 = 7LL * (v36[7] == 0);\n              else\n                v38 = 14LL;\n            } else {\n              v38 = 21LL;\n            }\n          } else {\n            v38 = 28LL;\n          }\n        } else {\n          v38 = 35LL;\n        }\n        (*board)[v35 + v38] = v34;\n      }\n      v53 = v37;\n      betad = v34;\n      alphad = v15;\n      v39 = minimax(board, v57, v33, v15, 0, v34, 0LL);\n      v15 = alphad;\n      v34 = betad;\n      if (*v36) break;\n      v40 = &(*board)[7];\n      if (v36[7]) goto LABEL_84;\n      v40 = &(*board)[14];\n      if (v36[14]) goto LABEL_84;\n      v40 = &(*board)[21];\n      if (v36[21]) goto LABEL_84;\n      v40 = &(*board)[28];\n      if (v36[28]) goto LABEL_84;\n      if (v36[35]) {\n        v40 = &(*board)[35];\n        goto LABEL_84;\n      }\n    LABEL_67:\n      if (v39 <= v12) {\n        if (v39 == v12) best_moves[best_moves_counta++] = v53;\n      } else {\n        best_moves[0] = v53;\n        v12 = v39;\n        best_moves_counta = 1;\n      }\n      if (v33 < v12) v33 = v12;\n      if (v33 < alphad && ++v32 != &valid_cols[v21 - 1 + 1]) continue;\n      v31 = v55;\n      goto LABEL_74;\n    }\n    v40 = (int *)board;\n  LABEL_84:\n    v40[v35] = 0;\n    goto LABEL_67;\n  }\nLABEL_30:\n  deptha = depth;\n  v22 = player;\n  v56 = depth - 1;\n  v12 = 2147483647;\n  v23 = valid_cols;\n  v54 = v8;\n  v24 = v51;\n  do {\n    v25 = *v23;\n    v26 = &(*board)[v25];\n    v27 = *v23;\n    if (!*v26) {\n      if (v26[35]) {\n        if (v26[28]) {\n          if (v26[21]) {\n            if (v26[14])\n              v28 = 7LL * (v26[7] == 0);\n            else\n              v28 = 14LL;\n          } else {\n            v28 = 21LL;\n          }\n        } else {\n          v28 = 28LL;\n        }\n      } else {\n        v28 = 35LL;\n      }\n      (*board)[v25 + v28] = v54;\n    }\n    v52 = v27;\n    betac = v22;\n    alphac = v13;\n    v29 = minimax(board, v56, v13, v24, 1, v22, 0LL);\n    v13 = alphac;\n    v22 = betac;\n    if (*v26) {\n      v30 = (int *)board;\n    } else {\n      v30 = &(*board)[7];\n      if (!v26[7]) {\n        v30 = &(*board)[14];\n        if (!v26[14]) {\n          v30 = &(*board)[21];\n          if (!v26[21]) {\n            v30 = &(*board)[28];\n            if (!v26[28]) {\n              if (!v26[35]) goto LABEL_44;\n              v30 = &(*board)[35];\n            }\n          }\n        }\n      }\n    }\n    v30[v25] = 0;\n  LABEL_44:\n    if (v29 >= v12) {\n      if (v29 == v12) best_moves[best_moves_counta++] = v52;\n    } else {\n      best_moves[0] = v52;\n      v12 = v29;\n      best_moves_counta = 1;\n    }\n    if (v24 > v12) v24 = v12;\n    if (v24 <= alphac) break;\n    ++v23;\n  } while (&valid_cols[v21 - 1 + 1] != v23);\n  v31 = deptha;\nLABEL_74:\n  if (best_move != 0LL && v31 == 4 && best_moves_counta > 0)\n    *best_move = best_moves[libmin_rand() % best_moves_counta];\n  return v12;\n}", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<minimax>:\nendbr64\npush   %r15\nmov    %r9d,%r15d\npush   %r14\npush   %r13\nmov    %rdi,%r13\npush   %r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nsub    $0x88,%rsp\nmov    0xc0(%rsp),%rax\nmov    %rax,(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x78(%rsp)\nxor    %eax,%eax\ncmp    $0x1,%r9d\nsete   %bpl\nadd    $0x1,%ebp\ntest   %esi,%esi\nje     3cb9 <minimax+0x89>\nmov    %r8d,%r14d\nmov    (%rdi),%r8d\nmov    %esi,%ebx\ntest   %r8d,%r8d\nje     3d10 <minimax+0xe0>\nmov    0x4(%rdi),%eax\ntest   %eax,%eax\nje     3d10 <minimax+0xe0>\nmov    0x8(%rdi),%eax\ntest   %eax,%eax\nje     3d10 <minimax+0xe0>\nmov    0xc(%rdi),%eax\ntest   %eax,%eax\nje     3d10 <minimax+0xe0>\nmov    0x10(%rdi),%eax\ntest   %eax,%eax\nje     3d10 <minimax+0xe0>\nmov    0x14(%rdi),%eax\ntest   %eax,%eax\nje     3d10 <minimax+0xe0>\nmov    0x18(%rdi),%r12d\ntest   %r12d,%r12d\nje     3d10 <minimax+0xe0>\nmov    %r15d,%esi\nmov    %r13,%rdi\ncall   1540 <check_win>\ntest   %eax,%eax\njne    3fb8 <minimax+0x388>\nmov    %ebp,%esi\nmov    %r13,%rdi\ncall   1540 <check_win>\ntest   %eax,%eax\njne    424f <minimax+0x61f>\nmov    0x78(%rsp),%rax\nsub    %fs:0x28,%rax\njne    424a <minimax+0x61a>\nadd    $0x88,%rsp\nmov    %r15d,%esi\nmov    %r13,%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    24a0 <score_position>\nxchg   %ax,%ax\nmov    %r15d,%esi\nmov    %r13,%rdi\nmov    %ecx,0x10(%rsp)\nmov    $0x186a0,%r12d\nmov    %edx,0xc(%rsp)\nmov    %r8d,0x8(%rsp)\ncall   1540 <check_win>\nmov    0x8(%rsp),%r8d\nmov    0xc(%rsp),%edx\ntest   %eax,%eax\nmov    0x10(%rsp),%ecx\nje     3d70 <minimax+0x140>\nmov    0x78(%rsp),%rax\nsub    %fs:0x28,%rax\njne    424a <minimax+0x61a>\nadd    $0x88,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    %ebp,%esi\nmov    %r13,%rdi\nmov    %ecx,0x14(%rsp)\nmov    $0xfffe7960,%r12d\nmov    %edx,0x10(%rsp)\nmov    %r8d,0xc(%rsp)\ncall   1540 <check_win>\nmov    %eax,0x8(%rsp)\ntest   %eax,%eax\njne    3d3f <minimax+0x10f>\nmov    0xc(%rsp),%r8d\nmov    0x10(%rsp),%edx\nxor    %eax,%eax\nmov    0x14(%rsp),%ecx\ntest   %r8d,%r8d\njne    3db6 <minimax+0x186>\nmovl   $0x0,0x30(%rsp)\nmov    $0x1,%eax\nmov    0x4(%r13),%r11d\ntest   %r11d,%r11d\njne    3dcd <minimax+0x19d>\nmovslq %eax,%rsi\nadd    $0x1,%eax\nmovl   $0x1,0x30(%rsp,%rsi,4)\nmov    0x8(%r13),%r10d\ntest   %r10d,%r10d\njne    3de4 <minimax+0x1b4>\nmovslq %eax,%rsi\nadd    $0x1,%eax\nmovl   $0x2,0x30(%rsp,%rsi,4)\nmov    0xc(%r13),%r9d\ntest   %r9d,%r9d\njne    3dfb <minimax+0x1cb>\nmovslq %eax,%rsi\nadd    $0x1,%eax\nmovl   $0x3,0x30(%rsp,%rsi,4)\nmov    0x10(%r13),%r8d\ntest   %r8d,%r8d\njne    3e12 <minimax+0x1e2>\nmovslq %eax,%rsi\nadd    $0x1,%eax\nmovl   $0x4,0x30(%rsp,%rsi,4)\nmov    0x14(%r13),%edi\ntest   %edi,%edi\njne    3e28 <minimax+0x1f8>\nmovslq %eax,%rsi\nadd    $0x1,%eax\nmovl   $0x5,0x30(%rsp,%rsi,4)\nmov    0x18(%r13),%esi\ntest   %esi,%esi\nje     3fc8 <minimax+0x398>\ntest   %r14d,%r14d\njne    41cd <minimax+0x59d>\nmov    %eax,%esi\nmov    $0x7fffffff,%r12d\ntest   %eax,%eax\nje     3d3f <minimax+0x10f>\nlea    -0x1(%rbx),%eax\nmov    %ebx,0x2c(%rsp)\nlea    0x30(%rsp),%r11\nmov    %r15d,%r9d\nmov    %eax,0x28(%rsp)\nlea    -0x1(%rsi),%eax\nmov    $0x7fffffff,%r12d\nmov    %r11,%r14\nlea    0x34(%rsp,%rax,4),%rax\nmov    %ebp,0x18(%rsp)\nmov    %ecx,%ebp\nmov    %rax,0x20(%rsp)\nmovslq (%r14),%r15\nlea    0x0(%r13,%r15,4),%rbx\nmov    %r15,%r10\nmov    (%rbx),%eax\ntest   %eax,%eax\njne    3ee5 <minimax+0x2b5>\nmov    0x8c(%rbx),%eax\ntest   %eax,%eax\nje     41ec <minimax+0x5bc>\nmov    0x70(%rbx),%eax\ntest   %eax,%eax\nje     41f6 <minimax+0x5c6>\nmov    0x54(%rbx),%r11d\ntest   %r11d,%r11d\nje     4214 <minimax+0x5e4>\nmov    0x38(%rbx),%r8d\ntest   %r8d,%r8d\nje     4228 <minimax+0x5f8>\nmov    0x1c(%rbx),%edi\nxor    %ecx,%ecx\ntest   %edi,%edi\nsete   %cl\nlea    0x0(,%rcx,8),%rax\nsub    %rcx,%rax\nshl    $0x2,%rax\nmov    0x18(%rsp),%edi\nlea    0x0(%r13,%r15,4),%rcx\nmov    %edi,(%rcx,%rax,1)\nmov    %r10d,0x14(%rsp)\nsub    $0x8,%rsp\nmov    %ebp,%ecx\nmov    %r13,%rdi\npush   $0x0\nmov    0x38(%rsp),%esi\nmov    $0x1,%r8d\nmov    %r9d,0x20(%rsp)\nmov    %edx,0x1c(%rsp)\ncall   3c30 <minimax>\nmov    (%rbx),%esi\npop    %rdx\npop    %rcx\nmov    0xc(%rsp),%edx\ntest   %esi,%esi\nmov    0x10(%rsp),%r9d\nmov    0x14(%rsp),%r10d\njne    41a4 <minimax+0x574>\nmov    0x1c(%rbx),%r11d\nlea    0x1c(%r13),%rcx\ntest   %r11d,%r11d\njne    41b0 <minimax+0x580>\nmov    0x38(%rbx),%r8d\nlea    0x38(%r13),%rcx\ntest   %r8d,%r8d\njne    41b0 <minimax+0x580>\nmov    0x54(%rbx),%edi\nlea    0x54(%r13),%rcx\ntest   %edi,%edi\njne    41b0 <minimax+0x580>\nmov    0x70(%rbx),%esi\nlea    0x70(%r13),%rcx\ntest   %esi,%esi\njne    41b0 <minimax+0x580>\nmov    0x8c(%rbx),%ecx\ntest   %ecx,%ecx\njne    4232 <minimax+0x602>\ncmp    %r12d,%eax\njge    4188 <minimax+0x558>\nmov    %r10d,0x50(%rsp)\nmov    %eax,%r12d\nmovl   $0x1,0x8(%rsp)\ncmp    %r12d,%ebp\ncmovg  %r12d,%ebp\ncmp    %edx,%ebp\njle    3fa8 <minimax+0x378>\nadd    $0x4,%r14\ncmp    %r14,0x20(%rsp)\njne    3e7c <minimax+0x24c>\nmov    0x2c(%rsp),%ebx\njmp    412c <minimax+0x4fc>\nnopl   0x0(%rax)\nmov    $0x186a0,%r12d\njmp    3d3f <minimax+0x10f>\nnopl   0x0(%rax,%rax,1)\nlea    0x1(%rax),%esi\ncltq\nmovl   $0x6,0x30(%rsp,%rax,4)\ntest   %r14d,%r14d\nje     3e4d <minimax+0x21d>\nlea    -0x1(%rbx),%eax\nmov    %ebx,0x20(%rsp)\nlea    0x30(%rsp),%r14\nmov    %edx,%ebp\nmov    %eax,0x28(%rsp)\nlea    -0x1(%rsi),%eax\nmov    $0x80000000,%r12d\nmov    %r15d,%r9d\nlea    0x34(%rsp,%rax,4),%rax\nmov    %rax,0x18(%rsp)\nmovslq (%r14),%r15\nlea    0x0(%r13,%r15,4),%rbx\nmov    %r15,%r10\nmov    (%rbx),%eax\ntest   %eax,%eax\njne    406c <minimax+0x43c>\nmov    0x8c(%rbx),%eax\ntest   %eax,%eax\nje     41e2 <minimax+0x5b2>\nmov    0x70(%rbx),%eax\ntest   %eax,%eax\nje     4200 <minimax+0x5d0>\nmov    0x54(%rbx),%r11d\ntest   %r11d,%r11d\nje     420a <minimax+0x5da>\nmov    0x38(%rbx),%r8d\ntest   %r8d,%r8d\nje     421e <minimax+0x5ee>\nmov    0x1c(%rbx),%edi\nxor    %edx,%edx\ntest   %edi,%edi\nsete   %dl\nlea    0x0(,%rdx,8),%rax\nsub    %rdx,%rax\nshl    $0x2,%rax\nlea    0x0(%r13,%r15,4),%rdx\nmov    %r9d,(%rdx,%rax,1)\nmov    %r10d,0x14(%rsp)\nsub    $0x8,%rsp\nxor    %r8d,%r8d\nmov    %ebp,%edx\npush   $0x0\nmov    0x38(%rsp),%esi\nmov    %r13,%rdi\nmov    %r9d,0x20(%rsp)\nmov    %ecx,0x1c(%rsp)\ncall   3c30 <minimax>\nmov    (%rbx),%esi\npop    %rdx\npop    %rcx\nmov    0xc(%rsp),%ecx\ntest   %esi,%esi\nmov    0x10(%rsp),%r9d\nmov    0x14(%rsp),%r10d\njne    41bd <minimax+0x58d>\nmov    0x1c(%rbx),%r11d\nlea    0x1c(%r13),%rdx\ntest   %r11d,%r11d\njne    41c0 <minimax+0x590>\nmov    0x38(%rbx),%r8d\nlea    0x38(%r13),%rdx\ntest   %r8d,%r8d\njne    41c0 <minimax+0x590>\nmov    0x54(%rbx),%edi\nlea    0x54(%r13),%rdx\ntest   %edi,%edi\njne    41c0 <minimax+0x590>\nmov    0x70(%rbx),%esi\nlea    0x70(%r13),%rdx\ntest   %esi,%esi\njne    41c0 <minimax+0x590>\nmov    0x8c(%rbx),%edx\ntest   %edx,%edx\njne    423e <minimax+0x60e>\ncmp    %r12d,%eax\njle    4170 <minimax+0x540>\nmov    %r10d,0x50(%rsp)\nmov    %eax,%r12d\nmovl   $0x1,0x8(%rsp)\ncmp    %r12d,%ebp\ncmovl  %r12d,%ebp\ncmp    %ecx,%ebp\njge    4128 <minimax+0x4f8>\nadd    $0x4,%r14\ncmp    0x18(%rsp),%r14\njne    4006 <minimax+0x3d6>\nmov    0x20(%rsp),%ebx\ncmp    $0x4,%ebx\nmov    (%rsp),%rbx\nsete   %dl\ntest   %rbx,%rbx\nsetne  %al\ntest   %al,%dl\nje     3d3f <minimax+0x10f>\nmov    0x8(%rsp),%r14d\ntest   %r14d,%r14d\njle    3d3f <minimax+0x10f>\ncall   6980 <libmin_rand>\nxor    %edx,%edx\ndiv    %r14d\nmov    0x50(%rsp,%rdx,4),%eax\nmov    %eax,(%rbx)\njmp    3d3f <minimax+0x10f>\nnopw   0x0(%rax,%rax,1)\njne    410e <minimax+0x4de>\nmovslq 0x8(%rsp),%rax\nmov    %r10d,0x50(%rsp,%rax,4)\nlea    0x1(%rax),%eax\nmov    %eax,0x8(%rsp)\njmp    410e <minimax+0x4de>\nnopl   (%rax)\njne    3f8e <minimax+0x35e>\nmovslq 0x8(%rsp),%rax\nmov    %r10d,0x50(%rsp,%rax,4)\nlea    0x1(%rax),%eax\nmov    %eax,0x8(%rsp)\njmp    3f8e <minimax+0x35e>\nmov    %r13,%rcx\nnopw   0x0(%rax,%rax,1)\nmovl   $0x0,(%rcx,%r15,4)\njmp    3f75 <minimax+0x345>\nmov    %r13,%rdx\nmovl   $0x0,(%rdx,%r15,4)\njmp    40f9 <minimax+0x4c9>\nmov    $0x80000000,%r12d\ntest   %eax,%eax\nje     3d3f <minimax+0x10f>\nmov    %eax,%esi\njmp    3fde <minimax+0x3ae>\nmov    $0x8c,%eax\njmp    4063 <minimax+0x433>\nmov    $0x8c,%eax\njmp    3ed9 <minimax+0x2a9>\nmov    $0x70,%eax\njmp    3ed9 <minimax+0x2a9>\nmov    $0x70,%eax\njmp    4063 <minimax+0x433>\nmov    $0x54,%eax\njmp    4063 <minimax+0x433>\nmov    $0x54,%eax\njmp    3ed9 <minimax+0x2a9>\nmov    $0x38,%eax\njmp    4063 <minimax+0x433>\nmov    $0x38,%eax\njmp    3ed9 <minimax+0x2a9>\nlea    0x8c(%r13),%rcx\njmp    41b0 <minimax+0x580>\nlea    0x8c(%r13),%rdx\njmp    41c0 <minimax+0x590>\ncall   10b0 <__stack_chk_fail@plt>\nmov    $0xfffe7960,%r12d\njmp    3d3f <minimax+0x10f>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "play_game", "content": "// -------------------------------------------------\n// Main Simulation Loop: Self-play game using minimax\n// -------------------------------------------------\nvoid play_game() {\n    int board[ROWS][COLS];\n    init_board(board);\n    \n    int current_player = 1; // Player 1 starts.\n    int move_number = 0;\n    \n    print_board(board);\n    \n    while (1) {\n        move_number++;\n        int best_move = -1;\n        // For both players, we use minimax to choose a move.\n        int score = minimax(board, MAX_DEPTH, INT_MIN, INT_MAX, 1, current_player, &best_move);\n        if (best_move == -1 || !valid_move(board, best_move)) {\n            // No valid move found => game over.\n            break;\n        }\n        make_move(board, best_move, current_player);\n        libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", move_number, current_player, best_move, score);\n        print_board(board);\n        \n        if (check_win(board, current_player)) {\n            libmin_printf(\"Player %d wins!\\n\", current_player);\n            break;\n        }\n        if (board_full(board)) {\n            libmin_printf(\"Game is a draw.\\n\");\n            break;\n        }\n        // Switch players.\n        current_player = (current_player == 1) ? 2 : 1;\n    }\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "play_game", "address": "0x4260", "label": "play_game", "content": "void __cdecl play_game()\n{\n  int *v0; // r12\n  int *v1; // rbx\n  __int64 v2; // rsi\n  int i; // ebx\n  int v4; // esi\n  int v5; // eax\n  int v6; // r9d\n  __int64 v7; // rcx\n  int *v8; // rbx\n  int *v9; // r12\n  __int64 v10; // rsi\n  int j; // r12d\n  int v12; // esi\n  int current_player; // [rsp+0h] [rbp-124h]\n  int move_number; // [rsp+Ch] [rbp-118h]\n  int best_move; // [rsp+38h] [rbp-ECh] BYREF\n  int board[6][7]; // [rsp+3Ch] [rbp-E8h] BYREF\n  unsigned __int64 v17; // [rsp+E4h] [rbp-40h]\n  _DWORD v18[5]; // [rsp+ECh] [rbp-38h] BYREF\n  _BYTE v19[36]; // [rsp+100h] [rbp-24h] BYREF\n\n  v17 = __readfsqword(0x28u);\n  v0 = board[1];\n  memset(board, 0, sizeof(board));\n  libmin_printf(\"\\n\");\n  do\n  {\n    v1 = v0 - 7;\n    do\n    {\n      v2 = 88LL;\n      if ( *v1 != 1 )\n      {\n        v2 = 46LL;\n        if ( *v1 == 2 )\n          v2 = 79LL;\n      }\n      ++v1;\n      libmin_printf(\"%c \", v2);\n    }\n    while ( v0 != v1 );\n    v0 += 7;\n    libmin_printf(\"\\n\");\n  }\n  while ( v19 != (_BYTE *)v0 );\n  for ( i = 0; i != 7; ++i )\n  {\n    v4 = i;\n    libmin_printf(\"%d \", v4);\n  }\n  libmin_printf(\"\\n\\n\");\n  move_number = 0;\n  for ( current_player = 1; ; current_player = 3 - current_player )\n  {\n    ++move_number;\n    best_move = -1;\n    v5 = minimax(board, 4, 0x80000000, 0x7FFFFFFF, 1, current_player, &best_move);\n    v6 = best_move;\n    if ( best_move == -1 || board[0][best_move] )\n      break;\n    if ( board[5][best_move] )\n    {\n      if ( board[4][best_move] )\n      {\n        if ( board[3][best_move] )\n        {\n          if ( board[2][best_move] )\n            v7 = 7LL * (board[1][best_move] == 0);\n          else\n            v7 = 14LL;\n        }\n        else\n        {\n          v7 = 21LL;\n        }\n      }\n      else\n      {\n        v7 = 28LL;\n      }\n    }\n    else\n    {\n      v7 = 35LL;\n    }\n    v18[best_move - 44 + v7] = current_player;\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", move_number, current_player, v6, v5);\n    libmin_printf(\"\\n\");\n    v8 = board[1];\n    do\n    {\n      v9 = v8 - 7;\n      do\n      {\n        v10 = 88LL;\n        if ( *v9 != 1 )\n        {\n          v10 = 46LL;\n          if ( *v9 == 2 )\n            v10 = 79LL;\n        }\n        ++v9;\n        libmin_printf(\"%c \", v10);\n      }\n      while ( v9 != v8 );\n      v8 += 7;\n      libmin_printf(\"\\n\");\n    }\n    while ( v19 != (_BYTE *)v8 );\n    for ( j = 0; j != 7; ++j )\n    {\n      v12 = j;\n      libmin_printf(\"%d \", v12);\n    }\n    libmin_printf(\"\\n\\n\");\n    if ( check_win(board, current_player) )\n    {\n      libmin_printf(\"Player %d wins!\\n\", current_player);\n      return;\n    }\n    if ( board[0][0] && board[0][1] && board[0][2] && board[0][3] && board[0][4] && board[0][5] && board[0][6] )\n    {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n  }\n}\n"}, "pseudo_normalize": "void play_game() {\n  int *v0;\n  int *v1;\n  long long v2;\n  int i;\n  int v4;\n  int v5;\n  int v6;\n  long long v7;\n  int *v8;\n  int *v9;\n  long long v10;\n  int j;\n  int v12;\n  int current_player;\n  int move_number;\n  int best_move;\n  int board[6][7];\n  unsigned long long v17;\n  uint32_t v18[5];\n  uint8_t v19[36];\n  v17 = __readfsqword(40u);\n  v0 = board[1];\n  memset(board, 0, sizeof(board));\n  libmin_printf(\"\\n\");\n  do {\n    v1 = v0 - 7;\n    do {\n      v2 = 88LL;\n      if (*v1 != 1) {\n        v2 = 46LL;\n        if (*v1 == 2) v2 = 79LL;\n      }\n      ++v1;\n      libmin_printf(\"%c \", v2);\n    } while (v0 != v1);\n    v0 += 7;\n    libmin_printf(\"\\n\");\n  } while (v19 != (uint8_t *)v0);\n  for (i = 0; i != 7; ++i) {\n    v4 = i;\n    libmin_printf(\"%d \", v4);\n  }\n  libmin_printf(\"\\n\\n\");\n  move_number = 0;\n  for (current_player = 1;; current_player = 3 - current_player) {\n    ++move_number;\n    best_move = -1;\n    v5 = minimax(board, 4, 2147483648, 2147483647, 1, current_player,\n                 &best_move);\n    v6 = best_move;\n    if (best_move == -1 || board[0][best_move]) break;\n    if (board[5][best_move]) {\n      if (board[4][best_move]) {\n        if (board[3][best_move]) {\n          if (board[2][best_move])\n            v7 = 7LL * (board[1][best_move] == 0);\n          else\n            v7 = 14LL;\n        } else {\n          v7 = 21LL;\n        }\n      } else {\n        v7 = 28LL;\n      }\n    } else {\n      v7 = 35LL;\n    }\n    v18[best_move - 44 + v7] = current_player;\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\",\n                  move_number, current_player, v6, v5);\n    libmin_printf(\"\\n\");\n    v8 = board[1];\n    do {\n      v9 = v8 - 7;\n      do {\n        v10 = 88LL;\n        if (*v9 != 1) {\n          v10 = 46LL;\n          if (*v9 == 2) v10 = 79LL;\n        }\n        ++v9;\n        libmin_printf(\"%c \", v10);\n      } while (v9 != v8);\n      v8 += 7;\n      libmin_printf(\"\\n\");\n    } while (v19 != (uint8_t *)v8);\n    for (j = 0; j != 7; ++j) {\n      v12 = j;\n      libmin_printf(\"%d \", v12);\n    }\n    libmin_printf(\"\\n\\n\");\n    if (check_win(board, current_player)) {\n      libmin_printf(\"Player %d wins!\\n\", current_player);\n      return;\n    }\n    if (board[0][0] && board[0][1] && board[0][2] && board[0][3] &&\n        board[0][4] && board[0][5] && board[0][6]) {\n      libmin_printf(\"Game is a draw.\\n\");\n      return;\n    }\n  }\n}", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<play_game>:\nendbr64\npush   %r15\npxor   %xmm0,%xmm0\npush   %r14\nlea    0x2d9a(%rip),%r14\npush   %r13\nmov    %r14,%rdi\npush   %r12\npush   %rbp\nlea    0x2d82(%rip),%rbp\npush   %rbx\nsub    $0xf8,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0xe8(%rsp)\nxor    %eax,%eax\nlea    0x5c(%rsp),%r12\nlea    0x104(%rsp),%r13\nmovq   $0x0,0xb0(%rsp)\nmovq   $0x0,0xb8(%rsp)\nmovq   $0x0,0xc0(%rsp)\nmovq   $0x0,0xc8(%rsp)\nmovq   $0x0,0xd0(%rsp)\nmovq   $0x0,0xd8(%rsp)\nmovq   $0x0,0xe0(%rsp)\nmovaps %xmm0,0x40(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x70(%rsp)\nmovaps %xmm0,0x80(%rsp)\nmovaps %xmm0,0x90(%rsp)\nmovaps %xmm0,0xa0(%rsp)\ncall   6710 <libmin_printf>\nmov    %r12,0x28(%rsp)\nmov    %r13,0x20(%rsp)\nnopl   0x0(%rax)\nlea    -0x1c(%r12),%rbx\nnopl   (%rax)\nmov    (%rbx),%eax\nmov    $0x58,%esi\ncmp    $0x1,%eax\nje     4364 <play_game+0x104>\ncmp    $0x2,%eax\nmov    $0x2e,%esi\nmov    $0x4f,%eax\ncmove  %eax,%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   6710 <libmin_printf>\ncmp    %rbx,%r12\njne    4348 <play_game+0xe8>\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x1c,%r12\ncall   6710 <libmin_printf>\ncmp    %r12,%r13\njne    4340 <play_game+0xe0>\nxor    %ebx,%ebx\nlea    0x2c75(%rip),%r13\nnopl   0x0(%rax,%rax,1)\nmov    %ebx,%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   6710 <libmin_printf>\ncmp    $0x7,%ebx\njne    4398 <play_game+0x138>\nlea    0x2c59(%rip),%rdi\nxor    %eax,%eax\ncall   6710 <libmin_printf>\nlea    0x40(%rsp),%rax\nmovl   $0x0,0x10(%rsp)\nmov    %rax,0x8(%rsp)\nlea    0x3c(%rsp),%rax\nmovl   $0x1,0x4(%rsp)\nmov    %rax,0x18(%rsp)\nxchg   %ax,%ax\naddl   $0x1,0x10(%rsp)\nsub    $0x8,%rsp\nmov    $0x1,%r8d\nmov    $0x80000000,%edx\nmovl   $0xffffffff,0x44(%rsp)\nmov    $0x7fffffff,%ecx\nmov    $0x4,%esi\npush   0x20(%rsp)\nmov    0x14(%rsp),%r9d\nmov    0x18(%rsp),%rdi\ncall   3c30 <minimax>\nmov    0x4c(%rsp),%r9d\nmov    %eax,%r8d\npop    %rax\npop    %rdx\ncmp    $0xffffffff,%r9d\nje     45bd <play_game+0x35d>\nmovslq %r9d,%rdx\nmov    0x40(%rsp,%rdx,4),%r12d\ntest   %r12d,%r12d\njne    45bd <play_game+0x35d>\nmov    0xcc(%rsp,%rdx,4),%eax\ntest   %eax,%eax\nje     45f4 <play_game+0x394>\nmov    0xb0(%rsp,%rdx,4),%r15d\ntest   %r15d,%r15d\nje     45fe <play_game+0x39e>\nmov    0x94(%rsp,%rdx,4),%ebx\ntest   %ebx,%ebx\nje     4608 <play_game+0x3a8>\nmov    0x78(%rsp,%rdx,4),%r11d\ntest   %r11d,%r11d\nje     4612 <play_game+0x3b2>\nmov    0x5c(%rsp,%rdx,4),%r10d\nxor    %eax,%eax\ntest   %r10d,%r10d\nsete   %al\nlea    0x0(,%rax,8),%rcx\nsub    %rax,%rcx\nshl    $0x2,%rcx\nlea    0xf0(%rsp,%rdx,4),%rax\nmov    0x4(%rsp),%edx\nmov    0x10(%rsp),%esi\nlea    0x2b8a(%rip),%rdi\nmov    %edx,-0xb0(%rcx,%rax,1)\nmov    %r9d,%ecx\nxor    %eax,%eax\ncall   6710 <libmin_printf>\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   6710 <libmin_printf>\nmov    %r12d,0x14(%rsp)\nmov    0x28(%rsp),%rbx\nmov    0x20(%rsp),%r15\nnopl   0x0(%rax,%rax,1)\nlea    -0x1c(%rbx),%r12\nnopl   0x0(%rax)\nmov    (%r12),%eax\nmov    $0x58,%esi\ncmp    $0x1,%eax\nje     4506 <play_game+0x2a6>\ncmp    $0x2,%eax\nmov    $0x2e,%esi\nmov    $0x4f,%eax\ncmove  %eax,%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x4,%r12\ncall   6710 <libmin_printf>\ncmp    %rbx,%r12\njne    44e8 <play_game+0x288>\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x1c,%rbx\ncall   6710 <libmin_printf>\ncmp    %rbx,%r15\njne    44e0 <play_game+0x280>\nmov    0x14(%rsp),%r12d\nnopl   0x0(%rax)\nmov    %r12d,%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%r12d\ncall   6710 <libmin_printf>\ncmp    $0x7,%r12d\njne    4538 <play_game+0x2d8>\nlea    0x2ab6(%rip),%rdi\nxor    %eax,%eax\ncall   6710 <libmin_printf>\nmov    0x4(%rsp),%esi\nmov    0x8(%rsp),%rdi\ncall   1540 <check_win>\ntest   %eax,%eax\njne    461c <play_game+0x3bc>\nmov    0x40(%rsp),%r9d\ntest   %r9d,%r9d\nje     45e2 <play_game+0x382>\nmov    0x44(%rsp),%r8d\ntest   %r8d,%r8d\nje     45e2 <play_game+0x382>\nmov    0x48(%rsp),%edi\ntest   %edi,%edi\nje     45e2 <play_game+0x382>\nmov    0x4c(%rsp),%esi\ntest   %esi,%esi\nje     45e2 <play_game+0x382>\nmov    0x50(%rsp),%ecx\ntest   %ecx,%ecx\nje     45e2 <play_game+0x382>\nmov    0x54(%rsp),%edx\ntest   %edx,%edx\nje     45e2 <play_game+0x382>\nmov    0x58(%rsp),%eax\ntest   %eax,%eax\nje     45e2 <play_game+0x382>\nlea    0x2a6a(%rip),%rdi\nxor    %eax,%eax\ncall   6710 <libmin_printf>\nmov    0xe8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    4630 <play_game+0x3d0>\nadd    $0xf8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x3,%eax\nsub    0x4(%rsp),%eax\nmov    %eax,0x4(%rsp)\njmp    43e0 <play_game+0x180>\nmov    $0x8c,%ecx\njmp    4497 <play_game+0x237>\nmov    $0x70,%ecx\njmp    4497 <play_game+0x237>\nmov    $0x54,%ecx\njmp    4497 <play_game+0x237>\nmov    $0x38,%ecx\njmp    4497 <play_game+0x237>\nmov    0x4(%rsp),%esi\nlea    0x29e8(%rip),%rdi\nxor    %eax,%eax\ncall   6710 <libmin_printf>\njmp    45bd <play_game+0x35d>\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "print_board", "content": "void print_board(int board[ROWS][COLS]) {\n    libmin_printf(\"\\n\");\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS; c++) {\n            char ch = board[r][c] == 1 ? 'X' : (board[r][c] == 2 ? 'O' : '.');\n            libmin_printf(\"%c \", ch);\n        }\n        libmin_printf(\"\\n\");\n    }\n    for (int c = 0; c < COLS; c++) {\n        libmin_printf(\"%d \", c);\n    }\n    libmin_printf(\"\\n\\n\");\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "print_board", "address": "0x12a0", "label": "print_board", "content": "void __fastcall print_board(int (*board)[7])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n  __int64 v3; // rsi\n  int i; // ebx\n  int v5; // esi\n\n  v1 = &(*board)[7];\n  libmin_printf(\"\\n\");\n  do\n  {\n    v2 = v1 - 7;\n    do\n    {\n      v3 = 88LL;\n      if ( *v2 != 1 )\n      {\n        v3 = 46LL;\n        if ( *v2 == 2 )\n          v3 = 79LL;\n      }\n      ++v2;\n      libmin_printf(\"%c \", v3);\n    }\n    while ( v2 != v1 );\n    v1 = v2 + 7;\n    libmin_printf(\"\\n\");\n  }\n  while ( v2 + 7 != &(*board)[49] );\n  for ( i = 0; i != 7; ++i )\n  {\n    v5 = i;\n    libmin_printf(\"%d \", v5);\n  }\n  libmin_printf(\"\\n\\n\");\n}\n"}, "pseudo_normalize": "void print_board(int (*board)[7]) {\n  int *v1;\n  int *v2;\n  long long v3;\n  int i;\n  int v5;\n  v1 = &(*board)[7];\n  libmin_printf(\"\\n\");\n  do {\n    v2 = v1 - 7;\n    do {\n      v3 = 88LL;\n      if (*v2 != 1) {\n        v3 = 46LL;\n        if (*v2 == 2) v3 = 79LL;\n      }\n      ++v2;\n      libmin_printf(\"%c \", v3);\n    } while (v2 != v1);\n    v1 = v2 + 7;\n    libmin_printf(\"\\n\");\n  } while (v2 + 7 != &(*board)[49]);\n  for (i = 0; i != 7; ++i) {\n    v5 = i;\n    libmin_printf(\"%d \", v5);\n  }\n  libmin_printf(\"\\n\\n\");\n}", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<print_board>:\nendbr64\npush   %r14\nlea    0x5d60(%rip),%r14\nxor    %eax,%eax\npush   %r13\nmov    %rdi,%r13\nmov    %r14,%rdi\npush   %r12\nlea    0x5d44(%rip),%r12\npush   %rbp\nlea    0x1c(%r13),%rbp\nadd    $0xc4,%r13\npush   %rbx\ncall   6710 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\nlea    -0x1c(%rbp),%rbx\nnopl   0x0(%rax)\nmov    (%rbx),%eax\nmov    $0x58,%esi\ncmp    $0x1,%eax\nje     12fc <print_board+0x5c>\ncmp    $0x2,%eax\nmov    $0x2e,%esi\nmov    $0x4f,%eax\ncmove  %eax,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   6710 <libmin_printf>\ncmp    %rbp,%rbx\njne    12e0 <print_board+0x40>\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    0x1c(%rbx),%rbp\ncall   6710 <libmin_printf>\ncmp    %r13,%rbp\njne    12d8 <print_board+0x38>\nxor    %ebx,%ebx\nlea    0x5cdd(%rip),%rbp\nnopl   0x0(%rax,%rax,1)\nmov    %ebx,%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   6710 <libmin_printf>\ncmp    $0x7,%ebx\njne    1330 <print_board+0x90>\npop    %rbx\nlea    0x5cc0(%rip),%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %r14\njmp    6710 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "score_position", "content": "// Score the board from the perspective of \"player\".\nint score_position(int board[ROWS][COLS], int player) {\n    int score = 0;\n    int window[4];\n    int center_count = 0;\n    // Score center column: pieces in the center are more valuable.\n    for (int r = 0; r < ROWS; r++) {\n        if (board[r][COLS/2] == player)\n            center_count++;\n    }\n    score += center_count * 3;\n\n    // Horizontal\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Vertical\n    for (int c = 0; c < COLS; c++) {\n        for (int r = 0; r < ROWS - 3; r++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r+i][c];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Positive diagonal\n    for (int r = 3; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r-i][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Negative diagonal\n    for (int r = 0; r < ROWS - 3; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r+i][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    return score;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "score_position", "address": "0x24a0", "label": "score_position", "content": "int __fastcall score_position(int (*board)[7], int player)\n{\n  int v2; // r14d\n  int v3; // r15d\n  int *v5; // r11\n  int *v6; // r12\n  int *v7; // rcx\n  int v8; // r8d\n  int v9; // edx\n  bool v10; // r13\n  int v11; // r9d\n  int v12; // edi\n  int v13; // esi\n  bool v14; // r10\n  bool v15; // bl\n  int v16; // esi\n  int v17; // ebp\n  int v18; // edi\n  int v19; // r13d\n  int v20; // r9d\n  int v21; // esi\n  int v22; // ebp\n  int v23; // r10d\n  _BOOL4 v24; // ebx\n  int v25; // edi\n  int v26; // ebx\n  int v27; // ebp\n  int v28; // ebx\n  int v29; // r10d\n  int v30; // ebp\n  bool v31; // zf\n  int v32; // r13d\n  int v33; // ebx\n  int v34; // r8d\n  int v35; // edi\n  int v36; // r13d\n  bool v37; // r15\n  int v38; // edi\n  int v39; // edi\n  int v40; // ebp\n  int v41; // r13d\n  int v42; // ebx\n  _BOOL4 v43; // r8d\n  int v44; // r9d\n  int v45; // r8d\n  int v46; // r13d\n  bool v47; // r15\n  int v48; // r8d\n  int v49; // ebx\n  int v50; // r8d\n  __int64 i; // rcx\n  int v52; // r13d\n  int v53; // r15d\n  int v54; // r12d\n  int v55; // ebp\n  int v56; // esi\n  int v57; // r13d\n  bool v58; // r15\n  int v59; // esi\n  int v60; // r15d\n  int v61; // esi\n  int v62; // ebp\n  int v63; // r13d\n  int v64; // r12d\n  int v65; // r8d\n  int v66; // edi\n  int v67; // r13d\n  int v68; // edi\n  int v69; // r12d\n  int v70; // r8d\n  int v71; // r15d\n  int v72; // edi\n  int v73; // esi\n  int v74; // r9d\n  int v75; // r9d\n  bool v76; // bp\n  int v77; // r10d\n  int v78; // r12d\n  int v79; // esi\n  int v80; // r9d\n  int v81; // edi\n  int v82; // r10d\n  int *v83; // rcx\n  int v84; // edi\n  int v85; // r12d\n  int v86; // ebx\n  int v87; // esi\n  int v88; // r15d\n  int v89; // r9d\n  _BOOL4 v90; // ebp\n  int v91; // edi\n  int v92; // ebp\n  int v93; // ebp\n  bool v94; // bl\n  int v95; // esi\n  int v96; // r12d\n  int v97; // esi\n  int v98; // r8d\n  int v99; // r12d\n  int v100; // ebx\n  int v101; // edi\n  int v102; // r15d\n  int v103; // r9d\n  _BOOL4 v104; // ebp\n  int v105; // r8d\n  int v106; // ebp\n  int v107; // ebp\n  bool v108; // bl\n  int v109; // edi\n  int v110; // r12d\n  int v111; // r8d\n  int v112; // edi\n  int v113; // r12d\n  int v114; // ebx\n  int v115; // esi\n  int v116; // r15d\n  int v117; // r9d\n  _BOOL4 v118; // ebp\n  int v119; // r8d\n  int v120; // ebp\n  int v121; // ebp\n  bool v122; // bl\n  int v123; // esi\n  int v124; // r12d\n  int v125; // esi\n  int v126; // edi\n  int v127; // r12d\n  int v128; // ebx\n  int v129; // r9d\n  int v130; // r15d\n  int v131; // r8d\n  _BOOL4 v132; // ebp\n  int v133; // edi\n  int v134; // ebp\n  int v135; // ebp\n  bool v136; // bl\n  int v137; // r9d\n  int v138; // esi\n  int v139; // ebp\n  int v140; // r10d\n  int v141; // ecx\n  int v142; // r14d\n  int v143; // edi\n  _BOOL4 v144; // ebx\n  int v145; // esi\n  int v146; // ebx\n  int v147; // ebx\n  bool v148; // r10\n  int v149; // ecx\n  int v150; // ebp\n  int v151; // edi\n  int v152; // ebp\n  int v153; // ecx\n  int v154; // r10d\n  int v155; // esi\n  int v156; // r14d\n  int v157; // r8d\n  _BOOL4 v158; // ebx\n  int v159; // edi\n  int v160; // ebx\n  int v161; // ebx\n  bool v162; // r10\n  int v163; // esi\n  int v164; // ebp\n  int v165; // edi\n  int v166; // esi\n  int v167; // ebp\n  int v168; // r10d\n  int v169; // ecx\n  int v170; // r14d\n  int v171; // r8d\n  _BOOL4 v172; // ebx\n  int v173; // edi\n  int v174; // ebx\n  int v175; // ebx\n  bool v176; // r10\n  int v177; // ecx\n  int v178; // ebp\n  int v179; // ecx\n  int v180; // esi\n  int v181; // ebp\n  int v182; // r10d\n  int v183; // r8d\n  int v184; // r14d\n  int v185; // edi\n  _BOOL4 v186; // ebx\n  int v187; // esi\n  int v188; // ebx\n  int v189; // ebx\n  bool v190; // r10\n  int v191; // r8d\n  int v192; // ebp\n  int v194; // r15d\n  int *v196; // [rsp+8h] [rbp-58h]\n  int *v197; // [rsp+10h] [rbp-50h]\n  int *v198; // [rsp+18h] [rbp-48h]\n  int *v199; // [rsp+20h] [rbp-40h]\n  int *v200; // [rsp+28h] [rbp-38h]\n\n  v5 = (int *)board;\n  v6 = &(*board)[42];\n  v199 = &(*board)[7];\n  v198 = &(*board)[14];\n  v196 = &(*board)[21];\n  v197 = &(*board)[28];\n  v200 = &(*board)[35];\n  v7 = (int *)board;\n  v8 = 3\n     * ((player == (*board)[38])\n      + (player == (*board)[31])\n      + (player == (*board)[24])\n      + (player == (*board)[17])\n      + (player == (*board)[10])\n      + ((*board)[3] == player));\n  v9 = (player == 1) + 1;\n  do\n  {\n    while ( 1 )\n    {\n      v18 = *v7;\n      v19 = v7[1];\n      v20 = v7[2];\n      v21 = v7[3];\n      if ( player == *v7 )\n      {\n        v3 = 1;\n        v2 = 0;\n        v22 = 2;\n        v25 = 0;\n        v26 = 1;\n        v23 = 1;\n      }\n      else\n      {\n        v22 = 1;\n        LOBYTE(v3) = v9 != v18;\n        LOBYTE(v2) = v9 == v18;\n        v23 = 0;\n        v24 = v9 != v18;\n        v25 = v24;\n        v26 = v24 + 1;\n      }\n      if ( player == v19 )\n      {\n        v23 = v22;\n        v27 = 0;\n      }\n      else if ( v9 == v19 )\n      {\n        v27 = v2;\n        v2 = v3;\n      }\n      else\n      {\n        v25 = v26;\n        v27 = 0;\n      }\n      if ( player != v20 )\n      {\n        if ( v9 != v20 )\n        {\n          v2 = v27;\n          ++v25;\n          v27 = 0;\n        }\n        if ( player != v21 )\n        {\n          if ( v9 == v21 )\n          {\n            LOBYTE(v3) = v25 == 1;\n            goto LABEL_291;\n          }\n          goto LABEL_26;\n        }\n        ++v23;\n        goto LABEL_27;\n      }\n      if ( player != v21 )\n      {\n        ++v23;\n        if ( v9 != v21 )\n        {\n          v27 = 0;\nLABEL_26:\n          ++v25;\n        }\nLABEL_27:\n        LOBYTE(v3) = v25 == 1;\n        if ( v23 == 3 )\n        {\n          v28 = 1;\n          v2 = 5;\n          if ( v25 == 1 )\n          {\nLABEL_29:\n            if ( !(_BYTE)v27 )\n              v28 = v2;\n            goto LABEL_31;\n          }\n        }\n        v2 = v27;\nLABEL_291:\n        if ( v23 == 2 )\n        {\n          v28 = 2;\n          if ( v25 == 2 )\n            goto LABEL_31;\n        }\n        v3 &= v2;\n        v28 = -4;\n        v2 = 0;\n        LOBYTE(v27) = v3;\n        goto LABEL_29;\n      }\n      v23 += 2;\n      if ( v23 == 4 )\n      {\n        v28 = 100;\n        goto LABEL_31;\n      }\n      v28 = 5;\n      LOBYTE(v3) = v25 == 1;\n      LOBYTE(v2) = v25 == 1 && v23 == 3;\n      if ( !(_BYTE)v2 )\n        goto LABEL_291;\nLABEL_31:\n      v29 = v7[4];\n      v30 = v8 + v28;\n      if ( player == v19 )\n      {\n        v2 = 0;\n        v35 = 1;\n        v34 = 0;\n        v33 = 1;\n        v3 = 1;\n        v32 = 2;\n      }\n      else\n      {\n        v31 = v9 == v19;\n        v32 = 1;\n        LOBYTE(v3) = !v31;\n        LOBYTE(v2) = v31;\n        v33 = 0;\n        v34 = !v31;\n        v35 = v34 + 1;\n      }\n      if ( player == v20 )\n      {\n        v33 = v32;\n        v36 = 0;\n      }\n      else if ( v9 == v20 )\n      {\n        v36 = v2;\n        v2 = v3;\n      }\n      else\n      {\n        v34 = v35;\n        v36 = 0;\n      }\n      if ( player != v21 )\n      {\n        if ( v9 != v21 )\n        {\n          v2 = v36;\n          ++v34;\n          v36 = 0;\n        }\n        if ( player != v29 )\n        {\n          if ( v9 == v29 )\n          {\n            v37 = v34 == 1;\n            goto LABEL_298;\n          }\n          goto LABEL_41;\n        }\n        ++v33;\n        goto LABEL_42;\n      }\n      if ( v29 != player )\n      {\n        ++v33;\n        if ( v9 != v29 )\n        {\n          v36 = 0;\nLABEL_41:\n          ++v34;\n        }\nLABEL_42:\n        v37 = v34 == 1;\n        if ( v33 == 3 )\n        {\n          v38 = 1;\n          v2 = 5;\n          if ( v34 == 1 )\n          {\nLABEL_44:\n            if ( !(_BYTE)v36 )\n              v38 = v2;\n            goto LABEL_46;\n          }\n        }\n        v2 = v36;\nLABEL_298:\n        if ( v34 == 2 )\n        {\n          v38 = 2;\n          if ( v33 == 2 )\n            goto LABEL_46;\n        }\n        v38 = -4;\n        LOBYTE(v36) = v37 & v2;\n        v2 = 0;\n        goto LABEL_44;\n      }\n      v33 += 2;\n      if ( v33 == 4 )\n      {\n        v38 = 100;\n        goto LABEL_46;\n      }\n      v38 = 5;\n      v37 = v34 == 1;\n      LOBYTE(v2) = v34 == 1 && v33 == 3;\n      if ( !(_BYTE)v2 )\n        goto LABEL_298;\nLABEL_46:\n      v39 = v30 + v38;\n      v40 = v7[5];\n      if ( player == v20 )\n      {\n        v3 = 1;\n        v2 = 0;\n        v41 = 2;\n        v45 = 1;\n        v44 = 0;\n        v42 = 1;\n      }\n      else\n      {\n        v41 = 1;\n        LOBYTE(v3) = v9 != v20;\n        LOBYTE(v2) = v9 == v20;\n        v42 = 0;\n        v43 = v9 != v20;\n        v44 = v43;\n        v45 = v43 + 1;\n      }\n      if ( player == v21 )\n      {\n        v42 = v41;\n        v46 = 0;\n      }\n      else if ( v9 == v21 )\n      {\n        v46 = v2;\n        v2 = v3;\n      }\n      else\n      {\n        v44 = v45;\n        v46 = 0;\n      }\n      if ( player != v29 )\n      {\n        if ( v9 != v29 )\n        {\n          v2 = v46;\n          ++v44;\n          v46 = 0;\n        }\n        if ( player != v40 )\n        {\n          if ( v9 == v40 )\n          {\n            v47 = v44 == 1;\n            goto LABEL_287;\n          }\n          goto LABEL_56;\n        }\n        ++v42;\n        goto LABEL_57;\n      }\n      if ( v40 != player )\n      {\n        ++v42;\n        if ( v9 != v40 )\n        {\n          v46 = 0;\nLABEL_56:\n          ++v44;\n        }\nLABEL_57:\n        v47 = v44 == 1;\n        if ( v42 == 3 )\n        {\n          v48 = 1;\n          v2 = 5;\n          if ( v44 == 1 )\n          {\nLABEL_59:\n            if ( !(_BYTE)v46 )\n              v48 = v2;\n            goto LABEL_61;\n          }\n        }\n        v2 = v46;\nLABEL_287:\n        if ( v44 == 2 )\n        {\n          v48 = 2;\n          if ( v42 == 2 )\n            goto LABEL_61;\n        }\n        v48 = -4;\n        LOBYTE(v46) = v47 & v2;\n        v2 = 0;\n        goto LABEL_59;\n      }\n      v42 += 2;\n      if ( v42 == 4 )\n      {\n        v48 = 100;\n        goto LABEL_61;\n      }\n      v48 = 5;\n      v47 = v44 == 1;\n      LOBYTE(v2) = v44 == 1 && v42 == 3;\n      if ( !(_BYTE)v2 )\n        goto LABEL_287;\nLABEL_61:\n      v49 = v7[6];\n      v50 = v39 + v48;\n      if ( player != v21 )\n        break;\n      v2 = 1;\n      v10 = 0;\n      v13 = 1;\n      v12 = 0;\n      v3 = 2;\n      v11 = 1;\n      if ( player != v29 )\n        goto LABEL_3;\nLABEL_63:\n      v11 = v3;\n      v14 = 0;\n      if ( player == v40 )\n        goto LABEL_64;\nLABEL_6:\n      if ( v9 != v40 )\n      {\n        v10 = v14;\n        ++v12;\n        v14 = 0;\n      }\n      if ( player != v49 )\n      {\n        if ( v9 == v49 )\n        {\n          v15 = v12 == 1;\n          goto LABEL_251;\n        }\n        goto LABEL_10;\n      }\n      ++v11;\nLABEL_11:\n      v15 = v12 == 1;\n      if ( v11 == 3 )\n      {\n        v16 = 1;\n        v17 = 5;\n        if ( v12 == 1 )\n          goto LABEL_13;\n      }\n      v10 = v14;\nLABEL_251:\n      if ( v11 != 2 || (v16 = 2, v12 != 2) )\n      {\n        v16 = -4;\n        v17 = 0;\n        v14 = v10 && v15;\nLABEL_13:\n        if ( !v14 )\n          v16 = v17;\n      }\nLABEL_15:\n      v7 += 7;\n      v8 = v16 + v50;\n      if ( v6 == v7 )\n        goto LABEL_67;\n    }\n    v3 = 1;\n    LOBYTE(v2) = v9 != v21;\n    v10 = v9 == v21;\n    v11 = 0;\n    v12 = v9 != v21;\n    v13 = v12 + 1;\n    if ( player == v29 )\n      goto LABEL_63;\nLABEL_3:\n    if ( v9 == v29 )\n    {\n      v14 = v10;\n      v10 = v2;\n    }\n    else\n    {\n      v12 = v13;\n      v14 = 0;\n    }\n    if ( player != v40 )\n      goto LABEL_6;\nLABEL_64:\n    if ( player != v49 )\n    {\n      ++v11;\n      if ( v9 != v49 )\n      {\n        v14 = 0;\nLABEL_10:\n        ++v12;\n        goto LABEL_11;\n      }\n      goto LABEL_11;\n    }\n    v11 += 2;\n    if ( v11 != 4 )\n    {\n      v16 = 5;\n      v15 = v12 == 1;\n      v10 = v12 == 1 && v11 == 3;\n      if ( v10 )\n        goto LABEL_15;\n      goto LABEL_251;\n    }\n    v7 += 7;\n    v8 = v50 + 100;\n  }\n  while ( v6 != v7 );\nLABEL_67:\n  for ( i = 0LL; i != 7; ++i )\n  {\n    while ( 1 )\n    {\n      v79 = (*board)[i];\n      v80 = v198[i];\n      v53 = (int)v196;\n      v81 = v199[i];\n      v82 = v196[i];\n      if ( player != v79 )\n        break;\n      v53 = 1;\n      v2 = 0;\n      v56 = 1;\n      v55 = 0;\n      v52 = 2;\n      v54 = 1;\n      if ( player != v81 )\n        goto LABEL_69;\nLABEL_112:\n      v54 = v52;\n      v57 = 0;\n      if ( player == v80 )\n        goto LABEL_113;\nLABEL_72:\n      if ( v9 != v80 )\n      {\n        v2 = v57;\n        ++v55;\n        v57 = 0;\n      }\n      if ( player != v82 )\n      {\n        if ( v9 == v82 )\n        {\n          v58 = v55 == 1;\n          goto LABEL_272;\n        }\n        goto LABEL_76;\n      }\n      ++v54;\nLABEL_77:\n      v58 = v55 == 1;\n      if ( v54 == 3 )\n      {\n        v59 = 1;\n        v2 = 5;\n        if ( v55 == 1 )\n          goto LABEL_79;\n      }\n      v2 = v57;\nLABEL_272:\n      if ( v54 == 2 )\n      {\n        v59 = 2;\n        if ( v55 == 2 )\n          goto LABEL_81;\n      }\n      v59 = -4;\n      LOBYTE(v57) = v58 & v2;\n      v2 = 0;\nLABEL_79:\n      if ( !(_BYTE)v57 )\n        v59 = v2;\nLABEL_81:\n      v60 = (int)v197;\n      v61 = v8 + v59;\n      v62 = v197[i];\n      if ( player == v81 )\n        goto LABEL_116;\nLABEL_82:\n      v63 = 1;\n      LOBYTE(v60) = v9 != v81;\n      LOBYTE(v2) = v9 == v81;\n      v64 = 0;\n      v65 = v9 != v81;\n      v66 = v65 + 1;\n      if ( player == v80 )\n        goto LABEL_117;\nLABEL_83:\n      if ( v9 == v80 )\n      {\n        v67 = v2;\n        v2 = v60;\n      }\n      else\n      {\n        v65 = v66;\n        v67 = 0;\n      }\n      if ( player != v82 )\n        goto LABEL_86;\nLABEL_118:\n      if ( v62 != player )\n      {\n        ++v64;\n        if ( v9 != v62 )\n        {\n          v67 = 0;\nLABEL_90:\n          ++v65;\n          goto LABEL_91;\n        }\n        goto LABEL_91;\n      }\n      v64 += 2;\n      if ( v64 != 4 )\n      {\n        v68 = 5;\n        LOBYTE(v60) = v65 == 1;\n        LOBYTE(v2) = v65 == 1 && v64 == 3;\n        if ( (_BYTE)v2 )\n          goto LABEL_95;\n        goto LABEL_283;\n      }\n      v69 = v200[i];\n      v70 = v61 + 100;\n      if ( player != v80 )\n        goto LABEL_96;\nLABEL_121:\n      v2 = 1;\n      v67 = 0;\n      v73 = 0;\n      v72 = 1;\n      v71 = 2;\n      v74 = 1;\n      if ( player != v82 )\n        goto LABEL_97;\nLABEL_122:\n      v72 = v71;\n      v75 = 0;\n      if ( player == v62 )\n        goto LABEL_123;\nLABEL_100:\n      if ( v9 != v62 )\n      {\n        v67 = v75;\n        ++v73;\n        v75 = 0;\n      }\n      if ( player != v69 )\n      {\n        if ( v9 == v69 )\n        {\n          v76 = v73 == 1;\n          goto LABEL_277;\n        }\n        goto LABEL_104;\n      }\n      ++v72;\nLABEL_105:\n      v76 = v73 == 1;\n      if ( v72 == 3 )\n      {\n        v77 = 1;\n        v78 = 5;\n        if ( v73 == 1 )\n          goto LABEL_107;\n      }\n      v67 = v75;\nLABEL_277:\n      if ( v72 != 2 || (v77 = 2, v73 != 2) )\n      {\n        v77 = -4;\n        v78 = 0;\n        LOBYTE(v75) = v76 & v67;\nLABEL_107:\n        if ( !(_BYTE)v75 )\n          v77 = v78;\n      }\nLABEL_109:\n      ++i;\n      v8 = v77 + v70;\n      if ( i == 7 )\n        goto LABEL_126;\n    }\n    v52 = 1;\n    LOBYTE(v53) = v9 != v79;\n    LOBYTE(v2) = v9 == v79;\n    v54 = 0;\n    v55 = v9 != v79;\n    v56 = v55 + 1;\n    if ( player == v81 )\n      goto LABEL_112;\nLABEL_69:\n    if ( v9 == v81 )\n    {\n      v57 = v2;\n      v2 = v53;\n    }\n    else\n    {\n      v55 = v56;\n      v57 = 0;\n    }\n    if ( player != v80 )\n      goto LABEL_72;\nLABEL_113:\n    if ( player != v82 )\n    {\n      ++v54;\n      if ( v9 != v82 )\n      {\n        v57 = 0;\nLABEL_76:\n        ++v55;\n        goto LABEL_77;\n      }\n      goto LABEL_77;\n    }\n    v54 += 2;\n    if ( v54 != 4 )\n    {\n      v59 = 5;\n      v58 = v55 == 1;\n      LOBYTE(v2) = v55 == 1 && v54 == 3;\n      if ( (_BYTE)v2 )\n        goto LABEL_81;\n      goto LABEL_272;\n    }\n    v60 = (int)v197;\n    v61 = v8 + 100;\n    v62 = v197[i];\n    if ( player != v81 )\n      goto LABEL_82;\nLABEL_116:\n    v60 = 1;\n    v2 = 0;\n    v66 = 1;\n    v65 = 0;\n    v63 = 2;\n    v64 = 1;\n    if ( player != v80 )\n      goto LABEL_83;\nLABEL_117:\n    v64 = v63;\n    v67 = 0;\n    if ( player == v82 )\n      goto LABEL_118;\nLABEL_86:\n    if ( v9 != v82 )\n    {\n      v2 = v67;\n      ++v65;\n      v67 = 0;\n    }\n    if ( player != v62 )\n    {\n      if ( v9 == v62 )\n      {\n        LOBYTE(v60) = v65 == 1;\n        goto LABEL_283;\n      }\n      goto LABEL_90;\n    }\n    ++v64;\nLABEL_91:\n    LOBYTE(v60) = v65 == 1;\n    if ( v64 == 3 )\n    {\n      v68 = 1;\n      v2 = 5;\n      if ( v65 == 1 )\n        goto LABEL_93;\n    }\n    v2 = v67;\nLABEL_283:\n    if ( v65 == 2 )\n    {\n      v68 = 2;\n      if ( v64 == 2 )\n        goto LABEL_95;\n    }\n    v194 = v2 & v60;\n    v68 = -4;\n    v2 = 0;\n    v67 = v194;\nLABEL_93:\n    if ( !(_BYTE)v67 )\n      v68 = v2;\nLABEL_95:\n    v69 = v200[i];\n    v70 = v68 + v61;\n    if ( player == v80 )\n      goto LABEL_121;\nLABEL_96:\n    v71 = 1;\n    LOBYTE(v2) = v9 != v80;\n    LOBYTE(v67) = v9 == v80;\n    v72 = 0;\n    v73 = v9 != v80;\n    v74 = v73 + 1;\n    if ( player == v82 )\n      goto LABEL_122;\nLABEL_97:\n    if ( v9 == v82 )\n    {\n      v75 = v67;\n      v67 = v2;\n    }\n    else\n    {\n      v73 = v74;\n      v75 = 0;\n    }\n    if ( player != v62 )\n      goto LABEL_100;\nLABEL_123:\n    if ( player != v69 )\n    {\n      ++v72;\n      if ( v9 != v69 )\n      {\n        v75 = 0;\nLABEL_104:\n        ++v73;\n        goto LABEL_105;\n      }\n      goto LABEL_105;\n    }\n    v72 += 2;\n    if ( v72 != 4 )\n    {\n      v77 = 5;\n      v76 = v73 == 1;\n      LOBYTE(v67) = v73 == 1 && v72 == 3;\n      if ( (_BYTE)v67 )\n        goto LABEL_109;\n      goto LABEL_277;\n    }\n    v8 = v70 + 100;\n  }\nLABEL_126:\n  v83 = &(*board)[3];\n  do\n  {\n    v84 = v83[18];\n    v85 = v83[12];\n    v86 = v83[6];\n    v87 = *v83;\n    if ( player == v84 )\n    {\n      v2 = 1;\n      v67 = 0;\n      v92 = 1;\n      v91 = 0;\n      v88 = 2;\n      v89 = 1;\n    }\n    else\n    {\n      v88 = 1;\n      LOBYTE(v2) = v9 != v84;\n      LOBYTE(v67) = v9 == v84;\n      v89 = 0;\n      v90 = v9 != v84;\n      v91 = v90;\n      v92 = v90 + 1;\n    }\n    if ( player == v85 )\n    {\n      v89 = v88;\n      v93 = 0;\n    }\n    else if ( v9 == v85 )\n    {\n      v93 = v67;\n      v67 = v2;\n    }\n    else\n    {\n      v91 = v92;\n      v93 = 0;\n    }\n    if ( player != v86 )\n    {\n      if ( v9 != v86 )\n      {\n        v67 = v93;\n        ++v91;\n        v93 = 0;\n      }\n      if ( player != v87 )\n      {\n        if ( v9 == v87 )\n        {\n          v94 = v91 == 1;\n          goto LABEL_365;\n        }\n        goto LABEL_137;\n      }\n      ++v89;\n      goto LABEL_138;\n    }\n    if ( v87 != player )\n    {\n      ++v89;\n      if ( v9 != v87 )\n      {\n        v93 = 0;\nLABEL_137:\n        ++v91;\n      }\nLABEL_138:\n      v94 = v91 == 1;\n      if ( v89 == 3 )\n      {\n        v95 = 1;\n        v96 = 5;\n        if ( v91 == 1 )\n        {\nLABEL_140:\n          if ( !(_BYTE)v93 )\n            v95 = v96;\n          goto LABEL_142;\n        }\n      }\n      v67 = v93;\nLABEL_365:\n      if ( v91 == 2 )\n      {\n        v95 = 2;\n        if ( v89 == 2 )\n          goto LABEL_142;\n      }\n      v95 = -4;\n      v96 = 0;\n      LOBYTE(v93) = v67 & v94;\n      goto LABEL_140;\n    }\n    v89 += 2;\n    if ( v89 == 4 )\n    {\n      v95 = 100;\n      goto LABEL_142;\n    }\n    v95 = 5;\n    v94 = v91 == 1;\n    LOBYTE(v67) = v91 == 1 && v89 == 3;\n    if ( !(_BYTE)v67 )\n      goto LABEL_365;\nLABEL_142:\n    v97 = v8 + v95;\n    v98 = v83[19];\n    v99 = v83[13];\n    v100 = v83[7];\n    v101 = v83[1];\n    if ( player == v98 )\n    {\n      v2 = 1;\n      v67 = 0;\n      v106 = 1;\n      v105 = 0;\n      v102 = 2;\n      v103 = 1;\n    }\n    else\n    {\n      v102 = 1;\n      LOBYTE(v2) = v9 != v98;\n      LOBYTE(v67) = v9 == v98;\n      v103 = 0;\n      v104 = v9 != v98;\n      v105 = v104;\n      v106 = v104 + 1;\n    }\n    if ( player == v99 )\n    {\n      v103 = v102;\n      v107 = 0;\n    }\n    else if ( v9 == v99 )\n    {\n      v107 = v67;\n      v67 = v2;\n    }\n    else\n    {\n      v105 = v106;\n      v107 = 0;\n    }\n    if ( player != v100 )\n    {\n      if ( v9 != v100 )\n      {\n        v67 = v107;\n        ++v105;\n        v107 = 0;\n      }\n      if ( player != v101 )\n      {\n        if ( v9 == v101 )\n        {\n          v108 = v105 == 1;\n          goto LABEL_370;\n        }\n        goto LABEL_152;\n      }\n      ++v103;\n      goto LABEL_153;\n    }\n    if ( player != v101 )\n    {\n      ++v103;\n      if ( v9 != v101 )\n      {\n        v107 = 0;\nLABEL_152:\n        ++v105;\n      }\nLABEL_153:\n      v108 = v105 == 1;\n      if ( v103 == 3 )\n      {\n        v109 = 1;\n        v110 = 5;\n        if ( v105 == 1 )\n        {\nLABEL_155:\n          if ( !(_BYTE)v107 )\n            v109 = v110;\n          goto LABEL_157;\n        }\n      }\n      v67 = v107;\nLABEL_370:\n      if ( v103 == 2 )\n      {\n        v109 = 2;\n        if ( v105 == 2 )\n          goto LABEL_157;\n      }\n      v109 = -4;\n      v110 = 0;\n      LOBYTE(v107) = v67 & v108;\n      goto LABEL_155;\n    }\n    v103 += 2;\n    if ( v103 == 4 )\n    {\n      v109 = 100;\n      goto LABEL_157;\n    }\n    v109 = 5;\n    v108 = v105 == 1;\n    LOBYTE(v67) = v105 == 1 && v103 == 3;\n    if ( !(_BYTE)v67 )\n      goto LABEL_370;\nLABEL_157:\n    v111 = v83[20];\n    v112 = v97 + v109;\n    v113 = v83[14];\n    v114 = v83[8];\n    v115 = v83[2];\n    if ( player == v111 )\n    {\n      v2 = 1;\n      v67 = 0;\n      v120 = 1;\n      v119 = 0;\n      v116 = 2;\n      v117 = 1;\n    }\n    else\n    {\n      v116 = 1;\n      LOBYTE(v2) = v9 != v111;\n      LOBYTE(v67) = v9 == v111;\n      v117 = 0;\n      v118 = v9 != v111;\n      v119 = v118;\n      v120 = v118 + 1;\n    }\n    if ( player == v113 )\n    {\n      v117 = v116;\n      v121 = 0;\n    }\n    else if ( v9 == v113 )\n    {\n      v121 = v67;\n      v67 = v2;\n    }\n    else\n    {\n      v119 = v120;\n      v121 = 0;\n    }\n    if ( player != v114 )\n    {\n      if ( v9 != v114 )\n      {\n        v67 = v121;\n        ++v119;\n        v121 = 0;\n      }\n      if ( player != v115 )\n      {\n        if ( v9 == v115 )\n        {\n          v122 = v119 == 1;\n          goto LABEL_380;\n        }\n        goto LABEL_167;\n      }\n      ++v117;\n      goto LABEL_168;\n    }\n    if ( v115 != player )\n    {\n      ++v117;\n      if ( v9 != v115 )\n      {\n        v121 = 0;\nLABEL_167:\n        ++v119;\n      }\nLABEL_168:\n      v122 = v119 == 1;\n      if ( v117 == 3 )\n      {\n        v123 = 1;\n        v124 = 5;\n        if ( v119 == 1 )\n        {\nLABEL_170:\n          if ( !(_BYTE)v121 )\n            v123 = v124;\n          goto LABEL_172;\n        }\n      }\n      v67 = v121;\nLABEL_380:\n      if ( v119 == 2 )\n      {\n        v123 = 2;\n        if ( v117 == 2 )\n          goto LABEL_172;\n      }\n      v123 = -4;\n      v124 = 0;\n      LOBYTE(v121) = v67 & v122;\n      goto LABEL_170;\n    }\n    v117 += 2;\n    if ( v117 == 4 )\n    {\n      v123 = 100;\n      goto LABEL_172;\n    }\n    v123 = 5;\n    v122 = v119 == 1;\n    LOBYTE(v67) = v119 == 1 && v117 == 3;\n    if ( !(_BYTE)v67 )\n      goto LABEL_380;\nLABEL_172:\n    v125 = v112 + v123;\n    v126 = v83[21];\n    v127 = v83[15];\n    v128 = v83[9];\n    v129 = v83[3];\n    if ( player == v126 )\n    {\n      v2 = 1;\n      v67 = 0;\n      v134 = 1;\n      v133 = 0;\n      v130 = 2;\n      v131 = 1;\n    }\n    else\n    {\n      v130 = 1;\n      LOBYTE(v2) = v9 != v126;\n      LOBYTE(v67) = v9 == v126;\n      v131 = 0;\n      v132 = v9 != v126;\n      v133 = v132;\n      v134 = v132 + 1;\n    }\n    if ( player == v127 )\n    {\n      v131 = v130;\n      v135 = 0;\n    }\n    else if ( v9 == v127 )\n    {\n      v135 = v67;\n      v67 = v2;\n    }\n    else\n    {\n      v133 = v134;\n      v135 = 0;\n    }\n    if ( player != v128 )\n    {\n      if ( v9 != v128 )\n      {\n        v67 = v135;\n        ++v133;\n        v135 = 0;\n      }\n      if ( player != v129 )\n      {\n        if ( v9 == v129 )\n        {\n          v136 = v133 == 1;\n          goto LABEL_375;\n        }\n        goto LABEL_182;\n      }\n      ++v131;\n      goto LABEL_183;\n    }\n    if ( player != v129 )\n    {\n      ++v131;\n      if ( v9 != v129 )\n      {\n        v135 = 0;\nLABEL_182:\n        ++v133;\n      }\nLABEL_183:\n      v136 = v133 == 1;\n      if ( v131 == 3 )\n      {\n        v137 = 1;\n        v127 = 5;\n        if ( v133 == 1 )\n        {\nLABEL_185:\n          if ( !(_BYTE)v135 )\n            v137 = v127;\n          goto LABEL_187;\n        }\n      }\n      v67 = v135;\nLABEL_375:\n      if ( v131 == 2 )\n      {\n        v137 = 2;\n        if ( v133 == 2 )\n          goto LABEL_187;\n      }\n      v137 = -4;\n      v127 = 0;\n      LOBYTE(v135) = v136 & v67;\n      goto LABEL_185;\n    }\n    v131 += 2;\n    if ( v131 == 4 )\n    {\n      v137 = 100;\n      goto LABEL_187;\n    }\n    v137 = 5;\n    v136 = v133 == 1;\n    LOBYTE(v67) = v133 == 1 && v131 == 3;\n    if ( !(_BYTE)v67 )\n      goto LABEL_375;\nLABEL_187:\n    v83 += 7;\n    v8 = v125 + v137;\n  }\n  while ( &(*board)[24] != v83 );\n  do\n  {\n    v138 = *v5;\n    v139 = v5[8];\n    v140 = v5[16];\n    v141 = v5[24];\n    if ( player == *v5 )\n    {\n      v67 = 1;\n      v127 = 0;\n      v146 = 1;\n      v145 = 0;\n      v142 = 2;\n      v143 = 1;\n    }\n    else\n    {\n      v142 = 1;\n      LOBYTE(v67) = v9 != v138;\n      LOBYTE(v127) = v9 == v138;\n      v143 = 0;\n      v144 = v9 != v138;\n      v145 = v144;\n      v146 = v144 + 1;\n    }\n    if ( player == v139 )\n    {\n      v143 = v142;\n      v147 = 0;\n    }\n    else if ( v9 == v139 )\n    {\n      v147 = v127;\n      v127 = v67;\n    }\n    else\n    {\n      v145 = v146;\n      v147 = 0;\n    }\n    if ( player != v140 )\n    {\n      if ( v9 != v140 )\n      {\n        v127 = v147;\n        ++v145;\n        v147 = 0;\n      }\n      if ( player != v141 )\n      {\n        if ( v9 == v141 )\n        {\n          v148 = v145 == 1;\n          goto LABEL_355;\n        }\n        goto LABEL_198;\n      }\n      ++v143;\n      goto LABEL_199;\n    }\n    if ( player != v141 )\n    {\n      ++v143;\n      if ( v9 != v141 )\n      {\n        v147 = 0;\nLABEL_198:\n        ++v145;\n      }\nLABEL_199:\n      v148 = v145 == 1;\n      if ( v143 == 3 )\n      {\n        v149 = 1;\n        v150 = 5;\n        if ( v145 == 1 )\n        {\nLABEL_201:\n          if ( !(_BYTE)v147 )\n            v149 = v150;\n          goto LABEL_203;\n        }\n      }\n      v127 = v147;\nLABEL_355:\n      if ( v145 == 2 )\n      {\n        v149 = 2;\n        if ( v143 == 2 )\n          goto LABEL_203;\n      }\n      v149 = -4;\n      v150 = 0;\n      LOBYTE(v147) = v127 & v148;\n      goto LABEL_201;\n    }\n    v143 += 2;\n    if ( v143 == 4 )\n    {\n      v149 = 100;\n      goto LABEL_203;\n    }\n    v149 = 5;\n    v148 = v145 == 1;\n    LOBYTE(v127) = v145 == 1 && v143 == 3;\n    if ( !(_BYTE)v127 )\n      goto LABEL_355;\nLABEL_203:\n    v151 = v5[1];\n    v152 = v5[9];\n    v153 = v8 + v149;\n    v154 = v5[17];\n    v155 = v5[25];\n    if ( player == v151 )\n    {\n      v67 = 1;\n      v127 = 0;\n      v160 = 1;\n      v159 = 0;\n      v156 = 2;\n      v157 = 1;\n    }\n    else\n    {\n      v156 = 1;\n      LOBYTE(v67) = v9 != v151;\n      LOBYTE(v127) = v9 == v151;\n      v157 = 0;\n      v158 = v9 != v151;\n      v159 = v158;\n      v160 = v158 + 1;\n    }\n    if ( player == v152 )\n    {\n      v157 = v156;\n      v161 = 0;\n    }\n    else if ( v9 == v152 )\n    {\n      v161 = v127;\n      v127 = v67;\n    }\n    else\n    {\n      v159 = v160;\n      v161 = 0;\n    }\n    if ( player != v154 )\n    {\n      if ( v9 != v154 )\n      {\n        v127 = v161;\n        ++v159;\n        v161 = 0;\n      }\n      if ( player != v155 )\n      {\n        if ( v9 == v155 )\n        {\n          v162 = v159 == 1;\n          goto LABEL_360;\n        }\n        goto LABEL_213;\n      }\n      ++v157;\n      goto LABEL_214;\n    }\n    if ( v155 != player )\n    {\n      ++v157;\n      if ( v9 != v155 )\n      {\n        v161 = 0;\nLABEL_213:\n        ++v159;\n      }\nLABEL_214:\n      v162 = v159 == 1;\n      if ( v157 == 3 )\n      {\n        v163 = 1;\n        v164 = 5;\n        if ( v159 == 1 )\n        {\nLABEL_216:\n          if ( !(_BYTE)v161 )\n            v163 = v164;\n          goto LABEL_218;\n        }\n      }\n      v127 = v161;\nLABEL_360:\n      if ( v159 == 2 )\n      {\n        v163 = 2;\n        if ( v157 == 2 )\n          goto LABEL_218;\n      }\n      v163 = -4;\n      v164 = 0;\n      LOBYTE(v161) = v162 & v127;\n      goto LABEL_216;\n    }\n    v157 += 2;\n    if ( v157 == 4 )\n    {\n      v163 = 100;\n      goto LABEL_218;\n    }\n    v163 = 5;\n    v162 = v159 == 1;\n    LOBYTE(v127) = v159 == 1 && v157 == 3;\n    if ( !(_BYTE)v127 )\n      goto LABEL_360;\nLABEL_218:\n    v165 = v5[2];\n    v166 = v153 + v163;\n    v167 = v5[10];\n    v168 = v5[18];\n    v169 = v5[26];\n    if ( player == v165 )\n    {\n      v67 = 1;\n      v127 = 0;\n      v174 = 1;\n      v173 = 0;\n      v170 = 2;\n      v171 = 1;\n    }\n    else\n    {\n      v170 = 1;\n      LOBYTE(v67) = v9 != v165;\n      LOBYTE(v127) = v9 == v165;\n      v171 = 0;\n      v172 = v9 != v165;\n      v173 = v172;\n      v174 = v172 + 1;\n    }\n    if ( player == v167 )\n    {\n      v171 = v170;\n      v175 = 0;\n    }\n    else if ( v9 == v167 )\n    {\n      v175 = v127;\n      v127 = v67;\n    }\n    else\n    {\n      v173 = v174;\n      v175 = 0;\n    }\n    if ( player != v168 )\n    {\n      if ( v9 != v168 )\n      {\n        v127 = v175;\n        ++v173;\n        v175 = 0;\n      }\n      if ( player != v169 )\n      {\n        if ( v9 == v169 )\n        {\n          v176 = v173 == 1;\n          goto LABEL_350;\n        }\n        goto LABEL_228;\n      }\n      ++v171;\n      goto LABEL_229;\n    }\n    if ( v169 != player )\n    {\n      ++v171;\n      if ( v9 != v169 )\n      {\n        v175 = 0;\nLABEL_228:\n        ++v173;\n      }\nLABEL_229:\n      v176 = v173 == 1;\n      if ( v171 == 3 )\n      {\n        v177 = 1;\n        v178 = 5;\n        if ( v173 == 1 )\n        {\nLABEL_231:\n          if ( !(_BYTE)v175 )\n            v177 = v178;\n          goto LABEL_233;\n        }\n      }\n      v127 = v175;\nLABEL_350:\n      if ( v173 == 2 )\n      {\n        v177 = 2;\n        if ( v171 == 2 )\n          goto LABEL_233;\n      }\n      v177 = -4;\n      v178 = 0;\n      LOBYTE(v175) = v176 & v127;\n      goto LABEL_231;\n    }\n    v171 += 2;\n    if ( v171 == 4 )\n    {\n      v177 = 100;\n      goto LABEL_233;\n    }\n    v177 = 5;\n    v176 = v173 == 1;\n    LOBYTE(v127) = v173 == 1 && v171 == 3;\n    if ( !(_BYTE)v127 )\n      goto LABEL_350;\nLABEL_233:\n    v179 = v166 + v177;\n    v180 = v5[3];\n    v181 = v5[11];\n    v182 = v5[19];\n    v183 = v5[27];\n    if ( player == v180 )\n    {\n      v67 = 1;\n      v127 = 0;\n      v188 = 1;\n      v187 = 0;\n      v184 = 2;\n      v185 = 1;\n    }\n    else\n    {\n      v184 = 1;\n      LOBYTE(v67) = v9 != v180;\n      LOBYTE(v127) = v9 == v180;\n      v185 = 0;\n      v186 = v9 != v180;\n      v187 = v186;\n      v188 = v186 + 1;\n    }\n    if ( player == v181 )\n    {\n      v185 = v184;\n      v189 = 0;\n    }\n    else if ( v9 == v181 )\n    {\n      v189 = v127;\n      v127 = v67;\n    }\n    else\n    {\n      v187 = v188;\n      v189 = 0;\n    }\n    if ( player != v182 )\n    {\n      if ( v9 != v182 )\n      {\n        v127 = v189;\n        ++v187;\n        v189 = 0;\n      }\n      if ( player != v183 )\n      {\n        if ( v9 == v183 )\n        {\n          v190 = v187 == 1;\n          goto LABEL_345;\n        }\n        goto LABEL_243;\n      }\n      ++v185;\n      goto LABEL_244;\n    }\n    if ( player != v183 )\n    {\n      ++v185;\n      if ( v9 != v183 )\n      {\n        v189 = 0;\nLABEL_243:\n        ++v187;\n      }\nLABEL_244:\n      v190 = v187 == 1;\n      if ( v185 == 3 )\n      {\n        v191 = 1;\n        v192 = 5;\n        if ( v187 == 1 )\n        {\nLABEL_246:\n          if ( !(_BYTE)v189 )\n            v191 = v192;\n          goto LABEL_248;\n        }\n      }\n      v127 = v189;\nLABEL_345:\n      if ( v185 == 2 )\n      {\n        v191 = 2;\n        if ( v187 == 2 )\n          goto LABEL_248;\n      }\n      v191 = -4;\n      v192 = 0;\n      LOBYTE(v189) = v190 & v127;\n      goto LABEL_246;\n    }\n    v185 += 2;\n    if ( v185 == 4 )\n    {\n      v191 = 100;\n      goto LABEL_248;\n    }\n    v191 = 5;\n    v190 = v187 == 1;\n    LOBYTE(v127) = v187 == 1 && v185 == 3;\n    if ( !(_BYTE)v127 )\n      goto LABEL_345;\nLABEL_248:\n    v5 += 7;\n    v8 = v179 + v191;\n  }\n  while ( v196 != v5 );\n  return v8;\n}\n"}, "pseudo_normalize": "", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<score_position>:\nendbr64\npush   %r15\nxor    %edx,%edx\nlea    0x1c(%rdi),%rcx\nmov    %esi,%eax\npush   %r14\nmov    %rdi,%r11\npush   %r13\npush   %r12\nlea    0xa8(%rdi),%r12\npush   %rbp\npush   %rbx\ncmp    %esi,0xc(%rdi)\nsete   %dl\nmov    %rcx,-0x10(%rsp)\nxor    %ecx,%ecx\ncmp    0x28(%rdi),%esi\nsete   %cl\nmov    %rdi,-0x30(%rsp)\nadd    %ecx,%edx\nlea    0x38(%rdi),%rcx\nmov    %rcx,-0x18(%rsp)\nxor    %ecx,%ecx\ncmp    0x44(%rdi),%esi\nsete   %cl\nadd    %ecx,%edx\nlea    0x54(%rdi),%rcx\nmov    %rcx,-0x28(%rsp)\nxor    %ecx,%ecx\ncmp    0x60(%rdi),%esi\nsete   %cl\nadd    %ecx,%edx\nlea    0x70(%rdi),%rcx\nmov    %rcx,-0x20(%rsp)\nxor    %ecx,%ecx\ncmp    0x7c(%rdi),%esi\nsete   %cl\nadd    %ecx,%edx\nlea    0x8c(%rdi),%rcx\nmov    %rcx,-0x8(%rsp)\nxor    %ecx,%ecx\ncmp    0x98(%rdi),%esi\nsete   %cl\nadd    %ecx,%edx\nmov    %rdi,%rcx\nlea    (%rdx,%rdx,2),%r8d\nxor    %edx,%edx\ncmp    $0x1,%esi\nsete   %dl\nadd    $0x1,%edx\njmp    25e1 <score_position+0x141>\nnopl   0x0(%rax,%rax,1)\ncmp    %esi,%edx\nmov    $0x1,%r15d\nsetne  %sil\nsetne  %r14b\nsete   %r13b\nxor    %r9d,%r9d\nmovzbl %sil,%esi\nmovzbl %r14b,%edi\nadd    $0x1,%esi\ncmp    %r10d,%eax\nje     27f6 <score_position+0x356>\ncmp    %r10d,%edx\nje     30f8 <score_position+0xc58>\nmov    %esi,%edi\nxor    %r10d,%r10d\ncmp    %ebp,%eax\nje     2804 <score_position+0x364>\ncmp    %ebp,%edx\nje     2596 <score_position+0xf6>\nmov    %r10d,%r13d\nadd    $0x1,%edi\nxor    %r10d,%r10d\ncmp    %ebx,%eax\nje     3bb6 <score_position+0x1716>\ncmp    %ebx,%edx\nje     30c8 <score_position+0xc28>\nadd    $0x1,%edi\ncmp    $0x1,%edi\nsete   %bl\ncmp    $0x3,%r9d\njne    3108 <score_position+0xc68>\nmov    $0x1,%esi\nmov    $0x5,%ebp\ntest   %bl,%bl\nje     3108 <score_position+0xc68>\ntest   %r10b,%r10b\ncmove  %ebp,%esi\nadd    $0x1c,%rcx\nadd    %esi,%r8d\ncmp    %rcx,%r12\nje     282f <score_position+0x38f>\nmov    (%rcx),%edi\nmov    0x4(%rcx),%r13d\nmov    0x8(%rcx),%r9d\nmov    0xc(%rcx),%esi\ncmp    %edi,%eax\nje     3200 <score_position+0xd60>\ncmp    %edi,%edx\nmov    $0x1,%ebp\nsetne  %bl\nsetne  %r15b\nsete   %r14b\nxor    %r10d,%r10d\nmovzbl %bl,%ebx\nmovzbl %r15b,%edi\nadd    $0x1,%ebx\ncmp    %r13d,%eax\nje     31f0 <score_position+0xd50>\ncmp    %r13d,%edx\nje     3350 <score_position+0xeb0>\nmov    %ebx,%edi\nxor    %ebp,%ebp\ncmp    %r9d,%eax\nje     31c8 <score_position+0xd28>\ncmp    %r9d,%edx\nje     2641 <score_position+0x1a1>\nmov    %ebp,%r14d\nadd    $0x1,%edi\nxor    %ebp,%ebp\ncmp    %esi,%eax\nje     3bcf <score_position+0x172f>\ncmp    %esi,%edx\nje     3318 <score_position+0xe78>\nadd    $0x1,%edi\ncmp    $0x1,%edi\nsete   %r15b\ncmp    $0x3,%r10d\njne    37e9 <score_position+0x1349>\nmov    $0x1,%ebx\nmov    $0x5,%r14d\ntest   %r15b,%r15b\nje     37e9 <score_position+0x1349>\ntest   %bpl,%bpl\ncmove  %r14d,%ebx\nmov    0x10(%rcx),%r10d\nlea    (%r8,%rbx,1),%ebp\ncmp    %r13d,%eax\nje     31a0 <score_position+0xd00>\ncmp    %r13d,%edx\nmov    $0x1,%r13d\nsetne  %dil\nsetne  %r15b\nsete   %r14b\nxor    %ebx,%ebx\nmovzbl %dil,%edi\nmovzbl %r15b,%r8d\nadd    $0x1,%edi\ncmp    %r9d,%eax\nje     3190 <score_position+0xcf0>\ncmp    %r9d,%edx\nje     3370 <score_position+0xed0>\nmov    %edi,%r8d\nxor    %r13d,%r13d\ncmp    %esi,%eax\nje     3168 <score_position+0xcc8>\ncmp    %esi,%edx\nje     26e1 <score_position+0x241>\nmov    %r13d,%r14d\nadd    $0x1,%r8d\nxor    %r13d,%r13d\ncmp    %r10d,%eax\nje     3bc7 <score_position+0x1727>\ncmp    %r10d,%edx\nje     3380 <score_position+0xee0>\nadd    $0x1,%r8d\ncmp    $0x1,%r8d\nsete   %r15b\ncmp    $0x3,%ebx\njne    37f1 <score_position+0x1351>\nmov    $0x1,%edi\nmov    $0x5,%r14d\ntest   %r15b,%r15b\nje     37f1 <score_position+0x1351>\ntest   %r13b,%r13b\ncmove  %r14d,%edi\nadd    %ebp,%edi\nmov    0x14(%rcx),%ebp\ncmp    %r9d,%eax\nje     3140 <score_position+0xca0>\ncmp    %r9d,%edx\nmov    $0x1,%r13d\nsetne  %r8b\nsetne  %r15b\nsete   %r14b\nxor    %ebx,%ebx\nmovzbl %r8b,%r8d\nmovzbl %r15b,%r9d\nadd    $0x1,%r8d\ncmp    %esi,%eax\nje     3130 <score_position+0xc90>\ncmp    %esi,%edx\nje     3360 <score_position+0xec0>\nmov    %r8d,%r9d\nxor    %r13d,%r13d\ncmp    %r10d,%eax\nje     3110 <score_position+0xc70>\ncmp    %r10d,%edx\nje     2782 <score_position+0x2e2>\nmov    %r13d,%r14d\nadd    $0x1,%r9d\nxor    %r13d,%r13d\ncmp    %ebp,%eax\nje     3bbf <score_position+0x171f>\ncmp    %ebp,%edx\nje     32e0 <score_position+0xe40>\nadd    $0x1,%r9d\ncmp    $0x1,%r9d\nsete   %r15b\ncmp    $0x3,%ebx\njne    37e1 <score_position+0x1341>\nmov    $0x1,%r8d\nmov    $0x5,%r14d\ntest   %r15b,%r15b\nje     37e1 <score_position+0x1341>\ntest   %r13b,%r13b\ncmove  %r14d,%r8d\nmov    0x18(%rcx),%ebx\nadd    %edi,%r8d\ncmp    %esi,%eax\njne    2548 <score_position+0xa8>\nmov    $0x1,%r14d\nxor    %r13d,%r13d\nmov    $0x1,%esi\nxor    %edi,%edi\nmov    $0x2,%r15d\nmov    $0x1,%r9d\ncmp    %r10d,%eax\njne    2573 <score_position+0xd3>\nmov    %r15d,%r9d\nxor    %r10d,%r10d\ncmp    %ebp,%eax\njne    2589 <score_position+0xe9>\ncmp    %ebx,%eax\njne    3ba2 <score_position+0x1702>\nadd    $0x2,%r9d\ncmp    $0x4,%r9d\njne    3b81 <score_position+0x16e1>\nmov    $0x64,%esi\nadd    $0x1c,%rcx\nadd    %esi,%r8d\ncmp    %rcx,%r12\njne    25e1 <score_position+0x141>\nmov    -0x8(%rsp),%rbx\nxor    %ecx,%ecx\njmp    2a29 <score_position+0x589>\nnopl   0x0(%rax,%rax,1)\ncmp    %esi,%edx\nmov    $0x1,%r13d\nsetne  %sil\nsetne  %r15b\nsete   %r14b\nxor    %r12d,%r12d\nmovzbl %sil,%esi\nmovzbl %r15b,%ebp\nadd    $0x1,%esi\ncmp    %edi,%eax\nje     2a77 <score_position+0x5d7>\ncmp    %edi,%edx\nje     3250 <score_position+0xdb0>\nmov    %esi,%ebp\nxor    %r13d,%r13d\ncmp    %r9d,%eax\nje     2a86 <score_position+0x5e6>\ncmp    %r9d,%edx\nje     288e <score_position+0x3ee>\nmov    %r13d,%r14d\nadd    $0x1,%ebp\nxor    %r13d,%r13d\ncmp    %r10d,%eax\nje     3b78 <score_position+0x16d8>\ncmp    %r10d,%edx\nje     3220 <score_position+0xd80>\nadd    $0x1,%ebp\ncmp    $0x1,%ebp\nsete   %r15b\ncmp    $0x3,%r12d\njne    3607 <score_position+0x1167>\nmov    $0x1,%esi\nmov    $0x5,%r14d\ntest   %r15b,%r15b\nje     3607 <score_position+0x1167>\ntest   %r13b,%r13b\ncmove  %r14d,%esi\nmov    -0x20(%rsp),%r15\nadd    %r8d,%esi\nmov    (%r15,%rcx,1),%ebp\ncmp    %edi,%eax\nje     2ab6 <score_position+0x616>\ncmp    %edi,%edx\nmov    $0x1,%r13d\nsetne  %dil\nsetne  %r15b\nsete   %r14b\nxor    %r12d,%r12d\nmovzbl %dil,%edi\nmovzbl %r15b,%r8d\nadd    $0x1,%edi\ncmp    %r9d,%eax\nje     2adc <score_position+0x63c>\ncmp    %r9d,%edx\nje     32a0 <score_position+0xe00>\nmov    %edi,%r8d\nxor    %r13d,%r13d\ncmp    %r10d,%eax\nje     2aeb <score_position+0x64b>\ncmp    %r10d,%edx\nje     2935 <score_position+0x495>\nmov    %r13d,%r14d\nadd    $0x1,%r8d\nxor    %r13d,%r13d\ncmp    %ebp,%eax\nje     3b6f <score_position+0x16cf>\ncmp    %ebp,%edx\nje     32b0 <score_position+0xe10>\nadd    $0x1,%r8d\ncmp    $0x1,%r8d\nsete   %r15b\ncmp    $0x3,%r12d\njne    3617 <score_position+0x1177>\nmov    $0x1,%edi\nmov    $0x5,%r14d\ntest   %r15b,%r15b\nje     3617 <score_position+0x1177>\ntest   %r13b,%r13b\ncmove  %r14d,%edi\nmov    (%rbx,%rcx,1),%r12d\nlea    (%rdi,%rsi,1),%r8d\ncmp    %r9d,%eax\nje     2b17 <score_position+0x677>\ncmp    %r9d,%edx\nmov    $0x1,%r15d\nsetne  %r9b\nsetne  %r14b\nsete   %r13b\nxor    %edi,%edi\nmovzbl %r9b,%r9d\nmovzbl %r14b,%esi\nadd    $0x1,%r9d\ncmp    %r10d,%eax\nje     2b3c <score_position+0x69c>\ncmp    %r10d,%edx\nje     3290 <score_position+0xdf0>\nmov    %r9d,%esi\nxor    %r9d,%r9d\ncmp    %ebp,%eax\nje     2b4a <score_position+0x6aa>\ncmp    %ebp,%edx\nje     29d7 <score_position+0x537>\nmov    %r9d,%r13d\nadd    $0x1,%esi\nxor    %r9d,%r9d\ncmp    %r12d,%eax\nje     3b67 <score_position+0x16c7>\ncmp    %r12d,%edx\nje     3260 <score_position+0xdc0>\nadd    $0x1,%esi\ncmp    $0x1,%esi\nsete   %bpl\ncmp    $0x3,%edi\njne    360f <score_position+0x116f>\nmov    $0x1,%r10d\nmov    $0x5,%r12d\ntest   %bpl,%bpl\nje     360f <score_position+0x116f>\ntest   %r9b,%r9b\ncmove  %r12d,%r10d\nadd    $0x4,%rcx\nadd    %r10d,%r8d\ncmp    $0x1c,%rcx\nje     2b76 <score_position+0x6d6>\nmov    -0x30(%rsp),%rdi\nmov    -0x18(%rsp),%r15\nmov    (%rdi,%rcx,1),%esi\nmov    (%r15,%rcx,1),%r9d\nmov    -0x10(%rsp),%rdi\nmov    -0x28(%rsp),%r15\nmov    (%rdi,%rcx,1),%edi\nmov    (%r15,%rcx,1),%r10d\ncmp    %esi,%eax\njne    2840 <score_position+0x3a0>\nmov    $0x1,%r15d\nxor    %r14d,%r14d\nmov    $0x1,%esi\nxor    %ebp,%ebp\nmov    $0x2,%r13d\nmov    $0x1,%r12d\ncmp    %edi,%eax\njne    286a <score_position+0x3ca>\nmov    %r13d,%r12d\nxor    %r13d,%r13d\ncmp    %r9d,%eax\njne    2880 <score_position+0x3e0>\ncmp    %r10d,%eax\njne    3b1c <score_position+0x167c>\nadd    $0x2,%r12d\ncmp    $0x4,%r12d\njne    3afa <score_position+0x165a>\nmov    -0x20(%rsp),%r15\nmov    $0x64,%esi\nadd    %r8d,%esi\nmov    (%r15,%rcx,1),%ebp\ncmp    %edi,%eax\njne    28e3 <score_position+0x443>\nmov    $0x1,%r15d\nxor    %r14d,%r14d\nmov    $0x1,%edi\nxor    %r8d,%r8d\nmov    $0x2,%r13d\nmov    $0x1,%r12d\ncmp    %r9d,%eax\njne    290e <score_position+0x46e>\nmov    %r13d,%r12d\nxor    %r13d,%r13d\ncmp    %r10d,%eax\njne    2926 <score_position+0x486>\ncmp    %eax,%ebp\njne    3ae6 <score_position+0x1646>\nadd    $0x2,%r12d\ncmp    $0x4,%r12d\njne    3ac3 <score_position+0x1623>\nmov    $0x64,%edi\nmov    (%rbx,%rcx,1),%r12d\nlea    (%rdi,%rsi,1),%r8d\ncmp    %r9d,%eax\njne    2987 <score_position+0x4e7>\nmov    $0x1,%r14d\nxor    %r13d,%r13d\nxor    %esi,%esi\nmov    $0x1,%edi\nmov    $0x2,%r15d\nmov    $0x1,%r9d\ncmp    %r10d,%eax\njne    29b3 <score_position+0x513>\nmov    %r15d,%edi\nxor    %r9d,%r9d\ncmp    %ebp,%eax\njne    29ca <score_position+0x52a>\ncmp    %r12d,%eax\njne    3b53 <score_position+0x16b3>\nadd    $0x2,%edi\ncmp    $0x4,%edi\njne    3b31 <score_position+0x1691>\nmov    $0x64,%r10d\nadd    $0x4,%rcx\nadd    %r10d,%r8d\ncmp    $0x1c,%rcx\njne    2a29 <score_position+0x589>\nmov    -0x30(%rsp),%rbx\nlea    0xc(%rbx),%rcx\nlea    0x60(%rbx),%r10\nmov    0x48(%rcx),%edi\nmov    0x30(%rcx),%r12d\nmov    0x18(%rcx),%ebx\nmov    (%rcx),%esi\ncmp    %edi,%eax\nje     35e6 <score_position+0x1146>\ncmp    %edi,%edx\nmov    $0x1,%r15d\nsetne  %bpl\nsetne  %r14b\nsete   %r13b\nxor    %r9d,%r9d\nmovzbl %bpl,%ebp\nmovzbl %r14b,%edi\nadd    $0x1,%ebp\ncmp    %r12d,%eax\nje     35dc <score_position+0x113c>\ncmp    %r12d,%edx\nje     372b <score_position+0x128b>\nmov    %ebp,%edi\nxor    %ebp,%ebp\ncmp    %ebx,%eax\nje     35bc <score_position+0x111c>\ncmp    %ebx,%edx\nje     2be3 <score_position+0x743>\nmov    %ebp,%r13d\nadd    $0x1,%edi\nxor    %ebp,%ebp\ncmp    %esi,%eax\nje     3873 <score_position+0x13d3>\ncmp    %esi,%edx\nje     36ff <score_position+0x125f>\nadd    $0x1,%edi\ncmp    $0x1,%edi\nsete   %bl\ncmp    $0x3,%r9d\njne    382e <score_position+0x138e>\nmov    $0x1,%esi\nmov    $0x5,%r12d\ntest   %bl,%bl\nje     382e <score_position+0x138e>\ntest   %bpl,%bpl\ncmove  %r12d,%esi\nadd    %r8d,%esi\nmov    0x4c(%rcx),%r8d\nmov    0x34(%rcx),%r12d\nmov    0x1c(%rcx),%ebx\nmov    0x4(%rcx),%edi\ncmp    %r8d,%eax\nje     359a <score_position+0x10fa>\ncmp    %r8d,%edx\nmov    $0x1,%r15d\nsetne  %bpl\nsetne  %r14b\nsete   %r13b\nxor    %r9d,%r9d\nmovzbl %bpl,%ebp\nmovzbl %r14b,%r8d\nadd    $0x1,%ebp\ncmp    %r12d,%eax\nje     3590 <score_position+0x10f0>\ncmp    %r12d,%edx\nje     3764 <score_position+0x12c4>\nmov    %ebp,%r8d\nxor    %ebp,%ebp\ncmp    %ebx,%eax\nje     3570 <score_position+0x10d0>\ncmp    %ebx,%edx\nje     2c89 <score_position+0x7e9>\nmov    %ebp,%r13d\nadd    $0x1,%r8d\nxor    %ebp,%ebp\ncmp    %edi,%eax\nje     3836 <score_position+0x1396>\ncmp    %edi,%edx\nje     3736 <score_position+0x1296>\nadd    $0x1,%r8d\ncmp    $0x1,%r8d\nsete   %bl\ncmp    $0x3,%r9d\njne    3826 <score_position+0x1386>\nmov    $0x1,%edi\nmov    $0x5,%r12d\ntest   %bl,%bl\nje     3826 <score_position+0x1386>\ntest   %bpl,%bpl\ncmove  %r12d,%edi\nmov    0x50(%rcx),%r8d\nadd    %esi,%edi\nmov    0x38(%rcx),%r12d\nmov    0x20(%rcx),%ebx\nmov    0x8(%rcx),%esi\ncmp    %r8d,%eax\nje     354e <score_position+0x10ae>\ncmp    %r8d,%edx\nmov    $0x1,%r15d\nsetne  %bpl\nsetne  %r14b\nsete   %r13b\nxor    %r9d,%r9d\nmovzbl %bpl,%ebp\nmovzbl %r14b,%r8d\nadd    $0x1,%ebp\ncmp    %r12d,%eax\nje     3544 <score_position+0x10a4>\ncmp    %r12d,%edx\nje     37d6 <score_position+0x1336>\nmov    %ebp,%r8d\nxor    %ebp,%ebp\ncmp    %ebx,%eax\nje     3524 <score_position+0x1084>\ncmp    %ebx,%edx\nje     2d30 <score_position+0x890>\nmov    %ebp,%r13d\nadd    $0x1,%r8d\nxor    %ebp,%ebp\ncmp    %esi,%eax\nje     386a <score_position+0x13ca>\ncmp    %esi,%edx\nje     37a8 <score_position+0x1308>\nadd    $0x1,%r8d\ncmp    $0x1,%r8d\nsete   %bl\ncmp    $0x3,%r9d\njne    3821 <score_position+0x1381>\nmov    $0x1,%esi\nmov    $0x5,%r12d\ntest   %bl,%bl\nje     3821 <score_position+0x1381>\ntest   %bpl,%bpl\ncmove  %r12d,%esi\nadd    %edi,%esi\nmov    0x54(%rcx),%edi\nmov    0x3c(%rcx),%r12d\nmov    0x24(%rcx),%ebx\nmov    0xc(%rcx),%r9d\ncmp    %edi,%eax\nje     3503 <score_position+0x1063>\ncmp    %edi,%edx\nmov    $0x1,%r15d\nsetne  %bpl\nsetne  %r14b\nsete   %r13b\nxor    %r8d,%r8d\nmovzbl %bpl,%ebp\nmovzbl %r14b,%edi\nadd    $0x1,%ebp\ncmp    %r12d,%eax\nje     34f9 <score_position+0x1059>\ncmp    %r12d,%edx\nje     379d <score_position+0x12fd>\nmov    %ebp,%edi\nxor    %ebp,%ebp\ncmp    %ebx,%eax\nje     34d7 <score_position+0x1037>\ncmp    %ebx,%edx\nje     2dd3 <score_position+0x933>\nmov    %ebp,%r13d\nadd    $0x1,%edi\nxor    %ebp,%ebp\ncmp    %r9d,%eax\nje     3861 <score_position+0x13c1>\ncmp    %r9d,%edx\nje     376f <score_position+0x12cf>\nadd    $0x1,%edi\ncmp    $0x1,%edi\nsete   %bl\ncmp    $0x3,%r8d\njne    3819 <score_position+0x1379>\nmov    $0x1,%r9d\nmov    $0x5,%r12d\ntest   %bl,%bl\nje     3819 <score_position+0x1379>\ntest   %bpl,%bpl\ncmove  %r12d,%r9d\nadd    $0x1c,%rcx\nlea    (%rsi,%r9,1),%r8d\ncmp    %rcx,%r10\njne    2b83 <score_position+0x6e3>\nmov    -0x28(%rsp),%r9\nmov    (%r11),%esi\nmov    0x20(%r11),%ebp\nmov    0x40(%r11),%r10d\nmov    0x60(%r11),%ecx\ncmp    %esi,%eax\nje     34b7 <score_position+0x1017>\ncmp    %esi,%edx\nmov    $0x1,%r14d\nsetne  %bl\nsetne  %r13b\nsete   %r12b\nxor    %edi,%edi\nmovzbl %bl,%ebx\nmovzbl %r13b,%esi\nadd    $0x1,%ebx\ncmp    %ebp,%eax\nje     34ad <score_position+0x100d>\ncmp    %ebp,%edx\nje     36bc <score_position+0x121c>\nmov    %ebx,%esi\nxor    %ebx,%ebx\ncmp    %r10d,%eax\nje     348f <score_position+0xfef>\ncmp    %r10d,%edx\nje     2e89 <score_position+0x9e9>\nmov    %ebx,%r12d\nadd    $0x1,%esi\nxor    %ebx,%ebx\ncmp    %ecx,%eax\nje     3848 <score_position+0x13a8>\ncmp    %ecx,%edx\nje     3690 <score_position+0x11f0>\nadd    $0x1,%esi\ncmp    $0x1,%esi\nsete   %r10b\ncmp    $0x3,%edi\njne    3811 <score_position+0x1371>\nmov    $0x1,%ecx\nmov    $0x5,%ebp\ntest   %r10b,%r10b\nje     3811 <score_position+0x1371>\ntest   %bl,%bl\ncmove  %ebp,%ecx\nmov    0x4(%r11),%edi\nmov    0x24(%r11),%ebp\nadd    %r8d,%ecx\nmov    0x44(%r11),%r10d\nmov    0x64(%r11),%esi\ncmp    %edi,%eax\nje     346e <score_position+0xfce>\ncmp    %edi,%edx\nmov    $0x1,%r14d\nsetne  %bl\nsetne  %r13b\nsete   %r12b\nxor    %r8d,%r8d\nmovzbl %bl,%ebx\nmovzbl %r13b,%edi\nadd    $0x1,%ebx\ncmp    %ebp,%eax\nje     3464 <score_position+0xfc4>\ncmp    %ebp,%edx\nje     36f4 <score_position+0x1254>\nmov    %ebx,%edi\nxor    %ebx,%ebx\ncmp    %r10d,%eax\nje     3444 <score_position+0xfa4>\ncmp    %r10d,%edx\nje     2f29 <score_position+0xa89>\nmov    %ebx,%r12d\nadd    $0x1,%edi\nxor    %ebx,%ebx\ncmp    %esi,%eax\nje     383f <score_position+0x139f>\ncmp    %esi,%edx\nje     36c7 <score_position+0x1227>\nadd    $0x1,%edi\ncmp    $0x1,%edi\nsete   %r10b\ncmp    $0x3,%r8d\njne    3809 <score_position+0x1369>\nmov    $0x1,%esi\nmov    $0x5,%ebp\ntest   %r10b,%r10b\nje     3809 <score_position+0x1369>\ntest   %bl,%bl\ncmove  %ebp,%esi\nmov    0x8(%r11),%edi\nadd    %ecx,%esi\nmov    0x28(%r11),%ebp\nmov    0x48(%r11),%r10d\nmov    0x68(%r11),%ecx\ncmp    %edi,%eax\nje     3423 <score_position+0xf83>\ncmp    %edi,%edx\nmov    $0x1,%r14d\nsetne  %bl\nsetne  %r13b\nsete   %r12b\nxor    %r8d,%r8d\nmovzbl %bl,%ebx\nmovzbl %r13b,%edi\nadd    $0x1,%ebx\ncmp    %ebp,%eax\nje     3419 <score_position+0xf79>\ncmp    %ebp,%edx\nje     3685 <score_position+0x11e5>\nmov    %ebx,%edi\nxor    %ebx,%ebx\ncmp    %r10d,%eax\nje     33f9 <score_position+0xf59>\ncmp    %r10d,%edx\nje     2fc9 <score_position+0xb29>\nmov    %ebx,%r12d\nadd    $0x1,%edi\nxor    %ebx,%ebx\ncmp    %ecx,%eax\nje     3858 <score_position+0x13b8>\ncmp    %ecx,%edx\nje     3658 <score_position+0x11b8>\nadd    $0x1,%edi\ncmp    $0x1,%edi\nsete   %r10b\ncmp    $0x3,%r8d\njne    3801 <score_position+0x1361>\nmov    $0x1,%ecx\nmov    $0x5,%ebp\ntest   %r10b,%r10b\nje     3801 <score_position+0x1361>\ntest   %bl,%bl\ncmove  %ebp,%ecx\nadd    %esi,%ecx\nmov    0xc(%r11),%esi\nmov    0x2c(%r11),%ebp\nmov    0x4c(%r11),%r10d\nmov    0x6c(%r11),%r8d\ncmp    %esi,%eax\nje     33d9 <score_position+0xf39>\ncmp    %esi,%edx\nmov    $0x1,%r14d\nsetne  %bl\nsetne  %r13b\nsete   %r12b\nxor    %edi,%edi\nmovzbl %bl,%ebx\nmovzbl %r13b,%esi\nadd    $0x1,%ebx\ncmp    %ebp,%eax\nje     33cf <score_position+0xf2f>\ncmp    %ebp,%edx\nje     364d <score_position+0x11ad>\nmov    %ebx,%esi\nxor    %ebx,%ebx\ncmp    %r10d,%eax\nje     33af <score_position+0xf0f>\ncmp    %r10d,%edx\nje     3068 <score_position+0xbc8>\nmov    %ebx,%r12d\nadd    $0x1,%esi\nxor    %ebx,%ebx\ncmp    %r8d,%eax\nje     3850 <score_position+0x13b0>\ncmp    %r8d,%edx\nje     361f <score_position+0x117f>\nadd    $0x1,%esi\ncmp    $0x1,%esi\nsete   %r10b\ncmp    $0x3,%edi\njne    37f9 <score_position+0x1359>\nmov    $0x1,%r8d\nmov    $0x5,%ebp\ntest   %r10b,%r10b\nje     37f9 <score_position+0x1359>\ntest   %bl,%bl\ncmove  %ebp,%r8d\nadd    $0x1c,%r11\nadd    %ecx,%r8d\ncmp    %r11,%r9\njne    2e29 <score_position+0x989>\npop    %rbx\nmov    %r8d,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\ncmp    $0x1,%edi\nsete   %bl\ncmp    $0x2,%r9d\njne    30e2 <score_position+0xc42>\nmov    $0x2,%esi\ncmp    $0x2,%edi\nje     25d1 <score_position+0x131>\nand    %r13d,%ebx\nmov    $0xfffffffc,%esi\nxor    %ebp,%ebp\nmov    %ebx,%r10d\njmp    25cb <score_position+0x12b>\nnopl   0x0(%rax)\nmov    %r13d,%r10d\nmov    %r14d,%r13d\njmp    2581 <score_position+0xe1>\nnopl   0x0(%rax,%rax,1)\nmov    %r10d,%r13d\njmp    30ce <score_position+0xc2e>\nnopl   (%rax)\ncmp    %eax,%ebp\njne    3ab0 <score_position+0x1610>\nadd    $0x2,%ebx\ncmp    $0x4,%ebx\njne    38e7 <score_position+0x1447>\nmov    $0x64,%r8d\njmp    27c3 <score_position+0x323>\nnop\nmov    %r13d,%ebx\nxor    %r13d,%r13d\njmp    276a <score_position+0x2ca>\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%r15d\nxor    %r14d,%r14d\nmov    $0x2,%r13d\nmov    $0x1,%r8d\nxor    %r9d,%r9d\nmov    $0x1,%ebx\njmp    2754 <score_position+0x2b4>\nnopw   0x0(%rax,%rax,1)\ncmp    %eax,%r10d\njne    38d3 <score_position+0x1433>\nadd    $0x2,%ebx\ncmp    $0x4,%ebx\njne    38b1 <score_position+0x1411>\nmov    $0x64,%edi\njmp    2723 <score_position+0x283>\nnopw   0x0(%rax,%rax,1)\nmov    %r13d,%ebx\nxor    %r13d,%r13d\njmp    26cb <score_position+0x22b>\nnopl   0x0(%rax,%rax,1)\nxor    %r14d,%r14d\nmov    $0x1,%edi\nxor    %r8d,%r8d\nmov    $0x1,%ebx\nmov    $0x1,%r15d\nmov    $0x2,%r13d\njmp    26b3 <score_position+0x213>\nnopl   0x0(%rax)\ncmp    %esi,%eax\njne    389e <score_position+0x13fe>\nadd    $0x2,%r10d\ncmp    $0x4,%r10d\njne    387c <score_position+0x13dc>\nmov    $0x64,%ebx\njmp    2680 <score_position+0x1e0>\nnopl   0x0(%rax,%rax,1)\nmov    %ebp,%r10d\nxor    %ebp,%ebp\njmp    262b <score_position+0x18b>\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%r15d\nxor    %r14d,%r14d\nmov    $0x2,%ebp\nxor    %edi,%edi\nmov    $0x1,%ebx\nmov    $0x1,%r10d\njmp    2615 <score_position+0x175>\ncmp    $0x1,%ebp\nsete   %r15b\ncmp    $0x2,%r12d\njne    323b <score_position+0xd9b>\nmov    $0x2,%esi\ncmp    $0x2,%ebp\nje     28cf <score_position+0x42f>\nand    %r15d,%r14d\nmov    $0xfffffffc,%esi\nmov    %r14d,%r13d\nxor    %r14d,%r14d\njmp    28c8 <score_position+0x428>\nxchg   %ax,%ax\nmov    %r14d,%r13d\nmov    %r15d,%r14d\njmp    2877 <score_position+0x3d7>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x1,%esi\nsete   %bpl\ncmp    $0x2,%edi\njne    327b <score_position+0xddb>\nmov    $0x2,%r10d\ncmp    $0x2,%esi\nje     2a18 <score_position+0x578>\nmov    %r13d,%r9d\nmov    $0xfffffffc,%r10d\nxor    %r12d,%r12d\nand    %ebp,%r9d\njmp    2a11 <score_position+0x571>\nnop\nmov    %r13d,%r9d\nmov    %r14d,%r13d\njmp    29c2 <score_position+0x522>\nnopl   0x0(%rax,%rax,1)\nmov    %r14d,%r13d\nmov    %r15d,%r14d\njmp    291d <score_position+0x47d>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x1,%r8d\nsete   %r15b\ncmp    $0x2,%r8d\njne    32cd <score_position+0xe2d>\nmov    $0x2,%edi\ncmp    $0x2,%r12d\nje     2976 <score_position+0x4d6>\nand    %r14d,%r15d\nmov    $0xfffffffc,%edi\nxor    %r14d,%r14d\nmov    %r15d,%r13d\njmp    296f <score_position+0x4cf>\ncmp    $0x1,%r9d\nsete   %r15b\ncmp    $0x2,%r9d\njne    32fd <score_position+0xe5d>\nmov    $0x2,%r8d\ncmp    $0x2,%ebx\nje     27c3 <score_position+0x323>\nand    %r15d,%r14d\nmov    $0xfffffffc,%r8d\nmov    %r14d,%r13d\nxor    %r14d,%r14d\njmp    27bc <score_position+0x31c>\nnopl   0x0(%rax)\ncmp    $0x1,%edi\nsete   %r15b\ncmp    $0x2,%r10d\njne    3333 <score_position+0xe93>\nmov    $0x2,%ebx\ncmp    $0x2,%edi\nje     2680 <score_position+0x1e0>\nand    %r14d,%r15d\nmov    $0xfffffffc,%ebx\nxor    %r14d,%r14d\nmov    %r15d,%ebp\njmp    2679 <score_position+0x1d9>\ncs nopw 0x0(%rax,%rax,1)\nmov    %r14d,%ebp\nmov    %r15d,%r14d\njmp    262b <score_position+0x18b>\nnopl   0x0(%rax,%rax,1)\nmov    %r14d,%r13d\nmov    %r15d,%r14d\njmp    276a <score_position+0x2ca>\nnopl   0x0(%rax,%rax,1)\nmov    %r14d,%r13d\nmov    %r15d,%r14d\njmp    26cb <score_position+0x22b>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x1,%r8d\nsete   %r15b\ncmp    $0x2,%r8d\njne    339c <score_position+0xefc>\nmov    $0x2,%edi\ncmp    $0x2,%ebx\nje     2723 <score_position+0x283>\nand    %r15d,%r14d\nmov    $0xfffffffc,%edi\nmov    %r14d,%r13d\nxor    %r14d,%r14d\njmp    271c <score_position+0x27c>\ncmp    %r8d,%eax\njne    3995 <score_position+0x14f5>\nadd    $0x2,%edi\ncmp    $0x4,%edi\njne    39bb <score_position+0x151b>\nmov    $0x64,%r8d\njmp    30a7 <score_position+0xc07>\nmov    %r14d,%edi\nxor    %ebx,%ebx\njmp    3052 <score_position+0xbb2>\nmov    $0x1,%r13d\nxor    %r12d,%r12d\nmov    $0x1,%ebx\nxor    %esi,%esi\nmov    $0x2,%r14d\nmov    $0x1,%edi\njmp    303e <score_position+0xb9e>\ncmp    %eax,%ecx\njne    39a8 <score_position+0x1508>\nadd    $0x2,%r8d\ncmp    $0x4,%r8d\njne    3a8e <score_position+0x15ee>\nmov    $0x64,%ecx\njmp    3005 <score_position+0xb65>\nmov    %r14d,%r8d\nxor    %ebx,%ebx\njmp    2fb3 <score_position+0xb13>\nmov    $0x1,%r13d\nxor    %r12d,%r12d\nmov    $0x1,%ebx\nxor    %edi,%edi\nmov    $0x2,%r14d\nmov    $0x1,%r8d\njmp    2f9f <score_position+0xaff>\ncmp    %eax,%esi\njne    3a7b <score_position+0x15db>\nadd    $0x2,%r8d\ncmp    $0x4,%r8d\njne    3a59 <score_position+0x15b9>\nmov    $0x64,%esi\njmp    2f65 <score_position+0xac5>\nmov    %r14d,%r8d\nxor    %ebx,%ebx\njmp    2f13 <score_position+0xa73>\nmov    $0x1,%r13d\nxor    %r12d,%r12d\nmov    $0x1,%ebx\nxor    %edi,%edi\nmov    $0x2,%r14d\nmov    $0x1,%r8d\njmp    2eff <score_position+0xa5f>\ncmp    %ecx,%eax\njne    3a47 <score_position+0x15a7>\nadd    $0x2,%edi\ncmp    $0x4,%edi\njne    3a26 <score_position+0x1586>\nmov    $0x64,%ecx\njmp    2ec4 <score_position+0xa24>\nmov    %r14d,%edi\nxor    %ebx,%ebx\njmp    2e73 <score_position+0x9d3>\nmov    $0x1,%r13d\nxor    %r12d,%r12d\nmov    $0x1,%ebx\nxor    %esi,%esi\nmov    $0x2,%r14d\nmov    $0x1,%edi\njmp    2e5f <score_position+0x9bf>\ncmp    %r9d,%eax\njne    3a12 <score_position+0x1572>\nadd    $0x2,%r8d\ncmp    $0x4,%r8d\njne    39f0 <score_position+0x1550>\nmov    $0x64,%r9d\njmp    2e13 <score_position+0x973>\nmov    %r15d,%r8d\nxor    %ebp,%ebp\njmp    2dbf <score_position+0x91f>\nmov    $0x1,%r14d\nxor    %r13d,%r13d\nmov    $0x1,%ebp\nxor    %edi,%edi\nmov    $0x2,%r15d\nmov    $0x1,%r8d\njmp    2da9 <score_position+0x909>\ncmp    %eax,%esi\njne    39dd <score_position+0x153d>\nadd    $0x2,%r9d\ncmp    $0x4,%r9d\njne    3952 <score_position+0x14b2>\nmov    $0x64,%esi\njmp    2d6f <score_position+0x8cf>\nmov    %r15d,%r9d\nxor    %ebp,%ebp\njmp    2d1b <score_position+0x87b>\nmov    $0x1,%r14d\nxor    %r13d,%r13d\nmov    $0x1,%ebp\nxor    %r8d,%r8d\nmov    $0x2,%r15d\nmov    $0x1,%r9d\njmp    2d04 <score_position+0x864>\ncmp    %edi,%eax\njne    393f <score_position+0x149f>\nadd    $0x2,%r9d\ncmp    $0x4,%r9d\njne    391d <score_position+0x147d>\nmov    $0x64,%edi\njmp    2cc8 <score_position+0x828>\nmov    %r15d,%r9d\nxor    %ebp,%ebp\njmp    2c74 <score_position+0x7d4>\nmov    $0x1,%r14d\nxor    %r13d,%r13d\nmov    $0x1,%ebp\nxor    %r8d,%r8d\nmov    $0x2,%r15d\nmov    $0x1,%r9d\njmp    2c5d <score_position+0x7bd>\ncmp    %eax,%esi\njne    390a <score_position+0x146a>\nadd    $0x2,%r9d\ncmp    $0x4,%r9d\njne    3974 <score_position+0x14d4>\nmov    $0x64,%esi\njmp    2c20 <score_position+0x780>\nmov    %r15d,%r9d\nxor    %ebp,%ebp\njmp    2bcf <score_position+0x72f>\nmov    $0x1,%r14d\nxor    %r13d,%r13d\nmov    $0x1,%ebp\nxor    %edi,%edi\nmov    $0x2,%r15d\nmov    $0x1,%r9d\njmp    2bb9 <score_position+0x719>\nmov    %r13d,%r14d\njmp    3227 <score_position+0xd87>\nmov    %r9d,%r13d\njmp    3267 <score_position+0xdc7>\nmov    %r13d,%r14d\njmp    32b8 <score_position+0xe18>\ncmp    $0x1,%esi\nsete   %r10b\ncmp    $0x2,%edi\njne    363a <score_position+0x119a>\nmov    $0x2,%r8d\ncmp    $0x2,%esi\nje     30a7 <score_position+0xc07>\nmov    %r12d,%ebx\nmov    $0xfffffffc,%r8d\nxor    %ebp,%ebp\nand    %r10d,%ebx\njmp    30a1 <score_position+0xc01>\nmov    %r12d,%ebx\nmov    %r13d,%r12d\njmp    3052 <score_position+0xbb2>\ncmp    $0x1,%edi\nsete   %r10b\ncmp    $0x2,%edi\njne    3673 <score_position+0x11d3>\nmov    $0x2,%ecx\ncmp    $0x2,%r8d\nje     3005 <score_position+0xb65>\nmov    %r12d,%ebx\nmov    $0xfffffffc,%ecx\nxor    %ebp,%ebp\nand    %r10d,%ebx\njmp    3000 <score_position+0xb60>\nmov    %r12d,%ebx\nmov    %r13d,%r12d\njmp    2fb3 <score_position+0xb13>\ncmp    $0x1,%esi\nsete   %r10b\ncmp    $0x2,%esi\njne    36aa <score_position+0x120a>\nmov    $0x2,%ecx\ncmp    $0x2,%edi\nje     2ec4 <score_position+0xa24>\nmov    %r10d,%ebx\nmov    $0xfffffffc,%ecx\nxor    %ebp,%ebp\nand    %r12d,%ebx\njmp    2ebf <score_position+0xa1f>\nmov    %r12d,%ebx\nmov    %r13d,%r12d\njmp    2e73 <score_position+0x9d3>\ncmp    $0x1,%edi\nsete   %r10b\ncmp    $0x2,%edi\njne    36e2 <score_position+0x1242>\nmov    $0x2,%esi\ncmp    $0x2,%r8d\nje     2f65 <score_position+0xac5>\nmov    %r12d,%ebx\nmov    $0xfffffffc,%esi\nxor    %ebp,%ebp\nand    %r10d,%ebx\njmp    2f60 <score_position+0xac0>\nmov    %r12d,%ebx\nmov    %r13d,%r12d\njmp    2f13 <score_position+0xa73>\ncmp    $0x1,%edi\nsete   %bl\ncmp    $0x2,%edi\njne    3719 <score_position+0x1279>\nmov    $0x2,%esi\ncmp    $0x2,%r9d\nje     2c20 <score_position+0x780>\nand    %r13d,%ebx\nmov    $0xfffffffc,%esi\nxor    %r12d,%r12d\nmov    %ebx,%ebp\njmp    2c19 <score_position+0x779>\nmov    %r13d,%ebp\nmov    %r14d,%r13d\njmp    2bcf <score_position+0x72f>\ncmp    $0x1,%r8d\nsete   %bl\ncmp    $0x2,%r9d\njne    3752 <score_position+0x12b2>\nmov    $0x2,%edi\ncmp    $0x2,%r8d\nje     2cc8 <score_position+0x828>\nand    %r13d,%ebx\nmov    $0xfffffffc,%edi\nxor    %r12d,%r12d\nmov    %ebx,%ebp\njmp    2cc1 <score_position+0x821>\nmov    %r13d,%ebp\nmov    %r14d,%r13d\njmp    2c74 <score_position+0x7d4>\ncmp    $0x1,%edi\nsete   %bl\ncmp    $0x2,%r8d\njne    378a <score_position+0x12ea>\nmov    $0x2,%r9d\ncmp    $0x2,%edi\nje     2e13 <score_position+0x973>\nmov    %r13d,%ebp\nmov    $0xfffffffc,%r9d\nxor    %r12d,%r12d\nand    %ebx,%ebp\njmp    2e0c <score_position+0x96c>\nmov    %r13d,%ebp\nmov    %r14d,%r13d\njmp    2dbf <score_position+0x91f>\ncmp    $0x1,%r8d\nsete   %bl\ncmp    $0x2,%r8d\njne    37c4 <score_position+0x1324>\nmov    $0x2,%esi\ncmp    $0x2,%r9d\nje     2d6f <score_position+0x8cf>\nand    %r13d,%ebx\nmov    $0xfffffffc,%esi\nxor    %r12d,%r12d\nmov    %ebx,%ebp\njmp    2d68 <score_position+0x8c8>\nmov    %r13d,%ebp\nmov    %r14d,%r13d\njmp    2d1b <score_position+0x87b>\nmov    %r13d,%r14d\njmp    32e8 <score_position+0xe48>\nmov    %ebp,%r14d\njmp    331f <score_position+0xe7f>\nmov    %r13d,%r14d\njmp    3388 <score_position+0xee8>\nmov    %ebx,%r12d\njmp    3626 <score_position+0x1186>\nmov    %ebx,%r12d\njmp    365f <score_position+0x11bf>\nmov    %ebx,%r12d\njmp    36ce <score_position+0x122e>\nmov    %ebx,%r12d\njmp    3697 <score_position+0x11f7>\nmov    %ebp,%r13d\njmp    3775 <score_position+0x12d5>\nmov    %ebp,%r13d\njmp    37af <score_position+0x130f>\nmov    %ebp,%r13d\njmp    373d <score_position+0x129d>\nmov    %ebp,%r13d\njmp    3705 <score_position+0x1265>\nadd    $0x1,%r9d\njmp    2c9d <score_position+0x7fd>\nadd    $0x1,%r8d\njmp    2f3c <score_position+0xa9c>\nadd    $0x1,%edi\njmp    2e9c <score_position+0x9fc>\nadd    $0x1,%edi\njmp    307d <score_position+0xbdd>\nadd    $0x1,%r8d\njmp    2fdc <score_position+0xb3c>\nadd    $0x1,%r8d\njmp    2de8 <score_position+0x948>\nadd    $0x1,%r9d\njmp    2d44 <score_position+0x8a4>\nadd    $0x1,%r9d\njmp    2bf6 <score_position+0x756>\ncmp    $0x1,%edi\nmov    $0x5,%ebx\nsete   %r15b\ncmp    $0x3,%r10d\nsete   %r14b\nand    %r15b,%r14b\njne    2680 <score_position+0x1e0>\njmp    331f <score_position+0xe7f>\nadd    $0x1,%r10d\ncmp    %esi,%edx\nje     2654 <score_position+0x1b4>\nxor    %ebp,%ebp\njmp    2651 <score_position+0x1b1>\ncmp    $0x1,%r8d\nmov    $0x5,%edi\nsete   %r15b\ncmp    $0x3,%ebx\nsete   %r14b\nand    %r15b,%r14b\njne    2723 <score_position+0x283>\njmp    3388 <score_position+0xee8>\nadd    $0x1,%ebx\ncmp    %r10d,%edx\nje     26f7 <score_position+0x257>\nxor    %r13d,%r13d\njmp    26f3 <score_position+0x253>\ncmp    $0x1,%r9d\nmov    $0x5,%r8d\nsete   %r15b\ncmp    $0x3,%ebx\nsete   %r14b\nand    %r15b,%r14b\njne    27c3 <score_position+0x323>\njmp    32e8 <score_position+0xe48>\nadd    $0x1,%r9d\ncmp    %esi,%edx\nje     2bf6 <score_position+0x756>\nxor    %ebp,%ebp\njmp    2bf3 <score_position+0x753>\ncmp    $0x1,%r8d\nmov    $0x5,%edi\nsete   %bl\ncmp    $0x3,%r9d\nsete   %r13b\nand    %bl,%r13b\njne    2cc8 <score_position+0x828>\njmp    373d <score_position+0x129d>\nadd    $0x1,%r9d\ncmp    %edi,%edx\nje     2c9d <score_position+0x7fd>\nxor    %ebp,%ebp\njmp    2c99 <score_position+0x7f9>\ncmp    $0x1,%r8d\nmov    $0x5,%esi\nsete   %bl\ncmp    $0x3,%r9d\nsete   %r13b\nand    %bl,%r13b\njne    2d6f <score_position+0x8cf>\njmp    37af <score_position+0x130f>\ncmp    $0x1,%edi\nmov    $0x5,%esi\nsete   %bl\ncmp    $0x3,%r9d\nsete   %r13b\nand    %bl,%r13b\njne    2c20 <score_position+0x780>\njmp    3705 <score_position+0x1265>\nadd    $0x1,%edi\ncmp    %r8d,%edx\nje     307d <score_position+0xbdd>\nxor    %ebx,%ebx\njmp    307a <score_position+0xbda>\nadd    $0x1,%r8d\ncmp    %ecx,%edx\nje     2fdc <score_position+0xb3c>\nxor    %ebx,%ebx\njmp    2fd9 <score_position+0xb39>\ncmp    $0x1,%esi\nmov    $0x5,%r8d\nsete   %r10b\ncmp    $0x3,%edi\nsete   %r12b\nand    %r10b,%r12b\njne    30a7 <score_position+0xc07>\njmp    3626 <score_position+0x1186>\nadd    $0x1,%r9d\ncmp    %esi,%edx\nje     2d44 <score_position+0x8a4>\nxor    %ebp,%ebp\njmp    2d40 <score_position+0x8a0>\ncmp    $0x1,%edi\nmov    $0x5,%r9d\nsete   %bl\ncmp    $0x3,%r8d\nsete   %r13b\nand    %bl,%r13b\njne    2e13 <score_position+0x973>\njmp    3775 <score_position+0x12d5>\nadd    $0x1,%r8d\ncmp    %r9d,%edx\nje     2de8 <score_position+0x948>\nxor    %ebp,%ebp\njmp    2de5 <score_position+0x945>\ncmp    $0x1,%esi\nmov    $0x5,%ecx\nsete   %r10b\ncmp    $0x3,%edi\nsete   %r12b\nand    %r10b,%r12b\njne    2ec4 <score_position+0xa24>\njmp    3697 <score_position+0x11f7>\nadd    $0x1,%edi\ncmp    %ecx,%edx\nje     2e9c <score_position+0x9fc>\nxor    %ebx,%ebx\njmp    2e99 <score_position+0x9f9>\ncmp    $0x1,%edi\nmov    $0x5,%esi\nsete   %r10b\ncmp    $0x3,%r8d\nsete   %r12b\nand    %r10b,%r12b\njne    2f65 <score_position+0xac5>\njmp    36ce <score_position+0x122e>\nadd    $0x1,%r8d\ncmp    %esi,%edx\nje     2f3c <score_position+0xa9c>\nxor    %ebx,%ebx\njmp    2f39 <score_position+0xa99>\ncmp    $0x1,%edi\nmov    $0x5,%ecx\nsete   %r10b\ncmp    $0x3,%r8d\nsete   %r12b\nand    %r10b,%r12b\njne    3005 <score_position+0xb65>\njmp    365f <score_position+0x11bf>\nadd    $0x1,%ebx\ncmp    %ebp,%edx\nje     2796 <score_position+0x2f6>\nxor    %r13d,%r13d\njmp    2792 <score_position+0x2f2>\ncmp    $0x1,%r8d\nmov    $0x5,%edi\nsete   %r15b\ncmp    $0x3,%r12d\nsete   %r14b\nand    %r15b,%r14b\njne    2976 <score_position+0x4d6>\njmp    32b8 <score_position+0xe18>\nadd    $0x1,%r12d\ncmp    %ebp,%edx\nje     2949 <score_position+0x4a9>\nxor    %r13d,%r13d\njmp    2945 <score_position+0x4a5>\ncmp    $0x1,%ebp\nmov    $0x5,%esi\nsete   %r15b\ncmp    $0x3,%r12d\nsete   %r14b\nand    %r15b,%r14b\njne    28cf <score_position+0x42f>\njmp    3227 <score_position+0xd87>\nadd    $0x1,%r12d\ncmp    %r10d,%edx\nje     28a3 <score_position+0x403>\nxor    %r13d,%r13d\njmp    28a0 <score_position+0x400>\ncmp    $0x1,%esi\nmov    $0x5,%r10d\nsete   %bpl\ncmp    $0x3,%edi\nsete   %r13b\nand    %bpl,%r13b\njne    2a18 <score_position+0x578>\njmp    3267 <score_position+0xdc7>\nadd    $0x1,%edi\ncmp    %r12d,%edx\nje     29ec <score_position+0x54c>\nxor    %r9d,%r9d\njmp    29e9 <score_position+0x549>\nadd    $0x1,%edi\njmp    29ec <score_position+0x54c>\nadd    $0x1,%r12d\njmp    2949 <score_position+0x4a9>\nadd    $0x1,%r12d\njmp    28a3 <score_position+0x403>\ncmp    $0x1,%edi\nmov    $0x5,%esi\nsete   %bl\ncmp    $0x3,%r9d\nsete   %r13b\nand    %bl,%r13b\njne    25d1 <score_position+0x131>\njmp    30ce <score_position+0xc2e>\nadd    $0x1,%r9d\ncmp    %ebx,%edx\nje     25a9 <score_position+0x109>\nxor    %r10d,%r10d\njmp    25a6 <score_position+0x106>\nadd    $0x1,%r9d\njmp    25a9 <score_position+0x109>\nadd    $0x1,%ebx\njmp    2796 <score_position+0x2f6>\nadd    $0x1,%ebx\njmp    26f7 <score_position+0x257>\nadd    $0x1,%r10d\njmp    2654 <score_position+0x1b4>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "terminal_score", "content": "// Check if terminal state has been reached and return a score.\n// If player wins, return WIN_SCORE; if opponent wins, return LOSS_SCORE; if draw return 0.\nint terminal_score(int board[ROWS][COLS], int player) {\n    int opp = (player == 1) ? 2 : 1;\n    if (check_win(board, player))\n        return WIN_SCORE;\n    if (check_win(board, opp))\n        return LOSS_SCORE;\n    return 0;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "terminal_score", "address": "0x3be0", "label": "terminal_score", "content": "int __fastcall terminal_score(int (*board)[7], int player)\n{\n  int v2; // r8d\n  int result; // eax\n\n  v2 = check_win(board, player);\n  result = 100000;\n  if ( !v2 )\n  {\n    result = check_win(board, (player == 1) + 1);\n    if ( result )\n      return -100000;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int terminal_score(int (*board)[7], int player) {\n  int v2;\n  int result;\n  v2 = check_win(board, player);\n  result = 100000;\n  if (!v2) {\n    result = check_win(board, (player == 1) + 1);\n    if (result) return -100000;\n  }\n  return result;\n}", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<terminal_score>:\nendbr64\npush   %r12\nxor    %r12d,%r12d\ncmp    $0x1,%esi\npush   %rbp\nsete   %r12b\nmov    %rdi,%rbp\nadd    $0x1,%r12d\ncall   1540 <check_win>\nmov    %eax,%r8d\nmov    $0x186a0,%eax\ntest   %r8d,%r8d\njne    3c19 <terminal_score+0x39>\nmov    %r12d,%esi\nmov    %rbp,%rdi\ncall   1540 <check_win>\ntest   %eax,%eax\njne    3c1d <terminal_score+0x3d>\npop    %rbp\npop    %r12\nret\nmov    $0xfffe7960,%eax\njmp    3c19 <terminal_score+0x39>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "undo_move", "content": "// Undo a move in the given column (remove the top piece).\nvoid undo_move(int board[ROWS][COLS], int col) {\n    for (int r = 0; r < ROWS; r++) {\n        if (board[r][col] != EMPTY) {\n            board[r][col] = EMPTY;\n            break;\n        }\n    }\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "undo_move", "address": "0x1490", "label": "undo_move", "content": "void __fastcall undo_move(int (*board)[7], int col)\n{\n  int *v2; // rax\n\n  if ( (*board)[col] )\n    goto LABEL_9;\n  v2 = &(*board)[7];\n  if ( (*board)[col + 7]\n    || (v2 = &(*board)[14], (*board)[col + 14])\n    || (v2 = &(*board)[21], (*board)[col + 21])\n    || (v2 = &(*board)[28], (*board)[col + 28]) )\n  {\n    board = (int (*)[7])v2;\n    goto LABEL_9;\n  }\n  board += 5;\n  if ( (*board)[col] )\nLABEL_9:\n    (*board)[col] = 0;\n}\n"}, "pseudo_normalize": "void undo_move(int (*board)[7], int col) {\n  int *v2;\n  if ((*board)[col]) goto LABEL_9;\n  v2 = &(*board)[7];\n  if ((*board)[col + 7] || (v2 = &(*board)[14], (*board)[col + 14]) ||\n      (v2 = &(*board)[21], (*board)[col + 21]) ||\n      (v2 = &(*board)[28], (*board)[col + 28])) {\n    board = (int(*)[7])v2;\n    goto LABEL_9;\n  }\n  board += 5;\n  if ((*board)[col])\n  LABEL_9:\n    (*board)[col] = 0;\n}", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<undo_move>:\nendbr64\nmovslq %esi,%rsi\nmov    (%rdi,%rsi,4),%r10d\ntest   %r10d,%r10d\njne    14eb <undo_move+0x5b>\nmov    0x1c(%rdi,%rsi,4),%r9d\nlea    0x1c(%rdi),%rax\ntest   %r9d,%r9d\njne    14e8 <undo_move+0x58>\nmov    0x38(%rdi,%rsi,4),%r8d\nlea    0x38(%rdi),%rax\ntest   %r8d,%r8d\njne    14e8 <undo_move+0x58>\nmov    0x54(%rdi,%rsi,4),%ecx\nlea    0x54(%rdi),%rax\ntest   %ecx,%ecx\njne    14e8 <undo_move+0x58>\nmov    0x70(%rdi,%rsi,4),%edx\nlea    0x70(%rdi),%rax\ntest   %edx,%edx\njne    14e8 <undo_move+0x58>\nadd    $0x8c,%rdi\nmov    (%rdi,%rsi,4),%eax\ntest   %eax,%eax\njne    14eb <undo_move+0x5b>\nret\nnopl   0x0(%rax,%rax,1)\nmov    %rax,%rdi\nmovl   $0x0,(%rdi,%rsi,4)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "valid_move", "content": "// Returns 1 if the column is not full.\nint valid_move(int board[ROWS][COLS], int col) {\n    return board[0][col] == EMPTY;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O3.pseudo", "function_name": "valid_move", "address": "0x1360", "label": "valid_move", "content": "int __fastcall valid_move(int (*board)[7], int col)\n{\n  return (*board)[col] == 0;\n}\n"}, "pseudo_normalize": "", "binary": "connect4-minimax/connect4-minimax.host.O3", "assembly": "<valid_move>:\nendbr64\nmovslq %esi,%rsi\nxor    %eax,%eax\nmov    (%rdi,%rsi,4),%edx\ntest   %edx,%edx\nsete   %al\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "comparePoints", "content": "// Comparator for sorting points with respect to global pivot p0.\n// Returns a negative number if a comes before b (i.e. a has a smaller polar angle),\n// zero if they are collinear (in which case the closer one comes first),\n// and a positive number otherwise.\nint comparePoints(Point a, Point b) {\n    int o = orientation(p0, a, b);\n    if (o == 0) {\n        // Collinear; sort by distance to p0.\n        return distanceSq(p0, a) - distanceSq(p0, b);\n    }\n    // If a is counterclockwise to b then a comes first.\n    return (o < 0) ? -1 : 1;\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O3.pseudo", "function_name": "comparePoints", "address": "0x16d0", "label": "comparePoints", "content": "int __fastcall comparePoints(Point a, Point b)\n{\n  int v2; // edx\n\n  v2 = (a.y - p0.y) * (b.x - a.x) - (a.x - p0.x) * (b.y - a.y);\n  if ( v2 )\n    return 2 * (v2 > 0) - 1;\n  else\n    return (a.y - p0.y) * (a.y - p0.y)\n         + (a.x - p0.x) * (a.x - p0.x)\n         - ((b.y - p0.y) * (b.y - p0.y)\n          + (b.x - p0.x) * (b.x - p0.x));\n}\n"}, "pseudo_normalize": "int comparePoints(Point a, Point b) {\n  int v2;\n  v2 = (a.y - p0.y) * (b.x - a.x) - (a.x - p0.x) * (b.y - a.y);\n  if (v2)\n    return 2 * (v2 > 0) - 1;\n  else\n    return (a.y - p0.y) * (a.y - p0.y) + (a.x - p0.x) * (a.x - p0.x) -\n           ((b.y - p0.y) * (b.y - p0.y) + (b.x - p0.x) * (b.x - p0.x));\n}", "binary": "convex-hull/convex-hull.host.O3", "assembly": "<comparePoints>:\nendbr64\nmov    %rdi,%r9\nmov    %rsi,%rcx\nmov    0x4b8f(%rip),%r11d\nmov    %esi,%edx\nsar    $0x20,%r9\nmov    0x4b86(%rip),%r10d\nmov    %edi,%eax\nsub    %edi,%edx\nsar    $0x20,%rcx\nmov    %r9d,%r8d\nsub    %r11d,%eax\nmov    %ecx,%edi\nsub    %r10d,%r8d\nsub    %r9d,%edi\nimul   %r8d,%edx\nimul   %eax,%edi\nsub    %edi,%edx\ntest   %edx,%edx\nje     1720 <comparePoints+0x50>\nsetg   %al\nmovzbl %al,%eax\nlea    -0x1(%rax,%rax,1),%eax\nret\nnopl   0x0(%rax)\nsub    %r11d,%esi\nimul   %eax,%eax\nsub    %r10d,%ecx\nimul   %r8d,%r8d\nimul   %esi,%esi\nimul   %ecx,%ecx\nadd    %r8d,%eax\nadd    %ecx,%esi\nsub    %esi,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "distanceSq", "content": "// Computes the squared Euclidean distance between points p and q.\nint distanceSq(Point p, Point q) {\n    int dx = q.x - p.x;\n    int dy = q.y - p.y;\n    return dx * dx + dy * dy;\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O3.pseudo", "function_name": "distanceSq", "address": "0x16b0", "label": "distanceSq", "content": "int __fastcall distanceSq(Point p, Point q)\n{\n  return (q.y - p.y) * (q.y - p.y) + (q.x - p.x) * (q.x - p.x);\n}\n"}, "pseudo_normalize": "", "binary": "convex-hull/convex-hull.host.O3", "assembly": "<distanceSq>:\nendbr64\nmov    %esi,%eax\nsar    $0x20,%rsi\nsub    %edi,%eax\nsar    $0x20,%rdi\nsub    %edi,%esi\nimul   %eax,%eax\nimul   %esi,%esi\nadd    %esi,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "main", "content": "int main() {\n    // Seed the random number generator with a fixed value for reproducibility.\n    libmin_srand(42);\n\n    // Generate a set of random points.\n    Point points[NUM_POINTS];\n    for (int i = 0; i < NUM_POINTS; i++) {\n        points[i].x = libmin_rand() % 101;  // x in range [0, 100]\n        points[i].y = libmin_rand() % 101;  // y in range [0, 100]\n    }\n\n    // Find the pivot: the point with the lowest y-coordinate.\n    // On a tie, choose the point with the lowest x-coordinate.\n    int minIdx = 0;\n    for (int i = 1; i < NUM_POINTS; i++) {\n        if (points[i].y < points[minIdx].y ||\n           (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {\n            minIdx = i;\n        }\n    }\n    // Swap the pivot with the first element.\n    Point temp = points[0];\n    points[0] = points[minIdx];\n    points[minIdx] = temp;\n    p0 = points[0];  // Set the global pivot.\n\n    // Sort the remaining points according to the polar angle relative to p0.\n    sortPoints(points, NUM_POINTS);\n\n    // Allocate an array to store the convex hull points.\n    Point hull[NUM_POINTS];\n    int hullSize = 0;\n\n    // Apply the Graham scan: iterate through all points.\n    for (int i = 0; i < NUM_POINTS; i++) {\n        // While the last two points in the hull and the current point do not make\n        // a counterclockwise turn, remove the top of the hull.\n        while (hullSize >= 2 &&\n               orientation(hull[hullSize - 2], hull[hullSize - 1], points[i]) <= 0) {\n            hullSize--;  // Pop the last point.\n        }\n        hull[hullSize++] = points[i];  // Push the current point.\n    }\n\n    // Print the convex hull result.\n    libmin_printf(\"Convex Hull Points (in order):\\n\");\n    for (int i = 0; i < hullSize; i++) {\n        libmin_printf(\"(%d, %d)\\n\", hull[i].x, hull[i].y);\n    }\n\n    // Optionally, compute a checksum (sum of coordinates) and print hull size.\n    int checksum = 0;\n    for (int i = 0; i < hullSize; i++) {\n        checksum += hull[i].x + hull[i].y;\n    }\n    libmin_printf(\"Hull size: %d, Checksum: %d\\n\", hullSize, checksum);\n\n    libtarg_success();\n    return 0;\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Point *v3; // rbx\n  Point *v4; // r13\n  int y; // esi\n  int *p_y; // rdx\n  int v7; // eax\n  int v8; // edi\n  Point v9; // rax\n  __int64 v10; // rsi\n  __int64 v11; // rcx\n  Point *v12; // r8\n  __int64 v13; // r9\n  int v14; // eax\n  int v15; // ebp\n  Point *v16; // rdx\n  int x; // eax\n  int v18; // edi\n  Point v19; // rdx\n  unsigned int v20; // r13d\n  int v21; // edx\n  int v22; // esi\n  unsigned int v23; // eax\n  __m128 si128; // xmm0\n  __m128i v25; // xmm0\n  __m128 v26; // xmm2\n  __m128 v27; // xmm2\n  __m128 v28; // xmm2\n  __m128 v29; // xmm2\n  __m128 v30; // xmm2\n  __m128 v31; // xmm2\n  __m128 v32; // xmm2\n  __m128 v33; // xmm2\n  __m128 v34; // xmm2\n  __m128 v35; // xmm2\n  __m128 v36; // xmm2\n  signed int v37; // eax\n  __m128i v38; // xmm0\n  int v39; // edx\n  int v40; // esi\n  int v41; // eax\n  Point points[50]; // [rsp+2h] [rbp+0h] BYREF\n  Point hull[50]; // [rsp+192h] [rbp+190h] BYREF\n  unsigned __int64 vars328; // [rsp+32Ah] [rbp+328h]\n\n  vars328 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  v3 = points;\n  v4 = points;\n  do\n  {\n    ++v4;\n    v4[-1].x = libmin_rand() % 0x65;\n    v4[-1].y = libmin_rand() % 0x65;\n  }\n  while ( v4 != hull );\n  y = points[0].y;\n  p_y = &points[1].y;\n  v7 = 1;\n  v8 = 0;\n  do\n  {\n    while ( *p_y < y )\n    {\n      v8 = v7++;\n      y = *p_y;\n      p_y += 2;\n      if ( v7 == 50 )\n        goto LABEL_10;\n    }\n    if ( *p_y == y && *(p_y - 1) < points[v8].x )\n      v8 = v7;\n    ++v7;\n    p_y += 2;\n  }\n  while ( v7 != 50 );\nLABEL_10:\n  v9 = points[0];\n  v10 = 50LL;\n  points[0] = points[v8];\n  points[v8] = v9;\n  p0 = points[0];\n  sortPoints(points, 50);\n  v14 = 0;\n  do\n  {\n    v15 = v14;\n    v16 = &hull[v14];\n    if ( v14 > 1 )\n    {\n      do\n      {\n        x = v16[-1].x;\n        v18 = v16[-1].y;\n        v12 = v16;\n        v13 = (unsigned int)(v15 - 1);\n        --v16;\n        v11 = (unsigned int)((v3->x - x) * (v18 - v12[-2].y));\n        v10 = (unsigned int)(v3->y - v18);\n        if ( (int)v11 > (int)v10 * (x - v12[-2].x) )\n          break;\n        v15 = v13;\n      }\n      while ( (int)v13 > 1 );\n    }\n    v19 = *v3;\n    v20 = v15 + 1;\n    ++v3;\n    v14 = v15 + 1;\n    hull[v15] = v19;\n  }\n  while ( v3 != hull );\n  libmin_printf(\"Convex Hull Points (in order):\\n\", v10, v19, v11, v12, v13);\n  do\n  {\n    v21 = v3->y;\n    v22 = v3->x;\n    ++v3;\n    libmin_printf(\"(%d, %d)\\n\", v22, v21);\n  }\n  while ( &hull[v15 + 1] != v3 );\n  if ( v15 <= 2 )\n  {\n    v37 = 0;\n    v39 = 0;\n  }\n  else\n  {\n    v23 = v20 >> 2;\n    si128 = (__m128)_mm_load_si128((const __m128i *)hull);\n    v25 = _mm_add_epi32(\n            (__m128i)_mm_shuffle_ps(si128, *(__m128 *)&hull[2].x, 136),\n            (__m128i)_mm_shuffle_ps(si128, *(__m128 *)&hull[2].x, 221));\n    if ( v20 >> 2 != 1 )\n    {\n      v26 = (__m128)_mm_load_si128((const __m128i *)&hull[4]);\n      v25 = _mm_add_epi32(\n              v25,\n              _mm_add_epi32(\n                (__m128i)_mm_shuffle_ps(v26, *(__m128 *)&hull[6].x, 221),\n                (__m128i)_mm_shuffle_ps(v26, *(__m128 *)&hull[6].x, 136)));\n      if ( v23 != 2 )\n      {\n        v27 = (__m128)_mm_load_si128((const __m128i *)&hull[8]);\n        v25 = _mm_add_epi32(\n                v25,\n                _mm_add_epi32(\n                  (__m128i)_mm_shuffle_ps(v27, *(__m128 *)&hull[10].x, 221),\n                  (__m128i)_mm_shuffle_ps(v27, *(__m128 *)&hull[10].x, 136)));\n        if ( v23 != 3 )\n        {\n          v28 = (__m128)_mm_load_si128((const __m128i *)&hull[12]);\n          v25 = _mm_add_epi32(\n                  v25,\n                  _mm_add_epi32(\n                    (__m128i)_mm_shuffle_ps(v28, *(__m128 *)&hull[14].x, 221),\n                    (__m128i)_mm_shuffle_ps(v28, *(__m128 *)&hull[14].x, 136)));\n          if ( v23 != 4 )\n          {\n            v29 = (__m128)_mm_load_si128((const __m128i *)&hull[16]);\n            v25 = _mm_add_epi32(\n                    v25,\n                    _mm_add_epi32(\n                      (__m128i)_mm_shuffle_ps(v29, *(__m128 *)&hull[18].x, 221),\n                      (__m128i)_mm_shuffle_ps(v29, *(__m128 *)&hull[18].x, 136)));\n            if ( v23 != 5 )\n            {\n              v30 = (__m128)_mm_load_si128((const __m128i *)&hull[20]);\n              v25 = _mm_add_epi32(\n                      v25,\n                      _mm_add_epi32(\n                        (__m128i)_mm_shuffle_ps(v30, *(__m128 *)&hull[22].x, 221),\n                        (__m128i)_mm_shuffle_ps(v30, *(__m128 *)&hull[22].x, 136)));\n              if ( v23 != 6 )\n              {\n                v31 = (__m128)_mm_load_si128((const __m128i *)&hull[24]);\n                v25 = _mm_add_epi32(\n                        v25,\n                        _mm_add_epi32(\n                          (__m128i)_mm_shuffle_ps(v31, *(__m128 *)&hull[26].x, 221),\n                          (__m128i)_mm_shuffle_ps(v31, *(__m128 *)&hull[26].x, 136)));\n                if ( v23 != 7 )\n                {\n                  v32 = (__m128)_mm_load_si128((const __m128i *)&hull[28]);\n                  v25 = _mm_add_epi32(\n                          v25,\n                          _mm_add_epi32(\n                            (__m128i)_mm_shuffle_ps(v32, *(__m128 *)&hull[30].x, 221),\n                            (__m128i)_mm_shuffle_ps(v32, *(__m128 *)&hull[30].x, 136)));\n                  if ( v23 != 8 )\n                  {\n                    v33 = (__m128)_mm_load_si128((const __m128i *)&hull[32]);\n                    v25 = _mm_add_epi32(\n                            v25,\n                            _mm_add_epi32(\n                              (__m128i)_mm_shuffle_ps(v33, *(__m128 *)&hull[34].x, 221),\n                              (__m128i)_mm_shuffle_ps(v33, *(__m128 *)&hull[34].x, 136)));\n                    if ( v23 != 9 )\n                    {\n                      v34 = (__m128)_mm_load_si128((const __m128i *)&hull[36]);\n                      v25 = _mm_add_epi32(\n                              v25,\n                              _mm_add_epi32(\n                                (__m128i)_mm_shuffle_ps(v34, *(__m128 *)&hull[38].x, 221),\n                                (__m128i)_mm_shuffle_ps(v34, *(__m128 *)&hull[38].x, 136)));\n                      if ( v23 != 10 )\n                      {\n                        v35 = (__m128)_mm_load_si128((const __m128i *)&hull[40]);\n                        v25 = _mm_add_epi32(\n                                v25,\n                                _mm_add_epi32(\n                                  (__m128i)_mm_shuffle_ps(v35, *(__m128 *)&hull[42].x, 221),\n                                  (__m128i)_mm_shuffle_ps(v35, *(__m128 *)&hull[42].x, 136)));\n                        if ( v23 != 11 )\n                        {\n                          v36 = (__m128)_mm_load_si128((const __m128i *)&hull[44]);\n                          v25 = _mm_add_epi32(\n                                  v25,\n                                  _mm_add_epi32(\n                                    (__m128i)_mm_shuffle_ps(v36, *(__m128 *)&hull[46].x, 221),\n                                    (__m128i)_mm_shuffle_ps(v36, *(__m128 *)&hull[46].x, 136)));\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    v37 = v20 & 0xFFFFFFFC;\n    v38 = _mm_add_epi32(v25, _mm_srli_si128(v25, 8));\n    v39 = _mm_cvtsi128_si32(_mm_add_epi32(v38, _mm_srli_si128(v38, 4)));\n    if ( (v20 & 3) == 0 )\n    {\nLABEL_34:\n      libmin_printf(\"Hull size: %d, Checksum: %d\\n\", v20, v39);\n      libtarg_success();\n    }\n  }\n  v40 = v37 + 1;\n  v39 += hull[v37].y + hull[v37].x;\n  if ( v15 >= v37 && v15 - v37 != 0 )\n  {\n    v41 = v37 + 2;\n    v39 += hull[v40].y + hull[v40].x;\n    if ( v15 >= v40 && v15 - v40 != 0 )\n      v39 += hull[v41].x + hull[v41].y;\n  }\n  goto LABEL_34;\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  Point *v3;\n  Point *v4;\n  int y;\n  int *p_y;\n  int v7;\n  int v8;\n  Point v9;\n  long long v10;\n  long long v11;\n  Point *v12;\n  long long v13;\n  int v14;\n  int v15;\n  Point *v16;\n  int x;\n  int v18;\n  Point v19;\n  unsigned int v20;\n  int v21;\n  int v22;\n  unsigned int v23;\n  __m128 si128;\n  __m128i v25;\n  __m128 v26;\n  __m128 v27;\n  __m128 v28;\n  __m128 v29;\n  __m128 v30;\n  __m128 v31;\n  __m128 v32;\n  __m128 v33;\n  __m128 v34;\n  __m128 v35;\n  __m128 v36;\n  signed int v37;\n  __m128i v38;\n  int v39;\n  int v40;\n  int v41;\n  Point points[50];\n  Point hull[50];\n  unsigned long long vars328;\n  vars328 = __readfsqword(40u);\n  libmin_srand(42u);\n  v3 = points;\n  v4 = points;\n  do {\n    ++v4;\n    v4[-1].x = libmin_rand() % 101;\n    v4[-1].y = libmin_rand() % 101;\n  } while (v4 != hull);\n  y = points[0].y;\n  p_y = &points[1].y;\n  v7 = 1;\n  v8 = 0;\n  do {\n    while (*p_y < y) {\n      v8 = v7++;\n      y = *p_y;\n      p_y += 2;\n      if (v7 == 50) goto LABEL_10;\n    }\n    if (*p_y == y && *(p_y - 1) < points[v8].x) v8 = v7;\n    ++v7;\n    p_y += 2;\n  } while (v7 != 50);\nLABEL_10:\n  v9 = points[0];\n  v10 = 50LL;\n  points[0] = points[v8];\n  points[v8] = v9;\n  p0 = points[0];\n  sortPoints(points, 50);\n  v14 = 0;\n  do {\n    v15 = v14;\n    v16 = &hull[v14];\n    if (v14 > 1) {\n      do {\n        x = v16[-1].x;\n        v18 = v16[-1].y;\n        v12 = v16;\n        v13 = (unsigned int)(v15 - 1);\n        --v16;\n        v11 = (unsigned int)((v3->x - x) * (v18 - v12[-2].y));\n        v10 = (unsigned int)(v3->y - v18);\n        if ((int)v11 > (int)v10 * (x - v12[-2].x)) break;\n        v15 = v13;\n      } while ((int)v13 > 1);\n    }\n    v19 = *v3;\n    v20 = v15 + 1;\n    ++v3;\n    v14 = v15 + 1;\n    hull[v15] = v19;\n  } while (v3 != hull);\n  libmin_printf(\"Convex Hull Points (in order):\\n\", v10, v19, v11, v12, v13);\n  do {\n    v21 = v3->y;\n    v22 = v3->x;\n    ++v3;\n    libmin_printf(\"(%d, %d)\\n\", v22, v21);\n  } while (&hull[v15 + 1] != v3);\n  if (v15 <= 2) {\n    v37 = 0;\n    v39 = 0;\n  } else {\n    v23 = v20 >> 2;\n    si128 = (__m128)_mm_load_si128((const __m128i *)hull);\n    v25 = _mm_add_epi32(\n        (__m128i)_mm_shuffle_ps(si128, *(__m128 *)&hull[2].x, 136),\n        (__m128i)_mm_shuffle_ps(si128, *(__m128 *)&hull[2].x, 221));\n    if (v20 >> 2 != 1) {\n      v26 = (__m128)_mm_load_si128((const __m128i *)&hull[4]);\n      v25 = _mm_add_epi32(\n          v25, _mm_add_epi32(\n                   (__m128i)_mm_shuffle_ps(v26, *(__m128 *)&hull[6].x, 221),\n                   (__m128i)_mm_shuffle_ps(v26, *(__m128 *)&hull[6].x, 136)));\n      if (v23 != 2) {\n        v27 = (__m128)_mm_load_si128((const __m128i *)&hull[8]);\n        v25 = _mm_add_epi32(\n            v25,\n            _mm_add_epi32(\n                (__m128i)_mm_shuffle_ps(v27, *(__m128 *)&hull[10].x, 221),\n                (__m128i)_mm_shuffle_ps(v27, *(__m128 *)&hull[10].x, 136)));\n        if (v23 != 3) {\n          v28 = (__m128)_mm_load_si128((const __m128i *)&hull[12]);\n          v25 = _mm_add_epi32(\n              v25,\n              _mm_add_epi32(\n                  (__m128i)_mm_shuffle_ps(v28, *(__m128 *)&hull[14].x, 221),\n                  (__m128i)_mm_shuffle_ps(v28, *(__m128 *)&hull[14].x, 136)));\n          if (v23 != 4) {\n            v29 = (__m128)_mm_load_si128((const __m128i *)&hull[16]);\n            v25 = _mm_add_epi32(\n                v25,\n                _mm_add_epi32(\n                    (__m128i)_mm_shuffle_ps(v29, *(__m128 *)&hull[18].x, 221),\n                    (__m128i)_mm_shuffle_ps(v29, *(__m128 *)&hull[18].x, 136)));\n            if (v23 != 5) {\n              v30 = (__m128)_mm_load_si128((const __m128i *)&hull[20]);\n              v25 = _mm_add_epi32(\n                  v25, _mm_add_epi32((__m128i)_mm_shuffle_ps(\n                                         v30, *(__m128 *)&hull[22].x, 221),\n                                     (__m128i)_mm_shuffle_ps(\n                                         v30, *(__m128 *)&hull[22].x, 136)));\n              if (v23 != 6) {\n                v31 = (__m128)_mm_load_si128((const __m128i *)&hull[24]);\n                v25 = _mm_add_epi32(\n                    v25, _mm_add_epi32((__m128i)_mm_shuffle_ps(\n                                           v31, *(__m128 *)&hull[26].x, 221),\n                                       (__m128i)_mm_shuffle_ps(\n                                           v31, *(__m128 *)&hull[26].x, 136)));\n                if (v23 != 7) {\n                  v32 = (__m128)_mm_load_si128((const __m128i *)&hull[28]);\n                  v25 = _mm_add_epi32(\n                      v25,\n                      _mm_add_epi32((__m128i)_mm_shuffle_ps(\n                                        v32, *(__m128 *)&hull[30].x, 221),\n                                    (__m128i)_mm_shuffle_ps(\n                                        v32, *(__m128 *)&hull[30].x, 136)));\n                  if (v23 != 8) {\n                    v33 = (__m128)_mm_load_si128((const __m128i *)&hull[32]);\n                    v25 = _mm_add_epi32(\n                        v25,\n                        _mm_add_epi32((__m128i)_mm_shuffle_ps(\n                                          v33, *(__m128 *)&hull[34].x, 221),\n                                      (__m128i)_mm_shuffle_ps(\n                                          v33, *(__m128 *)&hull[34].x, 136)));\n                    if (v23 != 9) {\n                      v34 = (__m128)_mm_load_si128((const __m128i *)&hull[36]);\n                      v25 = _mm_add_epi32(\n                          v25,\n                          _mm_add_epi32((__m128i)_mm_shuffle_ps(\n                                            v34, *(__m128 *)&hull[38].x, 221),\n                                        (__m128i)_mm_shuffle_ps(\n                                            v34, *(__m128 *)&hull[38].x, 136)));\n                      if (v23 != 10) {\n                        v35 =\n                            (__m128)_mm_load_si128((const __m128i *)&hull[40]);\n                        v25 = _mm_add_epi32(\n                            v25, _mm_add_epi32(\n                                     (__m128i)_mm_shuffle_ps(\n                                         v35, *(__m128 *)&hull[42].x, 221),\n                                     (__m128i)_mm_shuffle_ps(\n                                         v35, *(__m128 *)&hull[42].x, 136)));\n                        if (v23 != 11) {\n                          v36 = (__m128)_mm_load_si128(\n                              (const __m128i *)&hull[44]);\n                          v25 = _mm_add_epi32(\n                              v25, _mm_add_epi32(\n                                       (__m128i)_mm_shuffle_ps(\n                                           v36, *(__m128 *)&hull[46].x, 221),\n                                       (__m128i)_mm_shuffle_ps(\n                                           v36, *(__m128 *)&hull[46].x, 136)));\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    v37 = v20 & 4294967292;\n    v38 = _mm_add_epi32(v25, _mm_srli_si128(v25, 8));\n    v39 = _mm_cvtsi128_si32(_mm_add_epi32(v38, _mm_srli_si128(v38, 4)));\n    if ((v20 & 3) == 0) {\n    LABEL_34:\n      libmin_printf(\"Hull size: %d, Checksum: %d\\n\", v20, v39);\n      libtarg_success();\n    }\n  }\n  v40 = v37 + 1;\n  v39 += hull[v37].y + hull[v37].x;\n  if (v15 >= v37 && v15 - v37 != 0) {\n    v41 = v37 + 2;\n    v39 += hull[v40].y + hull[v40].x;\n    if (v15 >= v40 && v15 - v40 != 0) v39 += hull[v41].x + hull[v41].y;\n  }\n  goto LABEL_34;\n}", "binary": "convex-hull/convex-hull.host.O3", "assembly": "<main>:\nendbr64\npush   %r14\nmov    $0x2a,%edi\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x330,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x328(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbp\nlea    0x190(%rsp),%r12\ncall   3b20 <libmin_srand>\nmov    %rbp,%rbx\nmov    %rbp,%r13\nnopl   0x0(%rax)\ncall   3b80 <libmin_rand>\nadd    $0x8,%r13\nmov    %eax,%ecx\nmov    %eax,%edx\nimul   $0x446f8657,%rcx,%rcx\nshr    $0x20,%rcx\nsub    %ecx,%edx\nshr    %edx\nadd    %ecx,%edx\nshr    $0x6,%edx\nimul   $0x65,%edx,%edx\nsub    %edx,%eax\nmov    %eax,-0x8(%r13)\ncall   3b80 <libmin_rand>\nmov    %eax,%ecx\nmov    %eax,%edx\nimul   $0x446f8657,%rcx,%rcx\nshr    $0x20,%rcx\nsub    %ecx,%edx\nshr    %edx\nadd    %ecx,%edx\nshr    $0x6,%edx\nimul   $0x65,%edx,%edx\nsub    %edx,%eax\nmov    %eax,-0x4(%r13)\ncmp    %r12,%r13\njne    1148 <main+0x48>\nmov    0x4(%rsp),%esi\nlea    0xc(%rsp),%rdx\nmov    $0x1,%eax\nxor    %edi,%edi\njmp    11ca <main+0xca>\nnop\njne    11be <main+0xbe>\nmovslq %edi,%rcx\nmov    (%rsp,%rcx,8),%ecx\ncmp    %ecx,-0x4(%rdx)\ncmovl  %eax,%edi\nadd    $0x1,%eax\nadd    $0x8,%rdx\ncmp    $0x32,%eax\nje     11e0 <main+0xe0>\nmov    (%rdx),%ecx\ncmp    %esi,%ecx\njge    11b0 <main+0xb0>\nmov    %eax,%edi\nadd    $0x1,%eax\nmov    %ecx,%esi\nadd    $0x8,%rdx\ncmp    $0x32,%eax\njne    11ca <main+0xca>\nmovslq %edi,%rdi\nmov    (%rsp),%rax\nmov    $0x32,%esi\nmov    (%rsp,%rdi,8),%rdx\nmov    %rdx,(%rsp)\nmov    %rax,(%rsp,%rdi,8)\nmov    (%rsp),%rax\nmov    %rbp,%rdi\nmov    %rax,0x506a(%rip)\ncall   1740 <sortPoints>\nxor    %eax,%eax\nnopl   (%rax)\nmovslq %eax,%rdx\nmov    %eax,%ebp\nlea    (%r12,%rdx,8),%rdx\ncmp    $0x1,%ebp\njle    1258 <main+0x158>\nmov    -0x8(%rdx),%eax\nmov    -0x4(%rdx),%edi\nmov    %rdx,%r8\nlea    -0x1(%rbp),%r9d\nmov    (%rbx),%esi\nsub    $0x8,%rdx\nmov    %edi,%ecx\nsub    -0xc(%r8),%ecx\nsub    %eax,%esi\nsub    -0x10(%r8),%eax\nimul   %esi,%ecx\nmov    0x4(%rbx),%esi\nsub    %edi,%esi\nimul   %esi,%eax\ncmp    %eax,%ecx\njg     1258 <main+0x158>\nmov    %r9d,%ebp\ncmp    $0x1,%ebp\njg     121e <main+0x11e>\nnopl   0x0(%rax)\nmov    (%rbx),%rdx\nlea    0x1(%rbp),%r13d\nmovslq %ebp,%r14\nadd    $0x8,%rbx\nmov    %r13d,%eax\nmov    %rdx,0x190(%rsp,%r14,8)\ncmp    %r12,%rbx\njne    1210 <main+0x110>\nlea    0x2d8b(%rip),%rdi\nxor    %eax,%eax\nlea    0x198(%rsp,%r14,8),%r14\ncall   3910 <libmin_printf>\nlea    0x2d95(%rip),%r12\nnopl   0x0(%rax,%rax,1)\nmov    0x4(%rbx),%edx\nmov    (%rbx),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x8,%rbx\ncall   3910 <libmin_printf>\ncmp    %rbx,%r14\njne    1298 <main+0x198>\ncmp    $0x2,%ebp\njle    156c <main+0x46c>\nmovdqa 0x190(%rsp),%xmm1\nmov    %r13d,%eax\nshr    $0x2,%eax\nmovdqa %xmm1,%xmm0\nshufps $0xdd,0x1a0(%rsp),%xmm1\nshufps $0x88,0x1a0(%rsp),%xmm0\npaddd  %xmm1,%xmm0\ncmp    $0x1,%eax\nje     14e6 <main+0x3e6>\nmovdqa 0x1b0(%rsp),%xmm1\nmovdqa %xmm1,%xmm2\nshufps $0xdd,0x1c0(%rsp),%xmm1\nshufps $0x88,0x1c0(%rsp),%xmm2\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\ncmp    $0x2,%eax\nje     14e6 <main+0x3e6>\nmovdqa 0x1d0(%rsp),%xmm1\nmovdqa %xmm1,%xmm2\nshufps $0xdd,0x1e0(%rsp),%xmm1\nshufps $0x88,0x1e0(%rsp),%xmm2\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\ncmp    $0x3,%eax\nje     14e6 <main+0x3e6>\nmovdqa 0x1f0(%rsp),%xmm1\nmovdqa %xmm1,%xmm2\nshufps $0xdd,0x200(%rsp),%xmm1\nshufps $0x88,0x200(%rsp),%xmm2\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\ncmp    $0x4,%eax\nje     14e6 <main+0x3e6>\nmovdqa 0x210(%rsp),%xmm1\nmovdqa %xmm1,%xmm2\nshufps $0xdd,0x220(%rsp),%xmm1\nshufps $0x88,0x220(%rsp),%xmm2\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\ncmp    $0x5,%eax\nje     14e6 <main+0x3e6>\nmovdqa 0x230(%rsp),%xmm1\nmovdqa %xmm1,%xmm2\nshufps $0xdd,0x240(%rsp),%xmm1\nshufps $0x88,0x240(%rsp),%xmm2\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\ncmp    $0x6,%eax\nje     14e6 <main+0x3e6>\nmovdqa 0x250(%rsp),%xmm1\nmovdqa %xmm1,%xmm2\nshufps $0xdd,0x260(%rsp),%xmm1\nshufps $0x88,0x260(%rsp),%xmm2\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\ncmp    $0x7,%eax\nje     14e6 <main+0x3e6>\nmovdqa 0x270(%rsp),%xmm1\nmovdqa %xmm1,%xmm2\nshufps $0xdd,0x280(%rsp),%xmm1\nshufps $0x88,0x280(%rsp),%xmm2\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\ncmp    $0x8,%eax\nje     14e6 <main+0x3e6>\nmovdqa 0x290(%rsp),%xmm1\nmovdqa %xmm1,%xmm2\nshufps $0xdd,0x2a0(%rsp),%xmm1\nshufps $0x88,0x2a0(%rsp),%xmm2\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\ncmp    $0x9,%eax\nje     14e6 <main+0x3e6>\nmovdqa 0x2b0(%rsp),%xmm1\nmovdqa %xmm1,%xmm2\nshufps $0xdd,0x2c0(%rsp),%xmm1\nshufps $0x88,0x2c0(%rsp),%xmm2\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\ncmp    $0xa,%eax\nje     14e6 <main+0x3e6>\nmovdqa 0x2d0(%rsp),%xmm1\nmovdqa %xmm1,%xmm2\nshufps $0xdd,0x2e0(%rsp),%xmm1\nshufps $0x88,0x2e0(%rsp),%xmm2\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\ncmp    $0xb,%eax\nje     14e6 <main+0x3e6>\nmovdqa 0x2f0(%rsp),%xmm1\nmovdqa %xmm1,%xmm2\nshufps $0xdd,0x300(%rsp),%xmm1\nshufps $0x88,0x300(%rsp),%xmm2\npaddd  %xmm2,%xmm1\npaddd  %xmm1,%xmm0\nmovdqa %xmm0,%xmm1\nmov    %r13d,%eax\npsrldq $0x8,%xmm1\nand    $0xfffffffc,%eax\npaddd  %xmm1,%xmm0\nmovdqa %xmm0,%xmm1\npsrldq $0x4,%xmm1\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%edx\ntest   $0x3,%r13b\nje     1556 <main+0x456>\nmovslq %eax,%rsi\nmov    0x190(%rsp,%rsi,8),%ecx\nadd    0x194(%rsp,%rsi,8),%ecx\nlea    0x1(%rax),%esi\nadd    %ecx,%edx\ncmp    %eax,%ebp\njle    1556 <main+0x456>\nmovslq %esi,%rdi\nadd    $0x2,%eax\nmov    0x190(%rsp,%rdi,8),%ecx\nadd    0x194(%rsp,%rdi,8),%ecx\nadd    %ecx,%edx\ncmp    %esi,%ebp\njle    1556 <main+0x456>\ncltq\nmov    0x194(%rsp,%rax,8),%ecx\nadd    0x190(%rsp,%rax,8),%ecx\nadd    %ecx,%edx\nmov    %r13d,%esi\nlea    0x2ad2(%rip),%rdi\nxor    %eax,%eax\ncall   3910 <libmin_printf>\ncall   1840 <libtarg_success>\nxor    %eax,%eax\nxor    %edx,%edx\njmp    1510 <main+0x410>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "orientation", "content": "// Returns the orientation of the triplet (p, q, r).\n//  0  : p, q, r are collinear\n// -1  : counterclockwise turn (left turn)\n//  1  : clockwise turn (right turn)\nint orientation(Point p, Point q, Point r) {\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0)\n        return 0;\n    return (val > 0) ? 1 : -1;\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O3.pseudo", "function_name": "orientation", "address": "0x1670", "label": "orientation", "content": "int __fastcall orientation(Point p, Point q, Point r)\n{\n  int result; // eax\n\n  result = (r.x - q.x) * (q.y - p.y) - (r.y - q.y) * (q.x - p.x);\n  if ( result )\n    return 2 * (result > 0) - 1;\n  return result;\n}\n"}, "pseudo_normalize": "int orientation(Point p, Point q, Point r) {\n  int result;\n  result = (r.x - q.x) * (q.y - p.y) - (r.y - q.y) * (q.x - p.x);\n  if (result) return 2 * (result > 0) - 1;\n  return result;\n}", "binary": "convex-hull/convex-hull.host.O3", "assembly": "<orientation>:\nendbr64\nmov    %rsi,%rcx\nmov    %rdi,%r8\nsar    $0x20,%rcx\nsar    $0x20,%r8\nmov    %ecx,%eax\nsub    %r8d,%eax\nmov    %edx,%r8d\nsar    $0x20,%rdx\nsub    %esi,%r8d\nsub    %ecx,%edx\nsub    %edi,%esi\nimul   %r8d,%eax\nimul   %edx,%esi\nsub    %esi,%eax\ntest   %eax,%eax\nje     16ac <orientation+0x3c>\nsetg   %al\nmovzbl %al,%eax\nlea    -0x1(%rax,%rax,1),%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "sortPoints", "content": "// A simple insertion sort for an array of Points.\nvoid sortPoints(Point points[], int n) {\n    for (int i = 1; i < n; i++) {\n        Point key = points[i];\n        int j = i - 1;\n        while (j >= 0 && comparePoints(points[j], key) > 0) {\n            points[j + 1] = points[j];\n            j--;\n        }\n        points[j + 1] = key;\n    }\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O3.pseudo", "function_name": "sortPoints", "address": "0x1740", "label": "sortPoints", "content": "void __fastcall sortPoints(Point *points, int n)\n{\n  __int64 v2; // rbp\n  __m128i v3; // xmm0\n  __int64 v4; // rax\n  int v5; // r10d\n  int v6; // r11d\n  int x; // edx\n  int v8; // ecx\n  int v9; // r8d\n  int v10; // edx\n  int v11; // ecx\n  Point *v12; // rax\n\n  if ( n > 1 )\n  {\n    v2 = 0LL;\n    do\n    {\n      v3 = _mm_loadl_epi64((const __m128i *)&points[v2 + 1]);\n      v4 = v2;\n      v5 = _mm_cvtsi128_si32(v3);\n      v6 = _mm_cvtsi128_si32(_mm_shuffle_epi32(v3, 229));\n      do\n      {\n        x = points[v4].x;\n        v8 = v5 - x;\n        v9 = points[v4].y - p0.y;\n        v10 = x - p0.x;\n        v11 = v9 * v8 - v10 * (v6 - points[v4].y);\n        if ( v11 )\n        {\n          if ( v11 <= 0 )\n          {\n            v12 = &points[(int)v4 + 1];\n            goto LABEL_10;\n          }\n        }\n        else if ( v9 * v9 + v10 * v10 <= (v6 - p0.y) * (v6 - p0.y) + (v5 - p0.x) * (v5 - p0.x) )\n        {\n          v12 = &points[(int)v4 + 1];\n          goto LABEL_10;\n        }\n        points[v4 + 1] = points[v4];\n        --v4;\n      }\n      while ( (_DWORD)v4 != -1 );\n      v12 = points;\nLABEL_10:\n      ++v2;\n      *v12 = *(Point *)v3.m128i_i8;\n    }\n    while ( n - 1 != v2 );\n  }\n}\n"}, "pseudo_normalize": "void sortPoints(Point *points, int n) {\n  long long v2;\n  __m128i v3;\n  long long v4;\n  int v5;\n  int v6;\n  int x;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  Point *v12;\n  if (n > 1) {\n    v2 = 0LL;\n    do {\n      v3 = _mm_loadl_epi64((const __m128i *)&points[v2 + 1]);\n      v4 = v2;\n      v5 = _mm_cvtsi128_si32(v3);\n      v6 = _mm_cvtsi128_si32(_mm_shuffle_epi32(v3, 229));\n      do {\n        x = points[v4].x;\n        v8 = v5 - x;\n        v9 = points[v4].y - p0.y;\n        v10 = x - p0.x;\n        v11 = v9 * v8 - v10 * (v6 - points[v4].y);\n        if (v11) {\n          if (v11 <= 0) {\n            v12 = &points[(int)v4 + 1];\n            goto LABEL_10;\n          }\n        } else if (v9 * v9 + v10 * v10 <=\n                   (v6 - p0.y) * (v6 - p0.y) + (v5 - p0.x) * (v5 - p0.x)) {\n          v12 = &points[(int)v4 + 1];\n          goto LABEL_10;\n        }\n        points[v4 + 1] = points[v4];\n        --v4;\n      } while ((uint32_t)v4 != -1);\n      v12 = points;\n    LABEL_10:\n      ++v2;\n      *v12 = *(Point *)v3.m128i_i8;\n    } while (n - 1 != v2);\n  }\n}", "binary": "convex-hull/convex-hull.host.O3", "assembly": "<sortPoints>:\nendbr64\ncmp    $0x1,%esi\njle    1835 <sortPoints+0xf5>\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nlea    -0x1(%rsi),%r12d\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nlea    0x4b0c(%rip),%rbx\nnopl   0x0(%rax)\nmovq   0x8(%rdi,%rbp,8),%xmm0\nmov    %rbp,%rax\npshufd $0xe5,%xmm0,%xmm1\nmovd   %xmm0,%r10d\nmovd   %xmm1,%r11d\njmp    17a0 <sortPoints+0x60>\nnopw   0x0(%rax,%rax,1)\njle    1808 <sortPoints+0xc8>\nmov    (%rdi,%rax,8),%rdx\nmov    %rdx,0x8(%rdi,%rax,8)\nsub    $0x1,%rax\ncmp    $0xffffffff,%eax\nje     1830 <sortPoints+0xf0>\nmov    (%rdi,%rax,8),%esi\nmov    0x4(%rdi,%rax,8),%r15d\nmov    %r10d,%ecx\nmov    %eax,%r9d\nmov    (%rbx),%r14d\nmov    0x4abc(%rip),%r13d\nmov    %esi,%edx\nsub    %esi,%ecx\nmov    %r15d,%r8d\nmov    %r11d,%esi\nsub    %r13d,%r8d\nsub    %r14d,%edx\nsub    %r15d,%esi\nimul   %r8d,%ecx\nimul   %edx,%esi\nsub    %esi,%ecx\ntest   %ecx,%ecx\njne    1788 <sortPoints+0x48>\nmov    %r10d,%ecx\nimul   %edx,%edx\nmov    %r11d,%esi\nsub    %r14d,%ecx\nimul   %r8d,%r8d\nsub    %r13d,%esi\nimul   %ecx,%ecx\nimul   %esi,%esi\nadd    %r8d,%edx\nadd    %esi,%ecx\ncmp    %ecx,%edx\njg     178a <sortPoints+0x4a>\nlea    0x1(%rax),%eax\ncltq\nlea    (%rdi,%rax,8),%rax\njmp    1813 <sortPoints+0xd3>\nnopl   (%rax)\nadd    $0x1,%r9d\nmovslq %r9d,%r9\nlea    (%rdi,%r9,8),%rax\nadd    $0x1,%rbp\nmovq   %xmm0,(%rax)\ncmp    %rbp,%r12\njne    1768 <sortPoints+0x28>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnop\nmov    %rdi,%rax\njmp    1813 <sortPoints+0xd3>\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PFunc_1", "content": " /* PProc_8 */\n\n\nEnumeration PFunc_1 (Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val)\n/*************************************************/\n    /* executed three times                                         */\n    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */\n    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */\n    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */\n{\n  Capital_Letter        Ch_1_Loc;\n  Capital_Letter        Ch_2_Loc;\n\n  Ch_1_Loc = Ch_1_Par_Val;\n  Ch_2_Loc = Ch_1_Loc;\n  if (Ch_2_Loc != Ch_2_Par_Val)\n    /* then, executed */\n    return (Ident_1);\n  else  /* not executed */\n     {\n     Ch_1_Glob = Ch_1_Loc;\n     return (Ident_2);\n     }\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O3.pseudo", "function_name": "PFunc_1", "address": "0x1980", "label": "PFunc_1", "content": "Enumeration __fastcall PFunc_1(Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val)\n{\n  Enumeration result; // eax\n\n  result = Ident_1;\n  if ( Ch_1_Par_Val == Ch_2_Par_Val )\n  {\n    Ch_1_Glob[0] = Ch_1_Par_Val;\n    return 1;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "Enumeration PFunc_1(Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val) {\n  Enumeration result;\n  result = Ident_1;\n  if (Ch_1_Par_Val == Ch_2_Par_Val) {\n    Ch_1_Glob[0] = Ch_1_Par_Val;\n    return 1;\n  }\n  return result;\n}", "binary": "dhrystone/dhrystone.host.O3", "assembly": "<PFunc_1>:\nendbr64\nxor    %eax,%eax\ncmp    %sil,%dil\nje     1990 <PFunc_1+0x10>\nret\nnopl   0x0(%rax)\nmov    %dil,0x58ed(%rip)\nmov    $0x1,%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PFunc_2", "content": " /* PFunc_1 */\n\n\nBoolean PFunc_2 (Str_30 Str_1_Par_Ref, Str_30 Str_2_Par_Ref)\n/*************************************************/\n    /* executed once */\n    /* Str_1_Par_Ref == \"DHRYSTONE PROGRAM, 1'ST STRING\" */\n    /* Str_2_Par_Ref == \"DHRYSTONE PROGRAM, 2'ND STRING\" */\n{\n  REG One_Thirty        Int_Loc;\n      Capital_Letter    Ch_Loc = 0;\n\n  Int_Loc = 2;\n  while (Int_Loc <= 2) /* loop body executed once */\n    if (PFunc_1 (Str_1_Par_Ref[Int_Loc], Str_2_Par_Ref[Int_Loc+1]) == Ident_1)\n      /* then, executed */\n       {\n       Ch_Loc = 'A';\n       Int_Loc += 1;\n       } /* if, while */\n  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')\n    /* then, not executed */\n    Int_Loc = 7;\n  if (Ch_Loc == 'R')\n    /* then, not executed */\n    return (true);\n  else /* executed */\n     {\n     if (libmin_strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)\n      /* then, not executed */\n        {\n        Int_Loc += 7;\n        Int_Glob = Int_Loc;\n        return (true);\n        }\n     else /* executed */\n        return (false);\n     } /* if Ch_Loc */\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O3.pseudo", "function_name": "PFunc_2", "address": "0x19a0", "label": "PFunc_2", "content": "Boolean __fastcall PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref)\n{\n  int v2; // eax\n  Boolean v3; // r8d\n\n  if ( Str_2_Par_Ref[3] == Str_1_Par_Ref[2] )\n  {\n    while ( 1 )\n      ;\n  }\n  v2 = libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref);\n  v3 = 0;\n  if ( v2 > 0 )\n  {\n    Int_Glob = 10;\n    return 1;\n  }\n  return v3;\n}\n"}, "pseudo_normalize": "Boolean PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref) {\n  int v2;\n  Boolean v3;\n  if (Str_2_Par_Ref[3] == Str_1_Par_Ref[2]) {\n    while (1)\n      ;\n  }\n  v2 = libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref);\n  v3 = 0;\n  if (v2 > 0) {\n    Int_Glob = 10;\n    return 1;\n  }\n  return v3;\n}", "binary": "dhrystone/dhrystone.host.O3", "assembly": "<PFunc_2>:\nendbr64\nmovzbl 0x2(%rdi),%eax\ncmp    %al,0x3(%rsi)\nje     19d5 <PFunc_2+0x35>\nsub    $0x8,%rsp\ncall   3cd0 <libmin_strcmp>\nxor    %r8d,%r8d\ntest   %eax,%eax\njle    19cd <PFunc_2+0x2d>\nmovl   $0xa,0x58c1(%rip)\nmov    $0x1,%r8d\nmov    %r8d,%eax\nadd    $0x8,%rsp\nret\njmp    19d5 <PFunc_2+0x35>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PFunc_3", "content": " /* PFunc_2 */\n\n\nBoolean PFunc_3 (Enumeration Enum_Par_Val)\n/***************************/\n    /* executed once        */\n    /* Enum_Par_Val == Ident_3 */\n{\n  Enumeration Enum_Loc;\n\n  Enum_Loc = Enum_Par_Val;\n  if (Enum_Loc == Ident_3)\n    /* then, executed */\n    return (true);\n  else /* not executed */\n    return (false);\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O3.pseudo", "function_name": "PFunc_3", "address": "0x19e0", "label": "PFunc_3", "content": "Boolean __fastcall PFunc_3(Enumeration Enum_Par_Val)\n{\n  return Enum_Par_Val == Ident_3;\n}\n"}, "pseudo_normalize": "", "binary": "dhrystone/dhrystone.host.O3", "assembly": "<PFunc_3>:\nendbr64\nxor    %eax,%eax\ncmp    $0x2,%edi\nsete   %al\nret\nnopl   (%rax)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PProc_6", "content": "int\nPProc_6 (Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par)\n/*********************************/\n    /* executed once */\n    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */\n{\n  *Enum_Ref_Par = Enum_Val_Par;\n  if (! PFunc_3 (Enum_Val_Par))\n    /* then, not executed */\n    *Enum_Ref_Par = Ident_4;\n  switch (Enum_Val_Par)\n     {\n     case Ident_1:\n        *Enum_Ref_Par = Ident_1;\n        break;\n     case Ident_2:\n        if (Int_Glob > 100)\n           /* then */\n           *Enum_Ref_Par = Ident_1;\n        else\n           *Enum_Ref_Par = Ident_4;\n        break;\n     case Ident_3: /* executed */\n        *Enum_Ref_Par = Ident_2;\n        break;\n     case Ident_4:\n        break;\n     case Ident_5:\n        *Enum_Ref_Par = Ident_3;\n        break;\n     } /* switch */\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O3.pseudo", "function_name": "PProc_6", "address": "0x18b0", "label": "PProc_6", "content": "int __fastcall PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par)\n{\n  if ( Enum_Val_Par == Ident_3 )\n  {\n    *Enum_Ref_Par = Ident_2;\n    return 0;\n  }\n  else\n  {\n    *Enum_Ref_Par = Ident_4;\n    if ( Enum_Val_Par == Ident_2 )\n    {\n      if ( Int_Glob <= 100 )\n        return 0;\n    }\n    else if ( (unsigned int)Enum_Val_Par > Ident_2 )\n    {\n      if ( Enum_Val_Par == Ident_5 )\n        *Enum_Ref_Par = Ident_3;\n      return 0;\n    }\n    *Enum_Ref_Par = Ident_1;\n    return 0;\n  }\n}\n"}, "pseudo_normalize": "int PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par) {\n  if (Enum_Val_Par == Ident_3) {\n    *Enum_Ref_Par = Ident_2;\n    return 0;\n  } else {\n    *Enum_Ref_Par = Ident_4;\n    if (Enum_Val_Par == Ident_2) {\n      if (Int_Glob <= 100) return 0;\n    } else if ((unsigned int)Enum_Val_Par > Ident_2) {\n      if (Enum_Val_Par == Ident_5) *Enum_Ref_Par = Ident_3;\n      return 0;\n    }\n    *Enum_Ref_Par = Ident_1;\n    return 0;\n  }\n}", "binary": "dhrystone/dhrystone.host.O3", "assembly": "<PProc_6>:\nendbr64\ncmp    $0x2,%edi\nje     18f0 <PProc_6+0x40>\nmovl   $0x3,(%rsi)\ncmp    $0x1,%edi\nje     18d8 <PProc_6+0x28>\njbe    18e1 <PProc_6+0x31>\ncmp    $0x4,%edi\njne    18d1 <PProc_6+0x21>\nmovl   $0x2,(%rsi)\nxor    %eax,%eax\nret\nnopl   0x0(%rax)\ncmpl   $0x64,0x59a9(%rip)\njle    18d1 <PProc_6+0x21>\nmovl   $0x0,(%rsi)\nxor    %eax,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmovl   $0x1,(%rsi)\nxor    %eax,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PProc_7", "content": " /* PProc_6 */\n\n\nint\nPProc_7 (int Int_1_Par_Val, int Int_2_Par_Val, int *Int_Par_Ref)\n/**********************************************/\n    /* executed three times                                      */\n    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */\n    /*                  Int_Par_Ref becomes 7                    */\n    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */\n    /*                  Int_Par_Ref becomes 17                   */\n    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */\n    /*                  Int_Par_Ref becomes 18                   */\n{\n  One_Fifty Int_Loc;\n\n  Int_Loc = Int_1_Par_Val + 2;\n  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O3.pseudo", "function_name": "PProc_7", "address": "0x1900", "label": "PProc_7", "content": "int __fastcall PProc_7(int Int_1_Par_Val, int Int_2_Par_Val, int *Int_Par_Ref)\n{\n  *Int_Par_Ref = Int_1_Par_Val + Int_2_Par_Val + 2;\n  return 0;\n}\n"}, "pseudo_normalize": "", "binary": "dhrystone/dhrystone.host.O3", "assembly": "<PProc_7>:\nendbr64\nlea    0x2(%rdi,%rsi,1),%eax\nmov    %eax,(%rdx)\nxor    %eax,%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PProc_8", "content": " /* PProc_7 */\n\n\nint PProc_8 (Arr_1_Dim Arr_1_Par_Ref,\n             Arr_2_Dim Arr_2_Par_Ref,\n             int Int_1_Par_Val,\n             int Int_2_Par_Val)\n/*********************************************************************/\n    /* executed once      */\n    /* Int_Par_Val_1 == 3 */\n    /* Int_Par_Val_2 == 7 */\n{\n  REG One_Fifty Int_Index;\n  REG One_Fifty Int_Loc;\n\n  Int_Loc = Int_1_Par_Val + 5;\n  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;\n  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];\n  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;\n  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)\n     Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;\n  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;\n  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];\n  Int_Glob = 5;\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O3.pseudo", "function_name": "PProc_8", "address": "0x1910", "label": "PProc_8", "content": "int __fastcall PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val, int Int_2_Par_Val)\n{\n  int v4; // r8d\n  __int64 v6; // rdx\n  int *v7; // r9\n  __int64 v8; // rsi\n  int *v9; // rcx\n\n  v4 = Int_1_Par_Val + 5;\n  v6 = Int_1_Par_Val;\n  v7 = &Arr_1_Par_Ref[v4];\n  *(_QWORD *)v7 = _mm_shuffle_epi32(_mm_cvtsi32_si128(Int_2_Par_Val), 224).m128i_u64[0];\n  v7[30] = v4;\n  v8 = 50LL * v4;\n  v9 = &(*Arr_2_Par_Ref)[v8 + v6];\n  ++v9[4];\n  v9[5] = v4;\n  v9[6] = v4;\n  LODWORD(v9) = *v7;\n  Int_Glob = 5;\n  (*Arr_2_Par_Ref)[v8 + 1005 + v6] = (int)v9;\n  return 0;\n}\n"}, "pseudo_normalize": "int PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val,\n            int Int_2_Par_Val) {\n  int v4;\n  long long v6;\n  int *v7;\n  long long v8;\n  int *v9;\n  v4 = Int_1_Par_Val + 5;\n  v6 = Int_1_Par_Val;\n  v7 = &Arr_1_Par_Ref[v4];\n  *(uint64_t *)v7 =\n      _mm_shuffle_epi32(_mm_cvtsi32_si128(Int_2_Par_Val), 224).m128i_u64[0];\n  v7[30] = v4;\n  v8 = 50LL * v4;\n  v9 = &(*Arr_2_Par_Ref)[v8 + v6];\n  ++v9[4];\n  v9[5] = v4;\n  v9[6] = v4;\n  LODWORD(v9) = *v7;\n  Int_Glob = 5;\n  (*Arr_2_Par_Ref)[v8 + 1005 + v6] = (int)v9;\n  return 0;\n}", "binary": "dhrystone/dhrystone.host.O3", "assembly": "<PProc_8>:\nendbr64\nlea    0x5(%rdx),%r8d\nmov    %rsi,%rax\nmovd   %ecx,%xmm1\nmovslq %edx,%rdx\nmovslq %r8d,%r10\npshufd $0xe0,%xmm1,%xmm0\nshl    $0x2,%rdx\nlea    0x0(,%r10,4),%rsi\nlea    (%rdi,%rsi,1),%r9\nmovq   %xmm0,(%r9)\nmov    %r8d,0x78(%rdi,%rsi,1)\nadd    %r10,%rsi\nlea    (%rsi,%rsi,4),%rsi\nshl    $0x3,%rsi\nlea    (%rsi,%rdx,1),%rcx\nadd    %rax,%rcx\nadd    %rsi,%rax\naddl   $0x1,0x10(%rcx)\nmov    %r8d,0x14(%rcx)\nmov    %r8d,0x18(%rcx)\nmov    (%r9),%ecx\nmovl   $0x5,0x5916(%rip)\nmov    %ecx,0xfb4(%rdx,%rax,1)\nxor    %eax,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "main", "content": "int\nmain(void)\n/*****/\n\n  /* main program, corresponds to procedures        */\n  /* Main and Proc_0 in the Ada version             */\n{\n  int nofr = 10;\n\n        One_Fifty       Int_1_Loc;\n  REG   One_Fifty       Int_2_Loc;\n        One_Fifty       Int_3_Loc;\n  REG   char            Ch_Index;\n        Enumeration     Enum_Loc;\n        Str_30          Str_1_Loc;\n        Str_30          Str_2_Loc;\n  REG   int             Run_Index;\n  REG   int             Pnumber_of_runs;\n\n  /* Initializations */\n\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n\n  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;\n  Ptr_Glob->Discr                       = Ident_1;\n  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;\n  Ptr_Glob->variant.var_1.Int_Comp      = 40;\n  libmin_strcpy (Ptr_Glob->variant.var_1.Str_Comp,\n          \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy (Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n\n  Arr_2_Glob [8][7] = 10;\n        /* Was missing in published program. Without this statement,    */\n        /* Arr_2_Glob [8][7] would have an undefined value.             */\n        /* Warning: With 16-Bit processors and Pnumber_of_runs > 32000,  */\n        /* overflow may occur for this array element.                   */\n\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n\n  Pnumber_of_runs = nofr; // HCH\n\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\",Pnumber_of_runs);\n\n  /***************/\n  /* Start timer */\n  /***************/\n\n  for (Run_Index = 1; Run_Index <= Pnumber_of_runs; ++Run_Index)\n  {\n\n    Proc_5();\n    Proc_4();\n      /* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */\n    Int_1_Loc = 2;\n    Int_2_Loc = 3;\n    libmin_strcpy (Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = ! PFunc_2 (Str_1_Loc, Str_2_Loc);\n      /* Bool_Glob == 1 */\n    while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */\n    {\n      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;\n        /* Int_3_Loc == 7 */\n      PProc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);\n        /* Int_3_Loc == 7 */\n      Int_1_Loc += 1;\n    } /* while */\n      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */\n    PProc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);\n      /* Int_Glob == 5 */\n    Proc_1 (Ptr_Glob);\n    for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)\n                             /* loop body executed twice */\n    {\n      if (Enum_Loc == PFunc_1 (Ch_Index, 'C'))\n          /* then, not executed */\n        {\n        PProc_6 (Ident_1, &Enum_Loc);\n        libmin_strcpy (Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        Int_2_Loc = Run_Index;\n        Int_Glob = Run_Index;\n        }\n    }\n      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */\n    Int_2_Loc = Int_2_Loc * Int_1_Loc;\n    Int_1_Loc = Int_2_Loc / Int_3_Loc;\n    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;\n      /* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */\n    Proc_2 (&Int_1_Loc);\n      /* Int_1_Loc == 5 */\n\n  } /* loop \"for Run_Index\" */\n\n  /**************/\n  /* Stop timer */\n  /**************/\n\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", Ch_1_Glob);\n  libmin_printf(\"        should be:   %c\\n\", 'A');\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", Ch_2_Glob);\n  libmin_printf(\"        should be:   %c\\n\", 'B');\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\",\n         Next_Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\",\n         Next_Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\",\n                                Next_Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", Int_2_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", Int_3_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int v3; // ebx\n  int v4; // eax\n  __m128i *v5; // rax\n  record *Ptr_Comp; // rdx\n  const __m128i *v7; // roff\n  __m128i v8; // xmm0\n  __int64 v9; // rcx\n  const __m128i *v10; // rcx\n  char v11; // cl\n  int v12; // r14d\n  __int64 v13; // rsi\n  int v14; // r9d\n  int v15; // r11d\n  int v16; // r8d\n  int v17; // eax\n  __int32 v18; // eax\n  Enumeration Enum_Loc; // [rsp+4h] [rbp-94h]\n  One_Fifty Int_1_Loc; // [rsp+8h] [rbp-90h]\n  int v21; // [rsp+Ch] [rbp-8Ch]\n  char Str_1_Loc[32]; // [rsp+10h] [rbp-88h] BYREF\n  char Str_2_Loc[40]; // [rsp+30h] [rbp-68h] BYREF\n  unsigned __int64 v24; // [rsp+58h] [rbp-40h]\n\n  v24 = __readfsqword(0x28u);\n  Ptr_Glob = &rec2;\n  rec2.variant.var_1.Int_Comp = 40;\n  v3 = 1;\n  Next_Ptr_Glob = &rec1;\n  rec2.Ptr_Comp = &rec1;\n  *(_QWORD *)&rec2.Discr = 0x200000000LL;\n  libmin_strcpy(rec2.variant.var_1.Str_Comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", 10);\n  while ( 1 )\n  {\n    Ch_1_Glob[0] = 65;\n    Bool_Glob = 1;\n    Ch_2_Glob[0] = 66;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    if ( Str_2_Loc[3] == Str_1_Loc[2] )\n    {\n      while ( 1 )\n        ;\n    }\n    v4 = libmin_strcmp(Str_1_Loc, Str_2_Loc);\n    *(_QWORD *)&Arr_2_Glob[8][8] = 0x800000008LL;\n    *(_QWORD *)&Arr_1_Glob[8] = 0x700000007LL;\n    Arr_1_Glob[38] = 8;\n    ++Arr_2_Glob[8][7];\n    Bool_Glob = v4 <= 0;\n    v5 = (__m128i *)Ptr_Glob;\n    Arr_2_Glob[28][8] = 7;\n    Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    v7 = (const __m128i *)Ptr_Glob;\n    v8 = _mm_loadu_si128((const __m128i *)Ptr_Glob);\n    Int_Glob = 5;\n    *(__m128i *)&Ptr_Comp->Ptr_Comp = v8;\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 2) = _mm_loadu_si128(v7 + 1);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 10) = _mm_loadu_si128(v5 + 2);\n    v9 = v5[3].m128i_i64[0];\n    Ptr_Comp->variant.var_1.Int_Comp = 5;\n    *(_QWORD *)(&Ptr_Comp->variant.var_3 + 18) = v9;\n    Ptr_Comp->Ptr_Comp = (record *)v5->m128i_i64[0];\n    v10 = (const __m128i *)v5->m128i_i64[0];\n    Ptr_Comp->Ptr_Comp = (record *)v5->m128i_i64[0];\n    v5[1].m128i_i32[0] = 17;\n    if ( Ptr_Comp->Discr )\n    {\n      *v5 = _mm_loadu_si128(v10);\n      v5[1] = _mm_loadu_si128(v10 + 1);\n      v5[2] = _mm_loadu_si128(v10 + 2);\n      v5[3].m128i_i64[0] = v10[3].m128i_i64[0];\n    }\n    else\n    {\n      v18 = v5->m128i_i32[3];\n      Ptr_Comp->variant.var_1.Int_Comp = 6;\n      if ( v18 == 2 )\n      {\n        Ptr_Comp->variant.var_1.Enum_Comp = Ident_2;\n      }\n      else\n      {\n        Ptr_Comp->variant.var_1.Enum_Comp = Ident_4;\n        if ( v18 == 4 )\n        {\n          Ptr_Comp->variant.var_1.Enum_Comp = Ident_3;\n        }\n        else if ( !v18 )\n        {\n          Ptr_Comp->variant.var_1.Enum_Comp = Ident_1;\n        }\n      }\n      Ptr_Comp->Ptr_Comp = (record *)v10;\n      Ptr_Comp->variant.var_1.Int_Comp = 18;\n    }\n    v11 = Ch_2_Glob[0];\n    v12 = 65;\n    v13 = 3LL;\n    v14 = 1;\n    v15 = 13;\n    v16 = 1;\n    if ( Ch_2_Glob[0] > 64 )\n    {\n      while ( (char)++v12 <= v11 )\n      {\n        while ( 1 )\n        {\n          v17 = 0;\n          if ( (_BYTE)v12 == 67 )\n          {\n            Ch_1_Glob[0] = 67;\n            v17 = 1;\n          }\n          if ( v14 != v17 )\n            break;\n          ++v12;\n          libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n          Int_Glob = v3;\n          v13 = v3;\n          v14 = 0;\n          v11 = Ch_2_Glob[0];\n          if ( (char)v12 > Ch_2_Glob[0] )\n            goto LABEL_11;\n        }\n      }\nLABEL_11:\n      v16 = 3 * (int)v13 / 7;\n      v15 = 7 * (3 * v13 - 7) - v16;\n    }\n    if ( Ch_1_Glob[0] == 65 )\n      v16 = v16 + 9 - Int_Glob;\n    if ( ++v3 == 11 )\n    {\n      v21 = v15;\n      Int_1_Loc = v16;\n      Enum_Loc = v14;\n      libmin_printf(\"Execution ends\\n\", v13);\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 65LL);\n      libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 66LL);\n      libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n      libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n      libmin_printf((char *)\"Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 2);\n      libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 17);\n      libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Next_Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent), same as above\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\", Next_Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"  Int_Comp:          %d\\n\", Next_Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 18);\n      libmin_printf(\"  Str_Comp:          %s\\n\", Next_Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Int_2_Loc:           %d\\n\", v21);\n      libmin_printf(\"        should be:   %d\\n\", 13);\n      libmin_printf(\"Int_3_Loc:           %d\\n\", 7);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n      libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  int v4;\n  __m128i *v5;\n  record *Ptr_Comp;\n  const __m128i *v7;\n  __m128i v8;\n  long long v9;\n  const __m128i *v10;\n  char v11;\n  int v12;\n  long long v13;\n  int v14;\n  int v15;\n  int v16;\n  int v17;\n  int v18;\n  Enumeration Enum_Loc;\n  One_Fifty Int_1_Loc;\n  int v21;\n  char Str_1_Loc[32];\n  char Str_2_Loc[40];\n  unsigned long long v24;\n  v24 = __readfsqword(40u);\n  Ptr_Glob = &rec2;\n  rec2.variant.var_1.Int_Comp = 40;\n  v3 = 1;\n  Next_Ptr_Glob = &rec1;\n  rec2.Ptr_Comp = &rec1;\n  *(uint64_t *)&rec2.Discr = 8589934592LL;\n  libmin_strcpy(rec2.variant.var_1.Str_Comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", 10);\n  while (1) {\n    Ch_1_Glob[0] = 65;\n    Bool_Glob = 1;\n    Ch_2_Glob[0] = 66;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    if (Str_2_Loc[3] == Str_1_Loc[2]) {\n      while (1)\n        ;\n    }\n    v4 = libmin_strcmp(Str_1_Loc, Str_2_Loc);\n    *(uint64_t *)&Arr_2_Glob[8][8] = 34359738376LL;\n    *(uint64_t *)&Arr_1_Glob[8] = 30064771079LL;\n    Arr_1_Glob[38] = 8;\n    ++Arr_2_Glob[8][7];\n    Bool_Glob = v4 <= 0;\n    v5 = (__m128i *)Ptr_Glob;\n    Arr_2_Glob[28][8] = 7;\n    Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    v7 = (const __m128i *)Ptr_Glob;\n    v8 = _mm_loadu_si128((const __m128i *)Ptr_Glob);\n    Int_Glob = 5;\n    *(__m128i *)&Ptr_Comp->Ptr_Comp = v8;\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 2) = _mm_loadu_si128(v7 + 1);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 10) = _mm_loadu_si128(v5 + 2);\n    v9 = v5[3].m128i_i64[0];\n    Ptr_Comp->variant.var_1.Int_Comp = 5;\n    *(uint64_t *)(&Ptr_Comp->variant.var_3 + 18) = v9;\n    Ptr_Comp->Ptr_Comp = (record *)v5->m128i_i64[0];\n    v10 = (const __m128i *)v5->m128i_i64[0];\n    Ptr_Comp->Ptr_Comp = (record *)v5->m128i_i64[0];\n    v5[1].m128i_i32[0] = 17;\n    if (Ptr_Comp->Discr) {\n      *v5 = _mm_loadu_si128(v10);\n      v5[1] = _mm_loadu_si128(v10 + 1);\n      v5[2] = _mm_loadu_si128(v10 + 2);\n      v5[3].m128i_i64[0] = v10[3].m128i_i64[0];\n    } else {\n      v18 = v5->m128i_i32[3];\n      Ptr_Comp->variant.var_1.Int_Comp = 6;\n      if (v18 == 2) {\n        Ptr_Comp->variant.var_1.Enum_Comp = Ident_2;\n      } else {\n        Ptr_Comp->variant.var_1.Enum_Comp = Ident_4;\n        if (v18 == 4) {\n          Ptr_Comp->variant.var_1.Enum_Comp = Ident_3;\n        } else if (!v18) {\n          Ptr_Comp->variant.var_1.Enum_Comp = Ident_1;\n        }\n      }\n      Ptr_Comp->Ptr_Comp = (record *)v10;\n      Ptr_Comp->variant.var_1.Int_Comp = 18;\n    }\n    v11 = Ch_2_Glob[0];\n    v12 = 65;\n    v13 = 3LL;\n    v14 = 1;\n    v15 = 13;\n    v16 = 1;\n    if (Ch_2_Glob[0] > 64) {\n      while ((char)++v12 <= v11) {\n        while (1) {\n          v17 = 0;\n          if ((uint8_t)v12 == 67) {\n            Ch_1_Glob[0] = 67;\n            v17 = 1;\n          }\n          if (v14 != v17) break;\n          ++v12;\n          libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n          Int_Glob = v3;\n          v13 = v3;\n          v14 = 0;\n          v11 = Ch_2_Glob[0];\n          if ((char)v12 > Ch_2_Glob[0]) goto LABEL_11;\n        }\n      }\n    LABEL_11:\n      v16 = 3 * (int)v13 / 7;\n      v15 = 7 * (3 * v13 - 7) - v16;\n    }\n    if (Ch_1_Glob[0] == 65) v16 = v16 + 9 - Int_Glob;\n    if (++v3 == 11) {\n      v21 = v15;\n      Int_1_Loc = v16;\n      Enum_Loc = v14;\n      libmin_printf(\"Execution ends\\n\", v13);\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 65LL);\n      libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 66LL);\n      libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n      libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n      libmin_printf((char *)\"Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\",\n                    Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 2);\n      libmin_printf(\"  Int_Comp:          %d\\n\",\n                    Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 17);\n      libmin_printf(\"  Str_Comp:          %s\\n\",\n                    Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Next_Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\n          \"        should be:   (implementation-dependent), same as above\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\",\n                    Next_Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"  Int_Comp:          %d\\n\",\n                    Next_Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 18);\n      libmin_printf(\"  Str_Comp:          %s\\n\",\n                    Next_Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Int_2_Loc:           %d\\n\", v21);\n      libmin_printf(\"        should be:   %d\\n\", 13);\n      libmin_printf(\"Int_3_Loc:           %d\\n\", 7);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n      libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_success();\n    }\n  }\n}", "binary": "dhrystone/dhrystone.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nlea    0x2efb(%rip),%rsi\npush   %r14\npush   %r13\npush   %r12\nmovabs $0x800000008,%r12\npush   %rbp\npush   %rbx\nlea    0x897a(%rip),%rbx\nlea    0x14(%rbx),%rdi\nsub    $0x68,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x58(%rsp)\nlea    0x899d(%rip),%rax\nlea    0x10(%rsp),%rbp\nlea    0x30(%rsp),%r15\nmov    %rbx,0x89cc(%rip)\nmovl   $0x28,0x8952(%rip)\nmov    $0x1,%ebx\nmov    %rax,0x89ae(%rip)\nmov    %rax,0x892f(%rip)\nmov    0x3310(%rip),%rax\nmov    %rax,0x8929(%rip)\ncall   3d30 <libmin_strcpy>\nlea    0x2e9d(%rip),%rsi\nmov    %rbp,%rdi\ncall   3d30 <libmin_strcpy>\nlea    0x3256(%rip),%rdi\nxor    %eax,%eax\nmovl   $0xa,0x6756(%rip)\ncall   3ac0 <libmin_printf>\nlea    0x2e96(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nlea    0x3230(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    $0xa,%esi\nlea    0x2ea5(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x32af(%rip),%r13\nnopl   0x0(%rax)\nlea    0x2eb9(%rip),%rsi\nmov    %r15,%rdi\nmovb   $0x41,0x608b(%rip)\nmovl   $0x1,0x8889(%rip)\nmovb   $0x42,0x887e(%rip)\ncall   3d30 <libmin_strcpy>\nmovzbl 0x12(%rsp),%eax\ncmp    %al,0x33(%rsp)\nje     1755 <main+0x655>\nmov    %r15,%rsi\nmov    %rbp,%rdi\ncall   3cd0 <libmin_strcmp>\nmov    %r12,0x66d0(%rip)\ntest   %eax,%eax\nmov    %r13,0x87a7(%rip)\nmovl   $0x8,0x8815(%rip)\nsetle  %al\nmovzbl %al,%eax\naddl   $0x1,0x66ac(%rip)\nmov    %eax,0x8836(%rip)\nmov    0x88c3(%rip),%rax\nmovl   $0x7,0x7639(%rip)\nmov    (%rax),%rdx\nmovdqu (%rax),%xmm0\nmovl   $0x5,0x6010(%rip)\nmovups %xmm0,(%rdx)\nmovdqu 0x10(%rax),%xmm1\nmovups %xmm1,0x10(%rdx)\nmovdqu 0x20(%rax),%xmm2\nmovups %xmm2,0x20(%rdx)\nmov    0x30(%rax),%rcx\nmovl   $0x5,0x10(%rdx)\nmov    %rcx,0x30(%rdx)\nmov    (%rax),%rcx\nmov    %rcx,(%rdx)\nmov    (%rax),%rcx\nmov    %rcx,(%rdx)\nmovl   $0x11,0x10(%rax)\nmov    0x8(%rdx),%esi\ntest   %esi,%esi\nje     1760 <main+0x660>\nmovdqu (%rcx),%xmm3\nmovups %xmm3,(%rax)\nmovdqu 0x10(%rcx),%xmm4\nmovups %xmm4,0x10(%rax)\nmovdqu 0x20(%rcx),%xmm5\nmovups %xmm5,0x20(%rax)\nmov    0x30(%rcx),%rdx\nmov    %rdx,0x30(%rax)\nmovzbl 0x87a6(%rip),%ecx\nmov    $0x41,%r14d\nmov    $0x3,%esi\nmov    $0x1,%r9d\nmov    $0xd,%r11d\nmov    $0x1,%r8d\ncmp    $0x40,%cl\njle    1381 <main+0x281>\nnopl   0x0(%rax)\nadd    $0x1,%r14d\ncmp    %cl,%r14b\njg     1354 <main+0x254>\nxor    %eax,%eax\ncmp    $0x43,%r14b\njne    1325 <main+0x225>\nmovb   $0x43,0x5f64(%rip)\nmov    $0x1,%eax\ncmp    %eax,%r9d\njne    1308 <main+0x208>\nlea    0x2d97(%rip),%rsi\nmov    %r15,%rdi\nadd    $0x1,%r14d\ncall   3d30 <libmin_strcpy>\nmov    %ebx,0x5f45(%rip)\nmov    %ebx,%esi\nxor    %r9d,%r9d\nmovzbl 0x8739(%rip),%ecx\ncmp    %cl,%r14b\njle    1311 <main+0x211>\nlea    (%rsi,%rsi,2),%eax\nmovslq %eax,%r8\ncltd\nimul   $0xffffffff92492493,%r8,%r8\nshr    $0x20,%r8\nadd    %eax,%r8d\nsub    $0x7,%eax\nsar    $0x2,%r8d\nlea    0x0(,%rax,8),%r11d\nsub    %edx,%r8d\nsub    %eax,%r11d\nsub    %r8d,%r11d\ncmpb   $0x41,0x5efc(%rip)\njne    1395 <main+0x295>\nadd    $0x9,%r8d\nsub    0x5ef3(%rip),%r8d\nadd    $0x1,%ebx\ncmp    $0xb,%ebx\njne    11e8 <main+0xe8>\nlea    0x2efd(%rip),%rdi\nxor    %eax,%eax\nmov    %r11d,0xc(%rsp)\nlea    0x2f18(%rip),%r12\nmov    %r8d,0x8(%rsp)\nlea    0x2f57(%rip),%r13\nlea    0x2fb4(%rip),%rbx\nmov    %r9d,0x4(%rsp)\nlea    0x2fda(%rip),%r14\ncall   3ac0 <libmin_printf>\nlea    0x300f(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nlea    0x2cf9(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nlea    0x2ff3(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x5e7e(%rip),%esi\nlea    0x2ea4(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    $0x5,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x865f(%rip),%esi\nlea    0x2eb3(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    $0x1,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmovsbl 0x5e33(%rip),%esi\nlea    0x2ea8(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    %r13,%rdi\nmov    $0x41,%esi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmovsbl 0x8613(%rip),%esi\nlea    0x2eb6(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    %r13,%rdi\nmov    $0x42,%esi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x8548(%rip),%esi\nxor    %eax,%eax\nlea    0x2eaa(%rip),%rdi\nlea    0x2f20(%rip),%r13\ncall   3ac0 <libmin_printf>\nmov    $0x7,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x643a(%rip),%esi\nlea    0x2e9b(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nlea    0x2c49(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nxor    %eax,%eax\nlea    0x2eff(%rip),%rdi\ncall   3ac0 <libmin_printf>\nlea    0x2c5d(%rip),%rdx\nxor    %eax,%eax\nmov    %rdx,%rdi\ncall   3ac0 <libmin_printf>\nlea    0x2c84(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x860e(%rip),%rax\nmov    %rbx,%rdi\nmov    0x8(%rax),%esi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nxor    %esi,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x85ee(%rip),%rax\nlea    0x2e5d(%rip),%rcx\nmov    %rcx,%rdi\nmov    0xc(%rax),%esi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    $0x2,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x85c4(%rip),%rax\nmov    %r14,%rdi\nmov    0x10(%rax),%esi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    $0x11,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x85a1(%rip),%rax\nmov    %r13,%rdi\nlea    0x14(%rax),%rsi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nlea    0x2c2c(%rip),%r10\nxor    %eax,%eax\nmov    %r10,%rdi\ncall   3ac0 <libmin_printf>\nlea    0x2e3c(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nlea    0x2b9d(%rip),%rdx\nxor    %eax,%eax\nmov    %rdx,%rdi\ncall   3ac0 <libmin_printf>\nlea    0x2c34(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x8546(%rip),%rax\nmov    %rbx,%rdi\nmov    0x8(%rax),%esi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nxor    %esi,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x8526(%rip),%rax\nlea    0x2d9d(%rip),%rcx\nmov    %rcx,%rdi\nmov    0xc(%rax),%esi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    $0x1,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x84fc(%rip),%rax\nmov    %r14,%rdi\nmov    0x10(%rax),%esi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    $0x12,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x84d9(%rip),%rax\nmov    %r13,%rdi\nlea    0x14(%rax),%rsi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nlea    0x2b6c(%rip),%r10\nxor    %eax,%eax\nmov    %r10,%rdi\ncall   3ac0 <libmin_printf>\nmov    0x8(%rsp),%esi\nlea    0x2d89(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    $0x5,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0xc(%rsp),%esi\nlea    0x2d81(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    $0xd,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    $0x7,%esi\nlea    0x2d78(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    $0x7,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x4(%rsp),%esi\nlea    0x2d70(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    $0x1,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    %rbp,%rsi\nlea    0x2d69(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nxor    %eax,%eax\nlea    0x2b3b(%rip),%rdi\ncall   3ac0 <libmin_printf>\nmov    %r15,%rsi\nlea    0x2d63(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nlea    0x2b56(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nlea    0x2cc8(%rip),%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\ncall   3d80 <libmin_success>\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    17b1 <main+0x6b1>\nadd    $0x68,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\njmp    1755 <main+0x655>\nnopw   0x0(%rax,%rax,1)\nmov    0xc(%rax),%eax\nmovl   $0x6,0x10(%rdx)\ncmp    $0x2,%eax\nje     17a8 <main+0x6a8>\nmovl   $0x3,0xc(%rdx)\ncmp    $0x4,%eax\nje     179f <main+0x69f>\nja     1790 <main+0x690>\ntest   %eax,%eax\njne    1790 <main+0x690>\nmovl   $0x0,0xc(%rdx)\nnopl   0x0(%rax,%rax,1)\nmov    %rcx,(%rdx)\nmovl   $0x12,0x10(%rdx)\njmp    12db <main+0x1db>\nmovl   $0x2,0xc(%rdx)\njmp    1790 <main+0x690>\nmovl   $0x1,0xc(%rdx)\njmp    1790 <main+0x690>\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "distinctness/distinctness.c", "function_name": "isDistinct", "content": "int\nisDistinct(int elements[], int *pdup)\n{\n  int tree[SIZE][3];\n  *pdup = INT_MAX;\n\n\tfor(int i = 0; i < SIZE;i++){\n\t\ttree[i][0] = INT_MAX;\n\t\ttree[i][1] = INT_MAX;\n\t\ttree[i][2] = INT_MAX;\n\t}\t\n\t\n\ttree[0][0] = elements[0];\n\tint location = 0;\n\n\tfor(int i = 1; i < SIZE; i++){\n\t\tint temp = 0;\n\t\tint value = tree[0][0];\n\t\tint left = tree[0][1];\n\t\tint right = tree[0][2];\n\n\t\twhile(value != INT_MAX){\n\t\t\tif(elements[i] > value){\n\t\t\t\tif(right != INT_MAX){\n\t\t\t\t\tvalue = tree[right][0];\n\t\t\t\t\tleft = tree[right][1];\n\t\t\t\t\ttemp = right;\n\t\t\t\t\tright = tree[right][2];\n\t\t\t\t}else{\n\t\t\t\t\ttree[location+1][0] = elements[i];\n\t\t\t\t\ttree[temp][2] = location + 1;\n\t\t\t\t\tlocation++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(elements[i] < value){\n\t\t\t\tif(left != INT_MAX){\n\t\t\t\t\tvalue = tree[left][0];\n\t\t\t\t\tright = tree[left][2];\n\t\t\t\t\ttemp = left;\n\t\t\t\t\tleft = tree[left][1];\n\t\t\t\t}else{\n\t\t\t\t\ttree[temp][1] = location+1;\n\t\t\t\t\ttree[location+1][0] = elements[i];\n\t\t\t\t\tlocation++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n        *pdup = elements[i];\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n"}, "pseudo": {"path": "distinctness/distinctness.host.O3.pseudo", "function_name": "isDistinct", "address": "0x12a0", "label": "isDistinct", "content": "int __fastcall isDistinct(int *elements, int *pdup)\n{\n  __m128i si128; // xmm0\n  int *v4; // rax\n  int v5; // r9d\n  int *v6; // r8\n  int *v7; // r10\n  int v8; // ebx\n  int v9; // esi\n  int v10; // ecx\n  int v11; // edi\n  int v12; // eax\n  __int64 v13; // rbp\n  int tree[128][3]; // [rsp+0h] [rbp-628h] BYREF\n  char v16; // [rsp+600h] [rbp-28h] BYREF\n  unsigned __int64 v17; // [rsp+608h] [rbp-20h]\n\n  si128 = _mm_load_si128((const __m128i *)&xmmword_4100);\n  v17 = __readfsqword(0x28u);\n  *pdup = 0x7FFFFFFF;\n  v4 = tree[0];\n  do\n  {\n    *(__m128i *)v4 = si128;\n    v4 += 12;\n    *((__m128i *)v4 - 2) = si128;\n    *((__m128i *)v4 - 1) = si128;\n  }\n  while ( &v16 != (char *)v4 );\n  v5 = *elements;\n  v6 = elements + 1;\n  v7 = elements + 128;\n  v8 = 0;\n  tree[0][0] = *elements;\nLABEL_4:\n  while ( 2 )\n  {\n    while ( 1 )\n    {\n      v9 = tree[0][1];\n      v10 = tree[0][2];\n      if ( v5 != 0x7FFFFFFF )\n        break;\nLABEL_12:\n      if ( v7 == ++v6 )\n        return 1;\n    }\n    v11 = *v6;\n    v12 = v5;\n    v13 = 0LL;\n    while ( 1 )\n    {\n      while ( v11 > v12 )\n      {\n        if ( v10 == 0x7FFFFFFF )\n        {\n          ++v8;\n          ++v6;\n          tree[v8][0] = v11;\n          tree[v13][2] = v8;\n          if ( v7 != v6 )\n            goto LABEL_4;\n          return 1;\n        }\n        v13 = v10;\n        v12 = tree[v10][0];\n        v9 = tree[v10][1];\n        v10 = tree[v10][2];\n        if ( v12 == 0x7FFFFFFF )\n          goto LABEL_12;\n      }\n      if ( v11 >= v12 )\n      {\n        *pdup = v11;\n        return 0;\n      }\n      if ( v9 == 0x7FFFFFFF )\n        break;\n      v13 = v9;\n      v12 = tree[v9][0];\n      v10 = tree[v9][2];\n      v9 = tree[v9][1];\n      if ( v12 == 0x7FFFFFFF )\n        goto LABEL_12;\n    }\n    ++v8;\n    ++v6;\n    tree[v13][1] = v8;\n    tree[v8][0] = v11;\n    if ( v7 != v6 )\n      continue;\n    return 1;\n  }\n}\n"}, "pseudo_normalize": "int isDistinct(int *elements, int *pdup) {\n  __m128i si128;\n  int *v4;\n  int v5;\n  int *v6;\n  int *v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  long long v13;\n  int tree[128][3];\n  char v16;\n  unsigned long long v17;\n  si128 = _mm_load_si128((const __m128i *)&xmmword_4100);\n  v17 = __readfsqword(40u);\n  *pdup = 2147483647;\n  v4 = tree[0];\n  do {\n    *(__m128i *)v4 = si128;\n    v4 += 12;\n    *((__m128i *)v4 - 2) = si128;\n    *((__m128i *)v4 - 1) = si128;\n  } while (&v16 != (char *)v4);\n  v5 = *elements;\n  v6 = elements + 1;\n  v7 = elements + 128;\n  v8 = 0;\n  tree[0][0] = *elements;\nLABEL_4:\n  while (2) {\n    while (1) {\n      v9 = tree[0][1];\n      v10 = tree[0][2];\n      if (v5 != 2147483647) break;\n    LABEL_12:\n      if (v7 == ++v6) return 1;\n    }\n    v11 = *v6;\n    v12 = v5;\n    v13 = 0LL;\n    while (1) {\n      while (v11 > v12) {\n        if (v10 == 2147483647) {\n          ++v8;\n          ++v6;\n          tree[v8][0] = v11;\n          tree[v13][2] = v8;\n          if (v7 != v6) goto LABEL_4;\n          return 1;\n        }\n        v13 = v10;\n        v12 = tree[v10][0];\n        v9 = tree[v10][1];\n        v10 = tree[v10][2];\n        if (v12 == 2147483647) goto LABEL_12;\n      }\n      if (v11 >= v12) {\n        *pdup = v11;\n        return 0;\n      }\n      if (v9 == 2147483647) break;\n      v13 = v9;\n      v12 = tree[v9][0];\n      v10 = tree[v9][2];\n      v9 = tree[v9][1];\n      if (v12 == 2147483647) goto LABEL_12;\n    }\n    ++v8;\n    ++v6;\n    tree[v13][1] = v8;\n    tree[v8][0] = v11;\n    if (v7 != v6) continue;\n    return 1;\n  }\n}", "binary": "distinctness/distinctness.host.O3", "assembly": "<isDistinct>:\nendbr64\npush   %rbp\nmov    %rsi,%r11\npush   %rbx\nsub    $0x618,%rsp\nmovdqa 0x2e48(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x608(%rsp)\nxor    %eax,%eax\nmovl   $0x7fffffff,(%rsi)\nmov    %rsp,%rax\nlea    0x600(%rsp),%rdx\nnopl   0x0(%rax)\nmovaps %xmm0,(%rax)\nadd    $0x30,%rax\nmovaps %xmm0,-0x20(%rax)\nmovaps %xmm0,-0x10(%rax)\ncmp    %rax,%rdx\njne    12e0 <isDistinct+0x40>\nmov    (%rdi),%r9d\nlea    0x4(%rdi),%r8\nlea    0x200(%rdi),%r10\nxor    %ebx,%ebx\nmov    %r9d,(%rsp)\nmov    0x4(%rsp),%esi\nmov    0x8(%rsp),%ecx\ncmp    $0x7fffffff,%r9d\nje     137e <isDistinct+0xde>\nmov    (%r8),%edi\nmov    %r9d,%eax\nxor    %ebp,%ebp\njmp    1350 <isDistinct+0xb0>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x7fffffff,%ecx\nje     1390 <isDistinct+0xf0>\nmovslq %ecx,%rax\nmovslq %ecx,%rbp\nlea    (%rax,%rax,2),%rdx\nshl    $0x2,%rdx\nmov    (%rsp,%rdx,1),%eax\nmov    0x4(%rsp,%rdx,1),%esi\nmov    0x8(%rsp,%rdx,1),%ecx\ncmp    $0x7fffffff,%eax\nje     137e <isDistinct+0xde>\ncmp    %eax,%edi\njg     1328 <isDistinct+0x88>\njge    13b8 <isDistinct+0x118>\ncmp    $0x7fffffff,%esi\nje     13da <isDistinct+0x13a>\nmovslq %esi,%rax\nmovslq %esi,%rbp\nlea    (%rax,%rax,2),%rdx\nshl    $0x2,%rdx\nmov    (%rsp,%rdx,1),%eax\nmov    0x8(%rsp,%rdx,1),%ecx\nmov    0x4(%rsp,%rdx,1),%esi\ncmp    $0x7fffffff,%eax\njne    1350 <isDistinct+0xb0>\nadd    $0x4,%r8\ncmp    %r8,%r10\njne    1308 <isDistinct+0x68>\nmov    $0x1,%eax\njmp    13bd <isDistinct+0x11d>\nxchg   %ax,%ax\nadd    $0x1,%ebx\nadd    $0x4,%r8\nmovslq %ebx,%rax\nlea    (%rax,%rax,2),%rax\nmov    %edi,(%rsp,%rax,4)\nlea    0x0(%rbp,%rbp,2),%rax\nmov    %ebx,0x8(%rsp,%rax,4)\ncmp    %r8,%r10\njne    1308 <isDistinct+0x68>\njmp    1387 <isDistinct+0xe7>\nnopl   (%rax)\nmov    %edi,(%r11)\nxor    %eax,%eax\nmov    0x608(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    13ff <isDistinct+0x15f>\nadd    $0x618,%rsp\npop    %rbx\npop    %rbp\nret\nadd    $0x1,%ebx\nlea    0x0(%rbp,%rbp,2),%rax\nadd    $0x4,%r8\nmov    %ebx,0x4(%rsp,%rax,4)\nmovslq %ebx,%rax\nlea    (%rax,%rax,2),%rax\nmov    %edi,(%rsp,%rax,4)\ncmp    %r8,%r10\njne    1308 <isDistinct+0x68>\njmp    1387 <isDistinct+0xe7>\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "distinctness/distinctness.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int dup1, dup2;\n  int res1, res2;\n\n  res1 = isDistinct(elements1, &dup1);\n  res2 = isDistinct(elements2, &dup2);\n\n  if (res1)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n\telse\n\t\tlibmin_printf(\"The elements of `elements1' are not distinct (e.g., %d is duplicated)\\n\", dup1);\n\t\n  if (res2)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n\telse\n\t\tlibmin_printf(\"The elements of `elements2' are not distinct (e.g., %d is duplicated)\\n\", dup2);\n\n\tlibmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "distinctness/distinctness.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // ebx\n  int dup1; // [rsp+0h] [rbp-28h] BYREF\n  int dup2; // [rsp+4h] [rbp-24h] BYREF\n  unsigned __int64 v7; // [rsp+8h] [rbp-20h]\n\n  v7 = __readfsqword(0x28u);\n  v3 = isDistinct(elements1, &dup1);\n  v4 = isDistinct(elements2, &dup2);\n  if ( v3 )\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements1' are not distinct (e.g., %d is duplicated)\\n\", dup1);\n  if ( v4 )\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements2' are not distinct (e.g., %d is duplicated)\\n\", dup2);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int dup1;\n  int dup2;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  v3 = isDistinct(elements1, &dup1);\n  v4 = isDistinct(elements2, &dup2);\n  if (v3)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements1' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup1);\n  if (v4)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements2' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup2);\n  libmin_success();\n}", "binary": "distinctness/distinctness.host.O3", "assembly": "<main>:\nendbr64\npush   %rbp\nlea    0x5114(%rip),%rdi\npush   %rbx\nsub    $0x18,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rsi\ncall   12a0 <isDistinct>\nlea    0x4(%rsp),%rsi\nlea    0x4eeb(%rip),%rdi\nmov    %eax,%ebp\ncall   12a0 <isDistinct>\nmov    %eax,%ebx\ntest   %ebp,%ebp\nje     1180 <main+0x80>\nlea    0x2ebf(%rip),%rdi\nxor    %eax,%eax\ncall   34e0 <libmin_printf>\ntest   %ebx,%ebx\nje     1193 <main+0x93>\nlea    0x2f25(%rip),%rdi\nxor    %eax,%eax\ncall   34e0 <libmin_printf>\ncall   3720 <libmin_success>\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    11a7 <main+0xa7>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nret\nmov    (%rsp),%esi\nlea    0x2eae(%rip),%rdi\nxor    %eax,%eax\ncall   34e0 <libmin_printf>\njmp    1150 <main+0x50>\nmov    0x4(%rsp),%esi\nlea    0x2f12(%rip),%rdi\nxor    %eax,%eax\ncall   34e0 <libmin_printf>\njmp    1162 <main+0x62>\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax)\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "db_from_ampl", "content": "/* db_from_ampl() - find loudness (in dB) from\n   the complex amplitude.\n*/\nint db_from_ampl(fixed re, fixed im)\n{\n  static int loud2[N_LOUD] = {0};\n  int v;\n  int i;\n\n  if(loud2[0] == 0) {\n    loud2[0] = (int)Loudampl[0] * (int)Loudampl[0];\n    for(i=1; i<N_LOUD; ++i) {\n      v = (int)Loudampl[i] * (int)Loudampl[i];\n      loud2[i] = v;\n      loud2[i-1] = (loud2[i-1]+v) / 2;\n    }\n  }\n\n  v = (int)re * (int)re + (int)im * (int)im;\n\n  for(i=0; i<N_LOUD; ++i)\n    if(loud2[i] <= v)\n      break;\n\n  return (-i);\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O3.pseudo", "function_name": "db_from_ampl", "address": "0x1c50", "label": "db_from_ampl", "content": "int __fastcall db_from_ampl(int re, int im)\n{\n  const __m128i *v2; // rdx\n  int *v3; // rax\n  __m128i v4; // xmm1\n  __m128i v5; // xmm0\n  __m128i v6; // xmm1\n  __m128i v7; // xmm0\n  __m128i v8; // xmm0\n  __int64 v9; // rdx\n  int v10; // edi\n\n  if ( !loud2_0[0] )\n  {\n    v2 = (const __m128i *)&Loudampl[1];\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    v3 = loud2_0;\n    do\n    {\n      v4 = _mm_loadu_si128(v2++);\n      v3 += 4;\n      v5 = _mm_mul_epu32(v4, v4);\n      v6 = _mm_srli_epi64(v4, 0x20u);\n      v7 = _mm_unpacklo_epi32(_mm_shuffle_epi32(v5, 8), _mm_shuffle_epi32(_mm_mul_epu32(v6, v6), 8));\n      *(__m128i *)(v3 - 3) = v7;\n      v8 = _mm_add_epi32(v7, *((__m128i *)v3 - 1));\n      *((__m128i *)v3 - 1) = _mm_srai_epi32(_mm_sub_epi32(v8, _mm_cmpgt_epi32((__m128i)0LL, v8)), 1u);\n    }\n    while ( v2 != (const __m128i *)&Loudampl[97] );\n    xmmword_B5A0 = (__int128)_mm_unpacklo_epi64(\n                               _mm_unpacklo_epi32(\n                                 _mm_cvtsi32_si128((Loudampl[97] * Loudampl[97] + (int)xmmword_B5A0) / 2),\n                                 _mm_cvtsi32_si128((Loudampl[98] * Loudampl[98] + Loudampl[97] * Loudampl[97]) >> 1)),\n                               _mm_unpacklo_epi32(\n                                 _mm_cvtsi32_si128((Loudampl[99] * Loudampl[99] + Loudampl[98] * Loudampl[98]) >> 1),\n                                 _mm_cvtsi32_si128(Loudampl[99] * Loudampl[99])));\n  }\n  v9 = 0LL;\n  v10 = im * im + re * re;\n  do\n  {\n    if ( loud2_0[v9] <= v10 )\n      return -(int)v9;\n    ++v9;\n  }\n  while ( v9 != 100 );\n  return -100;\n}\n"}, "pseudo_normalize": "int db_from_ampl(int re, int im) {\n  const __m128i *v2;\n  int *v3;\n  __m128i v4;\n  __m128i v5;\n  __m128i v6;\n  __m128i v7;\n  __m128i v8;\n  long long v9;\n  int v10;\n  if (!loud2_0[0]) {\n    v2 = (const __m128i *)&Loudampl[1];\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    v3 = loud2_0;\n    do {\n      v4 = _mm_loadu_si128(v2++);\n      v3 += 4;\n      v5 = _mm_mul_epu32(v4, v4);\n      v6 = _mm_srli_epi64(v4, 32u);\n      v7 = _mm_unpacklo_epi32(_mm_shuffle_epi32(v5, 8),\n                              _mm_shuffle_epi32(_mm_mul_epu32(v6, v6), 8));\n      *(__m128i *)(v3 - 3) = v7;\n      v8 = _mm_add_epi32(v7, *((__m128i *)v3 - 1));\n      *((__m128i *)v3 - 1) = _mm_srai_epi32(\n          _mm_sub_epi32(v8, _mm_cmpgt_epi32((__m128i)0LL, v8)), 1u);\n    } while (v2 != (const __m128i *)&Loudampl[97]);\n    xmmword_B5A0 = (__int128)_mm_unpacklo_epi64(\n        _mm_unpacklo_epi32(\n            _mm_cvtsi32_si128(\n                (Loudampl[97] * Loudampl[97] + (int)xmmword_B5A0) / 2),\n            _mm_cvtsi32_si128(\n                (Loudampl[98] * Loudampl[98] + Loudampl[97] * Loudampl[97]) >>\n                1)),\n        _mm_unpacklo_epi32(_mm_cvtsi32_si128((Loudampl[99] * Loudampl[99] +\n                                              Loudampl[98] * Loudampl[98]) >>\n                                             1),\n                           _mm_cvtsi32_si128(Loudampl[99] * Loudampl[99])));\n  }\n  v9 = 0LL;\n  v10 = im * im + re * re;\n  do {\n    if (loud2_0[v9] <= v10) return -(int)v9;\n    ++v9;\n  } while (v9 != 100);\n  return -100;\n}", "binary": "fft-int/fft-int.host.O3", "assembly": "<db_from_ampl>:\nendbr64\nmov    0x97c6(%rip),%eax\nmov    %esi,%r8d\nlea    0x97bc(%rip),%rsi\ntest   %eax,%eax\njne    1d3d <db_from_ampl+0xed>\nmov    0x83ae(%rip),%eax\nlea    0x83ab(%rip),%rdx\npxor   %xmm2,%xmm2\nlea    0x180(%rdx),%rcx\nimul   %eax,%eax\nmov    %eax,0x9793(%rip)\nmov    %rsi,%rax\nmovdqu (%rdx),%xmm1\nadd    $0x10,%rdx\nadd    $0x10,%rax\nmovdqa %xmm1,%xmm0\npmuludq %xmm1,%xmm0\npsrlq  $0x20,%xmm1\npmuludq %xmm1,%xmm1\npshufd $0x8,%xmm0,%xmm0\npshufd $0x8,%xmm1,%xmm1\npunpckldq %xmm1,%xmm0\nmovdqa %xmm2,%xmm1\nmovups %xmm0,-0xc(%rax)\npaddd  -0x10(%rax),%xmm0\npcmpgtd %xmm0,%xmm1\npsubd  %xmm1,%xmm0\npsrad  $0x1,%xmm0\nmovaps %xmm0,-0x10(%rax)\ncmp    %rcx,%rdx\njne    1c90 <db_from_ampl+0x40>\nmov    0x84c0(%rip),%ecx\nmov    0x98b5(%rip),%r10d\nmov    0x84b7(%rip),%eax\nmov    0x84b4(%rip),%r9d\nimul   %ecx,%ecx\nimul   %eax,%eax\nimul   %r9d,%r9d\nadd    %ecx,%r10d\nmov    %r10d,%edx\nadd    %eax,%ecx\nshr    $0x1f,%edx\nadd    %r9d,%eax\nsar    %ecx\nmovd   %r9d,%xmm3\nadd    %r10d,%edx\nsar    %eax\nmovd   %ecx,%xmm4\nsar    %edx\nmovd   %eax,%xmm0\nmovd   %edx,%xmm1\npunpckldq %xmm3,%xmm0\npunpckldq %xmm4,%xmm1\npunpcklqdq %xmm0,%xmm1\nmovaps %xmm1,0x9863(%rip)\nimul   %edi,%edi\nxor    %edx,%edx\nimul   %r8d,%r8d\nadd    %r8d,%edi\njmp    1d5a <db_from_ampl+0x10a>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rdx\ncmp    $0x64,%rdx\nje     1d64 <db_from_ampl+0x114>\nmov    %edx,%eax\ncmp    %edi,(%rsi,%rdx,4)\njg     1d50 <db_from_ampl+0x100>\nneg    %eax\nret\nmov    $0xffffff9c,%eax\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "fix_fft", "content": "/* fix_fft() - perform fast Fourier transform.\n\n   if n>0 FFT is done, if n<0 inverse FFT is done\n   fr[n],fi[n] are real,imaginary arrays, INPUT AND RESULT.\n   size of data = 2**m\n   set inverse to 0=dft, 1=idft\n*/\nint\nfix_fft(fixed fr[], fixed fi[], int m, int inverse)\n{\n  int mr,nn,i,j,l,k,istep, n, scale, shift;\n  fixed qr,qi,tr,ti,wr,wi;\n\n  n = 1<<m;\n\n  if(n > N_WAVE)\n    return -1;\n\n  mr = 0;\n  nn = n - 1;\n  scale = 0;\n\n  /* decimation in time - re-order data */\n  for(m=1; m<=nn; ++m) {\n    l = n;\n    do {\n      l >>= 1;\n    } while(mr+l > nn);\n    mr = (mr & (l-1)) + l;\n\n    if(mr <= m) continue;\n    tr = fr[m];\n    fr[m] = fr[mr];\n    fr[mr] = tr;\n    ti = fi[m];\n    fi[m] = fi[mr];\n    fi[mr] = ti;\n  }\n\n  l = 1;\n  k = LOG2_N_WAVE-1;\n  while(l < n) {\n    if(inverse) {\n      /* variable scaling, depending upon data */\n      shift = 0;\n      for(i=0; i<n; ++i) {\n\tj = fr[i];\n\tif(j < 0)\n\t  j = -j;\n\tm = fi[i];\n\tif(m < 0)\n\t  m = -m;\n\tif(j > 16383 || m > 16383) {\n\t  shift = 1;\n\t  break;\n\t}\n      }\n      if(shift)\n\t++scale;\n    } else {\n      /* fixed scaling, for proper normalization -\n\t there will be log2(n) passes, so this\n\t results in an overall factor of 1/n,\n\t distributed to maximize arithmetic accuracy. */\n      shift = 1;\n    }\n    /* it may not be obvious, but the shift will be performed\n       on each data point exactly once, during this pass. */\n    istep = l << 1;\n    for(m=0; m<l; ++m) {\n      j = m << k;\n      /* 0 <= j < N_WAVE/2 */\n      wr =  Sinewave[j+N_WAVE/4];\n      wi = -Sinewave[j];\n      if(inverse)\n\twi = -wi;\n      if(shift) {\n\twr >>= 1;\n\twi >>= 1;\n      }\n      for(i=m; i<n; i+=istep) {\n\tj = i + l;\n\ttr = fix_mpy(wr,fr[j]) -\n\t  fix_mpy(wi,fi[j]);\n\tti = fix_mpy(wr,fi[j]) +\n\t  fix_mpy(wi,fr[j]);\n\tqr = fr[i];\n\tqi = fi[i];\n\tif(shift) {\n\t  qr >>= 1;\n\t  qi >>= 1;\n\t}\n\tfr[j] = qr - tr;\n\tfi[j] = qi - ti;\n\tfr[i] = qr + tr;\n\tfi[i] = qi + ti;\n      }\n    }\n    --k;\n    l = istep;\n  }\n\n  return scale;\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O3.pseudo", "function_name": "fix_fft", "address": "0x1370", "label": "fix_fft", "content": "int __fastcall fix_fft(int *fr, int *fi, int m, int inverse)\n{\n  int v4; // eax\n  int v6; // esi\n  int v8; // ebp\n  __int64 v9; // rdi\n  int v10; // ecx\n  __int64 v11; // r8\n  int v12; // eax\n  int v13; // r9d\n  __int64 v14; // rax\n  int *v15; // rdx\n  int *v16; // rax\n  int v17; // edx\n  int v18; // edi\n  __int64 v19; // r10\n  __int64 v20; // r9\n  __int64 v21; // rdi\n  int *v22; // r8\n  int *v23; // rdi\n  int v24; // r13d\n  int v25; // r14d\n  int v26; // r14d\n  __int64 v27; // rdx\n  int v28; // r13d\n  int v29; // ecx\n  int v30; // esi\n  int v31; // ecx\n  int v32; // eax\n  int v33; // esi\n  int v34; // r15d\n  int v35; // ecx\n  __int64 v36; // rax\n  int v37; // edi\n  int v38; // ecx\n  int v39; // ecx\n  __int64 v40; // rax\n  int v41; // edx\n  int v42; // esi\n  int v43; // ecx\n  int v44; // edx\n  int v45; // r15d\n  int v46; // esi\n  int shift; // [rsp+0h] [rbp-50h]\n  char k; // [rsp+4h] [rbp-4Ch]\n  int v51; // [rsp+Ch] [rbp-44h]\n  int istep; // [rsp+10h] [rbp-40h]\n  int scale; // [rsp+14h] [rbp-3Ch]\n\n  v4 = 1 << m;\n  if ( 1 << m > 1024 )\n    return -1;\n  v6 = v4 - 1;\n  v8 = 1 << m;\n  if ( v4 - 1 > 0 )\n  {\n    v9 = 1LL;\n    v10 = 0;\n    v11 = (unsigned int)(v4 - 2) + 2LL;\n    do\n    {\n      v12 = v8;\n      do\n        v12 >>= 1;\n      while ( v12 + v10 > v6 );\n      v10 = (v10 & (v12 - 1)) + v12;\n      if ( v10 > (int)v9 )\n      {\n        v13 = fr[v9];\n        v14 = v10;\n        v15 = &fr[v14];\n        v16 = &fi[v14];\n        fr[v9] = *v15;\n        *v15 = v13;\n        LODWORD(v15) = fi[v9];\n        fi[v9] = *v16;\n        *v16 = (int)v15;\n      }\n      ++v9;\n    }\n    while ( v11 != v9 );\n  }\n  scale = 0;\n  if ( v8 > 1 )\n  {\n    k = 9;\n    v17 = 1;\n    shift = 1;\n    if ( inverse )\n      goto LABEL_22;\n    while ( 1 )\n    {\nLABEL_11:\n      v18 = v17;\n      if ( v8 <= v17 )\n        v18 = v8;\n      istep = 2 * v17;\n      v19 = 0LL;\n      v20 = 2 * v17;\n      v51 = v18;\n      v21 = v17;\n      v22 = &fr[v21];\n      v23 = &fi[v21];\n      do\n      {\n        while ( 1 )\n        {\n          v24 = Sinewave[(_DWORD)v19 << k];\n          v25 = Sinewave[((_DWORD)v19 << k) + 256];\n          if ( !inverse )\n            v24 = -Sinewave[(_DWORD)v19 << k];\n          if ( !shift )\n            break;\n          v26 = v25 >> 1;\n          v27 = v19;\n          v28 = v24 >> 1;\n          do\n          {\n            v29 = v22[v27];\n            v30 = v28 * v29;\n            v31 = ((v26 * v29) >> 15) - ((v28 * v23[v27]) >> 15);\n            v32 = (v30 >> 15) + ((v26 * v23[v27]) >> 15);\n            v33 = fi[v27] >> 1;\n            v34 = (fr[v27] >> 1) - v31;\n            v35 = (fr[v27] >> 1) + v31;\n            v22[v27] = v34;\n            v23[v27] = v33 - v32;\n            fr[v27] = v35;\n            fi[v27] = v33 + v32;\n            v27 += v20;\n          }\n          while ( v8 > (int)v27 );\n          if ( v51 <= (int)++v19 )\n            goto LABEL_20;\n        }\n        v40 = v19;\n        do\n        {\n          v41 = v22[v40];\n          v42 = v23[v40];\n          v43 = ((v41 * v25) >> 15) - ((v42 * v24) >> 15);\n          v44 = ((v25 * v42) >> 15) + ((v24 * v41) >> 15);\n          v45 = fr[v40];\n          v46 = fi[v40];\n          v22[v40] = v45 - v43;\n          v23[v40] = v46 - v44;\n          fr[v40] = v43 + v45;\n          fi[v40] = v44 + v46;\n          v40 += v20;\n        }\n        while ( v8 > (int)v40 );\n        ++v19;\n      }\n      while ( v51 > (int)v19 );\nLABEL_20:\n      --k;\n      if ( v8 <= istep )\n        break;\n      v17 = istep;\n      shift = 1;\n      if ( inverse )\n      {\nLABEL_22:\n        v36 = 0LL;\n        while ( 1 )\n        {\n          v37 = fi[v36];\n          v38 = -fr[v36];\n          if ( fr[v36] > 0 )\n            v38 = fr[v36];\n          if ( v38 > 0x3FFF )\n            break;\n          v39 = -v37;\n          if ( v37 > 0 )\n            v39 = fi[v36];\n          if ( v39 > 0x3FFF )\n            break;\n          if ( v8 == ++v36 )\n          {\n            shift = 0;\n            goto LABEL_11;\n          }\n        }\n        ++scale;\n        shift = 1;\n      }\n    }\n  }\n  return scale;\n}\n"}, "pseudo_normalize": "int fix_fft(int *fr, int *fi, int m, int inverse) {\n  int v4;\n  int v6;\n  int v8;\n  long long v9;\n  int v10;\n  long long v11;\n  int v12;\n  int v13;\n  long long v14;\n  int *v15;\n  int *v16;\n  int v17;\n  int v18;\n  long long v19;\n  long long v20;\n  long long v21;\n  int *v22;\n  int *v23;\n  int v24;\n  int v25;\n  int v26;\n  long long v27;\n  int v28;\n  int v29;\n  int v30;\n  int v31;\n  int v32;\n  int v33;\n  int v34;\n  int v35;\n  long long v36;\n  int v37;\n  int v38;\n  int v39;\n  long long v40;\n  int v41;\n  int v42;\n  int v43;\n  int v44;\n  int v45;\n  int v46;\n  int shift;\n  char k;\n  int v51;\n  int istep;\n  int scale;\n  v4 = 1 << m;\n  if (1 << m > 1024) return -1;\n  v6 = v4 - 1;\n  v8 = 1 << m;\n  if (v4 - 1 > 0) {\n    v9 = 1LL;\n    v10 = 0;\n    v11 = (unsigned int)(v4 - 2) + 2LL;\n    do {\n      v12 = v8;\n      do v12 >>= 1;\n      while (v12 + v10 > v6);\n      v10 = (v10 & (v12 - 1)) + v12;\n      if (v10 > (int)v9) {\n        v13 = fr[v9];\n        v14 = v10;\n        v15 = &fr[v14];\n        v16 = &fi[v14];\n        fr[v9] = *v15;\n        *v15 = v13;\n        LODWORD(v15) = fi[v9];\n        fi[v9] = *v16;\n        *v16 = (int)v15;\n      }\n      ++v9;\n    } while (v11 != v9);\n  }\n  scale = 0;\n  if (v8 > 1) {\n    k = 9;\n    v17 = 1;\n    shift = 1;\n    if (inverse) goto LABEL_22;\n    while (1) {\n    LABEL_11:\n      v18 = v17;\n      if (v8 <= v17) v18 = v8;\n      istep = 2 * v17;\n      v19 = 0LL;\n      v20 = 2 * v17;\n      v51 = v18;\n      v21 = v17;\n      v22 = &fr[v21];\n      v23 = &fi[v21];\n      do {\n        while (1) {\n          v24 = Sinewave[(uint32_t)v19 << k];\n          v25 = Sinewave[((uint32_t)v19 << k) + 256];\n          if (!inverse) v24 = -Sinewave[(uint32_t)v19 << k];\n          if (!shift) break;\n          v26 = v25 >> 1;\n          v27 = v19;\n          v28 = v24 >> 1;\n          do {\n            v29 = v22[v27];\n            v30 = v28 * v29;\n            v31 = ((v26 * v29) >> 15) - ((v28 * v23[v27]) >> 15);\n            v32 = (v30 >> 15) + ((v26 * v23[v27]) >> 15);\n            v33 = fi[v27] >> 1;\n            v34 = (fr[v27] >> 1) - v31;\n            v35 = (fr[v27] >> 1) + v31;\n            v22[v27] = v34;\n            v23[v27] = v33 - v32;\n            fr[v27] = v35;\n            fi[v27] = v33 + v32;\n            v27 += v20;\n          } while (v8 > (int)v27);\n          if (v51 <= (int)++v19) goto LABEL_20;\n        }\n        v40 = v19;\n        do {\n          v41 = v22[v40];\n          v42 = v23[v40];\n          v43 = ((v41 * v25) >> 15) - ((v42 * v24) >> 15);\n          v44 = ((v25 * v42) >> 15) + ((v24 * v41) >> 15);\n          v45 = fr[v40];\n          v46 = fi[v40];\n          v22[v40] = v45 - v43;\n          v23[v40] = v46 - v44;\n          fr[v40] = v43 + v45;\n          fi[v40] = v44 + v46;\n          v40 += v20;\n        } while (v8 > (int)v40);\n        ++v19;\n      } while (v51 > (int)v19);\n    LABEL_20:\n      --k;\n      if (v8 <= istep) break;\n      v17 = istep;\n      shift = 1;\n      if (inverse) {\n      LABEL_22:\n        v36 = 0LL;\n        while (1) {\n          v37 = fi[v36];\n          v38 = -fr[v36];\n          if (fr[v36] > 0) v38 = fr[v36];\n          if (v38 > 16383) break;\n          v39 = -v37;\n          if (v37 > 0) v39 = fi[v36];\n          if (v39 > 16383) break;\n          if (v8 == ++v36) {\n            shift = 0;\n            goto LABEL_11;\n          }\n        }\n        ++scale;\n        shift = 1;\n      }\n    }\n  }\n  return scale;\n}", "binary": "fft-int/fft-int.host.O3", "assembly": "<fix_fft>:\nendbr64\npush   %r15\nmov    $0x1,%eax\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %ecx,-0x18(%rsp)\nmov    %edx,%ecx\nshl    %cl,%eax\ncmp    $0x400,%eax\njg     1632 <fix_fft+0x2c2>\nmov    %rsi,%rbx\nlea    -0x1(%rax),%esi\nmov    %rdi,%r11\nmov    %eax,%ebp\ntest   %esi,%esi\njle    1406 <fix_fft+0x96>\nlea    -0x2(%rax),%r8d\nmov    $0x1,%edi\nxor    %ecx,%ecx\nadd    $0x2,%r8\nnopl   0x0(%rax)\nmov    %ebp,%eax\nnopw   0x0(%rax,%rax,1)\nsar    %eax\nlea    (%rax,%rcx,1),%edx\ncmp    %esi,%edx\njg     13c0 <fix_fft+0x50>\nlea    -0x1(%rax),%edx\nand    %ecx,%edx\nlea    (%rdx,%rax,1),%ecx\ncmp    %edi,%ecx\njle    13fd <fix_fft+0x8d>\nmovslq %ecx,%rax\nmov    (%r11,%rdi,4),%r9d\nshl    $0x2,%rax\nlea    (%r11,%rax,1),%rdx\nadd    %rbx,%rax\nmov    (%rdx),%r10d\nmov    %r10d,(%r11,%rdi,4)\nmov    %r9d,(%rdx)\nmov    (%rbx,%rdi,4),%edx\nmov    (%rax),%r9d\nmov    %r9d,(%rbx,%rdi,4)\nmov    %edx,(%rax)\nadd    $0x1,%rdi\ncmp    %rdi,%r8\njne    13b8 <fix_fft+0x48>\nmovl   $0x0,-0xc(%rsp)\ncmp    $0x1,%ebp\njle    163a <fix_fft+0x2ca>\nmov    -0x18(%rsp),%esi\nmovslq %ebp,%rax\nmovl   $0x9,-0x1c(%rsp)\nmov    $0x1,%edx\nmov    %rax,-0x8(%rsp)\nmovl   $0x1,-0x20(%rsp)\ntest   %esi,%esi\njne    1557 <fix_fft+0x1e7>\ncmp    %edx,%ebp\nmov    %edx,%edi\nlea    (%rdx,%rdx,1),%eax\ncmovle %ebp,%edi\nmov    %eax,-0x10(%rsp)\nxor    %r10d,%r10d\nmovslq %eax,%r9\nmov    %edi,-0x14(%rsp)\nmovslq %edx,%rdi\nshl    $0x2,%rdi\nlea    (%r11,%rdi,1),%r8\nadd    %rbx,%rdi\ncs nopw 0x0(%rax,%rax,1)\nmovzbl -0x1c(%rsp),%ecx\nmov    %r10d,%eax\nshl    %cl,%eax\nlea    0x8d3f(%rip),%rcx\nlea    0x100(%rax),%edx\ncltq\nmov    (%rcx,%rax,4),%r13d\nmovslq %edx,%rdx\nmov    (%rcx,%rdx,4),%r14d\nmov    -0x18(%rsp),%edx\nmov    %r13d,%eax\nmov    -0x20(%rsp),%ecx\nneg    %eax\ntest   %edx,%edx\ncmove  %eax,%r13d\ntest   %ecx,%ecx\nje     15a8 <fix_fft+0x238>\nsar    %r14d\nmov    %r10,%rdx\nsar    %r13d\nnopl   0x0(%rax,%rax,1)\nmov    (%r8,%rdx,4),%esi\nmov    (%rdi,%rdx,4),%eax\nmov    %esi,%ecx\nimul   %r13d,%esi\nmov    %eax,%r12d\nimul   %r14d,%ecx\nimul   %r13d,%r12d\nimul   %r14d,%eax\nsar    $0xf,%esi\nsar    $0xf,%ecx\nsar    $0xf,%r12d\nsub    %r12d,%ecx\nmov    (%r11,%rdx,4),%r12d\nsar    $0xf,%eax\nadd    %esi,%eax\nmov    (%rbx,%rdx,4),%esi\nsar    %r12d\nmov    %r12d,%r15d\nsar    %esi\nsub    %ecx,%r15d\nadd    %r12d,%ecx\nmov    %r15d,(%r8,%rdx,4)\nmov    %esi,%r15d\nsub    %eax,%r15d\nadd    %esi,%eax\nmov    %r15d,(%rdi,%rdx,4)\nmov    %ecx,(%r11,%rdx,4)\nmov    %eax,(%rbx,%rdx,4)\nadd    %r9,%rdx\ncmp    %edx,%ebp\njg     14c0 <fix_fft+0x150>\nadd    $0x1,%r10\ncmp    %r10d,-0x14(%rsp)\njg     1470 <fix_fft+0x100>\nsubl   $0x1,-0x1c(%rsp)\ncmp    -0x10(%rsp),%ebp\njle    163a <fix_fft+0x2ca>\nmov    -0x18(%rsp),%esi\nmov    -0x10(%rsp),%edx\nmovl   $0x1,-0x20(%rsp)\ntest   %esi,%esi\nje     1440 <fix_fft+0xd0>\nmov    -0x8(%rsp),%r8\nxor    %eax,%eax\nxchg   %ax,%ax\nmov    (%r11,%rax,4),%esi\nmov    (%rbx,%rax,4),%edi\nmov    %esi,%ecx\nneg    %ecx\ncmovs  %esi,%ecx\ncmp    $0x3fff,%ecx\njg     1620 <fix_fft+0x2b0>\nmov    %edi,%ecx\nneg    %ecx\ncmovs  %edi,%ecx\ncmp    $0x3fff,%ecx\njg     1620 <fix_fft+0x2b0>\nadd    $0x1,%rax\ncmp    %rax,%r8\njne    1560 <fix_fft+0x1f0>\nmovl   $0x0,-0x20(%rsp)\njmp    1440 <fix_fft+0xd0>\nnopl   0x0(%rax,%rax,1)\nmov    %r10,%rax\nnopl   0x0(%rax,%rax,1)\nmov    (%r8,%rax,4),%edx\nmov    (%rdi,%rax,4),%esi\nmov    %r14d,%ecx\nmov    %r13d,%r12d\nimul   %edx,%ecx\nimul   %esi,%r12d\nimul   %r13d,%edx\nimul   %r14d,%esi\nsar    $0xf,%ecx\nsar    $0xf,%r12d\nsub    %r12d,%ecx\nmov    (%r11,%rax,4),%r12d\nsar    $0xf,%edx\nsar    $0xf,%esi\nadd    %esi,%edx\nmov    %r12d,%r15d\nmov    (%rbx,%rax,4),%esi\nadd    %ecx,%r12d\nsub    %ecx,%r15d\nmov    %r15d,(%r8,%rax,4)\nmov    %esi,%r15d\nadd    %edx,%esi\nsub    %edx,%r15d\nmov    %r15d,(%rdi,%rax,4)\nmov    %r12d,(%r11,%rax,4)\nmov    %esi,(%rbx,%rax,4)\nadd    %r9,%rax\ncmp    %eax,%ebp\njg     15b0 <fix_fft+0x240>\nadd    $0x1,%r10\ncmp    %r10d,-0x14(%rsp)\njg     1470 <fix_fft+0x100>\njmp    1530 <fix_fft+0x1c0>\naddl   $0x1,-0xc(%rsp)\nmovl   $0x1,-0x20(%rsp)\njmp    1440 <fix_fft+0xd0>\nmovl   $0xffffffff,-0xc(%rsp)\nmov    -0xc(%rsp),%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "fix_loud", "content": "/* fix_loud() - compute loudness of freq-spectrum components.\n   n should be ntot/2, where ntot was passed to fix_fft();\n   6 dB is added to account for the omitted alias components.\n   scale_shift should be the result of fix_fft(), if the time-series\n   was obtained from an inverse FFT, 0 otherwise.\n   loud[] is the loudness, in dB wrt 32767; will be +10 to -N_LOUD.\n*/\nvoid\nfix_loud(fixed loud[], fixed fr[], fixed fi[], int n, int scale_shift)\n{\n  int i, max;\n\n  max = 0;\n  if(scale_shift > 0)\n    max = 10;\n  scale_shift = (scale_shift+1) * 6;\n\n  for(i=0; i<n; ++i) {\n    loud[i] = db_from_ampl(fr[i],fi[i]) + scale_shift;\n    if(loud[i] > max)\n      loud[i] = max;\n  }\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O3.pseudo", "function_name": "fix_loud", "address": "0x1a90", "label": "fix_loud", "content": "__int64 __fastcall fix_loud(__int64 a1, __int64 a2, __int64 a3, int a4, int a5)\n{\n  __int64 result; // rax\n  int v6; // r14d\n  int v7; // r15d\n  int v10; // ebx\n  __int64 i; // r10\n  int v12; // r11d\n  int v13; // edi\n  int v14; // edx\n  const __m128i *v15; // rdx\n  int *v16; // rax\n  __m128i v17; // xmm1\n  __m128i v18; // xmm0\n  __m128i v19; // xmm1\n  __m128i v20; // xmm0\n  __m128i v21; // xmm0\n  __int64 v22; // rax\n  int v23; // edi\n  int v24; // ecx\n  int v25; // eax\n  __int64 v26; // [rsp+0h] [rbp-48h]\n\n  result = 10LL;\n  v6 = 0;\n  if ( a5 > 0 )\n    v6 = 10;\n  v7 = 2 * (3 * a5 + 3);\n  if ( a4 > 0 )\n  {\n    v26 = a4;\n    v10 = loud2_0[0];\n    for ( i = 1LL; ; ++i )\n    {\n      v12 = *(_DWORD *)(a3 + 4 * i - 4);\n      v13 = *(_DWORD *)(a2 + 4 * i - 4);\n      v14 = v10;\n      if ( !v10 )\n      {\n        v15 = (const __m128i *)&Loudampl[1];\n        loud2_0[0] = Loudampl[0] * Loudampl[0];\n        v16 = loud2_0;\n        do\n        {\n          v17 = _mm_loadu_si128(v15++);\n          v16 += 4;\n          v18 = _mm_mul_epu32(v17, v17);\n          v19 = _mm_srli_epi64(v17, 0x20u);\n          v20 = _mm_unpacklo_epi32(_mm_shuffle_epi32(v18, 8), _mm_shuffle_epi32(_mm_mul_epu32(v19, v19), 8));\n          *(__m128i *)(v16 - 3) = v20;\n          v21 = _mm_add_epi32(v20, *((__m128i *)v16 - 1));\n          *((__m128i *)v16 - 1) = _mm_srai_epi32(_mm_sub_epi32(v21, _mm_cmpgt_epi32((__m128i)0LL, v21)), 1u);\n        }\n        while ( v15 != (const __m128i *)&Loudampl[97] );\n        LODWORD(xmmword_B5A0) = _mm_unpacklo_epi32(\n                                  _mm_cvtsi32_si128((Loudampl[97] * Loudampl[97] + (int)xmmword_B5A0) / 2),\n                                  _mm_cvtsi32_si128(Loudampl[97] * Loudampl[97])).m128i_u32[0];\n        DWORD1(xmmword_B5A0) = (Loudampl[98] * Loudampl[98] + Loudampl[97] * Loudampl[97]) >> 1;\n        HIDWORD(xmmword_B5A0) = Loudampl[99] * Loudampl[99];\n        v14 = loud2_0[0];\n        DWORD2(xmmword_B5A0) = (Loudampl[98] * Loudampl[98] + Loudampl[99] * Loudampl[99]) >> 1;\n      }\n      v22 = 0LL;\n      v23 = v12 * v12 + v13 * v13;\n      while ( 1 )\n      {\n        v24 = v22;\n        if ( v23 >= loud2_0[v22] )\n          break;\n        if ( ++v22 == 100 )\n        {\n          v24 = 100;\n          break;\n        }\n      }\n      v25 = v7 - v24;\n      if ( v7 - v24 > v6 )\n        v25 = v6;\n      *(_DWORD *)(a1 + 4 * i - 4) = v25;\n      result = (int)i;\n      if ( v26 == i )\n        break;\n      if ( v10 )\n        JUMPOUT(0x1135LL);\n      v10 = v14;\n    }\n  }\n  return result;\n}\n"}, "pseudo_normalize": "long long fix_loud(long long a1, long long a2, long long a3, int a4, int a5) {\n  long long result;\n  int v6;\n  int v7;\n  int v10;\n  long long i;\n  int v12;\n  int v13;\n  int v14;\n  const __m128i *v15;\n  int *v16;\n  __m128i v17;\n  __m128i v18;\n  __m128i v19;\n  __m128i v20;\n  __m128i v21;\n  long long v22;\n  int v23;\n  int v24;\n  int v25;\n  long long v26;\n  result = 10LL;\n  v6 = 0;\n  if (a5 > 0) v6 = 10;\n  v7 = 2 * (3 * a5 + 3);\n  if (a4 > 0) {\n    v26 = a4;\n    v10 = loud2_0[0];\n    for (i = 1LL;; ++i) {\n      v12 = *(uint32_t *)(a3 + 4 * i - 4);\n      v13 = *(uint32_t *)(a2 + 4 * i - 4);\n      v14 = v10;\n      if (!v10) {\n        v15 = (const __m128i *)&Loudampl[1];\n        loud2_0[0] = Loudampl[0] * Loudampl[0];\n        v16 = loud2_0;\n        do {\n          v17 = _mm_loadu_si128(v15++);\n          v16 += 4;\n          v18 = _mm_mul_epu32(v17, v17);\n          v19 = _mm_srli_epi64(v17, 32u);\n          v20 =\n              _mm_unpacklo_epi32(_mm_shuffle_epi32(v18, 8),\n                                 _mm_shuffle_epi32(_mm_mul_epu32(v19, v19), 8));\n          *(__m128i *)(v16 - 3) = v20;\n          v21 = _mm_add_epi32(v20, *((__m128i *)v16 - 1));\n          *((__m128i *)v16 - 1) = _mm_srai_epi32(\n              _mm_sub_epi32(v21, _mm_cmpgt_epi32((__m128i)0LL, v21)), 1u);\n        } while (v15 != (const __m128i *)&Loudampl[97]);\n        LODWORD(xmmword_B5A0) =\n            _mm_unpacklo_epi32(\n                _mm_cvtsi32_si128(\n                    (Loudampl[97] * Loudampl[97] + (int)xmmword_B5A0) / 2),\n                _mm_cvtsi32_si128(Loudampl[97] * Loudampl[97]))\n                .m128i_u32[0];\n        DWORD1(xmmword_B5A0) =\n            (Loudampl[98] * Loudampl[98] + Loudampl[97] * Loudampl[97]) >> 1;\n        HIDWORD(xmmword_B5A0) = Loudampl[99] * Loudampl[99];\n        v14 = loud2_0[0];\n        DWORD2(xmmword_B5A0) =\n            (Loudampl[98] * Loudampl[98] + Loudampl[99] * Loudampl[99]) >> 1;\n      }\n      v22 = 0LL;\n      v23 = v12 * v12 + v13 * v13;\n      while (1) {\n        v24 = v22;\n        if (v23 >= loud2_0[v22]) break;\n        if (++v22 == 100) {\n          v24 = 100;\n          break;\n        }\n      }\n      v25 = v7 - v24;\n      if (v7 - v24 > v6) v25 = v6;\n      *(uint32_t *)(a1 + 4 * i - 4) = v25;\n      result = (int)i;\n      if (v26 == i) break;\n      if (v10) JUMPOUT(4405LL);\n      v10 = v14;\n    }\n  }\n  return result;\n}", "binary": "fft-int/fft-int.host.O3", "assembly": "<fix_loud>:\nendbr64\npush   %r15\nmov    $0xa,%eax\nlea    0x3(%r8,%r8,2),%r15d\npush   %r14\nxor    %r14d,%r14d\ntest   %r8d,%r8d\npush   %r13\ncmovg  %eax,%r14d\nadd    %r15d,%r15d\npush   %r12\npush   %rbp\npush   %rbx\nmov    %ecx,-0xc(%rsp)\ntest   %ecx,%ecx\njle    1c37 <fix_loud+0x1a7>\nmovslq %ecx,%rax\nlea    0x9955(%rip),%r8\nmov    %rsi,%r12\nmov    %rdi,%rbp\nmov    %rax,-0x18(%rsp)\nmov    %rdx,%r13\nmov    %r8,%rsi\npxor   %xmm2,%xmm2\nmov    0x993a(%rip),%ebx\nmov    $0x1,%r10d\nlea    0x86b1(%rip),%r9\nnopl   0x0(%rax,%rax,1)\nmov    -0x4(%r13,%r10,4),%r11d\nmov    -0x4(%r12,%r10,4),%edi\nmov    %ebx,%edx\ntest   %ebx,%ebx\njne    1bda <fix_loud+0x14a>\nmov    0x850e(%rip),%eax\nlea    0x850b(%rip),%rdx\nimul   %eax,%eax\nmov    %eax,(%r8)\nmov    %rsi,%r8\nlea    0x98f7(%rip),%rax\nnopl   0x0(%rax)\nmovdqu (%rdx),%xmm1\nadd    $0x10,%rdx\nadd    $0x10,%rax\nmovdqa %xmm1,%xmm0\npmuludq %xmm1,%xmm0\npsrlq  $0x20,%xmm1\npmuludq %xmm1,%xmm1\npshufd $0x8,%xmm0,%xmm0\npshufd $0x8,%xmm1,%xmm1\npunpckldq %xmm1,%xmm0\nmovdqa %xmm2,%xmm1\nmovups %xmm0,-0xc(%rax)\npaddd  -0x10(%rax),%xmm0\npcmpgtd %xmm0,%xmm1\npsubd  %xmm1,%xmm0\npsrad  $0x1,%xmm0\nmovaps %xmm0,-0x10(%rax)\ncmp    %r9,%rdx\njne    1b30 <fix_loud+0xa0>\nmov    0x8620(%rip),%eax\nmov    0x9a16(%rip),%ecx\nimul   %eax,%eax\nadd    %eax,%ecx\nmovd   %eax,%xmm3\nmov    %ecx,%edx\nshr    $0x1f,%edx\nadd    %ecx,%edx\nsar    %edx\nmovd   %edx,%xmm0\nmov    0x8602(%rip),%edx\npunpckldq %xmm3,%xmm0\nmovq   %xmm0,0x99ee(%rip)\nimul   %edx,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,0x99e5(%rip)\nmov    0x85e7(%rip),%eax\nimul   %eax,%eax\nmov    %eax,0x99de(%rip)\nadd    %edx,%eax\nmov    (%rsi),%edx\nsar    %eax\nmov    %eax,0x99ce(%rip)\nimul   %edi,%edi\nxor    %eax,%eax\nimul   %r11d,%r11d\nadd    %r11d,%edi\njmp    1bfa <fix_loud+0x16a>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rax\ncmp    $0x64,%rax\nje     1c30 <fix_loud+0x1a0>\nmov    %eax,%ecx\ncmp    (%r8,%rax,4),%edi\njl     1bf0 <fix_loud+0x160>\nmov    %r15d,%eax\nsub    %ecx,%eax\ncmp    %r14d,%eax\ncmovg  %r14d,%eax\nmov    %eax,-0x4(%rbp,%r10,4)\nmovslq %r10d,%rax\ncmp    %r10,-0x18(%rsp)\nje     1c37 <fix_loud+0x1a7>\nadd    $0x1,%r10\ntest   %ebx,%ebx\njne    1135 <fix_loud.cold+0x35>\nmov    %edx,%ebx\njmp    1af8 <fix_loud+0x68>\nmov    $0x64,%ecx\njmp    1c02 <fix_loud+0x172>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "fix_mpy", "content": "/* fix_mpy() - fixed-point multiplication */\nfixed\nfix_mpy(fixed a, fixed b)\n{\n  FIX_MPY(a,a,b);\n  return a;\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O3.pseudo", "function_name": "fix_mpy", "address": "0x1d70", "label": "fix_mpy", "content": "int __fastcall fix_mpy(int a, int b)\n{\n  return (b * a) >> 15;\n}\n"}, "pseudo_normalize": "", "binary": "fft-int/fft-int.host.O3", "assembly": "<fix_mpy>:\nendbr64\nimul   %esi,%edi\nmov    %edi,%eax\nsar    $0xf,%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "iscale", "content": "/* iscale() - scale an integer value by (numer/denom) */\nint\niscale(int value, int numer, int denom)\n{\n  return (int) value * (int)numer/(int)denom;\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O3.pseudo", "function_name": "iscale", "address": "0x1d80", "label": "iscale", "content": "int __fastcall iscale(int value, int numer, int denom)\n{\n  return numer * value / denom;\n}\n"}, "pseudo_normalize": "", "binary": "fft-int/fft-int.host.O3", "assembly": "<iscale>:\nendbr64\nmov    %edi,%eax\nmov    %edx,%r8d\nimul   %esi,%eax\ncltd\nidiv   %r8d\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "window", "content": "/* window() - apply a Hanning window       */\nvoid\nwindow(fixed fr[], int n)\n{\n  int i,j,k;\n\n  j = N_WAVE/n;\n  n >>= 1;\n  for(i=0,k=N_WAVE/4; i<n; ++i,k+=j)\n    FIX_MPY(fr[i],fr[i],16384-(Sinewave[k]>>1));\n  n <<= 1;\n  for(k-=j; i<n; ++i,k-=j)\n    FIX_MPY(fr[i],fr[i],16384-(Sinewave[k]>>1));\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O3.pseudo", "function_name": "window", "address": "0x1650", "label": "window", "content": "void __fastcall window(int *fr, int n)\n{\n  int v3; // eax\n  int v4; // esi\n  unsigned int v6; // r10d\n  __int64 v7; // rdx\n  int *v8; // rbp\n  __int64 v9; // rcx\n  unsigned int *v10; // rdx\n  int *v11; // rdi\n  int *v12; // rcx\n  bool v13; // di\n  int *v14; // rcx\n  __m128i si128; // xmm2\n  __m128i v16; // xmm0\n  __m128i v17; // xmm4\n  __m128i v18; // xmm1\n  __m128i v19; // xmm5\n  __m128i v20; // xmm0\n  unsigned int v21; // edi\n  signed int v22; // ecx\n  __int64 v23; // rdx\n  int v24; // ecx\n  __int64 v25; // rbp\n  __int64 v26; // rdx\n  int v27; // ecx\n  signed int v28; // r8d\n  unsigned int v29; // ebp\n  int v30; // r15d\n  int *v31; // rcx\n  __int64 v32; // rbx\n  __int64 v33; // rdx\n  __int64 v34; // rdi\n  __int64 v35; // r10\n  __int64 v36; // rbx\n  bool v37; // bl\n  __m128i v38; // xmm2\n  unsigned int *v39; // rdx\n  __int64 v40; // rbx\n  __m128i v41; // xmm0\n  __m128i v42; // xmm6\n  __m128i v43; // xmm1\n  __m128i v44; // xmm7\n  __m128i v45; // xmm0\n  unsigned int v46; // esi\n  signed int v47; // edx\n  __int64 v48; // rcx\n  int v49; // edx\n  __int64 v50; // r10\n  __int64 v51; // rdi\n  int v52; // edx\n  int *v53; // rdx\n  int *v54; // r9\n  int v55; // esi\n  int *v56; // rcx\n  int *v57; // rbx\n  int v58; // r14d\n  int v59; // [rsp+0h] [rbp-44h]\n  int *v60; // [rsp+4h] [rbp-40h]\n\n  v3 = 1024 / n;\n  v4 = n >> 1;\n  if ( v4 > 0 )\n  {\n    v6 = v4 - 1;\n    v7 = v4 - 1LL;\n    v8 = &fr[v7];\n    v9 = v7 * v3;\n    v10 = (unsigned int *)&Sinewave[256];\n    v11 = &Sinewave[256];\n    v12 = &Sinewave[v9 + 256];\n    if ( v3 < 0 )\n      v11 = v12;\n    v13 = v8 < v11;\n    if ( v3 < 0 )\n      v12 = &Sinewave[256];\n    if ( (fr > v12 || v13) && v6 > 6 )\n    {\n      v14 = fr;\n      si128 = _mm_load_si128((const __m128i *)&xmmword_7010);\n      do\n      {\n        v16 = _mm_cvtsi32_si128(v10[2 * v3]);\n        v17 = _mm_cvtsi32_si128(v10[3 * v3]);\n        v14 += 4;\n        v18 = _mm_cvtsi32_si128(*v10);\n        v19 = _mm_cvtsi32_si128(v10[v3]);\n        v10 += 4 * v3;\n        v20 = _mm_sub_epi32(\n                si128,\n                _mm_srai_epi32(_mm_unpacklo_epi64(_mm_unpacklo_epi32(v18, v19), _mm_unpacklo_epi32(v16, v17)), 1u));\n        *((__m128i *)v14 - 1) = _mm_srai_epi32(\n                                  _mm_unpacklo_epi32(\n                                    _mm_shuffle_epi32(_mm_mul_epu32(_mm_loadu_si128((const __m128i *)v14 - 1), v20), 8),\n                                    _mm_shuffle_epi32(\n                                      _mm_mul_epu32(\n                                        _mm_srli_epi64(v20, 0x20u),\n                                        _mm_srli_epi64(_mm_loadu_si128((const __m128i *)v14 - 1), 0x20u)),\n                                      8)),\n                                  0xFu);\n      }\n      while ( v14 != &fr[4 * ((unsigned int)v4 >> 2)] );\n      v21 = v4 & 0x7FFFFFFC;\n      v22 = (v4 & 0xFFFFFFFC) * v3 + 256;\n      if ( v4 != (v4 & 0xFFFFFFFC) )\n      {\n        v23 = v22;\n        v24 = v3 + v22;\n        v25 = v21;\n        fr[v25] = (fr[v25] * (0x4000 - (Sinewave[v23] >> 1))) >> 15;\n        if ( v4 > (int)(v21 + 1) )\n        {\n          v26 = v24;\n          v27 = v3 + v24;\n          fr[v25 + 1] = (fr[v25 + 1] * (0x4000 - (Sinewave[v26] >> 1))) >> 15;\n          if ( v4 > (int)(v21 + 2) )\n            fr[v25 + 2] = ((0x4000 - (Sinewave[v27] >> 1)) * fr[v25 + 2]) >> 15;\n        }\n      }\n    }\n    else\n    {\n      v56 = fr;\n      v57 = &Sinewave[256];\n      do\n      {\n        v58 = *v57;\n        ++v56;\n        v57 += v3;\n        *(v56 - 1) = (*(v56 - 1) * (0x4000 - (v58 >> 1))) >> 15;\n      }\n      while ( v56 != &fr[v6 + 1] );\n    }\n    v28 = n & 0xFFFFFFFE;\n    v59 = v3 * v6 + 256;\n    if ( v4 < v28 )\n    {\n      v29 = v28 - v4;\n      v30 = -v3;\n      v31 = &fr[v4];\n      v32 = (unsigned int)(v28 - v4);\n      v33 = v59;\n      v34 = 4LL * -v3;\n      v35 = v34 * (v32 - 1);\n      v60 = &fr[v32 - 1 + v4];\n      v36 = 0LL;\n      if ( v3 > 0 )\n        v36 = v35;\n      v37 = v60 < (int *)((char *)&Sinewave[v33] + v36);\n      if ( v3 > 0 )\n        v35 = 0LL;\n      if ( (v37 || v31 > (int *)((char *)&Sinewave[v33] + v35)) && v29 - 1 > 6 )\n      {\n        v38 = _mm_load_si128((const __m128i *)&xmmword_7010);\n        v39 = (unsigned int *)&Sinewave[v33];\n        v40 = (__int64)&v31[4 * (v29 >> 2)];\n        do\n        {\n          v41 = _mm_cvtsi32_si128(v39[2 * v30]);\n          v42 = _mm_cvtsi32_si128(v39[3 * v30]);\n          v31 += 4;\n          v43 = _mm_cvtsi32_si128(*v39);\n          v44 = _mm_cvtsi32_si128(v39[v30]);\n          v39 += 4 * v30;\n          v45 = _mm_sub_epi32(\n                  v38,\n                  _mm_srai_epi32(_mm_unpacklo_epi64(_mm_unpacklo_epi32(v43, v44), _mm_unpacklo_epi32(v41, v42)), 1u));\n          *((__m128i *)v31 - 1) = _mm_srai_epi32(\n                                    _mm_unpacklo_epi32(\n                                      _mm_shuffle_epi32(\n                                        _mm_mul_epu32(_mm_loadu_si128((const __m128i *)v31 - 1), v45),\n                                        8),\n                                      _mm_shuffle_epi32(\n                                        _mm_mul_epu32(\n                                          _mm_srli_epi64(v45, 0x20u),\n                                          _mm_srli_epi64(_mm_loadu_si128((const __m128i *)v31 - 1), 0x20u)),\n                                        8)),\n                                    0xFu);\n        }\n        while ( (int *)v40 != v31 );\n        v46 = (v29 & 0xFFFFFFFC) + v4;\n        v47 = v59 + (v29 & 0xFFFFFFFC) * v30;\n        if ( v29 != (v29 & 0xFFFFFFFC) )\n        {\n          v48 = v47;\n          v49 = v47 - v3;\n          fr[v46] = (fr[v46] * (0x4000 - (Sinewave[v48] >> 1))) >> 15;\n          if ( v28 > (int)(v46 + 1) )\n          {\n            v50 = (int)(v46 + 1);\n            v51 = v49;\n            v52 = v49 - v3;\n            fr[v50] = (fr[v50] * (0x4000 - (Sinewave[v51] >> 1))) >> 15;\n            if ( v28 > (int)(v46 + 2) )\n              fr[v50 + 1] = (fr[v50 + 1] * (0x4000 - (Sinewave[v52] >> 1))) >> 15;\n          }\n        }\n      }\n      else\n      {\n        v53 = &Sinewave[v33];\n        v54 = &fr[(unsigned int)(v28 - 1 - v4) + 1 + (__int64)v4];\n        do\n        {\n          v55 = *v53;\n          ++v31;\n          v53 = (int *)((char *)v53 + v34);\n          *(v31 - 1) = (*(v31 - 1) * (0x4000 - (v55 >> 1))) >> 15;\n        }\n        while ( v54 != v31 );\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void window(int *fr, int n) {\n  int v3;\n  int v4;\n  unsigned int v6;\n  long long v7;\n  int *v8;\n  long long v9;\n  unsigned int *v10;\n  int *v11;\n  int *v12;\n  bool v13;\n  int *v14;\n  __m128i si128;\n  __m128i v16;\n  __m128i v17;\n  __m128i v18;\n  __m128i v19;\n  __m128i v20;\n  unsigned int v21;\n  signed int v22;\n  long long v23;\n  int v24;\n  long long v25;\n  long long v26;\n  int v27;\n  signed int v28;\n  unsigned int v29;\n  int v30;\n  int *v31;\n  long long v32;\n  long long v33;\n  long long v34;\n  long long v35;\n  long long v36;\n  bool v37;\n  __m128i v38;\n  unsigned int *v39;\n  long long v40;\n  __m128i v41;\n  __m128i v42;\n  __m128i v43;\n  __m128i v44;\n  __m128i v45;\n  unsigned int v46;\n  signed int v47;\n  long long v48;\n  int v49;\n  long long v50;\n  long long v51;\n  int v52;\n  int *v53;\n  int *v54;\n  int v55;\n  int *v56;\n  int *v57;\n  int v58;\n  int v59;\n  int *v60;\n  v3 = 1024 / n;\n  v4 = n >> 1;\n  if (v4 > 0) {\n    v6 = v4 - 1;\n    v7 = v4 - 1LL;\n    v8 = &fr[v7];\n    v9 = v7 * v3;\n    v10 = (unsigned int *)&Sinewave[256];\n    v11 = &Sinewave[256];\n    v12 = &Sinewave[v9 + 256];\n    if (v3 < 0) v11 = v12;\n    v13 = v8 < v11;\n    if (v3 < 0) v12 = &Sinewave[256];\n    if ((fr > v12 || v13) && v6 > 6) {\n      v14 = fr;\n      si128 = _mm_load_si128((const __m128i *)&xmmword_7010);\n      do {\n        v16 = _mm_cvtsi32_si128(v10[2 * v3]);\n        v17 = _mm_cvtsi32_si128(v10[3 * v3]);\n        v14 += 4;\n        v18 = _mm_cvtsi32_si128(*v10);\n        v19 = _mm_cvtsi32_si128(v10[v3]);\n        v10 += 4 * v3;\n        v20 = _mm_sub_epi32(\n            si128,\n            _mm_srai_epi32(_mm_unpacklo_epi64(_mm_unpacklo_epi32(v18, v19),\n                                              _mm_unpacklo_epi32(v16, v17)),\n                           1u));\n        *((__m128i *)v14 - 1) = _mm_srai_epi32(\n            _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(\n                    _mm_mul_epu32(_mm_loadu_si128((const __m128i *)v14 - 1),\n                                  v20),\n                    8),\n                _mm_shuffle_epi32(\n                    _mm_mul_epu32(\n                        _mm_srli_epi64(v20, 32u),\n                        _mm_srli_epi64(\n                            _mm_loadu_si128((const __m128i *)v14 - 1), 32u)),\n                    8)),\n            15u);\n      } while (v14 != &fr[4 * ((unsigned int)v4 >> 2)]);\n      v21 = v4 & 2147483644;\n      v22 = (v4 & 4294967292) * v3 + 256;\n      if (v4 != (v4 & 4294967292)) {\n        v23 = v22;\n        v24 = v3 + v22;\n        v25 = v21;\n        fr[v25] = (fr[v25] * (16384 - (Sinewave[v23] >> 1))) >> 15;\n        if (v4 > (int)(v21 + 1)) {\n          v26 = v24;\n          v27 = v3 + v24;\n          fr[v25 + 1] = (fr[v25 + 1] * (16384 - (Sinewave[v26] >> 1))) >> 15;\n          if (v4 > (int)(v21 + 2))\n            fr[v25 + 2] = ((16384 - (Sinewave[v27] >> 1)) * fr[v25 + 2]) >> 15;\n        }\n      }\n    } else {\n      v56 = fr;\n      v57 = &Sinewave[256];\n      do {\n        v58 = *v57;\n        ++v56;\n        v57 += v3;\n        *(v56 - 1) = (*(v56 - 1) * (16384 - (v58 >> 1))) >> 15;\n      } while (v56 != &fr[v6 + 1]);\n    }\n    v28 = n & 4294967294;\n    v59 = v3 * v6 + 256;\n    if (v4 < v28) {\n      v29 = v28 - v4;\n      v30 = -v3;\n      v31 = &fr[v4];\n      v32 = (unsigned int)(v28 - v4);\n      v33 = v59;\n      v34 = 4LL * -v3;\n      v35 = v34 * (v32 - 1);\n      v60 = &fr[v32 - 1 + v4];\n      v36 = 0LL;\n      if (v3 > 0) v36 = v35;\n      v37 = v60 < (int *)((char *)&Sinewave[v33] + v36);\n      if (v3 > 0) v35 = 0LL;\n      if ((v37 || v31 > (int *)((char *)&Sinewave[v33] + v35)) && v29 - 1 > 6) {\n        v38 = _mm_load_si128((const __m128i *)&xmmword_7010);\n        v39 = (unsigned int *)&Sinewave[v33];\n        v40 = (long long)&v31[4 * (v29 >> 2)];\n        do {\n          v41 = _mm_cvtsi32_si128(v39[2 * v30]);\n          v42 = _mm_cvtsi32_si128(v39[3 * v30]);\n          v31 += 4;\n          v43 = _mm_cvtsi32_si128(*v39);\n          v44 = _mm_cvtsi32_si128(v39[v30]);\n          v39 += 4 * v30;\n          v45 = _mm_sub_epi32(\n              v38,\n              _mm_srai_epi32(_mm_unpacklo_epi64(_mm_unpacklo_epi32(v43, v44),\n                                                _mm_unpacklo_epi32(v41, v42)),\n                             1u));\n          *((__m128i *)v31 - 1) = _mm_srai_epi32(\n              _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(\n                      _mm_mul_epu32(_mm_loadu_si128((const __m128i *)v31 - 1),\n                                    v45),\n                      8),\n                  _mm_shuffle_epi32(\n                      _mm_mul_epu32(\n                          _mm_srli_epi64(v45, 32u),\n                          _mm_srli_epi64(\n                              _mm_loadu_si128((const __m128i *)v31 - 1), 32u)),\n                      8)),\n              15u);\n        } while ((int *)v40 != v31);\n        v46 = (v29 & 4294967292) + v4;\n        v47 = v59 + (v29 & 4294967292) * v30;\n        if (v29 != (v29 & 4294967292)) {\n          v48 = v47;\n          v49 = v47 - v3;\n          fr[v46] = (fr[v46] * (16384 - (Sinewave[v48] >> 1))) >> 15;\n          if (v28 > (int)(v46 + 1)) {\n            v50 = (int)(v46 + 1);\n            v51 = v49;\n            v52 = v49 - v3;\n            fr[v50] = (fr[v50] * (16384 - (Sinewave[v51] >> 1))) >> 15;\n            if (v28 > (int)(v46 + 2))\n              fr[v50 + 1] =\n                  (fr[v50 + 1] * (16384 - (Sinewave[v52] >> 1))) >> 15;\n          }\n        }\n      } else {\n        v53 = &Sinewave[v33];\n        v54 = &fr[(unsigned int)(v28 - 1 - v4) + 1 + (long long)v4];\n        do {\n          v55 = *v53;\n          ++v31;\n          v53 = (int *)((char *)v53 + v34);\n          *(v31 - 1) = (*(v31 - 1) * (16384 - (v55 >> 1))) >> 15;\n        } while (v54 != v31);\n      }\n    }\n  }\n}", "binary": "fft-int/fft-int.host.O3", "assembly": "<window>:\nendbr64\nmov    $0x400,%eax\nmov    %esi,%r8d\ncltd\nidiv   %esi\nsar    %esi\ntest   %esi,%esi\njle    1a80 <window+0x430>\npush   %r15\nlea    0x8b4e(%rip),%r11\nmov    %rdi,%r9\nlea    -0x1(%rsi),%r10d\npush   %r14\npush   %r13\nmovslq %esi,%r13\npush   %r12\nlea    -0x1(%r13),%rdx\npush   %rbp\nlea    (%rdi,%rdx,4),%rbp\npush   %rbx\nmovslq %eax,%rbx\nmov    %rbx,%rcx\nimul   %rdx,%rcx\nlea    0x400(%r11),%rdx\ntest   %eax,%eax\nmov    %rdx,%rdi\nlea    0x400(%r11,%rcx,4),%rcx\ncmovs  %rcx,%rdi\ncmp    %rdi,%rbp\nsetb   %dil\ntest   %eax,%eax\ncmovs  %rdx,%rcx\ncmp    %rcx,%r9\nseta   %cl\nor     %cl,%dil\nje     1a28 <window+0x3d8>\ncmp    $0x6,%r10d\njbe    1a28 <window+0x3d8>\nmov    %esi,%ebp\nmov    %rbx,%r12\nlea    0x0(,%rbx,4),%rdi\nmov    %r9,%rcx\nshr    $0x2,%ebp\nlea    (%rbx,%rbx,2),%rbx\nmovdqa 0x591d(%rip),%xmm2\nshl    $0x4,%r12\nsub    $0x1,%ebp\nshl    $0x2,%rbx\nshl    $0x4,%rbp\nlea    0x10(%r9,%rbp,1),%rbp\nnopw   0x0(%rax,%rax,1)\nmovd   (%rdx,%rdi,2),%xmm0\nmovd   (%rdx,%rbx,1),%xmm4\nadd    $0x10,%rcx\nmovd   (%rdx),%xmm1\nmovd   (%rdx,%rdi,1),%xmm5\nadd    %r12,%rdx\npunpckldq %xmm4,%xmm0\nmovdqu -0x10(%rcx),%xmm3\npunpckldq %xmm5,%xmm1\npunpcklqdq %xmm0,%xmm1\npsrlq  $0x20,%xmm3\nmovdqa %xmm2,%xmm0\npsrad  $0x1,%xmm1\npsubd  %xmm1,%xmm0\nmovdqu -0x10(%rcx),%xmm1\npmuludq %xmm0,%xmm1\npsrlq  $0x20,%xmm0\npmuludq %xmm3,%xmm0\npshufd $0x8,%xmm1,%xmm1\npshufd $0x8,%xmm0,%xmm0\npunpckldq %xmm0,%xmm1\nmovdqa %xmm1,%xmm0\npsrad  $0xf,%xmm0\nmovups %xmm0,-0x10(%rcx)\ncmp    %rbp,%rcx\njne    1710 <window+0xc0>\nmov    %esi,%edi\nmov    %eax,%ecx\nand    $0xfffffffc,%edi\nimul   %edi,%ecx\nadd    $0x100,%ecx\ncmp    %edi,%esi\nje     1809 <window+0x1b9>\nmovslq %ecx,%rdx\nmov    %edi,%ebp\nmov    $0x4000,%ebx\nadd    %eax,%ecx\nmov    (%r11,%rdx,4),%r14d\nshl    $0x2,%rbp\nmov    %ebx,%edx\nlea    (%r9,%rbp,1),%r12\nsar    %r14d\nsub    %r14d,%edx\nimul   (%r12),%edx\nsar    $0xf,%edx\nmov    %edx,(%r12)\nlea    0x1(%rdi),%edx\ncmp    %edx,%esi\njle    1809 <window+0x1b9>\nmovslq %ecx,%rdx\nlea    0x4(%r9,%rbp,1),%r12\nadd    %eax,%ecx\nmov    (%r11,%rdx,4),%r14d\nmov    %ebx,%edx\nsar    %r14d\nsub    %r14d,%edx\nimul   (%r12),%edx\nsar    $0xf,%edx\nmov    %edx,(%r12)\nlea    0x2(%rdi),%edx\ncmp    %edx,%esi\njle    1809 <window+0x1b9>\nmovslq %ecx,%rcx\nlea    0x8(%r9,%rbp,1),%rdi\nmov    (%r11,%rcx,4),%ecx\nmov    (%rdi),%edx\nsar    %ecx\nsub    %ecx,%ebx\nimul   %ebx,%edx\nsar    $0xf,%edx\nmov    %edx,(%rdi)\nimul   %eax,%r10d\nand    $0xfffffffe,%r8d\nlea    0x100(%r10),%ebx\nmov    %ebx,-0x14(%rsp)\ncmp    %r8d,%esi\njge    19c8 <window+0x378>\nmov    %r8d,%ebp\nmov    %eax,%r15d\nmovslq -0x14(%rsp),%rdx\nxor    %r14d,%r14d\nsub    %esi,%ebp\nneg    %r15d\nlea    (%r9,%r13,4),%rcx\nmov    %ebp,%ebx\nmovslq %r15d,%r12\nshl    $0x2,%rdx\nlea    -0x1(%rbx),%r10\nlea    0x0(,%r12,4),%rdi\nimul   %rdi,%r10\nlea    -0x1(%rbx,%r13,1),%rbx\ntest   %eax,%eax\nlea    (%r9,%rbx,4),%rbx\nmov    %rbx,-0x10(%rsp)\nmov    %r14,%rbx\ncmovg  %r10,%rbx\nadd    %rdx,%rbx\nadd    %r11,%rbx\ncmp    %rbx,-0x10(%rsp)\nsetb   %bl\ntest   %eax,%eax\ncmovg  %r14,%r10\nadd    %rdx,%r10\nadd    %r11,%r10\ncmp    %r10,%rcx\nseta   %r10b\nor     %bl,%r10b\nje     19d8 <window+0x388>\nlea    -0x1(%rbp),%r10d\ncmp    $0x6,%r10d\njbe    19d8 <window+0x388>\nmov    %ebp,%ebx\nmov    %r12,%r10\nmovdqa 0x575f(%rip),%xmm2\nadd    %r11,%rdx\nshr    $0x2,%ebx\nlea    (%r12,%r12,2),%r12\nshl    $0x4,%r10\nsub    $0x1,%ebx\nshl    $0x2,%r12\nshl    $0x4,%rbx\nlea    0x10(%rcx,%rbx,1),%rbx\nnop\nmovd   (%rdx,%rdi,2),%xmm0\nmovd   (%rdx,%r12,1),%xmm6\nadd    $0x10,%rcx\nmovd   (%rdx),%xmm1\nmovd   (%rdx,%rdi,1),%xmm7\nadd    %r10,%rdx\npunpckldq %xmm6,%xmm0\nmovdqu -0x10(%rcx),%xmm3\npunpckldq %xmm7,%xmm1\npunpcklqdq %xmm0,%xmm1\npsrlq  $0x20,%xmm3\nmovdqa %xmm2,%xmm0\npsrad  $0x1,%xmm1\npsubd  %xmm1,%xmm0\nmovdqu -0x10(%rcx),%xmm1\npmuludq %xmm0,%xmm1\npsrlq  $0x20,%xmm0\npmuludq %xmm3,%xmm0\npshufd $0x8,%xmm1,%xmm1\npshufd $0x8,%xmm0,%xmm0\npunpckldq %xmm0,%xmm1\npsrad  $0xf,%xmm1\nmovups %xmm1,-0x10(%rcx)\ncmp    %rcx,%rbx\njne    18d0 <window+0x280>\nmov    %ebp,%ecx\nmov    %r15d,%edx\nand    $0xfffffffc,%ecx\nimul   %ecx,%edx\nadd    %ecx,%esi\nadd    -0x14(%rsp),%edx\ncmp    %ecx,%ebp\nje     19c8 <window+0x378>\nmovslq %esi,%rcx\nlea    (%r9,%rcx,4),%rbx\nmovslq %edx,%rcx\nsub    %eax,%edx\nmov    (%r11,%rcx,4),%r10d\nmov    $0x4000,%ecx\nmov    %ecx,%edi\nsar    %r10d\nsub    %r10d,%edi\nimul   (%rbx),%edi\nsar    $0xf,%edi\nmov    %edi,(%rbx)\nlea    0x1(%rsi),%edi\ncmp    %edi,%r8d\njle    19c8 <window+0x378>\nmovslq %edi,%rdi\nadd    $0x2,%esi\nlea    0x0(,%rdi,4),%r10\nmovslq %edx,%rdi\nsub    %eax,%edx\nmov    (%r11,%rdi,4),%ebx\nlea    (%r9,%r10,1),%rbp\nmov    %ecx,%edi\nsar    %ebx\nsub    %ebx,%edi\nimul   0x0(%rbp),%edi\nsar    $0xf,%edi\nmov    %edi,0x0(%rbp)\ncmp    %esi,%r8d\njle    19c8 <window+0x378>\nmovslq %edx,%rdx\nlea    0x4(%r9,%r10,1),%rsi\nmov    %ecx,%eax\nmov    (%r11,%rdx,4),%edx\nsar    %edx\nsub    %edx,%eax\nimul   (%rsi),%eax\nsar    $0xf,%eax\nmov    %eax,(%rsi)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nsub    $0x1,%r8d\nadd    %r11,%rdx\nsub    %esi,%r8d\nlea    (%r8,%r13,1),%rax\nmov    $0x4000,%r8d\nlea    0x4(%r9,%rax,4),%r9\nnopl   0x0(%rax)\nmov    (%rdx),%esi\nmov    %r8d,%eax\nadd    $0x4,%rcx\nadd    %rdi,%rdx\nsar    %esi\nsub    %esi,%eax\nimul   -0x4(%rcx),%eax\nsar    $0xf,%eax\nmov    %eax,-0x4(%rcx)\ncmp    %rcx,%r9\njne    19f8 <window+0x3a8>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    %r10d,%edx\nlea    0x0(,%rbx,4),%rdi\nmov    %r9,%rcx\nmov    $0x4000,%ebp\nlea    0x8b7e(%rip),%rbx\nlea    0x4(%r9,%rdx,4),%r12\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%r14d\nmov    %ebp,%edx\nadd    $0x4,%rcx\nadd    %rdi,%rbx\nsar    %r14d\nsub    %r14d,%edx\nimul   -0x4(%rcx),%edx\nsar    $0xf,%edx\nmov    %edx,-0x4(%rcx)\ncmp    %r12,%rcx\njne    1a50 <window+0x400>\njmp    1809 <window+0x1b9>\ncs nopw 0x0(%rax,%rax,1)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "flood-fill/flood-fill.c", "function_name": "main", "content": " \nint\nmain()\n{\n\n  // start node\n  int x = 3, y = 9;    // having a target color `X`\n\n  // replacement color, NOTE: must be a new color!\n  char replacement = 'C';\n\n  // print the colors before replacement\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", replacement, x, y); printMatrix(mat);\n\n  // replace the target color with a replacement color using DFS\n  floodfill(mat, x, y, replacement);\n\n  // print the colors after replacement\n  libmin_printf(\"\\nAFTER:\\n\"); printMatrix(mat);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "flood-fill/flood-fill.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char (*)[10])mat);\n  floodfill((char (*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char (*)[10])mat);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char(*)[10])mat);\n  floodfill((char(*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char(*)[10])mat);\n  libmin_success();\n}", "binary": "flood-fill/flood-fill.host.O3", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    $0x9,%ecx\nlea    0x4f4f(%rip),%rbp\nxor    %eax,%eax\nmov    $0x3,%edx\nmov    $0x43,%esi\nlea    0x2ef4(%rip),%rdi\ncall   3960 <libmin_printf>\nmov    %rbp,%rdi\ncall   1820 <printMatrix>\nmov    $0x43,%ecx\nmov    $0x9,%edx\nmov    %rbp,%rdi\nmov    $0x3,%esi\ncall   1260 <floodfill>\nlea    0x2eba(%rip),%rdi\nxor    %eax,%eax\ncall   3960 <libmin_printf>\nmov    %rbp,%rdi\ncall   1820 <printMatrix>\ncall   3ba0 <libmin_success>\nxor    %eax,%eax\npop    %rbp\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "flood-fill/flood-fill.c", "function_name": "printMatrix", "content": " \n// Utility function to print a matrix\nvoid\nprintMatrix(char mat[M][N])\n{\n  for (int i = 0; i < M; i++)\n  {\n    for (int j = 0; j < N; j++)\n      libmin_printf(\"  %c\", mat[i][j]);\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo": {"path": "flood-fill/flood-fill.host.O3.pseudo", "function_name": "printMatrix", "address": "0x1820", "label": "printMatrix", "content": "void __fastcall printMatrix(char (*mat)[10])\n{\n  char *v1; // rbp\n  char *v2; // rbx\n  __int64 v3; // rsi\n\n  v1 = &(*mat)[10];\n  do\n  {\n    v2 = v1 - 10;\n    do\n    {\n      v3 = (unsigned int)*v2++;\n      libmin_printf(\"  %c\", v3);\n    }\n    while ( v2 != v1 );\n    v1 = v2 + 10;\n    libmin_printf((char *)\"\\n\");\n  }\n  while ( v2 + 10 != &(*mat)[110] );\n}\n"}, "pseudo_normalize": "void printMatrix(char (*mat)[10]) {\n  char *v1;\n  char *v2;\n  long long v3;\n  v1 = &(*mat)[10];\n  do {\n    v2 = v1 - 10;\n    do {\n      v3 = (unsigned int)*v2++;\n      libmin_printf(\"  %c\", v3);\n    } while (v2 != v1);\n    v1 = v2 + 10;\n    libmin_printf((char *)\"\\n\");\n  } while (v2 + 10 != &(*mat)[110]);\n}", "binary": "flood-fill/flood-fill.host.O3", "assembly": "<printMatrix>:\nendbr64\npush   %r14\nlea    0x27e3(%rip),%r14\npush   %r13\nlea    0x6e(%rdi),%r13\npush   %r12\nlea    0x27c8(%rip),%r12\npush   %rbp\nlea    0xa(%rdi),%rbp\npush   %rbx\nnopw   0x0(%rax,%rax,1)\nlea    -0xa(%rbp),%rbx\nnopl   0x0(%rax)\nmovsbl (%rbx),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   3960 <libmin_printf>\ncmp    %rbp,%rbx\njne    1850 <printMatrix+0x30>\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    0xa(%rbx),%rbp\ncall   3960 <libmin_printf>\ncmp    %r13,%rbp\njne    1848 <printMatrix+0x28>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "avaliatokens", "content": "/* ---------------------------------------------------------------------- */\nvoid avaliatokens(char *aux[SBUFF],  int frac[MYMAX], int i) /* analyzes the tokens, to check the fractions */\n{\n    int j, k = 0;\n    char *token2;\n    int mist;\n\n    /* 1 mist first fraction */\n    if(((libmin_strcmp(aux[2], \"+\") == 0) || (libmin_strcmp(aux[2], \"-\") == 0) || (libmin_strcmp(aux[2], \"*\") == 0) || (libmin_strcmp(aux[2], \"/\") == 0)) && i == 4)\n        mist = 1;\n    /* 1 mist second fraction */\n    if(((libmin_strcmp(aux[1], \"+\") == 0) || (libmin_strcmp(aux[1], \"-\") == 0) || (libmin_strcmp(aux[1], \"*\") == 0) || (libmin_strcmp(aux[1], \"/\") == 0)) && i == 4)\n        mist = 2;\n    \n    for(j = 0; j < i; j++)\n    {\n        if((libmin_strcmp(aux[j], \"+\") == 0))\n        {\n            frac[MYMAX - 1] = 1;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"-\") == 0))\n        {\n            frac[MYMAX - 1] = 2;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"*\") == 0))\n        {\n            frac[MYMAX - 1] = 3;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"/\") == 0))\n        {\n            frac[MYMAX - 1] = 4;\n            j++;\n        }\n\n        token2 = libmin_strtok(aux[j], \"/\"); /* divides the equation into tokens */\n        while(token2 != NULL)\n        {\n            frac[k] = libmin_atoi(token2); /* stores tokens in the array */\n            token2 = libmin_strtok(NULL, \"/\");\n            k++;\n        }\n    }\n    misto(mist, frac, i);\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O3.pseudo", "function_name": "avaliatokens", "address": "0x1730", "label": "avaliatokens", "content": "void __fastcall avaliatokens(char **aux, int *frac, int i)\n{\n  int v4; // ebp\n  int v5; // r14d\n  char **v6; // rbx\n  char *v7; // rdi\n  __int64 v8; // rbx\n  __int64 v9; // [rsp+0h] [rbp-58h]\n  int mist; // [rsp+1Ch] [rbp-3Ch]\n\n  if ( libmin_strcmp(aux[2], \"+\") && libmin_strcmp(aux[2], asc_60C8) && libmin_strcmp(aux[2], &asc_60C8[2]) )\n    libmin_strcmp(aux[2], &asc_60C8[4]);\n  if ( libmin_strcmp(aux[1], \"+\")\n    && libmin_strcmp(aux[1], asc_60C8)\n    && libmin_strcmp(aux[1], &asc_60C8[2])\n    && libmin_strcmp(aux[1], &asc_60C8[4])\n    || i != 4 )\n  {\n    mist = 1;\n    if ( i <= 0 )\n      goto LABEL_18;\n  }\n  else\n  {\n    mist = 2;\n  }\n  v4 = 0;\n  v5 = 0;\n  do\n  {\n    v6 = &aux[v5];\n    v9 = v5;\n    if ( !libmin_strcmp(*v6, \"+\") )\n    {\n      ++v5;\n      frac[10] = 1;\n      v6 = &aux[v9 + 1];\n    }\n    if ( !libmin_strcmp(*v6, asc_60C8) )\n    {\n      frac[10] = 2;\n      v6 = &aux[++v5];\n    }\n    if ( !libmin_strcmp(*v6, &asc_60C8[2]) )\n    {\n      frac[10] = 3;\n      v6 = &aux[++v5];\n    }\n    if ( !libmin_strcmp(*v6, &asc_60C8[4]) )\n    {\n      frac[10] = 4;\n      v6 = &aux[++v5];\n    }\n    v7 = libmin_strtok(*v6, &asc_60C8[4]);\n    if ( v7 )\n    {\n      v8 = v4 + 1;\n      do\n      {\n        v4 = v8;\n        frac[v8++ - 1] = libmin_atoi(v7);\n        v7 = libmin_strtok(0LL, &asc_60C8[4]);\n      }\n      while ( v7 );\n    }\n    ++v5;\n  }\n  while ( i > v5 );\nLABEL_18:\n  misto(mist, frac, i);\n}\n"}, "pseudo_normalize": "void avaliatokens(char **aux, int *frac, int i) {\n  int v4;\n  int v5;\n  char **v6;\n  char *v7;\n  long long v8;\n  long long v9;\n  int mist;\n  if (libmin_strcmp(aux[2], \"+\") && libmin_strcmp(aux[2], asc_60C8) &&\n      libmin_strcmp(aux[2], &asc_60C8[2]))\n    libmin_strcmp(aux[2], &asc_60C8[4]);\n  if (libmin_strcmp(aux[1], \"+\") && libmin_strcmp(aux[1], asc_60C8) &&\n          libmin_strcmp(aux[1], &asc_60C8[2]) &&\n          libmin_strcmp(aux[1], &asc_60C8[4]) ||\n      i != 4) {\n    mist = 1;\n    if (i <= 0) goto LABEL_18;\n  } else {\n    mist = 2;\n  }\n  v4 = 0;\n  v5 = 0;\n  do {\n    v6 = &aux[v5];\n    v9 = v5;\n    if (!libmin_strcmp(*v6, \"+\")) {\n      ++v5;\n      frac[10] = 1;\n      v6 = &aux[v9 + 1];\n    }\n    if (!libmin_strcmp(*v6, asc_60C8)) {\n      frac[10] = 2;\n      v6 = &aux[++v5];\n    }\n    if (!libmin_strcmp(*v6, &asc_60C8[2])) {\n      frac[10] = 3;\n      v6 = &aux[++v5];\n    }\n    if (!libmin_strcmp(*v6, &asc_60C8[4])) {\n      frac[10] = 4;\n      v6 = &aux[++v5];\n    }\n    v7 = libmin_strtok(*v6, &asc_60C8[4]);\n    if (v7) {\n      v8 = v4 + 1;\n      do {\n        v4 = v8;\n        frac[v8++ - 1] = libmin_atoi(v7);\n        v7 = libmin_strtok(0LL, &asc_60C8[4]);\n      } while (v7);\n    }\n    ++v5;\n  } while (i > v5);\nLABEL_18:\n  misto(mist, frac, i);\n}", "binary": "frac-calc/frac-calc.host.O3", "assembly": "<avaliatokens>:\nendbr64\npush   %r15\nmov    %rdi,%r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rsi,%r12\nlea    0x497d(%rip),%rsi\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    0x10(%rdi),%rdi\nmov    %edx,0x18(%rsp)\ncall   54c0 <libmin_strcmp>\ntest   %eax,%eax\njne    18cf <avaliatokens+0x19f>\nmov    0x8(%r15),%rdi\nlea    0x4957(%rip),%rsi\ncall   54c0 <libmin_strcmp>\ntest   %eax,%eax\njne    192a <avaliatokens+0x1fa>\ncmpl   $0x4,0x18(%rsp)\nje     191d <avaliatokens+0x1ed>\nmov    0x18(%rsp),%eax\nmovl   $0x1,0x1c(%rsp)\ntest   %eax,%eax\njle    18b1 <avaliatokens+0x181>\nlea    0x4926(%rip),%rax\nxor    %ebp,%ebp\nxor    %r14d,%r14d\nmov    %rax,0x8(%rsp)\nlea    0x4917(%rip),%rax\nlea    0x4912(%rip),%r13\nmov    %rax,0x10(%rsp)\nnop\nmovslq %r14d,%rdx\nlea    0x48fc(%rip),%rsi\nshl    $0x3,%rdx\nlea    (%r15,%rdx,1),%rbx\nmov    %rdx,(%rsp)\nmov    (%rbx),%rdi\ncall   54c0 <libmin_strcmp>\ntest   %eax,%eax\njne    17f8 <avaliatokens+0xc8>\nmov    (%rsp),%rdx\nadd    $0x1,%r14d\nmovl   $0x1,0x28(%r12)\nlea    0x8(%r15,%rdx,1),%rbx\nmov    0x8(%rsp),%rsi\nmov    (%rbx),%rdi\ncall   54c0 <libmin_strcmp>\ntest   %eax,%eax\njne    181d <avaliatokens+0xed>\nmovl   $0x2,0x28(%r12)\nadd    $0x1,%r14d\nmovslq %r14d,%rax\nlea    (%r15,%rax,8),%rbx\nmov    0x10(%rsp),%rsi\nmov    (%rbx),%rdi\ncall   54c0 <libmin_strcmp>\ntest   %eax,%eax\njne    1842 <avaliatokens+0x112>\nmovl   $0x3,0x28(%r12)\nadd    $0x1,%r14d\nmovslq %r14d,%rax\nlea    (%r15,%rax,8),%rbx\nmov    (%rbx),%rdi\nmov    %r13,%rsi\ncall   54c0 <libmin_strcmp>\ntest   %eax,%eax\njne    1865 <avaliatokens+0x135>\nmovl   $0x4,0x28(%r12)\nadd    $0x1,%r14d\nmovslq %r14d,%rax\nlea    (%r15,%rax,8),%rbx\nmov    (%rbx),%rdi\nmov    %r13,%rsi\ncall   55c0 <libmin_strtok>\nmov    %rax,%rdi\ntest   %rax,%rax\nje     18a2 <avaliatokens+0x172>\nadd    $0x1,%ebp\nmovslq %ebp,%rbx\nxchg   %ax,%ax\ncall   2ed0 <libmin_atoi>\nxor    %edi,%edi\nmov    %r13,%rsi\nmov    %ebx,%ebp\nmov    %eax,-0x4(%r12,%rbx,4)\nadd    $0x1,%rbx\ncall   55c0 <libmin_strtok>\nmov    %rax,%rdi\ntest   %rax,%rax\njne    1880 <avaliatokens+0x150>\nadd    $0x1,%r14d\ncmp    %r14d,0x18(%rsp)\njg     17c0 <avaliatokens+0x90>\nmov    0x18(%rsp),%edx\nmov    0x1c(%rsp),%edi\nadd    $0x28,%rsp\nmov    %r12,%rsi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    1610 <misto>\nlea    0x47f2(%rip),%rax\nmov    0x10(%r15),%rdi\nmov    %rax,%rsi\ncall   54c0 <libmin_strcmp>\ntest   %eax,%eax\nje     1764 <avaliatokens+0x34>\nlea    0x47d9(%rip),%rax\nmov    0x10(%r15),%rdi\nmov    %rax,%rsi\ncall   54c0 <libmin_strcmp>\ntest   %eax,%eax\nje     1764 <avaliatokens+0x34>\nlea    0x47c0(%rip),%r13\nmov    0x10(%r15),%rdi\nmov    %r13,%rsi\ncall   54c0 <libmin_strcmp>\njmp    1764 <avaliatokens+0x34>\nmovl   $0x2,0x1c(%rsp)\njmp    179b <avaliatokens+0x6b>\nlea    0x4797(%rip),%rax\nmov    0x8(%r15),%rdi\nmov    %rax,%rsi\ncall   54c0 <libmin_strcmp>\ntest   %eax,%eax\nje     177c <avaliatokens+0x4c>\nlea    0x477e(%rip),%rax\nmov    0x8(%r15),%rdi\nmov    %rax,%rsi\ncall   54c0 <libmin_strcmp>\ntest   %eax,%eax\nje     177c <avaliatokens+0x4c>\nlea    0x4765(%rip),%r13\nmov    0x8(%r15),%rdi\nmov    %r13,%rsi\ncall   54c0 <libmin_strcmp>\ntest   %eax,%eax\nje     177c <avaliatokens+0x4c>\njmp    1787 <avaliatokens+0x57>\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "calcula", "content": "/* ---------------------------------------------------------------------- */\nfloat calcula(int frac[MYMAX], int r[MYMAX]) /* computes the fraction */\n{\n    float dec = 0, a, b;\n\n    r[0] = frac[1] * frac[3]; /* mmc */\n    switch(frac[MYMAX - 1]) /* operation */\n    {\n        case 1: /* + */\n            r[1] = (r[0] / frac[1]) * frac[0] + (r[0] / frac[3]) * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 2: /* - */\n            r[1] = (r[0] / frac[1]) * frac[0] - (r[0] / frac[3]) * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 3: /* * */\n            r[1] = frac[0] * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 4: /* / */\n            r[0] = frac[1] * frac[2];\n            r[1] = frac[0] * frac[3];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n    }\n\n    return dec;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O3.pseudo", "function_name": "calcula", "address": "0x1a40", "label": "calcula", "content": "float __fastcall calcula(int *frac, int *r)\n{\n  int v2; // ecx\n  int v3; // eax\n  int v4; // r8d\n  float result; // xmm0_4\n  __int64 v6; // rdi\n  __int64 v7; // rdx\n  int v8; // r10d\n  int v9; // eax\n  int v10; // edi\n  int v11; // edx\n  __int64 v12; // rdi\n  __int64 v13; // rdx\n  int v14; // r10d\n  int v15; // eax\n  int v16; // r9d\n  int v17; // eax\n  int v18; // edi\n  int v19; // edx\n  int v20; // eax\n  int v21; // edx\n  __int64 v22; // rdi\n  __int64 v23; // rcx\n  int v24; // r10d\n  int v25; // r8d\n  int v26; // edi\n  int v27; // ecx\n  __int64 v28; // rdi\n  __int64 v29; // rcx\n  int v30; // r10d\n  int v31; // r8d\n  int v32; // r9d\n  int v33; // r8d\n  int v34; // edi\n  int v35; // ecx\n  int v36; // r8d\n  __int64 v37; // rax\n  __int64 v38; // rdx\n  int v39; // r9d\n  int v40; // edi\n  __int64 v41; // rax\n  __int64 v42; // rdx\n  int v43; // r9d\n  int v44; // edi\n  int v45; // r9d\n  int v46; // edi\n  int v47; // eax\n  int v48; // edx\n  int v49; // eax\n  int v50; // edi\n  __int64 v51; // rax\n  __int64 v52; // rdx\n  int v53; // r10d\n  int v54; // r8d\n  __int64 v55; // rax\n  __int64 v56; // rdx\n  int v57; // r10d\n  int v58; // r8d\n  int v59; // r9d\n  int v60; // r8d\n  int v61; // eax\n  int v62; // edx\n\n  v2 = frac[3] * frac[1];\n  *r = v2;\n  v3 = frac[10];\n  if ( v3 == 3 )\n  {\n    v49 = frac[2] * *frac;\n    r[1] = v49;\n    v50 = v49;\n    result = (float)v49 / (float)v2;\n    if ( !((v2 % 2) | (v49 % 2)) )\n    {\n      v50 = v49 / 2;\n      v2 /= 2;\n    }\n    if ( !((v2 % 3) | (v50 % 3)) )\n    {\n      v50 /= 3;\n      v2 /= 3;\n    }\n    if ( !((v2 % 4) | (v50 % 4)) )\n    {\n      v50 /= 4;\n      v2 /= 4;\n    }\n    v51 = v50;\n    v52 = v2;\n    if ( !((v2 % 5) | (v50 % 5)) )\n    {\n      v51 = v50 / 5;\n      v52 = v2 / 5;\n      v50 /= 5;\n      v2 /= 5;\n    }\n    v53 = ((unsigned __int64)(715827883 * v51) >> 32) - (v50 >> 31);\n    v54 = ((unsigned __int64)(715827883 * v52) >> 32) - (v2 >> 31);\n    if ( !((v50 - 6 * v53) | (v2 - 6 * v54)) )\n    {\n      v51 = v53;\n      v52 = v54;\n      v50 = v53;\n      v2 = v54;\n    }\n    if ( !((v50 - 7 * (((int)(v50 + ((unsigned __int64)(-1840700269 * v51) >> 32)) >> 2) - (v50 >> 31))) | (v2 - 7 * (((int)(v2 + ((unsigned __int64)(-1840700269 * v52) >> 32)) >> 2) - (v2 >> 31)))) )\n    {\n      v50 = ((int)(v50 + ((unsigned __int64)(-1840700269 * v51) >> 32)) >> 2) - (v50 >> 31);\n      v2 = ((int)(v2 + ((unsigned __int64)(-1840700269 * v52) >> 32)) >> 2) - (v2 >> 31);\n    }\n    if ( !((v2 % 8) | (v50 % 8)) )\n    {\n      v50 /= 8;\n      v2 /= 8;\n    }\n    v55 = v50;\n    v56 = v2;\n    if ( !((v2 % 9) | (v50 % 9)) )\n    {\n      v55 = v50 / 9;\n      v56 = v2 / 9;\n      v50 /= 9;\n      v2 /= 9;\n    }\n    v57 = ((int)((unsigned __int64)(1717986919 * v55) >> 32) >> 2) - (v50 >> 31);\n    v58 = ((int)((unsigned __int64)(1717986919 * v56) >> 32) >> 2) - (v2 >> 31);\n    if ( !((v50 - 10 * v57) | (v2 - 10 * v58)) )\n    {\n      v55 = v57;\n      v56 = v58;\n      v50 = v57;\n      v2 = v58;\n    }\n    v59 = ((int)((unsigned __int64)(780903145 * v55) >> 32) >> 1) - (v50 >> 31);\n    v60 = ((int)((unsigned __int64)(780903145 * v56) >> 32) >> 1) - (v2 >> 31);\n    if ( !((v50 - 11 * v59) | (v2 - 11 * v60)) )\n    {\n      v55 = v59;\n      v56 = v60;\n      v50 = v59;\n      v2 = v60;\n    }\n    v61 = ((int)((unsigned __int64)(715827883 * v55) >> 32) >> 1) - (v50 >> 31);\n    v62 = ((int)((unsigned __int64)(715827883 * v56) >> 32) >> 1) - (v2 >> 31);\n    if ( !((v2 - 12 * v62) | (v50 - 12 * v61)) )\n    {\n      v50 = v61;\n      v2 = v62;\n    }\n    r[3] = v50;\n    r[4] = v2;\n  }\n  else if ( v3 > 3 )\n  {\n    if ( v3 != 4 )\n      return 0.0;\n    v20 = frac[2] * frac[1];\n    *r = v20;\n    v21 = frac[3] * *frac;\n    r[1] = v21;\n    result = (float)v21 / (float)v20;\n    if ( !((v20 % 2) | (v21 % 2)) )\n    {\n      v20 /= 2;\n      v21 /= 2;\n    }\n    if ( !((v20 % 3) | (v21 % 3)) )\n    {\n      v21 /= 3;\n      v20 /= 3;\n    }\n    if ( !((v20 % 4) | (v21 % 4)) )\n    {\n      v21 /= 4;\n      v20 /= 4;\n    }\n    v22 = v21;\n    v23 = v20;\n    if ( !((v20 % 5) | (v21 % 5)) )\n    {\n      v22 = v21 / 5;\n      v23 = v20 / 5;\n      v21 /= 5;\n      v20 /= 5;\n    }\n    v24 = ((unsigned __int64)(715827883 * v22) >> 32) - (v21 >> 31);\n    v25 = ((unsigned __int64)(715827883 * v23) >> 32) - (v20 >> 31);\n    if ( !((v21 - 6 * v24) | (v20 - 6 * v25)) )\n    {\n      v22 = v24;\n      v23 = v25;\n      v21 = v24;\n      v20 = v25;\n    }\n    v26 = ((int)(v21 + ((unsigned __int64)(-1840700269 * v22) >> 32)) >> 2) - (v21 >> 31);\n    v27 = ((int)(v20 + ((unsigned __int64)(-1840700269 * v23) >> 32)) >> 2) - (v20 >> 31);\n    if ( !((v21 - 7 * v26) | (v20 - 7 * v27)) )\n    {\n      v21 = v26;\n      v20 = v27;\n    }\n    if ( !((v20 % 8) | (v21 % 8)) )\n    {\n      v21 /= 8;\n      v20 /= 8;\n    }\n    v28 = v21;\n    v29 = v20;\n    if ( !((v20 % 9) | (v21 % 9)) )\n    {\n      v28 = v21 / 9;\n      v29 = v20 / 9;\n      v21 /= 9;\n      v20 /= 9;\n    }\n    v30 = ((int)((unsigned __int64)(1717986919 * v28) >> 32) >> 2) - (v21 >> 31);\n    v31 = ((int)((unsigned __int64)(1717986919 * v29) >> 32) >> 2) - (v20 >> 31);\n    if ( !((v21 - 10 * v30) | (v20 - 10 * v31)) )\n    {\n      v28 = v30;\n      v29 = v31;\n      v21 = v30;\n      v20 = v31;\n    }\n    v32 = ((int)((unsigned __int64)(780903145 * v28) >> 32) >> 1) - (v21 >> 31);\n    v33 = ((int)((unsigned __int64)(780903145 * v29) >> 32) >> 1) - (v20 >> 31);\n    if ( !((v21 - 11 * v32) | (v20 - 11 * v33)) )\n    {\n      v28 = v32;\n      v29 = v33;\n      v21 = v32;\n      v20 = v33;\n    }\n    v34 = ((int)((unsigned __int64)(715827883 * v28) >> 32) >> 1) - (v21 >> 31);\n    v35 = ((int)((unsigned __int64)(715827883 * v29) >> 32) >> 1) - (v20 >> 31);\n    if ( !((v20 - 12 * v35) | (v21 - 12 * v34)) )\n    {\n      v21 = v34;\n      v20 = v35;\n    }\n    r[3] = v21;\n    r[4] = v20;\n  }\n  else\n  {\n    if ( v3 != 1 )\n    {\n      if ( v3 == 2 )\n      {\n        v4 = v2 / frac[1] * *frac - frac[2] * (v2 / frac[3]);\n        r[1] = v4;\n        result = (float)v4 / (float)v2;\n        if ( !((v2 % 2) | (v4 % 2)) )\n        {\n          v4 /= 2;\n          v2 /= 2;\n        }\n        if ( !((v2 % 3) | (v4 % 3)) )\n        {\n          v4 /= 3;\n          v2 /= 3;\n        }\n        if ( !((v2 % 4) | (v4 % 4)) )\n        {\n          v4 /= 4;\n          v2 /= 4;\n        }\n        v6 = v4;\n        v7 = v2;\n        if ( !((v2 % 5) | (v4 % 5)) )\n        {\n          v6 = v4 / 5;\n          v7 = v2 / 5;\n          v4 /= 5;\n          v2 /= 5;\n        }\n        v8 = ((unsigned __int64)(715827883 * v6) >> 32) - (v4 >> 31);\n        v9 = ((unsigned __int64)(715827883 * v7) >> 32) - (v2 >> 31);\n        if ( !((v4 - 6 * v8) | (v2 - 6 * v9)) )\n        {\n          v6 = v8;\n          v7 = v9;\n          v4 = v8;\n          v2 = v9;\n        }\n        v10 = ((int)(v4 + ((unsigned __int64)(-1840700269 * v6) >> 32)) >> 2) - (v4 >> 31);\n        v11 = ((int)(v2 + ((unsigned __int64)(-1840700269 * v7) >> 32)) >> 2) - (v2 >> 31);\n        if ( !((v4 - 7 * v10) | (v2 - 7 * v11)) )\n        {\n          v4 = v10;\n          v2 = v11;\n        }\n        if ( !((v2 % 8) | (v4 % 8)) )\n        {\n          v4 /= 8;\n          v2 /= 8;\n        }\n        v12 = v4;\n        v13 = v2;\n        if ( !((v2 % 9) | (v4 % 9)) )\n        {\n          v12 = v4 / 9;\n          v13 = v2 / 9;\n          v4 /= 9;\n          v2 /= 9;\n        }\n        v14 = ((int)((unsigned __int64)(1717986919 * v12) >> 32) >> 2) - (v4 >> 31);\n        v15 = ((int)((unsigned __int64)(1717986919 * v13) >> 32) >> 2) - (v2 >> 31);\n        if ( !((v4 - 10 * v14) | (v2 - 10 * v15)) )\n        {\n          v12 = v14;\n          v13 = v15;\n          v4 = v14;\n          v2 = v15;\n        }\n        v16 = ((int)((unsigned __int64)(780903145 * v12) >> 32) >> 1) - (v4 >> 31);\n        v17 = ((int)((unsigned __int64)(780903145 * v13) >> 32) >> 1) - (v2 >> 31);\n        if ( !((v4 - 11 * v16) | (v2 - 11 * v17)) )\n        {\n          v12 = v16;\n          v13 = v17;\n          v4 = v16;\n          v2 = v17;\n        }\n        v18 = ((int)((unsigned __int64)(715827883 * v12) >> 32) >> 1) - (v4 >> 31);\n        v19 = ((int)((unsigned __int64)(715827883 * v13) >> 32) >> 1) - (v2 >> 31);\n        if ( !((v2 - 12 * v19) | (v4 - 12 * v18)) )\n        {\n          v4 = v18;\n          v2 = v19;\n        }\n        r[3] = v4;\n        r[4] = v2;\n        return result;\n      }\n      return 0.0;\n    }\n    v36 = frac[2] * (v2 / frac[3]) + v2 / frac[1] * *frac;\n    r[1] = v36;\n    result = (float)v36 / (float)v2;\n    if ( !((v2 % 2) | (v36 % 2)) )\n    {\n      v36 /= 2;\n      v2 /= 2;\n    }\n    if ( !((v2 % 3) | (v36 % 3)) )\n    {\n      v36 /= 3;\n      v2 /= 3;\n    }\n    if ( !((v2 % 4) | (v36 % 4)) )\n    {\n      v36 /= 4;\n      v2 /= 4;\n    }\n    v37 = v36;\n    v38 = v2;\n    if ( !((v2 % 5) | (v36 % 5)) )\n    {\n      v37 = v36 / 5;\n      v38 = v2 / 5;\n      v36 /= 5;\n      v2 /= 5;\n    }\n    v39 = ((unsigned __int64)(715827883 * v37) >> 32) - (v36 >> 31);\n    v40 = ((unsigned __int64)(715827883 * v38) >> 32) - (v2 >> 31);\n    if ( !((v36 - 6 * v39) | (v2 - 6 * v40)) )\n    {\n      v37 = v39;\n      v38 = v40;\n      v36 = v39;\n      v2 = v40;\n    }\n    if ( !((v36 - 7 * (((int)(v36 + ((unsigned __int64)(-1840700269 * v37) >> 32)) >> 2) - (v36 >> 31))) | (v2 - 7 * (((int)(v2 + ((unsigned __int64)(-1840700269 * v38) >> 32)) >> 2) - (v2 >> 31)))) )\n    {\n      v36 = ((int)(v36 + ((unsigned __int64)(-1840700269 * v37) >> 32)) >> 2) - (v36 >> 31);\n      v2 = ((int)(v2 + ((unsigned __int64)(-1840700269 * v38) >> 32)) >> 2) - (v2 >> 31);\n    }\n    if ( !((v2 % 8) | (v36 % 8)) )\n    {\n      v36 /= 8;\n      v2 /= 8;\n    }\n    v41 = v36;\n    v42 = v2;\n    if ( !((v2 % 9) | (v36 % 9)) )\n    {\n      v41 = v36 / 9;\n      v42 = v2 / 9;\n      v36 /= 9;\n      v2 /= 9;\n    }\n    v43 = ((int)((unsigned __int64)(1717986919 * v41) >> 32) >> 2) - (v36 >> 31);\n    v44 = ((int)((unsigned __int64)(1717986919 * v42) >> 32) >> 2) - (v2 >> 31);\n    if ( !((v36 - 10 * v43) | (v2 - 10 * v44)) )\n    {\n      v41 = v43;\n      v42 = v44;\n      v36 = v43;\n      v2 = v44;\n    }\n    v45 = ((int)((unsigned __int64)(780903145 * v41) >> 32) >> 1) - (v36 >> 31);\n    v46 = ((int)((unsigned __int64)(780903145 * v42) >> 32) >> 1) - (v2 >> 31);\n    if ( !((v36 - 11 * v45) | (v2 - 11 * v46)) )\n    {\n      v41 = v45;\n      v42 = v46;\n      v36 = v45;\n      v2 = v46;\n    }\n    v47 = ((int)((unsigned __int64)(715827883 * v41) >> 32) >> 1) - (v36 >> 31);\n    v48 = ((int)((unsigned __int64)(715827883 * v42) >> 32) >> 1) - (v2 >> 31);\n    if ( !((v2 - 12 * v48) | (v36 - 12 * v47)) )\n    {\n      v36 = v47;\n      v2 = v48;\n    }\n    r[3] = v36;\n    r[4] = v2;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "", "binary": "frac-calc/frac-calc.host.O3", "assembly": "<calcula>:\nendbr64\npush   %rbx\nmov    0x4(%rdi),%ecx\nimul   0xc(%rdi),%ecx\nmov    %ecx,(%rsi)\nmov    0x28(%rdi),%eax\ncmp    $0x3,%eax\nje     24f8 <calcula+0xab8>\njg     1df0 <calcula+0x3b0>\ncmp    $0x1,%eax\nje     2180 <calcula+0x740>\ncmp    $0x2,%eax\njne    2178 <calcula+0x738>\nmov    %ecx,%eax\nmov    (%rdi),%r8d\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\ncltd\ncvtsi2ss %ecx,%xmm1\nidivl  0x4(%rdi)\nimul   %eax,%r8d\nmov    %ecx,%eax\ncltd\nidivl  0xc(%rdi)\nimul   0x8(%rdi),%eax\nmov    %ecx,%edi\nshr    $0x1f,%edi\nsub    %eax,%r8d\nmov    %r8d,%edx\ncvtsi2ss %r8d,%xmm0\nmov    %r8d,0x4(%rsi)\nshr    $0x1f,%edx\nlea    (%r8,%rdx,1),%eax\nand    $0x1,%eax\ndivss  %xmm1,%xmm0\nsub    %edx,%eax\nlea    (%rcx,%rdi,1),%edx\nand    $0x1,%edx\nsub    %edi,%edx\nor     %edx,%eax\nje     28b0 <calcula+0xe70>\nmovslq %r8d,%rdx\nmov    %r8d,%eax\nmov    %r8d,%edi\nmov    %ecx,%r9d\nimul   $0x55555556,%rdx,%rdx\nsar    $0x1f,%eax\nsar    $0x1f,%r9d\nshr    $0x20,%rdx\nsub    %eax,%edx\nlea    (%rdx,%rdx,2),%eax\nsub    %eax,%edi\nmovslq %ecx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nsub    %r9d,%eax\nmov    %ecx,%r9d\nlea    (%rax,%rax,2),%r10d\nsub    %r10d,%r9d\nor     %r9d,%edi\ncmove  %edx,%r8d\ncmove  %eax,%ecx\nmov    %r8d,%edx\nmov    %ecx,%edi\nsar    $0x1f,%edx\nsar    $0x1f,%edi\nshr    $0x1e,%edx\nshr    $0x1e,%edi\nlea    (%r8,%rdx,1),%eax\nand    $0x3,%eax\nsub    %edx,%eax\nlea    (%rcx,%rdi,1),%edx\nand    $0x3,%edx\nsub    %edi,%edx\nor     %edx,%eax\njne    1b57 <calcula+0x117>\ntest   %r8d,%r8d\nlea    0x3(%r8),%eax\ncmovns %r8d,%eax\nsar    $0x2,%eax\ntest   %ecx,%ecx\nmov    %eax,%r8d\nlea    0x3(%rcx),%eax\ncmovns %ecx,%eax\nsar    $0x2,%eax\nmov    %eax,%ecx\nmovslq %r8d,%rdi\nmov    %r8d,%edx\nmov    %r8d,%r10d\nmov    %ecx,%r11d\nimul   $0x66666667,%rdi,%rax\nsar    $0x1f,%edx\nsar    $0x1f,%r11d\nsar    $0x21,%rax\nsub    %edx,%eax\nmovslq %ecx,%rdx\nmov    %eax,%r9d\nlea    (%rax,%rax,4),%eax\nsub    %eax,%r10d\nimul   $0x66666667,%rdx,%rax\nsar    $0x21,%rax\nsub    %r11d,%eax\nmov    %ecx,%r11d\nlea    (%rax,%rax,4),%ebx\nsub    %ebx,%r11d\nor     %r11d,%r10d\njne    1bab <calcula+0x16b>\nmovslq %r9d,%rdi\nmovslq %eax,%rdx\nmov    %rdi,%r8\nmov    %rdx,%rcx\nimul   $0x2aaaaaab,%rdi,%rax\nmov    %r8d,%r9d\nmov    %r8d,%ebx\nmov    %ecx,%r11d\nsar    $0x1f,%r9d\nshr    $0x20,%rax\nmov    %eax,%r10d\nsub    %r9d,%r10d\nmov    %ecx,%r9d\nlea    (%r10,%r10,2),%eax\nsar    $0x1f,%r9d\nadd    %eax,%eax\nsub    %eax,%ebx\nimul   $0x2aaaaaab,%rdx,%rax\nshr    $0x20,%rax\nsub    %r9d,%eax\nlea    (%rax,%rax,2),%r9d\nadd    %r9d,%r9d\nsub    %r9d,%r11d\nor     %ebx,%r11d\njne    1c01 <calcula+0x1c1>\nmovslq %r10d,%rdi\nmovslq %eax,%rdx\nmov    %rdi,%r8\nmov    %rdx,%rcx\nimul   $0xffffffff92492493,%rdi,%rdi\nmov    %r8d,%eax\nmov    %r8d,%r9d\nmov    %ecx,%r10d\nsar    $0x1f,%eax\nimul   $0xffffffff92492493,%rdx,%rdx\nshr    $0x20,%rdi\nadd    %r8d,%edi\nshr    $0x20,%rdx\nsar    $0x2,%edi\nadd    %ecx,%edx\nsub    %eax,%edi\nsar    $0x2,%edx\nlea    0x0(,%rdi,8),%eax\nsub    %edi,%eax\nsub    %eax,%r9d\nmov    %ecx,%eax\nsar    $0x1f,%eax\nsub    %eax,%edx\nlea    0x0(,%rdx,8),%eax\nsub    %edx,%eax\nsub    %eax,%r10d\nor     %r9d,%r10d\ncmove  %edi,%r8d\ncmove  %edx,%ecx\nmov    %r8d,%edx\nmov    %ecx,%edi\nsar    $0x1f,%edx\nsar    $0x1f,%edi\nshr    $0x1d,%edx\nshr    $0x1d,%edi\nlea    (%r8,%rdx,1),%eax\nand    $0x7,%eax\nsub    %edx,%eax\nlea    (%rcx,%rdi,1),%edx\nand    $0x7,%edx\nsub    %edi,%edx\nor     %edx,%eax\njne    1c9d <calcula+0x25d>\ntest   %r8d,%r8d\nlea    0x7(%r8),%eax\ncmovns %r8d,%eax\nsar    $0x3,%eax\ntest   %ecx,%ecx\nmov    %eax,%r8d\nlea    0x7(%rcx),%eax\ncmovns %ecx,%eax\nsar    $0x3,%eax\nmov    %eax,%ecx\nmovslq %r8d,%rdi\nmov    %r8d,%edx\nmov    %r8d,%r10d\nmov    %ecx,%r11d\nimul   $0x38e38e39,%rdi,%rax\nsar    $0x1f,%edx\nsar    $0x1f,%r11d\nsar    $0x21,%rax\nsub    %edx,%eax\nmovslq %ecx,%rdx\nmov    %eax,%r9d\nlea    (%rax,%rax,8),%eax\nsub    %eax,%r10d\nimul   $0x38e38e39,%rdx,%rax\nsar    $0x21,%rax\nsub    %r11d,%eax\nmov    %ecx,%r11d\nlea    (%rax,%rax,8),%ebx\nsub    %ebx,%r11d\nor     %r11d,%r10d\njne    1cf1 <calcula+0x2b1>\nmovslq %r9d,%rdi\nmovslq %eax,%rdx\nmov    %rdi,%r8\nmov    %rdx,%rcx\nimul   $0x66666667,%rdi,%rax\nmov    %r8d,%r9d\nmov    %r8d,%ebx\nmov    %ecx,%r11d\nsar    $0x1f,%r9d\nsar    $0x22,%rax\nsub    %r9d,%eax\nmov    %ecx,%r9d\nmov    %eax,%r10d\nlea    (%rax,%rax,4),%eax\nsar    $0x1f,%r9d\nadd    %eax,%eax\nsub    %eax,%ebx\nimul   $0x66666667,%rdx,%rax\nsar    $0x22,%rax\nsub    %r9d,%eax\nlea    (%rax,%rax,4),%r9d\nadd    %r9d,%r9d\nsub    %r9d,%r11d\nor     %ebx,%r11d\njne    1d46 <calcula+0x306>\nmovslq %r10d,%rdi\nmovslq %eax,%rdx\nmov    %rdi,%r8\nmov    %rdx,%rcx\nimul   $0x2e8ba2e9,%rdi,%r9\nmov    %r8d,%eax\nmov    %r8d,%r11d\nmov    %ecx,%r10d\nsar    $0x1f,%eax\nsar    $0x1f,%r10d\nsar    $0x21,%r9\nsub    %eax,%r9d\nlea    (%r9,%r9,4),%eax\nlea    (%r9,%rax,2),%eax\nsub    %eax,%r11d\nimul   $0x2e8ba2e9,%rdx,%rax\nsar    $0x21,%rax\nsub    %r10d,%eax\nlea    (%rax,%rax,4),%r10d\nlea    (%rax,%r10,2),%ebx\nmov    %ecx,%r10d\nsub    %ebx,%r10d\nor     %r11d,%r10d\njne    1d9c <calcula+0x35c>\nmovslq %r9d,%rdi\nmovslq %eax,%rdx\nmov    %rdi,%r8\nmov    %rdx,%rcx\nimul   $0x2aaaaaab,%rdi,%rdi\nmov    %r8d,%eax\nmov    %r8d,%r9d\nmov    %ecx,%r10d\nsar    $0x1f,%eax\nimul   $0x2aaaaaab,%rdx,%rdx\npop    %rbx\nsar    $0x21,%rdi\nsub    %eax,%edi\nsar    $0x21,%rdx\nlea    (%rdi,%rdi,2),%eax\nshl    $0x2,%eax\nsub    %eax,%r9d\nmov    %ecx,%eax\nsar    $0x1f,%eax\nsub    %eax,%edx\nlea    (%rdx,%rdx,2),%eax\nshl    $0x2,%eax\nsub    %eax,%r10d\nor     %r10d,%r9d\ncmove  %edi,%r8d\ncmove  %edx,%ecx\nmov    %r8d,0xc(%rsi)\nmov    %ecx,0x10(%rsi)\nret\nnopl   0x0(%rax)\ncmp    $0x4,%eax\njne    2178 <calcula+0x738>\nmov    0x4(%rdi),%eax\nimul   0x8(%rdi),%eax\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\nmov    %eax,(%rsi)\nmov    (%rdi),%edx\nmov    %eax,%r8d\ncvtsi2ss %eax,%xmm1\nimul   0xc(%rdi),%edx\nshr    $0x1f,%r8d\nmov    %edx,%edi\ncvtsi2ss %edx,%xmm0\nmov    %edx,0x4(%rsi)\nshr    $0x1f,%edi\nlea    (%rdx,%rdi,1),%ecx\nand    $0x1,%ecx\ndivss  %xmm1,%xmm0\nsub    %edi,%ecx\nlea    (%rax,%r8,1),%edi\nand    $0x1,%edi\nsub    %r8d,%edi\nor     %edi,%ecx\nje     2898 <calcula+0xe58>\nmovslq %edx,%rdi\nmov    %edx,%ecx\nmov    %edx,%r8d\nmov    %eax,%r9d\nimul   $0x55555556,%rdi,%rdi\nsar    $0x1f,%ecx\nsar    $0x1f,%r9d\nshr    $0x20,%rdi\nsub    %ecx,%edi\nlea    (%rdi,%rdi,2),%ecx\nsub    %ecx,%r8d\nmovslq %eax,%rcx\nimul   $0x55555556,%rcx,%rcx\nshr    $0x20,%rcx\nsub    %r9d,%ecx\nmov    %eax,%r9d\nlea    (%rcx,%rcx,2),%r10d\nsub    %r10d,%r9d\nor     %r9d,%r8d\ncmove  %edi,%edx\ncmove  %ecx,%eax\nmov    %edx,%edi\nmov    %eax,%r8d\nsar    $0x1f,%edi\nsar    $0x1f,%r8d\nshr    $0x1e,%edi\nshr    $0x1e,%r8d\nlea    (%rdx,%rdi,1),%ecx\nand    $0x3,%ecx\nsub    %edi,%ecx\nlea    (%rax,%r8,1),%edi\nand    $0x3,%edi\nsub    %r8d,%edi\nor     %edi,%ecx\njne    1ecd <calcula+0x48d>\ntest   %edx,%edx\nlea    0x3(%rdx),%ecx\ncmovs  %ecx,%edx\nlea    0x3(%rax),%ecx\nsar    $0x2,%edx\ntest   %eax,%eax\ncmovs  %ecx,%eax\nsar    $0x2,%eax\nmovslq %edx,%rdi\nmov    %edx,%r8d\nmov    %edx,%r10d\nmov    %eax,%r11d\nimul   $0x66666667,%rdi,%rcx\nsar    $0x1f,%r8d\nsar    $0x1f,%r11d\nsar    $0x21,%rcx\nsub    %r8d,%ecx\nmov    %ecx,%r9d\nlea    (%rcx,%rcx,4),%ecx\nsub    %ecx,%r10d\nmovslq %eax,%rcx\nimul   $0x66666667,%rcx,%r8\nsar    $0x21,%r8\nsub    %r11d,%r8d\nmov    %eax,%r11d\nlea    (%r8,%r8,4),%ebx\nsub    %ebx,%r11d\nor     %r11d,%r10d\njne    1f24 <calcula+0x4e4>\nmovslq %r9d,%rdi\nmovslq %r8d,%rcx\nmov    %rdi,%rdx\nmov    %rcx,%rax\nimul   $0x2aaaaaab,%rdi,%r8\nmov    %edx,%r9d\nmov    %edx,%ebx\nmov    %eax,%r11d\nsar    $0x1f,%r9d\nshr    $0x20,%r8\nmov    %r8d,%r10d\nsub    %r9d,%r10d\nmov    %eax,%r9d\nlea    (%r10,%r10,2),%r8d\nsar    $0x1f,%r9d\nadd    %r8d,%r8d\nsub    %r8d,%ebx\nimul   $0x2aaaaaab,%rcx,%r8\nshr    $0x20,%r8\nsub    %r9d,%r8d\nlea    (%r8,%r8,2),%r9d\nadd    %r9d,%r9d\nsub    %r9d,%r11d\nor     %ebx,%r11d\njne    1f7b <calcula+0x53b>\nmovslq %r10d,%rdi\nmovslq %r8d,%rcx\nmov    %rdi,%rdx\nmov    %rcx,%rax\nimul   $0xffffffff92492493,%rdi,%rdi\nmov    %edx,%r8d\nmov    %edx,%r9d\nmov    %eax,%r10d\nsar    $0x1f,%r8d\nimul   $0xffffffff92492493,%rcx,%rcx\nshr    $0x20,%rdi\nadd    %edx,%edi\nshr    $0x20,%rcx\nsar    $0x2,%edi\nadd    %eax,%ecx\nsub    %r8d,%edi\nsar    $0x2,%ecx\nlea    0x0(,%rdi,8),%r8d\nsub    %edi,%r8d\nsub    %r8d,%r9d\nmov    %eax,%r8d\nsar    $0x1f,%r8d\nsub    %r8d,%ecx\nlea    0x0(,%rcx,8),%r8d\nsub    %ecx,%r8d\nsub    %r8d,%r10d\nor     %r9d,%r10d\ncmove  %edi,%edx\ncmove  %ecx,%eax\nmov    %edx,%edi\nmov    %eax,%r8d\nsar    $0x1f,%edi\nsar    $0x1f,%r8d\nshr    $0x1d,%edi\nshr    $0x1d,%r8d\nlea    (%rdx,%rdi,1),%ecx\nand    $0x7,%ecx\nsub    %edi,%ecx\nlea    (%rax,%r8,1),%edi\nand    $0x7,%edi\nsub    %r8d,%edi\nor     %edi,%ecx\njne    2019 <calcula+0x5d9>\ntest   %edx,%edx\nlea    0x7(%rdx),%ecx\ncmovs  %ecx,%edx\nlea    0x7(%rax),%ecx\nsar    $0x3,%edx\ntest   %eax,%eax\ncmovs  %ecx,%eax\nsar    $0x3,%eax\nmovslq %edx,%rdi\nmov    %edx,%r8d\nmov    %edx,%r10d\nmov    %eax,%r11d\nimul   $0x38e38e39,%rdi,%rcx\nsar    $0x1f,%r8d\nsar    $0x1f,%r11d\nsar    $0x21,%rcx\nsub    %r8d,%ecx\nmov    %ecx,%r9d\nlea    (%rcx,%rcx,8),%ecx\nsub    %ecx,%r10d\nmovslq %eax,%rcx\nimul   $0x38e38e39,%rcx,%r8\nsar    $0x21,%r8\nsub    %r11d,%r8d\nmov    %eax,%r11d\nlea    (%r8,%r8,8),%ebx\nsub    %ebx,%r11d\nor     %r11d,%r10d\njne    2070 <calcula+0x630>\nmovslq %r9d,%rdi\nmovslq %r8d,%rcx\nmov    %rdi,%rdx\nmov    %rcx,%rax\nimul   $0x66666667,%rdi,%r8\nmov    %edx,%r9d\nmov    %edx,%ebx\nmov    %eax,%r11d\nsar    $0x1f,%r9d\nsar    $0x22,%r8\nmov    %r8d,%r10d\nsub    %r9d,%r10d\nmov    %eax,%r9d\nlea    (%r10,%r10,4),%r8d\nsar    $0x1f,%r9d\nadd    %r8d,%r8d\nsub    %r8d,%ebx\nimul   $0x66666667,%rcx,%r8\nsar    $0x22,%r8\nsub    %r9d,%r8d\nlea    (%r8,%r8,4),%r9d\nadd    %r9d,%r9d\nsub    %r9d,%r11d\nor     %ebx,%r11d\njne    20c7 <calcula+0x687>\nmovslq %r10d,%rdi\nmovslq %r8d,%rcx\nmov    %rdi,%rdx\nmov    %rcx,%rax\nimul   $0x2e8ba2e9,%rdi,%r9\nmov    %edx,%r8d\nmov    %edx,%r11d\nmov    %eax,%r10d\nsar    $0x1f,%r8d\nsar    $0x1f,%r10d\nsar    $0x21,%r9\nsub    %r8d,%r9d\nlea    (%r9,%r9,4),%r8d\nlea    (%r9,%r8,2),%r8d\nsub    %r8d,%r11d\nimul   $0x2e8ba2e9,%rcx,%r8\nsar    $0x21,%r8\nsub    %r10d,%r8d\nlea    (%r8,%r8,4),%r10d\nlea    (%r8,%r10,2),%ebx\nmov    %eax,%r10d\nsub    %ebx,%r10d\nor     %r11d,%r10d\njne    211e <calcula+0x6de>\nmovslq %r9d,%rdi\nmovslq %r8d,%rcx\nmov    %rdi,%rdx\nmov    %rcx,%rax\nimul   $0x2aaaaaab,%rdi,%rdi\nmov    %edx,%r8d\nmov    %edx,%r9d\nmov    %eax,%r10d\nsar    $0x1f,%r8d\nimul   $0x2aaaaaab,%rcx,%rcx\npop    %rbx\nsar    $0x21,%rdi\nsub    %r8d,%edi\nsar    $0x21,%rcx\nlea    (%rdi,%rdi,2),%r8d\nshl    $0x2,%r8d\nsub    %r8d,%r9d\nmov    %eax,%r8d\nsar    $0x1f,%r8d\nsub    %r8d,%ecx\nlea    (%rcx,%rcx,2),%r8d\nshl    $0x2,%r8d\nsub    %r8d,%r10d\nor     %r10d,%r9d\ncmove  %edi,%edx\ncmove  %ecx,%eax\nmov    %edx,0xc(%rsi)\nmov    %eax,0x10(%rsi)\nret\nnopl   (%rax)\npxor   %xmm0,%xmm0\npop    %rbx\nret\nxchg   %ax,%ax\nmov    %ecx,%eax\nmov    (%rdi),%r8d\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\ncltd\ncvtsi2ss %ecx,%xmm1\nidivl  0x4(%rdi)\nimul   %eax,%r8d\nmov    %ecx,%eax\ncltd\nidivl  0xc(%rdi)\nimul   0x8(%rdi),%eax\nmov    %ecx,%edi\nshr    $0x1f,%edi\nadd    %eax,%r8d\nmov    %r8d,%edx\ncvtsi2ss %r8d,%xmm0\nmov    %r8d,0x4(%rsi)\nshr    $0x1f,%edx\nlea    (%r8,%rdx,1),%eax\nand    $0x1,%eax\ndivss  %xmm1,%xmm0\nsub    %edx,%eax\nlea    (%rcx,%rdi,1),%edx\nand    $0x1,%edx\nsub    %edi,%edx\nor     %edx,%eax\nje     28d0 <calcula+0xe90>\nmovslq %r8d,%rdx\nmov    %r8d,%eax\nmov    %r8d,%edi\nmov    %ecx,%r9d\nimul   $0x55555556,%rdx,%rdx\nsar    $0x1f,%eax\nsar    $0x1f,%r9d\nshr    $0x20,%rdx\nsub    %eax,%edx\nlea    (%rdx,%rdx,2),%eax\nsub    %eax,%edi\nmovslq %ecx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nsub    %r9d,%eax\nmov    %ecx,%r9d\nlea    (%rax,%rax,2),%r10d\nsub    %r10d,%r9d\nor     %r9d,%edi\ncmove  %edx,%r8d\ncmove  %eax,%ecx\nmov    %r8d,%edx\nmov    %ecx,%edi\nsar    $0x1f,%edx\nsar    $0x1f,%edi\nshr    $0x1e,%edx\nshr    $0x1e,%edi\nlea    (%r8,%rdx,1),%eax\nand    $0x3,%eax\nsub    %edx,%eax\nlea    (%rcx,%rdi,1),%edx\nand    $0x3,%edx\nsub    %edi,%edx\nor     %edx,%eax\njne    2265 <calcula+0x825>\ntest   %r8d,%r8d\nlea    0x3(%r8),%eax\ncmovns %r8d,%eax\nsar    $0x2,%eax\ntest   %ecx,%ecx\nmov    %eax,%r8d\nlea    0x3(%rcx),%eax\ncmovns %ecx,%eax\nsar    $0x2,%eax\nmov    %eax,%ecx\nmovslq %r8d,%rax\nmov    %r8d,%edx\nmov    %r8d,%r10d\nmov    %ecx,%r11d\nimul   $0x66666667,%rax,%r9\nsar    $0x1f,%edx\nsar    $0x1f,%r11d\nsar    $0x21,%r9\nsub    %edx,%r9d\nlea    (%r9,%r9,4),%edx\nsub    %edx,%r10d\nmovslq %ecx,%rdx\nimul   $0x66666667,%rdx,%rdi\nsar    $0x21,%rdi\nsub    %r11d,%edi\nmov    %ecx,%r11d\nlea    (%rdi,%rdi,4),%ebx\nsub    %ebx,%r11d\nor     %r11d,%r10d\njne    22b8 <calcula+0x878>\nmovslq %r9d,%rax\nmovslq %edi,%rdx\nmov    %rax,%r8\nmov    %rdx,%rcx\nimul   $0x2aaaaaab,%rax,%r9\nmov    %r8d,%edi\nmov    %r8d,%ebx\nmov    %ecx,%r10d\nsar    $0x1f,%edi\nsar    $0x1f,%r10d\nmov    %ecx,%r11d\nshr    $0x20,%r9\nsub    %edi,%r9d\nlea    (%r9,%r9,2),%edi\nadd    %edi,%edi\nsub    %edi,%ebx\nimul   $0x2aaaaaab,%rdx,%rdi\nshr    $0x20,%rdi\nsub    %r10d,%edi\nlea    (%rdi,%rdi,2),%r10d\nadd    %r10d,%r10d\nsub    %r10d,%r11d\nor     %ebx,%r11d\njne    230a <calcula+0x8ca>\nmovslq %r9d,%rax\nmovslq %edi,%rdx\nmov    %rax,%r8\nmov    %rdx,%rcx\nimul   $0xffffffff92492493,%rax,%rdi\nmov    %r8d,%r9d\nmov    %ecx,%r10d\nmov    %rdi,%rax\nshr    $0x20,%rax\nlea    (%r8,%rax,1),%edi\nmov    %r8d,%eax\nsar    $0x1f,%eax\nsar    $0x2,%edi\nsub    %eax,%edi\nlea    0x0(,%rdi,8),%eax\nsub    %edi,%eax\nsub    %eax,%r9d\nimul   $0xffffffff92492493,%rdx,%rax\nmov    %ecx,%edx\nsar    $0x1f,%edx\nshr    $0x20,%rax\nadd    %ecx,%eax\nsar    $0x2,%eax\nsub    %edx,%eax\nlea    0x0(,%rax,8),%edx\nsub    %eax,%edx\nsub    %edx,%r10d\nor     %r9d,%r10d\ncmove  %edi,%r8d\ncmove  %eax,%ecx\nmov    %r8d,%edx\nmov    %ecx,%edi\nsar    $0x1f,%edx\nsar    $0x1f,%edi\nshr    $0x1d,%edx\nshr    $0x1d,%edi\nlea    (%r8,%rdx,1),%eax\nand    $0x7,%eax\nsub    %edx,%eax\nlea    (%rcx,%rdi,1),%edx\nand    $0x7,%edx\nsub    %edi,%edx\nor     %edx,%eax\njne    23aa <calcula+0x96a>\ntest   %r8d,%r8d\nlea    0x7(%r8),%eax\ncmovns %r8d,%eax\nsar    $0x3,%eax\ntest   %ecx,%ecx\nmov    %eax,%r8d\nlea    0x7(%rcx),%eax\ncmovns %ecx,%eax\nsar    $0x3,%eax\nmov    %eax,%ecx\nmovslq %r8d,%rax\nmov    %r8d,%edx\nmov    %r8d,%r10d\nmov    %ecx,%r11d\nimul   $0x38e38e39,%rax,%r9\nsar    $0x1f,%edx\nsar    $0x1f,%r11d\nsar    $0x21,%r9\nsub    %edx,%r9d\nlea    (%r9,%r9,8),%edx\nsub    %edx,%r10d\nmovslq %ecx,%rdx\nimul   $0x38e38e39,%rdx,%rdi\nsar    $0x21,%rdi\nsub    %r11d,%edi\nmov    %ecx,%r11d\nlea    (%rdi,%rdi,8),%ebx\nsub    %ebx,%r11d\nor     %r11d,%r10d\njne    23fd <calcula+0x9bd>\nmovslq %r9d,%rax\nmovslq %edi,%rdx\nmov    %rax,%r8\nmov    %rdx,%rcx\nimul   $0x66666667,%rax,%r9\nmov    %r8d,%edi\nmov    %r8d,%ebx\nmov    %ecx,%r10d\nsar    $0x1f,%edi\nsar    $0x1f,%r10d\nmov    %ecx,%r11d\nsar    $0x22,%r9\nsub    %edi,%r9d\nlea    (%r9,%r9,4),%edi\nadd    %edi,%edi\nsub    %edi,%ebx\nimul   $0x66666667,%rdx,%rdi\nsar    $0x22,%rdi\nsub    %r10d,%edi\nlea    (%rdi,%rdi,4),%r10d\nadd    %r10d,%r10d\nsub    %r10d,%r11d\nor     %ebx,%r11d\njne    244f <calcula+0xa0f>\nmovslq %r9d,%rax\nmovslq %edi,%rdx\nmov    %rax,%r8\nmov    %rdx,%rcx\nimul   $0x2e8ba2e9,%rax,%r9\nmov    %r8d,%edi\nmov    %r8d,%r11d\nmov    %ecx,%r10d\nsar    $0x1f,%edi\nsar    $0x1f,%r10d\nsar    $0x21,%r9\nsub    %edi,%r9d\nlea    (%r9,%r9,4),%edi\nlea    (%r9,%rdi,2),%edi\nsub    %edi,%r11d\nimul   $0x2e8ba2e9,%rdx,%rdi\nsar    $0x21,%rdi\nsub    %r10d,%edi\nlea    (%rdi,%rdi,4),%r10d\nlea    (%rdi,%r10,2),%ebx\nmov    %ecx,%r10d\nsub    %ebx,%r10d\nor     %r11d,%r10d\njne    24a5 <calcula+0xa65>\nmovslq %r9d,%rax\nmovslq %edi,%rdx\nmov    %rax,%r8\nmov    %rdx,%rcx\nimul   $0x2aaaaaab,%rax,%rax\nmov    %r8d,%edi\nmov    %r8d,%r9d\nmov    %ecx,%r10d\nsar    $0x1f,%edi\nimul   $0x2aaaaaab,%rdx,%rdx\npop    %rbx\nsar    $0x21,%rax\nsub    %edi,%eax\nsar    $0x21,%rdx\nlea    (%rax,%rax,2),%edi\nshl    $0x2,%edi\nsub    %edi,%r9d\nmov    %ecx,%edi\nsar    $0x1f,%edi\nsub    %edi,%edx\nlea    (%rdx,%rdx,2),%edi\nshl    $0x2,%edi\nsub    %edi,%r10d\nor     %r10d,%r9d\ncmove  %eax,%r8d\ncmove  %edx,%ecx\nmov    %r8d,0xc(%rsi)\nmov    %ecx,0x10(%rsi)\nret\nnopl   (%rax)\nmov    (%rdi),%eax\nimul   0x8(%rdi),%eax\npxor   %xmm0,%xmm0\nmov    %ecx,%r8d\nshr    $0x1f,%r8d\npxor   %xmm1,%xmm1\ncvtsi2ss %ecx,%xmm1\nmov    %eax,%edx\ncvtsi2ss %eax,%xmm0\nmov    %eax,0x4(%rsi)\nmov    %eax,%edi\nshr    $0x1f,%edx\nlea    (%rax,%rdx,1),%eax\nand    $0x1,%eax\ndivss  %xmm1,%xmm0\nsub    %edx,%eax\nlea    (%rcx,%r8,1),%edx\nand    $0x1,%edx\nsub    %r8d,%edx\nor     %edx,%eax\nje     2878 <calcula+0xe38>\nmovslq %edi,%rdx\nmov    %edi,%eax\nmov    %edi,%r8d\nmov    %ecx,%r9d\nimul   $0x55555556,%rdx,%rdx\nsar    $0x1f,%eax\nsar    $0x1f,%r9d\nshr    $0x20,%rdx\nsub    %eax,%edx\nlea    (%rdx,%rdx,2),%eax\nsub    %eax,%r8d\nmovslq %ecx,%rax\nimul   $0x55555556,%rax,%rax\nshr    $0x20,%rax\nsub    %r9d,%eax\nmov    %ecx,%r9d\nlea    (%rax,%rax,2),%r10d\nsub    %r10d,%r9d\nor     %r9d,%r8d\ncmove  %edx,%edi\ncmove  %eax,%ecx\nmov    %edi,%edx\nmov    %ecx,%r8d\nsar    $0x1f,%edx\nsar    $0x1f,%r8d\nshr    $0x1e,%edx\nshr    $0x1e,%r8d\nlea    (%rdi,%rdx,1),%eax\nand    $0x3,%eax\nsub    %edx,%eax\nlea    (%rcx,%r8,1),%edx\nand    $0x3,%edx\nsub    %r8d,%edx\nor     %edx,%eax\njne    25c9 <calcula+0xb89>\ntest   %edi,%edi\nlea    0x3(%rdi),%eax\ncmovns %edi,%eax\nsar    $0x2,%eax\ntest   %ecx,%ecx\nmov    %eax,%edi\nlea    0x3(%rcx),%eax\ncmovns %ecx,%eax\nsar    $0x2,%eax\nmov    %eax,%ecx\nmovslq %edi,%rax\nmov    %edi,%r8d\nmov    %edi,%r10d\nmov    %ecx,%r11d\nimul   $0x66666667,%rax,%rdx\nsar    $0x1f,%r8d\nsar    $0x1f,%r11d\nsar    $0x21,%rdx\nsub    %r8d,%edx\nmov    %edx,%r9d\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%r10d\nmovslq %ecx,%rdx\nimul   $0x66666667,%rdx,%r8\nsar    $0x21,%r8\nsub    %r11d,%r8d\nmov    %ecx,%r11d\nlea    (%r8,%r8,4),%ebx\nsub    %ebx,%r11d\nor     %r11d,%r10d\njne    2620 <calcula+0xbe0>\nmovslq %r9d,%rax\nmovslq %r8d,%rdx\nmov    %rax,%rdi\nmov    %rdx,%rcx\nimul   $0x2aaaaaab,%rax,%r8\nmov    %edi,%r9d\nmov    %edi,%ebx\nmov    %ecx,%r11d\nsar    $0x1f,%r9d\nshr    $0x20,%r8\nmov    %r8d,%r10d\nsub    %r9d,%r10d\nmov    %ecx,%r9d\nlea    (%r10,%r10,2),%r8d\nsar    $0x1f,%r9d\nadd    %r8d,%r8d\nsub    %r8d,%ebx\nimul   $0x2aaaaaab,%rdx,%r8\nshr    $0x20,%r8\nsub    %r9d,%r8d\nlea    (%r8,%r8,2),%r9d\nadd    %r9d,%r9d\nsub    %r9d,%r11d\nor     %ebx,%r11d\njne    2677 <calcula+0xc37>\nmovslq %r10d,%rax\nmovslq %r8d,%rdx\nmov    %rax,%rdi\nmov    %rdx,%rcx\nimul   $0xffffffff92492493,%rax,%r8\nmov    %edi,%r9d\nmov    %ecx,%r10d\nmov    %r8,%rax\nshr    $0x20,%rax\nlea    (%rdi,%rax,1),%r8d\nmov    %edi,%eax\nsar    $0x1f,%eax\nsar    $0x2,%r8d\nsub    %eax,%r8d\nlea    0x0(,%r8,8),%eax\nsub    %r8d,%eax\nsub    %eax,%r9d\nimul   $0xffffffff92492493,%rdx,%rax\nmov    %ecx,%edx\nsar    $0x1f,%edx\nshr    $0x20,%rax\nadd    %ecx,%eax\nsar    $0x2,%eax\nsub    %edx,%eax\nlea    0x0(,%rax,8),%edx\nsub    %eax,%edx\nsub    %edx,%r10d\nor     %r9d,%r10d\ncmove  %r8d,%edi\ncmove  %eax,%ecx\nmov    %edi,%edx\nmov    %ecx,%r8d\nsar    $0x1f,%edx\nsar    $0x1f,%r8d\nshr    $0x1d,%edx\nshr    $0x1d,%r8d\nlea    (%rdi,%rdx,1),%eax\nand    $0x7,%eax\nsub    %edx,%eax\nlea    (%rcx,%r8,1),%edx\nand    $0x7,%edx\nsub    %r8d,%edx\nor     %edx,%eax\njne    2719 <calcula+0xcd9>\ntest   %edi,%edi\nlea    0x7(%rdi),%eax\ncmovns %edi,%eax\nsar    $0x3,%eax\ntest   %ecx,%ecx\nmov    %eax,%edi\nlea    0x7(%rcx),%eax\ncmovns %ecx,%eax\nsar    $0x3,%eax\nmov    %eax,%ecx\nmovslq %edi,%rax\nmov    %edi,%r8d\nmov    %edi,%r10d\nmov    %ecx,%r11d\nimul   $0x38e38e39,%rax,%rdx\nsar    $0x1f,%r8d\nsar    $0x1f,%r11d\nsar    $0x21,%rdx\nsub    %r8d,%edx\nmov    %edx,%r9d\nlea    (%rdx,%rdx,8),%edx\nsub    %edx,%r10d\nmovslq %ecx,%rdx\nimul   $0x38e38e39,%rdx,%r8\nsar    $0x21,%r8\nsub    %r11d,%r8d\nmov    %ecx,%r11d\nlea    (%r8,%r8,8),%ebx\nsub    %ebx,%r11d\nor     %r11d,%r10d\njne    2770 <calcula+0xd30>\nmovslq %r9d,%rax\nmovslq %r8d,%rdx\nmov    %rax,%rdi\nmov    %rdx,%rcx\nimul   $0x66666667,%rax,%r8\nmov    %edi,%r9d\nmov    %edi,%ebx\nmov    %ecx,%r11d\nsar    $0x1f,%r9d\nsar    $0x22,%r8\nmov    %r8d,%r10d\nsub    %r9d,%r10d\nmov    %ecx,%r9d\nlea    (%r10,%r10,4),%r8d\nsar    $0x1f,%r9d\nadd    %r8d,%r8d\nsub    %r8d,%ebx\nimul   $0x66666667,%rdx,%r8\nsar    $0x22,%r8\nsub    %r9d,%r8d\nlea    (%r8,%r8,4),%r9d\nadd    %r9d,%r9d\nsub    %r9d,%r11d\nor     %ebx,%r11d\njne    27c7 <calcula+0xd87>\nmovslq %r10d,%rax\nmovslq %r8d,%rdx\nmov    %rax,%rdi\nmov    %rdx,%rcx\nimul   $0x2e8ba2e9,%rax,%r9\nmov    %edi,%r8d\nmov    %edi,%r11d\nmov    %ecx,%r10d\nsar    $0x1f,%r8d\nsar    $0x1f,%r10d\nsar    $0x21,%r9\nsub    %r8d,%r9d\nlea    (%r9,%r9,4),%r8d\nlea    (%r9,%r8,2),%r8d\nsub    %r8d,%r11d\nimul   $0x2e8ba2e9,%rdx,%r8\nsar    $0x21,%r8\nsub    %r10d,%r8d\nlea    (%r8,%r8,4),%r10d\nlea    (%r8,%r10,2),%ebx\nmov    %ecx,%r10d\nsub    %ebx,%r10d\nor     %r11d,%r10d\njne    281e <calcula+0xdde>\nmovslq %r9d,%rax\nmovslq %r8d,%rdx\nmov    %rax,%rdi\nmov    %rdx,%rcx\nimul   $0x2aaaaaab,%rax,%rax\nmov    %edi,%r8d\nmov    %edi,%r9d\nmov    %ecx,%r10d\nsar    $0x1f,%r8d\nimul   $0x2aaaaaab,%rdx,%rdx\npop    %rbx\nsar    $0x21,%rax\nsub    %r8d,%eax\nsar    $0x21,%rdx\nlea    (%rax,%rax,2),%r8d\nshl    $0x2,%r8d\nsub    %r8d,%r9d\nmov    %ecx,%r8d\nsar    $0x1f,%r8d\nsub    %r8d,%edx\nlea    (%rdx,%rdx,2),%r8d\nshl    $0x2,%r8d\nsub    %r8d,%r10d\nor     %r10d,%r9d\ncmove  %eax,%edi\ncmove  %edx,%ecx\nmov    %edi,0xc(%rsi)\nmov    %ecx,0x10(%rsi)\nret\nnopl   (%rax)\nmov    %edi,%eax\nshr    $0x1f,%eax\nadd    %edi,%eax\nsar    %eax\nmov    %eax,%edi\nmov    %r8d,%eax\nadd    %ecx,%eax\nsar    %eax\nmov    %eax,%ecx\njmp    253d <calcula+0xafd>\nnopl   0x0(%rax)\nmov    %edx,%ecx\nadd    %r8d,%eax\nshr    $0x1f,%ecx\nsar    %eax\nadd    %ecx,%edx\nsar    %edx\njmp    1e45 <calcula+0x405>\nnopl   0x0(%rax,%rax,1)\nmov    %r8d,%eax\nshr    $0x1f,%eax\nadd    %r8d,%eax\nsar    %eax\nmov    %eax,%r8d\nmov    %edi,%eax\nadd    %ecx,%eax\nsar    %eax\nmov    %eax,%ecx\njmp    1ac9 <calcula+0x89>\nnopl   0x0(%rax,%rax,1)\nmov    %r8d,%eax\nshr    $0x1f,%eax\nadd    %r8d,%eax\nsar    %eax\nmov    %eax,%r8d\nmov    %edi,%eax\nadd    %ecx,%eax\nsar    %eax\nmov    %eax,%ecx\njmp    21d7 <calcula+0x797>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "copyr", "content": "/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief Prints version and copyright information and exit\n * @details Prints version and copyright information (usually called by opt -V)\n * @return Void\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nvoid copyr(void)\n{\n    IFDEBUG(\"copyr()\");\n    libmin_printf(\"%s - Version %s\\n\", \"frac\", VERSION);\n    libmin_printf(\"\\nCopyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author takes no responsability to any damage this software may inflige in your data.\\n\\n\", 2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n    if(verb > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", verb); /* -vvvv */\n    libmin_fail(1);\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O3.pseudo", "function_name": "copyr", "address": "0x1550", "label": "copyr", "content": "void __cdecl __noreturn copyr()\n{\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n    \"\\n\"\n    \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are fr\"\n    \"ee to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author \"\n    \"takes no responsability to any damage this software may inflige in your data.\\n\"\n    \"\\n\",\n    2018,\n    \"Iago Gade Gusmao Carrazzoni\",\n    \"iagocarrazzoni@gmail.com\");\n  if ( verb <= 3 )\n    libmin_fail(1);\n  libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "void __noreturn copyr() {\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n      \"\\n\"\n      \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http:\n      \"ee to change and redistribute it. There is NO WARRANTY, to the extent \"\n      \"permitted by law. USE IT AS IT IS. The author \"\n      \"takes no responsability to any damage this software may inflige in your \"\n      \"data.\\n\"\n      \"\\n\",\n      2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  if (verb <= 3) libmin_fail(1);\n  libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}", "binary": "frac-calc/frac-calc.host.O3", "assembly": "<copyr>:\nendbr64\nsub    $0x8,%rsp\nlea    0x4b1b(%rip),%rdx\nlea    0x4ab2(%rip),%rsi\nxor    %eax,%eax\nlea    0x4b1b(%rip),%rdi\ncall   52b0 <libmin_printf>\nmov    $0x7e2,%esi\nxor    %eax,%eax\nlea    0x4ac3(%rip),%rcx\nlea    0x4ad5(%rip),%rdx\nlea    0x4c88(%rip),%rdi\ncall   52b0 <libmin_printf>\nmov    0x7d11(%rip),%esi\ncmp    $0x3,%esi\njg     15b0 <copyr+0x60>\nmov    $0x1,%edi\nadd    $0x8,%rsp\njmp    2fb0 <libmin_fail>\nxchg   %ax,%ax\nlea    0x4ae4(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\nmov    $0x1,%edi\nadd    $0x8,%rsp\njmp    2fb0 <libmin_fail>\nnopl   0x0(%rax)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "divtokens", "content": "/* ---------------------------------------------------------------------- */\nvoid divtokens(char exp[SBUFF],  int frac[MYMAX]) /* break the string in tokens */\n{\n    char *token; /* token pointer */\n    char exp2[SBUFF];\n    char *aux[SBUFF];\n    int i = 0;\n\n    libmin_strcpy(exp2, exp); /* to maintain the original expression untouched */\n\n    token = libmin_strtok(exp2, \" \"); /* divides the equation into tokens */\n    while(token != NULL)\n    {\n        aux[i] = token;\n        token = libmin_strtok(NULL, \" \");\n        i++;\n    }\n\n    frac[MYMAX - 2] = i; /* number of elements of the expression */\n\n    avaliatokens(aux, frac, i);\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O3.pseudo", "function_name": "divtokens", "address": "0x1980", "label": "divtokens", "content": "void __fastcall divtokens(char *exp, int *frac)\n{\n  char *v2; // rax\n  __int64 v3; // rbx\n  int v4; // edx\n  char *aux[60]; // [rsp+0h] [rbp-258h] BYREF\n  char exp2[72]; // [rsp+1E0h] [rbp-78h] BYREF\n  unsigned __int64 v7; // [rsp+228h] [rbp-30h]\n\n  v7 = __readfsqword(0x28u);\n  libmin_strcpy(exp2, exp);\n  v2 = libmin_strtok(exp2, &asc_60C8[6]);\n  if ( v2 )\n  {\n    v3 = 1LL;\n    do\n    {\n      aux[v3 - 1] = v2;\n      v2 = libmin_strtok(0LL, &asc_60C8[6]);\n      v4 = v3++;\n    }\n    while ( v2 );\n  }\n  else\n  {\n    v4 = 0;\n  }\n  frac[9] = v4;\n  avaliatokens(aux, frac, v4);\n}\n"}, "pseudo_normalize": "void divtokens(char *exp, int *frac) {\n  char *v2;\n  long long v3;\n  int v4;\n  char *aux[60];\n  char exp2[72];\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  libmin_strcpy(exp2, exp);\n  v2 = libmin_strtok(exp2, &asc_60C8[6]);\n  if (v2) {\n    v3 = 1LL;\n    do {\n      aux[v3 - 1] = v2;\n      v2 = libmin_strtok(0LL, &asc_60C8[6]);\n      v4 = v3++;\n    } while (v2);\n  } else {\n    v4 = 0;\n  }\n  frac[9] = v4;\n  avaliatokens(aux, frac, v4);\n}", "binary": "frac-calc/frac-calc.host.O3", "assembly": "<divtokens>:\nendbr64\npush   %r13\npush   %r12\nmov    %rsi,%r12\nmov    %rdi,%rsi\npush   %rbp\nlea    0x4738(%rip),%rbp\npush   %rbx\nsub    $0x238,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x228(%rsp)\nxor    %eax,%eax\nlea    0x1e0(%rsp),%r13\nmov    %r13,%rdi\ncall   5520 <libmin_strcpy>\nmov    %rbp,%rsi\nmov    %r13,%rdi\ncall   55c0 <libmin_strtok>\ntest   %rax,%rax\nje     1a30 <divtokens+0xb0>\nmov    $0x1,%ebx\nmov    %rsp,%r13\nnopl   0x0(%rax)\nmov    %rbp,%rsi\nxor    %edi,%edi\nmov    %rax,-0x8(%r13,%rbx,8)\ncall   55c0 <libmin_strtok>\nmov    %ebx,%edx\nadd    $0x1,%rbx\ntest   %rax,%rax\njne    19e0 <divtokens+0x60>\nmov    %edx,0x24(%r12)\nmov    %r12,%rsi\nmov    %r13,%rdi\ncall   1730 <avaliatokens>\nmov    0x228(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1a37 <divtokens+0xb7>\nadd    $0x238,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax,%rax,1)\nxor    %edx,%edx\nmov    %rsp,%r13\njmp    19fa <divtokens+0x7a>\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "frac_init", "content": "/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief This function initializes some operations before start\n * @details Details to be written in\n * multiple lines\n *\n * @pre You need to call foo() before calling this function\n *\n * @param[in] i Input parameter that does bla\n * @param[out] o Parameter that outputs ble\n * @param[in,out] z The @a z variable is used as input and output\n *\n * @retval 0 Returned when bli\n * @retval 1 Error code: function returned blo\n *\n * @par Example\n * @code\n *    if(x == funcexample(i, o, z))\n *       printf(\"And that is it\\n\");\n * @endcode\n *\n * @return Void\n *\n * @warning Be carefull with blu\n * @todo Need to implement it. Its empty now. This doxygen tags are overwhelming.\n * Mandatory tags are: ingroup, brief, details, param, return, author and date.\n * The others are optional.\n *\n * @deprecated This function will be deactivated in version +11\n * @see help()\n * @see copyr()\n * @bug There is a bug with x greater than y\n * @note You can read more about it at <<a href=\"http://www.upe.br\">www.upe.br</a>>\n *\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n * @copyright Use this tag only if not the same as the whole file\n *\n */\nvoid frac_init(char exp[SBUFF])\n{\n    /* IFDEBUG(\"frac_init()\"); */\n    libmin_printf(\"-------------------\\n\");\n    libmin_printf(\"FRACTION CALCULATOR\\nPlease entry the desired operation:\\n(It is necessary to add a space between the fractions, like a/b + c/d)\\n-> \");\n    libmin_mgets(exp, SBUFF, minput); /* expression input */\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O3.pseudo", "function_name": "frac_init", "address": "0x15d0", "label": "frac_init", "content": "void __fastcall frac_init(char *exp)\n{\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\"FRACTION CALCULATOR\\n\"\n                \"Please entry the desired operation:\\n\"\n                \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n                \"-> \");\n  libmin_mgets(exp, 0x3CuLL, minput);\n}\n"}, "pseudo_normalize": "void frac_init(char *exp) {\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\n      \"FRACTION CALCULATOR\\n\"\n      \"Please entry the desired operation:\\n\"\n      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n      \"-> \");\n  libmin_mgets(exp, 60uLL, minput);\n}", "binary": "frac-calc/frac-calc.host.O3", "assembly": "<frac_init>:\nendbr64\npush   %rbp\nxor    %eax,%eax\nmov    %rdi,%rbp\nlea    0x4ad0(%rip),%rdi\ncall   52b0 <libmin_printf>\nlea    0x4d6b(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\nmov    0x7a25(%rip),%rdx\nmov    %rbp,%rdi\npop    %rbp\nmov    $0x3c,%esi\njmp    31e0 <libmin_mgets>\nnopl   0x0(%rax)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "help", "content": "/* functions */\n/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief Prints help information and exit\n * @details Prints help information (usually called by opt -h)\n * @return Void\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nvoid help(void)\n{\n    IFDEBUG(\"help()\");\n    libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n    libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n    libmin_printf(\"\\nOptions:\\n\");\n    libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n    libmin_printf(\"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n    libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n    /* add more options here */\n    libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n    libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n    libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\", \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n    libmin_fail(1);\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O3.pseudo", "function_name": "help", "address": "0x14a0", "label": "help", "content": "void __cdecl __noreturn help()\n{\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\", \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "void __noreturn help() {\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\n      \"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\",\n                \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}", "binary": "frac-calc/frac-calc.host.O3", "assembly": "<help>:\nendbr64\npush   %rbp\nlea    0x4b6c(%rip),%rbp\nlea    0x4b51(%rip),%rdx\nxor    %eax,%eax\nmov    %rbp,%rsi\nlea    0x4b5e(%rip),%rdi\ncall   52b0 <libmin_printf>\nmov    %rbp,%rsi\nlea    0x4b58(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\nlea    0x4b5e(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\nlea    0x4c0e(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\nlea    0x4c20(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\nlea    0x4c52(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\nlea    0x4c7c(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\nlea    0x4ca6(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\nlea    0x4cc8(%rip),%rdi\nlea    0x4b0e(%rip),%rdx\nxor    %eax,%eax\nlea    0x4b1e(%rip),%rsi\ncall   52b0 <libmin_printf>\nmov    $0x1,%edi\npop    %rbp\njmp    2fb0 <libmin_fail>\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "main", "content": " /* print the results */\n\n/* main */\n/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief This is the main event of the evening\n * @details Ladies and Gentleman... It's tiiiime!\n * Fightiiiiing at the blue corner,\n * he, who has compiled more C code than any other adversary in the history,\n * he, who has developed UNIX and Linux, and is an inspiration to maaany languages\n * and compilers, the GNU C Compiler, GCC!\n * Fightiiiiing at the red corner, the challenger, in his first fight, lacking of any\n * valid experience but angrily, blindly, and no doubtfully, will try to\n * compile this program without errors. He, the student, the apprentice,\n * the developer, iggc!!\n *\n * @param[in] argc Argument counter\n * @param[in] argv Argument strings (argument values)\n *\n * @retval 0 If succeed (EXIT_SUCCESS).\n * @retval 1 Or another error code if failed.\n *\n * @par Example\n * @code\n *    $./frac -h\n * @endcode\n *\n * @warning   Be carefull with...\n * @bug There is a bug with...\n * @todo Need to do...\n * @note You can read more about it at <<a href=\"http://www.upe.br\">www.upe.br</a>>\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nint main(int argc, char *argv[])\n{\n    int opt; /* return from getopt() */\n    char exp[SBUFF]; /* expression */\n    int frac[MYMAX];\n    int r[MYMAX];\n    float dec;\n    char rep[SBUFF];\n    int repi = 1;\n\n    /* IFDEBUG(\"Starting optarg loop...\"); */\n\n    /* getopt() configured options:\n     *        -h  help\n     *        -V  version\n     *        -v  verbose\n     */\n    opterr = 0;\n    while((opt = libmin_getopt(argc, argv, \"vhV\")) != EOF)\n        switch(opt)\n        {\n            case 'h':\n                help();\n                break;\n            case 'V':\n                copyr();\n                break;\n            case 'v':\n                verb++;\n                break;\n            case '?':\n            default:\n                libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", argv[0], argv[0]);\n                return 1;\n        }\n\n    if(verb)\n        libmin_printf(\"Verbose level set at: %d\\n\", verb);\n\n    do\n    {\n        frac_init(exp); /* initialization function */\n        divtokens(exp, frac); /* break the string in tokens */\n        dec = calcula(frac, r); /* computes the fraction */\n        print(exp, r, dec, frac); /* prints the results */\n        libmin_printf(\"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, SBUFF, minput);\n        repi = libmin_atoi(rep);\n    }while(repi == 1);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  char *v5; // rax\n  __int64 v6; // r13\n  int v7; // r8d\n  float v8; // xmm0_4\n  char v9; // r8\n  int frac[12]; // [rsp+10h] [rbp-348h] BYREF\n  int r[12]; // [rsp+40h] [rbp-318h] BYREF\n  char *aux[60]; // [rsp+70h] [rbp-2E8h] BYREF\n  char exp[64]; // [rsp+250h] [rbp-108h] BYREF\n  char rep[64]; // [rsp+290h] [rbp-C8h] BYREF\n  char dest[72]; // [rsp+2D0h] [rbp-88h] BYREF\n  unsigned __int64 v16; // [rsp+318h] [rbp-40h]\n\n  v16 = __readfsqword(0x28u);\n  opterr = 0;\n  while ( 1 )\n  {\n    v3 = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if ( v3 == -1 )\n    {\n      if ( verb )\n        libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      while ( 1 )\n      {\n        libmin_printf(\"-------------------\\n\");\n        libmin_printf(\"FRACTION CALCULATOR\\n\"\n                      \"Please entry the desired operation:\\n\"\n                      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n                      \"-> \");\n        libmin_mgets(exp, 0x3CuLL, minput);\n        libmin_strcpy(dest, exp);\n        v5 = libmin_strtok(dest, &asc_60C8[6]);\n        if ( v5 )\n        {\n          v6 = 1LL;\n          do\n          {\n            aux[v6 - 1] = v5;\n            v5 = libmin_strtok(0LL, &asc_60C8[6]);\n            v7 = v6++;\n          }\n          while ( v5 );\n        }\n        else\n        {\n          v7 = 0;\n        }\n        frac[9] = v7;\n        avaliatokens(aux, frac, v7);\n        v8 = calcula(frac, r);\n        v9 = 45;\n        if ( frac[10] != 2 )\n        {\n          v9 = 42;\n          if ( frac[10] != 3 )\n            v9 = 4 * (frac[10] == 4) + 43;\n        }\n        libmin_printf(\n          \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\",\n          exp,\n          frac[9],\n          frac[8],\n          (unsigned int)v9,\n          frac[7],\n          frac[6],\n          r[1],\n          r[0],\n          r[3],\n          r[4],\n          v8);\n        libmin_printf(\"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 0x3CuLL, minput);\n        if ( libmin_atoi(rep) != 1 )\n          libmin_success();\n      }\n    }\n    if ( v3 == 104 )\n      help();\n    if ( v3 != 118 )\n      break;\n    ++verb;\n  }\n  if ( v3 == 86 )\n    copyr();\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  int v3;\n  char *v5;\n  long long v6;\n  int v7;\n  float v8;\n  char v9;\n  int frac[12];\n  int r[12];\n  char *aux[60];\n  char exp[64];\n  char rep[64];\n  char dest[72];\n  unsigned long long v16;\n  v16 = __readfsqword(40u);\n  opterr = 0;\n  while (1) {\n    v3 = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if (v3 == -1) {\n      if (verb) libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      while (1) {\n        libmin_printf(\"-------------------\\n\");\n        libmin_printf(\n            \"FRACTION CALCULATOR\\n\"\n            \"Please entry the desired operation:\\n\"\n            \"(It is necessary to add a space between the fractions, like a/b + \"\n            \"c/d)\\n\"\n            \"-> \");\n        libmin_mgets(exp, 60uLL, minput);\n        libmin_strcpy(dest, exp);\n        v5 = libmin_strtok(dest, &asc_60C8[6]);\n        if (v5) {\n          v6 = 1LL;\n          do {\n            aux[v6 - 1] = v5;\n            v5 = libmin_strtok(0LL, &asc_60C8[6]);\n            v7 = v6++;\n          } while (v5);\n        } else {\n          v7 = 0;\n        }\n        frac[9] = v7;\n        avaliatokens(aux, frac, v7);\n        v8 = calcula(frac, r);\n        v9 = 45;\n        if (frac[10] != 2) {\n          v9 = 42;\n          if (frac[10] != 3) v9 = 4 * (frac[10] == 4) + 43;\n        }\n        libmin_printf(\n            \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: \"\n            \"%d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\",\n            exp, frac[9], frac[8], (unsigned int)v9, frac[7], frac[6], r[1],\n            r[0], r[3], r[4], v8);\n        libmin_printf(\n            \"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 60uLL, minput);\n        if (libmin_atoi(rep) != 1) libmin_success();\n      }\n    }\n    if (v3 == 104) help();\n    if (v3 != 118) break;\n    ++verb;\n  }\n  if (v3 == 86) copyr();\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}", "binary": "frac-calc/frac-calc.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nlea    0x4f9d(%rip),%r12\npush   %rbp\nmov    %edi,%ebp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x328,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x318(%rsp)\nxor    %eax,%eax\nmovl   $0x0,0x8112(%rip)\nmov    %r12,%rdx\nmov    %rbx,%rsi\nmov    %ebp,%edi\ncall   2fd0 <libmin_getopt>\ncmp    $0xffffffff,%eax\nje     11ec <main+0xcc>\ncmp    $0x68,%eax\nje     11c8 <main+0xa8>\ncmp    $0x76,%eax\nje     11e0 <main+0xc0>\ncmp    $0x56,%eax\nje     11d0 <main+0xb0>\nmov    (%rbx),%rsi\nlea    0x5257(%rip),%rdi\nxor    %eax,%eax\nmov    %rsi,%rdx\ncall   52b0 <libmin_printf>\nmov    $0x1,%eax\nmov    0x318(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    139c <main+0x27c>\nadd    $0x328,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\ncall   14a0 <help>\njmp    115e <main+0x3e>\nnop\ncall   1550 <copyr>\njmp    115e <main+0x3e>\nnopw   0x0(%rax,%rax,1)\naddl   $0x1,0x80c5(%rip)\njmp    115e <main+0x3e>\nmov    0x80ba(%rip),%esi\ntest   %esi,%esi\njne    1389 <main+0x269>\nlea    0x40(%rsp),%rax\nlea    0x250(%rsp),%r12\nmov    %rax,(%rsp)\nlea    0x70(%rsp),%rbx\nlea    0x10(%rsp),%r14\nlea    0x290(%rsp),%rax\nlea    0x2d0(%rsp),%r15\nmov    %rax,0x8(%rsp)\nlea    0x4e9d(%rip),%rbp\nnopl   0x0(%rax)\nlea    0x4e72(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\nlea    0x510b(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\nmov    0x7dc5(%rip),%rdx\nmov    $0x3c,%esi\nmov    %r12,%rdi\ncall   31e0 <libmin_mgets>\nmov    %r12,%rsi\nmov    %r15,%rdi\ncall   5520 <libmin_strcpy>\nmov    %rbp,%rsi\nmov    %r15,%rdi\ncall   55c0 <libmin_strtok>\ntest   %rax,%rax\nje     1381 <main+0x261>\nmov    $0x1,%r13d\nnopl   (%rax)\nmov    %rax,-0x8(%rbx,%r13,8)\nmov    %rbp,%rsi\nxor    %edi,%edi\ncall   55c0 <libmin_strtok>\nmov    %r13d,%r8d\nadd    $0x1,%r13\ntest   %rax,%rax\njne    1290 <main+0x170>\nmov    %r8d,%edx\nmov    %r14,%rsi\nmov    %rbx,%rdi\nmov    %r8d,0x34(%rsp)\ncall   1730 <avaliatokens>\nmov    (%rsp),%rsi\nmov    %r14,%rdi\ncall   1a40 <calcula>\nmov    0x38(%rsp),%eax\nmov    $0x2d,%r8d\ncmp    $0x2,%eax\nje     12f3 <main+0x1d3>\nmov    $0x2a,%r8d\ncmp    $0x3,%eax\nje     12f3 <main+0x1d3>\ncmp    $0x4,%eax\nsete   %r8b\nlea    0x2b(,%r8,4),%r8d\nsub    $0x8,%rsp\nmovsbl %r8b,%r8d\nmov    %r12,%rsi\ncvtss2sd %xmm0,%xmm0\nmov    0x58(%rsp),%eax\nlea    0x50fb(%rip),%rdi\npush   %rax\nmov    0x5c(%rsp),%eax\npush   %rax\nmov    0x58(%rsp),%eax\npush   %rax\nmov    0x64(%rsp),%eax\npush   %rax\nmov    0x50(%rsp),%eax\npush   %rax\nmov    0x5c(%rsp),%r9d\nmov    $0x1,%eax\nmov    0x60(%rsp),%ecx\nmov    0x64(%rsp),%edx\ncall   52b0 <libmin_printf>\nadd    $0x30,%rsp\nlea    0x5124(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\nmov    0x8(%rsp),%r13\nmov    $0x3c,%esi\nmov    0x7cc4(%rip),%rdx\nmov    %r13,%rdi\ncall   31e0 <libmin_mgets>\nmov    %r13,%rdi\ncall   2ed0 <libmin_atoi>\ncmp    $0x1,%eax\nje     1238 <main+0x118>\ncall   5670 <libmin_success>\nxor    %eax,%eax\njmp    1198 <main+0x78>\nxor    %r8d,%r8d\njmp    12ab <main+0x18b>\nlea    0x4d44(%rip),%rdi\nxor    %eax,%eax\ncall   52b0 <libmin_printf>\njmp    11fa <main+0xda>\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "misto", "content": "/* ---------------------------------------------------------------------- */\nvoid misto(int mist, int frac[MYMAX], int i) /* fraction to mixed number */\n{\n    /* 2 fractions no mist */\n    if(i == 3)\n    {\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    /* 1 mist first fraction */\n    if(mist == 1)\n    {\n        frac[0] = frac[2] * frac[0] + frac[1]; /* num */\n        frac[1] = frac[2]; /* den */\n        frac[2] = frac[3]; /* num */\n        frac[3] = frac[4]; /* den */\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n\n        return;\n    }\n    /* 1 mist second fraction */\n    if(mist == 2)\n    {\n        frac[2] = frac[4] * frac[2] + frac[3];\n        frac[3] = frac[4];\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    /* 2 mist */\n    if(i == 5)\n    {\n        frac[0] = frac[2] * frac[0] + frac[1]; /* num */\n        frac[1] = frac[2]; /* den */\n        frac[2] = frac[5] * frac[3] + frac[4]; /* num */\n        frac[3] = frac[5]; /* den */\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O3.pseudo", "function_name": "misto", "address": "0x1610", "label": "misto", "content": "void __fastcall misto(int mist, int *frac, int i)\n{\n  unsigned int v3; // edx\n  __m128i v4; // xmm2\n  __m128i v5; // xmm1\n  __m128i v6; // xmm7\n  unsigned int v7; // ecx\n  __m128i v8; // xmm0\n  unsigned int v9; // edx\n  __m128i v10; // xmm1\n  unsigned int v11; // edx\n  __m128i v12; // xmm2\n  __m128i v13; // xmm5\n  __m128i v14; // xmm0\n\n  if ( i == 3 )\n  {\n    *(__m128i *)(frac + 6) = _mm_shuffle_epi32(_mm_loadu_si128((const __m128i *)frac), 27);\n  }\n  else if ( mist == 1 )\n  {\n    v11 = frac[2];\n    v12 = _mm_cvtsi32_si128(frac[3]);\n    v13 = _mm_cvtsi32_si128(frac[4]);\n    v14 = _mm_cvtsi32_si128(frac[1] + v11 * *frac);\n    *(__m128i *)frac = _mm_unpacklo_epi64(_mm_unpacklo_epi32(v14, _mm_cvtsi32_si128(v11)), _mm_unpacklo_epi32(v12, v13));\n    *(__m128i *)(frac + 6) = _mm_unpacklo_epi64(\n                               _mm_unpacklo_epi32(v13, v12),\n                               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v11), v14));\n  }\n  else if ( mist == 2 )\n  {\n    v3 = frac[4];\n    v4 = _mm_cvtsi32_si128(frac[1]);\n    v5 = _mm_cvtsi32_si128(frac[3] + v3 * frac[2]);\n    v6 = _mm_cvtsi32_si128(*frac);\n    *((_QWORD *)frac + 1) = _mm_unpacklo_epi32(v5, _mm_cvtsi32_si128(v3)).m128i_u64[0];\n    *(__m128i *)(frac + 6) = _mm_unpacklo_epi64(\n                               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v3), v5),\n                               _mm_unpacklo_epi32(v4, v6));\n  }\n  else if ( i == 5 )\n  {\n    v7 = frac[2];\n    v8 = _mm_cvtsi32_si128(frac[1] + v7 * *frac);\n    v9 = frac[5];\n    v10 = _mm_cvtsi32_si128(frac[4] + v9 * frac[3]);\n    *(__m128i *)frac = _mm_unpacklo_epi64(\n                         _mm_unpacklo_epi32(v8, _mm_cvtsi32_si128(v7)),\n                         _mm_unpacklo_epi32(v10, _mm_cvtsi32_si128(v9)));\n    *(__m128i *)(frac + 6) = _mm_unpacklo_epi64(\n                               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v9), v10),\n                               _mm_unpacklo_epi32(_mm_cvtsi32_si128(v7), v8));\n  }\n}\n"}, "pseudo_normalize": "void misto(int mist, int *frac, int i) {\n  unsigned int v3;\n  __m128i v4;\n  __m128i v5;\n  __m128i v6;\n  unsigned int v7;\n  __m128i v8;\n  unsigned int v9;\n  __m128i v10;\n  unsigned int v11;\n  __m128i v12;\n  __m128i v13;\n  __m128i v14;\n  if (i == 3) {\n    *(__m128i *)(frac + 6) =\n        _mm_shuffle_epi32(_mm_loadu_si128((const __m128i *)frac), 27);\n  } else if (mist == 1) {\n    v11 = frac[2];\n    v12 = _mm_cvtsi32_si128(frac[3]);\n    v13 = _mm_cvtsi32_si128(frac[4]);\n    v14 = _mm_cvtsi32_si128(frac[1] + v11 * *frac);\n    *(__m128i *)frac =\n        _mm_unpacklo_epi64(_mm_unpacklo_epi32(v14, _mm_cvtsi32_si128(v11)),\n                           _mm_unpacklo_epi32(v12, v13));\n    *(__m128i *)(frac + 6) =\n        _mm_unpacklo_epi64(_mm_unpacklo_epi32(v13, v12),\n                           _mm_unpacklo_epi32(_mm_cvtsi32_si128(v11), v14));\n  } else if (mist == 2) {\n    v3 = frac[4];\n    v4 = _mm_cvtsi32_si128(frac[1]);\n    v5 = _mm_cvtsi32_si128(frac[3] + v3 * frac[2]);\n    v6 = _mm_cvtsi32_si128(*frac);\n    *((uint64_t *)frac + 1) =\n        _mm_unpacklo_epi32(v5, _mm_cvtsi32_si128(v3)).m128i_u64[0];\n    *(__m128i *)(frac + 6) =\n        _mm_unpacklo_epi64(_mm_unpacklo_epi32(_mm_cvtsi32_si128(v3), v5),\n                           _mm_unpacklo_epi32(v4, v6));\n  } else if (i == 5) {\n    v7 = frac[2];\n    v8 = _mm_cvtsi32_si128(frac[1] + v7 * *frac);\n    v9 = frac[5];\n    v10 = _mm_cvtsi32_si128(frac[4] + v9 * frac[3]);\n    *(__m128i *)frac =\n        _mm_unpacklo_epi64(_mm_unpacklo_epi32(v8, _mm_cvtsi32_si128(v7)),\n                           _mm_unpacklo_epi32(v10, _mm_cvtsi32_si128(v9)));\n    *(__m128i *)(frac + 6) =\n        _mm_unpacklo_epi64(_mm_unpacklo_epi32(_mm_cvtsi32_si128(v9), v10),\n                           _mm_unpacklo_epi32(_mm_cvtsi32_si128(v7), v8));\n  }\n}", "binary": "frac-calc/frac-calc.host.O3", "assembly": "<misto>:\nendbr64\nmov    %rsi,%rax\ncmp    $0x3,%edx\nje     1630 <misto+0x20>\ncmp    $0x1,%edi\nje     16e0 <misto+0xd0>\ncmp    $0x2,%edi\nje     1640 <misto+0x30>\ncmp    $0x5,%edx\nje     1680 <misto+0x70>\nret\nmovdqu (%rsi),%xmm4\npshufd $0x1b,%xmm4,%xmm0\nmovups %xmm0,0x18(%rsi)\nret\nxchg   %ax,%ax\nmov    0x10(%rsi),%edx\nmov    0x8(%rsi),%ecx\nmovd   0x4(%rsi),%xmm2\nimul   %edx,%ecx\nadd    0xc(%rsi),%ecx\nmovd   %edx,%xmm7\nmovd   %ecx,%xmm0\nmovd   %ecx,%xmm1\npunpckldq %xmm7,%xmm0\nmovd   (%rsi),%xmm7\nmovq   %xmm0,0x8(%rsi)\nmovd   %edx,%xmm0\npunpckldq %xmm7,%xmm2\npunpckldq %xmm1,%xmm0\npunpcklqdq %xmm2,%xmm0\nmovups %xmm0,0x18(%rsi)\nret\nnop\nmov    0x8(%rsi),%ecx\nmov    (%rsi),%edx\nimul   %ecx,%edx\nadd    0x4(%rsi),%edx\nmovd   %ecx,%xmm6\nmovd   %edx,%xmm0\nmov    0x14(%rsi),%edx\nmov    0xc(%rsi),%esi\nmovdqa %xmm0,%xmm2\nimul   %edx,%esi\nmovd   %edx,%xmm5\npunpckldq %xmm6,%xmm2\nadd    0x10(%rax),%esi\nmovd   %esi,%xmm3\nmovd   %esi,%xmm1\npunpckldq %xmm5,%xmm3\npunpcklqdq %xmm3,%xmm2\nmovups %xmm2,(%rax)\nmovd   %ecx,%xmm2\npunpckldq %xmm0,%xmm2\nmovd   %edx,%xmm0\npunpckldq %xmm1,%xmm0\npunpcklqdq %xmm2,%xmm0\nmovups %xmm0,0x18(%rax)\nret\nnopw   0x0(%rax,%rax,1)\nmov    0x8(%rsi),%edx\nmov    (%rsi),%ecx\nmovd   0xc(%rsi),%xmm2\nmovd   0x10(%rsi),%xmm5\nimul   %edx,%ecx\nadd    0x4(%rsi),%ecx\nmovd   %edx,%xmm6\nmovdqa %xmm2,%xmm3\nmovd   %ecx,%xmm1\nmovd   %ecx,%xmm0\npunpckldq %xmm5,%xmm3\npunpckldq %xmm6,%xmm1\npunpcklqdq %xmm3,%xmm1\nmovups %xmm1,(%rsi)\nmovd   %edx,%xmm1\npunpckldq %xmm0,%xmm1\nmovdqa %xmm5,%xmm0\npunpckldq %xmm2,%xmm0\npunpcklqdq %xmm1,%xmm0\nmovups %xmm0,0x18(%rsi)\nret\nnopl   (%rax)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "print", "content": "/* ---------------------------------------------------------------------- */\nvoid print(char exp[SBUFF], int r[MYMAX], float dec, int frac[MYMAX]) /* print the results */\n{\n    char op;\n\n    if(frac[MYMAX - 1] == 1)\n        op = '+';\n    if(frac[MYMAX - 1] == 2)\n        op = '-';\n    if(frac[MYMAX - 1] == 3)\n        op = '*';\n    if(frac[MYMAX - 1] == 4)\n        op = '/';\n    \n    libmin_printf(\"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\", exp, frac[MYMAX - 2], frac[MYMAX - 3], op, frac[MYMAX - 4], frac[MYMAX - 5], r[1], r[0], r[3], r[4], dec);\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O3.pseudo", "function_name": "print", "address": "0x2c60", "label": "print", "content": "void __fastcall print(char *exp, int *r, float dec, int *frac)\n{\n  int v4; // eax\n  __int64 v5; // r8\n\n  v4 = frac[10];\n  v5 = 45LL;\n  if ( v4 != 2 )\n  {\n    v5 = 42LL;\n    if ( v4 != 3 )\n      v5 = 4 * (unsigned int)(v4 == 4) + 43;\n  }\n  libmin_printf(\n    \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\",\n    exp,\n    frac[9],\n    frac[8],\n    v5,\n    frac[7],\n    frac[6],\n    r[1],\n    *r,\n    r[3],\n    r[4],\n    dec);\n}\n"}, "pseudo_normalize": "void print(char *exp, int *r, float dec, int *frac) {\n  int v4;\n  long long v5;\n  v4 = frac[10];\n  v5 = 45LL;\n  if (v4 != 2) {\n    v5 = 42LL;\n    if (v4 != 3) v5 = 4 * (unsigned int)(v4 == 4) + 43;\n  }\n  libmin_printf(\n      \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: \"\n      \"%d/%d\\nDECIMAL: %.3f\\n\",\n      exp, frac[9], frac[8], v5, frac[7], frac[6], r[1], *r, r[3], r[4], dec);\n}", "binary": "frac-calc/frac-calc.host.O3", "assembly": "<print>:\nendbr64\nsub    $0x8,%rsp\nmov    0x28(%rdx),%eax\nmov    %rdi,%r10\nmov    $0x2d,%r8d\ncmp    $0x2,%eax\nje     2c84 <print+0x24>\nmov    $0x2a,%r8d\ncmp    $0x3,%eax\njne    2cd0 <print+0x70>\nmov    0x10(%rsi),%eax\nsub    $0x8,%rsp\nmov    0x20(%rdx),%ecx\nlea    0x3773(%rip),%rdi\nmov    0x24(%rdx),%r11d\ncvtss2sd %xmm0,%xmm0\npush   %rax\nmov    0xc(%rsi),%eax\npush   %rax\nmov    (%rsi),%eax\npush   %rax\nmov    0x4(%rsi),%eax\nmov    %r10,%rsi\npush   %rax\nmov    0x18(%rdx),%eax\npush   %rax\nmov    0x1c(%rdx),%r9d\nmov    $0x1,%eax\nmov    %r11d,%edx\ncall   52b0 <libmin_printf>\nadd    $0x38,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nxor    %r8d,%r8d\ncmp    $0x4,%eax\nsete   %r8b\nlea    0x2b(,%r8,4),%r8d\njmp    2c84 <print+0x24>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "simplifica", "content": "/* ---------------------------------------------------------------------- */\nvoid simplifica(int r[MYMAX]) /* simplifies the result */\n{\n    int i;\n    int aux1, aux2;\n\n    aux1 = r[1];\n    aux2 = r[0];\n\n    for(i = 1; i < MYMAX + 2; i++)\n    {\n        if(aux1%i == 0 && aux2%i == 0) /* simplified */\n        {\n            aux1 /= i;\n            aux2 /= i;\n        }\n    }\n    r[3] = aux1;\n    r[4] = aux2;\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O3.pseudo", "function_name": "simplifica", "address": "0x28f0", "label": "simplifica", "content": "void __fastcall simplifica(int *r)\n{\n  signed int v1; // eax\n  signed int v2; // edx\n  __int64 v3; // rsi\n  __int64 v4; // rcx\n  signed int v5; // r9d\n  signed int v6; // r8d\n  int v7; // esi\n  int v8; // ecx\n  __int64 v9; // rsi\n  __int64 v10; // rcx\n  int v11; // r9d\n  int v12; // r8d\n  int v13; // r9d\n  int v14; // r8d\n  int v15; // esi\n  int v16; // ecx\n\n  v1 = r[1];\n  v2 = *r;\n  if ( !((*r % 2) | (v1 % 2)) )\n  {\n    v2 = *r / 2;\n    v1 /= 2;\n  }\n  if ( !((v2 % 3) | (v1 % 3)) )\n  {\n    v1 /= 3;\n    v2 /= 3;\n  }\n  if ( !((v2 % 4) | (v1 % 4)) )\n  {\n    v1 /= 4;\n    v2 /= 4;\n  }\n  v3 = v1;\n  v4 = v2;\n  if ( !((v2 % 5) | (v1 % 5)) )\n  {\n    v3 = v1 / 5;\n    v4 = v2 / 5;\n    v1 /= 5;\n    v2 /= 5;\n  }\n  v5 = ((unsigned __int64)(715827883 * v3) >> 32) - (v1 >> 31);\n  v6 = ((unsigned __int64)(715827883 * v4) >> 32) - (v2 >> 31);\n  if ( !((v2 - 6 * v6) | (v1 - 6 * v5)) )\n  {\n    v3 = v5;\n    v4 = v6;\n    v1 = v5;\n    v2 = v6;\n  }\n  v7 = ((int)(v1 + ((unsigned __int64)(-1840700269 * v3) >> 32)) >> 2) - (v1 >> 31);\n  v8 = ((int)(v2 + ((unsigned __int64)(-1840700269 * v4) >> 32)) >> 2) - (v2 >> 31);\n  if ( !((v1 - 7 * v7) | (v2 - 7 * v8)) )\n  {\n    v1 = v7;\n    v2 = v8;\n  }\n  if ( !((v2 % 8) | (v1 % 8)) )\n  {\n    v1 /= 8;\n    v2 /= 8;\n  }\n  v9 = v1;\n  v10 = v2;\n  if ( !((v2 % 9) | (v1 % 9)) )\n  {\n    v9 = v1 / 9;\n    v10 = v2 / 9;\n    v1 /= 9;\n    v2 /= 9;\n  }\n  v11 = ((int)((unsigned __int64)(1717986919 * v9) >> 32) >> 2) - (v1 >> 31);\n  v12 = ((int)((unsigned __int64)(1717986919 * v10) >> 32) >> 2) - (v2 >> 31);\n  if ( !((v2 - 10 * v12) | (v1 - 10 * v11)) )\n  {\n    v9 = v11;\n    v10 = v12;\n    v1 = v11;\n    v2 = v12;\n  }\n  v13 = ((int)((unsigned __int64)(780903145 * v9) >> 32) >> 1) - (v1 >> 31);\n  v14 = ((int)((unsigned __int64)(780903145 * v10) >> 32) >> 1) - (v2 >> 31);\n  if ( !((v2 - 11 * v14) | (v1 - 11 * v13)) )\n  {\n    v9 = v13;\n    v10 = v14;\n    v1 = v13;\n    v2 = v14;\n  }\n  v15 = ((int)((unsigned __int64)(715827883 * v9) >> 32) >> 1) - (v1 >> 31);\n  v16 = ((int)((unsigned __int64)(715827883 * v10) >> 32) >> 1) - (v2 >> 31);\n  if ( !((v2 - 12 * v16) | (v1 - 12 * v15)) )\n  {\n    v1 = v15;\n    v2 = v16;\n  }\n  *(_QWORD *)(r + 3) = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v1), _mm_cvtsi32_si128(v2)).m128i_u64[0];\n}\n"}, "pseudo_normalize": "void simplifica(int *r) {\n  signed int v1;\n  signed int v2;\n  long long v3;\n  long long v4;\n  signed int v5;\n  signed int v6;\n  int v7;\n  int v8;\n  long long v9;\n  long long v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  int v15;\n  int v16;\n  v1 = r[1];\n  v2 = *r;\n  if (!((*r % 2) | (v1 % 2))) {\n    v2 = *r / 2;\n    v1 /= 2;\n  }\n  if (!((v2 % 3) | (v1 % 3))) {\n    v1 /= 3;\n    v2 /= 3;\n  }\n  if (!((v2 % 4) | (v1 % 4))) {\n    v1 /= 4;\n    v2 /= 4;\n  }\n  v3 = v1;\n  v4 = v2;\n  if (!((v2 % 5) | (v1 % 5))) {\n    v3 = v1 / 5;\n    v4 = v2 / 5;\n    v1 /= 5;\n    v2 /= 5;\n  }\n  v5 = ((unsigned long long)(715827883 * v3) >> 32) - (v1 >> 31);\n  v6 = ((unsigned long long)(715827883 * v4) >> 32) - (v2 >> 31);\n  if (!((v2 - 6 * v6) | (v1 - 6 * v5))) {\n    v3 = v5;\n    v4 = v6;\n    v1 = v5;\n    v2 = v6;\n  }\n  v7 = ((int)(v1 + ((unsigned long long)(-1840700269 * v3) >> 32)) >> 2) -\n       (v1 >> 31);\n  v8 = ((int)(v2 + ((unsigned long long)(-1840700269 * v4) >> 32)) >> 2) -\n       (v2 >> 31);\n  if (!((v1 - 7 * v7) | (v2 - 7 * v8))) {\n    v1 = v7;\n    v2 = v8;\n  }\n  if (!((v2 % 8) | (v1 % 8))) {\n    v1 /= 8;\n    v2 /= 8;\n  }\n  v9 = v1;\n  v10 = v2;\n  if (!((v2 % 9) | (v1 % 9))) {\n    v9 = v1 / 9;\n    v10 = v2 / 9;\n    v1 /= 9;\n    v2 /= 9;\n  }\n  v11 = ((int)((unsigned long long)(1717986919 * v9) >> 32) >> 2) - (v1 >> 31);\n  v12 = ((int)((unsigned long long)(1717986919 * v10) >> 32) >> 2) - (v2 >> 31);\n  if (!((v2 - 10 * v12) | (v1 - 10 * v11))) {\n    v9 = v11;\n    v10 = v12;\n    v1 = v11;\n    v2 = v12;\n  }\n  v13 = ((int)((unsigned long long)(780903145 * v9) >> 32) >> 1) - (v1 >> 31);\n  v14 = ((int)((unsigned long long)(780903145 * v10) >> 32) >> 1) - (v2 >> 31);\n  if (!((v2 - 11 * v14) | (v1 - 11 * v13))) {\n    v9 = v13;\n    v10 = v14;\n    v1 = v13;\n    v2 = v14;\n  }\n  v15 = ((int)((unsigned long long)(715827883 * v9) >> 32) >> 1) - (v1 >> 31);\n  v16 = ((int)((unsigned long long)(715827883 * v10) >> 32) >> 1) - (v2 >> 31);\n  if (!((v2 - 12 * v16) | (v1 - 12 * v15))) {\n    v1 = v15;\n    v2 = v16;\n  }\n  *(uint64_t *)(r + 3) =\n      _mm_unpacklo_epi32(_mm_cvtsi32_si128(v1), _mm_cvtsi32_si128(v2))\n          .m128i_u64[0];\n}", "binary": "frac-calc/frac-calc.host.O3", "assembly": "<simplifica>:\nendbr64\nmov    0x4(%rdi),%eax\nmov    (%rdi),%edx\npush   %rbx\nmov    %eax,%esi\nmov    %edx,%r8d\nshr    $0x1f,%esi\nshr    $0x1f,%r8d\nlea    (%rax,%rsi,1),%ecx\nand    $0x1,%ecx\nsub    %esi,%ecx\nlea    (%rdx,%r8,1),%esi\nand    $0x1,%esi\nsub    %r8d,%esi\nor     %esi,%ecx\njne    292a <simplifica+0x3a>\nmov    %eax,%ecx\nadd    %r8d,%edx\nshr    $0x1f,%ecx\nsar    %edx\nadd    %ecx,%eax\nsar    %eax\nmovslq %eax,%rsi\nmov    %eax,%ecx\nmov    %eax,%r8d\nmov    %edx,%r9d\nimul   $0x55555556,%rsi,%rsi\nsar    $0x1f,%ecx\nsar    $0x1f,%r9d\nshr    $0x20,%rsi\nsub    %ecx,%esi\nlea    (%rsi,%rsi,2),%ecx\nsub    %ecx,%r8d\nmovslq %edx,%rcx\nimul   $0x55555556,%rcx,%rcx\nshr    $0x20,%rcx\nsub    %r9d,%ecx\nmov    %edx,%r9d\nlea    (%rcx,%rcx,2),%r10d\nsub    %r10d,%r9d\nor     %r9d,%r8d\ncmove  %esi,%eax\ncmove  %ecx,%edx\nmov    %eax,%esi\nmov    %edx,%r8d\nsar    $0x1f,%esi\nsar    $0x1f,%r8d\nshr    $0x1e,%esi\nshr    $0x1e,%r8d\nlea    (%rax,%rsi,1),%ecx\nand    $0x3,%ecx\nsub    %esi,%ecx\nlea    (%rdx,%r8,1),%esi\nand    $0x3,%esi\nsub    %r8d,%esi\nor     %esi,%ecx\njne    29b2 <simplifica+0xc2>\ntest   %eax,%eax\nlea    0x3(%rax),%ecx\ncmovs  %ecx,%eax\nlea    0x3(%rdx),%ecx\nsar    $0x2,%eax\ntest   %edx,%edx\ncmovs  %ecx,%edx\nsar    $0x2,%edx\nmovslq %eax,%rsi\nmov    %eax,%ecx\nmov    %eax,%r10d\nmov    %edx,%r11d\nimul   $0x66666667,%rsi,%r9\nsar    $0x1f,%ecx\nsar    $0x1f,%r11d\nsar    $0x21,%r9\nsub    %ecx,%r9d\nlea    (%r9,%r9,4),%ecx\nsub    %ecx,%r10d\nmovslq %edx,%rcx\nimul   $0x66666667,%rcx,%r8\nsar    $0x21,%r8\nsub    %r11d,%r8d\nmov    %edx,%r11d\nlea    (%r8,%r8,4),%ebx\nsub    %ebx,%r11d\nor     %r11d,%r10d\njne    2a05 <simplifica+0x115>\nmovslq %r9d,%rsi\nmovslq %r8d,%rcx\nmov    %rsi,%rax\nmov    %rcx,%rdx\nimul   $0x2aaaaaab,%rsi,%r9\nmov    %eax,%r8d\nmov    %eax,%r11d\nmov    %edx,%r10d\nsar    $0x1f,%r8d\nsar    $0x1f,%r10d\nmov    %edx,%ebx\nshr    $0x20,%r9\nsub    %r8d,%r9d\nlea    (%r9,%r9,2),%r8d\nadd    %r8d,%r8d\nsub    %r8d,%r11d\nimul   $0x2aaaaaab,%rcx,%r8\nshr    $0x20,%r8\nsub    %r10d,%r8d\nlea    (%r8,%r8,2),%r10d\nadd    %r10d,%r10d\nsub    %r10d,%ebx\nor     %ebx,%r11d\njne    2a59 <simplifica+0x169>\nmovslq %r9d,%rsi\nmovslq %r8d,%rcx\nmov    %rsi,%rax\nmov    %rcx,%rdx\nimul   $0xffffffff92492493,%rsi,%rsi\nmov    %eax,%r8d\nmov    %eax,%r10d\nmov    %edx,%r9d\nsar    $0x1f,%r8d\nimul   $0xffffffff92492493,%rcx,%rcx\nshr    $0x20,%rsi\nadd    %eax,%esi\nshr    $0x20,%rcx\nsar    $0x2,%esi\nadd    %edx,%ecx\nsub    %r8d,%esi\nsar    $0x2,%ecx\nlea    0x0(,%rsi,8),%r8d\nsub    %esi,%r8d\nsub    %r8d,%r10d\nmov    %edx,%r8d\nsar    $0x1f,%r8d\nsub    %r8d,%ecx\nlea    0x0(,%rcx,8),%r8d\nsub    %ecx,%r8d\nsub    %r8d,%r9d\nor     %r10d,%r9d\ncmove  %esi,%eax\ncmove  %ecx,%edx\nmov    %eax,%esi\nmov    %edx,%r8d\nsar    $0x1f,%esi\nsar    $0x1f,%r8d\nshr    $0x1d,%esi\nshr    $0x1d,%r8d\nlea    (%rax,%rsi,1),%ecx\nand    $0x7,%ecx\nsub    %esi,%ecx\nlea    (%rdx,%r8,1),%esi\nand    $0x7,%esi\nsub    %r8d,%esi\nor     %esi,%ecx\njne    2af7 <simplifica+0x207>\ntest   %eax,%eax\nlea    0x7(%rax),%ecx\ncmovs  %ecx,%eax\nlea    0x7(%rdx),%ecx\nsar    $0x3,%eax\ntest   %edx,%edx\ncmovs  %ecx,%edx\nsar    $0x3,%edx\nmovslq %eax,%rsi\nmov    %eax,%ecx\nmov    %eax,%r10d\nmov    %edx,%r11d\nimul   $0x38e38e39,%rsi,%r9\nsar    $0x1f,%ecx\nsar    $0x1f,%r11d\nsar    $0x21,%r9\nsub    %ecx,%r9d\nlea    (%r9,%r9,8),%ecx\nsub    %ecx,%r10d\nmovslq %edx,%rcx\nimul   $0x38e38e39,%rcx,%r8\nsar    $0x21,%r8\nsub    %r11d,%r8d\nmov    %edx,%r11d\nlea    (%r8,%r8,8),%ebx\nsub    %ebx,%r11d\nor     %r11d,%r10d\njne    2b4a <simplifica+0x25a>\nmovslq %r9d,%rsi\nmovslq %r8d,%rcx\nmov    %rsi,%rax\nmov    %rcx,%rdx\nimul   $0x66666667,%rsi,%r9\nmov    %eax,%r8d\nmov    %eax,%r11d\nmov    %edx,%r10d\nsar    $0x1f,%r8d\nsar    $0x1f,%r10d\nmov    %edx,%ebx\nsar    $0x22,%r9\nsub    %r8d,%r9d\nlea    (%r9,%r9,4),%r8d\nadd    %r8d,%r8d\nsub    %r8d,%r11d\nimul   $0x66666667,%rcx,%r8\nsar    $0x22,%r8\nsub    %r10d,%r8d\nlea    (%r8,%r8,4),%r10d\nadd    %r10d,%r10d\nsub    %r10d,%ebx\nor     %ebx,%r11d\njne    2b9e <simplifica+0x2ae>\nmovslq %r9d,%rsi\nmovslq %r8d,%rcx\nmov    %rsi,%rax\nmov    %rcx,%rdx\nimul   $0x2e8ba2e9,%rsi,%r9\nmov    %eax,%r8d\nmov    %eax,%r10d\nmov    %edx,%r11d\nsar    $0x1f,%r8d\nsar    $0x1f,%r11d\nsar    $0x21,%r9\nsub    %r8d,%r9d\nlea    (%r9,%r9,4),%r8d\nlea    (%r9,%r8,2),%r8d\nsub    %r8d,%r10d\nimul   $0x2e8ba2e9,%rcx,%r8\nsar    $0x21,%r8\nsub    %r11d,%r8d\nlea    (%r8,%r8,4),%r11d\nlea    (%r8,%r11,2),%ebx\nmov    %edx,%r11d\nsub    %ebx,%r11d\nor     %r11d,%r10d\njne    2bf5 <simplifica+0x305>\nmovslq %r9d,%rsi\nmovslq %r8d,%rcx\nmov    %rsi,%rax\nmov    %rcx,%rdx\nimul   $0x2aaaaaab,%rsi,%rsi\nmov    %eax,%r8d\nmov    %eax,%r9d\nmov    %edx,%r10d\nsar    $0x1f,%r8d\nimul   $0x2aaaaaab,%rcx,%rcx\npop    %rbx\nsar    $0x21,%rsi\nsub    %r8d,%esi\nsar    $0x21,%rcx\nlea    (%rsi,%rsi,2),%r8d\nshl    $0x2,%r8d\nsub    %r8d,%r9d\nmov    %edx,%r8d\nsar    $0x1f,%r8d\nsub    %r8d,%ecx\nlea    (%rcx,%rcx,2),%r8d\nshl    $0x2,%r8d\nsub    %r8d,%r10d\nor     %r10d,%r9d\ncmove  %esi,%eax\ncmove  %ecx,%edx\nmovd   %eax,%xmm0\nmovd   %edx,%xmm1\npunpckldq %xmm1,%xmm0\nmovq   %xmm0,0xc(%rdi)\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "fuzzy-match/fuzzy-match.c", "function_name": "fuzzy_match", "content": "/*\n * Returns score if each character in pattern is found sequentially within str.\n * Returns INT32_MIN otherwise.\n */\nint32_t fuzzy_match(const char *restrict pattern, const char *restrict str)\n{\n\tconst int unmatched_letter_penalty = -1;\n\tconst size_t slen = libmin_strlen(str);\n\tconst size_t plen = libmin_strlen(pattern);\n\tint32_t score = 100;\n\n\tif (*pattern == '\\0') {\n\t\treturn score;\n\t}\n\tif (slen < plen) {\n\t\treturn INT32_MIN;\n\t}\n\n\t/* We can already penalise any unused letters. */\n\tscore += unmatched_letter_penalty * (int32_t)(slen - plen);\n\n\t/* Perform the match. */\n\tscore = fuzzy_match_recurse(pattern, str, score, TRUE);\n\n\treturn score;\n}\n"}, "pseudo": {"path": "fuzzy-match/fuzzy-match.host.O3.pseudo", "function_name": "fuzzy_match", "address": "0x2590", "label": "fuzzy_match", "content": "int32_t __fastcall fuzzy_match(const char *pattern, const char *str)\n{\n  size_t v2; // rbx\n  size_t v3; // rax\n\n  v2 = libmin_strlen(str);\n  v3 = libmin_strlen(pattern);\n  if ( !*pattern )\n    return 100;\n  if ( v2 < v3 )\n    return 0x80000000;\n  return fuzzy_match_recurse(pattern, str, v3 - v2 + 100, 1);\n}\n"}, "pseudo_normalize": "int32_t fuzzy_match(const char *pattern, const char *str) {\n  unsigned int v2;\n  unsigned int v3;\n  v2 = libmin_strlen(str);\n  v3 = libmin_strlen(pattern);\n  if (!*pattern) return 100;\n  if (v2 < v3) return 2147483648;\n  return fuzzy_match_recurse(pattern, str, v3 - v2 + 100, 1);\n}", "binary": "fuzzy-match/fuzzy-match.host.O3", "assembly": "<fuzzy_match>:\nendbr64\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\nmov    %rsi,%rdi\npush   %rbx\ncall   4900 <libmin_strlen>\nmov    %rbp,%rdi\nmov    %rax,%rbx\ncall   4900 <libmin_strlen>\ncmpb   $0x0,0x0(%rbp)\nje     25d8 <fuzzy_match+0x48>\ncmp    %rax,%rbx\njb     25e8 <fuzzy_match+0x58>\nsub    %ebx,%eax\nmov    %r12,%rsi\npop    %rbx\nmov    %rbp,%rdi\nlea    0x64(%rax),%edx\npop    %rbp\nmov    $0x1,%ecx\npop    %r12\njmp    23e0 <fuzzy_match_recurse>\nnopl   (%rax)\nmov    $0x64,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x80000000,%eax\njmp    25dd <fuzzy_match+0x4d>\nnop\n"}
{"source": {"path": "fuzzy-match/fuzzy-match.c", "function_name": "fuzzy_match_recurse", "content": "/*\n * Recursively match the whole of pattern against str.\n * The score parameter is the score of the previously matched character.\n *\n * This reaches a maximum recursion depth of strlen(pattern) + 1. However, the\n * stack usage is small (the maximum I've seen on x86_64 is 144 bytes with\n * gcc -O3), so this shouldn't matter unless pattern contains thousands of\n * characters.\n */\nint32_t fuzzy_match_recurse(\n\t\tconst char *restrict pattern,\n\t\tconst char *restrict str,\n\t\tint32_t score,\n\t\tint first_char)\n{\n\tif (*pattern == '\\0') {\n\t\t/* We've matched the full pattern. */\n\t\treturn score;\n\t}\n\n\tconst char *match = str;\n\tconst char search[2] = { *pattern, '\\0' };\n\n\tint32_t best_score = INT32_MIN;\n\n\t/*\n\t * Find all occurrences of the next pattern character in str, and\n\t * recurse on them.\n\t */\n\twhile ((match = libmin_strcasestr(match, search)) != NULL) {\n\t\tint32_t subscore = fuzzy_match_recurse(\n\t\t\t\tpattern + 1,\n\t\t\t\tmatch + 1,\n\t\t\t\tcompute_score(match - str, first_char, match),\n\t\t\t\tFALSE);\n\t\tbest_score = MAX(best_score, subscore);\n\t\tmatch++;\n\t}\n\n\tif (best_score == INT32_MIN) {\n\t\t/* We couldn't match the rest of the pattern. */\n\t\treturn INT32_MIN;\n\t} else {\n\t\treturn score + best_score;\n\t}\n}\n"}, "pseudo": {"path": "fuzzy-match/fuzzy-match.host.O3.pseudo", "function_name": "fuzzy_match_recurse", "address": "0x23e0", "label": "fuzzy_match_recurse", "content": "int32_t __fastcall fuzzy_match_recurse(const char *pattern, const char *str, int32_t score, int first_char)\n{\n  int32_t v4; // r12d\n  int v5; // ebp\n  const char *v7; // r13\n  char v8; // r15\n  char *v9; // rsi\n  char *v10; // rax\n  char *v11; // r8\n  int v12; // eax\n  char v13; // cl\n  int32_t v14; // edx\n  int v15; // eax\n  int32_t matched; // eax\n  int v17; // r10d\n  int v18; // r9d\n  unsigned __int16 v19; // di\n  char search[2]; // [rsp+16h] [rbp-42h] BYREF\n  unsigned __int64 v24; // [rsp+18h] [rbp-40h]\n\n  v4 = score;\n  v24 = __readfsqword(0x28u);\n  if ( !*pattern )\n    return v4;\n  search[0] = *pattern;\n  v5 = (int)str;\n  search[1] = 0;\n  v4 = 0x80000000;\n  v7 = str;\n  v8 = first_char ^ 1;\n  while ( 1 )\n  {\n    v9 = search;\n    v10 = libmin_strcasestr(v7, search);\n    v11 = v10;\n    if ( !v10 )\n      break;\n    v12 = (_DWORD)v10 - v5;\n    v13 = ((int)v11 - v5 > 0) | v8 & 1;\n    if ( ((_DWORD)v11 - v5) | first_char )\n    {\n      if ( !v13 )\n      {\n        LOBYTE(v9) = (_DWORD)v11 == v5;\n        v14 = ((int)((first_char & (unsigned int)v9) << 31) >> 31) & 0xF;\n        goto LABEL_7;\n      }\n      v17 = 60;\n      v18 = 30;\n      v14 = 0;\n    }\n    else\n    {\n      if ( !v13 )\n      {\n        v14 = 15;\n        goto LABEL_7;\n      }\n      v17 = 75;\n      v18 = 45;\n      v14 = 15;\n    }\n    v19 = pctype[(unsigned __int8)*v11];\n    if ( (v19 & 1) != 0 && (pctype[(unsigned __int8)*(v11 - 1)] & 2) != 0 )\n    {\n      v14 = v18;\n      v18 = v17;\n    }\n    if ( (v19 & 7) != 0 && (pctype[(unsigned __int8)*(v11 - 1)] & 7) == 0 )\n      v14 = v18;\n    if ( (first_char & 1) != 0 && (_DWORD)v11 == v5 )\n    {\n      v14 += 15;\n    }\n    else if ( !first_char )\n    {\n      goto LABEL_10;\n    }\nLABEL_7:\n    v15 = -5 * v12;\n    if ( v15 < -15 )\n      v15 = -15;\n    v14 += v15;\nLABEL_10:\n    v7 = v11 + 1;\n    matched = fuzzy_match_recurse(pattern + 1, v11 + 1, v14, 0);\n    if ( v4 < matched )\n      v4 = matched;\n  }\n  if ( v4 != 0x80000000 )\n    v4 += score;\n  return v4;\n}\n"}, "pseudo_normalize": "int32_t fuzzy_match_recurse(const char *pattern, const char *str, int32_t score,\n                            int first_char) {\n  int32_t v4;\n  int v5;\n  const char *v7;\n  char v8;\n  char *v9;\n  char *v10;\n  char *v11;\n  int v12;\n  char v13;\n  int32_t v14;\n  int v15;\n  int32_t matched;\n  int v17;\n  int v18;\n  unsigned short v19;\n  char search[2];\n  unsigned long long v24;\n  v4 = score;\n  v24 = __readfsqword(40u);\n  if (!*pattern) return v4;\n  search[0] = *pattern;\n  v5 = (int)str;\n  search[1] = 0;\n  v4 = 2147483648;\n  v7 = str;\n  v8 = first_char ^ 1;\n  while (1) {\n    v9 = search;\n    v10 = libmin_strcasestr(v7, search);\n    v11 = v10;\n    if (!v10) break;\n    v12 = (uint32_t)v10 - v5;\n    v13 = ((int)v11 - v5 > 0) | v8 & 1;\n    if (((uint32_t)v11 - v5) | first_char) {\n      if (!v13) {\n        LOBYTE(v9) = (uint32_t)v11 == v5;\n        v14 = ((int)((first_char & (unsigned int)v9) << 31) >> 31) & 15;\n        goto LABEL_7;\n      }\n      v17 = 60;\n      v18 = 30;\n      v14 = 0;\n    } else {\n      if (!v13) {\n        v14 = 15;\n        goto LABEL_7;\n      }\n      v17 = 75;\n      v18 = 45;\n      v14 = 15;\n    }\n    v19 = pctype[(unsigned char)*v11];\n    if ((v19 & 1) != 0 && (pctype[(unsigned char)*(v11 - 1)] & 2) != 0) {\n      v14 = v18;\n      v18 = v17;\n    }\n    if ((v19 & 7) != 0 && (pctype[(unsigned char)*(v11 - 1)] & 7) == 0)\n      v14 = v18;\n    if ((first_char & 1) != 0 && (uint32_t)v11 == v5) {\n      v14 += 15;\n    } else if (!first_char) {\n      goto LABEL_10;\n    }\n  LABEL_7:\n    v15 = -5 * v12;\n    if (v15 < -15) v15 = -15;\n    v14 += v15;\n  LABEL_10:\n    v7 = v11 + 1;\n    matched = fuzzy_match_recurse(pattern + 1, v11 + 1, v14, 0);\n    if (v4 < matched) v4 = matched;\n  }\n  if (v4 != 2147483648) v4 += score;\n  return v4;\n}", "binary": "fuzzy-match/fuzzy-match.host.O3", "assembly": "<fuzzy_match_recurse>:\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %edx,%r12d\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %edx,0x4(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     252e <fuzzy_match_recurse+0x14e>\nmov    %al,0x16(%rsp)\nmov    %ecx,%r15d\nmov    %rsi,%rbp\nmov    %ecx,%ebx\nmovb   $0x0,0x17(%rsp)\nmov    $0x80000000,%r12d\nlea    0x16(%rsp),%r14\nmov    %rsi,%r13\nmov    %rdi,0x8(%rsp)\nxor    $0x1,%r15d\nmov    %r14,%rsi\nmov    %r13,%rdi\ncall   4930 <libmin_strcasestr>\nmov    %rax,%r8\ntest   %rax,%rax\nje     2520 <fuzzy_match_recurse+0x140>\nmov    %r8,%rax\nmov    %r15d,%ecx\nmov    %ebx,%edi\nsub    %rbp,%rax\ncmp    %ebp,%r8d\nsete   %sil\nand    $0x1,%ecx\ntest   %eax,%eax\nsetg   %dl\nor     %edx,%ecx\nor     %eax,%edi\nje     24b8 <fuzzy_match_recurse+0xd8>\nmov    %esi,%edx\nand    %ebx,%edx\ntest   %cl,%cl\njne    256f <fuzzy_match_recurse+0x18f>\nshl    $0x1f,%edx\nsar    $0x1f,%edx\nand    $0xf,%edx\nlea    (%rax,%rax,4),%eax\nmov    $0xfffffff1,%ecx\nneg    %eax\ncmp    %ecx,%eax\ncmovl  %ecx,%eax\nadd    %eax,%edx\nmov    0x8(%rsp),%rax\nlea    0x1(%r8),%r13\nxor    %ecx,%ecx\nmov    %r13,%rsi\nlea    0x1(%rax),%rdi\ncall   23e0 <fuzzy_match_recurse>\ncmp    %eax,%r12d\ncmovl  %eax,%r12d\njmp    2438 <fuzzy_match_recurse+0x58>\nnopl   (%rax)\ntest   %cl,%cl\nje     2565 <fuzzy_match_recurse+0x185>\nmov    $0x4b,%r10d\nmov    $0x2d,%r9d\nmov    $0xf,%edx\nmov    0x6230(%rip),%rcx\nmovzbl (%r8),%edi\nmovzwl (%rcx,%rdi,2),%edi\ntest   $0x1,%dil\nje     24f2 <fuzzy_match_recurse+0x112>\nmovzbl -0x1(%r8),%r11d\ntestb  $0x2,(%rcx,%r11,2)\njne    2550 <fuzzy_match_recurse+0x170>\nand    $0x7,%edi\nje     2504 <fuzzy_match_recurse+0x124>\nmovzbl -0x1(%r8),%edi\ntestb  $0x7,(%rcx,%rdi,2)\ncmove  %r9d,%edx\ntest   $0x1,%bl\nje     250e <fuzzy_match_recurse+0x12e>\ntest   %sil,%sil\njne    255d <fuzzy_match_recurse+0x17d>\ntest   %ebx,%ebx\nje     2495 <fuzzy_match_recurse+0xb5>\njmp    2484 <fuzzy_match_recurse+0xa4>\nnopw   0x0(%rax,%rax,1)\ncmp    $0x80000000,%r12d\nje     252e <fuzzy_match_recurse+0x14e>\nadd    0x4(%rsp),%r12d\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    2558 <fuzzy_match_recurse+0x178>\nadd    $0x28,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %r9d,%edx\nmov    %r10d,%r9d\njmp    24f2 <fuzzy_match_recurse+0x112>\ncall   20b0 <__stack_chk_fail@plt>\nadd    $0xf,%edx\njmp    2484 <fuzzy_match_recurse+0xa4>\nmov    $0xf,%edx\njmp    2484 <fuzzy_match_recurse+0xa4>\nmov    $0x3c,%r10d\nmov    $0x1e,%r9d\nxor    %edx,%edx\njmp    24d1 <fuzzy_match_recurse+0xf1>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "fuzzy-match/fuzzy-match.c", "function_name": "main", "content": "int\nmain(void)\n{\n  {\n\t  const char *pattern = \"core\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  {\n\t  const char *pattern = \"work\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  {\n\t  const char *pattern = \"sam\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  libmin_success();\t\n  return 0;\n}\n"}, "pseudo": {"path": "fuzzy-match/fuzzy-match.host.O3.pseudo", "function_name": "main", "address": "0x2100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  const char *v3; // r15\n  const char **v4; // rbx\n  size_t v5; // r14\n  size_t v6; // rax\n  int32_t matched; // esi\n  const char *v8; // r12\n  const char **v9; // rbx\n  size_t v10; // r15\n  size_t v11; // rax\n  int32_t v12; // esi\n  const char *v13; // r15\n  const char **v14; // rbx\n  size_t v15; // r14\n  size_t v16; // rax\n  int32_t v17; // esi\n\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  v3 = entries[0];\n  if ( entries[0] )\n  {\n    v4 = entries;\n    do\n    {\n      v5 = libmin_strlen(v3);\n      v6 = libmin_strlen(\"core\");\n      if ( v5 >= v6 )\n      {\n        matched = fuzzy_match_recurse(\"core\", v3, v6 - v5 + 100, 1);\n        if ( matched != 0x80000000 )\n          libmin_printf(\"  %3d|%s\\n\", matched, *v4);\n      }\n      v3 = v4[1];\n      ++v4;\n    }\n    while ( v3 );\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  v8 = entries[0];\n  if ( entries[0] )\n  {\n    v9 = entries;\n    do\n    {\n      v10 = libmin_strlen(v8);\n      v11 = libmin_strlen(\"work\");\n      if ( v10 >= v11 )\n      {\n        v12 = fuzzy_match_recurse(\"work\", v8, v11 - v10 + 100, 1);\n        if ( v12 != 0x80000000 )\n          libmin_printf(\"  %3d|%s\\n\", v12, *v9);\n      }\n      v8 = v9[1];\n      ++v9;\n    }\n    while ( v8 );\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  v13 = entries[0];\n  if ( entries[0] )\n  {\n    v14 = entries;\n    do\n    {\n      v15 = libmin_strlen(v13);\n      v16 = libmin_strlen(\"sam\");\n      if ( v15 >= v16 )\n      {\n        v17 = fuzzy_match_recurse(\"sam\", v13, v16 - v15 + 100, 1);\n        if ( v17 != 0x80000000 )\n          libmin_printf(\"  %3d|%s\\n\", v17, *v14);\n      }\n      v13 = v14[1];\n      ++v14;\n    }\n    while ( v13 );\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  const char *v3;\n  const char **v4;\n  unsigned int v5;\n  unsigned int v6;\n  int32_t matched;\n  const char *v8;\n  const char **v9;\n  unsigned int v10;\n  unsigned int v11;\n  int32_t v12;\n  const char *v13;\n  const char **v14;\n  unsigned int v15;\n  unsigned int v16;\n  int32_t v17;\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  v3 = entries[0];\n  if (entries[0]) {\n    v4 = entries;\n    do {\n      v5 = libmin_strlen(v3);\n      v6 = libmin_strlen(\"core\");\n      if (v5 >= v6) {\n        matched = fuzzy_match_recurse(\"core\", v3, v6 - v5 + 100, 1);\n        if (matched != 2147483648) libmin_printf(\"  %3d|%s\\n\", matched, *v4);\n      }\n      v3 = v4[1];\n      ++v4;\n    } while (v3);\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  v8 = entries[0];\n  if (entries[0]) {\n    v9 = entries;\n    do {\n      v10 = libmin_strlen(v8);\n      v11 = libmin_strlen(\"work\");\n      if (v10 >= v11) {\n        v12 = fuzzy_match_recurse(\"work\", v8, v11 - v10 + 100, 1);\n        if (v12 != 2147483648) libmin_printf(\"  %3d|%s\\n\", v12, *v9);\n      }\n      v8 = v9[1];\n      ++v9;\n    } while (v8);\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  v13 = entries[0];\n  if (entries[0]) {\n    v14 = entries;\n    do {\n      v15 = libmin_strlen(v13);\n      v16 = libmin_strlen(\"sam\");\n      if (v15 >= v16) {\n        v17 = fuzzy_match_recurse(\"sam\", v13, v16 - v15 + 100, 1);\n        if (v17 != 2147483648) libmin_printf(\"  %3d|%s\\n\", v17, *v14);\n      }\n      v13 = v14[1];\n      ++v14;\n    } while (v13);\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}", "binary": "fuzzy-match/fuzzy-match.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nlea    0x2efc(%rip),%rdi\nxor    %eax,%eax\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nlea    0x2ee7(%rip),%rbp\npush   %rbx\nmov    %rbp,%rsi\nsub    $0x8,%rsp\ncall   46f0 <libmin_printf>\nmov    0x5eef(%rip),%r15\ntest   %r15,%r15\nje     2199 <main+0x99>\nlea    0x5ee3(%rip),%rbx\nlea    0x2ed8(%rip),%r13\nnopl   0x0(%rax)\nmov    %r15,%rdi\ncall   4900 <libmin_strlen>\nmov    %rbp,%rdi\nmov    %rax,%r14\ncall   4900 <libmin_strlen>\ncmp    %rax,%r14\njb     218c <main+0x8c>\nsub    %r14d,%eax\nmov    %r15,%rsi\nmov    $0x1,%ecx\nmov    %rbp,%rdi\nlea    0x64(%rax),%edx\ncall   23e0 <fuzzy_match_recurse>\nmov    %eax,%esi\ncmp    $0x80000000,%eax\nje     218c <main+0x8c>\nmov    (%rbx),%rdx\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   46f0 <libmin_printf>\nmov    0x8(%rbx),%r15\nadd    $0x8,%rbx\ntest   %r15,%r15\njne    2148 <main+0x48>\nlea    0x2e7a(%rip),%r13\nxor    %eax,%eax\nlea    0x2e7d(%rip),%rbp\nmov    %r13,%rdi\ncall   46f0 <libmin_printf>\nmov    %rbp,%rsi\nlea    0x2e4e(%rip),%rdi\nxor    %eax,%eax\ncall   46f0 <libmin_printf>\nmov    0x5e57(%rip),%r12\ntest   %r12,%r12\nje     2231 <main+0x131>\nlea    0x5e4b(%rip),%rbx\nlea    0x2e40(%rip),%r14\nnopl   0x0(%rax)\nmov    %r12,%rdi\ncall   4900 <libmin_strlen>\nmov    %rbp,%rdi\nmov    %rax,%r15\ncall   4900 <libmin_strlen>\ncmp    %rax,%r15\njb     2224 <main+0x124>\nsub    %r15d,%eax\nmov    %r12,%rsi\nmov    $0x1,%ecx\nmov    %rbp,%rdi\nlea    0x64(%rax),%edx\ncall   23e0 <fuzzy_match_recurse>\nmov    %eax,%esi\ncmp    $0x80000000,%eax\nje     2224 <main+0x124>\nmov    (%rbx),%rdx\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   46f0 <libmin_printf>\nmov    0x8(%rbx),%r12\nadd    $0x8,%rbx\ntest   %r12,%r12\njne    21e0 <main+0xe0>\nmov    %r13,%rdi\nxor    %eax,%eax\nlea    0x2dee(%rip),%rbp\ncall   46f0 <libmin_printf>\nmov    %rbp,%rsi\nlea    0x2dbd(%rip),%rdi\nxor    %eax,%eax\ncall   46f0 <libmin_printf>\nmov    0x5dc6(%rip),%r15\ntest   %r15,%r15\nje     22c1 <main+0x1c1>\nlea    0x5dba(%rip),%rbx\nlea    0x2daf(%rip),%r12\nnopl   (%rax)\nmov    %r15,%rdi\ncall   4900 <libmin_strlen>\nmov    %rbp,%rdi\nmov    %rax,%r14\ncall   4900 <libmin_strlen>\ncmp    %rax,%r14\njb     22b4 <main+0x1b4>\nsub    %r14d,%eax\nmov    %r15,%rsi\nmov    $0x1,%ecx\nmov    %rbp,%rdi\nlea    0x64(%rax),%edx\ncall   23e0 <fuzzy_match_recurse>\nmov    %eax,%esi\ncmp    $0x80000000,%eax\nje     22b4 <main+0x1b4>\nmov    (%rbx),%rdx\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   46f0 <libmin_printf>\nmov    0x8(%rbx),%r15\nadd    $0x8,%rbx\ntest   %r15,%r15\njne    2270 <main+0x170>\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   46f0 <libmin_printf>\ncall   4980 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "fy-shuffle/fy-shuffle.c", "function_name": "fy_shuffle", "content": "void\nfy_shuffle(int *array, int n)\n{\n  int i, j, tmp;\n\n  for (i = n - 1; i > 0; i--)\n  {\n    j = rand_int(i + 1);\n    libmin_assert(i >= 0 && i < n && j >= 0 && j < n);\n    tmp = array[j];\n    array[j] = array[i];\n    array[i] = tmp;\n  }\n}\n"}, "pseudo": {"path": "fy-shuffle/fy-shuffle.host.O3.pseudo", "function_name": "fy_shuffle", "address": "0x1440", "label": "fy_shuffle", "content": "void __fastcall fy_shuffle(int *array, int n)\n{\n  __int64 v2; // rbp\n  int v3; // r12d\n  signed int v4; // eax\n  int *v5; // rax\n  int v6; // edx\n\n  LODWORD(v2) = n - 1;\n  if ( n - 1 > 0 )\n  {\n    v2 = (int)v2;\n    do\n    {\n      v3 = v2 + 1;\n      do\n        v4 = libmin_rand();\n      while ( 0x7FFFFFFF - 0x7FFFFFFF % ((int)v2 + 1) <= v4 );\n      if ( v4 % v3 < 0 || n <= v4 % v3 )\n        libmin_fail(1);\n      v5 = &array[v4 % v3];\n      v6 = *v5;\n      *v5 = array[v2];\n      array[v2--] = v6;\n    }\n    while ( (int)v2 > 0 );\n  }\n}\n"}, "pseudo_normalize": "void fy_shuffle(int *array, int n) {\n  long long v2;\n  int v3;\n  signed int v4;\n  int *v5;\n  int v6;\n  LODWORD(v2) = n - 1;\n  if (n - 1 > 0) {\n    v2 = (int)v2;\n    do {\n      v3 = v2 + 1;\n      do v4 = libmin_rand();\n      while (2147483647 - 2147483647 % ((int)v2 + 1) <= v4);\n      if (v4 % v3 < 0 || n <= v4 % v3) libmin_fail(1);\n      v5 = &array[v4 % v3];\n      v6 = *v5;\n      *v5 = array[v2];\n      array[v2--] = v6;\n    } while ((int)v2 > 0);\n  }\n}", "binary": "fy-shuffle/fy-shuffle.host.O3", "assembly": "<fy_shuffle>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nlea    -0x1(%rsi),%ebp\npush   %rbx\nsub    $0x8,%rsp\ntest   %ebp,%ebp\njle    14b4 <fy_shuffle+0x74>\nmov    %rdi,%r13\nmov    %esi,%r15d\nmovslq %ebp,%rbp\nmov    $0x7fffffff,%r14d\nnopl   0x0(%rax,%rax,1)\nmov    %r14d,%eax\nlea    0x1(%rbp),%r12d\nmov    %r14d,%ebx\ncltd\nidiv   %r12d\nsub    %edx,%ebx\ncall   38a0 <libmin_rand>\ncmp    %eax,%ebx\njle    1480 <fy_shuffle+0x40>\ncltd\nidiv   %r12d\nmovslq %edx,%rbx\ntest   %ebx,%ebx\njs     14c8 <fy_shuffle+0x88>\ncmp    %ebx,%r15d\njle    14c8 <fy_shuffle+0x88>\nlea    0x0(%r13,%rbx,4),%rax\nmov    0x0(%r13,%rbp,4),%ecx\nmov    (%rax),%edx\nmov    %ecx,(%rax)\nmov    %edx,0x0(%r13,%rbp,4)\nsub    $0x1,%rbp\ntest   %ebp,%ebp\njg     1470 <fy_shuffle+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%edi\ncall   1720 <libmin_fail>\njmp    1499 <fy_shuffle+0x59>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "fy-shuffle/fy-shuffle.c", "function_name": "main", "content": "int\nmain(void)\n{\n  /* initialize random seed: */\n  libmin_srand(42);\n\n  for (int k = 0; k < 8; k++)\n  {\n    print(\"A (before): \", a, SZ_A);\n    fy_shuffle(a, SZ_A);\n    print(\"A (after):  \", a, SZ_A);\n\n    print(\"B (before): \", b, SZ_B);\n    fy_shuffle(b, SZ_B);\n    print(\"B (after):  \", b, SZ_B);\n  }\n  \n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "fy-shuffle/fy-shuffle.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // r12\n  int *v4; // rbx\n  int v5; // esi\n  int v6; // ebp\n  int *v7; // r14\n  signed int v8; // eax\n  int v9; // edx\n  int v10; // ecx\n  int *v11; // rax\n  int v12; // edx\n  int v13; // esi\n  int *v14; // r12\n  int *v15; // rbx\n  int v16; // esi\n  int v17; // ebp\n  int *v18; // r14\n  signed int v19; // eax\n  int v20; // edx\n  int v21; // ecx\n  int *v22; // rax\n  int v23; // edx\n  int v24; // esi\n  int v25; // [rsp+Ch] [rbp-3Ch]\n\n  libmin_srand(0x2Au);\n  v25 = 8;\n  while ( 1 )\n  {\n    libmin_printf(\"%s\", \"A (before): \");\n    v3 = a;\n    v4 = a;\n    do\n    {\n      v5 = *v4++;\n      libmin_printf(\"%2d \", v5);\n    }\n    while ( &mti != v4 );\n    v6 = 11;\n    libmin_printf(\"\\n\");\n    v7 = &a[10];\n    do\n    {\n      do\n        v8 = libmin_rand();\n      while ( 0x7FFFFFFF - 0x7FFFFFFF % v6 <= v8 );\n      v9 = v8 % v6;\n      if ( v8 % v6 < 0 )\n        libmin_fail(1);\n      v10 = *v7--;\n      --v6;\n      v11 = &a[v9];\n      v12 = *v11;\n      *v11 = v10;\n      v7[1] = v12;\n    }\n    while ( v7 != a );\n    libmin_printf(\"%s\", \"A (after):  \");\n    do\n    {\n      v13 = *v3++;\n      libmin_printf(\"%2d \", v13);\n    }\n    while ( v3 != &mti );\n    v14 = b;\n    libmin_printf(\"\\n\");\n    v15 = b;\n    libmin_printf(\"%s\", \"B (before): \");\n    do\n    {\n      v16 = *v15++;\n      libmin_printf(\"%2d \", v16);\n    }\n    while ( v15 != (int *)&unk_606C );\n    v17 = 19;\n    libmin_printf(\"\\n\");\n    v18 = &b[18];\n    do\n    {\n      do\n        v19 = libmin_rand();\n      while ( 0x7FFFFFFF - 0x7FFFFFFF % v17 <= v19 );\n      v20 = v19 % v17;\n      if ( v19 % v17 < 0 )\n        libmin_fail(1);\n      v21 = *v18--;\n      --v17;\n      v22 = &b[v20];\n      v23 = *v22;\n      *v22 = v21;\n      v18[1] = v23;\n    }\n    while ( b != v18 );\n    libmin_printf(\"%s\", \"B (after):  \");\n    do\n    {\n      v24 = *v14++;\n      libmin_printf(\"%2d \", v24);\n    }\n    while ( v14 != (int *)&unk_606C );\n    libmin_printf(\"\\n\");\n    if ( !--v25 )\n      libmin_success();\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  int *v4;\n  int v5;\n  int v6;\n  int *v7;\n  signed int v8;\n  int v9;\n  int v10;\n  int *v11;\n  int v12;\n  int v13;\n  int *v14;\n  int *v15;\n  int v16;\n  int v17;\n  int *v18;\n  signed int v19;\n  int v20;\n  int v21;\n  int *v22;\n  int v23;\n  int v24;\n  int v25;\n  libmin_srand(42u);\n  v25 = 8;\n  while (1) {\n    libmin_printf(\"%s\", \"A (before): \");\n    v3 = a;\n    v4 = a;\n    do {\n      v5 = *v4++;\n      libmin_printf(\"%2d \", v5);\n    } while (&mti != v4);\n    v6 = 11;\n    libmin_printf(\"\\n\");\n    v7 = &a[10];\n    do {\n      do v8 = libmin_rand();\n      while (2147483647 - 2147483647 % v6 <= v8);\n      v9 = v8 % v6;\n      if (v8 % v6 < 0) libmin_fail(1);\n      v10 = *v7--;\n      --v6;\n      v11 = &a[v9];\n      v12 = *v11;\n      *v11 = v10;\n      v7[1] = v12;\n    } while (v7 != a);\n    libmin_printf(\"%s\", \"A (after):  \");\n    do {\n      v13 = *v3++;\n      libmin_printf(\"%2d \", v13);\n    } while (v3 != &mti);\n    v14 = b;\n    libmin_printf(\"\\n\");\n    v15 = b;\n    libmin_printf(\"%s\", \"B (before): \");\n    do {\n      v16 = *v15++;\n      libmin_printf(\"%2d \", v16);\n    } while (v15 != (int *)&unk_606C);\n    v17 = 19;\n    libmin_printf(\"\\n\");\n    v18 = &b[18];\n    do {\n      do v19 = libmin_rand();\n      while (2147483647 - 2147483647 % v17 <= v19);\n      v20 = v19 % v17;\n      if (v19 % v17 < 0) libmin_fail(1);\n      v21 = *v18--;\n      --v17;\n      v22 = &b[v20];\n      v23 = *v22;\n      *v22 = v21;\n      v18[1] = v23;\n    } while (b != v18);\n    libmin_printf(\"%s\", \"B (after):  \");\n    do {\n      v24 = *v14++;\n      libmin_printf(\"%2d \", v24);\n    } while (v14 != (int *)&unk_606C);\n    libmin_printf(\"\\n\");\n    if (!--v25) libmin_success();\n  }\n}", "binary": "fy-shuffle/fy-shuffle.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x2a,%edi\nmov    $0x7fffffff,%r15d\npush   %r14\npush   %r13\nlea    0x2eeb(%rip),%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   3840 <libmin_srand>\nmovl   $0x8,0xc(%rsp)\nnopl   0x0(%rax)\nlea    0x2ecf(%rip),%rsi\nlea    0x2ebe(%rip),%rdi\nxor    %eax,%eax\ncall   3630 <libmin_printf>\nlea    0x4f2c(%rip),%r12\nmov    %r12,%rbx\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   3630 <libmin_printf>\nlea    0x4f35(%rip),%rax\ncmp    %rbx,%rax\njne    1160 <main+0x60>\nlea    0x2e89(%rip),%rdi\nxor    %eax,%eax\nmov    $0xb,%ebp\ncall   3630 <libmin_printf>\nlea    0x4f12(%rip),%r14\ncs nopw 0x0(%rax,%rax,1)\nmov    %r15d,%eax\nmov    %r15d,%ebx\ncltd\nidiv   %ebp\nsub    %edx,%ebx\nnopl   0x0(%rax,%rax,1)\ncall   38a0 <libmin_rand>\ncmp    %eax,%ebx\njle    11b0 <main+0xb0>\ncltd\nidiv   %ebp\nmovslq %edx,%rbx\ntest   %ebx,%ebx\njns    11cd <main+0xcd>\nmov    $0x1,%edi\ncall   1720 <libmin_fail>\nlea    0x4eac(%rip),%rax\nmov    (%r14),%ecx\nsub    $0x4,%r14\nsub    $0x1,%ebp\nlea    (%rax,%rbx,4),%rax\nmov    (%rax),%edx\nmov    %ecx,(%rax)\nmov    %edx,0x4(%r14)\ncmp    %r12,%r14\njne    11a0 <main+0xa0>\nlea    0x2e25(%rip),%rsi\nlea    0x2e07(%rip),%rdi\nxor    %eax,%eax\ncall   3630 <libmin_printf>\nnopl   0x0(%rax)\nmov    (%r12),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%r12\ncall   3630 <libmin_printf>\nlea    0x4e8b(%rip),%rax\ncmp    %rax,%r12\njne    1208 <main+0x108>\nlea    0x2ddf(%rip),%rdi\nxor    %eax,%eax\nlea    0x4dea(%rip),%r12\ncall   3630 <libmin_printf>\nlea    0x2de6(%rip),%rsi\nxor    %eax,%eax\nmov    %r12,%rbx\nlea    0x2db6(%rip),%rdi\ncall   3630 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\nmov    (%rbx),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   3630 <libmin_printf>\nlea    0x4dfd(%rip),%rax\ncmp    %rax,%rbx\njne    1258 <main+0x158>\nlea    0x2d91(%rip),%rdi\nxor    %eax,%eax\nmov    $0x13,%ebp\ncall   3630 <libmin_printf>\nlea    0x4dda(%rip),%r14\nxchg   %ax,%ax\nmov    %r15d,%eax\nmov    %r15d,%ebx\ncltd\nidiv   %ebp\nsub    %edx,%ebx\nnopl   0x0(%rax,%rax,1)\ncall   38a0 <libmin_rand>\ncmp    %eax,%ebx\njle    12a0 <main+0x1a0>\ncltd\nidiv   %ebp\nmovslq %edx,%rbx\ntest   %ebx,%ebx\njns    12bd <main+0x1bd>\nmov    $0x1,%edi\ncall   1720 <libmin_fail>\nlea    0x4d5c(%rip),%rax\nmov    (%r14),%ecx\nsub    $0x4,%r14\nsub    $0x1,%ebp\nlea    (%rax,%rbx,4),%rax\nmov    (%rax),%edx\nmov    %ecx,(%rax)\nmov    %edx,0x4(%r14)\ncmp    %r14,%r12\njne    1290 <main+0x190>\nlea    0x2d4f(%rip),%rsi\nlea    0x2d17(%rip),%rdi\nxor    %eax,%eax\ncall   3630 <libmin_printf>\nnopl   0x0(%rax)\nmov    (%r12),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%r12\ncall   3630 <libmin_printf>\nlea    0x4d5b(%rip),%rax\ncmp    %rax,%r12\njne    12f8 <main+0x1f8>\nxor    %eax,%eax\nlea    0x2ced(%rip),%rdi\ncall   3630 <libmin_printf>\nsubl   $0x1,0xc(%rsp)\njne    1138 <main+0x38>\ncall   3a90 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "fy-shuffle/fy-shuffle.c", "function_name": "print", "content": "void\nprint(const char *prefix, int *array, int n)\n{\n  libmin_printf(\"%s\", prefix);\n  for (int i = 0; i < n; i++)\n    libmin_printf(\"%2d \", array[i]);\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "fy-shuffle/fy-shuffle.host.O3.pseudo", "function_name": "print", "address": "0x14e0", "label": "print", "content": "void __fastcall print(const char *prefix, int *array, int n)\n{\n  int *v4; // rbx\n  int *v5; // r12\n  int v6; // esi\n\n  v4 = array;\n  libmin_printf(\"%s\", prefix);\n  if ( n > 0 )\n  {\n    v5 = &array[n - 1 + 1];\n    do\n    {\n      v6 = *v4++;\n      libmin_printf(\"%2d \", v6);\n    }\n    while ( v4 != v5 );\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void print(const char *prefix, int *array, int n) {\n  int *v4;\n  int *v5;\n  int v6;\n  v4 = array;\n  libmin_printf(\"%s\", prefix);\n  if (n > 0) {\n    v5 = &array[n - 1 + 1];\n    do {\n      v6 = *v4++;\n      libmin_printf(\"%2d \", v6);\n    } while (v4 != v5);\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "fy-shuffle/fy-shuffle.host.O3", "assembly": "<print>:\nendbr64\npush   %r12\nxor    %eax,%eax\npush   %rbp\nmov    %edx,%ebp\npush   %rbx\nmov    %rsi,%rbx\nmov    %rdi,%rsi\nlea    0x2b0b(%rip),%rdi\ncall   3630 <libmin_printf>\ntest   %ebp,%ebp\njle    152d <print+0x4d>\nlea    -0x1(%rbp),%eax\nlea    0x2afb(%rip),%rbp\nlea    0x4(%rbx,%rax,4),%r12\nnopl   0x0(%rax)\nmov    (%rbx),%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   3630 <libmin_printf>\ncmp    %r12,%rbx\njne    1518 <print+0x38>\npop    %rbx\nlea    0x2ad7(%rip),%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\njmp    3630 <libmin_printf>\nnop\n"}
{"source": {"path": "gcd-list/gcd-list.c", "function_name": "gcd", "content": "/**\n * @file\n * @brief This program aims at calculating the GCD of n numbers by division\n * method\n *\n * @see gcd_iterative_euclidean.cpp, gcd_recursive_euclidean.cpp\n */\n#include \"libmin.h\"\n\n/** Compute GCD using division algorithm\n *\n * @param[in] a array of integers to compute GCD for\n * @param[in] n number of integers in array `a`\n */\nuint32_t\ngcd(uint32_t *a, unsigned n)\n{\n  unsigned j = 1;  // to access all elements of the array starting from 1\n  uint32_t gcd = a[0];\n  while (j < n)\n  {\n    if (a[j] % gcd == 0)  // value of gcd is as needed so far\n      j++;              // so we check for next element\n    else\n      gcd = a[j] % gcd;  // calculating GCD by division method\n  }\n  return gcd;\n}\n"}, "pseudo": {"path": "gcd-list/gcd-list.host.O3.pseudo", "function_name": "gcd", "address": "0x1310", "label": "gcd", "content": "uint32_t __fastcall gcd(uint32_t *a, unsigned int n)\n{\n  uint32_t v2; // edx\n  uint32_t *v3; // r8\n  uint32_t *v4; // rdi\n  uint32_t v5; // ecx\n  uint32_t v6; // esi\n\n  v2 = *a;\n  v3 = a + 1;\n  if ( n > 1 )\n  {\n    v4 = &a[n];\n    do\n    {\n      v5 = *v3;\n      do\n      {\n        v6 = v2;\n        v2 = v5 % v2;\n      }\n      while ( v5 % v6 );\n      ++v3;\n      v2 = v6;\n    }\n    while ( v3 != v4 );\n  }\n  return v2;\n}\n"}, "pseudo_normalize": "uint32_t gcd(uint32_t *a, unsigned int n) {\n  uint32_t v2;\n  uint32_t *v3;\n  uint32_t *v4;\n  uint32_t v5;\n  uint32_t v6;\n  v2 = *a;\n  v3 = a + 1;\n  if (n > 1) {\n    v4 = &a[n];\n    do {\n      v5 = *v3;\n      do {\n        v6 = v2;\n        v2 = v5 % v2;\n      } while (v5 % v6);\n      ++v3;\n      v2 = v6;\n    } while (v3 != v4);\n  }\n  return v2;\n}", "binary": "gcd-list/gcd-list.host.O3", "assembly": "<gcd>:\nendbr64\nmov    (%rdi),%edx\nlea    0x4(%rdi),%r8\ncmp    $0x1,%esi\njbe    1347 <gcd+0x37>\nlea    -0x2(%rsi),%eax\nlea    0x8(%rdi,%rax,4),%rdi\nmov    (%r8),%ecx\nnopw   0x0(%rax,%rax,1)\nmov    %edx,%esi\nmov    %ecx,%eax\nxor    %edx,%edx\ndiv    %esi\ntest   %edx,%edx\njne    1330 <gcd+0x20>\nadd    $0x4,%r8\nmov    %esi,%edx\ncmp    %rdi,%r8\njne    1327 <gcd+0x17>\nmov    %edx,%eax\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "gcd-list/gcd-list.c", "function_name": "main", "content": "/** Main function */\nint\nmain(void)\n{\n  // initialize RNG\n  libmin_srand(42);\n\n  unsigned n = 64;\n  uint32_t *a = (uint32_t *)libmin_malloc(sizeof(uint32_t)*n);\n  for (unsigned i = 0; i < n; i++)\n    a[i] = (libmin_rand() % 10000000) * 37;\n\n  libmin_printf(\"INFO: a[%d] = { \", n);\n  for (unsigned i = 0; i < n; i++)\n    libmin_printf(\"%d, \", a[i]);\n  libmin_printf(\" }\\n\");\n\n  uint32_t gcd_of_n;\n  gcd_of_n = gcd(a, n);\n  libmin_printf(\"GCD of list: %u\\n\", gcd_of_n);\n\n  libmin_free(a);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "gcd-list/gcd-list.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  _DWORD *v3; // r12\n  int *v4; // rbx\n  int *v5; // rbp\n  int *v6; // r13\n  int v7; // esi\n  unsigned int v8; // edx\n  unsigned int *v9; // rdi\n  unsigned int v10; // ecx\n  unsigned int v11; // esi\n\n  libmin_srand(0x2Au);\n  v3 = libmin_malloc(0x100uLL);\n  v4 = v3;\n  v5 = v3 + 64;\n  v6 = v3;\n  do\n    *v6++ = 37 * (libmin_rand() % 0x989680);\n  while ( v6 != v5 );\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  do\n  {\n    v7 = *v4++;\n    libmin_printf(\"%d, \", v7);\n  }\n  while ( v4 != v5 );\n  libmin_printf(\" }\\n\");\n  v8 = *v3;\n  v9 = v3 + 1;\n  while ( 1 )\n  {\n    v10 = *v9;\n    do\n    {\n      v11 = v8;\n      v8 = v10 % v8;\n    }\n    while ( v10 % v11 );\n    if ( ++v9 == (unsigned int *)v5 )\n    {\n      libmin_printf(\"GCD of list: %u\\n\", v11);\n      libmin_free(v3);\n      libmin_success();\n    }\n    v8 = v11;\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  uint32_t *v3;\n  int *v4;\n  int *v5;\n  int *v6;\n  int v7;\n  unsigned int v8;\n  unsigned int *v9;\n  unsigned int v10;\n  unsigned int v11;\n  libmin_srand(42u);\n  v3 = libmin_malloc(256uLL);\n  v4 = v3;\n  v5 = v3 + 64;\n  v6 = v3;\n  do *v6++ = 37 * (libmin_rand() % 10000000);\n  while (v6 != v5);\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  do {\n    v7 = *v4++;\n    libmin_printf(\"%d, \", v7);\n  } while (v4 != v5);\n  libmin_printf(\" }\\n\");\n  v8 = *v3;\n  v9 = v3 + 1;\n  while (1) {\n    v10 = *v9;\n    do {\n      v11 = v8;\n      v8 = v10 % v8;\n    } while (v10 % v11);\n    if (++v9 == (unsigned int *)v5) {\n      libmin_printf(\"GCD of list: %u\\n\", v11);\n      libmin_free(v3);\n      libmin_success();\n    }\n    v8 = v11;\n  }\n}", "binary": "gcd-list/gcd-list.host.O3", "assembly": "<main>:\nendbr64\npush   %r13\nmov    $0x2a,%edi\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   3a80 <libmin_srand>\nmov    $0x100,%edi\ncall   1530 <libmin_malloc>\nmov    %rax,%r12\nmov    %rax,%rbx\nlea    0x100(%rax),%rbp\nmov    %rax,%r13\nnopw   0x0(%rax,%rax,1)\ncall   3ae0 <libmin_rand>\nadd    $0x4,%r13\nmov    %eax,%edx\nimul   $0x6b5fca6b,%rdx,%rdx\nshr    $0x36,%rdx\nimul   $0x989680,%edx,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,8),%edx\nlea    (%rax,%rdx,4),%eax\nmov    %eax,-0x4(%r13)\ncmp    %rbp,%r13\njne    1158 <main+0x38>\nmov    $0x40,%esi\nlea    0x2e73(%rip),%rdi\nxor    %eax,%eax\ncall   3870 <libmin_printf>\nlea    0x2e76(%rip),%r13\nnop\nmov    (%rbx),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   3870 <libmin_printf>\ncmp    %rbp,%rbx\njne    11a0 <main+0x80>\nlea    0x2e5e(%rip),%rdi\nxor    %eax,%eax\ncall   3870 <libmin_printf>\nmov    (%r12),%edx\nlea    0x4(%r12),%rdi\nmov    (%rdi),%ecx\nxchg   %ax,%ax\nmov    %edx,%esi\nmov    %ecx,%eax\nxor    %edx,%edx\ndiv    %esi\ntest   %edx,%edx\njne    11d0 <main+0xb0>\nadd    $0x4,%rdi\ncmp    %rbp,%rdi\nje     11e9 <main+0xc9>\nmov    %esi,%edx\njmp    11cc <main+0xac>\nlea    0x2e2e(%rip),%rdi\nxor    %eax,%eax\ncall   3870 <libmin_printf>\nmov    %r12,%rdi\ncall   15e0 <libmin_free>\ncall   3cd0 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "grad-descent/grad-descent.c", "function_name": "derivateWRTBias", "content": "double\nderivateWRTBias(double weight, double bias)\n{\n\tdouble sum = 0;\n\t\n\tfor(int i = 0; i<M; i++){\n\t\tsum = (double)(sum + (Y[i] - (weight * X[i] + bias)));\n\t}\n\t\n\treturn ((double)-2.0 * sum)/M;\n}\n"}, "pseudo": {"path": "grad-descent/grad-descent.host.O3.pseudo", "function_name": "derivateWRTBias", "address": "0x12e0", "label": "derivateWRTBias", "content": "double __fastcall derivateWRTBias(__m128d a1, __m128d weight, double bias)\n{\n  __m128d v3; // xmm1\n  __int64 v4; // rax\n  __m128d v5; // xmm4\n  double v6; // xmm0_8\n  __m128d v7; // xmm3\n  __m128d v8; // xmm2\n  __m128d v9; // xmm2\n\n  v3 = _mm_unpacklo_pd(weight, weight);\n  v4 = 0LL;\n  v5 = _mm_unpacklo_pd(a1, a1);\n  v6 = 0.0;\n  do\n  {\n    v7 = *(__m128d *)&X[v4];\n    v8 = *(__m128d *)&Y[v4];\n    v4 += 2LL;\n    v9 = _mm_sub_pd(v8, _mm_add_pd(_mm_mul_pd(v7, v5), v3));\n    v6 = v6 + v9.m128d_f64[0] + _mm_unpackhi_pd(v9, v9).m128d_f64[0];\n  }\n  while ( v4 != 50 );\n  return v6 * -2.0 / 50.0;\n}\n"}, "pseudo_normalize": "double derivateWRTBias(__m128d a1, __m128d weight, double bias) {\n  __m128d v3;\n  long long v4;\n  __m128d v5;\n  double v6;\n  __m128d v7;\n  __m128d v8;\n  __m128d v9;\n  v3 = _mm_unpacklo_pd(weight, weight);\n  v4 = 0LL;\n  v5 = _mm_unpacklo_pd(a1, a1);\n  v6 = 0.0;\n  do {\n    v7 = *(__m128d *)&X[v4];\n    v8 = *(__m128d *)&Y[v4];\n    v4 += 2LL;\n    v9 = _mm_sub_pd(v8, _mm_add_pd(_mm_mul_pd(v7, v5), v3));\n    v6 = v6 + v9.m128d_f64[0] + _mm_unpackhi_pd(v9, v9).m128d_f64[0];\n  } while (v4 != 50);\n  return v6 * -2.0 / 50.0;\n}", "binary": "grad-descent/grad-descent.host.O3", "assembly": "<derivateWRTBias>:\nendbr64\nmovapd %xmm0,%xmm4\nunpcklpd %xmm1,%xmm1\nxor    %eax,%eax\nunpcklpd %xmm4,%xmm4\npxor   %xmm0,%xmm0\nlea    0x4ec3(%rip),%rcx\nlea    0x4d1c(%rip),%rdx\nnopl   0x0(%rax)\nmovapd (%rdx,%rax,1),%xmm3\nmovapd (%rcx,%rax,1),%xmm2\nadd    $0x10,%rax\nmulpd  %xmm4,%xmm3\naddpd  %xmm1,%xmm3\nsubpd  %xmm3,%xmm2\naddsd  %xmm2,%xmm0\nunpckhpd %xmm2,%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x190,%rax\njne    1308 <derivateWRTBias+0x28>\nmulsd  0x2cf2(%rip),%xmm0\ndivsd  0x2cf2(%rip),%xmm0\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "grad-descent/grad-descent.c", "function_name": "derivateWRTWeight", "content": "double\nderivateWRTWeight(double weight, double bias)\n{\n\tdouble sum = 0;\n\t\n\tfor(int i = 0; i<M; i++){\n\t\tsum = (double)(sum + (X[i]*(Y[i] - (weight * X[i] + bias))));\n\t}\n\t\n\treturn ((double)-2.0 * sum)/M;\n}\n"}, "pseudo": {"path": "grad-descent/grad-descent.host.O3.pseudo", "function_name": "derivateWRTWeight", "address": "0x1270", "label": "derivateWRTWeight", "content": "double __fastcall derivateWRTWeight(__m128d a1, __m128d weight, double bias)\n{\n  __m128d v3; // xmm1\n  __int64 v4; // rax\n  __m128d v5; // xmm4\n  double v6; // xmm0_8\n  __m128d v7; // xmm2\n\n  v3 = _mm_unpacklo_pd(weight, weight);\n  v4 = 0LL;\n  v5 = _mm_unpacklo_pd(a1, a1);\n  v6 = 0.0;\n  do\n  {\n    v7 = _mm_mul_pd(\n           _mm_sub_pd(*(__m128d *)&Y[v4], _mm_add_pd(_mm_mul_pd(*(__m128d *)&X[v4], v5), v3)),\n           *(__m128d *)&X[v4]);\n    v4 += 2LL;\n    v6 = v6 + v7.m128d_f64[0] + _mm_unpackhi_pd(v7, v7).m128d_f64[0];\n  }\n  while ( v4 != 50 );\n  return v6 * -2.0 / 50.0;\n}\n"}, "pseudo_normalize": "double derivateWRTWeight(__m128d a1, __m128d weight, double bias) {\n  __m128d v3;\n  long long v4;\n  __m128d v5;\n  double v6;\n  __m128d v7;\n  v3 = _mm_unpacklo_pd(weight, weight);\n  v4 = 0LL;\n  v5 = _mm_unpacklo_pd(a1, a1);\n  v6 = 0.0;\n  do {\n    v7 = _mm_mul_pd(\n        _mm_sub_pd(*(__m128d *)&Y[v4],\n                   _mm_add_pd(_mm_mul_pd(*(__m128d *)&X[v4], v5), v3)),\n        *(__m128d *)&X[v4]);\n    v4 += 2LL;\n    v6 = v6 + v7.m128d_f64[0] + _mm_unpackhi_pd(v7, v7).m128d_f64[0];\n  } while (v4 != 50);\n  return v6 * -2.0 / 50.0;\n}", "binary": "grad-descent/grad-descent.host.O3", "assembly": "<derivateWRTWeight>:\nendbr64\nmovapd %xmm0,%xmm4\nunpcklpd %xmm1,%xmm1\nxor    %eax,%eax\nunpcklpd %xmm4,%xmm4\npxor   %xmm0,%xmm0\nlea    0x4d93(%rip),%rcx\nlea    0x4f2c(%rip),%rdx\nnopl   0x0(%rax)\nmovapd (%rcx,%rax,1),%xmm3\nmovapd (%rdx,%rax,1),%xmm2\nmulpd  %xmm4,%xmm3\naddpd  %xmm1,%xmm3\nsubpd  %xmm3,%xmm2\nmulpd  (%rcx,%rax,1),%xmm2\nadd    $0x10,%rax\naddsd  %xmm2,%xmm0\nunpckhpd %xmm2,%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x190,%rax\njne    1298 <derivateWRTWeight+0x28>\nmulsd  0x2d5d(%rip),%xmm0\ndivsd  0x2d5d(%rip),%xmm0\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "grad-descent/grad-descent.c", "function_name": "gradientDescent", "content": "void\ngradientDescent(double *pweight, double *pbias)\n{\n\tfor (unsigned i = 0; i<200; i++)\n  {\n\t\t*pweight = (double)(*pweight - (L*derivateWRTWeight(*pweight, *pbias)));\n\t\t*pbias =(double)(*pbias - (L*derivateWRTBias(*pweight, *pbias)));\t\t\n\t}\n}\n"}, "pseudo": {"path": "grad-descent/grad-descent.host.O3.pseudo", "function_name": "gradientDescent", "address": "0x1350", "label": "gradientDescent", "content": "void __fastcall gradientDescent(double *pweight, double *pbias)\n{\n  __m128d v2; // xmm6\n  int v4; // esi\n  __m128d v5; // xmm7\n  __m128d v6; // xmm6\n  __int64 v7; // rax\n  double v8; // xmm1_8\n  __m128d v9; // xmm8\n  __m128d v10; // xmm0\n  __int64 v11; // rax\n  double v12; // xmm1_8\n  __m128d v13; // xmm7\n  __m128d v14; // xmm8\n  __m128d v15; // xmm5\n  __m128d v16; // xmm0\n  __m128d v17; // xmm0\n\n  v2 = (__m128d)*(unsigned __int64 *)pbias;\n  v4 = 200;\n  do\n  {\n    v5 = (__m128d)*(unsigned __int64 *)pweight;\n    v6 = _mm_unpacklo_pd(v2, v2);\n    v7 = 0LL;\n    v8 = 0.0;\n    v9 = _mm_unpacklo_pd(v5, v5);\n    do\n    {\n      v10 = _mm_mul_pd(\n              _mm_sub_pd(*(__m128d *)&Y[v7], _mm_add_pd(_mm_mul_pd(*(__m128d *)&X[v7], v9), v6)),\n              *(__m128d *)&X[v7]);\n      v7 += 2LL;\n      v8 = v8 + v10.m128d_f64[0] + _mm_unpackhi_pd(v10, v10).m128d_f64[0];\n    }\n    while ( v7 != 50 );\n    v11 = 0LL;\n    v5.m128d_f64[0] = v5.m128d_f64[0] - v8 * -2.0 / 50.0 * L;\n    v12 = 0.0;\n    *pweight = v5.m128d_f64[0];\n    v2 = (__m128d)*(unsigned __int64 *)pbias;\n    v13 = _mm_unpacklo_pd(v5, v5);\n    v14 = _mm_unpacklo_pd(v2, v2);\n    do\n    {\n      v15 = *(__m128d *)&X[v11];\n      v16 = *(__m128d *)&Y[v11];\n      v11 += 2LL;\n      v17 = _mm_sub_pd(v16, _mm_add_pd(_mm_mul_pd(v15, v13), v14));\n      v12 = v12 + v17.m128d_f64[0] + _mm_unpackhi_pd(v17, v17).m128d_f64[0];\n    }\n    while ( v11 != 50 );\n    v2.m128d_f64[0] = v2.m128d_f64[0] - v12 * -2.0 / 50.0 * L;\n    *pbias = v2.m128d_f64[0];\n    --v4;\n  }\n  while ( v4 );\n}\n"}, "pseudo_normalize": "void gradientDescent(double *pweight, double *pbias) {\n  __m128d v2;\n  int v4;\n  __m128d v5;\n  __m128d v6;\n  long long v7;\n  double v8;\n  __m128d v9;\n  __m128d v10;\n  long long v11;\n  double v12;\n  __m128d v13;\n  __m128d v14;\n  __m128d v15;\n  __m128d v16;\n  __m128d v17;\n  v2 = (__m128d) * (unsigned long long *)pbias;\n  v4 = 200;\n  do {\n    v5 = (__m128d) * (unsigned long long *)pweight;\n    v6 = _mm_unpacklo_pd(v2, v2);\n    v7 = 0LL;\n    v8 = 0.0;\n    v9 = _mm_unpacklo_pd(v5, v5);\n    do {\n      v10 = _mm_mul_pd(\n          _mm_sub_pd(*(__m128d *)&Y[v7],\n                     _mm_add_pd(_mm_mul_pd(*(__m128d *)&X[v7], v9), v6)),\n          *(__m128d *)&X[v7]);\n      v7 += 2LL;\n      v8 = v8 + v10.m128d_f64[0] + _mm_unpackhi_pd(v10, v10).m128d_f64[0];\n    } while (v7 != 50);\n    v11 = 0LL;\n    v5.m128d_f64[0] = v5.m128d_f64[0] - v8 * -2.0 / 50.0 * L;\n    v12 = 0.0;\n    *pweight = v5.m128d_f64[0];\n    v2 = (__m128d) * (unsigned long long *)pbias;\n    v13 = _mm_unpacklo_pd(v5, v5);\n    v14 = _mm_unpacklo_pd(v2, v2);\n    do {\n      v15 = *(__m128d *)&X[v11];\n      v16 = *(__m128d *)&Y[v11];\n      v11 += 2LL;\n      v17 = _mm_sub_pd(v16, _mm_add_pd(_mm_mul_pd(v15, v13), v14));\n      v12 = v12 + v17.m128d_f64[0] + _mm_unpackhi_pd(v17, v17).m128d_f64[0];\n    } while (v11 != 50);\n    v2.m128d_f64[0] = v2.m128d_f64[0] - v12 * -2.0 / 50.0 * L;\n    *pbias = v2.m128d_f64[0];\n    --v4;\n  } while (v4);\n}", "binary": "grad-descent/grad-descent.host.O3", "assembly": "<gradientDescent>:\nendbr64\nmovsd  0x2cd4(%rip),%xmm3\nmovsd  (%rsi),%xmm6\nmov    %rsi,%r8\npxor   %xmm4,%xmm4\nmovsd  0x2cc9(%rip),%xmm2\nmov    $0xc8,%esi\nlea    0x4ca5(%rip),%rcx\nlea    0x4e3e(%rip),%rdx\nnopw   0x0(%rax,%rax,1)\nmovsd  (%rdi),%xmm7\nunpcklpd %xmm6,%xmm6\nxor    %eax,%eax\nmovapd %xmm4,%xmm1\nmovapd %xmm7,%xmm8\nunpcklpd %xmm8,%xmm8\nmovapd (%rcx,%rax,1),%xmm5\nmovapd (%rdx,%rax,1),%xmm0\nmulpd  %xmm8,%xmm5\naddpd  %xmm6,%xmm5\nsubpd  %xmm5,%xmm0\nmulpd  (%rcx,%rax,1),%xmm0\nadd    $0x10,%rax\naddsd  %xmm0,%xmm1\nunpckhpd %xmm0,%xmm0\naddsd  %xmm0,%xmm1\ncmp    $0x190,%rax\njne    13a0 <gradientDescent+0x50>\nmulsd  %xmm3,%xmm1\nxor    %eax,%eax\ndivsd  %xmm2,%xmm1\nmulsd  0x4f6a(%rip),%xmm1\nsubsd  %xmm1,%xmm7\nmovapd %xmm4,%xmm1\nmovsd  %xmm7,(%rdi)\nmovsd  (%r8),%xmm6\nunpcklpd %xmm7,%xmm7\nmovapd %xmm6,%xmm8\nunpcklpd %xmm8,%xmm8\nnopl   (%rax)\nmovapd (%rcx,%rax,1),%xmm5\nmovapd (%rdx,%rax,1),%xmm0\nadd    $0x10,%rax\nmulpd  %xmm7,%xmm5\naddpd  %xmm8,%xmm5\nsubpd  %xmm5,%xmm0\naddsd  %xmm0,%xmm1\nunpckhpd %xmm0,%xmm0\naddsd  %xmm0,%xmm1\ncmp    $0x190,%rax\njne    1408 <gradientDescent+0xb8>\nmulsd  %xmm3,%xmm1\ndivsd  %xmm2,%xmm1\nmulsd  0x4f09(%rip),%xmm1\nsubsd  %xmm1,%xmm6\nmovsd  %xmm6,(%r8)\nsub    $0x1,%esi\njne    1388 <gradientDescent+0x38>\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "grad-descent/grad-descent.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tdouble weight = 0;\n\tdouble bias = 0;\n\n\tgradientDescent(&weight, &bias);\n\tlibmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "grad-descent/grad-descent.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double weight; // [rsp+8h] [rbp-20h] BYREF\n  double bias[3]; // [rsp+10h] [rbp-18h] BYREF\n\n  *(_QWORD *)&bias[1] = __readfsqword(0x28u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double weight;\n  double bias[3];\n  *(uint64_t *)&bias[1] = __readfsqword(40u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}", "binary": "grad-descent/grad-descent.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nlea    0x10(%rsp),%rsi\nlea    0x8(%rsp),%rdi\nmovq   $0x0,0x8(%rsp)\nmovq   $0x0,0x10(%rsp)\ncall   1350 <gradientDescent>\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x8(%rsp),%xmm0\nlea    0x2ebc(%rip),%rdi\nmov    $0x2,%eax\ncall   3530 <libmin_printf>\ncall   3770 <libmin_success>\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1172 <main+0x72>\nxor    %eax,%eax\nadd    $0x28,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "DFS_test", "content": "void DFS_test() {\n   int i, j;\n\n   for(i = 0; i < 5; i++) {   // set adjacency {\n      for(j = 0; j < 5; j++) // matrix to 0\n         adjMatrix[i][j] = 0;\n   }\n\n   addVertex();   // 0\n   addVertex();   // 1\n   addVertex();   // 2\n   addVertex();   // 3\n   addVertex();   // 4\n\n   addEdge_DFS(0, 1);    // S - A\n   addEdge_DFS(0, 2);    // S - B\n   addEdge_DFS(0, 3);    // S - C\n   addEdge_DFS(1, 4);    // A - D\n   addEdge_DFS(2, 4);    // B - D\n   addEdge_DFS(3, 4);    // C - D\n\n   depthFirstSearch();\n\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "DFS_test", "address": "0x2340", "label": "DFS_test", "content": "void __cdecl DFS_test()\n{\n  Vertex *v0; // rax\n  int v1; // ecx\n  Vertex *v2; // rax\n  int v3; // ecx\n  Vertex *v4; // rax\n  int v5; // ecx\n  Vertex *v6; // rax\n  int v7; // ecx\n  Vertex *v8; // rax\n  int v9; // edx\n\n  *(_OWORD *)&adjMatrix[0][0] = 0LL;\n  *(_OWORD *)&adjMatrix[0][4] = 0LL;\n  *(_OWORD *)&adjMatrix[1][3] = 0LL;\n  *(_OWORD *)&adjMatrix[2][2] = 0LL;\n  *(_OWORD *)&adjMatrix[3][1] = 0LL;\n  *(_OWORD *)&adjMatrix[4][0] = 0LL;\n  adjMatrix[4][4] = 0;\n  v0 = (Vertex *)libmin_malloc(4uLL);\n  v0->visited = 0;\n  v1 = vertexCount + 1;\n  lstVertices[vertexCount] = v0;\n  vertexCount = v1;\n  v2 = (Vertex *)libmin_malloc(4uLL);\n  v2->visited = 0;\n  v3 = vertexCount + 1;\n  lstVertices[vertexCount] = v2;\n  vertexCount = v3;\n  v4 = (Vertex *)libmin_malloc(4uLL);\n  v4->visited = 0;\n  v5 = vertexCount + 1;\n  lstVertices[vertexCount] = v4;\n  vertexCount = v5;\n  v6 = (Vertex *)libmin_malloc(4uLL);\n  v6->visited = 0;\n  v7 = vertexCount + 1;\n  lstVertices[vertexCount] = v6;\n  vertexCount = v7;\n  v8 = (Vertex *)libmin_malloc(4uLL);\n  v8->visited = 0;\n  v9 = vertexCount;\n  adjMatrix[1][0] = 1;\n  lstVertices[vertexCount] = v8;\n  vertexCount = v9 + 1;\n  adjMatrix[0][3] = 1;\n  *(_QWORD *)&adjMatrix[0][1] = 0x100000001LL;\n  *(_QWORD *)&adjMatrix[1][4] = 0x100000001LL;\n  *(_QWORD *)&adjMatrix[2][4] = 0x100000001LL;\n  *(_QWORD *)&adjMatrix[4][1] = 0x100000001LL;\n  adjMatrix[3][4] = 1;\n  adjMatrix[4][3] = 1;\n  depthFirstSearch();\n}\n"}, "pseudo_normalize": "void DFS_test() {\n  Vertex *v0;\n  int v1;\n  Vertex *v2;\n  int v3;\n  Vertex *v4;\n  int v5;\n  Vertex *v6;\n  int v7;\n  Vertex *v8;\n  int v9;\n  *(long double *)&adjMatrix[0][0] = 0LL;\n  *(long double *)&adjMatrix[0][4] = 0LL;\n  *(long double *)&adjMatrix[1][3] = 0LL;\n  *(long double *)&adjMatrix[2][2] = 0LL;\n  *(long double *)&adjMatrix[3][1] = 0LL;\n  *(long double *)&adjMatrix[4][0] = 0LL;\n  adjMatrix[4][4] = 0;\n  v0 = (Vertex *)libmin_malloc(4uLL);\n  v0->visited = 0;\n  v1 = vertexCount + 1;\n  lstVertices[vertexCount] = v0;\n  vertexCount = v1;\n  v2 = (Vertex *)libmin_malloc(4uLL);\n  v2->visited = 0;\n  v3 = vertexCount + 1;\n  lstVertices[vertexCount] = v2;\n  vertexCount = v3;\n  v4 = (Vertex *)libmin_malloc(4uLL);\n  v4->visited = 0;\n  v5 = vertexCount + 1;\n  lstVertices[vertexCount] = v4;\n  vertexCount = v5;\n  v6 = (Vertex *)libmin_malloc(4uLL);\n  v6->visited = 0;\n  v7 = vertexCount + 1;\n  lstVertices[vertexCount] = v6;\n  vertexCount = v7;\n  v8 = (Vertex *)libmin_malloc(4uLL);\n  v8->visited = 0;\n  v9 = vertexCount;\n  adjMatrix[1][0] = 1;\n  lstVertices[vertexCount] = v8;\n  vertexCount = v9 + 1;\n  adjMatrix[0][3] = 1;\n  *(uint64_t *)&adjMatrix[0][1] = 4294967297LL;\n  *(uint64_t *)&adjMatrix[1][4] = 4294967297LL;\n  *(uint64_t *)&adjMatrix[2][4] = 4294967297LL;\n  *(uint64_t *)&adjMatrix[4][1] = 4294967297LL;\n  adjMatrix[3][4] = 1;\n  adjMatrix[4][3] = 1;\n  depthFirstSearch();\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<DFS_test>:\nendbr64\npush   %rbx\npxor   %xmm0,%xmm0\nmov    $0x4,%edi\nlea    0x5fcb(%rip),%rbx\nmovaps %xmm0,0x5f44(%rip)\nmovaps %xmm0,0x5f4d(%rip)\nmovaps %xmm0,0x5f56(%rip)\nmovaps %xmm0,0x5f5f(%rip)\nmovaps %xmm0,0x5f68(%rip)\nmovaps %xmm0,0x5f71(%rip)\nmovl   $0x0,0x5f77(%rip)\ncall   2750 <libmin_malloc>\nmov    $0x4,%edi\nmovl   $0x0,(%rax)\nmovslq 0x5ee0(%rip),%rdx\nlea    0x1(%rdx),%ecx\nmov    %rax,(%rbx,%rdx,8)\nmov    %ecx,0x5ed3(%rip)\ncall   2750 <libmin_malloc>\nmov    $0x4,%edi\nmovl   $0x0,(%rax)\nmovslq 0x5ebc(%rip),%rdx\nlea    0x1(%rdx),%ecx\nmov    %rax,(%rbx,%rdx,8)\nmov    %ecx,0x5eaf(%rip)\ncall   2750 <libmin_malloc>\nmov    $0x4,%edi\nmovl   $0x0,(%rax)\nmovslq 0x5e98(%rip),%rdx\nlea    0x1(%rdx),%ecx\nmov    %rax,(%rbx,%rdx,8)\nmov    %ecx,0x5e8b(%rip)\ncall   2750 <libmin_malloc>\nmov    $0x4,%edi\nmovl   $0x0,(%rax)\nmovslq 0x5e74(%rip),%rdx\nlea    0x1(%rdx),%ecx\nmov    %rax,(%rbx,%rdx,8)\nmov    %ecx,0x5e67(%rip)\ncall   2750 <libmin_malloc>\nmovl   $0x0,(%rax)\nmovslq 0x5e55(%rip),%rdx\nmovl   $0x1,0x5e7f(%rip)\nmov    %rax,(%rbx,%rdx,8)\nlea    0x1(%rdx),%ecx\npop    %rbx\nmov    0x2c2c(%rip),%rax\nmov    %ecx,0x5e36(%rip)\nmovl   $0x1,0x5e58(%rip)\nmov    %rax,0x5e49(%rip)\nmov    %rax,0x5e62(%rip)\nmov    %rax,0x5e6f(%rip)\nmov    %rax,0x5e84(%rip)\nxor    %eax,%eax\nmovl   $0x1,0x5e70(%rip)\nmovl   $0x1,0x5e76(%rip)\njmp    2110 <depthFirstSearch>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "addEdge", "content": "void addEdge(struct Graph* graph, int src, int dest) {\n    // Add edge from src to dest\n    struct node* newNode = createNode(dest);\n    newNode->next = graph->adjLists[src];\n    graph->adjLists[src] = newNode;\n\n    // Add edge from dest to src\n    newNode = createNode(src);\n    newNode->next = graph->adjLists[dest];\n    graph->adjLists[dest] = newNode;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "addEdge", "address": "0x1610", "label": "addEdge", "content": "void __fastcall addEdge(Graph *graph, int src, int dest)\n{\n  __int64 v3; // rbx\n  node *v4; // rax\n  node **adjLists; // rdx\n  node **v6; // rdx\n  node *v7; // rax\n  node **v8; // rdx\n  node **v9; // rdx\n\n  v3 = dest;\n  v4 = (node *)libmin_malloc(0x10uLL);\n  adjLists = graph->adjLists;\n  v4->next = 0LL;\n  v6 = &adjLists[src];\n  v4->vertex = v3;\n  v4->next = *v6;\n  *v6 = v4;\n  v7 = (node *)libmin_malloc(0x10uLL);\n  v8 = graph->adjLists;\n  v7->next = 0LL;\n  v9 = &v8[v3];\n  v7->vertex = src;\n  v7->next = *v9;\n  *v9 = v7;\n}\n"}, "pseudo_normalize": "void addEdge(Graph *graph, int src, int dest) {\n  long long v3;\n  node *v4;\n  node **adjLists;\n  node **v6;\n  node *v7;\n  node **v8;\n  node **v9;\n  v3 = dest;\n  v4 = (node *)libmin_malloc(16uLL);\n  adjLists = graph->adjLists;\n  v4->next = 0LL;\n  v6 = &adjLists[src];\n  v4->vertex = v3;\n  v4->next = *v6;\n  *v6 = v4;\n  v7 = (node *)libmin_malloc(16uLL);\n  v8 = graph->adjLists;\n  v7->next = 0LL;\n  v9 = &v8[v3];\n  v7->vertex = src;\n  v7->next = *v9;\n  *v9 = v7;\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<addEdge>:\nendbr64\npush   %r12\nmov    %rdi,%r12\nmov    $0x10,%edi\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmovslq %edx,%rbx\ncall   2750 <libmin_malloc>\nmov    0x8(%r12),%rdx\nmovslq %ebp,%rcx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nlea    (%rdx,%rcx,8),%rdx\nmov    %ebx,(%rax)\nmov    (%rdx),%rcx\nmov    %rcx,0x8(%rax)\nmov    %rax,(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%r12),%rdx\nmovq   $0x0,0x8(%rax)\nlea    (%rdx,%rbx,8),%rdx\nmov    %ebp,(%rax)\nmov    (%rdx),%rcx\nmov    %rcx,0x8(%rax)\nmov    %rax,(%rdx)\npop    %rbx\npop    %rbp\npop    %r12\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "addEdge_DFS", "content": "void addEdge_DFS(int start,int end) {\n   adjMatrix[start][end] = 1;\n   adjMatrix[end][start] = 1;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "addEdge_DFS", "address": "0x1fc0", "label": "addEdge_DFS", "content": "void __fastcall addEdge_DFS(int start, int end)\n{\n  adjMatrix[start][end] = 1;\n  adjMatrix[end][start] = 1;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<addEdge_DFS>:\nendbr64\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nlea    0x62cf(%rip),%rdx\nlea    (%rdi,%rdi,4),%rax\nadd    %rsi,%rax\nmovl   $0x1,(%rdx,%rax,4)\nlea    (%rsi,%rsi,4),%rax\nadd    %rdi,%rax\nmovl   $0x1,(%rdx,%rax,4)\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "addVertex", "content": "void addVertex() {\n   struct Vertex* vertex = (struct Vertex*)libmin_malloc(sizeof(struct Vertex));\n   vertex->visited = FALSE;\n   lstVertices[vertexCount++] = vertex;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "addVertex", "address": "0x1f80", "label": "addVertex", "content": "void __cdecl addVertex()\n{\n  Vertex *v0; // rax\n  __int64 v1; // rdx\n\n  v0 = (Vertex *)libmin_malloc(4uLL);\n  v0->visited = 0;\n  v1 = vertexCount++;\n  lstVertices[v1] = v0;\n}\n"}, "pseudo_normalize": "void addVertex() {\n  Vertex *v0;\n  long long v1;\n  v0 = (Vertex *)libmin_malloc(4uLL);\n  v0->visited = 0;\n  v1 = vertexCount++;\n  lstVertices[v1] = v0;\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<addVertex>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x4,%edi\ncall   2750 <libmin_malloc>\nmovl   $0x0,(%rax)\nmovslq 0x62e1(%rip),%rdx\nlea    0x1(%rdx),%ecx\nmov    %ecx,0x62d8(%rip)\nlea    0x6371(%rip),%rcx\nmov    %rax,(%rcx,%rdx,8)\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "bfs", "content": "void bfs(struct Graph* graph, int startVertex) {\n    struct queue* q = createQueue();\n\n    graph->visited[startVertex] = 1;\n    enqueue(q, startVertex);\n\n    while(!isEmpty(q)){\n        printQueue(q);\n        int currentVertex = dequeue(q);\n        libmin_printf(\"Visited %d\\n\", currentVertex);\n       struct node* temp = graph->adjLists[currentVertex];\n\n       while(temp) {\n            int adjVertex = temp->vertex;\n            if(graph->visited[adjVertex] == 0){\n                graph->visited[adjVertex] = 1;\n                enqueue(q, adjVertex);\n            }\n            temp = temp->next;\n       }\n    }\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "bfs", "address": "0x1830", "label": "bfs", "content": "void __fastcall bfs(Graph *graph, int startVertex)\n{\n  int *v2; // r14\n  int v3; // eax\n  unsigned int v4; // ecx\n  signed int v5; // eax\n  __int64 i; // rbp\n  int v7; // esi\n  int v8; // ecx\n  int v9; // eax\n  __int64 v10; // rsi\n  __int64 v11; // rbp\n  node *v12; // rbp\n  __int64 vertex; // rsi\n  int *v14; // rax\n  __int64 v15; // rdx\n  int v16; // eax\n  int v17; // eax\n\n  v2 = (int *)libmin_malloc(0xA8uLL);\n  *((_QWORD *)v2 + 20) = -1LL;\n  graph->visited[startVertex] = 1;\n  v3 = v2[41];\n  if ( v3 == 39 )\n  {\n    libmin_printf(\"Queue is Full!!\\n\");\n    v5 = v2[41];\n  }\n  else\n  {\n    v4 = v2[40];\n    if ( v4 == -1 )\n      v4 = 0;\n    v5 = v3 + 1;\n    *((_QWORD *)v2 + 20) = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v4), _mm_cvtsi32_si128(v5)).m128i_u64[0];\n    v2[v5] = startVertex;\n  }\n  if ( v5 != -1 )\n  {\n    while ( 1 )\n    {\n      libmin_printf(\"Queue contains: \");\n      for ( i = v2[40]; v2[41] >= (int)i; ++i )\n      {\n        v7 = v2[i];\n        libmin_printf(\"%d \", v7);\n      }\n      libmin_printf((char *)\"\\n\");\n      v8 = v2[41];\n      if ( v8 == -1 )\n      {\n        v11 = 0x1FFFFFFFFFFFFFFFLL;\n        libmin_printf(\"Queue is empty\\n\");\n        LODWORD(v10) = -1;\n      }\n      else\n      {\n        v9 = v2[40] + 1;\n        v10 = v2[v2[40]];\n        v2[40] = v9;\n        v11 = v10;\n        if ( v8 < v9 )\n        {\n          libmin_printf(\"Resetting queue...\\n\");\n          *((_QWORD *)v2 + 20) = -1LL;\n        }\n      }\n      libmin_printf(\"Visited %d\\n\", v10);\n      v12 = graph->adjLists[v11];\n      if ( v12 )\n        break;\nLABEL_19:\n      if ( v2[41] == -1 )\n        return;\n    }\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        vertex = v12->vertex;\n        v14 = &graph->visited[vertex];\n        v15 = (unsigned int)*v14;\n        if ( !(_DWORD)v15 )\n          break;\nLABEL_13:\n        v12 = v12->next;\n        if ( !v12 )\n          goto LABEL_19;\n      }\n      *v14 = 1;\n      v16 = v2[41];\n      if ( v16 == 39 )\n      {\n        libmin_printf(\"Queue is Full!!\\n\", vertex, v15, vertex);\n        goto LABEL_13;\n      }\n      if ( v2[40] == -1 )\n        v2[40] = 0;\n      v17 = v16 + 1;\n      v12 = v12->next;\n      v2[41] = v17;\n      v2[v17] = vertex;\n      if ( !v12 )\n        goto LABEL_19;\n    }\n  }\n}\n"}, "pseudo_normalize": "void bfs(Graph *graph, int startVertex) {\n  int *v2;\n  int v3;\n  unsigned int v4;\n  signed int v5;\n  long long i;\n  int v7;\n  int v8;\n  int v9;\n  long long v10;\n  long long v11;\n  node *v12;\n  long long vertex;\n  int *v14;\n  long long v15;\n  int v16;\n  int v17;\n  v2 = (int *)libmin_malloc(168uLL);\n  *((uint64_t *)v2 + 20) = -1LL;\n  graph->visited[startVertex] = 1;\n  v3 = v2[41];\n  if (v3 == 39) {\n    libmin_printf(\"Queue is Full!!\\n\");\n    v5 = v2[41];\n  } else {\n    v4 = v2[40];\n    if (v4 == -1) v4 = 0;\n    v5 = v3 + 1;\n    *((uint64_t *)v2 + 20) =\n        _mm_unpacklo_epi32(_mm_cvtsi32_si128(v4), _mm_cvtsi32_si128(v5))\n            .m128i_u64[0];\n    v2[v5] = startVertex;\n  }\n  if (v5 != -1) {\n    while (1) {\n      libmin_printf(\"Queue contains: \");\n      for (i = v2[40]; v2[41] >= (int)i; ++i) {\n        v7 = v2[i];\n        libmin_printf(\"%d \", v7);\n      }\n      libmin_printf((char *)\"\\n\");\n      v8 = v2[41];\n      if (v8 == -1) {\n        v11 = 2305843009213693951LL;\n        libmin_printf(\"Queue is empty\\n\");\n        LODWORD(v10) = -1;\n      } else {\n        v9 = v2[40] + 1;\n        v10 = v2[v2[40]];\n        v2[40] = v9;\n        v11 = v10;\n        if (v8 < v9) {\n          libmin_printf(\"Resetting queue...\\n\");\n          *((uint64_t *)v2 + 20) = -1LL;\n        }\n      }\n      libmin_printf(\"Visited %d\\n\", v10);\n      v12 = graph->adjLists[v11];\n      if (v12) break;\n    LABEL_19:\n      if (v2[41] == -1) return;\n    }\n    while (1) {\n      while (1) {\n        vertex = v12->vertex;\n        v14 = &graph->visited[vertex];\n        v15 = (unsigned int)*v14;\n        if (!(uint32_t)v15) break;\n      LABEL_13:\n        v12 = v12->next;\n        if (!v12) goto LABEL_19;\n      }\n      *v14 = 1;\n      v16 = v2[41];\n      if (v16 == 39) {\n        libmin_printf(\"Queue is Full!!\\n\", vertex, v15, vertex);\n        goto LABEL_13;\n      }\n      if (v2[40] == -1) v2[40] = 0;\n      v17 = v16 + 1;\n      v12 = v12->next;\n      v2[41] = v17;\n      v2[v17] = vertex;\n      if (!v12) goto LABEL_19;\n    }\n  }\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<bfs>:\nendbr64\npush   %r15\nmov    %rdi,%r15\nmov    $0xa8,%edi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %esi,%ebx\nsub    $0x18,%rsp\ncall   2750 <libmin_malloc>\nmovslq %ebx,%rcx\nmov    %rax,%r14\nmov    0x3802(%rip),%rax\nmov    %rax,0xa0(%r14)\nmov    0x10(%r15),%rax\nmovl   $0x1,(%rax,%rcx,4)\nmov    0xa4(%r14),%eax\ncmp    $0x27,%eax\nje     1a50 <bfs+0x220>\nmov    0xa0(%r14),%ecx\nxor    %esi,%esi\ncmp    $0xffffffff,%ecx\ncmove  %esi,%ecx\nadd    $0x1,%eax\nmovd   %eax,%xmm1\nmovd   %ecx,%xmm0\nmovslq %eax,%rcx\npunpckldq %xmm1,%xmm0\nmovq   %xmm0,0xa0(%r14)\nmov    %ebx,(%r14,%rcx,4)\ncmp    $0xffffffff,%eax\nje     19d4 <bfs+0x1a4>\nlea    0x3755(%rip),%r13\nlea    0x3789(%rip),%r12\nlea    0x377e(%rip),%rbx\nlea    0x3766(%rip),%rdi\nxor    %eax,%eax\ncall   4a90 <libmin_printf>\nmovslq 0xa0(%r14),%rbp\ncmp    0xa4(%r14),%ebp\njg     190b <bfs+0xdb>\nnopw   0x0(%rax,%rax,1)\nmov    (%r14,%rbp,4),%esi\nmov    %rbx,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbp\ncall   4a90 <libmin_printf>\ncmp    %ebp,0xa4(%r14)\njge    18f0 <bfs+0xc0>\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   4a90 <libmin_printf>\nmov    0xa4(%r14),%ecx\ncmp    $0xffffffff,%ecx\nje     1a00 <bfs+0x1d0>\nmovslq 0xa0(%r14),%rsi\nmovslq (%r14,%rsi,4),%rbp\nmov    %rsi,%rax\nadd    $0x1,%eax\nmov    %rbp,%rsi\nmov    %eax,0xa0(%r14)\nshl    $0x3,%rbp\ncmp    %eax,%ecx\njl     1a20 <bfs+0x1f0>\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   4a90 <libmin_printf>\nmov    0x8(%r15),%rax\nmov    (%rax,%rbp,1),%rbp\ntest   %rbp,%rbp\njne    1971 <bfs+0x141>\njmp    19c6 <bfs+0x196>\nnopl   (%rax)\nmov    0x8(%rbp),%rbp\ntest   %rbp,%rbp\nje     19c6 <bfs+0x196>\nmovslq 0x0(%rbp),%rsi\nmov    0x10(%r15),%rax\nlea    (%rax,%rsi,4),%rax\nmov    %rsi,%rcx\nmov    (%rax),%edx\ntest   %edx,%edx\njne    1968 <bfs+0x138>\nmovl   $0x1,(%rax)\nmov    0xa4(%r14),%eax\ncmp    $0x27,%eax\nje     19e8 <bfs+0x1b8>\ncmpl   $0xffffffff,0xa0(%r14)\njne    19ad <bfs+0x17d>\nmovl   $0x0,0xa0(%r14)\nadd    $0x1,%eax\nmov    0x8(%rbp),%rbp\nmov    %eax,0xa4(%r14)\ncltq\nmov    %ecx,(%r14,%rax,4)\ntest   %rbp,%rbp\njne    1971 <bfs+0x141>\ncmpl   $0xffffffff,0xa4(%r14)\njne    18cc <bfs+0x9c>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nlea    0x3615(%rip),%rdi\nxor    %eax,%eax\ncall   4a90 <libmin_printf>\njmp    1968 <bfs+0x138>\nnopl   0x0(%rax,%rax,1)\nlea    0x360e(%rip),%rdi\nxor    %eax,%eax\nmov    $0xfffffffffffffff8,%rbp\ncall   4a90 <libmin_printf>\nmov    $0xffffffff,%esi\njmp    194c <bfs+0x11c>\nnop\nlea    0x35fe(%rip),%rdi\nxor    %eax,%eax\nmov    %esi,0xc(%rsp)\ncall   4a90 <libmin_printf>\nmov    0x3627(%rip),%rax\nmov    0xc(%rsp),%esi\nmov    %rax,0xa0(%r14)\njmp    194c <bfs+0x11c>\nnopl   0x0(%rax)\nlea    0x35ad(%rip),%rdi\nxor    %eax,%eax\ncall   4a90 <libmin_printf>\nmov    0xa4(%r14),%eax\njmp    18ae <bfs+0x7e>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "bfs_test", "content": "void bfs_test(){\n    struct Graph* graph = createGraph(6);\n    addEdge(graph, 0, 1);\n    addEdge(graph, 0, 2);\n    addEdge(graph, 1, 2);\n    addEdge(graph, 1, 4);\n    addEdge(graph, 1, 3);\n    addEdge(graph, 2, 4);\n    addEdge(graph, 3, 4);\n\n    bfs(graph, 0);\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "bfs_test", "address": "0x1a70", "label": "bfs_test", "content": "void __cdecl bfs_test()\n{\n  Graph *v0; // rax\n  Graph *v1; // rbp\n  int *v2; // rax\n  node **adjLists; // rdx\n  node *v4; // rax\n  node **v5; // rdx\n  node *v6; // rcx\n  node *v7; // rax\n  node **v8; // rdx\n  node *v9; // rcx\n  node *v10; // rax\n  node **v11; // rdx\n  node *v12; // rcx\n  node *v13; // rax\n  node **v14; // rdx\n  node *v15; // rcx\n  node *v16; // rax\n  node **v17; // rdx\n  node *v18; // rcx\n  node *v19; // rax\n  node **v20; // rdx\n  node *v21; // rcx\n  node *v22; // rax\n  node **v23; // rdx\n  node *v24; // rcx\n  node *v25; // rax\n  node **v26; // rdx\n  node *v27; // rcx\n  node *v28; // rax\n  node **v29; // rdx\n  node *v30; // rcx\n  node *v31; // rax\n  node **v32; // rdx\n  node *v33; // rcx\n  node *v34; // rax\n  node **v35; // rdx\n  node *v36; // rcx\n  node *v37; // rax\n  node **v38; // rdx\n  node *v39; // rcx\n  node *v40; // rax\n  node **v41; // rdx\n  node *v42; // rcx\n  node *v43; // rax\n  node **v44; // rdx\n  node *v45; // rcx\n\n  v0 = (Graph *)libmin_malloc(0x18uLL);\n  v0->numVertices = 6;\n  v1 = v0;\n  v0->adjLists = (node **)libmin_malloc(0x30uLL);\n  v2 = (int *)libmin_malloc(0x18uLL);\n  adjLists = v1->adjLists;\n  v1->visited = v2;\n  if ( adjLists < (node **)v2 + 3 && v2 < (int *)adjLists + 12 )\n  {\n    *adjLists = 0LL;\n    *v2 = 0;\n    adjLists[1] = 0LL;\n    v2[1] = 0;\n    adjLists[2] = 0LL;\n    v2[2] = 0;\n    adjLists[3] = 0LL;\n    v2[3] = 0;\n    adjLists[4] = 0LL;\n    v2[4] = 0;\n    adjLists[5] = 0LL;\n    v2[5] = 0;\n  }\n  else\n  {\n    *(_OWORD *)adjLists = 0LL;\n    *((_OWORD *)adjLists + 1) = 0LL;\n    *((_OWORD *)adjLists + 2) = 0LL;\n    *((_QWORD *)v2 + 2) = 0LL;\n    *(_OWORD *)v2 = 0LL;\n  }\n  v4 = (node *)libmin_malloc(0x10uLL);\n  v5 = v1->adjLists;\n  v4->next = 0LL;\n  v6 = *v5;\n  v4->vertex = 1;\n  v4->next = v6;\n  *v5 = v4;\n  v7 = (node *)libmin_malloc(0x10uLL);\n  v8 = v1->adjLists;\n  v7->next = 0LL;\n  v9 = v8[1];\n  v7->vertex = 0;\n  v7->next = v9;\n  v8[1] = v7;\n  v10 = (node *)libmin_malloc(0x10uLL);\n  v11 = v1->adjLists;\n  v10->next = 0LL;\n  v12 = *v11;\n  v10->vertex = 2;\n  v10->next = v12;\n  *v11 = v10;\n  v13 = (node *)libmin_malloc(0x10uLL);\n  v14 = v1->adjLists;\n  v13->next = 0LL;\n  v15 = v14[2];\n  v13->vertex = 0;\n  v13->next = v15;\n  v14[2] = v13;\n  v16 = (node *)libmin_malloc(0x10uLL);\n  v17 = v1->adjLists;\n  v16->next = 0LL;\n  v18 = v17[1];\n  v16->vertex = 2;\n  v16->next = v18;\n  v17[1] = v16;\n  v19 = (node *)libmin_malloc(0x10uLL);\n  v20 = v1->adjLists;\n  v19->next = 0LL;\n  v21 = v20[2];\n  v19->vertex = 1;\n  v19->next = v21;\n  v20[2] = v19;\n  v22 = (node *)libmin_malloc(0x10uLL);\n  v23 = v1->adjLists;\n  v22->next = 0LL;\n  v24 = v23[1];\n  v22->vertex = 4;\n  v22->next = v24;\n  v23[1] = v22;\n  v25 = (node *)libmin_malloc(0x10uLL);\n  v26 = v1->adjLists;\n  v25->next = 0LL;\n  v27 = v26[4];\n  v25->vertex = 1;\n  v25->next = v27;\n  v26[4] = v25;\n  v28 = (node *)libmin_malloc(0x10uLL);\n  v29 = v1->adjLists;\n  v28->next = 0LL;\n  v30 = v29[1];\n  v28->vertex = 3;\n  v28->next = v30;\n  v29[1] = v28;\n  v31 = (node *)libmin_malloc(0x10uLL);\n  v32 = v1->adjLists;\n  v31->next = 0LL;\n  v33 = v32[3];\n  v31->vertex = 1;\n  v31->next = v33;\n  v32[3] = v31;\n  v34 = (node *)libmin_malloc(0x10uLL);\n  v35 = v1->adjLists;\n  v34->next = 0LL;\n  v36 = v35[2];\n  v34->vertex = 4;\n  v34->next = v36;\n  v35[2] = v34;\n  v37 = (node *)libmin_malloc(0x10uLL);\n  v38 = v1->adjLists;\n  v37->next = 0LL;\n  v39 = v38[4];\n  v37->vertex = 2;\n  v37->next = v39;\n  v38[4] = v37;\n  v40 = (node *)libmin_malloc(0x10uLL);\n  v41 = v1->adjLists;\n  v40->next = 0LL;\n  v42 = v41[3];\n  v40->vertex = 4;\n  v40->next = v42;\n  v41[3] = v40;\n  v43 = (node *)libmin_malloc(0x10uLL);\n  v44 = v1->adjLists;\n  v43->next = 0LL;\n  v45 = v44[4];\n  v43->vertex = 3;\n  v43->next = v45;\n  v44[4] = v43;\n  bfs(v1, 0);\n}\n"}, "pseudo_normalize": "void bfs_test() {\n  Graph *v0;\n  Graph *v1;\n  int *v2;\n  node **adjLists;\n  node *v4;\n  node **v5;\n  node *v6;\n  node *v7;\n  node **v8;\n  node *v9;\n  node *v10;\n  node **v11;\n  node *v12;\n  node *v13;\n  node **v14;\n  node *v15;\n  node *v16;\n  node **v17;\n  node *v18;\n  node *v19;\n  node **v20;\n  node *v21;\n  node *v22;\n  node **v23;\n  node *v24;\n  node *v25;\n  node **v26;\n  node *v27;\n  node *v28;\n  node **v29;\n  node *v30;\n  node *v31;\n  node **v32;\n  node *v33;\n  node *v34;\n  node **v35;\n  node *v36;\n  node *v37;\n  node **v38;\n  node *v39;\n  node *v40;\n  node **v41;\n  node *v42;\n  node *v43;\n  node **v44;\n  node *v45;\n  v0 = (Graph *)libmin_malloc(24uLL);\n  v0->numVertices = 6;\n  v1 = v0;\n  v0->adjLists = (node **)libmin_malloc(48uLL);\n  v2 = (int *)libmin_malloc(24uLL);\n  adjLists = v1->adjLists;\n  v1->visited = v2;\n  if (adjLists < (node **)v2 + 3 && v2 < (int *)adjLists + 12) {\n    *adjLists = 0LL;\n    *v2 = 0;\n    adjLists[1] = 0LL;\n    v2[1] = 0;\n    adjLists[2] = 0LL;\n    v2[2] = 0;\n    adjLists[3] = 0LL;\n    v2[3] = 0;\n    adjLists[4] = 0LL;\n    v2[4] = 0;\n    adjLists[5] = 0LL;\n    v2[5] = 0;\n  } else {\n    *(long double *)adjLists = 0LL;\n    *((long double *)adjLists + 1) = 0LL;\n    *((long double *)adjLists + 2) = 0LL;\n    *((uint64_t *)v2 + 2) = 0LL;\n    *(long double *)v2 = 0LL;\n  }\n  v4 = (node *)libmin_malloc(16uLL);\n  v5 = v1->adjLists;\n  v4->next = 0LL;\n  v6 = *v5;\n  v4->vertex = 1;\n  v4->next = v6;\n  *v5 = v4;\n  v7 = (node *)libmin_malloc(16uLL);\n  v8 = v1->adjLists;\n  v7->next = 0LL;\n  v9 = v8[1];\n  v7->vertex = 0;\n  v7->next = v9;\n  v8[1] = v7;\n  v10 = (node *)libmin_malloc(16uLL);\n  v11 = v1->adjLists;\n  v10->next = 0LL;\n  v12 = *v11;\n  v10->vertex = 2;\n  v10->next = v12;\n  *v11 = v10;\n  v13 = (node *)libmin_malloc(16uLL);\n  v14 = v1->adjLists;\n  v13->next = 0LL;\n  v15 = v14[2];\n  v13->vertex = 0;\n  v13->next = v15;\n  v14[2] = v13;\n  v16 = (node *)libmin_malloc(16uLL);\n  v17 = v1->adjLists;\n  v16->next = 0LL;\n  v18 = v17[1];\n  v16->vertex = 2;\n  v16->next = v18;\n  v17[1] = v16;\n  v19 = (node *)libmin_malloc(16uLL);\n  v20 = v1->adjLists;\n  v19->next = 0LL;\n  v21 = v20[2];\n  v19->vertex = 1;\n  v19->next = v21;\n  v20[2] = v19;\n  v22 = (node *)libmin_malloc(16uLL);\n  v23 = v1->adjLists;\n  v22->next = 0LL;\n  v24 = v23[1];\n  v22->vertex = 4;\n  v22->next = v24;\n  v23[1] = v22;\n  v25 = (node *)libmin_malloc(16uLL);\n  v26 = v1->adjLists;\n  v25->next = 0LL;\n  v27 = v26[4];\n  v25->vertex = 1;\n  v25->next = v27;\n  v26[4] = v25;\n  v28 = (node *)libmin_malloc(16uLL);\n  v29 = v1->adjLists;\n  v28->next = 0LL;\n  v30 = v29[1];\n  v28->vertex = 3;\n  v28->next = v30;\n  v29[1] = v28;\n  v31 = (node *)libmin_malloc(16uLL);\n  v32 = v1->adjLists;\n  v31->next = 0LL;\n  v33 = v32[3];\n  v31->vertex = 1;\n  v31->next = v33;\n  v32[3] = v31;\n  v34 = (node *)libmin_malloc(16uLL);\n  v35 = v1->adjLists;\n  v34->next = 0LL;\n  v36 = v35[2];\n  v34->vertex = 4;\n  v34->next = v36;\n  v35[2] = v34;\n  v37 = (node *)libmin_malloc(16uLL);\n  v38 = v1->adjLists;\n  v37->next = 0LL;\n  v39 = v38[4];\n  v37->vertex = 2;\n  v37->next = v39;\n  v38[4] = v37;\n  v40 = (node *)libmin_malloc(16uLL);\n  v41 = v1->adjLists;\n  v40->next = 0LL;\n  v42 = v41[3];\n  v40->vertex = 4;\n  v40->next = v42;\n  v41[3] = v40;\n  v43 = (node *)libmin_malloc(16uLL);\n  v44 = v1->adjLists;\n  v43->next = 0LL;\n  v45 = v44[4];\n  v43->vertex = 3;\n  v43->next = v45;\n  v44[4] = v43;\n  bfs(v1, 0);\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<bfs_test>:\nendbr64\npush   %rbp\nmov    $0x18,%edi\ncall   2750 <libmin_malloc>\nmov    $0x30,%edi\nmovl   $0x6,(%rax)\nmov    %rax,%rbp\ncall   2750 <libmin_malloc>\nmov    $0x18,%edi\nmov    %rax,0x8(%rbp)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nlea    0x18(%rax),%rcx\nmov    %rax,0x10(%rbp)\ncmp    %rcx,%rdx\njae    1abe <bfs_test+0x4e>\nlea    0x30(%rdx),%rcx\ncmp    %rcx,%rax\njb     1d10 <bfs_test+0x2a0>\npxor   %xmm0,%xmm0\nmovups %xmm0,(%rdx)\nmovups %xmm0,0x10(%rdx)\nmovups %xmm0,0x20(%rdx)\nmovq   $0x0,0x10(%rax)\nmovups %xmm0,(%rax)\nmov    $0x10,%edi\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    (%rdx),%rcx\nmovl   $0x1,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x8(%rdx),%rcx\nmovl   $0x0,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x8(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    (%rdx),%rcx\nmovl   $0x2,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x10(%rdx),%rcx\nmovl   $0x0,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x10(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x8(%rdx),%rcx\nmovl   $0x2,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x8(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x10(%rdx),%rcx\nmovl   $0x1,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x10(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x8(%rdx),%rcx\nmovl   $0x4,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x8(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x20(%rdx),%rcx\nmovl   $0x1,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x20(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x8(%rdx),%rcx\nmovl   $0x3,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x8(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x18(%rdx),%rcx\nmovl   $0x1,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x18(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x10(%rdx),%rcx\nmovl   $0x4,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x10(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x20(%rdx),%rcx\nmovl   $0x2,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x20(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x18(%rdx),%rcx\nmovl   $0x4,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x18(%rdx)\ncall   2750 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    %rbp,%rdi\nxor    %esi,%esi\nmovq   $0x0,0x8(%rax)\nmov    0x20(%rdx),%rcx\nmovl   $0x3,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x20(%rdx)\npop    %rbp\njmp    1830 <bfs>\nnop\nmovq   $0x0,(%rdx)\nmovl   $0x0,(%rax)\nmovq   $0x0,0x8(%rdx)\nmovl   $0x0,0x4(%rax)\nmovq   $0x0,0x10(%rdx)\nmovl   $0x0,0x8(%rax)\nmovq   $0x0,0x18(%rdx)\nmovl   $0x0,0xc(%rax)\nmovq   $0x0,0x20(%rdx)\nmovl   $0x0,0x10(%rax)\nmovq   $0x0,0x28(%rdx)\nmovl   $0x0,0x14(%rax)\njmp    1ad8 <bfs_test+0x68>\nnopl   (%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "bubbleSort", "content": "void bubbleSort(struct Node *start) {\n    int swapped;\n    struct Node *ptr1;\n    struct Node *lptr = NULL;\n\n    if (start == NULL)\n        return;\n\n    do{\n        swapped = 0;\n        ptr1 = start;\n\n        while (ptr1->next != lptr){\n            if (ptr1->data > ptr1->next->data){\n                swap(ptr1, ptr1->next);\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    }\n    while (swapped);\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "bubbleSort", "address": "0x1db0", "label": "bubbleSort", "content": "void __fastcall bubbleSort(Node *start)\n{\n  Node *next; // r11\n  Node *v2; // r9\n  int data; // esi\n  Node *v4; // rax\n  Node *v5; // r8\n  int v6; // r10d\n  Node *v7; // rcx\n\n  if ( !start )\n    return;\n  next = start->next;\n  v2 = 0LL;\n  if ( !next )\n    return;\n  do\n  {\n    data = start->data;\n    v4 = next;\n    v5 = start;\n    v6 = 0;\n    while ( data > v4->data )\n    {\n      v7 = v4->next;\n      v5->data = v4->data;\n      v4->data = data;\n      if ( v2 == v7 )\n        goto LABEL_11;\n      v6 = 1;\nLABEL_6:\n      v5 = v4;\n      v4 = v7;\n    }\n    v7 = v4->next;\n    if ( v7 != v2 )\n    {\n      data = v4->data;\n      goto LABEL_6;\n    }\n    if ( !v6 )\n      return;\nLABEL_11:\n    v2 = v4;\n  }\n  while ( v4 != next );\n}\n"}, "pseudo_normalize": "void bubbleSort(Node *start) {\n  Node *next;\n  Node *v2;\n  int data;\n  Node *v4;\n  Node *v5;\n  int v6;\n  Node *v7;\n  if (!start) return;\n  next = start->next;\n  v2 = 0LL;\n  if (!next) return;\n  do {\n    data = start->data;\n    v4 = next;\n    v5 = start;\n    v6 = 0;\n    while (data > v4->data) {\n      v7 = v4->next;\n      v5->data = v4->data;\n      v4->data = data;\n      if (v2 == v7) goto LABEL_11;\n      v6 = 1;\n    LABEL_6:\n      v5 = v4;\n      v4 = v7;\n    }\n    v7 = v4->next;\n    if (v7 != v2) {\n      data = v4->data;\n      goto LABEL_6;\n    }\n    if (!v6) return;\n  LABEL_11:\n    v2 = v4;\n  } while (v4 != next);\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<bubbleSort>:\nendbr64\ntest   %rdi,%rdi\nje     1e15 <bubbleSort+0x65>\nmov    0x8(%rdi),%r11\nxor    %r9d,%r9d\ncmp    %r11,%r9\nje     1e15 <bubbleSort+0x65>\nnopl   (%rax)\nmov    (%rdi),%esi\nmov    %r11,%rax\nmov    %rdi,%r8\nxor    %r10d,%r10d\njmp    1df2 <bubbleSort+0x42>\nnopl   (%rax)\nmov    0x8(%rax),%rcx\nmov    %edx,(%r8)\nmov    %esi,(%rax)\ncmp    %rcx,%r9\nje     1e0d <bubbleSort+0x5d>\nmov    $0x1,%r10d\nmov    %rax,%r8\nmov    %rcx,%rax\nmov    (%rax),%edx\ncmp    %edx,%esi\njg     1dd8 <bubbleSort+0x28>\nmov    0x8(%rax),%rcx\ncmp    %r9,%rcx\nje     1e08 <bubbleSort+0x58>\nmov    %edx,%esi\njmp    1dec <bubbleSort+0x3c>\nnopl   (%rax)\ntest   %r10d,%r10d\nje     1e15 <bubbleSort+0x65>\nmov    %rax,%r9\ncmp    %r11,%r9\njne    1dc8 <bubbleSort+0x18>\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "createGraph", "content": "struct Graph* createGraph(int vertices) {\n    int i;\n    struct Graph* graph = (struct Graph*)libmin_malloc(sizeof(struct Graph));\n    graph->numVertices = vertices;\n\n    graph->adjLists = (struct node**)libmin_malloc(vertices * sizeof(struct node*));\n    graph->visited = (int*)libmin_malloc(vertices * sizeof(int));\n\n    for (i = 0; i < vertices; i++) {\n        graph->adjLists[i] = NULL;\n        graph->visited[i] = 0;\n    }\n\n    return graph;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "createGraph", "address": "0x1550", "label": "createGraph", "content": "Graph *__fastcall createGraph(int vertices)\n{\n  __int64 v1; // r13\n  size_t v2; // r14\n  size_t v3; // r15\n  Graph *v4; // rax\n  Graph *v5; // r12\n  int *v6; // rax\n  node **adjLists; // rdi\n  int *v8; // rbp\n  __int64 v10; // rax\n\n  v1 = vertices;\n  v2 = vertices;\n  v3 = vertices;\n  v4 = (Graph *)libmin_malloc(0x18uLL);\n  v4->numVertices = vertices;\n  v5 = v4;\n  v4->adjLists = (node **)libmin_malloc(v2 * 8);\n  v6 = (int *)libmin_malloc(v3 * 4);\n  v5->visited = v6;\n  if ( vertices > 0 )\n  {\n    adjLists = v5->adjLists;\n    v8 = v6;\n    if ( v6 < (int *)&adjLists[v2] && adjLists < (node **)&v6[v3] )\n    {\n      v10 = 0LL;\n      do\n      {\n        adjLists[v10] = 0LL;\n        v8[v10++] = 0;\n      }\n      while ( v10 != v1 );\n    }\n    else\n    {\n      memset(adjLists, 0, 8 * v1);\n      memset(v8, 0, 4 * v1);\n    }\n  }\n  return v5;\n}\n"}, "pseudo_normalize": "Graph *createGraph(int vertices) {\n  long long v1;\n  unsigned int v2;\n  unsigned int v3;\n  Graph *v4;\n  Graph *v5;\n  int *v6;\n  node **adjLists;\n  int *v8;\n  long long v10;\n  v1 = vertices;\n  v2 = vertices;\n  v3 = vertices;\n  v4 = (Graph *)libmin_malloc(24uLL);\n  v4->numVertices = vertices;\n  v5 = v4;\n  v4->adjLists = (node **)libmin_malloc(v2 * 8);\n  v6 = (int *)libmin_malloc(v3 * 4);\n  v5->visited = v6;\n  if (vertices > 0) {\n    adjLists = v5->adjLists;\n    v8 = v6;\n    if (v6 < (int *)&adjLists[v2] && adjLists < (node **)&v6[v3]) {\n      v10 = 0LL;\n      do {\n        adjLists[v10] = 0LL;\n        v8[v10++] = 0;\n      } while (v10 != v1);\n    } else {\n      memset(adjLists, 0, 8 * v1);\n      memset(v8, 0, 4 * v1);\n    }\n  }\n  return v5;\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<createGraph>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmovslq %edi,%r13\nmov    $0x18,%edi\npush   %r12\nlea    0x0(,%r13,8),%r14\nlea    0x0(,%r13,4),%r15\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   2750 <libmin_malloc>\nmov    %r14,%rdi\nmov    %r13d,(%rax)\nmov    %rax,%r12\ncall   2750 <libmin_malloc>\nmov    %r15,%rdi\nmov    %rax,0x8(%r12)\ncall   2750 <libmin_malloc>\nmov    %rax,0x10(%r12)\ntest   %r13d,%r13d\njle    15d6 <createGraph+0x86>\nmov    0x8(%r12),%rdi\nmov    %rax,%rbp\nlea    (%rdi,%r14,1),%rax\ncmp    %rax,%rbp\njae    15bf <createGraph+0x6f>\nlea    0x0(%rbp,%r15,1),%rax\ncmp    %rax,%rdi\njb     15e8 <createGraph+0x98>\nmov    %r14,%rdx\nxor    %esi,%esi\ncall   10d0 <memset@plt>\nmov    %r15,%rdx\nxor    %esi,%esi\nmov    %rbp,%rdi\ncall   10d0 <memset@plt>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmovq   $0x0,(%rdi,%rax,8)\nmovl   $0x0,0x0(%rbp,%rax,4)\nadd    $0x1,%rax\ncmp    %r13,%rax\njne    15f0 <createGraph+0xa0>\njmp    15d6 <createGraph+0x86>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "createNode", "content": "struct node* createNode(int v) {\n    struct node* newNode = (struct node*)libmin_malloc(sizeof(struct node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "createNode", "address": "0x1530", "label": "createNode", "content": "node *__fastcall createNode(int v)\n{\n  node *result; // rax\n\n  result = (node *)libmin_malloc(0x10uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "node *createNode(int v) {\n  node *result;\n  result = (node *)libmin_malloc(16uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<createNode>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\ncall   2750 <libmin_malloc>\nmov    %ebx,(%rax)\nmovq   $0x0,0x8(%rax)\npop    %rbx\nret\nnopl   (%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "createQueue", "content": "struct queue* createQueue() {\n    struct queue* q = (struct queue*)libmin_malloc(sizeof(struct queue));\n    q->front = -1;\n    q->rear = -1;\n    return q;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "createQueue", "address": "0x1680", "label": "createQueue", "content": "queue *__cdecl createQueue()\n{\n  queue *result; // rax\n\n  result = (queue *)libmin_malloc(0xA8uLL);\n  *(_QWORD *)&result->front = -1LL;\n  return result;\n}\n"}, "pseudo_normalize": "queue *createQueue() {\n  queue *result;\n  result = (queue *)libmin_malloc(168uLL);\n  *(uint64_t *)&result->front = -1LL;\n  return result;\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<createQueue>:\nendbr64\nsub    $0x8,%rsp\nmov    $0xa8,%edi\ncall   2750 <libmin_malloc>\nmov    0x39c7(%rip),%rdx\nmov    %rdx,0xa0(%rax)\nadd    $0x8,%rsp\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "depthFirstSearch", "content": "void depthFirstSearch() {\n   int i;\n\n   lstVertices[0]->visited = TRUE;\n\n\n   push(0);\n\n   while(!isStackEmpty()) {\n      int unvisitedVertex = getAdjUnvisitedVertex(peek());\n\n      if(unvisitedVertex == -1) {\n         pop();\n      } else {\n         lstVertices[unvisitedVertex]->visited = TRUE;\n         push(unvisitedVertex);\n      }\n   }\n\n   for(i = 0;i < vertexCount;i++) {\n      lstVertices[i]->visited = FALSE;\n   }\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "depthFirstSearch", "address": "0x2110", "label": "depthFirstSearch", "content": "void depthFirstSearch()\n{\n  Vertex *v0; // r9\n  __int64 v1; // rsi\n  int v2; // edx\n  Vertex *v3; // r10\n  Vertex *v4; // r11\n  int visited; // ecx\n  Vertex *v6; // rbx\n  Vertex *v7; // rbp\n  __int64 v8; // rax\n  Vertex *v9; // rax\n\n  v0 = lstVertices[0];\n  lstVertices[0]->visited = 1;\n  v1 = (unsigned int)vertexCount;\n  v2 = ++top;\n  stack[top] = 0;\n  if ( v2 == -1 )\n    goto LABEL_21;\n  v3 = lstVertices[1];\n  v4 = lstVertices[2];\n  visited = 0;\n  v6 = lstVertices[3];\n  v7 = lstVertices[4];\n  while ( (int)v1 > 0 )\n  {\n    while ( 1 )\n    {\n      v8 = visited;\n      if ( adjMatrix[visited][0] == 1 )\n      {\n        visited = v0->visited;\n        if ( !v0->visited )\n        {\n          v9 = v0;\n          goto LABEL_20;\n        }\n      }\n      if ( (_DWORD)v1 != 1 )\n      {\n        visited = adjMatrix[v8][1];\n        if ( visited == 1 && !v3->visited )\n        {\n          v9 = v3;\n          goto LABEL_20;\n        }\n        if ( (_DWORD)v1 != 2 )\n        {\n          if ( adjMatrix[v8][2] == 1 && !v4->visited )\n          {\n            v9 = v4;\n            visited = 2;\n            goto LABEL_20;\n          }\n          if ( (_DWORD)v1 != 3 )\n          {\n            if ( adjMatrix[v8][3] == 1 && !v6->visited )\n            {\n              v9 = v6;\n              visited = 3;\n              goto LABEL_20;\n            }\n            if ( (_DWORD)v1 != 4 && adjMatrix[v8][4] == 1 && !v7->visited )\n              break;\n          }\n        }\n      }\n      top = --v2;\n      if ( v2 == -1 )\n        goto LABEL_21;\n      visited = stack[v2];\n    }\n    v9 = v7;\n    visited = 4;\nLABEL_20:\n    v9->visited = 1;\n    v1 = (unsigned int)vertexCount;\n    v2 = ++top;\n    stack[top] = visited;\n    if ( v2 == -1 )\n      goto LABEL_21;\n  }\n  top = v2 - 1;\n  if ( !v2 )\n  {\nLABEL_21:\n    if ( (int)v1 > 0 )\n    {\n      v0->visited = 0;\n      if ( vertexCount > 1 )\n      {\n        lstVertices[1]->visited = 0;\n        if ( vertexCount > 2 )\n        {\n          lstVertices[2]->visited = 0;\n          if ( vertexCount > 3 )\n          {\n            lstVertices[3]->visited = 0;\n            if ( vertexCount > 4 )\n              lstVertices[4]->visited = 0;\n          }\n        }\n      }\n    }\n  }\n  else\n  {\n    top = v2 - 2;\n    if ( v2 != 1 )\n      depthFirstSearch_cold((__int64)adjMatrix, v1, v2);\n  }\n}\n"}, "pseudo_normalize": "void depthFirstSearch() {\n  Vertex *v0;\n  long long v1;\n  int v2;\n  Vertex *v3;\n  Vertex *v4;\n  int visited;\n  Vertex *v6;\n  Vertex *v7;\n  long long v8;\n  Vertex *v9;\n  v0 = lstVertices[0];\n  lstVertices[0]->visited = 1;\n  v1 = (unsigned int)vertexCount;\n  v2 = ++top;\n  stack[top] = 0;\n  if (v2 == -1) goto LABEL_21;\n  v3 = lstVertices[1];\n  v4 = lstVertices[2];\n  visited = 0;\n  v6 = lstVertices[3];\n  v7 = lstVertices[4];\n  while ((int)v1 > 0) {\n    while (1) {\n      v8 = visited;\n      if (adjMatrix[visited][0] == 1) {\n        visited = v0->visited;\n        if (!v0->visited) {\n          v9 = v0;\n          goto LABEL_20;\n        }\n      }\n      if ((uint32_t)v1 != 1) {\n        visited = adjMatrix[v8][1];\n        if (visited == 1 && !v3->visited) {\n          v9 = v3;\n          goto LABEL_20;\n        }\n        if ((uint32_t)v1 != 2) {\n          if (adjMatrix[v8][2] == 1 && !v4->visited) {\n            v9 = v4;\n            visited = 2;\n            goto LABEL_20;\n          }\n          if ((uint32_t)v1 != 3) {\n            if (adjMatrix[v8][3] == 1 && !v6->visited) {\n              v9 = v6;\n              visited = 3;\n              goto LABEL_20;\n            }\n            if ((uint32_t)v1 != 4 && adjMatrix[v8][4] == 1 && !v7->visited)\n              break;\n          }\n        }\n      }\n      top = --v2;\n      if (v2 == -1) goto LABEL_21;\n      visited = stack[v2];\n    }\n    v9 = v7;\n    visited = 4;\n  LABEL_20:\n    v9->visited = 1;\n    v1 = (unsigned int)vertexCount;\n    v2 = ++top;\n    stack[top] = visited;\n    if (v2 == -1) goto LABEL_21;\n  }\n  top = v2 - 1;\n  if (!v2) {\n  LABEL_21:\n    if ((int)v1 > 0) {\n      v0->visited = 0;\n      if (vertexCount > 1) {\n        lstVertices[1]->visited = 0;\n        if (vertexCount > 2) {\n          lstVertices[2]->visited = 0;\n          if (vertexCount > 3) {\n            lstVertices[3]->visited = 0;\n            if (vertexCount > 4) lstVertices[4]->visited = 0;\n          }\n        }\n      }\n    }\n  } else {\n    top = v2 - 2;\n    if (v2 != 1) depthFirstSearch_cold((long long)adjMatrix, v1, v2);\n  }\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<depthFirstSearch>:\nendbr64\nmov    0x6205(%rip),%r9\npush   %rbp\nlea    0x622d(%rip),%r8\npush   %rbx\nmovl   $0x1,(%r9)\nmov    0x5edf(%rip),%eax\nmov    0x6149(%rip),%esi\nlea    0x1(%rax),%edx\nmovslq %edx,%rax\nmov    %edx,0x5ecd(%rip)\nmovl   $0x0,(%r8,%rax,4)\ncmp    $0xffffffff,%edx\nje     2261 <depthFirstSearch+0x151>\nmov    0x61cd(%rip),%r10\nmov    0x61ce(%rip),%r11\nxor    %ecx,%ecx\nlea    0x6135(%rip),%rdi\nmov    0x61c6(%rip),%rbx\nmov    0x61c7(%rip),%rbp\nnopl   0x0(%rax)\ntest   %esi,%esi\njle    2200 <depthFirstSearch+0xf0>\nmovslq %ecx,%rax\nlea    (%rax,%rax,4),%rcx\ncmpl   $0x1,(%rdi,%rcx,4)\nje     2228 <depthFirstSearch+0x118>\ncmp    $0x1,%esi\nje     21e7 <depthFirstSearch+0xd7>\nlea    (%rax,%rax,4),%rcx\nmov    0x4(%rdi,%rcx,4),%ecx\ncmp    $0x1,%ecx\nje     22d0 <depthFirstSearch+0x1c0>\ncmp    $0x2,%esi\nje     21e7 <depthFirstSearch+0xd7>\nlea    (%rax,%rax,4),%rcx\ncmpl   $0x1,0x8(%rdi,%rcx,4)\nje     22e8 <depthFirstSearch+0x1d8>\ncmp    $0x3,%esi\nje     21e7 <depthFirstSearch+0xd7>\nlea    (%rax,%rax,4),%rcx\ncmpl   $0x1,0xc(%rdi,%rcx,4)\nje     2300 <depthFirstSearch+0x1f0>\ncmp    $0x4,%esi\nje     21e7 <depthFirstSearch+0xd7>\nlea    (%rax,%rax,4),%rax\ncmpl   $0x1,0x10(%rdi,%rax,4)\nje     2320 <depthFirstSearch+0x210>\nsub    $0x1,%edx\nmov    %edx,0x5e20(%rip)\ncmp    $0xffffffff,%edx\nje     2261 <depthFirstSearch+0x151>\nmovslq %edx,%rax\nmov    (%r8,%rax,4),%ecx\ntest   %esi,%esi\njg     2184 <depthFirstSearch+0x74>\nlea    -0x1(%rdx),%eax\nmov    %eax,0x5e07(%rip)\ncmp    $0xffffffff,%eax\nje     2261 <depthFirstSearch+0x151>\nlea    -0x2(%rdx),%eax\nmov    %eax,0x5df9(%rip)\ncmp    $0xffffffff,%eax\njne    1120 <depthFirstSearch.cold>\npop    %rbx\npop    %rbp\nret\nnopl   0x0(%rax,%rax,1)\nmov    (%r9),%ecx\ntest   %ecx,%ecx\njne    2195 <depthFirstSearch+0x85>\nmov    %r9,%rax\nmovl   $0x1,(%rax)\nmov    0x5dce(%rip),%eax\nmov    0x6038(%rip),%esi\nlea    0x1(%rax),%edx\nmovslq %edx,%rax\nmov    %edx,0x5dbc(%rip)\nmov    %ecx,(%r8,%rax,4)\ncmp    $0xffffffff,%edx\njne    2180 <depthFirstSearch+0x70>\ntest   %esi,%esi\njle    2220 <depthFirstSearch+0x110>\nmovl   $0x0,(%r9)\ncmpl   $0x1,0x600d(%rip)\njle    2220 <depthFirstSearch+0x110>\nmov    0x60ac(%rip),%rax\nmovl   $0x0,(%rax)\ncmpl   $0x2,0x5ff7(%rip)\njle    2220 <depthFirstSearch+0x110>\nmov    0x609e(%rip),%rax\nmovl   $0x0,(%rax)\ncmpl   $0x3,0x5fe1(%rip)\njle    2220 <depthFirstSearch+0x110>\nmov    0x608c(%rip),%rax\nmovl   $0x0,(%rax)\ncmpl   $0x4,0x5fc7(%rip)\njle    2220 <depthFirstSearch+0x110>\nmov    0x607a(%rip),%rax\nmovl   $0x0,(%rax)\npop    %rbx\npop    %rbp\nret\nnop\ncmpl   $0x0,(%r10)\njne    21ab <depthFirstSearch+0x9b>\nmov    %r10,%rax\njmp    2236 <depthFirstSearch+0x126>\nnopw   0x0(%rax,%rax,1)\nmov    (%r11),%ecx\ntest   %ecx,%ecx\njne    21bf <depthFirstSearch+0xaf>\nmov    %r11,%rax\nmov    $0x2,%ecx\njmp    2236 <depthFirstSearch+0x126>\nmov    (%rbx),%ecx\ntest   %ecx,%ecx\njne    21d3 <depthFirstSearch+0xc3>\nmov    %rbx,%rax\nmov    $0x3,%ecx\njmp    2236 <depthFirstSearch+0x126>\nnopw   0x0(%rax,%rax,1)\nmov    0x0(%rbp),%eax\ntest   %eax,%eax\njne    21e7 <depthFirstSearch+0xd7>\nmov    %rbp,%rax\nmov    $0x4,%ecx\njmp    2236 <depthFirstSearch+0x126>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "dequeue", "content": "int dequeue(struct queue* q){\n    int item;\n    if(isEmpty(q)){\n        libmin_printf(\"Queue is empty\\n\");\n        item = -1;\n    }\n    else{\n        item = q->items[q->front];\n        q->front++;\n        if(q->front > q->rear){\n            libmin_printf(\"Resetting queue...\\n\");\n            q->front = q->rear = -1;\n        }\n    }\n    return item;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "dequeue", "address": "0x1720", "label": "dequeue", "content": "int __fastcall dequeue(queue *q)\n{\n  int rear; // edx\n  int v2; // r12d\n  int v3; // eax\n\n  rear = q->rear;\n  if ( rear == -1 )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  }\n  else\n  {\n    v2 = q->items[q->front];\n    v3 = q->front + 1;\n    q->front = v3;\n    if ( v3 > rear )\n    {\n      libmin_printf(\"Resetting queue...\\n\");\n      *(_QWORD *)&q->front = -1LL;\n    }\n    return v2;\n  }\n}\n"}, "pseudo_normalize": "int dequeue(queue *q) {\n  int rear;\n  int v2;\n  int v3;\n  rear = q->rear;\n  if (rear == -1) {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  } else {\n    v2 = q->items[q->front];\n    v3 = q->front + 1;\n    q->front = v3;\n    if (v3 > rear) {\n      libmin_printf(\"Resetting queue...\\n\");\n      *(uint64_t *)&q->front = -1LL;\n    }\n    return v2;\n  }\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<dequeue>:\nendbr64\npush   %r12\npush   %rbx\nsub    $0x8,%rsp\nmov    0xa4(%rdi),%edx\ncmp    $0xffffffff,%edx\nje     1790 <dequeue+0x70>\nmovslq 0xa0(%rdi),%rcx\nmov    %rdi,%rbx\nmov    %rcx,%rax\nmov    (%rdi,%rcx,4),%r12d\nadd    $0x1,%eax\nmov    %eax,0xa0(%rdi)\ncmp    %edx,%eax\njg     1760 <dequeue+0x40>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %r12\nret\nnop\nlea    0x38be(%rip),%rdi\nxor    %eax,%eax\ncall   4a90 <libmin_printf>\nmov    0x38eb(%rip),%rax\nmov    %rax,0xa0(%rbx)\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nlea    0x387e(%rip),%rdi\nxor    %eax,%eax\nmov    $0xffffffff,%r12d\ncall   4a90 <libmin_printf>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %r12\nret\nnop\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "enqueue", "content": "void enqueue(struct queue* q, int value){\n    if(q->rear == 40-1){\n        libmin_printf(\"Queue is Full!!\\n\");\n    } else {\n        if(q->front == -1)\n            q->front = 0;\n        q->rear++;\n        q->items[q->rear] = value;\n    }\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "enqueue", "address": "0x16d0", "label": "enqueue", "content": "void __fastcall enqueue(queue *q, int value)\n{\n  int rear; // eax\n  int v3; // eax\n\n  rear = q->rear;\n  if ( rear == 39 )\n  {\n    libmin_printf(\"Queue is Full!!\\n\", value);\n  }\n  else\n  {\n    if ( q->front == -1 )\n      q->front = 0;\n    v3 = rear + 1;\n    q->rear = v3;\n    q->items[v3] = value;\n  }\n}\n"}, "pseudo_normalize": "void enqueue(queue *q, int value) {\n  int rear;\n  int v3;\n  rear = q->rear;\n  if (rear == 39) {\n    libmin_printf(\"Queue is Full!!\\n\", value);\n  } else {\n    if (q->front == -1) q->front = 0;\n    v3 = rear + 1;\n    q->rear = v3;\n    q->items[v3] = value;\n  }\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<enqueue>:\nendbr64\nmov    0xa4(%rdi),%eax\ncmp    $0x27,%eax\nje     1708 <enqueue+0x38>\ncmpl   $0xffffffff,0xa0(%rdi)\njne    16f2 <enqueue+0x22>\nmovl   $0x0,0xa0(%rdi)\nadd    $0x1,%eax\nmov    %eax,0xa4(%rdi)\ncltq\nmov    %esi,(%rdi,%rax,4)\nret\nnopl   0x0(%rax)\nlea    0x38f5(%rip),%rdi\nxor    %eax,%eax\njmp    4a90 <libmin_printf>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "getAdjUnvisitedVertex", "content": "int getAdjUnvisitedVertex(int vertexIndex) {\n   int i;\n\n   for(i = 0; i < vertexCount; i++) {\n      if(adjMatrix[vertexIndex][i] == 1 && lstVertices[i]->visited == FALSE) {\n         return i;\n      }\n   }\n\n   return -1;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "getAdjUnvisitedVertex", "address": "0x1ff0", "label": "getAdjUnvisitedVertex", "content": "int __fastcall getAdjUnvisitedVertex(int vertexIndex)\n{\n  int result; // eax\n\n  if ( vertexCount <= 0 )\n    return -1;\n  if ( adjMatrix[vertexIndex][0] != 1 || (result = lstVertices[0]->visited) != 0 )\n  {\n    if ( vertexCount != 1 )\n    {\n      result = adjMatrix[vertexIndex][1];\n      if ( result == 1 && !lstVertices[1]->visited )\n        return result;\n      if ( vertexCount != 2 )\n      {\n        if ( adjMatrix[vertexIndex][2] == 1 && !lstVertices[2]->visited )\n          return 2;\n        if ( vertexCount != 3 )\n        {\n          if ( adjMatrix[vertexIndex][3] == 1 && !lstVertices[3]->visited )\n            return 3;\n          if ( vertexCount != 4 )\n          {\n            result = -1;\n            if ( adjMatrix[vertexIndex][4] == 1 )\n              return lstVertices[4]->visited == 0 ? 4 : -1;\n            return result;\n          }\n        }\n      }\n    }\n    return -1;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int getAdjUnvisitedVertex(int vertexIndex) {\n  int result;\n  if (vertexCount <= 0) return -1;\n  if (adjMatrix[vertexIndex][0] != 1 ||\n      (result = lstVertices[0]->visited) != 0) {\n    if (vertexCount != 1) {\n      result = adjMatrix[vertexIndex][1];\n      if (result == 1 && !lstVertices[1]->visited) return result;\n      if (vertexCount != 2) {\n        if (adjMatrix[vertexIndex][2] == 1 && !lstVertices[2]->visited)\n          return 2;\n        if (vertexCount != 3) {\n          if (adjMatrix[vertexIndex][3] == 1 && !lstVertices[3]->visited)\n            return 3;\n          if (vertexCount != 4) {\n            result = -1;\n            if (adjMatrix[vertexIndex][4] == 1)\n              return lstVertices[4]->visited == 0 ? 4 : -1;\n            return result;\n          }\n        }\n      }\n    }\n    return -1;\n  }\n  return result;\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<getAdjUnvisitedVertex>:\nendbr64\nmov    0x6286(%rip),%edx\ntest   %edx,%edx\njle    2100 <getAdjUnvisitedVertex+0x110>\nmovslq %edi,%rdi\nlea    0x6294(%rip),%rcx\nlea    (%rdi,%rdi,4),%rax\ncmpl   $0x1,(%rcx,%rax,4)\nje     20b0 <getAdjUnvisitedVertex+0xc0>\ncmp    $0x1,%edx\nje     2100 <getAdjUnvisitedVertex+0x110>\nlea    (%rdi,%rdi,4),%rax\nmov    0x4(%rcx,%rax,4),%eax\ncmp    $0x1,%eax\nje     20c8 <getAdjUnvisitedVertex+0xd8>\ncmp    $0x2,%edx\nje     2100 <getAdjUnvisitedVertex+0x110>\nlea    (%rdi,%rdi,4),%rax\ncmpl   $0x1,0x8(%rcx,%rax,4)\nje     20e0 <getAdjUnvisitedVertex+0xf0>\ncmp    $0x3,%edx\nje     2100 <getAdjUnvisitedVertex+0x110>\nlea    (%rdi,%rdi,4),%rax\ncmpl   $0x1,0xc(%rcx,%rax,4)\nje     2080 <getAdjUnvisitedVertex+0x90>\ncmp    $0x4,%edx\nje     2100 <getAdjUnvisitedVertex+0x110>\nlea    (%rdi,%rdi,4),%rdx\nmov    $0xffffffff,%eax\ncmpl   $0x1,0x10(%rcx,%rdx,4)\nje     2098 <getAdjUnvisitedVertex+0xa8>\nret\nnopw   0x0(%rax,%rax,1)\nmov    0x62b1(%rip),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    2060 <getAdjUnvisitedVertex+0x70>\nmov    $0x3,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmov    0x62a1(%rip),%rax\ncmpl   $0x1,(%rax)\nsbb    %eax,%eax\nand    $0x5,%eax\nsub    $0x1,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmov    0x6269(%rip),%rax\nmov    (%rax),%eax\ntest   %eax,%eax\njne    201a <getAdjUnvisitedVertex+0x2a>\nret\nnopw   0x0(%rax,%rax,1)\nmov    0x6259(%rip),%rsi\nmov    (%rsi),%r8d\ntest   %r8d,%r8d\njne    2034 <getAdjUnvisitedVertex+0x44>\nret\nnopl   0x0(%rax)\nmov    0x6249(%rip),%rax\nmov    (%rax),%esi\ntest   %esi,%esi\njne    204c <getAdjUnvisitedVertex+0x5c>\nmov    $0x2,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0xffffffff,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "insertAtTheBegin", "content": "void insertAtTheBegin(struct Node **start_ref, int data) {\n    struct Node *ptr1 = (struct Node*)libmin_malloc(sizeof(struct Node));\n    ptr1->data = data;\n    ptr1->next = *start_ref;\n    *start_ref = ptr1;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "insertAtTheBegin", "address": "0x1d70", "label": "insertAtTheBegin", "content": "void __fastcall insertAtTheBegin(Node **start_ref, int data)\n{\n  Node *v2; // rax\n  Node *v3; // rdx\n\n  v2 = (Node *)libmin_malloc(0x10uLL);\n  v3 = *start_ref;\n  v2->data = data;\n  v2->next = v3;\n  *start_ref = v2;\n}\n"}, "pseudo_normalize": "void insertAtTheBegin(Node **start_ref, int data) {\n  Node *v2;\n  Node *v3;\n  v2 = (Node *)libmin_malloc(16uLL);\n  v3 = *start_ref;\n  v2->data = data;\n  v2->next = v3;\n  *start_ref = v2;\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<insertAtTheBegin>:\nendbr64\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmov    %rdi,%rbx\nmov    $0x10,%edi\nsub    $0x8,%rsp\ncall   2750 <libmin_malloc>\nmov    (%rbx),%rdx\nmov    %ebp,(%rax)\nmov    %rdx,0x8(%rax)\nmov    %rax,(%rbx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "isEmpty", "content": "int isEmpty(struct queue* q) {\n    if(q->rear == -1)\n        return 1;\n    else\n        return 0;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "isEmpty", "address": "0x16b0", "label": "isEmpty", "content": "int __fastcall isEmpty(queue *q)\n{\n  return q->rear == -1;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<isEmpty>:\nendbr64\nxor    %eax,%eax\ncmpl   $0xffffffff,0xa4(%rdi)\nsete   %al\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "isStackEmpty", "content": "int isStackEmpty() {\n   return top == -1;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "isStackEmpty", "address": "0x1f60", "label": "isStackEmpty", "content": "int __cdecl isStackEmpty()\n{\n  return top == -1;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<isStackEmpty>:\nendbr64\nxor    %eax,%eax\ncmpl   $0xffffffff,0x60a3(%rip)\nsete   %al\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "link_list", "content": "void link_list() {\n    int arr[] = {12, 56, 2, 11, 1, 90};\n    int i;\n\n    struct Node *start = NULL;\n\n    for (i = 0; i< 6; i++)\n        insertAtTheBegin(&start, arr[i]);\n\n    bubbleSort(start);\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "link_list", "address": "0x1e20", "label": "link_list", "content": "void __cdecl link_list()\n{\n  int *v0; // rbp\n  _QWORD *v1; // rax\n  int v2; // r12d\n  _QWORD *v3; // rbx\n  _QWORD *v4; // r9\n  int v5; // edi\n  _QWORD *v6; // rdx\n  _DWORD *v7; // r8\n  int v8; // r10d\n  _QWORD *v9; // rsi\n  int arr[6]; // [rsp+0h] [rbp-48h] BYREF\n  unsigned __int64 v11; // [rsp+18h] [rbp-30h] BYREF\n\n  v11 = __readfsqword(0x28u);\n  v0 = arr;\n  *(__m128i *)arr = _mm_load_si128((const __m128i *)&xmmword_5080);\n  *(_QWORD *)&arr[4] = 0x5A00000001LL;\n  v1 = 0LL;\n  do\n  {\n    v2 = *v0;\n    v3 = v1;\n    ++v0;\n    v1 = libmin_malloc(0x10uLL);\n    *(_DWORD *)v1 = v2;\n    v1[1] = v3;\n  }\n  while ( &v11 != (unsigned __int64 *)v0 );\n  v4 = 0LL;\n  if ( !v3 )\n    return;\n  do\n  {\n    v5 = *(_DWORD *)v1;\n    v6 = v3;\n    v7 = v1;\n    v8 = 0;\n    while ( *(_DWORD *)v6 < v5 )\n    {\n      v9 = (_QWORD *)v6[1];\n      *v7 = *(_DWORD *)v6;\n      *(_DWORD *)v6 = v5;\n      if ( v9 == v4 )\n        goto LABEL_12;\n      v8 = 1;\nLABEL_7:\n      v7 = v6;\n      v6 = v9;\n    }\n    v9 = (_QWORD *)v6[1];\n    if ( v9 != v4 )\n    {\n      v5 = *(_DWORD *)v6;\n      goto LABEL_7;\n    }\n    if ( !v8 )\n      return;\nLABEL_12:\n    v4 = v6;\n  }\n  while ( v6 != v3 );\n}\n"}, "pseudo_normalize": "void link_list() {\n  int *v0;\n  uint64_t *v1;\n  int v2;\n  uint64_t *v3;\n  uint64_t *v4;\n  int v5;\n  uint64_t *v6;\n  uint32_t *v7;\n  int v8;\n  uint64_t *v9;\n  int arr[6];\n  unsigned long long v11;\n  v11 = __readfsqword(40u);\n  v0 = arr;\n  *(__m128i *)arr = _mm_load_si128((const __m128i *)&xmmword_5080);\n  *(uint64_t *)&arr[4] = 386547056641LL;\n  v1 = 0LL;\n  do {\n    v2 = *v0;\n    v3 = v1;\n    ++v0;\n    v1 = libmin_malloc(16uLL);\n    *(uint32_t *)v1 = v2;\n    v1[1] = v3;\n  } while (&v11 != (unsigned long long *)v0);\n  v4 = 0LL;\n  if (!v3) return;\n  do {\n    v5 = *(uint32_t *)v1;\n    v6 = v3;\n    v7 = v1;\n    v8 = 0;\n    while (*(uint32_t *)v6 < v5) {\n      v9 = (uint64_t *)v6[1];\n      *v7 = *(uint32_t *)v6;\n      *(uint32_t *)v6 = v5;\n      if (v9 == v4) goto LABEL_12;\n      v8 = 1;\n    LABEL_7:\n      v7 = v6;\n      v6 = v9;\n    }\n    v9 = (uint64_t *)v6[1];\n    if (v9 != v4) {\n      v5 = *(uint32_t *)v6;\n      goto LABEL_7;\n    }\n    if (!v8) return;\n  LABEL_12:\n    v4 = v6;\n  } while (v6 != v3);\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<link_list>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovdqa 0x324a(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmov    0x321b(%rip),%rax\nmov    %rsp,%rbp\nlea    0x18(%rsp),%r13\nmovaps %xmm0,(%rsp)\nmov    %rax,0x10(%rsp)\nxor    %eax,%eax\nmov    0x0(%rbp),%r12d\nmov    $0x10,%edi\nmov    %rax,%rbx\nadd    $0x4,%rbp\ncall   2750 <libmin_malloc>\nmov    %r12d,(%rax)\nmov    %rbx,0x8(%rax)\ncmp    %rbp,%r13\njne    1e60 <link_list+0x40>\nxor    %r9d,%r9d\ncmp    %rbx,%r9\nje     1edd <link_list+0xbd>\nnopl   0x0(%rax)\nmov    (%rax),%edi\nmov    %rbx,%rdx\nmov    %rax,%r8\nxor    %r10d,%r10d\njmp    1eba <link_list+0x9a>\nnopl   (%rax)\nmov    0x8(%rdx),%rsi\nmov    %ecx,(%r8)\nmov    %edi,(%rdx)\ncmp    %r9,%rsi\nje     1ed5 <link_list+0xb5>\nmov    $0x1,%r10d\nmov    %rdx,%r8\nmov    %rsi,%rdx\nmov    (%rdx),%ecx\ncmp    %edi,%ecx\njl     1ea0 <link_list+0x80>\nmov    0x8(%rdx),%rsi\ncmp    %r9,%rsi\nje     1ed0 <link_list+0xb0>\nmov    %ecx,%edi\njmp    1eb4 <link_list+0x94>\nnopl   (%rax)\ntest   %r10d,%r10d\nje     1edd <link_list+0xbd>\nmov    %rdx,%r9\ncmp    %rbx,%r9\njne    1e90 <link_list+0x70>\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1ef8 <link_list+0xd8>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   10c0 <__stack_chk_fail@plt>\nnopl   (%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "main", "content": "int\nmain(void)\n{\n\n    bfs_test();\n\n    link_list();\n\n    DFS_test();\n\n    towers_test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "main", "address": "0x1180", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_0(5, 65, 67, 66);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_0(5, 65, 67, 66);\n  libmin_success();\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nxor    %eax,%eax\ncall   1a70 <bfs_test>\nxor    %eax,%eax\ncall   1e20 <link_list>\nxor    %eax,%eax\ncall   2340 <DFS_test>\nmov    $0x42,%ecx\nmov    $0x43,%edx\nmov    $0x41,%esi\nmov    $0x5,%edi\ncall   12c0 <towers.part.0>\ncall   4cd0 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "peek", "content": "int peek() {\n   return stack[top];\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "peek", "address": "0x1f40", "label": "peek", "content": "int __cdecl peek()\n{\n  return stack[top];\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<peek>:\nendbr64\nmovslq 0x60c5(%rip),%rdx\nlea    0x63fe(%rip),%rax\nmov    (%rax,%rdx,4),%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "pop", "content": "int pop() {\n   return stack[top--];\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "pop", "address": "0x1f20", "label": "pop", "content": "int __cdecl pop()\n{\n  __int64 v0; // rax\n\n  v0 = top--;\n  return stack[v0];\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<pop>:\nendbr64\nmovslq 0x60e5(%rip),%rax\nlea    -0x1(%rax),%edx\nmov    %edx,0x60dc(%rip)\nlea    0x6415(%rip),%rdx\nmov    (%rdx,%rax,4),%eax\nret\nnop\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "printQueue", "content": "void printQueue(struct queue *q) {\n    int i = q->front;\n    if(isEmpty(q)) {\n        libmin_printf(\"Queue is empty\\n\");\n    } else {\n        libmin_printf(\"Queue contains: \");\n        for(i = q->front; i < q->rear + 1; i++) {\n            libmin_printf(\"%d \", q->items[i]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "printQueue", "address": "0x17b0", "label": "printQueue", "content": "void __fastcall printQueue(queue *q)\n{\n  __int64 i; // rbx\n  int v2; // esi\n\n  if ( q->rear == -1 )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n  }\n  else\n  {\n    libmin_printf(\"Queue contains: \");\n    for ( i = q->front; q->rear >= (int)i; ++i )\n    {\n      v2 = q->items[i];\n      libmin_printf(\"%d \", v2);\n    }\n    libmin_printf((char *)\"\\n\");\n  }\n}\n"}, "pseudo_normalize": "void printQueue(queue *q) {\n  long long i;\n  int v2;\n  if (q->rear == -1) {\n    libmin_printf(\"Queue is empty\\n\");\n  } else {\n    libmin_printf(\"Queue contains: \");\n    for (i = q->front; q->rear >= (int)i; ++i) {\n      v2 = q->items[i];\n      libmin_printf(\"%d \", v2);\n    }\n    libmin_printf((char *)\"\\n\");\n  }\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<printQueue>:\nendbr64\ncmpl   $0xffffffff,0xa4(%rdi)\nje     1820 <printQueue+0x70>\npush   %r12\nxor    %eax,%eax\npush   %rbp\nmov    %rdi,%rbp\nlea    0x386d(%rip),%rdi\npush   %rbx\ncall   4a90 <libmin_printf>\nmovslq 0xa0(%rbp),%rbx\ncmp    0xa4(%rbp),%ebx\njg     180a <printQueue+0x5a>\nlea    0x3862(%rip),%r12\nnopl   0x0(%rax,%rax,1)\nmov    0x0(%rbp,%rbx,4),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   4a90 <libmin_printf>\ncmp    %ebx,0xa4(%rbp)\njge    17f0 <printQueue+0x40>\npop    %rbx\nlea    0x3801(%rip),%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\njmp    4a90 <libmin_printf>\nnopl   0x0(%rax)\nlea    0x37ee(%rip),%rdi\nxor    %eax,%eax\njmp    4a90 <libmin_printf>\nxchg   %ax,%ax\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "push", "content": "void push(int item) {\n   stack[++top] = item;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "push", "address": "0x1f00", "label": "push", "content": "void __fastcall push(int item)\n{\n  stack[++top] = item;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<push>:\nendbr64\nmov    0x6106(%rip),%eax\nlea    0x643f(%rip),%rdx\nadd    $0x1,%eax\nmov    %eax,0x60f6(%rip)\ncltq\nmov    %edi,(%rdx,%rax,4)\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "swap", "content": "void swap(struct Node *a, struct Node *b) {\n    int temp = a->data;\n    a->data = b->data;\n    b->data = temp;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "swap", "address": "0x1da0", "label": "swap", "content": "void __fastcall swap(Node *a, Node *b)\n{\n  int data; // eax\n\n  data = a->data;\n  a->data = b->data;\n  b->data = data;\n}\n"}, "pseudo_normalize": "void swap(Node *a, Node *b) {\n  int data;\n  data = a->data;\n  a->data = b->data;\n  b->data = data;\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<swap>:\nendbr64\nmov    (%rdi),%eax\nmov    (%rsi),%edx\nmov    %edx,(%rdi)\nmov    %eax,(%rsi)\nret\nnopl   (%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "towers", "content": "int\ntowers(int num, char frompeg, char topeg, char auxpeg)\n{\n    if (num == 1){\n        return 0;\n    }\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n    return 0;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "towers", "address": "0x2490", "label": "towers", "content": "int __fastcall towers(int num, char frompeg, char topeg, char auxpeg)\n{\n  char v4; // r8\n  char v5; // r9\n  char v6; // r10\n  int v7; // r11d\n  char v8; // r8\n  char v9; // r9\n  char v10; // r10\n  int v11; // r11d\n  char v12; // r8\n  char v13; // r9\n  char v14; // r10\n  int v15; // r11d\n  char v16; // r8\n  char v17; // r9\n  char v18; // r10\n  int v19; // r11d\n  char v20; // r8\n  char v21; // r9\n  char v22; // r10\n  int v23; // r11d\n  char v24; // r8\n  char v25; // r9\n  char v26; // r10\n  int v27; // r11d\n  char v28; // r8\n  char v29; // r9\n  char v30; // r10\n  int v31; // r11d\n\n  if ( (unsigned int)(num - 1) <= 2 || num == 4 )\n    return 0;\n  towers_0(num - 3, frompeg, auxpeg, topeg);\n  towers_0(v7, v4, v5, v6);\n  towers_0(v11, v9, v10, v8);\n  towers_0(v15, v14, v12, v13);\n  towers_0(v19, v16, v17, v18);\n  towers_0(v23, v21, v22, v20);\n  towers_0(v27, v26, v24, v25);\n  towers_0(v31, v28, v29, v30);\n  return 0;\n}\n"}, "pseudo_normalize": "int towers(int num, char frompeg, char topeg, char auxpeg) {\n  char v4;\n  char v5;\n  char v6;\n  int v7;\n  char v8;\n  char v9;\n  char v10;\n  int v11;\n  char v12;\n  char v13;\n  char v14;\n  int v15;\n  char v16;\n  char v17;\n  char v18;\n  int v19;\n  char v20;\n  char v21;\n  char v22;\n  int v23;\n  char v24;\n  char v25;\n  char v26;\n  int v27;\n  char v28;\n  char v29;\n  char v30;\n  int v31;\n  if ((unsigned int)(num - 1) <= 2 || num == 4) return 0;\n  towers_0(num - 3, frompeg, auxpeg, topeg);\n  towers_0(v7, v4, v5, v6);\n  towers_0(v11, v9, v10, v8);\n  towers_0(v15, v14, v12, v13);\n  towers_0(v19, v16, v17, v18);\n  towers_0(v23, v21, v22, v20);\n  towers_0(v27, v26, v24, v25);\n  towers_0(v31, v28, v29, v30);\n  return 0;\n}", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<towers>:\nendbr64\nlea    -0x1(%rdi),%eax\ncmp    $0x2,%eax\njbe    2550 <towers+0xc0>\nmovsbl %sil,%r10d\nmovsbl %dl,%r9d\nlea    -0x3(%rdi),%r11d\nmovsbl %cl,%r8d\ncmp    $0x4,%edi\nje     2550 <towers+0xc0>\nsub    $0x8,%rsp\nmov    %r9d,%ecx\nmov    %r8d,%edx\nmov    %r10d,%esi\nmov    %r11d,%edi\ncall   12c0 <towers.part.0>\nmov    %r10d,%ecx\nmov    %r9d,%edx\nmov    %r8d,%esi\nmov    %r11d,%edi\ncall   12c0 <towers.part.0>\nmov    %r8d,%ecx\nmov    %r10d,%edx\nmov    %r9d,%esi\nmov    %r11d,%edi\ncall   12c0 <towers.part.0>\nmov    %r9d,%ecx\nmov    %r8d,%edx\nmov    %r10d,%esi\nmov    %r11d,%edi\ncall   12c0 <towers.part.0>\nmov    %r10d,%ecx\nmov    %r9d,%edx\nmov    %r8d,%esi\nmov    %r11d,%edi\ncall   12c0 <towers.part.0>\nmov    %r8d,%ecx\nmov    %r10d,%edx\nmov    %r9d,%esi\nmov    %r11d,%edi\ncall   12c0 <towers.part.0>\nmov    %r9d,%ecx\nmov    %r8d,%edx\nmov    %r10d,%esi\nmov    %r11d,%edi\ncall   12c0 <towers.part.0>\nmov    %r10d,%ecx\nmov    %r9d,%edx\nmov    %r8d,%esi\nmov    %r11d,%edi\ncall   12c0 <towers.part.0>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "towers_test", "content": "void\ntowers_test(void)\n{\n    towers(5, 'A', 'C', 'B');\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O3.pseudo", "function_name": "towers_test", "address": "0x2560", "label": "towers_test", "content": "void __cdecl towers_test()\n{\n  ;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O3", "assembly": "<towers_test>:\nendbr64\nret\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "hanoi/hanoi.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int disk, Loops = 0;\n\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\");\n  libmin_printf(\"Disks     Moves\\n\");\n\n  disk = 0;\n\n  while (1)\n    {\n      disk++;\n      num[0] = 0;\n      num[1] = disk;\n      num[2] = 0;\n      num[3] = 0;\n      count  = 0;\n\n      mov(disk,1,3);\n\n      Loops = Loops + 1;\n      libmin_printf(\"%3d  %10ld\\n\",disk,count);\n\n      if (disk == 10) break;\n    }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "hanoi/hanoi.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r15d\n  int v4; // edx\n  int v5; // r14d\n  __int64 v6; // rdx\n  __m128i v7; // xmm0\n  int v8; // eax\n  int v9; // r15d\n  int v10; // eax\n  __int64 v11; // rdx\n\n  v3 = 0;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      num[0] = 0;\n      v5 = v3 + 1;\n      num[1] = v3 + 1;\n      *(_QWORD *)&num[2] = 0LL;\n      count = 0LL;\n      if ( v3 )\n        break;\n      num[1] = 0;\n      v3 = 1;\n      num[3] = 1;\n      count = 1LL;\n      libmin_printf(\"%3d  %10ld\\n\", 1, 1LL);\n    }\n    if ( v3 == 1 )\n    {\n      *(_QWORD *)&num[1] = 0LL;\n      v10 = 2;\n      v11 = 3LL;\n      goto LABEL_11;\n    }\n    if ( v3 == 2 )\n    {\n      *(_QWORD *)&num[1] = 0LL;\n      v11 = 7LL;\n      v10 = 3;\n      goto LABEL_11;\n    }\n    if ( v3 == 3 )\n      break;\n    mov_0(v3 - 3, 3, v4);\n    ++count;\n    *(_QWORD *)&num[1] = _mm_add_epi32(\n                           _mm_loadl_epi64((const __m128i *)&num[1]),\n                           _mm_loadl_epi64((const __m128i *)&qword_5058)).m128i_u64[0];\n    mov(v3 - 3, 3, 2);\n    --num[1];\n    ++num[3];\n    ++count;\n    mov(v3 - 3, 2, 1);\n    ++count;\n    *(_QWORD *)&num[2] = _mm_add_epi32(\n                           _mm_loadl_epi64((const __m128i *)&num[2]),\n                           _mm_loadl_epi64((const __m128i *)&qword_5058)).m128i_u64[0];\n    mov(v3 - 3, 1, 3);\n    ++count;\n    *(_QWORD *)&num[1] = _mm_add_epi32(\n                           _mm_loadl_epi64((const __m128i *)&num[1]),\n                           _mm_loadl_epi64((const __m128i *)&qword_5058)).m128i_u64[0];\n    mov(v3 - 3, 3, 2);\n    --num[3];\n    ++num[1];\n    ++count;\n    mov(v3 - 3, 2, 1);\n    ++count;\n    *(_QWORD *)&num[2] = _mm_add_epi32(\n                           _mm_loadl_epi64((const __m128i *)&num[2]),\n                           _mm_loadl_epi64((const __m128i *)&qword_5060)).m128i_u64[0];\n    mov(v3 - 3, 1, 3);\n    ++count;\n    *(_QWORD *)&num[1] = _mm_add_epi32(\n                           _mm_loadl_epi64((const __m128i *)&num[1]),\n                           _mm_loadl_epi64((const __m128i *)&qword_5058)).m128i_u64[0];\n    mov(v3 - 3, 3, 2);\n    --num[1];\n    ++num[3];\n    ++count;\n    mov(v3 - 3, 2, 1);\n    ++count;\n    *(_QWORD *)&num[2] = _mm_add_epi32(\n                           _mm_loadl_epi64((const __m128i *)&num[2]),\n                           _mm_loadl_epi64((const __m128i *)&qword_5058)).m128i_u64[0];\n    mov(v3 - 3, 1, 3);\n    ++count;\n    *(_QWORD *)&num[1] = _mm_add_epi32(\n                           _mm_loadl_epi64((const __m128i *)&num[1]),\n                           _mm_loadl_epi64((const __m128i *)&qword_5060)).m128i_u64[0];\n    mov(v3 - 3, 3, 2);\n    --num[3];\n    ++num[1];\n    ++count;\n    mov(v3 - 3, 2, 1);\n    ++count;\n    *(_QWORD *)&num[2] = _mm_add_epi32(\n                           _mm_loadl_epi64((const __m128i *)&num[2]),\n                           _mm_loadl_epi64((const __m128i *)&qword_5058)).m128i_u64[0];\n    mov(v3 - 3, 1, 3);\n    ++count;\n    *(_QWORD *)&num[1] = _mm_add_epi32(\n                           _mm_loadl_epi64((const __m128i *)&num[1]),\n                           _mm_loadl_epi64((const __m128i *)&qword_5058)).m128i_u64[0];\n    mov(v3 - 3, 3, 2);\n    --num[1];\n    ++num[3];\n    ++count;\n    mov(v3 - 3, 2, 1);\n    v6 = count;\n    v7 = _mm_loadl_epi64((const __m128i *)&num[2]);\n    v8 = _mm_cvtsi128_si32(_mm_shuffle_epi32(v7, 229));\n    ++count;\n    *(_QWORD *)&num[2] = _mm_add_epi32(v7, _mm_loadl_epi64((const __m128i *)&qword_5058)).m128i_u64[0];\n    if ( v3 == 4 )\n    {\n      --num[1];\n      v10 = v8 + 2;\n      v11 = v6 + 2;\nLABEL_11:\n      num[3] = v10;\n      count = v11;\n      ++v3;\n      libmin_printf(\"%3d  %10ld\\n\", v5, v11);\n    }\n    else\n    {\n      v9 = v3 - 4;\n      mov(v9, 1, 2);\n      --num[1];\n      ++num[3];\n      ++count;\n      mov(v9, 2, 3);\n      libmin_printf(\"%3d  %10ld\\n\", v5, count);\n      if ( v5 == 10 )\n        libmin_success();\n      v3 = v5;\n    }\n  }\n  v11 = 15LL;\n  v10 = 4;\n  *(_QWORD *)&num[1] = _mm_unpacklo_epi32((__m128i)0LL, _mm_cvtsi32_si128(0)).m128i_u64[0];\n  goto LABEL_11;\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  long long v6;\n  __m128i v7;\n  int v8;\n  int v9;\n  int v10;\n  long long v11;\n  v3 = 0;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  while (1) {\n    while (1) {\n      num[0] = 0;\n      v5 = v3 + 1;\n      num[1] = v3 + 1;\n      *(uint64_t *)&num[2] = 0LL;\n      count = 0LL;\n      if (v3) break;\n      num[1] = 0;\n      v3 = 1;\n      num[3] = 1;\n      count = 1LL;\n      libmin_printf(\"%3d  %10ld\\n\", 1, 1LL);\n    }\n    if (v3 == 1) {\n      *(uint64_t *)&num[1] = 0LL;\n      v10 = 2;\n      v11 = 3LL;\n      goto LABEL_11;\n    }\n    if (v3 == 2) {\n      *(uint64_t *)&num[1] = 0LL;\n      v11 = 7LL;\n      v10 = 3;\n      goto LABEL_11;\n    }\n    if (v3 == 3) break;\n    mov_0(v3 - 3, 3, v4);\n    ++count;\n    *(uint64_t *)&num[1] =\n        _mm_add_epi32(_mm_loadl_epi64((const __m128i *)&num[1]),\n                      _mm_loadl_epi64((const __m128i *)&qword_5058))\n            .m128i_u64[0];\n    mov(v3 - 3, 3, 2);\n    --num[1];\n    ++num[3];\n    ++count;\n    mov(v3 - 3, 2, 1);\n    ++count;\n    *(uint64_t *)&num[2] =\n        _mm_add_epi32(_mm_loadl_epi64((const __m128i *)&num[2]),\n                      _mm_loadl_epi64((const __m128i *)&qword_5058))\n            .m128i_u64[0];\n    mov(v3 - 3, 1, 3);\n    ++count;\n    *(uint64_t *)&num[1] =\n        _mm_add_epi32(_mm_loadl_epi64((const __m128i *)&num[1]),\n                      _mm_loadl_epi64((const __m128i *)&qword_5058))\n            .m128i_u64[0];\n    mov(v3 - 3, 3, 2);\n    --num[3];\n    ++num[1];\n    ++count;\n    mov(v3 - 3, 2, 1);\n    ++count;\n    *(uint64_t *)&num[2] =\n        _mm_add_epi32(_mm_loadl_epi64((const __m128i *)&num[2]),\n                      _mm_loadl_epi64((const __m128i *)&qword_5060))\n            .m128i_u64[0];\n    mov(v3 - 3, 1, 3);\n    ++count;\n    *(uint64_t *)&num[1] =\n        _mm_add_epi32(_mm_loadl_epi64((const __m128i *)&num[1]),\n                      _mm_loadl_epi64((const __m128i *)&qword_5058))\n            .m128i_u64[0];\n    mov(v3 - 3, 3, 2);\n    --num[1];\n    ++num[3];\n    ++count;\n    mov(v3 - 3, 2, 1);\n    ++count;\n    *(uint64_t *)&num[2] =\n        _mm_add_epi32(_mm_loadl_epi64((const __m128i *)&num[2]),\n                      _mm_loadl_epi64((const __m128i *)&qword_5058))\n            .m128i_u64[0];\n    mov(v3 - 3, 1, 3);\n    ++count;\n    *(uint64_t *)&num[1] =\n        _mm_add_epi32(_mm_loadl_epi64((const __m128i *)&num[1]),\n                      _mm_loadl_epi64((const __m128i *)&qword_5060))\n            .m128i_u64[0];\n    mov(v3 - 3, 3, 2);\n    --num[3];\n    ++num[1];\n    ++count;\n    mov(v3 - 3, 2, 1);\n    ++count;\n    *(uint64_t *)&num[2] =\n        _mm_add_epi32(_mm_loadl_epi64((const __m128i *)&num[2]),\n                      _mm_loadl_epi64((const __m128i *)&qword_5058))\n            .m128i_u64[0];\n    mov(v3 - 3, 1, 3);\n    ++count;\n    *(uint64_t *)&num[1] =\n        _mm_add_epi32(_mm_loadl_epi64((const __m128i *)&num[1]),\n                      _mm_loadl_epi64((const __m128i *)&qword_5058))\n            .m128i_u64[0];\n    mov(v3 - 3, 3, 2);\n    --num[1];\n    ++num[3];\n    ++count;\n    mov(v3 - 3, 2, 1);\n    v6 = count;\n    v7 = _mm_loadl_epi64((const __m128i *)&num[2]);\n    v8 = _mm_cvtsi128_si32(_mm_shuffle_epi32(v7, 229));\n    ++count;\n    *(uint64_t *)&num[2] =\n        _mm_add_epi32(v7, _mm_loadl_epi64((const __m128i *)&qword_5058))\n            .m128i_u64[0];\n    if (v3 == 4) {\n      --num[1];\n      v10 = v8 + 2;\n      v11 = v6 + 2;\n    LABEL_11:\n      num[3] = v10;\n      count = v11;\n      ++v3;\n      libmin_printf(\"%3d  %10ld\\n\", v5, v11);\n    } else {\n      v9 = v3 - 4;\n      mov(v9, 1, 2);\n      --num[1];\n      ++num[3];\n      ++count;\n      mov(v9, 2, 3);\n      libmin_printf(\"%3d  %10ld\\n\", v5, count);\n      if (v5 == 10) libmin_success();\n      v3 = v5;\n    }\n  }\n  v11 = 15LL;\n  v10 = 4;\n  *(uint64_t *)&num[1] =\n      _mm_unpacklo_epi32((__m128i)0LL, _mm_cvtsi32_si128(0)).m128i_u64[0];\n  goto LABEL_11;\n}", "binary": "hanoi/hanoi.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nlea    0x3efb(%rip),%rdi\nxor    %eax,%eax\nxor    %r15d,%r15d\npush   %r14\npush   %r13\npush   %r12\nmovabs $0x200000000,%r12\npush   %rbp\nlea    0x3f14(%rip),%rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   4160 <libmin_printf>\nlea    0x3ef2(%rip),%rdi\nxor    %eax,%eax\ncall   4160 <libmin_printf>\nmov    0x3f07(%rip),%r13\nnopl   0x0(%rax)\nmovl   $0x0,0x6126(%rip)\nlea    0x1(%r15),%r14d\nmov    %r14d,0x611f(%rip)\nmovq   $0x0,0x6118(%rip)\nmovq   $0x0,0x60f5(%rip)\ncmp    $0x1,%r14d\nje     1508 <main+0x408>\ncmp    $0x1,%r15d\nje     1550 <main+0x450>\ncmp    $0x2,%r15d\nje     1590 <main+0x490>\ncmp    $0x3,%r15d\nje     15b8 <main+0x4b8>\nlea    -0x3(%r15),%ebx\nmov    $0x3,%esi\nmov    %ebx,%edi\ncall   1c20 <mov.constprop.0.isra.0>\nmov    $0x2,%edx\nmov    %ebx,%edi\nmovq   0x60c2(%rip),%xmm0\nmovq   0x3e8e(%rip),%xmm1\nmov    $0x3,%esi\naddq   $0x1,0x6099(%rip)\npaddd  %xmm1,%xmm0\nmovq   %xmm0,0x60a1(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x1,%edx\nmov    %ebx,%edi\nmov    $0x2,%esi\nsubl   $0x1,0x6089(%rip)\naddl   $0x1,0x608a(%rip)\naddq   $0x1,0x6066(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x3,%edx\nmov    %ebx,%edi\nmovq   0x606a(%rip),%xmm0\nmovq   0x3e32(%rip),%xmm2\nmov    $0x1,%esi\naddq   $0x1,0x603d(%rip)\npaddd  %xmm2,%xmm0\nmovq   %xmm0,0x6049(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x2,%edx\nmov    %ebx,%edi\nmovq   0x6031(%rip),%xmm0\nmovq   0x3dfd(%rip),%xmm3\nmov    $0x3,%esi\naddq   $0x1,0x6008(%rip)\npaddd  %xmm3,%xmm0\nmovq   %xmm0,0x6010(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x1,%edx\nmov    %ebx,%edi\nmov    $0x2,%esi\nsubl   $0x1,0x6000(%rip)\naddl   $0x1,0x5ff1(%rip)\naddq   $0x1,0x5fd5(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x3,%edx\nmov    %ebx,%edi\nmovq   0x5fd9(%rip),%xmm0\nmovq   0x3da9(%rip),%xmm4\nmov    $0x1,%esi\naddq   $0x1,0x5fac(%rip)\npaddd  %xmm4,%xmm0\nmovq   %xmm0,0x5fb8(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x2,%edx\nmov    %ebx,%edi\nmovq   0x5fa0(%rip),%xmm0\nmovq   0x3d6c(%rip),%xmm5\nmov    $0x3,%esi\naddq   $0x1,0x5f77(%rip)\npaddd  %xmm5,%xmm0\nmovq   %xmm0,0x5f7f(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x1,%edx\nmov    %ebx,%edi\nmov    $0x2,%esi\nsubl   $0x1,0x5f67(%rip)\naddl   $0x1,0x5f68(%rip)\naddq   $0x1,0x5f44(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x3,%edx\nmov    %ebx,%edi\nmovq   0x5f48(%rip),%xmm0\nmovq   0x3d10(%rip),%xmm6\nmov    $0x1,%esi\naddq   $0x1,0x5f1b(%rip)\npaddd  %xmm6,%xmm0\nmovq   %xmm0,0x5f27(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x2,%edx\nmov    %ebx,%edi\nmovq   0x5f0f(%rip),%xmm0\nmovq   0x3ce3(%rip),%xmm7\nmov    $0x3,%esi\naddq   $0x1,0x5ee6(%rip)\npaddd  %xmm7,%xmm0\nmovq   %xmm0,0x5eee(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x1,%edx\nmov    %ebx,%edi\nmov    $0x2,%esi\nsubl   $0x1,0x5ede(%rip)\naddl   $0x1,0x5ecf(%rip)\naddq   $0x1,0x5eb3(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x3,%edx\nmov    %ebx,%edi\nmovq   0x5eb7(%rip),%xmm0\nmovq   0x3c7f(%rip),%xmm1\nmov    $0x1,%esi\naddq   $0x1,0x5e8a(%rip)\npaddd  %xmm1,%xmm0\nmovq   %xmm0,0x5e96(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x2,%edx\nmov    %ebx,%edi\nmovq   0x5e7e(%rip),%xmm0\nmovq   0x3c4a(%rip),%xmm2\nmov    $0x3,%esi\naddq   $0x1,0x5e55(%rip)\npaddd  %xmm2,%xmm0\nmovq   %xmm0,0x5e5d(%rip)\ncall   16f0 <mov.isra.0>\nmov    $0x1,%edx\nmov    %ebx,%edi\nmov    $0x2,%esi\nsubl   $0x1,0x5e45(%rip)\naddl   $0x1,0x5e46(%rip)\naddq   $0x1,0x5e22(%rip)\ncall   16f0 <mov.isra.0>\nmov    0x5e16(%rip),%rdx\nmovq   0x5e26(%rip),%xmm0\nmovq   0x3bee(%rip),%xmm4\npshufd $0xe5,%xmm0,%xmm3\nlea    0x1(%rdx),%rcx\nmovd   %xmm3,%eax\npaddd  %xmm4,%xmm0\nmov    %rcx,0x5dee(%rip)\nmovq   %xmm0,0x5dfe(%rip)\ncmp    $0x1,%ebx\nje     15e2 <main+0x4e2>\nsub    $0x4,%r15d\nmov    $0x2,%edx\nmov    $0x1,%esi\nmov    %r15d,%edi\ncall   16f0 <mov.isra.0>\nmov    $0x3,%edx\nmov    %r15d,%edi\nmov    $0x2,%esi\nsubl   $0x1,0x5dc7(%rip)\naddl   $0x1,0x5dc8(%rip)\naddq   $0x1,0x5da4(%rip)\ncall   16f0 <mov.isra.0>\nxor    %eax,%eax\nmov    %r14d,%esi\nmov    %rbp,%rdi\nmov    0x5d90(%rip),%rdx\ncall   4160 <libmin_printf>\ncmp    $0xa,%r14d\njne    15f5 <main+0x4f5>\ncall   43a0 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nmov    $0x1,%edx\nmov    $0x1,%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nmovl   $0x0,0x5d63(%rip)\nmov    $0x1,%r15d\nmovl   $0x1,0x5d5b(%rip)\nmovq   $0x1,0x5d34(%rip)\ncall   4160 <libmin_printf>\njmp    1150 <main+0x50>\ncs nopw 0x0(%rax,%rax,1)\nmovq   $0x0,0x5d29(%rip)\nmov    $0x2,%eax\nmov    $0x3,%edx\nmov    %eax,0x5d21(%rip)\nmov    %r14d,%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nmov    %rdx,0x5cf6(%rip)\nmov    %r14d,%r15d\ncall   4160 <libmin_printf>\njmp    1150 <main+0x50>\nnopw   0x0(%rax,%rax,1)\nmov    %r12,%rax\nmov    %r12,0x5cea(%rip)\nmov    $0x7,%edx\nshr    $0x20,%rax\nsub    $0x2,%eax\nmov    %eax,0x5cdc(%rip)\nmov    $0x3,%eax\njmp    1565 <main+0x465>\nnopl   0x0(%rax,%rax,1)\nmov    %r13,%rax\npxor   %xmm0,%xmm0\nmov    $0xf,%edx\nshr    $0x20,%rax\nsub    $0x3,%eax\nmovd   %eax,%xmm5\nmov    $0x4,%eax\npunpckldq %xmm5,%xmm0\nmovq   %xmm0,0x5ca4(%rip)\njmp    1565 <main+0x465>\nsubl   $0x1,0x5c9b(%rip)\nadd    $0x2,%eax\nadd    $0x2,%rdx\njmp    1565 <main+0x465>\nmov    %r14d,%r15d\njmp    1150 <main+0x50>\nnopl   (%rax)\n"}
{"source": {"path": "heapsort/heapsort.c", "function_name": "HSORT", "content": "/*************************/\n/*  Heap Sort Program    */\n/*************************/\n\nint\nHSORT(int64_t m, int64_t p)\n{\n  int64_t i,j,k,l;\n  int64_t size;\n\n  int64_t  msize, iran, ia, ic, im, ih, ir;\n  int64_t  count, ca;\n\n  msize = m * bplong;\n  size  = m - 1;\n\n  if (m >= 2048)\n    {\n      libmin_printf(\"base buffer overflow!\\n\");\n      libmin_fail(1);\n    }\n\n  ia = 106;\n  ic = 1283;\n  im = 6075;\n  ih = 1001;\n\n  count = 0;\n\n  iran = 47;                        /* Fill with 'random' numbers */\n  for(i=1 ; i<=size ; i++)\n    {\n      iran = (iran * ia + ic) % im;\n      *(base+i) = 1 + (ih * iran) / im;\n    }\n\n  k = (size >> 1) + 1;              /* Heap sort the array */\n  l = size;\n  ca = 0;\n\n  for (;;)\n    {\n      if (k > 1)\n\t{\n\t  ir = *(base+(--k));\n\t}\n      else\n\t{\n\t  ir = *(base+l);\n\t  *(base+l) = *(base+1);\n\t  if (--l == 1)\n\t    {\n\t      *(base+1) = ir;\n\t      goto Done;\n\t    }\n\t}\n\n      i = k;\n      j = k << 1;\n\n      while (j <= l)\n\t{\n\t  if ( (j < l) && (*(base+j) < *(base+j+1)) ) ++j;\n\t  if (ir < *(base+j))\n\t    {\n\t      *(base+i) = *(base+j);\n\t      j += (i=j);\n\t    }\n\t  else\n\t    {\n\t      j = l + 1;\n\t    }\n\t}\n      *(base+i) = ir;\n    }\n Done:\n  count = count + ca;\n\n  /* Scale runtime per iteration */\n  ir = count;\n  ir = (ir + ca) / 2;\n\n  if ( p != 0L )\n    libmin_printf(\"   %10ld\\n\", (int)msize);\n\n  /* check the array */\n  for(i = 0; i < size-1; i++)\n    {\n      if (base[i] > base[i+1])\n      {\n        libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n        libmin_fail(1);\n      }\n    }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n\n  return 0;\n}\n"}, "pseudo": {"path": "heapsort/heapsort.host.O3.pseudo", "function_name": "HSORT", "address": "0x12f0", "label": "HSORT", "content": "void __fastcall HSORT(__int64 a1, __int64 a2)\n{\n  __int64 v2; // r14\n  int v5; // r13d\n  int64_t *v6; // rsi\n  __int64 v7; // rcx\n  int64_t *v8; // rbx\n  __int64 v9; // r11\n  __int64 v10; // rcx\n  __int64 v11; // rsi\n  __int64 v12; // rdx\n  __int64 v13; // rax\n  __int64 v14; // r10\n  int64_t *v15; // r9\n  __int64 v16; // rdi\n  int64_t *v17; // r8\n  __int64 *v18; // r8\n  __int64 *v19; // r8\n  __int64 v20; // rbp\n  __int64 v21; // r12\n  int64_t v22; // rax\n  __int64 *v23; // rax\n\n  v2 = a1 - 1;\n  v5 = bplong;\n  if ( a1 > 2047 )\n  {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  if ( v2 <= 0 )\n  {\n    v8 = base;\n  }\n  else\n  {\n    v6 = &base[1];\n    v7 = 47LL;\n    v8 = base;\n    do\n    {\n      ++v6;\n      v7 = (106 * v7 + 1283) % 6075;\n      *(v6 - 1) = 1001 * v7 / 6075 + 1;\n    }\n    while ( &base[a1 - 7] != v6 );\n  }\n  v9 = (v2 >> 1) + 1;\n  if ( v9 <= 1 )\n    goto LABEL_25;\nLABEL_6:\n  v10 = v9 - 1;\n  v11 = 2 * (v9 - 1);\n  v12 = v8[v9 - 1];\n  if ( v11 > v2 )\n    goto LABEL_24;\n  while ( 1 )\n  {\n    v13 = v11;\n    v14 = v10;\n    while ( 1 )\n    {\n      v15 = &v8[v13];\n      v16 = *v15;\n      if ( v13 < v2 )\n      {\n        v17 = &v8[v13 + 1];\n        if ( *v17 > v16 )\n        {\n          ++v13;\n          v16 = *v17;\n          v15 = v17;\n        }\n      }\n      v18 = &v8[v14];\n      if ( v12 >= v16 )\n        break;\n      *v18 = v16;\n      if ( 2 * v13 > v2 )\n      {\n        v18 = v15;\n        break;\n      }\n      v14 = v13;\n      v13 *= 2LL;\n    }\n    *v18 = v12;\n    if ( v9 <= 1 )\n      goto LABEL_13;\nLABEL_24:\n    v9 = v10;\n    if ( v10 > 1 )\n      goto LABEL_6;\nLABEL_25:\n    v23 = &v8[v2--];\n    v12 = *v23;\n    *v23 = base[1];\n    if ( v2 == 1 )\n      goto LABEL_14;\n    v11 = 2 * v9;\n    if ( 2 * v9 > v2 )\n      break;\n    v10 = v9;\n  }\n  v8[v9] = v12;\n  v10 = v9;\nLABEL_13:\n  v19 = &v8[v2];\n  v12 = *v19;\n  *v19 = base[1];\n  if ( v2 == 2 )\n  {\nLABEL_14:\n    base[1] = v12;\n    if ( a2 )\n      libmin_printf(\"   %10ld\\n\", (unsigned int)(a1 * v5));\n    v20 = a1 - 2;\n    v21 = 0LL;\n    if ( v20 > 0 )\n    {\n      do\n      {\n        v22 = v8[v21++];\n        if ( v22 > v8[v21] )\n        {\n          libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n          libmin_fail(1);\n        }\n      }\n      while ( v21 != v20 );\n    }\n    libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  }\n  else\n  {\n    HSORT_cold(v2 - 1, v11, v12, v10);\n  }\n}\n"}, "pseudo_normalize": "void HSORT(long long a1, long long a2) {\n  long long v2;\n  int v5;\n  int64_t *v6;\n  long long v7;\n  int64_t *v8;\n  long long v9;\n  long long v10;\n  long long v11;\n  long long v12;\n  long long v13;\n  long long v14;\n  int64_t *v15;\n  long long v16;\n  int64_t *v17;\n  long long *v18;\n  long long *v19;\n  long long v20;\n  long long v21;\n  int64_t v22;\n  long long *v23;\n  v2 = a1 - 1;\n  v5 = bplong;\n  if (a1 > 2047) {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  if (v2 <= 0) {\n    v8 = base;\n  } else {\n    v6 = &base[1];\n    v7 = 47LL;\n    v8 = base;\n    do {\n      ++v6;\n      v7 = (106 * v7 + 1283) % 6075;\n      *(v6 - 1) = 1001 * v7 / 6075 + 1;\n    } while (&base[a1 - 7] != v6);\n  }\n  v9 = (v2 >> 1) + 1;\n  if (v9 <= 1) goto LABEL_25;\nLABEL_6:\n  v10 = v9 - 1;\n  v11 = 2 * (v9 - 1);\n  v12 = v8[v9 - 1];\n  if (v11 > v2) goto LABEL_24;\n  while (1) {\n    v13 = v11;\n    v14 = v10;\n    while (1) {\n      v15 = &v8[v13];\n      v16 = *v15;\n      if (v13 < v2) {\n        v17 = &v8[v13 + 1];\n        if (*v17 > v16) {\n          ++v13;\n          v16 = *v17;\n          v15 = v17;\n        }\n      }\n      v18 = &v8[v14];\n      if (v12 >= v16) break;\n      *v18 = v16;\n      if (2 * v13 > v2) {\n        v18 = v15;\n        break;\n      }\n      v14 = v13;\n      v13 *= 2LL;\n    }\n    *v18 = v12;\n    if (v9 <= 1) goto LABEL_13;\n  LABEL_24:\n    v9 = v10;\n    if (v10 > 1) goto LABEL_6;\n  LABEL_25:\n    v23 = &v8[v2--];\n    v12 = *v23;\n    *v23 = base[1];\n    if (v2 == 1) goto LABEL_14;\n    v11 = 2 * v9;\n    if (2 * v9 > v2) break;\n    v10 = v9;\n  }\n  v8[v9] = v12;\n  v10 = v9;\nLABEL_13:\n  v19 = &v8[v2];\n  v12 = *v19;\n  *v19 = base[1];\n  if (v2 == 2) {\n  LABEL_14:\n    base[1] = v12;\n    if (a2) libmin_printf(\"   %10ld\\n\", (unsigned int)(a1 * v5));\n    v20 = a1 - 2;\n    v21 = 0LL;\n    if (v20 > 0) {\n      do {\n        v22 = v8[v21++];\n        if (v22 > v8[v21]) {\n          libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n          libmin_fail(1);\n        }\n      } while (v21 != v20);\n    }\n    libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  } else {\n    HSORT_cold(v2 - 1, v11, v12, v10);\n  }\n}", "binary": "heapsort/heapsort.host.O3", "assembly": "<HSORT>:\nendbr64\npush   %r15\npush   %r14\nlea    -0x1(%rdi),%r14\npush   %r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    0x8f6d(%rip),%r13\ncmp    $0x7ff,%rdi\njg     153b <HSORT+0x24b>\ntest   %r14,%r14\njle    155c <HSORT+0x26c>\nlea    0x4f58(%rip),%rsi\nmov    $0x2f,%ecx\nmovabs $0x564d7402dd925a19,%rdi\nlea    -0x8(%rsi),%rbx\nlea    (%rbx,%rbp,8),%r8\nnopw   0x0(%rax,%rax,1)\nimul   $0x6a,%rcx,%r9\nadd    $0x8,%rsi\nadd    $0x503,%r9\nmov    %r9,%rax\nimul   %rdi\nmov    %r9,%rax\nsar    $0x3f,%rax\nsar    $0xb,%rdx\nmov    %rdx,%rcx\nsub    %rax,%rcx\nimul   $0x17bb,%rcx,%rax\nmov    %r9,%rcx\nsub    %rax,%rcx\nimul   $0x3e9,%rcx,%r9\nmov    %r9,%rax\nsar    $0x3f,%r9\nimul   %rdi\nsar    $0xb,%rdx\nsub    %r9,%rdx\nlea    0x1(%rdx),%rax\nmov    %rax,-0x8(%rsi)\ncmp    %rsi,%r8\njne    1350 <HSORT+0x60>\nmov    %r14,%r11\nsar    %r11\nadd    $0x1,%r11\ncmp    $0x1,%r11\njle    14ed <HSORT+0x1fd>\nnopl   0x0(%rax)\nlea    -0x1(%r11),%rcx\nlea    (%rcx,%rcx,1),%rsi\nmov    (%rbx,%rcx,8),%rdx\ncmp    %r14,%rsi\njg     14e0 <HSORT+0x1f0>\nmov    %rsi,%rax\nmov    %rcx,%r10\nnopl   0x0(%rax,%rax,1)\nlea    0x0(,%rax,8),%r8\nlea    (%rbx,%r8,1),%r9\nmov    (%r9),%rdi\ncmp    %r14,%rax\njge    140b <HSORT+0x11b>\nlea    0x8(%rbx,%r8,1),%r8\nmov    (%r8),%r15\ncmp    %rdi,%r15\njle    140b <HSORT+0x11b>\nadd    $0x1,%rax\nmov    %r15,%rdi\nmov    %r8,%r9\nlea    (%rbx,%r10,8),%r8\ncmp    %rdi,%rdx\njl     14c0 <HSORT+0x1d0>\nmov    %rdx,(%r8)\ncmp    $0x1,%r11\njg     14e0 <HSORT+0x1f0>\nmov    0x4e5c(%rip),%r9\nlea    (%rbx,%r14,8),%r8\nmov    %r14,%rax\nlea    -0x1(%r14),%rdi\nmov    (%r8),%rdx\nmov    %r9,(%r8)\ncmp    $0x2,%r14\njne    1100 <HSORT.cold>\nmov    %rdx,0x4e3a(%rip)\ntest   %r12,%r12\njne    1568 <HSORT+0x278>\nsub    $0x2,%rbp\nxor    %r12d,%r12d\nlea    0x2c1b(%rip),%r13\ntest   %rbp,%rbp\njg     1475 <HSORT+0x185>\njmp    149c <HSORT+0x1ac>\nnopl   0x0(%rax)\ncmp    %rbp,%r12\nje     149c <HSORT+0x1ac>\nmov    (%rbx,%r12,8),%rax\nadd    $0x1,%r12\ncmp    (%rbx,%r12,8),%rax\njle    1470 <HSORT+0x180>\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   3680 <libmin_printf>\nmov    $0x1,%edi\ncall   1770 <libmin_fail>\ncmp    %rbp,%r12\njne    1475 <HSORT+0x185>\nlea    0x2bb5(%rip),%rdi\nxor    %eax,%eax\ncall   3680 <libmin_printf>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    %rdi,(%r8)\nlea    (%rax,%rax,1),%rdi\ncmp    %r14,%rdi\njg     1528 <HSORT+0x238>\nmov    %rax,%r10\nmov    %rdi,%rax\njmp    13e0 <HSORT+0xf0>\nnopw   0x0(%rax,%rax,1)\nmov    %rcx,%r11\ncmp    $0x1,%r11\njg     13c0 <HSORT+0xd0>\nmov    0x4d94(%rip),%rcx\nlea    (%rbx,%r14,8),%rax\nsub    $0x1,%r14\nmov    (%rax),%rdx\nmov    %rcx,(%rax)\ncmp    $0x1,%r14\nje     1447 <HSORT+0x157>\nlea    (%r11,%r11,1),%rsi\nlea    (%rbx,%r11,8),%rax\ncmp    %r14,%rsi\njg     1530 <HSORT+0x240>\nmov    %r11,%rcx\njmp    13d5 <HSORT+0xe5>\nnopl   0x0(%rax)\nmov    %r9,%r8\njmp    1418 <HSORT+0x128>\nmov    %rdx,(%rax)\nmov    %r11,%rcx\njmp    1425 <HSORT+0x135>\nlea    0x2ac2(%rip),%rdi\nxor    %eax,%eax\ncall   3680 <libmin_printf>\nmov    $0x1,%edi\ncall   1770 <libmin_fail>\ntest   %r14,%r14\njg     1329 <HSORT+0x39>\nlea    0x4d1d(%rip),%rbx\njmp    13a8 <HSORT+0xb8>\nmov    %r13d,%esi\nlea    0x2aa9(%rip),%rdi\nxor    %eax,%eax\nimul   %ebp,%esi\ncall   3680 <libmin_printf>\njmp    1457 <HSORT+0x167>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "heapsort/heapsort.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int64_t  j, p;\n\n  bplong = sizeof(int64_t);\n\n  libmin_printf(\"\\n   Heap Sort C Program\\n\");\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", (long)bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n\n\t\t\t\t   /* Predetermine runtime (sec) for  */\n\t\t\t\t   /* memory size 2000 * sizeof(long),*/\n\t\t\t\t   /* and 256 iterations. p = 0 means */\n\t\t\t\t   /* don't print the result.         */\n  j = 1024;\n  p = 1;\n  HSORT(j,p);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "heapsort/heapsort.host.O3.pseudo", "function_name": "main", "address": "0x11a0", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}", "binary": "heapsort/heapsort.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nlea    0x2e76(%rip),%rdi\nxor    %eax,%eax\nmovq   $0x8,0x90c4(%rip)\ncall   3680 <libmin_printf>\nmov    0x90b8(%rip),%rsi\nlea    0x2ee1(%rip),%rdi\nxor    %eax,%eax\ncall   3680 <libmin_printf>\nlea    0x2e61(%rip),%rdi\nxor    %eax,%eax\ncall   3680 <libmin_printf>\nmov    $0x1,%esi\nmov    $0x400,%edi\ncall   12f0 <HSORT>\ncall   38c0 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\nnop\n"}
{"source": {"path": "heat-calc/heat-calc.c", "function_name": "main", "content": "#include \"libmin.h\"\n\n#define N      100    // Number of grid points along the rod.\n#define STEPS  500   // Number of time steps for the simulation.\n#define ALPHA  1.0    // Thermal diffusivity constant.\n#define DX     1.0    // Spatial step (distance between grid points).\n#define DT     0.1    // Time step (should be small enough for stability).\n\nint main() {\n    double u[N];      // Temperature distribution at current time.\n    double u_new[N];  // Temperature distribution for the next time step.\n    int i, step;\n\n    // Initialize the rod:\n    // Set an initial temperature distribution with a single \"hot spot\" at the center.\n    // Boundary conditions: fixed at 0.0 at both ends.\n    for (i = 0; i < N; i++) {\n        if (i == N / 2)\n            u[i] = 100.0;\n        else\n            u[i] = 0.0;\n    }\n\n    // Main time-stepping loop: simulate STEPS time steps.\n    for (step = 0; step < STEPS; step++) {\n        // Update interior points using the explicit finite difference scheme:\n        // u_new[i] = u[i] + DT * ALPHA * (u[i-1] - 2*u[i] + u[i+1]) / (DX*DX)\n        for (i = 1; i < N - 1; i++) {\n            u_new[i] = u[i] + DT * ALPHA * (u[i - 1] - 2 * u[i] + u[i + 1]) / (DX * DX);\n        }\n        \n        // Copy boundary values (Dirichlet boundary conditions; they remain constant).\n        u_new[0] = u[0];\n        u_new[N - 1] = u[N - 1];\n        \n        // Update the current temperature distribution from the newly computed values.\n        for (i = 0; i < N; i++) {\n            u[i] = u_new[i];\n        }\n    }\n\n    // Output the final temperature distribution.\n    libmin_printf(\"Final temperature distribution along the rod:\\n\");\n    for (i = 0; i < N; i++) {\n        libmin_printf(\"u[%d] = %.2f\\n\", i, u[i]);\n    }\n\n    // Compute a simple checksum (sum of all temperatures) for validation.\n    double checksum = 0.0;\n    for (i = 0; i < N; i++) {\n        checksum += u[i];\n    }\n    libmin_printf(\"Checksum: %.2f\\n\", checksum);\n\n    libtarg_success();\n    return 0;\n}\n"}, "pseudo": {"path": "heat-calc/heat-calc.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rax\n  double *v4; // rbx\n  int v5; // r9d\n  __m128d v6; // xmm2\n  double *v7; // rdx\n  __m128d *v8; // rax\n  __m128d v9; // xmm1\n  __m128d v10; // xmm3\n  __m128d v11; // xmm0\n  double v12; // xmm0_8\n  __int64 v13; // r12\n  double v14; // xmm0_8\n  int v15; // esi\n  double v16; // xmm0_8\n  double v17; // xmm1_8\n  _OWORD u[50]; // [rsp+0h] [rbp-678h] BYREF\n  double u_new[100]; // [rsp+320h] [rbp-358h] BYREF\n  _QWORD v20[7]; // [rsp+640h] [rbp-38h] BYREF\n\n  v20[1] = __readfsqword(0x28u);\n  v3 = 0LL;\n  v4 = (double *)u;\n  while ( 1 )\n  {\n    if ( v3 == 50 )\n    {\n      *(_QWORD *)&u[25] = 0x4059000000000000LL;\n    }\n    else\n    {\n      *((_QWORD *)u + v3) = 0LL;\n      if ( v3 == 99 )\n      {\n        v5 = 500;\n        do\n        {\n          v6 = (__m128d)u[0];\n          v7 = &u_new[1];\n          v8 = (__m128d *)((char *)u + 8);\n          do\n          {\n            v9 = *v8;\n            v7 += 2;\n            ++v8;\n            v10 = _mm_add_pd(v9, v9);\n            v11 = _mm_sub_pd(v6, v10);\n            v6 = *(__m128d *)((char *)&v8[-1] + 8);\n            *((__m128d *)v7 - 1) = _mm_add_pd(_mm_mul_pd(_mm_add_pd(v11, v6), (__m128d)xmmword_4060), v9);\n          }\n          while ( &u_new[99] != v7 );\n          u_new[0] = *(double *)u;\n          v12 = *((double *)&u[49] + 1);\n          u_new[99] = *((double *)&u[49] + 1);\n          qmemcpy(u, u_new, sizeof(u));\n          --v5;\n        }\n        while ( v5 );\n        v13 = 0LL;\n        libmin_printf(\n          \"Final temperature distribution along the rod:\\n\",\n          v20,\n          v7,\n          0LL,\n          &u_new[99],\n          v12,\n          v9.m128d_f64[0],\n          v6.m128d_f64[0],\n          v10.m128d_f64[0],\n          0.1);\n        do\n        {\n          v14 = *((double *)u + v13);\n          v15 = v13++;\n          libmin_printf(\"u[%d] = %.2f\\n\", v15, v14);\n        }\n        while ( v13 != 100 );\n        v16 = 0.0;\n        do\n        {\n          v17 = *v4;\n          v4 += 2;\n          v16 = v16 + v17 + *(v4 - 1);\n        }\n        while ( v4 != u_new );\n        libmin_printf(\"Checksum: %.2f\\n\", v16);\n        libtarg_success();\n      }\n    }\n    ++v3;\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  double *v4;\n  int v5;\n  __m128d v6;\n  double *v7;\n  __m128d *v8;\n  __m128d v9;\n  __m128d v10;\n  __m128d v11;\n  double v12;\n  long long v13;\n  double v14;\n  int v15;\n  double v16;\n  double v17;\n  long double u[50];\n  double u_new[100];\n  uint64_t v20[7];\n  v20[1] = __readfsqword(40u);\n  v3 = 0LL;\n  v4 = (double *)u;\n  while (1) {\n    if (v3 == 50) {\n      *(uint64_t *)&u[25] = 4636737291354636288LL;\n    } else {\n      *((uint64_t *)u + v3) = 0LL;\n      if (v3 == 99) {\n        v5 = 500;\n        do {\n          v6 = (__m128d)u[0];\n          v7 = &u_new[1];\n          v8 = (__m128d *)((char *)u + 8);\n          do {\n            v9 = *v8;\n            v7 += 2;\n            ++v8;\n            v10 = _mm_add_pd(v9, v9);\n            v11 = _mm_sub_pd(v6, v10);\n            v6 = *(__m128d *)((char *)&v8[-1] + 8);\n            *((__m128d *)v7 - 1) = _mm_add_pd(\n                _mm_mul_pd(_mm_add_pd(v11, v6), (__m128d)xmmword_4060), v9);\n          } while (&u_new[99] != v7);\n          u_new[0] = *(double *)u;\n          v12 = *((double *)&u[49] + 1);\n          u_new[99] = *((double *)&u[49] + 1);\n          qmemcpy(u, u_new, sizeof(u));\n          --v5;\n        } while (v5);\n        v13 = 0LL;\n        libmin_printf(\"Final temperature distribution along the rod:\\n\", v20,\n                      v7, 0LL, &u_new[99], v12, v9.m128d_f64[0],\n                      v6.m128d_f64[0], v10.m128d_f64[0], 0.1);\n        do {\n          v14 = *((double *)u + v13);\n          v15 = v13++;\n          libmin_printf(\"u[%d] = %.2f\\n\", v15, v14);\n        } while (v13 != 100);\n        v16 = 0.0;\n        do {\n          v17 = *v4;\n          v4 += 2;\n          v16 = v16 + v17 + *(v4 - 1);\n        } while (v4 != u_new);\n        libmin_printf(\"Checksum: %.2f\\n\", v16);\n        libtarg_success();\n      }\n    }\n    ++v3;\n  }\n}", "binary": "heat-calc/heat-calc.host.O3", "assembly": "<main>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x658,%rsp\nmovsd  0x2f3f(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x648(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbx\njmp    1143 <main+0x43>\nmovq   $0x0,(%rbx,%rax,8)\ncmp    $0x63,%rax\nje     1154 <main+0x54>\nadd    $0x1,%rax\ncmp    $0x32,%rax\njne    1131 <main+0x31>\nmovsd  %xmm0,0x190(%rsp)\njmp    113f <main+0x3f>\nmovapd 0x2f04(%rip),%xmm4\nmov    $0x1f4,%r9d\nlea    0x320(%rsp),%rbp\nlea    0x328(%rsp),%r11\nlea    0x8(%rsp),%r10\nlea    0x638(%rsp),%r8\nmovapd (%rsp),%xmm2\nmov    %r11,%rdx\nmov    %r10,%rax\nnopw   0x0(%rax,%rax,1)\nmovupd (%rax),%xmm1\nadd    $0x10,%rdx\nadd    $0x10,%rax\nmovapd %xmm1,%xmm3\naddpd  %xmm1,%xmm3\nsubpd  %xmm3,%xmm2\nmovapd %xmm2,%xmm0\nmovapd -0x8(%rax),%xmm2\naddpd  %xmm2,%xmm0\nmulpd  %xmm4,%xmm0\naddpd  %xmm1,%xmm0\nmovups %xmm0,-0x10(%rdx)\ncmp    %rdx,%r8\njne    1190 <main+0x90>\nmovsd  (%rsp),%xmm0\nmov    $0x64,%ecx\nmov    %rbx,%rdi\nmov    %rbp,%rsi\nmovsd  %xmm0,0x320(%rsp)\nmovsd  0x318(%rsp),%xmm0\nmovsd  %xmm0,0x638(%rsp)\nrep movsq %ds:(%rsi),%es:(%rdi)\nsub    $0x1,%r9d\njne    117f <main+0x7f>\nlea    0x2e07(%rip),%rdi\nxor    %eax,%eax\nxor    %r12d,%r12d\ncall   3430 <libmin_printf>\nlea    0x2e25(%rip),%r13\nmovsd  (%rbx,%r12,8),%xmm0\nmov    %r12d,%esi\nmov    %r13,%rdi\nmov    $0x1,%eax\nadd    $0x1,%r12\ncall   3430 <libmin_printf>\ncmp    $0x64,%r12\njne    1212 <main+0x112>\npxor   %xmm0,%xmm0\nmovsd  (%rbx),%xmm1\nadd    $0x10,%rbx\naddsd  %xmm1,%xmm0\nmovsd  -0x8(%rbx),%xmm1\naddsd  %xmm1,%xmm0\ncmp    %rbp,%rbx\njne    1236 <main+0x136>\nlea    0x2dee(%rip),%rdi\nmov    $0x1,%eax\ncall   3430 <libmin_printf>\ncall   1360 <libtarg_success>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "buildHuffmanTree", "content": "// Build Huffman Tree and return its root\nHuffmanNode* buildHuffmanTree(char data[], int freq[], int size) {\n    HuffmanNode *left, *right, *top;\n    MinHeap* minHeap = createAndBuildMinHeap(data, freq, size);\n    \n    while (!isSizeOne(minHeap)) {\n        left = extractMin(minHeap);\n        right = extractMin(minHeap);\n        \n        top = createNode('$', left->freq + right->freq);\n        top->left = left;\n        top->right = right;\n        \n        insertMinHeap(minHeap, top);\n    }\n    return extractMin(minHeap);\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "buildHuffmanTree", "address": "0x18b0", "label": "buildHuffmanTree", "content": "HuffmanNode *__fastcall buildHuffmanTree(char *data, int *freq, int size)\n{\n  MinHeap *v3; // rax\n  int v4; // r13d\n  MinHeap *v5; // r12\n  HuffmanNode **array; // rbx\n  HuffmanNode *v7; // r14\n  __m128i v8; // xmm0\n  HuffmanNode *v9; // r15\n  int v10; // ebp\n  char *v11; // rax\n  __m128i si128; // xmm0\n  HuffmanNode *v13; // r14\n  int v14; // eax\n  HuffmanNode **v15; // rdx\n  unsigned __int64 v16; // rcx\n  __m128i v18[4]; // [rsp+0h] [rbp-48h] BYREF\n\n  v3 = createAndBuildMinHeap(data, freq, size);\n  v4 = v3->size;\n  v5 = v3;\n  if ( v3->size == 1 )\n  {\n    v13 = *v3->array;\n  }\n  else\n  {\n    array = v3->array;\nLABEL_3:\n    while ( 1 )\n    {\n      v7 = *array;\n      v8 = (__m128i)(unsigned __int64)*array;\n      *array = array[v4 - 1];\n      v5->size = v4 - 1;\n      minHeapify(v5, 0);\n      v9 = *array;\n      *array = array[v4 - 2];\n      v5->size = v4 - 2;\n      v18[0] = _mm_unpacklo_epi64(v8, (__m128i)(unsigned __int64)v9);\n      minHeapify(v5, 0);\n      v10 = v7->freq + v9->freq;\n      v11 = (char *)libmin_malloc(0x18uLL);\n      si128 = _mm_load_si128(v18);\n      *v11 = 36;\n      v13 = (HuffmanNode *)v11;\n      *((_DWORD *)v11 + 1) = v10;\n      *(__m128i *)(v11 + 8) = si128;\n      v14 = v5->size;\n      v4 = v5->size + 1;\n      v5->size = v4;\n      if ( !v14 )\n        break;\n      array = v5->array;\n      do\n      {\n        v15 = &array[v14];\n        v14 = (v14 - 1) / 2;\n        v16 = (unsigned __int64)array[v14];\n        if ( v10 >= *(_DWORD *)(v16 + 4) )\n        {\n          *v15 = v13;\n          goto LABEL_3;\n        }\n        *v15 = (HuffmanNode *)v16;\n      }\n      while ( v14 );\n      *array = v13;\n    }\n    *v5->array = v13;\n  }\n  v5->size = 0;\n  minHeapify(v5, 0);\n  return v13;\n}\n"}, "pseudo_normalize": "HuffmanNode *buildHuffmanTree(char *data, int *freq, int size) {\n  MinHeap *v3;\n  int v4;\n  MinHeap *v5;\n  HuffmanNode **array;\n  HuffmanNode *v7;\n  __m128i v8;\n  HuffmanNode *v9;\n  int v10;\n  char *v11;\n  __m128i si128;\n  HuffmanNode *v13;\n  int v14;\n  HuffmanNode **v15;\n  unsigned long long v16;\n  __m128i v18[4];\n  v3 = createAndBuildMinHeap(data, freq, size);\n  v4 = v3->size;\n  v5 = v3;\n  if (v3->size == 1) {\n    v13 = *v3->array;\n  } else {\n    array = v3->array;\n  LABEL_3:\n    while (1) {\n      v7 = *array;\n      v8 = (__m128i)(unsigned long long)*array;\n      *array = array[v4 - 1];\n      v5->size = v4 - 1;\n      minHeapify(v5, 0);\n      v9 = *array;\n      *array = array[v4 - 2];\n      v5->size = v4 - 2;\n      v18[0] = _mm_unpacklo_epi64(v8, (__m128i)(unsigned long long)v9);\n      minHeapify(v5, 0);\n      v10 = v7->freq + v9->freq;\n      v11 = (char *)libmin_malloc(24uLL);\n      si128 = _mm_load_si128(v18);\n      *v11 = 36;\n      v13 = (HuffmanNode *)v11;\n      *((uint32_t *)v11 + 1) = v10;\n      *(__m128i *)(v11 + 8) = si128;\n      v14 = v5->size;\n      v4 = v5->size + 1;\n      v5->size = v4;\n      if (!v14) break;\n      array = v5->array;\n      do {\n        v15 = &array[v14];\n        v14 = (v14 - 1) / 2;\n        v16 = (unsigned long long)array[v14];\n        if (v10 >= *(uint32_t *)(v16 + 4)) {\n          *v15 = v13;\n          goto LABEL_3;\n        }\n        *v15 = (HuffmanNode *)v16;\n      } while (v14);\n      *array = v13;\n    }\n    *v5->array = v13;\n  }\n  v5->size = 0;\n  minHeapify(v5, 0);\n  return v13;\n}", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<buildHuffmanTree>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   17b0 <createAndBuildMinHeap>\nmov    (%rax),%r13d\nmov    %rax,%r12\ncmp    $0x1,%r13d\nje     19d7 <buildHuffmanTree+0x127>\nmov    0x8(%rax),%rbx\nnopl   0x0(%rax,%rax,1)\nmovslq %r13d,%rax\nlea    -0x1(%r13),%ebp\nmov    (%rbx),%r14\nxor    %esi,%esi\nmov    -0x8(%rbx,%rax,8),%rax\nmov    %r12,%rdi\nsub    $0x2,%r13d\nmovq   %r14,%xmm0\nmov    %rax,(%rbx)\nmov    %ebp,(%r12)\nmovslq %ebp,%rbp\ncall   1640 <minHeapify>\nmov    -0x8(%rbx,%rbp,8),%rax\nmov    (%rbx),%r15\nxor    %esi,%esi\nmov    %r12,%rdi\nmov    %rax,(%rbx)\nmovq   %r15,%xmm1\nmov    %r13d,(%r12)\npunpcklqdq %xmm1,%xmm0\nmovaps %xmm0,(%rsp)\ncall   1640 <minHeapify>\nmov    $0x18,%edi\nmov    0x4(%r15),%ebp\nadd    0x4(%r14),%ebp\ncall   2810 <libmin_malloc>\nmovdqa (%rsp),%xmm0\nmovb   $0x24,(%rax)\nmov    %rax,%r14\nmov    %ebp,0x4(%rax)\nmovups %xmm0,0x8(%rax)\nmov    (%r12),%eax\nlea    0x1(%rax),%r13d\nmov    %r13d,(%r12)\ntest   %eax,%eax\nje     19ab <buildHuffmanTree+0xfb>\nmov    0x8(%r12),%rbx\njmp    1977 <buildHuffmanTree+0xc7>\nnopl   (%rax)\nmov    %rcx,(%rdx)\ntest   %eax,%eax\nje     19a0 <buildHuffmanTree+0xf0>\nmovslq %eax,%rdx\nlea    -0x1(%rdx),%ecx\nlea    (%rbx,%rdx,8),%rdx\nmov    %ecx,%eax\nshr    $0x1f,%eax\nadd    %ecx,%eax\nsar    %eax\nmovslq %eax,%rcx\nmov    (%rbx,%rcx,8),%rcx\ncmp    0x4(%rcx),%ebp\njl     1970 <buildHuffmanTree+0xc0>\nmov    %r14,(%rdx)\njmp    18e0 <buildHuffmanTree+0x30>\nxchg   %ax,%ax\nmov    %rbx,%rdx\nmov    %r14,(%rdx)\njmp    18e0 <buildHuffmanTree+0x30>\nmov    0x8(%r12),%rax\nmov    %r14,(%rax)\nmovl   $0x0,(%r12)\nmov    %r12,%rdi\nxor    %esi,%esi\ncall   1640 <minHeapify>\nadd    $0x18,%rsp\nmov    %r14,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    0x8(%rax),%rax\nmov    (%rax),%r14\njmp    19b3 <buildHuffmanTree+0x103>\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "buildMinHeap", "content": "// Build the min-heap\nvoid buildMinHeap(MinHeap* minHeap) {\n    int n = minHeap->size;\n    for (int i = (n - 1) / 2; i >= 0; i--)\n        minHeapify(minHeap, i);\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "buildMinHeap", "address": "0x1770", "label": "buildMinHeap", "content": "void __fastcall buildMinHeap(MinHeap *minHeap)\n{\n  int v1; // ebx\n\n  v1 = (minHeap->size - 1) / 2;\n  if ( minHeap->size >= 0 )\n  {\n    do\n      minHeapify(minHeap, v1);\n    while ( v1-- != 0 );\n  }\n}\n"}, "pseudo_normalize": "void buildMinHeap(MinHeap *minHeap) {\n  int v1;\n  v1 = (minHeap->size - 1) / 2;\n  if (minHeap->size >= 0) {\n    do minHeapify(minHeap, v1);\n    while (v1-- != 0);\n  }\n}", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<buildMinHeap>:\nendbr64\npush   %rbp\npush   %rbx\nmov    (%rdi),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,%ebx\nshr    $0x1f,%ebx\nadd    %edx,%ebx\nsar    %ebx\ntest   %eax,%eax\njs     179f <buildMinHeap+0x2f>\nmov    %rdi,%rbp\nnopl   0x0(%rax,%rax,1)\nmov    %ebx,%esi\nmov    %rbp,%rdi\ncall   1640 <minHeapify>\nsub    $0x1,%ebx\njae    1790 <buildMinHeap+0x20>\npop    %rbx\npop    %rbp\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "createAndBuildMinHeap", "content": "// Create and build min-heap from given characters and their frequencies\nMinHeap* createAndBuildMinHeap(char data[], int freq[], int size) {\n    MinHeap* minHeap = createMinHeap(size);\n    for (int i = 0; i < size; i++) {\n        minHeap->array[i] = createNode(data[i], freq[i]);\n    }\n    minHeap->size = size;\n    buildMinHeap(minHeap);\n    return minHeap;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "createAndBuildMinHeap", "address": "0x17b0", "label": "createAndBuildMinHeap", "content": "MinHeap *__fastcall createAndBuildMinHeap(char *data, int *freq, int size)\n{\n  MinHeap *v4; // rax\n  MinHeap *v5; // r12\n  HuffmanNode **array; // rax\n  int v7; // r14d\n  __int64 v8; // r15\n  HuffmanNode **v9; // r13\n  int v10; // ebx\n  char v11; // bp\n  char *v12; // rax\n  __int64 v15; // [rsp+10h] [rbp-48h]\n\n  v4 = (MinHeap *)libmin_malloc(0x10uLL);\n  v4->size = 0;\n  v5 = v4;\n  v4->capacity = size;\n  v15 = size;\n  array = (HuffmanNode **)libmin_malloc(8LL * size);\n  v5->array = array;\n  v7 = (size - 1) / 2;\n  if ( size <= 0 )\n  {\n    v5->size = size;\n    if ( size )\n      return v5;\n  }\n  else\n  {\n    v8 = 0LL;\n    while ( 1 )\n    {\n      v9 = &array[v8];\n      v10 = freq[v8];\n      v11 = data[v8++];\n      v12 = (char *)libmin_malloc(0x18uLL);\n      *v12 = v11;\n      *((_DWORD *)v12 + 1) = v10;\n      *(_OWORD *)(v12 + 8) = 0LL;\n      *v9 = (HuffmanNode *)v12;\n      if ( v8 == v15 )\n        break;\n      array = v5->array;\n    }\n    v5->size = size;\n  }\n  do\n    minHeapify(v5, v7);\n  while ( v7-- != 0 );\n  return v5;\n}\n"}, "pseudo_normalize": "MinHeap *createAndBuildMinHeap(char *data, int *freq, int size) {\n  MinHeap *v4;\n  MinHeap *v5;\n  HuffmanNode **array;\n  int v7;\n  long long v8;\n  HuffmanNode **v9;\n  int v10;\n  char v11;\n  char *v12;\n  long long v15;\n  v4 = (MinHeap *)libmin_malloc(16uLL);\n  v4->size = 0;\n  v5 = v4;\n  v4->capacity = size;\n  v15 = size;\n  array = (HuffmanNode **)libmin_malloc(8LL * size);\n  v5->array = array;\n  v7 = (size - 1) / 2;\n  if (size <= 0) {\n    v5->size = size;\n    if (size) return v5;\n  } else {\n    v8 = 0LL;\n    while (1) {\n      v9 = &array[v8];\n      v10 = freq[v8];\n      v11 = data[v8++];\n      v12 = (char *)libmin_malloc(24uLL);\n      *v12 = v11;\n      *((uint32_t *)v12 + 1) = v10;\n      *(long double *)(v12 + 8) = 0LL;\n      *v9 = (HuffmanNode *)v12;\n      if (v8 == v15) break;\n      array = v5->array;\n    }\n    v5->size = size;\n  }\n  do minHeapify(v5, v7);\n  while (v7-- != 0);\n  return v5;\n}", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<createAndBuildMinHeap>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edx,%ebx\nsub    $0x28,%rsp\nmov    %rdi,(%rsp)\nmov    $0x10,%edi\nmov    %edx,0x1c(%rsp)\nmov    %rsi,0x8(%rsp)\ncall   2810 <libmin_malloc>\nmovl   $0x0,(%rax)\nmov    %rax,%r12\nmov    %ebx,0x4(%rax)\nmovslq %ebx,%rax\nlea    0x0(,%rax,8),%rdi\nmov    %rax,0x10(%rsp)\ncall   2810 <libmin_malloc>\nlea    -0x1(%rbx),%ecx\nmov    %ecx,%edx\nmov    %rax,0x8(%r12)\nshr    $0x1f,%edx\nadd    %ecx,%edx\nsar    %edx\nmov    %edx,%r14d\ntest   %ebx,%ebx\njle    1898 <createAndBuildMinHeap+0xe8>\nxor    %r15d,%r15d\njmp    1825 <createAndBuildMinHeap+0x75>\nnopl   (%rax)\nmov    0x8(%r12),%rax\nmov    0x8(%rsp),%rcx\nmov    (%rsp),%rdx\nmov    $0x18,%edi\nlea    (%rax,%r15,8),%r13\nmov    (%rcx,%r15,4),%ebx\nmovzbl (%rdx,%r15,1),%ebp\nadd    $0x1,%r15\ncall   2810 <libmin_malloc>\npxor   %xmm0,%xmm0\nmov    %bpl,(%rax)\nmov    %ebx,0x4(%rax)\nmovups %xmm0,0x8(%rax)\nmov    %rax,0x0(%r13)\ncmp    0x10(%rsp),%r15\njne    1820 <createAndBuildMinHeap+0x70>\nmov    0x1c(%rsp),%eax\nmov    %eax,(%r12)\nnopw   0x0(%rax,%rax,1)\nmov    %r14d,%esi\nmov    %r12,%rdi\ncall   1640 <minHeapify>\nsub    $0x1,%r14d\njae    1870 <createAndBuildMinHeap+0xc0>\nadd    $0x28,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    0x1c(%rsp),%eax\nmov    %eax,(%r12)\njne    1881 <createAndBuildMinHeap+0xd1>\njmp    1870 <createAndBuildMinHeap+0xc0>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "createMinHeap", "content": "// Function to create a min-heap of given capacity\nMinHeap* createMinHeap(int capacity) {\n    MinHeap* minHeap = (MinHeap*)libmin_malloc(sizeof(MinHeap));\n    minHeap->size = 0;\n    minHeap->capacity = capacity;\n    minHeap->array = (HuffmanNode**)libmin_malloc(capacity * sizeof(HuffmanNode*));\n    return minHeap;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "createMinHeap", "address": "0x15e0", "label": "createMinHeap", "content": "MinHeap *__fastcall createMinHeap(int capacity)\n{\n  MinHeap *v1; // rax\n  MinHeap *v2; // r12\n\n  v1 = (MinHeap *)libmin_malloc(0x10uLL);\n  v1->capacity = capacity;\n  v2 = v1;\n  v1->size = 0;\n  v1->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return v2;\n}\n"}, "pseudo_normalize": "MinHeap *createMinHeap(int capacity) {\n  MinHeap *v1;\n  MinHeap *v2;\n  v1 = (MinHeap *)libmin_malloc(16uLL);\n  v1->capacity = capacity;\n  v2 = v1;\n  v1->size = 0;\n  v1->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return v2;\n}", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<createMinHeap>:\nendbr64\npush   %r12\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\nsub    $0x8,%rsp\ncall   2810 <libmin_malloc>\nmovslq %ebx,%rdi\nmov    %ebx,0x4(%rax)\nshl    $0x3,%rdi\nmov    %rax,%r12\nmovl   $0x0,(%rax)\ncall   2810 <libmin_malloc>\nmov    %rax,0x8(%r12)\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %r12\nret\nnop\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "createNode", "content": "// Function to create a new Huffman node\nHuffmanNode* createNode(char data, int freq) {\n    HuffmanNode* node = (HuffmanNode*)libmin_malloc(sizeof(HuffmanNode));\n    node->data = data;\n    node->freq = freq;\n    node->left = node->right = NULL;\n    return node;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "createNode", "address": "0x15b0", "label": "createNode", "content": "HuffmanNode *__fastcall createNode(char data, int freq)\n{\n  HuffmanNode *result; // rax\n\n  result = (HuffmanNode *)libmin_malloc(0x18uLL);\n  result->data = data;\n  result->freq = freq;\n  *(_OWORD *)&result->left = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "HuffmanNode *createNode(char data, int freq) {\n  HuffmanNode *result;\n  result = (HuffmanNode *)libmin_malloc(24uLL);\n  result->data = data;\n  result->freq = freq;\n  *(long double *)&result->left = 0LL;\n  return result;\n}", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<createNode>:\nendbr64\npush   %rbp\nmov    %edi,%ebp\nmov    $0x18,%edi\npush   %rbx\nmov    %esi,%ebx\nsub    $0x8,%rsp\ncall   2810 <libmin_malloc>\npxor   %xmm0,%xmm0\nmov    %bpl,(%rax)\nmov    %ebx,0x4(%rax)\nmovups %xmm0,0x8(%rax)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   (%rax)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "decodeString", "content": "// Decode the encoded bit string using the Huffman tree\nvoid decodeString(HuffmanNode* root, const char* encoded, char* decoded) {\n    int idx = 0, out_idx = 0;\n    HuffmanNode* curr = root;\n    while (encoded[idx]) {\n        if (encoded[idx] == '0')\n            curr = curr->left;\n        else\n            curr = curr->right;\n        \n        // If leaf node, record the character and restart from tree root\n        if (!curr->left && !curr->right) {\n            decoded[out_idx++] = curr->data;\n            curr = root;\n        }\n        idx++;\n    }\n    decoded[out_idx] = '\\0';\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "decodeString", "address": "0x25b0", "label": "decodeString", "content": "void __fastcall decodeString(HuffmanNode *root, const char *encoded, char *decoded)\n{\n  char v3; // cl\n  const char *v4; // rsi\n  HuffmanNode *v5; // rax\n  int v6; // r9d\n  HuffmanNode *left; // r8\n  __int64 v8; // rax\n\n  v3 = *encoded;\n  if ( *encoded )\n  {\n    v4 = encoded + 1;\n    v5 = root;\n    v6 = 0;\n    do\n    {\n      while ( 1 )\n      {\n        left = v5->left;\n        if ( v3 != 48 )\n          left = v5->right;\n        v5 = left;\n        if ( !left->left && !left->right )\n          break;\n        v3 = *v4++;\n        if ( !v3 )\n          goto LABEL_9;\n      }\n      v8 = v6;\n      ++v4;\n      ++v6;\n      decoded[v8] = left->data;\n      v3 = *(v4 - 1);\n      v5 = root;\n    }\n    while ( v3 );\nLABEL_9:\n    decoded += v6;\n  }\n  *decoded = 0;\n}\n"}, "pseudo_normalize": "void decodeString(HuffmanNode *root, const char *encoded, char *decoded) {\n  char v3;\n  const char *v4;\n  HuffmanNode *v5;\n  int v6;\n  HuffmanNode *left;\n  long long v8;\n  v3 = *encoded;\n  if (*encoded) {\n    v4 = encoded + 1;\n    v5 = root;\n    v6 = 0;\n    do {\n      while (1) {\n        left = v5->left;\n        if (v3 != 48) left = v5->right;\n        v5 = left;\n        if (!left->left && !left->right) break;\n        v3 = *v4++;\n        if (!v3) goto LABEL_9;\n      }\n      v8 = v6;\n      ++v4;\n      ++v6;\n      decoded[v8] = left->data;\n      v3 = *(v4 - 1);\n      v5 = root;\n    } while (v3);\n  LABEL_9:\n    decoded += v6;\n  }\n  *decoded = 0;\n}", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<decodeString>:\nendbr64\nmovzbl (%rsi),%ecx\ntest   %cl,%cl\nje     261e <decodeString+0x6e>\nadd    $0x1,%rsi\nmov    %rdi,%rax\nxor    %r9d,%r9d\njmp    25db <decodeString+0x2b>\nnopw   0x0(%rax,%rax,1)\nmovzbl (%rsi),%ecx\nadd    $0x1,%rsi\ntest   %cl,%cl\nje     2618 <decodeString+0x68>\nmov    0x8(%rax),%r8\ncmp    $0x30,%cl\ncmovne 0x10(%rax),%r8\ncmpq   $0x0,0x8(%r8)\nmov    %r8,%rax\njne    25d0 <decodeString+0x20>\ncmpq   $0x0,0x10(%r8)\njne    25d0 <decodeString+0x20>\nmovzbl (%r8),%ecx\nmovslq %r9d,%rax\nadd    $0x1,%rsi\nadd    $0x1,%r9d\nmov    %cl,(%rdx,%rax,1)\nmovzbl -0x1(%rsi),%ecx\nmov    %rdi,%rax\ntest   %cl,%cl\njne    25db <decodeString+0x2b>\nnopl   (%rax)\nmovslq %r9d,%r9\nadd    %r9,%rdx\nmovb   $0x0,(%rdx)\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "encodeString", "content": "// Encode the input string using the generated Huffman codes\nvoid encodeString(const char* input, char codes[][MAX_TREE_HT], char* encoded) {\n    encoded[0] = '\\0';\n    for (int i = 0; input[i]; i++) {\n        libmin_strcat(encoded, codes[(unsigned char)input[i]]);\n    }\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "encodeString", "address": "0x2560", "label": "encodeString", "content": "void __fastcall encodeString(const char *input, char (*codes)[256], char *encoded)\n{\n  __int64 v4; // rsi\n  const char *v6; // r12\n\n  *encoded = 0;\n  v4 = *(unsigned __int8 *)input;\n  if ( (_BYTE)v4 )\n  {\n    v6 = input + 1;\n    do\n    {\n      ++v6;\n      libmin_strcat(encoded, &(*codes)[256 * v4]);\n      v4 = *((unsigned __int8 *)v6 - 1);\n    }\n    while ( (_BYTE)v4 );\n  }\n}\n"}, "pseudo_normalize": "void encodeString(const char *input, char (*codes)[256], char *encoded) {\n  long long v4;\n  const char *v6;\n  *encoded = 0;\n  v4 = *(unsigned char *)input;\n  if ((uint8_t)v4) {\n    v6 = input + 1;\n    do {\n      ++v6;\n      libmin_strcat(encoded, &(*codes)[256 * v4]);\n      v4 = *((unsigned char *)v6 - 1);\n    } while ((uint8_t)v4);\n  }\n}", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<encodeString>:\nendbr64\npush   %r12\nmovb   $0x0,(%rdx)\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmovzbl (%rdi),%esi\ntest   %sil,%sil\nje     259e <encodeString+0x3e>\nmov    %rdx,%rbx\nlea    0x1(%rdi),%r12\nnopl   (%rax)\nshl    $0x8,%rsi\nmov    %rbx,%rdi\nadd    $0x1,%r12\nadd    %rbp,%rsi\ncall   4d60 <libmin_strcat>\nmovzbl -0x1(%r12),%esi\ntest   %sil,%sil\njne    2580 <encodeString+0x20>\npop    %rbx\npop    %rbp\npop    %r12\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "extractMin", "content": "// Extract minimum node from heap\nHuffmanNode* extractMin(MinHeap* minHeap) {\n    HuffmanNode* temp = minHeap->array[0];\n    minHeap->array[0] = minHeap->array[minHeap->size - 1];\n    minHeap->size--;\n    minHeapify(minHeap, 0);\n    return temp;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "extractMin", "address": "0x16f0", "label": "extractMin", "content": "HuffmanNode *__fastcall extractMin(MinHeap *minHeap)\n{\n  HuffmanNode **array; // rdx\n  HuffmanNode *v2; // r12\n  int v3; // eax\n\n  array = minHeap->array;\n  v2 = *array;\n  v3 = minHeap->size - 1;\n  *array = array[minHeap->size - 1];\n  minHeap->size = v3;\n  minHeapify(minHeap, 0);\n  return v2;\n}\n"}, "pseudo_normalize": "HuffmanNode *extractMin(MinHeap *minHeap) {\n  HuffmanNode **array;\n  HuffmanNode *v2;\n  int v3;\n  array = minHeap->array;\n  v2 = *array;\n  v3 = minHeap->size - 1;\n  *array = array[minHeap->size - 1];\n  minHeap->size = v3;\n  minHeapify(minHeap, 0);\n  return v2;\n}", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<extractMin>:\nendbr64\nmovslq (%rdi),%rcx\nmov    0x8(%rdi),%rdx\npush   %r12\nxor    %esi,%esi\nmov    %rcx,%rax\nmov    -0x8(%rdx,%rcx,8),%rcx\nmov    (%rdx),%r12\nsub    $0x1,%eax\nmov    %rcx,(%rdx)\nmov    %eax,(%rdi)\ncall   1640 <minHeapify>\nmov    %r12,%rax\npop    %r12\nret\nnopl   (%rax)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "generateCodes", "content": "// Recursively generate Huffman codes and store them in codes array\n// codes[c] will store the Huffman code (a string of '0's and '1's) for character c.\nvoid generateCodes(HuffmanNode* root, char arr[], int top, char codes[][MAX_TREE_HT]) {\n    if (root->left) {\n        arr[top] = '0';\n        generateCodes(root->left, arr, top + 1, codes);\n    }\n    if (root->right) {\n        arr[top] = '1';\n        generateCodes(root->right, arr, top + 1, codes);\n    }\n    // If node is a leaf, store the code\n    if (!root->left && !root->right) {\n        arr[top] = '\\0';\n        libmin_strcpy(codes[(unsigned char)root->data], arr);\n    }\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "generateCodes", "address": "0x19e0", "label": "generateCodes", "content": "void __fastcall generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256])\n{\n  int v5; // r9d\n  HuffmanNode *left; // r13\n  int v7; // r10d\n  HuffmanNode *v8; // r15\n  __int64 v9; // r14\n  char *v10; // rax\n  int v11; // edx\n  __int64 v12; // r8\n  __int64 v13; // r14\n  char *p_data; // rax\n  int v15; // edx\n  char *v16; // r8\n  int v17; // r10d\n  HuffmanNode *right; // r15\n  __int64 v19; // r14\n  char *v20; // rax\n  int v21; // edx\n  __int64 v22; // r9\n  __int64 v23; // r14\n  char *v24; // rax\n  int v25; // edx\n  __int64 v26; // r14\n  int v27; // r9d\n  HuffmanNode *v28; // r13\n  int v29; // r11d\n  HuffmanNode *v30; // r8\n  __int64 v31; // r15\n  char *v32; // rax\n  int v33; // edx\n  __int64 v34; // r10\n  __int64 v35; // r15\n  char *v36; // rax\n  int v37; // edx\n  char *v38; // r10\n  int v39; // r9d\n  HuffmanNode *v40; // r8\n  char *v41; // rax\n  __int64 v42; // r15\n  int v43; // edx\n  __int64 v44; // r15\n  int v45; // [rsp+0h] [rbp-68h]\n  char *v46; // [rsp+0h] [rbp-68h]\n  char *v47; // [rsp+0h] [rbp-68h]\n  char *v48; // [rsp+0h] [rbp-68h]\n  char *v49; // [rsp+0h] [rbp-68h]\n  char *v50; // [rsp+0h] [rbp-68h]\n  char *v51; // [rsp+0h] [rbp-68h]\n  char *v52; // [rsp+0h] [rbp-68h]\n  char *v53; // [rsp+0h] [rbp-68h]\n  char *v54; // [rsp+0h] [rbp-68h]\n  char *v55; // [rsp+0h] [rbp-68h]\n  char *v56; // [rsp+0h] [rbp-68h]\n  char *v57; // [rsp+0h] [rbp-68h]\n  char *v58; // [rsp+0h] [rbp-68h]\n  char *v59; // [rsp+0h] [rbp-68h]\n  char *v60; // [rsp+0h] [rbp-68h]\n  char *v61; // [rsp+0h] [rbp-68h]\n  char *v62; // [rsp+0h] [rbp-68h]\n  char *v63; // [rsp+0h] [rbp-68h]\n  char *v64; // [rsp+0h] [rbp-68h]\n  char *v65; // [rsp+0h] [rbp-68h]\n  char *v66; // [rsp+0h] [rbp-68h]\n  char *codesa; // [rsp+8h] [rbp-60h]\n  char *codesb; // [rsp+8h] [rbp-60h]\n  char *codesc; // [rsp+8h] [rbp-60h]\n  char *codesd; // [rsp+8h] [rbp-60h]\n  char *codese; // [rsp+8h] [rbp-60h]\n  char *codesf; // [rsp+8h] [rbp-60h]\n  char *codesg; // [rsp+8h] [rbp-60h]\n  char *codesh; // [rsp+8h] [rbp-60h]\n  int codesi; // [rsp+8h] [rbp-60h]\n  char *codesj; // [rsp+8h] [rbp-60h]\n  int codesk; // [rsp+8h] [rbp-60h]\n  char *codesl; // [rsp+8h] [rbp-60h]\n  char *codesm; // [rsp+8h] [rbp-60h]\n  int codesn; // [rsp+8h] [rbp-60h]\n  char *codeso; // [rsp+8h] [rbp-60h]\n  int codesp; // [rsp+8h] [rbp-60h]\n  char *codesq; // [rsp+8h] [rbp-60h]\n  int codesr; // [rsp+8h] [rbp-60h]\n  char *codess; // [rsp+8h] [rbp-60h]\n  int codest; // [rsp+8h] [rbp-60h]\n  char *codesu; // [rsp+8h] [rbp-60h]\n  int codesv; // [rsp+8h] [rbp-60h]\n  char *codesw; // [rsp+8h] [rbp-60h]\n  char *codesx; // [rsp+8h] [rbp-60h]\n  char *codesy; // [rsp+8h] [rbp-60h]\n  int codesz; // [rsp+8h] [rbp-60h]\n  char *v93; // [rsp+10h] [rbp-58h]\n  char *v94; // [rsp+10h] [rbp-58h]\n  char *v95; // [rsp+10h] [rbp-58h]\n  char *v96; // [rsp+10h] [rbp-58h]\n  char *v97; // [rsp+10h] [rbp-58h]\n  char *v98; // [rsp+10h] [rbp-58h]\n  char *v99; // [rsp+10h] [rbp-58h]\n  char *v100; // [rsp+10h] [rbp-58h]\n  int v101; // [rsp+10h] [rbp-58h]\n  HuffmanNode *v102; // [rsp+10h] [rbp-58h]\n  int v103; // [rsp+10h] [rbp-58h]\n  int v104; // [rsp+10h] [rbp-58h]\n  int v105; // [rsp+10h] [rbp-58h]\n  __int64 v106; // [rsp+10h] [rbp-58h]\n  int v107; // [rsp+10h] [rbp-58h]\n  char *v108; // [rsp+10h] [rbp-58h]\n  int v109; // [rsp+10h] [rbp-58h]\n  int v110; // [rsp+10h] [rbp-58h]\n  char *v111; // [rsp+10h] [rbp-58h]\n  __int64 v112; // [rsp+10h] [rbp-58h]\n  int v113; // [rsp+10h] [rbp-58h]\n  HuffmanNode *v114; // [rsp+10h] [rbp-58h]\n  int v115; // [rsp+18h] [rbp-50h]\n  int v116; // [rsp+18h] [rbp-50h]\n  char *v117; // [rsp+18h] [rbp-50h]\n  int v118; // [rsp+18h] [rbp-50h]\n  HuffmanNode *v119; // [rsp+18h] [rbp-50h]\n  __int64 v120; // [rsp+18h] [rbp-50h]\n  int v121; // [rsp+18h] [rbp-50h]\n  HuffmanNode *v122; // [rsp+18h] [rbp-50h]\n  __int64 v123; // [rsp+18h] [rbp-50h]\n  char *v124; // [rsp+18h] [rbp-50h]\n  int v125; // [rsp+18h] [rbp-50h]\n  __int64 v126; // [rsp+18h] [rbp-50h]\n  HuffmanNode *v127; // [rsp+18h] [rbp-50h]\n  char *v128; // [rsp+18h] [rbp-50h]\n  int v129; // [rsp+20h] [rbp-48h]\n  __int64 v130; // [rsp+20h] [rbp-48h]\n  char *v131; // [rsp+20h] [rbp-48h]\n  __int64 v132; // [rsp+20h] [rbp-48h]\n  HuffmanNode *v133; // [rsp+20h] [rbp-48h]\n  HuffmanNode *v134; // [rsp+20h] [rbp-48h]\n  __int64 v135; // [rsp+20h] [rbp-48h]\n  HuffmanNode *v136; // [rsp+20h] [rbp-48h]\n  char *v137; // [rsp+20h] [rbp-48h]\n  HuffmanNode *v138; // [rsp+28h] [rbp-40h]\n  __int64 v139; // [rsp+28h] [rbp-40h]\n  char *v140; // [rsp+28h] [rbp-40h]\n\n  if ( root->left )\n  {\n    v5 = top + 1;\n    arr[top] = 48;\n    left = root->left;\n    if ( !left->left )\n      goto LABEL_13;\n    v7 = top + 2;\n    arr[v5] = 48;\n    v8 = left->left;\n    if ( !v8->left )\n    {\nLABEL_7:\n      if ( !v8->right )\n      {\n        v12 = v7;\n        if ( v8->left )\n          goto LABEL_13;\n        goto LABEL_61;\n      }\n      v12 = v7;\n      LODWORD(v13) = top + 3;\n      arr[v7] = 49;\n      p_data = &v8->right->data;\n      if ( *((_QWORD *)p_data + 1) )\n      {\n        v13 = (int)v13;\n        v130 = v7;\n        arr[(int)v13] = 48;\n        v116 = v5;\n        v94 = p_data;\n        codesb = (char *)codes;\n        generateCodes(*((HuffmanNode **)p_data + 1), arr, top + 4, codes);\n        p_data = v94;\n        v15 = top + 4;\n        codes = (char (*)[256])codesb;\n        v5 = v116;\n        v12 = v130;\n        if ( !*((_QWORD *)v94 + 2) )\n        {\n          if ( *((_QWORD *)v94 + 1) )\n          {\nLABEL_11:\n            if ( v8->left || v8->right )\n            {\nLABEL_13:\n              if ( !left->right )\n              {\n                v16 = (char *)v5;\n                if ( left->left )\n                  goto LABEL_25;\n                goto LABEL_48;\n              }\n              v16 = (char *)v5;\n              v17 = top + 2;\n              arr[v5] = 49;\n              right = left->right;\n              if ( !right->left )\n              {\nLABEL_18:\n                if ( !right->right )\n                {\n                  v22 = v17;\n                  if ( !right->left )\n                  {\nLABEL_63:\n                    arr[v22] = 0;\n                    codesl = v16;\n                    v52 = (char *)codes;\n                    libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)right->data], arr);\n                    v16 = codesl;\n                    codes = (char (*)[256])v52;\n                  }\nLABEL_23:\n                  if ( left->left || left->right )\n                    goto LABEL_25;\nLABEL_48:\n                  v16[(_QWORD)arr] = 0;\n                  v48 = (char *)codes;\n                  libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)left->data], arr);\n                  codes = (char (*)[256])v48;\n                  goto LABEL_25;\n                }\n                v22 = v17;\n                LODWORD(v23) = top + 3;\n                arr[v17] = 49;\n                v24 = &right->right->data;\n                if ( *((_QWORD *)v24 + 1) )\n                {\n                  v23 = (int)v23;\n                  v132 = v17;\n                  arr[(int)v23] = 48;\n                  v117 = v16;\n                  v96 = v24;\n                  codesd = (char *)codes;\n                  generateCodes(*((HuffmanNode **)v24 + 1), arr, top + 4, codes);\n                  v24 = v96;\n                  v25 = top + 4;\n                  codes = (char (*)[256])codesd;\n                  v16 = v117;\n                  v22 = v132;\n                  if ( !*((_QWORD *)v96 + 2) )\n                  {\n                    if ( *((_QWORD *)v96 + 1) )\n                    {\nLABEL_22:\n                      if ( !right->left && !right->right )\n                        goto LABEL_63;\n                      goto LABEL_23;\n                    }\nLABEL_81:\n                    arr[v23] = 0;\n                    v112 = v22;\n                    codesx = v16;\n                    v64 = (char *)codes;\n                    libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)*v24], arr);\n                    v22 = v112;\n                    v16 = codesx;\n                    codes = (char (*)[256])v64;\n                    goto LABEL_22;\n                  }\n                }\n                else\n                {\n                  v25 = top + 4;\n                  v23 = (int)v23;\n                  if ( !*((_QWORD *)v24 + 2) )\n                    goto LABEL_81;\n                }\n                arr[v23] = 49;\n                v126 = v22;\n                v111 = v16;\n                codesw = v24;\n                v63 = (char *)codes;\n                generateCodes(*((HuffmanNode **)v24 + 2), arr, v25, codes);\n                v24 = codesw;\n                codes = (char (*)[256])v63;\n                v16 = v111;\n                v22 = v126;\n                if ( *(_OWORD *)(codesw + 8) != 0LL )\n                  goto LABEL_22;\n                goto LABEL_81;\n              }\n              LODWORD(v19) = top + 3;\n              arr[v17] = 48;\n              v20 = &right->left->data;\n              if ( *((_QWORD *)v20 + 1) )\n              {\n                v19 = (int)v19;\n                v131 = (char *)v5;\n                arr[(int)v19] = 48;\n                v95 = v20;\n                codesc = (char *)codes;\n                generateCodes(*((HuffmanNode **)v20 + 1), arr, top + 4, codes);\n                v20 = v95;\n                v21 = top + 4;\n                codes = (char (*)[256])codesc;\n                v17 = top + 2;\n                v16 = v131;\n                if ( !*((_QWORD *)v95 + 2) )\n                {\n                  if ( *((_QWORD *)v95 + 1) )\n                    goto LABEL_18;\n                  goto LABEL_75;\n                }\n              }\n              else\n              {\n                v21 = top + 4;\n                v19 = (int)v19;\n                if ( !*((_QWORD *)v20 + 2) )\n                {\nLABEL_75:\n                  arr[v19] = 0;\n                  v108 = v16;\n                  codest = v17;\n                  v60 = (char *)codes;\n                  libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)*v20], arr);\n                  v16 = v108;\n                  v17 = codest;\n                  codes = (char (*)[256])v60;\n                  goto LABEL_18;\n                }\n              }\n              arr[v19] = 49;\n              v124 = v16;\n              v107 = v17;\n              codess = v20;\n              v59 = (char *)codes;\n              generateCodes(*((HuffmanNode **)v20 + 2), arr, v21, codes);\n              v20 = codess;\n              codes = (char (*)[256])v59;\n              v17 = v107;\n              v16 = v124;\n              if ( *(_OWORD *)(codess + 8) != 0LL )\n                goto LABEL_18;\n              goto LABEL_75;\n            }\nLABEL_61:\n            arr[v12] = 0;\n            codesk = v5;\n            v51 = (char *)codes;\n            libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)v8->data], arr);\n            v5 = codesk;\n            codes = (char (*)[256])v51;\n            goto LABEL_13;\n          }\nLABEL_72:\n          arr[v13] = 0;\n          v106 = v12;\n          codesr = v5;\n          v58 = (char *)codes;\n          libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)*p_data], arr);\n          v12 = v106;\n          v5 = codesr;\n          codes = (char (*)[256])v58;\n          goto LABEL_11;\n        }\n      }\n      else\n      {\n        v15 = top + 4;\n        v13 = (int)v13;\n        if ( !*((_QWORD *)p_data + 2) )\n          goto LABEL_72;\n      }\n      arr[v13] = 49;\n      v123 = v12;\n      v105 = v5;\n      codesq = p_data;\n      v57 = (char *)codes;\n      generateCodes(*((HuffmanNode **)p_data + 2), arr, v15, codes);\n      p_data = codesq;\n      codes = (char (*)[256])v57;\n      v5 = v105;\n      v12 = v123;\n      if ( *(_OWORD *)(codesq + 8) != 0LL )\n        goto LABEL_11;\n      goto LABEL_72;\n    }\n    LODWORD(v9) = top + 3;\n    arr[v7] = 48;\n    v10 = &v8->left->data;\n    if ( *((_QWORD *)v10 + 1) )\n    {\n      v9 = (int)v9;\n      v129 = top + 2;\n      arr[(int)v9] = 48;\n      v115 = top + 1;\n      v93 = v10;\n      codesa = (char *)codes;\n      v45 = top + 4;\n      generateCodes(*((HuffmanNode **)v10 + 1), arr, top + 4, codes);\n      v10 = v93;\n      v11 = v45;\n      codes = (char (*)[256])codesa;\n      v5 = v115;\n      v7 = v129;\n      if ( !*((_QWORD *)v93 + 2) )\n      {\n        if ( *((_QWORD *)v93 + 1) )\n          goto LABEL_7;\n        goto LABEL_78;\n      }\n    }\n    else\n    {\n      v9 = (int)v9;\n      v11 = top + 4;\n      if ( !*((_QWORD *)v10 + 2) )\n      {\nLABEL_78:\n        arr[v9] = 0;\n        v110 = v7;\n        codesv = v5;\n        v62 = (char *)codes;\n        libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)*v10], arr);\n        v7 = v110;\n        v5 = codesv;\n        codes = (char (*)[256])v62;\n        goto LABEL_7;\n      }\n    }\n    arr[v9] = 49;\n    v125 = v7;\n    v109 = v5;\n    codesu = v10;\n    v61 = (char *)codes;\n    generateCodes(*((HuffmanNode **)v10 + 2), arr, v11, codes);\n    v10 = codesu;\n    codes = (char (*)[256])v61;\n    v5 = v109;\n    v7 = v125;\n    if ( *(_OWORD *)(codesu + 8) != 0LL )\n      goto LABEL_7;\n    goto LABEL_78;\n  }\nLABEL_25:\n  if ( !root->right )\n  {\n    v26 = top;\n    if ( root->left )\n      return;\nLABEL_53:\n    arr[v26] = 0;\n    libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)root->data], arr);\n    return;\n  }\n  v26 = top;\n  v27 = top + 1;\n  arr[top] = 49;\n  v28 = root->right;\n  if ( v28->left )\n  {\n    v29 = top + 2;\n    arr[v27] = 48;\n    v30 = v28->left;\n    if ( !v30->left )\n      goto LABEL_31;\n    LODWORD(v31) = top + 3;\n    arr[v29] = 48;\n    v32 = &v30->left->data;\n    if ( *((_QWORD *)v32 + 1) )\n    {\n      v31 = (int)v31;\n      v138 = v30;\n      arr[(int)v31] = 48;\n      v97 = v32;\n      codese = (char *)codes;\n      generateCodes(*((HuffmanNode **)v32 + 1), arr, top + 4, codes);\n      v32 = v97;\n      v33 = top + 4;\n      codes = (char (*)[256])codese;\n      v27 = top + 1;\n      v29 = top + 2;\n      v30 = v138;\n      if ( !*((_QWORD *)v97 + 2) )\n      {\n        if ( *((_QWORD *)v97 + 1) )\n          goto LABEL_31;\n        goto LABEL_69;\n      }\n    }\n    else\n    {\n      v33 = top + 4;\n      v31 = (int)v31;\n      if ( !*((_QWORD *)v32 + 2) )\n      {\nLABEL_69:\n        arr[v31] = 0;\n        v122 = v30;\n        v104 = v29;\n        codesp = v27;\n        v56 = (char *)codes;\n        libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)*v32], arr);\n        v30 = v122;\n        v29 = v104;\n        v27 = codesp;\n        codes = (char (*)[256])v56;\nLABEL_31:\n        if ( !v30->right )\n        {\n          v34 = v29;\n          if ( v30->left )\n            goto LABEL_37;\n          goto LABEL_57;\n        }\n        v34 = v29;\n        LODWORD(v35) = top + 3;\n        arr[v29] = 49;\n        v36 = &v30->right->data;\n        if ( *((_QWORD *)v36 + 1) )\n        {\n          v35 = (int)v35;\n          v139 = v29;\n          arr[(int)v35] = 48;\n          v133 = v30;\n          v118 = v27;\n          v98 = v36;\n          codesf = (char *)codes;\n          generateCodes(*((HuffmanNode **)v36 + 1), arr, top + 4, codes);\n          v36 = v98;\n          v37 = top + 4;\n          codes = (char (*)[256])codesf;\n          v27 = v118;\n          v30 = v133;\n          v34 = v139;\n          if ( !*((_QWORD *)v98 + 2) )\n          {\n            if ( *((_QWORD *)v98 + 1) )\n            {\nLABEL_35:\n              if ( v30->left || v30->right )\n                goto LABEL_37;\nLABEL_57:\n              arr[v34] = 0;\n              codesi = v27;\n              v49 = (char *)codes;\n              libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)v30->data], arr);\n              v27 = codesi;\n              codes = (char (*)[256])v49;\n              goto LABEL_37;\n            }\nLABEL_66:\n            arr[v35] = 0;\n            v120 = v34;\n            v102 = v30;\n            codesn = v27;\n            v54 = (char *)codes;\n            libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)*v36], arr);\n            v34 = v120;\n            v30 = v102;\n            v27 = codesn;\n            codes = (char (*)[256])v54;\n            goto LABEL_35;\n          }\n        }\n        else\n        {\n          v37 = top + 4;\n          v35 = (int)v35;\n          if ( !*((_QWORD *)v36 + 2) )\n            goto LABEL_66;\n        }\n        arr[v35] = 49;\n        v135 = v34;\n        v119 = v30;\n        v101 = v27;\n        codesm = v36;\n        v53 = (char *)codes;\n        generateCodes(*((HuffmanNode **)v36 + 2), arr, v37, codes);\n        v36 = codesm;\n        codes = (char (*)[256])v53;\n        v27 = v101;\n        v30 = v119;\n        v34 = v135;\n        if ( *(_OWORD *)(codesm + 8) != 0LL )\n          goto LABEL_35;\n        goto LABEL_66;\n      }\n    }\n    arr[v31] = 49;\n    v136 = v30;\n    v121 = v29;\n    v103 = v27;\n    codeso = v32;\n    v55 = (char *)codes;\n    generateCodes(*((HuffmanNode **)v32 + 2), arr, v33, codes);\n    v32 = codeso;\n    codes = (char (*)[256])v55;\n    v27 = v103;\n    v29 = v121;\n    v30 = v136;\n    if ( *(_OWORD *)(codeso + 8) != 0LL )\n      goto LABEL_31;\n    goto LABEL_69;\n  }\nLABEL_37:\n  if ( !v28->right )\n  {\n    v38 = (char *)v27;\n    if ( v28->left )\n      goto LABEL_50;\n    goto LABEL_46;\n  }\n  v38 = (char *)v27;\n  v39 = top + 2;\n  v38[(_QWORD)arr] = 49;\n  v40 = v28->right;\n  if ( v40->left )\n  {\n    arr[v39] = 48;\n    v41 = &v40->left->data;\n    LODWORD(v42) = top + 3;\n    if ( *((_QWORD *)v41 + 1) )\n    {\n      v42 = (int)v42;\n      v140 = v38;\n      arr[(int)v42] = 48;\n      v134 = v40;\n      v99 = v41;\n      codesg = (char *)codes;\n      generateCodes(*((HuffmanNode **)v41 + 1), arr, top + 4, codes);\n      v41 = v99;\n      v43 = top + 4;\n      codes = (char (*)[256])codesg;\n      v39 = top + 2;\n      v40 = v134;\n      v38 = v140;\n      if ( !*((_QWORD *)v99 + 2) )\n      {\n        if ( *((_QWORD *)v99 + 1) )\n          goto LABEL_42;\n        goto LABEL_84;\n      }\n    }\n    else\n    {\n      v43 = top + 4;\n      v42 = (int)v42;\n      if ( !*((_QWORD *)v41 + 2) )\n      {\nLABEL_84:\n        arr[v42] = 0;\n        v128 = v38;\n        v114 = v40;\n        codesz = v39;\n        v66 = (char *)codes;\n        libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)*v41], arr);\n        v38 = v128;\n        v40 = v114;\n        v39 = codesz;\n        codes = (char (*)[256])v66;\n        goto LABEL_42;\n      }\n    }\n    arr[v42] = 49;\n    v137 = v38;\n    v127 = v40;\n    v113 = v39;\n    codesy = v41;\n    v65 = (char *)codes;\n    generateCodes(*((HuffmanNode **)v41 + 2), arr, v43, codes);\n    v41 = codesy;\n    codes = (char (*)[256])v65;\n    v39 = v113;\n    v40 = v127;\n    v38 = v137;\n    if ( *(_OWORD *)(codesy + 8) != 0LL )\n      goto LABEL_42;\n    goto LABEL_84;\n  }\nLABEL_42:\n  if ( !v40->right )\n  {\n    v44 = v39;\n    if ( v40->left )\n      goto LABEL_44;\nLABEL_59:\n    arr[v44] = 0;\n    codesj = v38;\n    v50 = (char *)codes;\n    libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)v40->data], arr);\n    v38 = codesj;\n    codes = (char (*)[256])v50;\n    goto LABEL_44;\n  }\n  v44 = v39;\n  v100 = v38;\n  arr[v39] = 49;\n  codesh = &v40->data;\n  v46 = (char *)codes;\n  generateCodes(v40->right, arr, top + 3, codes);\n  v40 = (HuffmanNode *)codesh;\n  codes = (char (*)[256])v46;\n  v38 = v100;\n  if ( *(_OWORD *)(codesh + 8) == 0LL )\n    goto LABEL_59;\nLABEL_44:\n  if ( !v28->left && !v28->right )\n  {\nLABEL_46:\n    v38[(_QWORD)arr] = 0;\n    v47 = (char *)codes;\n    libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)v28->data], arr);\n    codes = (char (*)[256])v47;\n  }\nLABEL_50:\n  if ( !root->left && !root->right )\n    goto LABEL_53;\n}\n"}, "pseudo_normalize": "", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<generateCodes>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmov    %edx,%ebx\nsub    $0x38,%rsp\ncmpq   $0x0,0x8(%rdi)\nje     1c80 <generateCodes+0x2a0>\nmovslq %edx,%r14\nlea    0x1(%rdx),%r9d\nmovb   $0x30,(%rsi,%r14,1)\nmov    0x8(%rdi),%r13\ncmpq   $0x0,0x8(%r13)\nje     1b40 <generateCodes+0x160>\nmovslq %r9d,%r8\nlea    0x2(%rdx),%r10d\nmovb   $0x30,(%rsi,%r8,1)\nmov    0x8(%r13),%r15\ncmpq   $0x0,0x8(%r15)\nje     1aaa <generateCodes+0xca>\nmovslq %r10d,%r8\nlea    0x3(%rdx),%r14d\nmovb   $0x30,(%rsi,%r8,1)\nmov    0x8(%r15),%rax\ncmpq   $0x0,0x8(%rax)\nje     2360 <generateCodes+0x980>\nmovslq %r14d,%r14\nlea    0x4(%rdx),%edx\nmov    %r10d,0x20(%rsp)\nmovb   $0x30,(%rsi,%r14,1)\nmov    0x8(%rax),%rdi\nmov    %r9d,0x18(%rsp)\nmov    %rax,0x10(%rsp)\nmov    %rcx,0x8(%rsp)\nmov    %edx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x10(%rsp),%rax\nmov    (%rsp),%edx\nmov    0x8(%rsp),%rcx\nmov    0x18(%rsp),%r9d\ncmpq   $0x0,0x10(%rax)\nmov    0x20(%rsp),%r10d\njne    236d <generateCodes+0x98d>\ncmpq   $0x0,0x8(%rax)\nje     23bb <generateCodes+0x9db>\ncmpq   $0x0,0x10(%r15)\nje     2050 <generateCodes+0x670>\nmovslq %r10d,%r8\nlea    0x3(%rbx),%r14d\nmovb   $0x31,0x0(%rbp,%r8,1)\nmov    0x10(%r15),%rax\ncmpq   $0x0,0x8(%rax)\nje     2230 <generateCodes+0x850>\nmovslq %r14d,%r14\nlea    0x4(%rbx),%edx\nmov    %rbp,%rsi\nmov    %r8,0x20(%rsp)\nmovb   $0x30,0x0(%rbp,%r14,1)\nmov    0x8(%rax),%rdi\nmov    %r9d,0x18(%rsp)\nmov    %rax,0x10(%rsp)\nmov    %rcx,0x8(%rsp)\nmov    %edx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x10(%rsp),%rax\nmov    (%rsp),%edx\nmov    0x8(%rsp),%rcx\nmov    0x18(%rsp),%r9d\ncmpq   $0x0,0x10(%rax)\nmov    0x20(%rsp),%r8\njne    223d <generateCodes+0x85d>\ncmpq   $0x0,0x8(%rax)\nje     228b <generateCodes+0x8ab>\ncmpq   $0x0,0x8(%r15)\njne    1b40 <generateCodes+0x160>\ncmpq   $0x0,0x10(%r15)\nje     205e <generateCodes+0x67e>\nnop\ncmpq   $0x0,0x10(%r13)\nje     1f20 <generateCodes+0x540>\nmovslq %r9d,%r8\nlea    0x2(%rbx),%r10d\nmovb   $0x31,0x0(%rbp,%r8,1)\nmov    0x10(%r13),%r15\ncmpq   $0x0,0x8(%r15)\nje     1bdb <generateCodes+0x1fb>\nmovslq %r10d,%r9\nlea    0x3(%rbx),%r14d\nmovb   $0x30,0x0(%rbp,%r9,1)\nmov    0x8(%r15),%rax\ncmpq   $0x0,0x8(%rax)\nje     22c8 <generateCodes+0x8e8>\nmovslq %r14d,%r14\nlea    0x4(%rbx),%edx\nmov    %rbp,%rsi\nmov    %r8,0x20(%rsp)\nmovb   $0x30,0x0(%rbp,%r14,1)\nmov    0x8(%rax),%rdi\nmov    %r10d,0x18(%rsp)\nmov    %rax,0x10(%rsp)\nmov    %rcx,0x8(%rsp)\nmov    %edx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x10(%rsp),%rax\nmov    (%rsp),%edx\nmov    0x8(%rsp),%rcx\nmov    0x18(%rsp),%r10d\ncmpq   $0x0,0x10(%rax)\nmov    0x20(%rsp),%r8\njne    22d5 <generateCodes+0x8f5>\ncmpq   $0x0,0x8(%rax)\nje     2323 <generateCodes+0x943>\ncmpq   $0x0,0x10(%r15)\nje     2090 <generateCodes+0x6b0>\nmovslq %r10d,%r9\nlea    0x3(%rbx),%r14d\nmovb   $0x31,0x0(%rbp,%r9,1)\nmov    0x10(%r15),%rax\ncmpq   $0x0,0x8(%rax)\nje     23f8 <generateCodes+0xa18>\nmovslq %r14d,%r14\nlea    0x4(%rbx),%edx\nmov    %rbp,%rsi\nmov    %r9,0x20(%rsp)\nmovb   $0x30,0x0(%rbp,%r14,1)\nmov    0x8(%rax),%rdi\nmov    %r8,0x18(%rsp)\nmov    %rax,0x10(%rsp)\nmov    %rcx,0x8(%rsp)\nmov    %edx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x10(%rsp),%rax\nmov    (%rsp),%edx\nmov    0x8(%rsp),%rcx\nmov    0x18(%rsp),%r8\ncmpq   $0x0,0x10(%rax)\nmov    0x20(%rsp),%r9\njne    2405 <generateCodes+0xa25>\ncmpq   $0x0,0x8(%rax)\nje     2453 <generateCodes+0xa73>\ncmpq   $0x0,0x8(%r15)\nje     2550 <generateCodes+0xb70>\ncmpq   $0x0,0x8(%r13)\njne    1c80 <generateCodes+0x2a0>\ncmpq   $0x0,0x10(%r13)\nje     1f2e <generateCodes+0x54e>\nnopl   0x0(%rax,%rax,1)\ncmpq   $0x0,0x10(%r12)\nje     1f80 <generateCodes+0x5a0>\nmovslq %ebx,%r14\nlea    0x1(%rbx),%r9d\nmovb   $0x31,0x0(%rbp,%r14,1)\nmov    0x10(%r12),%r13\ncmpq   $0x0,0x8(%r13)\nje     1df0 <generateCodes+0x410>\nmovslq %r9d,%r10\nlea    0x2(%rbx),%r11d\nmovb   $0x30,0x0(%rbp,%r10,1)\nmov    0x8(%r13),%r8\ncmpq   $0x0,0x8(%r8)\nje     1d47 <generateCodes+0x367>\nmovslq %r11d,%r10\nlea    0x3(%rbx),%r15d\nmovb   $0x30,0x0(%rbp,%r10,1)\nmov    0x8(%r8),%rax\ncmpq   $0x0,0x8(%rax)\nje     2180 <generateCodes+0x7a0>\nmovslq %r15d,%r15\nlea    0x4(%rbx),%edx\nmov    %rbp,%rsi\nmov    %r8,0x28(%rsp)\nmovb   $0x30,0x0(%rbp,%r15,1)\nmov    0x8(%rax),%rdi\nmov    %r11d,0x20(%rsp)\nmov    %r9d,0x18(%rsp)\nmov    %rax,0x10(%rsp)\nmov    %rcx,0x8(%rsp)\nmov    %edx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x10(%rsp),%rax\nmov    (%rsp),%edx\nmov    0x8(%rsp),%rcx\nmov    0x18(%rsp),%r9d\ncmpq   $0x0,0x10(%rax)\nmov    0x20(%rsp),%r11d\nmov    0x28(%rsp),%r8\njne    218d <generateCodes+0x7ad>\ncmpq   $0x0,0x8(%rax)\nje     21e5 <generateCodes+0x805>\ncmpq   $0x0,0x10(%r8)\nje     1fd0 <generateCodes+0x5f0>\nmovslq %r11d,%r10\nlea    0x3(%rbx),%r15d\nmovb   $0x31,0x0(%rbp,%r10,1)\nmov    0x10(%r8),%rax\ncmpq   $0x0,0x8(%rax)\nje     20d0 <generateCodes+0x6f0>\nmovslq %r15d,%r15\nlea    0x4(%rbx),%edx\nmov    %rbp,%rsi\nmov    %r10,0x28(%rsp)\nmovb   $0x30,0x0(%rbp,%r15,1)\nmov    0x8(%rax),%rdi\nmov    %r8,0x20(%rsp)\nmov    %r9d,0x18(%rsp)\nmov    %rax,0x10(%rsp)\nmov    %rcx,0x8(%rsp)\nmov    %edx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x10(%rsp),%rax\nmov    (%rsp),%edx\nmov    0x8(%rsp),%rcx\nmov    0x18(%rsp),%r9d\ncmpq   $0x0,0x10(%rax)\nmov    0x20(%rsp),%r8\nmov    0x28(%rsp),%r10\njne    20dd <generateCodes+0x6fd>\ncmpq   $0x0,0x8(%rax)\nje     2135 <generateCodes+0x755>\ncmpq   $0x0,0x8(%r8)\njne    1df0 <generateCodes+0x410>\ncmpq   $0x0,0x10(%r8)\nje     1fde <generateCodes+0x5fe>\ncs nopw 0x0(%rax,%rax,1)\ncmpq   $0x0,0x10(%r13)\nje     1f58 <generateCodes+0x578>\nmovslq %r9d,%r10\nlea    0x2(%rbx),%r9d\nmovb   $0x31,0x0(%rbp,%r10,1)\nmov    0x10(%r13),%r8\ncmpq   $0x0,0x8(%r8)\nje     1e99 <generateCodes+0x4b9>\nmovslq %r9d,%r15\nmovb   $0x30,0x0(%rbp,%r15,1)\nmov    0x8(%r8),%rax\nlea    0x3(%rbx),%r15d\ncmpq   $0x0,0x8(%rax)\nje     2490 <generateCodes+0xab0>\nmovslq %r15d,%r15\nlea    0x4(%rbx),%edx\nmov    %rbp,%rsi\nmov    %r10,0x28(%rsp)\nmovb   $0x30,0x0(%rbp,%r15,1)\nmov    0x8(%rax),%rdi\nmov    %r8,0x20(%rsp)\nmov    %r9d,0x18(%rsp)\nmov    %rax,0x10(%rsp)\nmov    %rcx,0x8(%rsp)\nmov    %edx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x10(%rsp),%rax\nmov    (%rsp),%edx\nmov    0x8(%rsp),%rcx\nmov    0x18(%rsp),%r9d\ncmpq   $0x0,0x10(%rax)\nmov    0x20(%rsp),%r8\nmov    0x28(%rsp),%r10\njne    249d <generateCodes+0xabd>\ncmpq   $0x0,0x8(%rax)\nje     24f5 <generateCodes+0xb15>\ncmpq   $0x0,0x10(%r8)\nje     2010 <generateCodes+0x630>\nmovslq %r9d,%r15\nlea    0x3(%rbx),%edx\nmov    %rbp,%rsi\nmov    %r10,0x10(%rsp)\nmovb   $0x31,0x0(%rbp,%r15,1)\nmov    0x10(%r8),%rdi\nmov    %r8,0x8(%rsp)\nmov    %rcx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x8(%rsp),%r8\nmov    (%rsp),%rcx\nmov    0x10(%rsp),%r10\ncmpq   $0x0,0x8(%r8)\nje     2540 <generateCodes+0xb60>\ncmpq   $0x0,0x8(%r13)\njne    1f62 <generateCodes+0x582>\ncmpq   $0x0,0x10(%r13)\njne    1f62 <generateCodes+0x582>\nnopl   0x0(%rax)\nmovb   $0x0,0x0(%rbp,%r10,1)\nmovzbl 0x0(%r13),%edi\nmov    %rbp,%rsi\nmov    %rcx,(%rsp)\nshl    $0x8,%rdi\nadd    %rcx,%rdi\ncall   4df0 <libmin_strcpy>\nmov    (%rsp),%rcx\njmp    1f62 <generateCodes+0x582>\nnopl   0x0(%rax)\ncmpq   $0x0,0x8(%r13)\nmovslq %r9d,%r8\njne    1c80 <generateCodes+0x2a0>\nmovb   $0x0,0x0(%rbp,%r8,1)\nmovzbl 0x0(%r13),%edi\nmov    %rbp,%rsi\nmov    %rcx,(%rsp)\nshl    $0x8,%rdi\nadd    %rcx,%rdi\ncall   4df0 <libmin_strcpy>\nmov    (%rsp),%rcx\njmp    1c80 <generateCodes+0x2a0>\nnopl   (%rax)\ncmpq   $0x0,0x8(%r13)\nmovslq %r9d,%r10\nje     1ef8 <generateCodes+0x518>\ncmpq   $0x0,0x8(%r12)\nje     1fb8 <generateCodes+0x5d8>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\ncmpq   $0x0,0x8(%r12)\nmovslq %ebx,%r14\njne    1f6a <generateCodes+0x58a>\nmovb   $0x0,0x0(%rbp,%r14,1)\nmovzbl (%r12),%edi\nadd    $0x38,%rsp\nmov    %rbp,%rsi\npop    %rbx\npop    %rbp\nshl    $0x8,%rdi\npop    %r12\npop    %r13\nadd    %rcx,%rdi\npop    %r14\npop    %r15\njmp    4df0 <libmin_strcpy>\nnopl   0x0(%rax,%rax,1)\ncmpq   $0x0,0x10(%r12)\nje     1f8b <generateCodes+0x5ab>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnop\ncmpq   $0x0,0x8(%r8)\nmovslq %r11d,%r10\njne    1df0 <generateCodes+0x410>\nmovb   $0x0,0x0(%rbp,%r10,1)\nmovzbl (%r8),%edi\nmov    %rbp,%rsi\nmov    %r9d,0x8(%rsp)\nshl    $0x8,%rdi\nmov    %rcx,(%rsp)\nadd    %rcx,%rdi\ncall   4df0 <libmin_strcpy>\nmov    0x8(%rsp),%r9d\nmov    (%rsp),%rcx\njmp    1df0 <generateCodes+0x410>\nxchg   %ax,%ax\ncmpq   $0x0,0x8(%r8)\nmovslq %r9d,%r15\njne    1ee3 <generateCodes+0x503>\nmovb   $0x0,0x0(%rbp,%r15,1)\nmovzbl (%r8),%edi\nmov    %rbp,%rsi\nmov    %r10,0x8(%rsp)\nshl    $0x8,%rdi\nmov    %rcx,(%rsp)\nadd    %rcx,%rdi\ncall   4df0 <libmin_strcpy>\nmov    0x8(%rsp),%r10\nmov    (%rsp),%rcx\njmp    1ee3 <generateCodes+0x503>\nxchg   %ax,%ax\ncmpq   $0x0,0x8(%r15)\nmovslq %r10d,%r8\njne    1b40 <generateCodes+0x160>\nmovb   $0x0,0x0(%rbp,%r8,1)\nmovzbl (%r15),%edi\nmov    %rbp,%rsi\nmov    %r9d,0x8(%rsp)\nshl    $0x8,%rdi\nmov    %rcx,(%rsp)\nadd    %rcx,%rdi\ncall   4df0 <libmin_strcpy>\nmov    0x8(%rsp),%r9d\nmov    (%rsp),%rcx\njmp    1b40 <generateCodes+0x160>\nxchg   %ax,%ax\ncmpq   $0x0,0x8(%r15)\nmovslq %r10d,%r9\njne    1c69 <generateCodes+0x289>\nmovb   $0x0,0x0(%rbp,%r9,1)\nmovzbl (%r15),%edi\nmov    %rbp,%rsi\nmov    %r8,0x8(%rsp)\nshl    $0x8,%rdi\nmov    %rcx,(%rsp)\nadd    %rcx,%rdi\ncall   4df0 <libmin_strcpy>\nmov    0x8(%rsp),%r8\nmov    (%rsp),%rcx\njmp    1c69 <generateCodes+0x289>\nxchg   %ax,%ax\ncmpq   $0x0,0x10(%rax)\nlea    0x4(%rbx),%edx\nmovslq %r15d,%r15\nje     2135 <generateCodes+0x755>\nmovb   $0x31,0x0(%rbp,%r15,1)\nmov    0x10(%rax),%rdi\nmov    %rbp,%rsi\nmov    %r10,0x20(%rsp)\nmov    %r8,0x18(%rsp)\nmov    %r9d,0x10(%rsp)\nmov    %rax,0x8(%rsp)\nmov    %rcx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x8(%rsp),%rax\nmov    (%rsp),%rcx\nmov    0x10(%rsp),%r9d\nmov    0x18(%rsp),%r8\ncmpq   $0x0,0x8(%rax)\nmov    0x20(%rsp),%r10\njne    1dd4 <generateCodes+0x3f4>\ncmpq   $0x0,0x10(%rax)\njne    1dd4 <generateCodes+0x3f4>\nmovb   $0x0,0x0(%rbp,%r15,1)\nmovzbl (%rax),%edi\nmov    %rbp,%rsi\nmov    %r10,0x18(%rsp)\nshl    $0x8,%rdi\nmov    %r8,0x10(%rsp)\nadd    %rcx,%rdi\nmov    %r9d,0x8(%rsp)\nmov    %rcx,(%rsp)\ncall   4df0 <libmin_strcpy>\nmov    0x18(%rsp),%r10\nmov    0x10(%rsp),%r8\nmov    0x8(%rsp),%r9d\nmov    (%rsp),%rcx\njmp    1dd4 <generateCodes+0x3f4>\nnopl   0x0(%rax,%rax,1)\ncmpq   $0x0,0x10(%rax)\nlea    0x4(%rbx),%edx\nmovslq %r15d,%r15\nje     21e5 <generateCodes+0x805>\nmovb   $0x31,0x0(%rbp,%r15,1)\nmov    0x10(%rax),%rdi\nmov    %rbp,%rsi\nmov    %r8,0x20(%rsp)\nmov    %r11d,0x18(%rsp)\nmov    %r9d,0x10(%rsp)\nmov    %rax,0x8(%rsp)\nmov    %rcx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x8(%rsp),%rax\nmov    (%rsp),%rcx\nmov    0x10(%rsp),%r9d\nmov    0x18(%rsp),%r11d\ncmpq   $0x0,0x8(%rax)\nmov    0x20(%rsp),%r8\njne    1d47 <generateCodes+0x367>\ncmpq   $0x0,0x10(%rax)\njne    1d47 <generateCodes+0x367>\nmovb   $0x0,0x0(%rbp,%r15,1)\nmovzbl (%rax),%edi\nmov    %rbp,%rsi\nmov    %r8,0x18(%rsp)\nshl    $0x8,%rdi\nmov    %r11d,0x10(%rsp)\nadd    %rcx,%rdi\nmov    %r9d,0x8(%rsp)\nmov    %rcx,(%rsp)\ncall   4df0 <libmin_strcpy>\nmov    0x18(%rsp),%r8\nmov    0x10(%rsp),%r11d\nmov    0x8(%rsp),%r9d\nmov    (%rsp),%rcx\njmp    1d47 <generateCodes+0x367>\nnopl   0x0(%rax,%rax,1)\ncmpq   $0x0,0x10(%rax)\nlea    0x4(%rbx),%edx\nmovslq %r14d,%r14\nje     228b <generateCodes+0x8ab>\nmovb   $0x31,0x0(%rbp,%r14,1)\nmov    0x10(%rax),%rdi\nmov    %rbp,%rsi\nmov    %r8,0x18(%rsp)\nmov    %r9d,0x10(%rsp)\nmov    %rax,0x8(%rsp)\nmov    %rcx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x8(%rsp),%rax\nmov    (%rsp),%rcx\nmov    0x10(%rsp),%r9d\nmov    0x18(%rsp),%r8\ncmpq   $0x0,0x8(%rax)\njne    1b2d <generateCodes+0x14d>\ncmpq   $0x0,0x10(%rax)\njne    1b2d <generateCodes+0x14d>\nmovb   $0x0,0x0(%rbp,%r14,1)\nmovzbl (%rax),%edi\nmov    %rbp,%rsi\nmov    %r8,0x10(%rsp)\nshl    $0x8,%rdi\nmov    %r9d,0x8(%rsp)\nadd    %rcx,%rdi\nmov    %rcx,(%rsp)\ncall   4df0 <libmin_strcpy>\nmov    0x10(%rsp),%r8\nmov    0x8(%rsp),%r9d\nmov    (%rsp),%rcx\njmp    1b2d <generateCodes+0x14d>\nnopl   0x0(%rax)\ncmpq   $0x0,0x10(%rax)\nlea    0x4(%rbx),%edx\nmovslq %r14d,%r14\nje     2323 <generateCodes+0x943>\nmovb   $0x31,0x0(%rbp,%r14,1)\nmov    0x10(%rax),%rdi\nmov    %rbp,%rsi\nmov    %r8,0x18(%rsp)\nmov    %r10d,0x10(%rsp)\nmov    %rax,0x8(%rsp)\nmov    %rcx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x8(%rsp),%rax\nmov    (%rsp),%rcx\nmov    0x10(%rsp),%r10d\nmov    0x18(%rsp),%r8\ncmpq   $0x0,0x8(%rax)\njne    1bdb <generateCodes+0x1fb>\ncmpq   $0x0,0x10(%rax)\njne    1bdb <generateCodes+0x1fb>\nmovb   $0x0,0x0(%rbp,%r14,1)\nmovzbl (%rax),%edi\nmov    %rbp,%rsi\nmov    %r8,0x10(%rsp)\nshl    $0x8,%rdi\nmov    %r10d,0x8(%rsp)\nadd    %rcx,%rdi\nmov    %rcx,(%rsp)\ncall   4df0 <libmin_strcpy>\nmov    0x10(%rsp),%r8\nmov    0x8(%rsp),%r10d\nmov    (%rsp),%rcx\njmp    1bdb <generateCodes+0x1fb>\nnopl   0x0(%rax)\ncmpq   $0x0,0x10(%rax)\nmovslq %r14d,%r14\nlea    0x4(%rdx),%edx\nje     23bb <generateCodes+0x9db>\nmovb   $0x31,0x0(%rbp,%r14,1)\nmov    0x10(%rax),%rdi\nmov    %rbp,%rsi\nmov    %r10d,0x18(%rsp)\nmov    %r9d,0x10(%rsp)\nmov    %rax,0x8(%rsp)\nmov    %rcx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x8(%rsp),%rax\nmov    (%rsp),%rcx\nmov    0x10(%rsp),%r9d\nmov    0x18(%rsp),%r10d\ncmpq   $0x0,0x8(%rax)\njne    1aaa <generateCodes+0xca>\ncmpq   $0x0,0x10(%rax)\njne    1aaa <generateCodes+0xca>\nmovb   $0x0,0x0(%rbp,%r14,1)\nmovzbl (%rax),%edi\nmov    %rbp,%rsi\nmov    %r10d,0x10(%rsp)\nshl    $0x8,%rdi\nmov    %r9d,0x8(%rsp)\nadd    %rcx,%rdi\nmov    %rcx,(%rsp)\ncall   4df0 <libmin_strcpy>\nmov    0x10(%rsp),%r10d\nmov    0x8(%rsp),%r9d\nmov    (%rsp),%rcx\njmp    1aaa <generateCodes+0xca>\nnopl   0x0(%rax)\ncmpq   $0x0,0x10(%rax)\nlea    0x4(%rbx),%edx\nmovslq %r14d,%r14\nje     2453 <generateCodes+0xa73>\nmovb   $0x31,0x0(%rbp,%r14,1)\nmov    0x10(%rax),%rdi\nmov    %rbp,%rsi\nmov    %r9,0x18(%rsp)\nmov    %r8,0x10(%rsp)\nmov    %rax,0x8(%rsp)\nmov    %rcx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x8(%rsp),%rax\nmov    (%rsp),%rcx\nmov    0x10(%rsp),%r8\nmov    0x18(%rsp),%r9\ncmpq   $0x0,0x8(%rax)\njne    1c5e <generateCodes+0x27e>\ncmpq   $0x0,0x10(%rax)\njne    1c5e <generateCodes+0x27e>\nmovb   $0x0,0x0(%rbp,%r14,1)\nmovzbl (%rax),%edi\nmov    %rbp,%rsi\nmov    %r9,0x10(%rsp)\nshl    $0x8,%rdi\nmov    %r8,0x8(%rsp)\nadd    %rcx,%rdi\nmov    %rcx,(%rsp)\ncall   4df0 <libmin_strcpy>\nmov    0x10(%rsp),%r9\nmov    0x8(%rsp),%r8\nmov    (%rsp),%rcx\njmp    1c5e <generateCodes+0x27e>\nnopl   0x0(%rax)\ncmpq   $0x0,0x10(%rax)\nlea    0x4(%rbx),%edx\nmovslq %r15d,%r15\nje     24f5 <generateCodes+0xb15>\nmovb   $0x31,0x0(%rbp,%r15,1)\nmov    0x10(%rax),%rdi\nmov    %rbp,%rsi\nmov    %r10,0x20(%rsp)\nmov    %r8,0x18(%rsp)\nmov    %r9d,0x10(%rsp)\nmov    %rax,0x8(%rsp)\nmov    %rcx,(%rsp)\ncall   19e0 <generateCodes>\nmov    0x8(%rsp),%rax\nmov    (%rsp),%rcx\nmov    0x10(%rsp),%r9d\nmov    0x18(%rsp),%r8\ncmpq   $0x0,0x8(%rax)\nmov    0x20(%rsp),%r10\njne    1e99 <generateCodes+0x4b9>\ncmpq   $0x0,0x10(%rax)\njne    1e99 <generateCodes+0x4b9>\nmovb   $0x0,0x0(%rbp,%r15,1)\nmovzbl (%rax),%edi\nmov    %rbp,%rsi\nmov    %r10,0x18(%rsp)\nshl    $0x8,%rdi\nmov    %r8,0x10(%rsp)\nadd    %rcx,%rdi\nmov    %r9d,0x8(%rsp)\nmov    %rcx,(%rsp)\ncall   4df0 <libmin_strcpy>\nmov    0x18(%rsp),%r10\nmov    0x10(%rsp),%r8\nmov    0x8(%rsp),%r9d\nmov    (%rsp),%rcx\njmp    1e99 <generateCodes+0x4b9>\nnopl   0x0(%rax,%rax,1)\ncmpq   $0x0,0x10(%r8)\njne    1ee3 <generateCodes+0x503>\njmp    201e <generateCodes+0x63e>\ncmpq   $0x0,0x10(%r15)\njne    1c69 <generateCodes+0x289>\njmp    209e <generateCodes+0x6be>\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "insertMinHeap", "content": "// Insert a node into the min-heap\nvoid insertMinHeap(MinHeap* minHeap, HuffmanNode* node) {\n    ++minHeap->size;\n    int i = minHeap->size - 1;\n    while (i && node->freq < minHeap->array[(i - 1) / 2]->freq) {\n        minHeap->array[i] = minHeap->array[(i - 1) / 2];\n        i = (i - 1) / 2;\n    }\n    minHeap->array[i] = node;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "insertMinHeap", "address": "0x1720", "label": "insertMinHeap", "content": "void __fastcall insertMinHeap(MinHeap *minHeap, HuffmanNode *node)\n{\n  int v2; // eax\n  HuffmanNode **array; // rdi\n  int freq; // r8d\n  HuffmanNode **v5; // rdx\n  HuffmanNode *v6; // rcx\n\n  v2 = minHeap->size++;\n  array = minHeap->array;\n  if ( v2 )\n  {\n    freq = node->freq;\n    while ( 1 )\n    {\n      v5 = &array[v2];\n      v2 = (v2 - 1) / 2;\n      v6 = array[v2];\n      if ( freq >= v6->freq )\n        break;\n      *v5 = v6;\n      if ( !v2 )\n        goto LABEL_6;\n    }\n    array = v5;\n  }\nLABEL_6:\n  *array = node;\n}\n"}, "pseudo_normalize": "void insertMinHeap(MinHeap *minHeap, HuffmanNode *node) {\n  int v2;\n  HuffmanNode **array;\n  int freq;\n  HuffmanNode **v5;\n  HuffmanNode *v6;\n  v2 = minHeap->size++;\n  array = minHeap->array;\n  if (v2) {\n    freq = node->freq;\n    while (1) {\n      v5 = &array[v2];\n      v2 = (v2 - 1) / 2;\n      v6 = array[v2];\n      if (freq >= v6->freq) break;\n      *v5 = v6;\n      if (!v2) goto LABEL_6;\n    }\n    array = v5;\n  }\nLABEL_6:\n  *array = node;\n}", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<insertMinHeap>:\nendbr64\nmov    (%rdi),%eax\nlea    0x1(%rax),%edx\nmov    %edx,(%rdi)\nmov    0x8(%rdi),%rdi\ntest   %eax,%eax\nje     176a <insertMinHeap+0x4a>\nmov    0x4(%rsi),%r8d\njmp    1747 <insertMinHeap+0x27>\nnopl   0x0(%rax)\nmov    %rcx,(%rdx)\ntest   %eax,%eax\nje     176a <insertMinHeap+0x4a>\nmovslq %eax,%rdx\nlea    -0x1(%rdx),%ecx\nlea    (%rdi,%rdx,8),%rdx\nmov    %ecx,%eax\nshr    $0x1f,%eax\nadd    %ecx,%eax\nsar    %eax\nmovslq %eax,%rcx\nmov    (%rdi,%rcx,8),%rcx\ncmp    0x4(%rcx),%r8d\njl     1740 <insertMinHeap+0x20>\nmov    %rdx,%rdi\nmov    %rsi,(%rdi)\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "isSizeOne", "content": "// Check if heap size is one\nint isSizeOne(MinHeap* minHeap) {\n    return (minHeap->size == 1);\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "isSizeOne", "address": "0x16e0", "label": "isSizeOne", "content": "int __fastcall isSizeOne(MinHeap *minHeap)\n{\n  return minHeap->size == 1;\n}\n"}, "pseudo_normalize": "", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<isSizeOne>:\nendbr64\nxor    %eax,%eax\ncmpl   $0x1,(%rdi)\nsete   %al\nret\nnopl   (%rax)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "main", "content": "int main() {\n    // Example input string to compress\n    char input[] = \"this is an example for huffman encoding\";\n    \n    // Count frequency of each character in input\n    int freq[256] = {0};\n    for (int i = 0; input[i]; i++) {\n        freq[(unsigned char)input[i]]++;\n    }\n    \n    // Create arrays for characters and their frequencies (for non-zero frequencies)\n    int unique = 0;\n    for (int i = 0; i < 256; i++)\n        if (freq[i])\n            unique++;\n    \n    char* characters = (char*)libmin_malloc(unique * sizeof(char));\n    int* frequencies = (int*)libmin_malloc(unique * sizeof(int));\n    \n    int index = 0;\n    for (int i = 0; i < 256; i++) {\n        if (freq[i]) {\n            characters[index] = (char)i;\n            frequencies[index] = freq[i];\n            index++;\n        }\n    }\n    \n    // Build Huffman Tree\n    HuffmanNode* root = buildHuffmanTree(characters, frequencies, unique);\n    \n    // Generate Huffman codes for characters\n    char codes[256][MAX_TREE_HT] = {{0}};\n    char arr[MAX_TREE_HT];\n    generateCodes(root, arr, 0, codes);\n    \n    // Print generated Huffman codes\n    libmin_printf(\"Huffman Codes:\\n\");\n    for (int i = 0; i < 256; i++) {\n        if (freq[i]) {\n            libmin_printf(\"'%c': %s\\n\", i, codes[i]);\n        }\n    }\n    \n    // Encode input string\n    char encoded[1024] = {0};\n    encodeString(input, codes, encoded);\n    libmin_printf(\"\\nEncoded string:\\n%s\\n\", encoded);\n    \n    // Report compression metrics:\n    int inputBits = libmin_strlen(input) * 8;         // Assuming 8 bits per char originally\n    int encodedBits = libmin_strlen(encoded);         // One character per bit in encoded string representation\n    libmin_printf(\"\\nCompression Metrics:\\n\");\n    libmin_printf(\"Original size: %d bits\\n\", inputBits);\n    libmin_printf(\"Encoded size: %d bits\\n\", encodedBits);\n    libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)encodedBits / inputBits * 100);\n    \n    // Decode the encoded string\n    char decoded[1024] = {0};\n    decodeString(root, encoded, decoded);\n    libmin_printf(\"\\nDecoded string:\\n%s\\n\", decoded);\n    \n    // Check that the decompressed string matches the original input\n    if (libmin_strcmp(input, decoded) == 0)\n        libmin_printf(\"\\nDecompression verified: decoded string matches the original input.\\n\");\n    else\n        libmin_printf(\"\\nError: decoded string does not match the original input.\\n\");\n    \n    // Free allocated memory for characters and frequencies\n    libmin_free(characters);\n    libmin_free(frequencies);\n    \n    // Note: In a complete implementation you should also free the Huffman tree nodes.\n\n    libmin_success();    \n    return 0;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "// positive sp value has been detected, the output may be wrong!\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char *v3; // rdx\n  __int64 v4; // rax\n  __m128i v5; // xmm1\n  char *v6; // rax\n  __m128i v7; // xmm1\n  __m128i v8; // xmm0\n  __m128i v9; // xmm1\n  int v10; // r14d\n  char *v11; // r12\n  int *v12; // rax\n  int v13; // ecx\n  int *v14; // rbp\n  __int64 v15; // rax\n  int v16; // edx\n  __int64 v17; // rsi\n  const char *v18; // r15\n  __int64 v19; // rbx\n  unsigned __int8 v20; // al\n  char *i; // rbx\n  int v22; // ebx\n  int v23; // [rsp-1DA0h] [rbp-12B28h]\n  HuffmanNode *v24; // [rsp-1D98h] [rbp-12B20h]\n  _DWORD v25[256]; // [rsp-1D88h] [rbp-12B10h] BYREF\n  char v26[2376]; // [rsp-1988h] [rbp-12710h] BYREF\n  __int64 v27; // [rsp-1040h] [rbp-11DC8h] BYREF\n  __int64 v28; // [rsp-40h] [rbp-10DC8h] BYREF\n  char codes[256][256]; // [rsp+410h] [rbp-10978h] BYREF\n\n  while ( &v27 != &v28 - 0x2000 )\n    ;\n  *(_QWORD *)&codes[235][160] = __readfsqword(0x28u);\n  *(__m128i *)&codes[226][104] = _mm_load_si128((const __m128i *)&xmmword_5140);\n  strcpy(&codes[226][136], \"ncoding\");\n  memset(v25, 0, sizeof(v25));\n  v3 = &codes[226][106];\n  v4 = 104LL;\n  v25[116] = 1;\n  *(__m128i *)&codes[226][120] = _mm_load_si128((const __m128i *)&xmmword_5150);\n  do\n  {\n    ++v3;\n    ++v25[v4];\n    v4 = (unsigned __int8)*(v3 - 1);\n  }\n  while ( (_BYTE)v4 );\n  v5 = 0LL;\n  v6 = (char *)v25;\n  do\n  {\n    v6 += 16;\n    v5 = _mm_sub_epi32(v5, _mm_cmpeq_epi32(_mm_cmpeq_epi32((__m128i)0LL, *((__m128i *)v6 - 1)), (__m128i)0LL));\n  }\n  while ( v26 != v6 );\n  v7 = _mm_add_epi32(v5, _mm_srli_si128(v5, 8));\n  v8 = _mm_srli_si128(v7, 4);\n  v9 = _mm_add_epi32(v7, v8);\n  v10 = _mm_cvtsi128_si32(v9);\n  v11 = (char *)libmin_malloc(v10);\n  v12 = (int *)libmin_malloc(4LL * v10);\n  v13 = 0;\n  v14 = v12;\n  v15 = 0LL;\n  while ( 1 )\n  {\n    v16 = v25[v15];\n    if ( v16 )\n    {\n      v17 = v13++;\n      v11[v17] = v15;\n      v14[v17] = v16;\n    }\n    if ( ++v15 == 256 )\n    {\n      v18 = v26;\n      v24 = buildHuffmanTree(v11, v14, v10);\n      memset(v26, 0, 0x10000uLL);\n      v19 = 0LL;\n      generateCodes(v24, &codes[226][152], 0, (char (*)[256])v26);\n      libmin_printf(\"Huffman Codes:\\n\", *(double *)v8.m128i_i64, *(double *)v9.m128i_i64, 0.0);\n      while ( 1 )\n      {\n        if ( v25[v19] )\n          libmin_printf(\"'%c': %s\\n\", (unsigned int)v19, v18);\n        ++v19;\n        v18 += 256;\n        if ( v19 == 256 )\n        {\n          memset(&codes[227][168], 0, 0x3F0uLL);\n          v20 = codes[226][104];\n          *(_OWORD *)&codes[227][152] = 0LL;\n          for ( i = &codes[226][105]; v20; v20 = *(i - 1) )\n          {\n            ++i;\n            libmin_strcat(&codes[227][152], &v26[256 * (unsigned __int64)v20]);\n          }\n          libmin_printf(\"\\nEncoded string:\\n%s\\n\", &codes[227][152]);\n          v22 = 8 * libmin_strlen(&codes[226][104]);\n          v23 = libmin_strlen(&codes[227][152]);\n          libmin_printf(\"\\nCompression Metrics:\\n\", 0.0);\n          libmin_printf(\"Original size: %d bits\\n\", v22);\n          libmin_printf(\"Encoded size: %d bits\\n\", v23);\n          libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)v23 / (double)v22 * 100.0);\n          *(_OWORD *)&codes[231][152] = 0LL;\n          memset(&codes[231][168], 0, 0x3F0uLL);\n          decodeString(v24, &codes[227][152], &codes[231][152]);\n          libmin_printf(\"\\nDecoded string:\\n%s\\n\", &codes[231][152]);\n          if ( libmin_strcmp(&codes[226][104], &codes[231][152]) )\n            libmin_printf(\"\\nError: decoded string does not match the original input.\\n\");\n          else\n            libmin_printf(\"\\nDecompression verified: decoded string matches the original input.\\n\");\n          libmin_free(v11);\n          libmin_free(v14);\n          libmin_success();\n        }\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  char *v3;\n  long long v4;\n  __m128i v5;\n  char *v6;\n  __m128i v7;\n  __m128i v8;\n  __m128i v9;\n  int v10;\n  char *v11;\n  int *v12;\n  int v13;\n  int *v14;\n  long long v15;\n  int v16;\n  long long v17;\n  const char *v18;\n  long long v19;\n  unsigned char v20;\n  char *i;\n  int v22;\n  int v23;\n  HuffmanNode *v24;\n  uint32_t v25[256];\n  char v26[2376];\n  long long v27;\n  long long v28;\n  char codes[256][256];\n  while (&v27 != &v28 - 8192)\n    ;\n  *(uint64_t *)&codes[235][160] = __readfsqword(40u);\n  *(__m128i *)&codes[226][104] = _mm_load_si128((const __m128i *)&xmmword_5140);\n  strcpy(&codes[226][136], \"ncoding\");\n  memset(v25, 0, sizeof(v25));\n  v3 = &codes[226][106];\n  v4 = 104LL;\n  v25[116] = 1;\n  *(__m128i *)&codes[226][120] = _mm_load_si128((const __m128i *)&xmmword_5150);\n  do {\n    ++v3;\n    ++v25[v4];\n    v4 = (unsigned char)*(v3 - 1);\n  } while ((uint8_t)v4);\n  v5 = 0LL;\n  v6 = (char *)v25;\n  do {\n    v6 += 16;\n    v5 = _mm_sub_epi32(\n        v5, _mm_cmpeq_epi32(_mm_cmpeq_epi32((__m128i)0LL, *((__m128i *)v6 - 1)),\n                            (__m128i)0LL));\n  } while (v26 != v6);\n  v7 = _mm_add_epi32(v5, _mm_srli_si128(v5, 8));\n  v8 = _mm_srli_si128(v7, 4);\n  v9 = _mm_add_epi32(v7, v8);\n  v10 = _mm_cvtsi128_si32(v9);\n  v11 = (char *)libmin_malloc(v10);\n  v12 = (int *)libmin_malloc(4LL * v10);\n  v13 = 0;\n  v14 = v12;\n  v15 = 0LL;\n  while (1) {\n    v16 = v25[v15];\n    if (v16) {\n      v17 = v13++;\n      v11[v17] = v15;\n      v14[v17] = v16;\n    }\n    if (++v15 == 256) {\n      v18 = v26;\n      v24 = buildHuffmanTree(v11, v14, v10);\n      memset(v26, 0, 65536uLL);\n      v19 = 0LL;\n      generateCodes(v24, &codes[226][152], 0, (char(*)[256])v26);\n      libmin_printf(\"Huffman Codes:\\n\", *(double *)v8.m128i_i64,\n                    *(double *)v9.m128i_i64, 0.0);\n      while (1) {\n        if (v25[v19]) libmin_printf(\"'%c': %s\\n\", (unsigned int)v19, v18);\n        ++v19;\n        v18 += 256;\n        if (v19 == 256) {\n          memset(&codes[227][168], 0, 1008uLL);\n          v20 = codes[226][104];\n          *(long double *)&codes[227][152] = 0LL;\n          for (i = &codes[226][105]; v20; v20 = *(i - 1)) {\n            ++i;\n            libmin_strcat(&codes[227][152],\n                          &v26[256 * (unsigned long long)v20]);\n          }\n          libmin_printf(\"\\nEncoded string:\\n%s\\n\", &codes[227][152]);\n          v22 = 8 * libmin_strlen(&codes[226][104]);\n          v23 = libmin_strlen(&codes[227][152]);\n          libmin_printf(\"\\nCompression Metrics:\\n\", 0.0);\n          libmin_printf(\"Original size: %d bits\\n\", v22);\n          libmin_printf(\"Encoded size: %d bits\\n\", v23);\n          libmin_printf(\"Compression ratio: %.2f%%\\n\",\n                        (double)v23 / (double)v22 * 100.0);\n          *(long double *)&codes[231][152] = 0LL;\n          memset(&codes[231][168], 0, 1008uLL);\n          decodeString(v24, &codes[227][152], &codes[231][152]);\n          libmin_printf(\"\\nDecoded string:\\n%s\\n\", &codes[231][152]);\n          if (libmin_strcmp(&codes[226][104], &codes[231][152]))\n            libmin_printf(\n                \"\\nError: decoded string does not match the original input.\\n\");\n          else\n            libmin_printf(\n                \"\\nDecompression verified: decoded string matches the original \"\n                \"input.\\n\");\n          libmin_free(v11);\n          libmin_free(v14);\n          libmin_success();\n        }\n      }\n    }\n  }\n}", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    -0x10000(%rsp),%r11\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\ncmp    %r11,%rsp\njne    1136 <main+0x16>\nsub    $0xd68,%rsp\nmovdqa 0x3fea(%rip),%xmm0\nmov    $0x80,%ecx\nmov    %fs:0x28,%rax\nmov    %rax,0x10d58(%rsp)\nxor    %eax,%eax\nlea    0x20(%rsp),%r13\nmovabs $0x676e69646f636e,%rax\nmovaps %xmm0,0x10420(%rsp)\nmov    %rax,0x10440(%rsp)\nmov    %r13,%rdi\nxor    %eax,%eax\nmovdqa 0x3fb6(%rip),%xmm0\nrep stos %rax,%es:(%rdi)\nlea    0x10422(%rsp),%rdx\nmov    $0x68,%eax\nmovl   $0x1,0x1f0(%rsp)\nmovaps %xmm0,0x10430(%rsp)\nnopl   (%rax)\nadd    $0x1,%rdx\naddl   $0x1,0x20(%rsp,%rax,4)\nmovzbl -0x1(%rdx),%eax\ntest   %al,%al\njne    11c0 <main+0xa0>\nlea    0x420(%rsp),%rcx\npxor   %xmm1,%xmm1\nmov    %r13,%rax\nmov    %rcx,0x8(%rsp)\nmovdqa %xmm1,%xmm2\nnopl   0x0(%rax)\nmovdqa %xmm2,%xmm0\nadd    $0x10,%rax\npcmpeqd -0x10(%rax),%xmm0\npcmpeqd %xmm2,%xmm0\npsubd  %xmm0,%xmm1\ncmp    %rax,0x8(%rsp)\njne    11f0 <main+0xd0>\nmovdqa %xmm1,%xmm0\npsrldq $0x8,%xmm0\npaddd  %xmm0,%xmm1\nmovdqa %xmm1,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm1\nmovd   %xmm1,%r14d\nmovslq %r14d,%rbx\nmov    %rbx,%rdi\ncall   2810 <libmin_malloc>\nlea    0x0(,%rbx,4),%rdi\nmov    %rax,%r12\ncall   2810 <libmin_malloc>\nxor    %ecx,%ecx\nmov    %rax,%rbp\nxor    %eax,%eax\nnopl   (%rax)\nmov    0x0(%r13,%rax,4),%edx\ntest   %edx,%edx\nje     1267 <main+0x147>\nmovslq %ecx,%rsi\nadd    $0x1,%ecx\nmov    %al,(%r12,%rsi,1)\nmov    %edx,0x0(%rbp,%rsi,4)\nadd    $0x1,%rax\ncmp    $0x100,%rax\njne    1250 <main+0x130>\nmov    %r14d,%edx\nmov    %rbp,%rsi\nlea    0x3d94(%rip),%r14\nmov    %r12,%rdi\ncall   18b0 <buildHuffmanTree>\nmov    0x8(%rsp),%r15\nmov    $0x10000,%edx\nxor    %esi,%esi\nmov    %rax,%rbx\nmov    %rax,0x10(%rsp)\nmov    %r15,%rdi\ncall   10d0 <memset@plt>\nmov    %rbx,%rdi\nmov    %r15,%rcx\nxor    %edx,%edx\nlea    0x10450(%rsp),%rsi\nxor    %ebx,%ebx\ncall   19e0 <generateCodes>\nlea    0x3d42(%rip),%rdi\nxor    %eax,%eax\ncall   4b50 <libmin_printf>\njmp    12e4 <main+0x1c4>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rbx\nadd    $0x100,%r15\ncmp    $0x100,%rbx\nje     12fe <main+0x1de>\nmov    0x0(%r13,%rbx,4),%eax\nmov    %ebx,%esi\ntest   %eax,%eax\nje     12d0 <main+0x1b0>\nmov    %r15,%rdx\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   4b50 <libmin_printf>\njmp    12d0 <main+0x1b0>\nxor    %eax,%eax\nlea    0x10560(%rsp),%rdi\npxor   %xmm0,%xmm0\nmov    $0x7e,%ecx\nrep stos %rax,%es:(%rdi)\nmovzbl 0x10420(%rsp),%eax\nmovaps %xmm0,0x10550(%rsp)\nlea    0x10421(%rsp),%rbx\nlea    0x10550(%rsp),%r14\ntest   %al,%al\nje     1367 <main+0x247>\nnopl   0x0(%rax,%rax,1)\nmovzbl %al,%esi\nmov    0x8(%rsp),%rcx\nmov    %r14,%rdi\nadd    $0x1,%rbx\nmov    %rsi,%rax\nshl    $0x8,%rax\nlea    (%rcx,%rax,1),%rsi\ncall   4d60 <libmin_strcat>\nmovzbl -0x1(%rbx),%eax\ntest   %al,%al\njne    1340 <main+0x220>\nmov    %r14,%rsi\nlea    0x3cad(%rip),%rdi\nxor    %eax,%eax\ncall   4b50 <libmin_printf>\nlea    0x10420(%rsp),%r8\nmov    %r8,%rdi\nmov    %r8,0x18(%rsp)\ncall   4e10 <libmin_strlen>\nmov    %r14,%rdi\nlea    0x0(,%rax,8),%ebx\ncall   4e10 <libmin_strlen>\nlea    0x3c90(%rip),%rdi\nmov    %rax,%r13\nmov    %eax,0x8(%rsp)\nxor    %eax,%eax\ncall   4b50 <libmin_printf>\nmov    %ebx,%esi\nlea    0x3c90(%rip),%rdi\nxor    %eax,%eax\ncall   4b50 <libmin_printf>\nmov    0x8(%rsp),%esi\nlea    0x3c96(%rip),%rdi\nxor    %eax,%eax\ncall   4b50 <libmin_printf>\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\nlea    0x3c97(%rip),%rdi\ncvtsi2sd %ebx,%xmm1\nmov    $0x1,%eax\ncvtsi2sd %r13d,%xmm0\nlea    0x10950(%rsp),%r13\ndivsd  %xmm1,%xmm0\nmulsd  0x3d34(%rip),%xmm0\ncall   4b50 <libmin_printf>\nxor    %eax,%eax\nmov    $0x7e,%ecx\npxor   %xmm0,%xmm0\nlea    0x10960(%rsp),%rdi\nmov    %r13,%rdx\nmov    %r14,%rsi\nmovaps %xmm0,0x10950(%rsp)\nrep stos %rax,%es:(%rdi)\nmov    0x10(%rsp),%rdi\ncall   25b0 <decodeString>\nmov    %r13,%rsi\nlea    0x3c53(%rip),%rdi\nxor    %eax,%eax\ncall   4b50 <libmin_printf>\nmov    0x18(%rsp),%rdi\nmov    %r13,%rsi\ncall   4d90 <libmin_strcmp>\ntest   %eax,%eax\njne    14a3 <main+0x383>\nlea    0x3c50(%rip),%rdi\nxor    %eax,%eax\ncall   4b50 <libmin_printf>\nmov    %r12,%rdi\ncall   28c0 <libmin_free>\nmov    %rbp,%rdi\ncall   28c0 <libmin_free>\ncall   4e40 <libmin_success>\nmov    0x10d58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    14b3 <main+0x393>\nadd    $0x10d68,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x3c4e(%rip),%rdi\nxor    %eax,%eax\ncall   4b50 <libmin_printf>\njmp    1467 <main+0x347>\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "minHeapify", "content": "// Heapify at given index (min-heap)\nvoid minHeapify(MinHeap* minHeap, int idx) {\n    int smallest = idx;\n    int left = 2 * idx + 1;\n    int right = 2 * idx + 2;\n    \n    if (left < minHeap->size && minHeap->array[left]->freq < minHeap->array[smallest]->freq)\n        smallest = left;\n    if (right < minHeap->size && minHeap->array[right]->freq < minHeap->array[smallest]->freq)\n        smallest = right;\n    if (smallest != idx) {\n        swapNodes(&minHeap->array[smallest], &minHeap->array[idx]);\n        minHeapify(minHeap, smallest);\n    }\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "minHeapify", "address": "0x1640", "label": "minHeapify", "content": "void __fastcall minHeapify(MinHeap *minHeap, int idx)\n{\n  int size; // r10d\n  HuffmanNode **array; // rcx\n  __int64 v5; // r9\n  HuffmanNode **v6; // r8\n  HuffmanNode *v7; // rdi\n  HuffmanNode **v8; // rax\n  int v9; // edx\n  int v10; // eax\n  HuffmanNode **v11; // rbx\n\n  size = minHeap->size;\n  while ( 1 )\n  {\n    v9 = 2 * idx + 1;\n    v10 = 2 * idx + 2;\n    if ( size > v9 )\n    {\n      array = minHeap->array;\n      v5 = v9;\n      v6 = &array[v9];\n      v7 = *v6;\n      if ( (*v6)->freq < array[idx]->freq )\n      {\n        if ( size <= v10 )\n          goto LABEL_4;\n        goto LABEL_9;\n      }\n    }\n    if ( size <= v10 )\n      break;\n    array = minHeap->array;\n    v9 = idx;\n    v5 = idx;\nLABEL_9:\n    v6 = &array[v5];\n    v11 = &array[v10];\n    v7 = *v6;\n    if ( (*v11)->freq < (*v6)->freq )\n    {\n      v7 = *v11;\n      v6 = &array[v10];\n      v9 = 2 * idx + 2;\n    }\nLABEL_4:\n    if ( v9 == idx )\n      return;\n    v8 = &array[idx];\n    idx = v9;\n    *v6 = *v8;\n    *v8 = v7;\n  }\n}\n"}, "pseudo_normalize": "void minHeapify(MinHeap *minHeap, int idx) {\n  int size;\n  HuffmanNode **array;\n  long long v5;\n  HuffmanNode **v6;\n  HuffmanNode *v7;\n  HuffmanNode **v8;\n  int v9;\n  int v10;\n  HuffmanNode **v11;\n  size = minHeap->size;\n  while (1) {\n    v9 = 2 * idx + 1;\n    v10 = 2 * idx + 2;\n    if (size > v9) {\n      array = minHeap->array;\n      v5 = v9;\n      v6 = &array[v9];\n      v7 = *v6;\n      if ((*v6)->freq < array[idx]->freq) {\n        if (size <= v10) goto LABEL_4;\n        goto LABEL_9;\n      }\n    }\n    if (size <= v10) break;\n    array = minHeap->array;\n    v9 = idx;\n    v5 = idx;\n  LABEL_9:\n    v6 = &array[v5];\n    v11 = &array[v10];\n    v7 = *v6;\n    if ((*v11)->freq < (*v6)->freq) {\n      v7 = *v11;\n      v6 = &array[v10];\n      v9 = 2 * idx + 2;\n    }\n  LABEL_4:\n    if (v9 == idx) return;\n    v8 = &array[idx];\n    idx = v9;\n    *v6 = *v8;\n    *v8 = v7;\n  }\n}", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<minHeapify>:\nendbr64\npush   %rbp\nmov    %rdi,%r11\npush   %rbx\nmov    (%rdi),%r10d\njmp    1688 <minHeapify+0x48>\nxchg   %ax,%ax\nmov    0x8(%r11),%rcx\nmovslq %edx,%r9\nmovslq %esi,%rbx\nlea    (%rcx,%r9,8),%r8\nmov    (%rcx,%rbx,8),%rbx\nmov    (%r8),%rdi\nmov    0x4(%rbx),%ebx\ncmp    %ebx,0x4(%rdi)\njge    1696 <minHeapify+0x56>\ncmp    %eax,%r10d\njg     16a4 <minHeapify+0x64>\ncmp    %esi,%edx\nje     16d0 <minHeapify+0x90>\nmovslq %esi,%rsi\nlea    (%rcx,%rsi,8),%rax\nmov    %edx,%esi\nmov    (%rax),%rcx\nmov    %rcx,(%r8)\nmov    %rdi,(%rax)\nlea    (%rsi,%rsi,1),%eax\nlea    0x1(%rax),%edx\nadd    $0x2,%eax\ncmp    %edx,%r10d\njg     1650 <minHeapify+0x10>\ncmp    %eax,%r10d\njle    16d0 <minHeapify+0x90>\nmov    0x8(%r11),%rcx\nmov    %esi,%edx\nmovslq %esi,%r9\nmovslq %eax,%rdi\nlea    (%rcx,%r9,8),%r8\nlea    (%rcx,%rdi,8),%rbx\nmov    (%r8),%rdi\nmov    (%rbx),%rbp\nmov    0x4(%rdi),%r9d\ncmp    %r9d,0x4(%rbp)\njge    1672 <minHeapify+0x32>\nmov    %rbp,%rdi\nmov    %rbx,%r8\nmov    %eax,%edx\njmp    1672 <minHeapify+0x32>\nnopl   0x0(%rax)\npop    %rbx\npop    %rbp\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "swapNodes", "content": "// Swap two Huffman nodes\nvoid swapNodes(HuffmanNode** a, HuffmanNode** b) {\n    HuffmanNode* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O3.pseudo", "function_name": "swapNodes", "address": "0x1620", "label": "swapNodes", "content": "void __fastcall swapNodes(HuffmanNode **a, HuffmanNode **b)\n{\n  HuffmanNode *v2; // rax\n\n  v2 = *a;\n  *a = *b;\n  *b = v2;\n}\n"}, "pseudo_normalize": "void swapNodes(HuffmanNode **a, HuffmanNode **b) {\n  HuffmanNode *v2;\n  v2 = *a;\n  *a = *b;\n  *b = v2;\n}", "binary": "huff-encode/huff-encode.host.O3", "assembly": "<swapNodes>:\nendbr64\nmov    (%rdi),%rax\nmov    (%rsi),%rdx\nmov    %rdx,(%rdi)\nmov    %rax,(%rsi)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "idct-alg/idct-alg.c", "function_name": "C", "content": "#include \"libmin.h\"\n\n#define N 8\n#define PI 3.14159265358979323846\n\ndouble C(int u) {\n    return (u == 0) ? libmin_sqrt(1.0 / N) : libmin_sqrt(2.0 / N);\n}\n"}, "pseudo": {"path": "idct-alg/idct-alg.host.O3.pseudo", "function_name": "C", "address": "0x12c0", "label": "C", "content": "double __fastcall C(int u)\n{\n  double v1; // xmm1_8\n\n  return libmin_sqrt(v1);\n}\n"}, "pseudo_normalize": "", "binary": "idct-alg/idct-alg.host.O3", "assembly": "<C>:\nendbr64\ntest   %edi,%edi\njne    12d8 <C+0x18>\nmovsd  0x4d50(%rip),%xmm0\njmp    4210 <libmin_sqrt>\nnopl   (%rax)\nmovsd  0x4d48(%rip),%xmm0\njmp    4210 <libmin_sqrt>\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "idct-alg/idct-alg.c", "function_name": "idct_2d", "content": "void idct_2d(double input[N][N], double output[N][N]) {\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n            double sum = 0.0;\n            for (int u = 0; u < N; u++) {\n                for (int v = 0; v < N; v++) {\n                    sum += C(u) * C(v) * input[u][v] *\n                        libmin_cos(((2 * x + 1) * u * PI) / (2 * N)) *\n                        libmin_cos(((2 * y + 1) * v * PI) / (2 * N));\n                }\n            }\n            output[x][y] = sum;\n        }\n    }\n}\n"}, "pseudo": {"path": "idct-alg/idct-alg.host.O3.pseudo", "function_name": "idct_2d", "address": "0x12f0", "label": "idct_2d", "content": "void __fastcall idct_2d(double (*input)[8], double (*output)[8])\n{\n  double v2; // xmm1_8\n  int v3; // r13d\n  double *v4; // r12\n  int v5; // r15d\n  int j; // r14d\n  int v7; // ebp\n  __int64 v8; // rbx\n  double v9; // xmm0_8\n  double v10; // xmm0_8\n  double v11; // xmm0_8\n  int v12; // ebp\n  __int64 v13; // rbx\n  double v14; // xmm0_8\n  double sum; // [rsp+8h] [rbp-70h]\n  double v16; // [rsp+18h] [rbp-60h]\n  double v17; // [rsp+18h] [rbp-60h]\n  double v18; // [rsp+18h] [rbp-60h]\n  double v19; // [rsp+18h] [rbp-60h]\n  int i; // [rsp+24h] [rbp-54h]\n  double *v21; // [rsp+28h] [rbp-50h]\n\n  for ( i = 1; i != 17; i += 2 )\n  {\n    v3 = 1;\n    v21 = (double *)output;\n    do\n    {\n      sum = 0.0;\n      v4 = (double *)input;\n      v5 = 0;\n      for ( j = 0; j != 8; ++j )\n      {\n        if ( !j )\n        {\n          v12 = 0;\n          v13 = 0LL;\n          v2 = (double)v5;\n          do\n          {\n            v19 = libmin_sqrt(v2);\n            v14 = libmin_sqrt(v2) * v19 * v4[v13++];\n            v12 += v3;\n            v18 = v14 * libmin_cos(v2);\n            sum = libmin_cos(v2) * v18 + sum;\n          }\n          while ( v13 != 8 );\n          v4 += 8;\n          v5 += i;\n          j = 1;\n        }\n        v7 = 0;\n        v8 = 0LL;\n        do\n        {\n          v17 = libmin_sqrt(v2);\n          v11 = libmin_sqrt(v2);\n          v9 = v11 * v17 * v4[v8++];\n          v7 += v3;\n          v16 = v9 * libmin_cos(v2);\n          v10 = libmin_cos(v2) * v16 + sum;\n          sum = v10;\n        }\n        while ( v8 != 8 );\n        v4 += 8;\n        v5 += i;\n      }\n      v3 += 2;\n      *v21++ = v10;\n    }\n    while ( v3 != 17 );\n    ++output;\n  }\n}\n"}, "pseudo_normalize": "void idct_2d(double (*input)[8], double (*output)[8]) {\n  double v2;\n  int v3;\n  double *v4;\n  int v5;\n  int j;\n  int v7;\n  long long v8;\n  double v9;\n  double v10;\n  double v11;\n  int v12;\n  long long v13;\n  double v14;\n  double sum;\n  double v16;\n  double v17;\n  double v18;\n  double v19;\n  int i;\n  double *v21;\n  for (i = 1; i != 17; i += 2) {\n    v3 = 1;\n    v21 = (double *)output;\n    do {\n      sum = 0.0;\n      v4 = (double *)input;\n      v5 = 0;\n      for (j = 0; j != 8; ++j) {\n        if (!j) {\n          v12 = 0;\n          v13 = 0LL;\n          v2 = (double)v5;\n          do {\n            v19 = libmin_sqrt(v2);\n            v14 = libmin_sqrt(v2) * v19 * v4[v13++];\n            v12 += v3;\n            v18 = v14 * libmin_cos(v2);\n            sum = libmin_cos(v2) * v18 + sum;\n          } while (v13 != 8);\n          v4 += 8;\n          v5 += i;\n          j = 1;\n        }\n        v7 = 0;\n        v8 = 0LL;\n        do {\n          v17 = libmin_sqrt(v2);\n          v11 = libmin_sqrt(v2);\n          v9 = v11 * v17 * v4[v8++];\n          v7 += v3;\n          v16 = v9 * libmin_cos(v2);\n          v10 = libmin_cos(v2) * v16 + sum;\n          sum = v10;\n        } while (v8 != 8);\n        v4 += 8;\n        v5 += i;\n      }\n      v3 += 2;\n      *v21++ = v10;\n    } while (v3 != 17);\n    ++output;\n  }\n}", "binary": "idct-alg/idct-alg.host.O3", "assembly": "<idct_2d>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,0x30(%rsp)\nmov    %rsi,0x38(%rsp)\nmovl   $0x1,0x24(%rsp)\nmov    0x38(%rsp),%rax\nmov    $0x1,%r13d\nmov    %rax,0x28(%rsp)\nnopl   0x0(%rax)\nmovq   $0x0,0x8(%rsp)\nmov    0x30(%rsp),%r12\nxor    %r15d,%r15d\nxor    %r14d,%r14d\ntest   %r14d,%r14d\nje     1430 <idct_2d+0x140>\npxor   %xmm4,%xmm4\nxor    %ebp,%ebp\nxor    %ebx,%ebx\ncvtsi2sd %r15d,%xmm4\nmovsd  %xmm4,0x10(%rsp)\njmp    13f2 <idct_2d+0x102>\nnopl   (%rax)\nmov    0x4cc1(%rip),%rax\nmovq   %rax,%xmm0\ncall   4210 <libmin_sqrt>\nmulsd  0x18(%rsp),%xmm0\nmovsd  0x4cb1(%rip),%xmm5\nmulsd  (%r12,%rbx,8),%xmm0\nadd    $0x1,%rbx\nmulsd  0x10(%rsp),%xmm5\nmovsd  %xmm0,0x18(%rsp)\nmovsd  0x4c9b(%rip),%xmm0\nmulsd  %xmm5,%xmm0\ncall   3a70 <libmin_cos>\nmovsd  0x18(%rsp),%xmm6\nmulsd  %xmm0,%xmm6\npxor   %xmm0,%xmm0\ncvtsi2sd %ebp,%xmm0\nmulsd  0x4c70(%rip),%xmm0\nadd    %r13d,%ebp\nmulsd  0x4c6d(%rip),%xmm0\nmovsd  %xmm6,0x18(%rsp)\ncall   3a70 <libmin_cos>\nmulsd  0x18(%rsp),%xmm0\naddsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncmp    $0x8,%rbx\nje     1520 <idct_2d+0x230>\nmov    0x4c2f(%rip),%rax\nmovq   %rax,%xmm0\ncall   4210 <libmin_sqrt>\nmovsd  %xmm0,0x18(%rsp)\ntest   %rbx,%rbx\njne    1360 <idct_2d+0x70>\nmov    0x4c07(%rip),%rax\nmovq   %rax,%xmm0\ncall   4210 <libmin_sqrt>\njmp    1371 <idct_2d+0x81>\nnopl   0x0(%rax,%rax,1)\npxor   %xmm1,%xmm1\nxor    %ebp,%ebp\nxor    %ebx,%ebx\ncvtsi2sd %r15d,%xmm1\nmovsd  %xmm1,0x10(%rsp)\njmp    14e2 <idct_2d+0x1f2>\nnopl   0x0(%rax,%rax,1)\nmov    0x4bc9(%rip),%rax\nmovq   %rax,%xmm0\ncall   4210 <libmin_sqrt>\nmulsd  0x18(%rsp),%xmm0\nmovsd  0x4bc1(%rip),%xmm2\nmulsd  (%r12,%rbx,8),%xmm0\nadd    $0x1,%rbx\nmulsd  0x10(%rsp),%xmm2\nmovsd  %xmm0,0x18(%rsp)\nmovsd  0x4bab(%rip),%xmm0\nmulsd  %xmm2,%xmm0\ncall   3a70 <libmin_cos>\nmovsd  0x18(%rsp),%xmm3\nmulsd  %xmm0,%xmm3\npxor   %xmm0,%xmm0\ncvtsi2sd %ebp,%xmm0\nmulsd  0x4b80(%rip),%xmm0\nadd    %r13d,%ebp\nmulsd  0x4b7d(%rip),%xmm0\nmovsd  %xmm3,0x18(%rsp)\ncall   3a70 <libmin_cos>\nmulsd  0x18(%rsp),%xmm0\naddsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncmp    $0x8,%rbx\nje     1580 <idct_2d+0x290>\nmov    0x4b37(%rip),%rax\nmovq   %rax,%xmm0\ncall   4210 <libmin_sqrt>\nmovsd  %xmm0,0x18(%rsp)\ntest   %rbx,%rbx\nje     1450 <idct_2d+0x160>\nmov    0x4b1f(%rip),%rax\nmovq   %rax,%xmm0\ncall   4210 <libmin_sqrt>\njmp    1461 <idct_2d+0x171>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r14d\nadd    $0x40,%r12\nadd    0x24(%rsp),%r15d\ncmp    $0x8,%r14d\njne    133c <idct_2d+0x4c>\nmov    0x28(%rsp),%rax\nadd    $0x2,%r13d\nmovsd  %xmm0,(%rax)\nadd    $0x8,%rax\nmov    %rax,0x28(%rsp)\ncmp    $0x11,%r13d\njne    1328 <idct_2d+0x38>\naddl   $0x2,0x24(%rsp)\nmov    0x24(%rsp),%eax\naddq   $0x40,0x38(%rsp)\ncmp    $0x11,%eax\njne    1314 <idct_2d+0x24>\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxchg   %ax,%ax\nadd    $0x40,%r12\nadd    0x24(%rsp),%r15d\nmov    $0x1,%r14d\njmp    1345 <idct_2d+0x55>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "idct-alg/idct-alg.c", "function_name": "main", "content": "int main() {\n    // Example: DCT domain input (can be real JPEG coefficients)\n    double input[N][N] = {\n        {52, 0, 0, 0, 0, 0, 0, 0},\n        {30, 0, 0, 0, 0, 0, 0, 0},\n        {20, 0, 0, 0, 0, 0, 0, 0},\n        {10, 0, 0, 0, 0, 0, 0, 0},\n        { 5, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n    };\n\n    double output[N][N] = {0};\n\n    idct_2d(input, output);\n    print_matrix(output, \"IDCT Output\");\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "idct-alg/idct-alg.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double input[8][8]; // [rsp+0h] [rbp-418h] BYREF\n  double output[8][8]; // [rsp+200h] [rbp-218h] BYREF\n  unsigned __int64 v5; // [rsp+408h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[4][0] = 5.0;\n  input[3][0] = 10.0;\n  memset(output, 0, sizeof(output));\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double input[8][8];\n  double output[8][8];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[4][0] = 5.0;\n  input[3][0] = 10.0;\n  memset(output, 0, sizeof(output));\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}", "binary": "idct-alg/idct-alg.host.O3", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    $0x40,%ecx\nsub    $0x410,%rsp\nmov    0x4f28(%rip),%rdx\nmov    0x4f41(%rip),%rsi\nmov    %fs:0x28,%rax\nmov    %rax,0x408(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdi\nlea    0x200(%rsp),%rbp\nrep stos %rax,%es:(%rdi)\nmov    0x4f11(%rip),%rcx\nmov    %rdx,(%rsp)\nlea    0x200(%rsp),%rdi\nmov    0x4eee(%rip),%rdx\nmov    %rsi,0x100(%rsp)\nmov    %rbp,%rsi\nmov    %rcx,0xc0(%rsp)\nmov    $0x40,%ecx\nrep stos %rax,%es:(%rdi)\nmov    %rdx,0x40(%rsp)\nmov    0x4ecf(%rip),%rdx\nmov    %rsp,%rdi\nmov    %rdx,0x80(%rsp)\ncall   12f0 <idct_2d>\nlea    0x4e78(%rip),%rsi\nmov    %rbp,%rdi\ncall   15a0 <print_matrix>\ncall   4460 <libmin_success>\nmov    0x408(%rsp),%rax\nsub    %fs:0x28,%rax\njne    11c3 <main+0xc3>\nadd    $0x410,%rsp\nxor    %eax,%eax\npop    %rbp\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "idct-alg/idct-alg.c", "function_name": "print_matrix", "content": "void print_matrix(double mat[N][N], const char* label) {\n    libmin_printf(\"%s:\\n\", label);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++)\n            libmin_printf(\"%8.2f \", mat[i][j]);\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "idct-alg/idct-alg.host.O3.pseudo", "function_name": "print_matrix", "address": "0x15a0", "label": "print_matrix", "content": "void __fastcall print_matrix(double (*mat)[8], const char *label)\n{\n  double *v2; // rbp\n  double *v3; // rbx\n  double v4; // xmm0_8\n\n  v2 = &(*mat)[8];\n  libmin_printf(\"%s:\\n\", label);\n  do\n  {\n    v3 = v2 - 8;\n    do\n    {\n      v4 = *v3++;\n      libmin_printf(\"%8.2f \", v4);\n    }\n    while ( v3 != v2 );\n    v2 = v3 + 8;\n    libmin_printf((char *)\"\\n\");\n  }\n  while ( v3 + 8 != &(*mat)[72] );\n  libmin_printf((char *)\"\\n\");\n}\n"}, "pseudo_normalize": "void print_matrix(double (*mat)[8], const char *label) {\n  double *v2;\n  double *v3;\n  double v4;\n  v2 = &(*mat)[8];\n  libmin_printf(\"%s:\\n\", label);\n  do {\n    v3 = v2 - 8;\n    do {\n      v4 = *v3++;\n      libmin_printf(\"%8.2f \", v4);\n    } while (v3 != v2);\n    v2 = v3 + 8;\n    libmin_printf((char *)\"\\n\");\n  } while (v3 + 8 != &(*mat)[72]);\n  libmin_printf((char *)\"\\n\");\n}", "binary": "idct-alg/idct-alg.host.O3", "assembly": "<print_matrix>:\nendbr64\npush   %r14\nxor    %eax,%eax\nlea    0x4a58(%rip),%r14\npush   %r13\nmov    %rdi,%r13\nlea    0x4a49(%rip),%rdi\npush   %r12\nlea    0x4a45(%rip),%r12\npush   %rbp\nlea    0x40(%r13),%rbp\nadd    $0x240,%r13\npush   %rbx\ncall   3700 <libmin_printf>\ncs nopw 0x0(%rax,%rax,1)\nlea    -0x40(%rbp),%rbx\nnopl   0x0(%rax)\nmovsd  (%rbx),%xmm0\nmov    %r12,%rdi\nmov    $0x1,%eax\nadd    $0x8,%rbx\ncall   3700 <libmin_printf>\ncmp    %rbp,%rbx\njne    15e8 <print_matrix+0x48>\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    0x40(%rbx),%rbp\ncall   3700 <libmin_printf>\ncmp    %r13,%rbp\njne    15e0 <print_matrix+0x40>\npop    %rbx\nmov    %r14,%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %r14\njmp    3700 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "indirect-test/indirect-test.c", "function_name": "bar", "content": "void\nbar(int (*pfoo)(int x))\n{\n  // call a function through a pointer\n  aglobal = (*pfoo)(aglobal);\n\n  // and implement a switch statement\n  switch (aglobal & 0x7)\n  {\n  case 0:\n    aglobal++;\n    break;\n\n  case 1:\n    aglobal--;\n    break;\n\n  case 2:\n    aglobal *= 2;\n    break;\n\n  case 3:\n    aglobal /= 2;\n    break;\n\n  case 4:\n    aglobal %= 2;\n    break;\n\n  default:\n    aglobal = -aglobal;\n    break;\n  }\n}\n"}, "pseudo": {"path": "indirect-test/indirect-test.host.O3.pseudo", "function_name": "bar", "address": "0x1250", "label": "bar", "content": "void __fastcall bar(int (*pfoo)(int))\n{\n  int v1; // eax\n\n  v1 = pfoo(aglobal);\n  switch ( v1 & 7 )\n  {\n    case 0:\n      aglobal = v1 + 1;\n      break;\n    case 1:\n      aglobal = v1 - 1;\n      break;\n    case 2:\n      aglobal = 2 * v1;\n      break;\n    case 3:\n      aglobal = v1 / 2;\n      break;\n    case 4:\n      aglobal = v1 % 2;\n      break;\n    default:\n      aglobal = -v1;\n      break;\n  }\n}\n"}, "pseudo_normalize": "void bar(int (*pfoo)(int)) {\n  int v1;\n  v1 = pfoo(aglobal);\n  switch (v1 & 7) {\n    case 0:\n      aglobal = v1 + 1;\n      break;\n    case 1:\n      aglobal = v1 - 1;\n      break;\n    case 2:\n      aglobal = 2 * v1;\n      break;\n    case 3:\n      aglobal = v1 / 2;\n      break;\n    case 4:\n      aglobal = v1 % 2;\n      break;\n    default:\n      aglobal = -v1;\n      break;\n  }\n}", "binary": "indirect-test/indirect-test.host.O3", "assembly": "<bar>:\nendbr64\nsub    $0x8,%rsp\nmov    %rdi,%r8\nmov    0x4daf(%rip),%edi\ncall   *%r8\nmov    %eax,%edx\nand    $0x7,%edx\ncmp    $0x4,%edx\nja     12dd <bar+0x8d>\nlea    0x2d8f(%rip),%rcx\nmovslq (%rcx,%rdx,4),%rdx\nadd    %rcx,%rdx\nnotrack jmp *%rdx\nnop\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,0x4d81(%rip)\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\nmov    %eax,0x4d66(%rip)\nadd    $0x8,%rsp\nret\nnop\nadd    $0x1,%eax\nmov    %eax,0x4d57(%rip)\nadd    $0x8,%rsp\nret\nxchg   %ax,%ax\nsub    $0x1,%eax\nmov    %eax,0x4d47(%rip)\nadd    $0x8,%rsp\nret\nxchg   %ax,%ax\nadd    %eax,%eax\nmov    %eax,0x4d38(%rip)\nadd    $0x8,%rsp\nret\nneg    %eax\nmov    %eax,0x4d2b(%rip)\nadd    $0x8,%rsp\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "indirect-test/indirect-test.c", "function_name": "foo", "content": "int\nfoo(int x)\n{\n  return x*x;\n}\n"}, "pseudo": {"path": "indirect-test/indirect-test.host.O3.pseudo", "function_name": "foo", "address": "0x1240", "label": "foo", "content": "int __fastcall foo(int x)\n{\n  return x * x;\n}\n"}, "pseudo_normalize": "", "binary": "indirect-test/indirect-test.host.O3", "assembly": "<foo>:\nendbr64\nmov    %edi,%eax\nimul   %edi,%eax\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "indirect-test/indirect-test.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int (*pfoo)(int) = &foo;\n  (*pbar)(pfoo);\n  (*pbar)(pfoo);\n  (*pbar)(pfoo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "indirect-test/indirect-test.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  pbar(foo);\n  pbar(foo);\n  pbar(foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  pbar(foo);\n  pbar(foo);\n  pbar(foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}", "binary": "indirect-test/indirect-test.host.O3", "assembly": "<main>:\nendbr64\npush   %rbp\nlea    0x134(%rip),%rbp\nmov    %rbp,%rdi\ncall   *0x4f03(%rip)\nmov    %rbp,%rdi\ncall   *0x4efa(%rip)\nmov    %rbp,%rdi\ncall   *0x4ef1(%rip)\nmov    0x4ee3(%rip),%esi\nlea    0x2ee4(%rip),%rdi\nxor    %eax,%eax\ncall   33c0 <libmin_printf>\ncall   3600 <libmin_success>\nxor    %eax,%eax\npop    %rbp\nret\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "calculateCentroid", "content": "/*!\n * Calculate centoid and assign it to the cluster variable\n *\n * @param observations  an array of observations whose centroid is calculated\n * @param size  size of the observations array\n * @param centroid  a reference to cluster object to store information of\n * centroid\n */\nvoid calculateCentroid(observation observations[], size_t size,\n                       cluster* centroid)\n{\n    size_t i = 0;\n    centroid->x = 0;\n    centroid->y = 0;\n    centroid->count = size;\n    for (; i < size; i++)\n    {\n        centroid->x += observations[i].x;\n        centroid->y += observations[i].y;\n        observations[i].group = 0;\n    }\n    centroid->x /= centroid->count;\n    centroid->y /= centroid->count;\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O3.pseudo", "function_name": "calculateCentroid", "address": "0x1390", "label": "calculateCentroid", "content": "void __fastcall calculateCentroid(observation *observations, size_t size, cluster *centroid)\n{\n  __m128d v3; // xmm0\n  observation *v4; // rax\n  __m128d v5; // xmm2\n  __m128d v6; // xmm1\n\n  v3 = 0LL;\n  centroid->count = size;\n  *(_OWORD *)&centroid->x = 0LL;\n  if ( size )\n  {\n    v4 = observations;\n    do\n    {\n      v5 = *(__m128d *)&v4->x;\n      v4->group = 0;\n      ++v4;\n      v3 = _mm_add_pd(v3, v5);\n    }\n    while ( v4 != &observations[size] );\n    observations[size - 1].group = 0;\n  }\n  else\n  {\n    v3 = 0LL;\n  }\n  v6 = 0LL;\n  v6.m128d_f64[0] = (double)(int)size;\n  *(__m128d *)&centroid->x = _mm_div_pd(v3, _mm_unpacklo_pd(v6, v6));\n}\n"}, "pseudo_normalize": "void calculateCentroid(observation *observations, unsigned int size,\n                       cluster *centroid) {\n  __m128d v3;\n  observation *v4;\n  __m128d v5;\n  __m128d v6;\n  v3 = 0LL;\n  centroid->count = size;\n  *(long double *)&centroid->x = 0LL;\n  if (size) {\n    v4 = observations;\n    do {\n      v5 = *(__m128d *)&v4->x;\n      v4->group = 0;\n      ++v4;\n      v3 = _mm_add_pd(v3, v5);\n    } while (v4 != &observations[size]);\n    observations[size - 1].group = 0;\n  } else {\n    v3 = 0LL;\n  }\n  v6 = 0LL;\n  v6.m128d_f64[0] = (double)(int)size;\n  *(__m128d *)&centroid->x = _mm_div_pd(v3, _mm_unpacklo_pd(v6, v6));\n}", "binary": "k-means/k-means.host.O3", "assembly": "<calculateCentroid>:\nendbr64\npxor   %xmm0,%xmm0\nmov    %rsi,0x10(%rdx)\nmovups %xmm0,(%rdx)\ntest   %rsi,%rsi\nje     13f0 <calculateCentroid+0x60>\nlea    (%rsi,%rsi,2),%r8\nmov    %rdi,%rax\nshl    $0x3,%r8\nlea    (%rdi,%r8,1),%rcx\nnopl   0x0(%rax,%rax,1)\nmovupd (%rax),%xmm2\nmovl   $0x0,0x10(%rax)\nadd    $0x18,%rax\naddpd  %xmm2,%xmm0\ncmp    %rcx,%rax\njne    13b8 <calculateCentroid+0x28>\nmovl   $0x0,-0x8(%rdi,%r8,1)\npxor   %xmm1,%xmm1\ncvtsi2sd %rsi,%xmm1\nunpcklpd %xmm1,%xmm1\ndivpd  %xmm1,%xmm0\nmovups %xmm0,(%rdx)\nret\nxchg   %ax,%ax\npxor   %xmm0,%xmm0\njmp    13d9 <calculateCentroid+0x49>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "calculateNearst", "content": "/*!\n * Returns the index of centroid nearest to\n * given observation\n *\n * @param o  observation\n * @param clusters  array of cluster having centroids coordinates\n * @param k  size of clusters array\n *\n * @returns the index of nearest centroid for given observation\n */\nint calculateNearst(observation* o, cluster clusters[], int k)\n{\n    double minD = DBL_MAX;\n    double dist = 0;\n    int index = -1;\n    int i = 0;\n    for (; i < k; i++)\n    {\n        /* Calculate Squared Distance*/\n        dist = (clusters[i].x - o->x) * (clusters[i].x - o->x) +\n               (clusters[i].y - o->y) * (clusters[i].y - o->y);\n        if (dist < minD)\n        {\n            minD = dist;\n            index = i;\n        }\n    }\n    return index;\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O3.pseudo", "function_name": "calculateNearst", "address": "0x1310", "label": "calculateNearst", "content": "int __fastcall calculateNearst(observation *o, cluster *clusters, int k)\n{\n  int v3; // eax\n  int v4; // r8d\n  double v5; // xmm2_8\n  double v6; // xmm0_8\n  bool v7; // cc\n  double v8; // xmm0_8\n\n  if ( k <= 0 )\n    return -1;\n  v3 = 0;\n  v4 = -1;\n  v5 = 1.797693134862316e308;\n  do\n  {\n    v6 = (clusters->y - o->y) * (clusters->y - o->y) + (clusters->x - o->x) * (clusters->x - o->x);\n    v7 = v5 <= v6;\n    v8 = fmin(v6, v5);\n    if ( !v7 )\n      v4 = v3;\n    ++v3;\n    v5 = v8;\n    ++clusters;\n  }\n  while ( k != v3 );\n  return v4;\n}\n"}, "pseudo_normalize": "int calculateNearst(observation *o, cluster *clusters, int k) {\n  int v3;\n  int v4;\n  double v5;\n  double v6;\n  bool v7;\n  double v8;\n  if (k <= 0) return -1;\n  v3 = 0;\n  v4 = -1;\n  v5 = 1.797693134862316e308;\n  do {\n    v6 = (clusters->y - o->y) * (clusters->y - o->y) +\n         (clusters->x - o->x) * (clusters->x - o->x);\n    v7 = v5 <= v6;\n    v8 = fmin(v6, v5);\n    if (!v7) v4 = v3;\n    ++v3;\n    v5 = v8;\n    ++clusters;\n  } while (k != v3);\n  return v4;\n}", "binary": "k-means/k-means.host.O3", "assembly": "<calculateNearst>:\nendbr64\ntest   %edx,%edx\njle    1378 <calculateNearst+0x68>\nmovsd  (%rdi),%xmm4\nmovsd  0x8(%rdi),%xmm3\nxor    %eax,%eax\nmov    $0xffffffff,%r8d\nmovsd  0x6e47(%rip),%xmm2\nnopl   0x0(%rax)\nmovsd  (%rsi),%xmm1\nmovsd  0x8(%rsi),%xmm0\nsubsd  %xmm4,%xmm1\nsubsd  %xmm3,%xmm0\nmulsd  %xmm1,%xmm1\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncomisd %xmm0,%xmm2\nminsd  %xmm2,%xmm0\ncmova  %eax,%r8d\nadd    $0x1,%eax\nmovapd %xmm0,%xmm2\nadd    $0x18,%rsi\ncmp    %eax,%edx\njne    1338 <calculateNearst+0x28>\nmov    %r8d,%eax\nret\nnopl   0x0(%rax)\nmov    $0xffffffff,%r8d\nmov    %r8d,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "kMeans", "content": "/*!\n *    --K Means Algorithm--\n * 1. Assign each observation to one of k groups\n *    creating a random initial clustering\n * 2. Find the centroid of observations for each\n *    cluster to form new centroids\n * 3. Find the centroid which is nearest for each\n *    observation among the calculated centroids\n * 4. Assign the observation to its nearest centroid\n *    to create a new clustering.\n * 5. Repeat step 2,3,4 until there is no change\n *    the current clustering and is same as last\n *    clustering.\n *\n * @param observations  an array of observations to cluster\n * @param size  size of observations array\n * @param k  no of clusters to be made\n *\n * @returns pointer to cluster object\n */\ncluster* kMeans(observation observations[], size_t size, int k)\n{\n    cluster* clusters = NULL;\n    if (k <= 1)\n    {\n        /*\n        If we have to cluster them only in one group\n        then calculate centroid of observations and\n        that will be a ingle cluster\n        */\n        clusters = (cluster*)libmin_malloc(sizeof(cluster));\n        libmin_memset(clusters, 0, sizeof(cluster));\n        calculateCentroid(observations, size, clusters);\n    }\n    else if (k < size)\n    {\n        clusters = libmin_malloc(sizeof(cluster) * k);\n        libmin_memset(clusters, 0, k * sizeof(cluster));\n        /* STEP 1 */\n        for (size_t j = 0; j < size; j++)\n        {\n            observations[j].group = libmin_rand() % k;\n        }\n        size_t changed = 0;\n        size_t minAcceptedError =\n            size /\n            10000;  // Do until 99.99 percent points are in correct cluster\n        int t = 0;\n        do\n        {\n            /* Initialize clusters */\n            for (int i = 0; i < k; i++)\n            {\n                clusters[i].x = 0;\n                clusters[i].y = 0;\n                clusters[i].count = 0;\n            }\n            /* STEP 2*/\n            for (size_t j = 0; j < size; j++)\n            {\n                t = observations[j].group;\n                clusters[t].x += observations[j].x;\n                clusters[t].y += observations[j].y;\n                clusters[t].count++;\n            }\n            for (int i = 0; i < k; i++)\n            {\n                clusters[i].x /= clusters[i].count;\n                clusters[i].y /= clusters[i].count;\n            }\n            /* STEP 3 and 4 */\n            changed = 0;  // this variable stores change in clustering\n            for (size_t j = 0; j < size; j++)\n            {\n                t = calculateNearst(observations + j, clusters, k);\n                if (t != observations[j].group)\n                {\n                    changed++;\n                    observations[j].group = t;\n                }\n            }\n        } while (changed > minAcceptedError);  // Keep on grouping until we have\n                                               // got almost best clustering\n    }\n    else\n    {\n        /* If no of clusters is more than observations\n           each observation can be its own cluster\n        */\n        clusters = (cluster*)libmin_malloc(sizeof(cluster) * k);\n        libmin_memset(clusters, 0, k * sizeof(cluster));\n        for (int j = 0; j < size; j++)\n        {\n            clusters[j].x = observations[j].x;\n            clusters[j].y = observations[j].y;\n            clusters[j].count = 1;\n            observations[j].group = j;\n        }\n    }\n    return clusters;\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O3.pseudo", "function_name": "kMeans", "address": "0x1400", "label": "kMeans", "content": "cluster *__fastcall kMeans(observation *observations, size_t size, int k)\n{\n  observation *v3; // rbp\n  size_t v5; // r14\n  cluster *v6; // r12\n  cluster *v7; // rdx\n  int v8; // eax\n  __int128 v9; // xmm5\n  cluster *v11; // rax\n  size_t v12; // rdx\n  int *p_group; // r15\n  __int64 v14; // r14\n  cluster *v15; // r8\n  observation *v16; // rdi\n  size_t v17; // r9\n  cluster *v18; // rax\n  observation *v19; // rax\n  __int64 group; // rdx\n  __m128d v21; // xmm7\n  cluster *v22; // rdx\n  __m128d v23; // xmm0\n  cluster *v24; // rax\n  __m128d v25; // xmm0\n  __m128d v26; // xmm1\n  __int64 count; // rdx\n  __int64 v28; // rcx\n  observation *v29; // rsi\n  size_t v30; // r10\n  double *p_x; // rdx\n  double v32; // xmm2_8\n  int v33; // ecx\n  int v34; // eax\n  double v35; // xmm0_8\n  bool v36; // cc\n  double v37; // xmm0_8\n  __m128d v38; // xmm0\n  observation *v39; // rax\n  __m128d v40; // xmm6\n  __m128d v41; // xmm1\n\n  v3 = observations;\n  if ( k <= 1 )\n  {\n    v6 = (cluster *)libmin_malloc(0x18uLL);\n    libmin_memset(v6, 0, 0x18uLL);\n    v38 = 0LL;\n    v6->count = size;\n    *(_OWORD *)&v6->x = 0LL;\n    if ( size )\n    {\n      v39 = observations;\n      do\n      {\n        v40 = *(__m128d *)&v39->x;\n        v39->group = 0;\n        ++v39;\n        v38 = _mm_add_pd(v38, v40);\n      }\n      while ( v39 != &observations[size] );\n      observations[size - 1].group = 0;\n    }\n    else\n    {\n      v38 = 0LL;\n    }\n    v41 = 0LL;\n    v41.m128d_f64[0] = (double)(int)size;\n    *(__m128d *)&v6->x = _mm_div_pd(v38, _mm_unpacklo_pd(v41, v41));\n  }\n  else\n  {\n    v5 = 24LL * k;\n    if ( k < size )\n    {\n      v11 = (cluster *)libmin_malloc(v5);\n      v12 = v5;\n      p_group = &observations->group;\n      v6 = v11;\n      v14 = 0LL;\n      libmin_memset(v11, 0, v12);\n      do\n      {\n        ++v14;\n        p_group += 6;\n        *(p_group - 6) = libmin_rand() % k;\n      }\n      while ( size != v14 );\n      v15 = &v6[k];\n      v16 = &observations[size];\n      v17 = size / 0x2710;\n      do\n      {\n        v18 = v6;\n        do\n        {\n          v18->count = 0LL;\n          ++v18;\n          *(_OWORD *)&v18[-1].x = 0LL;\n        }\n        while ( v15 != v18 );\n        v19 = v3;\n        do\n        {\n          group = v19->group;\n          v21 = *(__m128d *)&v19->x;\n          ++v19;\n          v22 = &v6[group];\n          v23 = *(__m128d *)&v22->x;\n          ++v22->count;\n          *(__m128d *)&v22->x = _mm_add_pd(v23, v21);\n        }\n        while ( v16 != v19 );\n        v24 = v6;\n        do\n        {\n          count = v24->count;\n          v25 = 0LL;\n          if ( count >= 0 )\n          {\n            v25.m128d_f64[0] = (double)(int)count;\n          }\n          else\n          {\n            v28 = v24->count & 1 | (v24->count >> 1);\n            v25.m128d_f64[0] = (double)(int)v28 + (double)(int)v28;\n          }\n          v26 = *(__m128d *)&v24->x;\n          ++v24;\n          *(__m128d *)&v24[-1].x = _mm_div_pd(v26, _mm_unpacklo_pd(v25, v25));\n        }\n        while ( v15 != v24 );\n        v29 = v3;\n        v30 = 0LL;\n        do\n        {\n          p_x = &v6->x;\n          v32 = 1.797693134862316e308;\n          v33 = -1;\n          v34 = 0;\n          do\n          {\n            v35 = (p_x[1] - v29->y) * (p_x[1] - v29->y) + (*p_x - v29->x) * (*p_x - v29->x);\n            v36 = v32 <= v35;\n            v37 = fmin(v35, v32);\n            if ( !v36 )\n              v33 = v34;\n            ++v34;\n            v32 = v37;\n            p_x += 3;\n          }\n          while ( k != v34 );\n          if ( v29->group != v33 )\n          {\n            v29->group = v33;\n            ++v30;\n          }\n          ++v29;\n        }\n        while ( v29 != v16 );\n      }\n      while ( v30 > v17 );\n    }\n    else\n    {\n      v6 = (cluster *)libmin_malloc(v5);\n      libmin_memset(v6, 0, v5);\n      if ( size )\n      {\n        v7 = v6;\n        v8 = 0;\n        do\n        {\n          v9 = *(_OWORD *)&v3->x;\n          ++v7;\n          ++v3;\n          v7[-1].count = 1LL;\n          *(_OWORD *)&v7[-1].x = v9;\n          v3[-1].group = v8++;\n        }\n        while ( (_DWORD)size != v8 );\n      }\n    }\n  }\n  return v6;\n}\n"}, "pseudo_normalize": "cluster *kMeans(observation *observations, unsigned int size, int k) {\n  observation *v3;\n  unsigned int v5;\n  cluster *v6;\n  cluster *v7;\n  int v8;\n  __int128 v9;\n  cluster *v11;\n  unsigned int v12;\n  int *p_group;\n  long long v14;\n  cluster *v15;\n  observation *v16;\n  unsigned int v17;\n  cluster *v18;\n  observation *v19;\n  long long group;\n  __m128d v21;\n  cluster *v22;\n  __m128d v23;\n  cluster *v24;\n  __m128d v25;\n  __m128d v26;\n  long long count;\n  long long v28;\n  observation *v29;\n  unsigned int v30;\n  double *p_x;\n  double v32;\n  int v33;\n  int v34;\n  double v35;\n  bool v36;\n  double v37;\n  __m128d v38;\n  observation *v39;\n  __m128d v40;\n  __m128d v41;\n  v3 = observations;\n  if (k <= 1) {\n    v6 = (cluster *)libmin_malloc(24uLL);\n    libmin_memset(v6, 0, 24uLL);\n    v38 = 0LL;\n    v6->count = size;\n    *(long double *)&v6->x = 0LL;\n    if (size) {\n      v39 = observations;\n      do {\n        v40 = *(__m128d *)&v39->x;\n        v39->group = 0;\n        ++v39;\n        v38 = _mm_add_pd(v38, v40);\n      } while (v39 != &observations[size]);\n      observations[size - 1].group = 0;\n    } else {\n      v38 = 0LL;\n    }\n    v41 = 0LL;\n    v41.m128d_f64[0] = (double)(int)size;\n    *(__m128d *)&v6->x = _mm_div_pd(v38, _mm_unpacklo_pd(v41, v41));\n  } else {\n    v5 = 24LL * k;\n    if (k < size) {\n      v11 = (cluster *)libmin_malloc(v5);\n      v12 = v5;\n      p_group = &observations->group;\n      v6 = v11;\n      v14 = 0LL;\n      libmin_memset(v11, 0, v12);\n      do {\n        ++v14;\n        p_group += 6;\n        *(p_group - 6) = libmin_rand() % k;\n      } while (size != v14);\n      v15 = &v6[k];\n      v16 = &observations[size];\n      v17 = size / 10000;\n      do {\n        v18 = v6;\n        do {\n          v18->count = 0LL;\n          ++v18;\n          *(long double *)&v18[-1].x = 0LL;\n        } while (v15 != v18);\n        v19 = v3;\n        do {\n          group = v19->group;\n          v21 = *(__m128d *)&v19->x;\n          ++v19;\n          v22 = &v6[group];\n          v23 = *(__m128d *)&v22->x;\n          ++v22->count;\n          *(__m128d *)&v22->x = _mm_add_pd(v23, v21);\n        } while (v16 != v19);\n        v24 = v6;\n        do {\n          count = v24->count;\n          v25 = 0LL;\n          if (count >= 0) {\n            v25.m128d_f64[0] = (double)(int)count;\n          } else {\n            v28 = v24->count & 1 | (v24->count >> 1);\n            v25.m128d_f64[0] = (double)(int)v28 + (double)(int)v28;\n          }\n          v26 = *(__m128d *)&v24->x;\n          ++v24;\n          *(__m128d *)&v24[-1].x = _mm_div_pd(v26, _mm_unpacklo_pd(v25, v25));\n        } while (v15 != v24);\n        v29 = v3;\n        v30 = 0LL;\n        do {\n          p_x = &v6->x;\n          v32 = 1.797693134862316e308;\n          v33 = -1;\n          v34 = 0;\n          do {\n            v35 = (p_x[1] - v29->y) * (p_x[1] - v29->y) +\n                  (*p_x - v29->x) * (*p_x - v29->x);\n            v36 = v32 <= v35;\n            v37 = fmin(v35, v32);\n            if (!v36) v33 = v34;\n            ++v34;\n            v32 = v37;\n            p_x += 3;\n          } while (k != v34);\n          if (v29->group != v33) {\n            v29->group = v33;\n            ++v30;\n          }\n          ++v29;\n        } while (v29 != v16);\n      } while (v30 > v17);\n    } else {\n      v6 = (cluster *)libmin_malloc(v5);\n      libmin_memset(v6, 0, v5);\n      if (size) {\n        v7 = v6;\n        v8 = 0;\n        do {\n          v9 = *(long double *)&v3->x;\n          ++v7;\n          ++v3;\n          v7[-1].count = 1LL;\n          *(long double *)&v7[-1].x = v9;\n          v3[-1].group = v8++;\n        } while ((uint32_t)size != v8);\n      }\n    }\n  }\n  return v6;\n}", "binary": "k-means/k-means.host.O3", "assembly": "<kMeans>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\ncmp    $0x1,%edx\njle    163a <kMeans+0x23a>\nmovslq %edx,%rax\nmov    %edx,%ebx\nlea    (%rax,%rax,2),%r14\nshl    $0x3,%r14\nmov    %r14,%rdi\ncmp    %rsi,%rax\njb     148e <kMeans+0x8e>\ncall   2710 <libmin_malloc>\nxor    %esi,%esi\nmov    %r14,%rdx\nmov    %rax,%rdi\nmov    %rax,%r12\ncall   2af0 <libmin_memset>\ntest   %r13,%r13\nje     147c <kMeans+0x7c>\nmov    %r12,%rdx\nxor    %eax,%eax\nnopl   (%rax)\nmovupd 0x0(%rbp),%xmm5\nadd    $0x18,%rdx\nadd    $0x18,%rbp\nmovq   $0x1,-0x8(%rdx)\nmovups %xmm5,-0x18(%rdx)\nmov    %eax,-0x8(%rbp)\nadd    $0x1,%eax\ncmp    %eax,%r13d\njne    1458 <kMeans+0x58>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   2710 <libmin_malloc>\nmov    %r14,%rdx\nxor    %esi,%esi\nlea    0x10(%rbp),%r15\nmov    %rax,%rdi\nmov    %rax,%r12\nxor    %r14d,%r14d\ncall   2af0 <libmin_memset>\nnopw   0x0(%rax,%rax,1)\ncall   4cc0 <libmin_rand>\nxor    %edx,%edx\nadd    $0x1,%r14\nadd    $0x18,%r15\ndiv    %ebx\nmov    %edx,-0x18(%r15)\ncmp    %r14,%r13\njne    14b0 <kMeans+0xb0>\nmov    %r13,%rax\nmovsd  0x6ca3(%rip),%xmm6\npxor   %xmm5,%xmm5\nmovabs $0x346dc5d63886594b,%rdx\nmul    %rdx\nmov    %ebx,%eax\nlea    (%rax,%rax,2),%rax\nlea    (%r12,%rax,8),%r8\nlea    0x0(%r13,%r13,2),%rax\nshr    $0xb,%rdx\nlea    0x0(%rbp,%rax,8),%rdi\nmov    %rdx,%r9\nnopl   0x0(%rax)\nmov    %r12,%rax\nnopl   0x0(%rax,%rax,1)\nmovq   $0x0,0x10(%rax)\nadd    $0x18,%rax\nmovups %xmm5,-0x18(%rax)\ncmp    %rax,%r8\njne    1510 <kMeans+0x110>\nmov    %rbp,%rax\nnopl   0x0(%rax,%rax,1)\nmovslq 0x10(%rax),%rdx\nmovupd (%rax),%xmm7\nadd    $0x18,%rax\nlea    (%rdx,%rdx,2),%rdx\nlea    (%r12,%rdx,8),%rdx\nmovupd (%rdx),%xmm0\naddq   $0x1,0x10(%rdx)\naddpd  %xmm7,%xmm0\nmovups %xmm0,(%rdx)\ncmp    %rax,%rdi\njne    1530 <kMeans+0x130>\nmov    %r12,%rax\njmp    1582 <kMeans+0x182>\nxchg   %ax,%ax\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\nmovupd (%rax),%xmm1\nunpcklpd %xmm0,%xmm0\nadd    $0x18,%rax\ndivpd  %xmm0,%xmm1\nmovups %xmm1,-0x18(%rax)\ncmp    %rax,%r8\nje     15b0 <kMeans+0x1b0>\nmov    0x10(%rax),%rdx\ntest   %rdx,%rdx\njns    1560 <kMeans+0x160>\nmov    %rdx,%rcx\nand    $0x1,%edx\npxor   %xmm0,%xmm0\nshr    %rcx\nor     %rdx,%rcx\ncvtsi2sd %rcx,%xmm0\naddsd  %xmm0,%xmm0\njmp    1569 <kMeans+0x169>\ncs nopw 0x0(%rax,%rax,1)\nmov    %rbp,%rsi\nxor    %r10d,%r10d\ncs nopw 0x0(%rax,%rax,1)\nmovsd  (%rsi),%xmm4\nmovsd  0x8(%rsi),%xmm3\nmov    %r12,%rdx\nmovapd %xmm6,%xmm2\nmov    $0xffffffff,%ecx\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmovsd  (%rdx),%xmm1\nmovsd  0x8(%rdx),%xmm0\nsubsd  %xmm4,%xmm1\nsubsd  %xmm3,%xmm0\nmulsd  %xmm1,%xmm1\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncomisd %xmm0,%xmm2\nminsd  %xmm2,%xmm0\ncmova  %eax,%ecx\nadd    $0x1,%eax\nmovapd %xmm0,%xmm2\nadd    $0x18,%rdx\ncmp    %eax,%ebx\njne    15e0 <kMeans+0x1e0>\ncmp    %ecx,0x10(%rsi)\nje     1623 <kMeans+0x223>\nmov    %ecx,0x10(%rsi)\nadd    $0x1,%r10\nadd    $0x18,%rsi\ncmp    %rdi,%rsi\njne    15c0 <kMeans+0x1c0>\ncmp    %r9,%r10\nja     1508 <kMeans+0x108>\njmp    147c <kMeans+0x7c>\nmov    $0x18,%edi\ncall   2710 <libmin_malloc>\nmov    $0x18,%edx\nxor    %esi,%esi\nmov    %rax,%rdi\nmov    %rax,%r12\ncall   2af0 <libmin_memset>\npxor   %xmm0,%xmm0\nmov    %r13,0x10(%r12)\nmovups %xmm0,(%r12)\ntest   %r13,%r13\nje     16b5 <kMeans+0x2b5>\nlea    0x0(%r13,%r13,2),%rcx\nmov    %rbp,%rax\nshl    $0x3,%rcx\nlea    0x0(%rbp,%rcx,1),%rdx\nmovupd (%rax),%xmm6\nmovl   $0x0,0x10(%rax)\nadd    $0x18,%rax\naddpd  %xmm6,%xmm0\ncmp    %rdx,%rax\njne    167a <kMeans+0x27a>\nmovl   $0x0,-0x8(%rbp,%rcx,1)\npxor   %xmm1,%xmm1\ncvtsi2sd %r13,%xmm1\nunpcklpd %xmm1,%xmm1\ndivpd  %xmm1,%xmm0\nmovups %xmm0,(%r12)\njmp    147c <kMeans+0x7c>\npxor   %xmm0,%xmm0\njmp    169a <kMeans+0x29a>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "main", "content": "/*!\n * This function calls the test\n * function\n */\nint main()\n{\n    libmin_srand(42);\n    test();\n    /* test2(); */\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  observation *v3; // r12\n  observation *v4; // rbx\n  cluster *v5; // rbp\n  double v6; // [rsp+0h] [rbp-28h]\n  double x; // [rsp+8h] [rbp-20h]\n\n  libmin_srand(0x2Au);\n  v3 = (observation *)libmin_malloc(0x12C0uLL);\n  v4 = v3;\n  do\n  {\n    ++v4;\n    v6 = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    x = (double)(int)libmin_rand() / 2147483647.0 * 6.283185307179586;\n    v4[-1].x = libmin_cos(x) * v6;\n    v4[-1].y = libmin_sin(x) * v6;\n  }\n  while ( v4 != &v3[200] );\n  v5 = kMeans(v3, 0xC8uLL, 5);\n  printEPS(v3, 0xC8uLL, v5, 5);\n  libmin_free(v3);\n  libmin_free(v5);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  observation *v3;\n  observation *v4;\n  cluster *v5;\n  double v6;\n  double x;\n  libmin_srand(42u);\n  v3 = (observation *)libmin_malloc(4800uLL);\n  v4 = v3;\n  do {\n    ++v4;\n    v6 = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    x = (double)(int)libmin_rand() / 2147483647.0 * 6.283185307179586;\n    v4[-1].x = libmin_cos(x) * v6;\n    v4[-1].y = libmin_sin(x) * v6;\n  } while (v4 != &v3[200]);\n  v5 = kMeans(v3, 200uLL, 5);\n  printEPS(v3, 200uLL, v5, 5);\n  libmin_free(v3);\n  libmin_free(v5);\n  libmin_success();\n}", "binary": "k-means/k-means.host.O3", "assembly": "<main>:\nendbr64\npush   %r12\nmov    $0x2a,%edi\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\ncall   4c60 <libmin_srand>\nmov    $0x12c0,%edi\ncall   2710 <libmin_malloc>\nmov    %rax,%r12\nmov    %rax,%rbx\nlea    0x12c0(%rax),%rbp\nnopl   (%rax)\ncall   4cc0 <libmin_rand>\npxor   %xmm0,%xmm0\nadd    $0x18,%rbx\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x7044(%rip),%xmm0\nmulsd  0x7044(%rip),%xmm0\nmovsd  %xmm0,(%rsp)\ncall   4cc0 <libmin_rand>\npxor   %xmm1,%xmm1\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm1\ndivsd  0x701f(%rip),%xmm1\nmulsd  0x7027(%rip),%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm1,0x8(%rsp)\ncall   4fe0 <libmin_cos>\nmulsd  (%rsp),%xmm0\nmovsd  0x8(%rsp),%xmm1\nmovsd  %xmm0,-0x18(%rbx)\nmovapd %xmm1,%xmm0\ncall   53d0 <libmin_sin>\nmulsd  (%rsp),%xmm0\nmovsd  %xmm0,-0x10(%rbx)\ncmp    %rbp,%rbx\njne    1150 <main+0x30>\nmov    %r12,%rdi\nmov    $0x5,%edx\nmov    $0xc8,%esi\ncall   1400 <kMeans>\nmov    $0x5,%ecx\nmov    $0xc8,%esi\nmov    %r12,%rdi\nmov    %rax,%rdx\nmov    %rax,%rbp\ncall   16c0 <printEPS>\nmov    %r12,%rdi\ncall   27c0 <libmin_free>\nmov    %rbp,%rdi\ncall   27c0 <libmin_free>\ncall   57b0 <libmin_success>\nadd    $0x10,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "printEPS", "content": "/**\n * @}\n * @}\n */\n\n/*!\n * A function to print observations and clusters\n * The code is taken from\n * http://rosettacode.org/wiki/K-means%2B%2B_clustering.\n * Even the K Means code is also inspired from it\n *\n * @note To print in a file use pipeline operator\n * ```sh\n * ./k_means_clustering > image.eps\n * ```\n *\n * @param observations  observations array\n * @param len  size of observation array\n * @param cent  clusters centroid's array\n * @param k  size of cent array\n */\nvoid printEPS(observation pts[], size_t len, cluster cent[], int k)\n{\n    int W = 400, H = 400;\n    double min_x = DBL_MAX, max_x = DBL_MIN, min_y = DBL_MAX, max_y = DBL_MIN;\n    double scale = 0, cx = 0, cy = 0;\n    double* colors = (double*)libmin_malloc(sizeof(double) * (k * 3));\n    int i;\n    size_t j;\n    double kd = k * 1.0;\n    for (i = 0; i < k; i++)\n    {\n        *(colors + 3 * i) = (3 * (i + 1) % k) / kd;\n        *(colors + 3 * i + 1) = (7 * i % k) / kd;\n        *(colors + 3 * i + 2) = (9 * i % k) / kd;\n    }\n\n    for (j = 0; j < len; j++)\n    {\n        if (max_x < pts[j].x)\n        {\n            max_x = pts[j].x;\n        }\n        if (min_x > pts[j].x)\n        {\n            min_x = pts[j].x;\n        }\n        if (max_y < pts[j].y)\n        {\n            max_y = pts[j].y;\n        }\n        if (min_y > pts[j].y)\n        {\n            min_y = pts[j].y;\n        }\n    }\n    scale = W / (max_x - min_x);\n    if (scale > (H / (max_y - min_y)))\n    {\n        scale = H / (max_y - min_y);\n    };\n    cx = (max_x + min_x) / 2;\n    cy = (max_y + min_y) / 2;\n\n    libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", W + 10,\n           H + 10);\n    libmin_printf(\n        \"/l {rlineto} def /m {rmoveto} def\\n\"\n        \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n        \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \"\n        \"\tgsave 1 setgray fill grestore gsave 3 setlinewidth\"\n        \" 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n    for (int i = 0; i < k; i++)\n    {\n        libmin_printf(\"%f %f %f setrgbcolor\\n\", *(colors + 3 * i),\n               *(colors + 3 * i + 1), *(colors + 3 * i + 2));\n        for (j = 0; j < len; j++)\n        {\n            if (pts[j].group != i)\n            {\n                continue;\n            }\n            libmin_printf(\"%.3f %.3f c\\n\", (pts[j].x - cx) * scale + W / 2,\n                   (pts[j].y - cy) * scale + H / 2);\n        }\n        libmin_printf(\"\\n0 setgray %f %f s\\n\", (cent[i].x - cx) * scale + W / 2,\n               (cent[i].y - cy) * scale + H / 2);\n    }\n    libmin_printf(\"\\n%%%%EOF\\n\");\n\n    // free accquired memory\n    libmin_free(colors);\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O3.pseudo", "function_name": "printEPS", "address": "0x16c0", "label": "printEPS", "content": "void __fastcall printEPS(observation *pts, size_t len, cluster *cent, int k)\n{\n  double *v7; // rax\n  double *v8; // r9\n  int v9; // r8d\n  __m128d v10; // xmm1\n  int v11; // edi\n  int v12; // esi\n  __m128d v13; // xmm2\n  int v14; // eax\n  int v15; // edx\n  int v16; // eax\n  unsigned int v17; // ecx\n  unsigned int v18; // edx\n  int v19; // eax\n  double v20; // xmm3_8\n  double v21; // xmm1_8\n  observation *v22; // rax\n  double v23; // xmm4_8\n  double v24; // xmm2_8\n  double x; // xmm0_8\n  double v26; // xmm7_8\n  double y; // xmm5_8\n  __int64 v28; // rdx\n  __int64 v29; // rcx\n  __int64 v30; // r8\n  __int64 v31; // r9\n  double *v32; // r12\n  int v33; // r15d\n  __int64 v34; // rbp\n  observation *v35; // r14\n  double v36; // xmm1_8\n  double v37; // xmm0_8\n  double v38; // [rsp+0h] [rbp-68h]\n  double scale; // [rsp+8h] [rbp-60h]\n  double v40; // [rsp+10h] [rbp-58h]\n  double *colors; // [rsp+28h] [rbp-40h]\n\n  v7 = (double *)libmin_malloc(24LL * k);\n  colors = v7;\n  if ( k <= 0 )\n  {\n    if ( !len )\n    {\n      libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410, 410);\n      libmin_printf(\"/l {rlineto} def /m {rmoveto} def\\n\"\n                    \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n                    \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray fill grestore gsave 3 setlinewid\"\n                    \"th 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n      goto LABEL_14;\n    }\nLABEL_5:\n    v20 = 2.225073858507201e-308;\n    v21 = 1.797693134862316e308;\n    v22 = pts;\n    v23 = 2.225073858507201e-308;\n    v24 = 1.797693134862316e308;\n    do\n    {\n      x = v22->x;\n      ++v22;\n      v26 = fmax(x, v23);\n      v24 = fmin(x, v24);\n      v23 = v26;\n      y = v22[-1].y;\n      v21 = fmin(y, v21);\n      v20 = fmax(y, v20);\n    }\n    while ( &pts[len] != v22 );\n    v40 = (v24 + v26) * 0.5;\n    v38 = (v21 + v20) * 0.5;\n    scale = fmin(400.0 / (v20 - v21), 400.0 / (v26 - v24));\n    libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410, 410);\n    libmin_printf(\"/l {rlineto} def /m {rmoveto} def\\n\"\n                  \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n                  \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray fill grestore gsave 3 setlinewidth\"\n                  \" 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n    if ( k <= 0 )\n      goto LABEL_14;\n    goto LABEL_8;\n  }\n  v10 = 0LL;\n  v8 = v7;\n  v9 = 0;\n  v10.m128d_f64[0] = (double)k;\n  v11 = 0;\n  v12 = 3;\n  v13 = _mm_unpacklo_pd(v10, v10);\n  do\n  {\n    v14 = v12;\n    v12 += 3;\n    v8 += 3;\n    v15 = v14 % k;\n    v16 = v11;\n    v11 += 7;\n    v17 = v15;\n    v18 = v16 % k;\n    v19 = v9;\n    v9 += 9;\n    *(__m128d *)(v8 - 3) = _mm_div_pd(\n                             _mm_cvtepi32_pd(_mm_unpacklo_epi32(_mm_cvtsi32_si128(v17), _mm_cvtsi32_si128(v18))),\n                             v13);\n    *(v8 - 1) = (double)(v19 % k) / v10.m128d_f64[0];\n  }\n  while ( 3 * k + 3 != v12 );\n  if ( len )\n    goto LABEL_5;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410, 410);\n  libmin_printf(\"/l {rlineto} def /m {rmoveto} def\\n\"\n                \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n                \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray fill grestore gsave 3 setlinewidth 1\"\n                \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  v38 = 8.988465674311579e307;\n  v40 = 8.988465674311579e307;\n  scale = -2.225073858507202e-306;\nLABEL_8:\n  v32 = colors;\n  v33 = 0;\n  do\n  {\n    v34 = 0LL;\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", *v32, v32[1], v32[2]);\n    v35 = pts;\n    if ( len )\n    {\n      do\n      {\n        if ( v35->group == v33 )\n          libmin_printf(\"%.3f %.3f c\\n\", (v35->x - v40) * scale + 200.0, (v35->y - v38) * scale + 200.0);\n        ++v34;\n        ++v35;\n      }\n      while ( len != v34 );\n    }\n    v36 = cent->y;\n    v37 = cent->x;\n    ++v33;\n    v32 += 3;\n    ++cent;\n    libmin_printf(\"\\n0 setgray %f %f s\\n\", (v37 - v40) * scale + 200.0, (v36 - v38) * scale + 200.0);\n  }\n  while ( k != v33 );\nLABEL_14:\n  libmin_printf(\"\\n%%%%EOF\\n\", 410LL, v28, v29, v30, v31, *(_QWORD *)&v38, *(_QWORD *)&scale, *(_QWORD *)&v40);\n  libmin_free(colors);\n}\n"}, "pseudo_normalize": "void printEPS(observation *pts, unsigned int len, cluster *cent, int k) {\n  double *v7;\n  double *v8;\n  int v9;\n  __m128d v10;\n  int v11;\n  int v12;\n  __m128d v13;\n  int v14;\n  int v15;\n  int v16;\n  unsigned int v17;\n  unsigned int v18;\n  int v19;\n  double v20;\n  double v21;\n  observation *v22;\n  double v23;\n  double v24;\n  double x;\n  double v26;\n  double y;\n  long long v28;\n  long long v29;\n  long long v30;\n  long long v31;\n  double *v32;\n  int v33;\n  long long v34;\n  observation *v35;\n  double v36;\n  double v37;\n  double v38;\n  double scale;\n  double v40;\n  double *colors;\n  v7 = (double *)libmin_malloc(24LL * k);\n  colors = v7;\n  if (k <= 0) {\n    if (!len) {\n      libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\",\n                    410, 410);\n      libmin_printf(\n          \"/l {rlineto} def /m {rmoveto} def\\n\"\n          \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n          \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n          \"fill grestore gsave 3 setlinewid\"\n          \"th 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n      goto LABEL_14;\n    }\n  LABEL_5:\n    v20 = 2.225073858507201e-308;\n    v21 = 1.797693134862316e308;\n    v22 = pts;\n    v23 = 2.225073858507201e-308;\n    v24 = 1.797693134862316e308;\n    do {\n      x = v22->x;\n      ++v22;\n      v26 = fmax(x, v23);\n      v24 = fmin(x, v24);\n      v23 = v26;\n      y = v22[-1].y;\n      v21 = fmin(y, v21);\n      v20 = fmax(y, v20);\n    } while (&pts[len] != v22);\n    v40 = (v24 + v26) * 0.5;\n    v38 = (v21 + v20) * 0.5;\n    scale = fmin(400.0 / (v20 - v21), 400.0 / (v26 - v24));\n    libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\",\n                  410, 410);\n    libmin_printf(\n        \"/l {rlineto} def /m {rmoveto} def\\n\"\n        \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n        \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n        \"fill grestore gsave 3 setlinewidth\"\n        \" 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n    if (k <= 0) goto LABEL_14;\n    goto LABEL_8;\n  }\n  v10 = 0LL;\n  v8 = v7;\n  v9 = 0;\n  v10.m128d_f64[0] = (double)k;\n  v11 = 0;\n  v12 = 3;\n  v13 = _mm_unpacklo_pd(v10, v10);\n  do {\n    v14 = v12;\n    v12 += 3;\n    v8 += 3;\n    v15 = v14 % k;\n    v16 = v11;\n    v11 += 7;\n    v17 = v15;\n    v18 = v16 % k;\n    v19 = v9;\n    v9 += 9;\n    *(__m128d *)(v8 - 3) =\n        _mm_div_pd(_mm_cvtepi32_pd(_mm_unpacklo_epi32(_mm_cvtsi32_si128(v17),\n                                                      _mm_cvtsi32_si128(v18))),\n                   v13);\n    *(v8 - 1) = (double)(v19 % k) / v10.m128d_f64[0];\n  } while (3 * k + 3 != v12);\n  if (len) goto LABEL_5;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410,\n                410);\n  libmin_printf(\n      \"/l {rlineto} def /m {rmoveto} def\\n\"\n      \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n      \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n      \"fill grestore gsave 3 setlinewidth 1\"\n      \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  v38 = 8.988465674311579e307;\n  v40 = 8.988465674311579e307;\n  scale = -2.225073858507202e-306;\nLABEL_8:\n  v32 = colors;\n  v33 = 0;\n  do {\n    v34 = 0LL;\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", *v32, v32[1], v32[2]);\n    v35 = pts;\n    if (len) {\n      do {\n        if (v35->group == v33)\n          libmin_printf(\"%.3f %.3f c\\n\", (v35->x - v40) * scale + 200.0,\n                        (v35->y - v38) * scale + 200.0);\n        ++v34;\n        ++v35;\n      } while (len != v34);\n    }\n    v36 = cent->y;\n    v37 = cent->x;\n    ++v33;\n    v32 += 3;\n    ++cent;\n    libmin_printf(\"\\n0 setgray %f %f s\\n\", (v37 - v40) * scale + 200.0,\n                  (v36 - v38) * scale + 200.0);\n  } while (k != v33);\nLABEL_14:\n  libmin_printf(\"\\n%%%%EOF\\n\", 410LL, v28, v29, v30, v31, *(uint64_t *)&v38,\n                *(uint64_t *)&scale, *(uint64_t *)&v40);\n  libmin_free(colors);\n}", "binary": "k-means/k-means.host.O3", "assembly": "<printEPS>:\nendbr64\npush   %r15\nmov    %ecx,%r15d\npush   %r14\npush   %r13\nmov    %rdx,%r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x38,%rsp\nmov    %rdi,0x20(%rsp)\nlea    (%rcx,%rcx,2),%edi\nmovslq %edi,%rdi\nmov    %ecx,0x1c(%rsp)\nshl    $0x3,%rdi\ncall   2710 <libmin_malloc>\nmov    %rax,0x28(%rsp)\ntest   %r15d,%r15d\njle    1993 <printEPS+0x2d3>\npxor   %xmm1,%xmm1\nmov    %rax,%r9\nlea    0x3(%r15,%r15,2),%r10d\nxor    %r8d,%r8d\ncvtsi2sd %r15d,%xmm1\nxor    %edi,%edi\nmov    $0x3,%esi\nmovapd %xmm1,%xmm2\nunpcklpd %xmm2,%xmm2\nnopl   0x0(%rax)\nmov    0x1c(%rsp),%r11d\nmov    %esi,%eax\nadd    $0x3,%esi\nadd    $0x18,%r9\ncltd\nidiv   %r11d\nmov    %edi,%eax\nadd    $0x7,%edi\nmov    %edx,%ecx\ncltd\nidiv   %r11d\nmovd   %ecx,%xmm0\nmov    %r8d,%eax\nadd    $0x9,%r8d\nmovd   %edx,%xmm4\ncltd\npunpckldq %xmm4,%xmm0\ncvtdq2pd %xmm0,%xmm0\ndivpd  %xmm2,%xmm0\nidiv   %r11d\nmovups %xmm0,-0x18(%r9)\npxor   %xmm0,%xmm0\ncvtsi2sd %edx,%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%r9)\ncmp    %esi,%r10d\njne    1728 <printEPS+0x68>\ntest   %rbx,%rbx\nje     19c4 <printEPS+0x304>\nmov    0x20(%rsp),%rcx\nmovsd  0x69ea(%rip),%xmm3\nlea    (%rbx,%rbx,2),%rdx\nmovsd  0x69d6(%rip),%xmm1\nmov    %rcx,%rax\nlea    (%rcx,%rdx,8),%rdx\nmovapd %xmm3,%xmm4\nmovapd %xmm1,%xmm2\nnopl   0x0(%rax)\nmovsd  (%rax),%xmm0\nadd    $0x18,%rax\nmovapd %xmm0,%xmm7\nminsd  %xmm2,%xmm0\nmaxsd  %xmm4,%xmm7\nmovapd %xmm0,%xmm2\nmovsd  -0x10(%rax),%xmm0\nmovapd %xmm7,%xmm4\nmovapd %xmm0,%xmm5\nminsd  %xmm1,%xmm0\nmaxsd  %xmm3,%xmm5\nmovapd %xmm0,%xmm1\nmovapd %xmm5,%xmm3\ncmp    %rax,%rdx\njne    17b8 <printEPS+0xf8>\nmovapd %xmm7,%xmm5\nmov    $0x19a,%edx\nmov    $0x19a,%esi\nxor    %eax,%eax\nsubsd  %xmm2,%xmm5\nmovsd  0x698a(%rip),%xmm0\naddsd  %xmm4,%xmm2\nmovsd  0x6986(%rip),%xmm4\nlea    0x67e7(%rip),%rdi\nmovapd %xmm0,%xmm7\ndivsd  %xmm5,%xmm7\nmovapd %xmm3,%xmm5\nsubsd  %xmm1,%xmm5\naddsd  %xmm3,%xmm1\nmulsd  %xmm4,%xmm2\nmulsd  %xmm4,%xmm1\nmovsd  %xmm2,0x10(%rsp)\nmovsd  %xmm1,(%rsp)\ndivsd  %xmm5,%xmm0\nminsd  %xmm7,%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncall   4a50 <libmin_printf>\nlea    0x67de(%rip),%rdi\nxor    %eax,%eax\ncall   4a50 <libmin_printf>\nmov    0x1c(%rsp),%eax\ntest   %eax,%eax\njle    196d <printEPS+0x2ad>\nmov    0x28(%rsp),%r12\nxor    %r15d,%r15d\nnopl   (%rax)\nmovsd  0x10(%r12),%xmm2\nmovsd  0x8(%r12),%xmm1\nxor    %ebp,%ebp\nlea    0x68a3(%rip),%rdi\nmovsd  (%r12),%xmm0\nmov    $0x3,%eax\ncall   4a50 <libmin_printf>\nmov    0x20(%rsp),%r14\ntest   %rbx,%rbx\nje     1910 <printEPS+0x250>\nnopl   0x0(%rax)\ncmp    %r15d,0x10(%r14)\njne    1903 <printEPS+0x243>\nmovsd  0x8(%r14),%xmm1\nmovsd  (%r14),%xmm0\nlea    0x6894(%rip),%rdi\nmov    $0x2,%eax\nsubsd  (%rsp),%xmm1\nsubsd  0x10(%rsp),%xmm0\nmovsd  0x8(%rsp),%xmm6\nmulsd  %xmm6,%xmm1\nmulsd  %xmm6,%xmm0\naddsd  0x68b2(%rip),%xmm1\naddsd  0x68aa(%rip),%xmm0\ncall   4a50 <libmin_printf>\nadd    $0x1,%rbp\nadd    $0x18,%r14\ncmp    %rbp,%rbx\njne    18b8 <printEPS+0x1f8>\nmovsd  0x8(%r13),%xmm1\nsubsd  (%rsp),%xmm1\nlea    0x682e(%rip),%rdi\nmov    $0x2,%eax\nmovsd  0x0(%r13),%xmm0\nadd    $0x1,%r15d\nadd    $0x18,%r12\nadd    $0x18,%r13\nsubsd  0x10(%rsp),%xmm0\nmovsd  0x8(%rsp),%xmm3\nmulsd  %xmm3,%xmm1\nmulsd  %xmm3,%xmm0\naddsd  0x6853(%rip),%xmm1\naddsd  0x684b(%rip),%xmm0\ncall   4a50 <libmin_printf>\ncmp    %r15d,0x1c(%rsp)\njne    1880 <printEPS+0x1c0>\nlea    0x67bc(%rip),%rdi\nxor    %eax,%eax\ncall   4a50 <libmin_printf>\nmov    0x28(%rsp),%rdi\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    27c0 <libmin_free>\ntest   %rbx,%rbx\njne    1789 <printEPS+0xc9>\nmov    $0x19a,%edx\nmov    $0x19a,%esi\nlea    0x665b(%rip),%rdi\nxor    %eax,%eax\ncall   4a50 <libmin_printf>\nlea    0x6685(%rip),%rdi\nxor    %eax,%eax\ncall   4a50 <libmin_printf>\njmp    196d <printEPS+0x2ad>\nmov    $0x19a,%edx\nmov    $0x19a,%esi\nlea    0x6633(%rip),%rdi\nxor    %eax,%eax\ncall   4a50 <libmin_printf>\nlea    0x665d(%rip),%rdi\nxor    %eax,%eax\ncall   4a50 <libmin_printf>\nmovsd  0x6796(%rip),%xmm4\nmovsd  %xmm4,(%rsp)\nmovsd  %xmm4,0x10(%rsp)\nmovsd  0x678b(%rip),%xmm4\nmovsd  %xmm4,0x8(%rsp)\njmp    1875 <printEPS+0x1b5>\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "test2", "content": "/*!\n * A function to test the kMeans function\n * Generates 1000000 points in a circle of\n * radius 20.0 with center at (0,0)\n * and cluster them into 11 clusters\n *\n * <img alt=\"Output for 1000000 points divided in 11 clusters\" src=\n * \"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest2.png\"\n * width=\"400px\" heiggt=\"400px\">\n * @returns None\n */\nvoid test2()\n{\n    size_t size = 1000000L;\n    observation* observations =\n        (observation*)libmin_malloc(sizeof(observation) * size);\n    double maxRadius = 20.00;\n    double radius = 0;\n    double ang = 0;\n    size_t i = 0;\n    for (; i < size; i++)\n    {\n        radius = maxRadius * ((double)libmin_rand() / RAND_MAX);\n        ang = 2 * M_PI * ((double)libmin_rand() / RAND_MAX);\n        observations[i].x = radius * libmin_cos(ang);\n        observations[i].y = radius * libmin_sin(ang);\n    }\n    int k = 11;  // No of clusters\n    cluster* clusters = kMeans(observations, size, k);\n    printEPS(observations, size, clusters, k);\n    // Free the accquired memory\n    libmin_free(observations);\n    libmin_free(clusters);\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O3.pseudo", "function_name": "test2", "address": "0x1a10", "label": "test2", "content": "void __cdecl test2()\n{\n  observation *v0; // rbx\n  observation *v1; // r13\n  _OWORD *v2; // r14\n  int *p_group; // r12\n  observation *v4; // rax\n  __int64 group; // rdx\n  __m128d v6; // xmm0\n  char *v7; // rdx\n  __m128d v8; // xmm7\n  __int64 v9; // rax\n  __m128d v10; // xmm1\n  __int64 v11; // rax\n  __m128d v12; // xmm0\n  double v13; // xmm11_8\n  __m128d v14; // xmm1\n  __int64 v15; // rax\n  __m128d v16; // xmm0\n  double v17; // xmm10_8\n  __m128d v18; // xmm1\n  __int64 v19; // rax\n  __m128d v20; // xmm0\n  double v21; // r15\n  __m128d v22; // xmm1\n  __int64 v23; // rax\n  __m128d v24; // xmm0\n  double v25; // r12\n  __m128d v26; // xmm1\n  __int64 v27; // rax\n  __m128d v28; // xmm0\n  double v29; // xmm14_8\n  __m128d v30; // xmm1\n  __int64 v31; // rax\n  __m128d v32; // xmm0\n  double v33; // xmm13_8\n  __m128d v34; // xmm1\n  __int64 v35; // rax\n  __m128d v36; // xmm0\n  double v37; // xmm12_8\n  __m128d v38; // xmm1\n  __int64 v39; // rax\n  __m128d v40; // xmm0\n  double v41; // xmm7_8\n  __m128d v42; // xmm1\n  __int64 v43; // rax\n  __m128d v44; // xmm0\n  double v45; // xmm8_8\n  __m128d v46; // xmm1\n  __int64 v47; // rax\n  __m128d v48; // xmm0\n  __m128d v49; // xmm1\n  double v50; // xmm6_8\n  observation *v51; // rdx\n  unsigned __int64 v52; // rcx\n  double v53; // xmm7_8\n  double v54; // xmm8_8\n  __m128d v55; // xmm0\n  double v56; // xmm9_8\n  double x; // xmm2_8\n  double y; // xmm1_8\n  int v59; // eax\n  double v60; // xmm3_8\n  double *p_x; // rax\n  double v62; // xmm4_8\n  double v63; // xmm0_8\n  double v64; // xmm2_8\n  double v65; // xmm1_8\n  double v66; // xmm7_8\n  double v67; // xmm1_8\n  double *v68; // rbp\n  double *v69; // rbx\n  int v70; // r14d\n  observation *v71; // r12\n  double v72; // xmm1_8\n  double v73; // xmm0_8\n  __int64 v74; // rdx\n  double radiusb; // [rsp+0h] [rbp-98h]\n  double radius; // [rsp+0h] [rbp-98h]\n  double radiusa; // [rsp+0h] [rbp-98h]\n  double angb; // [rsp+8h] [rbp-90h]\n  double ang; // [rsp+8h] [rbp-90h]\n  double anga; // [rsp+8h] [rbp-90h]\n  double v81; // [rsp+10h] [rbp-88h]\n  double block; // [rsp+18h] [rbp-80h]\n  _OWORD *blocka; // [rsp+18h] [rbp-80h]\n  double clusters; // [rsp+20h] [rbp-78h]\n  cluster *clustersa; // [rsp+20h] [rbp-78h]\n  double v86; // [rsp+28h] [rbp-70h]\n  double v87; // [rsp+30h] [rbp-68h]\n  double v88; // [rsp+38h] [rbp-60h]\n  double v89; // [rsp+40h] [rbp-58h]\n  double v90; // [rsp+48h] [rbp-50h]\n  double v91; // [rsp+50h] [rbp-48h]\n  observation *observations; // [rsp+58h] [rbp-40h]\n\n  observations = (observation *)libmin_malloc(0x16E3600uLL);\n  v0 = observations;\n  v1 = observations + 1000000;\n  do\n  {\n    ++v0;\n    radiusb = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    angb = (double)(int)libmin_rand() / 2147483647.0 * 6.283185307179586;\n    v0[-1].x = libmin_cos(angb) * radiusb;\n    v0[-1].y = libmin_sin(angb) * radiusb;\n  }\n  while ( v1 != v0 );\n  v2 = libmin_malloc(0x108uLL);\n  libmin_memset(v2, 0, 0x108uLL);\n  p_group = &observations->group;\n  do\n  {\n    p_group += 6;\n    *(p_group - 6) = libmin_rand() % 0xB;\n  }\n  while ( &observations[1000000].group != p_group );\n  do\n  {\n    *((_QWORD *)v2 + 2) = 0LL;\n    v4 = observations;\n    *((_QWORD *)v2 + 5) = 0LL;\n    *((_QWORD *)v2 + 8) = 0LL;\n    *((_QWORD *)v2 + 11) = 0LL;\n    *((_QWORD *)v2 + 14) = 0LL;\n    *((_QWORD *)v2 + 17) = 0LL;\n    *((_QWORD *)v2 + 20) = 0LL;\n    *((_QWORD *)v2 + 23) = 0LL;\n    *((_QWORD *)v2 + 26) = 0LL;\n    *((_QWORD *)v2 + 29) = 0LL;\n    *((_QWORD *)v2 + 32) = 0LL;\n    *v2 = 0LL;\n    *(_OWORD *)((char *)v2 + 24) = 0LL;\n    v2[3] = 0LL;\n    *(_OWORD *)((char *)v2 + 72) = 0LL;\n    v2[6] = 0LL;\n    *(_OWORD *)((char *)v2 + 120) = 0LL;\n    v2[9] = 0LL;\n    *(_OWORD *)((char *)v2 + 168) = 0LL;\n    v2[12] = 0LL;\n    *(_OWORD *)((char *)v2 + 216) = 0LL;\n    v2[15] = 0LL;\n    do\n    {\n      group = v4->group;\n      v6 = *(__m128d *)&v4->x;\n      ++v4;\n      v7 = (char *)v2 + 24 * group;\n      v8 = *(__m128d *)v7;\n      ++*((_QWORD *)v7 + 2);\n      *(__m128d *)v7 = _mm_add_pd(v6, v8);\n    }\n    while ( v4 != v1 );\n    v9 = *((_QWORD *)v2 + 2);\n    v10 = 0LL;\n    if ( v9 < 0 )\n    {\n      v74 = v2[1] & 1LL | (*((_QWORD *)v2 + 2) >> 1);\n      v10.m128d_f64[0] = (double)(int)v74 + (double)(int)v74;\n    }\n    else\n    {\n      v10.m128d_f64[0] = (double)(int)v9;\n    }\n    v11 = *((_QWORD *)v2 + 5);\n    v12 = _mm_div_pd(*(__m128d *)v2, _mm_unpacklo_pd(v10, v10));\n    clusters = v12.m128d_f64[1];\n    v13 = v12.m128d_f64[0];\n    *v2 = v12;\n    v14 = 0LL;\n    if ( v11 < 0 )\n      v14.m128d_f64[0] = (double)(int)(v11 & 1 | ((unsigned __int64)v11 >> 1))\n                       + (double)(int)(v11 & 1 | ((unsigned __int64)v11 >> 1));\n    else\n      v14.m128d_f64[0] = (double)(int)v11;\n    v15 = *((_QWORD *)v2 + 8);\n    v16 = _mm_div_pd(*(__m128d *)((char *)v2 + 24), _mm_unpacklo_pd(v14, v14));\n    block = v16.m128d_f64[1];\n    v17 = v16.m128d_f64[0];\n    *(__m128d *)((char *)v2 + 24) = v16;\n    v18 = 0LL;\n    if ( v15 < 0 )\n      v18.m128d_f64[0] = (double)(int)(v15 & 1 | ((unsigned __int64)v15 >> 1))\n                       + (double)(int)(v15 & 1 | ((unsigned __int64)v15 >> 1));\n    else\n      v18.m128d_f64[0] = (double)(int)v15;\n    v19 = *((_QWORD *)v2 + 11);\n    v20 = _mm_div_pd(*((__m128d *)v2 + 3), _mm_unpacklo_pd(v18, v18));\n    v90 = v20.m128d_f64[1];\n    v21 = v20.m128d_f64[0];\n    v2[3] = v20;\n    v22 = 0LL;\n    if ( v19 < 0 )\n      v22.m128d_f64[0] = (double)(int)(v19 & 1 | ((unsigned __int64)v19 >> 1))\n                       + (double)(int)(v19 & 1 | ((unsigned __int64)v19 >> 1));\n    else\n      v22.m128d_f64[0] = (double)(int)v19;\n    v23 = *((_QWORD *)v2 + 14);\n    v24 = _mm_div_pd(*(__m128d *)((char *)v2 + 72), _mm_unpacklo_pd(v22, v22));\n    v89 = v24.m128d_f64[1];\n    v25 = v24.m128d_f64[0];\n    *(__m128d *)((char *)v2 + 72) = v24;\n    v26 = 0LL;\n    if ( v23 < 0 )\n      v26.m128d_f64[0] = (double)(int)(v23 & 1 | ((unsigned __int64)v23 >> 1))\n                       + (double)(int)(v23 & 1 | ((unsigned __int64)v23 >> 1));\n    else\n      v26.m128d_f64[0] = (double)(int)v23;\n    v27 = *((_QWORD *)v2 + 17);\n    v28 = _mm_div_pd(*((__m128d *)v2 + 6), _mm_unpacklo_pd(v26, v26));\n    v88 = v28.m128d_f64[1];\n    v29 = v28.m128d_f64[0];\n    v2[6] = v28;\n    v30 = 0LL;\n    if ( v27 < 0 )\n      v30.m128d_f64[0] = (double)(int)(v27 & 1 | ((unsigned __int64)v27 >> 1))\n                       + (double)(int)(v27 & 1 | ((unsigned __int64)v27 >> 1));\n    else\n      v30.m128d_f64[0] = (double)(int)v27;\n    v31 = *((_QWORD *)v2 + 20);\n    v32 = _mm_div_pd(*(__m128d *)((char *)v2 + 120), _mm_unpacklo_pd(v30, v30));\n    v87 = v32.m128d_f64[1];\n    v33 = v32.m128d_f64[0];\n    *(__m128d *)((char *)v2 + 120) = v32;\n    v34 = 0LL;\n    if ( v31 < 0 )\n      v34.m128d_f64[0] = (double)(int)(v31 & 1 | ((unsigned __int64)v31 >> 1))\n                       + (double)(int)(v31 & 1 | ((unsigned __int64)v31 >> 1));\n    else\n      v34.m128d_f64[0] = (double)(int)v31;\n    v35 = *((_QWORD *)v2 + 23);\n    v36 = _mm_div_pd(*((__m128d *)v2 + 9), _mm_unpacklo_pd(v34, v34));\n    v86 = v36.m128d_f64[1];\n    v37 = v36.m128d_f64[0];\n    v2[9] = v36;\n    v38 = 0LL;\n    if ( v35 < 0 )\n      v38.m128d_f64[0] = (double)(int)(v35 & 1 | ((unsigned __int64)v35 >> 1))\n                       + (double)(int)(v35 & 1 | ((unsigned __int64)v35 >> 1));\n    else\n      v38.m128d_f64[0] = (double)(int)v35;\n    v39 = *((_QWORD *)v2 + 26);\n    v40 = _mm_div_pd(*(__m128d *)((char *)v2 + 168), _mm_unpacklo_pd(v38, v38));\n    radius = v40.m128d_f64[1];\n    v41 = v40.m128d_f64[0];\n    *(__m128d *)((char *)v2 + 168) = v40;\n    v42 = 0LL;\n    if ( v39 < 0 )\n      v42.m128d_f64[0] = (double)(int)(v39 & 1 | ((unsigned __int64)v39 >> 1))\n                       + (double)(int)(v39 & 1 | ((unsigned __int64)v39 >> 1));\n    else\n      v42.m128d_f64[0] = (double)(int)v39;\n    v43 = *((_QWORD *)v2 + 29);\n    v44 = _mm_div_pd(*((__m128d *)v2 + 12), _mm_unpacklo_pd(v42, v42));\n    ang = v44.m128d_f64[1];\n    v45 = v44.m128d_f64[0];\n    v2[12] = v44;\n    v46 = 0LL;\n    if ( v43 < 0 )\n      v46.m128d_f64[0] = (double)(int)(v43 & 1 | ((unsigned __int64)v43 >> 1))\n                       + (double)(int)(v43 & 1 | ((unsigned __int64)v43 >> 1));\n    else\n      v46.m128d_f64[0] = (double)(int)v43;\n    v47 = *((_QWORD *)v2 + 32);\n    v48 = _mm_div_pd(*(__m128d *)((char *)v2 + 216), _mm_unpacklo_pd(v46, v46));\n    v91 = v48.m128d_f64[1];\n    *(__m128d *)((char *)v2 + 216) = v48;\n    v49 = 0LL;\n    if ( v47 < 0 )\n      v49.m128d_f64[0] = (double)(int)(v47 & 1 | ((unsigned __int64)v47 >> 1))\n                       + (double)(int)(v47 & 1 | ((unsigned __int64)v47 >> 1));\n    else\n      v49.m128d_f64[0] = (double)(int)v47;\n    v50 = v41;\n    v51 = observations;\n    v52 = 0LL;\n    v53 = v45;\n    v54 = v48.m128d_f64[0];\n    v55 = _mm_div_pd(*((__m128d *)v2 + 15), _mm_unpacklo_pd(v49, v49));\n    v56 = v55.m128d_f64[0];\n    v2[15] = v55;\n    do\n    {\n      x = v51->x;\n      y = v51->y;\n      v59 = 0;\n      v55.m128d_f64[0] = (clusters - y) * (clusters - y) + (v13 - x) * (v13 - x);\n      if ( v55.m128d_f64[0] >= 1.797693134862316e308 )\n      {\n        v59 = -1;\n        v55.m128d_f64[0] = 1.797693134862316e308;\n      }\n      if ( v55.m128d_f64[0] > (v17 - x) * (v17 - x) + (block - y) * (block - y) )\n      {\n        v55.m128d_f64[0] = (v17 - x) * (v17 - x) + (block - y) * (block - y);\n        v59 = 1;\n      }\n      if ( v55.m128d_f64[0] > (v21 - x) * (v21 - x) + (v90 - y) * (v90 - y) )\n      {\n        v55.m128d_f64[0] = (v21 - x) * (v21 - x) + (v90 - y) * (v90 - y);\n        v59 = 2;\n      }\n      if ( v55.m128d_f64[0] > (v25 - x) * (v25 - x) + (v89 - y) * (v89 - y) )\n      {\n        v55.m128d_f64[0] = (v25 - x) * (v25 - x) + (v89 - y) * (v89 - y);\n        v59 = 3;\n      }\n      if ( v55.m128d_f64[0] > (v29 - x) * (v29 - x) + (v88 - y) * (v88 - y) )\n      {\n        v55.m128d_f64[0] = (v29 - x) * (v29 - x) + (v88 - y) * (v88 - y);\n        v59 = 4;\n      }\n      if ( v55.m128d_f64[0] > (v33 - x) * (v33 - x) + (v87 - y) * (v87 - y) )\n      {\n        v55.m128d_f64[0] = (v33 - x) * (v33 - x) + (v87 - y) * (v87 - y);\n        v59 = 5;\n      }\n      if ( v55.m128d_f64[0] > (v37 - x) * (v37 - x) + (v86 - y) * (v86 - y) )\n      {\n        v55.m128d_f64[0] = (v37 - x) * (v37 - x) + (v86 - y) * (v86 - y);\n        v59 = 6;\n      }\n      if ( v55.m128d_f64[0] > (v50 - x) * (v50 - x) + (radius - y) * (radius - y) )\n      {\n        v55.m128d_f64[0] = (v50 - x) * (v50 - x) + (radius - y) * (radius - y);\n        v59 = 7;\n      }\n      if ( v55.m128d_f64[0] > (v53 - x) * (v53 - x) + (ang - y) * (ang - y) )\n      {\n        v55.m128d_f64[0] = (v53 - x) * (v53 - x) + (ang - y) * (ang - y);\n        v59 = 8;\n      }\n      if ( v55.m128d_f64[0] > (v54 - x) * (v54 - x) + (v91 - y) * (v91 - y) )\n      {\n        v55.m128d_f64[0] = (v54 - x) * (v54 - x) + (v91 - y) * (v91 - y);\n        v59 = 9;\n      }\n      if ( v55.m128d_f64[0] > (v55.m128d_f64[1] - y) * (v55.m128d_f64[1] - y) + (v56 - x) * (v56 - x) )\n        v59 = 10;\n      if ( v51->group != v59 )\n      {\n        v51->group = v59;\n        ++v52;\n      }\n      ++v51;\n    }\n    while ( v51 != v1 );\n  }\n  while ( v52 > 0x64 );\n  blocka = libmin_malloc(0x108uLL);\n  *blocka = _mm_loadl_epi64((const __m128i *)&qword_81D0);\n  blocka[1] = xmmword_81E0;\n  blocka[2] = xmmword_81F0;\n  blocka[3] = xmmword_8200;\n  blocka[4] = xmmword_8210;\n  blocka[5] = xmmword_8220;\n  blocka[6] = xmmword_8230;\n  blocka[7] = xmmword_8240;\n  blocka[8] = xmmword_8250;\n  blocka[9] = xmmword_8260;\n  blocka[10] = xmmword_8270;\n  blocka[11] = xmmword_8280;\n  blocka[12] = xmmword_8290;\n  blocka[13] = xmmword_82A0;\n  blocka[14] = xmmword_82B0;\n  blocka[15] = xmmword_82C0;\n  v60 = 2.225073858507201e-308;\n  *((_QWORD *)blocka + 32) = 0x3FC745D1745D1746LL;\n  p_x = &observations->x;\n  v62 = 2.225073858507201e-308;\n  v63 = 1.797693134862316e308;\n  v64 = 1.797693134862316e308;\n  do\n  {\n    v65 = *p_x;\n    p_x += 3;\n    v64 = fmin(v65, v64);\n    v62 = fmax(v65, v62);\n    v66 = *(p_x - 2);\n    v67 = fmin(v66, v63);\n    v63 = v67;\n    v60 = fmax(v66, v60);\n  }\n  while ( p_x != (double *)v1 );\n  v68 = (double *)v2;\n  radiusa = fmin(400.0 / (v60 - v67), 400.0 / (v62 - v64));\n  anga = (v64 + v62) * 0.5;\n  v81 = (v67 + v60) * 0.5;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410, 410);\n  libmin_printf(\"/l {rlineto} def /m {rmoveto} def\\n\"\n                \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n                \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray fill grestore gsave 3 setlinewidth 1\"\n                \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  clustersa = (cluster *)v2;\n  v69 = (double *)blocka;\n  v70 = 0;\n  do\n  {\n    v71 = observations;\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", *v69, v69[1], v69[2]);\n    do\n    {\n      if ( v71->group == v70 )\n        libmin_printf(\"%.3f %.3f c\\n\", (v71->x - anga) * radiusa + 200.0, (v71->y - v81) * radiusa + 200.0);\n      ++v71;\n    }\n    while ( v71 != v1 );\n    v72 = v68[1];\n    v73 = *v68;\n    ++v70;\n    v69 += 3;\n    v68 += 3;\n    libmin_printf(\"\\n0 setgray %f %f s\\n\", (v73 - anga) * radiusa + 200.0, (v72 - v81) * radiusa + 200.0);\n  }\n  while ( v70 != 11 );\n  libmin_printf(\"\\n%%%%EOF\\n\");\n  libmin_free(blocka);\n  libmin_free(observations);\n  libmin_free(clustersa);\n}\n"}, "pseudo_normalize": "", "binary": "k-means/k-means.host.O3", "assembly": "<test2>:\nendbr64\npush   %r15\nmov    $0x16e3600,%edi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x68,%rsp\ncall   2710 <libmin_malloc>\nmov    %rax,0x58(%rsp)\nmov    %rax,%rbx\nlea    0x16e3600(%rax),%r13\nnopl   0x0(%rax,%rax,1)\ncall   4cc0 <libmin_rand>\npxor   %xmm0,%xmm0\nadd    $0x18,%rbx\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x6754(%rip),%xmm0\nmulsd  0x6754(%rip),%xmm0\nmovsd  %xmm0,(%rsp)\ncall   4cc0 <libmin_rand>\npxor   %xmm1,%xmm1\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm1\ndivsd  0x672f(%rip),%xmm1\nmulsd  0x6737(%rip),%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm1,0x8(%rsp)\ncall   4fe0 <libmin_cos>\nmulsd  (%rsp),%xmm0\nmovsd  0x8(%rsp),%xmm1\nmovsd  %xmm0,-0x18(%rbx)\nmovapd %xmm1,%xmm0\ncall   53d0 <libmin_sin>\nmulsd  (%rsp),%xmm0\nmovsd  %xmm0,-0x10(%rbx)\ncmp    %rbx,%r13\njne    1a40 <test2+0x30>\nmov    $0x108,%edi\nmov    $0xba2e8ba3,%ebx\ncall   2710 <libmin_malloc>\nmov    $0x108,%edx\nxor    %esi,%esi\nmov    %rax,%rdi\nmov    %rax,%r14\ncall   2af0 <libmin_memset>\nmov    0x58(%rsp),%rax\nlea    0x10(%rax),%r12\nlea    0x16e3610(%rax),%rbp\nnopl   0x0(%rax)\ncall   4cc0 <libmin_rand>\nadd    $0x18,%r12\nmov    %eax,%edx\nimul   %rbx,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%ecx\nlea    (%rdx,%rcx,2),%edx\nsub    %edx,%eax\nmov    %eax,-0x18(%r12)\ncmp    %r12,%rbp\njne    1af8 <test2+0xe8>\nmov    0x58(%rsp),%rdi\npxor   %xmm5,%xmm5\nmov    $0xa,%esi\nmovsd  0x6645(%rip),%xmm4\nnopl   0x0(%rax,%rax,1)\nmovq   $0x0,0x10(%r14)\nmov    %rdi,%rax\nmovq   $0x0,0x28(%r14)\nmovq   $0x0,0x40(%r14)\nmovq   $0x0,0x58(%r14)\nmovq   $0x0,0x70(%r14)\nmovq   $0x0,0x88(%r14)\nmovq   $0x0,0xa0(%r14)\nmovq   $0x0,0xb8(%r14)\nmovq   $0x0,0xd0(%r14)\nmovq   $0x0,0xe8(%r14)\nmovq   $0x0,0x100(%r14)\nmovups %xmm5,(%r14)\nmovups %xmm5,0x18(%r14)\nmovups %xmm5,0x30(%r14)\nmovups %xmm5,0x48(%r14)\nmovups %xmm5,0x60(%r14)\nmovups %xmm5,0x78(%r14)\nmovups %xmm5,0x90(%r14)\nmovups %xmm5,0xa8(%r14)\nmovups %xmm5,0xc0(%r14)\nmovups %xmm5,0xd8(%r14)\nmovups %xmm5,0xf0(%r14)\nnopw   0x0(%rax,%rax,1)\nmovslq 0x10(%rax),%rdx\nmovupd (%rax),%xmm0\nadd    $0x18,%rax\nlea    (%rdx,%rdx,2),%rdx\nlea    (%r14,%rdx,8),%rdx\nmovupd (%rdx),%xmm7\naddq   $0x1,0x10(%rdx)\naddpd  %xmm7,%xmm0\nmovups %xmm0,(%rdx)\ncmp    %r13,%rax\njne    1bf0 <test2+0x1e0>\nmov    0x10(%r14),%rax\ntest   %rax,%rax\njs     2512 <test2+0xb02>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovupd (%r14),%xmm0\nunpcklpd %xmm1,%xmm1\nmov    0x28(%r14),%rax\ndivpd  %xmm1,%xmm0\nmovhpd %xmm0,0x20(%rsp)\nmovapd %xmm0,%xmm11\nmovups %xmm0,(%r14)\ntest   %rax,%rax\njs     24f4 <test2+0xae4>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovupd 0x18(%r14),%xmm0\nunpcklpd %xmm1,%xmm1\nmov    0x40(%r14),%rax\ndivpd  %xmm1,%xmm0\nmovhpd %xmm0,0x18(%rsp)\nmovapd %xmm0,%xmm10\nmovups %xmm0,0x18(%r14)\ntest   %rax,%rax\njs     24d6 <test2+0xac6>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovupd 0x30(%r14),%xmm0\nunpcklpd %xmm1,%xmm1\nmov    0x58(%r14),%rax\ndivpd  %xmm1,%xmm0\nmovhpd %xmm0,0x48(%rsp)\nmovq   %xmm0,%r15\nmovups %xmm0,0x30(%r14)\ntest   %rax,%rax\njs     24b8 <test2+0xaa8>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovupd 0x48(%r14),%xmm0\nunpcklpd %xmm1,%xmm1\nmov    0x70(%r14),%rax\ndivpd  %xmm1,%xmm0\nmovhpd %xmm0,0x40(%rsp)\nmovq   %xmm0,%r12\nmovups %xmm0,0x48(%r14)\ntest   %rax,%rax\njs     249a <test2+0xa8a>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovupd 0x60(%r14),%xmm0\nunpcklpd %xmm1,%xmm1\nmov    0x88(%r14),%rax\ndivpd  %xmm1,%xmm0\nmovhpd %xmm0,0x38(%rsp)\nmovapd %xmm0,%xmm14\nmovups %xmm0,0x60(%r14)\ntest   %rax,%rax\njs     247c <test2+0xa6c>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovupd 0x78(%r14),%xmm0\nunpcklpd %xmm1,%xmm1\nmov    0xa0(%r14),%rax\ndivpd  %xmm1,%xmm0\nmovhpd %xmm0,0x30(%rsp)\nmovapd %xmm0,%xmm13\nmovups %xmm0,0x78(%r14)\ntest   %rax,%rax\njs     245e <test2+0xa4e>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovupd 0x90(%r14),%xmm0\nunpcklpd %xmm1,%xmm1\nmov    0xb8(%r14),%rax\ndivpd  %xmm1,%xmm0\nmovhpd %xmm0,0x28(%rsp)\nmovapd %xmm0,%xmm12\nmovups %xmm0,0x90(%r14)\ntest   %rax,%rax\njs     2440 <test2+0xa30>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovupd 0xa8(%r14),%xmm0\nunpcklpd %xmm1,%xmm1\nmov    0xd0(%r14),%rax\ndivpd  %xmm1,%xmm0\nmovhpd %xmm0,(%rsp)\nmovapd %xmm0,%xmm7\nmovups %xmm0,0xa8(%r14)\ntest   %rax,%rax\njs     2422 <test2+0xa12>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovupd 0xc0(%r14),%xmm0\nunpcklpd %xmm1,%xmm1\nmov    0xe8(%r14),%rax\ndivpd  %xmm1,%xmm0\nmovhpd %xmm0,0x8(%rsp)\nmovapd %xmm0,%xmm8\nmovups %xmm0,0xc0(%r14)\ntest   %rax,%rax\njs     2404 <test2+0x9f4>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nmovupd 0xd8(%r14),%xmm0\nunpcklpd %xmm1,%xmm1\nmov    0x100(%r14),%rax\ndivpd  %xmm1,%xmm0\nmovhpd %xmm0,0x50(%rsp)\nmovapd %xmm0,%xmm9\nmovups %xmm0,0xd8(%r14)\ntest   %rax,%rax\njs     23e6 <test2+0x9d6>\npxor   %xmm1,%xmm1\ncvtsi2sd %rax,%xmm1\nunpcklpd %xmm1,%xmm1\nmovapd %xmm7,%xmm6\nmov    %rdi,%rdx\nxor    %ecx,%ecx\nmovapd %xmm8,%xmm7\nmov    %r14,%r8\nmovapd %xmm9,%xmm8\nmov    %r13,%r9\nmovupd 0xf0(%r14),%xmm0\nmovapd %xmm14,%xmm15\ndivpd  %xmm1,%xmm0\nmovhpd %xmm0,0x10(%rsp)\nmovapd %xmm0,%xmm9\nmovups %xmm0,0xf0(%r14)\nnop\nmovsd  (%rdx),%xmm2\nmovsd  0x8(%rdx),%xmm1\nmovapd %xmm11,%xmm3\nxor    %eax,%eax\nmovsd  0x20(%rsp),%xmm0\nsubsd  %xmm2,%xmm3\nsubsd  %xmm1,%xmm0\nmulsd  %xmm3,%xmm3\nmulsd  %xmm0,%xmm0\naddsd  %xmm3,%xmm0\ncomisd %xmm0,%xmm4\nja     1ed9 <test2+0x4c9>\nmov    $0xffffffff,%eax\nmovapd %xmm4,%xmm0\nmovsd  0x18(%rsp),%xmm14\nmovapd %xmm10,%xmm3\nsubsd  %xmm2,%xmm3\nsubsd  %xmm1,%xmm14\nmulsd  %xmm3,%xmm3\nmulsd  %xmm14,%xmm14\naddsd  %xmm14,%xmm3\ncomisd %xmm3,%xmm0\njbe    1f0b <test2+0x4fb>\nmovapd %xmm3,%xmm0\nmov    $0x1,%eax\nmovsd  0x48(%rsp),%xmm14\nmovq   %r15,%xmm3\nsubsd  %xmm2,%xmm3\nsubsd  %xmm1,%xmm14\nmulsd  %xmm3,%xmm3\nmulsd  %xmm14,%xmm14\naddsd  %xmm14,%xmm3\ncomisd %xmm3,%xmm0\njbe    1f3d <test2+0x52d>\nmovapd %xmm3,%xmm0\nmov    $0x2,%eax\nmovsd  0x40(%rsp),%xmm14\nmovq   %r12,%xmm3\nsubsd  %xmm2,%xmm3\nsubsd  %xmm1,%xmm14\nmulsd  %xmm3,%xmm3\nmulsd  %xmm14,%xmm14\naddsd  %xmm14,%xmm3\ncomisd %xmm3,%xmm0\njbe    1f6f <test2+0x55f>\nmovapd %xmm3,%xmm0\nmov    $0x3,%eax\nmovsd  0x38(%rsp),%xmm14\nmovapd %xmm15,%xmm3\nsubsd  %xmm2,%xmm3\nsubsd  %xmm1,%xmm14\nmulsd  %xmm3,%xmm3\nmulsd  %xmm14,%xmm14\naddsd  %xmm14,%xmm3\ncomisd %xmm3,%xmm0\njbe    1fa1 <test2+0x591>\nmovapd %xmm3,%xmm0\nmov    $0x4,%eax\nmovsd  0x30(%rsp),%xmm14\nmovapd %xmm13,%xmm3\nsubsd  %xmm2,%xmm3\nsubsd  %xmm1,%xmm14\nmulsd  %xmm3,%xmm3\nmulsd  %xmm14,%xmm14\naddsd  %xmm14,%xmm3\ncomisd %xmm3,%xmm0\njbe    1fd3 <test2+0x5c3>\nmovapd %xmm3,%xmm0\nmov    $0x5,%eax\nmovsd  0x28(%rsp),%xmm14\nmovapd %xmm12,%xmm3\nsubsd  %xmm2,%xmm3\nsubsd  %xmm1,%xmm14\nmulsd  %xmm3,%xmm3\nmulsd  %xmm14,%xmm14\naddsd  %xmm14,%xmm3\ncomisd %xmm3,%xmm0\njbe    2005 <test2+0x5f5>\nmovapd %xmm3,%xmm0\nmov    $0x6,%eax\nmovsd  (%rsp),%xmm14\nmovapd %xmm6,%xmm3\nsubsd  %xmm2,%xmm3\nsubsd  %xmm1,%xmm14\nmulsd  %xmm3,%xmm3\nmulsd  %xmm14,%xmm14\naddsd  %xmm14,%xmm3\ncomisd %xmm3,%xmm0\njbe    2035 <test2+0x625>\nmovapd %xmm3,%xmm0\nmov    $0x7,%eax\nmovsd  0x8(%rsp),%xmm14\nmovapd %xmm7,%xmm3\nsubsd  %xmm2,%xmm3\nsubsd  %xmm1,%xmm14\nmulsd  %xmm3,%xmm3\nmulsd  %xmm14,%xmm14\naddsd  %xmm14,%xmm3\ncomisd %xmm3,%xmm0\njbe    2066 <test2+0x656>\nmovapd %xmm3,%xmm0\nmov    $0x8,%eax\nmovsd  0x50(%rsp),%xmm14\nmovapd %xmm8,%xmm3\nsubsd  %xmm2,%xmm3\nsubsd  %xmm1,%xmm14\nmulsd  %xmm3,%xmm3\nmulsd  %xmm14,%xmm14\naddsd  %xmm14,%xmm3\ncomisd %xmm3,%xmm0\njbe    2098 <test2+0x688>\nmovapd %xmm3,%xmm0\nmov    $0x9,%eax\nmovapd %xmm9,%xmm3\nsubsd  %xmm2,%xmm3\nmovsd  0x10(%rsp),%xmm2\nsubsd  %xmm1,%xmm2\nmulsd  %xmm3,%xmm3\nmulsd  %xmm2,%xmm2\naddsd  %xmm3,%xmm2\nucomisd %xmm2,%xmm0\ncmova  %esi,%eax\ncmp    %eax,0x10(%rdx)\nje     20ca <test2+0x6ba>\nmov    %eax,0x10(%rdx)\nadd    $0x1,%rcx\nadd    $0x18,%rdx\ncmp    %r9,%rdx\njne    1ea0 <test2+0x490>\nmov    %r8,%r14\nmov    %r9,%r13\ncmp    $0x64,%rcx\nja     1b38 <test2+0x128>\nmov    $0x108,%edi\ncall   2710 <libmin_malloc>\nmovq   0x60d7(%rip),%xmm0\nmov    %rax,0x18(%rsp)\nmovups %xmm0,(%rax)\nmovapd 0x60d7(%rip),%xmm0\nmovups %xmm0,0x10(%rax)\nmovapd 0x60db(%rip),%xmm0\nmovups %xmm0,0x20(%rax)\nmovapd 0x60df(%rip),%xmm0\nmovups %xmm0,0x30(%rax)\nmovapd 0x60e3(%rip),%xmm0\nmovups %xmm0,0x40(%rax)\nmovapd 0x60e7(%rip),%xmm0\nmovups %xmm0,0x50(%rax)\nmovapd 0x60eb(%rip),%xmm0\nmovups %xmm0,0x60(%rax)\nmovapd 0x60ef(%rip),%xmm0\nmovups %xmm0,0x70(%rax)\nmovapd 0x60f3(%rip),%xmm0\nmovups %xmm0,0x80(%rax)\nmovapd 0x60f4(%rip),%xmm0\nmovups %xmm0,0x90(%rax)\nmovapd 0x60f5(%rip),%xmm0\nmovups %xmm0,0xa0(%rax)\nmovapd 0x60f6(%rip),%xmm0\nmovups %xmm0,0xb0(%rax)\nmovapd 0x60f7(%rip),%xmm0\nmovups %xmm0,0xc0(%rax)\nmovapd 0x60f8(%rip),%xmm0\nmovups %xmm0,0xd0(%rax)\nmovapd 0x60f9(%rip),%xmm0\nmovups %xmm0,0xe0(%rax)\nmovapd 0x60fa(%rip),%xmm0\nmovups %xmm0,0xf0(%rax)\nmov    0x607c(%rip),%rsi\nmovsd  0x5fa4(%rip),%xmm3\nmov    %rsi,0x100(%rax)\nmov    0x58(%rsp),%rax\nmovapd %xmm3,%xmm4\nmov    0x5f85(%rip),%rsi\nmovq   %rsi,%xmm0\nmovq   %rsi,%xmm2\nnopl   (%rax)\nmovsd  (%rax),%xmm1\nadd    $0x18,%rax\nmovapd %xmm1,%xmm7\nminsd  %xmm2,%xmm1\nmaxsd  %xmm4,%xmm7\nmovapd %xmm1,%xmm2\nmovsd  -0x10(%rax),%xmm1\nmovapd %xmm7,%xmm4\nmovapd %xmm1,%xmm7\nminsd  %xmm0,%xmm1\nmaxsd  %xmm3,%xmm7\nmovapd %xmm1,%xmm0\nmovapd %xmm7,%xmm3\ncmp    %r13,%rax\njne    2200 <test2+0x7f0>\nmovapd %xmm4,%xmm5\nmov    $0x19a,%edx\nmov    $0x19a,%esi\nxor    %eax,%eax\nsubsd  %xmm2,%xmm5\naddsd  %xmm4,%xmm2\nxor    %r15d,%r15d\nmov    %r14,%rbp\nmovsd  0x5f38(%rip),%xmm1\nlea    0x5da1(%rip),%rdi\nmovapd %xmm1,%xmm7\ndivsd  %xmm5,%xmm7\nmovapd %xmm3,%xmm5\nsubsd  %xmm0,%xmm5\naddsd  %xmm3,%xmm0\ndivsd  %xmm5,%xmm1\nminsd  %xmm7,%xmm1\nmovsd  %xmm1,(%rsp)\nmovsd  0x5f10(%rip),%xmm1\nmulsd  %xmm1,%xmm2\nmulsd  %xmm1,%xmm0\nmovsd  %xmm2,0x8(%rsp)\nmovsd  %xmm0,0x10(%rsp)\ncall   4a50 <libmin_printf>\nlea    0x5d90(%rip),%rdi\nxor    %eax,%eax\ncall   4a50 <libmin_printf>\nmov    %r14,0x20(%rsp)\nmov    0x18(%rsp),%rbx\nmov    %r15d,%r14d\nmov    0x58(%rsp),%r15\nnopl   0x0(%rax)\nmovsd  0x10(%rbx),%xmm2\nmovsd  0x8(%rbx),%xmm1\nmov    %r15,%r12\nlea    0x5e56(%rip),%rdi\nmovsd  (%rbx),%xmm0\nmov    $0x3,%eax\ncall   4a50 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\ncmp    %r14d,0x10(%r12)\njne    2346 <test2+0x936>\nmovsd  (%r12),%xmm0\nmovsd  0x8(%r12),%xmm1\nlea    0x5e51(%rip),%rdi\nmov    $0x2,%eax\nsubsd  0x10(%rsp),%xmm1\nsubsd  0x8(%rsp),%xmm0\nmovsd  (%rsp),%xmm5\nmulsd  %xmm5,%xmm1\nmulsd  %xmm5,%xmm0\naddsd  0x5e6f(%rip),%xmm1\naddsd  0x5e67(%rip),%xmm0\ncall   4a50 <libmin_printf>\nadd    $0x18,%r12\ncmp    %r13,%r12\njne    22f8 <test2+0x8e8>\nmovsd  0x8(%rbp),%xmm1\nmovsd  0x0(%rbp),%xmm0\nlea    0x5df0(%rip),%rdi\nmov    $0x2,%eax\nsubsd  0x10(%rsp),%xmm1\nadd    $0x1,%r14d\nadd    $0x18,%rbx\nadd    $0x18,%rbp\nsubsd  0x8(%rsp),%xmm0\nmovsd  (%rsp),%xmm4\nmulsd  %xmm4,%xmm1\nmulsd  %xmm4,%xmm0\naddsd  0x5e16(%rip),%xmm1\naddsd  0x5e0e(%rip),%xmm0\ncall   4a50 <libmin_printf>\ncmp    $0xb,%r14d\njne    22d0 <test2+0x8c0>\nlea    0x5d80(%rip),%rdi\nxor    %eax,%eax\nmov    0x20(%rsp),%r14\ncall   4a50 <libmin_printf>\nmov    0x18(%rsp),%rdi\ncall   27c0 <libmin_free>\nmov    0x58(%rsp),%rdi\ncall   27c0 <libmin_free>\nadd    $0x68,%rsp\nmov    %r14,%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    27c0 <libmin_free>\nmov    %rax,%rdx\nand    $0x1,%eax\npxor   %xmm1,%xmm1\nshr    %rdx\nor     %rax,%rdx\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\njmp    1e5d <test2+0x44d>\nmov    %rax,%rdx\nand    $0x1,%eax\npxor   %xmm1,%xmm1\nshr    %rdx\nor     %rax,%rdx\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\njmp    1e20 <test2+0x410>\nmov    %rax,%rdx\nand    $0x1,%eax\npxor   %xmm1,%xmm1\nshr    %rdx\nor     %rax,%rdx\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\njmp    1de3 <test2+0x3d3>\nmov    %rax,%rdx\nand    $0x1,%eax\npxor   %xmm1,%xmm1\nshr    %rdx\nor     %rax,%rdx\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\njmp    1da8 <test2+0x398>\nmov    %rax,%rdx\nand    $0x1,%eax\npxor   %xmm1,%xmm1\nshr    %rdx\nor     %rax,%rdx\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\njmp    1d6b <test2+0x35b>\nmov    %rax,%rdx\nand    $0x1,%eax\npxor   %xmm1,%xmm1\nshr    %rdx\nor     %rax,%rdx\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\njmp    1d34 <test2+0x324>\nmov    %rax,%rdx\nand    $0x1,%eax\npxor   %xmm1,%xmm1\nshr    %rdx\nor     %rax,%rdx\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\njmp    1cfd <test2+0x2ed>\nmov    %rax,%rdx\nand    $0x1,%eax\npxor   %xmm1,%xmm1\nshr    %rdx\nor     %rax,%rdx\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\njmp    1cc9 <test2+0x2b9>\nmov    %rax,%rdx\nand    $0x1,%eax\npxor   %xmm1,%xmm1\nshr    %rdx\nor     %rax,%rdx\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\njmp    1c95 <test2+0x285>\nmov    %rax,%rdx\nand    $0x1,%eax\npxor   %xmm1,%xmm1\nshr    %rdx\nor     %rax,%rdx\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\njmp    1c61 <test2+0x251>\nmov    %rax,%rdx\nand    $0x1,%eax\npxor   %xmm1,%xmm1\nshr    %rdx\nor     %rax,%rdx\ncvtsi2sd %rdx,%xmm1\naddsd  %xmm1,%xmm1\njmp    1c2f <test2+0x21f>\n"}
{"source": {"path": "kadane/kadane.c", "function_name": "kadane", "content": "#include \"libmin.h\"\n \n// Function to find the maximum sum of a contiguous subarray\n// in a given integer array\nint\nkadane(int arr[], int n, int *ends_at)\n{\n  // stores the maximum sum subarray found so far\n  int max_so_far = 0;\n  *ends_at = -1;\n \n  // stores the maximum sum of subarray ending at the current position\n  int max_ending_here = 0;\n \n  // traverse the given array\n  for (int i = 0; i < n; i++)\n  {\n    // update the maximum sum of subarray \"ending\" at index `i` (by adding the\n    // current element to maximum sum ending at previous index `i-1`)\n    max_ending_here = max_ending_here + arr[i];\n \n    // if the maximum sum is negative, set it to 0 (which represents\n    // an empty subarray)\n    max_ending_here = MAX(max_ending_here, 0);\n\n    // update the result if the current subarray sum is found to be greater\n    if (max_so_far < max_ending_here)\n      *ends_at = i;\n    max_so_far = MAX(max_so_far, max_ending_here);\n  }\n  return max_so_far;\n}\n"}, "pseudo": {"path": "kadane/kadane.host.O3.pseudo", "function_name": "kadane", "address": "0x12b0", "label": "kadane", "content": "int __fastcall kadane(int *arr, int n, int *ends_at)\n{\n  __int64 v3; // rcx\n  int v4; // eax\n  int v5; // r8d\n\n  *ends_at = -1;\n  if ( n <= 0 )\n    return 0;\n  v3 = 0LL;\n  v4 = 0;\n  v5 = 0;\n  do\n  {\n    v4 += arr[v3];\n    if ( v4 < 0 )\n      v4 = 0;\n    if ( v4 > v5 )\n    {\n      *ends_at = v3;\n      v5 = v4;\n    }\n    ++v3;\n  }\n  while ( n != v3 );\n  return v5;\n}\n"}, "pseudo_normalize": "int kadane(int *arr, int n, int *ends_at) {\n  long long v3;\n  int v4;\n  int v5;\n  *ends_at = -1;\n  if (n <= 0) return 0;\n  v3 = 0LL;\n  v4 = 0;\n  v5 = 0;\n  do {\n    v4 += arr[v3];\n    if (v4 < 0) v4 = 0;\n    if (v4 > v5) {\n      *ends_at = v3;\n      v5 = v4;\n    }\n    ++v3;\n  } while (n != v3);\n  return v5;\n}", "binary": "kadane/kadane.host.O3", "assembly": "<kadane>:\nendbr64\nmovl   $0xffffffff,(%rdx)\ntest   %esi,%esi\njle    1300 <kadane+0x50>\nmovslq %esi,%rsi\nxor    %ecx,%ecx\nxor    %eax,%eax\nxor    %r8d,%r8d\nnopl   0x0(%rax,%rax,1)\nadd    (%rdi,%rcx,4),%eax\nmov    $0x0,%r9d\ncmovs  %r9d,%eax\ncmp    %r8d,%eax\njle    12e4 <kadane+0x34>\nmov    %ecx,(%rdx)\ncmp    %eax,%r8d\ncmovl  %eax,%r8d\nadd    $0x1,%rcx\ncmp    %rcx,%rsi\njne    12d0 <kadane+0x20>\nmov    %r8d,%eax\nret\nnopl   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "kadane/kadane.c", "function_name": "main", "content": " \nint\nmain(void)\n{\n  int arr[] = {\n    8155, 17168, 11554, -14406, 13854, 20973, -26471, -11245, 25508, -24548, -2094, -16932, -23080,\n    29777, -27647, -5927, 20197, -16505, -28944, 2518, 22405, 15304, -19199, 5439, 4971, 24179, 1119,\n    16764, -24526, -973, -9585, 15066, 12069, -21990, -19708, -16603, 24065, 15869, -6208, 22922,\n    2901, 24070, -16253, 15350, -27951, -817, -10363, -4185, -17835, -21493, -25281, -4842, -1425,\n    6710, -7297, -17119, -10408, 18129, -28213, -12161, 13068, -4347, 27196, -9652, -19423, 6057,\n    -22147, -10601, -17130, -13839, 4925, 27786, -9734, -25871, -2776, 16462, 13778, 11363, -6662,\n    -24896, 19904, 29515, 9625, 18193, -17274, -3246, 27168, 508, -81, 15064, 19885, 18619, -5470,\n    23422, -10780, -21517, 26606, -20833, -27943, -11223, -10137, -29356, 2701, -10774, 13286, -15863,\n    24259, -3434, -16362, -4444, -20182, 7785, 23559, -16482, -23146, 7477, 25038, -19306, -26506,\n    29314, 2174, 7862, -29266, -1236, -28187, 27877, -7969, 10314, -5142, 5466, 28920, 29191, -27061,\n    27601, 7428, 12574, -5776, 27915, -13399, -11340, 3307, 7043, -6927, 16463, -6535, 26316, -10710,\n    16103, -5578, 26102, -22493, 23027, 12203, 3251, 5281, -17123, -9919, 18986, -9330, -192, 16263,\n    -19289, -22665, -2993, 27926, -3020, -10050, -4092, 17416, 26503, -16237, -25905, -19723, -5055,\n    2901, 24070, -16253, 15350, -27951, -817, -10363, -4185, -17835, -21493, -25281, -4842, -1425,\n    27601, 7428, 12574, -5776, 27915, -13399, -11340, 3307, 7043, -6927, 16463, -6535, 26316, -10710,\n    29777, -27647, -5927, 20197, -16505, -28944, 2518, 22405, 15304, -19199, 5439, 4971, 24179, 1119,\n    8155, 17168, 11554, -14406, 13854, 20973, -26471, -11245, 25508, -24548, -2094, -16932, -23080,\n    -25496, -27164, -9845, 25985, 21965, 26979, -28295, -4574, -27464, -26163, 11498, -6302,\n    29123, -4712, -24339, -27645, 23484, 12151, 14797, -5334, -15853, 9431, 7116, 27195, -1075,\n    17134, 21955, -3745, -4717, 11285, -9264, -20400, 15249, -18604, 390, 25377, -7495,\n    -24694, 25767, 17461, -21795, 1815, -5557, 22489, 11085, -6132, -2513, 131, 18955,\n    -28518, -14482, 15781, 21178, 5485, -12187, -24004, 12344, 20129, -26045, -28136, -26435, 23729,\n    -12384, 3157, 3121, -18724, -17193, 22853, -29225, 29921, -19534, -28048, -9185, -29704, -29260, -2534,\n    21587, 4770, 4880, -9269, 9197, 25075, -3083, -4795, -28614, -8794, 20376, -12507, -14627, 8109,\n    28004, -29128, -10195, 16767, -6852, -21305, 28599, -23297, -16460, 18601, 5359, -7017, -24250, -23556,\n    16491, -23856, -16880, 19593, 6171, 12602, -29905, -27567, 18969, -12582, 18015, 7774, 23534, -26819,\n    -8535, 13345, 9279, -20758, -1612, 13739, -29764, 6005, 2037, 14339, -23422, -11, -16605, -11701\n  };\n  int n = sizeof(arr)/sizeof(arr[0]);\n  int max_sum, ends_at;\n \n  libmin_printf(\"Array size= %d\\n\", n);\n\n  max_sum = kadane(arr, n, &ends_at);\n\n  libmin_printf(\"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\", max_sum, ends_at);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "kadane/kadane.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rdx\n  int v4; // r8d\n  int v5; // esi\n  int v6; // eax\n  int arr[362]; // [rsp+0h] [rbp-5B8h] BYREF\n  unsigned __int64 v8; // [rsp+5A8h] [rbp-10h]\n\n  v8 = __readfsqword(0x28u);\n  qmemcpy(arr, &unk_4060, 0x5A0uLL);\n  libmin_printf(\"Array size= %d\\n\", 360);\n  v3 = 0LL;\n  v4 = -1;\n  v5 = 0;\n  v6 = 0;\n  while ( 1 )\n  {\n    v6 += arr[v3];\n    if ( v6 < 0 )\n      v6 = 0;\n    if ( v5 < v6 )\n    {\n      v4 = v3;\n      v5 = v6;\n    }\n    if ( ++v3 == 360 )\n    {\n      libmin_printf(\"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\", v5, v4);\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  int v5;\n  int v6;\n  int arr[362];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  qmemcpy(arr, &unk_4060, 1440uLL);\n  libmin_printf(\"Array size= %d\\n\", 360);\n  v3 = 0LL;\n  v4 = -1;\n  v5 = 0;\n  v6 = 0;\n  while (1) {\n    v6 += arr[v3];\n    if (v6 < 0) v6 = 0;\n    if (v5 < v6) {\n      v4 = v3;\n      v5 = v6;\n    }\n    if (++v3 == 360) {\n      libmin_printf(\n          \"The maximum sum of a contiguous subarray is %d (ending at index \"\n          \"%d)\\n\",\n          v5, v4);\n      libmin_success();\n    }\n  }\n}", "binary": "kadane/kadane.host.O3", "assembly": "<main>:\nendbr64\npush   %rbx\nlea    0x2f54(%rip),%rsi\nmov    $0xb4,%ecx\nsub    $0x5b0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x5a8(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbx\nmov    %rbx,%rdi\nrep movsq %ds:(%rsi),%es:(%rdi)\nmov    $0x168,%esi\nlea    0x2ec4(%rip),%rdi\ncall   33e0 <libmin_printf>\nxor    %edx,%edx\nmov    $0xffffffff,%r8d\nxor    %esi,%esi\nxor    %eax,%eax\nnopl   0x0(%rax)\nadd    (%rbx,%rdx,4),%eax\nmov    $0x0,%ecx\ncmovs  %ecx,%eax\ncmp    %eax,%esi\ncmovl  %edx,%r8d\ncmovl  %eax,%esi\nadd    $0x1,%rdx\ncmp    $0x168,%rdx\njne    1158 <main+0x58>\nmov    %r8d,%edx\nlea    0x2e95(%rip),%rdi\nxor    %eax,%eax\ncall   33e0 <libmin_printf>\ncall   3620 <libmin_success>\nmov    0x5a8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    11ad <main+0xad>\nadd    $0x5b0,%rsp\nxor    %eax,%eax\npop    %rbx\nret\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "J", "content": "/* The following routine calculates the Bessel function of the first kind \n   for an integer index. We just sum the series representation given by\n\n\n                      __                     2j\n\t              \\        j        (x/2)\nJ (x) = 1/n! (x/2)^n       (-1)   __________________\n n\t              /__          j!(n+1)...(n+j)\n\t\t      j=0\n\n   \nSee Special functions and their applications, N.N. Lebedev, Dover, 1972,\npp 95-142 for an introduction to Bessel functions and related cylinder\nfunctions.\n\n*/\n\ndouble J(int n, double x)\n{\n\tdouble dsum=0.0,dterm,s_j,d_n,d_j,cfact=1.0;\n\tint j,nn;\n\n\tnn = n >= 0 ? n : -n;  /* Absolute value of n. Use the relation\n                                  J  (x) = (-1)^n J  (x) for negative n \n\t\t\t\t    -n              n    */\n\n\td_n = (double) nn;\n\t\n\t/* Calculate the common factor (x/2)^n/n! so it only has to be\n           done once. */\n\n\tfor(j=1;j<=nn;j++){\n\t\td_j = (double)j;\n\t\tcfact *= x/(2.0*d_j);\n\t}\n\n\t/* j = 0 term: */\n\tdsum = dterm = cfact;\n\n\tj = 1;\n\n\tdo {\n\t\td_j = (double)j;\n\t\ts_j = j%2 ? -1.0: 1.0;\n\t\tdterm *= x*x/(d_j*4.0*(d_n + d_j));\n\t\tdsum += s_j*dterm;\n\t\tj++;\n\t} while( dterm > DBL_EPSILON );\n\t\t\n\ts_j = nn%2 ? -1.0 : 1.0;\n\treturn  n >= 0 ? dsum : s_j*dsum;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O3.pseudo", "function_name": "J", "address": "0x1b80", "label": "J", "content": "double __fastcall J(int n, double a2, double x)\n{\n  int v3; // ecx\n  int v4; // eax\n  double v5; // xmm1_8\n  double v6; // xmm2_8\n  double v7; // xmm0_8\n  double v8; // xmm3_8\n  int v9; // eax\n  double v10; // xmm0_8\n\n  v3 = -n;\n  if ( n > 0 )\n    v3 = n;\n  if ( n )\n  {\n    v4 = 1;\n    v5 = 1.0;\n    do\n    {\n      v6 = (double)v4++;\n      v5 = v5 * (a2 / (v6 + v6));\n    }\n    while ( v3 + 1 != v4 );\n  }\n  else\n  {\n    v5 = 1.0;\n  }\n  v7 = a2 * a2;\n  v8 = v5;\n  v9 = 1;\n  do\n  {\n    while ( 1 )\n    {\n      v5 = v5 * (v7 / ((double)v9 * 4.0 * ((double)v3 + (double)v9)));\n      if ( (v9 & 1) == 0 )\n        break;\n      ++v9;\n      v8 = v8 - v5;\n      if ( v5 <= 2.220446049250313e-16 )\n        goto LABEL_9;\n    }\n    ++v9;\n    v8 = v8 + v5;\n  }\n  while ( v5 > 2.220446049250313e-16 );\nLABEL_9:\n  v10 = -1.0;\n  if ( (v3 & 1) == 0 )\n    v10 = 1.0;\n  if ( n < 0 )\n    return v8 * v10;\n  return v8;\n}\n"}, "pseudo_normalize": "double J(int n, double a2, double x) {\n  int v3;\n  int v4;\n  double v5;\n  double v6;\n  double v7;\n  double v8;\n  int v9;\n  double v10;\n  v3 = -n;\n  if (n > 0) v3 = n;\n  if (n) {\n    v4 = 1;\n    v5 = 1.0;\n    do {\n      v6 = (double)v4++;\n      v5 = v5 * (a2 / (v6 + v6));\n    } while (v3 + 1 != v4);\n  } else {\n    v5 = 1.0;\n  }\n  v7 = a2 * a2;\n  v8 = v5;\n  v9 = 1;\n  do {\n    while (1) {\n      v5 = v5 * (v7 / ((double)v9 * 4.0 * ((double)v3 + (double)v9)));\n      if ((v9 & 1) == 0) break;\n      ++v9;\n      v8 = v8 - v5;\n      if (v5 <= 2.220446049250313e-16) goto LABEL_9;\n    }\n    ++v9;\n    v8 = v8 + v5;\n  } while (v5 > 2.220446049250313e-16);\nLABEL_9:\n  v10 = -1.0;\n  if ((v3 & 1) == 0) v10 = 1.0;\n  if (n < 0) return v8 * v10;\n  return v8;\n}", "binary": "kepler/kepler.host.O3", "assembly": "<J>:\nendbr64\nmov    %edi,%ecx\npxor   %xmm6,%xmm6\nneg    %ecx\ncmovs  %edi,%ecx\ncvtsi2sd %ecx,%xmm6\ntest   %edi,%edi\nje     1c60 <J+0xe0>\nmovsd  0x6714(%rip),%xmm8\nlea    0x1(%rcx),%edx\nmov    $0x1,%eax\nmovapd %xmm8,%xmm1\nnopl   0x0(%rax)\npxor   %xmm2,%xmm2\nmovapd %xmm0,%xmm3\ncvtsi2sd %eax,%xmm2\nadd    $0x1,%eax\naddsd  %xmm2,%xmm2\ndivsd  %xmm2,%xmm3\nmulsd  %xmm3,%xmm1\ncmp    %eax,%edx\njne    1bb8 <J+0x38>\nmulsd  %xmm0,%xmm0\nmovsd  0x66fd(%rip),%xmm7\nmovapd %xmm1,%xmm3\nmovsd  0x66f9(%rip),%xmm5\nmov    $0x1,%eax\nnopl   0x0(%rax)\npxor   %xmm2,%xmm2\nmovapd %xmm6,%xmm4\ncvtsi2sd %eax,%xmm2\naddsd  %xmm2,%xmm4\nmulsd  %xmm7,%xmm2\nmulsd  %xmm4,%xmm2\nmovapd %xmm0,%xmm4\ndivsd  %xmm2,%xmm4\nmulsd  %xmm4,%xmm1\ntest   $0x1,%al\nje     1c50 <J+0xd0>\nadd    $0x1,%eax\ncomisd %xmm5,%xmm1\nsubsd  %xmm1,%xmm3\nja     1bf8 <J+0x78>\nand    $0x1,%ecx\nmovsd  0x6698(%rip),%xmm0\njne    1c3f <J+0xbf>\nmovapd %xmm8,%xmm0\ntest   %edi,%edi\njns    1c47 <J+0xc7>\nmulsd  %xmm0,%xmm3\nmovapd %xmm3,%xmm0\nret\nnopl   0x0(%rax)\nadd    $0x1,%eax\ncomisd %xmm5,%xmm1\naddsd  %xmm1,%xmm3\nja     1bf8 <J+0x78>\njmp    1c2d <J+0xad>\nnop\nmovsd  0x664f(%rip),%xmm8\nmovapd %xmm8,%xmm1\njmp    1bd7 <J+0x57>\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "bin_fact", "content": "#endif /* NO_MAIN */\n\n/* The bin_fact routine calculates C(n,k)(n-2k)^(n-1)/n!2^(n-1). This\n   routine assumes 2k <  n, and tries to keep the intermediate products\n   small to prevent overflow.  */\n\ndouble \nbin_fact(int n, int k)\n{\n\t\tint j;\n\t\tdouble cum_prod = 1.0;\n\t\tdouble num_fact,den_fact,dj,dk,x;\n\n\t\tx = ((double) n)/2.0 - (double)k;\n\n\t\tfor(j=n-k;j>1;j--){\n\t\t\tdj = (double)j;\n\t\t\tdk = (double) n -(double)k - dj + 1.0;\n\t\t\tden_fact = n - k - j + 1 <= k ? dk*dj : dj;  \n\t\t\tnum_fact = n - k - j + 1 <= k ? x*x : x; \n\t\t\tcum_prod *= (num_fact/den_fact);\n\t\t}\n\t\treturn cum_prod;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O3.pseudo", "function_name": "bin_fact", "address": "0x1ad0", "label": "bin_fact", "content": "double __fastcall bin_fact(int n, int k)\n{\n  double v2; // xmm4_8\n  int v3; // edi\n  double v4; // xmm3_8\n  double v5; // xmm4_8\n  int v6; // eax\n  double v7; // xmm2_8\n  double v8; // xmm0_8\n\n  v2 = (double)n;\n  v3 = n - k;\n  v4 = 0.5 * v2 - (double)k;\n  if ( v3 <= 1 )\n    return 1.0;\n  v5 = v2 - (double)k;\n  v6 = v3;\n  v7 = 1.0;\n  do\n  {\n    while ( 1 )\n    {\n      v8 = (double)v6;\n      if ( k <= v3 - v6 )\n        break;\n      --v6;\n      v7 = v7 * (v4 * v4 / ((v5 - v8 + 1.0) * v8));\n      if ( v6 == 1 )\n        return v7;\n    }\n    --v6;\n    v7 = v7 * (v4 / v8);\n  }\n  while ( v6 != 1 );\n  return v7;\n}\n"}, "pseudo_normalize": "double bin_fact(int n, int k) {\n  double v2;\n  int v3;\n  double v4;\n  double v5;\n  int v6;\n  double v7;\n  double v8;\n  v2 = (double)n;\n  v3 = n - k;\n  v4 = 0.5 * v2 - (double)k;\n  if (v3 <= 1) return 1.0;\n  v5 = v2 - (double)k;\n  v6 = v3;\n  v7 = 1.0;\n  do {\n    while (1) {\n      v8 = (double)v6;\n      if (k <= v3 - v6) break;\n      --v6;\n      v7 = v7 * (v4 * v4 / ((v5 - v8 + 1.0) * v8));\n      if (v6 == 1) return v7;\n    }\n    --v6;\n    v7 = v7 * (v4 / v8);\n  } while (v6 != 1);\n  return v7;\n}", "binary": "kepler/kepler.host.O3", "assembly": "<bin_fact>:\nendbr64\npxor   %xmm4,%xmm4\nmovsd  0x67e8(%rip),%xmm3\npxor   %xmm0,%xmm0\ncvtsi2sd %edi,%xmm4\nsub    %esi,%edi\ncvtsi2sd %esi,%xmm0\nmulsd  %xmm4,%xmm3\nsubsd  %xmm0,%xmm3\ncmp    $0x1,%edi\njle    1b70 <bin_fact+0xa0>\nmovsd  0x67b5(%rip),%xmm5\nsubsd  %xmm0,%xmm4\nmov    %edi,%eax\nmovapd %xmm5,%xmm2\nnopl   (%rax)\nmov    %edi,%edx\npxor   %xmm0,%xmm0\nsub    %eax,%edx\ncvtsi2sd %eax,%xmm0\ncmp    %edx,%esi\njle    1b50 <bin_fact+0x80>\nmovapd %xmm4,%xmm1\nsub    $0x1,%eax\nsubsd  %xmm0,%xmm1\naddsd  %xmm5,%xmm1\nmulsd  %xmm0,%xmm1\nmovapd %xmm3,%xmm0\nmulsd  %xmm3,%xmm0\ndivsd  %xmm1,%xmm0\nmulsd  %xmm0,%xmm2\ncmp    $0x1,%eax\njne    1b10 <bin_fact+0x40>\nmovapd %xmm2,%xmm0\nret\nnopl   (%rax)\nmovapd %xmm3,%xmm1\nsub    $0x1,%eax\ndivsd  %xmm0,%xmm1\nmulsd  %xmm1,%xmm2\ncmp    $0x1,%eax\njne    1b10 <bin_fact+0x40>\nmovapd %xmm2,%xmm0\nret\nnopl   0x0(%rax)\nmovsd  0x6740(%rip),%xmm2\nmovapd %xmm2,%xmm0\nret\nnopl   (%rax)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "binary", "content": "/* The following routine implements the binary search algorithm due\n   to Roger Sinnott, Sky and Telescope, Vol 70, page 159 (August 1985.)\n   It is not the fastest algorithm, but it is completely reliable. \n*/\n\ndouble binary(double E, double e, double M, int reset)\n{\n\tstatic double scale = .7853981633975;   /* PI/4 */\n\tdouble R;\n\tdouble X;\n\n\tif(reset) {\n\t\tscale = PI/4.0;\n\t\treturn 0.0;\n\t}\n\n\tR = E - e*libmin_sin(E);\n\tX = M > R ? E + scale : E - scale;\n\tscale = scale/2.0;\n\treturn X;\n\t\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O3.pseudo", "function_name": "binary", "address": "0x16a0", "label": "binary", "content": "double __fastcall binary(double a1, double E, double e, double M, int reset)\n{\n  double result; // xmm0_8\n  double v7; // xmm3_8\n\n  if ( reset )\n  {\n    result = 0.0;\n    scale_2 = 0x3FE921FB54442EEALL;\n  }\n  else\n  {\n    if ( e <= a1 - E * libmin_sin(E) )\n      v7 = a1 - *(double *)&scale_2;\n    else\n      v7 = a1 + *(double *)&scale_2;\n    result = v7;\n    *(double *)&scale_2 = *(double *)&scale_2 * 0.5;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "double binary(double a1, double E, double e, double M, int reset) {\n  double result;\n  double v7;\n  if (reset) {\n    result = 0.0;\n    scale_2 = 4605249457297305322LL;\n  } else {\n    if (e <= a1 - E * libmin_sin(E))\n      v7 = a1 - *(double *)&scale_2;\n    else\n      v7 = a1 + *(double *)&scale_2;\n    result = v7;\n    *(double *)&scale_2 = *(double *)&scale_2 * 0.5;\n  }\n  return result;\n}", "binary": "kepler/kepler.host.O3", "assembly": "<binary>:\nendbr64\nsub    $0x28,%rsp\nmovsd  %xmm1,0x10(%rsp)\nmovsd  %xmm2,0x8(%rsp)\ntest   %edi,%edi\nje     16d8 <binary+0x38>\nmovsd  0x6c00(%rip),%xmm1\npxor   %xmm0,%xmm0\nmovsd  %xmm1,0x9944(%rip)\nadd    $0x28,%rsp\nret\nnopl   0x0(%rax)\nmovsd  %xmm0,0x18(%rsp)\ncall   5480 <libmin_sin>\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x18(%rsp),%xmm3\nmovsd  0x8(%rsp),%xmm2\nmulsd  %xmm0,%xmm1\nmovapd %xmm3,%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  0x9907(%rip),%xmm1\ncomisd %xmm0,%xmm2\njbe    1730 <binary+0x90>\naddsd  %xmm1,%xmm3\nmovapd %xmm3,%xmm0\nmulsd  0x6ba9(%rip),%xmm1\nmovsd  %xmm1,0x98e9(%rip)\nadd    $0x28,%rsp\nret\nnopl   0x0(%rax)\nsubsd  %xmm1,%xmm3\nmovapd %xmm3,%xmm0\njmp    1717 <binary+0x77>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "e_series", "content": "/* The following infinite series expansion for E in powers of e is known:\n\n                 __\n\t        \\       n\n\tE = M +      A e\n\t\t/__   n\n\t\tn=1\n\nwhere              __ \n       \t     n-1  \\          k            (n-1)\nA =      (1/2 n!)        (-1) C(n,k)(n-2k)   sin((n-2k)M),\n n                /__\n                 0<= k <= [n/2]\n\nwhich converges for e < LAPLACE_LIMIT (defined above). This is based upon\nthe Laplace inversion formula -- see the discussion of Burmann's theorem\nand following material in Whittaker and Watson.\n\nThe bin_fact helper routine calculates C(n,k)(n-2k)^(n-1)/n!2^(n-1) */\n\n\ndouble e_series(double E, double e, double M, int reset)\n{\n\tstatic int n;\n\tint k;\n\tdouble n_2k,a_n=0.0,s_k;\n\n\tif(reset){\n\t\tn = 0;\n\t\treturn 0.0;\n\t}\n\n\tif(n==0){\n\t\tn++;\n\t\treturn M;\n\t}\n\n\n\tfor(k=0;2*k<=n;k++){\n\t\tn_2k = (double)n - 2.0 * ((double)k);\n\t\ts_k = k%2 ? -1.0 : 1.0;   /*   (-1)^k */\n\t\ta_n += s_k*bin_fact(n,k)*libmin_sin(n_2k*M);\n\t}\n\tn++;\n\treturn E + libmin_pow(e,n-1)*a_n;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O3.pseudo", "function_name": "e_series", "address": "0x1740", "label": "e_series", "content": "double __fastcall e_series(double a1, double E, double e, double M, int reset)\n{\n  int v5; // ecx\n  double v6; // xmm1_8\n  double v7; // xmm5_8\n  int v8; // ebx\n  double v9; // xmm1_8\n  double v10; // xmm7_8\n  int v11; // ecx\n  double v12; // xmm4_8\n  double v13; // xmm5_8\n  int v14; // eax\n  double v15; // xmm3_8\n  double v16; // xmm0_8\n  double v18; // [rsp+0h] [rbp-38h]\n\n  if ( reset )\n  {\n    n_1 = 0;\n    return 0.0;\n  }\n  else\n  {\n    v5 = n_1;\n    if ( n_1 )\n    {\n      v6 = (double)n_1;\n      v7 = (double)n_1;\n      if ( n_1 < 0 )\n      {\n        v18 = 0.0;\n      }\n      else\n      {\n        v8 = 0;\n        v18 = 0.0;\n        v9 = 0.0;\nLABEL_5:\n        v10 = 1.0;\n        while ( 1 )\n        {\n          v11 = v5 - v8;\n          v12 = 0.5 * v7 - v9;\n          if ( v11 > 1 )\n          {\n            v13 = v7 - v9;\n            v14 = v11;\n            v15 = 1.0;\n            do\n            {\n              while ( 1 )\n              {\n                v9 = (double)v14;\n                if ( v8 <= v11 - v14 )\n                  break;\n                --v14;\n                e = (v13 - v9 + 1.0) * v9;\n                v9 = v12 * v12 / e;\n                v15 = v15 * v9;\n                if ( v14 == 1 )\n                  goto LABEL_10;\n              }\n              --v14;\n              e = v12 / v9;\n              v15 = v15 * (v12 / v9);\n            }\n            while ( v14 != 1 );\nLABEL_10:\n            v10 = v10 * v15;\n          }\n          ++v8;\n          v16 = libmin_sin(v9);\n          v5 = n_1;\n          v18 = v16 * v10 + v18;\n          if ( n_1 < 2 * v8 )\n            break;\n          v10 = -1.0;\n          v9 = (double)v8;\n          v7 = (double)n_1;\n          e = v9 + v9;\n          if ( (v8 & 1) == 0 )\n            goto LABEL_5;\n        }\n        v6 = (double)n_1;\n      }\n      n_1 = v5 + 1;\n      return libmin_pow(v6, e) * v18 + a1;\n    }\n    else\n    {\n      n_1 = 1;\n      return e;\n    }\n  }\n}\n"}, "pseudo_normalize": "double e_series(double a1, double E, double e, double M, int reset) {\n  int v5;\n  double v6;\n  double v7;\n  int v8;\n  double v9;\n  double v10;\n  int v11;\n  double v12;\n  double v13;\n  int v14;\n  double v15;\n  double v16;\n  double v18;\n  if (reset) {\n    n_1 = 0;\n    return 0.0;\n  } else {\n    v5 = n_1;\n    if (n_1) {\n      v6 = (double)n_1;\n      v7 = (double)n_1;\n      if (n_1 < 0) {\n        v18 = 0.0;\n      } else {\n        v8 = 0;\n        v18 = 0.0;\n        v9 = 0.0;\n      LABEL_5:\n        v10 = 1.0;\n        while (1) {\n          v11 = v5 - v8;\n          v12 = 0.5 * v7 - v9;\n          if (v11 > 1) {\n            v13 = v7 - v9;\n            v14 = v11;\n            v15 = 1.0;\n            do {\n              while (1) {\n                v9 = (double)v14;\n                if (v8 <= v11 - v14) break;\n                --v14;\n                e = (v13 - v9 + 1.0) * v9;\n                v9 = v12 * v12 / e;\n                v15 = v15 * v9;\n                if (v14 == 1) goto LABEL_10;\n              }\n              --v14;\n              e = v12 / v9;\n              v15 = v15 * (v12 / v9);\n            } while (v14 != 1);\n          LABEL_10:\n            v10 = v10 * v15;\n          }\n          ++v8;\n          v16 = libmin_sin(v9);\n          v5 = n_1;\n          v18 = v16 * v10 + v18;\n          if (n_1 < 2 * v8) break;\n          v10 = -1.0;\n          v9 = (double)v8;\n          v7 = (double)n_1;\n          e = v9 + v9;\n          if ((v8 & 1) == 0) goto LABEL_5;\n        }\n        v6 = (double)n_1;\n      }\n      n_1 = v5 + 1;\n      return libmin_pow(v6, e) * v18 + a1;\n    } else {\n      n_1 = 1;\n      return e;\n    }\n  }\n}", "binary": "kepler/kepler.host.O3", "assembly": "<e_series>:\nendbr64\npush   %r14\npush   %rbx\nsub    $0x28,%rsp\nmovsd  %xmm0,0x18(%rsp)\nmovsd  %xmm2,0x10(%rsp)\ntest   %edi,%edi\njne    18f0 <e_series+0x1b0>\nmov    0x9b6b(%rip),%ecx\ntest   %ecx,%ecx\nje     187f <e_series+0x13f>\nmovq   %xmm1,%r14\npxor   %xmm1,%xmm1\ncvtsi2sd %ecx,%xmm1\nmovapd %xmm1,%xmm5\njs     1906 <e_series+0x1c6>\npxor   %xmm6,%xmm6\nmovapd %xmm1,%xmm0\nmov    %edi,%ebx\nmovsd  %xmm6,(%rsp)\nmovapd %xmm6,%xmm1\nmovsd  0x6b19(%rip),%xmm6\nmovapd %xmm6,%xmm7\nmovsd  0x6b1d(%rip),%xmm4\nsub    %ebx,%ecx\nmulsd  %xmm5,%xmm4\nsubsd  %xmm1,%xmm4\ncmp    $0x1,%ecx\njle    1808 <e_series+0xc8>\nsubsd  %xmm1,%xmm5\nmov    %ecx,%eax\nmovapd %xmm6,%xmm3\nnopl   0x0(%rax)\nmov    %ecx,%edx\npxor   %xmm1,%xmm1\nsub    %eax,%edx\ncvtsi2sd %eax,%xmm1\ncmp    %edx,%ebx\njle    1898 <e_series+0x158>\nmovapd %xmm5,%xmm2\nsub    $0x1,%eax\nsubsd  %xmm1,%xmm2\naddsd  %xmm6,%xmm2\nmulsd  %xmm1,%xmm2\nmovapd %xmm4,%xmm1\nmulsd  %xmm4,%xmm1\ndivsd  %xmm2,%xmm1\nmulsd  %xmm1,%xmm3\ncmp    $0x1,%eax\njne    17c8 <e_series+0x88>\nmulsd  %xmm3,%xmm7\nmulsd  0x10(%rsp),%xmm0\nmovsd  %xmm7,0x8(%rsp)\nadd    $0x1,%ebx\ncall   5480 <libmin_sin>\nmovsd  0x8(%rsp),%xmm7\nmov    0x9aa8(%rip),%ecx\nlea    (%rbx,%rbx,1),%eax\nmulsd  %xmm7,%xmm0\ncmp    %eax,%ecx\nmov    0x6a80(%rip),%rax\naddsd  (%rsp),%xmm0\nmovq   %rax,%xmm6\nmovsd  %xmm0,(%rsp)\njl     18b8 <e_series+0x178>\npxor   %xmm1,%xmm1\npxor   %xmm5,%xmm5\nmovsd  0x6a77(%rip),%xmm7\ncvtsi2sd %ebx,%xmm1\ncvtsi2sd %ecx,%xmm5\nmovapd %xmm1,%xmm2\naddsd  %xmm1,%xmm2\nmovapd %xmm5,%xmm0\nsubsd  %xmm2,%xmm0\ntest   $0x1,%bl\njne    17a3 <e_series+0x63>\njmp    179f <e_series+0x5f>\nmovl   $0x1,0x9a47(%rip)\nadd    $0x28,%rsp\nmovapd %xmm2,%xmm0\npop    %rbx\npop    %r14\nret\nnopl   (%rax)\nmovapd %xmm4,%xmm2\nsub    $0x1,%eax\ndivsd  %xmm1,%xmm2\nmulsd  %xmm2,%xmm3\ncmp    $0x1,%eax\njne    17c8 <e_series+0x88>\njmp    1804 <e_series+0xc4>\nnopl   (%rax)\npxor   %xmm1,%xmm1\ncvtsi2sd %ecx,%xmm1\nadd    $0x1,%ecx\nmovq   %r14,%xmm0\nmov    %ecx,0x9a02(%rip)\ncall   23b0 <libmin_pow>\nmulsd  (%rsp),%xmm0\naddsd  0x18(%rsp),%xmm0\nadd    $0x28,%rsp\npop    %rbx\npop    %r14\nret\ncs nopw 0x0(%rax,%rax,1)\nmovl   $0x0,0x99d6(%rip)\nadd    $0x28,%rsp\npxor   %xmm0,%xmm0\npop    %rbx\npop    %r14\nret\npxor   %xmm6,%xmm6\nmovsd  %xmm6,(%rsp)\njmp    18c0 <e_series+0x180>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "j_series", "content": "\t\n/* The eccentric anomaly is an odd periodic function in the Mean Anomoly\n   and so can be developed in a Fourier sine series. This turns out to\n   be \n                 __\n\t        \\  \n\tE = M +      (2/n)J (ne)sin(nM)\n\t\t/__        n \n\t\tn=1\n\n  where J_n is the Bessel function of the first kind. See, e.g, A Mathematical\n  Introdution to Celestial Mechanics, Harry Pollard, Prentice Hall, 1966,\n  pp 22-23. The following routine is used to sum this series.\n*/\n\n\ndouble j_series(double E, double e, double M, int reset)\n{\n\tstatic int n;\n\tdouble dn, term;\n\n\tif(reset){\n\t\tn = 0;\n\t\treturn 0.0;\n\t}\n\n\tif(n==0){\n\t\tn++;\n\t\treturn M;\n\t}\n\tdn = (double)n;\n\tterm = (2.0/(double)n)*J(n,dn*e)*libmin_sin(dn*M);\n\tn++;\n\treturn E + term;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O3.pseudo", "function_name": "j_series", "address": "0x1920", "label": "j_series", "content": "double __fastcall j_series(double a1, double E, double e, double M, int reset)\n{\n  double result; // xmm0_8\n  double v7; // xmm0_8\n  int v8; // esi\n  double v9; // xmm3_8\n  int v10; // eax\n  double v11; // xmm1_8\n  double v12; // xmm4_8\n  double v13; // xmm1_8\n  double v14; // xmm5_8\n  int v15; // eax\n  double v16; // xmm1_8\n  double v17; // xmm0_8\n  double v18; // [rsp+0h] [rbp-18h]\n\n  if ( reset )\n  {\n    result = 0.0;\n    n_0 = 0;\n    return result;\n  }\n  if ( !n_0 )\n  {\n    result = e;\n    n_0 = 1;\n    return result;\n  }\n  v7 = (double)n_0;\n  v8 = -n_0;\n  if ( n_0 > 0 )\n    v8 = n_0;\n  v9 = 1.0;\n  v10 = 1;\n  v11 = E * v7;\n  do\n  {\n    v12 = (double)v10++;\n    v9 = v9 * (v11 / (v12 + v12));\n  }\n  while ( v10 != v8 + 1 );\n  v13 = v11 * v11;\n  v14 = v9;\n  v15 = 1;\n  do\n  {\n    while ( 1 )\n    {\n      v9 = v9 * (v13 / ((double)v15 * 4.0 * ((double)v8 + (double)v15)));\n      if ( (v15 & 1) != 0 )\n        break;\n      ++v15;\n      v14 = v14 + v9;\n      if ( v9 <= 2.220446049250313e-16 )\n      {\n        v16 = -1.0;\n        if ( (v8 & 1) == 0 )\n          goto LABEL_18;\nLABEL_12:\n        if ( n_0 >= 0 )\n          goto LABEL_13;\n        goto LABEL_19;\n      }\n    }\n    ++v15;\n    v14 = v14 - v9;\n  }\n  while ( v9 > 2.220446049250313e-16 );\n  v16 = -1.0;\n  if ( (v8 & 1) != 0 )\n    goto LABEL_12;\nLABEL_18:\n  v16 = 1.0;\n  if ( n_0 >= 0 )\n    goto LABEL_13;\nLABEL_19:\n  v14 = v14 * v16;\nLABEL_13:\n  v18 = 2.0 / v7 * v14;\n  v17 = libmin_sin(v16);\n  ++n_0;\n  return v17 * v18 + a1;\n}\n"}, "pseudo_normalize": "double j_series(double a1, double E, double e, double M, int reset) {\n  double result;\n  double v7;\n  int v8;\n  double v9;\n  int v10;\n  double v11;\n  double v12;\n  double v13;\n  double v14;\n  int v15;\n  double v16;\n  double v17;\n  double v18;\n  if (reset) {\n    result = 0.0;\n    n_0 = 0;\n    return result;\n  }\n  if (!n_0) {\n    result = e;\n    n_0 = 1;\n    return result;\n  }\n  v7 = (double)n_0;\n  v8 = -n_0;\n  if (n_0 > 0) v8 = n_0;\n  v9 = 1.0;\n  v10 = 1;\n  v11 = E * v7;\n  do {\n    v12 = (double)v10++;\n    v9 = v9 * (v11 / (v12 + v12));\n  } while (v10 != v8 + 1);\n  v13 = v11 * v11;\n  v14 = v9;\n  v15 = 1;\n  do {\n    while (1) {\n      v9 = v9 * (v13 / ((double)v15 * 4.0 * ((double)v8 + (double)v15)));\n      if ((v15 & 1) != 0) break;\n      ++v15;\n      v14 = v14 + v9;\n      if (v9 <= 2.220446049250313e-16) {\n        v16 = -1.0;\n        if ((v8 & 1) == 0) goto LABEL_18;\n      LABEL_12:\n        if (n_0 >= 0) goto LABEL_13;\n        goto LABEL_19;\n      }\n    }\n    ++v15;\n    v14 = v14 - v9;\n  } while (v9 > 2.220446049250313e-16);\n  v16 = -1.0;\n  if ((v8 & 1) != 0) goto LABEL_12;\nLABEL_18:\n  v16 = 1.0;\n  if (n_0 >= 0) goto LABEL_13;\nLABEL_19:\n  v14 = v14 * v16;\nLABEL_13:\n  v18 = 2.0 / v7 * v14;\n  v17 = libmin_sin(v16);\n  ++n_0;\n  return v17 * v18 + a1;\n}", "binary": "kepler/kepler.host.O3", "assembly": "<j_series>:\nendbr64\ntest   %edi,%edi\njne    1a98 <j_series+0x178>\nmov    0x999a(%rip),%edx\ntest   %edx,%edx\njne    1950 <j_series+0x30>\nmov    $0x1,%eax\nmovapd %xmm2,%xmm0\nmov    %eax,0x9987(%rip)\nret\ncs nopw 0x0(%rax,%rax,1)\nmovapd %xmm0,%xmm6\npxor   %xmm0,%xmm0\nsub    $0x18,%rsp\nmov    %edx,%esi\ncvtsi2sd %edx,%xmm0\nneg    %esi\nmovsd  0x696b(%rip),%xmm8\npxor   %xmm9,%xmm9\ncmovs  %edx,%esi\nmov    0x693c(%rip),%rax\ncvtsi2sd %esi,%xmm9\nmovq   %rax,%xmm3\nlea    0x1(%rsi),%ecx\nmov    $0x1,%eax\ndivsd  %xmm0,%xmm8\nmulsd  %xmm0,%xmm1\nnopw   0x0(%rax,%rax,1)\npxor   %xmm4,%xmm4\nmovapd %xmm1,%xmm5\ncvtsi2sd %eax,%xmm4\nadd    $0x1,%eax\naddsd  %xmm4,%xmm4\ndivsd  %xmm4,%xmm5\nmulsd  %xmm5,%xmm3\ncmp    %ecx,%eax\njne    19a0 <j_series+0x80>\nmulsd  %xmm1,%xmm1\nmovapd %xmm3,%xmm5\nmov    $0x1,%eax\nmovsd  0x690b(%rip),%xmm11\nmovsd  0x690a(%rip),%xmm10\nxchg   %ax,%ax\npxor   %xmm4,%xmm4\nmovapd %xmm9,%xmm7\ncvtsi2sd %eax,%xmm4\naddsd  %xmm4,%xmm7\nmulsd  %xmm11,%xmm4\nmulsd  %xmm7,%xmm4\nmovapd %xmm1,%xmm7\ndivsd  %xmm4,%xmm7\nmulsd  %xmm7,%xmm3\ntest   $0x1,%al\njne    1a70 <j_series+0x150>\nadd    $0x1,%eax\ncomisd %xmm10,%xmm3\naddsd  %xmm3,%xmm5\nja     19e0 <j_series+0xc0>\nand    $0x1,%esi\nmovsd  0x68ad(%rip),%xmm1\nje     1aa8 <j_series+0x188>\ntest   %edx,%edx\njs     1abc <j_series+0x19c>\nmulsd  %xmm5,%xmm8\nmovsd  %xmm6,0x8(%rsp)\nmulsd  %xmm2,%xmm0\nmovsd  %xmm8,(%rsp)\ncall   5480 <libmin_sin>\nmulsd  (%rsp),%xmm0\nmov    0x9876(%rip),%eax\nmovsd  0x8(%rsp),%xmm6\nadd    $0x1,%eax\nmov    %eax,0x9867(%rip)\nadd    $0x18,%rsp\naddsd  %xmm6,%xmm0\nret\nxchg   %ax,%ax\nadd    $0x1,%eax\ncomisd %xmm10,%xmm3\nsubsd  %xmm3,%xmm5\nja     19e0 <j_series+0xc0>\nand    $0x1,%esi\nmovsd  0x6843(%rip),%xmm1\njne    1a29 <j_series+0x109>\njmp    1aa8 <j_series+0x188>\nnopl   0x0(%rax)\nxor    %eax,%eax\npxor   %xmm0,%xmm0\nmov    %eax,0x9828(%rip)\nret\nnopl   (%rax)\nmov    0x6809(%rip),%rax\nmovq   %rax,%xmm1\ntest   %edx,%edx\njns    1a31 <j_series+0x111>\nmulsd  %xmm1,%xmm5\njmp    1a31 <j_series+0x111>\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "kepler", "content": "int\nkepler(double *E, double M, double e, double my_derror, int m)\n{\n\tint count = 0;\n\tdouble sign = 1.0;\n\tdouble  E_old=PI/2;\n\tdouble (*method)(double,double, double,int);\n\t\n\tif((m<0) || (m>=NMETHODS))return -1;\n\n\tmethod = (double(*)(double,double,double,int))methods[m];\n\n\tif((m==3)&&(e > LAPLACE_LIMIT))\n\t\treturn -1;\n\n\tif((e<0)||(e>=1.0))\n\t\treturn -1;\n\n\t/* Normalize M to lie between 0 and PI */\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M)/(2*PI);\n\tM = (M - libmin_floor(M))*2*PI*sign;\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M);\n\tif(M > PI){\n\t\tM = 2*PI - M;\n\t\tsign = -1.0;\n\t}\n\t\n\t/* Do selected calculation, and quit when accuracy is bettered. */\n\twhile(libmin_fabs(E_old - (*E = method(E_old,e,M,0))) >= my_derror){\n\t\tE_old = *E;\n\t\tcount++;\n\t}\n\t*E = sign*(*E);\n\tmethod(0.0,0.0,0.0,1);  /* reset */\n\n\treturn count;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O3.pseudo", "function_name": "kepler", "address": "0x1c80", "label": "kepler", "content": "__int64 __fastcall kepler(double *E, double a2, double M, double e, double my_derror, unsigned int m)\n{\n  double (__fastcall *v6)(double, double, double, double, int); // rbp\n  double v7; // xmm2_8\n  double v8; // xmm1_8\n  double v9; // r14\n  double v10; // xmm0_8\n  double v11; // xmm2_8\n  double v12; // xmm3_8\n  unsigned int i; // r12d\n  double v14; // xmm0_8\n  double v15; // xmm3_8\n  double E_old; // [rsp+0h] [rbp-48h]\n\n  if ( m > 4 )\n    return (unsigned int)-1;\n  v6 = (double (__fastcall *)(double, double, double, double, int))methods[m];\n  if ( m == 3 && M > 0.6627434193 )\n    return (unsigned int)-1;\n  if ( M < 0.0 || M >= 1.0 )\n  {\n    return (unsigned int)-1;\n  }\n  else\n  {\n    v7 = 1.0;\n    if ( a2 <= 0.0 )\n      v7 = -1.0;\n    E_old = libmin_fabs(M) / 6.28318530718;\n    v8 = E_old - libmin_floor(E_old);\n    v9 = 1.0;\n    if ( (v8 + v8) * 3.14159265359 * v7 <= 0.0 )\n      v9 = -1.0;\n    v10 = libmin_fabs(v8);\n    v11 = v10;\n    if ( v10 > 3.14159265359 )\n    {\n      v11 = 6.28318530718 - v10;\n      v9 = -1.0;\n    }\n    v12 = 1.570796326795;\n    for ( i = 0; ; ++i )\n    {\n      v14 = v6(v12, M, v11, v12, 0);\n      *E = v14;\n      v15 = v12 - v14;\n      if ( libmin_fabs(M) < e )\n        break;\n      v12 = *E;\n    }\n    *E = v9 * *E;\n    v6(0.0, 0.0, 0.0, v15, 1);\n  }\n  return i;\n}\n"}, "pseudo_normalize": "long long kepler(double *E, double a2, double M, double e, double my_derror,\n                 unsigned int m) {\n  double (*v6)(double, double, double, double, int);\n  double v7;\n  double v8;\n  double v9;\n  double v10;\n  double v11;\n  double v12;\n  unsigned int i;\n  double v14;\n  double v15;\n  double E_old;\n  if (m > 4) return (unsigned int)-1;\n  v6 = (double (*)(double, double, double, double, int))methods[m];\n  if (m == 3 && M > 0.6627434193) return (unsigned int)-1;\n  if (M < 0.0 || M >= 1.0) {\n    return (unsigned int)-1;\n  } else {\n    v7 = 1.0;\n    if (a2 <= 0.0) v7 = -1.0;\n    E_old = libmin_fabs(M) / 6.28318530718;\n    v8 = E_old - libmin_floor(E_old);\n    v9 = 1.0;\n    if ((v8 + v8) * 3.14159265359 * v7 <= 0.0) v9 = -1.0;\n    v10 = libmin_fabs(v8);\n    v11 = v10;\n    if (v10 > 3.14159265359) {\n      v11 = 6.28318530718 - v10;\n      v9 = -1.0;\n    }\n    v12 = 1.570796326795;\n    for (i = 0;; ++i) {\n      v14 = v6(v12, M, v11, v12, 0);\n      *E = v14;\n      v15 = v12 - v14;\n      if (libmin_fabs(M) < e) break;\n      v12 = *E;\n    }\n    *E = v9 * *E;\n    v6(0.0, 0.0, 0.0, v15, 1);\n  }\n  return i;\n}", "binary": "kepler/kepler.host.O3", "assembly": "<kepler>:\nendbr64\npush   %r14\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovsd  %xmm1,0x10(%rsp)\nmovsd  %xmm2,0x18(%rsp)\ncmp    $0x4,%esi\nja     1e3e <kepler+0x1be>\nmovslq %esi,%rdx\nlea    0x90b3(%rip),%rax\nmov    %rdi,%rbx\nmov    (%rax,%rdx,8),%rbp\ncmp    $0x3,%esi\nje     1e30 <kepler+0x1b0>\nmovsd  0x10(%rsp),%xmm5\npxor   %xmm6,%xmm6\ncomisd %xmm5,%xmm6\nja     1e3e <kepler+0x1be>\ncomisd 0x65df(%rip),%xmm5\njae    1e3e <kepler+0x1be>\ncomisd %xmm6,%xmm0\nmov    0x65ce(%rip),%rax\nmovq   %rax,%xmm2\nja     1cf9 <kepler+0x79>\nmovsd  0x65d7(%rip),%xmm2\nmovsd  %xmm2,0x8(%rsp)\ncall   22b0 <libmin_fabs>\nmovapd %xmm0,%xmm1\ndivsd  0x65f0(%rip),%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm1,(%rsp)\ncall   22f0 <libmin_floor>\nmovsd  (%rsp),%xmm1\npxor   %xmm7,%xmm7\nmovsd  0x8(%rsp),%xmm2\nmov    0x6584(%rip),%rax\nsubsd  %xmm0,%xmm1\nmov    %rax,%r14\nmovapd %xmm1,%xmm0\naddsd  %xmm1,%xmm0\nmulsd  0x65bd(%rip),%xmm0\nmulsd  %xmm2,%xmm0\ncomisd %xmm7,%xmm0\nja     1d62 <kepler+0xe2>\nmovsd  0x6573(%rip),%xmm7\nmovq   %xmm7,%r14\ncall   22b0 <libmin_fabs>\ncomisd 0x6599(%rip),%xmm0\nmovapd %xmm0,%xmm2\nja     1e08 <kepler+0x188>\nmovsd  0x656f(%rip),%xmm3\nxor    %r12d,%r12d\njmp    1d98 <kepler+0x118>\ncs nopw 0x0(%rax,%rax,1)\nmovsd  (%rbx),%xmm3\nadd    $0x1,%r12d\nxor    %edi,%edi\nmovsd  %xmm2,0x8(%rsp)\nmovsd  0x10(%rsp),%xmm1\nmovapd %xmm3,%xmm0\nmovsd  %xmm3,(%rsp)\ncall   *%rbp\nmovsd  (%rsp),%xmm3\nmovsd  %xmm0,(%rbx)\nsubsd  %xmm0,%xmm3\nmovapd %xmm3,%xmm0\ncall   22b0 <libmin_fabs>\ncomisd 0x18(%rsp),%xmm0\nmovsd  0x8(%rsp),%xmm2\njae    1d90 <kepler+0x110>\nmovq   %r14,%xmm0\npxor   %xmm2,%xmm2\nmov    $0x1,%edi\nmulsd  (%rbx),%xmm0\nmovapd %xmm2,%xmm1\nmovsd  %xmm0,(%rbx)\npxor   %xmm0,%xmm0\ncall   *%rbp\nadd    $0x28,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nmovsd  0x64f0(%rip),%xmm6\nsubsd  %xmm0,%xmm6\nmovapd %xmm6,%xmm2\nmovsd  0x64b0(%rip),%xmm6\nmovq   %xmm6,%r14\njmp    1d79 <kepler+0xf9>\nnopw   0x0(%rax,%rax,1)\ncomisd 0x64c0(%rip),%xmm1\njbe    1cbd <kepler+0x3d>\nmov    $0xffffffff,%r12d\njmp    1df5 <kepler+0x175>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tint n = 1,i=1;\n\tint m=1;\n\tdouble sign = 1.0;\n\tdouble M = 0.0, e = -0.1, E_old=PI/2 ,E;\n\tdouble (*method)(double,double, double,int);\n\n\n\t/* Process command line options */\n\n\twhile(argv[i][0] == '-'){\n\t\t  if(libmin_strcmp(argv[i],\"-h\")==0){\n\t\t\tlibmin_printf(\"%s\\n\", HELP);\n\t\t\tlibmin_success();\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-v\")==0){\n\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\tlibmin_success();\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-a\")==0){\n\t\t\tderror = libmin_atof(argv[i+1]);\n\t\t\tif(derror <= DBL_EPSILON)\n\t\t\t        libmin_printf(\"Warning: requested precision may exceed implementation limit.\\n\");\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-m\")==0){\n\t\t\tm = libmin_atoi(argv[i+1]);\n\t\t\tif((m<=0) || (m>NMETHODS)){\n\t\t\t\tlibmin_printf(\"Bad method number %d\\n\",m);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t  }\n\t\t  libmin_printf(\"kepler: Unknown option %s\\n\", argv[i]);\n\t\t  libmin_printf(\"%s\\n\",USAGE);\n\t\t  return 1;\n\t\t}\n\tif(i + 2 > argc){\n\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\treturn 1;\n\t}\n\tM = libmin_atof(argv[i++]);\n\te = libmin_atof(argv[i]);\n\tmethod = (double(*)(double,double,double,int))methods[m-1];\n\n\tif((m==4)&&(e > LAPLACE_LIMIT)){\n\t\tlibmin_printf(\"e cannot exceed %f for this method.\\n\",\n\t\t\t\tLAPLACE_LIMIT);\n\t\treturn 1;\n\t}\n\n\tif((e<0)||(e>=1.0)){\n\t\tlibmin_printf(\"Eccentricity %f out of range.\\n\",e);\n\t\treturn 1;\n\t}\n\n\t/* Normalize M to lie between 0 and PI */\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M)/(2*PI);\n\tM = (M - libmin_floor(M))*2*PI*sign;\n\tsign = 1.0;\n\tif(M > PI){\n\t\tM = 2*PI - M;\n\t\tsign = -1.0;\n\t}\n\t\n\t/* Do selected calculation, and quit when accuracy is bettered. */\n\twhile(libmin_fabs(E_old - (E = method(E_old,e,M,0))) >= derror){\n\t\tE_old = E;\n\t\tlibmin_printf(\"n = %d\\tE = %f\\n\",n++,sign*E);\n\t}\n\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  const char *v3; // rdi\n  char **v4; // rbx\n  int v5; // ebp\n  int v6; // r12d\n  __int64 v7; // rax\n  double v8; // xmm0_8\n  double v9; // xmm1_8\n  double (__usercall *v10)@<xmm0>(double@<xmm1>, double@<xmm2>, double@<xmm3>, int@<edi>); // rbx\n  double v11; // xmm2_8\n  double v12; // xmm0_8\n  double v13; // xmm0_8\n  double v14; // xmm3_8\n  int i; // ebp\n  int v16; // esi\n  double Ea; // [rsp+8h] [rbp-60h]\n  double Eb; // [rsp+8h] [rbp-60h]\n  double E; // [rsp+8h] [rbp-60h]\n  double e; // [rsp+18h] [rbp-50h]\n  double v22; // [rsp+20h] [rbp-48h]\n  double v23; // [rsp+28h] [rbp-40h]\n\n  v3 = ::argv[1];\n  if ( *::argv[1] == 45 )\n  {\n    v4 = ::argv;\n    v5 = 3;\n    v6 = 1;\n    do\n    {\n      if ( !libmin_strcmp(v3, \"-h\") )\n      {\n        libmin_printf(\n          (char *)\"%s\\n\",\n          \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n          \"-h: print this helpful message\\n\"\n          \"-v: print version number and exit\\n\"\n          \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n          \"-m: use selected calculation method k, where\\n\"\n          \"\\tk = 1: Simple iteration.\\n\"\n          \"\\tk = 2: Newton's method.\\n\"\n          \"\\tk = 3: Binary search.\\n\"\n          \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n          \"\\tk = 5: Fourier Bessel series.\\n\"\n          \"M = mean anomaly (radians)\\n\"\n          \"e = orbit eccentricty.\");\n        libmin_success();\n      }\n      if ( !libmin_strcmp(v4[1], \"-v\") )\n      {\n        libmin_printf((char *)\"%s\\n\", \"1.11\");\n        libmin_success();\n      }\n      if ( libmin_strcmp(v4[1], \"-a\") )\n      {\n        if ( libmin_strcmp(v4[1], \"-m\") )\n        {\n          libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[v5 - 2]);\n          goto LABEL_27;\n        }\n        v6 = libmin_atoi(v4[2]);\n        if ( (unsigned int)(v6 - 1) > 4 )\n        {\n          libmin_printf(\"Bad method number %d\\n\", v6);\n          return 1;\n        }\n      }\n      else\n      {\n        derror = libmin_atof(v4[2]);\n        if ( derror <= 2.220446049250313e-16 )\n          libmin_printf(\"Warning: requested precision may exceed implementation limit.\\n\");\n      }\n      v7 = v5;\n      v5 += 2;\n      v4 += 2;\n      v3 = ::argv[v7];\n    }\n    while ( *v3 == 45 );\n    if ( ::argc <= 4 )\n      goto LABEL_27;\n    Ea = libmin_atof(v3);\n    v8 = libmin_atof(::argv[4]);\n    v9 = Ea;\n    e = v8;\n    v10 = (double (__usercall *)@<xmm0>(double@<xmm1>, double@<xmm2>, double@<xmm3>, int@<edi>))methods[v6 - 1];\n    if ( v6 == 4 && v8 > 0.6627434193 )\n    {\n      libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n      return 1;\n    }\n  }\n  else\n  {\n    if ( ::argc <= 2 )\n    {\nLABEL_27:\n      libmin_printf((char *)\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n      return 1;\n    }\n    v10 = strict_iteration;\n    v9 = libmin_atof(::argv[1]);\n    e = libmin_atof(::argv[2]);\n  }\n  if ( e >= 0.0 && e < 1.0 )\n  {\n    v11 = 1.0;\n    if ( v9 <= 0.0 )\n      v11 = -1.0;\n    Eb = libmin_fabs(v9) / 6.28318530718;\n    v12 = libmin_floor(Eb);\n    v13 = (Eb - v12 + Eb - v12) * 3.14159265359 * v11;\n    v22 = v13;\n    if ( v13 <= 3.14159265359 )\n    {\n      v23 = 1.0;\n    }\n    else\n    {\n      v23 = -1.0;\n      v22 = 6.28318530718 - v13;\n    }\n    v14 = 1.570796326795;\n    for ( i = 1; ; ++i )\n    {\n      E = v10(e, v22, v14, 0);\n      if ( libmin_fabs(e) < derror )\n        break;\n      v16 = i;\n      libmin_printf(\"n = %d\\tE = %f\\n\", v16, E * v23);\n      v14 = E;\n    }\n    libmin_success();\n  }\n  libmin_printf(\"Eccentricity %f out of range.\\n\", e);\n  return 1;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  const char *v3;\n  char **v4;\n  int v5;\n  int v6;\n  long long v7;\n  double v8;\n  double v9;\n  double(__usercall * v10)\n      @<xmm0>(double @<xmm1>, double @<xmm2>, double @<xmm3>, int @<edi>);\n  double v11;\n  double v12;\n  double v13;\n  double v14;\n  int i;\n  int v16;\n  double Ea;\n  double Eb;\n  double E;\n  double e;\n  double v22;\n  double v23;\n  v3 = ::argv[1];\n  if (*::argv[1] == 45) {\n    v4 = ::argv;\n    v5 = 3;\n    v6 = 1;\n    do {\n      if (!libmin_strcmp(v3, \"-h\")) {\n        libmin_printf(\n            (char *)\"%s\\n\",\n            \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n            \"-h: print this helpful message\\n\"\n            \"-v: print version number and exit\\n\"\n            \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n            \"-m: use selected calculation method k, where\\n\"\n            \"\\tk = 1: Simple iteration.\\n\"\n            \"\\tk = 2: Newton's method.\\n\"\n            \"\\tk = 3: Binary search.\\n\"\n            \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n            \"\\tk = 5: Fourier Bessel series.\\n\"\n            \"M = mean anomaly (radians)\\n\"\n            \"e = orbit eccentricty.\");\n        libmin_success();\n      }\n      if (!libmin_strcmp(v4[1], \"-v\")) {\n        libmin_printf((char *)\"%s\\n\", \"1.11\");\n        libmin_success();\n      }\n      if (libmin_strcmp(v4[1], \"-a\")) {\n        if (libmin_strcmp(v4[1], \"-m\")) {\n          libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[v5 - 2]);\n          goto LABEL_27;\n        }\n        v6 = libmin_atoi(v4[2]);\n        if ((unsigned int)(v6 - 1) > 4) {\n          libmin_printf(\"Bad method number %d\\n\", v6);\n          return 1;\n        }\n      } else {\n        derror = libmin_atof(v4[2]);\n        if (derror <= 2.220446049250313e-16)\n          libmin_printf(\n              \"Warning: requested precision may exceed implementation \"\n              \"limit.\\n\");\n      }\n      v7 = v5;\n      v5 += 2;\n      v4 += 2;\n      v3 = ::argv[v7];\n    } while (*v3 == 45);\n    if (::argc <= 4) goto LABEL_27;\n    Ea = libmin_atof(v3);\n    v8 = libmin_atof(::argv[4]);\n    v9 = Ea;\n    e = v8;\n    v10 = (double(__usercall *)\n               @<xmm0>(double @<xmm1>, double @<xmm2>, double @<xmm3>,\n                       int @<edi>))methods[v6 - 1];\n    if (v6 == 4 && v8 > 0.6627434193) {\n      libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n      return 1;\n    }\n  } else {\n    if (::argc <= 2) {\n    LABEL_27:\n      libmin_printf((char *)\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n      return 1;\n    }\n    v10 = strict_iteration;\n    v9 = libmin_atof(::argv[1]);\n    e = libmin_atof(::argv[2]);\n  }\n  if (e >= 0.0 && e < 1.0) {\n    v11 = 1.0;\n    if (v9 <= 0.0) v11 = -1.0;\n    Eb = libmin_fabs(v9) / 6.28318530718;\n    v12 = libmin_floor(Eb);\n    v13 = (Eb - v12 + Eb - v12) * 3.14159265359 * v11;\n    v22 = v13;\n    if (v13 <= 3.14159265359) {\n      v23 = 1.0;\n    } else {\n      v23 = -1.0;\n      v22 = 6.28318530718 - v13;\n    }\n    v14 = 1.570796326795;\n    for (i = 1;; ++i) {\n      E = v10(e, v22, v14, 0);\n      if (libmin_fabs(e) < derror) break;\n      v16 = i;\n      libmin_printf(\"n = %d\\tE = %f\\n\", v16, E * v23);\n      v14 = E;\n    }\n    libmin_success();\n  }\n  libmin_printf(\"Eccentricity %f out of range.\\n\", e);\n  return 1;\n}", "binary": "kepler/kepler.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    0x9f2f(%rip),%rdi\ncmpb   $0x2d,(%rdi)\njne    14b2 <main+0x3b2>\nlea    0x9f17(%rip),%rbx\nmov    $0x3,%ebp\nmov    $0x1,%r12d\nlea    0x6ec9(%rip),%r15\nlea    0x6ec5(%rip),%r14\nlea    0x6ec6(%rip),%r13\nlea    -0x2(%rbp),%eax\nmov    %r15,%rsi\nmov    %eax,0x8(%rsp)\ncall   5a50 <libmin_strcmp>\ntest   %eax,%eax\nje     1370 <main+0x270>\nmov    0x8(%rbx),%rdi\nmov    %r14,%rsi\ncall   5a50 <libmin_strcmp>\ntest   %eax,%eax\nje     139c <main+0x29c>\nmov    0x8(%rbx),%rdi\nmov    %r13,%rsi\ncall   5a50 <libmin_strcmp>\ntest   %eax,%eax\nje     13c8 <main+0x2c8>\nmov    0x8(%rbx),%rdi\nlea    0x6e7f(%rip),%rsi\ncall   5a50 <libmin_strcmp>\ntest   %eax,%eax\njne    1425 <main+0x325>\nmov    0x10(%rbx),%rdi\ncall   21d0 <libmin_atoi>\nmov    %eax,%r12d\nlea    -0x1(%rax),%eax\ncmp    $0x4,%eax\nja     1400 <main+0x300>\nmovslq %ebp,%rax\nlea    0x9e7e(%rip),%rcx\nadd    $0x2,%ebp\nadd    $0x10,%rbx\nmov    (%rcx,%rax,8),%rdi\ncmpb   $0x2d,(%rdi)\nje     1149 <main+0x49>\ncmpl   $0x4,0x9e3b(%rip)\njle    1443 <main+0x343>\ncall   2030 <libmin_atof>\nmov    0x9e71(%rip),%rdi\nmovsd  %xmm0,0x8(%rsp)\ncall   2030 <libmin_atof>\nlea    -0x1(%r12),%eax\ncmp    $0x4,%r12d\nlea    0x9b56(%rip),%rdx\ncltq\nmovsd  0x8(%rsp),%xmm1\nmovsd  %xmm0,0x18(%rsp)\nmov    (%rdx,%rax,8),%rbx\nje     145f <main+0x35f>\nmovsd  0x18(%rsp),%xmm5\npxor   %xmm0,%xmm0\ncomisd %xmm5,%xmm0\nja     1491 <main+0x391>\ncomisd 0x707a(%rip),%xmm5\njae    1491 <main+0x391>\ncomisd %xmm0,%xmm1\nmov    0x7069(%rip),%rax\nmovq   %rax,%xmm2\nja     125e <main+0x15e>\nmovsd  0x7072(%rip),%xmm2\nmovapd %xmm1,%xmm0\nmovsd  %xmm2,0x10(%rsp)\ncall   22b0 <libmin_fabs>\nmovapd %xmm0,%xmm1\ndivsd  0x7087(%rip),%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm1,0x8(%rsp)\ncall   22f0 <libmin_floor>\nmovsd  0x8(%rsp),%xmm1\nmovsd  0x10(%rsp),%xmm2\nsubsd  %xmm0,%xmm1\nmovapd %xmm1,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  0x7060(%rip),%xmm1\nmulsd  %xmm1,%xmm0\nmulsd  %xmm2,%xmm0\ncomisd %xmm1,%xmm0\nmovsd  %xmm0,0x20(%rsp)\njbe    14ea <main+0x3ea>\nmovsd  0x7038(%rip),%xmm6\nmovsd  0x7000(%rip),%xmm7\nsubsd  %xmm0,%xmm6\nmovsd  %xmm7,0x28(%rsp)\nmovsd  %xmm6,0x20(%rsp)\nmovsd  0x7008(%rip),%xmm3\nmov    $0x1,%ebp\nlea    0x6d52(%rip),%r12\njmp    131e <main+0x21e>\nmovsd  0x8(%rsp),%xmm0\nmov    %ebp,%esi\nmov    %r12,%rdi\nmov    $0x1,%eax\nmulsd  0x28(%rsp),%xmm0\nlea    0x1(%rbp),%r13d\nmov    %r13d,%ebp\ncall   4c60 <libmin_printf>\nmovsd  0x8(%rsp),%xmm3\nxor    %edi,%edi\nmovsd  0x20(%rsp),%xmm2\nmovsd  0x18(%rsp),%xmm1\nmovapd %xmm3,%xmm0\nmovsd  %xmm3,0x10(%rsp)\ncall   *%rbx\nmovsd  0x10(%rsp),%xmm3\nmovsd  %xmm0,0x8(%rsp)\nsubsd  %xmm0,%xmm3\nmovapd %xmm3,%xmm0\ncall   22b0 <libmin_fabs>\ncomisd 0x9cc7(%rip),%xmm0\njae    12f6 <main+0x1f6>\ncall   5ae0 <libmin_success>\nxor    %eax,%eax\njmp    1416 <main+0x316>\nnopw   0x0(%rax,%rax,1)\nlea    0x6cf1(%rip),%rsi\nlea    0x6cc4(%rip),%rdi\ncall   4c60 <libmin_printf>\ncall   5ae0 <libmin_success>\nmov    0x8(%rbx),%rdi\nmov    %r14,%rsi\ncall   5a50 <libmin_strcmp>\ntest   %eax,%eax\njne    1174 <main+0x74>\nlea    0x6c67(%rip),%rsi\nlea    0x6c98(%rip),%rdi\ncall   4c60 <libmin_printf>\ncall   5ae0 <libmin_success>\nmov    0x8(%rbx),%rdi\nmov    %r13,%rsi\ncall   5a50 <libmin_strcmp>\ntest   %eax,%eax\njne    1188 <main+0x88>\nmov    0x10(%rbx),%rdi\ncall   2030 <libmin_atof>\nmovsd  0x6f0f(%rip),%xmm1\nmovsd  %xmm0,0x9c3f(%rip)\ncomisd %xmm0,%xmm1\njb     11b8 <main+0xb8>\nlea    0x6e16(%rip),%rdi\nxor    %eax,%eax\ncall   4c60 <libmin_printf>\njmp    11b8 <main+0xb8>\nxchg   %ax,%ax\nmov    %r12d,%esi\nlea    0x6c0b(%rip),%rdi\nxor    %eax,%eax\ncall   4c60 <libmin_printf>\nmov    $0x1,%eax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovslq 0x8(%rsp),%rax\nlea    0x9c0f(%rip),%rdx\nlea    0x6bf3(%rip),%rdi\nmov    (%rdx,%rax,8),%rsi\nxor    %eax,%eax\ncall   4c60 <libmin_printf>\nlea    0x6dfe(%rip),%rsi\nlea    0x6bf1(%rip),%rdi\nxor    %eax,%eax\ncall   4c60 <libmin_printf>\nmov    $0x1,%eax\njmp    1416 <main+0x316>\ncomisd 0x6e91(%rip),%xmm0\njbe    1222 <main+0x122>\nmov    0x6e84(%rip),%rax\nlea    0x6df5(%rip),%rdi\nmovq   %rax,%xmm0\nmov    $0x1,%eax\ncall   4c60 <libmin_printf>\nmov    $0x1,%eax\njmp    1416 <main+0x316>\nmovsd  0x18(%rsp),%xmm0\nlea    0x6dfa(%rip),%rdi\nmov    $0x1,%eax\ncall   4c60 <libmin_printf>\nmov    $0x1,%eax\njmp    1416 <main+0x316>\ncmpl   $0x2,0x9b5f(%rip)\njle    1443 <main+0x343>\ncall   2030 <libmin_atof>\nmov    0x9b89(%rip),%rdi\nlea    0x122(%rip),%rbx\nmovsd  %xmm0,0x8(%rsp)\ncall   2030 <libmin_atof>\nmovsd  0x8(%rsp),%xmm1\nmovsd  %xmm0,0x18(%rsp)\njmp    1222 <main+0x122>\nmov    0x6dc7(%rip),%rax\nmov    %rax,0x28(%rsp)\njmp    12e0 <main+0x1e0>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "newton", "content": "/* The following routine is used to solve kepler's equation using\n   Newton's method. It is very fast and reliable for small values of\n   e, but can be wildly erratic for e close to 1. See, e.g, the discussion\n   in Jean Meeus, Astronomical Algorithms, Willmann-Bell, 1991, 181-193.\n*/\n\ndouble newton(double E, double e, double M, int reset)\n{\n\t/* reset is not used in this routine. It may generate a compiler\n           warning */\n\treturn E + (M + e*libmin_sin(E) - E)/(1 - e*libmin_cos(E));\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O3.pseudo", "function_name": "newton", "address": "0x1620", "label": "newton", "content": "double __fastcall newton(double a1, double E, double e, double M, int reset)\n{\n  double Ea; // [rsp+18h] [rbp-10h]\n\n  Ea = e + libmin_sin(E) * E - a1;\n  return Ea / (1.0 - libmin_cos(Ea) * E) + a1;\n}\n"}, "pseudo_normalize": "", "binary": "kepler/kepler.host.O3", "assembly": "<newton>:\nendbr64\nsub    $0x28,%rsp\nmovsd  %xmm2,0x10(%rsp)\nmovsd  %xmm1,0x8(%rsp)\nmovsd  %xmm0,0x18(%rsp)\ncall   5480 <libmin_sin>\nmulsd  0x8(%rsp),%xmm0\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x18(%rsp),%xmm3\nmovsd  %xmm3,0x10(%rsp)\naddsd  %xmm0,%xmm1\nmovapd %xmm3,%xmm0\nsubsd  %xmm3,%xmm1\nmovsd  %xmm1,0x18(%rsp)\ncall   5090 <libmin_cos>\nmulsd  0x8(%rsp),%xmm0\nmovsd  0x6c3c(%rip),%xmm2\nmovsd  0x18(%rsp),%xmm1\nmovsd  0x10(%rsp),%xmm3\nadd    $0x28,%rsp\nsubsd  %xmm0,%xmm2\ndivsd  %xmm2,%xmm1\nmovapd %xmm1,%xmm0\naddsd  %xmm3,%xmm0\nret\nnopl   (%rax)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "strict_iteration", "content": "/* All the algorithms for solving kepler's equation are implemented in\n   the following subroutines. A subroutine is called iteratively from\n   main, until the previous value of E differs from the current one by\n   less than derror.\n\n   To add a new method, add its implementation as a subroutine \n   with signature\n\n\tdouble foo(double E, double e, double M, int reset);\n\n   It should return a better approximation to the true E\n   given the current E and the values of e and M. When passed a \n   nonzero value for the reset parameter it should reinitialize any\n   static information it retains and return.\n   Then add the address of\n   the new subroutine to the methods array defined below.\n*/ \n\n/* CURRENTLY IMPLEMENTED METHODS: */\n\n/* Used to solve kepler's equation by simple iteration */\n\ndouble strict_iteration(double E, double e, double M, int reset)\n{\n\n\t/* reset is not used in this routine. It may generate a compiler\n           warning */\n\treturn M + e*libmin_sin(E);\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O3.pseudo", "function_name": "strict_iteration", "address": "0x15f0", "label": "strict_iteration", "content": "double __fastcall strict_iteration(double a1, double E, double e, double M, int reset)\n{\n  return libmin_sin(E) * E + e;\n}\n"}, "pseudo_normalize": "", "binary": "kepler/kepler.host.O3", "assembly": "<strict_iteration>:\nendbr64\nsub    $0x18,%rsp\nmovsd  %xmm1,(%rsp)\nmovsd  %xmm2,0x8(%rsp)\ncall   5480 <libmin_sin>\nmulsd  (%rsp),%xmm0\naddsd  0x8(%rsp),%xmm0\nadd    $0x18,%rsp\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "knapsack/knapsack.c", "function_name": "knapSack", "content": "// Returns the maximum value that can be put in a knapsack of capacity W\nvoid\nknapSack(int wt[], int val[], int K[N+1][W+1])\n{\n  int i, w;\n\n  // Build table K[][] in bottom up manner\n  for (i = 0; i <= N; i++)\n  {\n    for (w = 0; w <= W; w++)\n    {\n      if (i==0 || w==0)\n        K[i][w] = 0;\n      else\n      {\n        if (wt[i-1] <= w)\n          K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]);\n        else\n          K[i][w] = K[i-1][w];\n      }\n    }\n  }\n}\n"}, "pseudo": {"path": "knapsack/knapsack.host.O3.pseudo", "function_name": "knapSack", "address": "0x1320", "label": "knapSack", "content": "void __fastcall knapSack(int *wt, int *val, int (*K)[251])\n{\n  int *v5; // r11\n  int *v6; // r10\n  int v7; // ebx\n  int *v8; // r9\n  __int64 i; // rax\n  int v10; // edx\n\n  v5 = val - 1;\n  v6 = wt - 1;\n  v7 = 0;\n  do\n  {\n    v8 = &(*K)[-251];\n    for ( i = 0LL; i != 251; ++i )\n    {\n      while ( !(_DWORD)i || !v7 )\n      {\n        (*K)[i++] = 0;\n        if ( i == 251 )\n          goto LABEL_10;\n      }\n      v10 = v8[i];\n      if ( *v6 <= (int)i && v10 < v8[(int)i - *v6] + *v5 )\n        v10 = v8[(int)i - *v6] + *v5;\n      (*K)[i] = v10;\n    }\nLABEL_10:\n    ++v7;\n    ++K;\n    ++v5;\n    ++v6;\n  }\n  while ( v7 != 51 );\n}\n"}, "pseudo_normalize": "void knapSack(int *wt, int *val, int (*K)[251]) {\n  int *v5;\n  int *v6;\n  int v7;\n  int *v8;\n  long long i;\n  int v10;\n  v5 = val - 1;\n  v6 = wt - 1;\n  v7 = 0;\n  do {\n    v8 = &(*K)[-251];\n    for (i = 0LL; i != 251; ++i) {\n      while (!(uint32_t)i || !v7) {\n        (*K)[i++] = 0;\n        if (i == 251) goto LABEL_10;\n      }\n      v10 = v8[i];\n      if (*v6 <= (int)i && v10 < v8[(int)i - *v6] + *v5)\n        v10 = v8[(int)i - *v6] + *v5;\n      (*K)[i] = v10;\n    }\n  LABEL_10:\n    ++v7;\n    ++K;\n    ++v5;\n    ++v6;\n  } while (v7 != 51);\n}", "binary": "knapsack/knapsack.host.O3", "assembly": "<knapSack>:\nendbr64\nmov    %rdi,%r10\npush   %rbx\nmov    %rdx,%rdi\nlea    -0x4(%rsi),%r11\nsub    $0x4,%r10\nxor    %ebx,%ebx\ntest   %ebx,%ebx\nlea    -0x3ec(%rdi),%r9\nsete   %r8b\nxor    %eax,%eax\njmp    137b <knapSack+0x5b>\ncs nopw 0x0(%rax,%rax,1)\nmov    (%r10),%esi\nmov    (%r9,%rax,4),%edx\ncmp    %eax,%esi\njg     136c <knapSack+0x4c>\nsub    %esi,%ecx\nmov    (%r11),%esi\nmovslq %ecx,%rcx\nadd    (%r9,%rcx,4),%esi\ncmp    %esi,%edx\ncmovl  %esi,%edx\nmov    %edx,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    $0xfb,%rax\nje     1397 <knapSack+0x77>\nmov    %eax,%ecx\ntest   %eax,%eax\nje     1386 <knapSack+0x66>\ntest   %r8b,%r8b\nje     1350 <knapSack+0x30>\nxor    %edx,%edx\nmov    %edx,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    $0xfb,%rax\njne    137b <knapSack+0x5b>\nadd    $0x1,%ebx\nadd    $0x3ec,%rdi\nadd    $0x4,%r11\nadd    $0x4,%r10\ncmp    $0x33,%ebx\njne    1335 <knapSack+0x15>\npop    %rbx\nret\n"}
{"source": {"path": "knapsack/knapsack.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int n = N;\n  int w = W;\n  int K[N+1][W+1];\n\n\n  knapSack(wt, val, K);\n\n\tlibmin_printf(\"Max value: %d\\n\", K[n][W]);\n\t\n  libmin_printf(\"Selected packs:\\n\");\n  while (n != 0)\n  {\n    if (K[n][w] != K[n - 1][w]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", n, wt[n - 1], val[n - 1]);\n      w = w - wt[n-1];\n    }\n    n--;\n  }\n  libmin_printf(\"Total weight: %d\\n\", W - w);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "knapsack/knapsack.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "// positive sp value has been detected, the output may be wrong!\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  int v4; // r12d\n  int v6[516]; // [rsp-1838h] [rbp-E070h] BYREF\n  __int64 v7; // [rsp-1028h] [rbp-D860h] BYREF\n  __int64 v8; // [rsp-28h] [rbp-C860h] BYREF\n  int K[51][251]; // [rsp+0h] [rbp-C838h]\n\n  while ( &v7 != &v8 - 6144 )\n    ;\n  v3 = 49LL;\n  v4 = 250;\n  *(_QWORD *)&K[44][208] = __readfsqword(0x28u);\n  knapSack(wt, val, (int (*)[251])v6);\n  libmin_printf(\"Max value: %d\\n\", K[44][206]);\n  libmin_printf(\"Selected packs:\\n\");\n  while ( 1 )\n  {\n    if ( v6[251 * (int)v3 + 251 + v4] != v6[251 * (int)v3 + v4] )\n    {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", v3 + 1, wt[v3], val[v3]);\n      v4 -= wt[v3];\n    }\n    if ( v3-- == 0 )\n    {\n      libmin_printf(\"Total weight: %d\\n\", 250 - v4);\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  int v6[516];\n  long long v7;\n  long long v8;\n  int K[51][251];\n  while (&v7 != &v8 - 6144)\n    ;\n  v3 = 49LL;\n  v4 = 250;\n  *(uint64_t *)&K[44][208] = __readfsqword(40u);\n  knapSack(wt, val, (int(*)[251])v6);\n  libmin_printf(\"Max value: %d\\n\", K[44][206]);\n  libmin_printf(\"Selected packs:\\n\");\n  while (1) {\n    if (v6[251 * (int)v3 + 251 + v4] != v6[251 * (int)v3 + v4]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", v3 + 1, wt[v3],\n                    val[v3]);\n      v4 -= wt[v3];\n    }\n    if (v3-- == 0) {\n      libmin_printf(\"Total weight: %d\\n\", 250 - v4);\n      libmin_success();\n    }\n  }\n}", "binary": "knapsack/knapsack.host.O3", "assembly": "<main>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    -0xc000(%rsp),%r11\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\ncmp    %r11,%rsp\njne    1114 <main+0x14>\nsub    $0x810,%rsp\nlea    0x4fcd(%rip),%r14\nlea    0x4ee6(%rip),%r13\nmov    $0x31,%ebx\nmov    %r14,%rsi\nmov    %r13,%rdi\nmov    $0xfa,%r12d\nlea    0x2ee6(%rip),%rbp\nmov    %fs:0x28,%rax\nmov    %rax,0xc808(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdx\ncall   1320 <knapSack>\nmov    0xc800(%rsp),%esi\nlea    0x2e89(%rip),%rdi\nxor    %eax,%eax\ncall   3480 <libmin_printf>\nlea    0x2e8a(%rip),%rdi\nxor    %eax,%eax\ncall   3480 <libmin_printf>\nlea    0x1(%rbx),%esi\nmovslq %ebx,%rax\nmovslq %r12d,%rcx\nmovslq %esi,%rdx\nimul   $0xfb,%rax,%rax\nimul   $0xfb,%rdx,%rdx\nadd    %rcx,%rax\nadd    %rcx,%rdx\nmov    (%rsp,%rax,4),%eax\ncmp    %eax,(%rsp,%rdx,4)\nje     11d0 <main+0xd0>\nmov    (%r14,%rbx,4),%ecx\nmov    0x0(%r13,%rbx,4),%edx\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   3480 <libmin_printf>\nsub    0x0(%r13,%rbx,4),%r12d\nsub    $0x1,%rbx\njae    1190 <main+0x90>\nmov    $0xfa,%esi\nlea    0x2e42(%rip),%rdi\nxor    %eax,%eax\nsub    %r12d,%esi\ncall   3480 <libmin_printf>\ncall   36c0 <libmin_success>\nmov    0xc808(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1216 <main+0x116>\nadd    $0xc810,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "knapsack/knapsack.c", "function_name": "max", "content": "#endif /* !PROBLEM_TINY */\n\n// A utility function that returns maximum of two integers\nint\nmax(int a, int b)\n{\n  if (a > b)\n    return a;\n  else\n    return b;\n}\n"}, "pseudo": {"path": "knapsack/knapsack.host.O3.pseudo", "function_name": "max", "address": "0x1310", "label": "max", "content": "int __fastcall max(int a, int b)\n{\n  int result; // eax\n\n  result = b;\n  if ( a >= b )\n    return a;\n  return result;\n}\n"}, "pseudo_normalize": "int max(int a, int b) {\n  int result;\n  result = b;\n  if (a >= b) return a;\n  return result;\n}", "binary": "knapsack/knapsack.host.O3", "assembly": "<max>:\nendbr64\ncmp    %esi,%edi\nmov    %esi,%eax\ncmovge %edi,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "isSafe", "content": "/* A utility function to check if i,j are valid indexes\n   for N*N chessboard */\nint\nisSafe(int x, int y, int sol[N][N])\n{\n    return ( x >= 0 && x < N && y >= 0 && y < N && sol[x][y] == -1);\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O3.pseudo", "function_name": "isSafe", "address": "0x1790", "label": "isSafe", "content": "int __fastcall isSafe(int x, int y, int (*sol)[5])\n{\n  return (unsigned int)x <= 4 && (unsigned int)y <= 4 && (*sol)[5 * x + y] == -1;\n}\n"}, "pseudo_normalize": "", "binary": "knights-tour/knights-tour.host.O3", "assembly": "<isSafe>:\nendbr64\ncmp    $0x4,%edi\nja     179e <isSafe+0xe>\ncmp    $0x4,%esi\njbe    17a8 <isSafe+0x18>\nxor    %eax,%eax\nret\nnopl   0x0(%rax)\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nlea    (%rdi,%rdi,4),%rax\nlea    (%rdx,%rax,4),%rax\ncmpl   $0xffffffff,(%rax,%rsi,4)\nsete   %al\nmovzbl %al,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "main", "content": "/* Driver program to test above functions */\nint\nmain(void)\n{\n    solveKT();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  solveKT();\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "knights-tour/knights-tour.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\ncall   1830 <solveKT>\ncall   3cb0 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "printSolution", "content": "/* A utility function to print solution matrix sol[N][N] */\nvoid\nprintSolution(int sol[N][N])\n{\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++)\n            libmin_printf(\" %2d \", sol[x][y]);\n        libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O3.pseudo", "function_name": "printSolution", "address": "0x17d0", "label": "printSolution", "content": "void __fastcall printSolution(int (*sol)[5])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n  int v3; // esi\n\n  v1 = &(*sol)[5];\n  do\n  {\n    v2 = v1 - 5;\n    do\n    {\n      v3 = *v2++;\n      libmin_printf(\" %2d \", v3);\n    }\n    while ( v2 != v1 );\n    v1 = v2 + 5;\n    libmin_printf(\"\\n\");\n  }\n  while ( v2 + 5 != &(*sol)[30] );\n}\n"}, "pseudo_normalize": "void printSolution(int (*sol)[5]) {\n  int *v1;\n  int *v2;\n  int v3;\n  v1 = &(*sol)[5];\n  do {\n    v2 = v1 - 5;\n    do {\n      v3 = *v2++;\n      libmin_printf(\" %2d \", v3);\n    } while (v2 != v1);\n    v1 = v2 + 5;\n    libmin_printf(\"\\n\");\n  } while (v2 + 5 != &(*sol)[30]);\n}", "binary": "knights-tour/knights-tour.host.O3", "assembly": "<printSolution>:\nendbr64\npush   %r14\nlea    0x282d(%rip),%r14\npush   %r13\nlea    0x78(%rdi),%r13\npush   %r12\nlea    0x2818(%rip),%r12\npush   %rbp\nlea    0x14(%rdi),%rbp\npush   %rbx\nlea    -0x14(%rbp),%rbx\nmov    (%rbx),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   3a70 <libmin_printf>\ncmp    %rbp,%rbx\njne    17f6 <printSolution+0x26>\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    0x14(%rbx),%rbp\ncall   3a70 <libmin_printf>\ncmp    %r13,%rbp\njne    17f2 <printSolution+0x22>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "solveKT", "content": "/* This function solves the Knight Tour problem using\n   Backtracking.  This function mainly uses solveKTUtil()\n   to solve the problem. It returns false if no complete\n   tour is possible, otherwise return true and prints the\n   tour.\n*/\nint\nsolveKT(void)\n{\n    int sol[N][N];\n\n    /* Initialization of solution matrix */\n    for (int x = 0; x < N; x++)\n        for (int y = 0; y < N; y++)\n            sol[x][y] = -1;\n\n    /* xMove[] and yMove[] define next move of Knight.\n       xMove[] is for next value of x coordinate\n       yMove[] is for next value of y coordinate */\n    int xMove[8] = {  2, 1, -1, -2, -2, -1,  1,  2 };\n    int yMove[8] = {  1, 2,  2,  1, -1, -2, -2, -1 };\n\n    // Since the Knight is initially at the first block\n    sol[0][0]  = 0;\n\n    /* Start from 0,0 and explore all tours using\n       solveKTUtil() */\n    if (solveKTUtil(0, 0, 1, sol, xMove, yMove) == 0) {\n        libmin_printf(\"Solution does not exist\");\n        return 0;\n    }\n    else\n        printSolution(sol);\n\n    return 1;\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O3.pseudo", "function_name": "solveKT", "address": "0x1830", "label": "solveKT", "content": "int __cdecl solveKT()\n{\n  int *v0; // rbp\n  int *v1; // rbx\n  int v2; // esi\n  int v3; // r12d\n  int xMove[8]; // [rsp+0h] [rbp-D8h] BYREF\n  int yMove[8]; // [rsp+20h] [rbp-B8h] BYREF\n  int sol[5][5]; // [rsp+40h] [rbp-98h] BYREF\n  unsigned __int64 v8; // [rsp+A8h] [rbp-30h]\n  char v9; // [rsp+B8h] [rbp-20h] BYREF\n\n  v8 = __readfsqword(0x28u);\n  memset(sol, 255, sizeof(sol));\n  *(__m128i *)xMove = _mm_load_si128((const __m128i *)&xmmword_4030);\n  sol[0][0] = 0;\n  *(__m128i *)&xMove[4] = _mm_load_si128((const __m128i *)&xmmword_4040);\n  *(__m128i *)yMove = _mm_load_si128((const __m128i *)&xmmword_4050);\n  *(__m128i *)&yMove[4] = _mm_load_si128((const __m128i *)&xmmword_4060);\n  if ( solveKTUtil_0(0, 0, 1, sol, xMove, yMove) )\n  {\n    v0 = sol[1];\n    do\n    {\n      v1 = v0 - 5;\n      do\n      {\n        v2 = *v1++;\n        libmin_printf(\" %2d \", v2);\n      }\n      while ( v0 != v1 );\n      v0 += 5;\n      libmin_printf(\"\\n\");\n    }\n    while ( &v9 != (char *)v0 );\n    return 1;\n  }\n  else\n  {\n    v3 = 0;\n    libmin_printf(\"Solution does not exist\");\n  }\n  return v3;\n}\n"}, "pseudo_normalize": "int solveKT() {\n  int *v0;\n  int *v1;\n  int v2;\n  int v3;\n  int xMove[8];\n  int yMove[8];\n  int sol[5][5];\n  unsigned long long v8;\n  char v9;\n  v8 = __readfsqword(40u);\n  memset(sol, 255, sizeof(sol));\n  *(__m128i *)xMove = _mm_load_si128((const __m128i *)&xmmword_4030);\n  sol[0][0] = 0;\n  *(__m128i *)&xMove[4] = _mm_load_si128((const __m128i *)&xmmword_4040);\n  *(__m128i *)yMove = _mm_load_si128((const __m128i *)&xmmword_4050);\n  *(__m128i *)&yMove[4] = _mm_load_si128((const __m128i *)&xmmword_4060);\n  if (solveKTUtil_0(0, 0, 1, sol, xMove, yMove)) {\n    v0 = sol[1];\n    do {\n      v1 = v0 - 5;\n      do {\n        v2 = *v1++;\n        libmin_printf(\" %2d \", v2);\n      } while (v0 != v1);\n      v0 += 5;\n      libmin_printf(\"\\n\");\n    } while (&v9 != (char *)v0);\n    return 1;\n  } else {\n    v3 = 0;\n    libmin_printf(\"Solution does not exist\");\n  }\n  return v3;\n}", "binary": "knights-tour/knights-tour.host.O3", "assembly": "<solveKT>:\nendbr64\npush   %r14\npcmpeqd %xmm0,%xmm0\nxor    %esi,%esi\nxor    %edi,%edi\npush   %r13\nmov    $0x1,%edx\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xb0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0xa8(%rsp)\nxor    %eax,%eax\nmovaps %xmm0,0x40(%rsp)\nlea    0x40(%rsp),%rcx\nmov    %rsp,%r8\nmovaps %xmm0,0x50(%rsp)\nlea    0x20(%rsp),%r9\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x70(%rsp)\nmovaps %xmm0,0x80(%rsp)\nmovaps %xmm0,0x90(%rsp)\nmovdqa 0x2794(%rip),%xmm0\nmovl   $0xffffffff,0xa0(%rsp)\nmovaps %xmm0,(%rsp)\nmovdqa 0x278d(%rip),%xmm0\nmovl   $0x0,0x40(%rsp)\nmovaps %xmm0,0x10(%rsp)\nmovdqa 0x2788(%rip),%xmm0\nmovaps %xmm0,0x20(%rsp)\nmovdqa 0x278b(%rip),%xmm0\nmovaps %xmm0,0x30(%rsp)\ncall   1210 <solveKTUtil.part.0>\ntest   %eax,%eax\nje     1960 <solveKT+0x130>\nlea    0x54(%rsp),%rbp\nlea    0xb8(%rsp),%r14\nlea    0x270d(%rip),%r12\nlea    0x270c(%rip),%r13\nlea    -0x14(%rbp),%rbx\nmov    (%rbx),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   3a70 <libmin_printf>\ncmp    %rbx,%rbp\njne    1902 <solveKT+0xd2>\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x14,%rbp\ncall   3a70 <libmin_printf>\ncmp    %rbp,%r14\njne    18fe <solveKT+0xce>\nmov    $0x1,%r12d\nmov    0xa8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1973 <solveKT+0x143>\nadd    $0xb0,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncs nopw 0x0(%rax,%rax,1)\nmov    %eax,%r12d\nlea    0x26a2(%rip),%rdi\nxor    %eax,%eax\ncall   3a70 <libmin_printf>\njmp    1930 <solveKT+0x100>\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "solveKTUtil", "content": "/* A recursive utility function to solve Knight Tour\n   problem */\nint\nsolveKTUtil(int x, int y, int movei, int sol[N][N], int xMove[N], int yMove[N])\n{\n   int k, next_x, next_y;\n   if (movei == N*N)\n       return 1;\n\n   /* Try all next moves from the current coordinate x, y */\n   for (k = 0; k < 8; k++) {\n       next_x = x + xMove[k];\n       next_y = y + yMove[k];\n       if (isSafe(next_x, next_y, sol)) {\n         sol[next_x][next_y] = movei;\n         if (solveKTUtil(next_x, next_y, movei+1, sol, xMove, yMove) == 1)\n             return 1;\n         else\n             sol[next_x][next_y] = -1;// backtracking\n       }\n   }\n\n   return 0;\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O3.pseudo", "function_name": "solveKTUtil", "address": "0x1980", "label": "solveKTUtil", "content": "int __fastcall solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove, int *yMove)\n{\n  if ( movei == 25 )\n    return 1;\n  else\n    return solveKTUtil_0(x, y, movei, sol, xMove, yMove);\n}\n"}, "pseudo_normalize": "int solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove,\n                int *yMove) {\n  if (movei == 25)\n    return 1;\n  else\n    return solveKTUtil_0(x, y, movei, sol, xMove, yMove);\n}", "binary": "knights-tour/knights-tour.host.O3", "assembly": "<solveKTUtil>:\nendbr64\ncmp    $0x19,%edx\nje     1990 <solveKTUtil+0x10>\njmp    1210 <solveKTUtil.part.0>\nxchg   %ax,%ax\nmov    $0x1,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "draw", "content": "void\ndraw(void)\n{\n  // go to home position on screen\n  libmin_printf(\"\\x1b[H\");\n\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", evolution++);\n  for (int y = 0; y < GRID_HEIGHT; ++y)\n    {\n      for (int x = 0; x < GRID_WIDTH; ++x)\n        libmin_printf(\"%c\", grid[x][y]);\n      libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "draw", "address": "0x1390", "label": "draw", "content": "void __cdecl draw()\n{\n  __int64 v0; // rbp\n  unsigned int v1; // esi\n  __int64 i; // rbx\n  char *v3; // rax\n\n  v0 = 0LL;\n  libmin_printf(\"\\x1B[H\");\n  v1 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v1);\n  do\n  {\n    for ( i = 0LL; i != 70; ++i )\n    {\n      v3 = grid[i];\n      libmin_printf(\"%c\", (unsigned int)v3[v0]);\n    }\n    ++v0;\n    libmin_printf(\"\\n\");\n  }\n  while ( v0 != 22 );\n}\n"}, "pseudo_normalize": "void draw() {\n  long long v0;\n  unsigned int v1;\n  long long i;\n  char *v3;\n  v0 = 0LL;\n  libmin_printf(\"\\x1B[H\");\n  v1 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v1);\n  do {\n    for (i = 0LL; i != 70; ++i) {\n      v3 = grid[i];\n      libmin_printf(\"%c\", (unsigned int)v3[v0]);\n    }\n    ++v0;\n    libmin_printf(\"\\n\");\n  } while (v0 != 22);\n}", "binary": "life/life.host.O3", "assembly": "<draw>:\nendbr64\npush   %r13\nlea    0x3c6c(%rip),%rdi\nxor    %eax,%eax\nlea    0x3c6a(%rip),%r13\npush   %r12\nlea    0x3c5e(%rip),%r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nsub    $0x8,%rsp\ncall   3b70 <libmin_printf>\nmov    0x5c4e(%rip),%esi\nlea    0x3c4f(%rip),%rdi\nlea    0x1(%rsi),%eax\nmov    %eax,0x5c3e(%rip)\nxor    %eax,%eax\ncall   3b70 <libmin_printf>\nnopl   0x0(%rax)\nxor    %ebx,%ebx\nnopw   0x0(%rax,%rax,1)\nmov    0x5c39(%rip),%rax\nmov    %r12,%rdi\nmov    (%rax,%rbx,1),%rax\nadd    $0x8,%rbx\nmovsbl (%rax,%rbp,1),%esi\nxor    %eax,%eax\ncall   3b70 <libmin_printf>\ncmp    $0x230,%rbx\njne    13e8 <draw+0x58>\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbp\ncall   3b70 <libmin_printf>\ncmp    $0x16,%rbp\njne    13e0 <draw+0x50>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   (%rax)\n"}
{"source": {"path": "life/life.c", "function_name": "flip", "content": "void\nflip(void)\n{\n  char **tmp = grid;\n  grid = gridTmp;\n  gridTmp = tmp;\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "flip", "address": "0x18a0", "label": "flip", "content": "void __cdecl flip()\n{\n  char **v0; // rdx\n\n  v0 = gridTmp;\n  gridTmp = grid;\n  grid = v0;\n}\n"}, "pseudo_normalize": "void flip() {\n  char **v0;\n  v0 = gridTmp;\n  gridTmp = grid;\n  grid = v0;\n}", "binary": "life/life.host.O3", "assembly": "<flip>:\nendbr64\nmov    0x577d(%rip),%rax\nmov    0x576e(%rip),%rdx\nmov    %rax,0x5767(%rip)\nmov    %rdx,0x5768(%rip)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "life/life.c", "function_name": "getDown", "content": "char\ngetDown(int x, int y)\n{\n  if (y == GRID_HEIGHT - 1)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x][y + 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "getDown", "address": "0x1960", "label": "getDown", "content": "char __fastcall getDown(int x, int y)\n{\n  if ( y == 21 )\n    return DEAD[0];\n  else\n    return grid[x][y + 1];\n}\n"}, "pseudo_normalize": "char getDown(int x, int y) {\n  if (y == 21)\n    return DEAD[0];\n  else\n    return grid[x][y + 1];\n}", "binary": "life/life.host.O3", "assembly": "<getDown>:\nendbr64\ncmp    $0x15,%esi\nje     1980 <getDown+0x20>\nmov    0x56b8(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    (%rax,%rdi,8),%rax\nmovzbl 0x1(%rax,%rsi,1),%eax\nret\nmovzbl 0x568f(%rip),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "getDownLeft", "content": "char\ngetDownLeft(int x, int y)\n {\n  if (y == GRID_HEIGHT - 1 || x == 0)\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x - 1][y + 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "getDownLeft", "address": "0x19f0", "label": "getDownLeft", "content": "char __fastcall getDownLeft(int x, int y)\n{\n  if ( y == 21 || !x )\n    return DEAD[0];\n  else\n    return grid[x - 1][y + 1];\n}\n"}, "pseudo_normalize": "char getDownLeft(int x, int y) {\n  if (y == 21 || !x)\n    return DEAD[0];\n  else\n    return grid[x - 1][y + 1];\n}", "binary": "life/life.host.O3", "assembly": "<getDownLeft>:\nendbr64\ncmp    $0x15,%esi\nje     1a18 <getDownLeft+0x28>\ntest   %edi,%edi\nje     1a18 <getDownLeft+0x28>\nmov    0x5624(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    -0x8(%rax,%rdi,8),%rax\nmovzbl 0x1(%rax,%rsi,1),%eax\nret\nnopl   (%rax)\nmovzbl 0x55f7(%rip),%eax\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getDownRight", "content": "char\ngetDownRight(int x, int y)\n{\n  if (y == GRID_HEIGHT - 1 || x == GRID_WIDTH - 1 )\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x + 1][y + 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "getDownRight", "address": "0x1a20", "label": "getDownRight", "content": "char __fastcall getDownRight(int x, int y)\n{\n  if ( y == 21 || x == 69 )\n    return DEAD[0];\n  else\n    return grid[x + 1][y + 1];\n}\n"}, "pseudo_normalize": "char getDownRight(int x, int y) {\n  if (y == 21 || x == 69)\n    return DEAD[0];\n  else\n    return grid[x + 1][y + 1];\n}", "binary": "life/life.host.O3", "assembly": "<getDownRight>:\nendbr64\ncmp    $0x15,%esi\nje     1a50 <getDownRight+0x30>\ncmp    $0x45,%edi\nje     1a50 <getDownRight+0x30>\nmov    0x55f3(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x8(%rax,%rdi,8),%rax\nmovzbl 0x1(%rax,%rsi,1),%eax\nret\ncs nopw 0x0(%rax,%rax,1)\nmovzbl 0x55bf(%rip),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "getLeft", "content": "char\ngetLeft(int x, int y)\n{\n  if (x == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x - 1][y];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "getLeft", "address": "0x18d0", "label": "getLeft", "content": "char __fastcall getLeft(int x, int y)\n{\n  if ( x )\n    return grid[x - 1][y];\n  else\n    return DEAD[0];\n}\n"}, "pseudo_normalize": "char getLeft(int x, int y) {\n  if (x)\n    return grid[x - 1][y];\n  else\n    return DEAD[0];\n}", "binary": "life/life.host.O3", "assembly": "<getLeft>:\nendbr64\ntest   %edi,%edi\nje     18f0 <getLeft+0x20>\nmov    0x5749(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    -0x8(%rax,%rdi,8),%rax\nmovzbl (%rax,%rsi,1),%eax\nret\nnop\nmovzbl 0x571f(%rip),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "getNumNeigbors", "content": "int\ngetNumNeigbors(int x, int y)\n{\n  int i = 0;\n\n  if (getLeft(x, y) == LIVE)\n    i++;\n  if (getRight(x, y) == LIVE)\n    i++;\n  if (getUp(x, y) == LIVE)\n    i++;\n  if (getDown(x, y) == LIVE)\n    i++;\n  if (getUpLeft(x, y) == LIVE)\n    i++;\n  if (getUpRight(x, y) == LIVE)\n    i++;\n  if (getDownLeft(x, y) == LIVE)\n    i++;\n  if (getDownRight(x, y) == LIVE)\n    i++;\n\n  return i;\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "getNumNeigbors", "address": "0x16d0", "label": "getNumNeigbors", "content": "int __fastcall getNumNeigbors(int x, int y)\n{\n  __int64 v2; // r9\n  char v3; // r10\n  _BOOL4 v4; // eax\n  int v5; // eax\n  char v6; // r10\n  int v7; // eax\n  bool v8; // r10\n  char v9; // bl\n  int v10; // eax\n  bool v11; // di\n  char v12; // r11\n  int v13; // eax\n  char v14; // r10\n  int v15; // eax\n\n  v2 = x;\n  if ( x )\n  {\n    v3 = DEAD[0];\n    v4 = grid[x - 1][y] == LIVE[0];\n    if ( x == 69 )\n      goto LABEL_4;\n  }\n  else\n  {\n    v4 = DEAD[0] == LIVE[0];\n  }\n  v3 = grid[x + 1][y];\nLABEL_4:\n  v5 = (v3 == LIVE[0]) + v4;\n  if ( y )\n  {\n    if ( grid[x][y - 1] != LIVE[0] )\n      goto LABEL_6;\n  }\n  else if ( DEAD[0] != LIVE[0] )\n  {\n    goto LABEL_7;\n  }\n  ++v5;\nLABEL_6:\n  v6 = DEAD[0];\n  if ( y != 21 )\nLABEL_7:\n    v6 = grid[x][y + 1];\n  v7 = (v6 == LIVE[0]) + v5;\n  v8 = x == 0;\n  if ( x && y )\n    v9 = grid[x - 1][y - 1];\n  else\n    v9 = DEAD[0];\n  v10 = (v9 == LIVE[0]) + v7;\n  v11 = x == 69;\n  if ( !y || v11 )\n    v12 = DEAD[0];\n  else\n    v12 = grid[v2 + 1][y - 1];\n  v13 = (v12 == LIVE[0]) + v10;\n  if ( v8 || y == 21 )\n    v14 = DEAD[0];\n  else\n    v14 = grid[v2 - 1][y + 1];\n  v15 = (v14 == LIVE[0]) + v13;\n  if ( v11 || y == 21 )\n    return (DEAD[0] == LIVE[0]) + v15;\n  else\n    return (grid[v2 + 1][y + 1] == LIVE[0]) + v15;\n}\n"}, "pseudo_normalize": "int getNumNeigbors(int x, int y) {\n  long long v2;\n  char v3;\n  int v4;\n  int v5;\n  char v6;\n  int v7;\n  bool v8;\n  char v9;\n  int v10;\n  bool v11;\n  char v12;\n  int v13;\n  char v14;\n  int v15;\n  v2 = x;\n  if (x) {\n    v3 = DEAD[0];\n    v4 = grid[x - 1][y] == LIVE[0];\n    if (x == 69) goto LABEL_4;\n  } else {\n    v4 = DEAD[0] == LIVE[0];\n  }\n  v3 = grid[x + 1][y];\nLABEL_4:\n  v5 = (v3 == LIVE[0]) + v4;\n  if (y) {\n    if (grid[x][y - 1] != LIVE[0]) goto LABEL_6;\n  } else if (DEAD[0] != LIVE[0]) {\n    goto LABEL_7;\n  }\n  ++v5;\nLABEL_6:\n  v6 = DEAD[0];\n  if (y != 21)\n  LABEL_7:\n    v6 = grid[x][y + 1];\n  v7 = (v6 == LIVE[0]) + v5;\n  v8 = x == 0;\n  if (x && y)\n    v9 = grid[x - 1][y - 1];\n  else\n    v9 = DEAD[0];\n  v10 = (v9 == LIVE[0]) + v7;\n  v11 = x == 69;\n  if (!y || v11)\n    v12 = DEAD[0];\n  else\n    v12 = grid[v2 + 1][y - 1];\n  v13 = (v12 == LIVE[0]) + v10;\n  if (v8 || y == 21)\n    v14 = DEAD[0];\n  else\n    v14 = grid[v2 - 1][y + 1];\n  v15 = (v14 == LIVE[0]) + v13;\n  if (v11 || y == 21)\n    return (DEAD[0] == LIVE[0]) + v15;\n  else\n    return (grid[v2 + 1][y + 1] == LIVE[0]) + v15;\n}", "binary": "life/life.host.O3", "assembly": "<getNumNeigbors>:\nendbr64\nmovslq %esi,%rsi\npush   %rbx\nmovzbl 0x5938(%rip),%edx\nmovslq %edi,%r9\nmov    0x593f(%rip),%r8\nmov    %rsi,%rcx\ntest   %edi,%edi\nje     1830 <getNumNeigbors+0x160>\nmov    -0x8(%r8,%r9,8),%rax\nmovzbl 0x5915(%rip),%r10d\ncmp    %dl,(%rax,%rsi,1)\nsete   %al\nmovzbl %al,%eax\ncmp    $0x45,%edi\nje     1719 <getNumNeigbors+0x49>\nmov    0x8(%r8,%r9,8),%r10\nmovzbl (%r10,%rsi,1),%r10d\ncmp    %dl,%r10b\nsete   %r10b\nmovzbl %r10b,%r10d\nadd    %r10d,%eax\ntest   %ecx,%ecx\nje     1818 <getNumNeigbors+0x148>\nmov    (%r8,%r9,8),%r10\ncmp    %dl,-0x1(%r10,%rsi,1)\nje     1824 <getNumNeigbors+0x154>\nmovzbl 0x58d0(%rip),%r10d\ncmp    $0x15,%ecx\nje     1755 <getNumNeigbors+0x85>\nmov    (%r8,%r9,8),%r10\nmovzbl 0x1(%r10,%rsi,1),%r10d\ncmp    %dl,%r10b\nsete   %r10b\nmovzbl %r10b,%r10d\nadd    %r10d,%eax\ntest   %edi,%edi\nsete   %r10b\ntest   %ecx,%ecx\nsete   %r11b\ntest   %r10b,%r10b\njne    1878 <getNumNeigbors+0x1a8>\ntest   %r11b,%r11b\njne    1878 <getNumNeigbors+0x1a8>\nmov    -0x8(%r8,%r9,8),%rbx\nmovzbl -0x1(%rbx,%rsi,1),%ebx\ncmp    %dl,%bl\nsete   %bl\nmovzbl %bl,%ebx\nadd    %ebx,%eax\ncmp    $0x45,%edi\nsete   %dil\ntest   %r11b,%r11b\njne    1868 <getNumNeigbors+0x198>\ntest   %dil,%dil\njne    1868 <getNumNeigbors+0x198>\nmov    0x8(%r8,%r9,8),%r11\nmovzbl -0x1(%r11,%rsi,1),%r11d\ncmp    %dl,%r11b\nsete   %r11b\nmovzbl %r11b,%r11d\nadd    %r11d,%eax\ncmp    $0x15,%ecx\nsete   %cl\ntest   %r10b,%r10b\njne    1858 <getNumNeigbors+0x188>\ntest   %cl,%cl\njne    1858 <getNumNeigbors+0x188>\nmov    -0x8(%r8,%r9,8),%r10\nmovzbl 0x1(%r10,%rsi,1),%r10d\ncmp    %dl,%r10b\nsete   %r10b\nmovzbl %r10b,%r10d\nadd    %r10d,%eax\ntest   %dil,%dil\njne    1840 <getNumNeigbors+0x170>\ntest   %cl,%cl\njne    1840 <getNumNeigbors+0x170>\nmov    0x8(%r8,%r9,8),%rcx\npop    %rbx\nmovzbl 0x1(%rcx,%rsi,1),%ecx\ncmp    %dl,%cl\nsete   %dl\nmovzbl %dl,%edx\nadd    %edx,%eax\nret\nnopw   0x0(%rax,%rax,1)\ncmp    %dl,0x57f8(%rip)\njne    174b <getNumNeigbors+0x7b>\nadd    $0x1,%eax\njmp    173e <getNumNeigbors+0x6e>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncmp    %dl,0x57de(%rip)\nsete   %al\njmp    170f <getNumNeigbors+0x3f>\nmovzbl 0x57cf(%rip),%ecx\npop    %rbx\ncmp    %dl,%cl\nsete   %dl\nmovzbl %dl,%edx\nadd    %edx,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmovzbl 0x57b6(%rip),%r10d\njmp    17e5 <getNumNeigbors+0x115>\nnopl   (%rax)\nmovzbl 0x57a6(%rip),%r11d\njmp    17b9 <getNumNeigbors+0xe9>\nnopl   (%rax)\nmovzbl 0x5797(%rip),%ebx\njmp    178b <getNumNeigbors+0xbb>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "life/life.c", "function_name": "getRight", "content": "char\ngetRight(int x, int y)\n{\n  if (x == GRID_WIDTH - 1)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x + 1][y];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "getRight", "address": "0x1900", "label": "getRight", "content": "char __fastcall getRight(int x, int y)\n{\n  if ( x == 69 )\n    return DEAD[0];\n  else\n    return grid[x + 1][y];\n}\n"}, "pseudo_normalize": "char getRight(int x, int y) {\n  if (x == 69)\n    return DEAD[0];\n  else\n    return grid[x + 1][y];\n}", "binary": "life/life.host.O3", "assembly": "<getRight>:\nendbr64\ncmp    $0x45,%edi\nje     1920 <getRight+0x20>\nmov    0x5718(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x8(%rax,%rdi,8),%rax\nmovzbl (%rax,%rsi,1),%eax\nret\nmovzbl 0x56ef(%rip),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "getUp", "content": "char\ngetUp(int x, int y)\n{\n  if (y == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x][y - 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "getUp", "address": "0x1930", "label": "getUp", "content": "char __fastcall getUp(int x, int y)\n{\n  if ( y )\n    return grid[x][y - 1];\n  else\n    return DEAD[0];\n}\n"}, "pseudo_normalize": "char getUp(int x, int y) {\n  if (y)\n    return grid[x][y - 1];\n  else\n    return DEAD[0];\n}", "binary": "life/life.host.O3", "assembly": "<getUp>:\nendbr64\ntest   %esi,%esi\nje     1950 <getUp+0x20>\nmov    0x56e9(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    (%rax,%rdi,8),%rax\nmovzbl -0x1(%rax,%rsi,1),%eax\nret\nnop\nmovzbl 0x56bf(%rip),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "getUpLeft", "content": "char\ngetUpLeft(int x, int y)\n{\n  if (x == 0 || y == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x - 1][y - 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "getUpLeft", "address": "0x1990", "label": "getUpLeft", "content": "char __fastcall getUpLeft(int x, int y)\n{\n  if ( x && y )\n    return grid[x - 1][y - 1];\n  else\n    return DEAD[0];\n}\n"}, "pseudo_normalize": "char getUpLeft(int x, int y) {\n  if (x && y)\n    return grid[x - 1][y - 1];\n  else\n    return DEAD[0];\n}", "binary": "life/life.host.O3", "assembly": "<getUpLeft>:\nendbr64\ntest   %edi,%edi\nje     19b8 <getUpLeft+0x28>\ntest   %esi,%esi\nje     19b8 <getUpLeft+0x28>\nmov    0x5685(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    -0x8(%rax,%rdi,8),%rax\nmovzbl -0x1(%rax,%rsi,1),%eax\nret\nnopl   0x0(%rax)\nmovzbl 0x5657(%rip),%eax\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getUpRight", "content": "char\ngetUpRight(int x, int y)\n{\n  if (x == GRID_WIDTH - 1 || y == 0)\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x + 1][y - 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "getUpRight", "address": "0x19c0", "label": "getUpRight", "content": "char __fastcall getUpRight(int x, int y)\n{\n  if ( x == 69 || !y )\n    return DEAD[0];\n  else\n    return grid[x + 1][y - 1];\n}\n"}, "pseudo_normalize": "char getUpRight(int x, int y) {\n  if (x == 69 || !y)\n    return DEAD[0];\n  else\n    return grid[x + 1][y - 1];\n}", "binary": "life/life.host.O3", "assembly": "<getUpRight>:\nendbr64\ncmp    $0x45,%edi\nje     19e8 <getUpRight+0x28>\ntest   %esi,%esi\nje     19e8 <getUpRight+0x28>\nmov    0x5654(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x8(%rax,%rdi,8),%rax\nmovzbl -0x1(%rax,%rsi,1),%eax\nret\nnopl   (%rax)\nmovzbl 0x5627(%rip),%eax\nret\n"}
{"source": {"path": "life/life.c", "function_name": "init", "content": "void\ninit(void)\n{ \n  libmin_srand(1001);\n  for (int x = 0; x < GRID_WIDTH; ++x)\n    {\n      grid[x] = gridVals[x];\n      gridTmp[x] = gridTmpVals[x];\n      for (int y = 0; y < GRID_HEIGHT; ++y)\n        {\n          grid[x][y] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n          gridTmp[x][y] = ' ';\n        }\n    }\n\n  // clear the screen\n  libmin_printf(\"\\x1b[2J\");\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "init", "address": "0x12c0", "label": "init", "content": "void __cdecl init()\n{\n  __int64 v0; // r15\n  __int64 v1; // r12\n  __int64 v2; // rbx\n\n  v0 = 0LL;\n  v1 = 0LL;\n  libmin_srand(0x3E9u);\n  do\n  {\n    v2 = 0LL;\n    grid[v0] = &gridVals[v1];\n    gridTmp[v0] = &gridTmpVals[v1];\n    do\n    {\n      grid[v0][v2] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[v0][v2++] = 32;\n    }\n    while ( v2 != 22 );\n    v1 += 22LL;\n    ++v0;\n  }\n  while ( v1 != 1540 );\n  libmin_printf(\"\\x1B[2J\");\n}\n"}, "pseudo_normalize": "void init() {\n  long long v0;\n  long long v1;\n  long long v2;\n  v0 = 0LL;\n  v1 = 0LL;\n  libmin_srand(1001u);\n  do {\n    v2 = 0LL;\n    grid[v0] = &gridVals[v1];\n    gridTmp[v0] = &gridTmpVals[v1];\n    do {\n      grid[v0][v2] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[v0][v2++] = 32;\n    } while (v2 != 22);\n    v1 += 22LL;\n    ++v0;\n  } while (v1 != 1540);\n  libmin_printf(\"\\x1B[2J\");\n}", "binary": "life/life.host.O3", "assembly": "<init>:\nendbr64\npush   %r15\nmov    $0x3e9,%edi\nxor    %r15d,%r15d\npush   %r14\nlea    0x6609(%rip),%r14\npush   %r13\nlea    0x5fe0(%rip),%r13\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nlea    0x5d27(%rip),%rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   3d80 <libmin_srand>\nnopw   0x0(%rax,%rax,1)\nmov    0x5d21(%rip),%rax\nlea    (%r14,%r12,1),%rdx\nxor    %ebx,%ebx\nmov    %rdx,(%rax,%r15,1)\nmov    0x5d08(%rip),%rax\nlea    0x0(%r13,%r12,1),%rdx\nmov    %rdx,(%rax,%r15,1)\nnopl   0x0(%rax)\ncall   3de0 <libmin_rand>\nxor    %edx,%edx\ndivl   0x5ce3(%rip)\nmov    0x5cec(%rip),%rax\nmov    (%rax,%r15,1),%rax\nmovzbl 0x0(%rbp,%rdx,1),%edx\nmov    %dl,(%rax,%rbx,1)\nmov    0x5cd1(%rip),%rax\nmov    (%rax,%r15,1),%rax\nmovb   $0x20,(%rax,%rbx,1)\nadd    $0x1,%rbx\ncmp    $0x16,%rbx\njne    1328 <init+0x68>\nadd    $0x16,%r12\nadd    $0x8,%r15\ncmp    $0x604,%r12\njne    1300 <init+0x40>\nadd    $0x8,%rsp\nlea    0x3c87(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    3b70 <libmin_printf>\nxchg   %ax,%ax\n"}
{"source": {"path": "life/life.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int iters = 0;\n\n  init();\n  int running = TRUE;\n  while (running) {\n    draw();\n    //sleep(500);\n    process();\n    iters++;\n    if (iters == 80)\n      running = FALSE;\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r12d\n  __int64 v4; // rbx\n  unsigned int v5; // esi\n  __int64 v6; // rdx\n  __int64 v7; // [rsp+8h] [rbp-40h]\n\n  v3 = 80;\n  init();\n  while ( 1 )\n  {\n    v4 = 0LL;\n    libmin_printf(\"\\x1B[H\", argv);\n    v5 = evolution++;\n    libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v5);\n    do\n    {\n      v6 = 0LL;\n      do\n      {\n        v7 = v6;\n        argv = (const char **)(unsigned int)(*(char **)((char *)grid + v6))[v4];\n        libmin_printf(\"%c\", argv);\n        v6 = v7 + 8;\n      }\n      while ( v7 != 552 );\n      ++v4;\n      libmin_printf(\"\\n\");\n    }\n    while ( v4 != 22 );\n    process();\n    if ( !--v3 )\n      libmin_success();\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  long long v4;\n  unsigned int v5;\n  long long v6;\n  long long v7;\n  v3 = 80;\n  init();\n  while (1) {\n    v4 = 0LL;\n    libmin_printf(\"\\x1B[H\", argv);\n    v5 = evolution++;\n    libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v5);\n    do {\n      v6 = 0LL;\n      do {\n        v7 = v6;\n        argv = (const char **)(unsigned int)(*(char **)((char *)grid + v6))[v4];\n        libmin_printf(\"%c\", argv);\n        v6 = v7 + 8;\n      } while (v7 != 552);\n      ++v4;\n      libmin_printf(\"\\n\");\n    } while (v4 != 22);\n    process();\n    if (!--v3) libmin_success();\n  }\n}", "binary": "life/life.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nlea    0x3efc(%rip),%r15\npush   %r14\nlea    0x3f02(%rip),%r14\npush   %r13\nlea    0x3eee(%rip),%r13\npush   %r12\nmov    $0x50,%r12d\npush   %rbp\nlea    0x3ee1(%rip),%rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   12c0 <init>\nmov    %r15,%rdi\nxor    %eax,%eax\nxor    %ebx,%ebx\ncall   3b70 <libmin_printf>\nmov    0x5ec5(%rip),%esi\nmov    %r14,%rdi\nlea    0x1(%rsi),%eax\nmov    %eax,0x5eb9(%rip)\nxor    %eax,%eax\ncall   3b70 <libmin_printf>\nxchg   %ax,%ax\nxor    %edx,%edx\nnopw   0x0(%rax,%rax,1)\nmov    0x5eb9(%rip),%rax\nmov    %r13,%rdi\nmov    %rdx,0x8(%rsp)\nmov    (%rax,%rdx,1),%rax\nmovsbl (%rax,%rbx,1),%esi\nxor    %eax,%eax\ncall   3b70 <libmin_printf>\nmov    0x8(%rsp),%rdx\nadd    $0x8,%rdx\ncmp    $0x230,%rdx\njne    1168 <main+0x68>\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   3b70 <libmin_printf>\ncmp    $0x16,%rbx\njne    1160 <main+0x60>\ncall   1430 <process>\nsub    $0x1,%r12d\njne    1139 <main+0x39>\ncall   3fd0 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\n"}
{"source": {"path": "life/life.c", "function_name": "process", "content": "void\nprocess(void)\n{\n  for (int y = 0; y < GRID_HEIGHT; ++y)\n    {\n      for (int x = 0; x < GRID_WIDTH; ++x)\n        {\n          int neighbors = getNumNeigbors(x, y);\n          if (grid[x][y] == LIVE)\n            {\n              //1. Any live cell with fewer than two live neighbors dies, as if caused by underpopulation.\n              //2. Any live cell with more than three live neighbors dies, as if by overcrowding.\n              if (neighbors < 2 || neighbors > 3)\n                gridTmp[x][y] = DEAD;\n              else\n                gridTmp[x][y] = LIVE;\n              //3. Any live cell with two or three live neighbors lives on to the next generation.\n            }\n          else\n            {\n              //4. Any dead cell with exactly three live neighbors becomes a live cell.\n              if (neighbors == 3)\n                gridTmp[x][y] = LIVE;\n              else\n                gridTmp[x][y] = DEAD;\n            }\n          processMutate(x, y);\n        }\n    }\n    flip();\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "process", "address": "0x1430", "label": "process", "content": "void __cdecl process()\n{\n  __int64 v0; // r15\n  __int64 v1; // rbp\n  __int64 v2; // r12\n  __int64 v3; // rbx\n  int i; // r13d\n  char v5; // si\n  _BOOL4 v6; // eax\n  int v7; // eax\n  __int64 v8; // rsi\n  char v9; // r8\n  int v10; // eax\n  char v11; // r8\n  int v12; // eax\n  char v13; // r11\n  int v14; // eax\n  char v15; // r9\n  int v16; // eax\n  char v17; // cl\n  int v18; // eax\n  char v19; // dl\n  __int64 v20; // rdi\n  char **v21; // rdx\n\n  v0 = 0LL;\n  v1 = -1LL;\n  v2 = 1LL;\n  do\n  {\n    v3 = 1LL;\n    for ( i = 0; i != 70; ++i )\n    {\n      v19 = LIVE[0];\n      v20 = v3 * 8 - 8;\n      if ( i )\n      {\n        v5 = DEAD[0];\n        v6 = grid[v3 - 2][v0] == LIVE[0];\n        if ( i == 69 )\n          goto LABEL_5;\n      }\n      else\n      {\n        v6 = DEAD[0] == LIVE[0];\n      }\n      v5 = grid[v3][v0];\nLABEL_5:\n      v7 = (LIVE[0] == (unsigned __int8)v5) + v6;\n      v8 = *(__int64 *)((char *)grid + v20);\n      if ( (_DWORD)v0 )\n      {\n        if ( LIVE[0] != *(_BYTE *)(v8 + v1) )\n          goto LABEL_7;\n      }\n      else if ( LIVE[0] != DEAD[0] )\n      {\nLABEL_8:\n        v9 = *(_BYTE *)(v8 + v2);\n        goto LABEL_9;\n      }\n      ++v7;\nLABEL_7:\n      v9 = DEAD[0];\n      if ( (_DWORD)v0 != 21 )\n        goto LABEL_8;\nLABEL_9:\n      v10 = (LIVE[0] == (unsigned __int8)v9) + v7;\n      if ( i && (_DWORD)v0 )\n        v11 = grid[v3 - 2][v1];\n      else\n        v11 = DEAD[0];\n      v12 = (LIVE[0] == (unsigned __int8)v11) + v10;\n      if ( i == 69 || !(_DWORD)v0 )\n        v13 = DEAD[0];\n      else\n        v13 = grid[v3][v1];\n      v14 = (LIVE[0] == (unsigned __int8)v13) + v12;\n      if ( !i || (_DWORD)v0 == 21 )\n        v15 = DEAD[0];\n      else\n        v15 = grid[v3 - 2][v2];\n      v16 = (LIVE[0] == (unsigned __int8)v15) + v14;\n      if ( i == 69 || (_DWORD)v0 == 21 )\n        v17 = DEAD[0];\n      else\n        v17 = grid[v3][v2];\n      v18 = (LIVE[0] == (unsigned __int8)v17) + v16;\n      if ( *(_BYTE *)(v8 + v0) == LIVE[0] )\n      {\n        if ( (unsigned int)(v18 - 2) > 1 )\n          v19 = DEAD[0];\n      }\n      else if ( v18 != 3 )\n      {\n        v19 = DEAD[0];\n      }\n      (*(char **)((char *)gridTmp + v20))[v0] = v19;\n      ++v3;\n      libmin_rand();\n    }\n    ++v0;\n    ++v2;\n    ++v1;\n  }\n  while ( v0 != 22 );\n  v21 = gridTmp;\n  gridTmp = grid;\n  grid = v21;\n}\n"}, "pseudo_normalize": "void process() {\n  long long v0;\n  long long v1;\n  long long v2;\n  long long v3;\n  int i;\n  char v5;\n  int v6;\n  int v7;\n  long long v8;\n  char v9;\n  int v10;\n  char v11;\n  int v12;\n  char v13;\n  int v14;\n  char v15;\n  int v16;\n  char v17;\n  int v18;\n  char v19;\n  long long v20;\n  char **v21;\n  v0 = 0LL;\n  v1 = -1LL;\n  v2 = 1LL;\n  do {\n    v3 = 1LL;\n    for (i = 0; i != 70; ++i) {\n      v19 = LIVE[0];\n      v20 = v3 * 8 - 8;\n      if (i) {\n        v5 = DEAD[0];\n        v6 = grid[v3 - 2][v0] == LIVE[0];\n        if (i == 69) goto LABEL_5;\n      } else {\n        v6 = DEAD[0] == LIVE[0];\n      }\n      v5 = grid[v3][v0];\n    LABEL_5:\n      v7 = (LIVE[0] == (unsigned char)v5) + v6;\n      v8 = *(long long *)((char *)grid + v20);\n      if ((uint32_t)v0) {\n        if (LIVE[0] != *(uint8_t *)(v8 + v1)) goto LABEL_7;\n      } else if (LIVE[0] != DEAD[0]) {\n      LABEL_8:\n        v9 = *(uint8_t *)(v8 + v2);\n        goto LABEL_9;\n      }\n      ++v7;\n    LABEL_7:\n      v9 = DEAD[0];\n      if ((uint32_t)v0 != 21) goto LABEL_8;\n    LABEL_9:\n      v10 = (LIVE[0] == (unsigned char)v9) + v7;\n      if (i && (uint32_t)v0)\n        v11 = grid[v3 - 2][v1];\n      else\n        v11 = DEAD[0];\n      v12 = (LIVE[0] == (unsigned char)v11) + v10;\n      if (i == 69 || !(uint32_t)v0)\n        v13 = DEAD[0];\n      else\n        v13 = grid[v3][v1];\n      v14 = (LIVE[0] == (unsigned char)v13) + v12;\n      if (!i || (uint32_t)v0 == 21)\n        v15 = DEAD[0];\n      else\n        v15 = grid[v3 - 2][v2];\n      v16 = (LIVE[0] == (unsigned char)v15) + v14;\n      if (i == 69 || (uint32_t)v0 == 21)\n        v17 = DEAD[0];\n      else\n        v17 = grid[v3][v2];\n      v18 = (LIVE[0] == (unsigned char)v17) + v16;\n      if (*(uint8_t *)(v8 + v0) == LIVE[0]) {\n        if ((unsigned int)(v18 - 2) > 1) v19 = DEAD[0];\n      } else if (v18 != 3) {\n        v19 = DEAD[0];\n      }\n      (*(char **)((char *)gridTmp + v20))[v0] = v19;\n      ++v3;\n      libmin_rand();\n    }\n    ++v0;\n    ++v2;\n    ++v1;\n  } while (v0 != 22);\n  v21 = gridTmp;\n  gridTmp = grid;\n  grid = v21;\n}", "binary": "life/life.host.O3", "assembly": "<process>:\nendbr64\npush   %r15\nxor    %r15d,%r15d\npush   %r14\npush   %r13\npush   %r12\nmov    $0xffffffffffffffff,%r12\npush   %rbp\nmov    $0x1,%ebp\npush   %rbx\nmov    %rbp,%rax\nmov    %r12,%rbp\nmov    %rax,%r12\nsub    $0x18,%rsp\nnopw   0x0(%rax,%rax,1)\ntest   %r15d,%r15d\nmov    %r15d,0x8(%rsp)\nmov    $0x8,%ebx\nsete   0xf(%rsp)\ncmp    $0x15,%r15d\nsete   %r14b\nxor    %r13d,%r13d\njmp    15e3 <process+0x1b3>\nnopw   0x0(%rax,%rax,1)\nmov    -0x10(%rcx,%rbx,1),%rax\nmovzbl 0x5b82(%rip),%esi\ncmp    %dl,(%rax,%r15,1)\nsete   %al\nmovzbl %al,%eax\ncmp    $0x45,%r13d\nje     14ad <process+0x7d>\nmov    (%rcx,%rbx,1),%rsi\nmovzbl (%rsi,%r15,1),%esi\ncmp    %sil,%dl\nmov    0x8(%rsp),%r8d\nsete   %sil\nmovzbl %sil,%esi\nadd    %esi,%eax\nmov    (%rcx,%rdi,1),%rsi\ntest   %r8d,%r8d\nje     1668 <process+0x238>\ncmp    (%rsi,%rbp,1),%dl\nje     1674 <process+0x244>\ncmpl   $0x15,0x8(%rsp)\nmovzbl 0x5b34(%rip),%r8d\nje     14e9 <process+0xb9>\nmovzbl (%rsi,%r12,1),%r8d\ncmp    %r8b,%dl\nsete   %r8b\nmovzbl %r8b,%r8d\nadd    %r8d,%eax\ntest   %r13d,%r13d\nsete   %r9b\nje     1658 <process+0x228>\ncmpb   $0x0,0xf(%rsp)\njne    1658 <process+0x228>\nmov    -0x10(%rcx,%rbx,1),%r8\nmovzbl (%r8,%rbp,1),%r8d\ncmp    %r8b,%dl\nsete   %r8b\nmovzbl %r8b,%r8d\nadd    %r8d,%eax\ncmp    $0x45,%r13d\nsete   %r8b\nje     1648 <process+0x218>\ncmpb   $0x0,0xf(%rsp)\njne    1648 <process+0x218>\nmov    (%rcx,%rbx,1),%r11\nmovzbl (%r11,%rbp,1),%r11d\ncmp    %r11b,%dl\nsete   %r11b\nmovzbl %r11b,%r11d\nadd    %r11d,%eax\ntest   %r9b,%r9b\njne    1638 <process+0x208>\ntest   %r14b,%r14b\njne    1638 <process+0x208>\nmov    -0x10(%rcx,%rbx,1),%r9\nmovzbl (%r9,%r12,1),%r9d\ncmp    %r9b,%dl\nsete   %r9b\nmovzbl %r9b,%r9d\nadd    %r9d,%eax\ntest   %r8b,%r8b\njne    1628 <process+0x1f8>\ntest   %r14b,%r14b\njne    1628 <process+0x1f8>\nmov    (%rcx,%rbx,1),%rcx\nmovzbl (%rcx,%r12,1),%ecx\ncmp    %cl,%dl\nsete   %cl\nmovzbl %cl,%ecx\nadd    %ecx,%eax\nmov    0x5a73(%rip),%rcx\nmov    (%rcx,%rdi,1),%r10\nadd    %r15,%r10\nmov    %r10,%rcx\ncmp    %dl,(%rsi,%r15,1)\nje     1610 <process+0x1e0>\ncmp    $0x3,%eax\nmovzbl 0x5a4f(%rip),%eax\ncmovne %eax,%edx\nmov    %dl,(%rcx)\nadd    $0x1,%r13d\nadd    $0x8,%rbx\ncall   3de0 <libmin_rand>\ncmp    $0x46,%r13d\nje     1680 <process+0x250>\nmov    0x5a3e(%rip),%rcx\nmovzbl 0x5a26(%rip),%edx\nlea    -0x8(%rbx),%rdi\ntest   %r13d,%r13d\njne    1488 <process+0x58>\nxor    %eax,%eax\ncmp    %dl,0x5a10(%rip)\nsete   %al\njmp    14a4 <process+0x74>\nxchg   %ax,%ax\nsub    $0x2,%eax\ncmp    $0x1,%eax\nmovzbl 0x59f9(%rip),%eax\ncmova  %eax,%edx\njmp    15ca <process+0x19a>\nnopw   0x0(%rax,%rax,1)\nmovzbl 0x59e7(%rip),%ecx\njmp    159c <process+0x16c>\nnopl   0x0(%rax)\nmovzbl 0x59d6(%rip),%r9d\njmp    1573 <process+0x143>\nnopl   (%rax)\nmovzbl 0x59c6(%rip),%r11d\njmp    1549 <process+0x119>\nnopl   (%rax)\nmovzbl 0x59b6(%rip),%r8d\njmp    1519 <process+0xe9>\nnopl   (%rax)\ncmp    0x59a8(%rip),%dl\njne    14e4 <process+0xb4>\nadd    $0x1,%eax\njmp    14d5 <process+0xa5>\nnopl   0x0(%rax)\nadd    $0x1,%r15\nadd    $0x1,%r12\nadd    $0x1,%rbp\ncmp    $0x16,%r15\njne    1460 <process+0x30>\nmov    0x598b(%rip),%rax\nmov    0x597c(%rip),%rdx\nmov    %rax,0x5975(%rip)\nmov    %rdx,0x5976(%rip)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "life/life.c", "function_name": "processMutate", "content": "void\nprocessMutate(int x, int y)\n{\n  if (libmin_rand() % 3000 > 2927)\n    {\n      if (gridTmp[x][y] == DEAD)\n        ; // gridTmp[x][y] = LIVE;\n    }\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "processMutate", "address": "0x1890", "label": "processMutate", "content": "void __fastcall processMutate(int x, int y)\n{\n  libmin_rand();\n}\n"}, "pseudo_normalize": "", "binary": "life/life.host.O3", "assembly": "<processMutate>:\nendbr64\njmp    3de0 <libmin_rand>\nnopl   0x0(%rax)\n"}
{"source": {"path": "life/life.c", "function_name": "sleep", "content": "void\nsleep(unsigned int mseconds)\n{\n  x = 0;\n  while (x < MS_DELAY)\n    x++;\n}\n"}, "pseudo": {"path": "life/life.host.O3.pseudo", "function_name": "sleep", "address": "0x1a60", "label": "sleep", "content": "void __fastcall sleep(unsigned int mseconds)\n{\n  x = 0;\n  do\n    ++x;\n  while ( x <= 0 );\n}\n"}, "pseudo_normalize": "", "binary": "life/life.host.O3", "assembly": "<sleep>:\nendbr64\nmovl   $0x0,0x5832(%rip)\nmov    0x582c(%rip),%eax\ntest   %eax,%eax\njg     1a99 <sleep+0x39>\nnopl   0x0(%rax,%rax,1)\nmov    0x581a(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x5811(%rip)\nmov    0x580b(%rip),%eax\ntest   %eax,%eax\njle    1a80 <sleep+0x20>\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "cut_off", "content": "/* Creates a new string by cutting the given number of characters off\n   the front of source */\n\nchar *\ncut_off(char *source, int n)\n{\n\tint k;\n\tchar *res;\n\n\tif((n <= 0)||(source == NULL))return NULL;\n\tk = libmin_strlen(source);\n\tk = ( n > k ? k : n );\n\tres = (char *)libmin_calloc(sizeof(char),(k+1));\n\tif(res == NULL){\n\t\tlibmin_printf(\"cut_off: Unable to malloc\\n\");\n\t\treturn NULL;\n\t}\n\tlibmin_strncpy(res,source,k);\n\treturn res;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O3.pseudo", "function_name": "cut_off", "address": "0x2040", "label": "cut_off", "content": "char *__fastcall cut_off(char *source, int n)\n{\n  int v2; // ebx\n  int v3; // eax\n  char *v4; // rax\n  char *v5; // r12\n\n  if ( n <= 0 || !source )\n    return 0LL;\n  v2 = n;\n  v3 = libmin_strlen(source);\n  if ( n > v3 )\n    v2 = v3;\n  v4 = (char *)libmin_calloc(1uLL, v2 + 1);\n  v5 = v4;\n  if ( v4 )\n    libmin_strncpy(v4, source, v2);\n  else\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n  return v5;\n}\n"}, "pseudo_normalize": "char *cut_off(char *source, int n) {\n  int v2;\n  int v3;\n  char *v4;\n  char *v5;\n  if (n <= 0 || !source) return 0LL;\n  v2 = n;\n  v3 = libmin_strlen(source);\n  if (n > v3) v2 = v3;\n  v4 = (char *)libmin_calloc(1uLL, v2 + 1);\n  v5 = v4;\n  if (v4)\n    libmin_strncpy(v4, source, v2);\n  else\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n  return v5;\n}", "binary": "longdiv/longdiv.host.O3", "assembly": "<cut_off>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\ntest   %esi,%esi\njle    2090 <cut_off+0x50>\nmov    %rdi,%rbp\ntest   %rdi,%rdi\nje     2090 <cut_off+0x50>\nmov    %esi,%ebx\ncall   4890 <libmin_strlen>\nmov    $0x1,%edi\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\nlea    0x1(%rbx),%esi\nmovslq %esi,%rsi\ncall   2430 <libmin_calloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     20a0 <cut_off+0x60>\nmovslq %ebx,%rdx\nmov    %rbp,%rsi\nmov    %rax,%rdi\ncall   48c0 <libmin_strncpy>\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\nxchg   %ax,%ax\nxor    %r12d,%r12d\npop    %rbx\npop    %rbp\nmov    %r12,%rax\npop    %r12\nret\nnopl   0x0(%rax,%rax,1)\nlea    0x2f98(%rip),%rdi\nxor    %eax,%eax\ncall   4620 <libmin_printf>\njmp    2086 <cut_off+0x46>\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "isgte", "content": "/* Isgte: returns TRUE if first digit string is >=  the second */\n\nint\nisgte( char *A, char *B)\n{\n\tint a,b,i;\n\tchar *AA, *BB;\n\n\tif(B==NULL) return TRUE;\n\tif(A==NULL) return FALSE;\n\n/* Normalize by stripping off leading zeros */\n\n\tAA = libmin_strpbrk(A,DIGITS);\n\tBB = libmin_strpbrk(B,DIGITS);\n\n\tif(BB == NULL) return TRUE;\n\tif(AA == NULL) return FALSE;  \n\n\tif((b=libmin_strlen(BB ))>(a=libmin_strlen(AA)))return FALSE;\n\tif(a > b) return TRUE;\n\t\n\tfor(i=0;i<b;i++){\n\t\tif(AA[i]>BB[i]) return TRUE;\n\t\tif(AA[i]<BB[i]) return FALSE;\n\t}\n\treturn TRUE;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O3.pseudo", "function_name": "isgte", "address": "0x1ab0", "label": "isgte", "content": "int __fastcall isgte(char *A, char *B)\n{\n  char *v2; // rbx\n  char *v3; // rax\n  char *v4; // rbp\n  int v5; // r12d\n  int v6; // eax\n  __int64 i; // rdx\n  char v8; // al\n\n  if ( !B )\n    return 1;\n  if ( !A )\n    return 0;\n  v2 = libmin_strpbrk(A, \"123456789\");\n  v3 = libmin_strpbrk(B, \"123456789\");\n  v4 = v3;\n  if ( !v3 )\n    return 1;\n  if ( v2 )\n  {\n    v5 = libmin_strlen(v3);\n    v6 = libmin_strlen(v2);\n    if ( v5 <= v6 )\n    {\n      if ( v5 >= v6 && v5 > 0 )\n      {\n        for ( i = 0LL; ; ++i )\n        {\n          v8 = v4[i];\n          if ( v2[i] > v8 )\n            break;\n          if ( v2[i] < v8 )\n            return 0;\n          if ( v5 - 1 == i )\n            break;\n        }\n      }\n      return 1;\n    }\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int isgte(char *A, char *B) {\n  char *v2;\n  char *v3;\n  char *v4;\n  int v5;\n  int v6;\n  long long i;\n  char v8;\n  if (!B) return 1;\n  if (!A) return 0;\n  v2 = libmin_strpbrk(A, \"123456789\");\n  v3 = libmin_strpbrk(B, \"123456789\");\n  v4 = v3;\n  if (!v3) return 1;\n  if (v2) {\n    v5 = libmin_strlen(v3);\n    v6 = libmin_strlen(v2);\n    if (v5 <= v6) {\n      if (v5 >= v6 && v5 > 0) {\n        for (i = 0LL;; ++i) {\n          v8 = v4[i];\n          if (v2[i] > v8) break;\n          if (v2[i] < v8) return 0;\n          if (v5 - 1 == i) break;\n        }\n      }\n      return 1;\n    }\n  }\n  return 0;\n}", "binary": "longdiv/longdiv.host.O3", "assembly": "<isgte>:\nendbr64\ntest   %rsi,%rsi\nje     1b58 <isgte+0xa8>\ntest   %rdi,%rdi\nje     1b50 <isgte+0xa0>\npush   %r12\nlea    0x3535(%rip),%r12\npush   %rbp\nmov    %rsi,%rbp\nmov    %r12,%rsi\npush   %rbx\ncall   4910 <libmin_strpbrk>\nmov    %rbp,%rdi\nmov    %r12,%rsi\nmov    %rax,%rbx\ncall   4910 <libmin_strpbrk>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     1b38 <isgte+0x88>\ntest   %rbx,%rbx\nje     1b48 <isgte+0x98>\nmov    %rax,%rdi\ncall   4890 <libmin_strlen>\nmov    %rbx,%rdi\nmov    %rax,%r12\ncall   4890 <libmin_strlen>\ncmp    %eax,%r12d\njg     1b48 <isgte+0x98>\njl     1b38 <isgte+0x88>\ntest   %r12d,%r12d\njle    1b38 <isgte+0x88>\nlea    -0x1(%r12),%ecx\nxor    %edx,%edx\njmp    1b2e <isgte+0x7e>\nnop\njl     1b48 <isgte+0x98>\nlea    0x1(%rdx),%rax\ncmp    %rdx,%rcx\nje     1b38 <isgte+0x88>\nmov    %rax,%rdx\nmovzbl 0x0(%rbp,%rdx,1),%eax\ncmp    %al,(%rbx,%rdx,1)\njle    1b20 <isgte+0x70>\npop    %rbx\nmov    $0x1,%eax\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\npop    %rbx\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\nnop\nxor    %eax,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "main", "content": "int \nmain(void)\n{\n\tint dsr_len,ddnd_len;\n\tint dgts_fwd;   /* digits carried forward from previous step */\n\tint i,j,k;\n\tint step = 0;\n\tchar *quotient;\n\tchar *dsr;             /* Divisor */\n\tchar *ddnds[128];   /* Successive dividends */\n\tchar *shends[128]; /* Successive subtrahends */\n\tchar *mend;  /* Current minuend: see example below */\n\tchar *pend;  /* Points to 1st char beyond current minuend */\n\tchar *ptr;\n\n\t/* Do sanity checks on args */\n\n\tfor(i=0; i<libmin_strlen(argv[1]); i++)\n\t\tif(!isdigit(argv[1][i])){\n\t\t\tlibmin_printf(\"%s\\n%s\\n\",\"longdiv: syntax error\",\n\t\t\t\targv[1]);\n\t\t\tfor(j=0;j<i;j++)libmin_putc(' ');\n\t\t\tlibmin_putc('^');\n\t\t\tlibmin_putc('\\n');\n\t\t\treturn FALSE;\n\t\t}\n\n\tfor(i=0; i<libmin_strlen(argv[2]); i++)\n\t\tif(!isdigit(argv[2][i])){\n\t\t\tlibmin_printf(\"%s\\n%s\\n\",\"longdiv: syntax error\",\n\t\t\t\targv[2]);\n\t\t\tfor(j=0;j<i;j++)libmin_putc(' ');\n\t\t\tlibmin_putc('^');\n\t\t\tlibmin_putc('\\n');\n\t\t\treturn FALSE;\n\t\t}\n\n\t/* Make sure we're not dividing by 0 */\n\n\tj = TRUE; /* Guilty, till proven innocent */\n\tfor(i=0;i<libmin_strlen(argv[2]);i++)\n\t\tif(argv[2][i] != '0'){j = FALSE; break; }\n\tif(j){\n\t\tlibmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n\t\treturn FALSE;\n\t}\n\n\t/* OK, lookin' good */\n\t/* Save divisor and dividend */\n\n\tif((ptr = libmin_strpbrk(argv[1],DIGITS))==NULL)\n\t\t ddnd_len = 1;\n\telse \n\t   ddnd_len = libmin_strlen(ptr);\n\tddnds[0] = (char *)libmin_malloc((ddnd_len+1)*sizeof(char));\n\tif(ptr == NULL)\n\t\tlibmin_strcpy(ddnds[0],\"0\");\n\telse\n\t        libmin_strcpy(ddnds[0],ptr);\n\tptr = libmin_strpbrk(argv[2],DIGITS);\n\tdsr_len = libmin_strlen(ptr);\n\tdsr = (char *)libmin_malloc((dsr_len+1)*sizeof(char));\n\tlibmin_strcpy(dsr,ptr);\n\n\tdgts_fwd = dsr_len-1; /* Turns out to be the right initialization */\n\n\t/* Reserve space for, and properly terminate, quotient */\n\n\tquotient = (char *)libmin_calloc(sizeof(char),ddnd_len+1);\n\n\t/* stick an appropriate number of leading zeros on quotient */\n\t/* These will be stripped in the printout */\n\n\tfor(j=0;j<dsr_len-1;j++)quotient[j]='0';\n\n\t/* The algorithm breaks into steps, each of which involves a\n\t   set of trial multiplications and a subtraction. \n\t   As a try at the first minuend, we take the first n digits of\n\t   the first dividend, where n is length of the divisor. To\n\t   clarify the terminology, consider the problem:\n\n\t\t9\n          _______________________\n   3213   ) 29946712\n\t    28917\n\t    -------\n\t       29\n\t\n\tHere, the first minuend is 29546, the first subtrahend is\n\t28917, and dgts_fwd is 2.  This was step = 0.  \n        The next dividend will be 29712, and the next minuend will be gotten\n        by taking the appropriate initial string from it. \n\t*/\n\t\n        while(isgte(ddnds[step],dsr)){  /* loop until dividend shorter than\n                                             divisor. When we exit the loop,\n                                             the last dividend is the remainder\n\t\t\t\t\t*/\n\n\t  /* Determine the next minuend */\n\t  mend = cut_off(ddnds[step],++dgts_fwd);\t\n\t  while(!isgte(mend,dsr)){\n\t\tlibmin_strcat(quotient,\"0\");\n\t\tlibmin_free(mend);\n\t\tmend = cut_off(ddnds[step],++dgts_fwd);\n\t  } \n\n\t  pend = ddnds[step]+libmin_strlen(mend); /* Set pointer to rest of dividend that\n\t\t\t\t\t will be spliced on to form the\n                                         next dividend. (points to 7 in example\n\t\t\t\t\t above. */\n\n\t/* Now we do some \"trial multiplications\" to determine the next\n           digit of the quotient. */\n\n\t  for(i='9';i>='1';i--){\n\t\tshends[step] = times_digit(dsr,i);\n\t\tif(isgte(mend,shends[step]))break;\n\t\tlibmin_free(shends[step]);\n\t  }\n\n\t/* \n\t  Insert the new digit in the quotient.  \n\t*/\n\n\t  quotient[libmin_strlen(quotient)]=i;\n\n\t/* Now, subtract the current subtrahend from the current minuend,\n\t   and splice the result with pend to form the next dividend */\n\n\t  ptr = sbc(mend,shends[step]);\n\t  if(libmin_strpbrk(ptr,DIGITS)==NULL)dgts_fwd = 0;\n\t  else\n\t  \tdgts_fwd = libmin_strlen(libmin_strpbrk(ptr,DIGITS));\n\n\t/* A special situation arises here if dgts_fwd = 0 and pend\n           points to a zero: since we strip off leading zeros when defining\n           the new dividend, we would miss the need to append zero digits\n           to the quotient.\n\t*/\n\t if(dgts_fwd == 0)\n\t\twhile ((*pend == '0') && (*pend != '\\0')){\n\t\t\tlibmin_strcat(quotient,\"0\");\n\t\t\tpend++;\n\t\t} \n\t  ddnds[step+1] = libmin_strpbrk(splice(ptr,pend),\n\t\t\t\tDIGITS); \n\t  if(ddnds[step+1]==NULL){\n\t\tddnds[step+1]= libmin_malloc(2*sizeof(char));\n\t\tlibmin_strcpy(ddnds[step+1],\"0\");\n\t  }\n\t  libmin_free(mend);\n\t  step++;\n\n\t}  /* repeat with new dividend */\n\n\t/* Add any necessary trailing zeros to quotient */\n\tj = libmin_strlen(quotient);\n\tfor(i=0;i<ddnd_len - j;i++)libmin_strcat(quotient,\"0\");\n\n\t/* Calculation done. Print everything out */\n\n\t/* Print out the quotient */\n\tfor(i=0;i<dsr_len+2;i++)libmin_putc(' ');\n\tfor(;*quotient == '0';quotient++)libmin_putc(' ');\n\tlibmin_printf(\"%s\\n\",quotient);\n\n\t/* Print out the top bar */\n\t\n\tfor(i=0;i<dsr_len+2;i++)libmin_putc(' ');   /* space over */\n\tfor(i=0;i<ddnd_len;i++)libmin_putc('_');\n\n\t/* Print out divisor and dividend */\n\tlibmin_printf(\"\\n %s)%s\\n\",dsr,ddnds[0]);\n\n\tfor(i=0;i<step;i++){\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tlibmin_printf(\"%s\\n\",shends[i]);\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tfor(k=0;k<libmin_strlen(shends[i]);k++)libmin_putc('-');\n\t\tlibmin_putc('\\n');\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i+1]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tlibmin_printf(\"%s\\n\",ddnds[i+1]);\n\t}\t\n\t\t\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  size_t v3; // rbx\n  const char *v4; // rdi\n  __int64 v5; // rdx\n  int v6; // ebp\n  const char *v7; // rdi\n  size_t v8; // rbx\n  __int64 v9; // rdx\n  size_t v10; // rax\n  int v11; // ebp\n  size_t v12; // rbx\n  char v13; // al\n  int v14; // ebx\n  int i; // ebx\n  char *v17; // rax\n  const char *v18; // r12\n  size_t v19; // rbp\n  char *v20; // r12\n  char *v21; // r13\n  _BYTE *v22; // r14\n  char *v23; // r12\n  int v24; // ebx\n  char *v25; // rbp\n  int v26; // eax\n  int v27; // r15d\n  char *v28; // rax\n  int v29; // ebx\n  char *v30; // r12\n  char *v31; // r15\n  const char *v32; // r12\n  char *v33; // r15\n  char *v34; // rax\n  char *v35; // rax\n  int v36; // ebx\n  int v37; // eax\n  char *v38; // rax\n  char *v39; // rbx\n  const char *v40; // rsi\n  int v41; // r15d\n  int v42; // r12d\n  int v43; // r12d\n  int v44; // eax\n  int v45; // r12d\n  int v46; // eax\n  int v47; // r12d\n  char **v48; // r13\n  __int64 v49; // rbx\n  size_t j; // r12\n  const char *v51; // rbp\n  size_t v52; // r12\n  const char *v53; // r14\n  size_t k; // rbp\n  size_t v55; // rbp\n  const char *v56; // r12\n  char *v57; // rdi\n  __int64 step; // [rsp+8h] [rbp-880h]\n  const char **stepa; // [rsp+8h] [rbp-880h]\n  int pend; // [rsp+18h] [rbp-870h]\n  char *penda; // [rsp+18h] [rbp-870h]\n  int pendb; // [rsp+18h] [rbp-870h]\n  int ddnd_len; // [rsp+24h] [rbp-864h]\n  int v64; // [rsp+28h] [rbp-860h]\n  int v65; // [rsp+30h] [rbp-858h]\n  char *v66; // [rsp+38h] [rbp-850h]\n  char *ddnds[128]; // [rsp+40h] [rbp-848h] BYREF\n  char *shends[128]; // [rsp+440h] [rbp-448h] BYREF\n  unsigned __int64 v69; // [rsp+848h] [rbp-40h]\n\n  v3 = 0LL;\n  v4 = ::argv[1];\n  v69 = __readfsqword(0x28u);\n  do\n  {\n    v6 = v3;\n    if ( libmin_strlen(v4) <= v3 )\n    {\n      v7 = ::argv[2];\n      v8 = 0LL;\n      while ( 1 )\n      {\n        v10 = libmin_strlen(v7);\n        v11 = v8;\n        v7 = ::argv[2];\n        if ( v10 <= v8 )\n          break;\n        v9 = ::argv[2][v8++];\n        if ( (pctype[v9] & 4) == 0 )\n        {\n          libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n          if ( v11 )\n          {\n            for ( i = 0; i != v11; ++i )\n              libmin_putc(32);\n          }\n          goto LABEL_13;\n        }\n      }\n      v12 = 0LL;\n      while ( libmin_strlen(v7) > v12 )\n      {\n        v7 = ::argv[2];\n        v13 = ::argv[2][v12++];\n        if ( v13 != 48 )\n        {\n          v17 = libmin_strpbrk(::argv[1], \"123456789\");\n          v18 = v17;\n          if ( v17 )\n          {\n            ddnd_len = libmin_strlen(v17);\n            v19 = ddnd_len + 1;\n            v66 = (char *)libmin_malloc(v19);\n            ddnds[0] = v66;\n            libmin_strcpy(v66, v18);\n          }\n          else\n          {\n            v19 = 2LL;\n            v66 = (char *)libmin_malloc(2uLL);\n            ddnds[0] = v66;\n            libmin_strcpy(v66, \"0\");\n            ddnd_len = 1;\n          }\n          v20 = libmin_strpbrk(::argv[2], \"123456789\");\n          v64 = libmin_strlen(v20);\n          v65 = v64 + 1;\n          v21 = (char *)libmin_malloc(v64 + 1);\n          libmin_strcpy(v21, v20);\n          pend = v64 - 1;\n          v22 = libmin_calloc(1uLL, v19);\n          if ( v64 - 1 > 0 )\n            memset(v22, 48, (unsigned int)(v64 - 2) + 1LL);\n          step = 0LL;\n          while ( 2 )\n          {\n            v23 = ddnds[step];\n            if ( v21 )\n            {\n              if ( !v23 || !isgte_0(ddnds[step], v21) )\n              {\n                pendb = step;\n                v41 = 0;\n                v42 = ddnd_len - libmin_strlen(v22);\n                if ( v42 > 0 )\n                {\n                  do\n                  {\n                    ++v41;\n                    libmin_strcat(v22, \"0\");\n                  }\n                  while ( v41 != v42 );\n                }\n                v43 = 0;\n                if ( v65 < 0 )\n                {\n                  if ( *v22 == 48 )\n                    goto LABEL_60;\n                  libmin_printf((char *)\"%s\\n\", v22);\n                }\n                else\n                {\n                  do\n                  {\n                    libmin_putc(32);\n                    v44 = v43++;\n                  }\n                  while ( v44 <= v64 );\n                  if ( *v22 != 48 )\n                  {\n                    libmin_printf((char *)\"%s\\n\", v22);\n                    goto LABEL_62;\n                  }\n                  do\n                  {\nLABEL_60:\n                    ++v22;\n                    libmin_putc(32);\n                  }\n                  while ( *v22 == 48 );\n                  libmin_printf((char *)\"%s\\n\", v22);\n                  if ( v65 >= 0 )\n                  {\nLABEL_62:\n                    v45 = 0;\n                    do\n                    {\n                      libmin_putc(32);\n                      v46 = v45++;\n                    }\n                    while ( v46 <= v64 );\n                  }\n                }\n                v47 = 0;\n                if ( ddnd_len > 0 )\n                {\n                  do\n                  {\n                    ++v47;\n                    libmin_putc(95);\n                  }\n                  while ( v47 != ddnd_len );\n                }\n                libmin_printf(\"\\n %s)%s\\n\", v21, v66);\n                if ( (_DWORD)step )\n                {\n                  v48 = ddnds;\n                  stepa = (const char **)shends;\n                  v49 = ddnd_len + v64 + 2;\n                  do\n                  {\n                    for ( j = 0LL; ; ++j )\n                    {\n                      v51 = *v48;\n                      if ( j >= v49 - libmin_strlen(*v48) )\n                        break;\n                      libmin_putc(32);\n                    }\n                    v52 = 0LL;\n                    v53 = *stepa;\n                    libmin_printf((char *)\"%s\\n\", *stepa);\n                    while ( v49 - libmin_strlen(v51) > v52 )\n                    {\n                      ++v52;\n                      libmin_putc(32);\n                    }\n                    for ( k = 0LL; k < libmin_strlen(v53); ++k )\n                      libmin_putc(45);\n                    v55 = 0LL;\n                    libmin_putc(10);\n                    v56 = v48[1];\n                    while ( v49 - libmin_strlen(v56) > v55 )\n                    {\n                      ++v55;\n                      libmin_putc(32);\n                    }\n                    ++v48;\n                    libmin_printf((char *)\"%s\\n\", v56);\n                    ++stepa;\n                  }\n                  while ( &ddnds[(unsigned int)(pendb - 1) + 1] != v48 );\n                }\n                libmin_success();\n              }\n              v24 = pend + 1;\n              v25 = cut_off(v23, pend + 1);\n              while ( !v25 || !isgte_0(v25, v21) )\n              {\n                while ( 1 )\n                {\n                  while ( 1 )\n                  {\n                    ++v24;\n                    libmin_strcat(v22, \"0\");\n                    libmin_free(v25);\n                    if ( v24 > 0 )\n                      break;\n                    v25 = 0LL;\n                  }\n                  v26 = libmin_strlen(v23);\n                  if ( v24 <= v26 )\n                    v26 = v24;\n                  v27 = v26;\n                  v28 = (char *)libmin_calloc(1uLL, v26 + 1);\n                  v25 = v28;\n                  if ( v28 )\n                    break;\n                  v25 = 0LL;\n                  libmin_printf(\"cut_off: Unable to malloc\\n\");\n                }\n                libmin_strncpy(v28, v23, v27);\n              }\n            }\n            else\n            {\n              v25 = cut_off(ddnds[step], pend + 1);\n            }\n            v29 = 57;\n            penda = &v23[libmin_strlen(v25)];\n            do\n            {\n              v30 = times_digit(v21, v29);\n              shends[step] = v30;\n              if ( !v30 || v25 && isgte_0(v25, v30) )\n                break;\n              --v29;\n              libmin_free(v30);\n            }\n            while ( v29 != 48 );\n            v31 = v30;\n            v32 = penda;\n            v22[libmin_strlen(v22)] = v29;\n            v33 = sbc(v25, v31);\n            if ( libmin_strpbrk(v33, \"123456789\")\n              && (v34 = libmin_strpbrk(v33, \"123456789\"), (pend = libmin_strlen(v34)) != 0) )\n            {\n              if ( !v33 )\n              {\nLABEL_47:\n                v35 = libmin_strpbrk(v32, \"123456789\");\n                ddnds[step + 1] = v35;\n                if ( !v35 )\n                {\n                  v57 = (char *)libmin_malloc(2uLL);\n                  ddnds[step + 1] = v57;\n                  libmin_strcpy(v57, \"0\");\n                }\n                libmin_free(v25);\n                ++step;\n                continue;\n              }\n              if ( !v32 )\n              {\n                v32 = v33;\n                goto LABEL_47;\n              }\n            }\n            else\n            {\n              while ( *v32 == 48 )\n              {\n                ++v32;\n                libmin_strcat(v22, \"0\");\n              }\n              pend = 0;\n              if ( !v33 )\n                goto LABEL_47;\n            }\n            break;\n          }\n          v36 = libmin_strlen(v33);\n          v37 = libmin_strlen(v32);\n          v38 = (char *)libmin_malloc(v36 + v37 + 1);\n          v39 = v38;\n          if ( v38 )\n          {\n            libmin_strcpy(v38, v33);\n            v40 = v32;\n            v32 = v39;\n            libmin_strcat(v39, v40);\n          }\n          else\n          {\n            v32 = 0LL;\n            libmin_printf(\"splice: unable to malloc\\n\");\n          }\n          goto LABEL_47;\n        }\n      }\n      libmin_printf((char *)\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n      return 0;\n    }\n    v4 = ::argv[1];\n    v5 = ::argv[1][v3++];\n  }\n  while ( (pctype[v5] & 4) != 0 );\n  v14 = 0;\n  libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n  if ( v6 )\n  {\n    do\n    {\n      ++v14;\n      libmin_putc(32);\n    }\n    while ( v6 != v14 );\n  }\nLABEL_13:\n  libmin_putc(94);\n  libmin_putc(10);\n  return 0;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  const char *v4;\n  long long v5;\n  int v6;\n  const char *v7;\n  unsigned int v8;\n  long long v9;\n  unsigned int v10;\n  int v11;\n  unsigned int v12;\n  char v13;\n  int v14;\n  int i;\n  char *v17;\n  const char *v18;\n  unsigned int v19;\n  char *v20;\n  char *v21;\n  uint8_t *v22;\n  char *v23;\n  int v24;\n  char *v25;\n  int v26;\n  int v27;\n  char *v28;\n  int v29;\n  char *v30;\n  char *v31;\n  const char *v32;\n  char *v33;\n  char *v34;\n  char *v35;\n  int v36;\n  int v37;\n  char *v38;\n  char *v39;\n  const char *v40;\n  int v41;\n  int v42;\n  int v43;\n  int v44;\n  int v45;\n  int v46;\n  int v47;\n  char **v48;\n  long long v49;\n  unsigned int j;\n  const char *v51;\n  unsigned int v52;\n  const char *v53;\n  unsigned int k;\n  unsigned int v55;\n  const char *v56;\n  char *v57;\n  long long step;\n  const char **stepa;\n  int pend;\n  char *penda;\n  int pendb;\n  int ddnd_len;\n  int v64;\n  int v65;\n  char *v66;\n  char *ddnds[128];\n  char *shends[128];\n  unsigned long long v69;\n  v3 = 0LL;\n  v4 = ::argv[1];\n  v69 = __readfsqword(40u);\n  do {\n    v6 = v3;\n    if (libmin_strlen(v4) <= v3) {\n      v7 = ::argv[2];\n      v8 = 0LL;\n      while (1) {\n        v10 = libmin_strlen(v7);\n        v11 = v8;\n        v7 = ::argv[2];\n        if (v10 <= v8) break;\n        v9 = ::argv[2][v8++];\n        if ((pctype[v9] & 4) == 0) {\n          libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n          if (v11) {\n            for (i = 0; i != v11; ++i) libmin_putc(32);\n          }\n          goto LABEL_13;\n        }\n      }\n      v12 = 0LL;\n      while (libmin_strlen(v7) > v12) {\n        v7 = ::argv[2];\n        v13 = ::argv[2][v12++];\n        if (v13 != 48) {\n          v17 = libmin_strpbrk(::argv[1], \"123456789\");\n          v18 = v17;\n          if (v17) {\n            ddnd_len = libmin_strlen(v17);\n            v19 = ddnd_len + 1;\n            v66 = (char *)libmin_malloc(v19);\n            ddnds[0] = v66;\n            libmin_strcpy(v66, v18);\n          } else {\n            v19 = 2LL;\n            v66 = (char *)libmin_malloc(2uLL);\n            ddnds[0] = v66;\n            libmin_strcpy(v66, \"0\");\n            ddnd_len = 1;\n          }\n          v20 = libmin_strpbrk(::argv[2], \"123456789\");\n          v64 = libmin_strlen(v20);\n          v65 = v64 + 1;\n          v21 = (char *)libmin_malloc(v64 + 1);\n          libmin_strcpy(v21, v20);\n          pend = v64 - 1;\n          v22 = libmin_calloc(1uLL, v19);\n          if (v64 - 1 > 0) memset(v22, 48, (unsigned int)(v64 - 2) + 1LL);\n          step = 0LL;\n          while (2) {\n            v23 = ddnds[step];\n            if (v21) {\n              if (!v23 || !isgte_0(ddnds[step], v21)) {\n                pendb = step;\n                v41 = 0;\n                v42 = ddnd_len - libmin_strlen(v22);\n                if (v42 > 0) {\n                  do {\n                    ++v41;\n                    libmin_strcat(v22, \"0\");\n                  } while (v41 != v42);\n                }\n                v43 = 0;\n                if (v65 < 0) {\n                  if (*v22 == 48) goto LABEL_60;\n                  libmin_printf((char *)\"%s\\n\", v22);\n                } else {\n                  do {\n                    libmin_putc(32);\n                    v44 = v43++;\n                  } while (v44 <= v64);\n                  if (*v22 != 48) {\n                    libmin_printf((char *)\"%s\\n\", v22);\n                    goto LABEL_62;\n                  }\n                  do {\n                  LABEL_60:\n                    ++v22;\n                    libmin_putc(32);\n                  } while (*v22 == 48);\n                  libmin_printf((char *)\"%s\\n\", v22);\n                  if (v65 >= 0) {\n                  LABEL_62:\n                    v45 = 0;\n                    do {\n                      libmin_putc(32);\n                      v46 = v45++;\n                    } while (v46 <= v64);\n                  }\n                }\n                v47 = 0;\n                if (ddnd_len > 0) {\n                  do {\n                    ++v47;\n                    libmin_putc(95);\n                  } while (v47 != ddnd_len);\n                }\n                libmin_printf(\"\\n %s)%s\\n\", v21, v66);\n                if ((uint32_t)step) {\n                  v48 = ddnds;\n                  stepa = (const char **)shends;\n                  v49 = ddnd_len + v64 + 2;\n                  do {\n                    for (j = 0LL;; ++j) {\n                      v51 = *v48;\n                      if (j >= v49 - libmin_strlen(*v48)) break;\n                      libmin_putc(32);\n                    }\n                    v52 = 0LL;\n                    v53 = *stepa;\n                    libmin_printf((char *)\"%s\\n\", *stepa);\n                    while (v49 - libmin_strlen(v51) > v52) {\n                      ++v52;\n                      libmin_putc(32);\n                    }\n                    for (k = 0LL; k < libmin_strlen(v53); ++k) libmin_putc(45);\n                    v55 = 0LL;\n                    libmin_putc(10);\n                    v56 = v48[1];\n                    while (v49 - libmin_strlen(v56) > v55) {\n                      ++v55;\n                      libmin_putc(32);\n                    }\n                    ++v48;\n                    libmin_printf((char *)\"%s\\n\", v56);\n                    ++stepa;\n                  } while (&ddnds[(unsigned int)(pendb - 1) + 1] != v48);\n                }\n                libmin_success();\n              }\n              v24 = pend + 1;\n              v25 = cut_off(v23, pend + 1);\n              while (!v25 || !isgte_0(v25, v21)) {\n                while (1) {\n                  while (1) {\n                    ++v24;\n                    libmin_strcat(v22, \"0\");\n                    libmin_free(v25);\n                    if (v24 > 0) break;\n                    v25 = 0LL;\n                  }\n                  v26 = libmin_strlen(v23);\n                  if (v24 <= v26) v26 = v24;\n                  v27 = v26;\n                  v28 = (char *)libmin_calloc(1uLL, v26 + 1);\n                  v25 = v28;\n                  if (v28) break;\n                  v25 = 0LL;\n                  libmin_printf(\"cut_off: Unable to malloc\\n\");\n                }\n                libmin_strncpy(v28, v23, v27);\n              }\n            } else {\n              v25 = cut_off(ddnds[step], pend + 1);\n            }\n            v29 = 57;\n            penda = &v23[libmin_strlen(v25)];\n            do {\n              v30 = times_digit(v21, v29);\n              shends[step] = v30;\n              if (!v30 || v25 && isgte_0(v25, v30)) break;\n              --v29;\n              libmin_free(v30);\n            } while (v29 != 48);\n            v31 = v30;\n            v32 = penda;\n            v22[libmin_strlen(v22)] = v29;\n            v33 = sbc(v25, v31);\n            if (libmin_strpbrk(v33, \"123456789\") &&\n                (v34 = libmin_strpbrk(v33, \"123456789\"),\n                 (pend = libmin_strlen(v34)) != 0)) {\n              if (!v33) {\n              LABEL_47:\n                v35 = libmin_strpbrk(v32, \"123456789\");\n                ddnds[step + 1] = v35;\n                if (!v35) {\n                  v57 = (char *)libmin_malloc(2uLL);\n                  ddnds[step + 1] = v57;\n                  libmin_strcpy(v57, \"0\");\n                }\n                libmin_free(v25);\n                ++step;\n                continue;\n              }\n              if (!v32) {\n                v32 = v33;\n                goto LABEL_47;\n              }\n            } else {\n              while (*v32 == 48) {\n                ++v32;\n                libmin_strcat(v22, \"0\");\n              }\n              pend = 0;\n              if (!v33) goto LABEL_47;\n            }\n            break;\n          }\n          v36 = libmin_strlen(v33);\n          v37 = libmin_strlen(v32);\n          v38 = (char *)libmin_malloc(v36 + v37 + 1);\n          v39 = v38;\n          if (v38) {\n            libmin_strcpy(v38, v33);\n            v40 = v32;\n            v32 = v39;\n            libmin_strcat(v39, v40);\n          } else {\n            v32 = 0LL;\n            libmin_printf(\"splice: unable to malloc\\n\");\n          }\n          goto LABEL_47;\n        }\n      }\n      libmin_printf((char *)\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n      return 0;\n    }\n    v4 = ::argv[1];\n    v5 = ::argv[1][v3++];\n  } while ((pctype[v5] & 4) != 0);\n  v14 = 0;\n  libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n  if (v6) {\n    do {\n      ++v14;\n      libmin_putc(32);\n    } while (v6 != v14);\n  }\nLABEL_13:\n  libmin_putc(94);\n  libmin_putc(10);\n  return 0;\n}", "binary": "longdiv/longdiv.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x858,%rsp\nmov    0x6eea(%rip),%rdi\nmov    %fs:0x28,%rax\nmov    %rax,0x848(%rsp)\nxor    %eax,%eax\njmp    1179 <main+0x59>\nnopl   0x0(%rax,%rax,1)\nmov    0x6ec9(%rip),%rdi\nmov    0x70e2(%rip),%rax\nmovsbq (%rdi,%rbx,1),%rdx\nadd    $0x1,%rbx\ntestb  $0x4,(%rax,%rdx,2)\nje     1200 <main+0xe0>\nmov    %ebx,%ebp\ncall   4890 <libmin_strlen>\ncmp    %rbx,%rax\nja     1158 <main+0x38>\nmov    0x6ea4(%rip),%rdi\nxor    %ebx,%ebx\njmp    11aa <main+0x8a>\nmovsbq (%rdi,%rbx,1),%rdx\nmov    0x70ac(%rip),%rax\nadd    $0x1,%rbx\ntestb  $0x4,(%rax,%rdx,2)\nje     1270 <main+0x150>\ncall   4890 <libmin_strlen>\nmov    %ebx,%ebp\nmov    0x6e78(%rip),%rdi\ncmp    %rbx,%rax\nja     1190 <main+0x70>\nxor    %ebx,%ebx\njmp    11df <main+0xbf>\nnopl   0x0(%rax)\nmov    0x6e61(%rip),%rdi\nmovzbl (%rdi,%rbx,1),%eax\nadd    $0x1,%rbx\ncmp    $0x30,%al\njne    12a3 <main+0x183>\ncall   4890 <libmin_strlen>\ncmp    %rbx,%rax\nja     11c8 <main+0xa8>\nlea    0x3e92(%rip),%rsi\nlea    0x3e7c(%rip),%rdi\nxor    %eax,%eax\ncall   4620 <libmin_printf>\njmp    1245 <main+0x125>\nmov    %rdi,%rdx\nlea    0x3e50(%rip),%rsi\nxor    %eax,%eax\nxor    %ebx,%ebx\nlea    0x3e5b(%rip),%rdi\ncall   4620 <libmin_printf>\ntest   %ebp,%ebp\nje     1231 <main+0x111>\nxchg   %ax,%ax\nmov    $0x20,%edi\nadd    $0x1,%ebx\ncall   4830 <libmin_putc>\ncmp    %ebx,%ebp\njne    1220 <main+0x100>\nmov    $0x5e,%edi\ncall   4830 <libmin_putc>\nmov    $0xa,%edi\ncall   4830 <libmin_putc>\nmov    0x848(%rsp),%rax\nsub    %fs:0x28,%rax\njne    18dc <main+0x7bc>\nadd    $0x858,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %rdi,%rdx\nxor    %eax,%eax\nlea    0x3dde(%rip),%rsi\nlea    0x3ded(%rip),%rdi\ncall   4620 <libmin_printf>\ntest   %ebp,%ebp\nje     1231 <main+0x111>\nxor    %ebx,%ebx\nxchg   %ax,%ax\nmov    $0x20,%edi\nadd    $0x1,%ebx\ncall   4830 <libmin_putc>\ncmp    %ebx,%ebp\njne    1290 <main+0x170>\njmp    1231 <main+0x111>\nmov    0x6d7e(%rip),%rdi\nlea    0x3d53(%rip),%rsi\ncall   4910 <libmin_strpbrk>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1852 <main+0x732>\nmov    %r12,%rdi\ncall   4890 <libmin_strlen>\nmov    %eax,0x24(%rsp)\nadd    $0x1,%eax\nmovslq %eax,%rbp\nmov    %rbp,%rdi\ncall   22e0 <libmin_malloc>\nmov    %r12,%rsi\nmov    %rax,%rdi\nmov    %rax,0x38(%rsp)\nmov    %rax,0x40(%rsp)\ncall   4870 <libmin_strcpy>\nmov    0x6d38(%rip),%rdi\nlea    0x3d05(%rip),%rsi\ncall   4910 <libmin_strpbrk>\nmov    %rax,%rdi\nmov    %rax,%r12\ncall   4890 <libmin_strlen>\nmov    %rax,0x28(%rsp)\nmov    %rax,%rbx\nmov    %eax,0x34(%rsp)\nadd    $0x1,%eax\nlea    -0x1(%rbx),%ebx\nmovslq %eax,%rdi\nmov    %eax,0x30(%rsp)\ncall   22e0 <libmin_malloc>\nmov    %r12,%rsi\nmov    %rax,%rdi\nmov    %rax,%r13\ncall   4870 <libmin_strcpy>\nmov    %rbp,%rsi\nmov    $0x1,%edi\nmov    %ebx,0x18(%rsp)\ncall   2430 <libmin_calloc>\nmov    %rax,%r14\ntest   %ebx,%ebx\njle    136c <main+0x24c>\nmov    0x28(%rsp),%rax\nmov    $0x30,%esi\nmov    %r14,%rdi\nlea    -0x2(%rax),%edx\nadd    $0x1,%rdx\ncall   10d0 <memset@plt>\nmovq   $0x0,0x8(%rsp)\nlea    0x40(%rsp),%rax\nmov    %rax,0x10(%rsp)\nmov    0x8(%rsp),%rax\nmov    0x10(%rsp),%rcx\nmov    %eax,%ebp\nmov    (%rcx,%rax,8),%r12\nmov    %eax,%r15d\ntest   %r13,%r13\nje     1440 <main+0x320>\ntest   %r12,%r12\nje     15c0 <main+0x4a0>\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   19e0 <isgte.part.0>\ntest   %eax,%eax\nje     15c0 <main+0x4a0>\nmov    0x18(%rsp),%ebx\nmov    %r12,%rdi\nadd    $0x1,%ebx\nmov    %ebx,%esi\ncall   2040 <cut_off>\nmov    %rax,%rbp\njmp    140a <main+0x2ea>\nnopl   (%rax)\nmov    %r12,%rdi\ncall   4890 <libmin_strlen>\nmov    $0x1,%edi\ncmp    %eax,%ebx\ncmovle %ebx,%eax\nlea    0x1(%rax),%esi\nmov    %eax,%r15d\nmovslq %esi,%rsi\ncall   2430 <libmin_calloc>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     1810 <main+0x6f0>\nmovslq %r15d,%rdx\nmov    %r12,%rsi\nmov    %rax,%rdi\ncall   48c0 <libmin_strncpy>\ntest   %rbp,%rbp\nje     141e <main+0x2fe>\nmov    %r13,%rsi\nmov    %rbp,%rdi\ncall   19e0 <isgte.part.0>\ntest   %eax,%eax\njne    1452 <main+0x332>\nlea    0x3c52(%rip),%rsi\nmov    %r14,%rdi\nadd    $0x1,%ebx\ncall   4840 <libmin_strcat>\nmov    %rbp,%rdi\ncall   2390 <libmin_free>\ntest   %ebx,%ebx\njg     13d0 <main+0x2b0>\nxor    %ebp,%ebp\njmp    141e <main+0x2fe>\nmov    0x18(%rsp),%esi\nmov    %r12,%rdi\nadd    $0x1,%esi\ncall   2040 <cut_off>\nmov    %rax,%rbp\nmov    %rbp,%rdi\nmov    $0x39,%ebx\nlea    0x440(%rsp),%r15\ncall   4890 <libmin_strlen>\nadd    %rax,%r12\nmov    %r12,0x18(%rsp)\nmov    %ebx,%esi\nmov    %r13,%rdi\ncall   1e70 <times_digit>\nmov    %rax,%r12\nmov    0x8(%rsp),%rax\nmov    %r12,(%r15,%rax,8)\ntest   %r12,%r12\nje     14ae <main+0x38e>\ntest   %rbp,%rbp\nje     149e <main+0x37e>\nmov    %r12,%rsi\nmov    %rbp,%rdi\ncall   19e0 <isgte.part.0>\ntest   %eax,%eax\njne    14ae <main+0x38e>\nmov    %r12,%rdi\nsub    $0x1,%ebx\ncall   2390 <libmin_free>\ncmp    $0x30,%ebx\njne    146f <main+0x34f>\nmov    %r14,%rdi\nmov    %r12,%r15\nmov    0x18(%rsp),%r12\ncall   4890 <libmin_strlen>\nmov    %r15,%rsi\nmov    %rbp,%rdi\nmov    %bl,(%r14,%rax,1)\ncall   1b60 <sbc>\nlea    0x3b30(%rip),%rsi\nmov    %rax,%rdi\nmov    %rax,%r15\ncall   4910 <libmin_strpbrk>\ntest   %rax,%rax\nje     1563 <main+0x443>\nlea    0x3b19(%rip),%rsi\nmov    %r15,%rdi\ncall   4910 <libmin_strpbrk>\nmov    %rax,%rdi\ncall   4890 <libmin_strlen>\nmov    %eax,0x18(%rsp)\ntest   %eax,%eax\nje     1563 <main+0x443>\ntest   %r15,%r15\nje     1510 <main+0x3f0>\ntest   %r12,%r12\njne    1577 <main+0x457>\nmov    %r15,%r12\nlea    0x3aed(%rip),%rsi\nmov    %r12,%rdi\ncall   4910 <libmin_strpbrk>\nmov    0x10(%rsp),%rcx\nmov    0x8(%rsp),%rsi\nmov    %rax,0x8(%rcx,%rsi,8)\ntest   %rax,%rax\nje     1825 <main+0x705>\nmov    %rbp,%rdi\ncall   2390 <libmin_free>\naddq   $0x1,0x8(%rsp)\njmp    137f <main+0x25f>\nnopw   0x0(%rax,%rax,1)\nlea    0x3b20(%rip),%rsi\nmov    %r14,%rdi\nadd    $0x1,%r12\ncall   4840 <libmin_strcat>\ncmpb   $0x30,(%r12)\nje     1550 <main+0x430>\nmovl   $0x0,0x18(%rsp)\ntest   %r15,%r15\nje     1510 <main+0x3f0>\nmov    %r15,%rdi\ncall   4890 <libmin_strlen>\nmov    %r12,%rdi\nmov    %rax,%rbx\ncall   4890 <libmin_strlen>\nlea    0x1(%rbx,%rax,1),%edi\nmovslq %edi,%rdi\ncall   22e0 <libmin_malloc>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     188a <main+0x76a>\nmov    %r15,%rsi\nmov    %rax,%rdi\ncall   4870 <libmin_strcpy>\nmov    %r12,%rsi\nmov    %rbx,%rdi\nmov    %rbx,%r12\ncall   4840 <libmin_strcat>\njmp    1510 <main+0x3f0>\nmov    %r14,%rdi\nmov    %ebp,0x18(%rsp)\nmov    %r15d,%ebx\nlea    0x3aa6(%rip),%rbp\ncall   4890 <libmin_strlen>\nmov    0x24(%rsp),%r12d\nxor    %r15d,%r15d\nsub    %eax,%r12d\ntest   %r12d,%r12d\njle    1604 <main+0x4e4>\ncs nopw 0x0(%rax,%rax,1)\nmov    %rbp,%rsi\nmov    %r14,%rdi\nadd    $0x1,%r15d\ncall   4840 <libmin_strcat>\ncmp    %r12d,%r15d\njne    15f0 <main+0x4d0>\nxor    %r12d,%r12d\ncmpl   $0x0,0x30(%rsp)\nmov    0x34(%rsp),%ebp\njs     18a0 <main+0x780>\ncs nopw 0x0(%rax,%rax,1)\nmov    $0x20,%edi\ncall   4830 <libmin_putc>\nmov    %r12d,%eax\nadd    $0x1,%r12d\ncmp    %ebp,%eax\njle    1620 <main+0x500>\ncmpb   $0x30,(%r14)\njne    18c3 <main+0x7a3>\nnop\nmov    $0x20,%edi\nadd    $0x1,%r14\ncall   4830 <libmin_putc>\ncmpb   $0x30,(%r14)\nje     1640 <main+0x520>\nlea    0x3a18(%rip),%r15\nxor    %eax,%eax\nmov    %r14,%rsi\nmov    %r15,%rdi\ncall   4620 <libmin_printf>\ncmpl   $0x0,0x30(%rsp)\njs     1695 <main+0x575>\nmov    0x34(%rsp),%ebp\nxor    %r12d,%r12d\ncs nopw 0x0(%rax,%rax,1)\nmov    $0x20,%edi\ncall   4830 <libmin_putc>\nmov    %r12d,%eax\nadd    $0x1,%r12d\ncmp    %ebp,%eax\njle    1680 <main+0x560>\nxor    %r12d,%r12d\ncmpl   $0x0,0x24(%rsp)\nmov    0x24(%rsp),%ebp\njle    16bb <main+0x59b>\nnopl   0x0(%rax,%rax,1)\nmov    $0x5f,%edi\nadd    $0x1,%r12d\ncall   4830 <libmin_putc>\ncmp    %ebp,%r12d\njne    16a8 <main+0x588>\nmov    0x38(%rsp),%rdx\nxor    %eax,%eax\nmov    %r13,%rsi\nlea    0x39ad(%rip),%rdi\ncall   4620 <libmin_printf>\ntest   %ebx,%ebx\nje     1806 <main+0x6e6>\nmov    0x24(%rsp),%eax\nmov    0x28(%rsp),%rcx\nmov    0x10(%rsp),%r13\nlea    0x2(%rax,%rcx,1),%ebx\nlea    0x440(%rsp),%rax\nmov    %rax,0x8(%rsp)\nmov    0x18(%rsp),%eax\nmovslq %ebx,%rbx\nsub    $0x1,%eax\nlea    0x48(%rsp,%rax,8),%rax\nmov    %rax,0x10(%rsp)\nnopl   0x0(%rax)\nxor    %r12d,%r12d\njmp    1726 <main+0x606>\nnopl   (%rax)\nmov    $0x20,%edi\nadd    $0x1,%r12\ncall   4830 <libmin_putc>\nmov    0x0(%r13),%rbp\nmov    %rbp,%rdi\ncall   4890 <libmin_strlen>\nmov    %rax,%r8\nmov    %rbx,%rax\nsub    %r8,%rax\ncmp    %rax,%r12\njb     1718 <main+0x5f8>\nmov    0x8(%rsp),%rax\nmov    %r15,%rdi\nxor    %r12d,%r12d\nmov    (%rax),%r14\nxor    %eax,%eax\nmov    %r14,%rsi\ncall   4620 <libmin_printf>\njmp    176e <main+0x64e>\nnopw   0x0(%rax,%rax,1)\nmov    $0x20,%edi\nadd    $0x1,%r12\ncall   4830 <libmin_putc>\nmov    %rbp,%rdi\ncall   4890 <libmin_strlen>\nmov    %rax,%r8\nmov    %rbx,%rax\nsub    %r8,%rax\ncmp    %r12,%rax\nja     1760 <main+0x640>\nxor    %ebp,%ebp\njmp    179e <main+0x67e>\nnopl   0x0(%rax,%rax,1)\nmov    $0x2d,%edi\nadd    $0x1,%rbp\ncall   4830 <libmin_putc>\nmov    %r14,%rdi\ncall   4890 <libmin_strlen>\ncmp    %rax,%rbp\njb     1790 <main+0x670>\nmov    $0xa,%edi\nxor    %ebp,%ebp\ncall   4830 <libmin_putc>\nmov    0x8(%r13),%r12\njmp    17ce <main+0x6ae>\nnopl   (%rax)\nmov    $0x20,%edi\nadd    $0x1,%rbp\ncall   4830 <libmin_putc>\nmov    %r12,%rdi\ncall   4890 <libmin_strlen>\nmov    %rax,%r8\nmov    %rbx,%rax\nsub    %r8,%rax\ncmp    %rbp,%rax\nja     17c0 <main+0x6a0>\nmov    %r12,%rsi\nmov    %r15,%rdi\nxor    %eax,%eax\nadd    $0x8,%r13\ncall   4620 <libmin_printf>\naddq   $0x8,0x8(%rsp)\ncmp    %r13,0x10(%rsp)\njne    1710 <main+0x5f0>\ncall   4930 <libmin_success>\njmp    1245 <main+0x125>\nlea    0x3828(%rip),%rdi\nxor    %eax,%eax\nxor    %ebp,%ebp\ncall   4620 <libmin_printf>\njmp    141e <main+0x2fe>\nmov    $0x2,%edi\ncall   22e0 <libmin_malloc>\nmov    0x8(%rsp),%rcx\nlea    0x383c(%rip),%rsi\nmov    %rax,%rdi\nmov    0x10(%rsp),%rax\nmov    %rdi,0x8(%rax,%rcx,8)\ncall   4870 <libmin_strcpy>\njmp    1537 <main+0x417>\nmov    $0x2,%edi\nlea    0x3819(%rip),%rbp\ncall   22e0 <libmin_malloc>\nmov    %rbp,%rsi\nmov    $0x2,%ebp\nmov    %rax,%rdi\nmov    %rax,0x38(%rsp)\nmov    %rax,0x40(%rsp)\ncall   4870 <libmin_strcpy>\nmovl   $0x1,0x24(%rsp)\njmp    12f1 <main+0x1d1>\nlea    0x3794(%rip),%rdi\nxor    %eax,%eax\nxor    %r12d,%r12d\ncall   4620 <libmin_printf>\njmp    1510 <main+0x3f0>\ncmpb   $0x30,(%r14)\nje     1640 <main+0x520>\nlea    0x37c2(%rip),%r15\nmov    %r14,%rsi\nxor    %eax,%eax\nmov    %r15,%rdi\ncall   4620 <libmin_printf>\njmp    1695 <main+0x575>\nlea    0x37a9(%rip),%r15\nmov    %r14,%rsi\nxor    %eax,%eax\nmov    %r15,%rdi\ncall   4620 <libmin_printf>\njmp    166f <main+0x54f>\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "sbc", "content": "\t\n\t\t \n\t\n\n/* Given character strings of digits with mend >= shend, this returns a pointer\nto the string corresponding to minuend - subtrahend. Returns NULL if\nminuend < subtrahend. Result array is padded with leading zeros.  \n*/\n\nchar *sbc(char *mend, char *shend)\n{\n\tint need_borrow = FALSE;\n\tint lm,ls,i;\n\tchar *res;\n\tchar *mnd,*p;\n\n\tif(!isgte(mend,shend))return NULL;\n\n\tlm = libmin_strlen(mend);\n\tls = libmin_strlen(shend);\n\tres = (char *)libmin_malloc(libmin_strlen(mend)+1);\n\tif(res == NULL){\n\t\tlibmin_printf(\"sbc: Unable to malloc space for result\\n\");\n\t\tlibmin_fail(1);\n\t}\n\tp = mnd = (char *)libmin_malloc(libmin_strlen(mend)+1);\n\tif(mnd == NULL){\n\t\tlibmin_printf(\"sbc: Unable to malloc\\n\");\n\t\tlibmin_fail(1);\n\t}\n\tlibmin_strcpy(mnd,mend);\n\n\t/* Fill result array with digit zero */\n\n\tfor(i=0;i<lm;i++)res[i]='0';\n\tres[lm] = '\\0';\n\n\n\tfor(i = 0; i<lm; i++){\n\t\tif (need_borrow)\n    {\n\t\t\tif(mnd[lm-i-1] == '0')\n\t\t\t\tmnd[lm-i-1] = '9'; /* need_borrow stays TRUE */\n\t\t\telse {\n\t\t\t\t--mnd[lm-i-1];\n\t\t\t\tneed_borrow = FALSE;\n\t\t\t}\n    }\n\t\tif( i < ls )\n\t\t need_borrow |= sub(mnd[lm-i-1],shend[ls-i-1],res+lm-i-1);\n\t\telse\n\t\t need_borrow |= sub(mnd[lm-i-1],'0',res+lm-i-1);\n\t}\n\t\t\n\tlibmin_free(p);\n\treturn res;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O3.pseudo", "function_name": "sbc", "address": "0x1b60", "label": "sbc", "content": "char *__fastcall sbc(char *mend, char *shend)\n{\n  char *v3; // r12\n  char *v4; // rax\n  char *v5; // rbp\n  int v6; // r13d\n  int v7; // eax\n  __int64 i; // rax\n  char v9; // si\n  int v10; // r12d\n  size_t v11; // rax\n  _BYTE *v12; // r15\n  size_t v13; // rax\n  char *v14; // rax\n  char *v15; // r8\n  __int64 v16; // rdx\n  int v17; // ecx\n  int v18; // r10d\n  __int64 v19; // rbx\n  char v20; // al\n  char v21; // al\n  int v23; // edi\n  char *v24; // r13\n  char v25; // si\n  char v26; // al\n  char v27; // al\n  char *block; // [rsp+8h] [rbp-50h]\n  int v29; // [rsp+14h] [rbp-44h]\n\n  if ( shend )\n  {\n    if ( !mend )\n      return 0LL;\n    v3 = libmin_strpbrk(mend, \"123456789\");\n    v4 = libmin_strpbrk(shend, \"123456789\");\n    v5 = v4;\n    if ( v4 )\n    {\n      if ( v3 )\n      {\n        v6 = libmin_strlen(v4);\n        v7 = libmin_strlen(v3);\n        if ( v6 <= v7 )\n        {\n          if ( v6 >= v7 && v6 > 0 )\n          {\n            for ( i = 0LL; ; ++i )\n            {\n              v9 = v5[i];\n              if ( v3[i] > v9 )\n                break;\n              if ( v3[i] < v9 )\n                return 0LL;\n              if ( v6 - 1 == i )\n                break;\n            }\n          }\n          goto LABEL_13;\n        }\n      }\n      return 0LL;\n    }\n  }\nLABEL_13:\n  v10 = libmin_strlen(mend);\n  v29 = libmin_strlen(shend);\n  v11 = libmin_strlen(mend);\n  v12 = libmin_malloc(v11 + 1);\n  if ( !v12 )\n  {\n    libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n    libmin_fail(1);\n  }\n  v13 = libmin_strlen(mend);\n  v14 = (char *)libmin_malloc(v13 + 1);\n  if ( !v14 )\n  {\n    libmin_printf(\"sbc: Unable to malloc\\n\");\n    libmin_fail(1);\n  }\n  block = v14;\n  libmin_strcpy(v14, mend);\n  v15 = block;\n  if ( v10 <= 0 )\n  {\n    v12[v10] = 0;\n    goto LABEL_26;\n  }\n  memset(v12, 48, (unsigned int)(v10 - 1) + 1LL);\n  v16 = v10 - 1LL;\n  v15 = block;\n  v12[v10] = 0;\n  if ( v29 <= 0 )\n  {\n    v17 = 0;\n    v18 = 0;\nLABEL_18:\n    v19 = v10 - (__int64)v17;\n    while ( v18 )\n    {\n      while ( 1 )\n      {\n        v21 = block[v19 - 1];\n        if ( v21 == 48 )\n        {\n          block[v19 - 1] = 57;\n          v20 = 57;\n          v18 = 1;\n          goto LABEL_25;\n        }\n        block[v19 - 1] = v21 - 1;\n        v20 = block[v19 - 1];\n        if ( v20 > 47 )\n          break;\nLABEL_21:\n        v12[--v19] = v20 + 10;\n        if ( v10 <= v10 - (int)v19 )\n          goto LABEL_26;\n      }\nLABEL_24:\n      v18 = 0;\nLABEL_25:\n      v12[--v19] = v20;\n      if ( v10 <= v10 - (int)v19 )\n        goto LABEL_26;\n    }\n    v20 = block[v19 - 1];\n    if ( v20 > 47 )\n      goto LABEL_24;\n    goto LABEL_21;\n  }\n  v23 = v10;\n  if ( v29 <= v10 )\n    v23 = v29;\n  v17 = 0;\n  v18 = 0;\n  v24 = &shend[v29 - (__int64)v10];\nLABEL_32:\n  while ( 1 )\n  {\n    v25 = v24[v16];\n    v26 = block[v16];\n    if ( v25 > v26 )\n      break;\n    while ( 1 )\n    {\n      ++v17;\n      v12[v16--] = v26 + 48 - v25;\n      if ( v23 <= v17 )\n        goto LABEL_41;\n      if ( !v18 )\n        break;\n      v27 = block[v16];\n      if ( v27 == 48 )\n      {\nLABEL_39:\n        block[v16] = 57;\n        v18 = 1;\n        goto LABEL_32;\n      }\nLABEL_35:\n      v18 = 0;\n      block[v16] = v27 - 1;\n      v25 = v24[v16];\n      v26 = block[v16];\n      if ( v25 > v26 )\n        goto LABEL_33;\n    }\n  }\nLABEL_33:\n  ++v17;\n  v12[v16--] = v26 + 58 - v25;\n  if ( v23 > v17 )\n  {\n    v27 = block[v16];\n    if ( v27 == 48 )\n      goto LABEL_39;\n    goto LABEL_35;\n  }\n  v18 = 1;\nLABEL_41:\n  if ( v10 > v17 )\n    goto LABEL_18;\nLABEL_26:\n  libmin_free(v15);\n  return v12;\n}\n"}, "pseudo_normalize": "char *sbc(char *mend, char *shend) {\n  char *v3;\n  char *v4;\n  char *v5;\n  int v6;\n  int v7;\n  long long i;\n  char v9;\n  int v10;\n  unsigned int v11;\n  uint8_t *v12;\n  unsigned int v13;\n  char *v14;\n  char *v15;\n  long long v16;\n  int v17;\n  int v18;\n  long long v19;\n  char v20;\n  char v21;\n  int v23;\n  char *v24;\n  char v25;\n  char v26;\n  char v27;\n  char *block;\n  int v29;\n  if (shend) {\n    if (!mend) return 0LL;\n    v3 = libmin_strpbrk(mend, \"123456789\");\n    v4 = libmin_strpbrk(shend, \"123456789\");\n    v5 = v4;\n    if (v4) {\n      if (v3) {\n        v6 = libmin_strlen(v4);\n        v7 = libmin_strlen(v3);\n        if (v6 <= v7) {\n          if (v6 >= v7 && v6 > 0) {\n            for (i = 0LL;; ++i) {\n              v9 = v5[i];\n              if (v3[i] > v9) break;\n              if (v3[i] < v9) return 0LL;\n              if (v6 - 1 == i) break;\n            }\n          }\n          goto LABEL_13;\n        }\n      }\n      return 0LL;\n    }\n  }\nLABEL_13:\n  v10 = libmin_strlen(mend);\n  v29 = libmin_strlen(shend);\n  v11 = libmin_strlen(mend);\n  v12 = libmin_malloc(v11 + 1);\n  if (!v12) {\n    libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n    libmin_fail(1);\n  }\n  v13 = libmin_strlen(mend);\n  v14 = (char *)libmin_malloc(v13 + 1);\n  if (!v14) {\n    libmin_printf(\"sbc: Unable to malloc\\n\");\n    libmin_fail(1);\n  }\n  block = v14;\n  libmin_strcpy(v14, mend);\n  v15 = block;\n  if (v10 <= 0) {\n    v12[v10] = 0;\n    goto LABEL_26;\n  }\n  memset(v12, 48, (unsigned int)(v10 - 1) + 1LL);\n  v16 = v10 - 1LL;\n  v15 = block;\n  v12[v10] = 0;\n  if (v29 <= 0) {\n    v17 = 0;\n    v18 = 0;\n  LABEL_18:\n    v19 = v10 - (long long)v17;\n    while (v18) {\n      while (1) {\n        v21 = block[v19 - 1];\n        if (v21 == 48) {\n          block[v19 - 1] = 57;\n          v20 = 57;\n          v18 = 1;\n          goto LABEL_25;\n        }\n        block[v19 - 1] = v21 - 1;\n        v20 = block[v19 - 1];\n        if (v20 > 47) break;\n      LABEL_21:\n        v12[--v19] = v20 + 10;\n        if (v10 <= v10 - (int)v19) goto LABEL_26;\n      }\n    LABEL_24:\n      v18 = 0;\n    LABEL_25:\n      v12[--v19] = v20;\n      if (v10 <= v10 - (int)v19) goto LABEL_26;\n    }\n    v20 = block[v19 - 1];\n    if (v20 > 47) goto LABEL_24;\n    goto LABEL_21;\n  }\n  v23 = v10;\n  if (v29 <= v10) v23 = v29;\n  v17 = 0;\n  v18 = 0;\n  v24 = &shend[v29 - (long long)v10];\nLABEL_32:\n  while (1) {\n    v25 = v24[v16];\n    v26 = block[v16];\n    if (v25 > v26) break;\n    while (1) {\n      ++v17;\n      v12[v16--] = v26 + 48 - v25;\n      if (v23 <= v17) goto LABEL_41;\n      if (!v18) break;\n      v27 = block[v16];\n      if (v27 == 48) {\n      LABEL_39:\n        block[v16] = 57;\n        v18 = 1;\n        goto LABEL_32;\n      }\n    LABEL_35:\n      v18 = 0;\n      block[v16] = v27 - 1;\n      v25 = v24[v16];\n      v26 = block[v16];\n      if (v25 > v26) goto LABEL_33;\n    }\n  }\nLABEL_33:\n  ++v17;\n  v12[v16--] = v26 + 58 - v25;\n  if (v23 > v17) {\n    v27 = block[v16];\n    if (v27 == 48) goto LABEL_39;\n    goto LABEL_35;\n  }\n  v18 = 1;\nLABEL_41:\n  if (v10 > v17) goto LABEL_18;\nLABEL_26:\n  libmin_free(v15);\n  return v12;\n}", "binary": "longdiv/longdiv.host.O3", "assembly": "<sbc>:\nendbr64\npush   %r15\npush   %r14\nmov    %rsi,%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x28,%rsp\ntest   %rsi,%rsi\nje     1c08 <sbc+0xa8>\ntest   %rdi,%rdi\nje     1e08 <sbc+0x2a8>\nlea    0x3473(%rip),%rbp\nmov    %rbp,%rsi\ncall   4910 <libmin_strpbrk>\nmov    %rbp,%rsi\nmov    %r14,%rdi\nmov    %rax,%r12\ncall   4910 <libmin_strpbrk>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     1c08 <sbc+0xa8>\ntest   %r12,%r12\nje     1e08 <sbc+0x2a8>\nmov    %rax,%rdi\ncall   4890 <libmin_strlen>\nmov    %r12,%rdi\nmov    %rax,%r13\ncall   4890 <libmin_strlen>\ncmp    %eax,%r13d\njg     1e08 <sbc+0x2a8>\njl     1c08 <sbc+0xa8>\ntest   %r13d,%r13d\njle    1c08 <sbc+0xa8>\nlea    -0x1(%r13),%ecx\nxor    %eax,%eax\njmp    1bfa <sbc+0x9a>\nnopl   0x0(%rax,%rax,1)\njl     1e08 <sbc+0x2a8>\nlea    0x1(%rax),%rdx\ncmp    %rax,%rcx\nje     1c08 <sbc+0xa8>\nmov    %rdx,%rax\nmovzbl 0x0(%rbp,%rax,1),%esi\ncmp    %sil,(%r12,%rax,1)\njle    1be8 <sbc+0x88>\nnopl   (%rax)\nmov    %rbx,%rdi\ncall   4890 <libmin_strlen>\nmov    %r14,%rdi\nmov    %rax,%r12\nmov    %eax,%ebp\ncall   4890 <libmin_strlen>\nmov    %rbx,%rdi\nmov    %eax,0x14(%rsp)\nmov    %rax,%r13\ncall   4890 <libmin_strlen>\nlea    0x1(%rax),%rdi\ncall   22e0 <libmin_malloc>\nmov    %rax,%r15\ntest   %rax,%rax\nje     1e10 <sbc+0x2b0>\nmov    %rbx,%rdi\ncall   4890 <libmin_strlen>\nlea    0x1(%rax),%rdi\ncall   22e0 <libmin_malloc>\nmov    %rax,%r8\ntest   %rax,%rax\nje     1e30 <sbc+0x2d0>\nmov    %rbx,%rsi\nmov    %r8,%rdi\nmov    %r8,0x8(%rsp)\nmovslq %r12d,%rbx\ncall   4870 <libmin_strcpy>\ntest   %r12d,%r12d\nmov    0x8(%rsp),%r8\nlea    (%r15,%rbx,1),%rcx\njle    1e60 <sbc+0x300>\nlea    -0x1(%r12),%edx\nmov    $0x30,%esi\nmov    %r15,%rdi\nmov    %rcx,0x18(%rsp)\nadd    $0x1,%rdx\ncall   10d0 <memset@plt>\nmov    0x18(%rsp),%rcx\ntest   %r13d,%r13d\nlea    -0x1(%rbx),%rdx\nmov    0x8(%rsp),%r8\nmovb   $0x0,(%rcx)\njg     1d58 <sbc+0x1f8>\nxor    %ecx,%ecx\nxor    %r10d,%r10d\nmovslq %ecx,%rax\nsub    %rax,%rbx\nlea    (%rcx,%rbx,1),%edx\ncs nopw 0x0(%rax,%rax,1)\ntest   %r10d,%r10d\njne    1cf3 <sbc+0x193>\nmovzbl -0x1(%r8,%rbx,1),%eax\ncmp    $0x2f,%al\njg     1d0f <sbc+0x1af>\nadd    $0xa,%eax\nmov    %al,-0x1(%r15,%rbx,1)\nsub    $0x1,%rbx\nmov    %edx,%eax\nsub    %ebx,%eax\ncmp    %eax,%ebp\njle    1d23 <sbc+0x1c3>\nmovzbl -0x1(%r8,%rbx,1),%eax\ncmp    $0x30,%al\nje     1d40 <sbc+0x1e0>\nsub    $0x1,%eax\nmov    %al,-0x1(%r8,%rbx,1)\nmovzbl -0x1(%r8,%rbx,1),%eax\ncmp    $0x2f,%al\njle    1cdf <sbc+0x17f>\nxor    %r10d,%r10d\nmov    %al,-0x1(%r15,%rbx,1)\nsub    $0x1,%rbx\nmov    %edx,%eax\nsub    %ebx,%eax\ncmp    %eax,%ebp\njg     1cd0 <sbc+0x170>\nmov    %r8,%rdi\ncall   2390 <libmin_free>\nadd    $0x28,%rsp\nmov    %r15,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nmovb   $0x39,-0x1(%r8,%rbx,1)\nmov    $0x39,%eax\nmov    $0x1,%r10d\njmp    1d12 <sbc+0x1b2>\nnopl   0x0(%rax,%rax,1)\ncmp    %r12d,%r13d\nmov    %r12d,%edi\ncmovle %r13d,%edi\nmovslq 0x14(%rsp),%r13\nxor    %ecx,%ecx\nxor    %r10d,%r10d\nsub    %rbx,%r13\nadd    %r14,%r13\nmovzbl 0x0(%r13,%rdx,1),%esi\nmovzbl (%r8,%rdx,1),%eax\ncmp    %al,%sil\njle    1db9 <sbc+0x259>\nadd    $0x3a,%eax\nadd    $0x1,%ecx\nsub    %esi,%eax\nmov    %al,(%r15,%rdx,1)\nsub    $0x1,%rdx\ncmp    %ecx,%edi\njle    1df0 <sbc+0x290>\nmovzbl (%r8,%rdx,1),%eax\ncmp    $0x30,%al\nje     1de0 <sbc+0x280>\nsub    $0x1,%eax\nxor    %r10d,%r10d\nmov    %al,(%r8,%rdx,1)\nmovzbl 0x0(%r13,%rdx,1),%esi\nmovzbl (%r8,%rdx,1),%eax\ncmp    %al,%sil\njg     1d82 <sbc+0x222>\nadd    $0x30,%eax\nadd    $0x1,%ecx\nsub    %esi,%eax\nmov    %al,(%r15,%rdx,1)\nsub    $0x1,%rdx\ncmp    %ecx,%edi\njle    1df6 <sbc+0x296>\ntest   %r10d,%r10d\nje     1d72 <sbc+0x212>\nmovzbl (%r8,%rdx,1),%eax\ncmp    $0x30,%al\njne    1d9f <sbc+0x23f>\nnopl   0x0(%rax,%rax,1)\nmovb   $0x39,(%r8,%rdx,1)\nmov    $0x1,%r10d\njmp    1d72 <sbc+0x212>\nnopl   (%rax)\nmov    $0x1,%r10d\ncmp    %ecx,%r12d\njg     1cbd <sbc+0x15d>\njmp    1d23 <sbc+0x1c3>\nnopl   0x0(%rax)\nxor    %r15d,%r15d\njmp    1d2b <sbc+0x1cb>\nlea    0x32a1(%rip),%rdi\nxor    %eax,%eax\ncall   4620 <libmin_printf>\nmov    $0x1,%edi\ncall   22c0 <libmin_fail>\njmp    1c41 <sbc+0xe1>\nnopl   (%rax)\nmov    %rax,0x8(%rsp)\nlea    0x31d2(%rip),%rdi\nxor    %eax,%eax\ncall   4620 <libmin_printf>\nmov    $0x1,%edi\ncall   22c0 <libmin_fail>\nmov    0x8(%rsp),%r8\njmp    1c5e <sbc+0xfe>\nnopw   0x0(%rax,%rax,1)\nmovb   $0x0,(%rcx)\njmp    1d23 <sbc+0x1c3>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "splice", "content": "/* Allocates a new string consisting of front and back glued together */\n\nchar *\nsplice(char *front, char *back)\n{\n\n\tchar *res;\n\tint len;\n\n\tif(front == NULL)return back;\n\tif(back == NULL) return front;  \n\tlen = libmin_strlen(front)+libmin_strlen(back);\n\n\tres = (char *)libmin_malloc((len+1)*sizeof(char));\n\tif(res == NULL) {\n\t\tlibmin_printf(\"splice: unable to malloc\\n\");\n\t\treturn NULL;\n\t}\n\tlibmin_strcpy(res,front);\n\tlibmin_strcat(res,back);\n\treturn res;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O3.pseudo", "function_name": "splice", "address": "0x1fc0", "label": "splice", "content": "char *__fastcall splice(char *front, char *back)\n{\n  char *v2; // r12\n  int v3; // r12d\n  int v4; // eax\n  char *v5; // rax\n\n  if ( !front )\n    return back;\n  v2 = front;\n  if ( back )\n  {\n    v3 = libmin_strlen(front);\n    v4 = libmin_strlen(back);\n    v5 = (char *)libmin_malloc(v3 + v4 + 1);\n    v2 = v5;\n    if ( v5 )\n    {\n      libmin_strcpy(v5, front);\n      libmin_strcat(v2, back);\n    }\n    else\n    {\n      libmin_printf(\"splice: unable to malloc\\n\");\n    }\n  }\n  return v2;\n}\n"}, "pseudo_normalize": "char *splice(char *front, char *back) {\n  char *v2;\n  int v3;\n  int v4;\n  char *v5;\n  if (!front) return back;\n  v2 = front;\n  if (back) {\n    v3 = libmin_strlen(front);\n    v4 = libmin_strlen(back);\n    v5 = (char *)libmin_malloc(v3 + v4 + 1);\n    v2 = v5;\n    if (v5) {\n      libmin_strcpy(v5, front);\n      libmin_strcat(v2, back);\n    } else {\n      libmin_printf(\"splice: unable to malloc\\n\");\n    }\n  }\n  return v2;\n}", "binary": "longdiv/longdiv.host.O3", "assembly": "<splice>:\nendbr64\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\ntest   %rdi,%rdi\nje     2020 <splice+0x60>\nmov    %rdi,%rbp\nmov    %rdi,%r12\ntest   %rsi,%rsi\nje     2017 <splice+0x57>\ncall   4890 <libmin_strlen>\nmov    %r13,%rdi\nmov    %rax,%r12\ncall   4890 <libmin_strlen>\nlea    0x1(%r12,%rax,1),%edi\nmovslq %edi,%rdi\ncall   22e0 <libmin_malloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     2030 <splice+0x70>\nmov    %rbp,%rsi\nmov    %rax,%rdi\ncall   4870 <libmin_strcpy>\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   4840 <libmin_strcat>\nmov    %r12,%rax\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    %rsi,%r12\npop    %rbp\nmov    %r12,%rax\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nlea    0x2fee(%rip),%rdi\nxor    %eax,%eax\ncall   4620 <libmin_printf>\njmp    2017 <splice+0x57>\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "sub", "content": "/* longdiv.c: program to print out examples of \"long-division\" problems.\n*  (Sure wish I had one of these in grade school.)\n*\n* By Terry R. McConnell 12/97\n*\n* Usage: longdiv <dividend> <divisor>\n* Here both dividend and divisor must be positive integers. At some point\n* we should improve the program to handle decimal points, negative\n* numbers, and other bases,\n* but this should be sufficient to establish the concept.\n*\n* Dividend and divisor can be arbitrarily long, subject only to the size of\n* ARG_MAX on your system. POSIX.1 ensures that this is at least 4096 bytes.\n* I.e, this can handle REALLY LARGE division problems!\n*\n* A bit of useful terminology: \n*   dividend = that which is divided into ( = numerator ).\n*   divisor  = that which is divided by ( = denominator ).\n*   subtrahend = that which is subtracted.\n*   minuend  = that which is subtracted from.\n*/\n\n\n#define _POSIX_SOURCE\n#define USAGE \"Usage: longdiv <dividend> <divisor>\"\n#define DIGITS \"123456789\"\n\n#include \"libmin.h\"\n\n#define RADIX 10 /* Actually, base 10 is assumed at many points in the pgm,\n                    so porting this to handle other bases will involve more\n                    than just changing this define. */\n\n#define BORROW 1\n#define NO_BORROW 0\n\n\n/* The main routine is at the bottom, following a number of auxiliary\n   routines.\n*/\n\n/* Subtracts digits and stores result in res. Returns indicator of whether\n   or not borrow is needed.\n*/\n\nint\nsub( char x, char y, char *res)\n{\n\tif( x >= y){\n\t\t *res = '0' + x - y;\n\t\t return FALSE;\n\t}\n\t*res = '0' + x - y + 10;\n\treturn TRUE;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O3.pseudo", "function_name": "sub", "address": "0x1a80", "label": "sub", "content": "int __fastcall sub(char x, char y, char *res)\n{\n  int result; // eax\n  char v4; // cl\n\n  result = 1;\n  v4 = x - y + 58;\n  if ( x >= y )\n  {\n    v4 = x - y + 48;\n    result = 0;\n  }\n  *res = v4;\n  return result;\n}\n"}, "pseudo_normalize": "int sub(char x, char y, char *res) {\n  int result;\n  char v4;\n  result = 1;\n  v4 = x - y + 58;\n  if (x >= y) {\n    v4 = x - y + 48;\n    result = 0;\n  }\n  *res = v4;\n  return result;\n}", "binary": "longdiv/longdiv.host.O3", "assembly": "<sub>:\nendbr64\nmov    %edi,%r8d\nmov    $0x1,%eax\nsub    %esi,%r8d\nlea    0x3a(%r8),%ecx\ncmp    %sil,%dil\njl     1a9e <sub+0x1e>\nlea    0x30(%r8),%ecx\nxor    %eax,%eax\nmov    %cl,(%rdx)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "times_digit", "content": "/* Multiplies digit string by digit character. Returns string pointing\n   to answer. Leading zeros are removed.\n*/\n\nchar *\ntimes_digit(char *mcand, char dgt)\n{\n\n\tint i,len;\n\tint carry=0,idgt,curdgt,prod;\n\tchar *res,*tmp;\n\n\tif(mcand == NULL) return NULL;\n\n\tidgt = dgt - '0';\n\tlen = libmin_strlen(mcand);\n\ttmp = (char *)libmin_malloc(len+2);\n\tif(tmp==NULL){\n\t\tlibmin_printf(\"Unable to malloc partial product array\\n\");\n\t\tlibmin_fail(1);\n\t}\n\t\n\ttmp[len+1]='\\0';\n\n\tfor(i=0;i<len;i++){\n\t\tcurdgt = mcand[len-i-1] - '0';\n\t\tprod = curdgt*idgt + carry;\n\t\ttmp[len-i] = '0' + (prod % RADIX);\t\n\t\tcarry = prod/RADIX;\n\t}\n\ttmp[0] = '0' + carry;\n\tif(tmp[0]=='0'){\n\t\tres = (char *)libmin_malloc(len+1);\n\t\tif(res == NULL){\n\t\t\tlibmin_printf(\"Unable to malloc partial product array\\n\");\n\t\t\tlibmin_fail(1);\n\t\t}\n\t\tres[len]='\\0';\n\t\tlibmin_strcpy(res,tmp+1);\n\t\tlibmin_free(tmp);\n\t}\n\telse res = tmp;\n\treturn res;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O3.pseudo", "function_name": "times_digit", "address": "0x1e70", "label": "times_digit", "content": "char *__fastcall times_digit(char *mcand, char dgt)\n{\n  int v2; // r14d\n  _BYTE *v3; // rax\n  _BYTE *v4; // r12\n  __int64 v5; // rcx\n  int v6; // edx\n  int v7; // eax\n  char v8; // dl\n  char *v10; // rax\n  char *v11; // rbx\n\n  if ( !mcand )\n    return 0LL;\n  v2 = libmin_strlen(mcand);\n  v3 = libmin_malloc(v2 + 2);\n  v4 = v3;\n  if ( !v3 )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v3[v2 + 1] = 0;\n  if ( v2 <= 0 )\n  {\n    *v3 = 48;\n  }\n  else\n  {\n    v5 = v2;\n    v6 = 0;\n    do\n    {\n      v7 = v6 + (dgt - 48) * (mcand[v5 - 1] - 48);\n      v6 = v7 / 10;\n      v4[v5--] = v7 % 10 + 48;\n    }\n    while ( v5 != v2 - 1LL - (unsigned int)(v2 - 1) );\n    v8 = v6 + 48;\n    *v4 = v8;\n    if ( v8 != 48 )\n      return v4;\n  }\n  v10 = (char *)libmin_malloc(v2 + 1LL);\n  v11 = v10;\n  if ( !v10 )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v10[v2] = 0;\n  libmin_strcpy(v10, v4 + 1);\n  libmin_free(v4);\n  return v11;\n}\n"}, "pseudo_normalize": "char *times_digit(char *mcand, char dgt) {\n  int v2;\n  uint8_t *v3;\n  uint8_t *v4;\n  long long v5;\n  int v6;\n  int v7;\n  char v8;\n  char *v10;\n  char *v11;\n  if (!mcand) return 0LL;\n  v2 = libmin_strlen(mcand);\n  v3 = libmin_malloc(v2 + 2);\n  v4 = v3;\n  if (!v3) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v3[v2 + 1] = 0;\n  if (v2 <= 0) {\n    *v3 = 48;\n  } else {\n    v5 = v2;\n    v6 = 0;\n    do {\n      v7 = v6 + (dgt - 48) * (mcand[v5 - 1] - 48);\n      v6 = v7 / 10;\n      v4[v5--] = v7 % 10 + 48;\n    } while (v5 != v2 - 1LL - (unsigned int)(v2 - 1));\n    v8 = v6 + 48;\n    *v4 = v8;\n    if (v8 != 48) return v4;\n  }\n  v10 = (char *)libmin_malloc(v2 + 1LL);\n  v11 = v10;\n  if (!v10) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v10[v2] = 0;\n  libmin_strcpy(v10, v4 + 1);\n  libmin_free(v4);\n  return v11;\n}", "binary": "longdiv/longdiv.host.O3", "assembly": "<times_digit>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ntest   %rdi,%rdi\nje     1f70 <times_digit+0x100>\nmovsbl %sil,%esi\nmov    %rdi,%rbp\nlea    -0x30(%rsi),%ebx\ncall   4890 <libmin_strlen>\nlea    0x2(%rax),%edi\nmov    %rax,%r14\nmovslq %edi,%rdi\ncall   22e0 <libmin_malloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1f80 <times_digit+0x110>\nmovslq %r14d,%r13\nmovb   $0x0,0x1(%r12,%r13,1)\nlea    0x1(%r13),%rdi\ntest   %r14d,%r14d\njle    1f30 <times_digit+0xc0>\nlea    -0x1(%r13),%rsi\nlea    -0x1(%r14),%eax\nmov    %r13,%rcx\nxor    %edx,%edx\nsub    %rax,%rsi\nmovsbl -0x1(%rbp,%rcx,1),%eax\nsub    $0x30,%eax\nimul   %ebx,%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    %eax,%r8d\nimul   $0x66666667,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x22,%rdx\nsub    %r8d,%edx\nlea    (%rdx,%rdx,4),%r8d\nadd    %r8d,%r8d\nsub    %r8d,%eax\nadd    $0x30,%eax\nmov    %al,(%r12,%rcx,1)\nsub    $0x1,%rcx\ncmp    %rsi,%rcx\njne    1ed0 <times_digit+0x60>\nadd    $0x30,%edx\nmov    %dl,(%r12)\ncmp    $0x30,%dl\nje     1f35 <times_digit+0xc5>\npop    %rbx\nmov    %r12,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopw   0x0(%rax,%rax,1)\nmovb   $0x30,(%r12)\ncall   22e0 <libmin_malloc>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     1f9d <times_digit+0x12d>\nmovb   $0x0,(%rbx,%r13,1)\nlea    0x1(%r12),%rsi\nmov    %rbx,%rdi\ncall   4870 <libmin_strcpy>\nmov    %r12,%rdi\nmov    %rbx,%r12\ncall   2390 <libmin_free>\npop    %rbx\nmov    %r12,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nxor    %r12d,%r12d\npop    %rbx\npop    %rbp\nmov    %r12,%rax\npop    %r12\npop    %r13\npop    %r14\nret\nnop\nlea    0x3159(%rip),%rdi\nxor    %eax,%eax\ncall   4620 <libmin_printf>\nmov    $0x1,%edi\ncall   22c0 <libmin_fail>\njmp    1eae <times_digit+0x3e>\nlea    0x313c(%rip),%rdi\nxor    %eax,%eax\ncall   4620 <libmin_printf>\nmov    $0x1,%edi\ncall   22c0 <libmin_fail>\njmp    1f42 <times_digit+0xd2>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "lu-decomp/lu-decomp.c", "function_name": "lu_decomposition", "content": "void lu_decomposition(double A[N][N], double L[N][N], double U[N][N]) {\n    for (int i = 0; i < N; i++) {\n        // Compute U row\n        for (int k = i; k < N; k++) {\n            double sum = 0;\n            for (int j = 0; j < i; j++)\n                sum += L[i][j] * U[j][k];\n            U[i][k] = A[i][k] - sum;\n        }\n\n        // Compute L column\n        for (int k = i; k < N; k++) {\n            if (i == k)\n                L[i][i] = 1.0;\n            else {\n                double sum = 0;\n                for (int j = 0; j < i; j++)\n                    sum += L[k][j] * U[j][i];\n                L[k][i] = (A[k][i] - sum) / U[i][i];\n            }\n        }\n    }\n}\n"}, "pseudo": {"path": "lu-decomp/lu-decomp.host.O3.pseudo", "function_name": "lu_decomposition", "address": "0x13a0", "label": "lu_decomposition", "content": "void __fastcall lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5])\n{\n  double *v4; // rsi\n  double *v5; // rax\n  unsigned __int64 v6; // rcx\n  int v7; // ebx\n  int v8; // r11d\n  double v9; // xmm0_8\n  int v10; // r9d\n  int v11; // r10d\n  double v12; // xmm0_8\n  double v13; // xmm0_8\n  double v14; // xmm0_8\n  double v15; // xmm0_8\n  double v16; // xmm2_8\n  double v17; // xmm0_8\n  double v18; // xmm0_8\n  double v19; // xmm0_8\n  double v20; // xmm0_8\n\n  v4 = (double *)U;\n  v5 = (double *)L;\n  v6 = 0LL;\n  v7 = 4;\n  v8 = 3;\n  v9 = 0.0;\n  v10 = 0;\n  v11 = 2;\n  while ( 1 )\n  {\n    ++v10;\n    *v4 = (*A)[0] - v9;\n    if ( v10 == 5 )\n      break;\n    if ( v6 )\n    {\n      v12 = *v5 * (*U)[1] + 0.0;\n      if ( (_DWORD)v6 != 1 )\n      {\n        v12 = v12 + v5[1] * (*U)[6];\n        if ( (_DWORD)v6 != 2 )\n        {\n          v12 = v12 + v5[2] * (*U)[11];\n          if ( (_DWORD)v6 == 4 )\n            v12 = v12 + v5[3] * (*U)[16];\n        }\n      }\n      v4[1] = (*A)[1] - v12;\n      if ( v11 != 5 )\n      {\n        v13 = *v5 * (*U)[2] + 0.0;\n        if ( (_DWORD)v6 != 1 )\n        {\n          v13 = v13 + v5[1] * (*U)[7];\n          if ( (_DWORD)v6 != 2 )\n          {\n            v13 = v13 + v5[2] * (*U)[12];\n            if ( (_DWORD)v6 == 4 )\n              v13 = v13 + v5[3] * (*U)[17];\n          }\n        }\n        v4[2] = (*A)[2] - v13;\n        if ( v8 != 5 )\n        {\n          v14 = *v5 * (*U)[3] + 0.0;\n          if ( v6 > 1 )\n          {\n            v14 = v14 + v5[1] * (*U)[8];\n            if ( (_DWORD)v6 != 2 )\n            {\n              v14 = v14 + v5[2] * (*U)[13];\n              if ( (_DWORD)v6 == 4 )\n                v14 = v14 + v5[3] * (*U)[18];\n            }\n          }\n          v4[3] = (*A)[3] - v14;\n          if ( v7 != 5 )\n          {\n            v15 = (*U)[4] * *v5 + 0.0;\n            if ( v6 > 1 )\n            {\n              v15 = v15 + (*U)[9] * v5[1];\n              if ( (_DWORD)v6 != 2 )\n              {\n                v15 = v15 + v5[2] * (*U)[14];\n                if ( (_DWORD)v6 == 4 )\n                  v15 = v15 + v5[3] * (*U)[19];\n              }\n            }\nLABEL_23:\n            v4[4] = (*A)[4] - v15;\n          }\n        }\n      }\n    }\n    else\n    {\n      v4[1] = (*A)[1];\n      if ( v11 != 5 )\n      {\n        v4[2] = (*A)[2];\n        if ( v8 != 5 )\n        {\n          v4[3] = (*A)[3];\n          v15 = 0.0;\n          if ( v7 != 5 )\n            goto LABEL_23;\n        }\n      }\n    }\n    (*L)[0] = 1.0;\n    v16 = 0.0;\n    if ( v6 )\n    {\n      v16 = v5[5] * (*U)[0] + 0.0;\n      if ( (_DWORD)v6 != 1 )\n      {\n        v16 = v16 + v5[6] * (*U)[5];\n        if ( (_DWORD)v6 != 2 )\n        {\n          v16 = v16 + v5[7] * (*U)[10];\n          if ( (_DWORD)v6 == 4 )\n            v16 = v16 + v5[8] * (*U)[15];\n        }\n      }\n    }\n    (*L)[5] = ((*A)[5] - v16) / *v4;\n    if ( v11 != 5 )\n    {\n      if ( v11 == (_DWORD)v6 )\n      {\n        (*L)[0] = 1.0;\n      }\n      else\n      {\n        if ( (int)v6 <= 0 )\n        {\n          v17 = 0.0;\n        }\n        else\n        {\n          v17 = v5[10] * (*U)[0] + 0.0;\n          if ( (_DWORD)v6 != 1 )\n          {\n            v17 = v17 + v5[11] * (*U)[5];\n            if ( (_DWORD)v6 != 2 )\n            {\n              v17 = v17 + v5[12] * (*U)[10];\n              if ( (_DWORD)v6 != 3 )\n                v17 = v17 + v5[13] * (*U)[15];\n            }\n          }\n        }\n        (*L)[10] = ((*A)[10] - v17) / *v4;\n      }\n      if ( v8 != 5 )\n      {\n        if ( v8 == (_DWORD)v6 )\n        {\n          (*L)[0] = 1.0;\n        }\n        else\n        {\n          if ( (int)v6 <= 0 )\n          {\n            v18 = 0.0;\n          }\n          else\n          {\n            v18 = v5[15] * (*U)[0] + 0.0;\n            if ( (_DWORD)v6 != 1 )\n            {\n              v18 = v18 + v5[16] * (*U)[5];\n              if ( (_DWORD)v6 != 2 )\n              {\n                v18 = v18 + v5[17] * (*U)[10];\n                if ( (_DWORD)v6 != 3 )\n                  v18 = v18 + v5[18] * (*U)[15];\n              }\n            }\n          }\n          (*L)[15] = ((*A)[15] - v18) / *v4;\n        }\n        if ( v7 != 5 )\n        {\n          if ( v7 == (_DWORD)v6 )\n          {\n            (*L)[0] = 1.0;\n          }\n          else\n          {\n            v19 = 0.0;\n            if ( (int)v6 > 0 )\n            {\n              v19 = (*U)[0] * v5[20] + 0.0;\n              if ( (_DWORD)v6 != 1 )\n              {\n                v19 = v19 + (*U)[5] * v5[21];\n                if ( (_DWORD)v6 != 2 )\n                {\n                  v19 = v19 + (*U)[10] * v5[22];\n                  if ( (_DWORD)v6 != 3 )\n                    v19 = v19 + v5[23] * (*U)[15];\n                }\n              }\n            }\n            (*L)[20] = ((*A)[20] - v19) / *v4;\n          }\n        }\n      }\n    }\n    U = (double (*)[5])((char *)U + 8);\n    v20 = v5[5];\n    v5 += 5;\n    ++v7;\n    ++v6;\n    L = (double (*)[5])((char *)L + 48);\n    A = (double (*)[5])((char *)A + 48);\n    v4 += 6;\n    ++v11;\n    ++v8;\n    v9 = v20 * (*U)[0] + 0.0;\n    if ( v10 != 1 )\n    {\n      v9 = v9 + v5[1] * (*U)[5];\n      if ( v10 != 2 )\n      {\n        v9 = v9 + v5[2] * (*U)[10];\n        if ( v10 == 4 )\n          v9 = v9 + v5[3] * (*U)[15];\n      }\n    }\n  }\n  (*L)[0] = 1.0;\n}\n"}, "pseudo_normalize": "void lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5]) {\n  double *v4;\n  double *v5;\n  unsigned long long v6;\n  int v7;\n  int v8;\n  double v9;\n  int v10;\n  int v11;\n  double v12;\n  double v13;\n  double v14;\n  double v15;\n  double v16;\n  double v17;\n  double v18;\n  double v19;\n  double v20;\n  v4 = (double *)U;\n  v5 = (double *)L;\n  v6 = 0LL;\n  v7 = 4;\n  v8 = 3;\n  v9 = 0.0;\n  v10 = 0;\n  v11 = 2;\n  while (1) {\n    ++v10;\n    *v4 = (*A)[0] - v9;\n    if (v10 == 5) break;\n    if (v6) {\n      v12 = *v5 * (*U)[1] + 0.0;\n      if ((uint32_t)v6 != 1) {\n        v12 = v12 + v5[1] * (*U)[6];\n        if ((uint32_t)v6 != 2) {\n          v12 = v12 + v5[2] * (*U)[11];\n          if ((uint32_t)v6 == 4) v12 = v12 + v5[3] * (*U)[16];\n        }\n      }\n      v4[1] = (*A)[1] - v12;\n      if (v11 != 5) {\n        v13 = *v5 * (*U)[2] + 0.0;\n        if ((uint32_t)v6 != 1) {\n          v13 = v13 + v5[1] * (*U)[7];\n          if ((uint32_t)v6 != 2) {\n            v13 = v13 + v5[2] * (*U)[12];\n            if ((uint32_t)v6 == 4) v13 = v13 + v5[3] * (*U)[17];\n          }\n        }\n        v4[2] = (*A)[2] - v13;\n        if (v8 != 5) {\n          v14 = *v5 * (*U)[3] + 0.0;\n          if (v6 > 1) {\n            v14 = v14 + v5[1] * (*U)[8];\n            if ((uint32_t)v6 != 2) {\n              v14 = v14 + v5[2] * (*U)[13];\n              if ((uint32_t)v6 == 4) v14 = v14 + v5[3] * (*U)[18];\n            }\n          }\n          v4[3] = (*A)[3] - v14;\n          if (v7 != 5) {\n            v15 = (*U)[4] * *v5 + 0.0;\n            if (v6 > 1) {\n              v15 = v15 + (*U)[9] * v5[1];\n              if ((uint32_t)v6 != 2) {\n                v15 = v15 + v5[2] * (*U)[14];\n                if ((uint32_t)v6 == 4) v15 = v15 + v5[3] * (*U)[19];\n              }\n            }\n          LABEL_23:\n            v4[4] = (*A)[4] - v15;\n          }\n        }\n      }\n    } else {\n      v4[1] = (*A)[1];\n      if (v11 != 5) {\n        v4[2] = (*A)[2];\n        if (v8 != 5) {\n          v4[3] = (*A)[3];\n          v15 = 0.0;\n          if (v7 != 5) goto LABEL_23;\n        }\n      }\n    }\n    (*L)[0] = 1.0;\n    v16 = 0.0;\n    if (v6) {\n      v16 = v5[5] * (*U)[0] + 0.0;\n      if ((uint32_t)v6 != 1) {\n        v16 = v16 + v5[6] * (*U)[5];\n        if ((uint32_t)v6 != 2) {\n          v16 = v16 + v5[7] * (*U)[10];\n          if ((uint32_t)v6 == 4) v16 = v16 + v5[8] * (*U)[15];\n        }\n      }\n    }\n    (*L)[5] = ((*A)[5] - v16) / *v4;\n    if (v11 != 5) {\n      if (v11 == (uint32_t)v6) {\n        (*L)[0] = 1.0;\n      } else {\n        if ((int)v6 <= 0) {\n          v17 = 0.0;\n        } else {\n          v17 = v5[10] * (*U)[0] + 0.0;\n          if ((uint32_t)v6 != 1) {\n            v17 = v17 + v5[11] * (*U)[5];\n            if ((uint32_t)v6 != 2) {\n              v17 = v17 + v5[12] * (*U)[10];\n              if ((uint32_t)v6 != 3) v17 = v17 + v5[13] * (*U)[15];\n            }\n          }\n        }\n        (*L)[10] = ((*A)[10] - v17) / *v4;\n      }\n      if (v8 != 5) {\n        if (v8 == (uint32_t)v6) {\n          (*L)[0] = 1.0;\n        } else {\n          if ((int)v6 <= 0) {\n            v18 = 0.0;\n          } else {\n            v18 = v5[15] * (*U)[0] + 0.0;\n            if ((uint32_t)v6 != 1) {\n              v18 = v18 + v5[16] * (*U)[5];\n              if ((uint32_t)v6 != 2) {\n                v18 = v18 + v5[17] * (*U)[10];\n                if ((uint32_t)v6 != 3) v18 = v18 + v5[18] * (*U)[15];\n              }\n            }\n          }\n          (*L)[15] = ((*A)[15] - v18) / *v4;\n        }\n        if (v7 != 5) {\n          if (v7 == (uint32_t)v6) {\n            (*L)[0] = 1.0;\n          } else {\n            v19 = 0.0;\n            if ((int)v6 > 0) {\n              v19 = (*U)[0] * v5[20] + 0.0;\n              if ((uint32_t)v6 != 1) {\n                v19 = v19 + (*U)[5] * v5[21];\n                if ((uint32_t)v6 != 2) {\n                  v19 = v19 + (*U)[10] * v5[22];\n                  if ((uint32_t)v6 != 3) v19 = v19 + v5[23] * (*U)[15];\n                }\n              }\n            }\n            (*L)[20] = ((*A)[20] - v19) / *v4;\n          }\n        }\n      }\n    }\n    U = (double(*)[5])((char *)U + 8);\n    v20 = v5[5];\n    v5 += 5;\n    ++v7;\n    ++v6;\n    L = (double(*)[5])((char *)L + 48);\n    A = (double(*)[5])((char *)A + 48);\n    v4 += 6;\n    ++v11;\n    ++v8;\n    v9 = v20 * (*U)[0] + 0.0;\n    if (v10 != 1) {\n      v9 = v9 + v5[1] * (*U)[5];\n      if (v10 != 2) {\n        v9 = v9 + v5[2] * (*U)[10];\n        if (v10 == 4) v9 = v9 + v5[3] * (*U)[15];\n      }\n    }\n  }\n  (*L)[0] = 1.0;\n}", "binary": "lu-decomp/lu-decomp.host.O3", "assembly": "<lu_decomposition>:\nendbr64\nmov    %rsi,%r8\npxor   %xmm1,%xmm1\nmovsd  0x2c65(%rip),%xmm3\npush   %rbp\nmov    %rdx,%rsi\npush   %rbx\nmov    %r8,%rax\nxor    %ecx,%ecx\nmov    $0x4,%ebx\nmov    $0x3,%r11d\nmovapd %xmm1,%xmm0\nxor    %r9d,%r9d\nmov    $0x2,%r10d\nmovsd  (%rdi),%xmm2\nadd    $0x1,%r9d\nsubsd  %xmm0,%xmm2\nmovsd  %xmm2,(%rsi)\ncmp    $0x5,%r9d\nje     17e4 <lu_decomposition+0x444>\nmov    %ecx,%ebp\ntest   %rcx,%rcx\nje     17f6 <lu_decomposition+0x456>\nmovsd  (%rax),%xmm0\nmulsd  0x8(%rdx),%xmm0\naddsd  %xmm1,%xmm0\ncmp    $0x1,%ecx\nje     1443 <lu_decomposition+0xa3>\nmovsd  0x8(%rax),%xmm2\nmulsd  0x30(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x2,%ecx\nje     1443 <lu_decomposition+0xa3>\nmovsd  0x10(%rax),%xmm2\nmulsd  0x58(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x4,%ecx\njne    1443 <lu_decomposition+0xa3>\nmovsd  0x18(%rax),%xmm2\nmulsd  0x80(%rdx),%xmm2\naddsd  %xmm2,%xmm0\nmovsd  0x8(%rdi),%xmm2\nsubsd  %xmm0,%xmm2\nmovsd  %xmm2,0x8(%rsi)\ncmp    $0x5,%r10d\nje     1571 <lu_decomposition+0x1d1>\nmovsd  (%rax),%xmm0\nmulsd  0x10(%rdx),%xmm0\naddsd  %xmm1,%xmm0\ncmp    $0x1,%ebp\nje     14a4 <lu_decomposition+0x104>\nmovsd  0x8(%rax),%xmm2\nmulsd  0x38(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x2,%ebp\nje     14a4 <lu_decomposition+0x104>\nmovsd  0x10(%rax),%xmm2\nmulsd  0x60(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x4,%ebp\njne    14a4 <lu_decomposition+0x104>\nmovsd  0x18(%rax),%xmm2\nmulsd  0x88(%rdx),%xmm2\naddsd  %xmm2,%xmm0\nmovsd  0x10(%rdi),%xmm2\nsubsd  %xmm0,%xmm2\nmovsd  %xmm2,0x10(%rsi)\ncmp    $0x5,%r11d\nje     1571 <lu_decomposition+0x1d1>\nmovsd  (%rax),%xmm0\nmulsd  0x18(%rdx),%xmm0\naddsd  %xmm1,%xmm0\ncmp    $0x1,%rcx\njbe    1506 <lu_decomposition+0x166>\nmovsd  0x8(%rax),%xmm2\nmulsd  0x40(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x2,%ebp\nje     1506 <lu_decomposition+0x166>\nmovsd  0x10(%rax),%xmm2\nmulsd  0x68(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x4,%ebp\njne    1506 <lu_decomposition+0x166>\nmovsd  0x18(%rax),%xmm2\nmulsd  0x90(%rdx),%xmm2\naddsd  %xmm2,%xmm0\nmovsd  0x18(%rdi),%xmm2\nsubsd  %xmm0,%xmm2\nmovsd  %xmm2,0x18(%rsi)\ncmp    $0x5,%ebx\nje     1571 <lu_decomposition+0x1d1>\nmovsd  0x20(%rdx),%xmm0\nmulsd  (%rax),%xmm0\naddsd  %xmm1,%xmm0\ncmp    $0x1,%rcx\njbe    1563 <lu_decomposition+0x1c3>\nmovsd  0x48(%rdx),%xmm2\nmulsd  0x8(%rax),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x2,%ebp\nje     1563 <lu_decomposition+0x1c3>\nmovsd  0x10(%rax),%xmm2\nmulsd  0x70(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x4,%ebp\njne    1563 <lu_decomposition+0x1c3>\nmovsd  0x18(%rax),%xmm2\nmulsd  0x98(%rdx),%xmm2\naddsd  %xmm2,%xmm0\nmovsd  0x20(%rdi),%xmm2\nsubsd  %xmm0,%xmm2\nmovsd  %xmm2,0x20(%rsi)\nmovsd  %xmm3,(%r8)\nmov    %ecx,%ebp\nmovapd %xmm1,%xmm2\ntest   %rcx,%rcx\nje     15c7 <lu_decomposition+0x227>\nmovsd  0x28(%rax),%xmm2\nmulsd  (%rdx),%xmm2\naddsd  %xmm1,%xmm2\ncmp    $0x1,%ecx\nje     15c7 <lu_decomposition+0x227>\nmovsd  0x30(%rax),%xmm0\nmulsd  0x28(%rdx),%xmm0\naddsd  %xmm0,%xmm2\ncmp    $0x2,%ebp\nje     15c7 <lu_decomposition+0x227>\nmovsd  0x38(%rax),%xmm0\nmulsd  0x50(%rdx),%xmm0\naddsd  %xmm0,%xmm2\ncmp    $0x4,%ebp\njne    15c7 <lu_decomposition+0x227>\nmovsd  0x40(%rax),%xmm0\nmulsd  0x78(%rdx),%xmm0\naddsd  %xmm0,%xmm2\nmovsd  0x28(%rdi),%xmm0\nsubsd  %xmm2,%xmm0\ndivsd  (%rsi),%xmm0\nmovsd  %xmm0,0x28(%r8)\ncmp    $0x5,%r10d\nje     174b <lu_decomposition+0x3ab>\ncmp    %ecx,%r10d\nje     17d0 <lu_decomposition+0x430>\ntest   %ebp,%ebp\njle    183a <lu_decomposition+0x49a>\nmovsd  0x50(%rax),%xmm0\nmulsd  (%rdx),%xmm0\naddsd  %xmm1,%xmm0\ncmp    $0x1,%ebp\nje     163b <lu_decomposition+0x29b>\nmovsd  0x58(%rax),%xmm2\nmulsd  0x28(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x2,%ebp\nje     163b <lu_decomposition+0x29b>\nmovsd  0x60(%rax),%xmm2\nmulsd  0x50(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x3,%ebp\nje     163b <lu_decomposition+0x29b>\nmovsd  0x68(%rax),%xmm2\nmulsd  0x78(%rdx),%xmm2\naddsd  %xmm2,%xmm0\nmovsd  0x50(%rdi),%xmm2\nsubsd  %xmm0,%xmm2\ndivsd  (%rsi),%xmm2\nmovsd  %xmm2,0x50(%r8)\ncmp    $0x5,%r11d\nje     174b <lu_decomposition+0x3ab>\ncmp    %ecx,%r11d\nje     17da <lu_decomposition+0x43a>\ntest   %ebp,%ebp\njle    1843 <lu_decomposition+0x4a3>\nmovsd  0x78(%rax),%xmm0\nmulsd  (%rdx),%xmm0\naddsd  %xmm1,%xmm0\ncmp    $0x1,%ebp\nje     16b8 <lu_decomposition+0x318>\nmovsd  0x80(%rax),%xmm2\nmulsd  0x28(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x2,%ebp\nje     16b8 <lu_decomposition+0x318>\nmovsd  0x88(%rax),%xmm2\nmulsd  0x50(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x3,%ebp\nje     16b8 <lu_decomposition+0x318>\nmovsd  0x90(%rax),%xmm2\nmulsd  0x78(%rdx),%xmm2\naddsd  %xmm2,%xmm0\nmovsd  0x78(%rdi),%xmm2\nsubsd  %xmm0,%xmm2\ndivsd  (%rsi),%xmm2\nmovsd  %xmm2,0x78(%r8)\ncmp    $0x5,%ebx\nje     174b <lu_decomposition+0x3ab>\ncmp    %ecx,%ebx\nje     17ec <lu_decomposition+0x44c>\nmovapd %xmm1,%xmm0\ntest   %ebp,%ebp\njle    1732 <lu_decomposition+0x392>\nmovsd  (%rdx),%xmm0\nmulsd  0xa0(%rax),%xmm0\naddsd  %xmm1,%xmm0\ncmp    $0x1,%ebp\nje     1732 <lu_decomposition+0x392>\nmovsd  0x28(%rdx),%xmm2\nmulsd  0xa8(%rax),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x2,%ebp\nje     1732 <lu_decomposition+0x392>\nmovsd  0x50(%rdx),%xmm2\nmulsd  0xb0(%rax),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x3,%ebp\nje     1732 <lu_decomposition+0x392>\nmovsd  0xb8(%rax),%xmm2\nmulsd  0x78(%rdx),%xmm2\naddsd  %xmm2,%xmm0\nmovsd  0xa0(%rdi),%xmm2\nsubsd  %xmm0,%xmm2\ndivsd  (%rsi),%xmm2\nmovsd  %xmm2,0xa0(%r8)\nadd    $0x8,%rdx\nmovsd  0x28(%rax),%xmm0\nadd    $0x28,%rax\nadd    $0x1,%ebx\nmulsd  (%rdx),%xmm0\nadd    $0x1,%rcx\nadd    $0x30,%r8\nadd    $0x30,%rdi\nadd    $0x30,%rsi\nadd    $0x1,%r10d\nadd    $0x1,%r11d\naddsd  %xmm1,%xmm0\ncmp    $0x1,%r9d\nje     13d5 <lu_decomposition+0x35>\nmovsd  0x8(%rax),%xmm2\nmulsd  0x28(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x2,%r9d\nje     13d5 <lu_decomposition+0x35>\nmovsd  0x10(%rax),%xmm2\nmulsd  0x50(%rdx),%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x4,%r9d\njne    13d5 <lu_decomposition+0x35>\nmovsd  0x18(%rax),%xmm2\nmulsd  0x78(%rdx),%xmm2\naddsd  %xmm2,%xmm0\njmp    13d5 <lu_decomposition+0x35>\nnopl   0x0(%rax,%rax,1)\nmovsd  %xmm3,(%r8)\njmp    164e <lu_decomposition+0x2ae>\nmovsd  %xmm3,(%r8)\njmp    16cb <lu_decomposition+0x32b>\nmovsd  %xmm3,(%r8)\npop    %rbx\npop    %rbp\nret\nmovsd  %xmm3,(%r8)\njmp    174b <lu_decomposition+0x3ab>\nmovsd  0x8(%rdi),%xmm0\nmovsd  %xmm0,0x8(%rsi)\ncmp    $0x5,%r10d\nje     1571 <lu_decomposition+0x1d1>\nmovsd  0x10(%rdi),%xmm0\nmovsd  %xmm0,0x10(%rsi)\ncmp    $0x5,%r11d\nje     1571 <lu_decomposition+0x1d1>\nmovsd  0x18(%rdi),%xmm0\nmovsd  %xmm0,0x18(%rsi)\nmovapd %xmm1,%xmm0\ncmp    $0x5,%ebx\njne    1563 <lu_decomposition+0x1c3>\njmp    1571 <lu_decomposition+0x1d1>\nmovapd %xmm1,%xmm0\njmp    163b <lu_decomposition+0x29b>\nmovapd %xmm1,%xmm0\njmp    16b8 <lu_decomposition+0x318>\nnopl   0x0(%rax)\n"}
{"source": {"path": "lu-decomp/lu-decomp.c", "function_name": "main", "content": "int main() {\n    double A[N][N] = {\n        {  2.0,  -1.0,   0.0,   0.0,   0.0 },\n        { -1.0,   2.0,  -1.0,   0.0,   0.0 },\n        {  0.0,  -1.0,   2.0,  -1.0,   0.0 },\n        {  0.0,   0.0,  -1.0,   2.0,  -1.0 },\n        {  0.0,   0.0,   0.0,  -1.0,   2.0 }\n    }; // A tridiagonal symmetric positive definite matrix\n\n#if 0\n    double A[N][N] = {\n        {2.0, -1.0, -2.0},\n        {-4.0, 6.0, 3.0},\n        {-4.0, -2.0, 8.0}\n    };\n#endif\n    double L[N][N] = {0};\n    double U[N][N] = {0};\n\n    lu_decomposition(A, L, U);\n\n    print_matrix(\"A\", A);\n    print_matrix(\"L\", L);\n    print_matrix(\"U\", U);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "lu-decomp/lu-decomp.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double A[5][5]; // [rsp+0h] [rbp-288h] BYREF\n  double L[5][5]; // [rsp+D0h] [rbp-1B8h] BYREF\n  double U[5][5]; // [rsp+1A0h] [rbp-E8h] BYREF\n  unsigned __int64 v6; // [rsp+268h] [rbp-20h]\n\n  v6 = __readfsqword(0x28u);\n  *(_OWORD *)&A[0][0] = xmmword_4020;\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  *(_OWORD *)&A[0][2] = 0LL;\n  memset(U, 0, sizeof(U));\n  *(_OWORD *)&A[0][4] = xmmword_4030;\n  *(_OWORD *)&A[1][1] = xmmword_4020;\n  *(_OWORD *)&A[1][3] = 0LL;\n  *(_OWORD *)&A[2][0] = xmmword_4030;\n  *(_OWORD *)&A[2][2] = xmmword_4020;\n  *(_OWORD *)&A[2][4] = 0LL;\n  *(_OWORD *)&A[3][1] = xmmword_4030;\n  *(_OWORD *)&A[3][3] = xmmword_4020;\n  *(_OWORD *)&A[4][0] = 0LL;\n  *(_OWORD *)&A[4][2] = xmmword_4030;\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double A[5][5];\n  double L[5][5];\n  double U[5][5];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  *(long double *)&A[0][0] = xmmword_4020;\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  *(long double *)&A[0][2] = 0LL;\n  memset(U, 0, sizeof(U));\n  *(long double *)&A[0][4] = xmmword_4030;\n  *(long double *)&A[1][1] = xmmword_4020;\n  *(long double *)&A[1][3] = 0LL;\n  *(long double *)&A[2][0] = xmmword_4030;\n  *(long double *)&A[2][2] = xmmword_4020;\n  *(long double *)&A[2][4] = 0LL;\n  *(long double *)&A[3][1] = xmmword_4030;\n  *(long double *)&A[3][3] = xmmword_4020;\n  *(long double *)&A[4][0] = 0LL;\n  *(long double *)&A[4][2] = xmmword_4030;\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}", "binary": "lu-decomp/lu-decomp.host.O3", "assembly": "<main>:\nendbr64\npush   %r13\nmov    $0x19,%ecx\npxor   %xmm1,%xmm1\npush   %r12\npush   %rbp\nsub    $0x270,%rsp\nmovapd 0x2eff(%rip),%xmm2\nmovapd 0x2f07(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x268(%rsp)\nxor    %eax,%eax\nmov    0x2edd(%rip),%rax\nlea    0xd0(%rsp),%rdi\nlea    0x1a0(%rsp),%rbp\nlea    0xd0(%rsp),%r12\nmov    %rsp,%r13\nmov    %rbp,%rdx\nmovaps %xmm2,(%rsp)\nmov    %rax,0xc0(%rsp)\nxor    %eax,%eax\nmov    %r12,%rsi\nrep stos %rax,%es:(%rdi)\nmov    $0x19,%ecx\nmovaps %xmm1,0x10(%rsp)\nlea    0x1a0(%rsp),%rdi\nrep stos %rax,%es:(%rdi)\nmov    %r13,%rdi\nmovaps %xmm0,0x20(%rsp)\nmovaps %xmm2,0x30(%rsp)\nmovaps %xmm1,0x40(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm2,0x60(%rsp)\nmovaps %xmm1,0x70(%rsp)\nmovaps %xmm0,0x80(%rsp)\nmovaps %xmm2,0x90(%rsp)\nmovaps %xmm1,0xa0(%rsp)\nmovaps %xmm0,0xb0(%rsp)\ncall   13a0 <lu_decomposition>\nmov    %r13,%rsi\nlea    0x2e37(%rip),%rdi\ncall   1320 <print_matrix>\nmov    %r12,%rsi\nlea    0x2e2a(%rip),%rdi\ncall   1320 <print_matrix>\nmov    %rbp,%rsi\nlea    0x2e1d(%rip),%rdi\ncall   1320 <print_matrix>\ncall   3b60 <libmin_success>\nmov    0x268(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1224 <main+0x124>\nadd    $0x270,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax)\n"}
{"source": {"path": "lu-decomp/lu-decomp.c", "function_name": "print_matrix", "content": "#include \"libmin.h\"\n\n#define N 5  // Matrix size\n// #define N 3  // Matrix size\n\nvoid print_matrix(const char* name, double mat[N][N]) {\n    libmin_printf(\"%s =\\n\", name);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            libmin_printf(\"%8.4f \", mat[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "lu-decomp/lu-decomp.host.O3.pseudo", "function_name": "print_matrix", "address": "0x1320", "label": "print_matrix", "content": "void __fastcall print_matrix(const char *name, double (*mat)[5])\n{\n  double *v2; // rbp\n  double *v3; // rbx\n  double v4; // xmm0_8\n\n  v2 = &(*mat)[5];\n  libmin_printf(\"%s =\\n\", name);\n  do\n  {\n    v3 = v2 - 5;\n    do\n    {\n      v4 = *v3++;\n      libmin_printf(\"%8.4f \", v4);\n    }\n    while ( v3 != v2 );\n    v2 = v3 + 5;\n    libmin_printf((char *)\"\\n\");\n  }\n  while ( v3 + 5 != &(*mat)[30] );\n  libmin_printf((char *)\"\\n\");\n}\n"}, "pseudo_normalize": "void print_matrix(const char *name, double (*mat)[5]) {\n  double *v2;\n  double *v3;\n  double v4;\n  v2 = &(*mat)[5];\n  libmin_printf(\"%s =\\n\", name);\n  do {\n    v3 = v2 - 5;\n    do {\n      v4 = *v3++;\n      libmin_printf(\"%8.4f \", v4);\n    } while (v3 != v2);\n    v2 = v3 + 5;\n    libmin_printf((char *)\"\\n\");\n  } while (v3 + 5 != &(*mat)[30]);\n  libmin_printf((char *)\"\\n\");\n}", "binary": "lu-decomp/lu-decomp.host.O3", "assembly": "<print_matrix>:\nendbr64\npush   %r14\nxor    %eax,%eax\nlea    0x2cd9(%rip),%r14\npush   %r13\nmov    %rsi,%r13\nmov    %rdi,%rsi\nlea    0x2cc6(%rip),%rdi\npush   %r12\nlea    0x2cc3(%rip),%r12\npush   %rbp\nlea    0x28(%r13),%rbp\nadd    $0xf0,%r13\npush   %rbx\ncall   3920 <libmin_printf>\nlea    -0x28(%rbp),%rbx\nmovsd  (%rbx),%xmm0\nmov    %r12,%rdi\nmov    $0x1,%eax\nadd    $0x8,%rbx\ncall   3920 <libmin_printf>\ncmp    %rbp,%rbx\njne    135d <print_matrix+0x3d>\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    0x28(%rbx),%rbp\ncall   3920 <libmin_printf>\ncmp    %r13,%rbp\njne    1359 <print_matrix+0x39>\npop    %rbx\nmov    %r14,%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %r14\njmp    3920 <libmin_printf>\nnopl   0x0(%rax)\n"}
{"source": {"path": "lz-compress/lz-compress.c", "function_name": "lz77_decompress", "content": "uint32_t lz77_decompress (uint8_t *compressed_text, uint8_t *uncompressed_text)\n{\n    uint8_t pointer_length_width;\n    uint16_t input_pointer, pointer_length, pointer_pos, pointer_length_mask;\n    uint32_t compressed_pointer, coding_pos, pointer_offset, uncompressed_size;\n\n    uncompressed_size = *((uint32_t *) compressed_text);\n    pointer_length_width = *(compressed_text + 4);\n    compressed_pointer = 5;\n\n    pointer_length_mask = (1 << pointer_length_width)- 1;\n\n\n    for(coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos)\n    {\n        input_pointer = *((uint16_t *) (compressed_text + compressed_pointer));\n        compressed_pointer += 2;\n        pointer_pos = input_pointer >> pointer_length_width;\n        pointer_length = pointer_pos ? ((input_pointer & pointer_length_mask) + 1) : 0;\n        if(pointer_pos)\n            for(pointer_offset = coding_pos - pointer_pos; pointer_length > 0; --pointer_length)\n                uncompressed_text[coding_pos++] = uncompressed_text[pointer_offset++];\n        *(uncompressed_text + coding_pos) = *(compressed_text + compressed_pointer++);\n    }\n\n    return coding_pos;\n}\n"}, "pseudo": {"path": "lz-compress/lz-compress.host.O3.pseudo", "function_name": "lz77_decompress", "address": "0x15f0", "label": "lz77_decompress", "content": "uint32_t __fastcall lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text)\n{\n  uint8_t v2; // cl\n  uint32_t v3; // r13d\n  uint32_t v6; // r9d\n  int v7; // r11d\n  int v8; // edi\n  unsigned __int16 v9; // r10\n  uint32_t v10; // eax\n  int v11; // ebp\n  __int64 v12; // rsi\n  __int64 v13; // rdx\n  uint8_t v14; // dl\n  __int64 v15; // rax\n\n  v2 = compressed_text[4];\n  v3 = *(_DWORD *)compressed_text;\n  if ( !*(_DWORD *)compressed_text )\n    return 0;\n  v6 = 0;\n  v7 = 5;\n  do\n  {\n    v8 = (int)*(unsigned __int16 *)&compressed_text[v7] >> v2;\n    if ( v8 )\n    {\n      v9 = ((1 << v2) - 1) & *(_WORD *)&compressed_text[v7];\n      v10 = v6 - v8;\n      if ( v9 != 0xFFFF )\n      {\n        v11 = v10 + v9 + 1;\n        do\n        {\n          v12 = v10;\n          v13 = v8 + v10++;\n          uncompressed_text[v13] = uncompressed_text[v12];\n        }\n        while ( v10 != v11 );\n        v6 += v9 + 1;\n      }\n    }\n    v14 = compressed_text[v7 + 2];\n    v15 = v6++;\n    v7 += 3;\n    uncompressed_text[v15] = v14;\n  }\n  while ( v3 > v6 );\n  return v6;\n}\n"}, "pseudo_normalize": "uint32_t lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text) {\n  uint8_t v2;\n  uint32_t v3;\n  uint32_t v6;\n  int v7;\n  int v8;\n  unsigned short v9;\n  uint32_t v10;\n  int v11;\n  long long v12;\n  long long v13;\n  uint8_t v14;\n  long long v15;\n  v2 = compressed_text[4];\n  v3 = *(uint32_t *)compressed_text;\n  if (!*(uint32_t *)compressed_text) return 0;\n  v6 = 0;\n  v7 = 5;\n  do {\n    v8 = (int)*(unsigned short *)&compressed_text[v7] >> v2;\n    if (v8) {\n      v9 = ((1 << v2) - 1) & *(unsigned short *)&compressed_text[v7];\n      v10 = v6 - v8;\n      if (v9 != 65535) {\n        v11 = v10 + v9 + 1;\n        do {\n          v12 = v10;\n          v13 = v8 + v10++;\n          uncompressed_text[v13] = uncompressed_text[v12];\n        } while (v10 != v11);\n        v6 += v9 + 1;\n      }\n    }\n    v14 = compressed_text[v7 + 2];\n    v15 = v6++;\n    v7 += 3;\n    uncompressed_text[v15] = v14;\n  } while (v3 > v6);\n  return v6;\n}", "binary": "lz-compress/lz-compress.host.O3", "assembly": "<lz77_decompress>:\nendbr64\npush   %r14\nmov    $0x1,%r14d\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmovzbl 0x4(%rdi),%ecx\nmov    (%rdi),%r13d\nshl    %cl,%r14d\nsub    $0x1,%r14d\ntest   %r13d,%r13d\nje     169f <lz77_decompress+0xaf>\nmov    %rdi,%r12\nmov    %rsi,%r8\nxor    %r9d,%r9d\nmov    $0x5,%r11d\nnopl   0x0(%rax,%rax,1)\nmov    %r11d,%eax\nlea    0x2(%r11),%ebx\nmovzwl (%r12,%rax,1),%edi\nmov    %edi,%r10d\nsar    %cl,%edi\ntest   %edi,%edi\nje     167a <lz77_decompress+0x8a>\nmov    %r9d,%eax\nand    %r14d,%r10d\nsub    %edi,%eax\ncmp    $0xffff,%r10w\nje     167a <lz77_decompress+0x8a>\nmovzwl %r10w,%r10d\nlea    0x1(%rax,%r10,1),%ebp\nnopl   (%rax)\nmov    %eax,%esi\nlea    (%rdi,%rax,1),%edx\nadd    $0x1,%eax\nmovzbl (%r8,%rsi,1),%esi\nmov    %sil,(%r8,%rdx,1)\ncmp    %ebp,%eax\njne    1660 <lz77_decompress+0x70>\nlea    0x1(%r10,%r9,1),%r9d\nmovzbl (%r12,%rbx,1),%edx\nmov    %r9d,%eax\nadd    $0x1,%r9d\nadd    $0x3,%r11d\nmov    %dl,(%r8,%rax,1)\ncmp    %r9d,%r13d\nja     1630 <lz77_decompress+0x40>\npop    %rbx\nmov    %r9d,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nxor    %r9d,%r9d\npop    %rbx\npop    %rbp\nmov    %r9d,%eax\npop    %r12\npop    %r13\npop    %r14\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "lz-compress/lz-compress.c", "function_name": "main", "content": "int main (int argc, char const *argv[])\n{\n    uint32_t compressed_size, uncompressed_size, orig_size;\n    uint8_t *compressed_text, *uncompressed_text;\n\n    libmin_mopen(infile, \"r\");\n    uncompressed_size = libmin_msize(infile);\n    libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n    uncompressed_text = libmin_malloc(uncompressed_size);\n    if((uncompressed_size != libmin_mread(uncompressed_text, uncompressed_size, infile)))\n        return 0;\n    libmin_mclose(infile);\n\n    compressed_text = libmin_malloc(MALLOC_SIZE);\n\n    for (unsigned i = 1; i < 16; ++i)\n    {\n      compressed_size = lz77_compress(uncompressed_text, uncompressed_size, compressed_text, i);\n      libmin_assert(compressed_size < MALLOC_SIZE);\n\n      orig_size = lz77_decompress(compressed_text, uncompressed_text);\n      libmin_assert(orig_size == uncompressed_size);\n\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i, compressed_size, uncompressed_size);\n    }\n\n    // output the final decompressed data\n    for (unsigned cnt=0; cnt < uncompressed_size; cnt++)\n      libmin_putc(uncompressed_text[cnt]);\n\n    libmin_success();\n}\n"}, "pseudo": {"path": "lz-compress/lz-compress.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  char *v3; // rbx\n  int v5; // r14d\n  uint8_t *v6; // rbp\n  uint8_t v7; // cl\n  unsigned int v8; // r13d\n  unsigned int v9; // edi\n  unsigned int v10; // r10d\n  __int64 v11; // r11\n  int v12; // esi\n  unsigned __int16 v13; // r8\n  unsigned int v14; // eax\n  int v15; // r12d\n  __int64 v16; // r9\n  __int64 v17; // rdx\n  __int64 v18; // rax\n  int v19; // esi\n  __int64 v20; // rbp\n  char v21; // di\n  uint32_t compressed_size; // [rsp+4h] [rbp-44h]\n  uint32_t v23; // [rsp+8h] [rbp-40h]\n\n  libmin_mopen(infile, \"r\");\n  v23 = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", v23);\n  v3 = (char *)libmin_malloc(v23);\n  if ( libmin_mread(v3, v23, infile) == v23 )\n  {\n    v5 = 1;\n    libmin_mclose(infile);\n    v6 = (uint8_t *)libmin_malloc(0x40000uLL);\n    while ( 1 )\n    {\n      compressed_size = lz77_compress((uint8_t *)v3, v23, v6, v5);\n      if ( compressed_size > 0x3FFFF )\n        break;\n      v7 = v6[4];\n      v8 = *(_DWORD *)v6;\n      v9 = 0;\n      if ( *(_DWORD *)v6 )\n      {\n        v10 = 5;\n        do\n        {\n          v11 = v10 + 2;\n          v12 = (int)*(unsigned __int16 *)&v6[v10] >> v7;\n          if ( v12 )\n          {\n            v13 = ((1 << v7) - 1) & *(_WORD *)&v6[v10];\n            v14 = v9 - v12;\n            if ( v13 != 0xFFFF )\n            {\n              v15 = v14 + v13 + 1;\n              do\n              {\n                v16 = v14;\n                v17 = v12 + v14++;\n                v3[v17] = v3[v16];\n              }\n              while ( v14 != v15 );\n              v9 += v13 + 1;\n            }\n          }\n          v18 = v9++;\n          v10 += 3;\n          v3[v18] = v6[v11];\n        }\n        while ( v8 > v9 );\n      }\n      if ( v23 != v9 )\n        libmin_fail(1);\n      v19 = v5++;\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", v19, compressed_size, v23);\n      if ( v5 == 16 )\n      {\n        if ( v23 )\n        {\n          v20 = (__int64)&v3[v23];\n          do\n          {\n            v21 = *v3++;\n            libmin_putc(v21);\n          }\n          while ( (char *)v20 != v3 );\n        }\n        libmin_success();\n      }\n    }\n    libmin_fail(1);\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  char *v3;\n  int v5;\n  uint8_t *v6;\n  uint8_t v7;\n  unsigned int v8;\n  unsigned int v9;\n  unsigned int v10;\n  long long v11;\n  int v12;\n  unsigned short v13;\n  unsigned int v14;\n  int v15;\n  long long v16;\n  long long v17;\n  long long v18;\n  int v19;\n  long long v20;\n  char v21;\n  uint32_t compressed_size;\n  uint32_t v23;\n  libmin_mopen(infile, \"r\");\n  v23 = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", v23);\n  v3 = (char *)libmin_malloc(v23);\n  if (libmin_mread(v3, v23, infile) == v23) {\n    v5 = 1;\n    libmin_mclose(infile);\n    v6 = (uint8_t *)libmin_malloc(262144uLL);\n    while (1) {\n      compressed_size = lz77_compress((uint8_t *)v3, v23, v6, v5);\n      if (compressed_size > 262143) break;\n      v7 = v6[4];\n      v8 = *(uint32_t *)v6;\n      v9 = 0;\n      if (*(uint32_t *)v6) {\n        v10 = 5;\n        do {\n          v11 = v10 + 2;\n          v12 = (int)*(unsigned short *)&v6[v10] >> v7;\n          if (v12) {\n            v13 = ((1 << v7) - 1) & *(unsigned short *)&v6[v10];\n            v14 = v9 - v12;\n            if (v13 != 65535) {\n              v15 = v14 + v13 + 1;\n              do {\n                v16 = v14;\n                v17 = v12 + v14++;\n                v3[v17] = v3[v16];\n              } while (v14 != v15);\n              v9 += v13 + 1;\n            }\n          }\n          v18 = v9++;\n          v10 += 3;\n          v3[v18] = v6[v11];\n        } while (v8 > v9);\n      }\n      if (v23 != v9) libmin_fail(1);\n      v19 = v5++;\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", v19,\n                    compressed_size, v23);\n      if (v5 == 16) {\n        if (v23) {\n          v20 = (long long)&v3[v23];\n          do {\n            v21 = *v3++;\n            libmin_putc(v21);\n          } while ((char *)v20 != v3);\n        }\n        libmin_success();\n      }\n    }\n    libmin_fail(1);\n  }\n  return 0;\n}", "binary": "lz-compress/lz-compress.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nlea    0x3ed7(%rip),%rsi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    0x13ee0(%rip),%rdi\ncall   1d10 <libmin_mopen>\nmov    0x13ed4(%rip),%rdi\ncall   1df0 <libmin_msize>\nlea    0x3eae(%rip),%rdi\nmov    %rax,%rbx\nmov    %eax,%esi\nmov    %rax,0x8(%rsp)\nmov    %ebx,%ebp\nmov    %eax,(%rsp)\nxor    %eax,%eax\ncall   3cf0 <libmin_printf>\nmov    %rbp,%rdi\ncall   18b0 <libmin_malloc>\nmov    0x13ea3(%rip),%rdx\nmov    %rbp,%rsi\nmov    %rax,%rdi\nmov    %rax,%rbx\ncall   1d60 <libmin_mread>\ncmp    %rbp,%rax\nje     11a1 <main+0x81>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    0x13e78(%rip),%rdi\nmov    $0x1,%r14d\ncall   1b50 <libmin_mclose>\nmov    $0x40000,%edi\ncall   18b0 <libmin_malloc>\nmov    %rax,%rbp\nmov    (%rsp),%esi\nmov    %r14d,%ecx\nmov    %rbp,%rdx\nmov    %rbx,%rdi\ncall   13e0 <lz77_compress>\nmov    %eax,0x4(%rsp)\ncmp    $0x3ffff,%eax\nja     12d8 <main+0x1b8>\nmovzbl 0x4(%rbp),%ecx\nmov    $0x1,%r15d\nmov    0x0(%rbp),%r13d\nxor    %edi,%edi\nshl    %cl,%r15d\nsub    $0x1,%r15d\ntest   %r13d,%r13d\nje     126b <main+0x14b>\nmov    $0x5,%r10d\nnopw   0x0(%rax,%rax,1)\nmov    %r10d,%eax\nlea    0x2(%r10),%r11d\nmovzwl 0x0(%rbp,%rax,1),%esi\nmov    %esi,%r8d\nsar    %cl,%esi\ntest   %esi,%esi\nje     1254 <main+0x134>\nmov    %edi,%eax\nand    %r15d,%r8d\nsub    %esi,%eax\ncmp    $0xffff,%r8w\nje     1254 <main+0x134>\nmovzwl %r8w,%r8d\nlea    0x1(%rax,%r8,1),%r12d\nnopl   0x0(%rax)\nmov    %eax,%r9d\nlea    (%rsi,%rax,1),%edx\nadd    $0x1,%eax\nmovzbl (%rbx,%r9,1),%r9d\nmov    %r9b,(%rbx,%rdx,1)\ncmp    %r12d,%eax\njne    1238 <main+0x118>\nlea    0x1(%rdi,%r8,1),%edi\nmovzbl 0x0(%rbp,%r11,1),%edx\nmov    %edi,%eax\nadd    $0x1,%edi\nadd    $0x3,%r10d\nmov    %dl,(%rbx,%rax,1)\ncmp    %edi,%r13d\nja     1208 <main+0xe8>\nmov    (%rsp),%r15d\ncmp    %edi,%r15d\nje     127e <main+0x15e>\nmov    $0x1,%edi\ncall   1890 <libmin_fail>\nmov    0x4(%rsp),%edx\nmov    %r14d,%esi\nmov    %r15d,%ecx\nxor    %eax,%eax\nlea    0x3d97(%rip),%rdi\nadd    $0x1,%r14d\ncall   3cf0 <libmin_printf>\ncmp    $0x10,%r14d\njne    11c0 <main+0xa0>\nmov    0x8(%rsp),%rax\ntest   %eax,%eax\nje     12c9 <main+0x1a9>\nsub    $0x1,%eax\nlea    0x1(%rbx,%rax,1),%rbp\nnopl   (%rax)\nmovsbl (%rbx),%edi\nadd    $0x1,%rbx\ncall   3f00 <libmin_putc>\ncmp    %rbx,%rbp\njne    12b8 <main+0x198>\ncall   3fa0 <libmin_success>\njmp    1190 <main+0x70>\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%edi\ncall   1890 <libmin_fail>\njmp    11e0 <main+0xc0>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "mandelbrot/mandelbrot.c", "function_name": "color", "content": "/**  mandel.c   by Eric R. Weeks   written 9-28-96\n **  weeks@dept.physics.upenn.edu\n **  http://dept.physics.upenn.edu/~weeks/\n **  \n **  This program is public domain, but this header must be left intact\n **  and unchanged.\n **  \n **  to compile:  cc -o mand mandel.c\n ** \n **/\n\n#include \"libmin.h\"\n\nvoid\ncolor(int red, int green, int blue)\n{\n  libmin_printf(\"<%d,%d,%d>\\n\", red, green, blue);\n}\n"}, "pseudo": {"path": "mandelbrot/mandelbrot.host.O3.pseudo", "function_name": "color", "address": "0x13b0", "label": "color", "content": "void __fastcall color(int red, int green, int blue)\n{\n  libmin_printf(\"<%d,%d,%d>\\n\", red, green, blue);\n}\n"}, "pseudo_normalize": "", "binary": "mandelbrot/mandelbrot.host.O3", "assembly": "<color>:\nendbr64\nmov    %edx,%ecx\nxor    %eax,%eax\nmov    %esi,%edx\nmov    %edi,%esi\nlea    0x2c41(%rip),%rdi\njmp    34a0 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "mandelbrot/mandelbrot.c", "function_name": "main", "content": "int\nmain(void)\n{\n  double x, xx, y, cx, cy;\n  int iteration, hx, hy;\n  int itermax = 100;\t\t/* how many iterations to do\t*/\n  double magnify = 1.0;\t\t/* no magnification\t\t*/\n  int hxres = 78;\t\t/* horizonal resolution\t\t*/\n  int hyres = 48;\t\t/* vertical resolution\t\t*/\n\n  /* header for PPM output */\n  libmin_printf(\"** Mandelbrot ASCII image\\n\");\n  libmin_printf(\"** xres: %d, yres: %d\\n\", hxres, hyres);\n\n  for (hy=1; hy <= hyres; hy++)\n    {\n      for (hx=1; hx <= hxres; hx++)\n\t{\n\t  cx = (((float)hx)/((float)hxres)-0.5)/magnify*3.0-0.7;\n\t  cy = (((float)hy)/((float)hyres)-0.5)/magnify*3.0;\n\t  x = 0.0; y = 0.0;\n\n\t  for (iteration=1; iteration < itermax; iteration++)\n\t    {\n\t      xx = x*x-y*y+cx;\n\t      y = 2.0*x*y+cy;\n\t      x = xx;\n\t      if (x*x+y*y > 100.0)\n\t\titeration = 999999;\n\t    }\n\t  if (iteration < 99999)\n\t    libmin_printf(\" \");\n\t  else\n\t    libmin_printf(\"0\");\n\t}\n      libmin_printf(\"\\n\");\n    }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "mandelbrot/mandelbrot.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r12d\n  __int128 v4; // xmm7\n  int v5; // r14d\n  double v6; // xmm5_8\n  int v7; // eax\n  double v8; // xmm2_8\n  __int128 v9; // xmm1\n  double v10; // xmm3_8\n  __int128 v11; // xmm0\n  double v12; // [rsp+8h] [rbp-30h]\n  double v13; // [rsp+8h] [rbp-30h]\n\n  v3 = 1;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  v4 = 0LL;\nLABEL_2:\n  v5 = 1;\n  v6 = ((float)((float)v3 / 48.0) - 0.5) * 3.0;\n  while ( 1 )\n  {\nLABEL_4:\n    v7 = 1;\n    v8 = *(double *)&v4;\n    v9 = v4;\n    v10 = *(double *)&v4;\n    while ( 1 )\n    {\n      *((_QWORD *)&v11 + 1) = *((_QWORD *)&v9 + 1);\n      v8 = v8 * (*(double *)&v9 + *(double *)&v9) + v6;\n      *(double *)&v11 = *(double *)&v9 * *(double *)&v9 - v10 + ((float)((float)v5 / 78.0) - 0.5) * 3.0 - 0.7;\n      v10 = v8 * v8;\n      if ( *(double *)&v11 * *(double *)&v11 + v8 * v8 > 100.0 )\n        break;\n      if ( ++v7 == 100 )\n      {\n        v13 = v6;\n        ++v5;\n        libmin_printf(\" \");\n        v6 = v13;\n        v4 = 0LL;\n        if ( v5 == 79 )\n          goto LABEL_9;\n        goto LABEL_4;\n      }\n      v9 = v11;\n    }\n    v12 = v6;\n    ++v5;\n    libmin_printf(\"0\");\n    v6 = v12;\n    v4 = 0LL;\n    if ( v5 == 79 )\n    {\nLABEL_9:\n      ++v3;\n      libmin_printf((char *)\"\\n\");\n      v4 = 0LL;\n      if ( v3 == 49 )\n        libmin_success();\n      goto LABEL_2;\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  __int128 v4;\n  int v5;\n  double v6;\n  int v7;\n  double v8;\n  __int128 v9;\n  double v10;\n  __int128 v11;\n  double v12;\n  double v13;\n  v3 = 1;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  v4 = 0LL;\nLABEL_2:\n  v5 = 1;\n  v6 = ((float)((float)v3 / 48.0) - 0.5) * 3.0;\n  while (1) {\n  LABEL_4:\n    v7 = 1;\n    v8 = *(double *)&v4;\n    v9 = v4;\n    v10 = *(double *)&v4;\n    while (1) {\n      *((uint64_t *)&v11 + 1) = *((uint64_t *)&v9 + 1);\n      v8 = v8 * (*(double *)&v9 + *(double *)&v9) + v6;\n      *(double *)&v11 = *(double *)&v9 * *(double *)&v9 - v10 +\n                        ((float)((float)v5 / 78.0) - 0.5) * 3.0 - 0.7;\n      v10 = v8 * v8;\n      if (*(double *)&v11 * *(double *)&v11 + v8 * v8 > 100.0) break;\n      if (++v7 == 100) {\n        v13 = v6;\n        ++v5;\n        libmin_printf(\" \");\n        v6 = v13;\n        v4 = 0LL;\n        if (v5 == 79) goto LABEL_9;\n        goto LABEL_4;\n      }\n      v9 = v11;\n    }\n    v12 = v6;\n    ++v5;\n    libmin_printf(\"0\");\n    v6 = v12;\n    v4 = 0LL;\n    if (v5 == 79) {\n    LABEL_9:\n      ++v3;\n      libmin_printf((char *)\"\\n\");\n      v4 = 0LL;\n      if (v3 == 49) libmin_success();\n      goto LABEL_2;\n    }\n  }\n}", "binary": "mandelbrot/mandelbrot.host.O3", "assembly": "<main>:\nendbr64\npush   %r14\nlea    0x2f03(%rip),%rdi\nxor    %eax,%eax\npush   %r13\nlea    0x2ef6(%rip),%r13\npush   %r12\nmov    $0x1,%r12d\npush   %rbp\npush   %rbx\nlea    0x2f1b(%rip),%rbx\nsub    $0x10,%rsp\ncall   34a0 <libmin_printf>\nmov    $0x30,%edx\nmov    $0x4e,%esi\nxor    %eax,%eax\nlea    0x2ee6(%rip),%rdi\ncall   34a0 <libmin_printf>\nmovsd  0x2f16(%rip),%xmm6\npxor   %xmm7,%xmm7\npxor   %xmm5,%xmm5\nmov    $0x1,%r14d\nlea    0x2edb(%rip),%rbp\ncvtsi2ss %r12d,%xmm5\ndivss  0x2ed8(%rip),%xmm5\ncvtss2sd %xmm5,%xmm5\nsubsd  0x2ed0(%rip),%xmm5\nmulsd  0x2ed0(%rip),%xmm5\njmp    11c4 <main+0xc4>\nnopw   0x0(%rax,%rax,1)\nmov    %rbx,%rdi\nxor    %eax,%eax\nmovsd  %xmm5,0x8(%rsp)\nadd    $0x1,%r14d\ncall   34a0 <libmin_printf>\nmov    0x2ebd(%rip),%rax\nmovsd  0x8(%rsp),%xmm5\npxor   %xmm7,%xmm7\nmovq   %rax,%xmm6\ncmp    $0x4f,%r14d\nje     1284 <main+0x184>\npxor   %xmm4,%xmm4\nmov    $0x1,%eax\nmovapd %xmm7,%xmm2\ncvtsi2ss %r14d,%xmm4\nmovapd %xmm7,%xmm1\nmovapd %xmm7,%xmm3\ndivss  0x2e62(%rip),%xmm4\ncvtss2sd %xmm4,%xmm4\nsubsd  0x2e5e(%rip),%xmm4\nmulsd  0x2e5e(%rip),%xmm4\nsubsd  0x2e5e(%rip),%xmm4\nmovapd %xmm1,%xmm0\nmulsd  %xmm1,%xmm0\naddsd  %xmm1,%xmm1\nmulsd  %xmm1,%xmm2\nsubsd  %xmm3,%xmm0\naddsd  %xmm5,%xmm2\naddsd  %xmm4,%xmm0\nmovapd %xmm2,%xmm3\nmovapd %xmm0,%xmm1\nmulsd  %xmm2,%xmm3\nmulsd  %xmm0,%xmm1\naddsd  %xmm3,%xmm1\ncomisd %xmm6,%xmm1\nja     1190 <main+0x90>\nadd    $0x1,%eax\ncmp    $0x64,%eax\nje     1250 <main+0x150>\nmovapd %xmm0,%xmm1\njmp    1202 <main+0x102>\nnopw   0x0(%rax,%rax,1)\nmov    %rbp,%rdi\nxor    %eax,%eax\nmovsd  %xmm5,0x8(%rsp)\nadd    $0x1,%r14d\ncall   34a0 <libmin_printf>\nmov    0x2dfd(%rip),%rax\nmovsd  0x8(%rsp),%xmm5\npxor   %xmm7,%xmm7\nmovq   %rax,%xmm6\ncmp    $0x4f,%r14d\njne    11c4 <main+0xc4>\nxor    %eax,%eax\nmov    %r13,%rdi\nadd    $0x1,%r12d\ncall   34a0 <libmin_printf>\nmov    0x2dcf(%rip),%rax\ncmp    $0x31,%r12d\npxor   %xmm7,%xmm7\nmovq   %rax,%xmm6\njne    1156 <main+0x56>\ncall   36e0 <libmin_success>\nadd    $0x10,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n"}
{"source": {"path": "matmult/matmult.c", "function_name": "main", "content": "   // Reference result using an alternative loop order (order: i, k, j)\n\nint main() {\n    // Initialize random seed\n    libmin_srand(12345);\n\n    // Initialize matrices A and B with random data; zero out C and refC\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            // Use modulo to restrict the range of random numbers (0..99)\n            A[i][j] = libmin_rand() % 1000;\n            B[i][j] = libmin_rand() % 1000;\n            C[i][j] = 0;\n            refC[i][j] = 0;\n        }\n    }\n\n    // --- First Multiplication: Loop order (i, j, k) ---\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    // --- Second Multiplication (Reference): Loop order (i, k, j) ---\n    for (int i = 0; i < N; i++) {\n        for (int k = 0; k < N; k++) {\n            for (int j = 0; j < N; j++) {\n                refC[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    // --- Verification: Compare C and refC ---\n    int error = 0;\n    for (int i = 0; i < N && !error; i++) {\n        for (int j = 0; j < N && !error; j++) {\n            if (C[i][j] != refC[i][j]) {\n                libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", \n                                i, j, C[i][j], refC[i][j]);\n                error = 1;\n            }\n        }\n    }\n\n    // --- Final Reporting ---\n    if (error) {\n        // If an error is detected, print a failure message.\n        libtarg_fail(1);\n    } else {\n        // Compute a checksum of the result matrix for quick verification.\n        int checksum = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                checksum = (checksum + C[i][j]) % 100000;\n            }\n        }\n        libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", checksum);\n        \n        // Print the computed result matrix.\n        libmin_printf(\"Result Matrix C:\\n\");\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                libmin_printf(\"%d \", C[i][j]);\n            }\n            libmin_printf(\"\\n\");\n        }\n        \n        libtarg_success();\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "matmult/matmult.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // r13\n  int *v4; // r12\n  int *v5; // rbp\n  __int64 *v6; // rbx\n  __int64 i; // r15\n  unsigned int v8; // eax\n  __int64 *v9; // rdi\n  __m128i *v10; // rdx\n  const __m128i *v11; // rax\n  unsigned int *v12; // rcx\n  __m128i v13; // xmm7\n  __m128i si128; // xmm3\n  __m128i v15; // xmm0\n  __m128i v16; // xmm1\n  __m128i *v17; // rdx\n  int v18; // edi\n  const __m128i *v19; // rax\n  __int64 v20; // rsi\n  __m128i v21; // xmm2\n  __int64 v22; // rcx\n  __m128i v23; // xmm1\n  __m128i v24; // xmm7\n  __m128i v25; // xmm3\n  __m128i v26; // xmm0\n  __m128i v27; // xmm4\n  __m128i v28; // xmm2\n  __m128i v29; // xmm6\n  __m128i v30; // xmm5\n  __m128i v31; // xmm4\n  __m128i v32; // xmm6\n  __m128i v33; // xmm5\n  __m128i v34; // xmm4\n  __m128i v35; // xmm6\n  __m128i v36; // xmm5\n  __m128i v37; // xmm4\n  __m128i v38; // xmm6\n  __m128i v39; // xmm4\n  __m128i v40; // xmm6\n  __m128i v41; // xmm4\n  __m128i v42; // xmm5\n  __m128i v43; // xmm4\n  __m128i v44; // xmm5\n  __m128i v45; // xmm6\n  __m128i v46; // xmm7\n  __m128i v47; // xmm8\n  __m128i v48; // xmm9\n  __m128i v49; // xmm10\n  __m128i v50; // xmm11\n  __m128i v51; // xmm12\n  __m128i v52; // xmm13\n  __m128i v53; // xmm0\n  __int64 v54; // rsi\n  __m128i v55; // xmm14\n  __int64 v56; // rsi\n  __int64 v57; // rcx\n  __m128i v58; // xmm0\n  __m128i v59; // xmm1\n  __m128i v60; // xmm15\n  __m128i v61; // xmm2\n  __m128i v62; // xmm3\n  __m128i v63; // xmm2\n  __m128i v64; // xmm3\n  __m128i v65; // xmm2\n  __m128i v66; // xmm3\n  __m128i v67; // xmm4\n  __m128i v68; // xmm5\n  __m128i v69; // xmm6\n  __m128i v70; // xmm7\n  __m128i v71; // xmm8\n  __m128i v72; // xmm9\n  __m128i v73; // xmm10\n  __m128i v74; // xmm11\n  __m128i v75; // xmm12\n  __m128i v76; // xmm13\n  __m128i v77; // xmm14\n  __m128i v78; // xmm0\n  __m128i v79; // xmm1\n  int *v80; // rcx\n  __int64 j; // rdx\n  __int64 k; // rax\n  int v83; // r9d\n  int v84; // r8d\n  int v85; // eax\n  int *v86; // rbx\n  int v87; // esi\n  int *v88; // rbp\n  int *v89; // rdi\n  int *v90; // rax\n  int v91; // esi\n  int *v92; // r12\n  int v93; // esi\n  int *v94; // [rsp+8h] [rbp-90h]\n  __m128i v95; // [rsp+10h] [rbp-88h] BYREF\n  __m128i v96; // [rsp+20h] [rbp-78h]\n  __m128i v97; // [rsp+30h] [rbp-68h] BYREF\n  __m128i v98; // [rsp+40h] [rbp-58h] BYREF\n  __m128i v99[4]; // [rsp+50h] [rbp-48h] BYREF\n\n  v3 = refC[0];\n  v4 = C[0];\n  v5 = B[0];\n  libmin_srand(0x3039u);\n  v94 = A[0];\n  v6 = (__int64 *)A[0];\n  do\n  {\n    for ( i = 0LL; i != 64; ++i )\n    {\n      *(_DWORD *)((char *)v6 + i * 4) = libmin_rand() % 0x3E8;\n      v8 = libmin_rand();\n      v4[i] = 0;\n      v3[i] = 0;\n      v5[i] = v8 % 0x3E8;\n    }\n    v6 += 32;\n    v5 += 64;\n    v4 += 64;\n    v3 += 64;\n  }\n  while ( v6 != &_start_time );\n  v9 = &_start_time - 2048;\n  v10 = (__m128i *)B[-64];\n  do\n  {\n    v11 = (const __m128i *)B;\n    v12 = (unsigned int *)v9;\n    do\n    {\n      v13 = _mm_cvtsi32_si128(*v12);\n      si128 = _mm_load_si128(v11);\n      v11 += 16;\n      ++v12;\n      v15 = _mm_shuffle_epi32(v13, 0);\n      v16 = _mm_srli_epi64(v15, 0x20u);\n      *v10 = _mm_add_epi32(\n               _mm_unpacklo_epi32(\n                 _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-16]), 8),\n                 _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(si128, 0x20u), v16), 8)),\n               *v10);\n      v10[1] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-15]), 8),\n                   _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 15), 0x20u), v16), 8)),\n                 v10[1]);\n      v10[2] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-14]), 8),\n                   _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 14), 0x20u), v16), 8)),\n                 v10[2]);\n      v10[3] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-13]), 8),\n                   _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 13), 0x20u), v16), 8)),\n                 v10[3]);\n      v10[4] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-12]), 8),\n                   _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 12), 0x20u), v16), 8)),\n                 v10[4]);\n      v10[5] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-11]), 8),\n                   _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 11), 0x20u), v16), 8)),\n                 v10[5]);\n      v10[6] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-10]), 8),\n                   _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 10), 0x20u), v16), 8)),\n                 v10[6]);\n      v10[7] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-9]), 8),\n                   _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 9), 0x20u), v16), 8)),\n                 v10[7]);\n      v10[8] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-8]), 8),\n                   _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 8), 0x20u), v16), 8)),\n                 v10[8]);\n      v10[9] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-7]), 8),\n                   _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 7), 0x20u), v16), 8)),\n                 v10[9]);\n      v10[10] = _mm_add_epi32(\n                  _mm_unpacklo_epi32(\n                    _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-6]), 8),\n                    _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 6), 0x20u), v16), 8)),\n                  v10[10]);\n      v10[11] = _mm_add_epi32(\n                  _mm_unpacklo_epi32(\n                    _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-5]), 8),\n                    _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 5), 0x20u), v16), 8)),\n                  v10[11]);\n      v10[12] = _mm_add_epi32(\n                  _mm_unpacklo_epi32(\n                    _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-4]), 8),\n                    _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 4), 0x20u), v16), 8)),\n                  v10[12]);\n      v10[13] = _mm_add_epi32(\n                  _mm_unpacklo_epi32(\n                    _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-3]), 8),\n                    _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 3), 0x20u), v16), 8)),\n                  v10[13]);\n      v10[14] = _mm_add_epi32(\n                  _mm_unpacklo_epi32(\n                    _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-2]), 8),\n                    _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v11 - 2), 0x20u), v16), 8)),\n                  v10[14]);\n      v10[15] = _mm_add_epi32(\n                  _mm_unpacklo_epi32(\n                    _mm_shuffle_epi32(_mm_mul_epu32(v15, v11[-1]), 8),\n                    _mm_shuffle_epi32(_mm_mul_epu32(v16, _mm_srli_epi64(_mm_load_si128(v11 - 1), 0x20u)), 8)),\n                  v10[15]);\n    }\n    while ( v11 != (const __m128i *)B[64] );\n    v10 += 16;\n    v9 += 32;\n  }\n  while ( v10 != (__m128i *)B );\n  v17 = (__m128i *)refC;\n  v18 = 0;\n  do\n  {\n    v19 = (const __m128i *)B;\n    v20 = 2LL;\n    do\n    {\n      v21 = _mm_load_si128(v19);\n      v22 = (int)v20;\n      v19 += 32;\n      v23 = _mm_shuffle_epi32(_mm_cvtsi32_si128(v94[v20 - 2]), 0);\n      v24 = _mm_cvtsi32_si128(v94[v20 - 1]);\n      v20 += 2LL;\n      v25 = _mm_srli_epi64(v23, 0x20u);\n      v26 = _mm_shuffle_epi32(v24, 0);\n      v27 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-32]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(v21, 0x20u), v25), 8)),\n              *v17);\n      v28 = _mm_srli_epi64(v26, 0x20u);\n      v29 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-16]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 16), 0x20u), v28), 8)),\n              v27);\n      *v17 = v29;\n      v30 = _mm_load_si128(v19 - 31);\n      v31 = _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-31]), 8);\n      v95 = v29;\n      v32 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-15]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 15), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(v31, _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(v30, 0x20u), v25), 8)),\n                v17[1]));\n      v17[1] = v32;\n      v33 = _mm_load_si128(v19 - 30);\n      v34 = _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-30]), 8);\n      v96 = v32;\n      v35 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-14]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 14), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(v34, _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(v33, 0x20u), v25), 8)),\n                v17[2]));\n      v17[2] = v35;\n      v36 = _mm_load_si128(v19 - 29);\n      v37 = _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-29]), 8);\n      v97 = v35;\n      v38 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-13]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 13), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(v37, _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(v36, 0x20u), v25), 8)),\n                v17[3]));\n      v17[3] = v38;\n      v39 = _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-28]), 8);\n      v98 = v38;\n      v40 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-12]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 12), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  v39,\n                  _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 28), 0x20u), v25), 8)),\n                v17[4]));\n      v17[4] = v40;\n      v41 = _mm_load_si128(v19 - 27);\n      v42 = _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-27]), 8);\n      v99[0] = v40;\n      v43 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-11]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 11), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(v42, _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(v41, 0x20u), v25), 8)),\n                v17[5]));\n      v17[5] = v43;\n      v44 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-10]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 10), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-26]), 8),\n                  _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 26), 0x20u), v25), 8)),\n                v17[6]));\n      v17[6] = v44;\n      v45 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-9]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 9), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-25]), 8),\n                  _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 25), 0x20u), v25), 8)),\n                v17[7]));\n      v17[7] = v45;\n      v46 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-8]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 8), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-24]), 8),\n                  _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 24), 0x20u), v25), 8)),\n                v17[8]));\n      v17[8] = v46;\n      v47 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-7]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 7), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-23]), 8),\n                  _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 23), 0x20u), v25), 8)),\n                v17[9]));\n      v17[9] = v47;\n      v48 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-6]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 6), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-22]), 8),\n                  _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 22), 0x20u), v25), 8)),\n                v17[10]));\n      v17[10] = v48;\n      v49 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-5]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 5), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-21]), 8),\n                  _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 21), 0x20u), v25), 8)),\n                v17[11]));\n      v17[11] = v49;\n      v50 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-4]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 4), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-20]), 8),\n                  _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 20), 0x20u), v25), 8)),\n                v17[12]));\n      v17[12] = v50;\n      v51 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-3]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 3), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-19]), 8),\n                  _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 19), 0x20u), v25), 8)),\n                v17[13]));\n      v17[13] = v51;\n      v52 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-2]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 2), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-18]), 8),\n                  _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 18), 0x20u), v25), 8)),\n                v17[14]));\n      v17[14] = v52;\n      v53 = _mm_add_epi32(\n              _mm_unpacklo_epi32(\n                _mm_shuffle_epi32(_mm_mul_epu32(v26, v19[-1]), 8),\n                _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 1), 0x20u), v28), 8)),\n              _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v23, v19[-17]), 8),\n                  _mm_shuffle_epi32(_mm_mul_epu32(_mm_srli_epi64(_mm_load_si128(v19 - 17), 0x20u), v25), 8)),\n                v17[15]));\n      v17[15] = v53;\n    }\n    while ( v20 != 64 );\n    v54 = v18;\n    v55 = v53;\n    ++v18;\n    v17 += 16;\n    v56 = v22 + (v54 << 6);\n    v57 = v22 << 8;\n    v58 = _mm_shuffle_epi32(_mm_cvtsi32_si128(A[0][v56]), 0);\n    v59 = _mm_srli_epi64(v58, 0x20u);\n    v60 = _mm_add_epi32(\n            _mm_load_si128(&v95),\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)B[0] + v57)), 8),\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)B + v57)), 0x20u), v59),\n                8)));\n    v61 = _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][8] + v57)), 0x20u);\n    v95 = _mm_add_epi32(\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][4] + v57)), 8),\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][4] + v57)), 0x20u), v59),\n                8)),\n            v96);\n    v62 = _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][12] + v57)), 8);\n    v96 = _mm_add_epi32(\n            _mm_load_si128(&v97),\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][8] + v57)), 8),\n              _mm_shuffle_epi32(_mm_mul_epu32(v61, v59), 8)));\n    v63 = _mm_add_epi32(\n            _mm_load_si128(&v98),\n            _mm_unpacklo_epi32(\n              v62,\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][12] + v57)), 0x20u), v59),\n                8)));\n    v64 = _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][16] + v57)), 8);\n    v97 = v63;\n    v65 = _mm_add_epi32(\n            _mm_load_si128(v99),\n            _mm_unpacklo_epi32(\n              v64,\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][16] + v57)), 0x20u), v59),\n                8)));\n    v66 = _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][20] + v57)), 8);\n    v98 = v65;\n    v67 = _mm_add_epi32(\n            v43,\n            _mm_unpacklo_epi32(\n              v66,\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][20] + v57)), 0x20u), v59),\n                8)));\n    v68 = _mm_add_epi32(\n            v44,\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][24] + v57)), 8),\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][24] + v57)), 0x20u), v59),\n                8)));\n    v69 = _mm_add_epi32(\n            v45,\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][28] + v57)), 8),\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][28] + v57)), 0x20u), v59),\n                8)));\n    v70 = _mm_add_epi32(\n            v46,\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][32] + v57)), 8),\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][32] + v57)), 0x20u), v59),\n                8)));\n    v71 = _mm_add_epi32(\n            v47,\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][36] + v57)), 8),\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][36] + v57)), 0x20u), v59),\n                8)));\n    v72 = _mm_add_epi32(\n            v48,\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][40] + v57)), 8),\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][40] + v57)), 0x20u), v59),\n                8)));\n    v73 = _mm_add_epi32(\n            v49,\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][44] + v57)), 8),\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][44] + v57)), 0x20u), v59),\n                8)));\n    v74 = _mm_add_epi32(\n            v50,\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][48] + v57)), 8),\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][48] + v57)), 0x20u), v59),\n                8)));\n    v75 = _mm_add_epi32(\n            v51,\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][52] + v57)), 8),\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][52] + v57)), 0x20u), v59),\n                8)));\n    v76 = _mm_add_epi32(\n            v52,\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][56] + v57)), 8),\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][56] + v57)), 0x20u), v59),\n                8)));\n    v77 = _mm_add_epi32(\n            v55,\n            _mm_unpacklo_epi32(\n              _mm_shuffle_epi32(_mm_mul_epu32(v58, *(__m128i *)((char *)&B[0][60] + v57)), 8),\n              _mm_shuffle_epi32(\n                _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[0][60] + v57)), 0x20u), v59),\n                8)));\n    v78 = _mm_shuffle_epi32(_mm_cvtsi32_si128(v94[63]), 0);\n    v79 = _mm_srli_epi64(v78, 0x20u);\n    v17[-16] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)B[1] + v57)), 8),\n                   _mm_shuffle_epi32(\n                     _mm_mul_epu32(_mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)B[1] + v57)), 0x20u), v79),\n                     8)),\n                 v60);\n    v17[-15] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][4] + v57)), 8),\n                   _mm_shuffle_epi32(\n                     _mm_mul_epu32(\n                       _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][4] + v57)), 0x20u),\n                       v79),\n                     8)),\n                 v95);\n    v17[-14] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][8] + v57)), 8),\n                   _mm_shuffle_epi32(\n                     _mm_mul_epu32(\n                       _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][8] + v57)), 0x20u),\n                       v79),\n                     8)),\n                 v96);\n    v17[-13] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][12] + v57)), 8),\n                   _mm_shuffle_epi32(\n                     _mm_mul_epu32(\n                       _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][12] + v57)), 0x20u),\n                       v79),\n                     8)),\n                 v97);\n    v17[-12] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][16] + v57)), 8),\n                   _mm_shuffle_epi32(\n                     _mm_mul_epu32(\n                       _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][16] + v57)), 0x20u),\n                       v79),\n                     8)),\n                 v98);\n    v17[-11] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][20] + v57)), 8),\n                   _mm_shuffle_epi32(\n                     _mm_mul_epu32(\n                       _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][20] + v57)), 0x20u),\n                       v79),\n                     8)),\n                 v67);\n    v17[-10] = _mm_add_epi32(\n                 _mm_unpacklo_epi32(\n                   _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][24] + v57)), 8),\n                   _mm_shuffle_epi32(\n                     _mm_mul_epu32(\n                       _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][24] + v57)), 0x20u),\n                       v79),\n                     8)),\n                 v68);\n    v17[-9] = _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][28] + v57)), 8),\n                  _mm_shuffle_epi32(\n                    _mm_mul_epu32(\n                      _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][28] + v57)), 0x20u),\n                      v79),\n                    8)),\n                v69);\n    v17[-8] = _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][32] + v57)), 8),\n                  _mm_shuffle_epi32(\n                    _mm_mul_epu32(\n                      _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][32] + v57)), 0x20u),\n                      v79),\n                    8)),\n                v70);\n    v17[-7] = _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][36] + v57)), 8),\n                  _mm_shuffle_epi32(\n                    _mm_mul_epu32(\n                      _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][36] + v57)), 0x20u),\n                      v79),\n                    8)),\n                v71);\n    v17[-6] = _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][40] + v57)), 8),\n                  _mm_shuffle_epi32(\n                    _mm_mul_epu32(\n                      _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][40] + v57)), 0x20u),\n                      v79),\n                    8)),\n                v72);\n    v17[-5] = _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][44] + v57)), 8),\n                  _mm_shuffle_epi32(\n                    _mm_mul_epu32(\n                      _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][44] + v57)), 0x20u),\n                      v79),\n                    8)),\n                v73);\n    v17[-4] = _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][48] + v57)), 8),\n                  _mm_shuffle_epi32(\n                    _mm_mul_epu32(\n                      _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][48] + v57)), 0x20u),\n                      v79),\n                    8)),\n                v74);\n    v17[-3] = _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][52] + v57)), 8),\n                  _mm_shuffle_epi32(\n                    _mm_mul_epu32(\n                      _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][52] + v57)), 0x20u),\n                      v79),\n                    8)),\n                v75);\n    v17[-2] = _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][56] + v57)), 8),\n                  _mm_shuffle_epi32(\n                    _mm_mul_epu32(\n                      _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][56] + v57)), 0x20u),\n                      v79),\n                    8)),\n                v76);\n    v17[-1] = _mm_add_epi32(\n                _mm_unpacklo_epi32(\n                  _mm_shuffle_epi32(_mm_mul_epu32(v78, *(__m128i *)((char *)&B[1][60] + v57)), 8),\n                  _mm_shuffle_epi32(\n                    _mm_mul_epu32(\n                      v79,\n                      _mm_srli_epi64(_mm_load_si128((const __m128i *)((char *)&B[1][60] + v57)), 0x20u)),\n                    8)),\n                v77);\n    v94 += 64;\n  }\n  while ( v18 != 64 );\n  v80 = C[0];\n  for ( j = 0LL; ; ++j )\n  {\n    for ( k = 0LL; k != 64; ++k )\n    {\n      v83 = v80[k];\n      v84 = refC[j][k];\n      if ( v83 != v84 )\n      {\n        libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", j, k, v83, v84);\n        libtarg_fail(1);\n      }\n    }\n    v85 = j;\n    v80 += 64;\n    if ( v85 > 62 )\n    {\n      v86 = C[1];\n      v87 = 0;\n      v88 = C[65];\n      v89 = C[1];\n      do\n      {\n        v90 = v89 - 64;\n        do\n        {\n          v91 = *v90++ + v87;\n          v87 = v91 % 100000;\n        }\n        while ( v89 != v90 );\n        v89 += 64;\n      }\n      while ( v88 != v89 );\n      libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", v87);\n      libmin_printf(\"Result Matrix C:\\n\");\n      while ( 1 )\n      {\n        v92 = v86 - 64;\n        do\n        {\n          v93 = *v92++;\n          libmin_printf(\"%d \", v93);\n        }\n        while ( v86 != v92 );\n        v86 += 64;\n        libmin_printf((char *)\"\\n\");\n        if ( v88 == v86 )\n          libtarg_success();\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "", "binary": "matmult/matmult.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x3039,%edi\npush   %r14\nlea    0xe16c(%rip),%r14\npush   %r13\nlea    0x6163(%rip),%r13\npush   %r12\nlea    0xa15a(%rip),%r12\npush   %rbp\nmov    %r14,%rbp\npush   %rbx\nsub    $0x68,%rsp\ncall   4830 <libmin_srand>\nlea    0x12145(%rip),%rax\nmov    %rax,0x8(%rsp)\nmov    %rax,%rbx\nxor    %r15d,%r15d\ncs nopw 0x0(%rax,%rax,1)\ncall   4890 <libmin_rand>\nmov    %eax,%ecx\nmov    %eax,%eax\nimul   $0x10624dd3,%rax,%rax\nshr    $0x26,%rax\nimul   $0x3e8,%eax,%eax\nsub    %eax,%ecx\nmov    %ecx,(%rbx,%r15,1)\ncall   4890 <libmin_rand>\nmovl   $0x0,(%r12,%r15,1)\nmovl   $0x0,0x0(%r13,%r15,1)\nmov    %eax,%ecx\nmov    %eax,%eax\nimul   $0x10624dd3,%rax,%rax\nshr    $0x26,%rax\nimul   $0x3e8,%eax,%eax\nsub    %eax,%ecx\nmov    %ecx,0x0(%rbp,%r15,1)\nadd    $0x4,%r15\ncmp    $0x100,%r15\njne    1150 <main+0x50>\nadd    $0x100,%rbx\nlea    0x160c3(%rip),%rax\nadd    $0x100,%rbp\nadd    $0x100,%r12\nadd    $0x100,%r13\ncmp    %rax,%rbx\njne    1143 <main+0x43>\nlea    0xe09e(%rip),%r8\nlea    -0x4000(%rax),%rdi\nlea    -0x4000(%r8),%rdx\nlea    0x4000(%r14),%rsi\nmov    %r14,%rax\nmov    %rdi,%rcx\nnopl   (%rax)\nmovd   (%rcx),%xmm7\nmovdqa (%rax),%xmm3\nadd    $0x100,%rax\nadd    $0x4,%rcx\npshufd $0x0,%xmm7,%xmm0\npsrlq  $0x20,%xmm3\nmovdqa %xmm0,%xmm1\nmovdqa %xmm0,%xmm2\npmuludq -0x100(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm1\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  (%rdx),%xmm2\nmovaps %xmm2,(%rdx)\nmovdqa -0xf0(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0xf0(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x10(%rdx),%xmm2\nmovaps %xmm2,0x10(%rdx)\nmovdqa -0xe0(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0xe0(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x20(%rdx),%xmm2\nmovaps %xmm2,0x20(%rdx)\nmovdqa -0xd0(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0xd0(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x30(%rdx),%xmm2\nmovaps %xmm2,0x30(%rdx)\nmovdqa -0xc0(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0xc0(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x40(%rdx),%xmm2\nmovaps %xmm2,0x40(%rdx)\nmovdqa -0xb0(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0xb0(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x50(%rdx),%xmm2\nmovaps %xmm2,0x50(%rdx)\nmovdqa -0xa0(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0xa0(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x60(%rdx),%xmm2\nmovaps %xmm2,0x60(%rdx)\nmovdqa -0x90(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0x90(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x70(%rdx),%xmm2\nmovaps %xmm2,0x70(%rdx)\nmovdqa -0x80(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0x80(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x80(%rdx),%xmm2\nmovaps %xmm2,0x80(%rdx)\nmovdqa -0x70(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0x70(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x90(%rdx),%xmm2\nmovaps %xmm2,0x90(%rdx)\nmovdqa -0x60(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0x60(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0xa0(%rdx),%xmm2\nmovaps %xmm2,0xa0(%rdx)\nmovdqa -0x50(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0x50(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0xb0(%rdx),%xmm2\nmovaps %xmm2,0xb0(%rdx)\nmovdqa -0x40(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0x40(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0xc0(%rdx),%xmm2\nmovaps %xmm2,0xc0(%rdx)\nmovdqa -0x30(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0x30(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0xd0(%rdx),%xmm2\nmovaps %xmm2,0xd0(%rdx)\nmovdqa -0x20(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq -0x20(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0xe0(%rdx),%xmm2\nmovaps %xmm2,0xe0(%rdx)\nmovdqa -0x10(%rax),%xmm2\npmuludq -0x10(%rax),%xmm0\npshufd $0x8,%xmm0,%xmm0\npsrlq  $0x20,%xmm2\npmuludq %xmm2,%xmm1\npshufd $0x8,%xmm1,%xmm1\npunpckldq %xmm1,%xmm0\npaddd  0xf0(%rdx),%xmm0\nmovaps %xmm0,0xf0(%rdx)\ncmp    %rsi,%rax\njne    1200 <main+0x100>\nadd    $0x100,%rdx\nadd    $0x100,%rdi\ncmp    %r8,%rdx\njne    11f7 <main+0xf7>\nlea    0x5d07(%rip),%rdx\nxor    %edi,%edi\nmov    %r14,%rax\nmov    $0x2,%esi\nmov    0x8(%rsp),%rbx\nmovdqa (%rax),%xmm2\nmovslq %esi,%rcx\nadd    $0x200,%rax\nmovdqa -0x100(%rax),%xmm5\nmovd   -0x8(%rbx,%rsi,4),%xmm7\npsrlq  $0x20,%xmm2\npsrlq  $0x20,%xmm5\npshufd $0x0,%xmm7,%xmm1\nmovd   -0x4(%rbx,%rsi,4),%xmm7\nadd    $0x2,%rsi\nmovdqa %xmm1,%xmm3\nmovdqa %xmm1,%xmm4\nmovdqa %xmm1,%xmm8\npmuludq -0x200(%rax),%xmm4\npsrlq  $0x20,%xmm3\npshufd $0x0,%xmm7,%xmm0\npshufd $0x8,%xmm4,%xmm4\npmuludq %xmm3,%xmm2\nmovdqa %xmm0,%xmm6\nmovdqa %xmm1,%xmm7\npmuludq -0x100(%rax),%xmm6\npshufd $0x8,%xmm6,%xmm6\nmovdqa %xmm1,%xmm9\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm4\nmovdqa %xmm0,%xmm2\npaddd  (%rdx),%xmm4\npsrlq  $0x20,%xmm2\npmuludq %xmm2,%xmm5\npshufd $0x8,%xmm5,%xmm5\npunpckldq %xmm5,%xmm6\npaddd  %xmm4,%xmm6\nmovdqa %xmm1,%xmm4\nmovaps %xmm6,(%rdx)\nmovdqa -0x1f0(%rax),%xmm5\npmuludq -0x1f0(%rax),%xmm4\npshufd $0x8,%xmm4,%xmm4\nmovaps %xmm6,0x10(%rsp)\nmovdqa %xmm0,%xmm6\npmuludq -0xf0(%rax),%xmm6\npshufd $0x8,%xmm6,%xmm6\npsrlq  $0x20,%xmm5\npmuludq %xmm3,%xmm5\npshufd $0x8,%xmm5,%xmm5\npunpckldq %xmm5,%xmm4\nmovdqa -0xf0(%rax),%xmm5\npaddd  0x10(%rdx),%xmm4\npsrlq  $0x20,%xmm5\npmuludq %xmm2,%xmm5\npshufd $0x8,%xmm5,%xmm5\npunpckldq %xmm5,%xmm6\npaddd  %xmm4,%xmm6\nmovdqa %xmm1,%xmm4\nmovaps %xmm6,0x10(%rdx)\nmovdqa -0x1e0(%rax),%xmm5\npmuludq -0x1e0(%rax),%xmm4\npshufd $0x8,%xmm4,%xmm4\nmovaps %xmm6,0x20(%rsp)\nmovdqa %xmm0,%xmm6\npmuludq -0xe0(%rax),%xmm6\npshufd $0x8,%xmm6,%xmm6\npsrlq  $0x20,%xmm5\npmuludq %xmm3,%xmm5\npshufd $0x8,%xmm5,%xmm5\npunpckldq %xmm5,%xmm4\nmovdqa -0xe0(%rax),%xmm5\npaddd  0x20(%rdx),%xmm4\npsrlq  $0x20,%xmm5\npmuludq %xmm2,%xmm5\npshufd $0x8,%xmm5,%xmm5\npunpckldq %xmm5,%xmm6\npaddd  %xmm4,%xmm6\nmovdqa %xmm1,%xmm4\nmovaps %xmm6,0x20(%rdx)\nmovdqa -0x1d0(%rax),%xmm5\npmuludq -0x1d0(%rax),%xmm4\npshufd $0x8,%xmm4,%xmm4\nmovaps %xmm6,0x30(%rsp)\nmovdqa %xmm0,%xmm6\npmuludq -0xd0(%rax),%xmm6\npshufd $0x8,%xmm6,%xmm6\npsrlq  $0x20,%xmm5\npmuludq %xmm3,%xmm5\npshufd $0x8,%xmm5,%xmm5\npunpckldq %xmm5,%xmm4\nmovdqa -0xd0(%rax),%xmm5\npaddd  0x30(%rdx),%xmm4\npsrlq  $0x20,%xmm5\npmuludq %xmm2,%xmm5\npshufd $0x8,%xmm5,%xmm5\npunpckldq %xmm5,%xmm6\npaddd  %xmm4,%xmm6\nmovdqa %xmm1,%xmm4\nmovaps %xmm6,0x30(%rdx)\npmuludq -0x1c0(%rax),%xmm4\npshufd $0x8,%xmm4,%xmm4\nmovaps %xmm6,0x40(%rsp)\nmovdqa -0x1c0(%rax),%xmm5\nmovdqa %xmm0,%xmm6\npmuludq -0xc0(%rax),%xmm6\npshufd $0x8,%xmm6,%xmm6\npsrlq  $0x20,%xmm5\npmuludq %xmm3,%xmm5\npshufd $0x8,%xmm5,%xmm5\npunpckldq %xmm5,%xmm4\nmovdqa -0xc0(%rax),%xmm5\npaddd  0x40(%rdx),%xmm4\npsrlq  $0x20,%xmm5\npmuludq %xmm2,%xmm5\npshufd $0x8,%xmm5,%xmm5\npunpckldq %xmm5,%xmm6\nmovdqa %xmm1,%xmm5\npaddd  %xmm4,%xmm6\nmovaps %xmm6,0x40(%rdx)\nmovdqa -0x1b0(%rax),%xmm4\npmuludq -0x1b0(%rax),%xmm5\npshufd $0x8,%xmm5,%xmm5\nmovaps %xmm6,0x50(%rsp)\nmovdqa -0xb0(%rax),%xmm6\npsrlq  $0x20,%xmm4\npmuludq %xmm3,%xmm4\npsrlq  $0x20,%xmm6\npmuludq %xmm2,%xmm6\npshufd $0x8,%xmm4,%xmm4\npunpckldq %xmm4,%xmm5\npshufd $0x8,%xmm6,%xmm6\npaddd  0x50(%rdx),%xmm5\nmovdqa %xmm0,%xmm4\npmuludq -0xb0(%rax),%xmm4\npshufd $0x8,%xmm4,%xmm4\npunpckldq %xmm6,%xmm4\npaddd  %xmm5,%xmm4\nmovaps %xmm4,0x50(%rdx)\nmovdqa -0x1a0(%rax),%xmm5\nmovdqa -0xa0(%rax),%xmm6\npmuludq -0x1a0(%rax),%xmm7\npshufd $0x8,%xmm7,%xmm7\npsrlq  $0x20,%xmm5\npsrlq  $0x20,%xmm6\npmuludq %xmm3,%xmm5\npmuludq %xmm2,%xmm6\npshufd $0x8,%xmm5,%xmm5\npshufd $0x8,%xmm6,%xmm6\npunpckldq %xmm5,%xmm7\nmovdqa %xmm0,%xmm5\npaddd  0x60(%rdx),%xmm7\npmuludq -0xa0(%rax),%xmm5\npshufd $0x8,%xmm5,%xmm5\npunpckldq %xmm6,%xmm5\npaddd  %xmm7,%xmm5\nmovaps %xmm5,0x60(%rdx)\nmovdqa -0x190(%rax),%xmm6\nmovdqa -0x90(%rax),%xmm7\npmuludq -0x190(%rax),%xmm8\npshufd $0x8,%xmm8,%xmm8\npsrlq  $0x20,%xmm6\npsrlq  $0x20,%xmm7\npmuludq %xmm3,%xmm6\npmuludq %xmm2,%xmm7\npshufd $0x8,%xmm6,%xmm6\npshufd $0x8,%xmm7,%xmm7\npunpckldq %xmm6,%xmm8\nmovdqa %xmm0,%xmm6\npaddd  0x70(%rdx),%xmm8\npmuludq -0x90(%rax),%xmm6\npshufd $0x8,%xmm6,%xmm6\npunpckldq %xmm7,%xmm6\npaddd  %xmm8,%xmm6\nmovaps %xmm6,0x70(%rdx)\nmovdqa -0x180(%rax),%xmm7\nmovdqa -0x80(%rax),%xmm8\npmuludq -0x180(%rax),%xmm9\npshufd $0x8,%xmm9,%xmm9\npsrlq  $0x20,%xmm7\npsrlq  $0x20,%xmm8\npmuludq %xmm3,%xmm7\npmuludq %xmm2,%xmm8\npshufd $0x8,%xmm7,%xmm7\npshufd $0x8,%xmm8,%xmm8\npunpckldq %xmm7,%xmm9\nmovdqa %xmm0,%xmm7\npmuludq -0x80(%rax),%xmm7\npaddd  0x80(%rdx),%xmm9\npshufd $0x8,%xmm7,%xmm7\npunpckldq %xmm8,%xmm7\npaddd  %xmm9,%xmm7\nmovdqa %xmm1,%xmm9\nmovaps %xmm7,0x80(%rdx)\nmovdqa -0x170(%rax),%xmm8\npmuludq -0x170(%rax),%xmm9\npshufd $0x8,%xmm9,%xmm9\npsrlq  $0x20,%xmm8\npmuludq %xmm3,%xmm8\npshufd $0x8,%xmm8,%xmm8\npunpckldq %xmm8,%xmm9\nmovdqa %xmm0,%xmm8\npaddd  0x90(%rdx),%xmm9\nmovdqa -0x70(%rax),%xmm10\npmuludq -0x70(%rax),%xmm8\npshufd $0x8,%xmm8,%xmm8\npsrlq  $0x20,%xmm10\npmuludq %xmm2,%xmm10\npshufd $0x8,%xmm10,%xmm10\npunpckldq %xmm10,%xmm8\nmovdqa %xmm1,%xmm10\npaddd  %xmm9,%xmm8\nmovaps %xmm8,0x90(%rdx)\nmovdqa -0x60(%rax),%xmm11\nmovdqa -0x160(%rax),%xmm9\npmuludq -0x160(%rax),%xmm10\npshufd $0x8,%xmm10,%xmm10\npsrlq  $0x20,%xmm9\npsrlq  $0x20,%xmm11\npmuludq %xmm3,%xmm9\npmuludq %xmm2,%xmm11\npshufd $0x8,%xmm9,%xmm9\npshufd $0x8,%xmm11,%xmm11\npunpckldq %xmm9,%xmm10\nmovdqa %xmm0,%xmm9\npmuludq -0x60(%rax),%xmm9\npaddd  0xa0(%rdx),%xmm10\npshufd $0x8,%xmm9,%xmm9\npunpckldq %xmm11,%xmm9\nmovdqa %xmm1,%xmm11\npaddd  %xmm10,%xmm9\nmovaps %xmm9,0xa0(%rdx)\nmovdqa -0x50(%rax),%xmm12\nmovdqa -0x150(%rax),%xmm10\npmuludq -0x150(%rax),%xmm11\npshufd $0x8,%xmm11,%xmm11\npsrlq  $0x20,%xmm10\npsrlq  $0x20,%xmm12\npmuludq %xmm3,%xmm10\npmuludq %xmm2,%xmm12\npshufd $0x8,%xmm10,%xmm10\npshufd $0x8,%xmm12,%xmm12\npunpckldq %xmm10,%xmm11\nmovdqa %xmm0,%xmm10\npmuludq -0x50(%rax),%xmm10\npaddd  0xb0(%rdx),%xmm11\npshufd $0x8,%xmm10,%xmm10\npunpckldq %xmm12,%xmm10\nmovdqa %xmm1,%xmm12\npaddd  %xmm11,%xmm10\nmovaps %xmm10,0xb0(%rdx)\nmovdqa -0x40(%rax),%xmm13\nmovdqa -0x140(%rax),%xmm11\npmuludq -0x140(%rax),%xmm12\npshufd $0x8,%xmm12,%xmm12\npsrlq  $0x20,%xmm11\npsrlq  $0x20,%xmm13\npmuludq %xmm3,%xmm11\npmuludq %xmm2,%xmm13\npshufd $0x8,%xmm11,%xmm11\npshufd $0x8,%xmm13,%xmm13\npunpckldq %xmm11,%xmm12\nmovdqa %xmm0,%xmm11\npmuludq -0x40(%rax),%xmm11\npaddd  0xc0(%rdx),%xmm12\npshufd $0x8,%xmm11,%xmm11\npunpckldq %xmm13,%xmm11\nmovdqa %xmm1,%xmm13\npaddd  %xmm12,%xmm11\nmovaps %xmm11,0xc0(%rdx)\nmovdqa -0x30(%rax),%xmm14\nmovdqa -0x130(%rax),%xmm12\npmuludq -0x130(%rax),%xmm13\npshufd $0x8,%xmm13,%xmm13\npsrlq  $0x20,%xmm12\npsrlq  $0x20,%xmm14\npmuludq %xmm3,%xmm12\npmuludq %xmm2,%xmm14\npshufd $0x8,%xmm12,%xmm12\npshufd $0x8,%xmm14,%xmm14\npunpckldq %xmm12,%xmm13\nmovdqa %xmm0,%xmm12\npmuludq -0x30(%rax),%xmm12\npaddd  0xd0(%rdx),%xmm13\npshufd $0x8,%xmm12,%xmm12\npunpckldq %xmm14,%xmm12\nmovdqa %xmm1,%xmm14\npaddd  %xmm13,%xmm12\nmovaps %xmm12,0xd0(%rdx)\nmovdqa -0x120(%rax),%xmm13\npmuludq -0x120(%rax),%xmm14\npshufd $0x8,%xmm14,%xmm14\npsrlq  $0x20,%xmm13\npmuludq %xmm3,%xmm13\npshufd $0x8,%xmm13,%xmm13\npunpckldq %xmm13,%xmm14\nmovdqa %xmm0,%xmm13\npmuludq -0x20(%rax),%xmm13\npaddd  0xe0(%rdx),%xmm14\nmovdqa -0x20(%rax),%xmm15\npshufd $0x8,%xmm13,%xmm13\npsrlq  $0x20,%xmm15\npmuludq %xmm2,%xmm15\npshufd $0x8,%xmm15,%xmm15\npunpckldq %xmm15,%xmm13\npaddd  %xmm14,%xmm13\nmovaps %xmm13,0xe0(%rdx)\npmuludq -0x110(%rax),%xmm1\nmovdqa -0x110(%rax),%xmm14\npshufd $0x8,%xmm1,%xmm1\npmuludq -0x10(%rax),%xmm0\npshufd $0x8,%xmm0,%xmm0\npsrlq  $0x20,%xmm14\npmuludq %xmm3,%xmm14\nmovdqa -0x10(%rax),%xmm3\npsrlq  $0x20,%xmm3\npmuludq %xmm2,%xmm3\npshufd $0x8,%xmm14,%xmm14\npunpckldq %xmm14,%xmm1\npaddd  0xf0(%rdx),%xmm1\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm0\npaddd  %xmm1,%xmm0\nmovaps %xmm0,0xf0(%rdx)\ncmp    $0x40,%rsi\njne    1583 <main+0x483>\nmovslq %edi,%rsi\nmovdqa %xmm0,%xmm14\nadd    $0x1,%edi\nmovdqa 0x10(%rsp),%xmm15\nshl    $0x6,%rsi\nlea    0x115d9(%rip),%rbx\nadd    $0x100,%rdx\nadd    %rcx,%rsi\nshl    $0x8,%rcx\nmovd   (%rbx,%rsi,4),%xmm1\nlea    (%r14,%rcx,1),%rax\nmovdqa (%rax),%xmm2\npshufd $0x0,%xmm1,%xmm0\nmovdqa %xmm0,%xmm1\npsrlq  $0x20,%xmm2\nmovdqa %xmm0,%xmm3\npmuludq (%r14,%rcx,1),%xmm3\npsrlq  $0x20,%xmm1\npshufd $0x8,%xmm3,%xmm3\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0x10(%rax),%xmm2\npaddd  %xmm3,%xmm15\nmovdqa %xmm0,%xmm3\npmuludq 0x10(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\npsrlq  $0x20,%xmm2\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0x20(%rax),%xmm2\npaddd  0x20(%rsp),%xmm3\npsrlq  $0x20,%xmm2\nmovaps %xmm3,0x10(%rsp)\nmovdqa %xmm0,%xmm3\npmuludq 0x20(%rax),%xmm3\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm3,%xmm3\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0x30(%rsp),%xmm2\npaddd  %xmm3,%xmm2\nmovdqa %xmm0,%xmm3\npmuludq 0x30(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\nmovaps %xmm2,0x20(%rsp)\nmovdqa 0x30(%rax),%xmm2\npsrlq  $0x20,%xmm2\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0x40(%rsp),%xmm2\npaddd  %xmm3,%xmm2\nmovdqa %xmm0,%xmm3\npmuludq 0x40(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\nmovaps %xmm2,0x30(%rsp)\nmovdqa 0x40(%rax),%xmm2\npsrlq  $0x20,%xmm2\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0x50(%rsp),%xmm2\npaddd  %xmm3,%xmm2\nmovdqa %xmm0,%xmm3\npmuludq 0x50(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\nmovaps %xmm2,0x40(%rsp)\nmovdqa 0x50(%rax),%xmm2\npsrlq  $0x20,%xmm2\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0x60(%rax),%xmm2\npaddd  %xmm3,%xmm4\nmovdqa %xmm0,%xmm3\npmuludq 0x60(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\npsrlq  $0x20,%xmm2\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0x70(%rax),%xmm2\npaddd  %xmm3,%xmm5\nmovdqa %xmm0,%xmm3\npmuludq 0x70(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\npsrlq  $0x20,%xmm2\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0x80(%rax),%xmm2\npaddd  %xmm3,%xmm6\nmovdqa %xmm0,%xmm3\npmuludq 0x80(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\npsrlq  $0x20,%xmm2\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0x90(%rax),%xmm2\npaddd  %xmm3,%xmm7\nmovdqa %xmm0,%xmm3\npmuludq 0x90(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\npsrlq  $0x20,%xmm2\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0xa0(%rax),%xmm2\npaddd  %xmm3,%xmm8\nmovdqa %xmm0,%xmm3\npmuludq 0xa0(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\npsrlq  $0x20,%xmm2\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\npaddd  %xmm3,%xmm9\nmovdqa %xmm0,%xmm3\npmuludq 0xb0(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\nmovdqa 0xb0(%rax),%xmm2\nmov    0x8(%rsp),%rbx\npsrlq  $0x20,%xmm2\nadd    $0x100,%rbx\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0xc0(%rax),%xmm2\npaddd  %xmm3,%xmm10\nmovdqa %xmm0,%xmm3\npmuludq 0xc0(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\npsrlq  $0x20,%xmm2\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0xd0(%rax),%xmm2\npaddd  %xmm3,%xmm11\nmovdqa %xmm0,%xmm3\npmuludq 0xd0(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\npsrlq  $0x20,%xmm2\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0xe0(%rax),%xmm2\npaddd  %xmm3,%xmm12\nmovdqa %xmm0,%xmm3\npmuludq 0xe0(%rax),%xmm3\npshufd $0x8,%xmm3,%xmm3\npsrlq  $0x20,%xmm2\npmuludq 0xf0(%rax),%xmm0\npshufd $0x8,%xmm0,%xmm0\npmuludq %xmm1,%xmm2\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm3\nmovdqa 0xf0(%rax),%xmm2\nlea    0x100(%r14,%rcx,1),%rax\npaddd  %xmm3,%xmm13\nmovdqa (%rax),%xmm3\npsrlq  $0x20,%xmm2\npmuludq %xmm1,%xmm2\nmovd   -0x4(%rbx),%xmm1\npsrlq  $0x20,%xmm3\npshufd $0x8,%xmm2,%xmm2\npunpckldq %xmm2,%xmm0\npaddd  %xmm0,%xmm14\npshufd $0x0,%xmm1,%xmm0\nmovdqa %xmm0,%xmm1\nmovdqa %xmm0,%xmm2\npmuludq 0x100(%r14,%rcx,1),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm1\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  %xmm15,%xmm2\nmovaps %xmm2,-0x100(%rdx)\nmovdqa 0x10(%rax),%xmm15\nmovdqa %xmm0,%xmm2\npmuludq 0x10(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm15\nmovdqa %xmm15,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x10(%rsp),%xmm2\nmovaps %xmm2,-0xf0(%rdx)\nmovdqa 0x20(%rax),%xmm15\nmovdqa %xmm0,%xmm2\npmuludq 0x20(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm15\nmovdqa %xmm15,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x20(%rsp),%xmm2\nmovaps %xmm2,-0xe0(%rdx)\nmovdqa 0x30(%rax),%xmm15\nmovdqa %xmm0,%xmm2\npmuludq 0x30(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm15\nmovdqa %xmm15,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x30(%rsp),%xmm2\nmovaps %xmm2,-0xd0(%rdx)\nmovdqa 0x40(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq 0x40(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  0x40(%rsp),%xmm2\nmovaps %xmm2,-0xc0(%rdx)\nmovdqa %xmm0,%xmm2\npmuludq 0x50(%rax),%xmm2\nmovdqa 0x50(%rax),%xmm3\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  %xmm4,%xmm2\nmovaps %xmm2,-0xb0(%rdx)\nmovdqa 0x60(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq 0x60(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  %xmm5,%xmm2\nmovaps %xmm2,-0xa0(%rdx)\nmovdqa 0x70(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq 0x70(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  %xmm6,%xmm2\nmovaps %xmm2,-0x90(%rdx)\nmovdqa 0x80(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq 0x80(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  %xmm7,%xmm2\nmovaps %xmm2,-0x80(%rdx)\nmovdqa 0x90(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq 0x90(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  %xmm8,%xmm2\nmovaps %xmm2,-0x70(%rdx)\nmovdqa 0xa0(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq 0xa0(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  %xmm9,%xmm2\nmovaps %xmm2,-0x60(%rdx)\nmovdqa 0xb0(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq 0xb0(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  %xmm10,%xmm2\nmovaps %xmm2,-0x50(%rdx)\nmovdqa 0xc0(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq 0xc0(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  %xmm11,%xmm2\nmovaps %xmm2,-0x40(%rdx)\nmovdqa 0xd0(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq 0xd0(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  %xmm12,%xmm2\nmovaps %xmm2,-0x30(%rdx)\nmovdqa 0xe0(%rax),%xmm3\nmovdqa %xmm0,%xmm2\npmuludq 0xe0(%rax),%xmm2\npshufd $0x8,%xmm2,%xmm2\npsrlq  $0x20,%xmm3\npmuludq %xmm1,%xmm3\npshufd $0x8,%xmm3,%xmm3\npunpckldq %xmm3,%xmm2\npaddd  %xmm13,%xmm2\nmovaps %xmm2,-0x20(%rdx)\nmovdqa 0xf0(%rax),%xmm2\npmuludq 0xf0(%rax),%xmm0\npshufd $0x8,%xmm0,%xmm0\npsrlq  $0x20,%xmm2\npmuludq %xmm2,%xmm1\npshufd $0x8,%xmm1,%xmm1\npunpckldq %xmm1,%xmm0\npaddd  %xmm14,%xmm0\nmovaps %xmm0,-0x10(%rdx)\nmov    %rbx,0x8(%rsp)\ncmp    $0x40,%edi\njne    157b <main+0x47b>\nlea    0x8f4f(%rip),%rcx\nxor    %edx,%edx\nmov    %rdx,%rsi\nlea    0x4f43(%rip),%rax\nmov    %edx,%r10d\nshl    $0x8,%rsi\nadd    %rax,%rsi\nxor    %eax,%eax\nmov    (%rcx,%rax,4),%r9d\nmov    (%rsi,%rax,4),%r8d\ncmp    %r8d,%r9d\nje     2376 <main+0x1276>\nmov    %eax,%edx\nlea    0x2ca9(%rip),%rdi\nmov    %r9d,%ecx\nmov    %r10d,%esi\nxor    %eax,%eax\ncall   4620 <libmin_printf>\nmov    $0x1,%edi\ncall   2570 <libtarg_fail>\nadd    $0x1,%rax\ncmp    $0x40,%rax\njne    2349 <main+0x1249>\nmov    %edx,%eax\nadd    $0x100,%rcx\nadd    $0x1,%rdx\ncmp    $0x3e,%eax\njle    2333 <main+0x1233>\nlea    0x8fe7(%rip),%rbx\nxor    %esi,%esi\nlea    0x4000(%rbx),%rbp\nmov    %rbx,%rdi\nlea    -0x100(%rdi),%rax\nnopl   0x0(%rax)\nadd    (%rax),%esi\nadd    $0x4,%rax\nmov    %esi,%edx\nmovslq %esi,%rsi\nimul   $0x14f8b589,%rsi,%rsi\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsar    $0x2d,%rsi\nsub    %ecx,%esi\nimul   $0x186a0,%esi,%ecx\nmov    %edx,%esi\nsub    %ecx,%esi\ncmp    %rax,%rdi\njne    23b0 <main+0x12b0>\nadd    $0x100,%rdi\ncmp    %rdi,%rbp\njne    23a5 <main+0x12a5>\nlea    0x2c49(%rip),%rdi\nxor    %eax,%eax\nlea    0x2c82(%rip),%r13\ncall   4620 <libmin_printf>\nlea    0x2c64(%rip),%rdi\nxor    %eax,%eax\nlea    0x2c6b(%rip),%r14\ncall   4620 <libmin_printf>\nlea    -0x100(%rbx),%r12\nnopl   0x0(%rax)\nmov    (%r12),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%r12\ncall   4620 <libmin_printf>\ncmp    %r12,%rbx\njne    2420 <main+0x1320>\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x100,%rbx\ncall   4620 <libmin_printf>\ncmp    %rbx,%rbp\njne    2412 <main+0x1312>\ncall   2550 <libtarg_success>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "max-subseq/max-subseq.c", "function_name": "lcsAlgo", "content": "void lcsAlgo() {\n  // Filling 0's in the matrix\n  for (i = 0; i <= m; i++)\n    LCS_table[i][0] = 0;\n  for (i = 0; i <= n; i++)\n    LCS_table[0][i] = 0;\n\n  // Building the mtrix in bottom-up way\n  for (i = 1; i <= m; i++)\n    for (j = 1; j <= n; j++) {\n      if (S1[i - 1] == S2[j - 1]) {\n        LCS_table[i][j] = LCS_table[i - 1][j - 1] + 1;\n      } else if (LCS_table[i - 1][j] >= LCS_table[i][j - 1]) {\n        LCS_table[i][j] = LCS_table[i - 1][j];\n      } else {\n        LCS_table[i][j] = LCS_table[i][j - 1];\n      }\n    }\n\n  int index = LCS_table[m][n];\n  char lcsAlgo[index + 1];\n  lcsAlgo[index] = '\\0';\n\n  int i = m, j = n;\n  while (i > 0 && j > 0) {\n    if (S1[i - 1] == S2[j - 1]) {\n      lcsAlgo[index - 1] = S1[i - 1];\n      i--;\n      j--;\n      index--;\n    }\n\n    else if (LCS_table[i - 1][j] > LCS_table[i][j - 1])\n      i--;\n    else\n      j--;\n  }\n\n  // Printing the sub sequences\n  libmin_printf(\"LCS: %s\", lcsAlgo);\n}\n"}, "pseudo": {"path": "max-subseq/max-subseq.host.O3.pseudo", "function_name": "lcsAlgo", "address": "0x1290", "label": "lcsAlgo", "content": "void __cdecl lcsAlgo()\n{\n  int *v0; // r11\n  int v1; // r12d\n  int *v2; // rax\n  int v3; // ebx\n  __int64 v4; // r13\n  char *v5; // r10\n  int v6; // eax\n  int *v7; // rsi\n  int *v8; // r12\n  char v9; // r8\n  char *v10; // rdx\n  int *v11; // rcx\n  int v12; // eax\n  int v13; // r12d\n  int v14; // edi\n  char *v15; // rcx\n  signed __int64 v16; // rdx\n  void *v17; // rsp\n  char v18; // si\n  __int64 v19; // rcx\n  char *v20; // rsi\n  signed __int64 v21; // rax\n  void *v22; // rsp\n  char v24[4088]; // [rsp+8h] [rbp-1060h] BYREF\n  __int64 v25; // [rsp+1008h] [rbp-60h] BYREF\n  int v26; // [rsp+1010h] [rbp-58h]\n  int v27; // [rsp+1014h] [rbp-54h]\n  __int64 v28; // [rsp+1018h] [rbp-50h]\n  __int64 v29; // [rsp+1020h] [rbp-48h]\n  unsigned __int64 v30; // [rsp+1030h] [rbp-38h]\n\n  v0 = LCS_table[0];\n  v1 = m;\n  v30 = __readfsqword(0x28u);\n  if ( m < 0 )\n  {\n    v28 = m;\n  }\n  else\n  {\n    v2 = LCS_table[0];\n    v28 = m;\n    do\n    {\n      *v2 = 0;\n      v2 += 40;\n    }\n    while ( v2 != LCS_table[v1 + 1] );\n  }\n  v3 = n;\n  v29 = n;\n  if ( n >= 0 )\n    v0 = (int *)memset(LCS_table, 0, 4LL * n + 4);\n  i = 1;\n  if ( v1 <= 0 )\n  {\n    v19 = v0[40 * v28 + v29];\n    v20 = (char *)&v25 - (((int)v19 + 1 + 15LL) & 0xFFFFFFFFFFFFF000LL);\n    if ( &v25 != (__int64 *)v20 )\n    {\n      while ( v24 != v20 )\n        ;\n    }\n    v21 = ((_WORD)v19 + 16) & 0xFF0;\n    v22 = alloca(v21);\n    if ( (((_WORD)v19 + 16) & 0xFF0) != 0 )\n      *(_QWORD *)&v24[v21 - 8] = *(_QWORD *)&v24[v21 - 8];\n    v24[v19] = 0;\n  }\n  else\n  {\n    v26 = v1;\n    v4 = (unsigned int)(v1 - 1);\n    v5 = S1;\n    v6 = 1;\n    if ( v3 > 0 )\n      v6 = v3 + 1;\n    v7 = LCS_table[0];\n    v27 = v6;\n    do\n    {\n      v8 = v7 + 40;\n      if ( v3 > 0 )\n      {\n        v8 = v7 + 40;\n        v9 = *v5;\n        v10 = S2;\n        v11 = v7 + 40;\n        do\n        {\n          if ( v9 == *v10 )\n          {\n            v12 = *v7 + 1;\n          }\n          else\n          {\n            v12 = *v11;\n            if ( *v11 < v7[1] )\n              v12 = v7[1];\n          }\n          ++v10;\n          v11[1] = v12;\n          ++v7;\n          ++v11;\n        }\n        while ( &S2[v3 - 1 + 1] != v10 );\n      }\n      ++v5;\n      v7 = v8;\n    }\n    while ( v5 != &S1[v4 + 1] );\n    v13 = v26;\n    j = v27;\n    i = v26 + 1;\n    v14 = v0[40 * v28 + v29];\n    v15 = (char *)&v25 - ((v14 + 1 + 15LL) & 0xFFFFFFFFFFFFF000LL);\n    if ( &v25 != (__int64 *)v15 )\n    {\n      while ( v24 != v15 )\n        ;\n    }\n    v16 = ((_WORD)v14 + 16) & 0xFF0;\n    v17 = alloca(v16);\n    if ( (((_WORD)v14 + 16) & 0xFF0) != 0 )\n      *(_QWORD *)&v24[v16 - 8] = *(_QWORD *)&v24[v16 - 8];\n    v24[v14] = 0;\n    if ( v3 > 0 )\n    {\n      while ( 1 )\n      {\n        v18 = S1[(int)v4];\n        if ( v18 == S2[v3 - 1] )\n        {\n          --v14;\n          v13 = v4;\n          --v3;\n          v24[v14] = v18;\n          if ( (int)v4 <= 0 )\n            break;\n        }\n        else\n        {\n          if ( v0[40 * (int)v4 + v3] <= v0[40 * v13 - 1 + v3] )\n            --v3;\n          else\n            v13 = v4;\n          if ( v13 <= 0 )\n            break;\n        }\n        if ( v3 <= 0 )\n          break;\n        LODWORD(v4) = v13 - 1;\n      }\n    }\n  }\n  libmin_printf(\"LCS: %s\", v24);\n}\n"}, "pseudo_normalize": "void lcsAlgo() {\n  int *v0;\n  int v1;\n  int *v2;\n  int v3;\n  long long v4;\n  char *v5;\n  int v6;\n  int *v7;\n  int *v8;\n  char v9;\n  char *v10;\n  int *v11;\n  int v12;\n  int v13;\n  int v14;\n  char *v15;\n  signed long long v16;\n  void *v17;\n  char v18;\n  long long v19;\n  char *v20;\n  signed long long v21;\n  void *v22;\n  char v24[4088];\n  long long v25;\n  int v26;\n  int v27;\n  long long v28;\n  long long v29;\n  unsigned long long v30;\n  v0 = LCS_table[0];\n  v1 = m;\n  v30 = __readfsqword(40u);\n  if (m < 0) {\n    v28 = m;\n  } else {\n    v2 = LCS_table[0];\n    v28 = m;\n    do {\n      *v2 = 0;\n      v2 += 40;\n    } while (v2 != LCS_table[v1 + 1]);\n  }\n  v3 = n;\n  v29 = n;\n  if (n >= 0) v0 = (int *)memset(LCS_table, 0, 4LL * n + 4);\n  i = 1;\n  if (v1 <= 0) {\n    v19 = v0[40 * v28 + v29];\n    v20 = (char *)&v25 - (((int)v19 + 1 + 15LL) & 18446744073709547520LL);\n    if (&v25 != (long long *)v20) {\n      while (v24 != v20)\n        ;\n    }\n    v21 = ((unsigned short)v19 + 16) & 4080;\n    v22 = alloca(v21);\n    if ((((unsigned short)v19 + 16) & 4080) != 0)\n      *(uint64_t *)&v24[v21 - 8] = *(uint64_t *)&v24[v21 - 8];\n    v24[v19] = 0;\n  } else {\n    v26 = v1;\n    v4 = (unsigned int)(v1 - 1);\n    v5 = S1;\n    v6 = 1;\n    if (v3 > 0) v6 = v3 + 1;\n    v7 = LCS_table[0];\n    v27 = v6;\n    do {\n      v8 = v7 + 40;\n      if (v3 > 0) {\n        v8 = v7 + 40;\n        v9 = *v5;\n        v10 = S2;\n        v11 = v7 + 40;\n        do {\n          if (v9 == *v10) {\n            v12 = *v7 + 1;\n          } else {\n            v12 = *v11;\n            if (*v11 < v7[1]) v12 = v7[1];\n          }\n          ++v10;\n          v11[1] = v12;\n          ++v7;\n          ++v11;\n        } while (&S2[v3 - 1 + 1] != v10);\n      }\n      ++v5;\n      v7 = v8;\n    } while (v5 != &S1[v4 + 1]);\n    v13 = v26;\n    j = v27;\n    i = v26 + 1;\n    v14 = v0[40 * v28 + v29];\n    v15 = (char *)&v25 - ((v14 + 1 + 15LL) & 18446744073709547520LL);\n    if (&v25 != (long long *)v15) {\n      while (v24 != v15)\n        ;\n    }\n    v16 = ((unsigned short)v14 + 16) & 4080;\n    v17 = alloca(v16);\n    if ((((unsigned short)v14 + 16) & 4080) != 0)\n      *(uint64_t *)&v24[v16 - 8] = *(uint64_t *)&v24[v16 - 8];\n    v24[v14] = 0;\n    if (v3 > 0) {\n      while (1) {\n        v18 = S1[(int)v4];\n        if (v18 == S2[v3 - 1]) {\n          --v14;\n          v13 = v4;\n          --v3;\n          v24[v14] = v18;\n          if ((int)v4 <= 0) break;\n        } else {\n          if (v0[40 * (int)v4 + v3] <= v0[40 * v13 - 1 + v3])\n            --v3;\n          else\n            v13 = v4;\n          if (v13 <= 0) break;\n        }\n        if (v3 <= 0) break;\n        LODWORD(v4) = v13 - 1;\n      }\n    }\n  }\n  libmin_printf(\"LCS: %s\", v24);\n}", "binary": "max-subseq/max-subseq.host.O3", "assembly": "<lcsAlgo>:\nendbr64\npush   %rbp\nlea    0x5664(%rip),%r11\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x38,%rsp\nmov    0x6f51(%rip),%r12d\nmov    %fs:0x28,%rax\nmov    %rax,-0x38(%rbp)\nxor    %eax,%eax\ntest   %r12d,%r12d\njs     150e <lcsAlgo+0x27e>\nmovslq %r12d,%rbx\nlea    0xa0(%r11),%rcx\nmov    %r11,%rax\nlea    (%rbx,%rbx,4),%rdx\nmov    %rbx,-0x50(%rbp)\nshl    $0x5,%rdx\nadd    %rcx,%rdx\nnopw   0x0(%rax,%rax,1)\nmovl   $0x0,(%rax)\nadd    $0xa0,%rax\ncmp    %rdx,%rax\njne    12f0 <lcsAlgo+0x60>\nmov    0x6ef9(%rip),%ebx\nmovslq %ebx,%rax\nmov    %rax,-0x48(%rbp)\ntest   %ebx,%ebx\njs     1327 <lcsAlgo+0x97>\nmov    %r11,%rdi\nlea    0x4(,%rax,4),%rdx\nxor    %esi,%esi\ncall   10d0 <memset@plt>\nmov    %rax,%r11\nmovl   $0x1,0x6edb(%rip)\ntest   %r12d,%r12d\njle    151a <lcsAlgo+0x28a>\nlea    0x4cef(%rip),%r15\nlea    -0x1(%r12),%edx\ntest   %ebx,%ebx\nmov    %r12d,-0x58(%rbp)\nlea    0x1(%r15),%rax\nmov    %rdx,%r13\nmov    %r15,%r10\nlea    (%rdx,%rax,1),%r14\nlea    0x1(%rbx),%edx\nmov    $0x1,%eax\ncmovg  %edx,%eax\nlea    0x4ca5(%rip),%r9\nlea    0x558d(%rip),%rsi\nmov    %eax,-0x54(%rbp)\nlea    -0x1(%rbx),%eax\nadd    %rax,%r9\nnopl   0x0(%rax)\nlea    0xa0(%rsi),%r12\ntest   %ebx,%ebx\njle    13d8 <lcsAlgo+0x148>\nlea    0xa0(%rsi),%r12\nmovzbl (%r10),%r8d\nlea    0x4c73(%rip),%rdx\nmov    %r12,%rcx\njmp    13c6 <lcsAlgo+0x136>\nnopw   0x0(%rax,%rax,1)\nmov    (%rcx),%eax\nmov    0x4(%rsi),%edi\ncmp    %edi,%eax\ncmovl  %edi,%eax\nadd    $0x1,%rdx\nmov    %eax,0x4(%rcx)\nadd    $0x4,%rsi\nadd    $0x4,%rcx\ncmp    %rdx,%r9\nje     13d8 <lcsAlgo+0x148>\ncmp    (%rdx),%r8b\njne    13a8 <lcsAlgo+0x118>\nmov    (%rsi),%eax\nadd    $0x1,%eax\njmp    13b2 <lcsAlgo+0x122>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%r10\nmov    %r12,%rsi\ncmp    %r14,%r10\njne    1380 <lcsAlgo+0xf0>\nmov    -0x54(%rbp),%eax\nmov    -0x58(%rbp),%r12d\nmov    %rsp,%rcx\nmov    -0x48(%rbp),%rdi\nmov    %eax,0x6e10(%rip)\nlea    0x1(%r12),%eax\nmov    %eax,0x6e09(%rip)\nmov    -0x50(%rbp),%rax\nlea    (%rax,%rax,4),%rax\nlea    (%rdi,%rax,8),%rax\nmov    (%r11,%rax,4),%edi\nlea    0x1(%rdi),%eax\ncltq\nadd    $0xf,%rax\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nsub    %rax,%rcx\nand    $0xfffffffffffffff0,%rdx\ncmp    %rcx,%rsp\nje     1446 <lcsAlgo+0x1b6>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\ncmp    %rcx,%rsp\njne    1431 <lcsAlgo+0x1a1>\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\njne    1503 <lcsAlgo+0x273>\nmovslq %edi,%rax\nmov    %rsp,%r9\nmovb   $0x0,(%rsp,%rax,1)\ntest   %ebx,%ebx\njle    14d0 <lcsAlgo+0x240>\nlea    0x4ba3(%rip),%r8\njmp    14a3 <lcsAlgo+0x213>\nnop\nmovslq %ebx,%rsi\nlea    (%rax,%rax,4),%rax\nlea    (%rsi,%rax,8),%rsi\nmovslq %r12d,%rax\nlea    (%rax,%rax,4),%rax\nlea    (%rcx,%rax,8),%rax\nmov    (%r11,%rax,4),%eax\ncmp    %eax,(%r11,%rsi,4)\ncmovg  %r13d,%r12d\ncmovle %edx,%ebx\ntest   %r12d,%r12d\njle    14d0 <lcsAlgo+0x240>\ntest   %ebx,%ebx\njle    14d0 <lcsAlgo+0x240>\nlea    -0x1(%r12),%r13d\nlea    -0x1(%rbx),%edx\nmovslq %r13d,%rax\nmovslq %edx,%rcx\nmovzbl (%r15,%rax,1),%esi\ncmp    (%r8,%rcx,1),%sil\njne    1470 <lcsAlgo+0x1e0>\nsub    $0x1,%edi\nmov    %r13d,%r12d\nmov    %edx,%ebx\nmovslq %edi,%rax\nmov    %sil,(%r9,%rax,1)\ntest   %r12d,%r12d\njg     149a <lcsAlgo+0x20a>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nmov    %r9,%rsi\nlea    0x2b28(%rip),%rdi\ncall   3660 <libmin_printf>\nmov    -0x38(%rbp),%rax\nsub    %fs:0x28,%rax\njne    1586 <lcsAlgo+0x2f6>\nlea    -0x28(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\norq    $0x0,-0x8(%rsp,%rdx,1)\njmp    1458 <lcsAlgo+0x1c8>\nmovslq %r12d,%rax\nmov    %rax,-0x50(%rbp)\njmp    1301 <lcsAlgo+0x71>\nmov    -0x50(%rbp),%rax\nmov    -0x48(%rbp),%rbx\nmov    %rsp,%rsi\nlea    (%rax,%rax,4),%rax\nlea    (%rbx,%rax,8),%rax\nmovslq (%r11,%rax,4),%rcx\nlea    0x1(%rcx),%eax\ncltq\nadd    $0xf,%rax\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nsub    %rax,%rsi\nand    $0xfffffffffffffff0,%rdx\ncmp    %rsi,%rsp\nje     1564 <lcsAlgo+0x2d4>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\ncmp    %rsi,%rsp\njne    154f <lcsAlgo+0x2bf>\nmov    %rdx,%rax\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     157a <lcsAlgo+0x2ea>\norq    $0x0,-0x8(%rsp,%rax,1)\nmovb   $0x0,(%rsp,%rcx,1)\nmov    %rsp,%r9\njmp    14d0 <lcsAlgo+0x240>\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "max-subseq/max-subseq.c", "function_name": "main", "content": "int\nmain(void)\n{\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "max-subseq/max-subseq.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}", "binary": "max-subseq/max-subseq.host.O3", "assembly": "<main>:\nendbr64\npush   %r12\nlea    0x4ee3(%rip),%r12\npush   %rbp\nlea    0x4efb(%rip),%rbp\nmov    %rbp,%rdi\nsub    $0x8,%rsp\ncall   3870 <libmin_strlen>\nmov    %r12,%rdi\nmov    %eax,0x70ba(%rip)\ncall   3870 <libmin_strlen>\nmov    0x70af(%rip),%edx\nmov    %r12,%rcx\nmov    %rbp,%rsi\nmov    %rax,%r8\nlea    0x2ea7(%rip),%rdi\nmov    %eax,0x7095(%rip)\nxor    %eax,%eax\ncall   3660 <libmin_printf>\nxor    %eax,%eax\ncall   1290 <lcsAlgo>\nlea    0x2ea7(%rip),%rdi\nxor    %eax,%eax\ncall   3660 <libmin_printf>\ncall   38a0 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "mersenne/mersenne.c", "function_name": "genrand", "content": "unsigned int \ngenrand(void)\n{\n  unsigned int y;\n  static unsigned int mag01[2]={0x0, MATRIX_A};\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (mti >= N) { /* generate N words at one time */\n    int kk;\n\n    if (mti == N+1)   /* if sgenrand() has not been called, */\n      sgenrand(4357); /* a default initial seed is used   */\n\n    for (kk=0;kk<N-M;kk++)\n      {\n\ty = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n\tmt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];\n      }\n    for (;kk<N-1;kk++)\n      {\n\ty = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n\tmt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];\n      }\n    y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);\n    mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];\n\n    mti = 0;\n  }\n  \n  y = mt[mti++];\n  y ^= TEMPERING_SHIFT_U(y);\n  y ^= TEMPERING_SHIFT_S(y) & TEMPERING_MASK_B;\n  y ^= TEMPERING_SHIFT_T(y) & TEMPERING_MASK_C;\n  y ^= TEMPERING_SHIFT_L(y);\n\n  return y; \n}\n"}, "pseudo": {"path": "mersenne/mersenne.host.O3.pseudo", "function_name": "genrand", "address": "0x1380", "label": "genrand", "content": "unsigned int __cdecl genrand()\n{\n  int v0; // edx\n  unsigned int v1; // ecx\n  unsigned int *v3; // rdx\n  unsigned int v4; // r8d\n  unsigned int *v5; // rcx\n  unsigned int v6; // esi\n  unsigned int v7; // esi\n  unsigned int v8; // ecx\n  unsigned int *v9; // rcx\n  int v10; // eax\n  int v11; // edx\n\n  if ( mti > 623 )\n  {\n    if ( mti == 625 )\n    {\n      v9 = mt;\n      v10 = 4357;\n      do\n      {\n        v11 = 69069 * v10;\n        LOWORD(v10) = 0;\n        *v9++ = ((unsigned int)(v11 + 1) >> 16) | v10;\n        v10 = 69069 * (v11 + 1) + 1;\n      }\n      while ( &mt[624] != v9 );\n    }\n    v3 = mt;\n    v4 = mt[0];\n    v5 = mt;\n    do\n    {\n      v6 = v4;\n      v4 = v5[1];\n      ++v5;\n      *(v5 - 1) = mag01_0[v4 & 1] ^ v5[396] ^ ((v6 & 0x80000000 | v4 & 0x7FFFFFFF) >> 1);\n    }\n    while ( &mt[227] != v5 );\n    v7 = mt[227];\n    do\n    {\n      v8 = v7;\n      v7 = v3[228];\n      ++v3;\n      v3[226] = mag01_0[v7 & 1] ^ *(v3 - 1) ^ ((v8 & 0x80000000 | v7 & 0x7FFFFFFF) >> 1);\n    }\n    while ( &mt[396] != v3 );\n    v1 = mt[0];\n    mt[623] = mag01_0[mt[0] & 1] ^ mt[396] ^ ((mt[0] & 0x7FFFFFFF | mt[623] & 0x80000000) >> 1);\n    v0 = 1;\n  }\n  else\n  {\n    v0 = mti + 1;\n    v1 = mt[mti];\n  }\n  mti = v0;\n  return v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 0x9D2C5680 ^ ((v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 0x9D2C5680) << 15) & 0xEFC60000 ^ ((v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 0x9D2C5680 ^ ((v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 0x9D2C5680) << 15) & 0xEFC60000) >> 18);\n}\n"}, "pseudo_normalize": "unsigned int genrand() {\n  int v0;\n  unsigned int v1;\n  unsigned int *v3;\n  unsigned int v4;\n  unsigned int *v5;\n  unsigned int v6;\n  unsigned int v7;\n  unsigned int v8;\n  unsigned int *v9;\n  int v10;\n  int v11;\n  if (mti > 623) {\n    if (mti == 625) {\n      v9 = mt;\n      v10 = 4357;\n      do {\n        v11 = 69069 * v10;\n        LOWORD(v10) = 0;\n        *v9++ = ((unsigned int)(v11 + 1) >> 16) | v10;\n        v10 = 69069 * (v11 + 1) + 1;\n      } while (&mt[624] != v9);\n    }\n    v3 = mt;\n    v4 = mt[0];\n    v5 = mt;\n    do {\n      v6 = v4;\n      v4 = v5[1];\n      ++v5;\n      *(v5 - 1) = mag01_0[v4 & 1] ^ v5[396] ^\n                  ((v6 & 2147483648 | v4 & 2147483647) >> 1);\n    } while (&mt[227] != v5);\n    v7 = mt[227];\n    do {\n      v8 = v7;\n      v7 = v3[228];\n      ++v3;\n      v3[226] = mag01_0[v7 & 1] ^ *(v3 - 1) ^\n                ((v8 & 2147483648 | v7 & 2147483647) >> 1);\n    } while (&mt[396] != v3);\n    v1 = mt[0];\n    mt[623] = mag01_0[mt[0] & 1] ^ mt[396] ^\n              ((mt[0] & 2147483647 | mt[623] & 2147483648) >> 1);\n    v0 = 1;\n  } else {\n    v0 = mti + 1;\n    v1 = mt[mti];\n  }\n  mti = v0;\n  return v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 2636928640 ^\n         ((v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 2636928640) << 15) &\n             4022730752 ^\n         ((v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 2636928640 ^\n           ((v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 2636928640) << 15) &\n               4022730752) >>\n          18);\n}", "binary": "mersenne/mersenne.host.O3", "assembly": "<genrand>:\nendbr64\nmovslq 0x4c85(%rip),%rax\ncmp    $0x26f,%eax\njg     13cd <genrand+0x4d>\nlea    0x4ee7(%rip),%rcx\nlea    0x1(%rax),%edx\nmov    (%rcx,%rax,4),%ecx\nmov    %edx,0x4c6b(%rip)\nmov    %ecx,%edx\nshr    $0xb,%edx\nxor    %ecx,%edx\nmov    %edx,%eax\nshl    $0x7,%eax\nand    $0x9d2c5680,%eax\nxor    %edx,%eax\nmov    %eax,%edx\nshl    $0xf,%edx\nand    $0xefc60000,%edx\nxor    %eax,%edx\nmov    %edx,%eax\nshr    $0x12,%eax\nxor    %edx,%eax\nret\ncmp    $0x271,%eax\nje     14ae <genrand+0x12e>\nlea    0x4ea1(%rip),%rdx\nmov    0x4e9a(%rip),%r8d\nlea    0x2c23(%rip),%rdi\nlea    0x38c(%rdx),%r9\nmov    %rdx,%rcx\nnopw   0x0(%rax,%rax,1)\nmov    %r8d,%esi\nmov    0x4(%rcx),%r8d\nadd    $0x4,%rcx\nand    $0x80000000,%esi\nmov    %r8d,%eax\nand    $0x7fffffff,%eax\nor     %esi,%eax\nmov    %eax,%esi\nand    $0x1,%eax\nshr    %esi\nxor    0x630(%rcx),%esi\nxor    (%rdi,%rax,4),%esi\nmov    %esi,-0x4(%rcx)\ncmp    %rcx,%r9\njne    1400 <genrand+0x80>\nmov    0x51d3(%rip),%esi\nlea    0x5470(%rip),%r8\nmov    %esi,%ecx\nmov    0x390(%rdx),%esi\nadd    $0x4,%rdx\nand    $0x80000000,%ecx\nmov    %esi,%eax\nand    $0x7fffffff,%eax\nor     %ecx,%eax\nmov    %eax,%ecx\nand    $0x1,%eax\nshr    %ecx\nxor    -0x4(%rdx),%ecx\nxor    (%rdi,%rax,4),%ecx\nmov    %ecx,0x388(%rdx)\ncmp    %rdx,%r8\njne    1440 <genrand+0xc0>\nmov    0x4e07(%rip),%ecx\nmov    0x57bd(%rip),%eax\nmov    %ecx,%edx\nand    $0x80000000,%eax\nand    $0x7fffffff,%edx\nor     %edx,%eax\nmov    %eax,%edx\nand    $0x1,%eax\nshr    %edx\nxor    0x5415(%rip),%edx\nxor    (%rdi,%rax,4),%edx\nmov    %edx,0x5798(%rip)\nmov    $0x1,%edx\njmp    139f <genrand+0x1f>\nlea    0x4dcb(%rip),%rcx\nmov    $0x1105,%eax\nlea    0x9c0(%rcx),%rdi\nnopl   0x0(%rax)\nimul   $0x10dcd,%eax,%edx\nxor    %ax,%ax\nadd    $0x4,%rcx\nadd    $0x1,%edx\nmov    %edx,%esi\nimul   $0x10dcd,%edx,%edx\nshr    $0x10,%esi\nor     %esi,%eax\nmov    %eax,-0x4(%rcx)\nlea    0x1(%rdx),%eax\ncmp    %rcx,%rdi\njne    14c8 <genrand+0x148>\njmp    13d8 <genrand+0x58>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "mersenne/mersenne.c", "function_name": "lsgenrand", "content": "/* Initialization by \"sgenrand()\" is an example. Theoretically,      */\n/* there are 2^19937-1 possible states as an intial state.           */\n/* This function allows to choose any of 2^19937-1 ones.             */\n/* Essential bits in \"seed_array[]\" is following 19937 bits:         */\n/* (seed_array[0]&UPPER_MASK), seed_array[1], ..., seed_array[N-1]. */\n/* (seed_array[0]&LOWER_MASK) is discarded.                          */ \n/* Theoretically,                                                    */\n/* (seed_array[0]&UPPER_MASK), seed_array[1], ..., seed_array[N-1]  */\n/* can take any values except all zeros.                             */\nvoid\nlsgenrand(unsigned int seed_array[])\n     /* the length of seed_array[] must be at least N */\n{\n  int i;\n\n  for (i=0;i<N;i++) \n    mt[i] = seed_array[i];\n  mti=N;\n}\n"}, "pseudo": {"path": "mersenne/mersenne.host.O3.pseudo", "function_name": "lsgenrand", "address": "0x1320", "label": "lsgenrand", "content": "void __fastcall lsgenrand(unsigned int *seed_array)\n{\n  __int64 v1; // rax\n\n  v1 = 0LL;\n  if ( (unsigned __int64)((char *)mt - (char *)(seed_array + 1)) <= 8 )\n  {\n    do\n    {\n      mt[v1] = seed_array[v1];\n      ++v1;\n    }\n    while ( v1 != 624 );\n  }\n  else\n  {\n    do\n    {\n      *(__m128i *)&mt[v1] = _mm_loadu_si128((const __m128i *)&seed_array[v1]);\n      v1 += 4LL;\n    }\n    while ( v1 != 624 );\n  }\n  mti = 624;\n}\n"}, "pseudo_normalize": "void lsgenrand(unsigned int *seed_array) {\n  long long v1;\n  v1 = 0LL;\n  if ((unsigned long long)((char *)mt - (char *)(seed_array + 1)) <= 8) {\n    do {\n      mt[v1] = seed_array[v1];\n      ++v1;\n    } while (v1 != 624);\n  } else {\n    do {\n      *(__m128i *)&mt[v1] = _mm_loadu_si128((const __m128i *)&seed_array[v1]);\n      v1 += 4LL;\n    } while (v1 != 624);\n  }\n  mti = 624;\n}", "binary": "mersenne/mersenne.host.O3", "assembly": "<lsgenrand>:\nendbr64\nlea    0x4f55(%rip),%rdx\nlea    0x4(%rdi),%rcx\nmov    %rdx,%rax\nsub    %rcx,%rax\ncmp    $0x8,%rax\nmov    $0x0,%eax\njbe    1360 <lsgenrand+0x40>\nmovdqu (%rdi,%rax,1),%xmm0\nmovaps %xmm0,(%rdx,%rax,1)\nadd    $0x10,%rax\ncmp    $0x9c0,%rax\njne    1340 <lsgenrand+0x20>\nmovl   $0x270,0x4cb1(%rip)\nret\nmov    (%rdi,%rax,1),%ecx\nmov    %ecx,(%rdx,%rax,1)\nadd    $0x4,%rax\ncmp    $0x9c0,%rax\njne    1360 <lsgenrand+0x40>\njmp    1355 <lsgenrand+0x35>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "mersenne/mersenne.c", "function_name": "main", "content": "/* This main() outputs first 1000 generated numbers.  */\nint\nmain(void)\n{ \n  int steps = 10000;\n  int i, j;\n    \n  sgenrand(4357);\n  for (i=0,j=0; i<steps; i++)\n    {\n      if ((i % 100) == 0)\n\t{\n\t  libmin_printf(\"%10u \", genrand());\n\t  if (++j%5==0)\n\t    libmin_printf(\"\\n\");\n\t}\n    }\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "mersenne/mersenne.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int *v3; // rcx\n  int v4; // eax\n  int v5; // edx\n  int v6; // ebp\n  int v7; // ebx\n  unsigned int v8; // eax\n\n  v3 = mt;\n  v4 = 4357;\n  do\n  {\n    v5 = 69069 * v4;\n    LOWORD(v4) = 0;\n    *v3++ = ((unsigned int)(v5 + 1) >> 16) | v4;\n    v4 = 69069 * (v5 + 1) + 1;\n  }\n  while ( &mt[624] != v3 );\n  mti = 624;\n  v6 = 0;\n  v7 = 0;\n  while ( 1 )\n  {\n    if ( __ROR4__(-1030792151 * v7, 2) > 0x28F5C28u\n      || (v8 = genrand(), ++v6, libmin_printf(\"%10u \", v8), (unsigned int)(-858993459 * v6) > 0x33333333) )\n    {\n      if ( ++v7 == 10000 )\n        goto LABEL_8;\n    }\n    else\n    {\n      ++v7;\n      libmin_printf(\"\\n\");\n      if ( v7 == 10000 )\n      {\nLABEL_8:\n        libmin_printf(\"\\n\");\n        libmin_success();\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int *v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  unsigned int v8;\n  v3 = mt;\n  v4 = 4357;\n  do {\n    v5 = 69069 * v4;\n    LOWORD(v4) = 0;\n    *v3++ = ((unsigned int)(v5 + 1) >> 16) | v4;\n    v4 = 69069 * (v5 + 1) + 1;\n  } while (&mt[624] != v3);\n  mti = 624;\n  v6 = 0;\n  v7 = 0;\n  while (1) {\n    if (__ROR4__(-1030792151 * v7, 2) > 42949672u ||\n        (v8 = genrand(), ++v6, libmin_printf(\"%10u \", v8),\n         (unsigned int)(-858993459 * v6) > 858993459)) {\n      if (++v7 == 10000) goto LABEL_8;\n    } else {\n      ++v7;\n      libmin_printf(\"\\n\");\n      if (v7 == 10000) {\n      LABEL_8:\n        libmin_printf(\"\\n\");\n        libmin_success();\n      }\n    }\n  }\n}", "binary": "mersenne/mersenne.host.O3", "assembly": "<main>:\nendbr64\npush   %r13\nlea    0x5173(%rip),%rcx\nmov    $0x1105,%eax\npush   %r12\nlea    0x9c0(%rcx),%rdi\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nnopl   0x0(%rax)\nimul   $0x10dcd,%eax,%edx\nxor    %ax,%ax\nadd    $0x4,%rcx\nadd    $0x1,%edx\nmov    %edx,%esi\nimul   $0x10dcd,%edx,%edx\nshr    $0x10,%esi\nor     %esi,%eax\nmov    %eax,-0x4(%rcx)\nlea    0x1(%rdx),%eax\ncmp    %rcx,%rdi\njne    1128 <main+0x28>\nmovl   $0x270,0x4eb6(%rip)\nxor    %ebp,%ebp\nxor    %ebx,%ebx\nlea    0x2ea5(%rip),%r13\nlea    0x2e98(%rip),%r12\njmp    117b <main+0x7b>\nxchg   %ax,%ax\nadd    $0x1,%ebx\ncmp    $0x2710,%ebx\nje     11c1 <main+0xc1>\nimul   $0xc28f5c29,%ebx,%eax\nror    $0x2,%eax\ncmp    $0x28f5c28,%eax\nja     1170 <main+0x70>\ncall   1380 <genrand>\nadd    $0x1,%ebp\nmov    %r12,%rdi\nmov    %eax,%esi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nimul   $0xcccccccd,%ebp,%eax\ncmp    $0x33333333,%eax\nja     1170 <main+0x70>\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   35d0 <libmin_printf>\ncmp    $0x2710,%ebx\njne    117b <main+0x7b>\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\ncall   3810 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   (%rax)\n"}
{"source": {"path": "mersenne/mersenne.c", "function_name": "sgenrand", "content": " /* mti==N+1 means mt[N] is not initialized */\n\n/* Initializing the array with a seed */\nvoid\nsgenrand(unsigned int seed)\n{\n  int i;\n\n  for (i=0;i<N;i++)\n    {\n      mt[i] = seed & 0xffff0000;\n      seed = 69069 * seed + 1;\n      mt[i] |= (seed & 0xffff0000) >> 16;\n      seed = 69069 * seed + 1;\n    }\n  mti = N;\n}\n"}, "pseudo": {"path": "mersenne/mersenne.host.O3.pseudo", "function_name": "sgenrand", "address": "0x12d0", "label": "sgenrand", "content": "void __fastcall sgenrand(unsigned int seed)\n{\n  unsigned int *v1; // rdx\n  unsigned int v2; // eax\n\n  v1 = mt;\n  do\n  {\n    v2 = 69069 * seed;\n    LOWORD(seed) = 0;\n    *v1++ = ((v2 + 1) >> 16) | seed;\n    seed = 69069 * (v2 + 1) + 1;\n  }\n  while ( &mt[624] != v1 );\n  mti = 624;\n}\n"}, "pseudo_normalize": "void sgenrand(unsigned int seed) {\n  unsigned int *v1;\n  unsigned int v2;\n  v1 = mt;\n  do {\n    v2 = 69069 * seed;\n    LOWORD(seed) = 0;\n    *v1++ = ((v2 + 1) >> 16) | seed;\n    seed = 69069 * (v2 + 1) + 1;\n  } while (&mt[624] != v1);\n  mti = 624;\n}", "binary": "mersenne/mersenne.host.O3", "assembly": "<sgenrand>:\nendbr64\nlea    0x4fa5(%rip),%rdx\nlea    0x9c0(%rdx),%rsi\nnopw   0x0(%rax,%rax,1)\nimul   $0x10dcd,%edi,%eax\nxor    %di,%di\nadd    $0x4,%rdx\nadd    $0x1,%eax\nmov    %eax,%ecx\nimul   $0x10dcd,%eax,%eax\nshr    $0x10,%ecx\nor     %ecx,%edi\nmov    %edi,-0x4(%rdx)\nlea    0x1(%rax),%edi\ncmp    %rdx,%rsi\njne    12e8 <sgenrand+0x18>\nmovl   $0x270,0x4cf6(%rip)\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "displayGraph", "content": "void\ndisplayGraph(int32_t graph[V][V])\n{\n\tint index = 0;\n\tfor (int i=-1;i<V;i++)\n  {\n\t\tfor (int j=-1;j<V;j++)\n    {\n\t\t\tif (i==-1)\n      {\n\t\t\t\tif (j==-1)\n          libmin_printf(\"       \");\n\t\t\t\telse\n          libmin_printf(\"%8s\", vertName[j]);\n\t\t\t}\n      else\n      {\n\t\t\t\tif(j==-1)\n        {\n          libmin_printf(\"%8s\", vertName[index]);\n\t\t\t\t\tindex++;\n\t\t\t\t}\n        else\n          libmin_printf(\"%8d\", graph[i][j]);\n\t\t\t}\n\t\t}\n    libmin_printf(\"\\n\");\n\t}\n  libmin_printf(\"\\n\\n\");\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O3.pseudo", "function_name": "displayGraph", "address": "0x1db0", "label": "displayGraph", "content": "void __fastcall displayGraph(int32_t (*graph)[1])\n{\n  int v1; // r12d\n  int32_t *v2; // rbx\n  __int64 v3; // r14\n  __int64 v4; // rax\n  __int64 j; // r14\n  int i; // [rsp+Ch] [rbp-3Ch]\n\n  v1 = 0;\n  v2 = &(*graph)[-10];\n  for ( i = -1; i != 10; ++i )\n  {\n    if ( i != -1 )\n      goto LABEL_3;\n    for ( j = 0LL; !(_DWORD)j; ++j )\n    {\n      libmin_printf(\"       \");\nLABEL_12:\n      ;\n    }\n    libmin_printf(\"%8s\", *((const char **)&unk_7018 + j));\n    if ( (_DWORD)j != 10 )\n      goto LABEL_12;\n    v2 += 10;\n    libmin_printf((char *)\"\\n\");\n    i = 0;\nLABEL_3:\n    v3 = 0LL;\n    while ( 2 )\n    {\n      if ( !v3 )\n      {\n        v4 = v1++;\n        libmin_printf(\"%8s\", vertName[v4]);\n        goto LABEL_5;\n      }\n      libmin_printf(\"%8d\", v2[v3 - 1]);\n      if ( v3 != 10 )\n      {\nLABEL_5:\n        ++v3;\n        continue;\n      }\n      break;\n    }\n    v2 += 10;\n    libmin_printf((char *)\"\\n\");\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}\n"}, "pseudo_normalize": "void displayGraph(int32_t (*graph)[1]) {\n  int v1;\n  int32_t *v2;\n  long long v3;\n  long long v4;\n  long long j;\n  int i;\n  v1 = 0;\n  v2 = &(*graph)[-10];\n  for (i = -1; i != 10; ++i) {\n    if (i != -1) goto LABEL_3;\n    for (j = 0LL; !(uint32_t)j; ++j) {\n      libmin_printf(\"       \");\n    LABEL_12:;\n    }\n    libmin_printf(\"%8s\", *((const char **)&unk_7018 + j));\n    if ((uint32_t)j != 10) goto LABEL_12;\n    v2 += 10;\n    libmin_printf((char *)\"\\n\");\n    i = 0;\n  LABEL_3:\n    v3 = 0LL;\n    while (2) {\n      if (!v3) {\n        v4 = v1++;\n        libmin_printf(\"%8s\", vertName[v4]);\n        goto LABEL_5;\n      }\n      libmin_printf(\"%8d\", v2[v3 - 1]);\n      if (v3 != 10) {\n      LABEL_5:\n        ++v3;\n        continue;\n      }\n      break;\n    }\n    v2 += 10;\n    libmin_printf((char *)\"\\n\");\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}", "binary": "minspan/minspan.host.O3", "assembly": "<displayGraph>:\nendbr64\npush   %r15\nlea    0x525b(%rip),%r15\npush   %r14\npush   %r13\nlea    0x3244(%rip),%r13\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nlea    0x323b(%rip),%rbp\npush   %rbx\nlea    -0x28(%rdi),%rbx\nsub    $0x18,%rsp\nmovl   $0xffffffff,0xc(%rsp)\ncs nopw 0x0(%rax,%rax,1)\ncmpl   $0xffffffff,0xc(%rsp)\nje     1e80 <displayGraph+0xd0>\nxor    %r14d,%r14d\njmp    1e19 <displayGraph+0x69>\nmov    -0x4(%rbx,%r14,4),%esi\nxor    %eax,%eax\nmov    %rbp,%rdi\ncall   4230 <libmin_printf>\ncmp    $0xa,%r14\nje     1e40 <displayGraph+0x90>\nadd    $0x1,%r14\ntest   %r14,%r14\njne    1e00 <displayGraph+0x50>\nmovslq %r12d,%rax\nlea    0x51f8(%rip),%rdx\nmov    %r13,%rdi\nadd    $0x1,%r12d\nmov    (%rdx,%rax,8),%rsi\nxor    %eax,%eax\ncall   4230 <libmin_printf>\njmp    1e15 <displayGraph+0x65>\nnopl   0x0(%rax)\nlea    0x31f2(%rip),%rdi\nxor    %eax,%eax\nadd    $0x28,%rbx\ncall   4230 <libmin_printf>\naddl   $0x1,0xc(%rsp)\nmov    0xc(%rsp),%eax\ncmp    $0xa,%eax\njne    1df0 <displayGraph+0x40>\nadd    $0x18,%rsp\nlea    0x31cd(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    4230 <libmin_printf>\nnopl   0x0(%rax)\nxor    %r14d,%r14d\njmp    1ea0 <displayGraph+0xf0>\nnopl   (%rax)\nmov    (%r15,%r14,8),%rsi\nxor    %eax,%eax\nmov    %r13,%rdi\ncall   4230 <libmin_printf>\ncmp    $0xa,%r14d\nje     1eb8 <displayGraph+0x108>\nadd    $0x1,%r14\ntest   %r14d,%r14d\njne    1e88 <displayGraph+0xd8>\nlea    0x3158(%rip),%rdi\nxor    %eax,%eax\ncall   4230 <libmin_printf>\njmp    1e9c <displayGraph+0xec>\nnopl   (%rax)\nlea    0x317a(%rip),%rdi\nxor    %eax,%eax\nadd    $0x28,%rbx\ncall   4230 <libmin_printf>\nmovl   $0x0,0xc(%rsp)\njmp    1dfb <displayGraph+0x4b>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "displayGraph1", "content": "void\ndisplayGraph1(int32_t graph[V][V], int32_t path[V])\n{\n\tint index = 0;\n\tfor (int i=-1;i<V;i++)\n  {\n\t\tfor (int j=-1;j<V;j++)\n    {\n\t\t\tif (i==-1)\n      {\n\t\t\t\tif (j==-1)\n          libmin_printf(\"       \");\n\t\t\t\telse\n          libmin_printf(\"%8s\", vertName[j]);\n\t\t\t}\n      else\n      {\n\t\t\t\tif(j==-1)\n        {\n          libmin_printf(\"%8s\", vertName[index]);\n\t\t\t\t\tindex++;\n\t\t\t\t}\n        else\n          libmin_printf(\"%8d / %d\", graph[i][j], path[i]);\n\t\t\t}\n\t\t}\n    libmin_printf(\"\\n\");\n\t}\n  libmin_printf(\"\\n\\n\");\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O3.pseudo", "function_name": "displayGraph1", "address": "0x1ee0", "label": "displayGraph1", "content": "void __fastcall displayGraph1(int32_t (*graph)[1], int32_t *path)\n{\n  int v2; // r13d\n  int32_t *v3; // rbp\n  int32_t *v4; // rbx\n  __int64 v5; // r15\n  __int64 v6; // rax\n  __int64 j; // r15\n  int i; // [rsp+Ch] [rbp-3Ch]\n\n  v2 = 0;\n  v3 = path - 1;\n  v4 = &(*graph)[-10];\n  for ( i = -1; i != 10; ++i )\n  {\n    if ( i != -1 )\n      goto LABEL_3;\n    for ( j = 0LL; !(_DWORD)j; ++j )\n    {\n      libmin_printf(\"       \");\nLABEL_12:\n      ;\n    }\n    libmin_printf(\"%8s\", *((const char **)&unk_7018 + j));\n    if ( (_DWORD)j != 10 )\n      goto LABEL_12;\n    ++v3;\n    v4 += 10;\n    libmin_printf((char *)\"\\n\");\n    i = 0;\nLABEL_3:\n    v5 = 0LL;\n    while ( 2 )\n    {\n      if ( !v5 )\n      {\n        v6 = v2++;\n        libmin_printf(\"%8s\", vertName[v6]);\n        goto LABEL_5;\n      }\n      libmin_printf(\"%8d / %d\", v4[v5 - 1], *v3);\n      if ( v5 != 10 )\n      {\nLABEL_5:\n        ++v5;\n        continue;\n      }\n      break;\n    }\n    ++v3;\n    v4 += 10;\n    libmin_printf((char *)\"\\n\");\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}\n"}, "pseudo_normalize": "void displayGraph1(int32_t (*graph)[1], int32_t *path) {\n  int v2;\n  int32_t *v3;\n  int32_t *v4;\n  long long v5;\n  long long v6;\n  long long j;\n  int i;\n  v2 = 0;\n  v3 = path - 1;\n  v4 = &(*graph)[-10];\n  for (i = -1; i != 10; ++i) {\n    if (i != -1) goto LABEL_3;\n    for (j = 0LL; !(uint32_t)j; ++j) {\n      libmin_printf(\"       \");\n    LABEL_12:;\n    }\n    libmin_printf(\"%8s\", *((const char **)&unk_7018 + j));\n    if ((uint32_t)j != 10) goto LABEL_12;\n    ++v3;\n    v4 += 10;\n    libmin_printf((char *)\"\\n\");\n    i = 0;\n  LABEL_3:\n    v5 = 0LL;\n    while (2) {\n      if (!v5) {\n        v6 = v2++;\n        libmin_printf(\"%8s\", vertName[v6]);\n        goto LABEL_5;\n      }\n      libmin_printf(\"%8d / %d\", v4[v5 - 1], *v3);\n      if (v5 != 10) {\n      LABEL_5:\n        ++v5;\n        continue;\n      }\n      break;\n    }\n    ++v3;\n    v4 += 10;\n    libmin_printf((char *)\"\\n\");\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}", "binary": "minspan/minspan.host.O3", "assembly": "<displayGraph1>:\nendbr64\npush   %r15\npush   %r14\nlea    0x311d(%rip),%r14\npush   %r13\nxor    %r13d,%r13d\npush   %r12\nlea    0x3117(%rip),%r12\npush   %rbp\nlea    -0x4(%rsi),%rbp\npush   %rbx\nlea    -0x28(%rdi),%rbx\nsub    $0x18,%rsp\nmovl   $0xffffffff,0xc(%rsp)\nnopl   0x0(%rax,%rax,1)\ncmpl   $0xffffffff,0xc(%rsp)\nje     1fb0 <displayGraph1+0xd0>\nxor    %r15d,%r15d\njmp    1f4c <displayGraph1+0x6c>\nnopl   0x0(%rax,%rax,1)\nmov    -0x4(%rbx,%r15,4),%esi\nmov    0x0(%rbp),%edx\nxor    %eax,%eax\nmov    %r12,%rdi\ncall   4230 <libmin_printf>\ncmp    $0xa,%r15\nje     1f70 <displayGraph1+0x90>\nadd    $0x1,%r15\ntest   %r15,%r15\njne    1f30 <displayGraph1+0x50>\nmovslq %r13d,%rax\nlea    0x50c5(%rip),%rcx\nmov    %r14,%rdi\nadd    $0x1,%r13d\nmov    (%rcx,%rax,8),%rsi\nxor    %eax,%eax\ncall   4230 <libmin_printf>\njmp    1f48 <displayGraph1+0x68>\nnop\nlea    0x30c2(%rip),%rdi\nxor    %eax,%eax\nadd    $0x4,%rbp\nadd    $0x28,%rbx\ncall   4230 <libmin_printf>\naddl   $0x1,0xc(%rsp)\nmov    0xc(%rsp),%eax\ncmp    $0xa,%eax\njne    1f18 <displayGraph1+0x38>\nadd    $0x18,%rsp\nlea    0x3099(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    4230 <libmin_printf>\nxor    %r15d,%r15d\njmp    1fd7 <displayGraph1+0xf7>\nnopl   (%rax)\nlea    0x5059(%rip),%rax\nmov    %r14,%rdi\nmov    (%rax,%r15,8),%rsi\nxor    %eax,%eax\ncall   4230 <libmin_printf>\ncmp    $0xa,%r15d\nje     1ff0 <displayGraph1+0x110>\nadd    $0x1,%r15\ntest   %r15d,%r15d\njne    1fb8 <displayGraph1+0xd8>\nlea    0x3021(%rip),%rdi\nxor    %eax,%eax\ncall   4230 <libmin_printf>\njmp    1fd3 <displayGraph1+0xf3>\nnopl   0x0(%rax)\nlea    0x3042(%rip),%rdi\nxor    %eax,%eax\nadd    $0x4,%rbp\nadd    $0x28,%rbx\ncall   4230 <libmin_printf>\nmovl   $0x0,0xc(%rsp)\njmp    1f23 <displayGraph1+0x43>\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "displayPath", "content": "//Displays the path from source to destination\nvoid\ndisplayPath(int32_t source, int32_t dest, int32_t path[V])\n{\n\tstatic int count = 0;\n\t\n\tint currPath = dest;\n\t\n\tif (count == 0)\n  {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source], vertName[currPath]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n\t\tcount++;\n\t}\t\n\tif (path[currPath] != source)\n  {\n\t\tdisplayPath(source,path[currPath],path);\n\t}\n  libmin_printf(\"-> %s\", vertName[currPath]);\n\tif (currPath == dest)\n  {\n    libmin_printf(\"\\n\");\n\t}\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O3.pseudo", "function_name": "displayPath", "address": "0x2020", "label": "displayPath", "content": "void __fastcall displayPath(int32_t source, int32_t dest, int32_t *path)\n{\n  __int64 v4; // rbx\n  int32_t v5; // esi\n\n  v4 = dest;\n  if ( !count_0 )\n  {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source], vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  v5 = path[dest];\n  if ( v5 != source )\n    displayPath(source, v5, path);\n  libmin_printf(\"-> %s\", vertName[v4]);\n  libmin_printf((char *)\"\\n\");\n}\n"}, "pseudo_normalize": "void displayPath(int32_t source, int32_t dest, int32_t *path) {\n  long long v4;\n  int32_t v5;\n  v4 = dest;\n  if (!count_0) {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source],\n                  vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  v5 = path[dest];\n  if (v5 != source) displayPath(source, v5, path);\n  libmin_printf(\"-> %s\", vertName[v4]);\n  libmin_printf((char *)\"\\n\");\n}", "binary": "minspan/minspan.host.O3", "assembly": "<displayPath>:\nendbr64\nmov    0x52a2(%rip),%eax\npush   %r14\npush   %r13\nlea    0x4feb(%rip),%r13\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %edi,%ebp\npush   %rbx\nmovslq %esi,%rbx\ntest   %eax,%eax\nje     2080 <displayPath+0x60>\nmov    (%r12,%rbx,4),%esi\ncmp    %ebp,%esi\nje     2057 <displayPath+0x37>\nmov    %r12,%rdx\nmov    %ebp,%edi\ncall   2020 <displayPath>\nmov    0x0(%r13,%rbx,8),%rsi\nlea    0x2fe1(%rip),%rdi\nxor    %eax,%eax\ncall   4230 <libmin_printf>\npop    %rbx\nlea    0x2fc7(%rip),%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %r14\njmp    4230 <libmin_printf>\nmovslq %edi,%r14\nmov    0x0(%r13,%rbx,8),%rdx\nxor    %eax,%eax\nlea    0x2f8c(%rip),%rdi\nmov    0x0(%r13,%r14,8),%rsi\ncall   4230 <libmin_printf>\nmov    0x0(%r13,%r14,8),%rsi\nlea    0x2f94(%rip),%rdi\nxor    %eax,%eax\ncall   4230 <libmin_printf>\naddl   $0x1,0x5217(%rip)\njmp    2045 <displayPath+0x25>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "displayTree", "content": "// display the minimum spanning tree\nvoid\ndisplayTree(int32_t graph[V][V], int32_t path[V])\n{\n  int cost = 0;\n  libmin_printf(\"minimum spanning tree:\\n\");\n  for (int i=1; i < V; i++)\n  {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", vertName[i], graph[i][path[i]], vertName[path[i]]);\n    cost += graph[i][path[i]];\n  }\n  libmin_printf(\"total cost = %d\\n\", cost);\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O3.pseudo", "function_name": "displayTree", "address": "0x20c0", "label": "displayTree", "content": "void __fastcall displayTree(int32_t (*graph)[1], int32_t *path)\n{\n  int v2; // r15d\n  int *v3; // r12\n  int32_t *v4; // rbp\n  int32_t *v5; // rbx\n  __int64 v6; // rax\n  const char *v7; // rsi\n\n  v2 = 0;\n  v3 = (int *)&vertName[1];\n  v4 = path + 1;\n  v5 = &(*graph)[10];\n  libmin_printf(\"minimum spanning tree:\\n\");\n  do\n  {\n    v6 = *v4;\n    v7 = *(const char **)v3;\n    v3 += 2;\n    ++v4;\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", v7, v5[v6], vertName[v6 - 7]);\n    v2 += v5[*(v4 - 1)];\n    v5 += 10;\n  }\n  while ( v3 != &mti );\n  libmin_printf(\"total cost = %d\\n\", v2);\n}\n"}, "pseudo_normalize": "void displayTree(int32_t (*graph)[1], int32_t *path) {\n  int v2;\n  int *v3;\n  int32_t *v4;\n  int32_t *v5;\n  long long v6;\n  const char *v7;\n  v2 = 0;\n  v3 = (int *)&vertName[1];\n  v4 = path + 1;\n  v5 = &(*graph)[10];\n  libmin_printf(\"minimum spanning tree:\\n\");\n  do {\n    v6 = *v4;\n    v7 = *(const char **)v3;\n    v3 += 2;\n    ++v4;\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", v7, v5[v6], vertName[v6 - 7]);\n    v2 += v5[*(v4 - 1)];\n    v5 += 10;\n  } while (v3 != &mti);\n  libmin_printf(\"total cost = %d\\n\", v2);\n}", "binary": "minspan/minspan.host.O3", "assembly": "<displayTree>:\nendbr64\npush   %r15\nxor    %eax,%eax\nxor    %r15d,%r15d\npush   %r14\npush   %r13\nlea    0x2f8c(%rip),%r13\npush   %r12\nlea    0x4f49(%rip),%r12\npush   %rbp\nmov    %rsi,%rbp\nlea    -0x8(%r12),%r14\npush   %rbx\nmov    %rdi,%rbx\nlea    0x2f57(%rip),%rdi\nadd    $0x4,%rbp\nadd    $0x28,%rbx\nsub    $0x8,%rsp\ncall   4230 <libmin_printf>\nnopl   0x0(%rax)\nmovslq 0x0(%rbp),%rax\nmov    (%r12),%rsi\nmov    %r13,%rdi\nadd    $0x8,%r12\nadd    $0x4,%rbp\nmov    (%rbx,%rax,4),%edx\nmov    (%r14,%rax,8),%rcx\nxor    %eax,%eax\ncall   4230 <libmin_printf>\nmovslq -0x4(%rbp),%rax\nadd    (%rbx,%rax,4),%r15d\nlea    0x4f38(%rip),%rax\nadd    $0x28,%rbx\ncmp    %rax,%r12\njne    2108 <displayTree+0x48>\nadd    $0x8,%rsp\nmov    %r15d,%esi\nlea    0x2f25(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    4230 <libmin_printf>\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "initializeData", "content": "//Used to initialize the graph\nvoid\ninitializeData(int32_t graph[V][V])\n{\n\tlibmin_srand(10);\n\tfor (int i=0; i < V; i++)\n  {\n\t\tfor (int j=0;j<V;j++)\n    {\n\t\t\tif (i>j)\n\t\t\t\tgraph[i][j] = graph[j][i];\n\t\t\telse if (i==j)\n\t\t\t\tgraph[i][j] = 0;\n\t\t\telse\n      {\n\t\t\t\tif (libmin_rand() % 5 == libmin_rand() % 5)\n\t\t\t\t\tgraph[i][j] = 0;\t\n\t\t\t\telse\n\t\t\t\t\tgraph[i][j] = libmin_rand() % 10;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O3.pseudo", "function_name": "initializeData", "address": "0x1890", "label": "initializeData", "content": "void __fastcall initializeData(int32_t (*graph)[1])\n{\n  int32_t *v1; // rbp\n  __int64 v2; // rbx\n  unsigned int v3; // r14d\n  unsigned int v4; // r14d\n  unsigned int v5; // r14d\n  unsigned int v6; // r14d\n  unsigned int v7; // r14d\n  unsigned int v8; // r14d\n  unsigned int v9; // r14d\n  unsigned int v10; // r14d\n  unsigned int v11; // r14d\n\n  v1 = (int32_t *)graph;\n  v2 = 0LL;\n  libmin_srand(0xAu);\n  do\n  {\n    if ( !v2 )\n    {\nLABEL_3:\n      (*graph)[0] = 0;\n      v3 = libmin_rand();\n      if ( v3 % 5 == libmin_rand() % 5 )\n        (*graph)[1] = 0;\n      else\n        (*graph)[1] = libmin_rand() % 0xA;\n      goto LABEL_5;\n    }\n    while ( 1 )\n    {\n      *v1 = (*graph)[v2];\n      if ( (_DWORD)v2 == 1 )\n      {\n        (*graph)[11] = 0;\nLABEL_5:\n        v4 = libmin_rand();\n        if ( v4 % 5 == libmin_rand() % 5 )\n          v1[2] = 0;\n        else\n          v1[2] = libmin_rand() % 0xA;\n        goto LABEL_7;\n      }\n      v1[1] = (*graph)[v2 + 10];\n      if ( (_DWORD)v2 == 2 )\n      {\n        (*graph)[22] = 0;\nLABEL_7:\n        v5 = libmin_rand();\n        if ( v5 % 5 == libmin_rand() % 5 )\n          v1[3] = 0;\n        else\n          v1[3] = libmin_rand() % 0xA;\n        goto LABEL_9;\n      }\n      v1[2] = (*graph)[v2 + 20];\n      if ( (_DWORD)v2 == 3 )\n      {\n        (*graph)[33] = 0;\nLABEL_9:\n        v6 = libmin_rand();\n        if ( v6 % 5 == libmin_rand() % 5 )\n          v1[4] = 0;\n        else\n          v1[4] = libmin_rand() % 0xA;\n        goto LABEL_11;\n      }\n      v1[3] = (*graph)[v2 + 30];\n      if ( (_DWORD)v2 == 4 )\n      {\n        (*graph)[44] = 0;\nLABEL_11:\n        v7 = libmin_rand();\n        if ( v7 % 5 == libmin_rand() % 5 )\n          v1[5] = 0;\n        else\n          v1[5] = libmin_rand() % 0xA;\n        goto LABEL_13;\n      }\n      v1[4] = (*graph)[v2 + 40];\n      if ( (_DWORD)v2 == 5 )\n      {\n        (*graph)[55] = 0;\nLABEL_13:\n        v8 = libmin_rand();\n        if ( v8 % 5 == libmin_rand() % 5 )\n          v1[6] = 0;\n        else\n          v1[6] = libmin_rand() % 0xA;\n        goto LABEL_15;\n      }\n      v1[5] = (*graph)[v2 + 50];\n      if ( (_DWORD)v2 == 6 )\n      {\n        (*graph)[66] = 0;\nLABEL_15:\n        v9 = libmin_rand();\n        if ( v9 % 5 == libmin_rand() % 5 )\n          v1[7] = 0;\n        else\n          v1[7] = libmin_rand() % 0xA;\n        goto LABEL_17;\n      }\n      v1[6] = (*graph)[v2 + 60];\n      if ( (_DWORD)v2 == 7 )\n      {\n        (*graph)[77] = 0;\nLABEL_17:\n        v10 = libmin_rand();\n        if ( v10 % 5 == libmin_rand() % 5 )\n          v1[8] = 0;\n        else\n          v1[8] = libmin_rand() % 0xA;\n        goto LABEL_19;\n      }\n      v1[7] = (*graph)[v2 + 70];\n      if ( (_DWORD)v2 == 9 )\n      {\n        *(_QWORD *)&(*graph)[98] = (unsigned int)(*graph)[89];\n        return;\n      }\n      (*graph)[88] = 0;\nLABEL_19:\n      v11 = libmin_rand();\n      if ( v11 % 5 == libmin_rand() % 5 )\n        break;\n      ++v2;\n      v1 += 10;\n      *(v1 - 1) = libmin_rand() % 0xA;\n      if ( v2 == 10 )\n        return;\n      if ( !v2 )\n        goto LABEL_3;\n    }\n    ++v2;\n    v1[9] = 0;\n    v1 += 10;\n  }\n  while ( v2 != 10 );\n}\n"}, "pseudo_normalize": "void initializeData(int32_t (*graph)[1]) {\n  int32_t *v1;\n  long long v2;\n  unsigned int v3;\n  unsigned int v4;\n  unsigned int v5;\n  unsigned int v6;\n  unsigned int v7;\n  unsigned int v8;\n  unsigned int v9;\n  unsigned int v10;\n  unsigned int v11;\n  v1 = (int32_t *)graph;\n  v2 = 0LL;\n  libmin_srand(10u);\n  do {\n    if (!v2) {\n    LABEL_3:\n      (*graph)[0] = 0;\n      v3 = libmin_rand();\n      if (v3 % 5 == libmin_rand() % 5)\n        (*graph)[1] = 0;\n      else\n        (*graph)[1] = libmin_rand() % 10;\n      goto LABEL_5;\n    }\n    while (1) {\n      *v1 = (*graph)[v2];\n      if ((uint32_t)v2 == 1) {\n        (*graph)[11] = 0;\n      LABEL_5:\n        v4 = libmin_rand();\n        if (v4 % 5 == libmin_rand() % 5)\n          v1[2] = 0;\n        else\n          v1[2] = libmin_rand() % 10;\n        goto LABEL_7;\n      }\n      v1[1] = (*graph)[v2 + 10];\n      if ((uint32_t)v2 == 2) {\n        (*graph)[22] = 0;\n      LABEL_7:\n        v5 = libmin_rand();\n        if (v5 % 5 == libmin_rand() % 5)\n          v1[3] = 0;\n        else\n          v1[3] = libmin_rand() % 10;\n        goto LABEL_9;\n      }\n      v1[2] = (*graph)[v2 + 20];\n      if ((uint32_t)v2 == 3) {\n        (*graph)[33] = 0;\n      LABEL_9:\n        v6 = libmin_rand();\n        if (v6 % 5 == libmin_rand() % 5)\n          v1[4] = 0;\n        else\n          v1[4] = libmin_rand() % 10;\n        goto LABEL_11;\n      }\n      v1[3] = (*graph)[v2 + 30];\n      if ((uint32_t)v2 == 4) {\n        (*graph)[44] = 0;\n      LABEL_11:\n        v7 = libmin_rand();\n        if (v7 % 5 == libmin_rand() % 5)\n          v1[5] = 0;\n        else\n          v1[5] = libmin_rand() % 10;\n        goto LABEL_13;\n      }\n      v1[4] = (*graph)[v2 + 40];\n      if ((uint32_t)v2 == 5) {\n        (*graph)[55] = 0;\n      LABEL_13:\n        v8 = libmin_rand();\n        if (v8 % 5 == libmin_rand() % 5)\n          v1[6] = 0;\n        else\n          v1[6] = libmin_rand() % 10;\n        goto LABEL_15;\n      }\n      v1[5] = (*graph)[v2 + 50];\n      if ((uint32_t)v2 == 6) {\n        (*graph)[66] = 0;\n      LABEL_15:\n        v9 = libmin_rand();\n        if (v9 % 5 == libmin_rand() % 5)\n          v1[7] = 0;\n        else\n          v1[7] = libmin_rand() % 10;\n        goto LABEL_17;\n      }\n      v1[6] = (*graph)[v2 + 60];\n      if ((uint32_t)v2 == 7) {\n        (*graph)[77] = 0;\n      LABEL_17:\n        v10 = libmin_rand();\n        if (v10 % 5 == libmin_rand() % 5)\n          v1[8] = 0;\n        else\n          v1[8] = libmin_rand() % 10;\n        goto LABEL_19;\n      }\n      v1[7] = (*graph)[v2 + 70];\n      if ((uint32_t)v2 == 9) {\n        *(uint64_t *)&(*graph)[98] = (unsigned int)(*graph)[89];\n        return;\n      }\n      (*graph)[88] = 0;\n    LABEL_19:\n      v11 = libmin_rand();\n      if (v11 % 5 == libmin_rand() % 5) break;\n      ++v2;\n      v1 += 10;\n      *(v1 - 1) = libmin_rand() % 10;\n      if (v2 == 10) return;\n      if (!v2) goto LABEL_3;\n    }\n    ++v2;\n    v1[9] = 0;\n    v1 += 10;\n  } while (v2 != 10);\n}", "binary": "minspan/minspan.host.O3", "assembly": "<initializeData>:\nendbr64\npush   %r14\npush   %r13\nmov    $0xcccccccd,%r13d\npush   %r12\nmov    %rdi,%r12\nmov    $0xa,%edi\npush   %rbp\nmov    %r12,%rbp\npush   %rbx\nxor    %ebx,%ebx\ncall   4440 <libmin_srand>\nnopl   0x0(%rax)\ntest   %rbx,%rbx\njne    1b20 <initializeData+0x290>\nmovl   $0x0,(%r12)\ncall   44a0 <libmin_rand>\nmov    %eax,%r14d\ncall   44a0 <libmin_rand>\nmov    %r14d,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%r14d\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\ncmp    %eax,%r14d\njne    1d90 <initializeData+0x500>\nmovl   $0x0,0x4(%r12)\ncall   44a0 <libmin_rand>\nmov    %eax,%r14d\ncall   44a0 <libmin_rand>\nmov    %r14d,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%r14d\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\ncmp    %eax,%r14d\njne    1d70 <initializeData+0x4e0>\nmovl   $0x0,0x8(%rbp)\ncall   44a0 <libmin_rand>\nmov    %eax,%r14d\ncall   44a0 <libmin_rand>\nmov    %r14d,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%r14d\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\ncmp    %eax,%r14d\njne    1d50 <initializeData+0x4c0>\nmovl   $0x0,0xc(%rbp)\ncall   44a0 <libmin_rand>\nmov    %eax,%r14d\ncall   44a0 <libmin_rand>\nmov    %r14d,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%r14d\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\ncmp    %eax,%r14d\njne    1d30 <initializeData+0x4a0>\nmovl   $0x0,0x10(%rbp)\ncall   44a0 <libmin_rand>\nmov    %eax,%r14d\ncall   44a0 <libmin_rand>\nmov    %r14d,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%r14d\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\ncmp    %eax,%r14d\njne    1d10 <initializeData+0x480>\nmovl   $0x0,0x14(%rbp)\ncall   44a0 <libmin_rand>\nmov    %eax,%r14d\ncall   44a0 <libmin_rand>\nmov    %r14d,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%r14d\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\ncmp    %eax,%r14d\njne    1cf0 <initializeData+0x460>\nmovl   $0x0,0x18(%rbp)\ncall   44a0 <libmin_rand>\nmov    %eax,%r14d\ncall   44a0 <libmin_rand>\nmov    %r14d,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%r14d\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\ncmp    %eax,%r14d\njne    1cd0 <initializeData+0x440>\nmovl   $0x0,0x1c(%rbp)\ncall   44a0 <libmin_rand>\nmov    %eax,%r14d\ncall   44a0 <libmin_rand>\nmov    %r14d,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%r14d\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\ncmp    %eax,%r14d\njne    1cb0 <initializeData+0x420>\nmovl   $0x0,0x20(%rbp)\ncall   44a0 <libmin_rand>\nmov    %eax,%r14d\ncall   44a0 <libmin_rand>\nmov    %r14d,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%r14d\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x22,%rdx\nlea    (%rdx,%rdx,4),%edx\nsub    %edx,%eax\ncmp    %eax,%r14d\nje     1bd8 <initializeData+0x348>\ncall   44a0 <libmin_rand>\nadd    $0x1,%rbx\nadd    $0x28,%rbp\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %eax,-0x4(%rbp)\ncmp    $0xa,%rbx\nje     1bcb <initializeData+0x33b>\ntest   %rbx,%rbx\nje     18c1 <initializeData+0x31>\nnopl   (%rax)\nmov    (%r12,%rbx,4),%edx\nmov    %edx,0x0(%rbp)\ncmp    $0x1,%ebx\nje     1c10 <initializeData+0x380>\nmov    0x28(%r12,%rbx,4),%edx\nmov    %edx,0x4(%rbp)\ncmp    $0x2,%ebx\nje     1c38 <initializeData+0x3a8>\nmov    0x50(%r12,%rbx,4),%edx\nmov    %edx,0x8(%rbp)\ncmp    $0x3,%ebx\nje     1c20 <initializeData+0x390>\nmov    0x78(%r12,%rbx,4),%edx\nmov    %edx,0xc(%rbp)\ncmp    $0x4,%ebx\nje     1c98 <initializeData+0x408>\nmov    0xa0(%r12,%rbx,4),%edx\nmov    %edx,0x10(%rbp)\ncmp    $0x5,%ebx\nje     1c80 <initializeData+0x3f0>\nmov    0xc8(%r12,%rbx,4),%edx\nmov    %edx,0x14(%rbp)\ncmp    $0x6,%ebx\nje     1c68 <initializeData+0x3d8>\nmov    0xf0(%r12,%rbx,4),%edx\nmov    %edx,0x18(%rbp)\ncmp    $0x7,%ebx\nje     1c50 <initializeData+0x3c0>\nmov    0x118(%r12,%rbx,4),%edx\nmov    %edx,0x1c(%rbp)\ncmp    $0x9,%ebx\njne    1bf8 <initializeData+0x368>\nmov    0x164(%r12),%eax\nmovl   $0x0,0x18c(%r12)\nmov    %eax,0x188(%r12)\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\nadd    $0x1,%rbx\nmovl   $0x0,0x24(%rbp)\nadd    $0x28,%rbp\ncmp    $0xa,%rbx\njne    18b8 <initializeData+0x28>\njmp    1bcb <initializeData+0x33b>\nnopl   0x0(%rax,%rax,1)\nmovl   $0x0,0x160(%r12)\njmp    1ab3 <initializeData+0x223>\nnopl   0x0(%rax)\nmovl   $0x0,0x2c(%r12)\njmp    1908 <initializeData+0x78>\nxchg   %ax,%ax\nmovl   $0x0,0x84(%r12)\njmp    1982 <initializeData+0xf2>\nnopl   0x0(%rax)\nmovl   $0x0,0x58(%r12)\njmp    1945 <initializeData+0xb5>\ncs nopw 0x0(%rax,%rax,1)\nmovl   $0x0,0x134(%r12)\njmp    1a76 <initializeData+0x1e6>\nnopl   0x0(%rax)\nmovl   $0x0,0x108(%r12)\njmp    1a39 <initializeData+0x1a9>\nnopl   0x0(%rax)\nmovl   $0x0,0xdc(%r12)\njmp    19fc <initializeData+0x16c>\nnopl   0x0(%rax)\nmovl   $0x0,0xb0(%r12)\njmp    19bf <initializeData+0x12f>\nnopl   0x0(%rax)\ncall   44a0 <libmin_rand>\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %eax,0x20(%rbp)\njmp    1ab3 <initializeData+0x223>\nxchg   %ax,%ax\ncall   44a0 <libmin_rand>\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %eax,0x1c(%rbp)\njmp    1a76 <initializeData+0x1e6>\nxchg   %ax,%ax\ncall   44a0 <libmin_rand>\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %eax,0x18(%rbp)\njmp    1a39 <initializeData+0x1a9>\nxchg   %ax,%ax\ncall   44a0 <libmin_rand>\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %eax,0x14(%rbp)\njmp    19fc <initializeData+0x16c>\nxchg   %ax,%ax\ncall   44a0 <libmin_rand>\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %eax,0x10(%rbp)\njmp    19bf <initializeData+0x12f>\nxchg   %ax,%ax\ncall   44a0 <libmin_rand>\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %eax,0xc(%rbp)\njmp    1982 <initializeData+0xf2>\nxchg   %ax,%ax\ncall   44a0 <libmin_rand>\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %eax,0x8(%rbp)\njmp    1945 <initializeData+0xb5>\nxchg   %ax,%ax\ncall   44a0 <libmin_rand>\nmov    %eax,%edx\nimul   %r13,%rdx\nshr    $0x23,%rdx\nlea    (%rdx,%rdx,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %eax,0x4(%r12)\njmp    1908 <initializeData+0x78>\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "main", "content": "int\nmain()\n{\n\t// int32_t source = 0;\n\t// int32_t destination = 1;\n\tint32_t graph[V][V];\n\tint32_t path[V];\t\n\tfor(int i=0;i<V;i++){\n\t\tpath[i]=-1;\n\t}\n\tinitializeData(graph);\t\n\tdisplayGraph(graph);\n  minSpanTree(graph,path);\n\n\t// displayPath(source,destination,path);\n\t// displayGraph1(graph, path);\n\tdisplayTree(graph, path);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "// local variable allocation has failed, the output may be wrong!\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int32_t v3[98]; // [rsp-188h] [rbp-11D0h] BYREF\n  _BYTE path[32]; // [rsp+1008h] [rbp-40h] OVERLAPPED BYREF\n  __int64 v5; // [rsp+1028h] [rbp-20h]\n  unsigned __int64 v6; // [rsp+1030h] [rbp-18h]\n\n  v6 = __readfsqword(0x28u);\n  memset(path, 255, sizeof(path));\n  v5 = -1LL;\n  initializeData((int32_t (*)[1])v3);\n  displayGraph((int32_t (*)[1])v3);\n  minSpanTree((int32_t (*)[1])v3, (int32_t *)path);\n  displayTree((int32_t (*)[1])v3, (int32_t *)path);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int32_t v3[98];\n  uint8_t path[32];\n  long long v5;\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  memset(path, 255, sizeof(path));\n  v5 = -1LL;\n  initializeData((int32_t(*)[1])v3);\n  displayGraph((int32_t(*)[1])v3);\n  minSpanTree((int32_t(*)[1])v3, (int32_t *)path);\n  displayTree((int32_t(*)[1])v3, (int32_t *)path);\n  libmin_success();\n}", "binary": "minspan/minspan.host.O3", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r13\npush   %r12\nsub    $0x30,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nmov    %rsp,%rax\ncmp    %rax,%rsp\nje     113a <main+0x3a>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\ncmp    %rax,%rsp\njne    1125 <main+0x25>\nsub    $0x190,%rsp\norq    $0x0,0x188(%rsp)\npcmpeqd %xmm0,%xmm0\nmov    %rsp,%r12\nmovups %xmm0,-0x40(%rbp)\nlea    -0x40(%rbp),%r13\nmov    %r12,%rdi\nmovups %xmm0,-0x30(%rbp)\nmovq   $0xffffffffffffffff,-0x20(%rbp)\ncall   1890 <initializeData>\nmov    %r12,%rdi\ncall   1db0 <displayGraph>\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   1400 <minSpanTree>\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   20c0 <displayTree>\ncall   4690 <libmin_success>\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\njne    11ab <main+0xab>\nlea    -0x10(%rbp),%rsp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %rbp\nret\ncall   10b0 <__stack_chk_fail@plt>\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "minSpanTree", "content": "// find the shortest path from the source to all other vertexes\nvoid\nminSpanTree(int32_t graph[V][V], int32_t path[V])\n{\n\tint32_t dist[V];\n\n  // KNOWN[I] set to true when the algorithm has linked node I into the minimal spanning tree being built\n\tint known[V];\n\tint32_t min = 0;\n\t\n\tfor (int i=0; i<V; i++)\n  {\n\t\tif (min == i)\n    {\n\t\t\tdist[i] = 0;\n\t\t\tknown[i] = TRUE;\n\t\t}\n    else\n    {\n\t\t\tdist[i] = INT_MAX;\n\t\t\tknown[i] = FALSE;\n\t\t}\n\t}\n\t\t\n\tfor (int i=0;i<V;i++)\n  {\n\t\tfor (int j = 0;j<V;j++)\n    {\n\t\t\tif (!known[j] && (graph[min][j] != 0) && (graph[min][j] < dist[j]))\n      {\n\t\t\t\tdist[j] = graph[min][j];\n\t\t\t\tpath[j] = min;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tmin = minVal(dist, known);\n\t}\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O3.pseudo", "function_name": "minSpanTree", "address": "0x1400", "label": "minSpanTree", "content": "void __fastcall minSpanTree(int32_t (*graph)[1], int32_t *path)\n{\n  int32_t v2; // r15d\n  int32_t v3; // eax\n  __int64 v4; // rcx\n  int v5; // edx\n  __int32 v6; // edx\n  int32_t v7; // ecx\n  __int32 v8; // esi\n  int32_t v9; // ecx\n  __int32 v10; // r8d\n  int32_t v11; // ecx\n  __int32 v12; // r9d\n  int32_t v13; // ecx\n  int v14; // ebp\n  int32_t v15; // ecx\n  int v16; // r10d\n  int32_t v17; // ecx\n  int v18; // r12d\n  int32_t v19; // ecx\n  int v20; // r11d\n  int32_t v21; // ecx\n  int v22; // r13d\n  int32_t v23; // ecx\n  int v24; // ebx\n  int32_t v25; // ecx\n  int32_t v26; // [rsp+0h] [rbp-98h]\n  int32_t v27; // [rsp+4h] [rbp-94h]\n  int32_t v28; // [rsp+8h] [rbp-90h]\n  int32_t v29; // [rsp+Ch] [rbp-8Ch]\n  int v31; // [rsp+18h] [rbp-80h]\n  int32_t v32; // [rsp+1Ch] [rbp-7Ch]\n  int32_t v33; // [rsp+20h] [rbp-78h]\n  int32_t v34; // [rsp+24h] [rbp-74h]\n  int32_t v35; // [rsp+28h] [rbp-70h]\n  int32_t v36; // [rsp+2Ch] [rbp-6Ch]\n  __m128i known; // [rsp+30h] [rbp-68h]\n  __int128 v38; // [rsp+40h] [rbp-58h]\n  __int64 v39; // [rsp+50h] [rbp-48h]\n  unsigned __int64 v40; // [rsp+58h] [rbp-40h]\n\n  v2 = 0x7FFFFFFF;\n  v40 = __readfsqword(0x28u);\n  v3 = 0;\n  known = _mm_load_si128((const __m128i *)&xmmword_50D0);\n  v39 = 0LL;\n  v31 = 10;\n  v29 = 0;\n  v26 = 0x7FFFFFFF;\n  v27 = 0x7FFFFFFF;\n  v33 = 0x7FFFFFFF;\n  v35 = 0x7FFFFFFF;\n  v36 = 0x7FFFFFFF;\n  v34 = 0x7FFFFFFF;\n  v32 = 0x7FFFFFFF;\n  v28 = 0x7FFFFFFF;\n  v38 = 0LL;\n  do\n  {\n    while ( 1 )\n    {\n      v6 = known.m128i_i32[0];\n      if ( !known.m128i_i32[0] )\n      {\n        v7 = (*graph)[10 * v3];\n        if ( v7 )\n        {\n          if ( v29 > v7 )\n          {\n            v29 = (*graph)[10 * v3];\n            *path = v3;\n          }\n        }\n      }\n      v8 = known.m128i_i32[1];\n      if ( !known.m128i_i32[1] )\n      {\n        v9 = (*graph)[10 * v3 + 1];\n        if ( v9 )\n        {\n          if ( v32 > v9 )\n          {\n            v32 = (*graph)[10 * v3 + 1];\n            path[1] = v3;\n          }\n        }\n      }\n      v10 = known.m128i_i32[2];\n      if ( !known.m128i_i32[2] )\n      {\n        v11 = (*graph)[10 * v3 + 2];\n        if ( v11 )\n        {\n          if ( v11 < v34 )\n          {\n            v34 = (*graph)[10 * v3 + 2];\n            path[2] = v3;\n          }\n        }\n      }\n      v12 = known.m128i_i32[3];\n      if ( !known.m128i_i32[3] )\n      {\n        v13 = (*graph)[10 * v3 + 3];\n        if ( v13 )\n        {\n          if ( v13 < v36 )\n          {\n            v36 = (*graph)[10 * v3 + 3];\n            path[3] = v3;\n          }\n        }\n      }\n      v14 = v38;\n      if ( !(_DWORD)v38 )\n      {\n        v15 = (*graph)[10 * v3 + 4];\n        if ( v15 )\n        {\n          if ( v28 > v15 )\n          {\n            v28 = (*graph)[10 * v3 + 4];\n            path[4] = v3;\n          }\n        }\n      }\n      v16 = DWORD1(v38);\n      if ( !DWORD1(v38) )\n      {\n        v17 = (*graph)[10 * v3 + 5];\n        if ( v17 )\n        {\n          if ( v35 > v17 )\n          {\n            v35 = (*graph)[10 * v3 + 5];\n            path[5] = v3;\n          }\n        }\n      }\n      v18 = DWORD2(v38);\n      if ( !DWORD2(v38) )\n      {\n        v19 = (*graph)[10 * v3 + 6];\n        if ( v19 )\n        {\n          if ( v2 > v19 )\n          {\n            v2 = (*graph)[10 * v3 + 6];\n            path[6] = v3;\n          }\n        }\n      }\n      v20 = HIDWORD(v38);\n      if ( !HIDWORD(v38) )\n      {\n        v21 = (*graph)[10 * v3 + 7];\n        if ( v21 )\n        {\n          if ( v33 > v21 )\n          {\n            v33 = (*graph)[10 * v3 + 7];\n            path[7] = v3;\n          }\n        }\n      }\n      v22 = v39;\n      if ( !(_DWORD)v39 )\n      {\n        v23 = (*graph)[10 * v3 + 8];\n        if ( v23 )\n        {\n          if ( v27 > v23 )\n          {\n            v27 = (*graph)[10 * v3 + 8];\n            path[8] = v3;\n          }\n        }\n      }\n      v24 = HIDWORD(v39);\n      if ( !HIDWORD(v39) )\n      {\n        v25 = (*graph)[10 * v3 + 9];\n        if ( v25 )\n        {\n          if ( v26 > v25 )\n          {\n            v26 = (*graph)[10 * v3 + 9];\n            path[9] = v3;\n          }\n        }\n      }\n      if ( v6 || v29 == 0x7FFFFFFF )\n      {\n        v4 = 0x3FFFFFFFFFFFFFFFLL;\n        v5 = 0x7FFFFFFF;\n        v3 = -1;\n      }\n      else\n      {\n        v5 = v29;\n        v4 = 0LL;\n        v3 = 0;\n      }\n      if ( !v8 && v5 > v32 )\n      {\n        v4 = 1LL;\n        v5 = v32;\n        v3 = 1;\n      }\n      if ( !v10 && v5 > v34 )\n      {\n        v4 = 2LL;\n        v5 = v34;\n        v3 = 2;\n      }\n      if ( !v12 && v5 > v36 )\n      {\n        v4 = 3LL;\n        v5 = v36;\n        v3 = 3;\n      }\n      if ( v5 > v28 && !v14 )\n      {\n        v4 = 4LL;\n        v5 = v28;\n        v3 = 4;\n      }\n      if ( !v16 && v5 > v35 )\n      {\n        v4 = 5LL;\n        v5 = v35;\n        v3 = 5;\n      }\n      if ( v5 > v2 && !v18 )\n      {\n        v4 = 6LL;\n        v5 = v2;\n        v3 = 6;\n      }\n      if ( !v20 && v33 < v5 )\n      {\n        v4 = 7LL;\n        v5 = v33;\n        v3 = 7;\n      }\n      if ( v5 > v27 && !v22 )\n        break;\n      if ( v26 < v5 && !v24 )\n      {\n        v4 = 9LL;\n        v3 = 9;\nLABEL_74:\n        known.m128i_i32[v4] = 1;\n        goto LABEL_75;\n      }\n      if ( v3 != -1 )\n        goto LABEL_74;\n      if ( !--v31 )\n        return;\n    }\n    if ( v26 < v27 )\n    {\n      *(__int32 *)((char *)known.m128i_i32 + (v24 == 0 ? 36LL : 32LL)) = 1;\n      v3 = 9 - (v24 != 0);\n    }\n    else\n    {\n      v3 = 8;\n      LODWORD(v39) = 1;\n    }\nLABEL_75:\n    --v31;\n  }\n  while ( v31 );\n}\n"}, "pseudo_normalize": "void minSpanTree(int32_t (*graph)[1], int32_t *path) {\n  int32_t v2;\n  int32_t v3;\n  long long v4;\n  int v5;\n  int v6;\n  int32_t v7;\n  int v8;\n  int32_t v9;\n  int v10;\n  int32_t v11;\n  int v12;\n  int32_t v13;\n  int v14;\n  int32_t v15;\n  int v16;\n  int32_t v17;\n  int v18;\n  int32_t v19;\n  int v20;\n  int32_t v21;\n  int v22;\n  int32_t v23;\n  int v24;\n  int32_t v25;\n  int32_t v26;\n  int32_t v27;\n  int32_t v28;\n  int32_t v29;\n  int v31;\n  int32_t v32;\n  int32_t v33;\n  int32_t v34;\n  int32_t v35;\n  int32_t v36;\n  __m128i known;\n  __int128 v38;\n  long long v39;\n  unsigned long long v40;\n  v2 = 2147483647;\n  v40 = __readfsqword(40u);\n  v3 = 0;\n  known = _mm_load_si128((const __m128i *)&xmmword_50D0);\n  v39 = 0LL;\n  v31 = 10;\n  v29 = 0;\n  v26 = 2147483647;\n  v27 = 2147483647;\n  v33 = 2147483647;\n  v35 = 2147483647;\n  v36 = 2147483647;\n  v34 = 2147483647;\n  v32 = 2147483647;\n  v28 = 2147483647;\n  v38 = 0LL;\n  do {\n    while (1) {\n      v6 = known.m128i_i32[0];\n      if (!known.m128i_i32[0]) {\n        v7 = (*graph)[10 * v3];\n        if (v7) {\n          if (v29 > v7) {\n            v29 = (*graph)[10 * v3];\n            *path = v3;\n          }\n        }\n      }\n      v8 = known.m128i_i32[1];\n      if (!known.m128i_i32[1]) {\n        v9 = (*graph)[10 * v3 + 1];\n        if (v9) {\n          if (v32 > v9) {\n            v32 = (*graph)[10 * v3 + 1];\n            path[1] = v3;\n          }\n        }\n      }\n      v10 = known.m128i_i32[2];\n      if (!known.m128i_i32[2]) {\n        v11 = (*graph)[10 * v3 + 2];\n        if (v11) {\n          if (v11 < v34) {\n            v34 = (*graph)[10 * v3 + 2];\n            path[2] = v3;\n          }\n        }\n      }\n      v12 = known.m128i_i32[3];\n      if (!known.m128i_i32[3]) {\n        v13 = (*graph)[10 * v3 + 3];\n        if (v13) {\n          if (v13 < v36) {\n            v36 = (*graph)[10 * v3 + 3];\n            path[3] = v3;\n          }\n        }\n      }\n      v14 = v38;\n      if (!(uint32_t)v38) {\n        v15 = (*graph)[10 * v3 + 4];\n        if (v15) {\n          if (v28 > v15) {\n            v28 = (*graph)[10 * v3 + 4];\n            path[4] = v3;\n          }\n        }\n      }\n      v16 = DWORD1(v38);\n      if (!DWORD1(v38)) {\n        v17 = (*graph)[10 * v3 + 5];\n        if (v17) {\n          if (v35 > v17) {\n            v35 = (*graph)[10 * v3 + 5];\n            path[5] = v3;\n          }\n        }\n      }\n      v18 = DWORD2(v38);\n      if (!DWORD2(v38)) {\n        v19 = (*graph)[10 * v3 + 6];\n        if (v19) {\n          if (v2 > v19) {\n            v2 = (*graph)[10 * v3 + 6];\n            path[6] = v3;\n          }\n        }\n      }\n      v20 = HIDWORD(v38);\n      if (!HIDWORD(v38)) {\n        v21 = (*graph)[10 * v3 + 7];\n        if (v21) {\n          if (v33 > v21) {\n            v33 = (*graph)[10 * v3 + 7];\n            path[7] = v3;\n          }\n        }\n      }\n      v22 = v39;\n      if (!(uint32_t)v39) {\n        v23 = (*graph)[10 * v3 + 8];\n        if (v23) {\n          if (v27 > v23) {\n            v27 = (*graph)[10 * v3 + 8];\n            path[8] = v3;\n          }\n        }\n      }\n      v24 = HIDWORD(v39);\n      if (!HIDWORD(v39)) {\n        v25 = (*graph)[10 * v3 + 9];\n        if (v25) {\n          if (v26 > v25) {\n            v26 = (*graph)[10 * v3 + 9];\n            path[9] = v3;\n          }\n        }\n      }\n      if (v6 || v29 == 2147483647) {\n        v4 = 4611686018427387903LL;\n        v5 = 2147483647;\n        v3 = -1;\n      } else {\n        v5 = v29;\n        v4 = 0LL;\n        v3 = 0;\n      }\n      if (!v8 && v5 > v32) {\n        v4 = 1LL;\n        v5 = v32;\n        v3 = 1;\n      }\n      if (!v10 && v5 > v34) {\n        v4 = 2LL;\n        v5 = v34;\n        v3 = 2;\n      }\n      if (!v12 && v5 > v36) {\n        v4 = 3LL;\n        v5 = v36;\n        v3 = 3;\n      }\n      if (v5 > v28 && !v14) {\n        v4 = 4LL;\n        v5 = v28;\n        v3 = 4;\n      }\n      if (!v16 && v5 > v35) {\n        v4 = 5LL;\n        v5 = v35;\n        v3 = 5;\n      }\n      if (v5 > v2 && !v18) {\n        v4 = 6LL;\n        v5 = v2;\n        v3 = 6;\n      }\n      if (!v20 && v33 < v5) {\n        v4 = 7LL;\n        v5 = v33;\n        v3 = 7;\n      }\n      if (v5 > v27 && !v22) break;\n      if (v26 < v5 && !v24) {\n        v4 = 9LL;\n        v3 = 9;\n      LABEL_74:\n        known.m128i_i32[v4] = 1;\n        goto LABEL_75;\n      }\n      if (v3 != -1) goto LABEL_74;\n      if (!--v31) return;\n    }\n    if (v26 < v27) {\n      *(int *)((char *)known.m128i_i32 + (v24 == 0 ? 36LL : 32LL)) = 1;\n      v3 = 9 - (v24 != 0);\n    } else {\n      v3 = 8;\n      LODWORD(v39) = 1;\n    }\n  LABEL_75:\n    --v31;\n  } while (v31);\n}", "binary": "minspan/minspan.host.O3", "assembly": "<minSpanTree>:\nendbr64\npush   %r15\nmov    $0x7fffffff,%r15d\npush   %r14\nmov    $0x7fffffff,%r14d\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x68,%rsp\nmovdqa 0x3caa(%rip),%xmm0\nmov    %rsi,0x10(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nmovaps %xmm0,0x30(%rsp)\npxor   %xmm0,%xmm0\nmovq   $0x0,0x50(%rsp)\nmovl   $0xa,0x18(%rsp)\nmovl   $0x0,0xc(%rsp)\nmovl   $0x7fffffff,(%rsp)\nmovl   $0x7fffffff,0x4(%rsp)\nmovl   $0x7fffffff,0x20(%rsp)\nmovl   $0x7fffffff,0x28(%rsp)\nmovl   $0x7fffffff,0x2c(%rsp)\nmovl   $0x7fffffff,0x24(%rsp)\nmovl   $0x7fffffff,0x1c(%rsp)\nmov    %r14d,0x8(%rsp)\nmovaps %xmm0,0x40(%rsp)\njmp    1603 <minSpanTree+0x203>\nnopl   0x0(%rax,%rax,1)\nmov    $0xfffffffffffffffc,%rcx\nmov    $0x7fffffff,%edx\nmov    $0xffffffff,%eax\ntest   %esi,%esi\njne    14e1 <minSpanTree+0xe1>\nmov    0x1c(%rsp),%r14d\ncmp    %r14d,%edx\nsetg   %sil\ntest   %sil,%sil\nmov    $0x4,%esi\ncmovne %rsi,%rcx\nmov    $0x1,%esi\ncmovne %r14d,%edx\ncmovne %esi,%eax\ntest   %r8d,%r8d\njne    150a <minSpanTree+0x10a>\nmov    0x24(%rsp),%r8d\ncmp    %r8d,%edx\nsetg   %sil\ntest   %sil,%sil\nmov    $0x8,%esi\ncmovne %rsi,%rcx\nmov    $0x2,%esi\ncmovne %r8d,%edx\ncmovne %esi,%eax\ntest   %r9d,%r9d\njne    1533 <minSpanTree+0x133>\nmov    0x2c(%rsp),%r9d\ncmp    %r9d,%edx\nsetg   %sil\ntest   %sil,%sil\nmov    $0xc,%esi\ncmovne %rsi,%rcx\nmov    $0x3,%esi\ncmovne %r9d,%edx\ncmovne %esi,%eax\nmov    0x8(%rsp),%r14d\ncmp    %r14d,%edx\njle    155b <minSpanTree+0x15b>\ntest   %ebp,%ebp\nsete   %sil\ntest   %sil,%sil\nmov    $0x10,%esi\ncmovne %rsi,%rcx\nmov    $0x4,%esi\ncmovne %r14d,%edx\ncmovne %esi,%eax\ntest   %r10d,%r10d\njne    1584 <minSpanTree+0x184>\nmov    0x28(%rsp),%r10d\ncmp    %r10d,%edx\nsetg   %sil\ntest   %sil,%sil\nmov    $0x14,%esi\ncmovne %rsi,%rcx\nmov    $0x5,%esi\ncmovne %r10d,%edx\ncmovne %esi,%eax\ncmp    %r15d,%edx\njle    15a8 <minSpanTree+0x1a8>\ntest   %r12d,%r12d\nsete   %sil\ntest   %sil,%sil\nmov    $0x18,%esi\ncmovne %rsi,%rcx\nmov    $0x6,%esi\ncmovne %r15d,%edx\ncmovne %esi,%eax\ntest   %r11d,%r11d\njne    15d1 <minSpanTree+0x1d1>\nmov    0x20(%rsp),%r11d\ncmp    %edx,%r11d\nsetl   %sil\ntest   %sil,%sil\nmov    $0x1c,%esi\ncmovne %rsi,%rcx\nmov    $0x7,%esi\ncmovne %r11d,%edx\ncmovne %esi,%eax\nmov    0x4(%rsp),%esi\ncmp    %esi,%edx\njle    15e2 <minSpanTree+0x1e2>\ntest   %r13d,%r13d\nje     1848 <minSpanTree+0x448>\ncmp    %edx,(%rsp)\njge    15ef <minSpanTree+0x1ef>\ntest   %ebx,%ebx\nje     1808 <minSpanTree+0x408>\ncmp    $0xffffffff,%eax\njne    1812 <minSpanTree+0x412>\nsubl   $0x1,0x18(%rsp)\nje     1825 <minSpanTree+0x425>\nmov    0x30(%rsp),%edx\ntest   %edx,%edx\njne    1630 <minSpanTree+0x230>\nmovslq %eax,%rcx\nlea    (%rcx,%rcx,4),%rcx\nmov    (%rdi,%rcx,8),%ecx\ntest   %ecx,%ecx\nje     1630 <minSpanTree+0x230>\ncmp    %ecx,0xc(%rsp)\njle    1630 <minSpanTree+0x230>\nmov    0x10(%rsp),%rbx\nmov    %ecx,0xc(%rsp)\nmov    %eax,(%rbx)\nnopw   0x0(%rax,%rax,1)\nmov    0x34(%rsp),%esi\ntest   %esi,%esi\njne    1660 <minSpanTree+0x260>\nmovslq %eax,%rcx\nlea    (%rcx,%rcx,4),%rcx\nmov    0x4(%rdi,%rcx,8),%ecx\ntest   %ecx,%ecx\nje     1660 <minSpanTree+0x260>\ncmp    %ecx,0x1c(%rsp)\njle    1660 <minSpanTree+0x260>\nmov    0x10(%rsp),%rbx\nmov    %ecx,0x1c(%rsp)\nmov    %eax,0x4(%rbx)\nnopl   0x0(%rax)\nmov    0x38(%rsp),%r8d\ntest   %r8d,%r8d\njne    1690 <minSpanTree+0x290>\nmovslq %eax,%rcx\nlea    (%rcx,%rcx,4),%rcx\nmov    0x8(%rdi,%rcx,8),%ecx\ntest   %ecx,%ecx\nje     1690 <minSpanTree+0x290>\ncmp    0x24(%rsp),%ecx\njge    1690 <minSpanTree+0x290>\nmov    0x10(%rsp),%rbx\nmov    %ecx,0x24(%rsp)\nmov    %eax,0x8(%rbx)\nnopl   0x0(%rax,%rax,1)\nmov    0x3c(%rsp),%r9d\ntest   %r9d,%r9d\njne    16c0 <minSpanTree+0x2c0>\nmovslq %eax,%rcx\nlea    (%rcx,%rcx,4),%rcx\nmov    0xc(%rdi,%rcx,8),%ecx\ntest   %ecx,%ecx\nje     16c0 <minSpanTree+0x2c0>\ncmp    0x2c(%rsp),%ecx\njge    16c0 <minSpanTree+0x2c0>\nmov    0x10(%rsp),%rbx\nmov    %ecx,0x2c(%rsp)\nmov    %eax,0xc(%rbx)\nnopl   0x0(%rax,%rax,1)\nmov    0x40(%rsp),%ebp\ntest   %ebp,%ebp\njne    16f0 <minSpanTree+0x2f0>\nmovslq %eax,%rcx\nlea    (%rcx,%rcx,4),%rcx\nmov    0x10(%rdi,%rcx,8),%ecx\ntest   %ecx,%ecx\nje     16f0 <minSpanTree+0x2f0>\ncmp    %ecx,0x8(%rsp)\njle    16f0 <minSpanTree+0x2f0>\nmov    0x10(%rsp),%rbx\nmov    %ecx,0x8(%rsp)\nmov    %eax,0x10(%rbx)\nnopl   0x0(%rax)\nmov    0x44(%rsp),%r10d\ntest   %r10d,%r10d\njne    1720 <minSpanTree+0x320>\nmovslq %eax,%rcx\nlea    (%rcx,%rcx,4),%rcx\nmov    0x14(%rdi,%rcx,8),%ecx\ntest   %ecx,%ecx\nje     1720 <minSpanTree+0x320>\ncmp    %ecx,0x28(%rsp)\njle    1720 <minSpanTree+0x320>\nmov    0x10(%rsp),%rbx\nmov    %ecx,0x28(%rsp)\nmov    %eax,0x14(%rbx)\nnopl   0x0(%rax,%rax,1)\nmov    0x48(%rsp),%r12d\ntest   %r12d,%r12d\njne    1750 <minSpanTree+0x350>\nmovslq %eax,%rcx\nlea    (%rcx,%rcx,4),%rcx\nmov    0x18(%rdi,%rcx,8),%ecx\ntest   %ecx,%ecx\nje     1750 <minSpanTree+0x350>\ncmp    %ecx,%r15d\njle    1750 <minSpanTree+0x350>\nmov    0x10(%rsp),%rbx\nmov    %ecx,%r15d\nmov    %eax,0x18(%rbx)\nnopl   0x0(%rax)\nmov    0x4c(%rsp),%r11d\ntest   %r11d,%r11d\njne    1780 <minSpanTree+0x380>\nmovslq %eax,%rcx\nlea    (%rcx,%rcx,4),%rcx\nmov    0x1c(%rdi,%rcx,8),%ecx\ntest   %ecx,%ecx\nje     1780 <minSpanTree+0x380>\ncmp    %ecx,0x20(%rsp)\njle    1780 <minSpanTree+0x380>\nmov    0x10(%rsp),%rbx\nmov    %ecx,0x20(%rsp)\nmov    %eax,0x1c(%rbx)\nnopl   0x0(%rax,%rax,1)\nmov    0x50(%rsp),%r13d\ntest   %r13d,%r13d\njne    17b0 <minSpanTree+0x3b0>\nmovslq %eax,%rcx\nlea    (%rcx,%rcx,4),%rcx\nmov    0x20(%rdi,%rcx,8),%ecx\ntest   %ecx,%ecx\nje     17b0 <minSpanTree+0x3b0>\ncmp    %ecx,0x4(%rsp)\njle    17b0 <minSpanTree+0x3b0>\nmov    0x10(%rsp),%rbx\nmov    %ecx,0x4(%rsp)\nmov    %eax,0x20(%rbx)\nnopl   0x0(%rax,%rax,1)\nmov    0x54(%rsp),%ebx\ntest   %ebx,%ebx\njne    17e0 <minSpanTree+0x3e0>\nmovslq %eax,%rcx\nlea    (%rcx,%rcx,4),%rcx\nmov    0x24(%rdi,%rcx,8),%ecx\ntest   %ecx,%ecx\nje     17e0 <minSpanTree+0x3e0>\ncmp    %ecx,(%rsp)\njle    17e0 <minSpanTree+0x3e0>\nmov    0x10(%rsp),%r14\nmov    %ecx,(%rsp)\nmov    %eax,0x24(%r14)\nnopl   0x0(%rax,%rax,1)\ntest   %edx,%edx\njne    14a8 <minSpanTree+0xa8>\ncmpl   $0x7fffffff,0xc(%rsp)\nje     14a8 <minSpanTree+0xa8>\nmov    0xc(%rsp),%edx\nxor    %ecx,%ecx\nxor    %eax,%eax\njmp    14b9 <minSpanTree+0xb9>\nnopl   0x0(%rax,%rax,1)\nmov    $0x24,%ecx\nmov    $0x9,%eax\nmovl   $0x1,0x30(%rsp,%rcx,1)\nsubl   $0x1,0x18(%rsp)\njne    1603 <minSpanTree+0x203>\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1886 <minSpanTree+0x486>\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\ncmp    %esi,(%rsp)\njl     1868 <minSpanTree+0x468>\nmov    $0x20,%ecx\nmov    $0x8,%eax\nmovl   $0x1,0x30(%rsp,%rcx,1)\njmp    181a <minSpanTree+0x41a>\nnopl   0x0(%rax)\ncmp    $0x1,%ebx\nsbb    %rcx,%rcx\nand    $0x4,%ecx\nadd    $0x20,%rcx\nneg    %ebx\nsbb    %eax,%eax\nmovl   $0x1,0x30(%rsp,%rcx,1)\nadd    $0x9,%eax\njmp    181a <minSpanTree+0x41a>\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "minVal", "content": "// find the vertex with min distance from the unknown vertexes\nint32_t\nminVal(int32_t *dist, int *known)\n{\n\tint32_t min = -1;\n\tint32_t distVal = INT_MAX;\n\t\t\t\n\tfor (int i=0; i<V; i++)\n  {\n\t\tif (distVal>dist[i] && !known[i])\n    {\n\t\t\tdistVal = dist[i];\n\t\t\tmin = i;\n\t\t}\t\t\t\t\t\n\t}\n\t\t\t\t\n  if (min != -1)\n    known[min] = TRUE;\n  return min;\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O3.pseudo", "function_name": "minVal", "address": "0x12a0", "label": "minVal", "content": "int32_t __fastcall minVal(int32_t *dist, int *known)\n{\n  int32_t v2; // eax\n  int32_t v4; // r8d\n  int32_t v5; // esi\n\n  v2 = *dist;\n  v4 = -1;\n  if ( *dist != 0x7FFFFFFF )\n  {\n    v4 = *known;\n    if ( *known )\n    {\n      v2 = 0x7FFFFFFF;\n      v4 = -1;\n    }\n  }\n  if ( v2 > dist[1] && !known[1] )\n  {\n    v2 = dist[1];\n    v4 = 1;\n  }\n  if ( v2 > dist[2] && !known[2] )\n  {\n    v2 = dist[2];\n    v4 = 2;\n  }\n  if ( v2 > dist[3] && !known[3] )\n  {\n    v2 = dist[3];\n    v4 = 3;\n  }\n  if ( v2 > dist[4] && !known[4] )\n  {\n    v2 = dist[4];\n    v4 = 4;\n  }\n  if ( v2 > dist[5] && !known[5] )\n  {\n    v2 = dist[5];\n    v4 = 5;\n  }\n  if ( v2 > dist[6] && !known[6] )\n  {\n    v2 = dist[6];\n    v4 = 6;\n  }\n  if ( v2 > dist[7] && !known[7] )\n  {\n    v2 = dist[7];\n    v4 = 7;\n  }\n  v5 = dist[8];\n  if ( v2 > v5 && !known[8] )\n  {\n    v4 = 8;\n    if ( dist[9] < v5 )\n    {\n      v4 = (known[9] == 0) + 8;\n      known[v4] = 1;\n      return v4;\n    }\n    goto LABEL_28;\n  }\n  if ( dist[9] < v2 && !known[9] )\n  {\n    v4 = 9;\n    known[9] = 1;\n    return v4;\n  }\n  if ( v4 != -1 )\n  {\nLABEL_28:\n    known[v4] = 1;\n    return v4;\n  }\n  return -1;\n}\n"}, "pseudo_normalize": "int32_t minVal(int32_t *dist, int *known) {\n  int32_t v2;\n  int32_t v4;\n  int32_t v5;\n  v2 = *dist;\n  v4 = -1;\n  if (*dist != 2147483647) {\n    v4 = *known;\n    if (*known) {\n      v2 = 2147483647;\n      v4 = -1;\n    }\n  }\n  if (v2 > dist[1] && !known[1]) {\n    v2 = dist[1];\n    v4 = 1;\n  }\n  if (v2 > dist[2] && !known[2]) {\n    v2 = dist[2];\n    v4 = 2;\n  }\n  if (v2 > dist[3] && !known[3]) {\n    v2 = dist[3];\n    v4 = 3;\n  }\n  if (v2 > dist[4] && !known[4]) {\n    v2 = dist[4];\n    v4 = 4;\n  }\n  if (v2 > dist[5] && !known[5]) {\n    v2 = dist[5];\n    v4 = 5;\n  }\n  if (v2 > dist[6] && !known[6]) {\n    v2 = dist[6];\n    v4 = 6;\n  }\n  if (v2 > dist[7] && !known[7]) {\n    v2 = dist[7];\n    v4 = 7;\n  }\n  v5 = dist[8];\n  if (v2 > v5 && !known[8]) {\n    v4 = 8;\n    if (dist[9] < v5) {\n      v4 = (known[9] == 0) + 8;\n      known[v4] = 1;\n      return v4;\n    }\n    goto LABEL_28;\n  }\n  if (dist[9] < v2 && !known[9]) {\n    v4 = 9;\n    known[9] = 1;\n    return v4;\n  }\n  if (v4 != -1) {\n  LABEL_28:\n    known[v4] = 1;\n    return v4;\n  }\n  return -1;\n}", "binary": "minspan/minspan.host.O3", "assembly": "<minVal>:\nendbr64\nmov    (%rdi),%eax\nmov    %rdi,%rdx\nmov    %rsi,%rcx\nmov    $0xffffffff,%r8d\ncmp    $0x7fffffff,%eax\nje     12c5 <minVal+0x25>\nmov    (%rsi),%r8d\ntest   %r8d,%r8d\njne    13d0 <minVal+0x130>\nmov    0x4(%rdx),%esi\ncmp    %esi,%eax\njle    12df <minVal+0x3f>\nmov    0x4(%rcx),%r11d\ntest   %r11d,%r11d\ncmove  %esi,%eax\nmov    $0x1,%esi\ncmove  %esi,%r8d\nmov    0x8(%rdx),%esi\ncmp    %esi,%eax\njle    12f9 <minVal+0x59>\nmov    0x8(%rcx),%r10d\ntest   %r10d,%r10d\ncmove  %esi,%eax\nmov    $0x2,%esi\ncmove  %esi,%r8d\nmov    0xc(%rdx),%esi\ncmp    %esi,%eax\njle    1313 <minVal+0x73>\nmov    0xc(%rcx),%r9d\ntest   %r9d,%r9d\ncmove  %esi,%eax\nmov    $0x3,%esi\ncmove  %esi,%r8d\nmov    0x10(%rdx),%esi\ncmp    %esi,%eax\njle    132b <minVal+0x8b>\nmov    0x10(%rcx),%edi\ntest   %edi,%edi\ncmove  %esi,%eax\nmov    $0x4,%esi\ncmove  %esi,%r8d\nmov    0x14(%rdx),%esi\ncmp    %esi,%eax\njle    1345 <minVal+0xa5>\nmov    0x14(%rcx),%r11d\ntest   %r11d,%r11d\ncmove  %esi,%eax\nmov    $0x5,%esi\ncmove  %esi,%r8d\nmov    0x18(%rdx),%esi\ncmp    %esi,%eax\njle    135f <minVal+0xbf>\nmov    0x18(%rcx),%r10d\ntest   %r10d,%r10d\ncmove  %esi,%eax\nmov    $0x6,%esi\ncmove  %esi,%r8d\nmov    0x1c(%rdx),%esi\ncmp    %esi,%eax\njle    1379 <minVal+0xd9>\nmov    0x1c(%rcx),%r9d\ntest   %r9d,%r9d\ncmove  %esi,%eax\nmov    $0x7,%esi\ncmove  %esi,%r8d\nmov    0x20(%rdx),%esi\ncmp    %esi,%eax\njle    13a0 <minVal+0x100>\nmov    0x20(%rcx),%edi\ntest   %edi,%edi\njne    13a0 <minVal+0x100>\nmov    $0x8,%r8d\ncmp    %esi,0x24(%rdx)\njl     13e0 <minVal+0x140>\nmovslq %r8d,%rax\nmovl   $0x1,(%rcx,%rax,4)\nmov    %r8d,%eax\nret\ncmp    %eax,0x24(%rdx)\njge    13c0 <minVal+0x120>\nmov    0x24(%rcx),%eax\ntest   %eax,%eax\njne    13c0 <minVal+0x120>\nmov    $0x9,%r8d\nmovslq %r8d,%rax\nmovl   $0x1,(%rcx,%rax,4)\njmp    139c <minVal+0xfc>\nxchg   %ax,%ax\ncmp    $0xffffffff,%r8d\njne    1392 <minVal+0xf2>\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x7fffffff,%eax\nmov    $0xffffffff,%r8d\njmp    12c5 <minVal+0x25>\ncmpl   $0x1,0x24(%rcx)\nmov    $0x8,%r8d\nadc    $0x0,%r8d\nmovslq %r8d,%rax\nmovl   $0x1,(%rcx,%rax,4)\njmp    139c <minVal+0xfc>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "monte-carlo/monte-carlo.c", "function_name": "main", "content": "#include \"libmin.h\"\n\n#define NUM_SAMPLES 25000  // samples\n\nint\nmain(void)\n{\n  int count_inside_circle = 0;\n  double x, y;\n\n  // Seed the random number generator\n  libmin_srand(42);\n\n  for (int i = 0; i < NUM_SAMPLES; ++i)\n  {\n    // Generate random (x, y) point in [0, 1]  [0, 1]\n    x = (double)libmin_rand() / RAND_MAX;\n    y = (double)libmin_rand() / RAND_MAX;\n\n    // Check if the point is inside the unit circle\n    if (x*x + y*y <= 1.0)\n      count_inside_circle++;\n  }\n\n  // Estimate Pi\n  double pi_estimate = 4.0 * count_inside_circle / NUM_SAMPLES;\n\n  // Output result\n  libmin_printf(\"Estimated Pi = %.8f\\n\", pi_estimate);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "monte-carlo/monte-carlo.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // ebx\n  signed int v5; // eax\n  double x; // [rsp+8h] [rbp-20h]\n\n  v3 = 0;\n  v4 = 25000;\n  libmin_srand(0x2Au);\n  do\n  {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    v5 = libmin_rand();\n    v3 -= (x * x + (double)v5 / 2147483647.0 * ((double)v5 / 2147483647.0) > 1.0) - 1;\n    --v4;\n  }\n  while ( v4 );\n  libmin_printf(\"Estimated Pi = %.8f\\n\", (double)v3 * 4.0 / 25000.0);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  signed int v5;\n  double x;\n  v3 = 0;\n  v4 = 25000;\n  libmin_srand(42u);\n  do {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    v5 = libmin_rand();\n    v3 -= (x * x + (double)v5 / 2147483647.0 * ((double)v5 / 2147483647.0) >\n           1.0) -\n          1;\n    --v4;\n  } while (v4);\n  libmin_printf(\"Estimated Pi = %.8f\\n\", (double)v3 * 4.0 / 25000.0);\n  libmin_success();\n}", "binary": "monte-carlo/monte-carlo.host.O3", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    $0x2a,%edi\nxor    %ebp,%ebp\npush   %rbx\nmov    $0x61a8,%ebx\nsub    $0x18,%rsp\ncall   3590 <libmin_srand>\nnopl   0x0(%rax,%rax,1)\ncall   35f0 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2ee8(%rip),%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncall   35f0 <libmin_rand>\nmovsd  0x8(%rsp),%xmm0\npxor   %xmm1,%xmm1\nmovsd  0x2ed3(%rip),%xmm2\nmov    %eax,%eax\nmulsd  %xmm0,%xmm0\ncvtsi2sd %rax,%xmm1\ndivsd  0x2eb8(%rip),%xmm1\nmulsd  %xmm1,%xmm1\naddsd  %xmm1,%xmm0\ncomisd %xmm0,%xmm2\nsbb    $0xffffffff,%ebp\nsub    $0x1,%ebx\njne    1120 <main+0x20>\npxor   %xmm0,%xmm0\nlea    0x2e7d(%rip),%rdi\nmov    $0x1,%eax\ncvtsi2sd %ebp,%xmm0\nmulsd  0x2e98(%rip),%xmm0\ndivsd  0x2e98(%rip),%xmm0\ncall   3380 <libmin_printf>\ncall   37e0 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "murmur-hash/murmur-hash.c", "function_name": "main", "content": "int\nmain(void)\n{\n    uint32_t seed = 0;\n\n    {\n      const char *key = \"kinkajou\"; // 0xb6d99cf8\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    {\n      const char *key = \"The bringup-bench benchmark MURMUR made this.\";\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    {\n      const char *key = \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\";\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "murmur-hash/murmur-hash.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint32_t v3; // eax\n  uint32_t v4; // eax\n  uint32_t v5; // eax\n  uint32_t v6; // eax\n  uint32_t v7; // eax\n  uint32_t v8; // eax\n\n  v3 = libmin_strlen(\"kinkajou\");\n  v4 = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", v4);\n  v5 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  v6 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v5, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"The bringup-bench benchmark MURMUR made this.\", v6);\n  v7 = libmin_strlen(\"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\");\n  v8 = murmurhash(\n         \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n         v7,\n         0);\n  libmin_printf(\n    \"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n    \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n    v8);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  uint32_t v3;\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint32_t v7;\n  uint32_t v8;\n  v3 = libmin_strlen(\"kinkajou\");\n  v4 = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", v4);\n  v5 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  v6 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v5, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"The bringup-bench benchmark MURMUR made this.\", v6);\n  v7 = libmin_strlen(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\");\n  v8 = murmurhash(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\",\n      v7, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"It has to start somewhere, it has to start sometime, what \"\n                \"better place than here? What better time than now?\",\n                v8);\n  libmin_success();\n}", "binary": "murmur-hash/murmur-hash.host.O3", "assembly": "<main>:\nendbr64\npush   %r12\nlea    0x2f1b(%rip),%r12\npush   %rbp\nlea    0x2eef(%rip),%rbp\nmov    %rbp,%rdi\nsub    $0x8,%rsp\ncall   3640 <libmin_strlen>\nmov    %rbp,%rdi\nxor    %edx,%edx\nmov    %eax,%esi\ncall   1290 <murmurhash>\nmov    %rbp,%rsi\nlea    0x2ed6(%rip),%rbp\nmov    %eax,%edx\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   3430 <libmin_printf>\nmov    %r12,%rdi\ncall   3640 <libmin_strlen>\nmov    %r12,%rdi\nxor    %edx,%edx\nmov    %eax,%esi\ncall   1290 <murmurhash>\nmov    %r12,%rsi\nmov    %rbp,%rdi\nlea    0x2ef4(%rip),%r12\nmov    %eax,%edx\nxor    %eax,%eax\ncall   3430 <libmin_printf>\nmov    %r12,%rdi\ncall   3640 <libmin_strlen>\nmov    %r12,%rdi\nxor    %edx,%edx\nmov    %eax,%esi\ncall   1290 <murmurhash>\nmov    %r12,%rsi\nmov    %rbp,%rdi\nmov    %eax,%edx\nxor    %eax,%eax\ncall   3430 <libmin_printf>\ncall   3670 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\nnop\n"}
{"source": {"path": "murmur-hash/murmur-hash.c", "function_name": "murmurhash", "content": "/**\n * `murmurhash.h' - murmurhash\n *\n * copyright (c) 2014-2022 joseph werle <joseph.werle@gmail.com>\n */\n\nuint32_t\nmurmurhash (const char *key, uint32_t len, uint32_t seed)\n{\n  uint32_t c1 = 0xcc9e2d51;\n  uint32_t c2 = 0x1b873593;\n  uint32_t r1 = 15;\n  uint32_t r2 = 13;\n  uint32_t m = 5;\n  uint32_t n = 0xe6546b64;\n  uint32_t h = 0;\n  uint32_t k = 0;\n  uint8_t *d = (uint8_t *) key; // 32 bit extract from `key'\n  const uint32_t *chunks = NULL;\n  const uint8_t *tail = NULL; // tail - last 8 bytes\n  int i = 0;\n  int l = len / 4; // chunk length\n\n  h = seed;\n\n  chunks = (const uint32_t *) (d + l * 4); // body\n  tail = (const uint8_t *) (d + l * 4); // last 8 byte chunk of `key'\n\n  // for each 4 byte chunk of `key'\n  for (i = -l; i != 0; ++i) {\n    // next 4 byte chunk of `key'\n    k = chunks[i];\n\n    // encode next 4 byte chunk of `key'\n    k *= c1;\n    k = (k << r1) | (k >> (32 - r1));\n    k *= c2;\n\n    // append to hash\n    h ^= k;\n    h = (h << r2) | (h >> (32 - r2));\n    h = h * m + n;\n  }\n\n  k = 0;\n\n  // remainder\n  switch (len & 3) { // `len % 4'\n    case 3: k ^= (tail[2] << 16);\n    case 2: k ^= (tail[1] << 8);\n\n    case 1:\n      k ^= tail[0];\n      k *= c1;\n      k = (k << r1) | (k >> (32 - r1));\n      k *= c2;\n      h ^= k;\n  }\n\n  h ^= len;\n\n  h ^= (h >> 16);\n  h *= 0x85ebca6b;\n  h ^= (h >> 13);\n  h *= 0xc2b2ae35;\n  h ^= (h >> 16);\n\n  return h;\n}\n"}, "pseudo": {"path": "murmur-hash/murmur-hash.host.O3.pseudo", "function_name": "murmurhash", "address": "0x1290", "label": "murmurhash", "content": "uint32_t __fastcall murmurhash(const char *key, uint32_t len, uint32_t seed)\n{\n  uint32_t v5; // r8d\n  uint32_t v7; // edx\n  const char *v8; // rsi\n  __int64 v9; // rdx\n  int v10; // eax\n  uint32_t v11; // eax\n  uint32_t v12; // edx\n  int v14; // edx\n  int v15; // eax\n\n  v5 = len >> 2;\n  v7 = len >> 2;\n  v8 = &key[len & 0xFFFFFFFC];\n  LODWORD(v9) = -v7;\n  if ( v5 )\n  {\n    v9 = (int)v9;\n    do\n    {\n      v10 = -862048943 * *(_DWORD *)&v8[4 * v9++];\n      seed = 5 * __ROL4__(seed ^ (461845907 * __ROL4__(v10, 15)), 13) - 430675100;\n    }\n    while ( (_DWORD)v9 );\n  }\n  v11 = len & 3;\n  switch ( v11 )\n  {\n    case 2u:\n      v15 = 0;\n      goto LABEL_11;\n    case 3u:\n      v15 = *((unsigned __int8 *)v8 + 2) << 16;\nLABEL_11:\n      v14 = v15 ^ (*((unsigned __int8 *)v8 + 1) << 8);\n      goto LABEL_9;\n    case 1u:\n      v14 = 0;\nLABEL_9:\n      seed ^= 461845907 * __ROL4__(-862048943 * (v14 ^ *(unsigned __int8 *)v8), 15);\n      break;\n  }\n  v12 = -1028477387\n      * ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) ^ ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) >> 13));\n  return v12 ^ HIWORD(v12);\n}\n"}, "pseudo_normalize": "uint32_t murmurhash(const char *key, uint32_t len, uint32_t seed) {\n  uint32_t v5;\n  uint32_t v7;\n  const char *v8;\n  long long v9;\n  int v10;\n  uint32_t v11;\n  uint32_t v12;\n  int v14;\n  int v15;\n  v5 = len >> 2;\n  v7 = len >> 2;\n  v8 = &key[len & 4294967292];\n  LODWORD(v9) = -v7;\n  if (v5) {\n    v9 = (int)v9;\n    do {\n      v10 = -862048943 * *(uint32_t *)&v8[4 * v9++];\n      seed =\n          5 * __ROL4__(seed ^ (461845907 * __ROL4__(v10, 15)), 13) - 430675100;\n    } while ((uint32_t)v9);\n  }\n  v11 = len & 3;\n  switch (v11) {\n    case 2u:\n      v15 = 0;\n      goto LABEL_11;\n    case 3u:\n      v15 = *((unsigned char *)v8 + 2) << 16;\n    LABEL_11:\n      v14 = v15 ^ (*((unsigned char *)v8 + 1) << 8);\n      goto LABEL_9;\n    case 1u:\n      v14 = 0;\n    LABEL_9:\n      seed ^=\n          461845907 * __ROL4__(-862048943 * (v14 ^ *(unsigned char *)v8), 15);\n      break;\n  }\n  v12 = -1028477387 *\n        ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) ^\n         ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) >> 13));\n  return v12 ^ HIWORD(v12);\n}", "binary": "murmur-hash/murmur-hash.host.O3", "assembly": "<murmurhash>:\nendbr64\nmov    %esi,%r8d\nmov    %esi,%eax\nmov    %rdi,%r9\nmov    %edx,%ecx\nshr    $0x2,%r8d\nand    $0xfffffffc,%eax\nmov    %esi,%edi\ncltq\nmov    %r8d,%edx\nlea    (%r9,%rax,1),%rsi\nneg    %edx\ntest   %r8d,%r8d\nje     12e4 <murmurhash+0x54>\nmovslq %edx,%rdx\nnopw   0x0(%rax,%rax,1)\nimul   $0xcc9e2d51,(%rsi,%rdx,4),%eax\nadd    $0x1,%rdx\nrol    $0xf,%eax\nimul   $0x1b873593,%eax,%eax\nxor    %ecx,%eax\nrol    $0xd,%eax\nlea    -0x19ab949c(%rax,%rax,4),%ecx\ntest   %edx,%edx\njne    12c0 <murmurhash+0x30>\nmov    %edi,%eax\nand    $0x3,%eax\ncmp    $0x2,%eax\nje     1358 <murmurhash+0xc8>\ncmp    $0x3,%eax\nje     1340 <murmurhash+0xb0>\ncmp    $0x1,%eax\nje     1320 <murmurhash+0x90>\nxor    %edi,%ecx\nmov    %ecx,%eax\nshr    $0x10,%eax\nxor    %ecx,%eax\nimul   $0x85ebca6b,%eax,%eax\nmov    %eax,%edx\nshr    $0xd,%edx\nxor    %eax,%edx\nimul   $0xc2b2ae35,%edx,%edx\nmov    %edx,%eax\nshr    $0x10,%eax\nxor    %edx,%eax\nret\nnopl   0x0(%rax)\nxor    %edx,%edx\nmovzbl (%rsi),%eax\nxor    %edx,%eax\nimul   $0xcc9e2d51,%eax,%eax\nrol    $0xf,%eax\nimul   $0x1b873593,%eax,%eax\nxor    %eax,%ecx\njmp    12f8 <murmurhash+0x68>\nnopw   0x0(%rax,%rax,1)\nmovzbl 0x2(%rsi),%eax\nshl    $0x10,%eax\nmovzbl 0x1(%rsi),%edx\nshl    $0x8,%edx\nxor    %eax,%edx\njmp    1322 <murmurhash+0x92>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\njmp    1347 <murmurhash+0xb7>\nnopl   0x0(%rax)\n"}
{"source": {"path": "n-queens/n-queens.c", "function_name": "is_safe", "content": "// Check if placing a queen at (row, col) is safe\nint\nis_safe(int queens[], int row, int col)\n{\n  for (int i = 0; i < row; i++)\n  {\n    int q_col = queens[i];\n    if (q_col == col || libmin_abs(q_col - col) == libmin_abs(i - row))\n      return FALSE;\n  }\n  return TRUE;\n}\n"}, "pseudo": {"path": "n-queens/n-queens.host.O3.pseudo", "function_name": "is_safe", "address": "0x1280", "label": "is_safe", "content": "int __fastcall is_safe(int *queens, int row, int col)\n{\n  int v5; // ebx\n  int v6; // ebp\n\n  if ( row <= 0 )\n    return 1;\n  v5 = -row;\n  do\n  {\n    if ( *queens == col )\n      return 0;\n    v6 = libmin_abs(*queens - col);\n    if ( v6 == libmin_abs(v5) )\n      return 0;\n    ++queens;\n    ++v5;\n  }\n  while ( v5 );\n  return 1;\n}\n"}, "pseudo_normalize": "int is_safe(int *queens, int row, int col) {\n  int v5;\n  int v6;\n  if (row <= 0) return 1;\n  v5 = -row;\n  do {\n    if (*queens == col) return 0;\n    v6 = libmin_abs(*queens - col);\n    if (v6 == libmin_abs(v5)) return 0;\n    ++queens;\n    ++v5;\n  } while (v5);\n  return 1;\n}", "binary": "n-queens/n-queens.host.O3", "assembly": "<is_safe>:\nendbr64\ntest   %esi,%esi\njle    12e8 <is_safe+0x68>\npush   %r13\nmov    %rdi,%r13\npush   %r12\nmov    %edx,%r12d\npush   %rbp\npush   %rbx\nmov    %esi,%ebx\nneg    %ebx\nsub    $0x8,%rsp\njmp    12be <is_safe+0x3e>\nxchg   %ax,%ax\nsub    %r12d,%edi\ncall   1590 <libmin_abs>\nmov    %ebx,%edi\nmov    %eax,%ebp\ncall   1590 <libmin_abs>\ncmp    %eax,%ebp\nje     12c7 <is_safe+0x47>\nadd    $0x4,%r13\nadd    $0x1,%ebx\nje     12d8 <is_safe+0x58>\nmov    0x0(%r13),%edi\ncmp    %r12d,%edi\njne    12a0 <is_safe+0x20>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nmov    $0x1,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    $0x1,%eax\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "n-queens/n-queens.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int *queens = (int *)libmin_malloc(BOARD_SIZE * sizeof(int));\n\n  solve(queens, 0);\n\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", BOARD_SIZE, solution_count);\n\n  libmin_free(queens);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "n-queens/n-queens.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n  int *v4; // rbp\n\n  v3 = 0;\n  v4 = (int *)libmin_malloc(0x28uLL);\n  do\n  {\n    *v4 = v3++;\n    solve(v4, 1);\n  }\n  while ( v3 != 10 );\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(v4);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int *v4;\n  v3 = 0;\n  v4 = (int *)libmin_malloc(40uLL);\n  do {\n    *v4 = v3++;\n    solve(v4, 1);\n  } while (v3 != 10);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(v4);\n  libmin_success();\n}", "binary": "n-queens/n-queens.host.O3", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    $0x28,%edi\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x8,%rsp\ncall   15a0 <libmin_malloc>\nmov    %rax,%rbp\nnopl   0x0(%rax)\nmov    %ebx,0x0(%rbp)\nmov    $0x1,%esi\nmov    %rbp,%rdi\nadd    $0x1,%ebx\ncall   12f0 <solve>\ncmp    $0xa,%ebx\njne    1140 <main+0x20>\nmov    0x510e(%rip),%edx\nmov    $0xa,%esi\nlea    0x2e9e(%rip),%rdi\nxor    %eax,%eax\ncall   38e0 <libmin_printf>\nmov    %rbp,%rdi\ncall   1650 <libmin_free>\ncall   3b20 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "n-queens/n-queens.c", "function_name": "solve", "content": "// Recursive backtracking solver\nvoid\nsolve(int queens[], int row)\n{\n  if (row == BOARD_SIZE)\n  {\n    solution_count++;\n    return;\n  }\n  for (int col = 0; col < BOARD_SIZE; col++)\n  {\n    if (is_safe(queens, row, col))\n    {\n      queens[row] = col;\n      solve(queens, row + 1);\n    }\n  }\n}\n"}, "pseudo": {"path": "n-queens/n-queens.host.O3.pseudo", "function_name": "solve", "address": "0x12f0", "label": "solve", "content": "void __fastcall solve(int *queens, int row)\n{\n  int i; // r14d\n  int *v3; // r13\n  int v4; // ebx\n  int v5; // r15d\n\n  if ( row == 10 )\n  {\n    ++solution_count;\n  }\n  else\n  {\n    for ( i = 0; i != 10; ++i )\n    {\n      while ( 1 )\n      {\n        v3 = queens;\n        v4 = -row;\n        if ( row > 0 )\n          break;\nLABEL_10:\n        queens[row] = i++;\n        solve(queens, row + 1);\n        if ( i == 10 )\n          return;\n      }\n      while ( *v3 != i )\n      {\n        v5 = libmin_abs(*v3 - i);\n        if ( v5 == libmin_abs(v4) )\n          break;\n        ++v3;\n        if ( !++v4 )\n          goto LABEL_10;\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void solve(int *queens, int row) {\n  int i;\n  int *v3;\n  int v4;\n  int v5;\n  if (row == 10) {\n    ++solution_count;\n  } else {\n    for (i = 0; i != 10; ++i) {\n      while (1) {\n        v3 = queens;\n        v4 = -row;\n        if (row > 0) break;\n      LABEL_10:\n        queens[row] = i++;\n        solve(queens, row + 1);\n        if (i == 10) return;\n      }\n      while (*v3 != i) {\n        v5 = libmin_abs(*v3 - i);\n        if (v5 == libmin_abs(v4)) break;\n        ++v3;\n        if (!++v4) goto LABEL_10;\n      }\n    }\n  }\n}", "binary": "n-queens/n-queens.host.O3", "assembly": "<solve>:\nendbr64\ncmp    $0xa,%esi\nje     139f <solve+0xaf>\npush   %r15\nmovslq %esi,%rax\npush   %r14\nlea    (%rdi,%rax,4),%rax\nxor    %r14d,%r14d\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rax,(%rsp)\nlea    0x1(%rsi),%eax\nmov    %eax,0xc(%rsp)\nnopl   (%rax)\nmov    %ebp,%ebx\nmov    %r12,%r13\nneg    %ebx\ntest   %ebp,%ebp\njg     1358 <solve+0x68>\njmp    1380 <solve+0x90>\nnopl   (%rax)\nsub    %r14d,%edi\ncall   1590 <libmin_abs>\nmov    %ebx,%edi\nmov    %eax,%r15d\ncall   1590 <libmin_abs>\ncmp    %eax,%r15d\nje     1361 <solve+0x71>\nadd    $0x4,%r13\nadd    $0x1,%ebx\nje     1380 <solve+0x90>\nmov    0x0(%r13),%edi\ncmp    %r14d,%edi\njne    1338 <solve+0x48>\nadd    $0x1,%r14d\ncmp    $0xa,%r14d\njne    1328 <solve+0x38>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    (%rsp),%rax\nmov    0xc(%rsp),%esi\nmov    %r12,%rdi\nmov    %r14d,(%rax)\nadd    $0x1,%r14d\ncall   12f0 <solve>\ncmp    $0xa,%r14d\njne    1328 <solve+0x38>\njmp    136b <solve+0x7b>\naddl   $0x1,0x4ec6(%rip)\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "natlog/natlog.c", "function_name": "main", "content": "#include \"libmin.h\"\n\n/* calculate e=2.718..., using an interative approximation */\n\nint\nmain(void)\n{\n  /* STEPS is usually a very large number eg 10000000 */\n  int steps = 100000;\n  double x, y;\n\n  y = 1.0 + 1.0/steps;\n  x = 1.0;\n\n  for(; steps > 0; steps--)\n    x *= y;\n\n  libmin_printf(\"natlog: e=%f\\n\", x);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "natlog/natlog.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm0_8\n  int v4; // eax\n\n  v3 = 1.0;\n  v4 = 100000;\n  do\n  {\n    v3 = v3 * 1.00001;\n    --v4;\n  }\n  while ( v4 );\n  libmin_printf(\"natlog: e=%f\\n\", v3);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  int v4;\n  v3 = 1.0;\n  v4 = 100000;\n  do {\n    v3 = v3 * 1.00001;\n    --v4;\n  } while (v4);\n  libmin_printf(\"natlog: e=%f\\n\", v3);\n  libmin_success();\n}", "binary": "natlog/natlog.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nmovsd  0x2f08(%rip),%xmm0\nmov    $0x186a0,%eax\nmovsd  0x2f03(%rip),%xmm1\nnopl   (%rax)\nmulsd  %xmm1,%xmm0\nsub    $0x1,%eax\njne    1120 <main+0x20>\nlea    0x2ed4(%rip),%rdi\nmov    $0x1,%eax\ncall   3310 <libmin_printf>\ncall   3550 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "nbody-sim/nbody-sim.c", "function_name": "main", "content": "int main(void) {\n    // Initialize three particles with arbitrary masses, positions (in meters), and velocities (in m/s)\n    Particle bodies[N_BODIES] = {\n        {1e24, {0.0,    0.0,    0.0},    {0.0,    0.0, 0.0}},      // Body 0\n        {1e24, {1e8,    0.0,    0.0},    {0.0,  1e3, 0.0}},      // Body 1\n        {1e24, {0.0,    1e8,    0.0},    {-1e3,   0.0, 0.0}}       // Body 2\n    };\n\n    // Time integration loop using Euler integration\n    for (int step = 0; step < NUM_STEPS; step++) {\n        // Array to store computed accelerations for each particle\n        double acc[N_BODIES][3] = { {0.0} };\n        \n        // Compute gravitational acceleration for each particle\n        for (int i = 0; i < N_BODIES; i++) {\n            for (int j = 0; j < N_BODIES; j++) {\n                if (i == j) \n                    continue; // Skip self-interaction\n                \n                // Compute difference vector between particle j and i\n                double dx = bodies[j].pos[0] - bodies[i].pos[0];\n                double dy = bodies[j].pos[1] - bodies[i].pos[1];\n                double dz = bodies[j].pos[2] - bodies[i].pos[2];\n                \n                // Compute squared distance (with softening factor to avoid division by zero)\n                double r2 = dx * dx + dy * dy + dz * dz + EPS;\n                double r = libmin_sqrt(r2);\n                \n                // Compute acceleration magnitude: a = G * m_j / r^2\n                // Multiply by (dx, dy, dz)/r to get the vector\n                double a = G * bodies[j].mass / r2;\n                acc[i][0] += a * (dx / r);\n                acc[i][1] += a * (dy / r);\n                acc[i][2] += a * (dz / r);\n            }\n        }\n        \n        // Update velocities and positions of each particle using the computed accelerations\n        for (int i = 0; i < N_BODIES; i++) {\n            bodies[i].vel[0] += acc[i][0] * DT;\n            bodies[i].vel[1] += acc[i][1] * DT;\n            bodies[i].vel[2] += acc[i][2] * DT;\n            \n            bodies[i].pos[0] += bodies[i].vel[0] * DT;\n            bodies[i].pos[1] += bodies[i].vel[1] * DT;\n            bodies[i].pos[2] += bodies[i].vel[2] * DT;\n        }\n    }\n\n    // Print final positions and velocities after the simulation\n    libmin_printf(\"Final state after %d steps:\\n\", NUM_STEPS);\n    for (int i = 0; i < N_BODIES; i++) {\n        libmin_printf(\"Body %d:\\n\", i);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", \n               bodies[i].pos[0], bodies[i].pos[1], bodies[i].pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", \n               bodies[i].vel[0], bodies[i].vel[1], bodies[i].vel[2]);\n    }\n    \n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "nbody-sim/nbody-sim.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __m128i v3; // xmm1\n  Particle *v4; // r13\n  int v5; // r14d\n  double *v6; // r12\n  Particle *v7; // r15\n  int v8; // ebp\n  int v9; // ebx\n  __m128d v10; // xmm2\n  double v11; // xmm6_8\n  __m128d v12; // xmm0\n  __m128d v13; // xmm5\n  __m128d v14; // xmm7\n  double v15; // xmm4_8\n  unsigned __int64 v16; // xmm1_8\n  __m128d v17; // xmm0\n  bool v18; // zf\n  int v19; // ebx\n  int v20; // esi\n  double dz; // [rsp+8h] [rbp-200h]\n  __m128d v22; // [rsp+10h] [rbp-1F8h]\n  double v23; // [rsp+28h] [rbp-1E0h]\n  double v24; // [rsp+30h] [rbp-1D8h]\n  double v25; // [rsp+38h] [rbp-1D0h]\n  double v26; // [rsp+40h] [rbp-1C8h]\n  double v27; // [rsp+48h] [rbp-1C0h]\n  __m128d v28; // [rsp+50h] [rbp-1B8h]\n  __m128d v29; // [rsp+60h] [rbp-1A8h]\n  __m128d v30; // [rsp+70h] [rbp-198h]\n  __m128d v31; // [rsp+80h] [rbp-188h]\n  __m128d v32; // [rsp+90h] [rbp-178h]\n  __m128d v33; // [rsp+A0h] [rbp-168h]\n  double v34; // [rsp+B0h] [rbp-158h]\n  Particle *v35; // [rsp+B8h] [rbp-150h]\n  int v36; // [rsp+C4h] [rbp-144h]\n  double acc[3][3]; // [rsp+D0h] [rbp-138h] BYREF\n  Particle bodies[3]; // [rsp+120h] [rbp-E8h] BYREF\n  unsigned __int64 v39; // [rsp+1C8h] [rbp-40h]\n\n  v39 = __readfsqword(0x28u);\n  *(_OWORD *)&bodies[0].pos[1] = 0LL;\n  *(_OWORD *)bodies[0].vel = 0LL;\n  *(_OWORD *)&bodies[1].pos[2] = 0LL;\n  *(_OWORD *)&bodies[0].vel[2] = xmmword_40C0;\n  *(__m128i *)&bodies[1].vel[1] = _mm_loadl_epi64((const __m128i *)&qword_40D0);\n  v3 = _mm_loadl_epi64((const __m128i *)&x);\n  v28 = (__m128d)xmmword_4070;\n  bodies[2].vel[2] = 0.0;\n  *(__m128i *)&bodies[0].mass = _mm_loadl_epi64((const __m128i *)&qword_40B0);\n  *(__m128i *)bodies[1].pos = _mm_loadl_epi64((const __m128i *)&qword_4090);\n  *(_OWORD *)&bodies[2].mass = *(_OWORD *)&bodies[0].mass;\n  *(_OWORD *)&bodies[2].pos[1] = *(_OWORD *)bodies[1].pos;\n  *(__m128i *)bodies[2].vel = v3;\n  v29 = (__m128d)v3;\n  v30 = *(__m128d *)bodies[1].pos;\n  v31 = (__m128d)xmmword_40A0;\n  v32 = 0LL;\n  v33 = 0LL;\n  v36 = 1000;\n  v34 = 0.0;\n  v27 = 0.0;\n  v26 = 0.0;\n  v25 = 0.0;\n  v24 = 0.0;\n  v23 = 0.0;\n  while ( 1 )\n  {\n    v4 = bodies;\n    v5 = 0;\n    v6 = acc[0];\n    memset(acc, 0, sizeof(acc));\n    v35 = bodies;\n    do\n    {\n      v7 = bodies;\n      v8 = 0;\n      v9 = v5 + 1;\n      do\n      {\n        while ( v5 == v8 )\n        {\n          v8 = v5 + 1;\n          ++v7;\n          if ( v5 == 2 )\n            goto LABEL_7;\n        }\n        v10 = *(__m128d *)v7->pos;\n        ++v8;\n        ++v7;\n        dz = v7[-1].pos[2] - v4->pos[2];\n        v22 = _mm_sub_pd(v10, *(__m128d *)v4->pos);\n        v11 = _mm_unpackhi_pd(v22, v22).m128d_f64[0];\n        v12.m128d_f64[1] = v22.m128d_f64[1];\n        v12.m128d_f64[0] = libmin_sqrt(*(double *)v3.m128i_i64);\n        v13 = v12;\n        v14 = *(__m128d *)v6;\n        v15 = dz / v12.m128d_f64[0];\n        *(double *)&v16 = 6.674299999999999e-11\n                        * v7[-1].mass\n                        / (v22.m128d_f64[0] * v22.m128d_f64[0] + v11 * v11 + dz * dz + 2.220446049250313e-16);\n        v17 = _mm_unpacklo_pd((__m128d)v16, (__m128d)v16);\n        *(double *)v3.m128i_i64 = *(double *)&v16 * v15 + v6[2];\n        v6[2] = *(double *)v3.m128i_i64;\n        *(__m128d *)v6 = _mm_add_pd(_mm_mul_pd(_mm_div_pd(v22, _mm_unpacklo_pd(v13, v13)), v17), v14);\n      }\n      while ( v8 != 3 );\n      ++v5;\n      ++v4;\n      v6 += 3;\n    }\n    while ( v9 != 3 );\nLABEL_7:\n    v33 = _mm_add_pd(_mm_mul_pd((__m128d)xmmword_40E0, *(__m128d *)&acc[0][0]), v33);\n    *(__m128d *)bodies[0].vel = v33;\n    v32 = _mm_add_pd(v32, _mm_mul_pd(v33, (__m128d)xmmword_40E0));\n    v23 = 0.01 * acc[0][2] + v23;\n    bodies[0].vel[2] = v23;\n    *(__m128d *)bodies[0].pos = v32;\n    v24 = 0.01 * v23 + v24;\n    bodies[0].pos[2] = v24;\n    v31 = _mm_add_pd(_mm_mul_pd(*(__m128d *)&acc[1][0], (__m128d)xmmword_40E0), v31);\n    *(__m128d *)bodies[1].vel = v31;\n    v30 = _mm_add_pd(v30, _mm_mul_pd(v31, (__m128d)xmmword_40E0));\n    v25 = 0.01 * acc[1][2] + v25;\n    *(__m128d *)bodies[1].pos = v30;\n    bodies[1].vel[2] = v25;\n    v18 = v36-- == 1;\n    v26 = 0.01 * v25 + v26;\n    bodies[1].pos[2] = v26;\n    v29 = _mm_add_pd(_mm_mul_pd((__m128d)xmmword_40E0, *(__m128d *)&acc[2][0]), v29);\n    *(__m128d *)bodies[2].vel = v29;\n    v28 = _mm_add_pd(v28, _mm_mul_pd(v29, (__m128d)xmmword_40E0));\n    v27 = 0.01 * acc[2][2] + v27;\n    bodies[2].vel[2] = v27;\n    *(__m128d *)bodies[2].pos = v28;\n    v34 = 0.01 * v27 + v34;\n    bodies[2].pos[2] = v34;\n    if ( v18 )\n    {\n      v19 = 0;\n      libmin_printf(\"Final state after %d steps:\\n\", 1000);\n      do\n      {\n        v20 = v19++;\n        libmin_printf(\"Body %d:\\n\", v20);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", v35->pos[0], v35->pos[1], v35->pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", v35->vel[0], v35->vel[1], v35->vel[2]);\n        ++v35;\n      }\n      while ( v19 != 3 );\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  __m128i v3;\n  Particle *v4;\n  int v5;\n  double *v6;\n  Particle *v7;\n  int v8;\n  int v9;\n  __m128d v10;\n  double v11;\n  __m128d v12;\n  __m128d v13;\n  __m128d v14;\n  double v15;\n  unsigned long long v16;\n  __m128d v17;\n  bool v18;\n  int v19;\n  int v20;\n  double dz;\n  __m128d v22;\n  double v23;\n  double v24;\n  double v25;\n  double v26;\n  double v27;\n  __m128d v28;\n  __m128d v29;\n  __m128d v30;\n  __m128d v31;\n  __m128d v32;\n  __m128d v33;\n  double v34;\n  Particle *v35;\n  int v36;\n  double acc[3][3];\n  Particle bodies[3];\n  unsigned long long v39;\n  v39 = __readfsqword(40u);\n  *(long double *)&bodies[0].pos[1] = 0LL;\n  *(long double *)bodies[0].vel = 0LL;\n  *(long double *)&bodies[1].pos[2] = 0LL;\n  *(long double *)&bodies[0].vel[2] = xmmword_40C0;\n  *(__m128i *)&bodies[1].vel[1] = _mm_loadl_epi64((const __m128i *)&qword_40D0);\n  v3 = _mm_loadl_epi64((const __m128i *)&x);\n  v28 = (__m128d)xmmword_4070;\n  bodies[2].vel[2] = 0.0;\n  *(__m128i *)&bodies[0].mass = _mm_loadl_epi64((const __m128i *)&qword_40B0);\n  *(__m128i *)bodies[1].pos = _mm_loadl_epi64((const __m128i *)&qword_4090);\n  *(long double *)&bodies[2].mass = *(long double *)&bodies[0].mass;\n  *(long double *)&bodies[2].pos[1] = *(long double *)bodies[1].pos;\n  *(__m128i *)bodies[2].vel = v3;\n  v29 = (__m128d)v3;\n  v30 = *(__m128d *)bodies[1].pos;\n  v31 = (__m128d)xmmword_40A0;\n  v32 = 0LL;\n  v33 = 0LL;\n  v36 = 1000;\n  v34 = 0.0;\n  v27 = 0.0;\n  v26 = 0.0;\n  v25 = 0.0;\n  v24 = 0.0;\n  v23 = 0.0;\n  while (1) {\n    v4 = bodies;\n    v5 = 0;\n    v6 = acc[0];\n    memset(acc, 0, sizeof(acc));\n    v35 = bodies;\n    do {\n      v7 = bodies;\n      v8 = 0;\n      v9 = v5 + 1;\n      do {\n        while (v5 == v8) {\n          v8 = v5 + 1;\n          ++v7;\n          if (v5 == 2) goto LABEL_7;\n        }\n        v10 = *(__m128d *)v7->pos;\n        ++v8;\n        ++v7;\n        dz = v7[-1].pos[2] - v4->pos[2];\n        v22 = _mm_sub_pd(v10, *(__m128d *)v4->pos);\n        v11 = _mm_unpackhi_pd(v22, v22).m128d_f64[0];\n        v12.m128d_f64[1] = v22.m128d_f64[1];\n        v12.m128d_f64[0] = libmin_sqrt(*(double *)v3.m128i_i64);\n        v13 = v12;\n        v14 = *(__m128d *)v6;\n        v15 = dz / v12.m128d_f64[0];\n        *(double *)&v16 = 6.674299999999999e-11 * v7[-1].mass /\n                          (v22.m128d_f64[0] * v22.m128d_f64[0] + v11 * v11 +\n                           dz * dz + 2.220446049250313e-16);\n        v17 = _mm_unpacklo_pd((__m128d)v16, (__m128d)v16);\n        *(double *)v3.m128i_i64 = *(double *)&v16 * v15 + v6[2];\n        v6[2] = *(double *)v3.m128i_i64;\n        *(__m128d *)v6 = _mm_add_pd(\n            _mm_mul_pd(_mm_div_pd(v22, _mm_unpacklo_pd(v13, v13)), v17), v14);\n      } while (v8 != 3);\n      ++v5;\n      ++v4;\n      v6 += 3;\n    } while (v9 != 3);\n  LABEL_7:\n    v33 = _mm_add_pd(_mm_mul_pd((__m128d)xmmword_40E0, *(__m128d *)&acc[0][0]),\n                     v33);\n    *(__m128d *)bodies[0].vel = v33;\n    v32 = _mm_add_pd(v32, _mm_mul_pd(v33, (__m128d)xmmword_40E0));\n    v23 = 0.01 * acc[0][2] + v23;\n    bodies[0].vel[2] = v23;\n    *(__m128d *)bodies[0].pos = v32;\n    v24 = 0.01 * v23 + v24;\n    bodies[0].pos[2] = v24;\n    v31 = _mm_add_pd(_mm_mul_pd(*(__m128d *)&acc[1][0], (__m128d)xmmword_40E0),\n                     v31);\n    *(__m128d *)bodies[1].vel = v31;\n    v30 = _mm_add_pd(v30, _mm_mul_pd(v31, (__m128d)xmmword_40E0));\n    v25 = 0.01 * acc[1][2] + v25;\n    *(__m128d *)bodies[1].pos = v30;\n    bodies[1].vel[2] = v25;\n    v18 = v36-- == 1;\n    v26 = 0.01 * v25 + v26;\n    bodies[1].pos[2] = v26;\n    v29 = _mm_add_pd(_mm_mul_pd((__m128d)xmmword_40E0, *(__m128d *)&acc[2][0]),\n                     v29);\n    *(__m128d *)bodies[2].vel = v29;\n    v28 = _mm_add_pd(v28, _mm_mul_pd(v29, (__m128d)xmmword_40E0));\n    v27 = 0.01 * acc[2][2] + v27;\n    bodies[2].vel[2] = v27;\n    *(__m128d *)bodies[2].pos = v28;\n    v34 = 0.01 * v27 + v34;\n    bodies[2].pos[2] = v34;\n    if (v18) {\n      v19 = 0;\n      libmin_printf(\"Final state after %d steps:\\n\", 1000);\n      do {\n        v20 = v19++;\n        libmin_printf(\"Body %d:\\n\", v20);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", v35->pos[0], v35->pos[1],\n                      v35->pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", v35->vel[0],\n                      v35->vel[1], v35->vel[2]);\n        ++v35;\n      } while (v19 != 3);\n      libmin_success();\n    }\n  }\n}", "binary": "nbody-sim/nbody-sim.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\npxor   %xmm1,%xmm1\npxor   %xmm5,%xmm5\npxor   %xmm6,%xmm6\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x1d8,%rsp\nmovapd 0x2f97(%rip),%xmm0\nmovapd 0x2f3f(%rip),%xmm7\nmov    %fs:0x28,%rax\nmov    %rax,0x1c8(%rsp)\nxor    %eax,%eax\nmovaps %xmm1,0x130(%rsp)\nmovq   0x2f5c(%rip),%xmm2\nlea    0x120(%rsp),%rax\nmovaps %xmm1,0x140(%rsp)\nmovaps %xmm1,0x170(%rsp)\nmovq   0x2f5c(%rip),%xmm1\nmovaps %xmm0,0x150(%rsp)\nmovq   0x2f0c(%rip),%xmm0\nmovaps %xmm1,0x180(%rsp)\nmovq   0x2eec(%rip),%xmm1\nmovaps %xmm7,0x50(%rsp)\nmovapd 0x2eff(%rip),%xmm7\nmovq   $0x0,0x1c0(%rsp)\nmovaps %xmm2,0x120(%rsp)\nmovaps %xmm0,0x160(%rsp)\nmovaps %xmm2,0x190(%rsp)\nmovaps %xmm0,0x1a0(%rsp)\nmovaps %xmm1,0x1b0(%rsp)\nmovaps %xmm1,0x60(%rsp)\nmovaps %xmm0,0x70(%rsp)\nmovaps %xmm7,0x80(%rsp)\nmovaps %xmm5,0x90(%rsp)\nmovaps %xmm5,0xa0(%rsp)\nmov    %rax,0x20(%rsp)\nlea    0xd0(%rsp),%rax\nmovl   $0x3e8,0xc4(%rsp)\nmov    %rax,0xc8(%rsp)\nmovsd  %xmm6,0xb0(%rsp)\nmovsd  %xmm6,0x48(%rsp)\nmovsd  %xmm6,0x40(%rsp)\nmovsd  %xmm6,0x38(%rsp)\nmovsd  %xmm6,0x30(%rsp)\nmovsd  %xmm6,0x28(%rsp)\nxchg   %ax,%ax\nmov    0x20(%rsp),%r13\npxor   %xmm0,%xmm0\nxor    %r14d,%r14d\nmovq   $0x0,0x110(%rsp)\nmov    0xc8(%rsp),%r12\nmovaps %xmm0,0xd0(%rsp)\nmov    %r13,0xb8(%rsp)\nmovaps %xmm0,0xe0(%rsp)\nmovaps %xmm0,0xf0(%rsp)\nmovaps %xmm0,0x100(%rsp)\nmov    0x20(%rsp),%r15\nxor    %ebp,%ebp\nlea    0x1(%r14),%ebx\ncmp    %ebp,%r14d\nje     1630 <main+0x530>\nmovupd 0x8(%r15),%xmm2\nmovupd 0x8(%r13),%xmm7\nadd    $0x1,%ebp\nadd    $0x38,%r15\nmovsd  -0x20(%r15),%xmm4\nsubsd  0x18(%r13),%xmm4\nsubpd  %xmm7,%xmm2\nmovsd  %xmm4,0x8(%rsp)\nmovapd %xmm2,%xmm6\nmovapd %xmm2,%xmm3\nmovaps %xmm2,0x10(%rsp)\nmulsd  %xmm2,%xmm3\nunpckhpd %xmm6,%xmm6\nmovapd %xmm6,%xmm0\nmulsd  %xmm6,%xmm0\naddsd  %xmm0,%xmm3\nmovapd %xmm4,%xmm0\nmulsd  %xmm4,%xmm0\naddsd  %xmm0,%xmm3\naddsd  0x2df6(%rip),%xmm3\nmovapd %xmm3,%xmm0\nmovsd  %xmm3,(%rsp)\ncall   3a30 <libmin_sqrt>\nmovsd  (%rsp),%xmm3\nmovapd 0x10(%rsp),%xmm2\nmovapd %xmm0,%xmm5\nmovsd  0x8(%rsp),%xmm4\nmovupd (%r12),%xmm7\nmovsd  0x2dcd(%rip),%xmm0\nmulsd  -0x38(%r15),%xmm0\ndivsd  %xmm5,%xmm4\nmovapd %xmm0,%xmm1\nmovapd %xmm5,%xmm0\nunpcklpd %xmm0,%xmm0\ndivsd  %xmm3,%xmm1\ndivpd  %xmm0,%xmm2\nmovapd %xmm1,%xmm0\nmulsd  %xmm4,%xmm1\nunpcklpd %xmm0,%xmm0\naddsd  0x10(%r12),%xmm1\nmovsd  %xmm1,0x10(%r12)\nmulpd  %xmm0,%xmm2\naddpd  %xmm7,%xmm2\nmovups %xmm2,(%r12)\ncmp    $0x3,%ebp\njne    1293 <main+0x193>\nmov    %ebx,%r14d\nadd    $0x38,%r13\nadd    $0x18,%r12\ncmp    $0x3,%ebx\njne    1288 <main+0x188>\nmovapd 0x2d4b(%rip),%xmm0\nmulpd  0xd0(%rsp),%xmm0\naddpd  0xa0(%rsp),%xmm0\nmovapd 0x90(%rsp),%xmm6\nmovapd %xmm0,%xmm5\nmovaps %xmm0,0xa0(%rsp)\nmulpd  0x2d1c(%rip),%xmm0\nmovaps %xmm5,0x140(%rsp)\naddpd  %xmm0,%xmm6\nmovsd  0x2d08(%rip),%xmm0\nmulsd  0xe0(%rsp),%xmm0\naddsd  0x28(%rsp),%xmm0\nmovaps %xmm6,0x90(%rsp)\nmovapd %xmm0,%xmm5\nmovsd  %xmm0,0x28(%rsp)\nmovsd  %xmm0,0x150(%rsp)\nmovsd  0x2cd6(%rip),%xmm0\nmovups %xmm6,0x128(%rsp)\nmulsd  %xmm5,%xmm0\nmovapd 0x70(%rsp),%xmm5\naddsd  0x30(%rsp),%xmm0\nmovsd  %xmm0,0x30(%rsp)\nmovsd  %xmm0,0x138(%rsp)\nmovupd 0xe8(%rsp),%xmm0\nmulpd  0x2c9e(%rip),%xmm0\naddpd  0x80(%rsp),%xmm0\nmovapd %xmm0,%xmm6\nmovaps %xmm0,0x80(%rsp)\nmulpd  0x2c81(%rip),%xmm0\nmovups %xmm6,0x178(%rsp)\naddpd  %xmm0,%xmm5\nmovsd  0x2c6d(%rip),%xmm0\nmulsd  0xf8(%rsp),%xmm0\naddsd  0x38(%rsp),%xmm0\nmovaps %xmm5,0x70(%rsp)\nmovapd %xmm0,%xmm6\nmovsd  %xmm0,0x38(%rsp)\nmovaps %xmm5,0x160(%rsp)\nmovsd  %xmm0,0x188(%rsp)\nmovsd  0x2c36(%rip),%xmm0\nmovapd 0x50(%rsp),%xmm5\nsubl   $0x1,0xc4(%rsp)\nmulsd  %xmm6,%xmm0\naddsd  0x40(%rsp),%xmm0\nmovsd  %xmm0,0x40(%rsp)\nmovsd  %xmm0,0x170(%rsp)\nmovapd 0x2c07(%rip),%xmm0\nmulpd  0x100(%rsp),%xmm0\naddpd  0x60(%rsp),%xmm0\nmovapd %xmm0,%xmm7\nmovaps %xmm0,0x60(%rsp)\nmulpd  0x2be7(%rip),%xmm0\nmovaps %xmm7,0x1b0(%rsp)\naddpd  %xmm0,%xmm5\nmovsd  0x2bd3(%rip),%xmm0\nmulsd  0x110(%rsp),%xmm0\naddsd  0x48(%rsp),%xmm0\nmovaps %xmm5,0x50(%rsp)\nmovapd %xmm0,%xmm7\nmovsd  %xmm0,0x48(%rsp)\nmovsd  %xmm0,0x1c0(%rsp)\nmovsd  0x2ba4(%rip),%xmm0\nmovups %xmm5,0x198(%rsp)\nmulsd  %xmm7,%xmm0\naddsd  0xb0(%rsp),%xmm0\nmovsd  %xmm0,0xb0(%rsp)\nmovsd  %xmm0,0x1a8(%rsp)\njne    1240 <main+0x140>\nmov    $0x3e8,%esi\nlea    0x2a8f(%rip),%rdi\nxor    %eax,%eax\nxor    %ebx,%ebx\ncall   3820 <libmin_printf>\nlea    0x2a9c(%rip),%r14\nlea    0x2a9f(%rip),%r12\nlea    0x2ab5(%rip),%rbp\nmov    %ebx,%esi\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   3820 <libmin_printf>\nmov    0xb8(%rsp),%r15\nmov    %r12,%rdi\nmov    $0x3,%eax\nmovsd  0x8(%r15),%xmm0\nmovsd  0x18(%r15),%xmm2\nmovsd  0x10(%r15),%xmm1\ncall   3820 <libmin_printf>\nmovsd  0x20(%r15),%xmm0\nmov    %rbp,%rdi\nmov    $0x3,%eax\nmovsd  0x30(%r15),%xmm2\nmovsd  0x28(%r15),%xmm1\ncall   3820 <libmin_printf>\nmov    %r15,%rax\nadd    $0x38,%rax\nmov    %rax,0xb8(%rsp)\ncmp    $0x3,%ebx\njne    1593 <main+0x493>\ncall   3c80 <libmin_success>\nmov    0x1c8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1658 <main+0x558>\nadd    $0x1d8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    %ebx,%ebp\nadd    $0x38,%r15\ncmp    $0x3,%ebx\njne    1293 <main+0x193>\nmov    %ebx,%r14d\nadd    $0x38,%r13\nadd    $0x18,%r12\ncmp    $0x3,%ebx\njne    1288 <main+0x188>\njmp    138d <main+0x28d>\ncall   10b0 <__stack_chk_fail@plt>\nnopl   (%rax)\n"}
{"source": {"path": "nr-solver/nr-solver.c", "function_name": "f", "content": "#define FN_SQRT\n\n#ifdef FN_SQRT\ndouble\nf(double x)\n{\n  return x*x - sqrt_value;\n}\n"}, "pseudo": {"path": "nr-solver/nr-solver.host.O3.pseudo", "function_name": "f", "address": "0x12f0", "label": "f", "content": "double __fastcall f(double a1, double x)\n{\n  return a1 * a1 - sqrt_value;\n}\n"}, "pseudo_normalize": "", "binary": "nr-solver/nr-solver.host.O3", "assembly": "<f>:\nendbr64\nmulsd  %xmm0,%xmm0\nsubsd  0x5110(%rip),%xmm0\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "nr-solver/nr-solver.c", "function_name": "myfabs", "content": "#endif\n\n// get absolute value of the number given by user\ndouble myfabs(double num)\n{\n  if (num < 0.0)\n    return -num;\n  else\n    return num;\n}\n"}, "pseudo": {"path": "nr-solver/nr-solver.host.O3.pseudo", "function_name": "myfabs", "address": "0x1320", "label": "myfabs", "content": "double __fastcall myfabs(double result, double num)\n{\n  if ( result < 0.0 )\n    return -result;\n  return result;\n}\n"}, "pseudo_normalize": "", "binary": "nr-solver/nr-solver.host.O3", "assembly": "<myfabs>:\nendbr64\npxor   %xmm1,%xmm1\ncomisd %xmm0,%xmm1\nja     1330 <myfabs+0x10>\nret\nnop\nxorpd  0x2cf8(%rip),%xmm0\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "nr-solver/nr-solver.c", "function_name": "rn_solver", "content": "// calculate function value using Newton-Raphson method\ndouble rn_solver(int *converged, double maxerr, unsigned maxiter, fn_type f, fn_type df)\n{\n  unsigned iter;\n  double guess = 1.0;\n\n  *converged = FALSE;\n  for (iter = 0; iter < maxiter; iter++)\n  {\n      *converged = myfabs(f(guess)) <= maxerr;\n      if (*converged)\n        break;\n      guess = guess - f(guess)/df(guess);\n  }\n  // libmin_printf(\"niter == %u\\n\", iter);\n  return guess;\n}\n"}, "pseudo": {"path": "nr-solver/nr-solver.host.O3.pseudo", "function_name": "rn_solver", "address": "0x1340", "label": "rn_solver", "content": "double __fastcall rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f, fn_type df_0)\n{\n  int v8; // ebx\n  double v9; // xmm2_8\n  double v10; // xmm0_8\n  double v12; // [rsp+8h] [rbp-40h]\n\n  *converged = 0;\n  if ( !maxiter )\n    return 1.0;\n  v8 = 0;\n  v9 = 1.0;\n  do\n  {\n    v10 = f(v9);\n    if ( v10 < 0.0 )\n      v10 = -v10;\n    *converged = maxerr >= v10;\n    if ( maxerr >= v10 )\n      break;\n    ++v8;\n    v12 = f(v9);\n    v9 = v9 - v12 / df_0(v9);\n  }\n  while ( maxiter != v8 );\n  return v9;\n}\n"}, "pseudo_normalize": "double rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f,\n                 fn_type df_0) {\n  int v8;\n  double v9;\n  double v10;\n  double v12;\n  *converged = 0;\n  if (!maxiter) return 1.0;\n  v8 = 0;\n  v9 = 1.0;\n  do {\n    v10 = f(v9);\n    if (v10 < 0.0) v10 = -v10;\n    *converged = maxerr >= v10;\n    if (maxerr >= v10) break;\n    ++v8;\n    v12 = f(v9);\n    v9 = v9 - v12 / df_0(v9);\n  } while (maxiter != v8);\n  return v9;\n}", "binary": "nr-solver/nr-solver.host.O3", "assembly": "<rn_solver>:\nendbr64\nmovl   $0x0,(%rdi)\ntest   %esi,%esi\nje     1401 <rn_solver+0xc1>\npush   %r15\nmovq   %xmm0,%r15\npush   %r14\nmov    %rcx,%r14\npush   %r13\nmov    %esi,%r13d\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x18,%rsp\nmovsd  0x2cc5(%rip),%xmm2\njmp    13b8 <rn_solver+0x78>\nnopl   (%rax)\nmovapd %xmm2,%xmm0\nmovsd  %xmm2,(%rsp)\nadd    $0x1,%ebx\ncall   *%rbp\nmovsd  (%rsp),%xmm2\nmovsd  %xmm0,0x8(%rsp)\nmovapd %xmm2,%xmm0\ncall   *%r14\nmovsd  0x8(%rsp),%xmm1\nmovsd  (%rsp),%xmm2\ndivsd  %xmm0,%xmm1\nsubsd  %xmm1,%xmm2\ncmp    %ebx,%r13d\nje     13ee <rn_solver+0xae>\nmovapd %xmm2,%xmm0\nmovsd  %xmm2,(%rsp)\ncall   *%rbp\npxor   %xmm4,%xmm4\nmovsd  (%rsp),%xmm2\ncomisd %xmm0,%xmm4\njbe    13da <rn_solver+0x9a>\nxorpd  0x2c56(%rip),%xmm0\nmovq   %r15,%xmm5\nxor    %eax,%eax\ncomisd %xmm0,%xmm5\nsetae  %al\nmov    %eax,(%r12)\njb     1380 <rn_solver+0x40>\nadd    $0x18,%rsp\nmovapd %xmm2,%xmm0\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovsd  0x2c37(%rip),%xmm2\nmovapd %xmm2,%xmm0\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "check_packet_filter", "content": "// Check if the packet matches the filter criteria:\n// The packet should be using TCP and have a destination IP in the range 192.168.0.0/16.\nint check_packet_filter(Packet pkt) {\n    if (pkt.protocol != TCP_PROTOCOL) {\n        return FALSE;\n    }\n    // Extract the first two octets of the destination IP.\n    unsigned int first_octet = (pkt.dest_ip >> 24) & 0xFF;\n    unsigned int second_octet = (pkt.dest_ip >> 16) & 0xFF;\n    return (first_octet == FIXED_IP_FIRST && second_octet == FIXED_IP_SECOND);\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O3.pseudo", "function_name": "check_packet_filter", "address": "0x1520", "label": "check_packet_filter", "content": "__int64 __fastcall check_packet_filter(Packet pkt)\n{\n  __int64 result; // rax\n\n  result = 0LL;\n  if ( pkt.protocol == 6 )\n    return (BYTE2(pkt.dest_ip) == 0xA8) & (unsigned __int8)(HIBYTE(pkt.dest_ip) == 192);\n  return result;\n}\n"}, "pseudo_normalize": "long long check_packet_filter(Packet pkt) {\n  long long result;\n  result = 0LL;\n  if (pkt.protocol == 6)\n    return (BYTE2(pkt.dest_ip) == 168) &\n           (unsigned char)(HIBYTE(pkt.dest_ip) == 192);\n  return result;\n}", "binary": "packet-filter/packet-filter.host.O3", "assembly": "<check_packet_filter>:\nendbr64\nxor    %eax,%eax\ncmpb   $0x6,0x14(%rsp)\njne    154c <check_packet_filter+0x2c>\nmov    0xc(%rsp),%eax\nmov    %eax,%edx\nshr    $0x10,%edx\ncmp    $0xa8,%dl\nsete   %dl\nshr    $0x18,%eax\ncmp    $0xc0,%eax\nsete   %al\nmovzbl %al,%eax\nand    %edx,%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "generate_packet", "content": "// Generate a random packet.\n// With ~5% probability, the packet will have the TCP protocol \n// and a destination IP within the range 192.168.0.0 - 192.168.255.255.\nPacket generate_packet() {\n    Packet pkt;\n    \n    if (libmin_rand() % 20 == 0) {\n        // Force matching criteria: destination IP in 192.168.x.x and TCP protocol.\n        pkt.dest_ip = ((unsigned int)FIXED_IP_FIRST << 24) |\n                      ((unsigned int)FIXED_IP_SECOND << 16) |\n                      (((unsigned int)libmin_rand() % 256) << 8) |\n                      ((unsigned int)libmin_rand() % 256);\n        pkt.protocol = TCP_PROTOCOL;\n    } else {\n        // Generate a random destination IP and a random protocol.\n        pkt.dest_ip = (unsigned int)libmin_rand();\n        pkt.protocol = (unsigned char)(libmin_rand() % 256);\n    }\n    \n    // Generate a random source IP.\n    pkt.src_ip = (unsigned int)libmin_rand();\n    \n    // Generate random source and destination ports.\n    pkt.src_port = (unsigned short)(libmin_rand() % 65536);\n    pkt.dest_port = (unsigned short)(libmin_rand() % 65536);\n    \n    // Fill the payload with 63 random uppercase characters and null-terminate.\n    for (int i = 0; i < 63; i++) {\n        pkt.payload[i] = 'A' + (libmin_rand() % 26);\n    }\n    pkt.payload[63] = '\\0';\n    \n    return pkt;\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O3.pseudo", "function_name": "generate_packet", "address": "0x13d0", "label": "generate_packet", "content": "Packet *__cdecl generate_packet(Packet *__return_ptr retstr)\n{\n  __int8 v1; // r13\n  __int16 v2; // bx\n  unsigned int v3; // ebx\n  __m128i *v4; // r14\n  __int64 v5; // xmm0_8\n  unsigned __int16 v6; // bp\n  unsigned int v7; // ebp\n  __m128i v8; // xmm3\n  __m128i v9; // xmm4\n  __m128i v10; // xmm5\n  __m128i v11; // xmm6\n  __m128i v12; // xmm2\n  __m128i v14; // [rsp+0h] [rbp-98h] BYREF\n  __m128i v15; // [rsp+10h] [rbp-88h] BYREF\n  __m128i v16; // [rsp+20h] [rbp-78h] BYREF\n  __m128i v17; // [rsp+30h] [rbp-68h] BYREF\n  __m128i v18; // [rsp+40h] [rbp-58h] BYREF\n  unsigned __int64 v19; // [rsp+58h] [rbp-40h]\n\n  v19 = __readfsqword(0x28u);\n  if ( __ROR4__(-858993459 * libmin_rand(), 2) > 0xCCCCCCCu )\n  {\n    v3 = libmin_rand();\n    v1 = libmin_rand();\n  }\n  else\n  {\n    v1 = 6;\n    v2 = libmin_rand();\n    v3 = (unsigned __int8)libmin_rand() | (unsigned __int16)(v2 << 8) | 0xC0A80000;\n  }\n  v4 = (__m128i *)((char *)&v14.m128i_u64[1] + 5);\n  v5 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(libmin_rand()), _mm_cvtsi32_si128(v3)).m128i_u64[0];\n  v6 = libmin_rand();\n  v7 = (libmin_rand() << 16) | v6;\n  do\n  {\n    v4 = (__m128i *)((char *)v4 + 1);\n    v4[-1].m128i_i8[15] = libmin_rand() % 0x1A + 65;\n  }\n  while ( v4 != (__m128i *)((char *)&v18.m128i_u64[1] + 4) );\n  v18.m128i_i8[12] = 0;\n  v8 = _mm_load_si128(&v15);\n  v9 = _mm_load_si128(&v16);\n  v10 = _mm_load_si128(&v17);\n  v14.m128i_i64[0] = v5;\n  v14.m128i_i32[2] = v7;\n  v11 = _mm_load_si128(&v18);\n  v14.m128i_i8[12] = v1;\n  v12 = _mm_load_si128(&v14);\n  *(__m128i *)&retstr->payload[3] = v8;\n  *(__m128i *)&retstr->src_ip = v12;\n  *(__m128i *)&retstr->payload[19] = v9;\n  *(__m128i *)&retstr->payload[35] = v10;\n  *(__m128i *)&retstr->payload[51] = v11;\n  return retstr;\n}\n"}, "pseudo_normalize": "Packet *generate_packet(Packet *__return_ptr retstr) {\n  char v1;\n  short v2;\n  unsigned int v3;\n  __m128i *v4;\n  long long v5;\n  unsigned short v6;\n  unsigned int v7;\n  __m128i v8;\n  __m128i v9;\n  __m128i v10;\n  __m128i v11;\n  __m128i v12;\n  __m128i v14;\n  __m128i v15;\n  __m128i v16;\n  __m128i v17;\n  __m128i v18;\n  unsigned long long v19;\n  v19 = __readfsqword(40u);\n  if (__ROR4__(-858993459 * libmin_rand(), 2) > 214748364u) {\n    v3 = libmin_rand();\n    v1 = libmin_rand();\n  } else {\n    v1 = 6;\n    v2 = libmin_rand();\n    v3 = (unsigned char)libmin_rand() | (unsigned short)(v2 << 8) | 3232235520;\n  }\n  v4 = (__m128i *)((char *)&v14.m128i_u64[1] + 5);\n  v5 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(libmin_rand()),\n                          _mm_cvtsi32_si128(v3))\n           .m128i_u64[0];\n  v6 = libmin_rand();\n  v7 = (libmin_rand() << 16) | v6;\n  do {\n    v4 = (__m128i *)((char *)v4 + 1);\n    v4[-1].m128i_i8[15] = libmin_rand() % 26 + 65;\n  } while (v4 != (__m128i *)((char *)&v18.m128i_u64[1] + 4));\n  v18.m128i_i8[12] = 0;\n  v8 = _mm_load_si128(&v15);\n  v9 = _mm_load_si128(&v16);\n  v10 = _mm_load_si128(&v17);\n  v14.m128i_i64[0] = v5;\n  v14.m128i_i32[2] = v7;\n  v11 = _mm_load_si128(&v18);\n  v14.m128i_i8[12] = v1;\n  v12 = _mm_load_si128(&v14);\n  *(__m128i *)&retstr->payload[3] = v8;\n  *(__m128i *)&retstr->src_ip = v12;\n  *(__m128i *)&retstr->payload[19] = v9;\n  *(__m128i *)&retstr->payload[35] = v10;\n  *(__m128i *)&retstr->payload[51] = v11;\n  return retstr;\n}", "binary": "packet-filter/packet-filter.host.O3", "assembly": "<generate_packet>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\ncall   39a0 <libmin_rand>\nimul   $0xcccccccd,%eax,%eax\nror    $0x2,%eax\ncmp    $0xccccccc,%eax\nja     14fd <generate_packet+0x12d>\ncall   39a0 <libmin_rand>\nmov    $0x6,%r13d\nmov    %eax,%ebx\ncall   39a0 <libmin_rand>\nshl    $0x8,%ebx\nmovzwl %bx,%ebx\nmovzbl %al,%eax\nor     %eax,%ebx\nor     $0xc0a80000,%ebx\ncall   39a0 <libmin_rand>\nmovd   %ebx,%xmm1\nlea    0xd(%rsp),%r14\nlea    0x4c(%rsp),%rbx\nmovd   %eax,%xmm0\npunpckldq %xmm1,%xmm0\nmovq   %xmm0,%r15\ncall   39a0 <libmin_rand>\nmov    %eax,%ebp\ncall   39a0 <libmin_rand>\nmovzwl %bp,%ebp\nshl    $0x10,%eax\nor     %eax,%ebp\nnopl   (%rax)\ncall   39a0 <libmin_rand>\nadd    $0x1,%r14\nmov    %eax,%edx\nimul   $0x4ec4ec4f,%rdx,%rdx\nshr    $0x23,%rdx\nimul   $0x1a,%edx,%edx\nsub    %edx,%eax\nadd    $0x41,%eax\nmov    %al,-0x1(%r14)\ncmp    %rbx,%r14\njne    1468 <generate_packet+0x98>\nmovb   $0x0,0x4c(%rsp)\nmovdqa 0x10(%rsp),%xmm3\nmovdqa 0x20(%rsp),%xmm4\nmovdqa 0x30(%rsp),%xmm5\nmov    %r15,(%rsp)\nmov    %ebp,0x8(%rsp)\nmovdqa 0x40(%rsp),%xmm6\nmov    %r13b,0xc(%rsp)\nmovdqa (%rsp),%xmm2\nmovups %xmm3,0x10(%r12)\nmovups %xmm2,(%r12)\nmovups %xmm4,0x20(%r12)\nmovups %xmm5,0x30(%r12)\nmovups %xmm6,0x40(%r12)\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1511 <generate_packet+0x141>\nadd    $0x68,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   39a0 <libmin_rand>\nmov    %eax,%ebx\ncall   39a0 <libmin_rand>\nmov    %eax,%r13d\njmp    1431 <generate_packet+0x61>\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "main", "content": "int main() {\n    // Seed the random number generator.\n    libmin_srand(42);\n    \n    int packetCounter = 0;\n    \n    // Simulate packet processing.\n    while (packetCounter < PACKET_COUNT) {\n        Packet pkt = generate_packet();\n        packetCounter++;\n        \n        // Use the updated filter: check for TCP and IP range.\n        if (check_packet_filter(pkt)) {\n            libmin_printf(\"Matched Packet #%d:\\n\", packetCounter);\n            print_packet(pkt);\n        }\n    }\n    \n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n  __m128i si128; // xmm0\n  __m128i v5; // xmm2\n  __m128i v6; // xmm3\n  __m128i v7; // xmm4\n  Packet pkt; // [rsp+0h] [rbp+0h] BYREF\n  _OWORD vars50[5]; // [rsp+50h] [rbp+50h] BYREF\n  unsigned __int64 varsA8; // [rsp+A8h] [rbp+A8h]\n\n  v3 = 0;\n  varsA8 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  while ( 1 )\n  {\n    ++v3;\n    generate_packet(&pkt);\n    if ( pkt.protocol == 6 && BYTE2(pkt.dest_ip) == 0xA8 && HIBYTE(pkt.dest_ip) == 192 )\n    {\n      libmin_printf(\"Matched Packet #%d:\\n\", v3);\n      si128 = _mm_load_si128((const __m128i *)&pkt);\n      v5 = _mm_load_si128((const __m128i *)&pkt.payload[19]);\n      v6 = _mm_load_si128((const __m128i *)&pkt.payload[35]);\n      v7 = _mm_load_si128((const __m128i *)&pkt.payload[51]);\n      vars50[1] = _mm_load_si128((const __m128i *)&pkt.payload[3]);\n      vars50[0] = si128;\n      vars50[2] = v5;\n      vars50[3] = v6;\n      vars50[4] = v7;\n      libmin_printf(\"Packet Details:\\n\");\n      libmin_printf(\"  Source IP: \");\n      libmin_printf(\"%u.%u.%u.%u\", HIBYTE(LODWORD(vars50[0])), BYTE2(vars50[0]), BYTE1(vars50[0]), LOBYTE(vars50[0]));\n      libmin_printf(\"\\n  Destination IP: \");\n      libmin_printf(\"%u.%u.%u.%u\", HIBYTE(DWORD1(vars50[0])), BYTE6(vars50[0]), BYTE5(vars50[0]), BYTE4(vars50[0]));\n      libmin_printf(\"\\n  Source Port: %u\\n\", WORD4(vars50[0]));\n      libmin_printf(\"  Destination Port: %u\\n\", WORD5(vars50[0]));\n      libmin_printf(\"  Protocol: %u\\n\", BYTE12(vars50[0]));\n      libmin_printf(\"  Payload: %s\\n\", (const char *)vars50 + 13);\n      libmin_printf(\"------------------------------\\n\");\n    }\n    if ( v3 == 100 )\n      libmin_success();\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  __m128i si128;\n  __m128i v5;\n  __m128i v6;\n  __m128i v7;\n  Packet pkt;\n  long double vars50[5];\n  unsigned long long varsA8;\n  v3 = 0;\n  varsA8 = __readfsqword(40u);\n  libmin_srand(42u);\n  while (1) {\n    ++v3;\n    generate_packet(&pkt);\n    if (pkt.protocol == 6 && BYTE2(pkt.dest_ip) == 168 &&\n        HIBYTE(pkt.dest_ip) == 192) {\n      libmin_printf(\"Matched Packet #%d:\\n\", v3);\n      si128 = _mm_load_si128((const __m128i *)&pkt);\n      v5 = _mm_load_si128((const __m128i *)&pkt.payload[19]);\n      v6 = _mm_load_si128((const __m128i *)&pkt.payload[35]);\n      v7 = _mm_load_si128((const __m128i *)&pkt.payload[51]);\n      vars50[1] = _mm_load_si128((const __m128i *)&pkt.payload[3]);\n      vars50[0] = si128;\n      vars50[2] = v5;\n      vars50[3] = v6;\n      vars50[4] = v7;\n      libmin_printf(\"Packet Details:\\n\");\n      libmin_printf(\"  Source IP: \");\n      libmin_printf(\"%u.%u.%u.%u\", HIBYTE(LODWORD(vars50[0])), BYTE2(vars50[0]),\n                    BYTE1(vars50[0]), LOBYTE(vars50[0]));\n      libmin_printf(\"\\n  Destination IP: \");\n      libmin_printf(\"%u.%u.%u.%u\", HIBYTE(DWORD1(vars50[0])), BYTE6(vars50[0]),\n                    BYTE5(vars50[0]), BYTE4(vars50[0]));\n      libmin_printf(\"\\n  Source Port: %u\\n\", WORD4(vars50[0]));\n      libmin_printf(\"  Destination Port: %u\\n\", WORD5(vars50[0]));\n      libmin_printf(\"  Protocol: %u\\n\", BYTE12(vars50[0]));\n      libmin_printf(\"  Payload: %s\\n\", (const char *)vars50 + 13);\n      libmin_printf(\"------------------------------\\n\");\n    }\n    if (v3 == 100) libmin_success();\n  }\n}", "binary": "packet-filter/packet-filter.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x2a,%edi\nlea    0x2f7c(%rip),%r15\npush   %r14\nlea    0x2ef5(%rip),%r14\npush   %r13\nlea    0x2efd(%rip),%r13\npush   %r12\nlea    0x2ed7(%rip),%r12\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0xb8,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0xa8(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbp\ncall   3940 <libmin_srand>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nmov    %rbp,%rdi\nadd    $0x1,%ebx\ncall   13d0 <generate_packet>\ncmpb   $0x6,0xc(%rsp)\njne    12a0 <main+0x1a0>\nmov    0x4(%rsp),%eax\nmov    %eax,%edx\nshr    $0x10,%edx\ncmp    $0xa8,%dl\njne    12a0 <main+0x1a0>\nshr    $0x18,%eax\ncmp    $0xc0,%eax\njne    12a0 <main+0x1a0>\nmov    %ebx,%esi\nmov    %r15,%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nmovdqa 0x10(%rsp),%xmm1\nmov    %r14,%rdi\nxor    %eax,%eax\nmovdqa (%rsp),%xmm0\nmovdqa 0x20(%rsp),%xmm2\nmovdqa 0x30(%rsp),%xmm3\nmovdqa 0x40(%rsp),%xmm4\nmovaps %xmm1,0x60(%rsp)\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm2,0x70(%rsp)\nmovaps %xmm3,0x80(%rsp)\nmovaps %xmm4,0x90(%rsp)\ncall   3730 <libmin_printf>\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nmov    0x50(%rsp),%eax\nmov    %r12,%rdi\nmov    %eax,%edx\nmov    %eax,%esi\nmovzbl %ah,%ecx\nmovzbl %al,%r8d\nshr    $0x10,%edx\nshr    $0x18,%esi\nxor    %eax,%eax\nmovzbl %dl,%edx\ncall   3730 <libmin_printf>\nlea    0x2e1a(%rip),%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nmov    0x54(%rsp),%eax\nmov    %r12,%rdi\nmov    %eax,%edx\nmov    %eax,%esi\nmovzbl %ah,%ecx\nmovzbl %al,%r8d\nshr    $0x10,%edx\nshr    $0x18,%esi\nxor    %eax,%eax\nmovzbl %dl,%edx\ncall   3730 <libmin_printf>\nmovzwl 0x58(%rsp),%esi\nlea    0x2df9(%rip),%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nmovzwl 0x5a(%rsp),%esi\nlea    0x2dfa(%rip),%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nmovzbl 0x5c(%rsp),%esi\nlea    0x2dff(%rip),%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nlea    0x2e01(%rip),%rdi\nlea    0x5d(%rsp),%rsi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nlea    0x2e17(%rip),%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x64,%ebx\njne    1158 <main+0x58>\ncall   3b90 <libmin_success>\nmov    0xa8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    12d5 <main+0x1d5>\nadd    $0xb8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "print_ip", "content": "// Helper function to print an IP address in dotted notation.\nvoid print_ip(unsigned int ip) {\n    libmin_printf(\"%u.%u.%u.%u\", \n           (ip >> 24) & 0xFF, \n           (ip >> 16) & 0xFF, \n           (ip >> 8) & 0xFF, \n           ip & 0xFF);\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O3.pseudo", "function_name": "print_ip", "address": "0x1550", "label": "print_ip", "content": "void __fastcall print_ip(unsigned int ip)\n{\n  libmin_printf(\"%u.%u.%u.%u\", HIBYTE(ip), BYTE2(ip), BYTE1(ip), (unsigned __int8)ip);\n}\n"}, "pseudo_normalize": "", "binary": "packet-filter/packet-filter.host.O3", "assembly": "<print_ip>:\nendbr64\nmov    %edi,%edx\nmov    %edi,%eax\nmov    %edi,%esi\nmovzbl %dil,%r8d\nshr    $0x10,%edx\nmovzbl %ah,%ecx\nshr    $0x18,%esi\nlea    0x2a96(%rip),%rdi\nmovzbl %dl,%edx\nxor    %eax,%eax\njmp    3730 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "print_packet", "content": "// Print the details of a packet.\nvoid print_packet(Packet pkt) {\n    libmin_printf(\"Packet Details:\\n\");\n    libmin_printf(\"  Source IP: \");\n    print_ip(pkt.src_ip);\n    libmin_printf(\"\\n  Destination IP: \");\n    print_ip(pkt.dest_ip);\n    libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n    libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n    libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n    libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n    libmin_printf(\"------------------------------\\n\");\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O3.pseudo", "function_name": "print_packet", "address": "0x1580", "label": "print_packet", "content": "void __cdecl print_packet(Packet pkt)\n{\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  libmin_printf(\"%u.%u.%u.%u\", HIBYTE(pkt.src_ip), BYTE2(pkt.src_ip), BYTE1(pkt.src_ip), LOBYTE(pkt.src_ip));\n  libmin_printf(\"\\n  Destination IP: \");\n  libmin_printf(\"%u.%u.%u.%u\", HIBYTE(pkt.dest_ip), BYTE2(pkt.dest_ip), BYTE1(pkt.dest_ip), LOBYTE(pkt.dest_ip));\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}\n"}, "pseudo_normalize": "void print_packet(Packet pkt) {\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  libmin_printf(\"%u.%u.%u.%u\", HIBYTE(pkt.src_ip), BYTE2(pkt.src_ip),\n                BYTE1(pkt.src_ip), LOBYTE(pkt.src_ip));\n  libmin_printf(\"\\n  Destination IP: \");\n  libmin_printf(\"%u.%u.%u.%u\", HIBYTE(pkt.dest_ip), BYTE2(pkt.dest_ip),\n                BYTE1(pkt.dest_ip), LOBYTE(pkt.dest_ip));\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}", "binary": "packet-filter/packet-filter.host.O3", "assembly": "<print_packet>:\nendbr64\npush   %rbp\nlea    0x2a84(%rip),%rdi\nxor    %eax,%eax\nlea    0x2a6f(%rip),%rbp\ncall   3730 <libmin_printf>\nlea    0x2a80(%rip),%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nmov    0x10(%rsp),%eax\nmov    %rbp,%rdi\nmov    %eax,%edx\nmov    %eax,%esi\nmovzbl %ah,%ecx\nmovzbl %al,%r8d\nshr    $0x10,%edx\nshr    $0x18,%esi\nxor    %eax,%eax\nmovzbl %dl,%edx\ncall   3730 <libmin_printf>\nlea    0x2a5e(%rip),%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nmov    0x14(%rsp),%eax\nmov    %rbp,%rdi\nmov    %eax,%edx\nmov    %eax,%esi\nmovzbl %ah,%ecx\nmovzbl %al,%r8d\nshr    $0x10,%edx\nshr    $0x18,%esi\nxor    %eax,%eax\nmovzbl %dl,%edx\ncall   3730 <libmin_printf>\nmovzwl 0x18(%rsp),%esi\nlea    0x2a3d(%rip),%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nmovzwl 0x1a(%rsp),%esi\nlea    0x2a3e(%rip),%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nmovzbl 0x1c(%rsp),%esi\nlea    0x2a43(%rip),%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nlea    0x1d(%rsp),%rsi\nlea    0x2a40(%rip),%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\nlea    0x2a5b(%rip),%rdi\nxor    %eax,%eax\ncall   3730 <libmin_printf>\npop    %rbp\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "parrondo/parrondo.c", "function_name": "cointoss", "content": "/* parrando.c: simulation of J. Parrando's probability paradox */\n\n\n/* Parrondo's game is based upon two simple games of chance.\n\n        The gambler's fortune starts at 0.\n\n\tThe simple game: Toss a biased coin and win +1 with probability\n\t\tS_WIN_PROB (defined below). Otherwise win -1; \n\n\tThe complex game: If the player's fortune is divisible by 3, toss\n\t\tthe \"bad coin\" having win probability BAD_WIN_PROB.\n\t\tIf the player's fortune is not divisible by 3 toss the\n                \"good coin\" having win probability GOOD_WIN_PROB.\n\n\tA game ends when the accumlated fortune exceeds MAX_FORTUNE ( a \"win\" )\n\tor dips below -MAX_FORTUNE ( a \"loss .)  \n\n\tThe numbers are chosen so that each game is quite unfavorable.\n        Remarkably, when the games are alternated at random, the resulting\n        game is quite favorable.\n\n\tThis program simulates many trials of a Parrondo game and reports\n        statistics on their outcomes. (It can also simulate the simple and\n        complex games individually.) The number of trials, fortune limits,\n        and a seed for the random number can be supplied on the command line.\n        The -h option prints detailed help. \n\n\tFor more information on Parrondo games and related phenomena see\n        J. Parrondo's website, http://seneca.fis.ucm.es/parr/,  or the\n        announcement in Nature magazine, 23/30, December 1999.\n*/\n\n/* compile: cc -o parrondo parrondo.c \n\n      Use -D_NO_RANDOM if your library doesn't have random/srandom. Most do,\n       \tbut the only truly portable RNG is rand/srand. Unfortunately it has\n        very poor performance, so you should use random if possible.\n\n      Use -D_MAX_RAND=  to set the size of the maximum value returned by\n         random(). The portable RNG rand() always returns a maximum of \n         RAND_MAX (defined in stdlib.h), but some implementations of random\n         do not use this value. Read the man page for random to be sure. A\n\t common value is 2^31-1 = 2147483647. In so, and this is not the\n         value of RAND_MAX on your system, you would compile with\n         -D_MAX_RAND=214748367.\n\n      Use -D_SHORT_STRINGS if your compiler does not support multiline\n          string constants.\n*/\n\n\n#include \"libmin.h\"\n\n#define VERSION \"1.1\"\n#define USAGE \"parrondo [ -s number -t number -m number -1 -2 -h -v]\"\n#ifndef _SHORT_STRINGS\n#define HELP \"parrondo [ -s number -t number -m number -1 -2 ]\\n\\n\\\nPrint information on simulations of Parrondo's paradoxical game.\\n\\n\\\n-s: Use next argument as RNG seed. (otherwise use system time as seed.)\\n\\\n-t: Use next argument as number of trials. Default 10000.\\n\\\n-m: Use number as max fortune (win), -number as min fortune(loss). Default 50. \\n\\\n-v: Print version number and exit. \\n\\\n-h: Print this helpful information. \\n\\\n-1: Simulate simple game alone.\\n\\\n-2: Simulate complex game alone.\\n\\n\"\n#else\n#define HELP USAGE\n#endif\n\n/* Default values */\n#define MAX_FORTUNE 50\n#define MAX_ITERATIONS 1000000L\n#define TRIALS 1000\n#define INITIAL_SEED 3445\n#ifndef _MAX_RAND\n#define _MAX_RAND RAND_MAX\n#endif\n\n/* See above for meaning of these */\n#define S_WIN_PROB .495\n#define BAD_WIN_PROB .095\n#define GOOD_WIN_PROB .745\n\n\n/* return -1 or +1 according as a simulated coin toss is heads (+1) or\n   tails (-1). Take p as probability of heads.\n*/\n\nint\ncointoss(double p)\n{\n\n\tdouble U;   /* U(0,1) random variable */\n\n\tU = ((double)libmin_rand())/((double)_MAX_RAND);\n\treturn U >= p ? -1 : 1;\n}\n"}, "pseudo": {"path": "parrondo/parrondo.host.O3.pseudo", "function_name": "cointoss", "address": "0x17a0", "label": "cointoss", "content": "__int64 __fastcall cointoss(double a1, double p)\n{\n  return (double)(int)libmin_rand() / 2147483647.0 < a1 ? 1 : -1;\n}\n"}, "pseudo_normalize": "", "binary": "parrondo/parrondo.host.O3", "assembly": "<cointoss>:\nendbr64\nsub    $0x18,%rsp\nmovsd  %xmm0,0x8(%rsp)\ncall   3d90 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2c82(%rip),%xmm0\ncomisd 0x8(%rsp),%xmm0\nsbb    %eax,%eax\nadd    $0x18,%rsp\nand    $0x2,%eax\nsub    $0x1,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "parrondo/parrondo.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tlong n=0L;\n\tdouble n_bar,n_tot=0.0;\n\tint trials = TRIALS;\n\tint i=0,j=0,m;\n\tint win_count = 0;\n\tint loss_count = 0;\n\tlong site_visits[3];  /* counts visits to numbers mod 3 */\n\tint fortune = 0;\n\tint max_fortune = MAX_FORTUNE;\n\tdouble game_select = 0.5;  /* Governs a coin toss below which selects\n                                      between games. Setting this to 1.0 chooses\n\t\t\t\t      complex game only. Setting to 0.0 chooses\n                                      simple game only. \n\t\t\t\t   */\n                                      \n\tlong seed=0;\n\n\t/* Process command line */\n\twhile(++j < argc){\n\t\tif(argv[j][0] == '-')\n\t\t\tswitch(argv[j][1]){ \n\t\t\t\tcase 's':\n\t\t\t\tcase 'S':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\tseed = libmin_atol(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 't':\n\t\t\t\tcase 'T':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\ttrials = libmin_atoi(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\t\n\t\t\t\tcase 'm':\n\t\t\t\tcase 'M':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\tmax_fortune = libmin_atoi(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'v':\n\t\t\t\tcase 'V':\n\t\t\t\t\tlibmin_printf(\"%s\\n\", VERSION);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '?':\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'H':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",HELP);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '1':\n\t\t\t\t\tgame_select = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tgame_select = 1.0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlibmin_printf(\"parrondo: unkown option %s\\n\",\n\t\t\t\t\t\targv[j]);\n\t\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\telse {\n\t\t\tlibmin_printf(\"%s\\n\", USAGE);\n\t\t\tlibmin_fail(1);\n\t\t}\n\t}\n \n\t/* If no seed is supplied, then use current system time */\n\t\n\tif(!seed)\n  {\n\t\t\tseed = INITIAL_SEED; /* if all else fails */\n\t\t\tlibmin_printf(\"Using seed = %d\\n\",INITIAL_SEED);\n  }\n\t\t\n\tlibmin_srand((int)seed);\n\tfor(i=0;i<3;i++)site_visits[i] = 0L;  /* initialize counters */\n\ti=0;\n\tlibmin_printf(\"Simulating %d trials ...\\n\",trials);\n\twhile(i<trials){   /* Loop over trials */\n\n\t\t/* reseed */\n\t\tseed = libmin_rand();\n\t\tlibmin_srand((int)seed);\n\n\t\t/* Each trial: loop until fortune goes out of range */\n\t\tfortune = 0;\n\t\twhile(n++<MAX_ITERATIONS){\n\t\t\tif(cointoss(game_select) == 1)\n\t\t\t\tfortune += play_c(fortune);\n\t\t\telse\n\t\t\t\tfortune += play_s();\n\t\t\tif((fortune >= max_fortune)||(fortune <= -max_fortune))\n\t\t\t\tbreak;\n\n\t\t\tm = fortune > 0 ? fortune : -fortune;\n\t\t\tsite_visits[m%3]++;\t\n\t\t}\n\n\t\tif(fortune == max_fortune)\n\t\t\twin_count++;\n\t\telse if(fortune == -max_fortune)\n\t\t\tloss_count++;\n\n\t\ti++;\n\t\tn_tot += (double)n;\n\t\tn = 0L;\n\t\t\n\t}\n\n\tn_bar = n_tot/((double)i);\n\n\t/* Print stuff out */\n\n\tlibmin_printf(\"%d wins, %d losses, %d draws\\n\",win_count,\n\t\t\tloss_count, i-(win_count+loss_count));\n\tlibmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\",\n\t\t\tmax_fortune,max_fortune,MAX_ITERATIONS);\n\tlibmin_printf(\"Average trial length = %lf\\n\",n_bar);\n\tlibmin_printf(\"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n\t\t100.0*((double)site_visits[0])/n_tot,\n\t\t100.0*((double)site_visits[1])/n_tot,\n\t\t100.0*((double)site_visits[2])/n_tot\n\t);\n\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "parrondo/parrondo.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ecx\n  int v4; // r13d\n  int v5; // ebp\n  int v6; // r8d\n  int v7; // r14d\n  char *v8; // rsi\n  int v9; // r13d\n  unsigned int v10; // eax\n  __int64 v11; // rbx\n  int v12; // r15d\n  bool v13; // zf\n  int v14; // eax\n  unsigned int v15; // ecx\n  int v16; // eax\n  double v17; // xmm0_8\n  double v18; // xmm0_8\n  int v19; // r8d\n  int v20; // eax\n  int v21; // r8d\n  int v22; // eax\n  int v23; // r8d\n  __int64 v24; // rax\n  double game_select; // [rsp+0h] [rbp-78h]\n  __int64 seed; // [rsp+8h] [rbp-70h]\n  double seeda; // [rsp+8h] [rbp-70h]\n  int loss_count; // [rsp+10h] [rbp-68h]\n  int loss_counta; // [rsp+10h] [rbp-68h]\n  int loss_countb; // [rsp+10h] [rbp-68h]\n  int loss_countc; // [rsp+10h] [rbp-68h]\n  int win_count; // [rsp+14h] [rbp-64h]\n  __int64 site_visits[3]; // [rsp+20h] [rbp-58h] BYREF\n  unsigned __int64 v35; // [rsp+38h] [rbp-40h]\n\n  v3 = ::argc;\n  v35 = __readfsqword(0x28u);\n  if ( ::argc <= 1 )\n  {\n    v5 = 50;\n    v7 = 1000;\n    game_select = 0.5;\nLABEL_43:\n    libmin_printf(\"Using seed = %d\\n\", 3445);\n    libmin_srand(0xD75u);\n  }\n  else\n  {\n    v4 = 1;\n    v5 = 50;\n    seed = 0LL;\n    v6 = 0;\n    v7 = 1000;\n    game_select = 0.5;\n    while ( 2 )\n    {\n      v8 = ::argv[v4];\n      if ( *v8 != 45 )\n      {\n        libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\nLABEL_6:\n        libmin_fail(1);\n      }\n      switch ( v8[1] )\n      {\n        case '1':\n          v6 = v4;\n          game_select = 0.0;\n          goto LABEL_7;\n        case '2':\n          v6 = v4;\n          game_select = 1.0;\n          goto LABEL_7;\n        case '?':\n        case 'H':\n        case 'h':\n          libmin_printf(\n            (char *)\"%s\\n\",\n            \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n            \"\\n\"\n            \"Print information on simulations of Parrondo's paradoxical game.\\n\"\n            \"\\n\"\n            \"-s: Use next argument as RNG seed. (otherwise use system time as seed.)\\n\"\n            \"-t: Use next argument as number of trials. Default 10000.\\n\"\n            \"-m: Use number as max fortune (win), -number as min fortune(loss). Default 50. \\n\"\n            \"-v: Print version number and exit. \\n\"\n            \"-h: Print this helpful information. \\n\"\n            \"-1: Simulate simple game alone.\\n\"\n            \"-2: Simulate complex game alone.\\n\"\n            \"\\n\");\n          libmin_success();\n        case 'M':\n        case 'm':\n          v19 = v6 + 2;\n          if ( v19 >= v3 )\n          {\n            libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          loss_counta = v19;\n          v20 = libmin_atoi(::argv[v19]);\n          v3 = ::argc;\n          v6 = loss_counta;\n          v5 = v20;\n          goto LABEL_7;\n        case 'S':\n        case 's':\n          v23 = v6 + 2;\n          if ( v23 >= v3 )\n          {\n            libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          loss_countc = v23;\n          v24 = libmin_atol(::argv[v23]);\n          v3 = ::argc;\n          v6 = loss_countc;\n          seed = v24;\n          goto LABEL_7;\n        case 'T':\n        case 't':\n          v21 = v6 + 2;\n          if ( v21 >= v3 )\n          {\n            libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          loss_countb = v21;\n          v22 = libmin_atoi(::argv[v21]);\n          v3 = ::argc;\n          v6 = loss_countb;\n          v7 = v22;\nLABEL_7:\n          v4 = v6 + 1;\n          if ( v3 > v6 + 1 )\n            continue;\n          if ( !seed )\n            goto LABEL_43;\n          libmin_srand(seed);\n          break;\n        case 'V':\n        case 'v':\n          libmin_printf((char *)\"%s\\n\", \"1.1\");\n          libmin_success();\n        default:\n          libmin_printf(\"parrondo: unkown option %s\\n\", v8);\n          goto LABEL_6;\n      }\n      break;\n    }\n  }\n  memset(site_visits, 0, sizeof(site_visits));\n  libmin_printf(\"Simulating %d trials ...\\n\", v7);\n  loss_count = 0;\n  win_count = 0;\n  if ( v7 <= 0 )\n  {\n    v7 = 0;\n    seeda = 0.0;\n    v18 = 0.0;\n    goto LABEL_26;\n  }\n  v9 = 0;\n  seeda = 0.0;\nLABEL_12:\n  v10 = libmin_rand();\n  v11 = 1LL;\n  v12 = 0;\n  libmin_srand(v10);\n  while ( 1 )\n  {\n    if ( (double)(int)libmin_rand() / 2147483647.0 >= game_select )\n    {\n      v12 = v12 + ((double)(int)libmin_rand() / 2147483647.0 < 0.495 ? 2 : 0) - 1;\n      v13 = v12 == v5;\n      if ( v12 >= v5 )\n        goto LABEL_23;\n      goto LABEL_14;\n    }\n    if ( (unsigned int)(-1431655765 * v12 + 715827882) > 0x55555554 )\n    {\n      if ( (double)(int)libmin_rand() / 2147483647.0 >= 0.745 )\n      {\nLABEL_21:\n        v16 = -1;\n        goto LABEL_22;\n      }\n    }\n    else if ( (double)(int)libmin_rand() / 2147483647.0 >= 0.095 )\n    {\n      goto LABEL_21;\n    }\n    v16 = 1;\nLABEL_22:\n    v12 += v16;\n    v13 = v12 == v5;\n    if ( v12 >= v5 )\n    {\nLABEL_23:\n      v17 = (double)(int)v11;\n      if ( v13 )\n      {\n        ++win_count;\n        goto LABEL_25;\n      }\n      v14 = -v5;\n      goto LABEL_39;\n    }\nLABEL_14:\n    v14 = -v5;\n    if ( -v5 >= v12 )\n    {\n      v17 = (double)(int)v11;\nLABEL_39:\n      loss_count += v14 == v12;\n      goto LABEL_25;\n    }\n    v15 = -v12;\n    if ( v12 > 0 )\n      v15 = v12;\n    ++v11;\n    ++site_visits[v15 % 3];\n    if ( v11 == 1000001 )\n    {\n      v17 = 1000001.0;\nLABEL_25:\n      v18 = v17 + seeda;\n      ++v9;\n      seeda = v18;\n      if ( v9 == v7 )\n      {\nLABEL_26:\n        libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count, v7 - (loss_count + win_count));\n        libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\", v5, v5, 1000000LL);\n        libmin_printf(\"Average trial length = %lf\\n\", v18 / (double)v7);\n        libmin_printf(\n          \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n          (double)SLODWORD(site_visits[0]) * 100.0 / seeda,\n          (double)SLODWORD(site_visits[1]) * 100.0 / seeda,\n          (double)SLODWORD(site_visits[2]) * 100.0 / seeda);\n        libmin_success();\n      }\n      goto LABEL_12;\n    }\n  }\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  char *v8;\n  int v9;\n  unsigned int v10;\n  long long v11;\n  int v12;\n  bool v13;\n  int v14;\n  unsigned int v15;\n  int v16;\n  double v17;\n  double v18;\n  int v19;\n  int v20;\n  int v21;\n  int v22;\n  int v23;\n  long long v24;\n  double game_select;\n  long long seed;\n  double seeda;\n  int loss_count;\n  int loss_counta;\n  int loss_countb;\n  int loss_countc;\n  int win_count;\n  long long site_visits[3];\n  unsigned long long v35;\n  v3 = ::argc;\n  v35 = __readfsqword(40u);\n  if (::argc <= 1) {\n    v5 = 50;\n    v7 = 1000;\n    game_select = 0.5;\n  LABEL_43:\n    libmin_printf(\"Using seed = %d\\n\", 3445);\n    libmin_srand(3445u);\n  } else {\n    v4 = 1;\n    v5 = 50;\n    seed = 0LL;\n    v6 = 0;\n    v7 = 1000;\n    game_select = 0.5;\n    while (2) {\n      v8 = ::argv[v4];\n      if (*v8 != 45) {\n        libmin_printf((char *)\"%s\\n\",\n                      \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n      LABEL_6:\n        libmin_fail(1);\n      }\n      switch (v8[1]) {\n        case '1':\n          v6 = v4;\n          game_select = 0.0;\n          goto LABEL_7;\n        case '2':\n          v6 = v4;\n          game_select = 1.0;\n          goto LABEL_7;\n        case '?':\n        case 'H':\n        case 'h':\n          libmin_printf(\n              (char *)\"%s\\n\",\n              \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n              \"\\n\"\n              \"Print information on simulations of Parrondo's paradoxical \"\n              \"game.\\n\"\n              \"\\n\"\n              \"-s: Use next argument as RNG seed. (otherwise use system time \"\n              \"as seed.)\\n\"\n              \"-t: Use next argument as number of trials. Default 10000.\\n\"\n              \"-m: Use number as max fortune (win), -number as min \"\n              \"fortune(loss). Default 50. \\n\"\n              \"-v: Print version number and exit. \\n\"\n              \"-h: Print this helpful information. \\n\"\n              \"-1: Simulate simple game alone.\\n\"\n              \"-2: Simulate complex game alone.\\n\"\n              \"\\n\");\n          libmin_success();\n        case 'M':\n        case 'm':\n          v19 = v6 + 2;\n          if (v19 >= v3) {\n            libmin_printf(\n                (char *)\"%s\\n\",\n                \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          loss_counta = v19;\n          v20 = libmin_atoi(::argv[v19]);\n          v3 = ::argc;\n          v6 = loss_counta;\n          v5 = v20;\n          goto LABEL_7;\n        case 'S':\n        case 's':\n          v23 = v6 + 2;\n          if (v23 >= v3) {\n            libmin_printf(\n                (char *)\"%s\\n\",\n                \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          loss_countc = v23;\n          v24 = libmin_atol(::argv[v23]);\n          v3 = ::argc;\n          v6 = loss_countc;\n          seed = v24;\n          goto LABEL_7;\n        case 'T':\n        case 't':\n          v21 = v6 + 2;\n          if (v21 >= v3) {\n            libmin_printf(\n                (char *)\"%s\\n\",\n                \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          loss_countb = v21;\n          v22 = libmin_atoi(::argv[v21]);\n          v3 = ::argc;\n          v6 = loss_countb;\n          v7 = v22;\n        LABEL_7:\n          v4 = v6 + 1;\n          if (v3 > v6 + 1) continue;\n          if (!seed) goto LABEL_43;\n          libmin_srand(seed);\n          break;\n        case 'V':\n        case 'v':\n          libmin_printf((char *)\"%s\\n\", \"1.1\");\n          libmin_success();\n        default:\n          libmin_printf(\"parrondo: unkown option %s\\n\", v8);\n          goto LABEL_6;\n      }\n      break;\n    }\n  }\n  memset(site_visits, 0, sizeof(site_visits));\n  libmin_printf(\"Simulating %d trials ...\\n\", v7);\n  loss_count = 0;\n  win_count = 0;\n  if (v7 <= 0) {\n    v7 = 0;\n    seeda = 0.0;\n    v18 = 0.0;\n    goto LABEL_26;\n  }\n  v9 = 0;\n  seeda = 0.0;\nLABEL_12:\n  v10 = libmin_rand();\n  v11 = 1LL;\n  v12 = 0;\n  libmin_srand(v10);\n  while (1) {\n    if ((double)(int)libmin_rand() / 2147483647.0 >= game_select) {\n      v12 =\n          v12 + ((double)(int)libmin_rand() / 2147483647.0 < 0.495 ? 2 : 0) - 1;\n      v13 = v12 == v5;\n      if (v12 >= v5) goto LABEL_23;\n      goto LABEL_14;\n    }\n    if ((unsigned int)(-1431655765 * v12 + 715827882) > 1431655764) {\n      if ((double)(int)libmin_rand() / 2147483647.0 >= 0.745) {\n      LABEL_21:\n        v16 = -1;\n        goto LABEL_22;\n      }\n    } else if ((double)(int)libmin_rand() / 2147483647.0 >= 0.095) {\n      goto LABEL_21;\n    }\n    v16 = 1;\n  LABEL_22:\n    v12 += v16;\n    v13 = v12 == v5;\n    if (v12 >= v5) {\n    LABEL_23:\n      v17 = (double)(int)v11;\n      if (v13) {\n        ++win_count;\n        goto LABEL_25;\n      }\n      v14 = -v5;\n      goto LABEL_39;\n    }\n  LABEL_14:\n    v14 = -v5;\n    if (-v5 >= v12) {\n      v17 = (double)(int)v11;\n    LABEL_39:\n      loss_count += v14 == v12;\n      goto LABEL_25;\n    }\n    v15 = -v12;\n    if (v12 > 0) v15 = v12;\n    ++v11;\n    ++site_visits[v15 % 3];\n    if (v11 == 1000001) {\n      v17 = 1000001.0;\n    LABEL_25:\n      v18 = v17 + seeda;\n      ++v9;\n      seeda = v18;\n      if (v9 == v7) {\n      LABEL_26:\n        libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count,\n                      v7 - (loss_count + win_count));\n        libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\",\n                      v5, v5, 1000000LL);\n        libmin_printf(\"Average trial length = %lf\\n\", v18 / (double)v7);\n        libmin_printf(\n            \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n            (double)SLODWORD(site_visits[0]) * 100.0 / seeda,\n            (double)SLODWORD(site_visits[1]) * 100.0 / seeda,\n            (double)SLODWORD(site_visits[2]) * 100.0 / seeda);\n        libmin_success();\n      }\n      goto LABEL_12;\n    }\n  }\n}", "binary": "parrondo/parrondo.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    0x5ef8(%rip),%ecx\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\ncmp    $0x1,%ecx\njle    15ae <main+0x4ae>\nmovsd  0x332f(%rip),%xmm7\nmov    $0x1,%r13d\nmov    $0x32,%ebp\nmovq   $0x0,0x8(%rsp)\nxor    %r8d,%r8d\nmov    $0x3e8,%r14d\nlea    0x5ec3(%rip),%rbx\nmovsd  %xmm7,(%rsp)\npxor   %xmm7,%xmm7\nlea    0x2e9b(%rip),%r15\nlea    0x3138(%rip),%r12\nmovsd  %xmm7,0x18(%rsp)\nnopw   0x0(%rax,%rax,1)\nmovslq %r13d,%rax\nmov    (%rbx,%rax,8),%rsi\ncmpb   $0x2d,(%rsi)\njne    1570 <main+0x470>\nmovzbl 0x1(%rsi),%eax\nsub    $0x31,%eax\ncmp    $0x45,%al\nja     11af <main+0xaf>\nlea    0x318a(%rip),%rdx\nmovzbl %al,%eax\nmovslq (%rdx,%rax,4),%rax\nadd    %rdx,%rax\nnotrack jmp *%rax\nlea    0x30de(%rip),%rdi\ncs nopw 0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   3b20 <libmin_printf>\nmov    $0x1,%edi\ncall   1c10 <libmin_fail>\nmov    0x5e39(%rip),%ecx\nmov    %r13d,%r8d\nlea    0x1(%r8),%r13d\ncmp    %r13d,%ecx\njg     1180 <main+0x80>\ncmpq   $0x0,0x8(%rsp)\nje     15d0 <main+0x4d0>\nmov    0x8(%rsp),%edi\ncall   3d30 <libmin_srand>\npxor   %xmm0,%xmm0\nmov    %r14d,%esi\nxor    %eax,%eax\nlea    0x30b9(%rip),%rdi\nmovaps %xmm0,0x20(%rsp)\nmovq   $0x0,0x30(%rsp)\ncall   3b20 <libmin_printf>\nmovl   $0x0,0x10(%rsp)\nmovl   $0x0,0x14(%rsp)\ntest   %r14d,%r14d\njle    168b <main+0x58b>\nmovsd  0x18(%rsp),%xmm3\nxor    %r13d,%r13d\nmovsd  %xmm3,0x8(%rsp)\nnopl   0x0(%rax,%rax,1)\ncall   3d90 <libmin_rand>\nmov    $0x1,%ebx\nxor    %r15d,%r15d\nmov    $0xaaaaaaab,%r12d\nmov    %eax,%edi\ncall   3d30 <libmin_srand>\njmp    12db <main+0x1db>\nnopl   0x0(%rax)\ncall   3d90 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x31c8(%rip),%xmm0\ncomisd 0x31c8(%rip),%xmm0\nsbb    %eax,%eax\nand    $0x2,%eax\nlea    -0x1(%r15,%rax,1),%r15d\ncmp    %ebp,%r15d\njge    134c <main+0x24c>\nmov    %ebp,%eax\nneg    %eax\ncmp    %r15d,%eax\njge    1580 <main+0x480>\nmov    %r15d,%ecx\nneg    %ecx\ncmovs  %r15d,%ecx\nadd    $0x1,%rbx\nmov    %ecx,%eax\nimul   %r12,%rax\nshr    $0x21,%rax\nlea    (%rax,%rax,2),%esi\nmov    %ecx,%eax\nsub    %esi,%eax\ncltq\naddq   $0x1,0x20(%rsp,%rax,8)\ncmp    $0xf4241,%rbx\nje     15a1 <main+0x4a1>\ncall   3d90 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x3155(%rip),%xmm0\ncomisd (%rsp),%xmm0\njae    1268 <main+0x168>\nimul   $0xaaaaaaab,%r15d,%eax\nadd    $0x2aaaaaaa,%eax\ncmp    $0x55555554,%eax\nja     1538 <main+0x438>\ncall   3d90 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x311b(%rip),%xmm0\ncomisd 0x312b(%rip),%xmm0\njb     155e <main+0x45e>\nmov    $0xffffffff,%eax\nadd    %eax,%r15d\ncmp    %ebp,%r15d\njl     129b <main+0x19b>\npxor   %xmm0,%xmm0\ncvtsi2sd %rbx,%xmm0\njne    159b <main+0x49b>\naddl   $0x1,0x14(%rsp)\naddsd  0x8(%rsp),%xmm0\nadd    $0x1,%r13d\nmovsd  %xmm0,0x8(%rsp)\ncmp    %r14d,%r13d\njne    1248 <main+0x148>\npxor   %xmm1,%xmm1\nmov    0x14(%rsp),%esi\nmov    0x10(%rsp),%edx\nmov    %r14d,%ecx\ncvtsi2sd %r14d,%xmm1\nlea    0x2f47(%rip),%rdi\nmov    %esi,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nxor    %eax,%eax\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rsp)\ncall   3b20 <libmin_printf>\nmov    $0xf4240,%ecx\nmov    %ebp,%edx\nmov    %ebp,%esi\nlea    0x2e5e(%rip),%rdi\nxor    %eax,%eax\ncall   3b20 <libmin_printf>\nmovsd  (%rsp),%xmm0\nmov    $0x1,%eax\nlea    0x2f27(%rip),%rdi\ncall   3b20 <libmin_printf>\npxor   %xmm2,%xmm2\npxor   %xmm1,%xmm1\npxor   %xmm0,%xmm0\ncvtsi2sdq 0x30(%rsp),%xmm2\nmovsd  0x308e(%rip),%xmm3\nmovsd  0x8(%rsp),%xmm6\nlea    0x2e51(%rip),%rdi\ncvtsi2sdq 0x28(%rsp),%xmm1\nmov    $0x3,%eax\ncvtsi2sdq 0x20(%rsp),%xmm0\nmulsd  %xmm3,%xmm2\nmulsd  %xmm3,%xmm1\nmulsd  %xmm3,%xmm0\ndivsd  %xmm6,%xmm2\ndivsd  %xmm6,%xmm0\ndivsd  %xmm6,%xmm1\ncall   3b20 <libmin_printf>\ncall   3f80 <libmin_success>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    16a3 <main+0x5a3>\nadd    $0x48,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x2e30(%rip),%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3b20 <libmin_printf>\ncall   3f80 <libmin_success>\nlea    0x2bca(%rip),%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3b20 <libmin_printf>\ncall   3f80 <libmin_success>\nmovsd  0x18(%rsp),%xmm7\nmov    0x5b7f(%rip),%ecx\nmov    %r13d,%r8d\nmovsd  %xmm7,(%rsp)\njmp    11da <main+0xda>\nadd    $0x2,%r8d\ncmp    %ecx,%r8d\njge    1617 <main+0x517>\nmovslq %r8d,%rax\nmov    %r8d,0x10(%rsp)\nmov    (%rbx,%rax,8),%rdi\ncall   1a80 <libmin_atoi>\nmov    0x5b4e(%rip),%ecx\nmov    0x10(%rsp),%r8d\nmov    %eax,%ebp\njmp    11da <main+0xda>\nadd    $0x2,%r8d\ncmp    %ecx,%r8d\njge    163d <main+0x53d>\nmovslq %r8d,%rax\nmov    %r8d,0x10(%rsp)\nmov    (%rbx,%rax,8),%rdi\ncall   1a80 <libmin_atoi>\nmov    0x5b1e(%rip),%ecx\nmov    0x10(%rsp),%r8d\nmov    %eax,%r14d\njmp    11da <main+0xda>\nadd    $0x2,%r8d\ncmp    %ecx,%r8d\njge    15f1 <main+0x4f1>\nmovslq %r8d,%rax\nmov    %r8d,0x10(%rsp)\nmov    (%rbx,%rax,8),%rdi\ncall   1b30 <libmin_atol>\nmov    0x5aed(%rip),%ecx\nmov    0x10(%rsp),%r8d\nmov    %rax,0x8(%rsp)\njmp    11da <main+0xda>\nnopw   0x0(%rax,%rax,1)\ncall   3d90 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2ef8(%rip),%xmm0\ncomisd 0x2f00(%rip),%xmm0\njae    133b <main+0x23b>\nmov    $0x1,%eax\njmp    1340 <main+0x240>\nnopl   0x0(%rax,%rax,1)\nmov    %r15,%rsi\nmov    %r12,%rdi\njmp    11c0 <main+0xc0>\nnopl   0x0(%rax,%rax,1)\npxor   %xmm0,%xmm0\ncvtsi2sd %rbx,%xmm0\ncmp    %r15d,%eax\nsete   %al\nmovzbl %al,%eax\nadd    %eax,0x10(%rsp)\njmp    1360 <main+0x260>\nmov    %ebp,%eax\nneg    %eax\njmp    1589 <main+0x489>\nmovsd  0x2ecf(%rip),%xmm0\njmp    1360 <main+0x260>\npxor   %xmm2,%xmm2\nmovsd  0x2eae(%rip),%xmm7\nmov    $0x32,%ebp\nmov    $0x3e8,%r14d\nmovsd  %xmm2,0x18(%rsp)\nmovsd  %xmm7,(%rsp)\nmov    $0xd75,%esi\nlea    0x2cd4(%rip),%rdi\nxor    %eax,%eax\ncall   3b20 <libmin_printf>\nmovq   $0xd75,0x8(%rsp)\njmp    11ef <main+0xef>\nmov    %r15,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\nmov    %r8d,0x8(%rsp)\ncall   3b20 <libmin_printf>\nmov    $0x1,%edi\ncall   1c10 <libmin_fail>\nmov    0x8(%rsp),%r8d\njmp    150c <main+0x40c>\nmov    %r15,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\nmov    %r8d,0x10(%rsp)\ncall   3b20 <libmin_printf>\nmov    $0x1,%edi\ncall   1c10 <libmin_fail>\nmov    0x10(%rsp),%r8d\njmp    14ab <main+0x3ab>\nmov    %r15,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\nmov    %r8d,0x10(%rsp)\ncall   3b20 <libmin_printf>\nmov    $0x1,%edi\ncall   1c10 <libmin_fail>\nmov    0x10(%rsp),%r8d\njmp    14db <main+0x3db>\nmovsd  0x2e05(%rip),%xmm2\nmov    %r13d,%r8d\nmovsd  %xmm2,(%rsp)\njmp    11da <main+0xda>\nmovsd  0x18(%rsp),%xmm2\nmov    %r13d,%r8d\nmovsd  %xmm2,(%rsp)\njmp    11da <main+0xda>\nmovsd  0x18(%rsp),%xmm7\nxor    %r14d,%r14d\nmovsd  %xmm7,0x8(%rsp)\nmovapd %xmm7,%xmm0\njmp    1379 <main+0x279>\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "parrondo/parrondo.c", "function_name": "play_c", "content": "/* One play of the complicated game: +1 if win, -1 if loss. */\n\nint play_c(int fortune)\n{\n\n\tif( fortune % 3 )\n\t\treturn cointoss(GOOD_WIN_PROB);\n\treturn cointoss(BAD_WIN_PROB);\n}\n"}, "pseudo": {"path": "parrondo/parrondo.host.O3.pseudo", "function_name": "play_c", "address": "0x1820", "label": "play_c", "content": "int __fastcall play_c(int fortune)\n{\n  if ( (unsigned int)(-1431655765 * fortune + 715827882) > 0x55555554 )\n  {\n    if ( (double)(int)libmin_rand() / 2147483647.0 < 0.745 )\n      return 1;\n  }\n  else if ( (double)(int)libmin_rand() / 2147483647.0 < 0.095 )\n  {\n    return 1;\n  }\n  return -1;\n}\n"}, "pseudo_normalize": "int play_c(int fortune) {\n  if ((unsigned int)(-1431655765 * fortune + 715827882) > 1431655764) {\n    if ((double)(int)libmin_rand() / 2147483647.0 < 0.745) return 1;\n  } else if ((double)(int)libmin_rand() / 2147483647.0 < 0.095) {\n    return 1;\n  }\n  return -1;\n}", "binary": "parrondo/parrondo.host.O3", "assembly": "<play_c>:\nendbr64\nimul   $0xaaaaaaab,%edi,%edi\nsub    $0x8,%rsp\nadd    $0x2aaaaaaa,%edi\ncmp    $0x55555554,%edi\nja     1870 <play_c+0x50>\ncall   3d90 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2bf4(%rip),%xmm0\ncomisd 0x2c04(%rip),%xmm0\njae    1892 <play_c+0x72>\nmov    $0x1,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\ncall   3d90 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2bc0(%rip),%xmm0\ncomisd 0x2bc8(%rip),%xmm0\njb     185e <play_c+0x3e>\nmov    $0xffffffff,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "parrondo/parrondo.c", "function_name": "play_s", "content": " \n\n/* One play of the simple game: +1 if win, -1 if loss. */\n\nint play_s(void)\n{\n\treturn cointoss(S_WIN_PROB);\n\t\t\n}\n"}, "pseudo": {"path": "parrondo/parrondo.host.O3.pseudo", "function_name": "play_s", "address": "0x17e0", "label": "play_s", "content": "int __cdecl play_s()\n{\n  return (double)(int)libmin_rand() / 2147483647.0 < 0.495 ? 1 : -1;\n}\n"}, "pseudo_normalize": "", "binary": "parrondo/parrondo.host.O3", "assembly": "<play_s>:\nendbr64\nsub    $0x8,%rsp\ncall   3d90 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2c48(%rip),%xmm0\ncomisd 0x2c48(%rip),%xmm0\nsbb    %eax,%eax\nadd    $0x8,%rsp\nand    $0x2,%eax\nsub    $0x1,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "pascal/pascal.c", "function_name": "main", "content": "int main(void)\n{\n\tint argc=1; char **argv=NULL;\n\tint i=1,j;\n\tint cols_option = FALSE;\n\tint nrows;\n\tint max_width;\n\tint row_offset;\n\n\t/* Process command line */\n\t\n\twhile(((i+1)<=argc)&&(argv[i][0] == '-')){\n\t\tif(argv[i][1] == 'h'){\n\t\t\tlibmin_printf(HELP);\n\t\t\treturn 0;\n\t\t}\n\t\tif(argv[i][1] == 'v'){\n\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\treturn 0;\n\t\t}\n\t\tif(argv[i][1]=='c'){\n\t\t\t/* make sure there is an arg */\n\t\t\tif((i+1) >= argc){\n\t\t\t\tlibmin_printf(USAGE);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcols_option = TRUE;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Unknown option if we got to here */\n\t\tlibmin_printf(USAGE);\n\t\treturn 1;\n\t}\n\n\t/* Make sure there is one arg left */\n\n\tif((i+1) != argc){ \n\t  nrows = 20;\n\t}\n\telse\n\t  nrows = libmin_atoi(argv[i]);\n\n\t/* Sanity checks */\n\tif(nrows == 0){ \n\t\tif(cols_option)\n\t\t  libmin_printf(\"0\\n\");\n\t\tlibmin_success(); /* nothing to do */\n\t}\n\tif(nrows < 0){\n\t\tlibmin_printf(\"%s: %d is an invalid number of rows\\n\", PROGRAM_NAME,nrows);\n\t\tlibmin_fail(1);\n\t}\n\tif(nrows > MAX_ROWS){\n\t\tlibmin_printf(\"%s: %d > %d rows maximum\\n\",PROGRAM_NAME,nrows, MAX_ROWS);\n\t\tlibmin_fail(1);\n\t}\n\n\t/* build the triangle */\n\t\n\ttriangle[0][0] = 1;\n\tfor(i=1;i<nrows;i++){\n\t\ttriangle[i][0] = 1;\n\t\tfor(j=1;j<i;j++)\n\t\t\ttriangle[i][j] = triangle[i-1][j-1]\n\t\t\t\t+ triangle[i-1][j];\n\t\ttriangle[i][i] = 1;\n\t}\n\n\t/* Find the widest number in table. It's the middle one in\n           the bottom row */\n\n\tmax_width = num_digits(triangle[nrows-1][nrows/2]);\n\n\t/* make sure this value is even */\n\tif(max_width % 2) max_width++;\n\n\t/* Since each number is printed in a field max_width+2 wide\n\t   and there are nrows numbers in the longest (bottom) row\n           the number of columns needed for the display is\n           (max_width+2)*nrows */\n\n\tif(cols_option){\n\t\t\tlibmin_printf(\"%d\\n\",(max_width + 2)*nrows);\n\t\t\tlibmin_success();\n\t}\n\t   \n\t/* Now print everything out */ \n\n\tfor(i=0;i<nrows;i++){\n\n\t\t/* This is the only tricky part. Think of each number as\n                   being printed in the center of a brick. Each brick has\n                   width max_width/2 + 1. Going down one row, the bricks\n                   move over one half width */\n\n\t\trow_offset = (nrows-i-1)*(max_width/2+1);\n\n\t\t/* Move first row in deepest, etc., by printing the approp.\n                   number of leading blanks */\n\n\t\tfor(j=0;j<row_offset;j++)\n\t\t  libmin_printf(\" \");\n\n\t\t/* Print ith row of numbers */\n\n\t\tfor(j=0;j<i+1;j++)\n\t\t\tif( print_centered(triangle[i][j],max_width+2)){\n\t\t\t\tlibmin_printf(\"%s: error printing element %d,%d\\n\",PROGRAM_NAME,i,j);\n\t\t\t\tlibmin_fail(1);\n\t\t}\n\t\tlibmin_printf(\"\\n\");\n\t}\n\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "pascal/pascal.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned __int64 v3; // rsi\n  __int64 v4; // r11\n  __int64 v5; // r8\n  int *v6; // rcx\n  __int64 v7; // r9\n  int *v8; // r10\n  unsigned int v9; // eax\n  __int64 v10; // rdi\n  int v11; // eax\n  int v12; // ebp\n  int *v13; // rax\n  char *v14; // rdi\n  int v15; // edx\n  __int64 v16; // rcx\n  __int64 v17; // rdx\n  int v18; // eax\n  int v19; // ebp\n  __int64 v20; // r13\n  __int64 v21; // r8\n  int v22; // r14d\n  __int64 v23; // rdx\n  int v24; // eax\n  int v25; // ebp\n  int v26; // r12d\n  int v27; // r15d\n  int v28; // ebp\n  int v29; // r12d\n  __int64 v30; // [rsp+8h] [rbp-60h]\n  int *v31; // [rsp+10h] [rbp-58h]\n  int v32; // [rsp+18h] [rbp-50h]\n  int row_offset; // [rsp+20h] [rbp-48h]\n  unsigned int v34; // [rsp+24h] [rbp-44h]\n  int v35; // [rsp+28h] [rbp-40h]\n  int v36; // [rsp+2Ch] [rbp-3Ch]\n\n  v3 = (unsigned __int64)triangle[1];\n  v4 = 60LL;\n  v5 = 1LL;\n  v6 = triangle[0];\n  v7 = 2LL;\n  v8 = &triangle[1][1];\n  triangle[0][0] = 1;\n  v31 = triangle[0];\n  *(_QWORD *)&triangle[1][0] = 0x100000001LL;\n  while ( 1 )\n  {\n    *(_DWORD *)(v3 + 120) = 1;\n    if ( (unsigned __int64)(120 * (v7 - v5)) <= 0xC || (_DWORD)v5 == 1 )\n    {\n      v13 = (int *)v3;\n      do\n      {\n        v14 = (char *)v13 + (_QWORD)v6 - v3;\n        v15 = v13[1] + *v13;\n        ++v13;\n        *(_DWORD *)&v14[4 * v4 + 4] = v15;\n      }\n      while ( v13 != v8 );\n    }\n    else\n    {\n      if ( (unsigned int)(v7 - 2) <= 2 )\n      {\n        v10 = 0LL;\n        v11 = 1;\n      }\n      else\n      {\n        v9 = (unsigned int)v5 >> 2;\n        *(__m128i *)(v3 + 124) = _mm_add_epi32(\n                                   _mm_loadu_si128((const __m128i *)v3),\n                                   _mm_loadu_si128((const __m128i *)(v3 + 4)));\n        if ( (unsigned int)v5 >> 2 != 1 )\n        {\n          *(__m128i *)(v3 + 140) = _mm_add_epi32(\n                                     _mm_loadu_si128((const __m128i *)(v3 + 16)),\n                                     _mm_loadu_si128((const __m128i *)(v3 + 20)));\n          if ( v9 != 2 )\n          {\n            *(__m128i *)(v3 + 156) = _mm_add_epi32(\n                                       _mm_loadu_si128((const __m128i *)(v3 + 32)),\n                                       _mm_loadu_si128((const __m128i *)(v3 + 36)));\n            if ( v9 == 4 )\n              *(__m128i *)(v3 + 172) = _mm_add_epi32(\n                                         _mm_loadu_si128((const __m128i *)(v3 + 48)),\n                                         _mm_loadu_si128((const __m128i *)(v3 + 52)));\n          }\n        }\n        v10 = (unsigned int)v5 & 0xFFFFFFFC;\n        v11 = v10 + 1;\n        if ( (_DWORD)v10 == (_DWORD)v5 )\n          goto LABEL_12;\n      }\n      v12 = v5 - v10;\n      if ( (_DWORD)v5 - (_DWORD)v10 == 1\n        || (*(_QWORD *)&v6[v10 + 1 + v4] = _mm_add_epi32(\n                                             _mm_loadl_epi64((const __m128i *)&triangle[-1][v10 + 1 + v4]),\n                                             _mm_loadl_epi64((const __m128i *)&v6[v10 - 30 + v4])).m128i_u64[0],\n            v11 += v12 & 0xFFFFFFFE,\n            v12 != (v12 & 0xFFFFFFFE)) )\n      {\n        v6[30 * (int)v7 + v11] = v6[30 * (int)v5 - 1 + v11] + v6[30 * (int)v5 + v11];\n      }\n    }\nLABEL_12:\n    ++v7;\n    v3 += 120LL;\n    v8 += 31;\n    ++v5;\n    *v8 = 1;\n    v4 += 30LL;\n    if ( v7 == 20 )\n    {\n      LODWORD(v16) = 1;\n      v17 = (unsigned int)(triangle[19][10] / 10);\n      if ( !(_DWORD)v17 )\n        goto LABEL_39;\n      do\n      {\n        v16 = (unsigned int)(v16 + 1);\n        v3 = (unsigned int)((int)v17 >> 31);\n        v18 = (int)v17 / 10;\n        v17 = (unsigned int)((int)v17 / 10);\n      }\n      while ( v18 );\n      if ( (v16 & 1) != 0 )\nLABEL_39:\n        v16 = (unsigned int)(v16 + 1);\n      v30 = 1LL;\n      v32 = v16 + 2;\n      v34 = ((int)v16 >> 1) + 1;\n      row_offset = 19 * v34;\n      v35 = v16 + 1;\n      v36 = ((int)v16 + 1) >> 1;\n      while ( 2 )\n      {\n        v19 = 0;\n        if ( row_offset > 0 )\n        {\n          do\n          {\n            ++v19;\n            libmin_printf(\" \", v3, v17, v16, v5);\n          }\n          while ( row_offset != v19 );\n        }\n        v20 = 0LL;\nLABEL_25:\n        v21 = (unsigned int)v20;\n        v22 = v31[v20];\n        v23 = (unsigned int)(v22 / 10);\n        if ( (_DWORD)v23 )\n        {\n          LODWORD(v3) = 1;\n          do\n          {\n            v3 = (unsigned int)(v3 + 1);\n            v16 = (unsigned int)((int)v23 >> 31);\n            v24 = (int)v23 / 10;\n            v23 = (unsigned int)((int)v23 / 10);\n          }\n          while ( v24 );\n          if ( (int)v3 > v32 )\n          {\n            libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", v30 - 1, v20);\n            libmin_fail(1);\n          }\n          v25 = v32 - v3;\n          v26 = (v32 - (int)v3) / 2;\n          if ( v32 - (int)v3 > 1 )\n          {\nLABEL_30:\n            v27 = 0;\n            do\n            {\n              ++v27;\n              libmin_printf(\" \", v3, v23, v16, v21);\n            }\n            while ( v27 < v26 );\n          }\n          v3 = (unsigned int)v22;\n          v28 = v25 - v26;\n          libmin_printf(\"%d\", v22);\n          v29 = 0;\n          if ( v28 > 0 )\n          {\n            do\n            {\n              ++v29;\n              libmin_printf(\" \");\n            }\n            while ( v28 != v29 );\n          }\n          if ( ++v20 == v30 )\n          {\n            libmin_printf(\"\\n\");\n            v3 = v34;\n            v31 += 30;\n            row_offset -= v34;\n            v30 = v20 + 1;\n            if ( v20 == 20 )\n              libmin_success();\n            continue;\n          }\n          goto LABEL_25;\n        }\n        break;\n      }\n      v25 = v35;\n      v26 = v36;\n      goto LABEL_30;\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned long long v3;\n  long long v4;\n  long long v5;\n  int *v6;\n  long long v7;\n  int *v8;\n  unsigned int v9;\n  long long v10;\n  int v11;\n  int v12;\n  int *v13;\n  char *v14;\n  int v15;\n  long long v16;\n  long long v17;\n  int v18;\n  int v19;\n  long long v20;\n  long long v21;\n  int v22;\n  long long v23;\n  int v24;\n  int v25;\n  int v26;\n  int v27;\n  int v28;\n  int v29;\n  long long v30;\n  int *v31;\n  int v32;\n  int row_offset;\n  unsigned int v34;\n  int v35;\n  int v36;\n  v3 = (unsigned long long)triangle[1];\n  v4 = 60LL;\n  v5 = 1LL;\n  v6 = triangle[0];\n  v7 = 2LL;\n  v8 = &triangle[1][1];\n  triangle[0][0] = 1;\n  v31 = triangle[0];\n  *(uint64_t *)&triangle[1][0] = 4294967297LL;\n  while (1) {\n    *(uint32_t *)(v3 + 120) = 1;\n    if ((unsigned long long)(120 * (v7 - v5)) <= 12 || (uint32_t)v5 == 1) {\n      v13 = (int *)v3;\n      do {\n        v14 = (char *)v13 + (uint64_t)v6 - v3;\n        v15 = v13[1] + *v13;\n        ++v13;\n        *(uint32_t *)&v14[4 * v4 + 4] = v15;\n      } while (v13 != v8);\n    } else {\n      if ((unsigned int)(v7 - 2) <= 2) {\n        v10 = 0LL;\n        v11 = 1;\n      } else {\n        v9 = (unsigned int)v5 >> 2;\n        *(__m128i *)(v3 + 124) =\n            _mm_add_epi32(_mm_loadu_si128((const __m128i *)v3),\n                          _mm_loadu_si128((const __m128i *)(v3 + 4)));\n        if ((unsigned int)v5 >> 2 != 1) {\n          *(__m128i *)(v3 + 140) =\n              _mm_add_epi32(_mm_loadu_si128((const __m128i *)(v3 + 16)),\n                            _mm_loadu_si128((const __m128i *)(v3 + 20)));\n          if (v9 != 2) {\n            *(__m128i *)(v3 + 156) =\n                _mm_add_epi32(_mm_loadu_si128((const __m128i *)(v3 + 32)),\n                              _mm_loadu_si128((const __m128i *)(v3 + 36)));\n            if (v9 == 4)\n              *(__m128i *)(v3 + 172) =\n                  _mm_add_epi32(_mm_loadu_si128((const __m128i *)(v3 + 48)),\n                                _mm_loadu_si128((const __m128i *)(v3 + 52)));\n          }\n        }\n        v10 = (unsigned int)v5 & 4294967292;\n        v11 = v10 + 1;\n        if ((uint32_t)v10 == (uint32_t)v5) goto LABEL_12;\n      }\n      v12 = v5 - v10;\n      if ((uint32_t)v5 - (uint32_t)v10 == 1 ||\n          (*(uint64_t *)&v6[v10 + 1 + v4] =\n               _mm_add_epi32(\n                   _mm_loadl_epi64(\n                       (const __m128i *)&triangle[-1][v10 + 1 + v4]),\n                   _mm_loadl_epi64((const __m128i *)&v6[v10 - 30 + v4]))\n                   .m128i_u64[0],\n           v11 += v12 & 4294967294, v12 != (v12 & 4294967294))) {\n        v6[30 * (int)v7 + v11] =\n            v6[30 * (int)v5 - 1 + v11] + v6[30 * (int)v5 + v11];\n      }\n    }\n  LABEL_12:\n    ++v7;\n    v3 += 120LL;\n    v8 += 31;\n    ++v5;\n    *v8 = 1;\n    v4 += 30LL;\n    if (v7 == 20) {\n      LODWORD(v16) = 1;\n      v17 = (unsigned int)(triangle[19][10] / 10);\n      if (!(uint32_t)v17) goto LABEL_39;\n      do {\n        v16 = (unsigned int)(v16 + 1);\n        v3 = (unsigned int)((int)v17 >> 31);\n        v18 = (int)v17 / 10;\n        v17 = (unsigned int)((int)v17 / 10);\n      } while (v18);\n      if ((v16 & 1) != 0)\n      LABEL_39:\n        v16 = (unsigned int)(v16 + 1);\n      v30 = 1LL;\n      v32 = v16 + 2;\n      v34 = ((int)v16 >> 1) + 1;\n      row_offset = 19 * v34;\n      v35 = v16 + 1;\n      v36 = ((int)v16 + 1) >> 1;\n      while (2) {\n        v19 = 0;\n        if (row_offset > 0) {\n          do {\n            ++v19;\n            libmin_printf(\" \", v3, v17, v16, v5);\n          } while (row_offset != v19);\n        }\n        v20 = 0LL;\n      LABEL_25:\n        v21 = (unsigned int)v20;\n        v22 = v31[v20];\n        v23 = (unsigned int)(v22 / 10);\n        if ((uint32_t)v23) {\n          LODWORD(v3) = 1;\n          do {\n            v3 = (unsigned int)(v3 + 1);\n            v16 = (unsigned int)((int)v23 >> 31);\n            v24 = (int)v23 / 10;\n            v23 = (unsigned int)((int)v23 / 10);\n          } while (v24);\n          if ((int)v3 > v32) {\n            libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\",\n                          v30 - 1, v20);\n            libmin_fail(1);\n          }\n          v25 = v32 - v3;\n          v26 = (v32 - (int)v3) / 2;\n          if (v32 - (int)v3 > 1) {\n          LABEL_30:\n            v27 = 0;\n            do {\n              ++v27;\n              libmin_printf(\" \", v3, v23, v16, v21);\n            } while (v27 < v26);\n          }\n          v3 = (unsigned int)v22;\n          v28 = v25 - v26;\n          libmin_printf(\"%d\", v22);\n          v29 = 0;\n          if (v28 > 0) {\n            do {\n              ++v29;\n              libmin_printf(\" \");\n            } while (v28 != v29);\n          }\n          if (++v20 == v30) {\n            libmin_printf(\"\\n\");\n            v3 = v34;\n            v31 += 30;\n            row_offset -= v34;\n            v30 = v20 + 1;\n            if (v20 == 20) libmin_success();\n            continue;\n          }\n          goto LABEL_25;\n        }\n        break;\n      }\n      v25 = v35;\n      v26 = v36;\n      goto LABEL_30;\n    }\n  }\n}", "binary": "pascal/pascal.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nlea    0x51eb(%rip),%rsi\nmov    $0x3c,%r11d\nmov    $0x1,%r8d\npush   %r14\nlea    -0x78(%rsi),%rcx\nmov    $0x2,%r9d\npush   %r13\nlea    0x7c(%rcx),%r10\npush   %r12\npush   %rbp\npush   %rbx\nlea    0x4(%rcx),%rbx\nsub    $0x38,%rsp\nmov    0x2f02(%rip),%rax\nmovl   $0x1,0x5138(%rip)\nmov    %rcx,0x10(%rsp)\nmov    %rax,0x51a4(%rip)\njmp    126d <main+0x16d>\nnopl   0x0(%rax)\ncmp    $0x1,%r8d\nje     129b <main+0x19b>\nlea    -0x2(%rdx),%eax\ncmp    $0x2,%eax\njbe    12ca <main+0x1ca>\nmovdqu (%rsi),%xmm0\nmovdqu 0x4(%rsi),%xmm2\nmov    %r8d,%eax\nshr    $0x2,%eax\npaddd  %xmm2,%xmm0\nmovups %xmm0,0x7c(%rsi)\ncmp    $0x1,%eax\nje     11db <main+0xdb>\nmovdqu 0x10(%rsi),%xmm0\nmovdqu 0x14(%rsi),%xmm3\npaddd  %xmm3,%xmm0\nmovups %xmm0,0x8c(%rsi)\ncmp    $0x2,%eax\nje     11db <main+0xdb>\nmovdqu 0x20(%rsi),%xmm0\nmovdqu 0x24(%rsi),%xmm4\npaddd  %xmm4,%xmm0\nmovups %xmm0,0x9c(%rsi)\ncmp    $0x4,%eax\njne    11db <main+0xdb>\nmovdqu 0x30(%rsi),%xmm0\nmovdqu 0x34(%rsi),%xmm5\npaddd  %xmm5,%xmm0\nmovups %xmm0,0xac(%rsi)\nmov    %ebp,%edi\nand    $0xfffffffc,%edi\nlea    0x1(%rdi),%eax\ncmp    %ebp,%edi\nje     124c <main+0x14c>\nsub    %edi,%ebp\ncmp    $0x1,%ebp\nje     1218 <main+0x118>\nlea    -0x1e(%rdi,%r11,1),%r13\nlea    0x1(%rdi,%r11,1),%rdi\nmovq   (%rbx,%r13,4),%xmm0\nmovq   (%rcx,%r13,4),%xmm1\npaddd  %xmm1,%xmm0\nmovq   %xmm0,(%rcx,%rdi,4)\nmov    %ebp,%edi\nand    $0xfffffffe,%edi\nadd    %edi,%eax\ncmp    %edi,%ebp\nje     124c <main+0x14c>\nmov    %rdx,%rdi\nmovslq %eax,%rbp\nshl    $0x4,%rdi\nsub    %rdx,%rdi\nlea    -0x1(%rax),%edx\nmov    %r12,%rax\nshl    $0x4,%rax\nmovslq %edx,%rdx\nlea    0x0(%rbp,%rdi,2),%rdi\nsub    %r12,%rax\nadd    %rax,%rax\nadd    %rax,%rdx\nadd    %rbp,%rax\nmov    (%rcx,%rax,4),%eax\nadd    (%rcx,%rdx,4),%eax\nmov    %eax,(%rcx,%rdi,4)\nadd    $0x1,%r9\nadd    $0x78,%rsi\nadd    $0x7c,%r10\nadd    $0x1,%r8\nmovl   $0x1,(%r10)\nadd    $0x1e,%r11\ncmp    $0x14,%r9\nje     12d6 <main+0x1d6>\nmov    %r9,%rdi\nmovl   $0x1,0x78(%rsi)\nmovslq %r9d,%rdx\nmov    %r8d,%ebp\nsub    %r8,%rdi\nmovslq %r8d,%r12\nmov    %rdi,%rax\nshl    $0x4,%rax\nsub    %rdi,%rax\nshl    $0x3,%rax\ncmp    $0xc,%rax\nja     1160 <main+0x60>\nmov    %rcx,%rbp\nlea    0x0(,%r11,4),%r12\nmov    %rsi,%rax\nsub    %rsi,%rbp\nnopl   0x0(%rax)\nmov    (%rax),%edx\nlea    0x0(%rbp,%rax,1),%rdi\nadd    0x4(%rax),%edx\nadd    $0x4,%rax\nmov    %edx,0x4(%rdi,%r12,1)\ncmp    %r10,%rax\njne    12b0 <main+0x1b0>\njmp    124c <main+0x14c>\nxor    %edi,%edi\nmov    $0x1,%eax\njmp    11e7 <main+0xe7>\nmovslq 0x58b3(%rip),%rdx\nmov    $0x1,%ecx\nmov    %rdx,%rax\nimul   $0x66666667,%rdx,%rdx\nsar    $0x1f,%eax\nsar    $0x22,%rdx\nsub    %eax,%edx\nje     14fe <main+0x3fe>\nmovslq %edx,%rax\nmov    %edx,%esi\nadd    $0x1,%ecx\nimul   $0x66666667,%rax,%rax\nsar    $0x1f,%esi\nsar    $0x22,%rax\nsub    %esi,%eax\nmov    %eax,%edx\njne    12fb <main+0x1fb>\ntest   $0x1,%cl\njne    14fe <main+0x3fe>\nmovq   $0x1,0x8(%rsp)\nmov    %ecx,%eax\nsar    %eax\nlea    0x1(%rax),%ebx\nlea    0x2(%rcx),%eax\nmov    %eax,0x18(%rsp)\nlea    (%rbx,%rbx,8),%eax\nlea    (%rbx,%rax,2),%eax\nmov    %ebx,0x24(%rsp)\nlea    0x2cbc(%rip),%rbx\nmov    %eax,0x20(%rsp)\nlea    0x1(%rcx),%eax\nmov    %eax,0x28(%rsp)\nsar    %eax\nmov    %eax,0x2c(%rsp)\nnopl   0x0(%rax)\nmov    0x8(%rsp),%eax\nmov    0x20(%rsp),%r12d\nxor    %ebp,%ebp\nsub    $0x1,%eax\nmov    %eax,0x1c(%rsp)\nmov    0x20(%rsp),%eax\ntest   %eax,%eax\njle    1392 <main+0x292>\nnopw   0x0(%rax,%rax,1)\nmov    %rbx,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebp\ncall   3810 <libmin_printf>\ncmp    %ebp,%r12d\njne    1380 <main+0x280>\nxor    %r13d,%r13d\nnopl   (%rax)\nmov    0x10(%rsp),%rax\nmov    %r13d,%r8d\nmovslq (%rax,%r13,4),%rdx\nmov    %rdx,%r14\nimul   $0x66666667,%rdx,%rdx\nmov    %r14d,%eax\nsar    $0x1f,%eax\nsar    $0x22,%rdx\nsub    %eax,%edx\nje     14f0 <main+0x3f0>\nmov    $0x1,%esi\nnopl   (%rax)\nmovslq %edx,%rax\nmov    %edx,%ecx\nadd    $0x1,%esi\nimul   $0x66666667,%rax,%rax\nsar    $0x1f,%ecx\nsar    $0x22,%rax\nsub    %ecx,%eax\nmov    %eax,%edx\njne    13c8 <main+0x2c8>\ncmp    0x18(%rsp),%esi\njg     14b0 <main+0x3b0>\nmov    0x18(%rsp),%ebp\nsub    %esi,%ebp\nmov    %ebp,%r12d\nshr    $0x1f,%r12d\nadd    %ebp,%r12d\nsar    %r12d\ncmp    $0x1,%ebp\njle    1423 <main+0x323>\nxor    %r15d,%r15d\nnopl   0x0(%rax)\nmov    %rbx,%rdi\nxor    %eax,%eax\nadd    $0x1,%r15d\ncall   3810 <libmin_printf>\ncmp    %r12d,%r15d\njl     1410 <main+0x310>\nmov    %r14d,%esi\nlea    0x2bd9(%rip),%rdi\nxor    %eax,%eax\nsub    %r12d,%ebp\ncall   3810 <libmin_printf>\nxor    %r12d,%r12d\ntest   %ebp,%ebp\njle    1453 <main+0x353>\nxchg   %ax,%ax\nmov    %rbx,%rdi\nxor    %eax,%eax\nadd    $0x1,%r12d\ncall   3810 <libmin_printf>\ncmp    %r12d,%ebp\njne    1440 <main+0x340>\nadd    $0x1,%r13\ncmp    0x8(%rsp),%r13\njne    1398 <main+0x298>\nlea    0x2ba7(%rip),%rdi\nxor    %eax,%eax\ncall   3810 <libmin_printf>\nlea    0x1(%r13),%rax\nmov    0x24(%rsp),%esi\naddq   $0x78,0x10(%rsp)\nsub    %esi,0x20(%rsp)\nmov    %rax,0x8(%rsp)\ncmp    $0x14,%r13\njne    1360 <main+0x260>\ncall   3a50 <libmin_success>\nadd    $0x38,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    0x1c(%rsp),%edx\nmov    %r8d,%ecx\nlea    0x2b4b(%rip),%rsi\nxor    %eax,%eax\nlea    0x2b51(%rip),%rdi\nadd    $0x1,%r13\ncall   3810 <libmin_printf>\nmov    $0x1,%edi\ncall   1900 <libmin_fail>\ncmp    0x8(%rsp),%r13\njne    1398 <main+0x298>\njmp    1462 <main+0x362>\nnopw   0x0(%rax,%rax,1)\nmov    0x28(%rsp),%ebp\nmov    0x2c(%rsp),%r12d\njmp    1406 <main+0x306>\nadd    $0x1,%ecx\njmp    1320 <main+0x220>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "pascal/pascal.c", "function_name": "num_digits", "content": "/* num_digits: count how man digits the argument has and return that number */\n\nint num_digits(int n) {\n\n\tint d = 1;\n\n\t\n\twhile((n=n/10) != 0)\n    d++;\n\treturn d;\n}\n"}, "pseudo": {"path": "pascal/pascal.host.O3.pseudo", "function_name": "num_digits", "address": "0x1600", "label": "num_digits", "content": "int __fastcall num_digits(int n)\n{\n  int v1; // r8d\n  int i; // edx\n\n  v1 = 1;\n  for ( i = n / 10; i; i /= 10 )\n    ++v1;\n  return v1;\n}\n"}, "pseudo_normalize": "int num_digits(int n) {\n  int v1;\n  int i;\n  v1 = 1;\n  for (i = n / 10; i; i /= 10) ++v1;\n  return v1;\n}", "binary": "pascal/pascal.host.O3", "assembly": "<num_digits>:\nendbr64\nmovslq %edi,%rdx\nsar    $0x1f,%edi\nmov    $0x1,%r8d\nimul   $0x66666667,%rdx,%rdx\nsar    $0x22,%rdx\nsub    %edi,%edx\nje     163d <num_digits+0x3d>\nnop\nmovslq %edx,%rax\nmov    %edx,%ecx\nadd    $0x1,%r8d\nimul   $0x66666667,%rax,%rax\nsar    $0x1f,%ecx\nsar    $0x22,%rax\nsub    %ecx,%eax\nmov    %eax,%edx\njne    1620 <num_digits+0x20>\nmov    %r8d,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "pascal/pascal.c", "function_name": "print_centered", "content": "/* print_centered: print the first argument centered in a field of \n\twidth given by the second argument, to the extent possible.\n\t(The width is always the second argument, but the number may not\n        be quite centered, depending on parity.) \n\tReturn 0 if successful and 1 if not.\n*/\n\nint print_centered(int n, int width)\n{\n\tint nw;\n\tint pad_space;\n\tint i;\n\n\tnw = num_digits(n);\n\tif(width < nw) return 1;  /* no can do */\n\n\tpad_space = (width - nw)/2;\n\n\tfor(i=0;i<pad_space;i++)\n\t  libmin_printf(\" \");\n\tlibmin_printf(\"%d\",n);\n\tfor(i=0;i<width - nw - pad_space;i++)\n\t  libmin_printf(\" \");\n\treturn 0;\n}\n"}, "pseudo": {"path": "pascal/pascal.host.O3.pseudo", "function_name": "print_centered", "address": "0x1650", "label": "print_centered", "content": "int __fastcall print_centered(int n, int width)\n{\n  int v3; // edi\n  int v4; // ebp\n  __int64 v5; // rdx\n  int v6; // eax\n  int result; // eax\n  __int64 v8; // rsi\n  int v9; // r12d\n  int v10; // ebx\n  int v11; // ebp\n\n  v3 = 1;\n  v4 = n;\n  v5 = (unsigned int)(n / 10);\n  if ( (_DWORD)v5 )\n  {\n    do\n    {\n      ++v3;\n      v6 = (int)v5 / 10;\n      v5 = (unsigned int)((int)v5 / 10);\n    }\n    while ( v6 );\n  }\n  result = 1;\n  if ( width >= v3 )\n  {\n    v8 = (unsigned int)(width - v3);\n    v9 = (int)v8 >> 1;\n    if ( (int)v8 >> 1 )\n    {\n      v10 = 0;\n      do\n      {\n        ++v10;\n        libmin_printf(\" \", v8, v5);\n      }\n      while ( v9 != v10 );\n    }\n    libmin_printf(\"%d\", v4);\n    v11 = 0;\n    if ( (int)v8 - v9 > 0 )\n    {\n      do\n      {\n        ++v11;\n        libmin_printf(\" \");\n      }\n      while ( v11 != (_DWORD)v8 - v9 );\n    }\n    return 0;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int print_centered(int n, int width) {\n  int v3;\n  int v4;\n  long long v5;\n  int v6;\n  int result;\n  long long v8;\n  int v9;\n  int v10;\n  int v11;\n  v3 = 1;\n  v4 = n;\n  v5 = (unsigned int)(n / 10);\n  if ((uint32_t)v5) {\n    do {\n      ++v3;\n      v6 = (int)v5 / 10;\n      v5 = (unsigned int)((int)v5 / 10);\n    } while (v6);\n  }\n  result = 1;\n  if (width >= v3) {\n    v8 = (unsigned int)(width - v3);\n    v9 = (int)v8 >> 1;\n    if ((int)v8 >> 1) {\n      v10 = 0;\n      do {\n        ++v10;\n        libmin_printf(\" \", v8, v5);\n      } while (v9 != v10);\n    }\n    libmin_printf(\"%d\", v4);\n    v11 = 0;\n    if ((int)v8 - v9 > 0) {\n      do {\n        ++v11;\n        libmin_printf(\" \");\n      } while (v11 != (uint32_t)v8 - v9);\n    }\n    return 0;\n  }\n  return result;\n}", "binary": "pascal/pascal.host.O3", "assembly": "<print_centered>:\nendbr64\nmovslq %edi,%rdx\npush   %r14\nmov    $0x1,%edi\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\nimul   $0x66666667,%rdx,%rdx\nmov    %ebp,%eax\npush   %rbx\nsar    $0x1f,%eax\nsar    $0x22,%rdx\nsub    %eax,%edx\nje     169c <print_centered+0x4c>\nnopl   0x0(%rax,%rax,1)\nmovslq %edx,%rax\nmov    %edx,%ecx\nadd    $0x1,%edi\nimul   $0x66666667,%rax,%rax\nsar    $0x1f,%ecx\nsar    $0x22,%rax\nsub    %ecx,%eax\nmov    %eax,%edx\njne    1680 <print_centered+0x30>\nmov    $0x1,%eax\ncmp    %edi,%esi\njl     170c <print_centered+0xbc>\nsub    %edi,%esi\nmov    %esi,%r12d\nmov    %esi,%r14d\nsar    %r12d\nje     16d2 <print_centered+0x82>\nxor    %ebx,%ebx\nlea    0x2949(%rip),%r13\nnopl   0x0(%rax,%rax,1)\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   3810 <libmin_printf>\ncmp    %ebx,%r12d\njne    16c0 <print_centered+0x70>\nmov    %ebp,%esi\nlea    0x292b(%rip),%rdi\nxor    %eax,%eax\nsub    %r12d,%r14d\ncall   3810 <libmin_printf>\nxor    %ebp,%ebp\nlea    0x2916(%rip),%r13\ntest   %r14d,%r14d\njle    170a <print_centered+0xba>\nnopl   0x0(%rax,%rax,1)\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebp\ncall   3810 <libmin_printf>\ncmp    %r14d,%ebp\njne    16f8 <print_centered+0xa8>\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "pi-calc/pi-calc.c", "function_name": "main", "content": "int main(void){for(;(b=c-=14);h=libmin_printf(\"%04d\",e+d/f))for(e=d%=f;(g=--b*2);d/=g)d=d*b+f*(h?a[b]:f/5),a[b]=d%--g;libmin_success(); return 0;}\n"}, "pseudo": {"path": "pi-calc/pi-calc.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // edi\n  int v4; // ecx\n  int v5; // r9d\n  int v6; // r10d\n  int v7; // edx\n  int v8; // r8d\n  __int64 v9; // rsi\n  int v10; // r10d\n  int v11; // eax\n  unsigned int v12; // eax\n  int v13; // edx\n  __int64 v14; // rt2\n  __int64 v15; // r11\n  int v16; // r10d\n  unsigned int v17; // eax\n  int v18; // edx\n  __int64 v19; // rt2\n\n  v3 = c - 14;\n  c = v3;\n  for ( b = v3; v3; b = v3 )\n  {\n    v4 = f;\n    v5 = v3 - 1;\n    v6 = 2 * (v3 - 1);\n    b = v3 - 1;\n    g = v6;\n    v7 = d % f;\n    d = v7;\n    v8 = v7;\n    e = v7;\n    if ( v3 == 1 )\n    {\n      v11 = v7;\n    }\n    else\n    {\n      if ( h )\n      {\n        v15 = v5;\n        v16 = v6 - 1;\n        v11 = v7;\n        do\n        {\n          v18 = (v4 * a[v15] + (int)v15 * v11) >> 31;\n          v17 = v4 * a[v15] + v15 * v11;\n          v19 = __SPAIR64__(v18, v17) % v16;\n          v11 = __SPAIR64__(v18, v17) / v16;\n          v16 -= 2;\n          a[v15--] = v19;\n        }\n        while ( (_DWORD)v15 );\n      }\n      else\n      {\n        v9 = v5;\n        v10 = v6 - 1;\n        v11 = v7;\n        do\n        {\n          v13 = (v4 * (v4 / 5) + (int)v9 * v11) >> 31;\n          v12 = v4 * (v4 / 5) + v9 * v11;\n          v14 = __SPAIR64__(v13, v12) % v10;\n          v11 = __SPAIR64__(v13, v12) / v10;\n          v10 -= 2;\n          a[v9--] = v14;\n        }\n        while ( (_DWORD)v9 );\n      }\n      d = v11;\n      b = 0;\n      g = 0;\n    }\n    h = libmin_printf(\"%04d\", v11 / v4 + v8);\n    v3 = c - 14;\n    c = v3;\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  long long v9;\n  int v10;\n  int v11;\n  unsigned int v12;\n  int v13;\n  long long v14;\n  long long v15;\n  int v16;\n  unsigned int v17;\n  int v18;\n  long long v19;\n  v3 = c - 14;\n  c = v3;\n  for (b = v3; v3; b = v3) {\n    v4 = f;\n    v5 = v3 - 1;\n    v6 = 2 * (v3 - 1);\n    b = v3 - 1;\n    g = v6;\n    v7 = d % f;\n    d = v7;\n    v8 = v7;\n    e = v7;\n    if (v3 == 1) {\n      v11 = v7;\n    } else {\n      if (h) {\n        v15 = v5;\n        v16 = v6 - 1;\n        v11 = v7;\n        do {\n          v18 = (v4 * a[v15] + (int)v15 * v11) >> 31;\n          v17 = v4 * a[v15] + v15 * v11;\n          v19 = __SPAIR64__(v18, v17) % v16;\n          v11 = __SPAIR64__(v18, v17) / v16;\n          v16 -= 2;\n          a[v15--] = v19;\n        } while ((uint32_t)v15);\n      } else {\n        v9 = v5;\n        v10 = v6 - 1;\n        v11 = v7;\n        do {\n          v13 = (v4 * (v4 / 5) + (int)v9 * v11) >> 31;\n          v12 = v4 * (v4 / 5) + v9 * v11;\n          v14 = __SPAIR64__(v13, v12) % v10;\n          v11 = __SPAIR64__(v13, v12) / v10;\n          v10 -= 2;\n          a[v9--] = v14;\n        } while ((uint32_t)v9);\n      }\n      d = v11;\n      b = 0;\n      g = 0;\n    }\n    h = libmin_printf(\"%04d\", v11 / v4 + v8);\n    v3 = c - 14;\n    c = v3;\n  }\n  libmin_success();\n}", "binary": "pi-calc/pi-calc.host.O3", "assembly": "<main>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x4f04(%rip),%eax\nlea    -0xe(%rax),%edi\nmov    %edi,0x4efb(%rip)\nmov    %edi,0x5171(%rip)\ntest   %edi,%edi\nje     121c <main+0x11c>\nlea    0x2ed6(%rip),%rbx\nlea    0x516b(%rip),%rbp\nnopl   (%rax)\nmov    0x514e(%rip),%eax\nmov    0x4ecc(%rip),%ecx\nlea    -0x1(%rdi),%r9d\nlea    (%r9,%r9,1),%r10d\nmov    %r9d,0x513d(%rip)\ncltd\nmov    %r10d,0x5129(%rip)\nidiv   %ecx\nmov    %edx,0x5129(%rip)\nmov    %edx,%r8d\nmov    %edx,0x511c(%rip)\ntest   %r9d,%r9d\nje     1270 <main+0x170>\nmovslq %ecx,%r11\nmov    %ecx,%eax\nimul   $0x66666667,%r11,%r11\nsar    $0x1f,%eax\nsar    $0x21,%r11\nsub    %eax,%r11d\nmov    0x50ef(%rip),%eax\ntest   %eax,%eax\njne    1230 <main+0x130>\nimul   %ecx,%r11d\nmovslq %r9d,%rsi\nsub    $0x1,%r10d\nmov    %edx,%eax\ncs nopw 0x0(%rax,%rax,1)\nimul   %esi,%eax\nadd    %r11d,%eax\ncltd\nidiv   %r10d\nsub    $0x2,%r10d\nmov    %edx,0x0(%rbp,%rsi,4)\nsub    $0x1,%rsi\ntest   %esi,%esi\njne    11b0 <main+0xb0>\nsub    %edi,%r9d\nmov    %eax,0x50b9(%rip)\nmovl   $0x0,0x50b3(%rip)\nlea    0x2(%r9,%r9,1),%edx\nmov    %edx,0x509c(%rip)\ncltd\nmov    %rbx,%rdi\nidiv   %ecx\nlea    (%rax,%r8,1),%esi\nxor    %eax,%eax\ncall   3440 <libmin_printf>\nmov    %eax,0x5081(%rip)\nmov    0x4e0f(%rip),%eax\nlea    -0xe(%rax),%edi\nmov    %edi,0x4e06(%rip)\nmov    %edi,0x507c(%rip)\ntest   %edi,%edi\njne    1138 <main+0x38>\ncall   3680 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nret\nnopw   0x0(%rax,%rax,1)\nmovslq %r9d,%r11\nsub    $0x1,%r10d\nmov    %edx,%eax\nnopl   0x0(%rax)\nmov    0x0(%rbp,%r11,4),%edx\nimul   %r11d,%eax\nimul   %ecx,%edx\nadd    %edx,%eax\ncltd\nidiv   %r10d\nsub    $0x2,%r10d\nmov    %edx,0x0(%rbp,%r11,4)\nsub    $0x1,%r11\ntest   %r11d,%r11d\njne    1240 <main+0x140>\njmp    11ca <main+0xca>\nnopl   0x0(%rax)\nmov    %edx,%eax\njmp    11e8 <main+0xe8>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "get_random_int", "content": "/*\n * This function generates a random integer between in the interval\n * [low, high].  As we divide by (high - low + 1) in the process, we need\n * low < high.\n */\nuint64_t get_random_int(uint64_t low, uint64_t high)\n{\n\treturn (uint64_t)libmin_rand() % (high - low + 1) + low;\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O3.pseudo", "function_name": "get_random_int", "address": "0x1460", "label": "get_random_int", "content": "uint64_t __fastcall get_random_int(uint64_t low, uint64_t high)\n{\n  return libmin_rand() % (high - low + 1) + low;\n}\n"}, "pseudo_normalize": "", "binary": "primal-test/primal-test.host.O3", "assembly": "<get_random_int>:\nendbr64\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    %rbp,%rbx\nsub    $0x8,%rsp\ncall   4340 <libmin_rand>\nlea    0x1(%rbx),%rsi\nxor    %edx,%edx\nadd    $0x8,%rsp\nmov    %eax,%eax\npop    %rbx\ndiv    %rsi\nlea    (%rdx,%rbp,1),%rax\npop    %rbp\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "main", "content": "int\nmain(void)\n{\n  // initialize the RNG\n  libmin_srand(42);\n\n  // locate primes in a stream of random numbers\n  {\n    uint32_t val = 3;\n    for (int i=0; i < 200; i++)\n    {\n      int32_t prim = miller_rabin_int(val, K);\n      int _pred = (prim != PT_COMPOSITE);\n      if (_pred)\n      {\n        q[q_head].val = val;\n        q[q_head].prim = prim;\n        if (q_head+1 < Q_SIZE)\n          q_head++;\n      }\n      val = libmin_rand();\n    } \n  }\n\n  // print out the primes that were found\n  libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n  for (int i=0; i < q_head; i++)\n  {\n    if (q[i].prim == PT_PRIME)\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\", q[i].val);\n    else if (q[i].prim == PT_PRIME_LIKELY)\n      libmin_printf(\"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\", q[i].val, libmin_pow(4.0, K));\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm2_8\n  uint32_t v4; // r14d\n  __int64 v5; // r13\n  unsigned __int64 v6; // r12\n  unsigned __int64 v7; // r15\n  int v8; // ebp\n  unsigned int v9; // eax\n  unsigned __int64 v10; // rcx\n  unsigned __int64 v11; // rsi\n  unsigned __int64 v12; // r10\n  unsigned __int64 v13; // rdx\n  __int64 v14; // rcx\n  int32_t v15; // ecx\n  __int64 v16; // rdx\n  unsigned int v17; // eax\n  bool v18; // zf\n  int v19; // ebp\n  struct {uint32_t val;int32_t prim;} *v20; // rbx\n  int v21; // edx\n  int32_t prim; // eax\n  uint32_t val; // esi\n  double v24; // xmm0_8\n  int v25; // [rsp+Ch] [rbp-3Ch]\n\n  v4 = 3;\n  libmin_srand(0x2Au);\n  v25 = 200;\n  while ( 1 )\n  {\n    if ( (v4 & 1) != 0 )\n    {\n      if ( v4 == 3 )\n      {\n        v15 = 1;\nLABEL_24:\n        v16 = q_head;\n        q[q_head].val = v4;\n        q[v16].prim = v15;\n        if ( (int)v16 <= 62 )\n          q_head = v16 + 1;\n        goto LABEL_26;\n      }\n      if ( v4 > 2 )\n      {\n        v5 = v4 - 1;\n        v6 = v4 - 1LL;\n        v7 = ((_BYTE)v4 - 1) & 1;\n        if ( (((_BYTE)v4 - 1) & 1) != 0 )\n        {\n          v7 = 0LL;\n        }\n        else\n        {\n          do\n          {\n            v6 >>= 1;\n            ++v7;\n          }\n          while ( (v6 & 1) == 0 );\n        }\n        v8 = 16;\n        do\n        {\n          v9 = libmin_rand();\n          v10 = v6;\n          v11 = 1LL;\n          v12 = v9 % ((unsigned __int64)(v4 - 2) - 1) + 2;\n          do\n          {\n            if ( (v10 & 1) != 0 )\n              v11 = v12 * v11 % v4;\n            v10 >>= 1;\n            v12 = v12 * v12 % v4;\n          }\n          while ( v10 );\n          if ( v11 != 1 && v5 != v11 )\n          {\n            if ( !v7 )\n              goto LABEL_26;\n            v13 = v11 * v11 % v4;\n            if ( v13 == 1 )\n              goto LABEL_26;\n            if ( v5 != v13 )\n            {\n              v14 = 1LL;\n              while ( ++v14 <= v7 )\n              {\n                v13 = v13 * v13 % v4;\n                if ( v13 == 1 )\n                  goto LABEL_26;\n                if ( v5 == v13 )\n                  goto LABEL_22;\n              }\n              if ( v13 != v5 )\n                goto LABEL_26;\n            }\n          }\nLABEL_22:\n          --v8;\n        }\n        while ( v8 );\n        v15 = 2;\n        goto LABEL_24;\n      }\n    }\n    else\n    {\n      v15 = 1;\n      if ( v4 == 2 )\n        goto LABEL_24;\n    }\nLABEL_26:\n    v17 = libmin_rand();\n    v18 = v25-- == 1;\n    v4 = v17;\n    if ( v18 )\n    {\n      v19 = 0;\n      v20 = q;\n      libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n      v21 = q_head;\n      if ( q_head > 0 )\n      {\n        do\n        {\n          while ( 1 )\n          {\n            prim = v20->prim;\n            if ( prim != 1 )\n              break;\n            val = v20->val;\n            ++v19;\n            ++v20;\n            libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\", val);\n            v21 = q_head;\n            if ( v19 >= q_head )\n              goto LABEL_34;\n          }\n          if ( prim == 2 )\n          {\n            v24 = libmin_pow(16.0, v3);\n            libmin_printf(\"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\", v20->val, v24);\n            v21 = q_head;\n          }\n          ++v19;\n          ++v20;\n        }\n        while ( v19 < v21 );\n      }\nLABEL_34:\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  uint32_t v4;\n  long long v5;\n  unsigned long long v6;\n  unsigned long long v7;\n  int v8;\n  unsigned int v9;\n  unsigned long long v10;\n  unsigned long long v11;\n  unsigned long long v12;\n  unsigned long long v13;\n  long long v14;\n  int32_t v15;\n  long long v16;\n  unsigned int v17;\n  bool v18;\n  int v19;\n  struct {\n    uint32_t val;\n    int32_t prim;\n  } * v20;\n  int v21;\n  int32_t prim;\n  uint32_t val;\n  double v24;\n  int v25;\n  v4 = 3;\n  libmin_srand(42u);\n  v25 = 200;\n  while (1) {\n    if ((v4 & 1) != 0) {\n      if (v4 == 3) {\n        v15 = 1;\n      LABEL_24:\n        v16 = q_head;\n        q[q_head].val = v4;\n        q[v16].prim = v15;\n        if ((int)v16 <= 62) q_head = v16 + 1;\n        goto LABEL_26;\n      }\n      if (v4 > 2) {\n        v5 = v4 - 1;\n        v6 = v4 - 1LL;\n        v7 = ((uint8_t)v4 - 1) & 1;\n        if ((((uint8_t)v4 - 1) & 1) != 0) {\n          v7 = 0LL;\n        } else {\n          do {\n            v6 >>= 1;\n            ++v7;\n          } while ((v6 & 1) == 0);\n        }\n        v8 = 16;\n        do {\n          v9 = libmin_rand();\n          v10 = v6;\n          v11 = 1LL;\n          v12 = v9 % ((unsigned long long)(v4 - 2) - 1) + 2;\n          do {\n            if ((v10 & 1) != 0) v11 = v12 * v11 % v4;\n            v10 >>= 1;\n            v12 = v12 * v12 % v4;\n          } while (v10);\n          if (v11 != 1 && v5 != v11) {\n            if (!v7) goto LABEL_26;\n            v13 = v11 * v11 % v4;\n            if (v13 == 1) goto LABEL_26;\n            if (v5 != v13) {\n              v14 = 1LL;\n              while (++v14 <= v7) {\n                v13 = v13 * v13 % v4;\n                if (v13 == 1) goto LABEL_26;\n                if (v5 == v13) goto LABEL_22;\n              }\n              if (v13 != v5) goto LABEL_26;\n            }\n          }\n        LABEL_22:\n          --v8;\n        } while (v8);\n        v15 = 2;\n        goto LABEL_24;\n      }\n    } else {\n      v15 = 1;\n      if (v4 == 2) goto LABEL_24;\n    }\n  LABEL_26:\n    v17 = libmin_rand();\n    v18 = v25-- == 1;\n    v4 = v17;\n    if (v18) {\n      v19 = 0;\n      v20 = q;\n      libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n      v21 = q_head;\n      if (q_head > 0) {\n        do {\n          while (1) {\n            prim = v20->prim;\n            if (prim != 1) break;\n            val = v20->val;\n            ++v19;\n            ++v20;\n            libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\",\n                          val);\n            v21 = q_head;\n            if (v19 >= q_head) goto LABEL_34;\n          }\n          if (prim == 2) {\n            v24 = libmin_pow(16.0, v3);\n            libmin_printf(\n                \"Value %u is `likely prime' with failure probability (1 in \"\n                \"%.0lf)\\n\",\n                v20->val, v24);\n            v21 = q_head;\n          }\n          ++v19;\n          ++v20;\n        } while (v19 < v21);\n      }\n    LABEL_34:\n      libmin_success();\n    }\n  }\n}", "binary": "primal-test/primal-test.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x2a,%edi\npush   %r14\nmov    $0x3,%r14d\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   42e0 <libmin_srand>\nmovl   $0xc8,0xc(%rsp)\nnopw   0x0(%rax,%rax,1)\ntest   $0x1,%r14b\nje     1318 <main+0x218>\ncmp    $0x3,%r14d\nje     132c <main+0x22c>\ncmp    $0x2,%r14d\njbe    1277 <main+0x177>\nmov    %r14d,%ebx\nlea    -0x1(%r14),%r13d\nlea    -0x1(%rbx),%r12\nmov    %r12,%r15\nand    $0x1,%r15d\njne    1336 <main+0x236>\ncs nopw 0x0(%rax,%rax,1)\nshr    %r12\nadd    $0x1,%r15\ntest   $0x1,%r12b\nje     1170 <main+0x70>\nlea    -0x2(%r14),%eax\nmov    $0x10,%ebp\nsub    $0x1,%rax\nmov    %rax,(%rsp)\nxchg   %ax,%ax\ncall   4340 <libmin_rand>\nxor    %edx,%edx\nmov    %r12,%rcx\nmov    $0x1,%esi\nmov    %eax,%eax\ndivq   (%rsp)\nlea    0x2(%rdx),%r10\nnopl   0x0(%rax)\ntest   $0x1,%cl\nje     11c4 <main+0xc4>\nmov    %rsi,%rax\nxor    %edx,%edx\nimul   %r10,%rax\ndiv    %rbx\nmov    %rdx,%rsi\nmov    %r10,%rax\nxor    %edx,%edx\nimul   %r10,%rax\ndiv    %rbx\nshr    %rcx\nmov    %rdx,%r10\njne    11b0 <main+0xb0>\ncmp    $0x1,%rsi\nje     1238 <main+0x138>\ncmp    %rsi,%r13\nje     1238 <main+0x138>\ntest   %r15,%r15\nje     1277 <main+0x177>\nmov    %rsi,%rax\nxor    %edx,%edx\nimul   %rsi,%rax\ndiv    %rbx\ncmp    $0x1,%rdx\nje     1277 <main+0x177>\ncmp    %rdx,%r13\nje     1238 <main+0x138>\nmov    $0x1,%ecx\njmp    1227 <main+0x127>\nnopw   0x0(%rax,%rax,1)\nimul   %rdx,%rdx\nmov    %rdx,%rax\nxor    %edx,%edx\ndiv    %rbx\ncmp    $0x1,%rdx\nje     1277 <main+0x177>\ncmp    %rdx,%r13\nje     1238 <main+0x138>\nadd    $0x1,%rcx\ncmp    %r15,%rcx\njbe    1210 <main+0x110>\ncmp    %r13,%rdx\njne    1277 <main+0x177>\nnopl   (%rax)\nsub    $0x1,%ebp\njne    1190 <main+0x90>\nmov    $0x2,%ecx\ncs nopw 0x0(%rax,%rax,1)\nmovslq 0x7029(%rip),%rdx\nlea    0x7042(%rip),%rdi\nmov    %r14d,(%rdi,%rdx,8)\nmov    %rdx,%rax\nmov    %ecx,0x4(%rdi,%rdx,8)\ncmp    $0x3e,%edx\njg     1277 <main+0x177>\nadd    $0x1,%eax\nmov    %eax,0x7009(%rip)\ncall   4340 <libmin_rand>\nsubl   $0x1,0xc(%rsp)\nmov    %eax,%r14d\njne    1130 <main+0x30>\nmov    0x6ff0(%rip),%esi\nlea    0x3d71(%rip),%rdi\nxor    %eax,%eax\nxor    %ebp,%ebp\nlea    0x6ffe(%rip),%rbx\nlea    0x3dbf(%rip),%r13\ncall   40d0 <libmin_printf>\nmov    0x6fcc(%rip),%edx\nlea    0x3d75(%rip),%r12\ntest   %edx,%edx\njg     12d8 <main+0x1d8>\njmp    12fd <main+0x1fd>\nnopl   0x0(%rax)\ncmp    $0x2,%eax\nje     133e <main+0x23e>\nadd    $0x1,%ebp\nadd    $0x8,%rbx\ncmp    %edx,%ebp\njge    12fd <main+0x1fd>\nmov    0x4(%rbx),%eax\ncmp    $0x1,%eax\njne    12c8 <main+0x1c8>\nmov    (%rbx),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebp\nadd    $0x8,%rbx\ncall   40d0 <libmin_printf>\nmov    0x6f87(%rip),%edx\ncmp    %edx,%ebp\njl     12d8 <main+0x1d8>\ncall   4810 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%ecx\ncmp    $0x2,%r14d\nje     1250 <main+0x150>\njmp    1277 <main+0x177>\nmov    $0x1,%ecx\njmp    1250 <main+0x150>\nxor    %r15d,%r15d\njmp    117d <main+0x7d>\nmovsd  0x3d6a(%rip),%xmm1\nmovsd  0x3d6a(%rip),%xmm0\ncall   1820 <libmin_pow>\nmov    (%rbx),%esi\nmov    %r13,%rdi\nmov    $0x1,%eax\ncall   40d0 <libmin_printf>\nmov    0x6f18(%rip),%edx\njmp    12cd <main+0x1cd>\nnopl   (%rax)\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "miller_rabin_int", "content": "/*\n * This function checks whether a given number n is a prime or not, using the\n * Miller-Rabin primality test.  This is a probabilistic test which randomly\n * chooses an integer a as a base and checks whether n satisfies a certain\n * property (which depends on b).  If it does, n is a prime for at least three\n * out of four of the possible values of a, if it does not, it is certainly not\n * prime.\n *\n * The implementation is taken from the pseudo code found on\n * http://en.wikipedia.org/wiki/Miller-Rabin_primality_test.\n *\n * The function returns `probably_prime` if it found no evidence, that n might\n * be composite and `composite` if it did find a counter example.\n */\nint32_t\nmiller_rabin_int(uint32_t n, uint32_t k)\n{\n\tuint64_t s;\n\tuint64_t a = 0, d, x, nm1;\n\t/* We need an odd integer greater than 3 */\n\tif ((n & 1) == 0)\n\t\treturn n == 2 ? PT_PRIME : PT_COMPOSITE;\n\tif (n == 3)\n\t\treturn PT_PRIME;\n\telse if (n < 3)\n\t\treturn PT_COMPOSITE;\n\n\tnm1 = n - 1;\n\n\t/* compute s and d s.t. n-1=2^s*d */\n\tsplit_int(&s, &d, n);\n\n\t/* Repeat the test itself k times to increase the accuracy */\n\tfor (unsigned i = 0; i < k; i++) {\n\t\ta = get_random_int(2, n - 2);\n\n\t\t/* compute a^d mod n */\n\t\tx = powm(a, d, n);\n\n\t\tif (x == 1 || x == nm1)\n\t\t\tcontinue;\n\n\t\tfor (uint64_t r = 1; r <= s; r++) {\n\t\t\tx = (x * x) % n;\n\t\t\tif (x == 1)\n\t\t\t\treturn PT_COMPOSITE;\n\t\t\tif (x == nm1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (x != nm1)\n\t\t\treturn PT_COMPOSITE;\n\t}\n\n\treturn PT_PRIME_LIKELY;\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O3.pseudo", "function_name": "miller_rabin_int", "address": "0x14d0", "label": "miller_rabin_int", "content": "int32_t __fastcall miller_rabin_int(uint32_t n, uint32_t k)\n{\n  int32_t result; // eax\n  __int64 v3; // r15\n  unsigned __int64 v4; // r14\n  unsigned __int64 v6; // r13\n  int v7; // ebp\n  unsigned int v8; // eax\n  unsigned __int64 v9; // rsi\n  unsigned __int64 v10; // r8\n  unsigned __int64 v11; // rcx\n  unsigned __int64 v12; // rdx\n  __int64 v13; // rcx\n\n  if ( (n & 1) == 0 )\n    return n == 2;\n  result = 1;\n  if ( n != 3 )\n  {\n    if ( n <= 2 )\n    {\n      return 0;\n    }\n    else\n    {\n      v3 = n - 1;\n      v4 = n - 1LL;\n      v6 = ((_BYTE)n - 1) & 1;\n      if ( (((_BYTE)n - 1) & 1) != 0 )\n      {\n        v6 = 0LL;\n      }\n      else\n      {\n        do\n        {\n          v4 >>= 1;\n          ++v6;\n        }\n        while ( (v4 & 1) == 0 );\n      }\n      v7 = 0;\n      if ( k )\n      {\n        while ( 1 )\n        {\n          v8 = libmin_rand();\n          v9 = v4;\n          v10 = 1LL;\n          v11 = v8 % ((unsigned __int64)(n - 2) - 1) + 2;\n          do\n          {\n            if ( (v9 & 1) != 0 )\n              v10 = v11 * v10 % n;\n            v9 >>= 1;\n            v11 = v11 * v11 % n;\n          }\n          while ( v9 );\n          if ( v10 != 1 && v3 != v10 )\n          {\n            if ( !v6 )\n              return 0;\n            v12 = v10 * v10 % n;\n            if ( v12 == 1 )\n              return 0;\n            if ( v3 != v12 )\n            {\n              v13 = 1LL;\n              while ( ++v13 <= v6 )\n              {\n                v12 = v12 * v12 % n;\n                if ( v12 == 1 )\n                  return 0;\n                if ( v3 == v12 )\n                  goto LABEL_21;\n              }\n              if ( v3 != v12 )\n                return 0;\n            }\n          }\nLABEL_21:\n          if ( k == ++v7 )\n            return 2;\n        }\n      }\n      else\n      {\n        return 2;\n      }\n    }\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int32_t miller_rabin_int(uint32_t n, uint32_t k) {\n  int32_t result;\n  long long v3;\n  unsigned long long v4;\n  unsigned long long v6;\n  int v7;\n  unsigned int v8;\n  unsigned long long v9;\n  unsigned long long v10;\n  unsigned long long v11;\n  unsigned long long v12;\n  long long v13;\n  if ((n & 1) == 0) return n == 2;\n  result = 1;\n  if (n != 3) {\n    if (n <= 2) {\n      return 0;\n    } else {\n      v3 = n - 1;\n      v4 = n - 1LL;\n      v6 = ((uint8_t)n - 1) & 1;\n      if ((((uint8_t)n - 1) & 1) != 0) {\n        v6 = 0LL;\n      } else {\n        do {\n          v4 >>= 1;\n          ++v6;\n        } while ((v4 & 1) == 0);\n      }\n      v7 = 0;\n      if (k) {\n        while (1) {\n          v8 = libmin_rand();\n          v9 = v4;\n          v10 = 1LL;\n          v11 = v8 % ((unsigned long long)(n - 2) - 1) + 2;\n          do {\n            if ((v9 & 1) != 0) v10 = v11 * v10 % n;\n            v9 >>= 1;\n            v11 = v11 * v11 % n;\n          } while (v9);\n          if (v10 != 1 && v3 != v10) {\n            if (!v6) return 0;\n            v12 = v10 * v10 % n;\n            if (v12 == 1) return 0;\n            if (v3 != v12) {\n              v13 = 1LL;\n              while (++v13 <= v6) {\n                v12 = v12 * v12 % n;\n                if (v12 == 1) return 0;\n                if (v3 == v12) goto LABEL_21;\n              }\n              if (v3 != v12) return 0;\n            }\n          }\n        LABEL_21:\n          if (k == ++v7) return 2;\n        }\n      } else {\n        return 2;\n      }\n    }\n  }\n  return result;\n}", "binary": "primal-test/primal-test.host.O3", "assembly": "<miller_rabin_int>:\nendbr64\ntest   $0x1,%dil\nje     1608 <miller_rabin_int+0x138>\nmov    $0x1,%eax\ncmp    $0x3,%edi\nje     1602 <miller_rabin_int+0x132>\ncmp    $0x2,%edi\njbe    1600 <miller_rabin_int+0x130>\npush   %r15\nlea    -0x1(%rdi),%r15d\npush   %r14\npush   %r13\npush   %r12\nmov    %edi,%r12d\npush   %rbp\nlea    -0x1(%r12),%r14\npush   %rbx\nmov    %r14,%r13\nmov    %esi,%ebx\nsub    $0x18,%rsp\nand    $0x1,%r13d\njne    1629 <miller_rabin_int+0x159>\nxchg   %ax,%ax\nshr    %r14\nadd    $0x1,%r13\ntest   $0x1,%r14b\nje     1520 <miller_rabin_int+0x50>\nlea    -0x2(%rdi),%ebp\nlea    -0x1(%rbp),%rax\nxor    %ebp,%ebp\nmov    %rax,0x8(%rsp)\ntest   %ebx,%ebx\nje     15f3 <miller_rabin_int+0x123>\nnopl   0x0(%rax,%rax,1)\ncall   4340 <libmin_rand>\nxor    %edx,%edx\nmov    %r14,%rsi\nmov    $0x1,%r8d\nmov    %eax,%eax\ndivq   0x8(%rsp)\nlea    0x2(%rdx),%rcx\nnopl   0x0(%rax,%rax,1)\ntest   $0x1,%sil\nje     157d <miller_rabin_int+0xad>\nmov    %r8,%rax\nxor    %edx,%edx\nimul   %rcx,%rax\ndiv    %r12\nmov    %rdx,%r8\nimul   %rcx,%rcx\nxor    %edx,%edx\nmov    %rcx,%rax\ndiv    %r12\nshr    %rsi\nmov    %rdx,%rcx\njne    1568 <miller_rabin_int+0x98>\ncmp    $0x1,%r8\nje     15e8 <miller_rabin_int+0x118>\ncmp    %r8,%r15\nje     15e8 <miller_rabin_int+0x118>\ntest   %r13,%r13\nje     1618 <miller_rabin_int+0x148>\nmov    %r8,%rax\nxor    %edx,%edx\nimul   %r8,%rax\ndiv    %r12\ncmp    $0x1,%rdx\nje     1618 <miller_rabin_int+0x148>\ncmp    %rdx,%r15\nje     15e8 <miller_rabin_int+0x118>\nmov    $0x1,%ecx\njmp    15d7 <miller_rabin_int+0x107>\nnop\nimul   %rdx,%rdx\nmov    %rdx,%rax\nxor    %edx,%edx\ndiv    %r12\ncmp    $0x1,%rdx\nje     1618 <miller_rabin_int+0x148>\ncmp    %rdx,%r15\nje     15e8 <miller_rabin_int+0x118>\nadd    $0x1,%rcx\ncmp    %r13,%rcx\njbe    15c0 <miller_rabin_int+0xf0>\ncmp    %rdx,%r15\njne    1618 <miller_rabin_int+0x148>\nnopl   (%rax)\nadd    $0x1,%ebp\ncmp    %ebp,%ebx\njne    1548 <miller_rabin_int+0x78>\nmov    $0x2,%eax\njmp    161a <miller_rabin_int+0x14a>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nret\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncmp    $0x2,%edi\nsete   %al\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxor    %r13d,%r13d\njmp    152d <miller_rabin_int+0x5d>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "split_int", "content": "/*\n * Calculate s, d such that n-1=2^s*d where d is odd.\n */\nvoid split_int(uint64_t *s, uint64_t *d, uint64_t n)\n{\n\t*s = 0;\n\t*d = n - 1;\n\n\twhile ((*d & 1) == 0)\n  {\n\t\t(*s)++;\n\t\t*d /= 2;\n\t}\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O3.pseudo", "function_name": "split_int", "address": "0x1490", "label": "split_int", "content": "void __fastcall split_int(uint64_t *s, uint64_t *d, uint64_t n)\n{\n  uint64_t v3; // rdx\n  uint64_t v4; // rax\n\n  v3 = n - 1;\n  *s = 0LL;\n  *d = v3;\n  if ( (v3 & 1) == 0 )\n  {\n    do\n    {\n      ++*s;\n      v4 = *d >> 1;\n      *d = v4;\n    }\n    while ( (v4 & 1) == 0 );\n  }\n}\n"}, "pseudo_normalize": "void split_int(uint64_t *s, uint64_t *d, uint64_t n) {\n  uint64_t v3;\n  uint64_t v4;\n  v3 = n - 1;\n  *s = 0LL;\n  *d = v3;\n  if ((v3 & 1) == 0) {\n    do {\n      ++*s;\n      v4 = *d >> 1;\n      *d = v4;\n    } while ((v4 & 1) == 0);\n  }\n}", "binary": "primal-test/primal-test.host.O3", "assembly": "<split_int>:\nendbr64\nsub    $0x1,%rdx\nmovq   $0x0,(%rdi)\nmov    %rdx,(%rsi)\nand    $0x1,%edx\njne    14c1 <split_int+0x31>\nnopw   0x0(%rax,%rax,1)\naddq   $0x1,(%rdi)\nmov    (%rsi),%rax\nshr    %rax\nmov    %rax,(%rsi)\ntest   $0x1,%al\nje     14b0 <split_int+0x20>\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "isEmpty", "content": "// Function to check is list is empty\nint isEmpty(Node** head)\n{\n    return (*head) == NULL;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O3.pseudo", "function_name": "isEmpty", "address": "0x14b0", "label": "isEmpty", "content": "int __fastcall isEmpty(Node **head)\n{\n  return *head == 0LL;\n}\n"}, "pseudo_normalize": "", "binary": "priority-queue/priority-queue.host.O3", "assembly": "<isEmpty>:\nendbr64\nxor    %eax,%eax\ncmpq   $0x0,(%rdi)\nsete   %al\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "main", "content": "// Driver code\nint main()\n{\n    // Create a Priority Queue\n    // 7->4->5->6\n    Node* pq = newNode(4, 1);\n    push(&pq, 5, 2);\n    push(&pq, 6, 3);\n    push(&pq, 7, 0);\n    printPQ(&pq);\n\n    libmin_srand(42);\n    pq = newNode(4, 1);\n    for (int i=0; i < 250; i++)\n    {\n      int prio = libmin_rand() % 250;\n      int val = libmin_rand() % 250;\n      push(&pq, prio, val);\n    }\n    printPQ(&pq);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  Node *v4; // rax\n  Node *v5; // rax\n  Node *v6; // r14\n  unsigned int v7; // r13d\n  signed int v8; // ebx\n  Node *v9; // rax\n  node *v10; // rdx\n  node *v11; // rcx\n  Node *pq[7]; // [rsp+0h] [rbp-38h] BYREF\n\n  v3 = 250;\n  pq[1] = (Node *)__readfsqword(0x28u);\n  v4 = (Node *)libmin_malloc(0x10uLL);\n  v4->next = 0LL;\n  *(_QWORD *)&v4->data = 0x100000004LL;\n  pq[0] = v4;\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(0x2Au);\n  v5 = (Node *)libmin_malloc(0x10uLL);\n  *(_QWORD *)&v5->data = 0x100000004LL;\n  v6 = v5;\n  v5->next = 0LL;\n  pq[0] = v5;\n  while ( 1 )\n  {\n    v7 = libmin_rand();\n    v8 = libmin_rand() % 0xFA;\n    v9 = (Node *)libmin_malloc(0x10uLL);\n    *(_QWORD *)&v9->data = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v7 % 0xFA), _mm_cvtsi32_si128(v8)).m128i_u64[0];\n    v9->next = 0LL;\n    if ( v6->priority > v8 )\n    {\n      v9->next = v6;\n      v6 = v9;\n      pq[0] = v9;\n      if ( !--v3 )\n        goto LABEL_8;\n    }\n    else\n    {\n      v10 = v6;\n      do\n      {\n        v11 = v10;\n        v10 = v10->next;\n      }\n      while ( v10 && v10->priority < v8 );\n      v9->next = v10;\n      v11->next = v9;\n      if ( !--v3 )\n      {\nLABEL_8:\n        printPQ(pq);\n        libmin_success();\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  Node *v4;\n  Node *v5;\n  Node *v6;\n  unsigned int v7;\n  signed int v8;\n  Node *v9;\n  node *v10;\n  node *v11;\n  Node *pq[7];\n  v3 = 250;\n  pq[1] = (Node *)__readfsqword(40u);\n  v4 = (Node *)libmin_malloc(16uLL);\n  v4->next = 0LL;\n  *(uint64_t *)&v4->data = 4294967300LL;\n  pq[0] = v4;\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(42u);\n  v5 = (Node *)libmin_malloc(16uLL);\n  *(uint64_t *)&v5->data = 4294967300LL;\n  v6 = v5;\n  v5->next = 0LL;\n  pq[0] = v5;\n  while (1) {\n    v7 = libmin_rand();\n    v8 = libmin_rand() % 250;\n    v9 = (Node *)libmin_malloc(16uLL);\n    *(uint64_t *)&v9->data =\n        _mm_unpacklo_epi32(_mm_cvtsi32_si128(v7 % 250), _mm_cvtsi32_si128(v8))\n            .m128i_u64[0];\n    v9->next = 0LL;\n    if (v6->priority > v8) {\n      v9->next = v6;\n      v6 = v9;\n      pq[0] = v9;\n      if (!--v3) goto LABEL_8;\n    } else {\n      v10 = v6;\n      do {\n        v11 = v10;\n        v10 = v10->next;\n      } while (v10 && v10->priority < v8);\n      v9->next = v10;\n      v11->next = v9;\n      if (!--v3) {\n      LABEL_8:\n        printPQ(pq);\n        libmin_success();\n      }\n    }\n  }\n}", "binary": "priority-queue/priority-queue.host.O3", "assembly": "<main>:\nendbr64\npush   %r14\nmov    $0x10,%edi\npush   %r13\npush   %r12\npush   %rbp\nmov    $0xfa,%ebp\npush   %rbx\nsub    $0x10,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r12\ncall   1710 <libmin_malloc>\nmov    0x2ecf(%rip),%rbx\nmov    $0x2,%edx\nmov    %r12,%rdi\nmovq   $0x0,0x8(%rax)\nmov    $0x5,%esi\nmov    %rbx,(%rax)\nmov    %rax,(%rsp)\ncall   1420 <push>\nmov    $0x3,%edx\nmov    $0x6,%esi\nmov    %r12,%rdi\ncall   1420 <push>\nxor    %edx,%edx\nmov    $0x7,%esi\nmov    %r12,%rdi\ncall   1420 <push>\nmov    %r12,%rdi\ncall   14c0 <printPQ>\nmov    $0x2a,%edi\ncall   3c60 <libmin_srand>\nmov    $0x10,%edi\ncall   1710 <libmin_malloc>\nmov    %rbx,(%rax)\nmov    %rax,%r14\nmovq   $0x0,0x8(%rax)\nmov    %rax,(%rsp)\njmp    11e4 <main+0xc4>\nnopl   0x0(%rax,%rax,1)\nmov    %r14,0x8(%rax)\nmov    %rax,%r14\nmov    %rax,(%rsp)\nsub    $0x1,%ebp\nje     127a <main+0x15a>\ncall   3cc0 <libmin_rand>\nmov    %eax,%r13d\ncall   3cc0 <libmin_rand>\nmov    $0x10,%edi\nmov    %eax,%ebx\nmov    %r13d,%eax\nimul   $0x10624dd3,%rax,%rax\nshr    $0x24,%rax\nimul   $0xfa,%eax,%eax\nsub    %eax,%r13d\nmov    %ebx,%eax\nimul   $0x10624dd3,%rax,%rax\nmovd   %r13d,%xmm0\nshr    $0x24,%rax\nimul   $0xfa,%eax,%eax\nsub    %eax,%ebx\nmovd   %ebx,%xmm1\npunpckldq %xmm1,%xmm0\nmovq   %xmm0,%r13\ncall   1710 <libmin_malloc>\nmov    %r13,(%rax)\nmovq   $0x0,0x8(%rax)\ncmp    %ebx,0x4(%r14)\njg     11d0 <main+0xb0>\nmov    %r14,%rdx\njmp    125d <main+0x13d>\nnopl   0x0(%rax)\ncmp    %ebx,0x4(%rdx)\njge    1269 <main+0x149>\nmov    %rdx,%rcx\nmov    0x8(%rdx),%rdx\ntest   %rdx,%rdx\njne    1258 <main+0x138>\nmov    %rdx,0x8(%rax)\nmov    %rax,0x8(%rcx)\nsub    $0x1,%ebp\njne    11e4 <main+0xc4>\nmov    %r12,%rdi\ncall   14c0 <printPQ>\ncall   3eb0 <libmin_success>\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    12a6 <main+0x186>\nadd    $0x10,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "newNode", "content": "// Function to Create A New Node\nNode* newNode(int d, int p)\n{\n    Node* temp = (Node*)libmin_malloc(sizeof(Node));\n    temp->data = d;\n    temp->priority = p;\n    temp->next = NULL;\n\n    return temp;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O3.pseudo", "function_name": "newNode", "address": "0x13a0", "label": "newNode", "content": "Node *__fastcall newNode(int d, int p)\n{\n  Node *result; // rax\n  unsigned __int64 v3; // xmm0_8\n  unsigned __int64 v4; // [rsp+0h] [rbp-10h]\n\n  v4 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(d), _mm_cvtsi32_si128(p)).m128i_u64[0];\n  result = (Node *)libmin_malloc(0x10uLL);\n  v3 = v4;\n  result->next = 0LL;\n  *(_QWORD *)&result->data = v3;\n  return result;\n}\n"}, "pseudo_normalize": "Node *newNode(int d, int p) {\n  Node *result;\n  unsigned long long v3;\n  unsigned long long v4;\n  v4 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(d), _mm_cvtsi32_si128(p))\n           .m128i_u64[0];\n  result = (Node *)libmin_malloc(16uLL);\n  v3 = v4;\n  result->next = 0LL;\n  *(uint64_t *)&result->data = v3;\n  return result;\n}", "binary": "priority-queue/priority-queue.host.O3", "assembly": "<newNode>:\nendbr64\nmovd   %edi,%xmm0\nmovd   %esi,%xmm1\nsub    $0x18,%rsp\nmov    $0x10,%edi\npunpckldq %xmm1,%xmm0\nmovq   %xmm0,0x8(%rsp)\ncall   1710 <libmin_malloc>\nmovq   0x8(%rsp),%xmm0\nmovq   $0x0,0x8(%rax)\nmovq   %xmm0,(%rax)\nadd    $0x18,%rsp\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "peek", "content": "// Return the value at head\nint peek(Node** head)\n{\n    return (*head)->data;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O3.pseudo", "function_name": "peek", "address": "0x13e0", "label": "peek", "content": "int __fastcall peek(Node **head)\n{\n  return (*head)->data;\n}\n"}, "pseudo_normalize": "", "binary": "priority-queue/priority-queue.host.O3", "assembly": "<peek>:\nendbr64\nmov    (%rdi),%rax\nmov    (%rax),%eax\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "pop", "content": "// Removes the element with the\n// highest priority form the list\nvoid pop(Node** head)\n{\n    Node* temp = *head;\n    (*head) = (*head)->next;\n    libmin_free(temp);\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O3.pseudo", "function_name": "pop", "address": "0x1400", "label": "pop", "content": "void __fastcall pop(Node **head)\n{\n  Node *v1; // r8\n\n  v1 = *head;\n  *head = (*head)->next;\n  libmin_free(v1);\n}\n"}, "pseudo_normalize": "void pop(Node **head) {\n  Node *v1;\n  v1 = *head;\n  *head = (*head)->next;\n  libmin_free(v1);\n}", "binary": "priority-queue/priority-queue.host.O3", "assembly": "<pop>:\nendbr64\nmov    (%rdi),%r8\nmov    0x8(%r8),%rax\nmov    %rax,(%rdi)\nmov    %r8,%rdi\njmp    17c0 <libmin_free>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "printPQ", "content": "void\nprintPQ(Node** pq)\n{\n  libmin_printf(\"priorityQ: \");\n  while (!isEmpty(pq)) {\n      libmin_printf(\"<prio:%d, val:%d> \", priopeek(pq), peek(pq));\n      pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O3.pseudo", "function_name": "printPQ", "address": "0x14c0", "label": "printPQ", "content": "void __fastcall printPQ(Node **pq)\n{\n  Node *i; // rax\n  Node *v3; // rdi\n\n  libmin_printf(\"priorityQ: \");\n  for ( i = *pq; *pq; i = *pq )\n  {\n    libmin_printf(\"<prio:%d, val:%d> \", i->priority, i->data);\n    v3 = *pq;\n    *pq = (*pq)->next;\n    libmin_free(v3);\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void printPQ(Node **pq) {\n  Node *i;\n  Node *v3;\n  libmin_printf(\"priorityQ: \");\n  for (i = *pq; *pq; i = *pq) {\n    libmin_printf(\"<prio:%d, val:%d> \", i->priority, i->data);\n    v3 = *pq;\n    *pq = (*pq)->next;\n    libmin_free(v3);\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "priority-queue/priority-queue.host.O3", "assembly": "<printPQ>:\nendbr64\npush   %rbp\nxor    %eax,%eax\npush   %rbx\nmov    %rdi,%rbx\nlea    0x2b32(%rip),%rdi\nsub    $0x8,%rsp\ncall   3a50 <libmin_printf>\nmov    (%rbx),%rax\ntest   %rax,%rax\nje     1516 <printPQ+0x56>\nlea    0x2b26(%rip),%rbp\nnopw   0x0(%rax,%rax,1)\nmov    0x4(%rax),%esi\nmov    (%rax),%edx\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   3a50 <libmin_printf>\nmov    (%rbx),%rdi\nmov    0x8(%rdi),%rax\nmov    %rax,(%rbx)\ncall   17c0 <libmin_free>\nmov    (%rbx),%rax\ntest   %rax,%rax\njne    14f0 <printPQ+0x30>\nadd    $0x8,%rsp\nlea    0x2b02(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\njmp    3a50 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "priopeek", "content": "// Return the value at head\nint priopeek(Node** head)\n{\n    return (*head)->priority;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O3.pseudo", "function_name": "priopeek", "address": "0x13f0", "label": "priopeek", "content": "int __fastcall priopeek(Node **head)\n{\n  return (*head)->priority;\n}\n"}, "pseudo_normalize": "", "binary": "priority-queue/priority-queue.host.O3", "assembly": "<priopeek>:\nendbr64\nmov    (%rdi),%rax\nmov    0x4(%rax),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "push", "content": "// Function to push according to priority\nvoid push(Node** head, int d, int p)\n{\n    Node* start = (*head);\n\n    // Create new Node\n    Node* temp = newNode(d, p);\n\n    // Special Case: The head of list has lesser\n    // priority than new node. So insert new\n    // node before head node and change head node.\n    if ((*head)->priority > p) {\n\n        // Insert New Node before head\n        temp->next = *head;\n        (*head) = temp;\n    }\n    else {\n\n        // Traverse the list and find a\n        // position to insert new node\n        while (start->next != NULL &&\n               start->next->priority < p) {\n            start = start->next;\n        }\n\n        // Either at the ends of the list\n        // or at required position\n        temp->next = start->next;\n        start->next = temp;\n    }\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O3.pseudo", "function_name": "push", "address": "0x1420", "label": "push", "content": "void __fastcall push(Node **head, int d, int p)\n{\n  Node *v4; // rbx\n  Node *v5; // rax\n  Node *v6; // rdx\n  Node *v7; // rdx\n  unsigned __int64 v8; // [rsp+0h] [rbp-20h]\n\n  v4 = *head;\n  v8 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(d), _mm_cvtsi32_si128(p)).m128i_u64[0];\n  v5 = (Node *)libmin_malloc(0x10uLL);\n  v5->next = 0LL;\n  v6 = *head;\n  *(_QWORD *)&v5->data = v8;\n  if ( v6->priority <= p )\n  {\n    do\n    {\n      v7 = v4;\n      v4 = v4->next;\n    }\n    while ( v4 && v4->priority < p );\n    v5->next = v4;\n    v7->next = v5;\n  }\n  else\n  {\n    v5->next = v6;\n    *head = v5;\n  }\n}\n"}, "pseudo_normalize": "void push(Node **head, int d, int p) {\n  Node *v4;\n  Node *v5;\n  Node *v6;\n  Node *v7;\n  unsigned long long v8;\n  v4 = *head;\n  v8 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(d), _mm_cvtsi32_si128(p))\n           .m128i_u64[0];\n  v5 = (Node *)libmin_malloc(16uLL);\n  v5->next = 0LL;\n  v6 = *head;\n  *(uint64_t *)&v5->data = v8;\n  if (v6->priority <= p) {\n    do {\n      v7 = v4;\n      v4 = v4->next;\n    } while (v4 && v4->priority < p);\n    v5->next = v4;\n    v7->next = v5;\n  } else {\n    v5->next = v6;\n    *head = v5;\n  }\n}", "binary": "priority-queue/priority-queue.host.O3", "assembly": "<push>:\nendbr64\npush   %r12\nmovd   %edx,%xmm1\nmovd   %esi,%xmm0\nmov    %rdi,%r12\npush   %rbp\npunpckldq %xmm1,%xmm0\nmov    %edx,%ebp\npush   %rbx\nsub    $0x10,%rsp\nmov    (%rdi),%rbx\nmov    $0x10,%edi\nmovq   %xmm0,0x8(%rsp)\ncall   1710 <libmin_malloc>\nmovq   0x8(%rsp),%xmm0\nmovq   $0x0,0x8(%rax)\nmov    (%r12),%rdx\nmovq   %xmm0,(%rax)\ncmp    %ebp,0x4(%rdx)\njle    1485 <push+0x65>\nmov    %rdx,0x8(%rax)\nmov    %rax,(%r12)\nadd    $0x10,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopl   0x0(%rax)\ncmp    %ebp,0x4(%rbx)\njge    1491 <push+0x71>\nmov    %rbx,%rdx\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\njne    1480 <push+0x60>\nmov    %rbx,0x8(%rax)\nmov    %rax,0x8(%rdx)\nadd    $0x10,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "cstring_cmp", "content": "/* qsort C-string comparison function */\nint\ncstring_cmp(const void *a, const void *b)\n{\n    const char **ia = (const char **)a;\n    const char **ib = (const char **)b;\n    return libmin_strcmp(*ia, *ib);\n    /* strcmp functions works exactly as expected from\n    comparison function */\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O3.pseudo", "function_name": "cstring_cmp", "address": "0x1280", "label": "cstring_cmp", "content": "int __fastcall cstring_cmp(const void *a, const void *b)\n{\n  return libmin_strcmp(*(const char **)a, *(const char **)b);\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O3", "assembly": "<cstring_cmp>:\nendbr64\nmov    (%rsi),%rsi\nmov    (%rdi),%rdi\njmp    3da0 <libmin_strcmp>\nnop\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "int_cmp", "content": "#include \"libmin.h\"\n\n/* qsort int comparison function */\nint\nint_cmp(const void *a, const void *b)\n{\n    const int *ia = (const int *)a; // casting pointer types\n    const int *ib = (const int *)b;\n    return *ia  - *ib;\n    /* integer comparison: returns negative if a < b\n    and positive if a > b */\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O3.pseudo", "function_name": "int_cmp", "address": "0x1240", "label": "int_cmp", "content": "int __fastcall int_cmp(const void *a, const void *b)\n{\n  return *(_DWORD *)a - *(_DWORD *)b;\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O3", "assembly": "<int_cmp>:\nendbr64\nmov    (%rdi),%eax\nsub    (%rsi),%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "main", "content": "/* MAIN program (calls all other examples) */\nint\nmain(void)\n{\n    /* run all example functions */\n    sort_integers_example();\n    sort_cstrings_example();\n    sort_structs_example();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}", "binary": "qsort-demo/qsort-demo.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\ncall   1310 <sort_integers_example>\ncall   1480 <sort_cstrings_example>\ncall   1630 <sort_structs_example>\ncall   3e30 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "print_cstring_array", "content": "/* C-string array printing function */\nvoid\nprint_cstring_array(char **array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"%s | \", array[i]);\n\n    libmin_putc('\\n');\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O3.pseudo", "function_name": "print_cstring_array", "address": "0x1410", "label": "print_cstring_array", "content": "void __fastcall print_cstring_array(char **array, size_t len)\n{\n  __int64 i; // rbx\n  const char *v4; // rsi\n\n  if ( len )\n  {\n    for ( i = 0LL; i != len; ++i )\n    {\n      v4 = array[i];\n      libmin_printf(\"%s | \", v4);\n    }\n  }\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "void print_cstring_array(char **array, unsigned int len) {\n  long long i;\n  const char *v4;\n  if (len) {\n    for (i = 0LL; i != len; ++i) {\n      v4 = array[i];\n      libmin_printf(\"%s | \", v4);\n    }\n  }\n  libmin_putc(10);\n}", "binary": "qsort-demo/qsort-demo.host.O3", "assembly": "<print_cstring_array>:\nendbr64\ntest   %rsi,%rsi\nje     1468 <print_cstring_array+0x58>\npush   %r13\nlea    0x3bff(%rip),%r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x8,%rsp\nnopw   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,8),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   38e0 <libmin_printf>\ncmp    %rbx,%rbp\njne    1438 <print_cstring_array+0x28>\nadd    $0x8,%rsp\nmov    $0xa,%edi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    3af0 <libmin_putc>\nnopl   0x0(%rax,%rax,1)\nmov    $0xa,%edi\njmp    3af0 <libmin_putc>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "print_int_array", "content": "/* integer array printing function */\nvoid\nprint_int_array(const int *array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"%d | \", array[i]);\n\n    libmin_putc('\\n');\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O3.pseudo", "function_name": "print_int_array", "address": "0x12a0", "label": "print_int_array", "content": "void __fastcall print_int_array(const int *array, size_t len)\n{\n  __int64 i; // rbx\n  int v4; // esi\n\n  if ( len )\n  {\n    for ( i = 0LL; i != len; ++i )\n    {\n      v4 = array[i];\n      libmin_printf(\"%d | \", v4);\n    }\n  }\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "void print_int_array(const int *array, unsigned int len) {\n  long long i;\n  int v4;\n  if (len) {\n    for (i = 0LL; i != len; ++i) {\n      v4 = array[i];\n      libmin_printf(\"%d | \", v4);\n    }\n  }\n  libmin_putc(10);\n}", "binary": "qsort-demo/qsort-demo.host.O3", "assembly": "<print_int_array>:\nendbr64\ntest   %rsi,%rsi\nje     12f8 <print_int_array+0x58>\npush   %r13\nlea    0x3d52(%rip),%r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x8,%rsp\nnopw   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,4),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   38e0 <libmin_printf>\ncmp    %rbx,%rbp\njne    12c8 <print_int_array+0x28>\nadd    $0x8,%rsp\nmov    $0xa,%edi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    3af0 <libmin_putc>\nnopl   0x0(%rax,%rax,1)\nmov    $0xa,%edi\njmp    3af0 <libmin_putc>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "print_struct_array", "content": "/* Example struct array printing function */\nvoid\nprint_struct_array(struct st_ex *array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array[i].product, array[i].price);\n\n    libmin_puts(\"--\");\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O3.pseudo", "function_name": "print_struct_array", "address": "0x15b0", "label": "print_struct_array", "content": "void __fastcall print_struct_array(st_ex *array, size_t len)\n{\n  __int64 v3; // rbp\n  st_ex *v5; // rsi\n  double price; // xmm0_8\n\n  if ( len )\n  {\n    v3 = 0LL;\n    do\n    {\n      v5 = array;\n      ++v3;\n      price = array->price;\n      ++array;\n      libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v5->product, price);\n    }\n    while ( len != v3 );\n  }\n  libmin_puts(\"--\");\n}\n"}, "pseudo_normalize": "void print_struct_array(st_ex *array, unsigned int len) {\n  long long v3;\n  st_ex *v5;\n  double price;\n  if (len) {\n    v3 = 0LL;\n    do {\n      v5 = array;\n      ++v3;\n      price = array->price;\n      ++array;\n      libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v5->product, price);\n    } while (len != v3);\n  }\n  libmin_puts(\"--\");\n}", "binary": "qsort-demo/qsort-demo.host.O3", "assembly": "<print_struct_array>:\nendbr64\ntest   %rsi,%rsi\nje     1618 <print_struct_array+0x68>\npush   %r13\nlea    0x3ac6(%rip),%r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x8,%rsp\nnopw   0x0(%rax,%rax,1)\nmov    %rbx,%rsi\npxor   %xmm0,%xmm0\nmov    %r13,%rdi\nmov    $0x1,%eax\nadd    $0x1,%rbp\ncvtss2sd 0x10(%rbx),%xmm0\nadd    $0x14,%rbx\ncall   38e0 <libmin_printf>\ncmp    %rbp,%r12\njne    15d8 <print_struct_array+0x28>\nadd    $0x8,%rsp\nlea    0x3a59(%rip),%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    3b00 <libmin_puts>\nnopl   0x0(%rax)\nlea    0x3a43(%rip),%rdi\njmp    3b00 <libmin_puts>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "sort_cstrings_example", "content": "/* sorting C-strings array using qsort() example */\nvoid\nsort_cstrings_example(void)\n{\n    char *strings[] = { \"Zorro\", \"Alex\", \"Celine\", \"Bill\", \"Forest\", \"Dexter\" };\n    size_t strings_len = sizeof(strings) / sizeof(char *);\n\n    /* STRING */\n    libmin_puts(\"*** String sorting...\");\n\n    /* print original string array */\n    print_cstring_array(strings, strings_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(strings, strings_len, sizeof(char *), cstring_cmp);\n\n    /* print sorted string array */\n    print_cstring_array(strings, strings_len);\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O3.pseudo", "function_name": "sort_cstrings_example", "address": "0x1480", "label": "sort_cstrings_example", "content": "void __cdecl sort_cstrings_example()\n{\n  char **v0; // rbx\n  char **v1; // rbp\n  const char *v2; // rsi\n  const char *v3; // rsi\n  char *strings[6]; // [rsp+0h] [rbp-68h] BYREF\n  char v5; // [rsp+30h] [rbp-38h] BYREF\n  unsigned __int64 v6; // [rsp+38h] [rbp-30h]\n\n  v6 = __readfsqword(0x28u);\n  v0 = strings;\n  v1 = strings;\n  *(__m128i *)strings = _mm_unpacklo_epi64((__m128i)(unsigned __int64)\"Zorro\", (__m128i)(unsigned __int64)\"Alex\");\n  *(__m128i *)&strings[2] = _mm_unpacklo_epi64((__m128i)(unsigned __int64)\"Celine\", (__m128i)(unsigned __int64)\"Bill\");\n  *(__m128i *)&strings[4] = _mm_unpacklo_epi64((__m128i)(unsigned __int64)\"Forest\", (__m128i)(unsigned __int64)\"Dexter\");\n  libmin_puts(\"*** String sorting...\");\n  do\n  {\n    v2 = *v1++;\n    libmin_printf(\"%s | \", v2);\n  }\n  while ( v1 != (char **)&v5 );\n  libmin_putc(10);\n  libmin_qsort(strings, 6uLL, 8uLL, cstring_cmp);\n  do\n  {\n    v3 = *v0++;\n    libmin_printf(\"%s | \", v3);\n  }\n  while ( v0 != (char **)&v5 );\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "void sort_cstrings_example() {\n  char **v0;\n  char **v1;\n  const char *v2;\n  const char *v3;\n  char *strings[6];\n  char v5;\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  v0 = strings;\n  v1 = strings;\n  *(__m128i *)strings = _mm_unpacklo_epi64((__m128i)(unsigned long long)\"Zorro\",\n                                           (__m128i)(unsigned long long)\"Alex\");\n  *(__m128i *)&strings[2] =\n      _mm_unpacklo_epi64((__m128i)(unsigned long long)\"Celine\",\n                         (__m128i)(unsigned long long)\"Bill\");\n  *(__m128i *)&strings[4] =\n      _mm_unpacklo_epi64((__m128i)(unsigned long long)\"Forest\",\n                         (__m128i)(unsigned long long)\"Dexter\");\n  libmin_puts(\"*** String sorting...\");\n  do {\n    v2 = *v1++;\n    libmin_printf(\"%s | \", v2);\n  } while (v1 != (char **)&v5);\n  libmin_putc(10);\n  libmin_qsort(strings, 6uLL, 8uLL, cstring_cmp);\n  do {\n    v3 = *v0++;\n    libmin_printf(\"%s | \", v3);\n  } while (v0 != (char **)&v5);\n  libmin_putc(10);\n}", "binary": "qsort-demo/qsort-demo.host.O3", "assembly": "<sort_cstrings_example>:\nendbr64\npush   %r14\nlea    0x3b9a(%rip),%rdx\nlea    0x3baa(%rip),%rcx\npush   %r13\nmovq   %rdx,%xmm0\nlea    0x3b90(%rip),%rdx\nlea    0x3ba3(%rip),%rdi\npush   %r12\nlea    0x3b6f(%rip),%r13\npush   %rbp\npush   %rbx\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nlea    0x3b60(%rip),%rax\nmov    %rsp,%r14\nlea    0x30(%rsp),%r12\nmov    %r14,%rbx\nmov    %r14,%rbp\nmovq   %rax,%xmm1\nlea    0x3b52(%rip),%rax\npunpcklqdq %xmm1,%xmm0\nmovq   %rax,%xmm2\nlea    0x3b4e(%rip),%rax\nmovaps %xmm0,(%rsp)\nmovq   %rdx,%xmm0\nmovq   %rax,%xmm3\npunpcklqdq %xmm2,%xmm0\nmovaps %xmm0,0x10(%rsp)\nmovq   %rcx,%xmm0\npunpcklqdq %xmm3,%xmm0\nmovaps %xmm0,0x20(%rsp)\ncall   3b00 <libmin_puts>\nnopl   0x0(%rax)\nmov    0x0(%rbp),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x8,%rbp\ncall   38e0 <libmin_printf>\ncmp    %r12,%rbp\njne    1528 <sort_cstrings_example+0xa8>\nmov    $0xa,%edi\ncall   3af0 <libmin_putc>\nlea    -0x2d0(%rip),%rcx\nmov    $0x8,%edx\nmov    %r14,%rdi\nmov    $0x6,%esi\ncall   3d70 <libmin_qsort>\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x8,%rbx\ncall   38e0 <libmin_printf>\ncmp    %r12,%rbx\njne    1568 <sort_cstrings_example+0xe8>\nmov    $0xa,%edi\ncall   3af0 <libmin_putc>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    15a5 <sort_cstrings_example+0x125>\nadd    $0x40,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10c0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "sort_integers_example", "content": "/* sorting integers using qsort() example */\nvoid\nsort_integers_example(void)\n{\n    int numbers[] = { 7, 3, 4, 1, -1, 23, 12, 43, 2, -4, 5 };\n    size_t numbers_len = sizeof(numbers)/sizeof(int);\n\n    libmin_puts(\"*** Integer sorting...\");\n\n    /* print original integer array */\n    print_int_array(numbers, numbers_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(numbers, numbers_len, sizeof(int), int_cmp);\n\n    /* print sorted integer array */\n    print_int_array(numbers, numbers_len);\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O3.pseudo", "function_name": "sort_integers_example", "address": "0x1310", "label": "sort_integers_example", "content": "void __cdecl sort_integers_example()\n{\n  int *v0; // rbx\n  int *v1; // rbp\n  int v2; // esi\n  int v3; // esi\n  int numbers[11]; // [rsp+0h] [rbp-68h] BYREF\n  _BYTE v5[12]; // [rsp+2Ch] [rbp-3Ch] BYREF\n  unsigned __int64 v6; // [rsp+38h] [rbp-30h]\n\n  v6 = __readfsqword(0x28u);\n  numbers[10] = 5;\n  *(__m128i *)numbers = _mm_load_si128((const __m128i *)&xmmword_50D0);\n  v0 = numbers;\n  v1 = numbers;\n  *(_QWORD *)&numbers[8] = 0xFFFFFFFC00000002LL;\n  *(__m128i *)&numbers[4] = _mm_load_si128((const __m128i *)&xmmword_50E0);\n  libmin_puts(\"*** Integer sorting...\");\n  do\n  {\n    v2 = *v1++;\n    libmin_printf(\"%d | \", v2);\n  }\n  while ( v1 != (int *)v5 );\n  libmin_putc(10);\n  libmin_qsort(numbers, 0xBuLL, 4uLL, int_cmp);\n  do\n  {\n    v3 = *v0++;\n    libmin_printf(\"%d | \", v3);\n  }\n  while ( v0 != (int *)v5 );\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "void sort_integers_example() {\n  int *v0;\n  int *v1;\n  int v2;\n  int v3;\n  int numbers[11];\n  uint8_t v5[12];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  numbers[10] = 5;\n  *(__m128i *)numbers = _mm_load_si128((const __m128i *)&xmmword_50D0);\n  v0 = numbers;\n  v1 = numbers;\n  *(uint64_t *)&numbers[8] = 18446744056529682434LL;\n  *(__m128i *)&numbers[4] = _mm_load_si128((const __m128i *)&xmmword_50E0);\n  libmin_puts(\"*** Integer sorting...\");\n  do {\n    v2 = *v1++;\n    libmin_printf(\"%d | \", v2);\n  } while (v1 != (int *)v5);\n  libmin_putc(10);\n  libmin_qsort(numbers, 11uLL, 4uLL, int_cmp);\n  do {\n    v3 = *v0++;\n    libmin_printf(\"%d | \", v3);\n  } while (v0 != (int *)v5);\n  libmin_putc(10);\n}", "binary": "qsort-demo/qsort-demo.host.O3", "assembly": "<sort_integers_example>:\nendbr64\npush   %r14\nlea    0x3ced(%rip),%rdi\npush   %r13\nlea    0x3cde(%rip),%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x40,%rsp\nmovdqa 0x3d9a(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nmov    0x3de3(%rip),%rax\nmov    %rsp,%r14\nmovl   $0x5,0x28(%rsp)\nmovaps %xmm0,(%rsp)\nmov    %r14,%rbx\nlea    0x2c(%rsp),%r12\nmov    %r14,%rbp\nmovdqa 0x3d71(%rip),%xmm0\nmov    %rax,0x20(%rsp)\nmovaps %xmm0,0x10(%rsp)\ncall   3b00 <libmin_puts>\nxchg   %ax,%ax\nmov    0x0(%rbp),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbp\ncall   38e0 <libmin_printf>\ncmp    %r12,%rbp\njne    1380 <sort_integers_example+0x70>\nmov    $0xa,%edi\ncall   3af0 <libmin_putc>\nlea    -0x167(%rip),%rcx\nmov    $0x4,%edx\nmov    %r14,%rdi\nmov    $0xb,%esi\ncall   3d70 <libmin_qsort>\nnopl   0x0(%rax)\nmov    (%rbx),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   38e0 <libmin_printf>\ncmp    %r12,%rbx\njne    13c0 <sort_integers_example+0xb0>\nmov    $0xa,%edi\ncall   3af0 <libmin_putc>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    13fc <sort_integers_example+0xec>\nadd    $0x40,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10c0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "sort_structs_example", "content": "/* sorting structs using qsort() example */\nvoid\nsort_structs_example(void)\n{\n    struct st_ex structs[] = {{\"mp3 player\", 299.0f}, {\"plasma tv\", 2200.0f},\n                              {\"notebook\", 1300.0f}, {\"smartphone\", 499.99f},\n                              {\"dvd player\", 150.0f}, {\"matches\", 0.2f }};\n\n    size_t structs_len = sizeof(structs) / sizeof(struct st_ex);\n\n    libmin_puts(\"*** Struct sorting (price)...\");\n\n    /* print original struct array */\n    print_struct_array(structs, structs_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(structs, structs_len, sizeof(struct st_ex), struct_cmp_by_price);\n\n    /* print sorted struct array */\n    print_struct_array(structs, structs_len);\n\n    libmin_puts(\"*** Struct sorting (product)...\");\n\n    /* resort using other comparision function */\n    libmin_qsort(structs, structs_len, sizeof(struct st_ex), struct_cmp_by_product);\n\n    /* print sorted struct array */\n    print_struct_array(structs, structs_len);\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O3.pseudo", "function_name": "sort_structs_example", "address": "0x1630", "label": "sort_structs_example", "content": "void __cdecl sort_structs_example()\n{\n  st_ex *v0; // rbx\n  st_ex *v1; // rbp\n  st_ex *v2; // rbp\n  st_ex structs[6]; // [rsp+0h] [rbp-B8h] BYREF\n  _QWORD v4[8]; // [rsp+78h] [rbp-40h] BYREF\n\n  v4[0] = __readfsqword(0x28u);\n  structs[2].product[9] = 0;\n  *(_WORD *)&structs[2].product[10] = 0;\n  *(_DWORD *)&structs[2].product[12] = 0;\n  *(__m128i *)structs[0].product = _mm_load_si128((const __m128i *)&xmmword_50F0);\n  v0 = structs;\n  v1 = structs;\n  structs[0].price = 299.0;\n  strcpy(structs[2].product, \"notebook\");\n  *(__m128i *)structs[1].product = _mm_load_si128((const __m128i *)&xmmword_5100);\n  structs[1].price = 2200.0;\n  *(__m128i *)structs[3].product = _mm_load_si128((const __m128i *)&xmmword_5110);\n  structs[2].price = 1300.0;\n  structs[3].price = 499.98999;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(_QWORD *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  *(__m128i *)structs[4].product = _mm_load_si128((const __m128i *)&xmmword_5120);\n  libmin_puts(\"*** Struct sorting (price)...\");\n  do\n  {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v1->product, v1->price);\n    ++v1;\n  }\n  while ( v1 != (st_ex *)v4 );\n  v2 = structs;\n  libmin_puts(\"--\");\n  libmin_qsort(structs, 6uLL, 0x14uLL, struct_cmp_by_price);\n  do\n  {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v2->product, v2->price);\n    ++v2;\n  }\n  while ( v2 != (st_ex *)v4 );\n  libmin_puts(\"--\");\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 0x14uLL, struct_cmp_by_product);\n  do\n  {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v0->product, v0->price);\n    ++v0;\n  }\n  while ( v0 != (st_ex *)v4 );\n  libmin_puts(\"--\");\n}\n"}, "pseudo_normalize": "void sort_structs_example() {\n  st_ex *v0;\n  st_ex *v1;\n  st_ex *v2;\n  st_ex structs[6];\n  uint64_t v4[8];\n  v4[0] = __readfsqword(40u);\n  structs[2].product[9] = 0;\n  *(unsigned short *)&structs[2].product[10] = 0;\n  *(uint32_t *)&structs[2].product[12] = 0;\n  *(__m128i *)structs[0].product =\n      _mm_load_si128((const __m128i *)&xmmword_50F0);\n  v0 = structs;\n  v1 = structs;\n  structs[0].price = 299.0;\n  strcpy(structs[2].product, \"notebook\");\n  *(__m128i *)structs[1].product =\n      _mm_load_si128((const __m128i *)&xmmword_5100);\n  structs[1].price = 2200.0;\n  *(__m128i *)structs[3].product =\n      _mm_load_si128((const __m128i *)&xmmword_5110);\n  structs[2].price = 1300.0;\n  structs[3].price = 499.98999;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(uint64_t *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  *(__m128i *)structs[4].product =\n      _mm_load_si128((const __m128i *)&xmmword_5120);\n  libmin_puts(\"*** Struct sorting (price)...\");\n  do {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v1->product, v1->price);\n    ++v1;\n  } while (v1 != (st_ex *)v4);\n  v2 = structs;\n  libmin_puts(\"--\");\n  libmin_qsort(structs, 6uLL, 20uLL, struct_cmp_by_price);\n  do {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v2->product, v2->price);\n    ++v2;\n  } while (v2 != (st_ex *)v4);\n  libmin_puts(\"--\");\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 20uLL, struct_cmp_by_product);\n  do {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v0->product, v0->price);\n    ++v0;\n  } while (v0 != (st_ex *)v4);\n  libmin_puts(\"--\");\n}", "binary": "qsort-demo/qsort-demo.host.O3", "assembly": "<sort_structs_example>:\nendbr64\npush   %r15\nxor    %edx,%edx\nlea    0x3a26(%rip),%rdi\npush   %r14\npush   %r13\nlea    0x3a3e(%rip),%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x88,%rsp\nmovdqa 0x3a93(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x78(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r14\nmov    %rdx,0x30(%rsp)\nxor    %edx,%edx\nmovaps %xmm0,(%rsp)\nmov    %r14,%rbx\nlea    0x78(%rsp),%r12\nmov    %r14,%rbp\nmovdqa 0x3a72(%rip),%xmm0\nmovl   $0x43958000,0x10(%rsp)\nmovabs $0x6b6f6f6265746f6e,%rax\nmov    %rax,0x28(%rsp)\nmovabs $0x7365686374616d,%rax\nmovups %xmm0,0x14(%rsp)\nmovdqa 0x3a54(%rip),%xmm0\nmovl   $0x45098000,0x24(%rsp)\nmovups %xmm0,0x3c(%rsp)\nmovdqa 0x3a4f(%rip),%xmm0\nmovl   $0x44a28000,0x38(%rsp)\nmovl   $0x43f9feb8,0x4c(%rsp)\nmovl   $0x43160000,0x60(%rsp)\nmov    %rax,0x64(%rsp)\nmov    %rdx,0x6c(%rsp)\nmovl   $0x3e4ccccd,0x74(%rsp)\nmovaps %xmm0,0x50(%rsp)\ncall   3b00 <libmin_puts>\nnopl   (%rax)\npxor   %xmm0,%xmm0\nmov    %rbp,%rsi\nmov    %r13,%rdi\nmov    $0x1,%eax\ncvtss2sd 0x10(%rbp),%xmm0\ncall   38e0 <libmin_printf>\nadd    $0x14,%rbp\ncmp    %r12,%rbp\njne    1708 <sort_structs_example+0xd8>\nlea    0x3931(%rip),%r15\nmov    %r14,%rbp\nmov    %r15,%rdi\ncall   3b00 <libmin_puts>\nlea    -0x4f3(%rip),%rcx\nmov    $0x14,%edx\nmov    %r14,%rdi\nmov    $0x6,%esi\ncall   3d70 <libmin_qsort>\nnopl   (%rax)\npxor   %xmm0,%xmm0\nmov    %rbp,%rsi\nmov    %r13,%rdi\nmov    $0x1,%eax\ncvtss2sd 0x10(%rbp),%xmm0\ncall   38e0 <libmin_printf>\nadd    $0x14,%rbp\ncmp    %r12,%rbp\njne    1758 <sort_structs_example+0x128>\nmov    %r15,%rdi\ncall   3b00 <libmin_puts>\nlea    0x391f(%rip),%rdi\ncall   3b00 <libmin_puts>\nlea    -0x505(%rip),%rcx\nmov    $0x14,%edx\nmov    %r14,%rdi\nmov    $0x6,%esi\ncall   3d70 <libmin_qsort>\nnopw   0x0(%rax,%rax,1)\npxor   %xmm0,%xmm0\nmov    %rbx,%rsi\nmov    %r13,%rdi\nmov    $0x1,%eax\ncvtss2sd 0x10(%rbx),%xmm0\ncall   38e0 <libmin_printf>\nadd    $0x14,%rbx\ncmp    %r12,%rbx\njne    17b0 <sort_structs_example+0x180>\nmov    %r15,%rdi\ncall   3b00 <libmin_puts>\nmov    0x78(%rsp),%rax\nsub    %fs:0x28,%rax\njne    17fc <sort_structs_example+0x1cc>\nadd    $0x88,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "struct_cmp_by_price", "content": "/* qsort struct comparision function (price float field) */\nint\nstruct_cmp_by_price(const void *a, const void *b)\n{\n    struct st_ex *ia = (struct st_ex *)a;\n    struct st_ex *ib = (struct st_ex *)b;\n    return (int)(100.f*ia->price - 100.f*ib->price);\n    /* float comparison: returns negative if b > a\n    and positive if a > b. We multiplied result by 100.0\n    to preserve decimal fraction */\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O3.pseudo", "function_name": "struct_cmp_by_price", "address": "0x1250", "label": "struct_cmp_by_price", "content": "int __fastcall struct_cmp_by_price(const void *a, const void *b)\n{\n  return (int)(float)((float)(*((float *)a + 4) * 100.0) - (float)(100.0 * *((float *)b + 4)));\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O3", "assembly": "<struct_cmp_by_price>:\nendbr64\nmovss  0x3e6c(%rip),%xmm0\nmovss  0x10(%rdi),%xmm1\nmulss  %xmm0,%xmm1\nmulss  0x10(%rsi),%xmm0\nsubss  %xmm0,%xmm1\ncvttss2si %xmm1,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "struct_cmp_by_product", "content": "/* qsort struct comparision function (product C-string field) */\nint\nstruct_cmp_by_product(const void *a, const void *b)\n{\n    struct st_ex *ia = (struct st_ex *)a;\n    struct st_ex *ib = (struct st_ex *)b;\n    return libmin_strcmp(ia->product, ib->product);\n    /* strcmp functions works exactly as expected from\n    comparison function */\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O3.pseudo", "function_name": "struct_cmp_by_product", "address": "0x1290", "label": "struct_cmp_by_product", "content": "int __fastcall struct_cmp_by_product(const void *a, const void *b)\n{\n  return libmin_strcmp((const char *)a, (const char *)b);\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O3", "assembly": "<struct_cmp_by_product>:\nendbr64\njmp    3da0 <libmin_strcmp>\nnopl   0x0(%rax)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "int_compare", "content": "#include \"libmin.h\"\n\n/* Comparison function for integers. */\nint int_compare(const void *a, const void *b) {\n    const int *ia = (const int *) a;\n    const int *ib = (const int *) b;\n    return (*ia) - (*ib);\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O3.pseudo", "function_name": "int_compare", "address": "0x1990", "label": "int_compare", "content": "int __fastcall int_compare(const void *a, const void *b)\n{\n  return *(_DWORD *)a - *(_DWORD *)b;\n}\n"}, "pseudo_normalize": "", "binary": "qsort-test/qsort-test.host.O3", "assembly": "<int_compare>:\nendbr64\nmov    (%rdi),%eax\nsub    (%rsi),%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "is_sorted", "content": "/* Utility function to check if an array of integers is sorted (non-decreasing order). */\nint is_sorted(const int arr[], size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        if (arr[i - 1] > arr[i])\n            return 0;\n    }\n    return 1;\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O3.pseudo", "function_name": "is_sorted", "address": "0x19b0", "label": "is_sorted", "content": "int __fastcall is_sorted(const int *arr, size_t n)\n{\n  int v2; // edx\n  __int64 v3; // rax\n  int v4; // ecx\n\n  if ( n <= 1 )\n    return 1;\n  v2 = *arr;\n  v3 = 1LL;\n  while ( 1 )\n  {\n    v4 = v2;\n    v2 = arr[v3];\n    if ( v2 < v4 )\n      break;\n    if ( n == ++v3 )\n      return 1;\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int is_sorted(const int *arr, unsigned int n) {\n  int v2;\n  long long v3;\n  int v4;\n  if (n <= 1) return 1;\n  v2 = *arr;\n  v3 = 1LL;\n  while (1) {\n    v4 = v2;\n    v2 = arr[v3];\n    if (v2 < v4) break;\n    if (n == ++v3) return 1;\n  }\n  return 0;\n}", "binary": "qsort-test/qsort-test.host.O3", "assembly": "<is_sorted>:\nendbr64\ncmp    $0x1,%rsi\njbe    19e0 <is_sorted+0x30>\nmov    (%rdi),%edx\nmov    $0x1,%eax\njmp    19d1 <is_sorted+0x21>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rax\ncmp    %rax,%rsi\nje     19e0 <is_sorted+0x30>\nmov    %edx,%ecx\nmov    (%rdi,%rax,4),%edx\ncmp    %ecx,%edx\njge    19c8 <is_sorted+0x18>\nxor    %eax,%eax\nret\nnopl   (%rax)\nmov    $0x1,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "is_sorted_string_array", "content": "/* Utility function to check if an array of strings is sorted lexicographically. */\nint is_sorted_string_array(const char *arr[], size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        if (libmin_strcmp(arr[i - 1], arr[i]) > 0)\n            return 0;\n    }\n    return 1;\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O3.pseudo", "function_name": "is_sorted_string_array", "address": "0x1a50", "label": "is_sorted_string_array", "content": "int __fastcall is_sorted_string_array(const char **arr, size_t n)\n{\n  __int64 i; // rbx\n\n  if ( n <= 1 )\n    return 1;\n  for ( i = 1LL; i != n; ++i )\n  {\n    if ( libmin_strcmp(arr[i - 1], arr[i]) > 0 )\n      return 0;\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int is_sorted_string_array(const char **arr, unsigned int n) {\n  long long i;\n  if (n <= 1) return 1;\n  for (i = 1LL; i != n; ++i) {\n    if (libmin_strcmp(arr[i - 1], arr[i]) > 0) return 0;\n  }\n  return 1;\n}", "binary": "qsort-test/qsort-test.host.O3", "assembly": "<is_sorted_string_array>:\nendbr64\ncmp    $0x1,%rsi\njbe    1aa2 <is_sorted_string_array+0x52>\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    $0x1,%ebx\njmp    1a79 <is_sorted_string_array+0x29>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rbx\ncmp    %rbx,%r12\nje     1a98 <is_sorted_string_array+0x48>\nmov    0x0(%rbp,%rbx,8),%rsi\nmov    -0x8(%rbp,%rbx,8),%rdi\ncall   4060 <libmin_strcmp>\ntest   %eax,%eax\njle    1a70 <is_sorted_string_array+0x20>\npop    %rbx\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\nnopl   0x0(%rax,%rax,1)\npop    %rbx\nmov    $0x1,%eax\npop    %rbp\npop    %r12\nret\nmov    $0x1,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "main", "content": "int main(void) {\n    /* ---------------------------\n     * Test 1: Random integer array (40 elements).\n     * These values are mostly unique with only few duplicates.\n     * ---------------------------\n     */\n    int test1[40] = {\n         5,  3, 12,  8,  1, 19,  7,  4,  0,  6,\n        10, 15,  2, 22, 11, 17, 13, 20,  9, 14,\n        16, 21, 23, 18, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39\n    };\n    size_t n1 = sizeof(test1) / sizeof(test1[0]);\n    libmin_qsort(test1, n1, sizeof(int), int_compare);\n    libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n    print_array(test1, n1);\n    if (is_sorted(test1, n1))\n        libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 2: Integer array with few duplicates (40 elements).\n     * Only one duplicate (the value '5' appears twice).\n     * ---------------------------\n     */\n    int test2[40] = {\n         2,  1,  3,  0,  4,  5,  5,  7,  8,  9,\n        10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39\n    };\n    size_t n2 = sizeof(test2) / sizeof(test2[0]);\n    libmin_qsort(test2, n2, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n    print_array(test2, n2);\n    if (is_sorted(test2, n2))\n        libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 3: Already sorted integer array (40 elements).\n     * Generate 40 ascending integers (0, 1, 2, ... 39).\n     * ---------------------------\n     */\n    int test3[40];\n    for (int i = 0; i < 40; i++) {\n        test3[i] = i;\n    }\n    libmin_qsort(test3, 40, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n    print_array(test3, 40);\n    if (is_sorted(test3, 40))\n        libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n    else\n        libmin_printf(\"Test 3 failed: already sorted array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 4: Reverse sorted integer array (40 elements).\n     * Generate 40 descending integers (39, 38, ... 0).\n     * ---------------------------\n     */\n    int test4[40];\n    for (int i = 0; i < 40; i++) {\n        test4[i] = 39 - i;\n    }\n    libmin_qsort(test4, 40, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n    print_array(test4, 40);\n    if (is_sorted(test4, 40))\n        libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 5: String array (32 elements).\n     * These 32 strings are mostly distinct with one duplicate (\"apple\").\n     * ---------------------------\n     */\n    const char *test_strings[32] = {\n        \"banana\", \"apple\", \"orange\", \"kiwi\", \"grape\", \"mango\", \"strawberry\", \"pear\",\n        \"pineapple\", \"watermelon\", \"blueberry\", \"raspberry\", \"blackberry\", \"cherry\", \"peach\", \"apricot\",\n        \"plum\", \"nectarine\", \"cantaloupe\", \"honeydew\", \"papaya\", \"passionfruit\", \"guava\", \"lychee\",\n        \"pomegranate\", \"grapefruit\", \"lemon\", \"lime\", \"tangerine\", \"cranberry\", \"fig\", \"apple\"  // \"apple\" appears twice\n    };\n    size_t n_str = sizeof(test_strings) / sizeof(test_strings[0]);\n    libmin_qsort(test_strings, n_str, sizeof(char *), string_compare);\n    libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n    print_string_array(test_strings, n_str);\n    if (is_sorted_string_array(test_strings, n_str))\n        libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v7; // edx\n  int *v8; // rax\n  int v9; // ecx\n  int v10; // edx\n  int *v11; // rax\n  int v12; // ecx\n  int v13; // edx\n  int *v14; // rax\n  int v15; // ecx\n  int v16; // edx\n  const char **v17; // rax\n  int v18; // ecx\n  __m128i v19; // xmm6\n  __m128i v20; // [rsp+0h] [rbp-3C8h] BYREF\n  __m128i v21; // [rsp+10h] [rbp-3B8h] BYREF\n  int test1[40]; // [rsp+20h] [rbp-3A8h] BYREF\n  int test2[40]; // [rsp+C0h] [rbp-308h] BYREF\n  int test3[40]; // [rsp+160h] [rbp-268h] BYREF\n  int test4[40]; // [rsp+200h] [rbp-1C8h] BYREF\n  const char *test_strings[32]; // [rsp+2A0h] [rbp-128h] BYREF\n  unsigned __int64 v27; // [rsp+3A8h] [rbp-20h]\n\n  v27 = __readfsqword(0x28u);\n  *(__m128i *)&test1[24] = _mm_load_si128((const __m128i *)&xmmword_54B0);\n  *(__m128i *)&test1[28] = _mm_load_si128((const __m128i *)&xmmword_54C0);\n  *(__m128i *)&test1[32] = _mm_load_si128((const __m128i *)&xmmword_54D0);\n  *(__m128i *)&test1[36] = _mm_load_si128((const __m128i *)&xmmword_54E0);\n  *(__m128i *)test1 = _mm_load_si128((const __m128i *)&xmmword_5450);\n  *(__m128i *)&test1[4] = _mm_load_si128((const __m128i *)&xmmword_5460);\n  *(__m128i *)&test1[8] = _mm_load_si128((const __m128i *)&xmmword_5470);\n  *(__m128i *)&test1[12] = _mm_load_si128((const __m128i *)&xmmword_5480);\n  *(__m128i *)&test1[16] = _mm_load_si128((const __m128i *)&xmmword_5490);\n  *(__m128i *)&test1[20] = _mm_load_si128((const __m128i *)&xmmword_54A0);\n  libmin_qsort(test1, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\n    \"Test 1: Sorted Random Integer Array (40 elements):\\n\",\n    40LL,\n    v3,\n    v4,\n    v5,\n    v6,\n    _mm_unpacklo_epi64((__m128i)(unsigned __int64)\"fig\", (__m128i)(unsigned __int64)\"apple\"),\n    _mm_unpacklo_epi64((__m128i)(unsigned __int64)\"banana\", (__m128i)(unsigned __int64)\"apple\"));\n  print_array(test1, 0x28uLL);\n  v7 = test1[0];\n  v8 = &test1[1];\n  while ( 1 )\n  {\n    v9 = v7;\n    v7 = *v8;\n    if ( *v8 < v9 )\n      break;\n    if ( test2 == ++v8 )\n    {\n      libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\nLABEL_5:\n      *(__m128i *)test2 = _mm_load_si128((const __m128i *)&xmmword_54F0);\n      *(__m128i *)&test2[8] = _mm_load_si128((const __m128i *)&xmmword_5510);\n      *(__m128i *)&test2[12] = _mm_load_si128((const __m128i *)&xmmword_5520);\n      *(__m128i *)&test2[16] = _mm_load_si128((const __m128i *)&xmmword_5530);\n      *(__m128i *)&test2[4] = _mm_load_si128((const __m128i *)&xmmword_5500);\n      *(__m128i *)&test2[20] = _mm_load_si128((const __m128i *)&xmmword_5540);\n      *(__m128i *)&test2[24] = _mm_load_si128((const __m128i *)&xmmword_54B0);\n      *(__m128i *)&test2[28] = _mm_load_si128((const __m128i *)&xmmword_54C0);\n      *(__m128i *)&test2[32] = _mm_load_si128((const __m128i *)&xmmword_54D0);\n      *(__m128i *)&test2[36] = _mm_load_si128((const __m128i *)&xmmword_54E0);\n      libmin_qsort(test2, 0x28uLL, 4uLL, int_compare);\n      libmin_printf(\"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n      print_array(test2, 0x28uLL);\n      v10 = test2[0];\n      v11 = &test2[1];\n      while ( 1 )\n      {\n        v12 = v10;\n        v10 = *v11;\n        if ( *v11 < v12 )\n          break;\n        if ( test3 == ++v11 )\n        {\n          libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\nLABEL_9:\n          *(__m128i *)test3 = _mm_load_si128((const __m128i *)&xmmword_55F0);\n          *(__m128i *)&test3[8] = _mm_load_si128((const __m128i *)&xmmword_5510);\n          *(__m128i *)&test3[12] = _mm_load_si128((const __m128i *)&xmmword_5520);\n          *(__m128i *)&test3[4] = _mm_load_si128((const __m128i *)&xmmword_5600);\n          *(__m128i *)&test3[16] = _mm_load_si128((const __m128i *)&xmmword_5530);\n          *(__m128i *)&test3[20] = _mm_load_si128((const __m128i *)&xmmword_5540);\n          *(__m128i *)&test3[24] = _mm_load_si128((const __m128i *)&xmmword_54B0);\n          *(__m128i *)&test3[28] = _mm_load_si128((const __m128i *)&xmmword_54C0);\n          *(__m128i *)&test3[32] = _mm_load_si128((const __m128i *)&xmmword_54D0);\n          *(__m128i *)&test3[36] = _mm_load_si128((const __m128i *)&xmmword_54E0);\n          libmin_qsort(test3, 0x28uLL, 4uLL, int_compare);\n          libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n          print_array(test3, 0x28uLL);\n          v13 = test3[0];\n          v14 = &test3[1];\n          while ( 1 )\n          {\n            v15 = v13;\n            v13 = *v14;\n            if ( v15 > *v14 )\n              break;\n            if ( test4 == ++v14 )\n            {\n              libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\nLABEL_13:\n              *(__m128i *)test4 = _mm_load_si128((const __m128i *)&xmmword_5550);\n              *(__m128i *)&test4[4] = _mm_load_si128((const __m128i *)&xmmword_5560);\n              *(__m128i *)&test4[8] = _mm_load_si128((const __m128i *)&xmmword_5570);\n              *(__m128i *)&test4[12] = _mm_load_si128((const __m128i *)&xmmword_5580);\n              *(__m128i *)&test4[16] = _mm_load_si128((const __m128i *)&xmmword_5590);\n              *(__m128i *)&test4[20] = _mm_load_si128((const __m128i *)&xmmword_55A0);\n              *(__m128i *)&test4[24] = _mm_load_si128((const __m128i *)&xmmword_55B0);\n              *(__m128i *)&test4[28] = _mm_load_si128((const __m128i *)&xmmword_55C0);\n              *(__m128i *)&test4[32] = _mm_load_si128((const __m128i *)&xmmword_55D0);\n              *(__m128i *)&test4[36] = _mm_load_si128((const __m128i *)&xmmword_55E0);\n              libmin_qsort(test4, 0x28uLL, 4uLL, int_compare);\n              libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n              print_array(test4, 0x28uLL);\n              v16 = test4[0];\n              v17 = (const char **)&test4[1];\n              while ( 1 )\n              {\n                v18 = v16;\n                v16 = *(_DWORD *)v17;\n                if ( v18 > *(_DWORD *)v17 )\n                  break;\n                v17 = (const char **)((char *)v17 + 4);\n                if ( test_strings == v17 )\n                {\n                  libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n                  goto LABEL_17;\n                }\n              }\n              libmin_printf(\"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\nLABEL_17:\n              *(__m128i *)test_strings = _mm_load_si128(&v21);\n              *(__m128i *)&test_strings[2] = _mm_unpacklo_epi64(\n                                               (__m128i)(unsigned __int64)\"orange\",\n                                               (__m128i)(unsigned __int64)\"kiwi\");\n              *(__m128i *)&test_strings[4] = _mm_unpacklo_epi64(\n                                               (__m128i)(unsigned __int64)\"grape\",\n                                               (__m128i)(unsigned __int64)\"mango\");\n              *(__m128i *)&test_strings[6] = _mm_unpacklo_epi64(\n                                               (__m128i)(unsigned __int64)\"strawberry\",\n                                               (__m128i)(unsigned __int64)\"pear\");\n              *(__m128i *)&test_strings[8] = _mm_unpacklo_epi64(\n                                               (__m128i)(unsigned __int64)\"pineapple\",\n                                               (__m128i)(unsigned __int64)\"watermelon\");\n              *(__m128i *)&test_strings[10] = _mm_unpacklo_epi64(\n                                                (__m128i)(unsigned __int64)\"blueberry\",\n                                                (__m128i)(unsigned __int64)\"raspberry\");\n              *(__m128i *)&test_strings[12] = _mm_unpacklo_epi64(\n                                                (__m128i)(unsigned __int64)\"blackberry\",\n                                                (__m128i)(unsigned __int64)\"cherry\");\n              *(__m128i *)&test_strings[14] = _mm_unpacklo_epi64(\n                                                (__m128i)(unsigned __int64)\"peach\",\n                                                (__m128i)(unsigned __int64)\"apricot\");\n              v19 = _mm_load_si128(&v20);\n              *(__m128i *)&test_strings[16] = _mm_unpacklo_epi64(\n                                                (__m128i)(unsigned __int64)\"plum\",\n                                                (__m128i)(unsigned __int64)\"nectarine\");\n              *(__m128i *)&test_strings[30] = v19;\n              *(__m128i *)&test_strings[18] = _mm_unpacklo_epi64(\n                                                (__m128i)(unsigned __int64)\"cantaloupe\",\n                                                (__m128i)(unsigned __int64)\"honeydew\");\n              *(__m128i *)&test_strings[20] = _mm_unpacklo_epi64(\n                                                (__m128i)(unsigned __int64)\"papaya\",\n                                                (__m128i)(unsigned __int64)\"passionfruit\");\n              *(__m128i *)&test_strings[22] = _mm_unpacklo_epi64(\n                                                (__m128i)(unsigned __int64)\"guava\",\n                                                (__m128i)(unsigned __int64)\"lychee\");\n              *(__m128i *)&test_strings[24] = _mm_unpacklo_epi64(\n                                                (__m128i)(unsigned __int64)\"pomegranate\",\n                                                (__m128i)(unsigned __int64)\"grapefruit\");\n              *(__m128i *)&test_strings[26] = _mm_unpacklo_epi64(\n                                                (__m128i)(unsigned __int64)\"lemon\",\n                                                (__m128i)(unsigned __int64)\"lime\");\n              *(__m128i *)&test_strings[28] = _mm_unpacklo_epi64(\n                                                (__m128i)(unsigned __int64)\"tangerine\",\n                                                (__m128i)(unsigned __int64)\"cranberry\");\n              libmin_qsort(test_strings, 0x20uLL, 8uLL, string_compare);\n              libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n              print_string_array(test_strings, 0x20uLL);\n              if ( is_sorted_string_array(test_strings, 0x20uLL) )\n                libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n              else\n                libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n              libmin_success();\n            }\n          }\n          libmin_printf(\"Test 3 failed: already sorted array not sorted correctly.\\n\");\n          goto LABEL_13;\n        }\n      }\n      libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n      goto LABEL_9;\n    }\n  }\n  libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  goto LABEL_5;\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  int v7;\n  int *v8;\n  int v9;\n  int v10;\n  int *v11;\n  int v12;\n  int v13;\n  int *v14;\n  int v15;\n  int v16;\n  const char **v17;\n  int v18;\n  __m128i v19;\n  __m128i v20;\n  __m128i v21;\n  int test1[40];\n  int test2[40];\n  int test3[40];\n  int test4[40];\n  const char *test_strings[32];\n  unsigned long long v27;\n  v27 = __readfsqword(40u);\n  *(__m128i *)&test1[24] = _mm_load_si128((const __m128i *)&xmmword_54B0);\n  *(__m128i *)&test1[28] = _mm_load_si128((const __m128i *)&xmmword_54C0);\n  *(__m128i *)&test1[32] = _mm_load_si128((const __m128i *)&xmmword_54D0);\n  *(__m128i *)&test1[36] = _mm_load_si128((const __m128i *)&xmmword_54E0);\n  *(__m128i *)test1 = _mm_load_si128((const __m128i *)&xmmword_5450);\n  *(__m128i *)&test1[4] = _mm_load_si128((const __m128i *)&xmmword_5460);\n  *(__m128i *)&test1[8] = _mm_load_si128((const __m128i *)&xmmword_5470);\n  *(__m128i *)&test1[12] = _mm_load_si128((const __m128i *)&xmmword_5480);\n  *(__m128i *)&test1[16] = _mm_load_si128((const __m128i *)&xmmword_5490);\n  *(__m128i *)&test1[20] = _mm_load_si128((const __m128i *)&xmmword_54A0);\n  libmin_qsort(test1, 40uLL, 4uLL, int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\", 40LL,\n                v3, v4, v5, v6,\n                _mm_unpacklo_epi64((__m128i)(unsigned long long)\"fig\",\n                                   (__m128i)(unsigned long long)\"apple\"),\n                _mm_unpacklo_epi64((__m128i)(unsigned long long)\"banana\",\n                                   (__m128i)(unsigned long long)\"apple\"));\n  print_array(test1, 40uLL);\n  v7 = test1[0];\n  v8 = &test1[1];\n  while (1) {\n    v9 = v7;\n    v7 = *v8;\n    if (*v8 < v9) break;\n    if (test2 == ++v8) {\n      libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n    LABEL_5:\n      *(__m128i *)test2 = _mm_load_si128((const __m128i *)&xmmword_54F0);\n      *(__m128i *)&test2[8] = _mm_load_si128((const __m128i *)&xmmword_5510);\n      *(__m128i *)&test2[12] = _mm_load_si128((const __m128i *)&xmmword_5520);\n      *(__m128i *)&test2[16] = _mm_load_si128((const __m128i *)&xmmword_5530);\n      *(__m128i *)&test2[4] = _mm_load_si128((const __m128i *)&xmmword_5500);\n      *(__m128i *)&test2[20] = _mm_load_si128((const __m128i *)&xmmword_5540);\n      *(__m128i *)&test2[24] = _mm_load_si128((const __m128i *)&xmmword_54B0);\n      *(__m128i *)&test2[28] = _mm_load_si128((const __m128i *)&xmmword_54C0);\n      *(__m128i *)&test2[32] = _mm_load_si128((const __m128i *)&xmmword_54D0);\n      *(__m128i *)&test2[36] = _mm_load_si128((const __m128i *)&xmmword_54E0);\n      libmin_qsort(test2, 40uLL, 4uLL, int_compare);\n      libmin_printf(\n          \"\\nTest 2: Sorted Integer Array with Few Duplicates (40 \"\n          \"elements):\\n\");\n      print_array(test2, 40uLL);\n      v10 = test2[0];\n      v11 = &test2[1];\n      while (1) {\n        v12 = v10;\n        v10 = *v11;\n        if (*v11 < v12) break;\n        if (test3 == ++v11) {\n          libmin_printf(\n              \"Test 2 passed: duplicate elements sorted correctly.\\n\");\n        LABEL_9:\n          *(__m128i *)test3 = _mm_load_si128((const __m128i *)&xmmword_55F0);\n          *(__m128i *)&test3[8] =\n              _mm_load_si128((const __m128i *)&xmmword_5510);\n          *(__m128i *)&test3[12] =\n              _mm_load_si128((const __m128i *)&xmmword_5520);\n          *(__m128i *)&test3[4] =\n              _mm_load_si128((const __m128i *)&xmmword_5600);\n          *(__m128i *)&test3[16] =\n              _mm_load_si128((const __m128i *)&xmmword_5530);\n          *(__m128i *)&test3[20] =\n              _mm_load_si128((const __m128i *)&xmmword_5540);\n          *(__m128i *)&test3[24] =\n              _mm_load_si128((const __m128i *)&xmmword_54B0);\n          *(__m128i *)&test3[28] =\n              _mm_load_si128((const __m128i *)&xmmword_54C0);\n          *(__m128i *)&test3[32] =\n              _mm_load_si128((const __m128i *)&xmmword_54D0);\n          *(__m128i *)&test3[36] =\n              _mm_load_si128((const __m128i *)&xmmword_54E0);\n          libmin_qsort(test3, 40uLL, 4uLL, int_compare);\n          libmin_printf(\n              \"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n          print_array(test3, 40uLL);\n          v13 = test3[0];\n          v14 = &test3[1];\n          while (1) {\n            v15 = v13;\n            v13 = *v14;\n            if (v15 > *v14) break;\n            if (test4 == ++v14) {\n              libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n            LABEL_13:\n              *(__m128i *)test4 =\n                  _mm_load_si128((const __m128i *)&xmmword_5550);\n              *(__m128i *)&test4[4] =\n                  _mm_load_si128((const __m128i *)&xmmword_5560);\n              *(__m128i *)&test4[8] =\n                  _mm_load_si128((const __m128i *)&xmmword_5570);\n              *(__m128i *)&test4[12] =\n                  _mm_load_si128((const __m128i *)&xmmword_5580);\n              *(__m128i *)&test4[16] =\n                  _mm_load_si128((const __m128i *)&xmmword_5590);\n              *(__m128i *)&test4[20] =\n                  _mm_load_si128((const __m128i *)&xmmword_55A0);\n              *(__m128i *)&test4[24] =\n                  _mm_load_si128((const __m128i *)&xmmword_55B0);\n              *(__m128i *)&test4[28] =\n                  _mm_load_si128((const __m128i *)&xmmword_55C0);\n              *(__m128i *)&test4[32] =\n                  _mm_load_si128((const __m128i *)&xmmword_55D0);\n              *(__m128i *)&test4[36] =\n                  _mm_load_si128((const __m128i *)&xmmword_55E0);\n              libmin_qsort(test4, 40uLL, 4uLL, int_compare);\n              libmin_printf(\n                  \"\\nTest 4: Sorted Reverse Order Integer Array (40 \"\n                  \"elements):\\n\");\n              print_array(test4, 40uLL);\n              v16 = test4[0];\n              v17 = (const char **)&test4[1];\n              while (1) {\n                v18 = v16;\n                v16 = *(uint32_t *)v17;\n                if (v18 > *(uint32_t *)v17) break;\n                v17 = (const char **)((char *)v17 + 4);\n                if (test_strings == v17) {\n                  libmin_printf(\n                      \"Test 4 passed: reverse sorted array sorted \"\n                      \"correctly.\\n\");\n                  goto LABEL_17;\n                }\n              }\n              libmin_printf(\n                  \"Test 4 failed: reverse sorted array not sorted \"\n                  \"correctly.\\n\");\n            LABEL_17:\n              *(__m128i *)test_strings = _mm_load_si128(&v21);\n              *(__m128i *)&test_strings[2] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"orange\",\n                                     (__m128i)(unsigned long long)\"kiwi\");\n              *(__m128i *)&test_strings[4] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"grape\",\n                                     (__m128i)(unsigned long long)\"mango\");\n              *(__m128i *)&test_strings[6] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"strawberry\",\n                                     (__m128i)(unsigned long long)\"pear\");\n              *(__m128i *)&test_strings[8] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"pineapple\",\n                                     (__m128i)(unsigned long long)\"watermelon\");\n              *(__m128i *)&test_strings[10] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"blueberry\",\n                                     (__m128i)(unsigned long long)\"raspberry\");\n              *(__m128i *)&test_strings[12] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"blackberry\",\n                                     (__m128i)(unsigned long long)\"cherry\");\n              *(__m128i *)&test_strings[14] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"peach\",\n                                     (__m128i)(unsigned long long)\"apricot\");\n              v19 = _mm_load_si128(&v20);\n              *(__m128i *)&test_strings[16] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"plum\",\n                                     (__m128i)(unsigned long long)\"nectarine\");\n              *(__m128i *)&test_strings[30] = v19;\n              *(__m128i *)&test_strings[18] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"cantaloupe\",\n                                     (__m128i)(unsigned long long)\"honeydew\");\n              *(__m128i *)&test_strings[20] = _mm_unpacklo_epi64(\n                  (__m128i)(unsigned long long)\"papaya\",\n                  (__m128i)(unsigned long long)\"passionfruit\");\n              *(__m128i *)&test_strings[22] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"guava\",\n                                     (__m128i)(unsigned long long)\"lychee\");\n              *(__m128i *)&test_strings[24] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"pomegranate\",\n                                     (__m128i)(unsigned long long)\"grapefruit\");\n              *(__m128i *)&test_strings[26] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"lemon\",\n                                     (__m128i)(unsigned long long)\"lime\");\n              *(__m128i *)&test_strings[28] =\n                  _mm_unpacklo_epi64((__m128i)(unsigned long long)\"tangerine\",\n                                     (__m128i)(unsigned long long)\"cranberry\");\n              libmin_qsort(test_strings, 32uLL, 8uLL, string_compare);\n              libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n              print_string_array(test_strings, 32uLL);\n              if (is_sorted_string_array(test_strings, 32uLL))\n                libmin_printf(\n                    \"Test 5 passed: string array sorted correctly.\\n\");\n              else\n                libmin_printf(\n                    \"Test 5 failed: string array not sorted correctly.\\n\");\n              libmin_success();\n            }\n          }\n          libmin_printf(\n              \"Test 3 failed: already sorted array not sorted correctly.\\n\");\n          goto LABEL_13;\n        }\n      }\n      libmin_printf(\n          \"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n      goto LABEL_9;\n    }\n  }\n  libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  goto LABEL_5;\n}", "binary": "qsort-test/qsort-test.host.O3", "assembly": "<main>:\nendbr64\npush   %r12\nlea    0x863(%rip),%r12\nmov    $0x4,%edx\nmov    $0x28,%esi\npush   %rbp\nmov    %r12,%rcx\nsub    $0x3b8,%rsp\nmovdqa 0x4366(%rip),%xmm3\nmovdqa 0x436e(%rip),%xmm4\nmov    %fs:0x28,%rax\nmov    %rax,0x3a8(%rsp)\nlea    0x3ed7(%rip),%rax\nmovdqa 0x435e(%rip),%xmm5\nlea    0x20(%rsp),%rbp\nmovdqa 0x4361(%rip),%xmm6\nmov    %rbp,%rdi\nmovaps %xmm3,0x80(%rsp)\nmovaps %xmm4,0x90(%rsp)\nmovaps %xmm5,0xa0(%rsp)\nmovaps %xmm6,0xb0(%rsp)\nmovq   %rax,%xmm0\nlea    0x3e60(%rip),%rax\nmovq   %rax,%xmm1\nlea    0x3f46(%rip),%rax\nmovq   %rax,%xmm2\npunpcklqdq %xmm0,%xmm1\npunpcklqdq %xmm0,%xmm2\nmovdqa 0x4281(%rip),%xmm0\nmovaps %xmm1,0x10(%rsp)\nmovaps %xmm2,(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmovdqa 0x427b(%rip),%xmm0\nmovaps %xmm0,0x30(%rsp)\nmovdqa 0x427e(%rip),%xmm0\nmovaps %xmm0,0x40(%rsp)\nmovdqa 0x4281(%rip),%xmm0\nmovaps %xmm0,0x50(%rsp)\nmovdqa 0x4284(%rip),%xmm0\nmovaps %xmm0,0x60(%rsp)\nmovdqa 0x4287(%rip),%xmm0\nmovaps %xmm0,0x70(%rsp)\ncall   4030 <libmin_qsort>\nlea    0x3ede(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\nmov    %rbp,%rdi\nmov    $0x28,%esi\nlea    0xc0(%rsp),%rbp\ncall   19f0 <print_array>\nmov    0x20(%rsp),%edx\nlea    0x24(%rsp),%rax\nnop\nmov    %edx,%ecx\nmov    (%rax),%edx\ncmp    %ecx,%edx\njl     1854 <main+0x734>\nadd    $0x4,%rax\ncmp    %rax,%rbp\njne    1250 <main+0x130>\nlea    0x4184(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\nmovdqa 0x4275(%rip),%xmm0\nmovdqa 0x428d(%rip),%xmm7\nmov    $0x4,%edx\nmov    %r12,%rcx\nmovdqa 0x428d(%rip),%xmm3\nmov    $0x28,%esi\nmov    %rbp,%rdi\nmovdqa 0x428d(%rip),%xmm4\nmovdqa 0x4295(%rip),%xmm5\nmovdqa 0x41fd(%rip),%xmm6\nmovaps %xmm0,0xc0(%rsp)\nmovaps %xmm7,0xe0(%rsp)\nmovdqa 0x4235(%rip),%xmm0\nmovdqa 0x41ed(%rip),%xmm7\nmovaps %xmm3,0xf0(%rsp)\nmovdqa 0x41ed(%rip),%xmm3\nmovaps %xmm4,0x100(%rsp)\nmovdqa 0x41ed(%rip),%xmm4\nmovaps %xmm0,0xd0(%rsp)\nmovaps %xmm5,0x110(%rsp)\nmovaps %xmm6,0x120(%rsp)\nmovaps %xmm7,0x130(%rsp)\nmovaps %xmm3,0x140(%rsp)\nmovaps %xmm4,0x150(%rsp)\ncall   4030 <libmin_qsort>\nlea    0x3e11(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\nmov    %rbp,%rdi\nmov    $0x28,%esi\nlea    0x160(%rsp),%rbp\ncall   19f0 <print_array>\nmov    0xc0(%rsp),%edx\nlea    0xc4(%rsp),%rax\nnopw   0x0(%rax,%rax,1)\nmov    %edx,%ecx\nmov    (%rax),%edx\ncmp    %ecx,%edx\njl     1841 <main+0x721>\nadd    $0x4,%rax\ncmp    %rax,%rbp\njne    1360 <main+0x240>\nlea    0x3fc4(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\nmovdqa 0x4265(%rip),%xmm0\nmovdqa 0x417d(%rip),%xmm7\nmov    $0x4,%edx\nmov    %r12,%rcx\nmovdqa 0x417d(%rip),%xmm1\nmovdqa 0x4185(%rip),%xmm2\nmov    $0x28,%esi\nmov    %rbp,%rdi\nmovdqa 0x4185(%rip),%xmm3\nmovdqa 0x40ed(%rip),%xmm4\nmovaps %xmm0,0x160(%rsp)\nmovdqa 0x40ed(%rip),%xmm5\nmovdqa 0x4225(%rip),%xmm0\nmovaps %xmm7,0x180(%rsp)\nmovdqa 0x40e5(%rip),%xmm6\nmovdqa 0x40ed(%rip),%xmm7\nmovaps %xmm1,0x190(%rsp)\nmovaps %xmm0,0x170(%rsp)\nmovaps %xmm2,0x1a0(%rsp)\nmovaps %xmm3,0x1b0(%rsp)\nmovaps %xmm4,0x1c0(%rsp)\nmovaps %xmm5,0x1d0(%rsp)\nmovaps %xmm6,0x1e0(%rsp)\nmovaps %xmm7,0x1f0(%rsp)\ncall   4030 <libmin_qsort>\nlea    0x3f39(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\nmov    %rbp,%rdi\nmov    $0x28,%esi\nlea    0x200(%rsp),%rbp\ncall   19f0 <print_array>\nmov    0x160(%rsp),%edx\nlea    0x164(%rsp),%rax\nnopw   0x0(%rax,%rax,1)\nmov    %edx,%ecx\nmov    (%rax),%edx\ncmp    %edx,%ecx\njg     1867 <main+0x747>\nadd    $0x4,%rax\ncmp    %rax,%rbp\njne    1470 <main+0x350>\nlea    0x3e0c(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\nmov    %r12,%rcx\nmov    $0x4,%edx\nmov    $0x28,%esi\nmov    %rbp,%rdi\nmovdqa 0x40a5(%rip),%xmm0\nlea    0x2a0(%rsp),%r12\nmovaps %xmm0,0x200(%rsp)\nmovdqa 0x409d(%rip),%xmm0\nmovaps %xmm0,0x210(%rsp)\nmovdqa 0x409d(%rip),%xmm0\nmovaps %xmm0,0x220(%rsp)\nmovdqa 0x409d(%rip),%xmm0\nmovaps %xmm0,0x230(%rsp)\nmovdqa 0x409d(%rip),%xmm0\nmovaps %xmm0,0x240(%rsp)\nmovdqa 0x409d(%rip),%xmm0\nmovaps %xmm0,0x250(%rsp)\nmovdqa 0x409d(%rip),%xmm0\nmovaps %xmm0,0x260(%rsp)\nmovdqa 0x409d(%rip),%xmm0\nmovaps %xmm0,0x270(%rsp)\nmovdqa 0x409d(%rip),%xmm0\nmovaps %xmm0,0x280(%rsp)\nmovdqa 0x409d(%rip),%xmm0\nmovaps %xmm0,0x290(%rsp)\ncall   4030 <libmin_qsort>\nlea    0x3d69(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\nmov    $0x28,%esi\nmov    %rbp,%rdi\ncall   19f0 <print_array>\nmov    0x200(%rsp),%edx\nlea    0x204(%rsp),%rax\nnopw   0x0(%rax,%rax,1)\nmov    %edx,%ecx\nmov    (%rax),%edx\ncmp    %edx,%ecx\njg     182e <main+0x70e>\nadd    $0x4,%rax\ncmp    %rax,%r12\njne    1580 <main+0x460>\nlea    0x3cc4(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\nlea    0x3a72(%rip),%rax\nmovdqa 0x10(%rsp),%xmm5\nmov    %r12,%rdi\nlea    0x3a5b(%rip),%rsi\nmovq   %rax,%xmm6\nmovq   %rsi,%xmm0\nmov    $0x8,%edx\npunpcklqdq %xmm6,%xmm0\nlea    0x3a53(%rip),%rax\nlea    0x3a46(%rip),%rsi\nmovaps %xmm5,0x2a0(%rsp)\nmovq   %rax,%xmm7\nmovaps %xmm0,0x2b0(%rsp)\nmovq   %rsi,%xmm0\nlea    0x3a3c(%rip),%rax\npunpcklqdq %xmm7,%xmm0\nlea    0x3a26(%rip),%rsi\nmovq   %rax,%xmm1\nmovaps %xmm0,0x2c0(%rsp)\nmovq   %rsi,%xmm0\nlea    0x3a27(%rip),%rax\nlea    0x3a16(%rip),%rsi\npunpcklqdq %xmm1,%xmm0\nmovq   %rax,%xmm2\nlea    0x3a25(%rip),%rax\nmovaps %xmm0,0x2d0(%rsp)\nmovq   %rsi,%xmm0\nlea    0x3a07(%rip),%rsi\nmovq   %rax,%xmm3\npunpcklqdq %xmm2,%xmm0\nlea    0x3a16(%rip),%rax\nlea    0x33e(%rip),%rcx\nmovaps %xmm0,0x2e0(%rsp)\nmovq   %rsi,%xmm0\nlea    0x39f0(%rip),%rsi\nmovq   %rax,%xmm4\npunpcklqdq %xmm3,%xmm0\nlea    0x39f8(%rip),%rax\nmovaps %xmm0,0x2f0(%rsp)\nmovq   %rsi,%xmm0\nlea    0x39de(%rip),%rsi\nmovq   %rax,%xmm5\npunpcklqdq %xmm4,%xmm0\nlea    0x39e1(%rip),%rax\nmovaps %xmm0,0x300(%rsp)\nmovq   %rsi,%xmm0\nlea    0x39c8(%rip),%rsi\nmovq   %rax,%xmm6\npunpcklqdq %xmm5,%xmm0\nlea    0x39d2(%rip),%rax\nmovaps %xmm0,0x310(%rsp)\nmovq   %rsi,%xmm0\nlea    0x39b3(%rip),%rsi\nmovq   %rax,%xmm7\npunpcklqdq %xmm6,%xmm0\nlea    0x39be(%rip),%rax\nmovdqa (%rsp),%xmm6\nmovaps %xmm0,0x320(%rsp)\nmovq   %rsi,%xmm0\nlea    0x399e(%rip),%rsi\nmovq   %rax,%xmm1\npunpcklqdq %xmm7,%xmm0\nlea    0x39a8(%rip),%rax\nmovaps %xmm6,0x390(%rsp)\nmovaps %xmm0,0x330(%rsp)\nmovq   %rsi,%xmm0\nlea    0x3986(%rip),%rsi\nmovq   %rax,%xmm2\npunpcklqdq %xmm1,%xmm0\nlea    0x398f(%rip),%rax\nmovaps %xmm0,0x340(%rsp)\nmovq   %rsi,%xmm0\nlea    0x396f(%rip),%rsi\nmovq   %rax,%xmm3\npunpcklqdq %xmm2,%xmm0\nlea    0x397c(%rip),%rax\nmovaps %xmm0,0x350(%rsp)\nmovq   %rsi,%xmm0\nlea    0x3962(%rip),%rsi\nmovq   %rax,%xmm4\npunpcklqdq %xmm3,%xmm0\nlea    0x3967(%rip),%rax\nmovaps %xmm0,0x360(%rsp)\nmovq   %rsi,%xmm0\nlea    0x3949(%rip),%rsi\nmovq   %rax,%xmm5\npunpcklqdq %xmm4,%xmm0\nmovaps %xmm0,0x370(%rsp)\nmovq   %rsi,%xmm0\nmov    $0x20,%esi\npunpcklqdq %xmm5,%xmm0\nmovaps %xmm0,0x380(%rsp)\ncall   4030 <libmin_qsort>\nlea    0x39b2(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\nmov    $0x20,%esi\nmov    %r12,%rdi\ncall   1ab0 <print_string_array>\nmov    $0x20,%esi\nmov    %r12,%rdi\ncall   1a50 <is_sorted_string_array>\ntest   %eax,%eax\nje     187a <main+0x75a>\nlea    0x39b6(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\ncall   40f0 <libmin_success>\nmov    0x3a8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    188d <main+0x76d>\nadd    $0x3b8,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\nlea    0x39eb(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\njmp    15a3 <main+0x483>\nlea    0x3b68(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\njmp    1383 <main+0x263>\nlea    0x3bbd(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\njmp    1273 <main+0x153>\nlea    0x3a92(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\njmp    1493 <main+0x373>\nlea    0x3967(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\njmp    1809 <main+0x6e9>\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "print_array", "content": "/* Function to print an array of integers. */\nvoid print_array(const int arr[], size_t n) {\n    for (size_t i = 0; i < n; i++)\n        libmin_printf(\"%d \", arr[i]);\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O3.pseudo", "function_name": "print_array", "address": "0x19f0", "label": "print_array", "content": "void __fastcall print_array(const int *arr, size_t n)\n{\n  __int64 i; // rbx\n  int v4; // esi\n\n  if ( n )\n  {\n    for ( i = 0LL; i != n; ++i )\n    {\n      v4 = arr[i];\n      libmin_printf(\"%d \", v4);\n    }\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void print_array(const int *arr, unsigned int n) {\n  long long i;\n  int v4;\n  if (n) {\n    for (i = 0LL; i != n; ++i) {\n      v4 = arr[i];\n      libmin_printf(\"%d \", v4);\n    }\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "qsort-test/qsort-test.host.O3", "assembly": "<print_array>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %rsi,%rsi\nje     1a2f <print_array+0x3f>\nmov    %rdi,%r12\nmov    %rsi,%rbp\nlea    0x35f4(%rip),%r13\nxor    %ebx,%ebx\nnopw   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,4),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   3be0 <libmin_printf>\ncmp    %rbx,%rbp\njne    1a18 <print_array+0x28>\nadd    $0x8,%rsp\nlea    0x35ce(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    3be0 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "print_string_array", "content": "/* Function to print an array of strings. */\nvoid print_string_array(const char *arr[], size_t n) {\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s \", arr[i]);\n    }\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O3.pseudo", "function_name": "print_string_array", "address": "0x1ab0", "label": "print_string_array", "content": "void __fastcall print_string_array(const char **arr, size_t n)\n{\n  __int64 i; // rbx\n  const char *v4; // rsi\n\n  if ( n )\n  {\n    for ( i = 0LL; i != n; ++i )\n    {\n      v4 = arr[i];\n      libmin_printf(\"%s \", v4);\n    }\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void print_string_array(const char **arr, unsigned int n) {\n  long long i;\n  const char *v4;\n  if (n) {\n    for (i = 0LL; i != n; ++i) {\n      v4 = arr[i];\n      libmin_printf(\"%s \", v4);\n    }\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "qsort-test/qsort-test.host.O3", "assembly": "<print_string_array>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %rsi,%rsi\nje     1aef <print_string_array+0x3f>\nmov    %rdi,%r12\nmov    %rsi,%rbp\nlea    0x353a(%rip),%r13\nxor    %ebx,%ebx\nnopw   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,8),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   3be0 <libmin_printf>\ncmp    %rbx,%rbp\njne    1ad8 <print_string_array+0x28>\nadd    $0x8,%rsp\nlea    0x350e(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    3be0 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "string_compare", "content": "/* Comparison function for strings using strcmp.\n * Note: Each element is a pointer to char.\n */\nint string_compare(const void *a, const void *b) {\n    const char * const *str1 = (const char * const *) a;\n    const char * const *str2 = (const char * const *) b;\n    return libmin_strcmp(*str1, *str2);\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O3.pseudo", "function_name": "string_compare", "address": "0x19a0", "label": "string_compare", "content": "int __fastcall string_compare(const void *a, const void *b)\n{\n  return libmin_strcmp(*(const char **)a, *(const char **)b);\n}\n"}, "pseudo_normalize": "", "binary": "qsort-test/qsort-test.host.O3", "assembly": "<string_compare>:\nendbr64\nmov    (%rsi),%rsi\nmov    (%rdi),%rdi\njmp    4060 <libmin_strcmp>\nnop\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "euler_from_quat", "content": "/**\n * Function to convert given quaternion to Euler angles.\n * \\f{eqnarray*}{\n * \\phi & = &\n * \\tan^{-1}\\left[\\frac{2\\left(q_0q_1+q_2q_3\\right)}{1-2\\left(q_1^2+q_2^2\\right)}\\right]\\\\\n * \\theta & =\n * &-\\sin^{-1}\\left[2\\left(q_0q_2-q_3q_1\\right)\\right]\\\\\n * \\psi & = &\n * \\tan^{-1}\\left[\\frac{2\\left(q_0q_3+q_1q_2\\right)}{1-2\\left(q_2^2+q_3^2\\right)}\\right]\\\\\n * \\f}\n *\n * @param [in] in_quat input quaternion instance\n * @returns converted euler angles\n */\neuler euler_from_quat(const quaternion *in_quat)\n{\n    euler out_euler = {{0.0}, {0.0}, {0.0}};\n    if (!in_quat)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_euler;\n    }\n\n    out_euler.roll = libmin_atan2(\n        2.0 * (in_quat->w * in_quat->q1 + in_quat->q2 * in_quat->q3),\n        1.0 - 2.0 * (in_quat->q1 * in_quat->q1 + in_quat->q2 * in_quat->q2));\n    out_euler.pitch =\n        libmin_asin(2.0 * (in_quat->w * in_quat->q2 + in_quat->q1 * in_quat->q3));\n    out_euler.yaw = libmin_atan2(\n        2.0 * (in_quat->w * in_quat->q3 + in_quat->q1 * in_quat->q2),\n        1.0 - 2.0 * (in_quat->q2 * in_quat->q2 + in_quat->q3 * in_quat->q3));\n\n    return out_euler;\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O3.pseudo", "function_name": "euler_from_quat", "address": "0x1550", "label": "euler_from_quat", "content": "euler *__fastcall euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat)\n{\n  double v2; // xmm1_8\n  __m128d v3; // xmm0\n  double v4; // xmm2_8\n  double v5; // xmm0_8\n  __m128d v6; // xmm3\n  euler *result; // rax\n  double v8; // [rsp+0h] [rbp-28h]\n  __m128d v9; // [rsp+0h] [rbp-28h]\n\n  if ( in_quat )\n  {\n    v2 = in_quat->dual.x * in_quat->dual.x;\n    v8 = libmin_atan2(\n           1.0 - (v2 + in_quat->dual.y * in_quat->dual.y + v2 + in_quat->dual.y * in_quat->dual.y),\n           in_quat->dual.y * in_quat->dual.z);\n    v3 = (__m128d)*(unsigned __int64 *)&in_quat->w;\n    v3.m128d_f64[0] = libmin_asin(in_quat->dual.x * in_quat->dual.z);\n    v9 = _mm_unpacklo_pd((__m128d)*(unsigned __int64 *)&v8, v3);\n    v4 = in_quat->dual.y * in_quat->dual.y\n       + in_quat->dual.z * in_quat->dual.z\n       + in_quat->dual.y * in_quat->dual.y\n       + in_quat->dual.z * in_quat->dual.z;\n    v5 = libmin_atan2(1.0 - v4, v4);\n    v6 = v9;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    v6 = 0LL;\n    v5 = 0.0;\n  }\n  *(__m128d *)&retstr->roll = v6;\n  result = retstr;\n  retstr->yaw = v5;\n  return result;\n}\n"}, "pseudo_normalize": "euler *euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat) {\n  double v2;\n  __m128d v3;\n  double v4;\n  double v5;\n  __m128d v6;\n  euler *result;\n  double v8;\n  __m128d v9;\n  if (in_quat) {\n    v2 = in_quat->dual.x * in_quat->dual.x;\n    v8 = libmin_atan2(1.0 - (v2 + in_quat->dual.y * in_quat->dual.y + v2 +\n                             in_quat->dual.y * in_quat->dual.y),\n                      in_quat->dual.y * in_quat->dual.z);\n    v3 = (__m128d) * (unsigned long long *)&in_quat->w;\n    v3.m128d_f64[0] = libmin_asin(in_quat->dual.x * in_quat->dual.z);\n    v9 = _mm_unpacklo_pd((__m128d) * (unsigned long long *)&v8, v3);\n    v4 = in_quat->dual.y * in_quat->dual.y + in_quat->dual.z * in_quat->dual.z +\n         in_quat->dual.y * in_quat->dual.y + in_quat->dual.z * in_quat->dual.z;\n    v5 = libmin_atan2(1.0 - v4, v4);\n    v6 = v9;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    v6 = 0LL;\n    v5 = 0.0;\n  }\n  *(__m128d *)&retstr->roll = v6;\n  result = retstr;\n  retstr->yaw = v5;\n  return result;\n}", "binary": "quaternions/quaternions.host.O3", "assembly": "<euler_from_quat>:\nendbr64\npush   %r12\nmov    %rdi,%r12\npush   %rbx\nsub    $0x18,%rsp\ntest   %rsi,%rsi\nje     1650 <euler_from_quat+0x100>\nmovsd  0x8(%rsi),%xmm0\nmovsd  0x10(%rsi),%xmm2\nmov    %rsi,%rbx\nmovsd  0x5b3c(%rip),%xmm5\nmovapd %xmm0,%xmm1\nmovapd %xmm2,%xmm3\nmulsd  %xmm2,%xmm3\nmulsd  %xmm0,%xmm1\nmulsd  0x18(%rsi),%xmm2\nmulsd  (%rsi),%xmm0\naddsd  %xmm3,%xmm1\naddsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm1\naddsd  %xmm0,%xmm0\nsubsd  %xmm1,%xmm5\nmovapd %xmm5,%xmm1\ncall   1ee0 <libmin_atan2>\nmovsd  0x8(%rbx),%xmm1\nmulsd  0x18(%rbx),%xmm1\nmovsd  %xmm0,(%rsp)\nmovsd  (%rbx),%xmm0\nmulsd  0x10(%rbx),%xmm0\naddsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\ncall   1960 <libmin_asin>\nmovsd  (%rsp),%xmm3\nmovsd  0x18(%rbx),%xmm1\nunpcklpd %xmm0,%xmm3\nmovsd  0x10(%rbx),%xmm0\nmovapd %xmm1,%xmm4\nmulsd  %xmm1,%xmm4\nmovaps %xmm3,(%rsp)\nmulsd  (%rbx),%xmm1\nmovapd %xmm0,%xmm2\nmulsd  %xmm0,%xmm2\nmulsd  0x8(%rbx),%xmm0\naddsd  %xmm4,%xmm2\naddsd  %xmm0,%xmm1\naddsd  %xmm2,%xmm2\naddsd  %xmm1,%xmm1\nmovapd %xmm1,%xmm0\nmovsd  0x5a95(%rip),%xmm1\nsubsd  %xmm2,%xmm1\ncall   1ee0 <libmin_atan2>\nmovapd (%rsp),%xmm3\nmovups %xmm3,(%r12)\nmov    %r12,%rax\nmovsd  %xmm0,0x10(%r12)\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\nret\nnopl   0x0(%rax,%rax,1)\nlea    0x5a39(%rip),%rsi\nlea    0x59a6(%rip),%rdi\nxor    %eax,%eax\ncall   40f0 <libmin_printf>\npxor   %xmm3,%xmm3\npxor   %xmm0,%xmm0\njmp    1631 <euler_from_quat+0xe1>\nnop\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "main", "content": "int main()\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double x; // xmm1_8\n  double v4; // xmm1_8\n  __int128 v5; // [rsp+8h] [rbp-90h]\n  euler in_euler; // [rsp+20h] [rbp-78h] BYREF\n  quaternion in_quat; // [rsp+40h] [rbp-58h] BYREF\n  quaternion v8; // [rsp+60h] [rbp-38h] BYREF\n  unsigned __int64 v9; // [rsp+88h] [rbp-10h]\n\n  v9 = __readfsqword(0x28u);\n  *(_OWORD *)&in_quat.w = xmmword_70D0;\n  *(_OWORD *)&in_quat.q2 = 0LL;\n  euler_from_quat(&in_euler, &in_quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", in_euler.pitch, in_euler.roll, in_euler.yaw);\n  quat_from_euler(&v8, &in_euler);\n  x = v8.dual.x;\n  v5 = *(_OWORD *)&v8.w;\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", v8.w, v8.dual.x, v8.dual.y, v8.dual.z);\n  if ( libmin_fabs(x) < 0.01 )\n  {\n    v4 = *((double *)&v5 + 1) - in_quat.dual.x;\n    if ( libmin_fabs(*((double *)&v5 + 1) - in_quat.dual.x) < 0.01 )\n    {\n      if ( libmin_fabs(v4) < 0.01 )\n      {\n        if ( libmin_fabs(v4) < 0.01 )\n        {\n          libmin_printf(\"All tests passed!\\n\");\n          libmin_success();\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double x;\n  double v4;\n  __int128 v5;\n  euler in_euler;\n  quaternion in_quat;\n  quaternion v8;\n  unsigned long long v9;\n  v9 = __readfsqword(40u);\n  *(long double *)&in_quat.w = xmmword_70D0;\n  *(long double *)&in_quat.q2 = 0LL;\n  euler_from_quat(&in_euler, &in_quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", in_euler.pitch, in_euler.roll,\n                in_euler.yaw);\n  quat_from_euler(&v8, &in_euler);\n  x = v8.dual.x;\n  v5 = *(long double *)&v8.w;\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", v8.w, v8.dual.x,\n                v8.dual.y, v8.dual.z);\n  if (libmin_fabs(x) < 0.01) {\n    v4 = *((double *)&v5 + 1) - in_quat.dual.x;\n    if (libmin_fabs(*((double *)&v5 + 1) - in_quat.dual.x) < 0.01) {\n      if (libmin_fabs(v4) < 0.01) {\n        if (libmin_fabs(v4) < 0.01) {\n          libmin_printf(\"All tests passed!\\n\");\n          libmin_success();\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}", "binary": "quaternions/quaternions.host.O3", "assembly": "<main>:\nendbr64\npush   %rbp\nsub    $0x90,%rsp\nmovapd 0x5fbc(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x88(%rsp)\nxor    %eax,%eax\nlea    0x20(%rsp),%rbp\nlea    0x40(%rsp),%rsi\nmov    %rbp,%rdi\nmovaps %xmm0,0x40(%rsp)\npxor   %xmm0,%xmm0\nmovaps %xmm0,0x50(%rsp)\ncall   1550 <euler_from_quat>\nmovsd  0x30(%rsp),%xmm2\nmovsd  0x20(%rsp),%xmm1\nlea    0x5ebd(%rip),%rdi\nmovsd  0x28(%rsp),%xmm0\nmov    $0x3,%eax\ncall   40f0 <libmin_printf>\nmov    %rbp,%rsi\nlea    0x60(%rsp),%rdi\ncall   13e0 <quat_from_euler>\nmovsd  0x78(%rsp),%xmm4\nmov    $0x4,%eax\nmovsd  0x68(%rsp),%xmm1\nmovsd  0x70(%rsp),%xmm2\nmovsd  0x60(%rsp),%xmm0\nlea    0x5ead(%rip),%rdi\nmovapd %xmm4,%xmm3\nmovsd  %xmm1,0x10(%rsp)\nmovq   %xmm4,%rbp\nmovsd  %xmm2,0x18(%rsp)\nmovsd  %xmm0,0x8(%rsp)\ncall   40f0 <libmin_printf>\nmovsd  0x8(%rsp),%xmm0\nsubsd  0x40(%rsp),%xmm0\ncall   21a0 <libmin_fabs>\nmovsd  0x5eec(%rip),%xmm5\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x18(%rsp),%xmm2\ncomisd %xmm0,%xmm5\njbe    1287 <main+0x187>\nsubsd  0x48(%rsp),%xmm1\nmovsd  %xmm2,0x8(%rsp)\nmovapd %xmm1,%xmm0\ncall   21a0 <libmin_fabs>\nmovsd  0x5eb9(%rip),%xmm6\nmovsd  0x8(%rsp),%xmm2\ncomisd %xmm0,%xmm6\njbe    12c9 <main+0x1c9>\nsubsd  0x50(%rsp),%xmm2\nmovapd %xmm2,%xmm0\ncall   21a0 <libmin_fabs>\nmovsd  0x5e92(%rip),%xmm7\ncomisd %xmm0,%xmm7\njbe    12ba <main+0x1ba>\nmovq   %rbp,%xmm0\nsubsd  0x58(%rsp),%xmm0\ncall   21a0 <libmin_fabs>\nmovsd  0x5e70(%rip),%xmm4\ncomisd %xmm0,%xmm4\njbe    12ae <main+0x1ae>\nlea    0x5dd6(%rip),%rdi\nxor    %eax,%eax\ncall   40f0 <libmin_printf>\ncall   4e50 <libmin_success>\nmov    0x88(%rsp),%rax\nsub    %fs:0x28,%rax\njne    12de <main+0x1de>\nadd    $0x90,%rsp\nxor    %eax,%eax\npop    %rbp\nret\nmov    $0x1,%edi\nmovsd  %xmm2,0x10(%rsp)\nmovsd  %xmm1,0x8(%rsp)\ncall   21e0 <libmin_fail>\nmovsd  0x10(%rsp),%xmm2\nmovsd  0x8(%rsp),%xmm1\njmp    11ea <main+0xea>\nmov    $0x1,%edi\ncall   21e0 <libmin_fail>\njmp    1256 <main+0x156>\nmov    $0x1,%edi\ncall   21e0 <libmin_fail>\njmp    1238 <main+0x138>\nmov    $0x1,%edi\ncall   21e0 <libmin_fail>\nmovsd  0x8(%rsp),%xmm2\njmp    1217 <main+0x117>\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "quat_from_euler", "content": "/**\n * @addtogroup quats 3D Quaternion operations\n * @{\n */\n\n/**\n * Function to convert given Euler angles to a quaternion.\n * \\f{eqnarray*}{\n * q_{0} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * +\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{1} & =\n * &\\sin\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * -\n * \\cos\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{2} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * +\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{3} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\n * -\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\\\\\n * \\f}\n *\n * @param [in] in_euler input Euler angles instance\n * @returns converted quaternion\n */\nquaternion quat_from_euler(const euler *in_euler)\n{\n    quaternion out_quat = {{0.0}, {{0.0, 0.0, 0.0}}}; \n\n    if (!in_euler)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_quat;\n    }\n\n    quaternion temp;\n\n    double cy = libmin_cos(in_euler->yaw * 0.5);\n    double sy = libmin_sin(in_euler->yaw * 0.5);\n    double cp = libmin_cos(in_euler->pitch * 0.5);\n    double sp = libmin_sin(in_euler->pitch * 0.5);\n    double cr = libmin_cos(in_euler->roll * 0.5);\n    double sr = libmin_sin(in_euler->roll * 0.5);\n\n    temp.w = cr * cp * cy + sr * sp * sy;\n    temp.q1 = sr * cp * cy - cr * sp * sy;\n    temp.q2 = cr * sp * cy + sr * cp * sy;\n    temp.q3 = cr * cp * sy - sr * sp * cy;\n\n    return temp;\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O3.pseudo", "function_name": "quat_from_euler", "address": "0x13e0", "label": "quat_from_euler", "content": "quaternion *__fastcall quat_from_euler(quaternion *__return_ptr retstr, const euler *in_euler)\n{\n  double v2; // xmm1_8\n  double v3; // xmm0_8\n  quaternion *result; // rax\n  __m128d v5; // xmm1\n  __m128d v6; // xmm3\n  double cr; // [rsp+8h] [rbp-40h]\n  double sp_0; // [rsp+10h] [rbp-38h]\n  double cp; // [rsp+18h] [rbp-30h]\n  double sy; // [rsp+20h] [rbp-28h]\n  double cy; // [rsp+28h] [rbp-20h]\n\n  if ( in_euler )\n  {\n    cy = libmin_cos(v2);\n    sy = libmin_sin(v2);\n    cp = libmin_cos(v2);\n    sp_0 = libmin_sin(v2);\n    cr = libmin_cos(v2);\n    v3 = libmin_sin(v2);\n    result = retstr;\n    v5 = (__m128d)*(unsigned __int64 *)&sp_0;\n    v6 = (__m128d)*(unsigned __int64 *)&cp;\n    v6.m128d_f64[0] = cp * cr * sy - sp_0 * v3 * cy;\n    v5.m128d_f64[0] = sp_0 * cr * cy + cp * v3 * sy;\n    *(__m128d *)&retstr->w = _mm_unpacklo_pd(\n                               (__m128d)COERCE_UNSIGNED_INT64(cp * cr * cy + sp_0 * v3 * sy),\n                               (__m128d)COERCE_UNSIGNED_INT64(cp * v3 * cy - sp_0 * cr * sy));\n    *(__m128d *)&retstr->q2 = _mm_unpacklo_pd(v5, v6);\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    result = retstr;\n    *(_OWORD *)&retstr->w = 0LL;\n    *(_OWORD *)&retstr->q2 = 0LL;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "quaternion *quat_from_euler(quaternion *__return_ptr retstr,\n                            const euler *in_euler) {\n  double v2;\n  double v3;\n  quaternion *result;\n  __m128d v5;\n  __m128d v6;\n  double cr;\n  double sp_0;\n  double cp;\n  double sy;\n  double cy;\n  if (in_euler) {\n    cy = libmin_cos(v2);\n    sy = libmin_sin(v2);\n    cp = libmin_cos(v2);\n    sp_0 = libmin_sin(v2);\n    cr = libmin_cos(v2);\n    v3 = libmin_sin(v2);\n    result = retstr;\n    v5 = (__m128d) * (unsigned long long *)&sp_0;\n    v6 = (__m128d) * (unsigned long long *)&cp;\n    v6.m128d_f64[0] = cp * cr * sy - sp_0 * v3 * cy;\n    v5.m128d_f64[0] = sp_0 * cr * cy + cp * v3 * sy;\n    *(__m128d *)&retstr->w = _mm_unpacklo_pd(\n        (__m128d)COERCE_UNSIGNED_INT64(cp * cr * cy + sp_0 * v3 * sy),\n        (__m128d)COERCE_UNSIGNED_INT64(cp * v3 * cy - sp_0 * cr * sy));\n    *(__m128d *)&retstr->q2 = _mm_unpacklo_pd(v5, v6);\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    result = retstr;\n    *(long double *)&retstr->w = 0LL;\n    *(long double *)&retstr->q2 = 0LL;\n  }\n  return result;\n}", "binary": "quaternions/quaternions.host.O3", "assembly": "<quat_from_euler>:\nendbr64\npush   %r12\nmov    %rdi,%r12\npush   %rbx\nsub    $0x38,%rsp\ntest   %rsi,%rsi\nje     1520 <quat_from_euler+0x140>\nmovsd  0x5cb1(%rip),%xmm0\nmulsd  0x10(%rsi),%xmm0\nmov    %rsi,%rbx\ncall   4460 <libmin_cos>\nmovsd  %xmm0,0x28(%rsp)\nmovsd  0x5c96(%rip),%xmm0\nmulsd  0x10(%rbx),%xmm0\ncall   4850 <libmin_sin>\nmovsd  %xmm0,0x20(%rsp)\nmovsd  0x5c7e(%rip),%xmm0\nmulsd  0x8(%rbx),%xmm0\ncall   4460 <libmin_cos>\nmovsd  %xmm0,0x18(%rsp)\nmovsd  0x5c66(%rip),%xmm0\nmulsd  0x8(%rbx),%xmm0\ncall   4850 <libmin_sin>\nmovsd  %xmm0,0x10(%rsp)\nmovsd  0x5c4e(%rip),%xmm0\nmulsd  (%rbx),%xmm0\ncall   4460 <libmin_cos>\nmovsd  %xmm0,0x8(%rsp)\nmovsd  0x5c37(%rip),%xmm0\nmulsd  (%rbx),%xmm0\ncall   4850 <libmin_sin>\nmovsd  0x18(%rsp),%xmm2\nmov    %r12,%rax\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x8(%rsp),%xmm7\nmovsd  0x28(%rsp),%xmm4\nmovapd %xmm2,%xmm3\nmovapd %xmm1,%xmm6\nmovsd  0x20(%rsp),%xmm5\nmulsd  %xmm7,%xmm3\nmulsd  %xmm0,%xmm6\nmulsd  %xmm0,%xmm2\nmulsd  %xmm7,%xmm1\nmovapd %xmm3,%xmm0\nmulsd  %xmm4,%xmm0\nmovapd %xmm6,%xmm7\nmulsd  %xmm5,%xmm7\nmulsd  %xmm5,%xmm3\nmovapd %xmm1,%xmm8\nmulsd  %xmm5,%xmm8\nmulsd  %xmm4,%xmm1\nmulsd  %xmm4,%xmm6\naddsd  %xmm7,%xmm0\nmovapd %xmm2,%xmm7\nmulsd  %xmm4,%xmm7\nmulsd  %xmm5,%xmm2\nsubsd  %xmm6,%xmm3\nsubsd  %xmm8,%xmm7\naddsd  %xmm2,%xmm1\nunpcklpd %xmm7,%xmm0\nunpcklpd %xmm3,%xmm1\nmovups %xmm0,(%r12)\nmovups %xmm1,0x10(%r12)\nadd    $0x38,%rsp\npop    %rbx\npop    %r12\nret\nnopl   0x0(%rax)\nlea    0x5b79(%rip),%rsi\nlea    0x5ad6(%rip),%rdi\nxor    %eax,%eax\ncall   40f0 <libmin_printf>\npxor   %xmm0,%xmm0\nmov    %r12,%rax\nmovups %xmm0,(%r12)\nmovups %xmm0,0x10(%r12)\nadd    $0x38,%rsp\npop    %rbx\npop    %r12\nret\nnop\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "quaternion_multiply", "content": "/**\n * Function to multiply two quaternions.\n * \\f{eqnarray*}{\n * \\mathbf{c} & = & \\mathbf{a}\\otimes\\mathbf{b}\\\\\n * & = & \\begin{bmatrix}a_{0} & a_{1} & a_{2} &\n *  a_{3}\\end{bmatrix}\\otimes\\begin{bmatrix}b_{0} & b_{1} & b_{2} &\n *  b_{3}\\end{bmatrix}\\\\\n * & = &\n * \\begin{bmatrix}\n *  a_{0}b_{0}-a_{1}b_{1}-a_{2}b_{2}-a_{3}b_{3}\\\\\n *  a_{0}b_{1}+a_{1}b_{0}+a_{2}b_{3}-a_{3}b_{2}\\\\\n *  a_{0}b_{2}-a_{1}b_{3}+a_{2}b_{0}+a_{3}b_{1}\\\\\n *  a_{0}b_{3}+a_{1}b_{2}-a_{2}b_{1}+a_{3}b_{0}\n * \\end{bmatrix}^{T}\n * \\f}\n *\n * @param [in] in_quat1 first input quaternion instance\n * @param [in] in_quat2 second input quaternion instance\n * @returns resultant quaternion\n */\nquaternion quaternion_multiply(const quaternion *in_quat1,\n                               const quaternion *in_quat2)\n{\n    quaternion out_quat = {{0.0}, {{0.0, 0.0, 0.0}}}; \n    if (!in_quat1 || !in_quat2)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_quat;\n    }\n\n    out_quat.w = in_quat1->w * in_quat2->w - in_quat1->q1 * in_quat2->q1 -\n                 in_quat1->q2 * in_quat2->q2 - in_quat1->q3 * in_quat2->q3;\n    out_quat.q1 = in_quat1->w * in_quat2->q1 + in_quat1->q1 * in_quat2->w +\n                  in_quat1->q2 * in_quat2->q3 - in_quat1->q3 * in_quat2->q2;\n    out_quat.q2 = in_quat1->w * in_quat2->q2 - in_quat1->q1 * in_quat2->q3 +\n                  in_quat1->q2 * in_quat2->w + in_quat1->q3 * in_quat2->q1;\n    out_quat.q3 = in_quat1->w * in_quat2->q3 + in_quat1->q1 * in_quat2->q2 -\n                  in_quat1->q2 * in_quat2->q1 + in_quat1->q3 * in_quat2->w;\n\n    return out_quat;\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O3.pseudo", "function_name": "quaternion_multiply", "address": "0x1670", "label": "quaternion_multiply", "content": "quaternion *__fastcall quaternion_multiply(\n        quaternion *__return_ptr retstr,\n        const quaternion *in_quat1,\n        const quaternion *in_quat2)\n{\n  __m128d v3; // xmm2\n  __m128d v4; // xmm4\n  __m128d v5; // xmm3\n  __m128d v6; // xmm0\n  __m128d v7; // xmm2\n  __m128d v8; // xmm7\n  __m128d v9; // xmm5\n  __m128d v10; // xmm1\n  __m128d v11; // xmm8\n  __m128d v12; // xmm0\n  __m128d v13; // xmm2\n  double v14; // xmm9_8\n  __m128d v15; // xmm1\n  __m128d v16; // xmm0\n  __m128d v17; // xmm2\n  __m128d v18; // xmm3\n  __m128d v19; // xmm6\n  __m128d v20; // xmm4\n  __m128d v21; // xmm0\n  __m128d v22; // xmm1\n  __m128d v23; // xmm0\n  __m128d v24; // xmm1\n  quaternion *result; // rax\n\n  if ( in_quat1 && in_quat2 )\n  {\n    v3 = *(__m128d *)&in_quat1->w;\n    v4 = *(__m128d *)&in_quat2->q2;\n    v5 = *(__m128d *)&in_quat1->q2;\n    v6 = _mm_unpacklo_pd(v3, v3);\n    v7 = _mm_unpackhi_pd(v3, v3);\n    v8 = _mm_shuffle_pd(*(__m128d *)&in_quat2->w, *(__m128d *)&in_quat2->w, 1);\n    v9 = _mm_shuffle_pd(v4, v4, 1);\n    v10 = _mm_mul_pd(v6, *(__m128d *)&in_quat2->w);\n    v11 = _mm_mul_pd(v7, v8);\n    v12 = _mm_mul_pd(v6, v4);\n    v13 = _mm_mul_pd(v7, v9);\n    v14 = v10.m128d_f64[0] - v11.m128d_f64[0];\n    v15 = _mm_add_pd(v10, v11);\n    v11.m128d_f64[0] = v12.m128d_f64[0] - v13.m128d_f64[0];\n    v16 = _mm_add_pd(v12, v13);\n    v17 = _mm_unpacklo_pd(v5, v5);\n    v15.m128d_f64[0] = v14;\n    v18 = _mm_unpackhi_pd(v5, v5);\n    v19 = _mm_mul_pd(*(__m128d *)&in_quat2->w, v17);\n    v20 = _mm_mul_pd(v4, v17);\n    v16.m128d_f64[0] = v11.m128d_f64[0];\n    v21 = _mm_sub_pd(v16, v19);\n    v21.m128d_f64[0] = v11.m128d_f64[0] + v19.m128d_f64[0];\n    v22 = _mm_add_pd(v15, v20);\n    v23 = _mm_add_pd(v21, _mm_mul_pd(v8, v18));\n    v22.m128d_f64[0] = v14 - v20.m128d_f64[0];\n    v24 = _mm_sub_pd(v22, _mm_mul_pd(v9, v18));\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    v23 = 0LL;\n    v24 = 0LL;\n  }\n  result = retstr;\n  *(__m128d *)&retstr->w = v24;\n  *(__m128d *)&retstr->q2 = v23;\n  return result;\n}\n"}, "pseudo_normalize": "quaternion *quaternion_multiply(quaternion *__return_ptr retstr,\n                                const quaternion *in_quat1,\n                                const quaternion *in_quat2) {\n  __m128d v3;\n  __m128d v4;\n  __m128d v5;\n  __m128d v6;\n  __m128d v7;\n  __m128d v8;\n  __m128d v9;\n  __m128d v10;\n  __m128d v11;\n  __m128d v12;\n  __m128d v13;\n  double v14;\n  __m128d v15;\n  __m128d v16;\n  __m128d v17;\n  __m128d v18;\n  __m128d v19;\n  __m128d v20;\n  __m128d v21;\n  __m128d v22;\n  __m128d v23;\n  __m128d v24;\n  quaternion *result;\n  if (in_quat1 && in_quat2) {\n    v3 = *(__m128d *)&in_quat1->w;\n    v4 = *(__m128d *)&in_quat2->q2;\n    v5 = *(__m128d *)&in_quat1->q2;\n    v6 = _mm_unpacklo_pd(v3, v3);\n    v7 = _mm_unpackhi_pd(v3, v3);\n    v8 = _mm_shuffle_pd(*(__m128d *)&in_quat2->w, *(__m128d *)&in_quat2->w, 1);\n    v9 = _mm_shuffle_pd(v4, v4, 1);\n    v10 = _mm_mul_pd(v6, *(__m128d *)&in_quat2->w);\n    v11 = _mm_mul_pd(v7, v8);\n    v12 = _mm_mul_pd(v6, v4);\n    v13 = _mm_mul_pd(v7, v9);\n    v14 = v10.m128d_f64[0] - v11.m128d_f64[0];\n    v15 = _mm_add_pd(v10, v11);\n    v11.m128d_f64[0] = v12.m128d_f64[0] - v13.m128d_f64[0];\n    v16 = _mm_add_pd(v12, v13);\n    v17 = _mm_unpacklo_pd(v5, v5);\n    v15.m128d_f64[0] = v14;\n    v18 = _mm_unpackhi_pd(v5, v5);\n    v19 = _mm_mul_pd(*(__m128d *)&in_quat2->w, v17);\n    v20 = _mm_mul_pd(v4, v17);\n    v16.m128d_f64[0] = v11.m128d_f64[0];\n    v21 = _mm_sub_pd(v16, v19);\n    v21.m128d_f64[0] = v11.m128d_f64[0] + v19.m128d_f64[0];\n    v22 = _mm_add_pd(v15, v20);\n    v23 = _mm_add_pd(v21, _mm_mul_pd(v8, v18));\n    v22.m128d_f64[0] = v14 - v20.m128d_f64[0];\n    v24 = _mm_sub_pd(v22, _mm_mul_pd(v9, v18));\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    v23 = 0LL;\n    v24 = 0LL;\n  }\n  result = retstr;\n  *(__m128d *)&retstr->w = v24;\n  *(__m128d *)&retstr->q2 = v23;\n  return result;\n}", "binary": "quaternions/quaternions.host.O3", "assembly": "<quaternion_multiply>:\nendbr64\npush   %r12\nmov    %rdi,%r12\ntest   %rsi,%rsi\nje     1758 <quaternion_multiply+0xe8>\ntest   %rdx,%rdx\nje     1758 <quaternion_multiply+0xe8>\nmovupd (%rsi),%xmm2\nmovupd (%rdx),%xmm6\nmovupd 0x10(%rdx),%xmm4\nmovupd 0x10(%rsi),%xmm3\nmovapd %xmm2,%xmm0\nmovapd %xmm6,%xmm7\nunpcklpd %xmm2,%xmm0\nunpckhpd %xmm2,%xmm2\nshufpd $0x1,%xmm6,%xmm7\nmovapd %xmm4,%xmm5\nmovapd %xmm0,%xmm1\nmovapd %xmm2,%xmm8\nshufpd $0x1,%xmm4,%xmm5\nmulpd  %xmm6,%xmm1\nmulpd  %xmm7,%xmm8\nmulpd  %xmm4,%xmm0\nmulpd  %xmm5,%xmm2\nmovapd %xmm1,%xmm9\nsubpd  %xmm8,%xmm9\naddpd  %xmm8,%xmm1\nmovapd %xmm0,%xmm8\nsubpd  %xmm2,%xmm8\naddpd  %xmm2,%xmm0\nmovapd %xmm3,%xmm2\nunpcklpd %xmm3,%xmm2\nmovsd  %xmm9,%xmm1\nunpckhpd %xmm3,%xmm3\nmulpd  %xmm2,%xmm6\nmulpd  %xmm2,%xmm4\nmovsd  %xmm8,%xmm0\nmulpd  %xmm3,%xmm7\nmovapd %xmm0,%xmm2\nmulpd  %xmm3,%xmm5\naddpd  %xmm6,%xmm2\nsubpd  %xmm6,%xmm0\nmovsd  %xmm2,%xmm0\nmovapd %xmm1,%xmm2\naddpd  %xmm4,%xmm1\nsubpd  %xmm4,%xmm2\naddpd  %xmm7,%xmm0\nmovsd  %xmm2,%xmm1\nsubpd  %xmm5,%xmm1\nmov    %r12,%rax\nmovups %xmm1,(%r12)\nmovups %xmm0,0x10(%r12)\npop    %r12\nret\nnopl   0x0(%rax)\nlea    0x5911(%rip),%rsi\nlea    0x589e(%rip),%rdi\nxor    %eax,%eax\ncall   40f0 <libmin_printf>\npxor   %xmm0,%xmm0\nmovapd %xmm0,%xmm1\njmp    1740 <quaternion_multiply+0xd0>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "rabinkarp-search/rabinkarp-search.c", "function_name": "main", "content": "int\nmain(void) \n{ \n  int n = libmin_strlen(inp_txt); // String lengths are public\n  int m = libmin_strlen(inp_pat); // String lengths are public\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  \n  char *txt = libmin_malloc(sizeof(char)*(n+1));\n  int k;\n  for (k=0; k < n; k++)\n    txt[k] = inp_txt[k];\n  txt[k] = '\\0';\n\n  char *pat = libmin_malloc(sizeof(char)*(m+1));\n  for (k=0; k < m; k++)\n    pat[k] = inp_pat[k];\n  txt[k] = '\\0';\n\n  // Return vector\n  int *ret = (int *)libmin_malloc(sizeof(int)*n);\n  for (int i=0; i<n; i++)\n    ret[i] = FALSE; \n\n  // Run search\n  search(txt, n, pat, m, ret);\n\n  // print results\n  for(int i=0; i<n; i++)\n  {\n    if (ret[i]) \n    { \n      libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "rabinkarp-search/rabinkarp-search.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r13d\n  int v4; // ebp\n  int v5; // ebx\n  int v6; // r12d\n  char *v7; // r14\n  unsigned int v8; // eax\n  int v9; // esi\n  __int64 v10; // rax\n  __int64 v11; // rdx\n  int v12; // eax\n  int v13; // edx\n  int v14; // eax\n  __int64 v15; // rax\n  __m128i *v16; // r9\n  unsigned int v17; // eax\n  int v18; // esi\n  char *v19; // rcx\n  __int64 v20; // rax\n  int v21; // edx\n  int v22; // eax\n  int v23; // edx\n  int *v24; // rax\n  int *v25; // r15\n  __int64 v26; // r13\n  __int64 v27; // rbx\n  __int64 v28; // rax\n  __int64 v29; // rdx\n  __int64 v30; // rax\n  __int64 v31; // rsi\n  __int64 v32; // rdx\n  __int64 v33; // rax\n  __int64 v34; // rsi\n  char *pat; // [rsp+8h] [rbp-40h]\n\n  v3 = libmin_strlen(inp_txt);\n  v4 = v3;\n  v5 = libmin_strlen(inp_pat);\n  v6 = v5;\n  libmin_printf(\"n = %d, m = %d\\n\", v3, v5);\n  v7 = (char *)libmin_malloc(v3 + 1);\n  if ( v3 <= 0 )\n  {\n    v15 = 0LL;\nLABEL_18:\n    v7[v15] = 0;\n    v16 = (__m128i *)libmin_malloc(v5 + 1);\n    if ( v5 <= 0 )\n    {\n      v5 = 0;\n      goto LABEL_32;\n    }\n    v17 = v5 - 1;\n    v18 = v5;\n    v19 = inp_pat;\n    if ( (unsigned __int64)((char *)v16 - &inp_pat[1]) <= 0xE || v17 <= 6 )\n    {\n      v29 = v17;\n      v30 = 0LL;\n      do\n      {\n        v16->m128i_i8[v30] = v19[v30];\n        v31 = v30++;\n      }\n      while ( v31 != v29 );\n      goto LABEL_32;\n    }\n    if ( v17 <= 0xE )\n    {\n      v20 = 0LL;\n      v21 = 0;\n    }\n    else\n    {\n      v20 = v5 & 0xFFFFFFF0;\n      *v16 = _mm_load_si128((const __m128i *)inp_pat);\n      v21 = v20;\n      if ( v5 == (_DWORD)v20 )\n        goto LABEL_32;\n      v18 = v5 - v20;\n      if ( (unsigned int)(v5 - v20 - 1) <= 6 )\n      {\nLABEL_25:\n        v16->m128i_i8[v21] = v19[v21];\n        if ( v5 > v21 + 1 )\n        {\n          v16->m128i_i8[v21 + 1] = v19[v21 + 1];\n          if ( v21 + 2 < v5 )\n          {\n            v16->m128i_i8[v21 + 2] = v19[v21 + 2];\n            if ( v5 > v21 + 3 )\n            {\n              v16->m128i_i8[v21 + 3] = v19[v21 + 3];\n              if ( v5 > v21 + 4 )\n              {\n                v16->m128i_i8[v21 + 4] = v19[v21 + 4];\n                v22 = v21 + 5;\n                if ( v5 > v21 + 5 )\n                {\n                  v23 = v21 + 6;\n                  v16->m128i_i8[v22] = v19[v22];\n                  if ( v5 > v23 )\n                    v16->m128i_i8[v23] = v19[v23];\n                }\n              }\n            }\n          }\n        }\nLABEL_32:\n        pat = (char *)v16;\n        v7[v5] = 0;\n        v24 = (int *)libmin_malloc(4LL * v3);\n        v25 = v24;\n        if ( v3 > 0 )\n        {\n          v26 = (unsigned int)(v3 - 1);\n          v27 = 0LL;\n          memset(v24, 0, 4 * v26 + 4);\n          search(v7, v4, pat, v6, v25);\n          while ( 1 )\n          {\n            if ( v25[v27] )\n            {\n              libmin_printf(\"pattern occurs at shift = %d\\n\", v27);\n              v28 = v27 + 1;\n              if ( v26 == v27 )\n                goto LABEL_38;\n            }\n            else\n            {\n              v28 = v27 + 1;\n              if ( v26 == v27 )\n                goto LABEL_38;\n            }\n            v27 = v28;\n          }\n        }\n        search(v7, v3, pat, v6, v24);\nLABEL_38:\n        libmin_success();\n      }\n    }\n    *(__int64 *)((char *)v16->m128i_i64 + v20) = *(_QWORD *)&v19[v20];\n    v21 += v18 & 0xFFFFFFF8;\n    if ( v18 == (v18 & 0xFFFFFFF8) )\n      goto LABEL_32;\n    goto LABEL_25;\n  }\n  v8 = v3 - 1;\n  v9 = v3;\n  if ( (unsigned __int64)(v7 - &inp_txt[1]) <= 0xE || v8 <= 6 )\n  {\n    v32 = v8;\n    v33 = 0LL;\n    do\n    {\n      v7[v33] = inp_txt[v33];\n      v34 = v33++;\n    }\n    while ( v32 != v34 );\n    goto LABEL_17;\n  }\n  if ( v8 <= 0xE )\n  {\n    v11 = 0LL;\n    v12 = 0;\n  }\n  else\n  {\n    v10 = 0LL;\n    do\n    {\n      *(__m128i *)&v7[v10] = _mm_load_si128((const __m128i *)&inp_txt[v10]);\n      v10 += 16LL;\n    }\n    while ( v10 != 16LL * ((unsigned int)v3 >> 4) );\n    v11 = v3 & 0xFFFFFFF0;\n    v12 = v11;\n    if ( v3 == (_DWORD)v11 )\n      goto LABEL_17;\n    v9 = v3 - v11;\n    if ( (unsigned int)(v3 - v11 - 1) <= 6 )\n    {\nLABEL_10:\n      v7[v12] = inp_txt[v12];\n      if ( v3 > v12 + 1 )\n      {\n        v7[v12 + 1] = inp_txt[v12 + 1];\n        if ( v3 > v12 + 2 )\n        {\n          v7[v12 + 2] = inp_txt[v12 + 2];\n          if ( v3 > v12 + 3 )\n          {\n            v7[v12 + 3] = inp_txt[v12 + 3];\n            if ( v3 > v12 + 4 )\n            {\n              v7[v12 + 4] = inp_txt[v12 + 4];\n              v13 = v12 + 5;\n              if ( v3 > v12 + 5 )\n              {\n                v14 = v12 + 6;\n                v7[v13] = inp_txt[v13];\n                if ( v3 > v14 )\n                  v7[v14] = inp_txt[v14];\n              }\n            }\n          }\n        }\n      }\n      goto LABEL_17;\n    }\n  }\n  *(_QWORD *)&v7[v11] = *(_QWORD *)&inp_txt[v11];\n  v12 += v9 & 0xFFFFFFF8;\n  if ( v9 != (v9 & 0xFFFFFFF8) )\n    goto LABEL_10;\nLABEL_17:\n  v15 = v3;\n  goto LABEL_18;\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  char *v7;\n  unsigned int v8;\n  int v9;\n  long long v10;\n  long long v11;\n  int v12;\n  int v13;\n  int v14;\n  long long v15;\n  __m128i *v16;\n  unsigned int v17;\n  int v18;\n  char *v19;\n  long long v20;\n  int v21;\n  int v22;\n  int v23;\n  int *v24;\n  int *v25;\n  long long v26;\n  long long v27;\n  long long v28;\n  long long v29;\n  long long v30;\n  long long v31;\n  long long v32;\n  long long v33;\n  long long v34;\n  char *pat;\n  v3 = libmin_strlen(inp_txt);\n  v4 = v3;\n  v5 = libmin_strlen(inp_pat);\n  v6 = v5;\n  libmin_printf(\"n = %d, m = %d\\n\", v3, v5);\n  v7 = (char *)libmin_malloc(v3 + 1);\n  if (v3 <= 0) {\n    v15 = 0LL;\n  LABEL_18:\n    v7[v15] = 0;\n    v16 = (__m128i *)libmin_malloc(v5 + 1);\n    if (v5 <= 0) {\n      v5 = 0;\n      goto LABEL_32;\n    }\n    v17 = v5 - 1;\n    v18 = v5;\n    v19 = inp_pat;\n    if ((unsigned long long)((char *)v16 - &inp_pat[1]) <= 14 || v17 <= 6) {\n      v29 = v17;\n      v30 = 0LL;\n      do {\n        v16->m128i_i8[v30] = v19[v30];\n        v31 = v30++;\n      } while (v31 != v29);\n      goto LABEL_32;\n    }\n    if (v17 <= 14) {\n      v20 = 0LL;\n      v21 = 0;\n    } else {\n      v20 = v5 & 4294967280;\n      *v16 = _mm_load_si128((const __m128i *)inp_pat);\n      v21 = v20;\n      if (v5 == (uint32_t)v20) goto LABEL_32;\n      v18 = v5 - v20;\n      if ((unsigned int)(v5 - v20 - 1) <= 6) {\n      LABEL_25:\n        v16->m128i_i8[v21] = v19[v21];\n        if (v5 > v21 + 1) {\n          v16->m128i_i8[v21 + 1] = v19[v21 + 1];\n          if (v21 + 2 < v5) {\n            v16->m128i_i8[v21 + 2] = v19[v21 + 2];\n            if (v5 > v21 + 3) {\n              v16->m128i_i8[v21 + 3] = v19[v21 + 3];\n              if (v5 > v21 + 4) {\n                v16->m128i_i8[v21 + 4] = v19[v21 + 4];\n                v22 = v21 + 5;\n                if (v5 > v21 + 5) {\n                  v23 = v21 + 6;\n                  v16->m128i_i8[v22] = v19[v22];\n                  if (v5 > v23) v16->m128i_i8[v23] = v19[v23];\n                }\n              }\n            }\n          }\n        }\n      LABEL_32:\n        pat = (char *)v16;\n        v7[v5] = 0;\n        v24 = (int *)libmin_malloc(4LL * v3);\n        v25 = v24;\n        if (v3 > 0) {\n          v26 = (unsigned int)(v3 - 1);\n          v27 = 0LL;\n          memset(v24, 0, 4 * v26 + 4);\n          search(v7, v4, pat, v6, v25);\n          while (1) {\n            if (v25[v27]) {\n              libmin_printf(\"pattern occurs at shift = %d\\n\", v27);\n              v28 = v27 + 1;\n              if (v26 == v27) goto LABEL_38;\n            } else {\n              v28 = v27 + 1;\n              if (v26 == v27) goto LABEL_38;\n            }\n            v27 = v28;\n          }\n        }\n        search(v7, v3, pat, v6, v24);\n      LABEL_38:\n        libmin_success();\n      }\n    }\n    *(long long *)((char *)v16->m128i_i64 + v20) = *(uint64_t *)&v19[v20];\n    v21 += v18 & 4294967288;\n    if (v18 == (v18 & 4294967288)) goto LABEL_32;\n    goto LABEL_25;\n  }\n  v8 = v3 - 1;\n  v9 = v3;\n  if ((unsigned long long)(v7 - &inp_txt[1]) <= 14 || v8 <= 6) {\n    v32 = v8;\n    v33 = 0LL;\n    do {\n      v7[v33] = inp_txt[v33];\n      v34 = v33++;\n    } while (v32 != v34);\n    goto LABEL_17;\n  }\n  if (v8 <= 14) {\n    v11 = 0LL;\n    v12 = 0;\n  } else {\n    v10 = 0LL;\n    do {\n      *(__m128i *)&v7[v10] = _mm_load_si128((const __m128i *)&inp_txt[v10]);\n      v10 += 16LL;\n    } while (v10 != 16LL * ((unsigned int)v3 >> 4));\n    v11 = v3 & 4294967280;\n    v12 = v11;\n    if (v3 == (uint32_t)v11) goto LABEL_17;\n    v9 = v3 - v11;\n    if ((unsigned int)(v3 - v11 - 1) <= 6) {\n    LABEL_10:\n      v7[v12] = inp_txt[v12];\n      if (v3 > v12 + 1) {\n        v7[v12 + 1] = inp_txt[v12 + 1];\n        if (v3 > v12 + 2) {\n          v7[v12 + 2] = inp_txt[v12 + 2];\n          if (v3 > v12 + 3) {\n            v7[v12 + 3] = inp_txt[v12 + 3];\n            if (v3 > v12 + 4) {\n              v7[v12 + 4] = inp_txt[v12 + 4];\n              v13 = v12 + 5;\n              if (v3 > v12 + 5) {\n                v14 = v12 + 6;\n                v7[v13] = inp_txt[v13];\n                if (v3 > v14) v7[v14] = inp_txt[v14];\n              }\n            }\n          }\n        }\n      }\n      goto LABEL_17;\n    }\n  }\n  *(uint64_t *)&v7[v11] = *(uint64_t *)&inp_txt[v11];\n  v12 += v9 & 4294967288;\n  if (v9 != (v9 & 4294967288)) goto LABEL_10;\nLABEL_17:\n  v15 = v3;\n  goto LABEL_18;\n}", "binary": "rabinkarp-search/rabinkarp-search.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nlea    0x4ef3(%rip),%r15\npush   %r14\nmov    %r15,%rdi\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   3f20 <libmin_strlen>\nlea    0x54d8(%rip),%rcx\nmov    %rcx,%rdi\nmov    %rax,%r13\nmov    %eax,%ebp\ncall   3f20 <libmin_strlen>\nmov    %r13d,%esi\nlea    0x2ea5(%rip),%rdi\nmov    %eax,%edx\nmov    %rax,%rbx\nmov    %eax,%r12d\nxor    %eax,%eax\ncall   3d10 <libmin_printf>\nlea    0x1(%r13),%edi\nmovslq %edi,%rdi\ncall   19d0 <libmin_malloc>\nmov    %rax,%r14\ntest   %r13d,%r13d\njle    148e <main+0x36e>\nlea    0x1(%r15),%rdi\nmov    %r14,%rdx\nlea    -0x1(%r13),%eax\nmov    %r13d,%esi\nsub    %rdi,%rdx\ncmp    $0xe,%rdx\njbe    1451 <main+0x331>\ncmp    $0x6,%eax\njbe    1451 <main+0x331>\ncmp    $0xe,%eax\njbe    149e <main+0x37e>\nmov    %r13d,%edx\nxor    %eax,%eax\nshr    $0x4,%edx\nshl    $0x4,%rdx\nnop\nmovdqa (%r15,%rax,1),%xmm0\nmovups %xmm0,(%r14,%rax,1)\nadd    $0x10,%rax\ncmp    %rdx,%rax\njne    11c0 <main+0xa0>\nmov    %r13d,%edx\nand    $0xfffffff0,%edx\nmov    %edx,%eax\ncmp    %edx,%r13d\nje     128c <main+0x16c>\nmov    %r13d,%esi\nsub    %edx,%esi\nlea    -0x1(%rsi),%edi\ncmp    $0x6,%edi\njbe    1209 <main+0xe9>\nmov    (%r15,%rdx,1),%rdi\nmov    %rdi,(%r14,%rdx,1)\nmov    %esi,%edx\nand    $0xfffffff8,%edx\nadd    %edx,%eax\ncmp    %edx,%esi\nje     128c <main+0x16c>\nmovslq %eax,%rdx\nmovzbl (%r15,%rdx,1),%esi\nmov    %sil,(%r14,%rdx,1)\nlea    0x1(%rax),%edx\ncmp    %edx,%r13d\njle    128c <main+0x16c>\nmovslq %edx,%rdx\nmovzbl (%r15,%rdx,1),%esi\nmov    %sil,(%r14,%rdx,1)\nlea    0x2(%rax),%edx\ncmp    %edx,%r13d\njle    128c <main+0x16c>\nmovslq %edx,%rdx\nmovzbl (%r15,%rdx,1),%esi\nmov    %sil,(%r14,%rdx,1)\nlea    0x3(%rax),%edx\ncmp    %edx,%r13d\njle    128c <main+0x16c>\nmovslq %edx,%rdx\nmovzbl (%r15,%rdx,1),%esi\nmov    %sil,(%r14,%rdx,1)\nlea    0x4(%rax),%edx\ncmp    %edx,%r13d\njle    128c <main+0x16c>\nmovslq %edx,%rdx\nmovzbl (%r15,%rdx,1),%esi\nmov    %sil,(%r14,%rdx,1)\nlea    0x5(%rax),%edx\ncmp    %edx,%r13d\njle    128c <main+0x16c>\nmovslq %edx,%rdx\nadd    $0x6,%eax\nmovzbl (%r15,%rdx,1),%esi\nmov    %sil,(%r14,%rdx,1)\ncmp    %eax,%r13d\njle    128c <main+0x16c>\ncltq\nmovzbl (%r15,%rax,1),%edx\nmov    %dl,(%r14,%rax,1)\nmovslq %r13d,%rax\nmovb   $0x0,(%r14,%rax,1)\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\ncall   19d0 <libmin_malloc>\nmov    %rax,%r9\ntest   %ebx,%ebx\njle    1472 <main+0x352>\nlea    0x5370(%rip),%rdi\nmov    %r9,%rdx\nlea    -0x1(%rbx),%eax\nmov    %ebx,%esi\nsub    %rdi,%rdx\nlea    -0x1(%rdi),%rcx\ncmp    $0xe,%rdx\njbe    142f <main+0x30f>\ncmp    $0x6,%eax\njbe    142f <main+0x30f>\ncmp    $0xe,%eax\njbe    1495 <main+0x375>\nmovdqa 0x533c(%rip),%xmm1\nmov    %ebx,%eax\nand    $0xfffffff0,%eax\nmovups %xmm1,(%r9)\nmov    %eax,%edx\ncmp    %eax,%ebx\nje     1386 <main+0x266>\nsub    %eax,%esi\nlea    -0x1(%rsi),%edi\ncmp    $0x6,%edi\njbe    1314 <main+0x1f4>\nmov    (%rcx,%rax,1),%rdi\nmov    %rdi,(%r9,%rax,1)\nmov    %esi,%eax\nand    $0xfffffff8,%eax\nadd    %eax,%edx\ncmp    %eax,%esi\nje     1386 <main+0x266>\nmovslq %edx,%rax\nmovzbl (%rcx,%rax,1),%esi\nmov    %sil,(%r9,%rax,1)\nlea    0x1(%rdx),%eax\ncmp    %eax,%ebx\njle    1386 <main+0x266>\ncltq\nmovzbl (%rcx,%rax,1),%esi\nmov    %sil,(%r9,%rax,1)\nlea    0x2(%rdx),%eax\ncmp    %ebx,%eax\njge    1386 <main+0x266>\ncltq\nmovzbl (%rcx,%rax,1),%esi\nmov    %sil,(%r9,%rax,1)\nlea    0x3(%rdx),%eax\ncmp    %eax,%ebx\njle    1386 <main+0x266>\ncltq\nmovzbl (%rcx,%rax,1),%esi\nmov    %sil,(%r9,%rax,1)\nlea    0x4(%rdx),%eax\ncmp    %eax,%ebx\njle    1386 <main+0x266>\ncltq\nmovzbl (%rcx,%rax,1),%esi\nmov    %sil,(%r9,%rax,1)\nlea    0x5(%rdx),%eax\ncmp    %eax,%ebx\njle    1386 <main+0x266>\ncltq\nadd    $0x6,%edx\nmovzbl (%rcx,%rax,1),%esi\nmov    %sil,(%r9,%rax,1)\ncmp    %edx,%ebx\njle    1386 <main+0x266>\nmovslq %edx,%rdx\nmovzbl (%rcx,%rdx,1),%eax\nmov    %al,(%r9,%rdx,1)\nmovslq %ebx,%rbx\nmovslq %r13d,%rdi\nmov    %r9,0x8(%rsp)\nmovb   $0x0,(%r14,%rbx,1)\nshl    $0x2,%rdi\ncall   19d0 <libmin_malloc>\ntest   %r13d,%r13d\nmov    0x8(%rsp),%r9\nmov    %rax,%r15\njle    1479 <main+0x359>\nsub    $0x1,%r13d\nxor    %esi,%esi\nmov    %rax,%rdi\nxor    %ebx,%ebx\nlea    0x4(,%r13,4),%rdx\ncall   10d0 <memset@plt>\nmov    0x8(%rsp),%rdx\nmov    %ebp,%esi\nmov    %r15,%r8\nmov    %r12d,%ecx\nmov    %r14,%rdi\nlea    0x2c35(%rip),%rbp\ncall   15a0 <search>\njmp    13fc <main+0x2dc>\ncs nopw 0x0(%rax,%rax,1)\nlea    0x1(%rbx),%rax\ncmp    %rbx,%r13\nje     1419 <main+0x2f9>\nmov    %rax,%rbx\nmov    (%r15,%rbx,4),%eax\nmov    %ebx,%esi\ntest   %eax,%eax\nje     13f0 <main+0x2d0>\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   3d10 <libmin_printf>\nlea    0x1(%rbx),%rax\ncmp    %rbx,%r13\njne    13f9 <main+0x2d9>\ncall   3f50 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %eax,%edx\nxor    %eax,%eax\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rcx,%rax,1),%esi\nmov    %sil,(%r9,%rax,1)\nmov    %rax,%rsi\nadd    $0x1,%rax\ncmp    %rdx,%rsi\njne    1438 <main+0x318>\njmp    1386 <main+0x266>\nmov    %eax,%edx\nxor    %eax,%eax\nnopl   (%rax)\nmovzbl (%r15,%rax,1),%esi\nmov    %sil,(%r14,%rax,1)\nmov    %rax,%rsi\nadd    $0x1,%rax\ncmp    %rsi,%rdx\njne    1458 <main+0x338>\njmp    128c <main+0x16c>\nxor    %ebx,%ebx\njmp    1386 <main+0x266>\nmov    %rax,%r8\nmov    %r12d,%ecx\nmov    %r9,%rdx\nmov    %ebp,%esi\nmov    %r14,%rdi\ncall   15a0 <search>\njmp    1419 <main+0x2f9>\nxor    %eax,%eax\njmp    128f <main+0x16f>\nxor    %eax,%eax\nxor    %edx,%edx\njmp    1301 <main+0x1e1>\nxor    %edx,%edx\nxor    %eax,%eax\njmp    11f2 <main+0xd2>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "rabinkarp-search/rabinkarp-search.c", "function_name": "search", "content": "// D is the number of characters in the input alphabet \n#define D 256 \n\n/* simple string search algorithm */\nvoid\nsearch(char *txt, int n, char *pat, int m, int *ret)\n{\n  int q = INT_MAX; \n\n  // value of h would be \"pow(d, M-1)%q\" \n  int h = 1;\n  for (int i = 0; i < m - 1; i++) \n    h = (h * D) % q; \n\n  int32_t p = 0; // hash value for pattern \n  int32_t t = 0; // hash value for txt \n\n  // calculate the hash value of pattern and first window of text \n  for (int i = 0; i < m; i++) \n  { \n    p = (D * p + pat[i]) % q; \n    t = (D * t + txt[i]) % q; \n  } \n\n  // slide the pattern over text one by one \n  for (int i = 0; i <= n - m; i++) \n    { \n  \n    // check the hash values of current window of text \n    // and pattern. If the hash values match then only \n    // check for characters one by one \n    ret[i] = (p == t);\n  \n    // calculate hash value for next window of text: Remove leading digit, add trailing digit \n    if (i < n-m) \n    { \n      t = (D*(t - ((int32_t)txt[i])*h) + txt[i+m])%q; \n  \n      // we might get negative value of t, converting it to positive \n      if (t < 0) \n        t = (t + q); \n    } \n  } \n}\n"}, "pseudo": {"path": "rabinkarp-search/rabinkarp-search.host.O3.pseudo", "function_name": "search", "address": "0x15a0", "label": "search", "content": "void __fastcall search(char *txt, int n, char *pat, int m, int *ret)\n{\n  int v7; // esi\n  int v8; // r9d\n  __int64 v9; // rcx\n  unsigned int v10; // eax\n  unsigned int v11; // esi\n  unsigned int v12; // ebp\n  int v13; // eax\n  int v14; // r10d\n  __int64 v15; // rcx\n  char *v16; // rbx\n  int v17; // edx\n  bool v18; // sf\n  int v19; // r11d\n  int v20; // edx\n  unsigned int v21; // r9d\n  int *v22; // rcx\n  int *v23; // rdx\n  __m128i v24; // xmm0\n  __int64 v25; // rdi\n  __int64 v26; // rcx\n  _BOOL4 v27; // eax\n\n  if ( m - 1 > 0 )\n  {\n    v7 = 0;\n    v8 = 1;\n    do\n    {\n      ++v7;\n      v8 = (v8 << 8) % 0x7FFFFFFF;\n    }\n    while ( v7 != m - 1 );\n    if ( m > 0 )\n      goto LABEL_5;\nLABEL_26:\n    v10 = 0;\n    v11 = 0;\n    goto LABEL_7;\n  }\n  v8 = 1;\n  if ( m <= 0 )\n    goto LABEL_26;\nLABEL_5:\n  v9 = 0LL;\n  v10 = 0;\n  v11 = 0;\n  do\n  {\n    v12 = v10 << 8;\n    v13 = txt[v9];\n    v11 = (int)(pat[v9++] + (v11 << 8)) % 0x7FFFFFFF;\n    v10 = (int)(v13 + v12) % 0x7FFFFFFF;\n  }\n  while ( v9 != m );\nLABEL_7:\n  v14 = n - m;\n  if ( v14 < 0 )\n    return;\n  if ( !v14 )\n  {\n    v19 = 0;\nLABEL_14:\n    v21 = v14 - v19 + 1;\n    if ( v19 > v14 )\n      goto LABEL_20;\n    if ( (unsigned int)(v14 - v19) <= 2 )\n      goto LABEL_20;\n    v22 = &ret[v19];\n    v23 = v22 + 4;\n    v24 = _mm_and_si128(\n            _mm_cmpeq_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v10), 0), _mm_shuffle_epi32(_mm_cvtsi32_si128(v11), 0)),\n            (__m128i)xmmword_4040);\n    v25 = (__int64)&v22[4 * (v21 >> 2)];\n    while ( 1 )\n    {\n      *(__m128i *)v22 = v24;\n      v22 = v23;\n      if ( (int *)v25 == v23 )\n        break;\n      v23 += 4;\n    }\n    v19 += v21 & 0xFFFFFFFC;\n    if ( v21 != (v21 & 0xFFFFFFFC) )\n    {\nLABEL_20:\n      v26 = v19;\n      v27 = v10 == v11;\n      ret[v26] = v27;\n      if ( v14 >= v19 + 1 )\n      {\n        ret[v26 + 1] = v27;\n        if ( v19 + 2 <= v14 )\n          ret[v26 + 2] = v27;\n      }\n    }\n    return;\n  }\n  v15 = 1LL;\n  v16 = &txt[m];\n  do\n  {\n    ret[v15 - 1] = v10 == v11;\n    v17 = v16[v15 - 1] + ((v10 - v8 * txt[v15 - 1]) << 8);\n    v18 = v17 % 0x7FFFFFFF < 0;\n    v10 = v17 % 0x7FFFFFFF;\n    v19 = v15;\n    v20 = v17 % 0x7FFFFFFF + 0x7FFFFFFF;\n    if ( v18 )\n      v10 = v20;\n    ++v15;\n  }\n  while ( v14 + 1 != v15 );\n  if ( v19 <= v14 )\n    goto LABEL_14;\n}\n"}, "pseudo_normalize": "void search(char *txt, int n, char *pat, int m, int *ret) {\n  int v7;\n  int v8;\n  long long v9;\n  unsigned int v10;\n  unsigned int v11;\n  unsigned int v12;\n  int v13;\n  int v14;\n  long long v15;\n  char *v16;\n  int v17;\n  bool v18;\n  int v19;\n  int v20;\n  unsigned int v21;\n  int *v22;\n  int *v23;\n  __m128i v24;\n  long long v25;\n  long long v26;\n  int v27;\n  if (m - 1 > 0) {\n    v7 = 0;\n    v8 = 1;\n    do {\n      ++v7;\n      v8 = (v8 << 8) % 2147483647;\n    } while (v7 != m - 1);\n    if (m > 0) goto LABEL_5;\n  LABEL_26:\n    v10 = 0;\n    v11 = 0;\n    goto LABEL_7;\n  }\n  v8 = 1;\n  if (m <= 0) goto LABEL_26;\nLABEL_5:\n  v9 = 0LL;\n  v10 = 0;\n  v11 = 0;\n  do {\n    v12 = v10 << 8;\n    v13 = txt[v9];\n    v11 = (int)(pat[v9++] + (v11 << 8)) % 2147483647;\n    v10 = (int)(v13 + v12) % 2147483647;\n  } while (v9 != m);\nLABEL_7:\n  v14 = n - m;\n  if (v14 < 0) return;\n  if (!v14) {\n    v19 = 0;\n  LABEL_14:\n    v21 = v14 - v19 + 1;\n    if (v19 > v14) goto LABEL_20;\n    if ((unsigned int)(v14 - v19) <= 2) goto LABEL_20;\n    v22 = &ret[v19];\n    v23 = v22 + 4;\n    v24 = _mm_and_si128(\n        _mm_cmpeq_epi32(_mm_shuffle_epi32(_mm_cvtsi32_si128(v10), 0),\n                        _mm_shuffle_epi32(_mm_cvtsi32_si128(v11), 0)),\n        (__m128i)xmmword_4040);\n    v25 = (long long)&v22[4 * (v21 >> 2)];\n    while (1) {\n      *(__m128i *)v22 = v24;\n      v22 = v23;\n      if ((int *)v25 == v23) break;\n      v23 += 4;\n    }\n    v19 += v21 & 4294967292;\n    if (v21 != (v21 & 4294967292)) {\n    LABEL_20:\n      v26 = v19;\n      v27 = v10 == v11;\n      ret[v26] = v27;\n      if (v14 >= v19 + 1) {\n        ret[v26 + 1] = v27;\n        if (v19 + 2 <= v14) ret[v26 + 2] = v27;\n      }\n    }\n    return;\n  }\n  v15 = 1LL;\n  v16 = &txt[m];\n  do {\n    ret[v15 - 1] = v10 == v11;\n    v17 = v16[v15 - 1] + ((v10 - v8 * txt[v15 - 1]) << 8);\n    v18 = v17 % 2147483647 < 0;\n    v10 = v17 % 2147483647;\n    v19 = v15;\n    v20 = v17 % 2147483647 + 2147483647;\n    if (v18) v10 = v20;\n    ++v15;\n  } while (v14 + 1 != v15);\n  if (v19 <= v14) goto LABEL_14;\n}", "binary": "rabinkarp-search/rabinkarp-search.host.O3", "assembly": "<search>:\nendbr64\npush   %r12\nmov    %esi,%r10d\nmov    %ecx,%r11d\npush   %rbp\npush   %rbx\nlea    -0x1(%rcx),%ebx\ntest   %ebx,%ebx\njle    17d0 <search+0x230>\nxor    %esi,%esi\nmov    $0x1,%r9d\nnopl   0x0(%rax)\nmov    %r9d,%ecx\nadd    $0x1,%esi\nshl    $0x8,%ecx\nmovslq %ecx,%rax\nmov    %rax,%r9\nshl    $0x1e,%r9\nadd    %rax,%r9\nmov    %ecx,%eax\nsar    $0x1f,%eax\nsar    $0x3d,%r9\nsub    %eax,%r9d\nmov    %r9d,%eax\nshl    $0x1f,%eax\nsub    %r9d,%eax\nsub    %eax,%ecx\nmov    %ecx,%r9d\ncmp    %ebx,%esi\njne    15c8 <search+0x28>\ntest   %r11d,%r11d\njle    17e0 <search+0x240>\nmovslq %r11d,%rbx\nxor    %ecx,%ecx\nxor    %eax,%eax\nxor    %esi,%esi\nxchg   %ax,%ax\nshl    $0x8,%esi\nshl    $0x8,%eax\nmov    %esi,%ebp\nmovsbl (%rdx,%rcx,1),%esi\nadd    %esi,%ebp\nmovslq %ebp,%r12\nmov    %r12,%rsi\nshl    $0x1e,%rsi\nadd    %r12,%rsi\nmov    %ebp,%r12d\nsar    $0x1f,%r12d\nsar    $0x3d,%rsi\nsub    %r12d,%esi\nmov    %esi,%r12d\nshl    $0x1f,%r12d\nsub    %esi,%r12d\nmov    %ebp,%esi\nmov    %eax,%ebp\nmovsbl (%rdi,%rcx,1),%eax\nsub    %r12d,%esi\nadd    $0x1,%rcx\nadd    %eax,%ebp\nmovslq %ebp,%r12\nmov    %r12,%rax\nshl    $0x1e,%rax\nadd    %r12,%rax\nmov    %ebp,%r12d\nsar    $0x1f,%r12d\nsar    $0x3d,%rax\nsub    %r12d,%eax\nmov    %eax,%r12d\nshl    $0x1f,%r12d\nsub    %eax,%r12d\nmov    %ebp,%eax\nsub    %r12d,%eax\ncmp    %rbx,%rcx\njne    1610 <search+0x70>\nsub    %r11d,%r10d\njs     17c0 <search+0x220>\nje     17c8 <search+0x228>\nmovslq %r11d,%rbx\nlea    0x1(%r10),%ebp\nmov    $0x1,%ecx\nadd    %rdi,%rbx\nnopl   0x0(%rax)\nxor    %edx,%edx\ncmp    %esi,%eax\nsete   %dl\nmov    %edx,-0x4(%r8,%rcx,4)\nmovsbl -0x1(%rdi,%rcx,1),%r11d\nimul   %r9d,%r11d\nsub    %r11d,%eax\nmov    %eax,%edx\nmovsbl -0x1(%rbx,%rcx,1),%eax\nshl    $0x8,%edx\nadd    %eax,%edx\nmovslq %edx,%r11\nmov    %r11,%rax\nshl    $0x1e,%rax\nadd    %r11,%rax\nmov    %edx,%r11d\nsar    $0x1f,%r11d\nsar    $0x3d,%rax\nsub    %r11d,%eax\nmov    %eax,%r11d\nshl    $0x1f,%r11d\nsub    %eax,%r11d\nmov    %edx,%eax\nsub    %r11d,%eax\nmov    %ecx,%r11d\nlea    0x7fffffff(%rax),%edx\ncmovs  %edx,%eax\nadd    $0x1,%rcx\ncmp    %rcx,%rbp\njne    16a8 <search+0x108>\ncmp    %r10d,%r11d\njg     17c0 <search+0x220>\nmov    %r10d,%edx\nmov    $0x1,%ecx\nsub    %r11d,%edx\ncmp    %r10d,%r11d\nlea    0x1(%rdx),%r9d\ncmovg  %ecx,%r9d\njg     178d <search+0x1ed>\ncmp    $0x2,%edx\njbe    178d <search+0x1ed>\nmovslq %r11d,%rdx\nmovd   %eax,%xmm2\nmovd   %esi,%xmm3\nlea    (%r8,%rdx,4),%rcx\nmov    %r9d,%edx\npshufd $0x0,%xmm2,%xmm0\nshr    $0x2,%edx\npshufd $0x0,%xmm3,%xmm1\nlea    -0x1(%rdx),%edi\nlea    0x10(%rcx),%rdx\npcmpeqd %xmm1,%xmm0\nshl    $0x4,%rdi\npand   0x28d8(%rip),%xmm0\nadd    %rdx,%rdi\njmp    1774 <search+0x1d4>\nnopl   (%rax)\nadd    $0x10,%rdx\nmovups %xmm0,(%rcx)\nmov    %rdx,%rcx\ncmp    %rdx,%rdi\njne    1770 <search+0x1d0>\nmov    %r9d,%edx\nand    $0xfffffffc,%edx\nadd    %edx,%r11d\ncmp    %edx,%r9d\nje     17c0 <search+0x220>\ncmp    %esi,%eax\nmovslq %r11d,%rdx\nsete   %al\nlea    0x0(,%rdx,4),%rcx\nmovzbl %al,%eax\nmov    %eax,(%r8,%rdx,4)\nlea    0x1(%r11),%edx\ncmp    %edx,%r10d\njl     17c0 <search+0x220>\nadd    $0x2,%r11d\nmov    %eax,0x4(%r8,%rcx,1)\ncmp    %r10d,%r11d\njg     17c0 <search+0x220>\nmov    %eax,0x8(%r8,%rcx,1)\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopl   (%rax)\nxor    %r11d,%r11d\njmp    1715 <search+0x175>\nmov    $0x1,%r9d\ntest   %r11d,%r11d\njg     1605 <search+0x65>\nnop\nxor    %eax,%eax\nxor    %esi,%esi\njmp    1683 <search+0xe3>\nnopl   0x0(%rax)\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "bad_rand", "content": "// A deliberately weak (\"bad\") random number generator using a simple LCG.\nuint32_t bad_rand(void) {\n    static uint32_t state = 123456789;  // Fixed seed for reproducibility.\n    state = state * 110351524 + 12345;\n    return state;\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O3.pseudo", "function_name": "bad_rand", "address": "0x1240", "label": "bad_rand", "content": "uint32_t __cdecl bad_rand()\n{\n  uint32_t result; // eax\n\n  result = 110351524 * state_0 + 12345;\n  state_0 = result;\n  return result;\n}\n"}, "pseudo_normalize": "uint32_t bad_rand() {\n  uint32_t result;\n  result = 110351524 * state_0 + 12345;\n  state_0 = result;\n  return result;\n}", "binary": "rand-test/rand-test.host.O3", "assembly": "<bad_rand>:\nendbr64\nimul   $0x693d4a4,0x4dc2(%rip),%eax\nadd    $0x3039,%eax\nmov    %eax,0x4db7(%rip)\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "good_rand", "content": "// A wrapper for the system's rand() function.\n// Since rand() may not return a full 32-bit value, we combine two calls.\nuint32_t good_rand(void) {\n    // Obtain two random numbers.\n    uint32_t r1 = (uint32_t) libmin_rand();\n    uint32_t r2 = (uint32_t) libmin_rand();\n    // Combine them. This assumes rand() returns at most 15 bits.\n    return (r1 << 15) | (r2 & 0x7FFF);\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O3.pseudo", "function_name": "good_rand", "address": "0x1260", "label": "good_rand", "content": "uint32_t __cdecl good_rand()\n{\n  unsigned int v0; // ebx\n\n  v0 = libmin_rand();\n  return (v0 << 15) | libmin_rand() & 0x7FFF;\n}\n"}, "pseudo_normalize": "", "binary": "rand-test/rand-test.host.O3", "assembly": "<good_rand>:\nendbr64\npush   %rbx\ncall   38c0 <libmin_rand>\nmov    %eax,%ebx\ncall   38c0 <libmin_rand>\nshl    $0xf,%ebx\nand    $0x7fff,%eax\nor     %ebx,%eax\npop    %rbx\nret\nnopl   (%rax)\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "main", "content": "int main(void) {\n    // Seed the system's RNG for good_rand().\n    libmin_srand(42);\n\n    // First test: Use the deliberately weak generator (bad_rand).\n    run_tests(\"Bad (bad_rand())\", bad_rand);\n\n    // Second test: Use the system's standard rand() via good_rand.\n    run_tests(\"Good (good_rand())\", good_rand);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}", "binary": "rand-test/rand-test.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x2a,%edi\ncall   3860 <libmin_srand>\nlea    0x127(%rip),%rsi\nlea    0x306d(%rip),%rdi\ncall   1280 <run_tests>\nlea    0x134(%rip),%rsi\nlea    0x306b(%rip),%rdi\ncall   1280 <run_tests>\ncall   3cd0 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "run_tests", "content": "// Test harness to run the battery of randomness tests on the provided RNG.\nvoid run_tests(const char *gen_name, rng_func_t rng_func) {\n    libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n\n    uint64_t ones_count = 0;\n    uint64_t total_bits = 0;\n    uint32_t bins[BIN_COUNT] = {0};\n\n    // Variables for the serial correlation test.\n    double serial_x_sum = 0.0, serial_y_sum = 0.0;\n    double serial_xy_sum = 0.0, serial_x2_sum = 0.0, serial_y2_sum = 0.0;\n    int serial_count = 0;\n    uint32_t prev = 0;\n    int first = 1;\n\n    // Loop to generate SAMPLE_SIZE random numbers.\n    for (size_t i = 0; i < SAMPLE_SIZE; i++) {\n        uint32_t sample = rng_func();\n\n        // Monobit Test: Count the number of 1 bits.\n        ones_count += count_bits(sample);\n        total_bits += 32;\n\n        // Chi-Square Test: Use the top 8 bits for binning.\n        uint32_t bin = sample >> 24;\n        bins[bin]++;\n\n        // Serial Correlation Test: Compare adjacent samples.\n        if (!first) {\n            serial_x_sum   += (double)prev;\n            serial_y_sum   += (double)sample;\n            serial_xy_sum  += (double)prev * sample;\n            serial_x2_sum  += (double)prev * prev;\n            serial_y2_sum  += (double)sample * sample;\n            serial_count++;\n        } else {\n            first = 0;\n        }\n        prev = sample;\n    }\n\n    // Report Monobit Test Results.\n    double ones_ratio = (double)ones_count / total_bits;\n    libmin_printf(\"Monobit Test:\\n\");\n    libmin_printf(\"  Total bits processed: %llu\\n\", total_bits);\n    libmin_printf(\"  Total ones count: %llu\\n\", ones_count);\n    libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", ones_ratio);\n\n    // Report Chi-Square Test results on top 8 bits.\n    double expected_count = (double)SAMPLE_SIZE / BIN_COUNT;\n    double chi_square = 0.0;\n    for (int i = 0; i < BIN_COUNT; i++) {\n        double diff = bins[i] - expected_count;\n        chi_square += (diff * diff) / expected_count;\n    }\n    libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n    libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", chi_square, BIN_COUNT - 1);\n\n    // Report Serial Correlation Test results.\n    double mean_x = serial_x_sum / serial_count;\n    double mean_y = serial_y_sum / serial_count;\n    double covariance = (serial_xy_sum / serial_count) - (mean_x * mean_y);\n    double var_x = (serial_x2_sum / serial_count) - (mean_x * mean_x);\n    double var_y = (serial_y2_sum / serial_count) - (mean_y * mean_y);\n    double serial_corr = covariance / (libmin_sqrt(var_x * var_y));\n    libmin_printf(\"\\nSerial Correlation Test:\\n\");\n    libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\", serial_corr);\n\n    libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O3.pseudo", "function_name": "run_tests", "address": "0x1280", "label": "run_tests", "content": "void __fastcall run_tests(const char *gen_name, rng_func_t rng_func)\n{\n  __int64 v2; // r12\n  __int64 v3; // r15\n  __int64 v4; // r13\n  int v5; // ebp\n  double v6; // xmm0_8\n  uint32_t *v7; // rbx\n  double v8; // xmm1_8\n  int v9; // eax\n  double serial_corr; // [rsp+0h] [rbp-478h]\n  double serial_corra; // [rsp+0h] [rbp-478h]\n  double serial_y_sum; // [rsp+8h] [rbp-470h]\n  double serial_x_sum; // [rsp+10h] [rbp-468h]\n  double serial_y2_sum; // [rsp+18h] [rbp-460h]\n  double serial_x2_sum; // [rsp+20h] [rbp-458h]\n  uint32_t bins[256]; // [rsp+30h] [rbp-448h] BYREF\n  _BYTE v17[8]; // [rsp+430h] [rbp-48h] BYREF\n  unsigned __int64 v18; // [rsp+438h] [rbp-40h]\n\n  v2 = 9999LL;\n  v18 = __readfsqword(0x28u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  memset(bins, 0, sizeof(bins));\n  LODWORD(v3) = rng_func();\n  serial_corr = 0.0;\n  serial_y2_sum = 0.0;\n  v4 = (int)((__int64 (*)(void))_popcountdi2)();\n  serial_x2_sum = 0.0;\n  bins[BYTE3(v3)] = 1;\n  serial_y_sum = 0.0;\n  serial_x_sum = 0.0;\n  do\n  {\n    v5 = v3;\n    v3 = rng_func();\n    v4 += (int)_popcountdi2(v3);\n    ++bins[BYTE3(v3)];\n    serial_x_sum = serial_x_sum + (double)v5;\n    serial_y_sum = serial_y_sum + (double)(int)v3;\n    serial_corr = (double)v5 * (double)(int)v3 + serial_corr;\n    serial_x2_sum = (double)v5 * (double)v5 + serial_x2_sum;\n    serial_y2_sum = (double)(int)v3 * (double)(int)v3 + serial_y2_sum;\n    --v2;\n  }\n  while ( v2 );\n  libmin_printf(\"Monobit Test:\\n\");\n  libmin_printf(\"  Total bits processed: %llu\\n\", 320000LL);\n  libmin_printf(\"  Total ones count: %llu\\n\", v4);\n  if ( v4 < 0 )\n    v6 = (double)(int)(v4 & 1 | ((unsigned __int64)v4 >> 1)) + (double)(int)(v4 & 1 | ((unsigned __int64)v4 >> 1));\n  else\n    v6 = (double)(int)v4;\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v6 / 320000.0);\n  v7 = bins;\n  v8 = 0.0;\n  do\n  {\n    v9 = *v7++;\n    v8 = v8 + ((double)v9 - 39.0625) * ((double)v9 - 39.0625) / 39.0625;\n  }\n  while ( v7 != (uint32_t *)v17 );\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\", v4, v17);\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", v8, 255);\n  serial_corra = (serial_corr / 9999.0 - serial_x_sum / 9999.0 * (serial_y_sum / 9999.0))\n               / libmin_sqrt(serial_y_sum / 9999.0 * (serial_y_sum / 9999.0));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\", serial_corra);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}\n"}, "pseudo_normalize": "void run_tests(const char *gen_name, rng_func_t rng_func) {\n  long long v2;\n  long long v3;\n  long long v4;\n  int v5;\n  double v6;\n  uint32_t *v7;\n  double v8;\n  int v9;\n  double serial_corr;\n  double serial_corra;\n  double serial_y_sum;\n  double serial_x_sum;\n  double serial_y2_sum;\n  double serial_x2_sum;\n  uint32_t bins[256];\n  uint8_t v17[8];\n  unsigned long long v18;\n  v2 = 9999LL;\n  v18 = __readfsqword(40u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  memset(bins, 0, sizeof(bins));\n  LODWORD(v3) = rng_func();\n  serial_corr = 0.0;\n  serial_y2_sum = 0.0;\n  v4 = (int)((long long (*)(void))_popcountdi2)();\n  serial_x2_sum = 0.0;\n  bins[BYTE3(v3)] = 1;\n  serial_y_sum = 0.0;\n  serial_x_sum = 0.0;\n  do {\n    v5 = v3;\n    v3 = rng_func();\n    v4 += (int)_popcountdi2(v3);\n    ++bins[BYTE3(v3)];\n    serial_x_sum = serial_x_sum + (double)v5;\n    serial_y_sum = serial_y_sum + (double)(int)v3;\n    serial_corr = (double)v5 * (double)(int)v3 + serial_corr;\n    serial_x2_sum = (double)v5 * (double)v5 + serial_x2_sum;\n    serial_y2_sum = (double)(int)v3 * (double)(int)v3 + serial_y2_sum;\n    --v2;\n  } while (v2);\n  libmin_printf(\"Monobit Test:\\n\");\n  libmin_printf(\"  Total bits processed: %llu\\n\", 320000LL);\n  libmin_printf(\"  Total ones count: %llu\\n\", v4);\n  if (v4 < 0)\n    v6 = (double)(int)(v4 & 1 | ((unsigned long long)v4 >> 1)) +\n         (double)(int)(v4 & 1 | ((unsigned long long)v4 >> 1));\n  else\n    v6 = (double)(int)v4;\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v6 / 320000.0);\n  v7 = bins;\n  v8 = 0.0;\n  do {\n    v9 = *v7++;\n    v8 = v8 + ((double)v9 - 39.0625) * ((double)v9 - 39.0625) / 39.0625;\n  } while (v7 != (uint32_t *)v17);\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\", v4, v17);\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", v8,\n                255);\n  serial_corra =\n      (serial_corr / 9999.0 - serial_x_sum / 9999.0 * (serial_y_sum / 9999.0)) /\n      libmin_sqrt(serial_y_sum / 9999.0 * (serial_y_sum / 9999.0));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\",\n                serial_corra);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}", "binary": "rand-test/rand-test.host.O3", "assembly": "<run_tests>:\nendbr64\npush   %r15\npush   %r14\nmov    %rsi,%r14\nmov    %rdi,%rsi\nlea    0x2d73(%rip),%rdi\npush   %r13\npush   %r12\nmov    $0x270f,%r12d\npush   %rbp\npush   %rbx\nsub    $0x448,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x438(%rsp)\nxor    %eax,%eax\ncall   3650 <libmin_printf>\nlea    0x30(%rsp),%rdi\nxor    %eax,%eax\nmov    $0x80,%ecx\nmov    %rdi,0x28(%rsp)\nrep stos %rax,%es:(%rdi)\ncall   *%r14\nmov    %eax,%edi\nmov    %rdi,%r15\ncall   3d30 <__popcountdi2>\nmovq   $0x0,(%rsp)\nmovq   $0x0,0x18(%rsp)\nmovslq %eax,%r13\nmov    %r15d,%eax\nmovq   $0x0,0x20(%rsp)\nshr    $0x18,%eax\nmovl   $0x1,0x30(%rsp,%rax,4)\nmovq   $0x0,0x8(%rsp)\nmovq   $0x0,0x10(%rsp)\nxchg   %ax,%ax\ncall   *%r14\nmov    %r15d,%ebp\nmov    %eax,%ebx\nmov    %rbx,%rdi\nmov    %rbx,%r15\ncall   3d30 <__popcountdi2>\npxor   %xmm1,%xmm1\npxor   %xmm0,%xmm0\nmovsd  0x10(%rsp),%xmm5\ncvtsi2sd %rbp,%xmm1\nmovsd  0x8(%rsp),%xmm6\ncltq\ncvtsi2sd %rbx,%xmm0\nadd    %rax,%r13\nmov    %ebx,%eax\nshr    $0x18,%eax\naddl   $0x1,0x30(%rsp,%rax,4)\nmovapd %xmm1,%xmm2\naddsd  %xmm1,%xmm5\nmulsd  %xmm0,%xmm2\naddsd  %xmm0,%xmm6\nmulsd  %xmm1,%xmm1\naddsd  (%rsp),%xmm2\nmulsd  %xmm0,%xmm0\naddsd  0x20(%rsp),%xmm1\nmovsd  %xmm5,0x10(%rsp)\naddsd  0x18(%rsp),%xmm0\nmovsd  %xmm6,0x8(%rsp)\nmovsd  %xmm2,(%rsp)\nmovsd  %xmm1,0x20(%rsp)\nmovsd  %xmm0,0x18(%rsp)\nsub    $0x1,%r12\njne    1320 <run_tests+0xa0>\nlea    0x2d74(%rip),%rdi\nxor    %eax,%eax\ncall   3650 <libmin_printf>\nmov    $0x4e200,%esi\nlea    0x2d70(%rip),%rdi\nxor    %eax,%eax\ncall   3650 <libmin_printf>\nxor    %eax,%eax\nmov    %r13,%rsi\nlea    0x2d7b(%rip),%rdi\ncall   3650 <libmin_printf>\ntest   %r13,%r13\njs     1553 <run_tests+0x2d3>\npxor   %xmm0,%xmm0\ncvtsi2sd %r13,%xmm0\nlea    0x2c35(%rip),%rdi\nmov    $0x1,%eax\ndivsd  0x2db0(%rip),%xmm0\ncall   3650 <libmin_printf>\nmov    0x28(%rsp),%rbx\npxor   %xmm1,%xmm1\nmovsd  0x2da2(%rip),%xmm2\nlea    0x430(%rsp),%rdx\ncs nopw 0x0(%rax,%rax,1)\nmov    (%rbx),%eax\npxor   %xmm0,%xmm0\nadd    $0x4,%rbx\ncvtsi2sd %rax,%xmm0\nsubsd  %xmm2,%xmm0\nmulsd  %xmm0,%xmm0\ndivsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm1\ncmp    %rdx,%rbx\njne    1430 <run_tests+0x1b0>\nlea    0x2bfd(%rip),%rdi\nxor    %eax,%eax\nmovsd  %xmm1,0x28(%rsp)\ncall   3650 <libmin_printf>\nmovsd  0x28(%rsp),%xmm1\nmov    $0xff,%esi\nlea    0x2c0e(%rip),%rdi\nmov    $0x1,%eax\nmovapd %xmm1,%xmm0\ncall   3650 <libmin_printf>\nmovsd  0x10(%rsp),%xmm2\nmovsd  0x8(%rsp),%xmm1\nmovsd  0x2d2c(%rip),%xmm3\nmovsd  (%rsp),%xmm0\ndivsd  %xmm3,%xmm2\ndivsd  %xmm3,%xmm1\nmovapd %xmm2,%xmm4\nmulsd  %xmm2,%xmm2\ndivsd  %xmm3,%xmm0\nmulsd  %xmm1,%xmm4\nmulsd  %xmm1,%xmm1\nsubsd  %xmm4,%xmm0\nmovq   %xmm0,%rbx\nmovsd  0x20(%rsp),%xmm0\ndivsd  %xmm3,%xmm0\nsubsd  %xmm2,%xmm0\nmovsd  0x18(%rsp),%xmm2\ndivsd  %xmm3,%xmm2\nsubsd  %xmm1,%xmm2\nmulsd  %xmm2,%xmm0\ncall   3a80 <libmin_sqrt>\nmovq   %rbx,%xmm1\nlea    0x2c7b(%rip),%rdi\nxor    %eax,%eax\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,(%rsp)\ncall   3650 <libmin_printf>\nmovsd  (%rsp),%xmm1\nmov    $0x1,%eax\nlea    0x2ba8(%rip),%rdi\nmovapd %xmm1,%xmm0\ncall   3650 <libmin_printf>\nmov    0x438(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1572 <run_tests+0x2f2>\nadd    $0x448,%rsp\nlea    0x2bb6(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    3650 <libmin_printf>\nmov    %r13,%rax\nand    $0x1,%r13d\npxor   %xmm0,%xmm0\nshr    %rax\nor     %r13,%rax\ncvtsi2sd %rax,%xmm0\naddsd  %xmm0,%xmm0\njmp    13f4 <run_tests+0x174>\ncall   10b0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "ransac/ransac.c", "function_name": "line_distance", "content": "// Compute the perpendicular distance from a point to the line: y = m*x + b.\ndouble line_distance(Point p, double m, double b) {\n    return libmin_fabs(m * p.x - p.y + b) / libmin_sqrt(m * m + 1.0);\n}\n"}, "pseudo": {"path": "ransac/ransac.host.O3.pseudo", "function_name": "line_distance", "address": "0x13b0", "label": "line_distance", "content": "double __fastcall line_distance(double a1, Point p, double m, double b)\n{\n  double v5; // [rsp+0h] [rbp-18h]\n\n  v5 = libmin_fabs(p.x);\n  return v5 / libmin_sqrt(p.x);\n}\n"}, "pseudo_normalize": "", "binary": "ransac/ransac.host.O3", "assembly": "<line_distance>:\nendbr64\nmulsd  %xmm2,%xmm0\nsub    $0x18,%rsp\nmovsd  %xmm2,0x8(%rsp)\nsubsd  %xmm1,%xmm0\naddsd  %xmm3,%xmm0\ncall   17b0 <libmin_fabs>\nmovsd  0x8(%rsp),%xmm2\nmovsd  %xmm0,(%rsp)\nmulsd  %xmm2,%xmm2\naddsd  0x2c6a(%rip),%xmm2\nmovapd %xmm2,%xmm0\ncall   3b10 <libmin_sqrt>\nmovsd  (%rsp),%xmm1\nadd    $0x18,%rsp\ndivsd  %xmm0,%xmm1\nmovapd %xmm1,%xmm0\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "ransac/ransac.c", "function_name": "main", "content": "int main(void) {\n    libmin_srand(42);\n    Point points[NUM_POINTS];\n\n    // Generate inlier points along the line: y = 2*x + 1\n    int inlierCount = NUM_POINTS / 2;\n    for (int i = 0; i < inlierCount; i++) {\n        // Spread x values over a range.\n        double x = ((double) i / inlierCount) * 50.0;\n        // Add a small random noise in the y value.\n        double noise = ((double) libmin_rand() / RAND_MAX - 0.5) * 2.0;  // Noise in range [-1, 1]\n        points[i].x = x;\n        points[i].y = 2 * x + 1 + noise;\n    }\n\n    // Generate outlier points randomly.\n    for (int i = inlierCount; i < NUM_POINTS; i++) {\n        points[i].x = ((double) libmin_rand() / RAND_MAX) * 50.0;\n        points[i].y = ((double) libmin_rand() / RAND_MAX) * 100.0;\n    }\n\n    double best_m = 0, best_b = 0;\n    int best_inlier_count = 0;\n\n    // Run RANSAC to estimate the line parameters.\n    ransac_line_fitting(points, NUM_POINTS, &best_m, &best_b, &best_inlier_count);\n\n    // Display the results.\n    libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n    libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, NUM_POINTS);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "ransac/ransac.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n  Point *v4; // r12\n  double v5; // xmm1_8\n  signed int v6; // eax\n  __m128d v7; // xmm0\n  Point *v8; // r12\n  int best_inlier_count; // [rsp+1Ch] [rbp-67Ch] BYREF\n  double best_m; // [rsp+20h] [rbp-678h] BYREF\n  double best_b; // [rsp+28h] [rbp-670h] BYREF\n  Point points[100]; // [rsp+30h] [rbp-668h] BYREF\n  _QWORD v13[5]; // [rsp+670h] [rbp-28h] BYREF\n\n  v3 = 0;\n  v13[1] = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  v4 = points;\n  do\n  {\n    ++v4;\n    v5 = (double)v3++ / 50.0;\n    v6 = libmin_rand();\n    v7 = 0LL;\n    v7.m128d_f64[0] = (double)v6 / 2147483647.0 - 0.5 + (double)v6 / 2147483647.0 - 0.5 + v5 * 50.0 + v5 * 50.0 + 1.0;\n    v4[-1] = (Point)_mm_unpacklo_pd((__m128d)COERCE_UNSIGNED_INT64(v5 * 50.0), v7);\n  }\n  while ( v3 != 50 );\n  v8 = &points[50];\n  do\n  {\n    ++v8;\n    v8[-1].x = (double)(int)libmin_rand() / 2147483647.0 * 50.0;\n    v8[-1].y = (double)(int)libmin_rand() / 2147483647.0 * 100.0;\n  }\n  while ( v8 != (Point *)v13 );\n  best_inlier_count = 0;\n  best_m = 0.0;\n  best_b = 0.0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  Point *v4;\n  double v5;\n  signed int v6;\n  __m128d v7;\n  Point *v8;\n  int best_inlier_count;\n  double best_m;\n  double best_b;\n  Point points[100];\n  uint64_t v13[5];\n  v3 = 0;\n  v13[1] = __readfsqword(40u);\n  libmin_srand(42u);\n  v4 = points;\n  do {\n    ++v4;\n    v5 = (double)v3++ / 50.0;\n    v6 = libmin_rand();\n    v7 = 0LL;\n    v7.m128d_f64[0] = (double)v6 / 2147483647.0 - 0.5 +\n                      (double)v6 / 2147483647.0 - 0.5 + v5 * 50.0 + v5 * 50.0 +\n                      1.0;\n    v4[-1] =\n        (Point)_mm_unpacklo_pd((__m128d)COERCE_UNSIGNED_INT64(v5 * 50.0), v7);\n  } while (v3 != 50);\n  v8 = &points[50];\n  do {\n    ++v8;\n    v8[-1].x = (double)(int)libmin_rand() / 2147483647.0 * 50.0;\n    v8[-1].y = (double)(int)libmin_rand() / 2147483647.0 * 100.0;\n  } while (v8 != (Point *)v13);\n  best_inlier_count = 0;\n  best_m = 0.0;\n  best_b = 0.0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}", "binary": "ransac/ransac.host.O3", "assembly": "<main>:\nendbr64\npush   %r12\nmov    $0x2a,%edi\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x680,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x678(%rsp)\nxor    %eax,%eax\nlea    0x30(%rsp),%rbp\ncall   38f0 <libmin_srand>\nmov    %rbp,%r12\ncs nopw 0x0(%rax,%rax,1)\npxor   %xmm1,%xmm1\nadd    $0x10,%r12\ncvtsi2sd %ebx,%xmm1\ndivsd  0x2f0c(%rip),%xmm1\nadd    $0x1,%ebx\nmulsd  0x2f01(%rip),%xmm1\nmovsd  %xmm1,0x8(%rsp)\ncall   3950 <libmin_rand>\npxor   %xmm0,%xmm0\nmovsd  0x8(%rsp),%xmm1\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2ee5(%rip),%xmm0\nmovapd %xmm1,%xmm2\nsubsd  0x2ee1(%rip),%xmm0\naddsd  %xmm1,%xmm2\naddsd  0x2eb5(%rip),%xmm2\naddsd  %xmm0,%xmm0\naddsd  %xmm2,%xmm0\nunpcklpd %xmm0,%xmm1\nmovaps %xmm1,-0x10(%r12)\ncmp    $0x32,%ebx\njne    1140 <main+0x40>\nlea    0x350(%rsp),%r12\nlea    0x640(%rbp),%rbx\nnopl   0x0(%rax)\ncall   3950 <libmin_rand>\npxor   %xmm0,%xmm0\nadd    $0x10,%r12\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2e84(%rip),%xmm0\nmulsd  0x2e74(%rip),%xmm0\nmovsd  %xmm0,-0x10(%r12)\ncall   3950 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2e5d(%rip),%xmm0\nmulsd  0x2e65(%rip),%xmm0\nmovsd  %xmm0,-0x8(%r12)\ncmp    %rbx,%r12\njne    11c8 <main+0xc8>\nlea    0x28(%rsp),%rcx\nlea    0x20(%rsp),%rdx\nmov    $0x64,%esi\nmov    %rbp,%rdi\nlea    0x1c(%rsp),%r8\nmovl   $0x0,0x1c(%rsp)\nmovq   $0x0,0x20(%rsp)\nmovq   $0x0,0x28(%rsp)\ncall   1410 <ransac_line_fitting>\nmovsd  0x28(%rsp),%xmm1\nmovsd  0x20(%rsp),%xmm0\nlea    0x2da0(%rip),%rdi\nmov    $0x2,%eax\ncall   36e0 <libmin_printf>\nmov    0x1c(%rsp),%esi\nmov    $0x64,%edx\nxor    %eax,%eax\nlea    0x2dac(%rip),%rdi\ncall   36e0 <libmin_printf>\ncall   3d60 <libmin_success>\nmov    0x678(%rsp),%rax\nsub    %fs:0x28,%rax\njne    12af <main+0x1af>\nadd    $0x680,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "ransac/ransac.c", "function_name": "ransac_line_fitting", "content": "// A simple RANSAC function to fit a line to a set of points.\nvoid ransac_line_fitting(Point points[], int numPoints, double *best_m, double *best_b, int *best_inlier_count) {\n    *best_inlier_count = 0;\n\n    for (int iter = 0; iter < NUM_ITERATIONS; iter++) {\n        // Randomly select two distinct points.\n        int idx1 = libmin_rand() % numPoints;\n        int idx2 = libmin_rand() % numPoints;\n        while (idx2 == idx1) {\n            idx2 = libmin_rand() % numPoints;\n        }\n        Point p1 = points[idx1];\n        Point p2 = points[idx2];\n\n        // Avoid vertical lines for simplicity; skip if x values are too close.\n        if (libmin_fabs(p2.x - p1.x) < 1e-6)\n            continue;\n\n        // Compute candidate line parameters.\n        double m = (p2.y - p1.y) / (p2.x - p1.x);\n        double b = p1.y - m * p1.x;\n\n        // Count inliers: points whose distance to the line is within DIST_THRESHOLD.\n        int inlierCount = 0;\n        for (int i = 0; i < numPoints; i++) {\n            if (line_distance(points[i], m, b) < DIST_THRESHOLD)\n                inlierCount++;\n        }\n        // If this candidate is the best so far, remember its parameters.\n        if (inlierCount > *best_inlier_count) {\n            *best_inlier_count = inlierCount;\n            *best_m = m;\n            *best_b = b;\n        }\n    }\n}\n"}, "pseudo": {"path": "ransac/ransac.host.O3.pseudo", "function_name": "ransac_line_fitting", "address": "0x1410", "label": "ransac_line_fitting", "content": "void __fastcall ransac_line_fitting(\n        Point *points,\n        int numPoints,\n        double *best_m,\n        double *best_b,\n        int *best_inlier_count)\n{\n  int v5; // r13d\n  __int64 v6; // rbp\n  unsigned int v7; // edx\n  Point *v8; // rbp\n  Point *v9; // rdx\n  double x; // xmm2_8\n  double y; // xmm7_8\n  double v12; // rbp\n  double v13; // xmm1_8\n  Point *v14; // r15\n  int v15; // ebp\n  double v16; // [rsp+8h] [rbp-70h]\n  double m; // [rsp+10h] [rbp-68h]\n  double ma; // [rsp+10h] [rbp-68h]\n\n  v5 = 500;\n  *best_inlier_count = 0;\n  do\n  {\n    v6 = (int)(libmin_rand() % numPoints);\n    do\n      v7 = libmin_rand() % numPoints;\n    while ( (_DWORD)v6 == v7 );\n    v8 = &points[v6];\n    v9 = &points[v7];\n    x = v8->x;\n    y = v8->y;\n    v12 = v9->y;\n    m = v9->x - x;\n    if ( libmin_fabs(m) >= 0.000001 )\n    {\n      v13 = m;\n      ma = (v12 - y) / m;\n      if ( numPoints <= 0 )\n      {\n        v15 = 0;\n      }\n      else\n      {\n        v14 = points;\n        v15 = 0;\n        do\n        {\n          v16 = libmin_fabs(v13);\n          v13 = v16 / libmin_sqrt(v13);\n          ++v14;\n          v15 += v13 < 1.0;\n        }\n        while ( v14 != &points[(unsigned int)(numPoints - 1) + 1] );\n      }\n      if ( *best_inlier_count < v15 )\n      {\n        *best_inlier_count = v15;\n        *best_m = ma;\n        *best_b = y - x * ma;\n      }\n    }\n    --v5;\n  }\n  while ( v5 );\n}\n"}, "pseudo_normalize": "void ransac_line_fitting(Point *points, int numPoints, double *best_m,\n                         double *best_b, int *best_inlier_count) {\n  int v5;\n  long long v6;\n  unsigned int v7;\n  Point *v8;\n  Point *v9;\n  double x;\n  double y;\n  double v12;\n  double v13;\n  Point *v14;\n  int v15;\n  double v16;\n  double m;\n  double ma;\n  v5 = 500;\n  *best_inlier_count = 0;\n  do {\n    v6 = (int)(libmin_rand() % numPoints);\n    do v7 = libmin_rand() % numPoints;\n    while ((uint32_t)v6 == v7);\n    v8 = &points[v6];\n    v9 = &points[v7];\n    x = v8->x;\n    y = v8->y;\n    v12 = v9->y;\n    m = v9->x - x;\n    if (libmin_fabs(m) >= 0.000001) {\n      v13 = m;\n      ma = (v12 - y) / m;\n      if (numPoints <= 0) {\n        v15 = 0;\n      } else {\n        v14 = points;\n        v15 = 0;\n        do {\n          v16 = libmin_fabs(v13);\n          v13 = v16 / libmin_sqrt(v13);\n          ++v14;\n          v15 += v13 < 1.0;\n        } while (v14 != &points[(unsigned int)(numPoints - 1) + 1]);\n      }\n      if (*best_inlier_count < v15) {\n        *best_inlier_count = v15;\n        *best_m = ma;\n        *best_b = y - x * ma;\n      }\n    }\n    --v5;\n  } while (v5);\n}", "binary": "ransac/ransac.host.O3", "assembly": "<ransac_line_fitting>:\nendbr64\npush   %r15\nlea    -0x1(%rsi),%eax\npush   %r14\nshl    $0x4,%rax\nmov    %rdi,%r14\npush   %r13\nmov    $0x1f4,%r13d\npush   %r12\nlea    0x10(%rdi,%rax,1),%r12\npush   %rbp\npush   %rbx\nmov    %esi,%ebx\nsub    $0x48,%rsp\nmovl   $0x0,(%r8)\nmov    %rdx,0x30(%rsp)\nmov    %rcx,0x38(%rsp)\nmov    %r8,0x28(%rsp)\nnop\ncall   3950 <libmin_rand>\nxor    %edx,%edx\ndiv    %ebx\nmovslq %edx,%rbp\nnopl   0x0(%rax)\ncall   3950 <libmin_rand>\nxor    %edx,%edx\ndiv    %ebx\ncmp    %edx,%ebp\nje     1460 <ransac_line_fitting+0x50>\nmovslq %edx,%rdx\nshl    $0x4,%rbp\nshl    $0x4,%rdx\nadd    %r14,%rbp\nadd    %r14,%rdx\nmovsd  0x0(%rbp),%xmm2\nmovsd  0x8(%rbp),%xmm7\nmovsd  (%rdx),%xmm1\nmov    0x8(%rdx),%rbp\nmovsd  %xmm7,0x8(%rsp)\nsubsd  %xmm2,%xmm1\nmovsd  %xmm2,0x18(%rsp)\nmovapd %xmm1,%xmm0\nmovsd  %xmm1,0x10(%rsp)\ncall   17b0 <libmin_fabs>\nmovsd  0x2ba1(%rip),%xmm6\ncomisd %xmm0,%xmm6\njbe    14d8 <ransac_line_fitting+0xc8>\nsub    $0x1,%r13d\njne    1450 <ransac_line_fitting+0x40>\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmovsd  0x8(%rsp),%xmm7\nmovq   %rbp,%xmm0\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x18(%rsp),%xmm2\nsubsd  %xmm7,%xmm0\ndivsd  %xmm1,%xmm0\nmulsd  %xmm0,%xmm2\nmovsd  %xmm0,0x10(%rsp)\nsubsd  %xmm2,%xmm7\nmovsd  %xmm7,0x18(%rsp)\ntest   %ebx,%ebx\njle    15bd <ransac_line_fitting+0x1ad>\nmovapd %xmm0,%xmm7\nmov    %r14,%r15\nxor    %ebp,%ebp\nmulsd  %xmm0,%xmm7\nmovsd  %xmm7,0x20(%rsp)\ncs nopw 0x0(%rax,%rax,1)\nmovsd  0x10(%rsp),%xmm0\nmulsd  (%r15),%xmm0\nsubsd  0x8(%r15),%xmm0\naddsd  0x18(%rsp),%xmm0\ncall   17b0 <libmin_fabs>\nmovsd  %xmm0,0x8(%rsp)\nmovsd  0x2af6(%rip),%xmm0\naddsd  0x20(%rsp),%xmm0\ncall   3b10 <libmin_sqrt>\nmovsd  0x8(%rsp),%xmm1\nmovsd  0x2add(%rip),%xmm5\nxor    %edx,%edx\ndivsd  %xmm0,%xmm1\ncomisd %xmm1,%xmm5\nseta   %dl\nadd    $0x10,%r15\nadd    %edx,%ebp\ncmp    %r12,%r15\njne    1530 <ransac_line_fitting+0x120>\nmov    0x28(%rsp),%rax\ncmp    %ebp,(%rax)\njge    14bd <ransac_line_fitting+0xad>\nmovsd  0x10(%rsp),%xmm7\nmovsd  0x18(%rsp),%xmm3\nmov    %ebp,(%rax)\nmov    0x30(%rsp),%rax\nmovsd  %xmm7,(%rax)\nmov    0x38(%rsp),%rax\nmovsd  %xmm3,(%rax)\njmp    14bd <ransac_line_fitting+0xad>\nxor    %ebp,%ebp\njmp    158b <ransac_line_fitting+0x17b>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "main", "content": "int main()\n{\n    char* text;\n    char* pattern;\n    int should_fail;\n    int length;\n    int correctlen;\n    size_t ntests = sizeof(test_vector) / sizeof(*test_vector);\n    size_t nfailed = 0;\n    size_t i;\n\n    for (i = 0; i < ntests; ++i)\n    {\n        pattern = test_vector[i][1];\n        text = test_vector[i][2];\n        should_fail = (test_vector[i][0] == NOK);\n        correctlen = (int)(long int)(test_vector[i][3]);\n\n        int m = re_match(pattern, text, &length);\n\n        if (should_fail)\n        {\n            if (m != (-1))\n            {\n                libmin_printf(\"\\n\");\n                re_print(re_compile(pattern));\n                libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \\n\", (i+1), ntests, pattern, text, length);\n                nfailed += 1;\n            }\n        }\n        else\n        {\n            if (m == (-1))\n            {\n                libmin_printf(\"\\n\");\n                re_print(re_compile(pattern));\n                libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", (i+1), ntests, pattern, text);\n                nfailed += 1;\n            }\n            else if (length != correctlen)\n            {\n                libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \\n\", (i+1), ntests, pattern, length, text, correctlen);\n                nfailed += 1;\n            }\n        }\n    }\n\n    // printf(\"\\n\");\n    libmin_printf(\"%lu/%lu tests succeeded.\\n\", ntests - nfailed, ntests);\n\n    if (nfailed != 0)\n      return nfailed; /* 0 if all tests passed */\n    else\n      libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O3.pseudo", "function_name": "main", "address": "0x2100", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  const char **v3; // rbp\n  char **v4; // rbx\n  const char *v5; // r12\n  const char **v6; // r15\n  re_t v7; // rax\n  regex_t *v8; // r13\n  int result; // eax\n  regex_t *v10; // rax\n  regex_t *v11; // rax\n  char *v12; // [rsp+0h] [rbp-68h]\n  char *text; // [rsp+8h] [rbp-60h]\n  char *correctlen; // [rsp+10h] [rbp-58h]\n  size_t nfailed; // [rsp+18h] [rbp-50h]\n  int length; // [rsp+24h] [rbp-44h] BYREF\n  unsigned __int64 v17; // [rsp+28h] [rbp-40h]\n\n  v3 = 0LL;\n  v4 = test_vector[0];\n  v17 = __readfsqword(0x28u);\n  nfailed = 0LL;\n  do\n  {\n    v5 = v4[1];\n    v3 = (const char **)((char *)v3 + 1);\n    v6 = (const char **)v4[2];\n    v12 = *v4;\n    text = (char *)v6;\n    correctlen = v4[3];\n    v7 = re_compile(v5);\n    length = 0;\n    v8 = v7;\n    if ( !v7 )\n    {\nLABEL_16:\n      if ( v12 )\n      {\n        libmin_printf(\"\\n\", argv);\n        v10 = re_compile(v5);\n        re_print(v10);\n        argv = v3;\n        libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", v3, 68LL, v5, text);\n        ++nfailed;\n      }\n      goto LABEL_11;\n    }\n    if ( v7->type == 2 )\n    {\n      argv = v6;\n      if ( !matchpattern(v7 + 1, (const char *)v6, &length) )\n        goto LABEL_16;\n    }\n    else\n    {\n      while ( 1 )\n      {\n        argv = v6;\n        if ( matchpattern(v8, (const char *)v6, &length) )\n          break;\n        v6 = (const char **)((char *)v6 + 1);\n        if ( !*((_BYTE *)v6 - 1) )\n          goto LABEL_16;\n      }\n      if ( !*(_BYTE *)v6 )\n        goto LABEL_16;\n    }\n    if ( v12 )\n    {\n      if ( length != (_DWORD)correctlen )\n      {\n        argv = v3;\n        libmin_printf(\n          \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \\n\",\n          v3,\n          68LL,\n          v5,\n          length,\n          text,\n          (_DWORD)correctlen);\n        ++nfailed;\n      }\n    }\n    else\n    {\n      libmin_printf(\"\\n\");\n      v11 = re_compile(v5);\n      re_print(v11);\n      argv = v3;\n      libmin_printf(\n        \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \\n\",\n        v3,\n        68LL,\n        v5,\n        text,\n        length);\n      ++nfailed;\n    }\nLABEL_11:\n    v4 += 4;\n  }\n  while ( v3 != (const char **)&dword_44 );\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", 68 - nfailed, 68LL);\n  result = nfailed;\n  if ( !nfailed )\n    libmin_success();\n  return result;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  const char **v3;\n  char **v4;\n  const char *v5;\n  const char **v6;\n  re_t v7;\n  regex_t *v8;\n  int result;\n  regex_t *v10;\n  regex_t *v11;\n  char *v12;\n  char *text;\n  char *correctlen;\n  unsigned int nfailed;\n  int length;\n  unsigned long long v17;\n  v3 = 0LL;\n  v4 = test_vector[0];\n  v17 = __readfsqword(40u);\n  nfailed = 0LL;\n  do {\n    v5 = v4[1];\n    v3 = (const char **)((char *)v3 + 1);\n    v6 = (const char **)v4[2];\n    v12 = *v4;\n    text = (char *)v6;\n    correctlen = v4[3];\n    v7 = re_compile(v5);\n    length = 0;\n    v8 = v7;\n    if (!v7) {\n    LABEL_16:\n      if (v12) {\n        libmin_printf(\"\\n\", argv);\n        v10 = re_compile(v5);\n        re_print(v10);\n        argv = v3;\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", v3,\n            68LL, v5, text);\n        ++nfailed;\n      }\n      goto LABEL_11;\n    }\n    if (v7->type == 2) {\n      argv = v6;\n      if (!matchpattern(v7 + 1, (const char *)v6, &length)) goto LABEL_16;\n    } else {\n      while (1) {\n        argv = v6;\n        if (matchpattern(v8, (const char *)v6, &length)) break;\n        v6 = (const char **)((char *)v6 + 1);\n        if (!*((uint8_t *)v6 - 1)) goto LABEL_16;\n      }\n      if (!*(uint8_t *)v6) goto LABEL_16;\n    }\n    if (v12) {\n      if (length != (uint32_t)correctlen) {\n        argv = v3;\n        libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected \"\n            \"'%i'. \\n\",\n            v3, 68LL, v5, length, text, (uint32_t)correctlen);\n        ++nfailed;\n      }\n    } else {\n      libmin_printf(\"\\n\");\n      v11 = re_compile(v5);\n      re_print(v11);\n      argv = v3;\n      libmin_printf(\n          \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i \"\n          \"chars. \\n\",\n          v3, 68LL, v5, text, length);\n      ++nfailed;\n    }\n  LABEL_11:\n    v4 += 4;\n  } while (v3 != (const char **)&dword_44);\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", 68 - nfailed, 68LL);\n  result = nfailed;\n  if (!nfailed) libmin_success();\n  return result;\n}", "binary": "regex-parser/regex-parser.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nlea    0x6f09(%rip),%rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmovq   $0x0,0x18(%rsp)\nnopl   0x0(%rax)\nmov    (%rbx),%rax\nmov    0x8(%rbx),%r12\nadd    $0x1,%rbp\nmov    0x10(%rbx),%r15\nmov    %rax,(%rsp)\nmov    0x18(%rbx),%rax\nmov    %r12,%rdi\nmov    %r15,0x8(%rsp)\nmov    %rax,0x10(%rsp)\ncall   2ac0 <re_compile>\nmovl   $0x0,0x24(%rsp)\nmov    %rax,%r13\ntest   %rax,%rax\nje     2278 <main+0x178>\ncmpb   $0x2,(%rax)\nlea    0x24(%rsp),%r14\njne    2197 <main+0x97>\njmp    2258 <main+0x158>\nnopl   0x0(%rax)\nadd    $0x1,%r15\ncmpb   $0x0,-0x1(%r15)\nje     2278 <main+0x178>\nmov    %r14,%rdx\nmov    %r15,%rsi\nmov    %r13,%rdi\ncall   26d0 <matchpattern>\ntest   %eax,%eax\nje     2188 <main+0x88>\ncmpb   $0x0,(%r15)\nje     2278 <main+0x178>\ncmpq   $0x0,(%rsp)\nje     22d0 <main+0x1d0>\nmov    0x24(%rsp),%r8d\nmov    0x10(%rsp),%rax\ncmp    %eax,%r8d\nje     21f8 <main+0xf8>\nsub    $0x8,%rsp\nmov    $0x44,%edx\nmov    %r12,%rcx\nmov    %rbp,%rsi\npush   %rax\nmov    0x18(%rsp),%r9\nlea    0x444f(%rip),%rdi\nxor    %eax,%eax\ncall   5170 <libmin_printf>\naddq   $0x1,0x28(%rsp)\npop    %rax\npop    %rdx\nadd    $0x20,%rbx\ncmp    $0x44,%rbp\njne    2138 <main+0x38>\nmov    0x18(%rsp),%rbx\nmov    %rbp,%rsi\nmov    $0x44,%edx\nxor    %eax,%eax\nlea    0x40f4(%rip),%rdi\nsub    %rbx,%rsi\ncall   5170 <libmin_printf>\nmov    %ebx,%eax\ntest   %rbx,%rbx\njne    2232 <main+0x132>\ncall   53b0 <libmin_success>\nxor    %eax,%eax\nmov    0x28(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    231c <main+0x21c>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nmov    0x8(%rsp),%rsi\nlea    0x10(%rax),%rdi\nmov    %r14,%rdx\ncall   26d0 <matchpattern>\ntest   %eax,%eax\njne    21b3 <main+0xb3>\nnopl   0x0(%rax)\ncmpq   $0x0,(%rsp)\nje     21f8 <main+0xf8>\nlea    0x41b0(%rip),%rdi\nxor    %eax,%eax\ncall   5170 <libmin_printf>\nmov    %r12,%rdi\ncall   2ac0 <re_compile>\nmov    %rax,%rdi\ncall   2e30 <re_print>\nmov    0x8(%rsp),%r8\nmov    %r12,%rcx\nmov    %rbp,%rsi\nmov    $0x44,%edx\nlea    0x4340(%rip),%rdi\nxor    %eax,%eax\ncall   5170 <libmin_printf>\naddq   $0x1,0x18(%rsp)\njmp    21f8 <main+0xf8>\nnopw   0x0(%rax,%rax,1)\nlea    0x4163(%rip),%rdi\nxor    %eax,%eax\ncall   5170 <libmin_printf>\nmov    %r12,%rdi\ncall   2ac0 <re_compile>\nmov    %rax,%rdi\ncall   2e30 <re_print>\nmov    0x24(%rsp),%r9d\nmov    %r12,%rcx\nmov    %rbp,%rsi\nmov    0x8(%rsp),%r8\nmov    $0x44,%edx\nlea    0x42a6(%rip),%rdi\nxor    %eax,%eax\ncall   5170 <libmin_printf>\naddq   $0x1,0x18(%rsp)\njmp    21f8 <main+0xf8>\ncall   20b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchcharclass", "content": "static int matchcharclass(char c, const char* str)\n{\n  do\n  {\n    if (matchrange(c, str))\n    {\n      return 1;\n    }\n    else if (str[0] == '\\\\')\n    {\n      /* Escape-char: increment str-ptr and match on next char */\n      str += 1;\n      if (matchmetachar(c, str))\n      {\n        return 1;\n      }\n      else if ((c == str[0]) && !ismetachar(c))\n      {\n        return 1;\n      }\n    }\n    else if (c == str[0])\n    {\n      if (c == '-')\n      {\n        return ((str[-1] == '\\0') || (str[1] == '\\0'));\n      }\n      else\n      {\n        return 1;\n      }\n    }\n  }\n  while (*str++ != '\\0');\n\n  return 0;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O3.pseudo", "function_name": "matchcharclass", "address": "0x2420", "label": "matchcharclass", "content": "int __fastcall matchcharclass(char c, const char *str)\n{\n  __int64 v3; // r11\n  unsigned __int16 *v4; // r10\n  int v5; // eax\n  const char *v6; // r8\n  int result; // eax\n  int v8; // esi\n  char v9; // si\n\n  v3 = 0x8800100088001LL;\n  v4 = &pctype[c];\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      LOBYTE(v5) = *str;\n      if ( c != 45 && (_BYTE)v5 && (_BYTE)v5 != 45 && str[1] == 45 )\n        break;\n      if ( (_BYTE)v5 != 92 )\n      {\n        if ( c == (_BYTE)v5 )\n          goto LABEL_32;\n        goto LABEL_3;\n      }\n      v5 = *((unsigned __int8 *)str + 1);\n      v6 = str + 1;\n      if ( (_BYTE)v5 != 68 )\n      {\n        switch ( (char)v5 )\n        {\n          case 'S':\n            if ( (*(_BYTE *)v4 & 8) != 0 )\n              goto LABEL_24;\n            return 1;\n          case 'W':\n            if ( c == 95 )\n              goto LABEL_18;\n            if ( (*(_BYTE *)v4 & 7) == 0 )\n              return 1;\n            goto LABEL_17;\n          case 'd':\n            v8 = *v4 & 4;\n            goto LABEL_16;\n          case 's':\n            v8 = *v4 & 8;\nLABEL_16:\n            if ( v8 )\n              return 1;\nLABEL_17:\n            if ( c != (_BYTE)v5 )\n              goto LABEL_18;\n            goto LABEL_25;\n          case 'w':\n            if ( c == 95 || (*(_BYTE *)v4 & 7) != 0 )\n              return 1;\n            goto LABEL_18;\n          default:\n            if ( c != (_BYTE)v5 )\n              goto LABEL_38;\n            return 1;\n        }\n      }\n      if ( (*(_BYTE *)v4 & 4) == 0 )\n        return 1;\nLABEL_24:\n      ++str;\n      if ( c == (_BYTE)v5 )\n      {\nLABEL_25:\n        if ( (unsigned __int8)(v5 - 68) > 0x33u )\n          return 1;\n        if ( !_bittest64(&v3, (unsigned int)(v5 - 68)) )\n          return 1;\nLABEL_38:\n        str = v6 + 1;\n        if ( !(_BYTE)v5 )\n          return 0;\n      }\n      else\n      {\nLABEL_3:\n        ++str;\n        if ( !(_BYTE)v5 )\n          return 0;\n      }\n    }\n    v9 = str[2];\n    if ( v9 != 0 && c >= (char)v5 && c <= v9 )\n      return 1;\n    if ( (_BYTE)v5 != 92 )\n      break;\nLABEL_18:\n    str += 2;\n  }\n  if ( c != (_BYTE)v5 )\n    goto LABEL_3;\nLABEL_32:\n  result = 1;\n  if ( c == 45 && *(str - 1) )\n    return str[1] == 0;\n  return result;\n}\n"}, "pseudo_normalize": "int matchcharclass(char c, const char *str) {\n  long long v3;\n  unsigned short *v4;\n  int v5;\n  const char *v6;\n  int result;\n  int v8;\n  char v9;\n  v3 = 2392541597564929LL;\n  v4 = &pctype[c];\n  while (1) {\n    while (1) {\n      LOBYTE(v5) = *str;\n      if (c != 45 && (uint8_t)v5 && (uint8_t)v5 != 45 && str[1] == 45) break;\n      if ((uint8_t)v5 != 92) {\n        if (c == (uint8_t)v5) goto LABEL_32;\n        goto LABEL_3;\n      }\n      v5 = *((unsigned char *)str + 1);\n      v6 = str + 1;\n      if ((uint8_t)v5 != 68) {\n        switch ((char)v5) {\n          case 'S':\n            if ((*(uint8_t *)v4 & 8) != 0) goto LABEL_24;\n            return 1;\n          case 'W':\n            if (c == 95) goto LABEL_18;\n            if ((*(uint8_t *)v4 & 7) == 0) return 1;\n            goto LABEL_17;\n          case 'd':\n            v8 = *v4 & 4;\n            goto LABEL_16;\n          case 's':\n            v8 = *v4 & 8;\n          LABEL_16:\n            if (v8) return 1;\n          LABEL_17:\n            if (c != (uint8_t)v5) goto LABEL_18;\n            goto LABEL_25;\n          case 'w':\n            if (c == 95 || (*(uint8_t *)v4 & 7) != 0) return 1;\n            goto LABEL_18;\n          default:\n            if (c != (uint8_t)v5) goto LABEL_38;\n            return 1;\n        }\n      }\n      if ((*(uint8_t *)v4 & 4) == 0) return 1;\n    LABEL_24:\n      ++str;\n      if (c == (uint8_t)v5) {\n      LABEL_25:\n        if ((unsigned char)(v5 - 68) > 51u) return 1;\n        if (!_bittest64(&v3, (unsigned int)(v5 - 68))) return 1;\n      LABEL_38:\n        str = v6 + 1;\n        if (!(uint8_t)v5) return 0;\n      } else {\n      LABEL_3:\n        ++str;\n        if (!(uint8_t)v5) return 0;\n      }\n    }\n    v9 = str[2];\n    if (v9 != 0 && c >= (char)v5 && c <= v9) return 1;\n    if ((uint8_t)v5 != 92) break;\n  LABEL_18:\n    str += 2;\n  }\n  if (c != (uint8_t)v5) goto LABEL_3;\nLABEL_32:\n  result = 1;\n  if (c == 45 && *(str - 1)) return str[1] == 0;\n  return result;\n}", "binary": "regex-parser/regex-parser.host.O3", "assembly": "<matchcharclass>:\nmov    0x7681(%rip),%rax\nmov    %rsi,%rdx\nmovsbq %dil,%rsi\nmov    %edi,%ecx\nmovabs $0x8800100088001,%r11\nmov    %edi,%r9d\npush   %rbx\nlea    0x3bbf(%rip),%rdi\nlea    (%rax,%rsi,2),%r10\njmp    2464 <matchcharclass+0x44>\nnopl   0x0(%rax,%rax,1)\ncmp    %al,%cl\nje     2560 <matchcharclass+0x140>\nadd    $0x1,%rdx\ntest   %al,%al\nje     25b7 <matchcharclass+0x197>\nmovzbl (%rdx),%eax\ncmp    $0x2d,%cl\nje     2480 <matchcharclass+0x60>\ntest   %al,%al\nje     2480 <matchcharclass+0x60>\ncmp    $0x2d,%al\nje     2480 <matchcharclass+0x60>\ncmpb   $0x2d,0x1(%rdx)\nje     2530 <matchcharclass+0x110>\nxchg   %ax,%ax\ncmp    $0x5c,%al\njne    2450 <matchcharclass+0x30>\nmovzbl 0x1(%rdx),%eax\nlea    0x1(%rdx),%r8\ncmp    $0x44,%al\nje     2588 <matchcharclass+0x168>\nlea    -0x53(%rax),%esi\ncmp    $0x24,%sil\nja     25a0 <matchcharclass+0x180>\nmovzbl %sil,%esi\nmovslq (%rdi,%rsi,4),%rsi\nadd    %rdi,%rsi\nnotrack jmp *%rsi\nnop\ncmp    $0x5f,%cl\nje     24bb <matchcharclass+0x9b>\ntestb  $0x7,(%r10)\nje     24d7 <matchcharclass+0xb7>\nmov    $0x1,%eax\npop    %rbx\nret\nnopw   0x0(%rax,%rax,1)\nmovzwl (%r10),%esi\nand    $0x8,%esi\ntest   %esi,%esi\njne    24bb <matchcharclass+0x9b>\ncmp    %al,%cl\nje     2511 <matchcharclass+0xf1>\nadd    $0x2,%rdx\njmp    2464 <matchcharclass+0x44>\nnopl   (%rax)\nmovzwl (%r10),%esi\nand    $0x4,%esi\njmp    24cf <matchcharclass+0xaf>\nnopl   0x0(%rax)\ncmp    $0x5f,%cl\nje     24d7 <matchcharclass+0xb7>\ntestb  $0x7,(%r10)\njne    24d3 <matchcharclass+0xb3>\njmp    24bb <matchcharclass+0x9b>\nnopl   (%rax)\ntestb  $0x8,(%r10)\nje     24bb <matchcharclass+0x9b>\nmov    %r8,%rdx\ncmp    %al,%cl\njne    2458 <matchcharclass+0x38>\nlea    -0x44(%rax),%edx\ncmp    $0x33,%dl\nja     24bb <matchcharclass+0x9b>\nbt     %rdx,%r11\njb     25a8 <matchcharclass+0x188>\nmov    $0x1,%eax\njmp    24c0 <matchcharclass+0xa0>\nnopw   0x0(%rax,%rax,1)\nmovzbl 0x2(%rdx),%esi\ncmp    %al,%cl\nsetge  %bl\ntest   %sil,%sil\nsetne  %r8b\ntest   %r8b,%bl\nje     254e <matchcharclass+0x12e>\ncmp    %sil,%cl\njle    24bb <matchcharclass+0x9b>\ncmp    $0x5c,%al\nje     24d7 <matchcharclass+0xb7>\ncmp    %al,%cl\njne    2458 <matchcharclass+0x38>\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\ncmp    $0x2d,%r9b\njne    24c0 <matchcharclass+0xa0>\ncmpb   $0x0,-0x1(%rdx)\nje     24c0 <matchcharclass+0xa0>\nxor    %eax,%eax\ncmpb   $0x0,0x1(%rdx)\npop    %rbx\nsete   %al\nret\nnopl   0x0(%rax)\ntestb  $0x4,(%r10)\njne    2506 <matchcharclass+0xe6>\njmp    24bb <matchcharclass+0x9b>\nnopw   0x0(%rax,%rax,1)\ncmp    %al,%cl\nje     24bb <matchcharclass+0x9b>\nmov    %r8,%rdx\nadd    $0x1,%rdx\ntest   %al,%al\njne    2464 <matchcharclass+0x44>\nxor    %eax,%eax\npop    %rbx\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchone", "content": "static int matchone(regex_t p, char c)\n{\n  switch (p.type)\n  {\n    case DOT:            return matchdot(c);\n    case CHAR_CLASS:     return  matchcharclass(c, (const char*)p.u.ccl);\n    case INV_CHAR_CLASS: return !matchcharclass(c, (const char*)p.u.ccl);\n    case DIGIT:          return  matchdigit(c);\n    case NOT_DIGIT:      return !matchdigit(c);\n    case ALPHA:          return  matchalphanum(c);\n    case NOT_ALPHA:      return !matchalphanum(c);\n    case WHITESPACE:     return  matchwhitespace(c);\n    case NOT_WHITESPACE: return !matchwhitespace(c);\n    default:             return  (p.u.ch == c);\n  }\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O3.pseudo", "function_name": "matchone", "address": "0x25c0", "label": "matchone", "content": "int __fastcall matchone(regex_t p, char c)\n{\n  int result; // eax\n\n  switch ( p.type )\n  {\n    case 1u:\n      result = 1;\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 0xAu:\n      result = pctype[c] & 4;\n      break;\n    case 0xBu:\n      result = ((unsigned __int8)(pctype[c] >> 2) ^ 1) & 1;\n      break;\n    case 0xCu:\n      result = 1;\n      if ( c != 95 )\n        result = (pctype[c] & 7) != 0;\n      break;\n    case 0xDu:\n      result = 0;\n      if ( c != 95 )\n        result = (pctype[c] & 7) == 0;\n      break;\n    case 0xEu:\n      result = pctype[c] & 8;\n      break;\n    case 0xFu:\n      result = ((unsigned __int8)(pctype[c] >> 3) ^ 1) & 1;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int matchone(regex_t p, char c) {\n  int result;\n  switch (p.type) {\n    case 1u:\n      result = 1;\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 10u:\n      result = pctype[c] & 4;\n      break;\n    case 11u:\n      result = ((unsigned char)(pctype[c] >> 2) ^ 1) & 1;\n      break;\n    case 12u:\n      result = 1;\n      if (c != 95) result = (pctype[c] & 7) != 0;\n      break;\n    case 13u:\n      result = 0;\n      if (c != 95) result = (pctype[c] & 7) == 0;\n      break;\n    case 14u:\n      result = pctype[c] & 8;\n      break;\n    case 15u:\n      result = ((unsigned char)(pctype[c] >> 3) ^ 1) & 1;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}", "binary": "regex-parser/regex-parser.host.O3", "assembly": "<matchone>:\ncmp    $0xf,%dil\nja     25e0 <matchone+0x20>\nlea    0x3acb(%rip),%rcx\nmovzbl %dil,%edi\nmovslq (%rcx,%rdi,4),%rax\nadd    %rcx,%rax\nnotrack jmp *%rax\nnopl   0x0(%rax,%rax,1)\nmovzbl %sil,%esi\nmovsbl %dl,%edx\nxor    %eax,%eax\ncmp    %edx,%esi\nsete   %al\nret\nnop\nmovsbl %dl,%edi\njmp    2420 <matchcharclass>\nnopl   0x0(%rax,%rax,1)\nmovsbl %dl,%edi\ncall   2420 <matchcharclass>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\nret\nnopl   0x0(%rax)\nmov    0x7489(%rip),%rax\nmovsbq %dl,%rdx\nmovzwl (%rax,%rdx,2),%eax\nand    $0x4,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmov    0x7471(%rip),%rax\nmovsbq %dl,%rdx\nmovzwl (%rax,%rdx,2),%eax\nshr    $0x2,%ax\nxor    $0x1,%eax\nand    $0x1,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\ncmp    $0x5f,%dl\nje     26cd <matchone+0x10d>\nmov    0x7447(%rip),%rax\nmovsbq %dl,%rdx\ntestb  $0x7,(%rax,%rdx,2)\nsetne  %al\nmovzbl %al,%eax\nret\nxor    %eax,%eax\ncmp    $0x5f,%dl\nje     26cd <matchone+0x10d>\nmov    0x742a(%rip),%rax\nmovsbq %dl,%rdx\ntestb  $0x7,(%rax,%rdx,2)\nsete   %al\nmovzbl %al,%eax\nret\nnopl   (%rax)\nmov    0x7411(%rip),%rax\nmovsbq %dl,%rdx\nmovzwl (%rax,%rdx,2),%eax\nand    $0x8,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmov    0x73f9(%rip),%rax\nmovsbq %dl,%rdx\nmovzwl (%rax,%rdx,2),%eax\nshr    $0x3,%ax\nxor    $0x1,%eax\nand    $0x1,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchpattern", "content": "/* Iterative matching */\nstatic int matchpattern(regex_t* pattern, const char* text, int* matchlength)\n{\n  int pre = *matchlength;\n  do\n  {\n    if ((pattern[0].type == UNUSED) || (pattern[1].type == QUESTIONMARK))\n    {\n      return matchquestion(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if (pattern[1].type == STAR)\n    {\n      return matchstar(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if (pattern[1].type == PLUS)\n    {\n      return matchplus(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if ((pattern[0].type == END) && pattern[1].type == UNUSED)\n    {\n      return (text[0] == '\\0');\n    }\n/*  Branching is not working properly\n    else if (pattern[1].type == BRANCH)\n    {\n      return (matchpattern(pattern, text) || matchpattern(&pattern[2], text));\n    }\n*/\n  (*matchlength)++;\n  }\n  while ((text[0] != '\\0') && matchone(*pattern++, *text++));\n\n  *matchlength = pre;\n  return 0;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O3.pseudo", "function_name": "matchpattern", "address": "0x26d0", "label": "matchpattern", "content": "int __fastcall matchpattern(regex_t *pattern, const char *text, int *matchlength)\n{\n  unsigned __int8 type; // bl\n  regex_t *v4; // r12\n  int v7; // ecx\n  unsigned __int8 v8; // bp\n  __int64 v9; // rax\n  int v10; // eax\n  int v11; // r13d\n  int v12; // eax\n  unsigned __int8 *v14; // rax\n  regex_t *v15; // r12\n  char v16; // dl\n  __int64 v17; // rbx\n  regex_t *v18; // rbp\n  const char *v19; // r13\n  unsigned __int8 *ccl; // r12\n  int v21; // eax\n  const char *v22; // rsi\n  char v23; // dl\n  __int64 v24; // rbp\n  regex_t *v25; // r13\n  const char *v26; // rbx\n  unsigned __int8 *v27; // r12\n  const char *v28; // rsi\n  int pre; // [rsp+0h] [rbp-48h]\n  unsigned __int8 *prea; // [rsp+0h] [rbp-48h]\n  int prec; // [rsp+0h] [rbp-48h]\n  int preb; // [rsp+0h] [rbp-48h]\n  int v33; // [rsp+Ch] [rbp-3Ch]\n  int v34; // [rsp+Ch] [rbp-3Ch]\n  regex_t v35; // 0:di.1,8:rsi.8\n  regex_t v36; // 0:di.1,8:rsi.8\n  regex_t v37; // 0:di.1,8:rsi.8\n\n  type = pattern->type;\n  pre = *matchlength;\n  if ( !pattern->type )\n    return 1;\n  v4 = pattern;\n  v7 = *matchlength;\n  while ( 2 )\n  {\n    v8 = type;\n    type = v4[1].type;\n    if ( type != 4 )\n    {\n      if ( type == 5 )\n      {\n        v16 = *text;\n        v17 = *(_QWORD *)&v4->type;\n        v18 = v4 + 2;\n        v19 = text;\n        ccl = v4->u.ccl;\n        if ( *text )\n        {\n          do\n          {\n            v36.u.ccl = ccl;\n            v36.type = v17;\n            prec = v7;\n            v21 = matchone(v36, v16);\n            v7 = prec;\n            if ( !v21 )\n              break;\n            ++v19;\n            ++*matchlength;\n            v16 = *v19;\n          }\n          while ( *v19 );\n          if ( v19 < text )\n          {\nLABEL_39:\n            *matchlength = v7;\n            return 0;\n          }\n        }\n        while ( 1 )\n        {\n          v22 = v19--;\n          preb = v7;\n          if ( matchpattern(v18, v22, matchlength) )\n            break;\n          --*matchlength;\n          v7 = preb;\n          if ( v19 < text )\n            goto LABEL_39;\n        }\n      }\n      else\n      {\n        if ( type != 6 )\n        {\n          if ( v8 == 3 && !type )\n            return *text == 0;\n          *matchlength = ++v7;\n          v9 = *text;\n          if ( (_BYTE)v9 )\n          {\n            ++v4;\n            ++text;\n            switch ( v8 )\n            {\n              case 1u:\n                goto LABEL_12;\n              case 8u:\n                v33 = v7;\n                v10 = matchcharclass(v9, (const char *)v4[-1].u.ccl);\n                v7 = v33;\n                goto LABEL_11;\n              case 9u:\n                v34 = v7;\n                v12 = matchcharclass(v9, (const char *)v4[-1].u.ccl);\n                v7 = v34;\n                v10 = v12 == 0;\n                goto LABEL_11;\n              case 0xAu:\n                v10 = pctype[v9] & 4;\n                goto LABEL_11;\n              case 0xBu:\n                v10 = ((unsigned __int8)(pctype[v9] >> 2) ^ 1) & 1;\n                goto LABEL_11;\n              case 0xCu:\n                if ( (_BYTE)v9 != 95 && (pctype[v9] & 7) == 0 )\n                  break;\n                goto LABEL_12;\n              case 0xDu:\n                if ( (_BYTE)v9 == 95 )\n                  break;\n                v10 = (pctype[v9] & 7) == 0;\n                goto LABEL_11;\n              case 0xEu:\n                v10 = pctype[v9] & 8;\n                goto LABEL_11;\n              case 0xFu:\n                v10 = ((unsigned __int8)(pctype[v9] >> 3) ^ 1) & 1;\n                goto LABEL_11;\n              default:\n                v10 = (unsigned __int8)v4[-1].u.ccl == (char)v9;\nLABEL_11:\n                if ( !v10 )\n                  break;\nLABEL_12:\n                if ( !type )\n                  return 1;\n                continue;\n            }\n          }\n          *matchlength = pre;\n          return 0;\n        }\n        v23 = *text;\n        v24 = *(_QWORD *)&v4->type;\n        v25 = v4 + 2;\n        v26 = text;\n        v27 = v4->u.ccl;\n        if ( !*text )\n          return 0;\n        do\n        {\n          v37.u.ccl = v27;\n          v37.type = v24;\n          if ( !matchone(v37, v23) )\n            break;\n          ++v26;\n          ++*matchlength;\n          v23 = *v26;\n        }\n        while ( *v26 );\n        if ( v26 <= text )\n          return 0;\n        while ( 1 )\n        {\n          v28 = v26--;\n          if ( matchpattern(v25, v28, matchlength) )\n            break;\n          --*matchlength;\n          if ( v26 == text )\n            return 0;\n        }\n      }\n      return 1;\n    }\n    break;\n  }\n  v14 = v4->u.ccl;\n  v15 = v4 + 2;\n  prea = v14;\n  v11 = matchpattern(v15, text, matchlength);\n  if ( v11 )\n    return 1;\n  if ( *text )\n  {\n    v35.u.ccl = prea;\n    v35.type = v8;\n    if ( matchone(v35, *text) )\n    {\n      if ( matchpattern(v15, text + 1, matchlength) )\n      {\n        ++*matchlength;\n        return 1;\n      }\n    }\n  }\n  return v11;\n}\n"}, "pseudo_normalize": "int matchpattern(regex_t *pattern, const char *text, int *matchlength) {\n  unsigned char type;\n  regex_t *v4;\n  int v7;\n  unsigned char v8;\n  long long v9;\n  int v10;\n  int v11;\n  int v12;\n  unsigned char *v14;\n  regex_t *v15;\n  char v16;\n  long long v17;\n  regex_t *v18;\n  const char *v19;\n  unsigned char *ccl;\n  int v21;\n  const char *v22;\n  char v23;\n  long long v24;\n  regex_t *v25;\n  const char *v26;\n  unsigned char *v27;\n  const char *v28;\n  int pre;\n  unsigned char *prea;\n  int prec;\n  int preb;\n  int v33;\n  int v34;\n  regex_t v35;\n  regex_t v36;\n  regex_t v37;\n  type = pattern->type;\n  pre = *matchlength;\n  if (!pattern->type) return 1;\n  v4 = pattern;\n  v7 = *matchlength;\n  while (2) {\n    v8 = type;\n    type = v4[1].type;\n    if (type != 4) {\n      if (type == 5) {\n        v16 = *text;\n        v17 = *(uint64_t *)&v4->type;\n        v18 = v4 + 2;\n        v19 = text;\n        ccl = v4->u.ccl;\n        if (*text) {\n          do {\n            v36.u.ccl = ccl;\n            v36.type = v17;\n            prec = v7;\n            v21 = matchone(v36, v16);\n            v7 = prec;\n            if (!v21) break;\n            ++v19;\n            ++*matchlength;\n            v16 = *v19;\n          } while (*v19);\n          if (v19 < text) {\n          LABEL_39:\n            *matchlength = v7;\n            return 0;\n          }\n        }\n        while (1) {\n          v22 = v19--;\n          preb = v7;\n          if (matchpattern(v18, v22, matchlength)) break;\n          --*matchlength;\n          v7 = preb;\n          if (v19 < text) goto LABEL_39;\n        }\n      } else {\n        if (type != 6) {\n          if (v8 == 3 && !type) return *text == 0;\n          *matchlength = ++v7;\n          v9 = *text;\n          if ((uint8_t)v9) {\n            ++v4;\n            ++text;\n            switch (v8) {\n              case 1u:\n                goto LABEL_12;\n              case 8u:\n                v33 = v7;\n                v10 = matchcharclass(v9, (const char *)v4[-1].u.ccl);\n                v7 = v33;\n                goto LABEL_11;\n              case 9u:\n                v34 = v7;\n                v12 = matchcharclass(v9, (const char *)v4[-1].u.ccl);\n                v7 = v34;\n                v10 = v12 == 0;\n                goto LABEL_11;\n              case 10u:\n                v10 = pctype[v9] & 4;\n                goto LABEL_11;\n              case 11u:\n                v10 = ((unsigned char)(pctype[v9] >> 2) ^ 1) & 1;\n                goto LABEL_11;\n              case 12u:\n                if ((uint8_t)v9 != 95 && (pctype[v9] & 7) == 0) break;\n                goto LABEL_12;\n              case 13u:\n                if ((uint8_t)v9 == 95) break;\n                v10 = (pctype[v9] & 7) == 0;\n                goto LABEL_11;\n              case 14u:\n                v10 = pctype[v9] & 8;\n                goto LABEL_11;\n              case 15u:\n                v10 = ((unsigned char)(pctype[v9] >> 3) ^ 1) & 1;\n                goto LABEL_11;\n              default:\n                v10 = (unsigned char)v4[-1].u.ccl == (char)v9;\n              LABEL_11:\n                if (!v10) break;\n              LABEL_12:\n                if (!type) return 1;\n                continue;\n            }\n          }\n          *matchlength = pre;\n          return 0;\n        }\n        v23 = *text;\n        v24 = *(uint64_t *)&v4->type;\n        v25 = v4 + 2;\n        v26 = text;\n        v27 = v4->u.ccl;\n        if (!*text) return 0;\n        do {\n          v37.u.ccl = v27;\n          v37.type = v24;\n          if (!matchone(v37, v23)) break;\n          ++v26;\n          ++*matchlength;\n          v23 = *v26;\n        } while (*v26);\n        if (v26 <= text) return 0;\n        while (1) {\n          v28 = v26--;\n          if (matchpattern(v25, v28, matchlength)) break;\n          --*matchlength;\n          if (v26 == text) return 0;\n        }\n      }\n      return 1;\n    }\n    break;\n  }\n  v14 = v4->u.ccl;\n  v15 = v4 + 2;\n  prea = v14;\n  v11 = matchpattern(v15, text, matchlength);\n  if (v11) return 1;\n  if (*text) {\n    v35.u.ccl = prea;\n    v35.type = v8;\n    if (matchone(v35, *text)) {\n      if (matchpattern(v15, text + 1, matchlength)) {\n        ++*matchlength;\n        return 1;\n      }\n    }\n  }\n  return v11;\n}", "binary": "regex-parser/regex-parser.host.O3", "assembly": "<matchpattern>:\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    (%rdx),%eax\nmovzbl (%rdi),%ebx\nmov    %eax,(%rsp)\ntest   %bl,%bl\nje     2788 <matchpattern+0xb8>\nmov    %rdi,%r12\nmov    %rsi,%r14\nmov    %rdx,%r15\nmov    %eax,%ecx\nlea    0x39d8(%rip),%r13\nmovzbl %bl,%ebp\nmovzbl 0x10(%r12),%ebx\ncmp    $0x4,%bl\nje     2890 <matchpattern+0x1c0>\ncmp    $0x5,%bl\nje     2900 <matchpattern+0x230>\ncmp    $0x6,%bl\nje     2988 <matchpattern+0x2b8>\ncmp    $0x3,%bpl\njne    2732 <matchpattern+0x62>\ntest   %bl,%bl\nje     2a08 <matchpattern+0x338>\nadd    $0x1,%ecx\nmov    %ecx,(%r15)\nmovsbq (%r14),%rax\ntest   %al,%al\nje     2851 <matchpattern+0x181>\nadd    $0x10,%r12\nadd    $0x1,%r14\nmovsbl %al,%edi\nmov    -0x8(%r12),%r8\ncmp    $0xf,%bpl\nja     2768 <matchpattern+0x98>\nmovslq 0x0(%r13,%rbp,4),%rsi\nadd    %r13,%rsi\nnotrack jmp *%rsi\nnopl   (%rax)\nmovzbl %r8b,%r8d\nxor    %eax,%eax\ncmp    %edi,%r8d\nsete   %al\nnopl   0x0(%rax)\ntest   %eax,%eax\nje     2851 <matchpattern+0x181>\ntest   %bl,%bl\njne    2700 <matchpattern+0x30>\nmov    $0x1,%r13d\njmp    285a <matchpattern+0x18a>\nnopl   0x0(%rax,%rax,1)\nmov    0x7309(%rip),%rsi\nmovzwl (%rsi,%rax,2),%eax\nshr    $0x3,%ax\nxor    $0x1,%eax\nand    $0x1,%eax\njmp    2778 <matchpattern+0xa8>\nnop\nmov    %r8,%rsi\nmov    %ecx,0xc(%rsp)\ncall   2420 <matchcharclass>\nmov    0xc(%rsp),%ecx\njmp    2778 <matchpattern+0xa8>\nnopw   0x0(%rax,%rax,1)\nmov    0x72d9(%rip),%rsi\nmovzwl (%rsi,%rax,2),%eax\nand    $0x4,%eax\njmp    2778 <matchpattern+0xa8>\nnopl   0x0(%rax,%rax,1)\nmov    %r8,%rsi\nmov    %ecx,0xc(%rsp)\ncall   2420 <matchcharclass>\nmov    0xc(%rsp),%ecx\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\njmp    2778 <matchpattern+0xa8>\nnopl   (%rax)\nmov    0x72a1(%rip),%rsi\nmovzwl (%rsi,%rax,2),%eax\nand    $0x8,%eax\njmp    2778 <matchpattern+0xa8>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x5f,%al\nje     2851 <matchpattern+0x181>\nmov    0x7285(%rip),%rsi\ntestb  $0x7,(%rsi,%rax,2)\nsete   %al\nmovzbl %al,%eax\njmp    2778 <matchpattern+0xa8>\nnopw   0x0(%rax,%rax,1)\ncmp    $0x5f,%al\nje     2780 <matchpattern+0xb0>\nmov    0x7261(%rip),%rsi\ntestb  $0x7,(%rsi,%rax,2)\njne    2780 <matchpattern+0xb0>\nmov    (%rsp),%eax\nmov    %eax,(%r15)\nxor    %r13d,%r13d\nadd    $0x18,%rsp\nmov    %r13d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nmov    0x7231(%rip),%rsi\nmovzwl (%rsi,%rax,2),%eax\nshr    $0x2,%ax\nxor    $0x1,%eax\nand    $0x1,%eax\njmp    2778 <matchpattern+0xa8>\nnopw   0x0(%rax,%rax,1)\nmov    0x8(%r12),%rax\nmov    (%r12),%rbx\nadd    $0x20,%r12\nmov    %r15,%rdx\nmov    %r14,%rsi\nmov    %r12,%rdi\nmov    %rax,(%rsp)\ncall   26d0 <matchpattern>\nmov    %eax,%r13d\ntest   %eax,%eax\njne    2788 <matchpattern+0xb8>\nmovzbl (%r14),%eax\ntest   %al,%al\nje     285a <matchpattern+0x18a>\nmov    %bpl,%bl\nmov    (%rsp),%rsi\nmovsbl %al,%edx\nmov    %ebx,%edi\ncall   25c0 <matchone>\ntest   %eax,%eax\nje     285a <matchpattern+0x18a>\nlea    0x1(%r14),%rsi\nmov    %r15,%rdx\nmov    %r12,%rdi\ncall   26d0 <matchpattern>\ntest   %eax,%eax\nje     285a <matchpattern+0x18a>\naddl   $0x1,(%r15)\nmov    $0x1,%r13d\njmp    285a <matchpattern+0x18a>\nnopl   (%rax)\nmovsbl (%r14),%edx\nmov    (%r12),%rbx\nlea    0x20(%r12),%rbp\nmov    %r14,%r13\nmov    0x8(%r12),%r12\ntest   %dl,%dl\njne    2931 <matchpattern+0x261>\njmp    2950 <matchpattern+0x280>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r13\naddl   $0x1,(%r15)\nmovsbl 0x0(%r13),%edx\ntest   %dl,%dl\nje     2945 <matchpattern+0x275>\nmov    %r12,%rsi\nmov    %ebx,%edi\nmov    %ecx,(%rsp)\ncall   25c0 <matchone>\nmov    (%rsp),%ecx\ntest   %eax,%eax\njne    2920 <matchpattern+0x250>\ncmp    %r14,%r13\njb     2979 <matchpattern+0x2a9>\nnopw   0x0(%rax,%rax,1)\nmov    %r13,%rsi\nmov    %r15,%rdx\nmov    %rbp,%rdi\nsub    $0x1,%r13\nmov    %ecx,(%rsp)\ncall   26d0 <matchpattern>\ntest   %eax,%eax\njne    2788 <matchpattern+0xb8>\nsubl   $0x1,(%r15)\ncmp    %r14,%r13\nmov    (%rsp),%ecx\njae    2950 <matchpattern+0x280>\nmov    %ecx,(%r15)\nxor    %r13d,%r13d\njmp    285a <matchpattern+0x18a>\nnopl   0x0(%rax)\nmovsbl (%r14),%edx\nmov    (%r12),%rbp\nlea    0x20(%r12),%r13\nmov    %r14,%rbx\nmov    0x8(%r12),%r12\ntest   %dl,%dl\njne    29bf <matchpattern+0x2ef>\njmp    2857 <matchpattern+0x187>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%rbx\naddl   $0x1,(%r15)\nmovsbl (%rbx),%edx\ntest   %dl,%dl\nje     29cd <matchpattern+0x2fd>\nmov    %r12,%rsi\nmov    %ebp,%edi\ncall   25c0 <matchone>\ntest   %eax,%eax\njne    29b0 <matchpattern+0x2e0>\ncmp    %r14,%rbx\nja     29ed <matchpattern+0x31d>\njmp    2857 <matchpattern+0x187>\nnopw   0x0(%rax,%rax,1)\nsubl   $0x1,(%r15)\ncmp    %r14,%rbx\nje     2857 <matchpattern+0x187>\nmov    %rbx,%rsi\nmov    %r15,%rdx\nmov    %r13,%rdi\nsub    $0x1,%rbx\ncall   26d0 <matchpattern>\ntest   %eax,%eax\nje     29e0 <matchpattern+0x310>\njmp    2788 <matchpattern+0xb8>\nxor    %r13d,%r13d\ncmpb   $0x0,(%r14)\nsete   %r13b\njmp    285a <matchpattern+0x18a>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "re_compile", "content": "re_t re_compile(const char* pattern)\n{\n  /* The sizes of the two static arrays below substantiates the static RAM usage of this module.\n     MAX_REGEXP_OBJECTS is the max number of symbols in the expression.\n     MAX_CHAR_CLASS_LEN determines the size of buffer for chars in all char-classes in the expression. */\n  static regex_t re_compiled[MAX_REGEXP_OBJECTS];\n  static unsigned char ccl_buf[MAX_CHAR_CLASS_LEN];\n  int ccl_bufidx = 1;\n\n  char c;     /* current char in pattern   */\n  int i = 0;  /* index into pattern        */\n  int j = 0;  /* index into re_compiled    */\n\n  while (pattern[i] != '\\0' && (j+1 < MAX_REGEXP_OBJECTS))\n  {\n    c = pattern[i];\n\n    switch (c)\n    {\n      /* Meta-characters: */\n      case '^': {    re_compiled[j].type = BEGIN;           } break;\n      case '$': {    re_compiled[j].type = END;             } break;\n      case '.': {    re_compiled[j].type = DOT;             } break;\n      case '*': {    re_compiled[j].type = STAR;            } break;\n      case '+': {    re_compiled[j].type = PLUS;            } break;\n      case '?': {    re_compiled[j].type = QUESTIONMARK;    } break;\n/*    case '|': {    re_compiled[j].type = BRANCH;          } break; <-- not working properly */\n\n      /* Escaped character-classes (\\s \\w ...): */\n      case '\\\\':\n      {\n        if (pattern[i+1] != '\\0')\n        {\n          /* Skip the escape-char '\\\\' */\n          i += 1;\n          /* ... and check the next */\n          switch (pattern[i])\n          {\n            /* Meta-character: */\n            case 'd': {    re_compiled[j].type = DIGIT;            } break;\n            case 'D': {    re_compiled[j].type = NOT_DIGIT;        } break;\n            case 'w': {    re_compiled[j].type = ALPHA;            } break;\n            case 'W': {    re_compiled[j].type = NOT_ALPHA;        } break;\n            case 's': {    re_compiled[j].type = WHITESPACE;       } break;\n            case 'S': {    re_compiled[j].type = NOT_WHITESPACE;   } break;\n\n            /* Escaped character, e.g. '.' or '$' */\n            default:\n            {\n              re_compiled[j].type = CHAR;\n              re_compiled[j].u.ch = pattern[i];\n            } break;\n          }\n        }\n        /* '\\\\' as last char in pattern -> invalid regular expression. */\n/*\n        else\n        {\n          re_compiled[j].type = CHAR;\n          re_compiled[j].ch = pattern[i];\n        }\n*/\n      } break;\n\n      /* Character class: */\n      case '[':\n      {\n        /* Remember where the char-buffer starts. */\n        int buf_begin = ccl_bufidx;\n\n        /* Look-ahead to determine if negated */\n        if (pattern[i+1] == '^')\n        {\n          re_compiled[j].type = INV_CHAR_CLASS;\n          i += 1; /* Increment i to avoid including '^' in the char-buffer */\n          if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '^' */\n          {\n            return 0;\n          }\n        }\n        else\n        {\n          re_compiled[j].type = CHAR_CLASS;\n        }\n\n        /* Copy characters inside [..] to buffer */\n        while (    (pattern[++i] != ']')\n                && (pattern[i]   != '\\0')) /* Missing ] */\n        {\n          if (pattern[i] == '\\\\')\n          {\n            if (ccl_bufidx >= MAX_CHAR_CLASS_LEN - 1)\n            {\n              //fputs(\"exceeded internal buffer!\\n\", stderr);\n              return 0;\n            }\n            if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '\\\\' */\n            {\n              return 0;\n            }\n            ccl_buf[ccl_bufidx++] = pattern[i++];\n          }\n          else if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)\n          {\n              //fputs(\"exceeded internal buffer!\\n\", stderr);\n              return 0;\n          }\n          ccl_buf[ccl_bufidx++] = pattern[i];\n        }\n        if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)\n        {\n            /* Catches cases such as [00000000000000000000000000000000000000][ */\n            //fputs(\"exceeded internal buffer!\\n\", stderr);\n            return 0;\n        }\n        /* Null-terminate string end */\n        ccl_buf[ccl_bufidx++] = 0;\n        re_compiled[j].u.ccl = &ccl_buf[buf_begin];\n      } break;\n\n      /* Other characters: */\n      default:\n      {\n        re_compiled[j].type = CHAR;\n        re_compiled[j].u.ch = c;\n      } break;\n    }\n    /* no buffer-out-of-bounds access on invalid patterns - see https://github.com/kokke/tiny-regex-c/commit/1a279e04014b70b0695fba559a7c05d55e6ee90b */\n    if (pattern[i] == 0)\n    {\n      return 0;\n    }\n\n    i += 1;\n    j += 1;\n  }\n  /* 'UNUSED' is a sentinel used to indicate end-of-pattern */\n  re_compiled[j].type = UNUSED;\n\n  return (re_t) re_compiled;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O3.pseudo", "function_name": "re_compile", "address": "0x2ac0", "label": "re_compile", "content": "re_t __fastcall re_compile(const char *pattern)\n{\n  char v1; // cl\n  int v2; // r9d\n  int v3; // eax\n  __int64 v4; // rsi\n  regex_t *v5; // r10\n  int v6; // ebp\n  const char *v7; // rcx\n  re_t result; // rax\n  int v9; // r8d\n  int v10; // esi\n  __int64 v11; // r14\n  unsigned __int8 v12; // dl\n  int v13; // ecx\n  const char *v14; // rsi\n  char v15; // dl\n\n  v1 = *pattern;\n  if ( *pattern )\n  {\n    v2 = 0;\n    v3 = 0;\n    v4 = 0LL;\n    v5 = re_compiled_1;\n    v6 = 1;\n    while ( 1 )\n    {\n      switch ( v1 )\n      {\n        case '$':\n          v5->type = 3;\n          v7 = &pattern[v3];\n          goto LABEL_6;\n        case '*':\n          v5->type = 5;\n          v7 = &pattern[v3];\n          goto LABEL_6;\n        case '+':\n          v5->type = 6;\n          v7 = &pattern[v3];\n          goto LABEL_6;\n        case '.':\n          v5->type = 1;\n          v7 = &pattern[v3];\n          goto LABEL_6;\n        case '?':\n          v5->type = 4;\n          v7 = &pattern[v3];\n          goto LABEL_6;\n        case '[':\n          if ( pattern[v4 + 1] == 94 )\n          {\n            v5->type = 9;\n            if ( !pattern[v4 + 2] )\n              return 0LL;\n            ++v3;\n          }\n          else\n          {\n            v5->type = 8;\n          }\n          v9 = v3 + 1;\n          v10 = v6;\n          v11 = v3 + 1;\n          v7 = &pattern[v11];\n          v12 = pattern[v11];\n          if ( v12 && v12 != 93 )\n          {\n            do\n            {\n              if ( v12 == 92 )\n              {\n                if ( v10 > 38 || !pattern[v11 + 1] )\n                  return 0LL;\n                v3 += 2;\n                v13 = v10 + 1;\n                ccl_buf_0[v10] = 92;\n                v12 = pattern[v3];\n              }\n              else\n              {\n                if ( v10 > 39 )\n                  return 0LL;\n                v3 = v9;\n                v13 = v10;\n              }\n              v9 = v3 + 1;\n              v10 = v13 + 1;\n              v11 = v3 + 1;\n              ccl_buf_0[v13] = v12;\n              v7 = &pattern[v11];\n              v12 = pattern[v11];\n            }\n            while ( v12 != 93 && v12 );\n          }\n          if ( v10 > 39 )\n            return 0LL;\n          ccl_buf_0[v10] = 0;\n          v3 = v9;\n          v5->u.ccl = &ccl_buf_0[v6];\n          v6 = v10 + 1;\nLABEL_6:\n          if ( !*v7 )\n            return 0LL;\nLABEL_7:\n          ++v3;\n          ++v2;\n          v4 = v3;\n          v1 = pattern[v3];\n          if ( !v1 )\n            goto LABEL_9;\n          ++v5;\n          if ( v2 == 29 )\n            goto LABEL_9;\n          break;\n        case '\\\\':\n          v14 = &pattern[v4 + 1];\n          v15 = *v14;\n          if ( !*v14 )\n            goto LABEL_5;\n          v7 = &pattern[++v3];\n          if ( v15 == 68 )\n          {\n            v5->type = 11;\n          }\n          else\n          {\n            switch ( v15 )\n            {\n              case 'S':\n                v5->type = 15;\n                break;\n              case 'W':\n                v5->type = 13;\n                break;\n              case 'd':\n                v5->type = 10;\n                break;\n              case 's':\n                v5->type = 14;\n                break;\n              case 'w':\n                v5->type = 12;\n                break;\n              default:\n                v5->type = 7;\n                v5->u.ch = *v14;\n                break;\n            }\n          }\n          goto LABEL_6;\n        case '^':\n          v5->type = 2;\n          if ( !pattern[v3] )\n            return 0LL;\n          goto LABEL_7;\n        default:\n          v5->type = 7;\n          v5->u.ch = v1;\nLABEL_5:\n          v7 = &pattern[v3];\n          goto LABEL_6;\n      }\n    }\n  }\n  v2 = 0;\nLABEL_9:\n  result = re_compiled_1;\n  re_compiled_1[v2].type = 0;\n  return result;\n}\n"}, "pseudo_normalize": "re_t re_compile(const char *pattern) {\n  char v1;\n  int v2;\n  int v3;\n  long long v4;\n  regex_t *v5;\n  int v6;\n  const char *v7;\n  re_t result;\n  int v9;\n  int v10;\n  long long v11;\n  unsigned char v12;\n  int v13;\n  const char *v14;\n  char v15;\n  v1 = *pattern;\n  if (*pattern) {\n    v2 = 0;\n    v3 = 0;\n    v4 = 0LL;\n    v5 = re_compiled_1;\n    v6 = 1;\n    while (1) {\n      switch (v1) {\n        case '$':\n          v5->type = 3;\n          v7 = &pattern[v3];\n          goto LABEL_6;\n        case '*':\n          v5->type = 5;\n          v7 = &pattern[v3];\n          goto LABEL_6;\n        case '+':\n          v5->type = 6;\n          v7 = &pattern[v3];\n          goto LABEL_6;\n        case '.':\n          v5->type = 1;\n          v7 = &pattern[v3];\n          goto LABEL_6;\n        case '?':\n          v5->type = 4;\n          v7 = &pattern[v3];\n          goto LABEL_6;\n        case '[':\n          if (pattern[v4 + 1] == 94) {\n            v5->type = 9;\n            if (!pattern[v4 + 2]) return 0LL;\n            ++v3;\n          } else {\n            v5->type = 8;\n          }\n          v9 = v3 + 1;\n          v10 = v6;\n          v11 = v3 + 1;\n          v7 = &pattern[v11];\n          v12 = pattern[v11];\n          if (v12 && v12 != 93) {\n            do {\n              if (v12 == 92) {\n                if (v10 > 38 || !pattern[v11 + 1]) return 0LL;\n                v3 += 2;\n                v13 = v10 + 1;\n                ccl_buf_0[v10] = 92;\n                v12 = pattern[v3];\n              } else {\n                if (v10 > 39) return 0LL;\n                v3 = v9;\n                v13 = v10;\n              }\n              v9 = v3 + 1;\n              v10 = v13 + 1;\n              v11 = v3 + 1;\n              ccl_buf_0[v13] = v12;\n              v7 = &pattern[v11];\n              v12 = pattern[v11];\n            } while (v12 != 93 && v12);\n          }\n          if (v10 > 39) return 0LL;\n          ccl_buf_0[v10] = 0;\n          v3 = v9;\n          v5->u.ccl = &ccl_buf_0[v6];\n          v6 = v10 + 1;\n        LABEL_6:\n          if (!*v7) return 0LL;\n        LABEL_7:\n          ++v3;\n          ++v2;\n          v4 = v3;\n          v1 = pattern[v3];\n          if (!v1) goto LABEL_9;\n          ++v5;\n          if (v2 == 29) goto LABEL_9;\n          break;\n        case '\\\\':\n          v14 = &pattern[v4 + 1];\n          v15 = *v14;\n          if (!*v14) goto LABEL_5;\n          v7 = &pattern[++v3];\n          if (v15 == 68) {\n            v5->type = 11;\n          } else {\n            switch (v15) {\n              case 'S':\n                v5->type = 15;\n                break;\n              case 'W':\n                v5->type = 13;\n                break;\n              case 'd':\n                v5->type = 10;\n                break;\n              case 's':\n                v5->type = 14;\n                break;\n              case 'w':\n                v5->type = 12;\n                break;\n              default:\n                v5->type = 7;\n                v5->u.ch = *v14;\n                break;\n            }\n          }\n          goto LABEL_6;\n        case '^':\n          v5->type = 2;\n          if (!pattern[v3]) return 0LL;\n          goto LABEL_7;\n        default:\n          v5->type = 7;\n          v5->u.ch = v1;\n        LABEL_5:\n          v7 = &pattern[v3];\n          goto LABEL_6;\n      }\n    }\n  }\n  v2 = 0;\nLABEL_9:\n  result = re_compiled_1;\n  re_compiled_1[v2].type = 0;\n  return result;\n}", "binary": "regex-parser/regex-parser.host.O3", "assembly": "<re_compile>:\nendbr64\nmovzbl (%rdi),%ecx\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ntest   %cl,%cl\nje     2d56 <re_compile+0x296>\nlea    0x7062(%rip),%r12\nxor    %r9d,%r9d\nxor    %eax,%eax\nxor    %esi,%esi\nmov    %r12,%r10\nmov    $0x1,%ebp\nlea    0x3624(%rip),%rbx\nlea    0x7005(%rip),%r11\nlea    0x3702(%rip),%r13\nnopw   0x0(%rax,%rax,1)\nlea    -0x24(%rcx),%edx\ncmp    $0x3a,%dl\nja     2b20 <re_compile+0x60>\nmovzbl %dl,%edx\nmovslq (%rbx,%rdx,4),%rdx\nadd    %rbx,%rdx\nnotrack jmp *%rdx\nnopl   (%rax)\nmovb   $0x7,(%r10)\nmov    %cl,0x8(%r10)\nmovslq %eax,%rcx\nadd    %rdi,%rcx\nxchg   %ax,%ax\ncmpb   $0x0,(%rcx)\nje     2b7f <re_compile+0xbf>\nadd    $0x1,%eax\nadd    $0x1,%r9d\nmovslq %eax,%rsi\nmovzbl (%rdi,%rsi,1),%ecx\ntest   %cl,%cl\nje     2b51 <re_compile+0x91>\nadd    $0x10,%r10\ncmp    $0x1d,%r9d\njne    2b08 <re_compile+0x48>\nmovslq %r9d,%r9\npop    %rbx\nlea    0x6fe4(%rip),%rax\npop    %rbp\nshl    $0x4,%r9\nmovb   $0x0,(%r12,%r9,1)\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   (%rax)\nmovslq %eax,%rcx\nmovb   $0x2,(%r10)\nadd    %rdi,%rcx\ncmpb   $0x0,(%rcx)\njne    2b35 <re_compile+0x75>\npop    %rbx\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopw   0x0(%rax,%rax,1)\nmovslq %eax,%rcx\nmovb   $0x1,(%r10)\nadd    %rdi,%rcx\njmp    2b30 <re_compile+0x70>\nnopl   0x0(%rax)\nmovslq %eax,%rcx\nmovb   $0x6,(%r10)\nadd    %rdi,%rcx\njmp    2b30 <re_compile+0x70>\nnopl   0x0(%rax)\nmovslq %eax,%rcx\nmovb   $0x5,(%r10)\nadd    %rdi,%rcx\njmp    2b30 <re_compile+0x70>\nnop\nmovslq %eax,%rcx\nmovb   $0x3,(%r10)\nadd    %rdi,%rcx\njmp    2b30 <re_compile+0x70>\nnop\ncmpb   $0x5e,0x1(%rdi,%rsi,1)\nje     2cf0 <re_compile+0x230>\nmovb   $0x8,(%r10)\nlea    0x1(%rax),%r8d\nmov    %ebp,%esi\nmovslq %r8d,%r14\nlea    (%rdi,%r14,1),%rcx\nmovzbl (%rcx),%edx\ntest   %dl,%dl\nje     2cc0 <re_compile+0x200>\ncmp    $0x5d,%dl\njne    2c3f <re_compile+0x17f>\njmp    2cc0 <re_compile+0x200>\nnopl   0x0(%rax)\ncmp    $0x27,%esi\njg     2b7f <re_compile+0xbf>\nmov    %r8d,%eax\nmov    %esi,%ecx\nlea    0x1(%rax),%r8d\nlea    0x1(%rcx),%esi\nmovslq %ecx,%rcx\nmovslq %r8d,%r14\nmov    %dl,(%r11,%rcx,1)\nlea    (%rdi,%r14,1),%rcx\nmovzbl (%rcx),%edx\ncmp    $0x5d,%dl\nje     2cc0 <re_compile+0x200>\ntest   %dl,%dl\nje     2cc0 <re_compile+0x200>\ncmp    $0x5c,%dl\njne    2c08 <re_compile+0x148>\ncmp    $0x26,%esi\njg     2b7f <re_compile+0xbf>\ncmpb   $0x0,0x1(%rdi,%r14,1)\nje     2b7f <re_compile+0xbf>\nadd    $0x2,%eax\nlea    0x1(%rsi),%ecx\nmovslq %esi,%rsi\nmovslq %eax,%rdx\nmovb   $0x5c,(%r11,%rsi,1)\nmovzbl (%rdi,%rdx,1),%edx\njmp    2c16 <re_compile+0x156>\nmovslq %eax,%rcx\nmovb   $0x4,(%r10)\nadd    %rdi,%rcx\njmp    2b30 <re_compile+0x70>\nnop\nlea    0x1(%rdi,%rsi,1),%rsi\nmovzbl (%rsi),%edx\ntest   %dl,%dl\nje     2b28 <re_compile+0x68>\nadd    $0x1,%eax\nmovslq %eax,%rcx\nadd    %rdi,%rcx\ncmp    $0x44,%dl\nje     2d4d <re_compile+0x28d>\nsub    $0x53,%edx\ncmp    $0x24,%dl\nja     2d10 <re_compile+0x250>\nmovzbl %dl,%edx\nmovslq 0x0(%r13,%rdx,4),%rdx\nadd    %r13,%rdx\nnotrack jmp *%rdx\nnopl   0x0(%rax,%rax,1)\ncmp    $0x27,%esi\njg     2b7f <re_compile+0xbf>\nmovslq %ebp,%rbp\nmovslq %esi,%rax\nadd    %r11,%rbp\nmovb   $0x0,(%r11,%rax,1)\nmov    %r8d,%eax\nmov    %rbp,0x8(%r10)\nlea    0x1(%rsi),%ebp\njmp    2b30 <re_compile+0x70>\ncs nopw 0x0(%rax,%rax,1)\nmovb   $0x9,(%r10)\ncmpb   $0x0,0x2(%rdi,%rsi,1)\nje     2b7f <re_compile+0xbf>\nadd    $0x1,%eax\njmp    2bdf <re_compile+0x11f>\nnopw   0x0(%rax,%rax,1)\nmovb   $0x7,(%r10)\nmovzbl (%rsi),%edx\nmov    %dl,0x8(%r10)\njmp    2b30 <re_compile+0x70>\nmovb   $0xc,(%r10)\njmp    2b30 <re_compile+0x70>\nmovb   $0xe,(%r10)\njmp    2b30 <re_compile+0x70>\nmovb   $0xa,(%r10)\njmp    2b30 <re_compile+0x70>\nmovb   $0xd,(%r10)\njmp    2b30 <re_compile+0x70>\nmovb   $0xf,(%r10)\njmp    2b30 <re_compile+0x70>\nmovb   $0xb,(%r10)\njmp    2b30 <re_compile+0x70>\nxor    %r9d,%r9d\nlea    0x6de0(%rip),%r12\njmp    2b51 <re_compile+0x91>\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "re_match", "content": "/* Public functions: */\nint re_match(const char* pattern, const char* text, int* matchlength)\n{\n  return re_matchp(re_compile(pattern), text, matchlength);\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O3.pseudo", "function_name": "re_match", "address": "0x2d70", "label": "re_match", "content": "int __fastcall re_match(const char *pattern, const char *text, int *matchlength)\n{\n  const char *v4; // rbp\n  re_t v5; // rax\n  regex_t *v6; // rbx\n  int v7; // r12d\n\n  v4 = text;\n  v5 = re_compile(pattern);\n  *matchlength = 0;\n  if ( !v5 )\n    return -1;\n  v6 = v5;\n  v7 = -1;\n  if ( v5->type == 2 )\n    return -(matchpattern(v5 + 1, text, matchlength) == 0);\n  while ( 1 )\n  {\n    ++v7;\n    if ( matchpattern(v6, v4, matchlength) )\n      break;\n    if ( !*v4++ )\n      return -1;\n  }\n  if ( *v4 )\n    return v7;\n  else\n    return -1;\n}\n"}, "pseudo_normalize": "int re_match(const char *pattern, const char *text, int *matchlength) {\n  const char *v4;\n  re_t v5;\n  regex_t *v6;\n  int v7;\n  v4 = text;\n  v5 = re_compile(pattern);\n  *matchlength = 0;\n  if (!v5) return -1;\n  v6 = v5;\n  v7 = -1;\n  if (v5->type == 2) return -(matchpattern(v5 + 1, text, matchlength) == 0);\n  while (1) {\n    ++v7;\n    if (matchpattern(v6, v4, matchlength)) break;\n    if (!*v4++) return -1;\n  }\n  if (*v4)\n    return v7;\n  else\n    return -1;\n}", "binary": "regex-parser/regex-parser.host.O3", "assembly": "<re_match>:\nendbr64\npush   %r13\nmov    %rdx,%r13\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   2ac0 <re_compile>\nmovl   $0x0,0x0(%r13)\ntest   %rax,%rax\nje     2de8 <re_match+0x78>\ncmpb   $0x2,(%rax)\nmov    %rax,%rbx\nmov    $0xffffffff,%r12d\njne    2dba <re_match+0x4a>\njmp    2e00 <re_match+0x90>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%rbp\ncmpb   $0x0,-0x1(%rbp)\nje     2de8 <re_match+0x78>\nmov    %r13,%rdx\nmov    %rbp,%rsi\nmov    %rbx,%rdi\nadd    $0x1,%r12d\ncall   26d0 <matchpattern>\ntest   %eax,%eax\nje     2db0 <re_match+0x40>\ncmpb   $0x0,0x0(%rbp)\nje     2de8 <re_match+0x78>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nmov    $0xffffffff,%r12d\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nmov    %r13,%rdx\nmov    %rbp,%rsi\nlea    0x10(%rax),%rdi\ncall   26d0 <matchpattern>\ncmp    $0x1,%eax\nsbb    %r12d,%r12d\nadd    $0x8,%rsp\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "re_matchp", "content": "int re_matchp(re_t pattern, const char* text, int* matchlength)\n{\n  *matchlength = 0;\n  if (pattern != 0)\n  {\n    if (pattern[0].type == BEGIN)\n    {\n      return ((matchpattern(&pattern[1], text, matchlength)) ? 0 : -1);\n    }\n    else\n    {\n      int idx = -1;\n\n      do\n      {\n        idx += 1;\n\n        if (matchpattern(pattern, text, matchlength))\n        {\n          if (text[0] == '\\0')\n            return -1;\n\n          return idx;\n        }\n      }\n      while (*text++ != '\\0');\n    }\n  }\n  return -1;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O3.pseudo", "function_name": "re_matchp", "address": "0x2a20", "label": "re_matchp", "content": "int __fastcall re_matchp(re_t pattern, const char *text, int *matchlength)\n{\n  const char *v3; // rbp\n  int v5; // r12d\n\n  *matchlength = 0;\n  if ( !pattern )\n    return -1;\n  v3 = text;\n  v5 = -1;\n  if ( pattern->type == 2 )\n    return -(matchpattern(pattern + 1, text, matchlength) == 0);\n  while ( 1 )\n  {\n    ++v5;\n    if ( matchpattern(pattern, v3, matchlength) )\n      break;\n    if ( !*v3++ )\n      return -1;\n  }\n  if ( *v3 )\n    return v5;\n  else\n    return -1;\n}\n"}, "pseudo_normalize": "int re_matchp(re_t pattern, const char *text, int *matchlength) {\n  const char *v3;\n  int v5;\n  *matchlength = 0;\n  if (!pattern) return -1;\n  v3 = text;\n  v5 = -1;\n  if (pattern->type == 2)\n    return -(matchpattern(pattern + 1, text, matchlength) == 0);\n  while (1) {\n    ++v5;\n    if (matchpattern(pattern, v3, matchlength)) break;\n    if (!*v3++) return -1;\n  }\n  if (*v3)\n    return v5;\n  else\n    return -1;\n}", "binary": "regex-parser/regex-parser.host.O3", "assembly": "<re_matchp>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovl   $0x0,(%rdx)\ntest   %rdi,%rdi\nje     2a88 <re_matchp+0x68>\ncmpb   $0x2,(%rdi)\nmov    %rdi,%rbx\nmov    %rsi,%rbp\nmov    %rdx,%r13\nmov    $0xffffffff,%r12d\njne    2a5a <re_matchp+0x3a>\njmp    2aa0 <re_matchp+0x80>\nnop\nadd    $0x1,%rbp\ncmpb   $0x0,-0x1(%rbp)\nje     2a88 <re_matchp+0x68>\nmov    %r13,%rdx\nmov    %rbp,%rsi\nmov    %rbx,%rdi\nadd    $0x1,%r12d\ncall   26d0 <matchpattern>\ntest   %eax,%eax\nje     2a50 <re_matchp+0x30>\ncmpb   $0x0,0x0(%rbp)\nje     2a88 <re_matchp+0x68>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nmov    $0xffffffff,%r12d\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nlea    0x10(%rdi),%rdi\ncall   26d0 <matchpattern>\ncmp    $0x1,%eax\nsbb    %r12d,%r12d\nadd    $0x8,%rsp\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   (%rax)\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "re_print", "content": "void re_print(regex_t* pattern)\n{\n  const char* types[] = { \"UNUSED\", \"DOT\", \"BEGIN\", \"END\", \"QUESTIONMARK\", \"STAR\", \"PLUS\", \"CHAR\", \"CHAR_CLASS\", \"INV_CHAR_CLASS\", \"DIGIT\", \"NOT_DIGIT\", \"ALPHA\", \"NOT_ALPHA\", \"WHITESPACE\", \"NOT_WHITESPACE\", \"BRANCH\" };\n\n  int i;\n  int j;\n  char c;\n  for (i = 0; i < MAX_REGEXP_OBJECTS; ++i)\n  {\n    if (pattern[i].type == UNUSED)\n    {\n      break;\n    }\n\n    libmin_printf(\"type: %s\", types[pattern[i].type]);\n    if (pattern[i].type == CHAR_CLASS || pattern[i].type == INV_CHAR_CLASS)\n    {\n      libmin_printf(\" [\");\n      for (j = 0; j < MAX_CHAR_CLASS_LEN; ++j)\n      {\n        c = pattern[i].u.ccl[j];\n        if ((c == '\\0') || (c == ']'))\n        {\n          break;\n        }\n        libmin_printf(\"%c\", c);\n      }\n      libmin_printf(\"]\");\n    }\n    else if (pattern[i].type == CHAR)\n    {\n      libmin_printf(\" '%c'\", pattern[i].u.ch);\n    }\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O3.pseudo", "function_name": "re_print", "address": "0x2e30", "label": "re_print", "content": "void __fastcall re_print(regex_t *pattern)\n{\n  regex_t *v1; // r14\n  __int64 type; // rax\n  __int64 v3; // r15\n  unsigned __int8 *ccl; // rax\n  __int64 v5; // rsi\n  const char *types[17]; // [rsp+0h] [rbp-C8h]\n  unsigned __int64 v7; // [rsp+88h] [rbp-40h]\n\n  v1 = pattern;\n  v7 = __readfsqword(0x28u);\n  *(__m128i *)&types[1] = _mm_unpacklo_epi64((__m128i)(unsigned __int64)&unk_6298, (__m128i)(unsigned __int64)\"BEGIN\");\n  *(__m128i *)&types[3] = _mm_unpacklo_epi64(\n                            (__m128i)(unsigned __int64)\"END\",\n                            (__m128i)(unsigned __int64)\"QUESTIONMARK\");\n  *(__m128i *)&types[5] = _mm_unpacklo_epi64((__m128i)(unsigned __int64)\"STAR\", (__m128i)(unsigned __int64)\"PLUS\");\n  *(__m128i *)&types[7] = _mm_unpacklo_epi64((__m128i)(unsigned __int64)\"CHAR\", (__m128i)(unsigned __int64)\"CHAR_CLASS\");\n  *(__m128i *)&types[9] = _mm_unpacklo_epi64(\n                            (__m128i)(unsigned __int64)\"INV_CHAR_CLASS\",\n                            (__m128i)(unsigned __int64)\"DIGIT\");\n  *(__m128i *)&types[11] = _mm_unpacklo_epi64(\n                             (__m128i)(unsigned __int64)\"NOT_DIGIT\",\n                             (__m128i)(unsigned __int64)\"ALPHA\");\n  *(__m128i *)&types[13] = _mm_unpacklo_epi64(\n                             (__m128i)(unsigned __int64)\"NOT_ALPHA\",\n                             (__m128i)(unsigned __int64)\"WHITESPACE\");\n  *(__m128i *)&types[15] = _mm_unpacklo_epi64(\n                             (__m128i)(unsigned __int64)\"NOT_WHITESPACE\",\n                             (__m128i)(unsigned __int64)\"BRANCH\");\n  do\n  {\n    type = v1->type;\n    if ( !(_BYTE)type )\n      break;\n    libmin_printf(\"type: %s\", types[type]);\n    if ( (unsigned __int8)(v1->type - 8) <= 1u )\n    {\n      v3 = 0LL;\n      libmin_printf(\" [\");\n      do\n      {\n        ccl = v1->u.ccl;\n        v5 = (unsigned int)(char)ccl[v3];\n        if ( !ccl[v3] )\n          break;\n        if ( ccl[v3] == 93 )\n          break;\n        ++v3;\n        libmin_printf(\"%c\", v5);\n      }\n      while ( v3 != 40 );\n      libmin_printf(\"]\");\n    }\n    else if ( v1->type == 7 )\n    {\n      libmin_printf(\" '%c'\", v1->u.ch);\n    }\n    ++v1;\n    libmin_printf(\"\\n\");\n  }\n  while ( &pattern[30] != v1 );\n}\n"}, "pseudo_normalize": "void re_print(regex_t *pattern) {\n  regex_t *v1;\n  long long type;\n  long long v3;\n  unsigned char *ccl;\n  long long v5;\n  const char *types[17];\n  unsigned long long v7;\n  v1 = pattern;\n  v7 = __readfsqword(40u);\n  *(__m128i *)&types[1] =\n      _mm_unpacklo_epi64((__m128i)(unsigned long long)&unk_6298,\n                         (__m128i)(unsigned long long)\"BEGIN\");\n  *(__m128i *)&types[3] =\n      _mm_unpacklo_epi64((__m128i)(unsigned long long)\"END\",\n                         (__m128i)(unsigned long long)\"QUESTIONMARK\");\n  *(__m128i *)&types[5] = _mm_unpacklo_epi64(\n      (__m128i)(unsigned long long)\"STAR\", (__m128i)(unsigned long long)\"PLUS\");\n  *(__m128i *)&types[7] =\n      _mm_unpacklo_epi64((__m128i)(unsigned long long)\"CHAR\",\n                         (__m128i)(unsigned long long)\"CHAR_CLASS\");\n  *(__m128i *)&types[9] =\n      _mm_unpacklo_epi64((__m128i)(unsigned long long)\"INV_CHAR_CLASS\",\n                         (__m128i)(unsigned long long)\"DIGIT\");\n  *(__m128i *)&types[11] =\n      _mm_unpacklo_epi64((__m128i)(unsigned long long)\"NOT_DIGIT\",\n                         (__m128i)(unsigned long long)\"ALPHA\");\n  *(__m128i *)&types[13] =\n      _mm_unpacklo_epi64((__m128i)(unsigned long long)\"NOT_ALPHA\",\n                         (__m128i)(unsigned long long)\"WHITESPACE\");\n  *(__m128i *)&types[15] =\n      _mm_unpacklo_epi64((__m128i)(unsigned long long)\"NOT_WHITESPACE\",\n                         (__m128i)(unsigned long long)\"BRANCH\");\n  do {\n    type = v1->type;\n    if (!(uint8_t)type) break;\n    libmin_printf(\"type: %s\", types[type]);\n    if ((unsigned char)(v1->type - 8) <= 1u) {\n      v3 = 0LL;\n      libmin_printf(\" [\");\n      do {\n        ccl = v1->u.ccl;\n        v5 = (unsigned int)(char)ccl[v3];\n        if (!ccl[v3]) break;\n        if (ccl[v3] == 93) break;\n        ++v3;\n        libmin_printf(\"%c\", v5);\n      } while (v3 != 40);\n      libmin_printf(\"]\");\n    } else if (v1->type == 7) {\n      libmin_printf(\" '%c'\", v1->u.ch);\n    }\n    ++v1;\n    libmin_printf(\"\\n\");\n  } while (&pattern[30] != v1);\n}", "binary": "regex-parser/regex-parser.host.O3", "assembly": "<re_print>:\nendbr64\npush   %r15\nlea    0x345b(%rip),%rcx\npush   %r14\nmovq   %rcx,%xmm0\nlea    0x3457(%rip),%rcx\nmov    %rdi,%r14\npush   %r13\nlea    0x34b3(%rip),%r13\npush   %r12\nlea    0x1e0(%rdi),%r12\npush   %rbp\nlea    0x3493(%rip),%rbp\npush   %rbx\nlea    0x3497(%rip),%rbx\nsub    $0x98,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x88(%rsp)\nlea    0x340d(%rip),%rax\nmovq   %rax,%xmm1\nlea    0x340b(%rip),%rax\npunpcklqdq %xmm1,%xmm0\nmovq   %rax,%xmm2\nlea    0x340d(%rip),%rax\nmovups %xmm0,0x8(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm3\nlea    0x33f2(%rip),%rcx\npunpcklqdq %xmm2,%xmm0\nlea    0x33fa(%rip),%rax\nmovups %xmm0,0x18(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm4\nlea    0x33db(%rip),%rcx\npunpcklqdq %xmm3,%xmm0\nlea    0x33e8(%rip),%rax\nmovups %xmm0,0x28(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm5\nlea    0x33bf(%rip),%rcx\npunpcklqdq %xmm4,%xmm0\nlea    0x33d1(%rip),%rax\nmovups %xmm0,0x38(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm6\nlea    0x33ad(%rip),%rcx\npunpcklqdq %xmm5,%xmm0\nlea    0x33ba(%rip),%rax\nmovups %xmm0,0x48(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm7\nlea    0x3396(%rip),%rcx\npunpcklqdq %xmm6,%xmm0\nlea    0x33a4(%rip),%rax\nmovups %xmm0,0x58(%rsp)\nmovq   %rcx,%xmm0\nmovq   %rax,%xmm1\nlea    0x337f(%rip),%rcx\npunpcklqdq %xmm7,%xmm0\nmovups %xmm0,0x68(%rsp)\nmovq   %rcx,%xmm0\npunpcklqdq %xmm1,%xmm0\nmovups %xmm0,0x78(%rsp)\njmp    2f9b <re_print+0x16b>\nnop\nlea    0x34b3(%rip),%rdi\nxor    %eax,%eax\nadd    $0x10,%r14\ncall   5170 <libmin_printf>\ncmp    %r14,%r12\nje     3038 <re_print+0x208>\nmovzbl (%r14),%eax\ntest   %al,%al\nje     3038 <re_print+0x208>\nmov    (%rsp,%rax,8),%rsi\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   5170 <libmin_printf>\nmovzbl (%r14),%eax\nlea    -0x8(%rax),%edx\ncmp    $0x1,%dl\njbe    2fe0 <re_print+0x1b0>\ncmp    $0x7,%al\njne    2f80 <re_print+0x150>\nmovzbl 0x8(%r14),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   5170 <libmin_printf>\njmp    2f80 <re_print+0x150>\ncs nopw 0x0(%rax,%rax,1)\nlea    0x331d(%rip),%rdi\nxor    %eax,%eax\nxor    %r15d,%r15d\ncall   5170 <libmin_printf>\njmp    3012 <re_print+0x1e2>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x5d,%sil\nje     3020 <re_print+0x1f0>\nmov    %rbx,%rdi\nxor    %eax,%eax\nadd    $0x1,%r15\ncall   5170 <libmin_printf>\ncmp    $0x28,%r15\nje     3020 <re_print+0x1f0>\nmov    0x8(%r14),%rax\nmovsbl (%rax,%r15,1),%esi\ntest   %sil,%sil\njne    2ff8 <re_print+0x1c8>\nlea    0x33a2(%rip),%rdi\nxor    %eax,%eax\ncall   5170 <libmin_printf>\njmp    2f80 <re_print+0x150>\nnopl   0x0(%rax,%rax,1)\nmov    0x88(%rsp),%rax\nsub    %fs:0x28,%rax\njne    305d <re_print+0x22d>\nadd    $0x98,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   20b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "rho-factor/rho-factor.c", "function_name": "factor", "content": "// fill the given array with prime factors of n, result will be zero terminated.\npositive_number * factor(positive_number n, positive_number *array) {\n    positive_number a, b; size_t s ;\n    do  if (n < 4)\n            *array++ = n, n = 1;\n        else if (n & 1) {\n            for (b = n >> 1, a = (b + n / b) >> 1; a < b; b = a, a = (b + n / b) >> 1);\n            if (b * b == n) {\n                s = factor(b, array) - array ;\n                libmin_memcpy(array + s, array, s * sizeof(positive_number)) ;\n                array += s + s ;\n                n = 1;\n            } else {\n                if (is_prime(n, 24)) // number of Miller-Rabin iterations.\n                    *array++ = n, n = 1;\n                else {\n                    a = factor_worker(n); // factor_worker can't be called with a prime.\n                    array = factor(a, array);\n                    n /= a;\n                }\n            }\n        } else\n            for (; !(n & 1); *array++ = 2, n >>= 1);\n    while (n > 1);\n    *array = 0 ;\n    return array ;\n}\n"}, "pseudo": {"path": "rho-factor/rho-factor.host.O3.pseudo", "function_name": "factor", "address": "0x35d0", "label": "factor", "content": "positive_number *__fastcall factor(positive_number n, positive_number *array)\n{\n  positive_number v4; // r12\n  positive_number v5; // rdi\n  positive_number v6; // rcx\n  positive_number v7; // rbx\n  positive_number v8; // rbp\n  int v9; // eax\n  int v10; // edx\n  positive_number v11; // r15\n  unsigned __int64 *v12; // r14\n  positive_number v13; // rsi\n  unsigned __int64 v14; // rcx\n  unsigned __int64 v15; // rdx\n  positive_number v16; // rax\n  positive_number v17; // r9\n  unsigned __int64 v18; // r9\n  positive_number v19; // rcx\n  positive_number v20; // rdx\n  unsigned __int64 v21; // rax\n  positive_number v22; // rsi\n  int v23; // r8d\n  positive_number v24; // rdx\n  unsigned __int64 v25; // rax\n  positive_number v26; // rsi\n  positive_number v27; // rbx\n  positive_number *result; // rax\n  unsigned __int64 v29; // rdx\n  unsigned __int64 v30; // rax\n  positive_number v31; // rsi\n  __int64 v32; // rcx\n  positive_number *v33; // rax\n  __int64 v34; // rbx\n  int v35; // [rsp+4h] [rbp-64h]\n  int v36; // [rsp+10h] [rbp-58h]\n  int v37; // [rsp+14h] [rbp-54h]\n  positive_number *arraya; // [rsp+18h] [rbp-50h]\n  unsigned __int64 v39; // [rsp+20h] [rbp-48h] BYREF\n  unsigned __int64 v40; // [rsp+28h] [rbp-40h] BYREF\n\n  v40 = __readfsqword(0x28u);\n  while ( 1 )\n  {\n    if ( n <= 3 )\n      goto LABEL_68;\n    v4 = n & 1;\n    if ( (n & 1) != 0 )\n      break;\n    do\n    {\n      n >>= 1;\n      *array++ = 2LL;\n    }\n    while ( (n & 1) == 0 );\nLABEL_52:\n    if ( n <= 1 )\n    {\n      result = array;\n      goto LABEL_69;\n    }\n  }\n  v5 = n >> 1;\n  v6 = (n / (n >> 1) + (n >> 1)) >> 1;\n  if ( v6 < n >> 1 )\n  {\n    do\n    {\n      v5 = v6;\n      v6 = (v6 + n / v6) >> 1;\n    }\n    while ( v6 < v5 );\n  }\n  if ( n == v5 * v5 )\n  {\n    v33 = factor(v5, array);\n    v34 = (char *)v33 - (char *)array;\n    libmin_memcpy(v33, array, (char *)v33 - (char *)array);\n    result = &array[2 * (v34 >> 3)];\n    goto LABEL_69;\n  }\n  v39 = 0LL;\n  if ( (n & 1) == 0 )\n    goto LABEL_51;\n  if ( n > 0x4741E0 )\n  {\n    v7 = n - 1;\n    v8 = n - 1;\n    if ( (n & 1) != 0 )\n    {\n      v9 = 0;\n      do\n      {\n        v8 >>= 1;\n        v10 = v9++;\n      }\n      while ( (v8 & 1) == 0 );\n      v37 = v10;\n      v36 = v9;\n    }\n    else\n    {\n      v37 = -1;\n      v36 = 0;\n    }\n    arraya = array;\n    v11 = n;\n    v35 = 24;\n    while ( 1 )\n    {\n      v12 = &v39;\n      do\n      {\n        v12 = (unsigned __int64 *)((char *)v12 + 1);\n        *((_BYTE *)v12 - 1) = libmin_rand();\n      }\n      while ( &v40 != v12 );\n      v13 = v11;\n      v14 = v39 % v7 + 1;\n      do\n      {\n        v15 = v14 % v13;\n        v14 = v15;\n        if ( !v15 )\n          break;\n        v13 %= v15;\n      }\n      while ( v13 );\n      v16 = v4;\n      do\n      {\n        v17 = v16;\n        v16 *= 2LL;\n      }\n      while ( v16 <= v8 );\n      v18 = v17 & 0x7FFFFFFFFFFFFFFFLL;\n      if ( !v18 )\n        goto LABEL_66;\n      v19 = v4;\n      do\n      {\n        v20 = v19 % v11;\n        if ( v19 )\n        {\n          v21 = 0LL;\n          do\n          {\n            if ( (v19 & 1) != 0 )\n            {\n              if ( v11 - v21 <= v20 )\n                v21 -= v11;\n              v21 += v20;\n            }\n            v22 = v20 - v11;\n            if ( v11 - v20 > v20 )\n              v22 = v20;\n            v20 += v22;\n            v19 >>= 1;\n          }\n          while ( v19 );\n          v19 = v21 % v11;\n        }\n        if ( (v8 & v18) != 0 )\n        {\n          v29 = v39 % v7 + 1;\n          v30 = 0LL;\n          do\n          {\n            if ( (v29 & 1) != 0 )\n            {\n              if ( v11 - v30 <= v19 )\n                v30 -= v11;\n              v30 += v19;\n            }\n            v31 = v19 - v11;\n            if ( v11 - v19 > v19 )\n              v31 = v19;\n            v19 += v31;\n            v29 >>= 1;\n          }\n          while ( v29 );\n          v19 = v30 % v11;\n        }\n        v18 >>= 1;\n      }\n      while ( v18 );\n      if ( v19 == 1 )\n        goto LABEL_66;\n      if ( v36 )\n      {\n        if ( v19 == v7 )\n          goto LABEL_66;\n        v23 = v37;\n        v24 = v19 % v11;\n        if ( !v19 )\n        {\nLABEL_50:\n          n = v11;\n          array = arraya;\n          goto LABEL_51;\n        }\n        while ( 1 )\n        {\n          v25 = 0LL;\n          do\n          {\n            if ( (v19 & 1) != 0 )\n            {\n              if ( v11 - v25 <= v24 )\n                v25 -= v11;\n              v25 += v24;\n            }\n            v26 = v24 - v11;\n            if ( v11 - v24 > v24 )\n              v26 = v24;\n            v24 += v26;\n            v19 >>= 1;\n          }\n          while ( v19 );\n          v19 = v25 % v11;\n          if ( !v23 )\n            break;\n          if ( v7 == v25 % v11 )\n            goto LABEL_66;\n          --v23;\n          v24 = v19 % v11;\n          if ( !v19 )\n            goto LABEL_50;\n        }\n      }\n      if ( v7 != v19 )\n      {\n        n = v11;\n        array = arraya;\n        goto LABEL_51;\n      }\nLABEL_66:\n      if ( !--v35 )\n      {\n        n = v11;\n        array = arraya;\n        goto LABEL_68;\n      }\n    }\n  }\n  v32 = n - 2 * ((((n * (unsigned __int128)0x8888888888888889LL) >> 64) & 0xFFFFFFFFFFFFFFF0LL) - n / 0x1E);\n  if ( n > 5 )\n  {\n    if ( ((unsigned __int8)n & (unsigned __int8)(545925250 >> v32) & 1) != 0\n      && (n <= 0x30\n       || 0x6DB6DB6DB6DB6DB7LL * n > 0x2492492492492492LL\n       && 0x2E8BA2E8BA2E8BA3LL * n > 0x1745D1745D1745D1LL\n       && 0x4EC4EC4EC4EC4EC5LL * n > 0x13B13B13B13B13B1LL\n       && 0xF0F0F0F0F0F0F0F1LL * n > 0xF0F0F0F0F0F0F0FLL\n       && 0x86BCA1AF286BCA1BLL * n > 0xD79435E50D79435LL\n       && 0xD37A6F4DE9BD37A7LL * n > 0xB21642C8590B216LL\n       && 0x34F72C234F72C235LL * n > 0x8D3DCB08D3DCB08LL\n       && (n <= 0x3C0\n        || n % 0x1F\n        && n % 0x25\n        && n % 0x29\n        && n % 0x2B\n        && n % 0x2F\n        && n % 0x35\n        && n % 0x3B\n        && n % 0x3D\n        && n % 0x43\n        && (n <= 0x13B0\n         || n % 0x47\n         && n % 0x49\n         && n % 0x4F\n         && n % 0x53\n         && n % 0x59\n         && n % 0x61\n         && n % 0x65\n         && n % 0x67\n         && n % 0x6B\n         && (n <= 0x2E68\n          || n % 0x6D\n          && n % 0x71\n          && n % 0x7F\n          && n % 0x83\n          && n % 0x89\n          && n % 0x8B\n          && n % 0x95\n          && n % 0x97\n          && n % 0x9D\n          && (n <= 0x67C8\n           || n % 0xA3\n           && n % 0xA7\n           && n % 0xAD\n           && n % 0xB3\n           && n % 0xB5\n           && n % 0xBF\n           && n % 0xC1\n           && n % 0xC5\n           && n % 0xC7\n           && (n <= 0xADE8\n            || n % 0xD3\n            && n % 0xDF\n            && n % 0xE3\n            && n % 0xE5\n            && n % 0xE9\n            && n % 0xEF\n            && n % 0xF1\n            && n % 0xFB\n            && n % 0x101\n            && (n <= 0x10E30\n             || n % 0x107\n             && n % 0x10D\n             && n % 0x10F\n             && n % 0x115\n             && n % 0x119\n             && n % 0x11B\n             && n % 0x125\n             && n % 0x133\n             && n % 0x137\n             && (n <= 0x17EB0\n              || n % 0x139\n              && n % 0x13D\n              && n % 0x14B\n              && n % 0x151\n              && n % 0x15B\n              && n % 0x15D\n              && n % 0x161\n              && n % 0x167\n              && n % 0x16F\n              && (n <= 0x21F78\n               || n % 0x175\n               && n % 0x17B\n               && n % 0x17F\n               && n % 0x185\n               && n % 0x18D\n               && n % 0x191\n               && n % 0x199\n               && n % 0x1A3\n               && n % 0x1A5\n               && (n <= 0x2D5A0\n                || n % 0x1AF\n                && n % 0x1B1\n                && n % 0x1B7\n                && n % 0x1BB\n                && n % 0x1C1\n                && n % 0x1C9\n                && n % 0x1CD\n                && n % 0x1CF\n                && n % 0x1D3\n                && (n <= 0x38040\n                 || n % 0x1DF\n                 && n % 0x1E7\n                 && n % 0x1EB\n                 && n % 0x1F3\n                 && n % 0x1F7\n                 && n % 0x1FD\n                 && n % 0x209\n                 && n % 0x20B\n                 && n % 0x21D\n                 && (n <= 0x490C8\n                  || n % 0x223\n                  && n % 0x22D\n                  && n % 0x233\n                  && n % 0x239\n                  && n % 0x23B\n                  && n % 0x241\n                  && n % 0x24B\n                  && n % 0x251\n                  && n % 0x257\n                  && (n <= 0x582F0\n                   || n % 0x259\n                   && n % 0x25F\n                   && n % 0x265\n                   && n % 0x269\n                   && n % 0x26B\n                   && n % 0x277\n                   && n % 0x281\n                   && n % 0x283\n                   && n % 0x287\n                   && (n <= 0x681A8\n                    || n % 0x28D\n                    && n % 0x293\n                    && n % 0x295\n                    && n % 0x2A1\n                    && n % 0x2A5\n                    && n % 0x2AB\n                    && n % 0x2B3\n                    && n % 0x2BD\n                    && n % 0x2C5\n                    && (n <= 0x7E360\n                     || n % 0x2CF\n                     && n % 0x2D7\n                     && n % 0x2DD\n                     && n % 0x2E3\n                     && n % 0x2E7\n                     && n % 0x2EF\n                     && n % 0x2F5\n                     && n % 0x2F9\n                     && n % 0x301\n                     && (n <= 0x91E18\n                      || n % 0x305\n                      && n % 0x313\n                      && n % 0x31D\n                      && n % 0x329\n                      && n % 0x32B\n                      && n % 0x335\n                      && n % 0x337\n                      && n % 0x33B\n                      && n % 0x33D\n                      && (n <= 0xABDB0\n                       || n % 0x347\n                       && n % 0x355\n                       && n % 0x359\n                       && n % 0x35B\n                       && n % 0x35F\n                       && n % 0x36D\n                       && n % 0x371\n                       && n % 0x373\n                       && n % 0x377\n                       && (n <= 0xC8D78\n                        || n % 0x38B\n                        && n % 0x38F\n                        && n % 0x397\n                        && n % 0x3A1\n                        && n % 0x3A9\n                        && n % 0x3AD\n                        && n % 0x3B3\n                        && n % 0x3B9\n                        && n % 0x3C7\n                        && (n <= 0xE62F8\n                         || n % 0x3CB\n                         && n % 0x3D1\n                         && n % 0x3D7\n                         && n % 0x3DF\n                         && n % 0x3E5\n                         && n % 0x3F1\n                         && n % 0x3F5\n                         && n % 0x3FB\n                         && n % 0x3FD\n                         && (n <= 0x103830\n                          || n % 0x407\n                          && n % 0x409\n                          && n % 0x40F\n                          && n % 0x419\n                          && n % 0x41B\n                          && n % 0x425\n                          && n % 0x427\n                          && n % 0x42D\n                          && n % 0x43F\n                          && (n <= 0x122988\n                           || n % 0x443\n                           && n % 0x445\n                           && n % 0x449\n                           && n % 0x44F\n                           && n % 0x455\n                           && n % 0x45D\n                           && n % 0x463\n                           && n % 0x469\n                           && n % 0x47F\n                           && (n <= 0x144900\n                            || n % 0x481\n                            && n % 0x48B\n                            && n % 0x493\n                            && n % 0x49D\n                            && n % 0x4A3\n                            && n % 0x4A9\n                            && n % 0x4B1\n                            && n % 0x4BD\n                            && n % 0x4C1\n                            && (n <= 0x16D2B0\n                             || n % 0x4C7\n                             && n % 0x4CD\n                             && n % 0x4CF\n                             && n % 0x4D5\n                             && n % 0x4E1\n                             && n % 0x4EB\n                             && n % 0x4FD\n                             && n % 0x4FF\n                             && n % 0x503\n                             && (n <= 0x195A50\n                              || n % 0x509\n                              && n % 0x50B\n                              && n % 0x511\n                              && n % 0x515\n                              && n % 0x517\n                              && n % 0x51B\n                              && n % 0x527\n                              && n % 0x529\n                              && n % 0x52F\n                              && (n <= 0x1C43A0\n                               || n % 0x551\n                               && n % 0x557\n                               && n % 0x55D\n                               && n % 0x565\n                               && n % 0x577\n                               && n % 0x581\n                               && n % 0x58F\n                               && n % 0x593\n                               && n % 0x595\n                               && (n <= 0x1F5570\n                                || n % 0x599\n                                && n % 0x59F\n                                && n % 0x5A7\n                                && n % 0x5AB\n                                && n % 0x5AD\n                                && n % 0x5B3\n                                && n % 0x5BF\n                                && n % 0x5C9\n                                && n % 0x5CB\n                                && (n <= 0x21BD60\n                                 || n % 0x5CF\n                                 && n % 0x5D1\n                                 && n % 0x5D5\n                                 && n % 0x5DB\n                                 && n % 0x5E7\n                                 && n % 0x5F3\n                                 && n % 0x5FB\n                                 && n % 0x607\n                                 && n % 0x60D\n                                 && (n <= 0x24CD20\n                                  || n % 0x611\n                                  && n % 0x617\n                                  && n % 0x61F\n                                  && n % 0x623\n                                  && n % 0x62B\n                                  && n % 0x62F\n                                  && n % 0x63D\n                                  && n % 0x641\n                                  && n % 0x647\n                                  && (n <= 0x2780D0\n                                   || n % 0x649\n                                   && n % 0x64D\n                                   && n % 0x653\n                                   && n % 0x655\n                                   && n % 0x65B\n                                   && n % 0x665\n                                   && n % 0x679\n                                   && n % 0x67F\n                                   && n % 0x683\n                                   && (n <= 0x2A8118\n                                    || n % 0x685\n                                    && n % 0x69D\n                                    && n % 0x6A1\n                                    && n % 0x6A3\n                                    && n % 0x6AD\n                                    && n % 0x6B9\n                                    && n % 0x6BB\n                                    && n % 0x6C5\n                                    && n % 0x6CD\n                                    && (n <= 0x2E91E8\n                                     || n % 0x6D3\n                                     && n % 0x6D9\n                                     && n % 0x6DF\n                                     && n % 0x6F1\n                                     && n % 0x6F7\n                                     && n % 0x6FB\n                                     && n % 0x6FD\n                                     && n % 0x709\n                                     && n % 0x713\n                                     && (n <= 0x32B5C0\n                                      || n % 0x71F\n                                      && n % 0x727\n                                      && n % 0x737\n                                      && n % 0x745\n                                      && n % 0x74B\n                                      && n % 0x74F\n                                      && n % 0x751\n                                      && n % 0x755\n                                      && n % 0x757\n                                      && (n <= 0x3672C0\n                                       || n % 0x761\n                                       && n % 0x76D\n                                       && n % 0x773\n                                       && n % 0x779\n                                       && n % 0x78B\n                                       && n % 0x78D\n                                       && n % 0x79D\n                                       && n % 0x79F\n                                       && n % 0x7B5\n                                       && (n <= 0x3BC298\n                                        || n % 0x7BB\n                                        && n % 0x7C3\n                                        && n % 0x7C9\n                                        && n % 0x7CD\n                                        && n % 0x7CF\n                                        && n % 0x7D3\n                                        && n % 0x7DB\n                                        && n % 0x7E1\n                                        && n % 0x7EB\n                                        && (n <= 0x3ED168\n                                         || n % 0x7ED\n                                         && n % 0x7F7\n                                         && n % 0x805\n                                         && n % 0x80F\n                                         && n % 0x815\n                                         && n % 0x821\n                                         && n % 0x823\n                                         && n % 0x827\n                                         && n % 0x829\n                                         && (n <= 0x433A28\n                                          || n % 0x833\n                                          && n % 0x83F\n                                          && n % 0x841\n                                          && n % 0x851\n                                          && n % 0x853\n                                          && n % 0x859\n                                          && n % 0x85D\n                                          && n % 0x85F\n                                          && n % 0x869)))))))))))))))))))))))))))))))))))) )\n    {\n      goto LABEL_68;\n    }\nLABEL_51:\n    v27 = factor_worker(n);\n    array = factor(v27, array);\n    n /= v27;\n    goto LABEL_52;\n  }\n  if ( ((unsigned __int8)n & (unsigned __int8)(545925292 >> v32) & 1) == 0 )\n    goto LABEL_51;\nLABEL_68:\n  *array = n;\n  result = array + 1;\nLABEL_69:\n  *result = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "", "binary": "rho-factor/rho-factor.host.O3", "assembly": "<factor>:\nendbr64\npush   %r15\nmov    %rsi,%r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\ncmp    $0x3,%r14\njbe    3917 <factor+0x347>\nmov    %r14,%r12\nand    $0x1,%r12d\nje     3890 <factor+0x2c0>\nmov    %r14,%rdi\nmov    %r14,%rax\nxor    %edx,%edx\nshr    %rdi\ndiv    %rdi\nlea    (%rax,%rdi,1),%rcx\nshr    %rcx\ncmp    %rdi,%rcx\njae    3649 <factor+0x79>\nnopl   0x0(%rax)\nmov    %r14,%rax\nxor    %edx,%edx\nmov    %rcx,%rdi\ndiv    %rcx\nadd    %rcx,%rax\nshr    %rax\nmov    %rax,%rcx\ncmp    %rdi,%rax\njb     3630 <factor+0x60>\nmov    %rdi,%rax\nimul   %rdi,%rax\ncmp    %rax,%r14\nje     5777 <factor+0x21a7>\nmovq   $0x0,0x20(%rsp)\ntest   $0x1,%r14b\nje     3851 <factor+0x281>\ncmp    $0x4741e0,%r14\njbe    3948 <factor+0x378>\nlea    -0x1(%r14),%rbx\nmov    %rbx,%rbp\ntest   $0x1,%r14b\nje     57a6 <factor+0x21d6>\nxor    %eax,%eax\nshr    %rbp\nmov    %eax,%edx\nadd    $0x1,%eax\ntest   $0x1,%bpl\nje     368c <factor+0xbc>\nmov    %edx,0x14(%rsp)\nmov    %eax,0x10(%rsp)\nlea    0x20(%rsp),%rax\nmov    %r15,0x18(%rsp)\nlea    0x28(%rsp),%r13\nmov    %r14,%r15\nmovl   $0x18,0x4(%rsp)\nmov    %rax,0x8(%rsp)\nnopl   0x0(%rax)\nmov    0x8(%rsp),%r14\nnopl   (%rax)\ncall   7f80 <libmin_rand>\nadd    $0x1,%r14\nmov    %al,-0x1(%r14)\ncmp    %r14,%r13\njne    36d0 <factor+0x100>\nmov    0x20(%rsp),%rax\nxor    %edx,%edx\nmov    %r15,%rsi\ndiv    %rbx\nlea    0x1(%rdx),%r8\nmov    %r8,%rcx\njmp    3710 <factor+0x140>\nnopl   0x0(%rax,%rax,1)\nmov    %rsi,%rax\nxor    %edx,%edx\ndiv    %rcx\nmov    %rdx,%rsi\ntest   %rdx,%rdx\nje     3720 <factor+0x150>\nmov    %rcx,%rax\nxor    %edx,%edx\ndiv    %rsi\nmov    %rdx,%rcx\ntest   %rdx,%rdx\njne    3700 <factor+0x130>\nmov    %r12,%rax\nmov    %rax,%r9\nadd    %rax,%rax\ncmp    %rbp,%rax\njbe    3723 <factor+0x153>\nmovabs $0x7fffffffffffffff,%rax\nand    %rax,%r9\nje     3904 <factor+0x334>\nmov    %r12,%rcx\nnopl   0x0(%rax)\nmov    %rcx,%rax\nxor    %edx,%edx\ndiv    %r15\ntest   %rcx,%rcx\nje     379e <factor+0x1ce>\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\ntest   $0x1,%cl\nje     377b <factor+0x1ab>\nmov    %r15,%rdi\nmov    %rax,%rsi\nsub    %rax,%rdi\nsub    %r15,%rsi\ncmp    %rdx,%rdi\ncmovbe %rsi,%rax\nadd    %rdx,%rax\nmov    %r15,%rdi\nmov    %rdx,%rsi\nsub    %rdx,%rdi\nsub    %r15,%rsi\ncmp    %rdx,%rdi\ncmova  %rdx,%rsi\nadd    %rsi,%rdx\nshr    %rcx\njne    3760 <factor+0x190>\nxor    %edx,%edx\ndiv    %r15\nmov    %rdx,%rcx\ntest   %rbp,%r9\njne    38b0 <factor+0x2e0>\nshr    %r9\njne    3748 <factor+0x178>\ncmp    $0x1,%rcx\nje     3904 <factor+0x334>\nmov    0x10(%rsp),%eax\ntest   %eax,%eax\nje     38fb <factor+0x32b>\ncmp    %rbx,%rcx\nje     3904 <factor+0x334>\nmov    %rcx,%rax\nxor    %edx,%edx\nmov    0x14(%rsp),%r8d\ndiv    %r15\ntest   %rcx,%rcx\nje     3849 <factor+0x279>\nnopl   (%rax)\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\ntest   $0x1,%cl\nje     3803 <factor+0x233>\nmov    %r15,%rdi\nmov    %rax,%rsi\nsub    %rax,%rdi\nsub    %r15,%rsi\ncmp    %rdx,%rdi\ncmovbe %rsi,%rax\nadd    %rdx,%rax\nmov    %r15,%rdi\nmov    %rdx,%rsi\nsub    %rdx,%rdi\nsub    %r15,%rsi\ncmp    %rdx,%rdi\ncmova  %rdx,%rsi\nadd    %rsi,%rdx\nshr    %rcx\njne    37e8 <factor+0x218>\nxor    %edx,%edx\ndiv    %r15\nmov    %rdx,%rcx\ntest   %r8d,%r8d\nje     38fb <factor+0x32b>\ncmp    %rdx,%rbx\nje     3904 <factor+0x334>\nmov    %rcx,%rax\nxor    %edx,%edx\nsub    $0x1,%r8d\ndiv    %r15\ntest   %rcx,%rcx\njne    37e0 <factor+0x210>\nmov    %r15,%r14\nmov    0x18(%rsp),%r15\nmov    %r14,%rdi\ncall   34c0 <factor_worker>\nmov    %r15,%rsi\nmov    %rax,%rdi\nmov    %rax,%rbx\ncall   35d0 <factor>\nxor    %edx,%edx\nmov    %rax,%r15\nmov    %r14,%rax\ndiv    %rbx\nmov    %rax,%r14\ncmp    $0x1,%r14\nja     35f8 <factor+0x28>\nmov    %r15,%rax\njmp    391e <factor+0x34e>\nnopw   0x0(%rax,%rax,1)\nshr    %r14\nadd    $0x8,%r15\nmovq   $0x2,-0x8(%r15)\ntest   $0x1,%r14b\nje     3890 <factor+0x2c0>\njmp    3875 <factor+0x2a5>\nnopw   0x0(%rax,%rax,1)\nmov    %r8,%rdx\nxor    %eax,%eax\nnopl   (%rax)\ntest   $0x1,%dl\nje     38d3 <factor+0x303>\nmov    %r15,%rdi\nmov    %rax,%rsi\nsub    %rax,%rdi\nsub    %r15,%rsi\ncmp    %rcx,%rdi\ncmovbe %rsi,%rax\nadd    %rcx,%rax\nmov    %r15,%rdi\nmov    %rcx,%rsi\nsub    %rcx,%rdi\nsub    %r15,%rsi\ncmp    %rcx,%rdi\ncmova  %rcx,%rsi\nadd    %rsi,%rcx\nshr    %rdx\njne    38b8 <factor+0x2e8>\nxor    %edx,%edx\ndiv    %r15\nmov    %rdx,%rcx\njmp    37a7 <factor+0x1d7>\ncmp    %rcx,%rbx\njne    57bb <factor+0x21eb>\nsubl   $0x1,0x4(%rsp)\njne    36c8 <factor+0xf8>\nmov    %r15,%r14\nmov    0x18(%rsp),%r15\nmov    %r14,(%r15)\nlea    0x8(%r15),%rax\nmovq   $0x0,(%rax)\nmov    0x28(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    57c8 <factor+0x21f8>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovabs $0x8888888888888889,%rax\nmul    %r14\nmov    %rdx,%rcx\nmov    %rdx,%rax\nshr    $0x4,%rcx\nand    $0xfffffffffffffff0,%rax\nsub    %rcx,%rax\nmov    %r14,%rcx\nadd    %rax,%rax\nsub    %rax,%rcx\ncmp    $0x5,%r14\njbe    5760 <factor+0x2190>\nmov    $0x208a2882,%eax\nsar    %cl,%eax\nand    %r14,%rax\ntest   $0x1,%al\nje     3851 <factor+0x281>\ncmp    $0x30,%r14\njbe    3917 <factor+0x347>\nmovabs $0x6db6db6db6db6db7,%rax\nmovabs $0x2492492492492492,%rbx\nimul   %r14,%rax\ncmp    %rbx,%rax\njbe    3851 <factor+0x281>\nmovabs $0x2e8ba2e8ba2e8ba3,%rax\nmovabs $0x1745d1745d1745d1,%rdx\nimul   %r14,%rax\ncmp    %rdx,%rax\njbe    3851 <factor+0x281>\nmovabs $0x4ec4ec4ec4ec4ec5,%rax\nmovabs $0x13b13b13b13b13b1,%rdx\nimul   %r14,%rax\ncmp    %rdx,%rax\njbe    3851 <factor+0x281>\nmovabs $0xf0f0f0f0f0f0f0f1,%rax\nmovabs $0xf0f0f0f0f0f0f0f,%rdx\nimul   %r14,%rax\ncmp    %rdx,%rax\njbe    3851 <factor+0x281>\nmovabs $0x86bca1af286bca1b,%rax\nmovabs $0xd79435e50d79435,%rdx\nimul   %r14,%rax\ncmp    %rdx,%rax\njbe    3851 <factor+0x281>\nmovabs $0xd37a6f4de9bd37a7,%rax\nmovabs $0xb21642c8590b216,%rdx\nimul   %r14,%rax\ncmp    %rdx,%rax\njbe    3851 <factor+0x281>\nmovabs $0x34f72c234f72c235,%rax\nmovabs $0x8d3dcb08d3dcb08,%rdx\nimul   %r14,%rax\ncmp    %rdx,%rax\njbe    3851 <factor+0x281>\ncmp    $0x3c0,%r14\njbe    3917 <factor+0x347>\nmov    $0x1f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x25,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x29,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x35,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x43,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x13b0,%r14\njbe    3917 <factor+0x347>\nmov    $0x47,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x49,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x53,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x59,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x61,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x65,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x67,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x2e68,%r14\njbe    3917 <factor+0x347>\nmov    $0x6d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x71,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x7f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x83,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x89,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x8b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x95,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x97,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x9d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x67c8,%r14\njbe    3917 <factor+0x347>\nmov    $0xa3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xa7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xad,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xb3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xb5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xbf,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xc1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xc5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xc7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0xade8,%r14\njbe    3917 <factor+0x347>\nmov    $0xd3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xdf,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xe3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xe5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xe9,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xef,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xf1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0xfb,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x101,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x10e30,%r14\njbe    3917 <factor+0x347>\nmov    $0x107,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x10d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x10f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x115,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x119,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x11b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x125,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x133,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x137,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x17eb0,%r14\njbe    3917 <factor+0x347>\nmov    $0x139,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x13d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x14b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x151,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x15b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x15d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x161,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x167,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x16f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x21f78,%r14\njbe    3917 <factor+0x347>\nmov    $0x175,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x17b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x17f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x185,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x18d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x191,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x199,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1a3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1a5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x2d5a0,%r14\njbe    3917 <factor+0x347>\nmov    $0x1af,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1b1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1b7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1bb,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1c1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1c9,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1cd,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1cf,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1d3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x38040,%r14\njbe    3917 <factor+0x347>\nmov    $0x1df,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1e7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1eb,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1f3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1f7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x1fd,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x209,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x20b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x21d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x490c8,%r14\njbe    3917 <factor+0x347>\nmov    $0x223,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x22d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x233,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x239,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x23b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x241,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x24b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x251,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x257,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x582f0,%r14\njbe    3917 <factor+0x347>\nmov    $0x259,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x25f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x265,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x269,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x26b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x277,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x281,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x283,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x287,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x681a8,%r14\njbe    3917 <factor+0x347>\nmov    $0x28d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x293,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x295,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2a1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2a5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2ab,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2b3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2bd,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2c5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x7e360,%r14\njbe    3917 <factor+0x347>\nmov    $0x2cf,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2d7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2dd,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2e3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2e7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2ef,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2f5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x2f9,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x301,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x91e18,%r14\njbe    3917 <factor+0x347>\nmov    $0x305,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x313,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x31d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x329,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x32b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x335,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x337,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x33b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x33d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0xabdb0,%r14\njbe    3917 <factor+0x347>\nmov    $0x347,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x355,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x359,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x35b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x35f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x36d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x371,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x373,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x377,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0xc8d78,%r14\njbe    3917 <factor+0x347>\nmov    $0x38b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x38f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x397,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3a1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3a9,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3ad,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3b3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3b9,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3c7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0xe62f8,%r14\njbe    3917 <factor+0x347>\nmov    $0x3cb,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3d1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3d7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3df,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3e5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3f1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3f5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3fb,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x3fd,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x103830,%r14\njbe    3917 <factor+0x347>\nmov    $0x407,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x409,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x40f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x419,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x41b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x425,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x427,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x42d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x43f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x122988,%r14\njbe    3917 <factor+0x347>\nmov    $0x443,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x445,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x449,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x44f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x455,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x45d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x463,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x469,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x47f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x144900,%r14\njbe    3917 <factor+0x347>\nmov    $0x481,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x48b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x493,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x49d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4a3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4a9,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4b1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4bd,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4c1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x16d2b0,%r14\njbe    3917 <factor+0x347>\nmov    $0x4c7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4cd,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4cf,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4d5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4e1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4eb,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4fd,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x4ff,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x503,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x195a50,%r14\njbe    3917 <factor+0x347>\nmov    $0x509,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x50b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x511,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x515,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x517,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x51b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x527,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x529,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x52f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x1c43a0,%r14\njbe    3917 <factor+0x347>\nmov    $0x551,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x557,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x55d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x565,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x577,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x581,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x58f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x593,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x595,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x1f5570,%r14\njbe    3917 <factor+0x347>\nmov    $0x599,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x59f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5a7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5ab,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5ad,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5b3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5bf,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5c9,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5cb,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x21bd60,%r14\njbe    3917 <factor+0x347>\nmov    $0x5cf,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5d1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5d5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5db,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5e7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5f3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x5fb,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x607,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x60d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x24cd20,%r14\njbe    3917 <factor+0x347>\nmov    $0x611,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x617,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x61f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x623,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x62b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x62f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x63d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x641,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x647,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x2780d0,%r14\njbe    3917 <factor+0x347>\nmov    $0x649,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x64d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x653,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x655,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x65b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x665,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x679,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x67f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x683,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x2a8118,%r14\njbe    3917 <factor+0x347>\nmov    $0x685,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x69d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6a1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6a3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6ad,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6b9,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6bb,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6c5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6cd,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x2e91e8,%r14\njbe    3917 <factor+0x347>\nmov    $0x6d3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6d9,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6df,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6f1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6f7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6fb,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x6fd,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x709,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x713,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x32b5c0,%r14\njbe    3917 <factor+0x347>\nmov    $0x71f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x727,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x737,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x745,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x74b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x74f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x751,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x755,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x757,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x3672c0,%r14\njbe    3917 <factor+0x347>\nmov    $0x761,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x76d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x773,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x779,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x78b,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x78d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x79d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x79f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x7b5,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x3bc298,%r14\njbe    3917 <factor+0x347>\nmov    $0x7bb,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x7c3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x7c9,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x7cd,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x7cf,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x7d3,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x7db,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x7e1,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x7eb,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x3ed168,%r14\njbe    3917 <factor+0x347>\nmov    $0x7ed,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x7f7,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x805,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x80f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x815,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x821,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x823,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x827,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x829,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\ncmp    $0x433a28,%r14\njbe    3917 <factor+0x347>\nmov    $0x833,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x83f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x841,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x851,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x853,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x859,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x85d,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x85f,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     3851 <factor+0x281>\nmov    $0x869,%ecx\nmov    %r14,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\njne    3917 <factor+0x347>\njmp    3851 <factor+0x281>\ncs nopw 0x0(%rax,%rax,1)\nmov    $0x208a28ac,%eax\nsar    %cl,%eax\nand    %r14,%rax\ntest   $0x1,%al\nje     3851 <factor+0x281>\njmp    3917 <factor+0x347>\nmov    %r15,%rsi\ncall   35d0 <factor>\nmov    %r15,%rsi\nmov    %rax,%rbx\nmov    %rax,%rdi\nsub    %r15,%rbx\nmov    %rbx,%rdx\ncall   5c70 <libmin_memcpy>\nmov    %rbx,%rax\nsar    $0x3,%rax\nshl    $0x4,%rax\nadd    %r15,%rax\njmp    391e <factor+0x34e>\nmovl   $0xffffffff,0x14(%rsp)\nmovl   $0x0,0x10(%rsp)\njmp    36a2 <factor+0xd2>\nmov    %r15,%r14\nmov    0x18(%rsp),%r15\njmp    3851 <factor+0x281>\ncall   10c0 <__stack_chk_fail@plt>\nnopl   (%rax)\n"}
{"source": {"path": "rho-factor/rho-factor.c", "function_name": "factor_worker", "content": "positive_number factor_worker(const positive_number n) {\n    size_t a = -1, b = 2 ;\n    positive_number c, d = 1 + libmin_rand(), e, f;\n    c = d %= n;\n    do {\n        if (++a == b){\n            // handle your timeout here, when (a == 1 << 20) or another power of two.\n            d = c, b <<= 1, a = 0;\n        }\n        c = multiplication_modulo(c, c, n);\n        for (++c, c *= c != n, e = n, f = c > d ? c - d : d - c; (f %= e) && (e %= f););\n    } while ((f |= e) == 1);\n    return f;\n}\n"}, "pseudo": {"path": "rho-factor/rho-factor.host.O3.pseudo", "function_name": "factor_worker", "address": "0x34c0", "label": "factor_worker", "content": "positive_number __fastcall factor_worker(const positive_number n)\n{\n  unsigned int v2; // eax\n  __int64 v3; // r10\n  __int64 v4; // r9\n  positive_number v5; // rsi\n  positive_number v6; // rdi\n  positive_number v7; // rdx\n  unsigned __int64 v8; // rax\n  positive_number v9; // rcx\n  positive_number v10; // rdx\n  positive_number v11; // r8\n  positive_number v12; // rcx\n  positive_number v13; // rdx\n\n  v2 = libmin_rand();\n  v3 = 2LL;\n  v4 = 0LL;\n  v5 = (v2 + 1) % n;\n  v6 = v5;\nLABEL_2:\n  v7 = v5 % n;\n  if ( v5 )\n  {\nLABEL_3:\n    v8 = 0LL;\n    do\n    {\n      if ( (v5 & 1) != 0 )\n      {\n        if ( n - v8 <= v7 )\n          v8 -= n;\n        v8 += v7;\n      }\n      v9 = v7 - n;\n      if ( n - v7 > v7 )\n        v9 = v7;\n      v7 += v9;\n      v5 >>= 1;\n    }\n    while ( v5 );\n    v10 = v8 % n + 1;\n  }\n  else\n  {\nLABEL_20:\n    v10 = 1LL;\n  }\n  v11 = n;\n  v5 = v10 * (n != v10);\n  v12 = v6 - v5;\n  if ( v6 < v5 )\n    v12 = v5 - v6;\n  do\n  {\n    v13 = v12 % v11;\n    v12 = v13;\n    if ( !v13 )\n    {\n      if ( v11 != 1 )\n        return v11;\nLABEL_18:\n      if ( v3 != ++v4 )\n        goto LABEL_2;\n      v3 *= 2LL;\n      v6 = v5;\n      v7 = v5 % n;\n      v4 = 0LL;\n      if ( v5 )\n        goto LABEL_3;\n      goto LABEL_20;\n    }\n    v11 %= v13;\n  }\n  while ( v11 );\n  v11 = v13;\n  if ( v13 == 1 )\n    goto LABEL_18;\n  return v11;\n}\n"}, "pseudo_normalize": "positive_number factor_worker(const positive_number n) {\n  unsigned int v2;\n  long long v3;\n  long long v4;\n  positive_number v5;\n  positive_number v6;\n  positive_number v7;\n  unsigned long long v8;\n  positive_number v9;\n  positive_number v10;\n  positive_number v11;\n  positive_number v12;\n  positive_number v13;\n  v2 = libmin_rand();\n  v3 = 2LL;\n  v4 = 0LL;\n  v5 = (v2 + 1) % n;\n  v6 = v5;\nLABEL_2:\n  v7 = v5 % n;\n  if (v5) {\n  LABEL_3:\n    v8 = 0LL;\n    do {\n      if ((v5 & 1) != 0) {\n        if (n - v8 <= v7) v8 -= n;\n        v8 += v7;\n      }\n      v9 = v7 - n;\n      if (n - v7 > v7) v9 = v7;\n      v7 += v9;\n      v5 >>= 1;\n    } while (v5);\n    v10 = v8 % n + 1;\n  } else {\n  LABEL_20:\n    v10 = 1LL;\n  }\n  v11 = n;\n  v5 = v10 * (n != v10);\n  v12 = v6 - v5;\n  if (v6 < v5) v12 = v5 - v6;\n  do {\n    v13 = v12 % v11;\n    v12 = v13;\n    if (!v13) {\n      if (v11 != 1) return v11;\n    LABEL_18:\n      if (v3 != ++v4) goto LABEL_2;\n      v3 *= 2LL;\n      v6 = v5;\n      v7 = v5 % n;\n      v4 = 0LL;\n      if (v5) goto LABEL_3;\n      goto LABEL_20;\n    }\n    v11 %= v13;\n  } while (v11);\n  v11 = v13;\n  if (v13 == 1) goto LABEL_18;\n  return v11;\n}", "binary": "rho-factor/rho-factor.host.O3", "assembly": "<factor_worker>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   7f80 <libmin_rand>\nxor    %edx,%edx\nmov    $0x2,%r10d\nxor    %r9d,%r9d\nadd    $0x1,%eax\ndiv    %rbx\nmov    %rdx,%rsi\nmov    %rdx,%rdi\nnopl   0x0(%rax)\nmov    %rsi,%rax\nxor    %edx,%edx\ndiv    %rbx\ntest   %rsi,%rsi\nje     35b5 <factor_worker+0xf5>\nxor    %eax,%eax\nnopl   0x0(%rax,%rax,1)\ntest   $0x1,%sil\nje     351c <factor_worker+0x5c>\nmov    %rbx,%r8\nmov    %rax,%rcx\nsub    %rax,%r8\nsub    %rbx,%rcx\ncmp    %rdx,%r8\ncmovbe %rcx,%rax\nadd    %rdx,%rax\nmov    %rbx,%r8\nmov    %rdx,%rcx\nsub    %rdx,%r8\nsub    %rbx,%rcx\ncmp    %rdx,%r8\ncmova  %rdx,%rcx\nadd    %rcx,%rdx\nshr    %rsi\njne    3500 <factor_worker+0x40>\nxor    %edx,%edx\ndiv    %rbx\nadd    $0x1,%rdx\nxor    %esi,%esi\ncmp    %rdx,%rbx\nmov    %rdi,%rcx\nmov    %rbx,%r8\nsetne  %sil\nimul   %rdx,%rsi\nmov    %rsi,%rax\nsub    %rsi,%rcx\nsub    %rdi,%rax\ncmp    %rsi,%rdi\ncmovb  %rax,%rcx\njmp    3578 <factor_worker+0xb8>\nnopl   (%rax)\nmov    %r8,%rax\nxor    %edx,%edx\ndiv    %rcx\nmov    %rdx,%r8\ntest   %rdx,%rdx\nje     35c0 <factor_worker+0x100>\nmov    %rcx,%rax\nxor    %edx,%edx\ndiv    %r8\nmov    %rdx,%rcx\ntest   %rdx,%rdx\njne    3568 <factor_worker+0xa8>\ncmp    $0x1,%r8\njne    35c9 <factor_worker+0x109>\nadd    $0x1,%r9\ncmp    %r9,%r10\njne    34e8 <factor_worker+0x28>\nmov    %rsi,%rax\nxor    %edx,%edx\nadd    %r10,%r10\nmov    %rsi,%rdi\ndiv    %rbx\nxor    %r9d,%r9d\ntest   %rsi,%rsi\njne    34f9 <factor_worker+0x39>\nmov    $0x1,%edx\njmp    3540 <factor_worker+0x80>\nnopl   0x0(%rax)\nmov    %rcx,%r8\ncmp    $0x1,%r8\nje     358e <factor_worker+0xce>\nmov    %r8,%rax\npop    %rbx\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "rho-factor/rho-factor.c", "function_name": "main", "content": "int main(void)\n{\n    // allocate memory for 64 factors.\n    positive_number *factors = libmin_calloc(64, sizeof(positive_number));\n    positive_number n = 0, mask = -1;\n    /* TMA: unsigned sr = (size_t)factors; sr = -sr / 561; libmin_printf(\"srand at %u :\\n\\n\", sr); */ libmin_srand(/* TMA: sr */42);\n    for (int wrapper = 4, count = 0, j; wrapper < 64; ++wrapper)\n    {\n        for (int64_t n_bits = wrapper; n_bits <= 64; ++n_bits)\n        {\n            // generate a random number of ~ n_bits bits.\n            n = 0;\n            for (size_t k = 0; k < sizeof(positive_number); k++)\n            {\n              ((char *) &n)[k] = (libmin_rand() & 0xff);\n            }\n            n &= mask >> ((positive_number)8 * sizeof(positive_number) - n_bits); n += !(n & (positive_number)1);\n            libmin_printf(\"%5d. (%2ld bits) %22lu = \", ++count, n_bits, n);\n            // fill the \"factors\" array with the prime factors.\n            factor(n, factors);\n            // iterate over the factors (zero terminated array).\n            for (j = 0; factors[j + 1]; ++j) {\n                libmin_printf(\"%lu * \", factors[j]);\n                libmin_assert(n % factors[j] == 0);\n                libmin_assert(is_prime(factors[j], 36));\n            }\n            libmin_printf(\"%lu\\n\", factors[j]);\n        }\n    }\n\n    // release memory.\n    libmin_free(factors);\n\n    // proper exit\n    libmin_success();\n}\n"}, "pseudo": {"path": "rho-factor/rho-factor.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  positive_number *p_n; // rbx\n  unsigned __int64 v5; // r15\n  unsigned __int64 v6; // rbx\n  unsigned __int64 v7; // rbp\n  int v8; // r14d\n  int v9; // eax\n  int v10; // r13d\n  unsigned __int64 v11; // r14\n  unsigned __int64 *v12; // r15\n  unsigned __int64 v13; // rdi\n  unsigned __int64 v14; // rcx\n  unsigned __int64 v15; // rdx\n  unsigned __int64 v16; // rax\n  unsigned __int64 v17; // rdi\n  unsigned __int64 v18; // rdi\n  unsigned __int64 v19; // rcx\n  unsigned __int64 v20; // rdx\n  unsigned __int64 v21; // rax\n  unsigned __int64 v22; // rsi\n  int v23; // r8d\n  unsigned __int64 v24; // rdx\n  unsigned __int64 v25; // rax\n  unsigned __int64 v26; // rsi\n  unsigned __int64 v27; // rdx\n  unsigned __int64 v28; // rax\n  unsigned __int64 v29; // rsi\n  __int64 v30; // rcx\n  positive_number *v31; // rax\n  __int64 j; // [rsp+8h] [rbp-A0h]\n  positive_number *factors; // [rsp+18h] [rbp-90h]\n  int v34; // [rsp+20h] [rbp-88h]\n  int v35; // [rsp+24h] [rbp-84h]\n  __int64 wrapper; // [rsp+28h] [rbp-80h]\n  int64_t n_bits; // [rsp+30h] [rbp-78h]\n  positive_number v38; // [rsp+38h] [rbp-70h]\n  int v39; // [rsp+40h] [rbp-68h]\n  int v40; // [rsp+44h] [rbp-64h]\n  positive_number n; // [rsp+58h] [rbp-50h] BYREF\n  unsigned __int64 v42; // [rsp+60h] [rbp-48h] BYREF\n  unsigned __int64 v43; // [rsp+68h] [rbp-40h] BYREF\n\n  v43 = __readfsqword(0x28u);\n  factors = (positive_number *)libmin_calloc(0x40uLL, 8uLL);\n  libmin_srand(0x2Au);\n  v3 = 0;\n  wrapper = 4LL;\nLABEL_2:\n  v39 = v3 + 1;\n  n_bits = wrapper;\n  while ( 1 )\n  {\n    n = 0LL;\n    p_n = &n;\n    do\n    {\n      p_n = (positive_number *)((char *)p_n + 1);\n      *((_BYTE *)p_n - 1) = libmin_rand();\n    }\n    while ( &v42 != p_n );\n    v40 = wrapper;\n    v38 = (((unsigned __int8)n & (unsigned __int8)(0xFFFFFFFFFFFFFFFFLL >> (64 - (unsigned __int8)n_bits)) & 1) == 0)\n        + (n & (0xFFFFFFFFFFFFFFFFLL >> (64 - (unsigned __int8)n_bits)));\n    n = v38;\n    libmin_printf(\"%5d. (%2ld bits) %22lu = \", n_bits + v39 - wrapper, n_bits, v38);\n    factor(v38, factors);\n    if ( factors[1] )\n    {\n      j = 0LL;\n      do\n      {\n        libmin_printf(\"%lu * \", factors[j]);\n        v5 = factors[j];\n        if ( v38 % v5 )\n          libmin_fail(1);\n        v42 = 0LL;\n        if ( (v5 != 1) == (v5 & 1) )\n        {\n          if ( v5 > 0x4741E0 )\n          {\n            v6 = v5 - 1;\n            v7 = v5 - 1;\n            if ( (v5 & 1) != 0 )\n            {\n              v8 = 0;\n              do\n              {\n                v7 >>= 1;\n                v9 = v8++;\n              }\n              while ( (v7 & 1) == 0 );\n              v34 = v9;\n            }\n            else\n            {\n              v34 = -1;\n              v8 = 0;\n            }\n            v35 = v8;\n            v10 = 36;\n            v11 = v5;\n            while ( 1 )\n            {\n              v12 = &v42;\n              do\n              {\n                v12 = (unsigned __int64 *)((char *)v12 + 1);\n                *((_BYTE *)v12 - 1) = libmin_rand();\n              }\n              while ( &v43 != v12 );\n              v13 = v11;\n              v14 = v42 % v6 + 1;\n              do\n              {\n                v15 = v14 % v13;\n                v14 = v15;\n                if ( !v15 )\n                  break;\n                v13 %= v15;\n              }\n              while ( v13 );\n              v16 = 1LL;\n              do\n              {\n                v17 = v16;\n                v16 *= 2LL;\n              }\n              while ( v16 <= v7 );\n              v18 = v17 & 0x7FFFFFFFFFFFFFFFLL;\n              if ( v18 )\n              {\n                v19 = 1LL;\n                do\n                {\n                  v20 = v19 % v11;\n                  if ( v19 )\n                  {\n                    v21 = 0LL;\n                    do\n                    {\n                      if ( (v19 & 1) != 0 )\n                      {\n                        if ( v11 - v21 <= v20 )\n                          v21 -= v11;\n                        v21 += v20;\n                      }\n                      v22 = v20 - v11;\n                      if ( v11 - v20 > v20 )\n                        v22 = v20;\n                      v20 += v22;\n                      v19 >>= 1;\n                    }\n                    while ( v19 );\n                    v19 = v21 % v11;\n                  }\n                  if ( (v18 & v7) != 0 )\n                  {\n                    v27 = v42 % v6 + 1;\n                    v28 = 0LL;\n                    do\n                    {\n                      if ( (v27 & 1) != 0 )\n                      {\n                        if ( v11 - v28 <= v19 )\n                          v28 -= v11;\n                        v28 += v19;\n                      }\n                      v29 = v19 - v11;\n                      if ( v11 - v19 > v19 )\n                        v29 = v19;\n                      v19 += v29;\n                      v27 >>= 1;\n                    }\n                    while ( v27 );\n                    v19 = v28 % v11;\n                  }\n                  v18 >>= 1;\n                }\n                while ( v18 );\n                if ( v19 != 1 )\n                {\n                  if ( !v35 )\n                    goto LABEL_63;\n                  if ( v6 != v19 )\n                    break;\n                }\n              }\nLABEL_64:\n              if ( !--v10 )\n                goto LABEL_8;\n            }\n            v23 = v34;\n            v24 = v19 % v11;\n            if ( !v19 )\n              goto LABEL_53;\n            while ( 1 )\n            {\n              v25 = 0LL;\n              do\n              {\n                if ( (v19 & 1) != 0 )\n                {\n                  if ( v11 - v25 <= v24 )\n                    v25 -= v11;\n                  v25 += v24;\n                }\n                v26 = v24 - v11;\n                if ( v11 - v24 > v24 )\n                  v26 = v24;\n                v24 += v26;\n                v19 >>= 1;\n              }\n              while ( v19 );\n              v19 = v25 % v11;\n              if ( !v23 )\n                break;\n              if ( v6 == v25 % v11 )\n                goto LABEL_64;\n              --v23;\n              v24 = v19 % v11;\n              if ( !v19 )\n                goto LABEL_53;\n            }\nLABEL_63:\n            if ( v6 != v19 )\n              goto LABEL_53;\n            goto LABEL_64;\n          }\n          v30 = v5 - 2 * ((((v5 * (unsigned __int128)0x8888888888888889LL) >> 64) & 0xFFFFFFFFFFFFFFF0LL) - v5 / 0x1E);\n          if ( v5 <= 5 )\n          {\n            if ( ((unsigned __int8)(545925292 >> v30) & (unsigned __int8)v5 & 1) == 0 )\n              libmin_fail(1);\n          }\n          else if ( ((unsigned __int8)v5 & (unsigned __int8)(545925250 >> v30) & 1) == 0\n                 || v5 > 0x30\n                 && (0x6DB6DB6DB6DB6DB7LL * v5 <= 0x2492492492492492LL\n                  || 0x2E8BA2E8BA2E8BA3LL * v5 <= 0x1745D1745D1745D1LL\n                  || 0x4EC4EC4EC4EC4EC5LL * v5 <= 0x13B13B13B13B13B1LL\n                  || 0xF0F0F0F0F0F0F0F1LL * v5 <= 0xF0F0F0F0F0F0F0FLL\n                  || 0x86BCA1AF286BCA1BLL * v5 <= 0xD79435E50D79435LL\n                  || 0xD37A6F4DE9BD37A7LL * v5 <= 0xB21642C8590B216LL\n                  || 0x34F72C234F72C235LL * v5 <= 0x8D3DCB08D3DCB08LL\n                  || v5 > 0x3C0\n                  && (!(v5 % 0x1F)\n                   || !(v5 % 0x25)\n                   || !(v5 % 0x29)\n                   || !(v5 % 0x2B)\n                   || !(v5 % 0x2F)\n                   || !(v5 % 0x35)\n                   || !(v5 % 0x3B)\n                   || !(v5 % 0x3D)\n                   || !(v5 % 0x43)\n                   || v5 > 0x13B0\n                   && (!(v5 % 0x47)\n                    || !(v5 % 0x49)\n                    || !(v5 % 0x4F)\n                    || !(v5 % 0x53)\n                    || !(v5 % 0x59)\n                    || !(v5 % 0x61)\n                    || !(v5 % 0x65)\n                    || !(v5 % 0x67)\n                    || !(v5 % 0x6B)\n                    || v5 > 0x2E68\n                    && (!(v5 % 0x6D)\n                     || !(v5 % 0x71)\n                     || !(v5 % 0x7F)\n                     || !(v5 % 0x83)\n                     || !(v5 % 0x89)\n                     || !(v5 % 0x8B)\n                     || !(v5 % 0x95)\n                     || !(v5 % 0x97)\n                     || !(v5 % 0x9D)\n                     || v5 > 0x67C8\n                     && (!(v5 % 0xA3)\n                      || !(v5 % 0xA7)\n                      || !(v5 % 0xAD)\n                      || !(v5 % 0xB3)\n                      || !(v5 % 0xB5)\n                      || !(v5 % 0xBF)\n                      || !(v5 % 0xC1)\n                      || !(v5 % 0xC5)\n                      || !(v5 % 0xC7)\n                      || v5 > 0xADE8\n                      && (!(v5 % 0xD3)\n                       || !(v5 % 0xDF)\n                       || !(v5 % 0xE3)\n                       || !(v5 % 0xE5)\n                       || !(v5 % 0xE9)\n                       || !(v5 % 0xEF)\n                       || !(v5 % 0xF1)\n                       || !(v5 % 0xFB)\n                       || !(v5 % 0x101)\n                       || v5 > 0x10E30\n                       && (!(v5 % 0x107)\n                        || !(v5 % 0x10D)\n                        || !(v5 % 0x10F)\n                        || !(v5 % 0x115)\n                        || !(v5 % 0x119)\n                        || !(v5 % 0x11B)\n                        || !(v5 % 0x125)\n                        || !(v5 % 0x133)\n                        || !(v5 % 0x137)\n                        || v5 > 0x17EB0\n                        && (!(v5 % 0x139)\n                         || !(v5 % 0x13D)\n                         || !(v5 % 0x14B)\n                         || !(v5 % 0x151)\n                         || !(v5 % 0x15B)\n                         || !(v5 % 0x15D)\n                         || !(v5 % 0x161)\n                         || !(v5 % 0x167)\n                         || !(v5 % 0x16F)\n                         || v5 > 0x21F78\n                         && (!(v5 % 0x175)\n                          || !(v5 % 0x17B)\n                          || !(v5 % 0x17F)\n                          || !(v5 % 0x185)\n                          || !(v5 % 0x18D)\n                          || !(v5 % 0x191)\n                          || !(v5 % 0x199)\n                          || !(v5 % 0x1A3)\n                          || !(v5 % 0x1A5)\n                          || v5 > 0x2D5A0\n                          && (!(v5 % 0x1AF)\n                           || !(v5 % 0x1B1)\n                           || !(v5 % 0x1B7)\n                           || !(v5 % 0x1BB)\n                           || !(v5 % 0x1C1)\n                           || !(v5 % 0x1C9)\n                           || !(v5 % 0x1CD)\n                           || !(v5 % 0x1CF)\n                           || !(v5 % 0x1D3)\n                           || v5 > 0x38040\n                           && (!(v5 % 0x1DF)\n                            || !(v5 % 0x1E7)\n                            || !(v5 % 0x1EB)\n                            || !(v5 % 0x1F3)\n                            || !(v5 % 0x1F7)\n                            || !(v5 % 0x1FD)\n                            || !(v5 % 0x209)\n                            || !(v5 % 0x20B)\n                            || !(v5 % 0x21D)\n                            || v5 > 0x490C8\n                            && (!(v5 % 0x223)\n                             || !(v5 % 0x22D)\n                             || !(v5 % 0x233)\n                             || !(v5 % 0x239)\n                             || !(v5 % 0x23B)\n                             || !(v5 % 0x241)\n                             || !(v5 % 0x24B)\n                             || !(v5 % 0x251)\n                             || !(v5 % 0x257)\n                             || v5 > 0x582F0\n                             && (!(v5 % 0x259)\n                              || !(v5 % 0x25F)\n                              || !(v5 % 0x265)\n                              || !(v5 % 0x269)\n                              || !(v5 % 0x26B)\n                              || !(v5 % 0x277)\n                              || !(v5 % 0x281)\n                              || !(v5 % 0x283)\n                              || !(v5 % 0x287)\n                              || v5 > 0x681A8\n                              && (!(v5 % 0x28D)\n                               || !(v5 % 0x293)\n                               || !(v5 % 0x295)\n                               || !(v5 % 0x2A1)\n                               || !(v5 % 0x2A5)\n                               || !(v5 % 0x2AB)\n                               || !(v5 % 0x2B3)\n                               || !(v5 % 0x2BD)\n                               || !(v5 % 0x2C5)\n                               || v5 > 0x7E360\n                               && (!(v5 % 0x2CF)\n                                || !(v5 % 0x2D7)\n                                || !(v5 % 0x2DD)\n                                || !(v5 % 0x2E3)\n                                || !(v5 % 0x2E7)\n                                || !(v5 % 0x2EF)\n                                || !(v5 % 0x2F5)\n                                || !(v5 % 0x2F9)\n                                || !(v5 % 0x301)\n                                || v5 > 0x91E18\n                                && (!(v5 % 0x305)\n                                 || !(v5 % 0x313)\n                                 || !(v5 % 0x31D)\n                                 || !(v5 % 0x329)\n                                 || !(v5 % 0x32B)\n                                 || !(v5 % 0x335)\n                                 || !(v5 % 0x337)\n                                 || !(v5 % 0x33B)\n                                 || !(v5 % 0x33D)\n                                 || v5 > 0xABDB0\n                                 && (!(v5 % 0x347)\n                                  || !(v5 % 0x355)\n                                  || !(v5 % 0x359)\n                                  || !(v5 % 0x35B)\n                                  || !(v5 % 0x35F)\n                                  || !(v5 % 0x36D)\n                                  || !(v5 % 0x371)\n                                  || !(v5 % 0x373)\n                                  || !(v5 % 0x377)\n                                  || v5 > 0xC8D78\n                                  && (!(v5 % 0x38B)\n                                   || !(v5 % 0x38F)\n                                   || !(v5 % 0x397)\n                                   || !(v5 % 0x3A1)\n                                   || !(v5 % 0x3A9)\n                                   || !(v5 % 0x3AD)\n                                   || !(v5 % 0x3B3)\n                                   || !(v5 % 0x3B9)\n                                   || !(v5 % 0x3C7)\n                                   || v5 > 0xE62F8\n                                   && (!(v5 % 0x3CB)\n                                    || !(v5 % 0x3D1)\n                                    || !(v5 % 0x3D7)\n                                    || !(v5 % 0x3DF)\n                                    || !(v5 % 0x3E5)\n                                    || !(v5 % 0x3F1)\n                                    || !(v5 % 0x3F5)\n                                    || !(v5 % 0x3FB)\n                                    || !(v5 % 0x3FD)\n                                    || v5 > 0x103830\n                                    && (!(v5 % 0x407)\n                                     || !(v5 % 0x409)\n                                     || !(v5 % 0x40F)\n                                     || !(v5 % 0x419)\n                                     || !(v5 % 0x41B)\n                                     || !(v5 % 0x425)\n                                     || !(v5 % 0x427)\n                                     || !(v5 % 0x42D)\n                                     || !(v5 % 0x43F)\n                                     || v5 > 0x122988\n                                     && (!(v5 % 0x443)\n                                      || !(v5 % 0x445)\n                                      || !(v5 % 0x449)\n                                      || !(v5 % 0x44F)\n                                      || !(v5 % 0x455)\n                                      || !(v5 % 0x45D)\n                                      || !(v5 % 0x463)\n                                      || !(v5 % 0x469)\n                                      || !(v5 % 0x47F)\n                                      || v5 > 0x144900\n                                      && (!(v5 % 0x481)\n                                       || !(v5 % 0x48B)\n                                       || !(v5 % 0x493)\n                                       || !(v5 % 0x49D)\n                                       || !(v5 % 0x4A3)\n                                       || !(v5 % 0x4A9)\n                                       || !(v5 % 0x4B1)\n                                       || !(v5 % 0x4BD)\n                                       || !(v5 % 0x4C1)\n                                       || v5 > 0x16D2B0\n                                       && (!(v5 % 0x4C7)\n                                        || !(v5 % 0x4CD)\n                                        || !(v5 % 0x4CF)\n                                        || !(v5 % 0x4D5)\n                                        || !(v5 % 0x4E1)\n                                        || !(v5 % 0x4EB)\n                                        || !(v5 % 0x4FD)\n                                        || !(v5 % 0x4FF)\n                                        || !(v5 % 0x503)\n                                        || v5 > 0x195A50\n                                        && (!(v5 % 0x509)\n                                         || !(v5 % 0x50B)\n                                         || !(v5 % 0x511)\n                                         || !(v5 % 0x515)\n                                         || !(v5 % 0x517)\n                                         || !(v5 % 0x51B)\n                                         || !(v5 % 0x527)\n                                         || !(v5 % 0x529)\n                                         || !(v5 % 0x52F)\n                                         || v5 > 0x1C43A0\n                                         && (!(v5 % 0x551)\n                                          || !(v5 % 0x557)\n                                          || !(v5 % 0x55D)\n                                          || !(v5 % 0x565)\n                                          || !(v5 % 0x577)\n                                          || !(v5 % 0x581)\n                                          || !(v5 % 0x58F)\n                                          || !(v5 % 0x593)\n                                          || !(v5 % 0x595)\n                                          || v5 > 0x1F5570\n                                          && (!(v5 % 0x599)\n                                           || !(v5 % 0x59F)\n                                           || !(v5 % 0x5A7)\n                                           || !(v5 % 0x5AB)\n                                           || !(v5 % 0x5AD)\n                                           || !(v5 % 0x5B3)\n                                           || !(v5 % 0x5BF)\n                                           || !(v5 % 0x5C9)\n                                           || !(v5 % 0x5CB)\n                                           || v5 > 0x21BD60\n                                           && (!(v5 % 0x5CF)\n                                            || !(v5 % 0x5D1)\n                                            || !(v5 % 0x5D5)\n                                            || !(v5 % 0x5DB)\n                                            || !(v5 % 0x5E7)\n                                            || !(v5 % 0x5F3)\n                                            || !(v5 % 0x5FB)\n                                            || !(v5 % 0x607)\n                                            || !(v5 % 0x60D)\n                                            || v5 > 0x24CD20\n                                            && (!(v5 % 0x611)\n                                             || !(v5 % 0x617)\n                                             || !(v5 % 0x61F)\n                                             || !(v5 % 0x623)\n                                             || !(v5 % 0x62B)\n                                             || !(v5 % 0x62F)\n                                             || !(v5 % 0x63D)\n                                             || !(v5 % 0x641)\n                                             || !(v5 % 0x647)\n                                             || v5 > 0x2780D0\n                                             && (!(v5 % 0x649)\n                                              || !(v5 % 0x64D)\n                                              || !(v5 % 0x653)\n                                              || !(v5 % 0x655)\n                                              || !(v5 % 0x65B)\n                                              || !(v5 % 0x665)\n                                              || !(v5 % 0x679)\n                                              || !(v5 % 0x67F)\n                                              || !(v5 % 0x683)\n                                              || v5 > 0x2A8118\n                                              && (!(v5 % 0x685)\n                                               || !(v5 % 0x69D)\n                                               || !(v5 % 0x6A1)\n                                               || !(v5 % 0x6A3)\n                                               || !(v5 % 0x6AD)\n                                               || !(v5 % 0x6B9)\n                                               || !(v5 % 0x6BB)\n                                               || !(v5 % 0x6C5)\n                                               || !(v5 % 0x6CD)\n                                               || v5 > 0x2E91E8\n                                               && (!(v5 % 0x6D3)\n                                                || !(v5 % 0x6D9)\n                                                || !(v5 % 0x6DF)\n                                                || !(v5 % 0x6F1)\n                                                || !(v5 % 0x6F7)\n                                                || !(v5 % 0x6FB)\n                                                || !(v5 % 0x6FD)\n                                                || !(v5 % 0x709)\n                                                || !(v5 % 0x713)\n                                                || v5 > 0x32B5C0\n                                                && (!(v5 % 0x71F)\n                                                 || !(v5 % 0x727)\n                                                 || !(v5 % 0x737)\n                                                 || !(v5 % 0x745)\n                                                 || !(v5 % 0x74B)\n                                                 || !(v5 % 0x74F)\n                                                 || !(v5 % 0x751)\n                                                 || !(v5 % 0x755)\n                                                 || !(v5 % 0x757)\n                                                 || v5 > 0x3672C0\n                                                 && (!(v5 % 0x761)\n                                                  || !(v5 % 0x76D)\n                                                  || !(v5 % 0x773)\n                                                  || !(v5 % 0x779)\n                                                  || !(v5 % 0x78B)\n                                                  || !(v5 % 0x78D)\n                                                  || !(v5 % 0x79D)\n                                                  || !(v5 % 0x79F)\n                                                  || !(v5 % 0x7B5)\n                                                  || v5 > 0x3BC298\n                                                  && (!(v5 % 0x7BB)\n                                                   || !(v5 % 0x7C3)\n                                                   || !(v5 % 0x7C9)\n                                                   || !(v5 % 0x7CD)\n                                                   || !(v5 % 0x7CF)\n                                                   || !(v5 % 0x7D3)\n                                                   || !(v5 % 0x7DB)\n                                                   || !(v5 % 0x7E1)\n                                                   || !(v5 % 0x7EB)\n                                                   || v5 > 0x3ED168\n                                                   && (!(v5 % 0x7ED)\n                                                    || !(v5 % 0x7F7)\n                                                    || !(v5 % 0x805)\n                                                    || !(v5 % 0x80F)\n                                                    || !(v5 % 0x815)\n                                                    || !(v5 % 0x821)\n                                                    || !(v5 % 0x823)\n                                                    || !(v5 % 0x827)\n                                                    || !(v5 % 0x829)\n                                                    || v5 > 0x433A28\n                                                    && (!(v5 % 0x833)\n                                                     || !(v5 % 0x83F)\n                                                     || !(v5 % 0x841)\n                                                     || !(v5 % 0x851)\n                                                     || !(v5 % 0x853)\n                                                     || !(v5 % 0x859)\n                                                     || !(v5 % 0x85D)\n                                                     || !(v5 % 0x85F)\n                                                     || !(v5 % 0x869))))))))))))))))))))))))))))))))))))) )\n          {\nLABEL_53:\n            libmin_fail(1);\n          }\n        }\n        else if ( v5 != 2 )\n        {\n          goto LABEL_53;\n        }\nLABEL_8:\n        ++j;\n      }\n      while ( factors[j + 1] );\n      v31 = &factors[j];\n    }\n    else\n    {\n      v31 = factors;\n    }\n    libmin_printf(\"%lu\\n\", *v31);\n    if ( ++n_bits == 65 )\n    {\n      ++wrapper;\n      v3 = v39 - v40 + 64;\n      if ( wrapper == 64 )\n      {\n        libmin_free(factors);\n        libmin_success();\n      }\n      goto LABEL_2;\n    }\n  }\n}\n"}, "pseudo_normalize": "", "binary": "rho-factor/rho-factor.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x8,%esi\nmov    $0x40,%edi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x78,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\nlea    0x58(%rsp),%rbx\ncall   5b20 <libmin_calloc>\nmov    $0x2a,%edi\nmov    %rax,0x18(%rsp)\ncall   7f20 <libmin_srand>\nmov    %rbx,0x48(%rsp)\nlea    0x60(%rsp),%rbx\nxor    %eax,%eax\nmovq   $0x4,0x28(%rsp)\nmov    %rbx,0x10(%rsp)\nmov    0x28(%rsp),%rbx\nadd    $0x1,%eax\nmov    %eax,0x40(%rsp)\nmov    %rbx,0x30(%rsp)\nmovq   $0x0,0x58(%rsp)\nmov    0x48(%rsp),%rbx\nmov    0x10(%rsp),%rbp\ncall   7f80 <libmin_rand>\nadd    $0x1,%rbx\nmov    %al,-0x1(%rbx)\ncmp    %rbx,%rbp\njne    11a3 <main+0x83>\nmov    0x30(%rsp),%rbx\nmov    $0x40,%ecx\nmov    $0xffffffffffffffff,%rax\nmov    0x28(%rsp),%rdi\nmov    0x40(%rsp),%esi\nsub    %ebx,%ecx\nmov    %edi,0x44(%rsp)\nshr    %cl,%rax\nand    0x58(%rsp),%rax\nsub    %edi,%esi\nmov    %rax,%rdx\nadd    %ebx,%esi\nlea    0x7e1a(%rip),%rdi\nnot    %rdx\nand    $0x1,%edx\nadd    %rdx,%rax\nmov    %rbx,%rdx\nmov    %rax,%rcx\nmov    %rax,0x38(%rsp)\nmov    %rax,%rbx\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\ncall   7d10 <libmin_printf>\nmov    0x18(%rsp),%r15\nmov    %rbx,%rdi\nmov    %r15,%rsi\ncall   35d0 <factor>\ncmpq   $0x0,0x8(%r15)\nje     33b7 <main+0x2297>\nmovq   $0x0,0x8(%rsp)\njmp    1259 <main+0x139>\ncmp    $0x2,%r15\njne    1461 <main+0x341>\naddq   $0x1,0x8(%rsp)\nmov    0x18(%rsp),%rbx\nmov    0x8(%rsp),%rax\ncmpq   $0x0,0x8(%rbx,%rax,8)\nje     3300 <main+0x21e0>\nmov    0x18(%rsp),%rbx\nmov    0x8(%rsp),%r15\nlea    0x7db4(%rip),%rdi\nxor    %eax,%eax\nmov    (%rbx,%r15,8),%rsi\ncall   7d10 <libmin_printf>\nmov    (%rbx,%r15,8),%r15\nmov    0x38(%rsp),%rax\nxor    %edx,%edx\ndiv    %r15\ntest   %rdx,%rdx\njne    14cf <main+0x3af>\nmovq   $0x0,0x60(%rsp)\ncmp    $0x1,%r15\nmov    %r15d,%eax\nsetne  %dl\nand    $0x1,%eax\ncmp    %al,%dl\njne    1233 <main+0x113>\ncmp    $0x4741e0,%r15\njbe    14ec <main+0x3cc>\nlea    -0x1(%r15),%rbx\nmov    %rbx,%rbp\ntest   $0x1,%r15b\nje     33a7 <main+0x2287>\nxor    %r14d,%r14d\nshr    %rbp\nmov    %r14d,%eax\nadd    $0x1,%r14d\ntest   $0x1,%bpl\nje     12c7 <main+0x1a7>\nmov    %eax,0x20(%rsp)\nmov    %r14d,0x24(%rsp)\nmov    $0x24,%r13d\nlea    0x68(%rsp),%r12\nmov    %r15,%r14\nxchg   %ax,%ax\nmov    0x10(%rsp),%r15\nnopl   (%rax)\ncall   7f80 <libmin_rand>\nadd    $0x1,%r15\nmov    %al,-0x1(%r15)\ncmp    %r15,%r12\njne    12f8 <main+0x1d8>\nmov    0x60(%rsp),%rax\nxor    %edx,%edx\nmov    %r14,%rdi\ndiv    %rbx\nlea    0x1(%rdx),%r8\nmov    %r8,%rcx\njmp    1330 <main+0x210>\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\nmov    %rdx,%rdi\ntest   %rdx,%rdx\nje     1340 <main+0x220>\nmov    %rcx,%rax\nxor    %edx,%edx\ndiv    %rdi\nmov    %rdx,%rcx\ntest   %rdx,%rdx\njne    1320 <main+0x200>\nmov    $0x1,%eax\nmov    %rax,%rdi\nadd    %rax,%rax\ncmp    %rbp,%rax\njbe    1345 <main+0x225>\nmovabs $0x7fffffffffffffff,%rax\nand    %rax,%rdi\nje     14c0 <main+0x3a0>\nmov    $0x1,%ecx\nnopl   0x0(%rax,%rax,1)\nmov    %rcx,%rax\nxor    %edx,%edx\ndiv    %r14\ntest   %rcx,%rcx\nje     13be <main+0x29e>\nxor    %eax,%eax\nnop\ntest   $0x1,%cl\nje     139b <main+0x27b>\nmov    %r14,%r9\nmov    %rax,%rsi\nsub    %rax,%r9\nsub    %r14,%rsi\ncmp    %rdx,%r9\ncmovbe %rsi,%rax\nadd    %rdx,%rax\nmov    %r14,%r9\nmov    %rdx,%rsi\nsub    %rdx,%r9\nsub    %r14,%rsi\ncmp    %rdx,%r9\ncmova  %rdx,%rsi\nadd    %rsi,%rdx\nshr    %rcx\njne    1380 <main+0x260>\nxor    %edx,%edx\ndiv    %r14\nmov    %rdx,%rcx\ntest   %rdi,%rbp\njne    1470 <main+0x350>\nshr    %rdi\njne    1370 <main+0x250>\ncmp    $0x1,%rcx\nje     14c0 <main+0x3a0>\nmov    0x24(%rsp),%eax\ntest   %eax,%eax\nje     14bb <main+0x39b>\ncmp    %rcx,%rbx\nje     14c0 <main+0x3a0>\nmov    %rcx,%rax\nxor    %edx,%edx\nmov    0x20(%rsp),%r8d\ndiv    %r14\ntest   %rcx,%rcx\nje     1461 <main+0x341>\nnopl   (%rax)\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\ntest   $0x1,%cl\nje     1423 <main+0x303>\nmov    %r14,%rdi\nmov    %rax,%rsi\nsub    %rax,%rdi\nsub    %r14,%rsi\ncmp    %rdx,%rdi\ncmovbe %rsi,%rax\nadd    %rdx,%rax\nmov    %r14,%rdi\nmov    %rdx,%rsi\nsub    %rdx,%rdi\nsub    %r14,%rsi\ncmp    %rdx,%rdi\ncmova  %rdx,%rsi\nadd    %rsi,%rdx\nshr    %rcx\njne    1408 <main+0x2e8>\nxor    %edx,%edx\ndiv    %r14\nmov    %rdx,%rcx\ntest   %r8d,%r8d\nje     14bb <main+0x39b>\ncmp    %rdx,%rbx\nje     14c0 <main+0x3a0>\nmov    %rcx,%rax\nxor    %edx,%edx\nsub    $0x1,%r8d\ndiv    %r14\ntest   %rcx,%rcx\njne    1400 <main+0x2e0>\nmov    $0x1,%edi\ncall   59b0 <libmin_fail>\njmp    123d <main+0x11d>\nmov    %r8,%rdx\nxor    %eax,%eax\nnopl   (%rax)\ntest   $0x1,%dl\nje     1493 <main+0x373>\nmov    %r14,%r9\nmov    %rax,%rsi\nsub    %rax,%r9\nsub    %r14,%rsi\ncmp    %rcx,%r9\ncmovbe %rsi,%rax\nadd    %rcx,%rax\nmov    %r14,%r9\nmov    %rcx,%rsi\nsub    %rcx,%r9\nsub    %r14,%rsi\ncmp    %rcx,%r9\ncmova  %rcx,%rsi\nadd    %rsi,%rcx\nshr    %rdx\njne    1478 <main+0x358>\nxor    %edx,%edx\ndiv    %r14\nmov    %rdx,%rcx\njmp    13c7 <main+0x2a7>\ncmp    %rcx,%rbx\njne    1461 <main+0x341>\nsub    $0x1,%r13d\njne    12f0 <main+0x1d0>\njmp    123d <main+0x11d>\nmov    $0x1,%edi\ncall   59b0 <libmin_fail>\nmov    0x18(%rsp),%rax\nmov    0x8(%rsp),%rbx\nmov    (%rax,%rbx,8),%r15\njmp    128c <main+0x16c>\nmovabs $0x8888888888888889,%rax\nmul    %r15\nmov    %rdx,%rcx\nmov    %rdx,%rax\nshr    $0x4,%rcx\nand    $0xfffffffffffffff0,%rax\nsub    %rcx,%rax\nmov    %r15,%rcx\nadd    %rax,%rax\nsub    %rax,%rcx\ncmp    $0x5,%r15\njbe    3382 <main+0x2262>\nmov    $0x208a2882,%eax\nsar    %cl,%eax\nand    %r15,%rax\ntest   $0x1,%al\nje     1461 <main+0x341>\ncmp    $0x30,%r15\njbe    123d <main+0x11d>\nmovabs $0x6db6db6db6db6db7,%rax\nmovabs $0x2492492492492492,%rbx\nimul   %r15,%rax\ncmp    %rbx,%rax\njbe    1461 <main+0x341>\nmovabs $0x2e8ba2e8ba2e8ba3,%rax\nmovabs $0x1745d1745d1745d1,%rdx\nimul   %r15,%rax\ncmp    %rdx,%rax\njbe    1461 <main+0x341>\nmovabs $0x4ec4ec4ec4ec4ec5,%rax\nmovabs $0x13b13b13b13b13b1,%rdx\nimul   %r15,%rax\ncmp    %rdx,%rax\njbe    1461 <main+0x341>\nmovabs $0xf0f0f0f0f0f0f0f1,%rax\nmovabs $0xf0f0f0f0f0f0f0f,%rdx\nimul   %r15,%rax\ncmp    %rdx,%rax\njbe    1461 <main+0x341>\nmovabs $0x86bca1af286bca1b,%rax\nmovabs $0xd79435e50d79435,%rdx\nimul   %r15,%rax\ncmp    %rdx,%rax\njbe    1461 <main+0x341>\nmovabs $0xd37a6f4de9bd37a7,%rax\nmovabs $0xb21642c8590b216,%rdx\nimul   %r15,%rax\ncmp    %rdx,%rax\njbe    1461 <main+0x341>\nmovabs $0x34f72c234f72c235,%rax\nmovabs $0x8d3dcb08d3dcb08,%rdx\nimul   %r15,%rax\ncmp    %rdx,%rax\njbe    1461 <main+0x341>\ncmp    $0x3c0,%r15\njbe    123d <main+0x11d>\nmov    $0x1f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x25,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x29,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x35,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x43,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x13b0,%r15\njbe    123d <main+0x11d>\nmov    $0x47,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x49,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x53,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x59,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x61,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x65,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x67,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x2e68,%r15\njbe    123d <main+0x11d>\nmov    $0x6d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x71,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x7f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x83,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x89,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x8b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x95,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x97,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x9d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x67c8,%r15\njbe    123d <main+0x11d>\nmov    $0xa3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xa7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xad,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xb3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xb5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xbf,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xc1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xc5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xc7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0xade8,%r15\njbe    123d <main+0x11d>\nmov    $0xd3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xdf,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xe3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xe5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xe9,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xef,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xf1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0xfb,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x101,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x10e30,%r15\njbe    123d <main+0x11d>\nmov    $0x107,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x10d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x10f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x115,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x119,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x11b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x125,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x133,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x137,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x17eb0,%r15\njbe    123d <main+0x11d>\nmov    $0x139,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x13d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x14b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x151,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x15b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x15d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x161,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x167,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x16f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x21f78,%r15\njbe    123d <main+0x11d>\nmov    $0x175,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x17b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x17f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x185,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x18d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x191,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x199,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1a3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1a5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x2d5a0,%r15\njbe    123d <main+0x11d>\nmov    $0x1af,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1b1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1b7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1bb,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1c1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1c9,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1cd,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1cf,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1d3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x38040,%r15\njbe    123d <main+0x11d>\nmov    $0x1df,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1e7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1eb,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1f3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1f7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x1fd,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x209,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x20b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x21d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x490c8,%r15\njbe    123d <main+0x11d>\nmov    $0x223,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x22d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x233,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x239,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x23b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x241,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x24b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x251,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x257,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x582f0,%r15\njbe    123d <main+0x11d>\nmov    $0x259,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x25f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x265,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x269,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x26b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x277,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x281,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x283,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x287,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x681a8,%r15\njbe    123d <main+0x11d>\nmov    $0x28d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x293,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x295,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2a1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2a5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2ab,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2b3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2bd,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2c5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x7e360,%r15\njbe    123d <main+0x11d>\nmov    $0x2cf,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2d7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2dd,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2e3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2e7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2ef,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2f5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x2f9,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x301,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x91e18,%r15\njbe    123d <main+0x11d>\nmov    $0x305,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x313,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x31d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x329,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x32b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x335,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x337,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x33b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x33d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0xabdb0,%r15\njbe    123d <main+0x11d>\nmov    $0x347,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x355,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x359,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x35b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x35f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x36d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x371,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x373,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x377,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0xc8d78,%r15\njbe    123d <main+0x11d>\nmov    $0x38b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x38f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x397,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3a1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3a9,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3ad,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3b3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3b9,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3c7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0xe62f8,%r15\njbe    123d <main+0x11d>\nmov    $0x3cb,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3d1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3d7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3df,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3e5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3f1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3f5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3fb,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x3fd,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x103830,%r15\njbe    123d <main+0x11d>\nmov    $0x407,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x409,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x40f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x419,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x41b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x425,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x427,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x42d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x43f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x122988,%r15\njbe    123d <main+0x11d>\nmov    $0x443,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x445,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x449,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x44f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x455,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x45d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x463,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x469,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x47f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x144900,%r15\njbe    123d <main+0x11d>\nmov    $0x481,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x48b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x493,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x49d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4a3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4a9,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4b1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4bd,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4c1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x16d2b0,%r15\njbe    123d <main+0x11d>\nmov    $0x4c7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4cd,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4cf,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4d5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4e1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4eb,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4fd,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x4ff,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x503,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x195a50,%r15\njbe    123d <main+0x11d>\nmov    $0x509,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x50b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x511,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x515,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x517,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x51b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x527,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x529,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x52f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x1c43a0,%r15\njbe    123d <main+0x11d>\nmov    $0x551,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x557,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x55d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x565,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x577,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x581,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x58f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x593,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x595,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x1f5570,%r15\njbe    123d <main+0x11d>\nmov    $0x599,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x59f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5a7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5ab,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5ad,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5b3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5bf,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5c9,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5cb,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x21bd60,%r15\njbe    123d <main+0x11d>\nmov    $0x5cf,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5d1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5d5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5db,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5e7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5f3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x5fb,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x607,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x60d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x24cd20,%r15\njbe    123d <main+0x11d>\nmov    $0x611,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x617,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x61f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x623,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x62b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x62f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x63d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x641,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x647,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x2780d0,%r15\njbe    123d <main+0x11d>\nmov    $0x649,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x64d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x653,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x655,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x65b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x665,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x679,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x67f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x683,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x2a8118,%r15\njbe    123d <main+0x11d>\nmov    $0x685,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x69d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6a1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6a3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6ad,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6b9,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6bb,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6c5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6cd,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x2e91e8,%r15\njbe    123d <main+0x11d>\nmov    $0x6d3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6d9,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6df,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6f1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6f7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6fb,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x6fd,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x709,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x713,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x32b5c0,%r15\njbe    123d <main+0x11d>\nmov    $0x71f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x727,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x737,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x745,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x74b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x74f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x751,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x755,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x757,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x3672c0,%r15\njbe    123d <main+0x11d>\nmov    $0x761,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x76d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x773,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x779,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x78b,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x78d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x79d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x79f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x7b5,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x3bc298,%r15\njbe    123d <main+0x11d>\nmov    $0x7bb,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x7c3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x7c9,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x7cd,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x7cf,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x7d3,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x7db,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x7e1,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x7eb,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x3ed168,%r15\njbe    123d <main+0x11d>\nmov    $0x7ed,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x7f7,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x805,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x80f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x815,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x821,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x823,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x827,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x829,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\ncmp    $0x433a28,%r15\njbe    123d <main+0x11d>\nmov    $0x833,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x83f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x841,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x851,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x853,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x859,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x85d,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x85f,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1461 <main+0x341>\nmov    $0x869,%ecx\nmov    %r15,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\njne    123d <main+0x11d>\njmp    1461 <main+0x341>\nxchg   %ax,%ax\nmov    %rbx,%rax\nmov    0x8(%rsp),%rbx\nlea    (%rax,%rbx,8),%rax\nmov    (%rax),%rsi\nlea    0x5d0f(%rip),%rdi\nxor    %eax,%eax\ncall   7d10 <libmin_printf>\naddq   $0x1,0x30(%rsp)\nmov    0x30(%rsp),%rax\ncmp    $0x41,%rax\njne    1190 <main+0x70>\naddq   $0x1,0x28(%rsp)\nmov    0x28(%rsp),%rbx\nmov    0x40(%rsp),%eax\nsub    0x44(%rsp),%eax\nadd    $0x40,%eax\ncmp    $0x40,%rbx\njne    117f <main+0x5f>\nmov    0x18(%rsp),%rdi\ncall   5a80 <libmin_free>\ncall   8170 <libmin_success>\nmov    0x68(%rsp),%rax\nsub    %fs:0x28,%rax\njne    33c1 <main+0x22a1>\nadd    $0x78,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x208a28ac,%eax\nmov    %r15,%rsi\nsar    %cl,%eax\nand    %rax,%rsi\nand    $0x1,%esi\njne    123d <main+0x11d>\nmov    $0x1,%edi\ncall   59b0 <libmin_fail>\njmp    123d <main+0x11d>\nmovl   $0xffffffff,0x20(%rsp)\nxor    %r14d,%r14d\njmp    12db <main+0x1bb>\nmov    0x18(%rsp),%rax\njmp    330c <main+0x21ec>\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "rle-compress/rle-compress.c", "function_name": "main", "content": "/**\n * @brief Main function\n * @returns 0 on exit\n */\nint main() {\n    test();  // run self-test implementations\n\n    libmin_printf(\"All tests have passed!\\n\");\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "rle-compress/rle-compress.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char *v3; // rbp\n  char *v4; // rbp\n  char *v5; // rbp\n\n  v3 = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if ( !libmin_strcmp(v3, \"7a3b2a4c1d1e1f2a1d1r\") )\n  {\n    libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", v3);\n    libmin_free(v3);\n    v4 = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n    if ( !libmin_strcmp(v4, \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\") )\n    {\n      libmin_printf(\"in: %s -> out: %s\\n\", \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", v4);\n      libmin_free(v4);\n      v5 = run_length_encode(\"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\");\n      if ( !libmin_strcmp(v5, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\") )\n      {\n        libmin_printf(\n          \"in: %s -> out: %s\\n\",\n          \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n          v5);\n        libmin_free(v5);\n        libmin_printf(\"All tests have passed!\\n\");\n        libmin_success();\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  char *v3;\n  char *v4;\n  char *v5;\n  v3 = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if (!libmin_strcmp(v3, \"7a3b2a4c1d1e1f2a1d1r\")) {\n    libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", v3);\n    libmin_free(v3);\n    v4 = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n    if (!libmin_strcmp(v4,\n                       \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1\"\n                       \"e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\")) {\n      libmin_printf(\"in: %s -> out: %s\\n\",\n                    \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", v4);\n      libmin_free(v4);\n      v5 = run_length_encode(\n          \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaahghghrw\");\n      if (!libmin_strcmp(v5, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\")) {\n        libmin_printf(\"in: %s -> out: %s\\n\",\n                      \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n                      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n                      v5);\n        libmin_free(v5);\n        libmin_printf(\"All tests have passed!\\n\");\n        libmin_success();\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}", "binary": "rle-compress/rle-compress.host.O3", "assembly": "<main>:\nendbr64\npush   %r13\npush   %r12\nlea    0x2ed8(%rip),%r12\npush   %rbp\nmov    %r12,%rdi\ncall   1330 <run_length_encode>\nlea    0x2ee0(%rip),%rsi\nmov    %rax,%rdi\nmov    %rax,%rbp\ncall   3bb0 <libmin_strcmp>\ntest   %eax,%eax\njne    120a <main+0xea>\nmov    %r12,%rsi\nlea    0x2ed8(%rip),%r12\nmov    %rbp,%rdx\nxor    %eax,%eax\nmov    %r12,%rdi\nlea    0x2ef5(%rip),%r13\ncall   39a0 <libmin_printf>\nmov    %rbp,%rdi\ncall   1710 <libmin_free>\nmov    %r13,%rdi\ncall   1330 <run_length_encode>\nlea    0x2f09(%rip),%rsi\nmov    %rax,%rdi\nmov    %rax,%rbp\ncall   3bb0 <libmin_strcmp>\ntest   %eax,%eax\njne    1225 <main+0x105>\nmov    %r13,%rsi\nmov    %rbp,%rdx\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   39a0 <libmin_printf>\nlea    0x2f3f(%rip),%r13\nmov    %rbp,%rdi\ncall   1710 <libmin_free>\nmov    %r13,%rdi\ncall   1330 <run_length_encode>\nlea    0x2f90(%rip),%rsi\nmov    %rax,%rdi\nmov    %rax,%rbp\ncall   3bb0 <libmin_strcmp>\ntest   %eax,%eax\njne    1219 <main+0xf9>\nmov    %rbp,%rdx\nmov    %r13,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   39a0 <libmin_printf>\nmov    %rbp,%rdi\ncall   1710 <libmin_free>\nlea    0x2e51(%rip),%rdi\nxor    %eax,%eax\ncall   39a0 <libmin_printf>\ncall   3cb0 <libmin_success>\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\nret\nmov    $0x1,%edi\ncall   1640 <libmin_fail>\njmp    1152 <main+0x32>\nmov    $0x1,%edi\ncall   1640 <libmin_fail>\njmp    11d7 <main+0xb7>\nmov    $0x1,%edi\ncall   1640 <libmin_fail>\njmp    119a <main+0x7a>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "rle-compress/rle-compress.c", "function_name": "run_length_encode", "content": "/**\n * @file\n * @author [serturx](https://github.com/serturx/)\n * @brief Encode a null terminated string using [Run-length encoding](https://en.wikipedia.org/wiki/Run-length_encoding)\n * @details\n * Run-length encoding is a lossless compression algorithm.\n * It works by counting the consecutive occurences symbols\n * and encodes that series of consecutive symbols into the\n * counted symbol and a number denoting the number of\n * consecutive occorences.\n * \n * For example the string \"AAAABBCCD\" gets encoded into \"4A2B2C1D\"\n * \n */\n\n#include \"libmin.h\"\n\n/**\n * @brief Encodes a null-terminated string using run-length encoding\n * @param str String to encode\n * @return char* Encoded string\n */\n\nchar* run_length_encode(char* str) {\n    int str_length = libmin_strlen(str);\n    int encoded_index = 0;\n\n    //allocate space for worst-case scenario\n    char* encoded = libmin_malloc(2 * libmin_strlen(str) + 1);\n    \n    //temp space for int to str conversion\n    char int_str[20];\n\n    for(int i = 0; i < str_length; ++i) {\n        int count = 0;\n        char current = str[i];\n\n        //count occurences\n        while(current == str[i + count]) count++;\n\n        i += count - 1;\n\n        //convert occurrence amount to string and write to encoded string\n        libmin_snprintf(int_str, 20, \"%d\", count);\n        libmin_strncpy(&encoded[encoded_index], int_str, libmin_strlen(int_str));\n\n        //write current char to encoded string\n        encoded_index += libmin_strlen(int_str);\n        encoded[encoded_index] = current;\n        ++encoded_index;\n    }\n\n    //null terminate string and move encoded string to compacted memory space \n    encoded[encoded_index] = '\\0';\n    char* compacted_string = libmin_malloc(libmin_strlen(encoded) + 1);\n    libmin_strcpy(compacted_string, encoded);\n    \n    libmin_free(encoded);\n\n    return compacted_string;\n}\n"}, "pseudo": {"path": "rle-compress/rle-compress.host.O3.pseudo", "function_name": "run_length_encode", "address": "0x1330", "label": "run_length_encode", "content": "char *__fastcall run_length_encode(char *str)\n{\n  size_t v1; // rax\n  char *v2; // rax\n  char *v3; // r13\n  int v4; // ebx\n  int v5; // r12d\n  int v6; // ecx\n  char v7; // r15\n  char *v8; // rax\n  int v9; // edx\n  size_t v10; // rax\n  int v11; // eax\n  size_t v12; // rax\n  char *v13; // r12\n  int v15; // [rsp+Ch] [rbp-5Ch]\n  char int_str[24]; // [rsp+10h] [rbp-58h] BYREF\n  unsigned __int64 v17; // [rsp+28h] [rbp-40h]\n\n  v17 = __readfsqword(0x28u);\n  v15 = libmin_strlen(str);\n  v1 = libmin_strlen(str);\n  v2 = (char *)libmin_malloc(2 * v1 + 1);\n  v3 = v2;\n  if ( v15 > 0 )\n  {\n    v4 = 0;\n    v5 = 0;\n    do\n    {\n      v6 = 0;\n      v7 = str[v4];\n      v8 = &str[v4 + 1];\n      do\n      {\n        ++v8;\n        v9 = v6++;\n      }\n      while ( *(v8 - 1) == v7 );\n      v4 += v9 + 1;\n      libmin_snprintf(int_str, 0x14uLL, \"%d\", v6);\n      v10 = libmin_strlen(int_str);\n      libmin_strncpy(&v3[v5], int_str, v10);\n      v11 = v5 + libmin_strlen(int_str);\n      v5 = v11 + 1;\n      v3[v11] = v7;\n    }\n    while ( v15 > v4 );\n    v2 = &v3[v5];\n  }\n  *v2 = 0;\n  v12 = libmin_strlen(v3);\n  v13 = (char *)libmin_malloc(v12 + 1);\n  libmin_strcpy(v13, v3);\n  libmin_free(v3);\n  return v13;\n}\n"}, "pseudo_normalize": "char *run_length_encode(char *str) {\n  unsigned int v1;\n  char *v2;\n  char *v3;\n  int v4;\n  int v5;\n  int v6;\n  char v7;\n  char *v8;\n  int v9;\n  unsigned int v10;\n  int v11;\n  unsigned int v12;\n  char *v13;\n  int v15;\n  char int_str[24];\n  unsigned long long v17;\n  v17 = __readfsqword(40u);\n  v15 = libmin_strlen(str);\n  v1 = libmin_strlen(str);\n  v2 = (char *)libmin_malloc(2 * v1 + 1);\n  v3 = v2;\n  if (v15 > 0) {\n    v4 = 0;\n    v5 = 0;\n    do {\n      v6 = 0;\n      v7 = str[v4];\n      v8 = &str[v4 + 1];\n      do {\n        ++v8;\n        v9 = v6++;\n      } while (*(v8 - 1) == v7);\n      v4 += v9 + 1;\n      libmin_snprintf(int_str, 20uLL, \"%d\", v6);\n      v10 = libmin_strlen(int_str);\n      libmin_strncpy(&v3[v5], int_str, v10);\n      v11 = v5 + libmin_strlen(int_str);\n      v5 = v11 + 1;\n      v3[v11] = v7;\n    } while (v15 > v4);\n    v2 = &v3[v5];\n  }\n  *v2 = 0;\n  v12 = libmin_strlen(v3);\n  v13 = (char *)libmin_malloc(v12 + 1);\n  libmin_strcpy(v13, v3);\n  libmin_free(v3);\n  return v13;\n}", "binary": "rle-compress/rle-compress.host.O3", "assembly": "<run_length_encode>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\ncall   3c30 <libmin_strlen>\nmov    %r14,%rdi\nmov    %eax,0xc(%rsp)\nmov    %rax,%rbx\ncall   3c30 <libmin_strlen>\nlea    0x1(%rax,%rax,1),%rdi\ncall   1660 <libmin_malloc>\nmov    %rax,%r13\ntest   %ebx,%ebx\njle    1406 <run_length_encode+0xd6>\nxor    %ebx,%ebx\nxor    %r12d,%r12d\nlea    0x10(%rsp),%rbp\nnopl   0x0(%rax,%rax,1)\nmovslq %ebx,%rax\nxor    %ecx,%ecx\nmovzbl (%r14,%rax,1),%r15d\nlea    0x1(%r14,%rax,1),%rax\nnop\nadd    $0x1,%rax\nmov    %ecx,%edx\nadd    $0x1,%ecx\ncmp    %r15b,-0x1(%rax)\nje     13a0 <run_length_encode+0x70>\nmov    $0x14,%esi\nadd    %edx,%ebx\nmov    %rbp,%rdi\nxor    %eax,%eax\nlea    0x2c42(%rip),%rdx\nadd    $0x1,%ebx\ncall   3ae0 <libmin_snprintf>\nmov    %rbp,%rdi\ncall   3c30 <libmin_strlen>\nmovslq %r12d,%rdi\nmov    %rbp,%rsi\nmov    %rax,%rdx\nadd    %r13,%rdi\ncall   3c60 <libmin_strncpy>\nmov    %rbp,%rdi\ncall   3c30 <libmin_strlen>\nadd    %r12d,%eax\nmovslq %eax,%rdx\nlea    0x1(%rax),%r12d\nmov    %r15b,0x0(%r13,%rdx,1)\ncmp    %ebx,0xc(%rsp)\njg     1390 <run_length_encode+0x60>\nmovslq %r12d,%rax\nadd    %r13,%rax\nmovb   $0x0,(%rax)\nmov    %r13,%rdi\ncall   3c30 <libmin_strlen>\nlea    0x1(%rax),%rdi\ncall   1660 <libmin_malloc>\nmov    %r13,%rsi\nmov    %rax,%rdi\nmov    %rax,%r12\ncall   3c10 <libmin_strcpy>\nmov    %r13,%rdi\ncall   1710 <libmin_free>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1452 <run_length_encode+0x122>\nadd    $0x38,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10c0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "rsa-cipher/rsa-cipher.c", "function_name": "main", "content": "int main() {\n    // Fixed primes for demonstration (not cryptographically secure)\n    unsigned long long p_ll = 1000003ULL;  // About 1e6\n    unsigned long long q_ll = 1000033ULL;  // About 1e6\n    int128 p = p_ll;\n    int128 q = q_ll;\n    \n    // Compute modulus: n = p * q (using 128-bit arithmetic)\n    int128 n = p * q;\n    \n    // Compute Euler's totient: phi = (p - 1) * (q - 1)\n    int128 phi = (p - 1) * (q - 1);\n    \n    // Choose a common public exponent e = 65537\n    int128 e = 65537;\n    \n    // Compute private exponent d as the modular inverse of e modulo phi\n    int128 d = mod_inverse(e, phi);\n    \n    // Choose a sample message to encrypt (must be less than n)\n    int128 message = 0xdeadbeef;\n    \n    // Encrypt: ciphertext = message^e mod n\n    int128 encrypted = mod_pow(message, e, n);\n    \n    // Decrypt: decrypted = ciphertext^d mod n\n    int128 decrypted = mod_pow(encrypted, d, n);\n    \n    // Print all outputs in hexadecimal\n    libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n    \n    libmin_printf(\"p: \");\n    print_hex_int128(p);\n    libmin_printf(\"\\nq: \");\n    print_hex_int128(q);\n    \n    libmin_printf(\"\\nn (modulus): \");\n    print_hex_int128(n);\n    \n    libmin_printf(\"\\nphi(n): \");\n    print_hex_int128(phi);\n    \n    libmin_printf(\"\\n\\nPublic exponent (e): \");\n    print_hex_int128(e);\n    \n    libmin_printf(\"\\nPrivate exponent (d): \");\n    print_hex_int128(d);\n    \n    libmin_printf(\"\\n\\nOriginal message: \");\n    print_hex_int128(message);\n    \n    libmin_printf(\"\\nEncrypted message: \");\n    print_hex_int128(encrypted);\n    \n    libmin_printf(\"\\nDecrypted message: \");\n    print_hex_int128(decrypted);\n    \n    libmin_printf(\"\\n\");\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "rsa-cipher/rsa-cipher.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // r15\n  __int64 v4; // r14\n  __int64 v5; // r13\n  __int64 v6; // r12\n  __int64 v7; // rbp\n  __int64 v8; // rbx\n  __int64 i; // rax\n  __int64 v10; // rdx\n  __int128 v11; // rdi\n  __int64 v12; // rcx\n  unsigned __int128 v13; // rax\n  __int64 v14; // r8\n  __int64 v15; // r9\n  unsigned __int128 v16; // kr00_16\n  unsigned __int128 v17; // kr10_16\n  __int64 v18; // r8\n  __int64 v19; // r9\n  __int64 v20; // r14\n  unsigned __int64 v21; // rbp\n  __int64 v22; // r15\n  unsigned __int64 v23; // rbx\n  __int64 v24; // rax\n  unsigned __int64 v25; // rdx\n  __int128 v26; // rt0\n  __int64 v27; // rax\n  unsigned __int64 v28; // rdx\n  int128 v29; // rdi\n  __int64 v30; // [rsp+0h] [rbp-58h]\n  __int64 v31; // [rsp+8h] [rbp-50h]\n  __int64 v32; // [rsp+10h] [rbp-48h] BYREF\n  __int64 v33; // [rsp+18h] [rbp-40h]\n\n  v3 = 0LL;\n  v4 = 1LL;\n  v5 = 0LL;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0xE8D6ABDCC0LL;\n  for ( i = _divmodti4(65537LL, 0LL, 0xE8D6ABDCC0LL, 0LL, &v32);\n        ;\n        i = _divmodti4(v11, *((_QWORD *)&v11 + 1), v32, v33, &v32) )\n  {\n    *(_QWORD *)&v11 = v8;\n    *((_QWORD *)&v11 + 1) = v7;\n    v8 = v32;\n    v7 = v33;\n    v12 = v6 * v10 + i * v5;\n    v13 = (unsigned __int64)v6 * (unsigned __int128)(unsigned __int64)i;\n    *((_QWORD *)&v13 + 1) += v12;\n    v16 = __PAIR128__(v3, v4) - v13;\n    v15 = v16 >> 64;\n    v14 = v16;\n    v4 = v6;\n    v3 = v5;\n    if ( 1 >= v11 )\n      break;\n    v6 = v14;\n    v5 = v15;\n  }\n  if ( v5 < 0 )\n  {\n    v17 = __PAIR128__(v5, v6) + 0xE8D6ABDCC0LL;\n    v5 = *((_QWORD *)&v17 + 1);\n    v6 = v17;\n  }\n  if ( (v6 != 0) + v5 <= 0 )\n  {\n    v20 = 1LL;\n    v21 = 0LL;\n  }\n  else\n  {\n    v18 = v6;\n    v19 = v5;\n    v20 = 1LL;\n    v21 = 0LL;\n    v22 = 0x8433C60BBLL;\n    v23 = 0LL;\n    do\n    {\n      if ( (v18 & 1) != 0 )\n      {\n        v30 = v18;\n        v31 = v19;\n        v24 = _modti3(v20 * v22, (__PAIR128__(v21, v20) * __PAIR128__(v23, v22)) >> 64, 0xE8D6CA6163LL, 0LL);\n        v18 = v30;\n        v19 = v31;\n        v20 = v24;\n        v21 = v25;\n      }\n      *(_QWORD *)&v26 = v18;\n      *((_QWORD *)&v26 + 1) = v19;\n      v27 = _modti3(\n              v22 * v22,\n              (((unsigned __int64)v22 * (unsigned __int128)(unsigned __int64)v22) >> 64) + 2 * v22 * v23,\n              0xE8D6CA6163LL,\n              0LL);\n      v19 = (unsigned __int128)(v26 >> 1) >> 64;\n      v18 = v26 >> 1;\n      v22 = v27;\n      v23 = v28;\n    }\n    while ( v26 >> 1 != 0 );\n  }\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(0xF4243uLL);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(0xF4261uLL);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(0xE8D6CA6163uLL);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(0xE8D6ABDCC0uLL);\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(0x10001uLL);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  *((_QWORD *)&v29 + 1) = v5;\n  *(_QWORD *)&v29 = v6;\n  print_hex_int128(v29);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(0xDEADBEEFuLL);\n  libmin_printf(\"\\nEncrypted message: \");\n  print_hex_int128(0x8433C60BBuLL);\n  libmin_printf(\"\\nDecrypted message: \");\n  *((_QWORD *)&v29 + 1) = v21;\n  *(_QWORD *)&v29 = v20;\n  print_hex_int128(v29);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long i;\n  long long v10;\n  __int128 v11;\n  long long v12;\n  unsigned __int128 v13;\n  long long v14;\n  long long v15;\n  unsigned __int128 v16;\n  unsigned __int128 v17;\n  long long v18;\n  long long v19;\n  long long v20;\n  unsigned long long v21;\n  long long v22;\n  unsigned long long v23;\n  long long v24;\n  unsigned long long v25;\n  __int128 v26;\n  long long v27;\n  unsigned long long v28;\n  int128 v29;\n  long long v30;\n  long long v31;\n  long long v32;\n  long long v33;\n  v3 = 0LL;\n  v4 = 1LL;\n  v5 = 0LL;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 1000034000064LL;\n  for (i = _divmodti4(65537LL, 0LL, 1000034000064LL, 0LL, &v32);;\n       i = _divmodti4(v11, *((uint64_t *)&v11 + 1), v32, v33, &v32)) {\n    *(uint64_t *)&v11 = v8;\n    *((uint64_t *)&v11 + 1) = v7;\n    v8 = v32;\n    v7 = v33;\n    v12 = v6 * v10 + i * v5;\n    v13 = (unsigned long long)v6 * (unsigned __int128)(unsigned long long)i;\n    *((uint64_t *)&v13 + 1) += v12;\n    v16 = __PAIR128__(v3, v4) - v13;\n    v15 = v16 >> 64;\n    v14 = v16;\n    v4 = v6;\n    v3 = v5;\n    if (1 >= v11) break;\n    v6 = v14;\n    v5 = v15;\n  }\n  if (v5 < 0) {\n    v17 = __PAIR128__(v5, v6) + 1000034000064LL;\n    v5 = *((uint64_t *)&v17 + 1);\n    v6 = v17;\n  }\n  if ((v6 != 0) + v5 <= 0) {\n    v20 = 1LL;\n    v21 = 0LL;\n  } else {\n    v18 = v6;\n    v19 = v5;\n    v20 = 1LL;\n    v21 = 0LL;\n    v22 = 35487768763LL;\n    v23 = 0LL;\n    do {\n      if ((v18 & 1) != 0) {\n        v30 = v18;\n        v31 = v19;\n        v24 = _modti3(v20 * v22,\n                      (__PAIR128__(v21, v20) * __PAIR128__(v23, v22)) >> 64,\n                      1000036000099LL, 0LL);\n        v18 = v30;\n        v19 = v31;\n        v20 = v24;\n        v21 = v25;\n      }\n      *(uint64_t *)&v26 = v18;\n      *((uint64_t *)&v26 + 1) = v19;\n      v27 = _modti3(v22 * v22,\n                    (((unsigned long long)v22 *\n                      (unsigned __int128)(unsigned long long)v22) >>\n                     64) +\n                        2 * v22 * v23,\n                    1000036000099LL, 0LL);\n      v19 = (unsigned __int128)(v26 >> 1) >> 64;\n      v18 = v26 >> 1;\n      v22 = v27;\n      v23 = v28;\n    } while (v26 >> 1 != 0);\n  }\n  libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n  libmin_printf(\"p: \");\n  print_hex_int128(1000003uLL);\n  libmin_printf(\"\\nq: \");\n  print_hex_int128(1000033uLL);\n  libmin_printf(\"\\nn (modulus): \");\n  print_hex_int128(1000036000099uLL);\n  libmin_printf(\"\\nphi(n): \");\n  print_hex_int128(1000034000064uLL);\n  libmin_printf(\"\\n\\nPublic exponent (e): \");\n  print_hex_int128(65537uLL);\n  libmin_printf(\"\\nPrivate exponent (d): \");\n  *((uint64_t *)&v29 + 1) = v5;\n  *(uint64_t *)&v29 = v6;\n  print_hex_int128(v29);\n  libmin_printf(\"\\n\\nOriginal message: \");\n  print_hex_int128(3735928559uLL);\n  libmin_printf(\"\\nEncrypted message: \");\n  print_hex_int128(35487768763uLL);\n  libmin_printf(\"\\nDecrypted message: \");\n  *((uint64_t *)&v29 + 1) = v21;\n  *(uint64_t *)&v29 = v20;\n  print_hex_int128(v29);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}", "binary": "rsa-cipher/rsa-cipher.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x10001,%edi\nxor    %r15d,%r15d\nxor    %esi,%esi\npush   %r14\nmov    $0x1,%r14d\npush   %r13\nxor    %r13d,%r13d\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nmovabs $0xe8d6abdcc0,%rbx\nsub    $0x28,%rsp\nlea    0x10(%rsp),%rax\nmov    %rax,(%rsp)\njmp    1146 <main+0x46>\nnop\nmov    %r8,%r12\nmov    %r9,%r13\nmov    (%rsp),%r8\nmov    %rbp,%rcx\nmov    %rbx,%rdx\ncall   3cc0 <__divmodti4>\nmov    %r13,%rcx\nmov    %rbx,%rdi\nmov    %rbp,%rsi\nimul   %r12,%rdx\nmov    0x10(%rsp),%rbx\nmov    0x18(%rsp),%rbp\nimul   %rax,%rcx\nadd    %rdx,%rcx\nmul    %r12\nadd    %rcx,%rdx\nsub    %rax,%r14\nmov    $0x1,%eax\nsbb    %rdx,%r15\ncmp    %rdi,%rax\nmov    $0x0,%eax\nmov    %r14,%r8\nsbb    %rsi,%rax\nmov    %r15,%r9\nmov    %r12,%r14\nmov    %r13,%r15\njl     1140 <main+0x40>\ntest   %r13,%r13\njns    11b4 <main+0xb4>\nmovabs $0xe8d6abdcc0,%rax\nxor    %edx,%edx\nadd    %rax,%r12\nadc    %rdx,%r13\nxor    %eax,%eax\ncmp    %r12,%rax\nsbb    %r13,%rax\njge    13a5 <main+0x2a5>\nmov    %r12,%r8\nmov    %r13,%r9\nmov    $0x1,%r14d\nxor    %ebp,%ebp\nmovabs $0x8433c60bb,%r15\nxor    %ebx,%ebx\nnopl   0x0(%rax)\ntest   $0x1,%r8b\nje     122b <main+0x12b>\nmov    %rbx,%rax\nimul   %r15,%rbp\nxor    %ecx,%ecx\nmov    %r8,(%rsp)\nimul   %r14,%rax\nmov    %r9,0x8(%rsp)\nlea    0x0(%rbp,%rax,1),%rsi\nmov    %r14,%rax\nmul    %r15\nadd    %rdx,%rsi\nmov    %rax,%rdi\nmovabs $0xe8d6ca6163,%rdx\ncall   3b20 <__modti3>\nmov    (%rsp),%r8\nmov    0x8(%rsp),%r9\nmov    %rax,%r14\nmov    %rdx,%rbp\nimul   %r15,%rbx\nmov    %r15,%rax\nshrd   $0x1,%r9,%r8\nxor    %ecx,%ecx\nmul    %r15\nsar    %r9\nmov    %r8,(%rsp)\nmov    %r9,0x8(%rsp)\nlea    (%rbx,%rbx,1),%rsi\nadd    %rdx,%rsi\nmov    %rax,%rdi\nmovabs $0xe8d6ca6163,%rdx\ncall   3b20 <__modti3>\nmov    0x8(%rsp),%r9\nmov    (%rsp),%r8\nmov    %rax,%r15\nmov    %rdx,%rbx\nmov    %r9,%rax\nor     %r8,%rax\njne    11e0 <main+0xe0>\nlea    0x3e35(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nlea    0x3d8f(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nxor    %esi,%esi\nmov    $0xf4243,%edi\ncall   16c0 <print_hex_int128>\nlea    0x3d79(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nxor    %esi,%esi\nmov    $0xf4261,%edi\ncall   16c0 <print_hex_int128>\nlea    0x3d64(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nxor    %esi,%esi\nmovabs $0xe8d6ca6163,%rdi\ncall   16c0 <print_hex_int128>\nlea    0x3d54(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nxor    %esi,%esi\nmovabs $0xe8d6abdcc0,%rdi\ncall   16c0 <print_hex_int128>\nlea    0x3d3f(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nxor    %esi,%esi\nmov    $0x10001,%edi\ncall   16c0 <print_hex_int128>\nlea    0x3d3d(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   16c0 <print_hex_int128>\nlea    0x3d3c(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nxor    %esi,%esi\nmov    $0xdeadbeef,%edi\ncall   16c0 <print_hex_int128>\nlea    0x3d37(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nxor    %esi,%esi\nmovabs $0x8433c60bb,%rdi\ncall   16c0 <print_hex_int128>\nlea    0x3d2d(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nmov    %rbp,%rsi\nmov    %r14,%rdi\ncall   16c0 <print_hex_int128>\nlea    0x3d29(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\ncall   3ae0 <libmin_success>\nadd    $0x28,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x1,%r14d\nxor    %ebp,%ebp\njmp    127c <main+0x17c>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "rsa-cipher/rsa-cipher.c", "function_name": "mod_inverse", "content": "// Extended Euclidean Algorithm: returns d such that (a*d) % mod == 1\nint128 mod_inverse(int128 a, int128 mod) {\n    int128 m0 = mod, t, q;\n    int128 x0 = 0, x1 = 1;\n    \n    if (mod == 1)\n        return 0;\n    \n    while (a > 1) {\n        q = a / mod;\n        t = mod;\n        mod = a % mod;\n        a = t;\n        \n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    \n    if (x1 < 0)\n        x1 += m0;\n    return x1;\n}\n"}, "pseudo": {"path": "rsa-cipher/rsa-cipher.host.O3.pseudo", "function_name": "mod_inverse", "address": "0x15a0", "label": "mod_inverse", "content": "int128 __fastcall mod_inverse(int128 a, int128 mod)\n{\n  __int64 v2; // rbx\n  __int64 v3; // rbp\n  __int64 v4; // r13\n  __int64 v5; // r12\n  __int64 v6; // r14\n  __int64 v7; // r15\n  __int64 i; // rax\n  __int64 v9; // rdx\n  unsigned __int128 v10; // kr00_16\n  __int64 v11; // r8\n  __int64 v12; // r9\n  __int128 v13; // rdi\n  __int64 v14; // rcx\n  unsigned __int128 v15; // rax\n  int128 result; // rax\n  unsigned __int128 v17; // kr10_16\n  __int64 v19; // [rsp+20h] [rbp-48h] BYREF\n  __int64 v20; // [rsp+28h] [rbp-40h]\n\n  if ( *((_QWORD *)&mod + 1) | (unsigned __int64)mod ^ 1 )\n  {\n    if ( 1 >= a )\n    {\n      v6 = 1LL;\n      v7 = 0LL;\n    }\n    else\n    {\n      v2 = mod;\n      v3 = *((_QWORD *)&mod + 1);\n      v4 = 0LL;\n      v5 = 1LL;\n      v6 = 0LL;\n      v7 = 0LL;\n      for ( i = _divmodti4(a, *((_QWORD *)&a + 1), mod, *((_QWORD *)&mod + 1), &v19);\n            ;\n            i = _divmodti4(v13, *((_QWORD *)&v13 + 1), v19, v20, &v19) )\n      {\n        v11 = v5;\n        *(_QWORD *)&v13 = v2;\n        v12 = v4;\n        *((_QWORD *)&v13 + 1) = v3;\n        v2 = v19;\n        v3 = v20;\n        v5 = v6;\n        v4 = v7;\n        v14 = v6 * v9 + i * v7;\n        v15 = (unsigned __int64)v6 * (unsigned __int128)(unsigned __int64)i;\n        *((_QWORD *)&v15 + 1) += v14;\n        if ( 1 >= v13 )\n          break;\n        v10 = __PAIR128__(v12, v11) - v15;\n        v7 = v10 >> 64;\n        v6 = v10;\n      }\n      if ( v7 < 0 )\n      {\n        v17 = mod + __PAIR128__(v7, v6);\n        v7 = (mod + __PAIR128__(v7, v6)) >> 64;\n        v6 = v17;\n      }\n    }\n  }\n  else\n  {\n    v6 = 0LL;\n    v7 = 0LL;\n  }\n  *(_QWORD *)&result = v6;\n  *((_QWORD *)&result + 1) = v7;\n  return result;\n}\n"}, "pseudo_normalize": "int128 mod_inverse(int128 a, int128 mod) {\n  long long v2;\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  long long i;\n  long long v9;\n  unsigned __int128 v10;\n  long long v11;\n  long long v12;\n  __int128 v13;\n  long long v14;\n  unsigned __int128 v15;\n  int128 result;\n  unsigned __int128 v17;\n  long long v19;\n  long long v20;\n  if (*((uint64_t *)&mod + 1) | (unsigned long long)mod ^ 1) {\n    if (1 >= a) {\n      v6 = 1LL;\n      v7 = 0LL;\n    } else {\n      v2 = mod;\n      v3 = *((uint64_t *)&mod + 1);\n      v4 = 0LL;\n      v5 = 1LL;\n      v6 = 0LL;\n      v7 = 0LL;\n      for (i = _divmodti4(a, *((uint64_t *)&a + 1), mod,\n                          *((uint64_t *)&mod + 1), &v19);\n           ; i = _divmodti4(v13, *((uint64_t *)&v13 + 1), v19, v20, &v19)) {\n        v11 = v5;\n        *(uint64_t *)&v13 = v2;\n        v12 = v4;\n        *((uint64_t *)&v13 + 1) = v3;\n        v2 = v19;\n        v3 = v20;\n        v5 = v6;\n        v4 = v7;\n        v14 = v6 * v9 + i * v7;\n        v15 = (unsigned long long)v6 * (unsigned __int128)(unsigned long long)i;\n        *((uint64_t *)&v15 + 1) += v14;\n        if (1 >= v13) break;\n        v10 = __PAIR128__(v12, v11) - v15;\n        v7 = v10 >> 64;\n        v6 = v10;\n      }\n      if (v7 < 0) {\n        v17 = mod + __PAIR128__(v7, v6);\n        v7 = (mod + __PAIR128__(v7, v6)) >> 64;\n        v6 = v17;\n      }\n    }\n  } else {\n    v6 = 0LL;\n    v7 = 0LL;\n  }\n  *(uint64_t *)&result = v6;\n  *((uint64_t *)&result + 1) = v7;\n  return result;\n}", "binary": "rsa-cipher/rsa-cipher.host.O3", "assembly": "<mod_inverse>:\nendbr64\npush   %r15\nmov    %rdx,%rax\nmov    %rcx,%rdx\npush   %r14\nmov    %rax,%rcx\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rax,0x10(%rsp)\nxor    $0x1,%rax\nor     %rdx,%rax\nmov    %rdx,0x18(%rsp)\nje     16a0 <mod_inverse+0x100>\nmov    $0x1,%eax\ncmp    %rdi,%rax\nmov    $0x0,%eax\nsbb    %rsi,%rax\njge    16b0 <mod_inverse+0x110>\nlea    0x20(%rsp),%rax\nmov    %rcx,%rbx\nmov    %rdx,%rbp\nxor    %r13d,%r13d\nmov    %rax,0x8(%rsp)\nmov    $0x1,%r12d\nxor    %r14d,%r14d\nxor    %r15d,%r15d\njmp    1616 <mod_inverse+0x76>\nnopl   0x0(%rax)\nmov    %r8,%r14\nmov    %r9,%r15\nmov    0x8(%rsp),%r8\nmov    %rbp,%rcx\nmov    %rbx,%rdx\ncall   3cc0 <__divmodti4>\nmov    %r15,%rcx\nmov    %r12,%r8\nmov    %rbx,%rdi\nimul   %r14,%rdx\nmov    %r13,%r9\nmov    %rbp,%rsi\nmov    0x20(%rsp),%rbx\nimul   %rax,%rcx\nmov    0x28(%rsp),%rbp\nmov    %r14,%r12\nmov    %r15,%r13\nadd    %rdx,%rcx\nmul    %r14\nadd    %rcx,%rdx\nsub    %rax,%r8\nmov    $0x1,%eax\nsbb    %rdx,%r9\ncmp    %rdi,%rax\nmov    $0x0,%eax\nsbb    %rsi,%rax\njl     1610 <mod_inverse+0x70>\ntest   %r15,%r15\njs     1690 <mod_inverse+0xf0>\nadd    $0x38,%rsp\nmov    %r14,%rax\nmov    %r15,%rdx\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nadd    0x10(%rsp),%r14\nadc    0x18(%rsp),%r15\njmp    1673 <mod_inverse+0xd3>\nnopl   0x0(%rax)\nxor    %r14d,%r14d\nxor    %r15d,%r15d\njmp    1673 <mod_inverse+0xd3>\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%r14d\nxor    %r15d,%r15d\njmp    1673 <mod_inverse+0xd3>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "rsa-cipher/rsa-cipher.c", "function_name": "mod_pow", "content": "// Fast modular exponentiation: computes (base^exp) mod mod\nint128 mod_pow(int128 base, int128 exp, int128 mod) {\n    int128 result = 1;\n    base = base % mod;\n    while (exp > 0) {\n        if (exp & 1)\n            result = (result * base) % mod;\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}\n"}, "pseudo": {"path": "rsa-cipher/rsa-cipher.host.O3.pseudo", "function_name": "mod_pow", "address": "0x14b0", "label": "mod_pow", "content": "__int64 __fastcall mod_pow(int128 base, int128 exp, int128 mod)\n{\n  __int64 v3; // r15\n  __int64 v4; // r14\n  __int64 v5; // r13\n  __int64 v6; // r12\n  unsigned __int64 v7; // rdx\n  __int64 v8; // r9\n  unsigned __int64 v9; // r8\n  __int64 v10; // rbx\n  unsigned __int64 v11; // rbp\n  __int64 v12; // rax\n  unsigned __int64 v13; // rdx\n  __int128 v14; // rt0\n  unsigned __int64 v15; // rdx\n  __int64 v17; // [rsp+0h] [rbp-48h]\n  unsigned __int64 v18; // [rsp+8h] [rbp-40h]\n\n  v3 = *((_QWORD *)&mod + 1);\n  v4 = mod;\n  v5 = *((_QWORD *)&exp + 1);\n  v6 = exp;\n  v8 = _modti3(base, *((_QWORD *)&base + 1), mod, *((_QWORD *)&mod + 1));\n  if ( (v6 != 0) + v5 <= 0 )\n    return 1LL;\n  v9 = v7;\n  v10 = 1LL;\n  v11 = 0LL;\n  do\n  {\n    if ( (v6 & 1) != 0 )\n    {\n      v18 = v9;\n      v17 = v8;\n      v12 = _modti3(v10 * v8, (__PAIR128__(v11, v10) * __PAIR128__(v9, v8)) >> 64, v4, v3);\n      v9 = v18;\n      v8 = v17;\n      v10 = v12;\n      v11 = v13;\n    }\n    *(_QWORD *)&v14 = v6;\n    *((_QWORD *)&v14 + 1) = v5;\n    v6 = v14 >> 1;\n    v5 >>= 1;\n    v8 = _modti3(\n           v8 * v8,\n           (((unsigned __int64)v8 * (unsigned __int128)(unsigned __int64)v8) >> 64) + 2 * v8 * v9,\n           v4,\n           v3);\n    v9 = v15;\n  }\n  while ( v14 >> 1 != 0 );\n  return v10;\n}\n"}, "pseudo_normalize": "long long mod_pow(int128 base, int128 exp, int128 mod) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  unsigned long long v7;\n  long long v8;\n  unsigned long long v9;\n  long long v10;\n  unsigned long long v11;\n  long long v12;\n  unsigned long long v13;\n  __int128 v14;\n  unsigned long long v15;\n  long long v17;\n  unsigned long long v18;\n  v3 = *((uint64_t *)&mod + 1);\n  v4 = mod;\n  v5 = *((uint64_t *)&exp + 1);\n  v6 = exp;\n  v8 = _modti3(base, *((uint64_t *)&base + 1), mod, *((uint64_t *)&mod + 1));\n  if ((v6 != 0) + v5 <= 0) return 1LL;\n  v9 = v7;\n  v10 = 1LL;\n  v11 = 0LL;\n  do {\n    if ((v6 & 1) != 0) {\n      v18 = v9;\n      v17 = v8;\n      v12 =\n          _modti3(v10 * v8, (__PAIR128__(v11, v10) * __PAIR128__(v9, v8)) >> 64,\n                  v4, v3);\n      v9 = v18;\n      v8 = v17;\n      v10 = v12;\n      v11 = v13;\n    }\n    *(uint64_t *)&v14 = v6;\n    *((uint64_t *)&v14 + 1) = v5;\n    v6 = v14 >> 1;\n    v5 >>= 1;\n    v8 = _modti3(\n        v8 * v8,\n        (((unsigned long long)v8 * (unsigned __int128)(unsigned long long)v8) >>\n         64) +\n            2 * v8 * v9,\n        v4, v3);\n    v9 = v15;\n  } while (v14 >> 1 != 0);\n  return v10;\n}", "binary": "rsa-cipher/rsa-cipher.host.O3", "assembly": "<mod_pow>:\nendbr64\npush   %r15\nmov    %r9,%r15\npush   %r14\nmov    %r8,%r14\npush   %r13\nmov    %rcx,%r13\nmov    %r9,%rcx\npush   %r12\nmov    %rdx,%r12\nmov    %r8,%rdx\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   3b20 <__modti3>\nmov    %rax,%r9\nxor    %eax,%eax\ncmp    %r12,%rax\nsbb    %r13,%rax\njge    1588 <mod_pow+0xd8>\nmov    %rdx,%r8\nmov    $0x1,%ebx\nxor    %ebp,%ebp\nnopl   0x0(%rax)\ntest   $0x1,%r12b\nje     153b <mod_pow+0x8b>\nmov    %r8,%rsi\nimul   %r9,%rbp\nmov    %rbx,%rax\nmov    %r15,%rcx\nimul   %rbx,%rsi\nmov    %r8,0x8(%rsp)\nmul    %r9\nmov    %r9,(%rsp)\nadd    %rbp,%rsi\nadd    %rdx,%rsi\nmov    %rax,%rdi\nmov    %r14,%rdx\ncall   3b20 <__modti3>\nmov    0x8(%rsp),%r8\nmov    (%rsp),%r9\nmov    %rax,%rbx\nmov    %rdx,%rbp\nimul   %r9,%r8\nmov    %r9,%rax\nmov    %r15,%rcx\nshrd   $0x1,%r13,%r12\nmul    %r9\nsar    %r13\nlea    (%r8,%r8,1),%rsi\nadd    %rdx,%rsi\nmov    %rax,%rdi\nmov    %r14,%rdx\ncall   3b20 <__modti3>\nmov    %rax,%r9\nmov    %r13,%rax\nmov    %rdx,%r8\nor     %r12,%rax\njne    14f8 <mod_pow+0x48>\nadd    $0x18,%rsp\nmov    %rbx,%rax\nmov    %rbp,%rdx\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nmov    $0x1,%ebx\nxor    %ebp,%ebp\njmp    1570 <mod_pow+0xc0>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "rsa-cipher/rsa-cipher.c", "function_name": "print_hex_int128", "content": "// Helper function to print a 128-bit number in hexadecimal.\n// It converts the number to a 32-digit hex string, then trims leading zeros.\nvoid print_hex_int128(int128 n) {\n    if (n == 0) {\n        libmin_printf(\"0x0\");\n        return;\n    }\n    if (n < 0) {\n        libmin_printf(\"-\");\n        n = -n;\n    }\n    \n    // 128 bits = 32 hex digits; extra one for the null terminator\n    char hex_digits[33];\n    hex_digits[32] = '\\0';\n    \n    // Fill the array from the least-significant nibble upward.\n    for (int i = 31; i >= 0; i--) {\n        hex_digits[i] = \"0123456789abcdef\"[n & 0xF];\n        n >>= 4;\n    }\n    \n    // Skip over any leading zeros for a cleaner output.\n    int j = 0;\n    while (hex_digits[j] == '0' && hex_digits[j+1] != '\\0') {\n        j++;\n    }\n    libmin_printf(\"0x%s\", &hex_digits[j]);\n}\n"}, "pseudo": {"path": "rsa-cipher/rsa-cipher.host.O3.pseudo", "function_name": "print_hex_int128", "address": "0x16c0", "label": "print_hex_int128", "content": "void __fastcall print_hex_int128(int128 n)\n{\n  __int128 v1; // kr00_16\n  char *v2; // rax\n  char *v3; // rdx\n  char v4; // dl\n  __int64 v5; // rax\n  __int64 v6; // rcx\n  char hex_digits[40]; // [rsp+0h] [rbp-48h] BYREF\n  unsigned __int64 v8; // [rsp+28h] [rbp-20h]\n\n  v8 = __readfsqword(0x28u);\n  if ( n == 0 )\n  {\n    libmin_printf(\"0x0\");\n  }\n  else\n  {\n    v1 = n;\n    if ( n < 0 )\n    {\n      libmin_printf(\"-\");\n      v1 = -n;\n    }\n    hex_digits[32] = 0;\n    v2 = &hex_digits[31];\n    do\n    {\n      *v2 = a0123456789abcd[v1 & 0xF];\n      v3 = v2--;\n      v1 >>= 4;\n    }\n    while ( v3 != hex_digits );\n    v4 = hex_digits[0];\n    v5 = 0LL;\n    do\n    {\n      v6 = (int)v5;\n      if ( v4 != 48 )\n        break;\n      v4 = hex_digits[++v5];\n    }\n    while ( v4 );\n    libmin_printf(\"0x%s\", &hex_digits[v6]);\n  }\n}\n"}, "pseudo_normalize": "void print_hex_int128(int128 n) {\n  __int128 v1;\n  char *v2;\n  char *v3;\n  char v4;\n  long long v5;\n  long long v6;\n  char hex_digits[40];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  if (n == 0) {\n    libmin_printf(\"0\");\n  } else {\n    v1 = n;\n    if (n < 0) {\n      libmin_printf(\"-\");\n      v1 = -n;\n    }\n    hex_digits[32] = 0;\n    v2 = &hex_digits[31];\n    do {\n      *v2 = a0123456789abcd[v1 & 15];\n      v3 = v2--;\n      v1 >>= 4;\n    } while (v3 != hex_digits);\n    v4 = hex_digits[0];\n    v5 = 0LL;\n    do {\n      v6 = (int)v5;\n      if (v4 != 48) break;\n      v4 = hex_digits[++v5];\n    } while (v4);\n    libmin_printf(\"0x%s\", &hex_digits[v6]);\n  }\n}", "binary": "rsa-cipher/rsa-cipher.host.O3", "assembly": "<print_hex_int128>:\nendbr64\npush   %r13\npush   %r12\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nmov    %rsi,%rax\nor     %rdi,%rax\nje     177e <print_hex_int128+0xbe>\nmov    %rdi,%r12\nmov    %rsi,%r13\ntest   %rsi,%rsi\njs     17a4 <print_hex_int128+0xe4>\nmovb   $0x0,0x20(%rsp)\nmov    %rsp,%rsi\nlea    0x1f(%rsp),%rax\nlea    0x3906(%rip),%rcx\nnopl   0x0(%rax)\nmov    %r12,%rdx\nshrd   $0x4,%r13,%r12\nand    $0xf,%edx\nsar    $0x4,%r13\nmovzbl (%rcx,%rdx,1),%edx\nmov    %dl,(%rax)\nmov    %rax,%rdx\nsub    $0x1,%rax\ncmp    %rsi,%rdx\njne    1710 <print_hex_int128+0x50>\nmovzbl (%rsp),%edx\nxor    %eax,%eax\nlea    0x1(%rsp),%rdi\njmp    174c <print_hex_int128+0x8c>\nxchg   %ax,%ax\nmovzbl (%rdi,%rax,1),%edx\nadd    $0x1,%rax\ntest   %dl,%dl\nje     1754 <print_hex_int128+0x94>\nmovslq %eax,%rcx\ncmp    $0x30,%dl\nje     1740 <print_hex_int128+0x80>\nadd    %rcx,%rsi\nxor    %eax,%eax\nlea    0x38aa(%rip),%rdi\ncall   38a0 <libmin_printf>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    17c1 <print_hex_int128+0x101>\nadd    $0x38,%rsp\npop    %r12\npop    %r13\nret\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    17c1 <print_hex_int128+0x101>\nadd    $0x38,%rsp\nlea    0x386b(%rip),%rdi\nxor    %eax,%eax\npop    %r12\npop    %r13\njmp    38a0 <libmin_printf>\nxor    %eax,%eax\nlea    0x385b(%rip),%rdi\ncall   38a0 <libmin_printf>\nneg    %r12\nadc    $0x0,%r13\nneg    %r13\njmp    16f5 <print_hex_int128+0x35>\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "conflict", "content": "// Function to check if the current assignment causes a conflict.\n// For each clause, if all literals are assigned and none is true, then a conflict exists.\nint conflict() {\n    for (int i = 0; i < NUM_CLAUSES; i++) {\n        int satisfied = 0;\n        int fully_assigned = 1;\n        for (int j = 0; j < MAX_LITERALS && formula[i][j] != 0; j++) {\n            int lit = formula[i][j];\n            int var = (lit > 0) ? lit : -lit;\n            int val = assignment[var];\n            if (val == UNASSIGNED) {\n                fully_assigned = 0;\n            } else {\n                // For a positive literal, it is satisfied if the value is 1;\n                // for a negative literal, it is satisfied if the value is 0.\n                if ((lit > 0 && val == 1) || (lit < 0 && val == 0)) {\n                    satisfied = 1;\n                    break;  // This clause is satisfied.\n                }\n            }\n        }\n        // If a clause is fully assigned and not satisfied, there is a conflict.\n        if (!satisfied && fully_assigned)\n            return 1;\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O3.pseudo", "function_name": "conflict", "address": "0x1260", "label": "conflict", "content": "int __cdecl conflict()\n{\n  int *v0; // rax\n  int v1; // edx\n  char v2; // r8\n  int v3; // ecx\n  int v4; // ecx\n  int v5; // edx\n  int v6; // ecx\n  int v7; // ecx\n  int v8; // edx\n  int v9; // ecx\n  int v10; // ecx\n  int v11; // edx\n  int v12; // ecx\n  int v13; // ecx\n\n  v0 = formula[0];\n  while ( 1 )\n  {\n    v11 = *v0;\n    if ( !*v0 )\n      return 1;\n    v12 = -v11;\n    if ( v11 > 0 )\n      v12 = *v0;\n    v13 = assignment[v12];\n    if ( v13 == -1 )\n    {\n      v1 = v0[1];\n      v2 = 0;\n      if ( !v1 )\n        goto LABEL_32;\n    }\n    else\n    {\n      if ( v11 > 0 && v13 == 1 || v11 < 0 && !v13 )\n        goto LABEL_32;\n      v1 = v0[1];\n      if ( !v1 )\n        return 1;\n      v2 = 1;\n    }\n    v3 = -v1;\n    if ( v1 > 0 )\n      v3 = v1;\n    v4 = assignment[v3];\n    if ( v4 == -1 )\n    {\n      v5 = v0[2];\n      v2 = 0;\n      if ( !v5 )\n        goto LABEL_32;\n    }\n    else\n    {\n      if ( v1 > 0 && v4 == 1 || v1 < 0 && !v4 )\n        goto LABEL_32;\n      v5 = v0[2];\n      if ( !v5 )\n        goto LABEL_31;\n    }\n    v6 = -v5;\n    if ( v5 > 0 )\n      v6 = v5;\n    v7 = assignment[v6];\n    if ( v7 == -1 )\n    {\n      v8 = v0[3];\n      v2 = 0;\n      if ( !v8 )\n        goto LABEL_32;\n    }\n    else\n    {\n      if ( v5 > 0 && v7 == 1 || v5 < 0 && !v7 )\n        goto LABEL_32;\n      v8 = v0[3];\n      if ( !v8 )\n        goto LABEL_31;\n    }\n    v9 = -v8;\n    if ( v8 > 0 )\n      v9 = v8;\n    v10 = assignment[v9];\n    if ( v10 == -1 || v8 > 0 && v10 == 1 || v8 < 0 && !v10 )\n      goto LABEL_32;\nLABEL_31:\n    if ( v2 )\n      return 1;\nLABEL_32:\n    v0 += 4;\n    if ( formula[10] == v0 )\n      return 0;\n  }\n}\n"}, "pseudo_normalize": "int conflict() {\n  int *v0;\n  int v1;\n  char v2;\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  v0 = formula[0];\n  while (1) {\n    v11 = *v0;\n    if (!*v0) return 1;\n    v12 = -v11;\n    if (v11 > 0) v12 = *v0;\n    v13 = assignment[v12];\n    if (v13 == -1) {\n      v1 = v0[1];\n      v2 = 0;\n      if (!v1) goto LABEL_32;\n    } else {\n      if (v11 > 0 && v13 == 1 || v11 < 0 && !v13) goto LABEL_32;\n      v1 = v0[1];\n      if (!v1) return 1;\n      v2 = 1;\n    }\n    v3 = -v1;\n    if (v1 > 0) v3 = v1;\n    v4 = assignment[v3];\n    if (v4 == -1) {\n      v5 = v0[2];\n      v2 = 0;\n      if (!v5) goto LABEL_32;\n    } else {\n      if (v1 > 0 && v4 == 1 || v1 < 0 && !v4) goto LABEL_32;\n      v5 = v0[2];\n      if (!v5) goto LABEL_31;\n    }\n    v6 = -v5;\n    if (v5 > 0) v6 = v5;\n    v7 = assignment[v6];\n    if (v7 == -1) {\n      v8 = v0[3];\n      v2 = 0;\n      if (!v8) goto LABEL_32;\n    } else {\n      if (v5 > 0 && v7 == 1 || v5 < 0 && !v7) goto LABEL_32;\n      v8 = v0[3];\n      if (!v8) goto LABEL_31;\n    }\n    v9 = -v8;\n    if (v8 > 0) v9 = v8;\n    v10 = assignment[v9];\n    if (v10 == -1 || v8 > 0 && v10 == 1 || v8 < 0 && !v10) goto LABEL_32;\n  LABEL_31:\n    if (v2) return 1;\n  LABEL_32:\n    v0 += 4;\n    if (formula[10] == v0) return 0;\n  }\n}", "binary": "sat-solver/sat-solver.host.O3", "assembly": "<conflict>:\nendbr64\nlea    0x2e35(%rip),%rax\nlea    0x500e(%rip),%rsi\nlea    0xa0(%rax),%rdi\njmp    1337 <conflict+0xd7>\nxchg   %ax,%ax\ntest   %edx,%edx\njle    128d <conflict+0x2d>\ncmp    $0x1,%ecx\nje     132e <conflict+0xce>\ntest   %edx,%edx\njns    1299 <conflict+0x39>\ntest   %ecx,%ecx\nje     132e <conflict+0xce>\nmov    0x4(%rax),%edx\ntest   %edx,%edx\nje     1398 <conflict+0x138>\nmov    $0x1,%r8d\nmov    %edx,%ecx\nneg    %ecx\ncmovs  %edx,%ecx\nmovslq %ecx,%rcx\nmov    (%rsi,%rcx,4),%ecx\ncmp    $0xffffffff,%ecx\nje     1368 <conflict+0x108>\ntest   %edx,%edx\njle    12c9 <conflict+0x69>\ncmp    $0x1,%ecx\nje     132e <conflict+0xce>\ntest   %edx,%edx\njns    12d1 <conflict+0x71>\ntest   %ecx,%ecx\nje     132e <conflict+0xce>\nmov    0x8(%rax),%edx\ntest   %edx,%edx\nje     1329 <conflict+0xc9>\nmov    %edx,%ecx\nneg    %ecx\ncmovs  %edx,%ecx\nmovslq %ecx,%rcx\nmov    (%rsi,%rcx,4),%ecx\ncmp    $0xffffffff,%ecx\nje     1380 <conflict+0x120>\ntest   %edx,%edx\njle    12f7 <conflict+0x97>\ncmp    $0x1,%ecx\nje     132e <conflict+0xce>\ntest   %edx,%edx\njns    12ff <conflict+0x9f>\ntest   %ecx,%ecx\nje     132e <conflict+0xce>\nmov    0xc(%rax),%edx\ntest   %edx,%edx\nje     1329 <conflict+0xc9>\nmov    %edx,%ecx\nneg    %ecx\ncmovs  %edx,%ecx\nmovslq %ecx,%rcx\nmov    (%rsi,%rcx,4),%ecx\ncmp    $0xffffffff,%ecx\nje     132e <conflict+0xce>\ntest   %edx,%edx\njle    1321 <conflict+0xc1>\ncmp    $0x1,%ecx\nje     132e <conflict+0xce>\ntest   %edx,%edx\njns    1329 <conflict+0xc9>\ntest   %ecx,%ecx\nje     132e <conflict+0xce>\ntest   %r8b,%r8b\njne    1398 <conflict+0x138>\nadd    $0x10,%rax\ncmp    %rax,%rdi\nje     1390 <conflict+0x130>\nmov    (%rax),%edx\ntest   %edx,%edx\nje     1398 <conflict+0x138>\nmov    %edx,%ecx\nneg    %ecx\ncmovs  %edx,%ecx\nmovslq %ecx,%rcx\nmov    (%rsi,%rcx,4),%ecx\ncmp    $0xffffffff,%ecx\njne    1280 <conflict+0x20>\nmov    0x4(%rax),%edx\nxor    %r8d,%r8d\ntest   %edx,%edx\njne    12aa <conflict+0x4a>\njmp    132e <conflict+0xce>\nnopl   0x0(%rax,%rax,1)\nmov    0x8(%rax),%edx\nxor    %r8d,%r8d\ntest   %edx,%edx\njne    12d8 <conflict+0x78>\njmp    132e <conflict+0xce>\nnopl   0x0(%rax,%rax,1)\nmov    0xc(%rax),%edx\nxor    %r8d,%r8d\ntest   %edx,%edx\njne    1306 <conflict+0xa6>\njmp    132e <conflict+0xce>\nxor    %eax,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "main", "content": "int main() {\n    // Initialize all variables to UNASSIGNED.\n    for (int i = 1; i <= NUM_VARS; i++) {\n        assignment[i] = UNASSIGNED;\n    }\n    \n    printFormula();\n\n    if (solveSAT(1)) {\n        libmin_printf(\"SAT solution found:\\n\");\n        printAssignment();\n        libtarg_success();\n    } else {\n        libmin_printf(\"No SAT solution exists.\\n\");\n        libtarg_fail(1);\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  *(_OWORD *)&assignment[1] = -1LL;\n  *(_OWORD *)&assignment[5] = -1LL;\n  printFormula();\n  if ( solveSAT(1) )\n  {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  *(long double *)&assignment[1] = -1LL;\n  *(long double *)&assignment[5] = -1LL;\n  printFormula();\n  if (solveSAT(1)) {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}", "binary": "sat-solver/sat-solver.host.O3", "assembly": "<main>:\nendbr64\npush   %rax\npop    %rax\npcmpeqd %xmm0,%xmm0\nxor    %eax,%eax\nsub    $0x8,%rsp\nmovups %xmm0,0x516d(%rip)\nmovups %xmm0,0x5176(%rip)\ncall   1680 <printFormula>\nmov    $0x1,%edi\ncall   13a0 <solveSAT>\ntest   %eax,%eax\nje     114b <main+0x4b>\nlea    0x2efb(%rip),%rdi\nxor    %eax,%eax\ncall   3870 <libmin_printf>\nxor    %eax,%eax\ncall   1730 <printAssignment>\ncall   17a0 <libtarg_success>\nlea    0x2ef6(%rip),%rdi\nxor    %eax,%eax\ncall   3870 <libmin_printf>\nmov    $0x1,%edi\ncall   17c0 <libtarg_fail>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "printAssignment", "content": "// Utility to print the variable assignments once a solution is found.\nvoid printAssignment() {\n    libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n    for (int i = 1; i <= NUM_VARS; i++) {\n        libmin_printf(\"x%d = %s\\n\", i, (assignment[i] == 1 ? \"true\" : \"false\"));\n    }\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O3.pseudo", "function_name": "printAssignment", "address": "0x1730", "label": "printAssignment", "content": "void __cdecl printAssignment()\n{\n  __int64 v0; // rbx\n  int v1; // esi\n  const char *v2; // rdx\n\n  v0 = 1LL;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  do\n  {\n    v1 = v0;\n    v2 = \"true\";\n    if ( assignment[v0] != 1 )\n      v2 = \"false\";\n    ++v0;\n    libmin_printf(\"x%d = %s\\n\", v1, v2);\n  }\n  while ( v0 != 9 );\n}\n"}, "pseudo_normalize": "void printAssignment() {\n  long long v0;\n  int v1;\n  const char *v2;\n  v0 = 1LL;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  do {\n    v1 = v0;\n    v2 = \"true\";\n    if (assignment[v0] != 1) v2 = \"false\";\n    ++v0;\n    libmin_printf(\"x%d = %s\\n\", v1, v2);\n  } while (v0 != 9);\n}", "binary": "sat-solver/sat-solver.host.O3", "assembly": "<printAssignment>:\nendbr64\npush   %r14\nlea    0x292b(%rip),%rdi\nxor    %eax,%eax\nlea    0x28d8(%rip),%r14\npush   %r13\nlea    0x28de(%rip),%r13\npush   %r12\nlea    0x4b28(%rip),%r12\npush   %rbp\nlea    0x28c3(%rip),%rbp\npush   %rbx\nmov    $0x1,%ebx\ncall   3870 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\ncmpl   $0x1,(%r12,%rbx,4)\nmov    %ebx,%esi\nmov    %r14,%rdx\nje     177f <printAssignment+0x4f>\nmov    %r13,%rdx\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   3870 <libmin_printf>\ncmp    $0x9,%rbx\njne    1770 <printAssignment+0x40>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "printFormula", "content": "// Utility to print the CNF formula.\nvoid printFormula() {\n    libmin_printf(\"CNF Formula:\\n\");\n    for (int i = 0; i < NUM_CLAUSES; i++) {\n        libmin_printf(\"(\");\n        for (int j = 0; j < MAX_LITERALS && formula[i][j] != 0; j++) {\n            int lit = formula[i][j];\n            if (lit < 0)\n                libmin_printf(\"x%d \", -lit);\n            else\n                libmin_printf(\"x%d \", lit);\n        }\n        libmin_printf(\")\\n\");\n    }\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O3.pseudo", "function_name": "printFormula", "address": "0x1680", "label": "printFormula", "content": "void __cdecl printFormula()\n{\n  char *v0; // rbx\n  char *v1; // r15\n  int v2; // esi\n\n  v0 = (char *)formula[1];\n  libmin_printf(\"CNF Formula:\\n\");\n  do\n  {\n    v1 = v0 - 16;\n    libmin_printf(\"(\");\n    do\n    {\n      v2 = *(_DWORD *)v1;\n      if ( !*(_DWORD *)v1 )\n        break;\n      if ( v2 < 0 )\n        libmin_printf((char *)&byte_4014, (unsigned int)-v2);\n      else\n        libmin_printf(\"x%d \", v2);\n      v1 += 4;\n    }\n    while ( v1 != v0 );\n    v0 += 16;\n    libmin_printf(\")\\n\");\n  }\n  while ( v0 != \"n for %lu us.\\n\" );\n}\n"}, "pseudo_normalize": "void printFormula() {\n  char *v0;\n  char *v1;\n  int v2;\n  v0 = (char *)formula[1];\n  libmin_printf(\"CNF Formula:\\n\");\n  do {\n    v1 = v0 - 16;\n    libmin_printf(\"(\");\n    do {\n      v2 = *(uint32_t *)v1;\n      if (!*(uint32_t *)v1) break;\n      if (v2 < 0)\n        libmin_printf((char *)&byte_4014, (unsigned int)-v2);\n      else\n        libmin_printf(\"x%d \", v2);\n      v1 += 4;\n    } while (v1 != v0);\n    v0 += 16;\n    libmin_printf(\")\\n\");\n  } while (v0 != \"n for %lu us.\\n\");\n}", "binary": "sat-solver/sat-solver.host.O3", "assembly": "<printFormula>:\nendbr64\npush   %r15\nlea    0x2977(%rip),%rdi\nxor    %eax,%eax\npush   %r14\nlea    0x297a(%rip),%r14\npush   %r13\nlea    0x297a(%rip),%r13\npush   %r12\nlea    0x296a(%rip),%r12\npush   %rbp\nlea    0x2964(%rip),%rbp\npush   %rbx\nlea    0x29f6(%rip),%rbx\nsub    $0x8,%rsp\ncall   3870 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    -0x10(%rbx),%r15\ncall   3870 <libmin_printf>\nmov    (%r15),%esi\ntest   %esi,%esi\nje     16f2 <printFormula+0x72>\njs     1720 <printFormula+0xa0>\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   3870 <libmin_printf>\nadd    $0x4,%r15\ncmp    %rbx,%r15\njne    16d6 <printFormula+0x56>\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x10,%rbx\ncall   3870 <libmin_printf>\nlea    0x2a49(%rip),%rax\ncmp    %rax,%rbx\njne    16c8 <printFormula+0x48>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nneg    %esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3870 <libmin_printf>\njmp    16e9 <printFormula+0x69>\nxchg   %ax,%ax\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "solveSAT", "content": "// Recursive backtracking solver.\n// 'var' is the current variable index to assign (starting at 1).\n// Returns 1 if a satisfying assignment is found.\nint solveSAT(int var) {\n    if (var > NUM_VARS) {\n        // All variables are assigned.\n        return conflict() ? 0 : 1;\n    }\n    // Try both truth values: 0 (false) and 1 (true).\n    for (int v = 0; v < 2; v++) {\n        assignment[var] = v;\n        if (!conflict() && solveSAT(var + 1))\n            return 1;\n    }\n    assignment[var] = UNASSIGNED;  // Backtrack.\n    return 0;\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O3.pseudo", "function_name": "solveSAT", "address": "0x13a0", "label": "solveSAT", "content": "int __fastcall solveSAT(int var)\n{\n  int v1; // r12d\n  int *v2; // rax\n  int v3; // edx\n  char v4; // si\n  int v5; // ecx\n  int v6; // ecx\n  int v7; // edx\n  int v8; // ecx\n  int v9; // ecx\n  int v10; // edx\n  int v11; // ecx\n  int v12; // ecx\n  int v13; // edx\n  int v14; // ecx\n  int v15; // ecx\n  int result; // eax\n  int *v17; // rdx\n  char v18; // r8\n  int v19; // ecx\n  int v20; // ecx\n  int v21; // eax\n  int v22; // ecx\n  int v23; // ecx\n  int v24; // eax\n  int v25; // ecx\n  int v26; // ecx\n  int v27; // ecx\n  int v28; // ecx\n\n  if ( var > 8 )\n  {\n    v17 = formula[0];\n    while ( 1 )\n    {\n      result = *v17;\n      if ( !*v17 )\n        return result;\n      v27 = -result;\n      if ( result > 0 )\n        v27 = *v17;\n      v28 = assignment[v27];\n      if ( v28 == -1 )\n      {\n        result = v17[1];\n        v18 = 0;\n        if ( !result )\n          goto LABEL_80;\n      }\n      else\n      {\n        if ( result > 0 && v28 == 1 || result < 0 && !v28 )\n          goto LABEL_80;\n        result = v17[1];\n        if ( !result )\n          return result;\n        v18 = 1;\n      }\n      v19 = -result;\n      if ( result > 0 )\n        v19 = result;\n      v20 = assignment[v19];\n      if ( v20 == -1 )\n      {\n        v21 = v17[2];\n        v18 = 0;\n        if ( !v21 )\n          goto LABEL_80;\n      }\n      else\n      {\n        if ( result > 0 && v20 == 1 || result < 0 && !v20 )\n          goto LABEL_80;\n        v21 = v17[2];\n        if ( !v21 )\n          goto LABEL_79;\n      }\n      v22 = -v21;\n      if ( v21 > 0 )\n        v22 = v21;\n      v23 = assignment[v22];\n      if ( v23 == -1 )\n      {\n        v24 = v17[3];\n        v18 = 0;\n        if ( !v24 )\n          goto LABEL_80;\n      }\n      else\n      {\n        if ( v21 > 0 && v23 == 1 || v21 < 0 && !v23 )\n          goto LABEL_80;\n        v24 = v17[3];\n        if ( !v24 )\n          goto LABEL_79;\n      }\n      v25 = -v24;\n      if ( v24 > 0 )\n        v25 = v24;\n      v26 = assignment[v25];\n      if ( v26 == -1 || v24 > 0 && v26 == 1 || v24 < 0 && !v26 )\n        goto LABEL_80;\nLABEL_79:\n      if ( v18 )\n        return 0;\nLABEL_80:\n      v17 += 4;\n      if ( formula[10] == v17 )\n        return 1;\n    }\n  }\n  v1 = 0;\nLABEL_3:\n  assignment[var] = v1;\n  v2 = formula[0];\n  do\n  {\n    v13 = *v2;\n    if ( !*v2 )\n    {\nLABEL_46:\n      if ( v1 == 1 )\n      {\n        assignment[var] = -1;\n        return 0;\n      }\n      v1 = 1;\n      goto LABEL_3;\n    }\n    v14 = -v13;\n    if ( v13 > 0 )\n      v14 = *v2;\n    v15 = assignment[v14];\n    if ( v15 == -1 )\n    {\n      v3 = v2[1];\n      v4 = 0;\n      if ( !v3 )\n        goto LABEL_34;\n    }\n    else\n    {\n      if ( v13 > 0 && v15 == 1 || v13 < 0 && !v15 )\n        goto LABEL_34;\n      v3 = v2[1];\n      if ( !v3 )\n        goto LABEL_46;\n      v4 = 1;\n    }\n    v5 = -v3;\n    if ( v3 > 0 )\n      v5 = v3;\n    v6 = assignment[v5];\n    if ( v6 == -1 )\n    {\n      v7 = v2[2];\n      v4 = 0;\n      if ( !v7 )\n        goto LABEL_34;\n    }\n    else\n    {\n      if ( v3 > 0 && v6 == 1 || v3 < 0 && !v6 )\n        goto LABEL_34;\n      v7 = v2[2];\n      if ( !v7 )\n        goto LABEL_33;\n    }\n    v8 = -v7;\n    if ( v7 > 0 )\n      v8 = v7;\n    v9 = assignment[v8];\n    if ( v9 == -1 )\n    {\n      v10 = v2[3];\n      v4 = 0;\n      if ( !v10 )\n        goto LABEL_34;\nLABEL_26:\n      v11 = -v10;\n      if ( v10 > 0 )\n        v11 = v10;\n      v12 = assignment[v11];\n      if ( v12 == -1 || v10 > 0 && v12 == 1 || v10 < 0 && !v12 )\n        goto LABEL_34;\n      goto LABEL_33;\n    }\n    if ( v7 > 0 && v9 == 1 || v7 < 0 && !v9 )\n      goto LABEL_34;\n    v10 = v2[3];\n    if ( v10 )\n      goto LABEL_26;\nLABEL_33:\n    if ( v4 )\n      goto LABEL_46;\nLABEL_34:\n    v2 += 4;\n  }\n  while ( \"PERF: program ran for %lu us.\\n\" != (char *)v2 );\n  if ( !solveSAT(var + 1) )\n    goto LABEL_46;\n  return 1;\n}\n"}, "pseudo_normalize": "int solveSAT(int var) {\n  int v1;\n  int *v2;\n  int v3;\n  char v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  int v15;\n  int result;\n  int *v17;\n  char v18;\n  int v19;\n  int v20;\n  int v21;\n  int v22;\n  int v23;\n  int v24;\n  int v25;\n  int v26;\n  int v27;\n  int v28;\n  if (var > 8) {\n    v17 = formula[0];\n    while (1) {\n      result = *v17;\n      if (!*v17) return result;\n      v27 = -result;\n      if (result > 0) v27 = *v17;\n      v28 = assignment[v27];\n      if (v28 == -1) {\n        result = v17[1];\n        v18 = 0;\n        if (!result) goto LABEL_80;\n      } else {\n        if (result > 0 && v28 == 1 || result < 0 && !v28) goto LABEL_80;\n        result = v17[1];\n        if (!result) return result;\n        v18 = 1;\n      }\n      v19 = -result;\n      if (result > 0) v19 = result;\n      v20 = assignment[v19];\n      if (v20 == -1) {\n        v21 = v17[2];\n        v18 = 0;\n        if (!v21) goto LABEL_80;\n      } else {\n        if (result > 0 && v20 == 1 || result < 0 && !v20) goto LABEL_80;\n        v21 = v17[2];\n        if (!v21) goto LABEL_79;\n      }\n      v22 = -v21;\n      if (v21 > 0) v22 = v21;\n      v23 = assignment[v22];\n      if (v23 == -1) {\n        v24 = v17[3];\n        v18 = 0;\n        if (!v24) goto LABEL_80;\n      } else {\n        if (v21 > 0 && v23 == 1 || v21 < 0 && !v23) goto LABEL_80;\n        v24 = v17[3];\n        if (!v24) goto LABEL_79;\n      }\n      v25 = -v24;\n      if (v24 > 0) v25 = v24;\n      v26 = assignment[v25];\n      if (v26 == -1 || v24 > 0 && v26 == 1 || v24 < 0 && !v26) goto LABEL_80;\n    LABEL_79:\n      if (v18) return 0;\n    LABEL_80:\n      v17 += 4;\n      if (formula[10] == v17) return 1;\n    }\n  }\n  v1 = 0;\nLABEL_3:\n  assignment[var] = v1;\n  v2 = formula[0];\n  do {\n    v13 = *v2;\n    if (!*v2) {\n    LABEL_46:\n      if (v1 == 1) {\n        assignment[var] = -1;\n        return 0;\n      }\n      v1 = 1;\n      goto LABEL_3;\n    }\n    v14 = -v13;\n    if (v13 > 0) v14 = *v2;\n    v15 = assignment[v14];\n    if (v15 == -1) {\n      v3 = v2[1];\n      v4 = 0;\n      if (!v3) goto LABEL_34;\n    } else {\n      if (v13 > 0 && v15 == 1 || v13 < 0 && !v15) goto LABEL_34;\n      v3 = v2[1];\n      if (!v3) goto LABEL_46;\n      v4 = 1;\n    }\n    v5 = -v3;\n    if (v3 > 0) v5 = v3;\n    v6 = assignment[v5];\n    if (v6 == -1) {\n      v7 = v2[2];\n      v4 = 0;\n      if (!v7) goto LABEL_34;\n    } else {\n      if (v3 > 0 && v6 == 1 || v3 < 0 && !v6) goto LABEL_34;\n      v7 = v2[2];\n      if (!v7) goto LABEL_33;\n    }\n    v8 = -v7;\n    if (v7 > 0) v8 = v7;\n    v9 = assignment[v8];\n    if (v9 == -1) {\n      v10 = v2[3];\n      v4 = 0;\n      if (!v10) goto LABEL_34;\n    LABEL_26:\n      v11 = -v10;\n      if (v10 > 0) v11 = v10;\n      v12 = assignment[v11];\n      if (v12 == -1 || v10 > 0 && v12 == 1 || v10 < 0 && !v12) goto LABEL_34;\n      goto LABEL_33;\n    }\n    if (v7 > 0 && v9 == 1 || v7 < 0 && !v9) goto LABEL_34;\n    v10 = v2[3];\n    if (v10) goto LABEL_26;\n  LABEL_33:\n    if (v4) goto LABEL_46;\n  LABEL_34:\n    v2 += 4;\n  } while (\"PERF: program ran for %lu us.\\n\" != (char *)v2);\n  if (!solveSAT(var + 1)) goto LABEL_46;\n  return 1;\n}", "binary": "sat-solver/sat-solver.host.O3", "assembly": "<solveSAT>:\nendbr64\ncmp    $0x8,%edi\njg     1530 <solveSAT+0x190>\npush   %r14\nlea    0x1(%rdi),%r14d\npush   %r13\nmovslq %edi,%r13\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nlea    0x2d7b(%rip),%rbp\npush   %rbx\nlea    0x4eb3(%rip),%rbx\nmov    %r12d,(%rbx,%r13,4)\nlea    0x2cc8(%rip),%rax\njmp    1496 <solveSAT+0xf6>\nnopl   (%rax)\ntest   %edx,%edx\njle    13ed <solveSAT+0x4d>\ncmp    $0x1,%ecx\nje     148d <solveSAT+0xed>\ntest   %edx,%edx\njns    13f9 <solveSAT+0x59>\ntest   %ecx,%ecx\nje     148d <solveSAT+0xed>\nmov    0x4(%rax),%edx\ntest   %edx,%edx\nje     1500 <solveSAT+0x160>\nmov    $0x1,%esi\nmov    %edx,%ecx\nneg    %ecx\ncmovs  %edx,%ecx\nmovslq %ecx,%rcx\nmov    (%rbx,%rcx,4),%ecx\ncmp    $0xffffffff,%ecx\nje     14c8 <solveSAT+0x128>\ntest   %edx,%edx\njle    1428 <solveSAT+0x88>\ncmp    $0x1,%ecx\nje     148d <solveSAT+0xed>\ntest   %edx,%edx\njns    1430 <solveSAT+0x90>\ntest   %ecx,%ecx\nje     148d <solveSAT+0xed>\nmov    0x8(%rax),%edx\ntest   %edx,%edx\nje     1488 <solveSAT+0xe8>\nmov    %edx,%ecx\nneg    %ecx\ncmovs  %edx,%ecx\nmovslq %ecx,%rcx\nmov    (%rbx,%rcx,4),%ecx\ncmp    $0xffffffff,%ecx\nje     14e0 <solveSAT+0x140>\ntest   %edx,%edx\njle    1456 <solveSAT+0xb6>\ncmp    $0x1,%ecx\nje     148d <solveSAT+0xed>\ntest   %edx,%edx\njns    145e <solveSAT+0xbe>\ntest   %ecx,%ecx\nje     148d <solveSAT+0xed>\nmov    0xc(%rax),%edx\ntest   %edx,%edx\nje     1488 <solveSAT+0xe8>\nmov    %edx,%ecx\nneg    %ecx\ncmovs  %edx,%ecx\nmovslq %ecx,%rcx\nmov    (%rbx,%rcx,4),%ecx\ncmp    $0xffffffff,%ecx\nje     148d <solveSAT+0xed>\ntest   %edx,%edx\njle    1480 <solveSAT+0xe0>\ncmp    $0x1,%ecx\nje     148d <solveSAT+0xed>\ntest   %edx,%edx\njns    1488 <solveSAT+0xe8>\ntest   %ecx,%ecx\nje     148d <solveSAT+0xed>\ntest   %sil,%sil\njne    1500 <solveSAT+0x160>\nadd    $0x10,%rax\ncmp    %rax,%rbp\nje     14f0 <solveSAT+0x150>\nmov    (%rax),%edx\ntest   %edx,%edx\nje     1500 <solveSAT+0x160>\nmov    %edx,%ecx\nneg    %ecx\ncmovs  %edx,%ecx\nmovslq %ecx,%rcx\nmov    (%rbx,%rcx,4),%ecx\ncmp    $0xffffffff,%ecx\njne    13e0 <solveSAT+0x40>\nmov    0x4(%rax),%edx\nxor    %esi,%esi\ntest   %edx,%edx\njne    1409 <solveSAT+0x69>\njmp    148d <solveSAT+0xed>\nnopl   0x0(%rax)\nmov    0x8(%rax),%edx\nxor    %esi,%esi\ntest   %edx,%edx\njne    1437 <solveSAT+0x97>\njmp    148d <solveSAT+0xed>\nnopw   0x0(%rax,%rax,1)\nmov    0xc(%rax),%edx\nxor    %esi,%esi\ntest   %edx,%edx\njne    1465 <solveSAT+0xc5>\njmp    148d <solveSAT+0xed>\nnop\nmov    %r14d,%edi\ncall   13a0 <solveSAT>\ntest   %eax,%eax\njne    1667 <solveSAT+0x2c7>\ncmp    $0x1,%r12d\njne    1520 <solveSAT+0x180>\nmovl   $0xffffffff,(%rbx,%r13,4)\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\nmov    $0x1,%r12d\njmp    13cd <solveSAT+0x2d>\nnopl   0x0(%rax,%rax,1)\nlea    0x2b69(%rip),%rdx\nlea    0x4d42(%rip),%rsi\nlea    0xa0(%rdx),%rdi\njmp    1607 <solveSAT+0x267>\nnopw   0x0(%rax,%rax,1)\ntest   %eax,%eax\njle    155d <solveSAT+0x1bd>\ncmp    $0x1,%ecx\nje     15fe <solveSAT+0x25e>\ntest   %eax,%eax\njns    1569 <solveSAT+0x1c9>\ntest   %ecx,%ecx\nje     15fe <solveSAT+0x25e>\nmov    0x4(%rdx),%eax\ntest   %eax,%eax\nje     1671 <solveSAT+0x2d1>\nmov    $0x1,%r8d\nmov    %eax,%ecx\nneg    %ecx\ncmovs  %eax,%ecx\nmovslq %ecx,%rcx\nmov    (%rsi,%rcx,4),%ecx\ncmp    $0xffffffff,%ecx\nje     1638 <solveSAT+0x298>\ntest   %eax,%eax\njle    1599 <solveSAT+0x1f9>\ncmp    $0x1,%ecx\nje     15fe <solveSAT+0x25e>\ntest   %eax,%eax\njns    15a1 <solveSAT+0x201>\ntest   %ecx,%ecx\nje     15fe <solveSAT+0x25e>\nmov    0x8(%rdx),%eax\ntest   %eax,%eax\nje     15f9 <solveSAT+0x259>\nmov    %eax,%ecx\nneg    %ecx\ncmovs  %eax,%ecx\nmovslq %ecx,%rcx\nmov    (%rsi,%rcx,4),%ecx\ncmp    $0xffffffff,%ecx\nje     1650 <solveSAT+0x2b0>\ntest   %eax,%eax\njle    15c7 <solveSAT+0x227>\ncmp    $0x1,%ecx\nje     15fe <solveSAT+0x25e>\ntest   %eax,%eax\njns    15cf <solveSAT+0x22f>\ntest   %ecx,%ecx\nje     15fe <solveSAT+0x25e>\nmov    0xc(%rdx),%eax\ntest   %eax,%eax\nje     15f9 <solveSAT+0x259>\nmov    %eax,%ecx\nneg    %ecx\ncmovs  %eax,%ecx\nmovslq %ecx,%rcx\nmov    (%rsi,%rcx,4),%ecx\ncmp    $0xffffffff,%ecx\nje     15fe <solveSAT+0x25e>\ntest   %eax,%eax\njle    15f1 <solveSAT+0x251>\ncmp    $0x1,%ecx\nje     15fe <solveSAT+0x25e>\ntest   %eax,%eax\njns    15f9 <solveSAT+0x259>\ntest   %ecx,%ecx\nje     15fe <solveSAT+0x25e>\ntest   %r8b,%r8b\njne    1672 <solveSAT+0x2d2>\nadd    $0x10,%rdx\ncmp    %rdx,%rdi\nje     1661 <solveSAT+0x2c1>\nmov    (%rdx),%eax\ntest   %eax,%eax\nje     1660 <solveSAT+0x2c0>\nmov    %eax,%ecx\nneg    %ecx\ncmovs  %eax,%ecx\nmovslq %ecx,%rcx\nmov    (%rsi,%rcx,4),%ecx\ncmp    $0xffffffff,%ecx\njne    1550 <solveSAT+0x1b0>\nmov    0x4(%rdx),%eax\nxor    %r8d,%r8d\ntest   %eax,%eax\njne    157a <solveSAT+0x1da>\njmp    15fe <solveSAT+0x25e>\nnopl   0x0(%rax,%rax,1)\nmov    0x8(%rdx),%eax\nxor    %r8d,%r8d\ntest   %eax,%eax\njne    15a8 <solveSAT+0x208>\njmp    15fe <solveSAT+0x25e>\nnopl   0x0(%rax,%rax,1)\nmov    0xc(%rdx),%eax\nxor    %r8d,%r8d\ntest   %eax,%eax\njne    15d6 <solveSAT+0x236>\njmp    15fe <solveSAT+0x25e>\nret\nmov    $0x1,%eax\nret\nmov    $0x1,%eax\njmp    1510 <solveSAT+0x170>\nret\nxor    %eax,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "shortest-path/shortest-path.c", "function_name": "floydWarshall", "content": "// Solves the all-pairs shortest path problem using Floyd Warshall algorithm\nvoid\nfloydWarshall (int graph[][V])\n{\n  /* dist[][] will be the output matrix that will finally have the shortest \n    distances between every pair of vertices */\n  int i, j, k;\n \n  /* Initialize the solution matrix same as input graph matrix. Or \n     we can say the initial values of shortest distances are based\n     on shortest paths considering no intermediate vertex. */\n  for (i = 0; i < V; i++)\n    for (j = 0; j < V; j++)\n      dist[i][j] = graph[i][j];\n \n  /* Add all vertices one by one to the set of intermediate vertices.\n    ---> Before start of a iteration, we have shortest distances between all\n    pairs of vertices such that the shortest distances consider only the\n    vertices in set {0, 1, 2, .. k-1} as intermediate vertices.\n    ----> After the end of a iteration, vertex no. k is added to the set of\n    intermediate vertices and the set becomes {0, 1, 2, .. k} */\n  for (k = 0; k < V; k++)\n  {\n    // Pick all vertices as source one by one\n    for (i = 0; i < V; i++)\n    {\n      // Pick all vertices as destination for the\n      // above picked source\n      for (j = 0; j < V; j++)\n      {\n        // If vertex k is on the shortest path from\n        // i to j, then update the value of dist[i][j]\n        if (dist[i][k] + dist[k][j] < dist[i][j])\n          dist[i][j] = dist[i][k] + dist[k][j];\n      }\n    }\n  }\n}\n"}, "pseudo": {"path": "shortest-path/shortest-path.host.O3.pseudo", "function_name": "floydWarshall", "address": "0x1330", "label": "floydWarshall", "content": "void __fastcall floydWarshall(int (*graph)[8])\n{\n  __m128i v1; // xmm2\n  __m128i v2; // xmm3\n  __m128i v3; // xmm4\n  __m128i v4; // xmm5\n  __m128i v5; // xmm6\n  __m128i v6; // xmm7\n  __m128i v7; // xmm0\n  __m128i v8; // xmm1\n  __m128i v9; // xmm2\n  __m128i v10; // xmm3\n  __m128i v11; // xmm4\n  __m128i v12; // xmm5\n  __m128i v13; // xmm6\n  __m128i v14; // xmm7\n  __m128i v15; // xmm0\n  __int64 *v16; // r10\n  __int64 *v17; // rcx\n  int *v18; // rax\n  __int64 *v19; // rsi\n  int v20; // edx\n  int v21; // edi\n  int v22; // edi\n  int v23; // edi\n  int v24; // edi\n  int v25; // edi\n  int v26; // edi\n  int v27; // edi\n  int v28; // edx\n  int v29; // eax\n  int v30; // edx\n\n  if ( (unsigned __int64)((char *)&(*graph)[7] + 3 - (char *)dist) <= 0x3E )\n  {\n    *(_OWORD *)&dist[0][0] = *(_OWORD *)graph;\n    *(_OWORD *)&dist[0][4] = *(_OWORD *)&(*graph)[4];\n    *(_OWORD *)&dist[1][0] = *(_OWORD *)&(*graph)[8];\n    *(_OWORD *)&dist[1][4] = *(_OWORD *)&(*graph)[12];\n    *(_OWORD *)&dist[2][0] = *(_OWORD *)&(*graph)[16];\n    *(_OWORD *)&dist[2][4] = *(_OWORD *)&(*graph)[20];\n    *(_OWORD *)&dist[3][0] = *(_OWORD *)&(*graph)[24];\n    *(_OWORD *)&dist[3][4] = *(_OWORD *)&(*graph)[28];\n    *(_OWORD *)&dist[4][0] = *(_OWORD *)&(*graph)[32];\n    *(_OWORD *)&dist[4][4] = *(_OWORD *)&(*graph)[36];\n    *(_OWORD *)&dist[5][0] = *(_OWORD *)&(*graph)[40];\n    *(_OWORD *)&dist[5][4] = *(_OWORD *)&(*graph)[44];\n    v29 = (*graph)[63];\n    *(_OWORD *)&dist[6][0] = *(_OWORD *)&(*graph)[48];\n    *(_OWORD *)&dist[6][4] = *(_OWORD *)&(*graph)[52];\n    *(_OWORD *)&dist[7][0] = *(_OWORD *)&(*graph)[56];\n    *(_QWORD *)&dist[7][4] = *(_QWORD *)&(*graph)[60];\n    v30 = (*graph)[62];\n    dist[7][7] = v29;\n    dist[7][6] = v30;\n  }\n  else\n  {\n    v1 = _mm_loadu_si128((const __m128i *)&(*graph)[4]);\n    v2 = _mm_loadu_si128((const __m128i *)&(*graph)[8]);\n    v3 = _mm_loadu_si128((const __m128i *)&(*graph)[12]);\n    v4 = _mm_loadu_si128((const __m128i *)&(*graph)[16]);\n    v5 = _mm_loadu_si128((const __m128i *)&(*graph)[20]);\n    *(__m128i *)&dist[0][0] = _mm_loadu_si128((const __m128i *)graph);\n    v6 = _mm_loadu_si128((const __m128i *)&(*graph)[24]);\n    v7 = _mm_loadu_si128((const __m128i *)&(*graph)[28]);\n    *(__m128i *)&dist[0][4] = v1;\n    v8 = _mm_loadu_si128((const __m128i *)&(*graph)[32]);\n    v9 = _mm_loadu_si128((const __m128i *)&(*graph)[36]);\n    *(__m128i *)&dist[1][0] = v2;\n    *(__m128i *)&dist[1][4] = v3;\n    v10 = _mm_loadu_si128((const __m128i *)&(*graph)[40]);\n    v11 = _mm_loadu_si128((const __m128i *)&(*graph)[44]);\n    *(__m128i *)&dist[2][0] = v4;\n    v12 = _mm_loadu_si128((const __m128i *)&(*graph)[48]);\n    *(__m128i *)&dist[2][4] = v5;\n    v13 = _mm_loadu_si128((const __m128i *)&(*graph)[52]);\n    *(__m128i *)&dist[3][0] = v6;\n    v14 = _mm_loadu_si128((const __m128i *)&(*graph)[60]);\n    *(__m128i *)&dist[3][4] = v7;\n    v15 = _mm_loadu_si128((const __m128i *)&(*graph)[56]);\n    *(__m128i *)&dist[4][0] = v8;\n    *(__m128i *)&dist[4][4] = v9;\n    *(__m128i *)&dist[5][0] = v10;\n    *(__m128i *)&dist[5][4] = v11;\n    *(__m128i *)&dist[6][0] = v12;\n    *(__m128i *)&dist[6][4] = v13;\n    *(__m128i *)&dist[7][4] = v14;\n    *(__m128i *)&dist[7][0] = v15;\n  }\n  v16 = &_start_time - 32;\n  v17 = &_start_time - 32;\n  do\n  {\n    v18 = dist[0];\n    v19 = v16;\n    do\n    {\n      v20 = *(_DWORD *)v19;\n      v21 = *(_DWORD *)v19 + *(_DWORD *)v17;\n      if ( v21 < *v18 )\n      {\n        *v18 = v21;\n        v20 = *(_DWORD *)v19;\n      }\n      v22 = v20 + *((_DWORD *)v17 + 1);\n      if ( v22 < v18[1] )\n      {\n        v18[1] = v22;\n        v20 = *(_DWORD *)v19;\n      }\n      v23 = v20 + *((_DWORD *)v17 + 2);\n      if ( v23 < v18[2] )\n      {\n        v18[2] = v23;\n        v20 = *(_DWORD *)v19;\n      }\n      v24 = v20 + *((_DWORD *)v17 + 3);\n      if ( v24 < v18[3] )\n      {\n        v18[3] = v24;\n        v20 = *(_DWORD *)v19;\n      }\n      v25 = v20 + *((_DWORD *)v17 + 4);\n      if ( v25 < v18[4] )\n      {\n        v18[4] = v25;\n        v20 = *(_DWORD *)v19;\n      }\n      v26 = v20 + *((_DWORD *)v17 + 5);\n      if ( v26 < v18[5] )\n      {\n        v18[5] = v26;\n        v20 = *(_DWORD *)v19;\n      }\n      v27 = v20 + *((_DWORD *)v17 + 6);\n      if ( v27 < v18[6] )\n      {\n        v18[6] = v27;\n        v20 = *(_DWORD *)v19;\n      }\n      v28 = *((_DWORD *)v17 + 7) + v20;\n      if ( v28 < v18[7] )\n        v18[7] = v28;\n      v18 += 8;\n      v19 += 4;\n    }\n    while ( &_start_time != (__int64 *)v18 );\n    v17 += 4;\n    v16 = (__int64 *)((char *)v16 + 4);\n  }\n  while ( v17 != &_start_time );\n}\n"}, "pseudo_normalize": "void floydWarshall(int (*graph)[8]) {\n  __m128i v1;\n  __m128i v2;\n  __m128i v3;\n  __m128i v4;\n  __m128i v5;\n  __m128i v6;\n  __m128i v7;\n  __m128i v8;\n  __m128i v9;\n  __m128i v10;\n  __m128i v11;\n  __m128i v12;\n  __m128i v13;\n  __m128i v14;\n  __m128i v15;\n  long long *v16;\n  long long *v17;\n  int *v18;\n  long long *v19;\n  int v20;\n  int v21;\n  int v22;\n  int v23;\n  int v24;\n  int v25;\n  int v26;\n  int v27;\n  int v28;\n  int v29;\n  int v30;\n  if ((unsigned long long)((char *)&(*graph)[7] + 3 - (char *)dist) <= 62) {\n    *(long double *)&dist[0][0] = *(long double *)graph;\n    *(long double *)&dist[0][4] = *(long double *)&(*graph)[4];\n    *(long double *)&dist[1][0] = *(long double *)&(*graph)[8];\n    *(long double *)&dist[1][4] = *(long double *)&(*graph)[12];\n    *(long double *)&dist[2][0] = *(long double *)&(*graph)[16];\n    *(long double *)&dist[2][4] = *(long double *)&(*graph)[20];\n    *(long double *)&dist[3][0] = *(long double *)&(*graph)[24];\n    *(long double *)&dist[3][4] = *(long double *)&(*graph)[28];\n    *(long double *)&dist[4][0] = *(long double *)&(*graph)[32];\n    *(long double *)&dist[4][4] = *(long double *)&(*graph)[36];\n    *(long double *)&dist[5][0] = *(long double *)&(*graph)[40];\n    *(long double *)&dist[5][4] = *(long double *)&(*graph)[44];\n    v29 = (*graph)[63];\n    *(long double *)&dist[6][0] = *(long double *)&(*graph)[48];\n    *(long double *)&dist[6][4] = *(long double *)&(*graph)[52];\n    *(long double *)&dist[7][0] = *(long double *)&(*graph)[56];\n    *(uint64_t *)&dist[7][4] = *(uint64_t *)&(*graph)[60];\n    v30 = (*graph)[62];\n    dist[7][7] = v29;\n    dist[7][6] = v30;\n  } else {\n    v1 = _mm_loadu_si128((const __m128i *)&(*graph)[4]);\n    v2 = _mm_loadu_si128((const __m128i *)&(*graph)[8]);\n    v3 = _mm_loadu_si128((const __m128i *)&(*graph)[12]);\n    v4 = _mm_loadu_si128((const __m128i *)&(*graph)[16]);\n    v5 = _mm_loadu_si128((const __m128i *)&(*graph)[20]);\n    *(__m128i *)&dist[0][0] = _mm_loadu_si128((const __m128i *)graph);\n    v6 = _mm_loadu_si128((const __m128i *)&(*graph)[24]);\n    v7 = _mm_loadu_si128((const __m128i *)&(*graph)[28]);\n    *(__m128i *)&dist[0][4] = v1;\n    v8 = _mm_loadu_si128((const __m128i *)&(*graph)[32]);\n    v9 = _mm_loadu_si128((const __m128i *)&(*graph)[36]);\n    *(__m128i *)&dist[1][0] = v2;\n    *(__m128i *)&dist[1][4] = v3;\n    v10 = _mm_loadu_si128((const __m128i *)&(*graph)[40]);\n    v11 = _mm_loadu_si128((const __m128i *)&(*graph)[44]);\n    *(__m128i *)&dist[2][0] = v4;\n    v12 = _mm_loadu_si128((const __m128i *)&(*graph)[48]);\n    *(__m128i *)&dist[2][4] = v5;\n    v13 = _mm_loadu_si128((const __m128i *)&(*graph)[52]);\n    *(__m128i *)&dist[3][0] = v6;\n    v14 = _mm_loadu_si128((const __m128i *)&(*graph)[60]);\n    *(__m128i *)&dist[3][4] = v7;\n    v15 = _mm_loadu_si128((const __m128i *)&(*graph)[56]);\n    *(__m128i *)&dist[4][0] = v8;\n    *(__m128i *)&dist[4][4] = v9;\n    *(__m128i *)&dist[5][0] = v10;\n    *(__m128i *)&dist[5][4] = v11;\n    *(__m128i *)&dist[6][0] = v12;\n    *(__m128i *)&dist[6][4] = v13;\n    *(__m128i *)&dist[7][4] = v14;\n    *(__m128i *)&dist[7][0] = v15;\n  }\n  v16 = &_start_time - 32;\n  v17 = &_start_time - 32;\n  do {\n    v18 = dist[0];\n    v19 = v16;\n    do {\n      v20 = *(uint32_t *)v19;\n      v21 = *(uint32_t *)v19 + *(uint32_t *)v17;\n      if (v21 < *v18) {\n        *v18 = v21;\n        v20 = *(uint32_t *)v19;\n      }\n      v22 = v20 + *((uint32_t *)v17 + 1);\n      if (v22 < v18[1]) {\n        v18[1] = v22;\n        v20 = *(uint32_t *)v19;\n      }\n      v23 = v20 + *((uint32_t *)v17 + 2);\n      if (v23 < v18[2]) {\n        v18[2] = v23;\n        v20 = *(uint32_t *)v19;\n      }\n      v24 = v20 + *((uint32_t *)v17 + 3);\n      if (v24 < v18[3]) {\n        v18[3] = v24;\n        v20 = *(uint32_t *)v19;\n      }\n      v25 = v20 + *((uint32_t *)v17 + 4);\n      if (v25 < v18[4]) {\n        v18[4] = v25;\n        v20 = *(uint32_t *)v19;\n      }\n      v26 = v20 + *((uint32_t *)v17 + 5);\n      if (v26 < v18[5]) {\n        v18[5] = v26;\n        v20 = *(uint32_t *)v19;\n      }\n      v27 = v20 + *((uint32_t *)v17 + 6);\n      if (v27 < v18[6]) {\n        v18[6] = v27;\n        v20 = *(uint32_t *)v19;\n      }\n      v28 = *((uint32_t *)v17 + 7) + v20;\n      if (v28 < v18[7]) v18[7] = v28;\n      v18 += 8;\n      v19 += 4;\n    } while (&_start_time != (long long *)v18);\n    v17 += 4;\n    v16 = (long long *)((char *)v16 + 4);\n  } while (v17 != &_start_time);\n}", "binary": "shortest-path/shortest-path.host.O3", "assembly": "<floydWarshall>:\nendbr64\nlea    0x1f(%rdi),%rdx\nlea    0x4f41(%rip),%r9\nsub    %r9,%rdx\ncmp    $0x3e,%rdx\njbe    14d2 <floydWarshall+0x1a2>\nmovdqu (%rdi),%xmm1\nmovdqu 0x10(%rdi),%xmm2\nmovdqu 0x20(%rdi),%xmm3\nmovdqu 0x30(%rdi),%xmm4\nmovdqu 0x40(%rdi),%xmm5\nmovdqu 0x50(%rdi),%xmm6\nmovaps %xmm1,0x4f10(%rip)\nmovdqu 0x60(%rdi),%xmm7\nmovdqu 0x70(%rdi),%xmm0\nmovaps %xmm2,0x4f0f(%rip)\nmovdqu 0x80(%rdi),%xmm1\nmovdqu 0x90(%rdi),%xmm2\nmovaps %xmm3,0x4f08(%rip)\nmovaps %xmm4,0x4f11(%rip)\nmovdqu 0xa0(%rdi),%xmm3\nmovdqu 0xb0(%rdi),%xmm4\nmovaps %xmm5,0x4f0a(%rip)\nmovdqu 0xc0(%rdi),%xmm5\nmovaps %xmm6,0x4f0b(%rip)\nmovdqu 0xd0(%rdi),%xmm6\nmovaps %xmm7,0x4f0c(%rip)\nmovdqu 0xf0(%rdi),%xmm7\nmovaps %xmm0,0x4f0d(%rip)\nmovdqu 0xe0(%rdi),%xmm0\nmovaps %xmm1,0x4f0e(%rip)\nmovaps %xmm2,0x4f17(%rip)\nmovaps %xmm3,0x4f20(%rip)\nmovaps %xmm4,0x4f29(%rip)\nmovaps %xmm5,0x4f32(%rip)\nmovaps %xmm6,0x4f3b(%rip)\nmovaps %xmm7,0x4f54(%rip)\nmovaps %xmm0,0x4f3d(%rip)\nlea    0x4f56(%rip),%r8\nlea    -0x100(%r8),%r10\nmov    %r10,%rcx\nnopl   0x0(%rax)\nmov    %r9,%rax\nmov    %r10,%rsi\nxchg   %ax,%ax\nmov    (%rsi),%edx\nmov    (%rcx),%edi\nadd    %edx,%edi\ncmp    (%rax),%edi\njge    144e <floydWarshall+0x11e>\nmov    %edi,(%rax)\nmov    (%rsi),%edx\nmov    0x4(%rcx),%edi\nadd    %edx,%edi\ncmp    0x4(%rax),%edi\njge    145d <floydWarshall+0x12d>\nmov    %edi,0x4(%rax)\nmov    (%rsi),%edx\nmov    0x8(%rcx),%edi\nadd    %edx,%edi\ncmp    0x8(%rax),%edi\njge    146c <floydWarshall+0x13c>\nmov    %edi,0x8(%rax)\nmov    (%rsi),%edx\nmov    0xc(%rcx),%edi\nadd    %edx,%edi\ncmp    0xc(%rax),%edi\njge    147b <floydWarshall+0x14b>\nmov    %edi,0xc(%rax)\nmov    (%rsi),%edx\nmov    0x10(%rcx),%edi\nadd    %edx,%edi\ncmp    0x10(%rax),%edi\njge    148a <floydWarshall+0x15a>\nmov    %edi,0x10(%rax)\nmov    (%rsi),%edx\nmov    0x14(%rcx),%edi\nadd    %edx,%edi\ncmp    0x14(%rax),%edi\njge    1499 <floydWarshall+0x169>\nmov    %edi,0x14(%rax)\nmov    (%rsi),%edx\nmov    0x18(%rcx),%edi\nadd    %edx,%edi\ncmp    0x18(%rax),%edi\njge    14a8 <floydWarshall+0x178>\nmov    %edi,0x18(%rax)\nmov    (%rsi),%edx\nadd    0x1c(%rcx),%edx\ncmp    0x1c(%rax),%edx\njge    14b3 <floydWarshall+0x183>\nmov    %edx,0x1c(%rax)\nadd    $0x20,%rax\nadd    $0x20,%rsi\ncmp    %rax,%r8\njne    1440 <floydWarshall+0x110>\nadd    $0x20,%rcx\nadd    $0x4,%r10\ncmp    %r8,%rcx\njne    1438 <floydWarshall+0x108>\nret\nmov    (%rdi),%edx\nmov    %edx,0x4da6(%rip)\nmov    0x4(%rdi),%edx\nmov    %edx,0x4da1(%rip)\nmov    0x8(%rdi),%edx\nmov    %edx,0x4d9c(%rip)\nmov    0xc(%rdi),%edx\nmov    %edx,0x4d97(%rip)\nmov    0x10(%rdi),%edx\nmov    %edx,0x4d92(%rip)\nmov    0x14(%rdi),%edx\nmov    %edx,0x4d8d(%rip)\nmov    0x18(%rdi),%edx\nmov    %edx,0x4d88(%rip)\nmov    0x1c(%rdi),%edx\nmov    %edx,0x4d83(%rip)\nmov    0x20(%rdi),%edx\nmov    %edx,0x4d7e(%rip)\nmov    0x24(%rdi),%edx\nmov    %edx,0x4d79(%rip)\nmov    0x28(%rdi),%edx\nmov    %edx,0x4d74(%rip)\nmov    0x2c(%rdi),%edx\nmov    %edx,0x4d6f(%rip)\nmov    0x30(%rdi),%edx\nmov    %edx,0x4d6a(%rip)\nmov    0x34(%rdi),%edx\nmov    %edx,0x4d65(%rip)\nmov    0x38(%rdi),%edx\nmov    %edx,0x4d60(%rip)\nmov    0x3c(%rdi),%edx\nmov    %edx,0x4d5b(%rip)\nmov    0x40(%rdi),%edx\nmov    %edx,0x4d56(%rip)\nmov    0x44(%rdi),%edx\nmov    %edx,0x4d51(%rip)\nmov    0x48(%rdi),%edx\nmov    %edx,0x4d4c(%rip)\nmov    0x4c(%rdi),%edx\nmov    %edx,0x4d47(%rip)\nmov    0x50(%rdi),%edx\nmov    %edx,0x4d42(%rip)\nmov    0x54(%rdi),%edx\nmov    %edx,0x4d3d(%rip)\nmov    0x58(%rdi),%edx\nmov    %edx,0x4d38(%rip)\nmov    0x5c(%rdi),%edx\nmov    %edx,0x4d33(%rip)\nmov    0x60(%rdi),%edx\nmov    %edx,0x4d2e(%rip)\nmov    0x64(%rdi),%edx\nmov    %edx,0x4d29(%rip)\nmov    0x68(%rdi),%edx\nmov    %edx,0x4d24(%rip)\nmov    0x6c(%rdi),%edx\nmov    %edx,0x4d1f(%rip)\nmov    0x70(%rdi),%edx\nmov    %edx,0x4d1a(%rip)\nmov    0x74(%rdi),%edx\nmov    %edx,0x4d15(%rip)\nmov    0x78(%rdi),%edx\nmov    %edx,0x4d10(%rip)\nmov    0x7c(%rdi),%edx\nmov    %edx,0x4d0b(%rip)\nmov    0x80(%rdi),%edx\nmov    %edx,0x4d03(%rip)\nmov    0x84(%rdi),%edx\nmov    %edx,0x4cfb(%rip)\nmov    0x88(%rdi),%edx\nmov    %edx,0x4cf3(%rip)\nmov    0x8c(%rdi),%edx\nmov    %edx,0x4ceb(%rip)\nmov    0x90(%rdi),%edx\nmov    %edx,0x4ce3(%rip)\nmov    0x94(%rdi),%edx\nmov    %edx,0x4cdb(%rip)\nmov    0x98(%rdi),%edx\nmov    %edx,0x4cd3(%rip)\nmov    0x9c(%rdi),%edx\nmov    %edx,0x4ccb(%rip)\nmov    0xa0(%rdi),%edx\nmov    %edx,0x4cc3(%rip)\nmov    0xa4(%rdi),%edx\nmov    %edx,0x4cbb(%rip)\nmov    0xa8(%rdi),%edx\nmov    %edx,0x4cb3(%rip)\nmov    0xac(%rdi),%edx\nmov    %edx,0x4cab(%rip)\nmov    0xb0(%rdi),%edx\nmov    %edx,0x4ca3(%rip)\nmov    0xb4(%rdi),%edx\nmov    %edx,0x4c9b(%rip)\nmov    0xb8(%rdi),%edx\nmov    %edx,0x4c93(%rip)\nmov    0xbc(%rdi),%edx\nmov    %edx,0x4c8b(%rip)\nmov    0xc0(%rdi),%edx\nmov    0xfc(%rdi),%eax\nmov    %edx,0x4c7d(%rip)\nmov    0xc4(%rdi),%edx\nmov    %edx,0x4c75(%rip)\nmov    0xc8(%rdi),%edx\nmov    %edx,0x4c6d(%rip)\nmov    0xcc(%rdi),%edx\nmov    %edx,0x4c65(%rip)\nmov    0xd0(%rdi),%edx\nmov    %edx,0x4c5d(%rip)\nmov    0xd4(%rdi),%edx\nmov    %edx,0x4c55(%rip)\nmov    0xd8(%rdi),%edx\nmov    %edx,0x4c4d(%rip)\nmov    0xdc(%rdi),%edx\nmov    %edx,0x4c45(%rip)\nmov    0xe0(%rdi),%edx\nmov    %edx,0x4c3d(%rip)\nmov    0xe4(%rdi),%edx\nmov    %edx,0x4c35(%rip)\nmov    0xe8(%rdi),%edx\nmov    %edx,0x4c2d(%rip)\nmov    0xec(%rdi),%edx\nmov    %edx,0x4c25(%rip)\nmov    0xf0(%rdi),%edx\nmov    %edx,0x4c1d(%rip)\nmov    0xf4(%rdi),%edx\nmov    %edx,0x4c15(%rip)\nmov    0xf8(%rdi),%edx\nmov    %eax,0x4c11(%rip)\nmov    %edx,0x4c07(%rip)\njmp    1423 <floydWarshall+0xf3>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "shortest-path/shortest-path.c", "function_name": "main", "content": " \n// driver program to test above function\nint\nmain(void)\n{\n  /* Let us create the following weighted graph\n          10\n     (0)------->(3)\n      |         /|\\\n    5 |          |\n      |          | 1\n     \\|/         |\n     (1)------->(2)\n          3           */\n#ifdef notdef\n  int graph[V][V] = { {0,   5,  INF, 10},\n                      {INF, 0,   3, INF},\n                      {INF, INF, 0,   1},\n                      {INF, INF, INF, 0}\n                    };\n#endif /* notdef */\n\tint graph[V][V] = {\n  // Vertex # A  B  C  D  E  F  G  H\t   Vertex\n            { 0, N, 4, N, N, 7, N, N }, // A\n\t\t\t      { N, 0, N, N, 9, N, N, 3 }, // B\n\t\t\t      { 4, N, 0, 3, N, 2, 9, N }, // C\t\n\t\t\t      { N, N, 3, 0, 3, N, 7, N }, // D\n\t\t\t      { N, 9, N, 3, 0, N, 2, 7 }, // E\n\t\t\t      { 7, N, 2, N, N, 0, 8, N }, // F\n\t\t\t      { N, N, 9, 7, 2, 8, 0, 3 }, // G\n\t\t\t      { N, 3, N, N, 7, N, 3, 0 } };//H\n\n \n  // Print the solution\n  floydWarshall(graph);\n \n  // Print the shortest distance matrix\n  printSolution(dist);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "shortest-path/shortest-path.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int graph[8][8]; // [rsp+0h] [rbp-118h] BYREF\n  unsigned __int64 v4; // [rsp+108h] [rbp-10h]\n\n  v4 = __readfsqword(0x28u);\n  *(__m128i *)&graph[0][0] = _mm_load_si128((const __m128i *)&xmmword_4070);\n  *(__m128i *)&graph[0][4] = _mm_load_si128((const __m128i *)&xmmword_4080);\n  *(__m128i *)&graph[1][0] = _mm_load_si128((const __m128i *)&xmmword_4090);\n  *(__m128i *)&graph[1][4] = _mm_load_si128((const __m128i *)&xmmword_40A0);\n  *(__m128i *)&graph[2][0] = _mm_load_si128((const __m128i *)&xmmword_40B0);\n  *(__m128i *)&graph[2][4] = _mm_load_si128((const __m128i *)&xmmword_40C0);\n  *(__m128i *)&graph[3][0] = _mm_load_si128((const __m128i *)&xmmword_40D0);\n  *(__m128i *)&graph[3][4] = _mm_load_si128((const __m128i *)&xmmword_40E0);\n  *(__m128i *)&graph[4][0] = _mm_load_si128((const __m128i *)&xmmword_40F0);\n  *(__m128i *)&graph[4][4] = _mm_load_si128((const __m128i *)&xmmword_4100);\n  *(__m128i *)&graph[5][0] = _mm_load_si128((const __m128i *)&xmmword_4110);\n  *(__m128i *)&graph[5][4] = _mm_load_si128((const __m128i *)&xmmword_4120);\n  *(__m128i *)&graph[6][0] = _mm_load_si128((const __m128i *)&xmmword_4130);\n  *(__m128i *)&graph[6][4] = _mm_load_si128((const __m128i *)&xmmword_4140);\n  *(__m128i *)&graph[7][0] = _mm_load_si128((const __m128i *)&xmmword_4150);\n  *(__m128i *)&graph[7][4] = _mm_load_si128((const __m128i *)&xmmword_4160);\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int graph[8][8];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  *(__m128i *)&graph[0][0] = _mm_load_si128((const __m128i *)&xmmword_4070);\n  *(__m128i *)&graph[0][4] = _mm_load_si128((const __m128i *)&xmmword_4080);\n  *(__m128i *)&graph[1][0] = _mm_load_si128((const __m128i *)&xmmword_4090);\n  *(__m128i *)&graph[1][4] = _mm_load_si128((const __m128i *)&xmmword_40A0);\n  *(__m128i *)&graph[2][0] = _mm_load_si128((const __m128i *)&xmmword_40B0);\n  *(__m128i *)&graph[2][4] = _mm_load_si128((const __m128i *)&xmmword_40C0);\n  *(__m128i *)&graph[3][0] = _mm_load_si128((const __m128i *)&xmmword_40D0);\n  *(__m128i *)&graph[3][4] = _mm_load_si128((const __m128i *)&xmmword_40E0);\n  *(__m128i *)&graph[4][0] = _mm_load_si128((const __m128i *)&xmmword_40F0);\n  *(__m128i *)&graph[4][4] = _mm_load_si128((const __m128i *)&xmmword_4100);\n  *(__m128i *)&graph[5][0] = _mm_load_si128((const __m128i *)&xmmword_4110);\n  *(__m128i *)&graph[5][4] = _mm_load_si128((const __m128i *)&xmmword_4120);\n  *(__m128i *)&graph[6][0] = _mm_load_si128((const __m128i *)&xmmword_4130);\n  *(__m128i *)&graph[6][4] = _mm_load_si128((const __m128i *)&xmmword_4140);\n  *(__m128i *)&graph[7][0] = _mm_load_si128((const __m128i *)&xmmword_4150);\n  *(__m128i *)&graph[7][4] = _mm_load_si128((const __m128i *)&xmmword_4160);\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}", "binary": "shortest-path/shortest-path.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x118,%rsp\nmovdqa 0x2f5d(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x108(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdi\nmovaps %xmm0,(%rsp)\nmovdqa 0x2f4b(%rip),%xmm0\nmovaps %xmm0,0x10(%rsp)\nmovdqa 0x2f4e(%rip),%xmm0\nmovaps %xmm0,0x20(%rsp)\nmovdqa 0x2f51(%rip),%xmm0\nmovaps %xmm0,0x30(%rsp)\nmovdqa 0x2f54(%rip),%xmm0\nmovaps %xmm0,0x40(%rsp)\nmovdqa 0x2f57(%rip),%xmm0\nmovaps %xmm0,0x50(%rsp)\nmovdqa 0x2f5a(%rip),%xmm0\nmovaps %xmm0,0x60(%rsp)\nmovdqa 0x2f5d(%rip),%xmm0\nmovaps %xmm0,0x70(%rsp)\nmovdqa 0x2f60(%rip),%xmm0\nmovaps %xmm0,0x80(%rsp)\nmovdqa 0x2f60(%rip),%xmm0\nmovaps %xmm0,0x90(%rsp)\nmovdqa 0x2f60(%rip),%xmm0\nmovaps %xmm0,0xa0(%rsp)\nmovdqa 0x2f60(%rip),%xmm0\nmovaps %xmm0,0xb0(%rsp)\nmovdqa 0x2f60(%rip),%xmm0\nmovaps %xmm0,0xc0(%rsp)\nmovdqa 0x2f60(%rip),%xmm0\nmovaps %xmm0,0xd0(%rsp)\nmovdqa 0x2f60(%rip),%xmm0\nmovaps %xmm0,0xe0(%rsp)\nmovdqa 0x2f60(%rip),%xmm0\nmovaps %xmm0,0xf0(%rsp)\ncall   1330 <floydWarshall>\nlea    0x506c(%rip),%rdi\ncall   1780 <printSolution>\ncall   3b50 <libmin_success>\nmov    0x108(%rsp),%rax\nsub    %fs:0x28,%rax\njne    123b <main+0x13b>\nxor    %eax,%eax\nadd    $0x118,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\n"}
{"source": {"path": "shortest-path/shortest-path.c", "function_name": "printSolution", "content": " \n/* A utility function to print solution */\nvoid\nprintSolution(int dist[][V])\n{\n    libmin_printf (\"Following matrix shows the shortest distances\"\n                   \" between every pair of vertices \\n\");\n    for (int i = 0; i < V; i++)\n    {\n        for (int j = 0; j < V; j++)\n        {\n            if (dist[i][j] == INF)\n                libmin_printf(\"%7s\", \"INF\");\n            else\n                libmin_printf (\"%7d\", dist[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "shortest-path/shortest-path.host.O3.pseudo", "function_name": "printSolution", "address": "0x1780", "label": "printSolution", "content": "void __fastcall printSolution(int (*dist)[8])\n{\n  int *v1; // rbx\n  int *v2; // r14\n  int v3; // esi\n\n  v1 = &(*dist)[8];\n  libmin_printf(\"Following matrix shows the shortest distances between every pair of vertices \\n\");\n  do\n  {\n    v2 = v1 - 8;\n    do\n    {\n      while ( 1 )\n      {\n        v3 = *v2;\n        if ( *v2 == 99999 )\n          break;\n        ++v2;\n        libmin_printf(\"%7d\", v3);\n        if ( v2 == v1 )\n          goto LABEL_6;\n      }\n      ++v2;\n      libmin_printf(\"%7s\", \"INF\");\n    }\n    while ( v2 != v1 );\nLABEL_6:\n    v1 = v2 + 8;\n    libmin_printf(\"\\n\");\n  }\n  while ( v2 + 8 != &(*dist)[72] );\n}\n"}, "pseudo_normalize": "void printSolution(int (*dist)[8]) {\n  int *v1;\n  int *v2;\n  int v3;\n  v1 = &(*dist)[8];\n  libmin_printf(\n      \"Following matrix shows the shortest distances between every pair of \"\n      \"vertices \\n\");\n  do {\n    v2 = v1 - 8;\n    do {\n      while (1) {\n        v3 = *v2;\n        if (*v2 == 99999) break;\n        ++v2;\n        libmin_printf(\"%7d\", v3);\n        if (v2 == v1) goto LABEL_6;\n      }\n      ++v2;\n      libmin_printf(\"%7s\", \"INF\");\n    } while (v2 != v1);\n  LABEL_6:\n    v1 = v2 + 8;\n    libmin_printf(\"\\n\");\n  } while (v2 + 8 != &(*dist)[72]);\n}", "binary": "shortest-path/shortest-path.host.O3", "assembly": "<printSolution>:\nendbr64\npush   %r15\nxor    %eax,%eax\nlea    0x28d4(%rip),%r15\npush   %r14\nmov    %rdi,%r14\nlea    0x286d(%rip),%rdi\npush   %r13\nlea    0x28b3(%rip),%r13\npush   %r12\nlea    0x28ae(%rip),%r12\npush   %rbp\nlea    0x28aa(%rip),%rbp\npush   %rbx\nlea    0x20(%r14),%rbx\nsub    $0x18,%rsp\ncall   3910 <libmin_printf>\nlea    0x120(%r14),%rax\nmov    %rax,0x8(%rsp)\nnop\nlea    -0x20(%rbx),%r14\njmp    17f3 <printSolution+0x73>\ncs nopw 0x0(%rax,%rax,1)\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x4,%r14\ncall   3910 <libmin_printf>\ncmp    %rbx,%r14\nje     1814 <printSolution+0x94>\nmov    (%r14),%esi\ncmp    $0x1869f,%esi\njne    17e0 <printSolution+0x60>\nmov    %r13,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x4,%r14\ncall   3910 <libmin_printf>\ncmp    %rbx,%r14\njne    17f3 <printSolution+0x73>\nmov    %r15,%rdi\nxor    %eax,%eax\nlea    0x20(%r14),%rbx\ncall   3910 <libmin_printf>\ncmp    0x8(%rsp),%rbx\njne    17d0 <printSolution+0x50>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "sieve/sieve.c", "function_name": "main", "content": "int\nmain(void)\n{\n\n  long  j,p;\n\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\");\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n\t\n  j = 1024;\n  p = 1;\n  SIEVE(j,p);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "sieve/sieve.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // r10\n  __int64 v4; // r9\n  unsigned __int64 v5; // r8\n  __int64 v6; // rdx\n  char *v7; // rcx\n  __int64 v8; // rax\n\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv, envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  v3 = 0LL;\n  v4 = 0LL;\n  v5 = 3LL;\n  v6 = 3LL;\n  memset(flags, 1u, 0x400uLL);\n  v7 = flags;\n  while ( 1 )\n  {\n    if ( *v7 )\n    {\n      ++v4;\n      v3 = v6;\n      v8 = v5;\n      if ( v5 <= 0x3FF )\n      {\n        do\n        {\n          flags[v8] = 0;\n          v8 += v6;\n        }\n        while ( v8 <= 1023 );\n      }\n    }\n    ++v7;\n    v6 += 2LL;\n    v5 += 3LL;\n    if ( &flags[1024] == v7 )\n    {\n      libmin_printf(\"  %9ld   %8ld     %8ld\\n\", 1024LL, v4, v3);\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  unsigned long long v5;\n  long long v6;\n  char *v7;\n  long long v8;\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv,\n                envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  v3 = 0LL;\n  v4 = 0LL;\n  v5 = 3LL;\n  v6 = 3LL;\n  memset(flags, 1u, 1024uLL);\n  v7 = flags;\n  while (1) {\n    if (*v7) {\n      ++v4;\n      v3 = v6;\n      v8 = v5;\n      if (v5 <= 1023) {\n        do {\n          flags[v8] = 0;\n          v8 += v6;\n        } while (v8 <= 1023);\n      }\n    }\n    ++v7;\n    v6 += 2LL;\n    v5 += 3LL;\n    if (&flags[1024] == v7) {\n      libmin_printf(\"  %9ld   %8ld     %8ld\\n\", 1024LL, v4, v3);\n      libmin_success();\n    }\n  }\n}", "binary": "sieve/sieve.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nlea    0x2ef9(%rip),%rdi\nxor    %eax,%eax\ncall   33b0 <libmin_printf>\nlea    0x2f23(%rip),%rdi\nxor    %eax,%eax\ncall   33b0 <libmin_printf>\nlea    0x2f35(%rip),%rdi\nxor    %eax,%eax\ncall   33b0 <libmin_printf>\nlea    0x2f4c(%rip),%rdi\nxor    %eax,%eax\ncall   33b0 <libmin_printf>\nmov    $0x80,%ecx\nxor    %r10d,%r10d\nxor    %r9d,%r9d\nlea    0x512e(%rip),%rsi\nmov    $0x3,%r8d\nmov    $0x3,%edx\nmovabs $0x101010101010101,%rax\nmov    %rsi,%rdi\nrep stos %rax,%es:(%rdi)\nmov    %rsi,%rcx\njmp    1189 <main+0x89>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%rcx\nadd    $0x2,%rdx\nadd    $0x3,%r8\ncmp    %rcx,%rdi\nje     11c0 <main+0xc0>\ncmpb   $0x0,(%rcx)\nje     1178 <main+0x78>\nadd    $0x1,%r9\nmov    %rdx,%r10\nmov    %r8,%rax\ncmp    $0x3ff,%r8\nja     1178 <main+0x78>\nnopl   0x0(%rax)\nmovb   $0x0,(%rsi,%rax,1)\nadd    %rdx,%rax\ncmp    $0x3ff,%rax\njle    11a8 <main+0xa8>\njmp    1178 <main+0x78>\nnopl   0x0(%rax)\nmov    %r10,%rcx\nmov    %r9,%rdx\nmov    $0x400,%esi\nxor    %eax,%eax\nlea    0x2eca(%rip),%rdi\ncall   33b0 <libmin_printf>\ncall   35f0 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "simple-grep/simple-grep.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int ac = 3; char *av[] = { \"simple-grep\", \"speech.txt\", \"the\" };\n  char lineBuffer[BUFFER_LENGTH+1];\n  MFILE *fp = &speech;\n  int count = 0;\n\n  if (ac < 3)\n  {\n    libmin_printf(\"A string pattern and a file name are required\\n\" );\n    return 1;\n  }\n\n  libmin_mopen(&speech, \"r\");\n  if (!fp)\n  {\n    libmin_printf(\"Error - unable to open %s\\n\", av[1]);\n    return 2;\n  }\n\n  while (libmin_mgets(lineBuffer, BUFFER_LENGTH, fp))\n  {\n    // libmin_printf(\"%s\\n\", lineBuffer);\n    if (libmin_strstr(lineBuffer, av[2]))\n    {\n      libmin_printf(\"%s\", lineBuffer);\n      ++count;\n    }\n  }\n  libmin_mclose(fp);\n\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", count, av[2]);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "simple-grep/simple-grep.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r13d\n  char lineBuffer[520]; // [rsp+0h] [rbp-238h] BYREF\n  unsigned __int64 v5; // [rsp+208h] [rbp-30h]\n\n  v3 = 0;\n  v5 = __readfsqword(0x28u);\n  libmin_mopen(&speech, \"r\");\n  while ( libmin_mgets(lineBuffer, 0x1FFuLL, &speech) )\n  {\n    if ( libmin_strstr(lineBuffer, \"the\") )\n    {\n      ++v3;\n      libmin_printf(\"%s\", lineBuffer);\n    }\n  }\n  libmin_mclose(&speech);\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", v3, \"the\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  char lineBuffer[520];\n  unsigned long long v5;\n  v3 = 0;\n  v5 = __readfsqword(40u);\n  libmin_mopen(&speech, \"r\");\n  while (libmin_mgets(lineBuffer, 511uLL, &speech)) {\n    if (libmin_strstr(lineBuffer, \"the\")) {\n      ++v3;\n      libmin_printf(\"%s\", lineBuffer);\n    }\n  }\n  libmin_mclose(&speech);\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", v3,\n                \"the\");\n  libmin_success();\n}", "binary": "simple-grep/simple-grep.host.O3", "assembly": "<main>:\nendbr64\npush   %r14\nlea    0x2ed7(%rip),%rsi\nlea    0x2ed6(%rip),%r14\npush   %r13\nxor    %r13d,%r13d\npush   %r12\nlea    0x2ec4(%rip),%r12\npush   %rbp\nlea    0x6ed6(%rip),%rbp\npush   %rbx\nmov    %rbp,%rdi\nsub    $0x210,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x208(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbx\ncall   16c0 <libmin_mopen>\njmp    1188 <main+0x68>\nnopw   0x0(%rax,%rax,1)\nmov    %r12,%rsi\nmov    %rbx,%rdi\ncall   38f0 <libmin_strstr>\ntest   %rax,%rax\njne    11e8 <main+0xc8>\nmov    %rbp,%rdx\nmov    $0x1ff,%esi\nmov    %rbx,%rdi\ncall   14e0 <libmin_mgets>\ntest   %rax,%rax\njne    1178 <main+0x58>\nmov    %rbp,%rdi\ncall   14d0 <libmin_mclose>\nmov    %r12,%rdx\nmov    %r13d,%esi\nxor    %eax,%eax\nlea    0x2e64(%rip),%rdi\ncall   3600 <libmin_printf>\ncall   3960 <libmin_success>\nmov    0x208(%rsp),%rax\nsub    %fs:0x28,%rax\njne    11fb <main+0xdb>\nadd    $0x210,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nmov    %rbx,%rsi\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x1,%r13d\ncall   3600 <libmin_printf>\njmp    1188 <main+0x68>\ncall   10c0 <__stack_chk_fail@plt>\n"}
{"source": {"path": "skeleton/skeleton.c", "function_name": "main", "content": "#include \"libmin.h\"\n\nint\nmain(void)\n{\n  libmin_printf(\"This is a test!, %d, %f...\\n\", 23, 44.4);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "skeleton/skeleton.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"This is a test!, %d, %f...\\n\", 23, 44.4);\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "skeleton/skeleton.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x17,%esi\nmov    $0x1,%eax\nmovsd  0x2f06(%rip),%xmm0\nlea    0x2ee3(%rip),%rdi\ncall   3300 <libmin_printf>\ncall   3540 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "spelt2num/spelt2num.c", "function_name": "main", "content": "int main(){char **r;int e=0;for(;n++||(e=*p++)>0;b=\"ynwtsflrabg\"[n%=11]-e?b:b*8+n)for(r=(char **)(b%64-25);e<47&&b;b/=8)for(n=19;n;(void)(((n[\"1+DIY/.K430x9G(kC[\"]-42)&255)^b||(m+=n>15?n:n>9?m%u*~-u:~(long)r?n+!(long)r*16:n*16,b=0)))u=1ll<<6177%n--*4;libmin_printf(\"%llx\\n\",m);libmin_success();}\n"}, "pseudo": {"path": "spelt2num/spelt2num.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rcx\n  int v4; // r14d\n  __int64 v5; // rax\n  char *v6; // r15\n  __int64 v7; // rsi\n  __int64 v8; // r9\n  __int64 v9; // r12\n  __int64 v10; // rbx\n  char v11; // bp\n  char v12; // dl\n  __int64 v13; // rsi\n  __int64 v14; // rdi\n  char v15; // al\n  __int64 v16; // rdx\n  __int64 v17; // [rsp+8h] [rbp-40h]\n\n  v4 = 0;\n  v5 = n;\n  v6 = p;\n  v17 = m;\n  while ( 1 )\n  {\n    v7 = v5 + 1;\n    n = v5 + 1;\n    if ( !v5 )\n    {\n      p = v6 + 1;\n      v4 = *v6;\n      if ( v4 <= 0 )\n      {\n        libmin_printf(\"%llx\\n\", v17);\n        libmin_success();\n      }\n      ++v6;\n    }\n    v8 = b;\n    v9 = b % 64;\n    if ( v4 <= 46 && (v10 = v17, v11 = 0, v12 = 0, b) )\n    {\n      do\n      {\n        v13 = 19LL;\n        while ( v13 )\n        {\n          v14 = v13 - 1;\n          v12 = 1;\n          v3 = 1LL << (4 * (unsigned __int8)(6177 % v13));\n          v15 = a1DiyK430x9gKc[--v13];\n          if ( (unsigned __int8)(v15 - 42) == v8 )\n          {\n            v16 = v14;\n            if ( v14 <= 15 )\n            {\n              if ( v14 <= 9 )\n              {\n                v16 = 16 * v14;\n                if ( v9 != 24 )\n                  v16 = v14 + 16LL * (v9 == 25);\n              }\n              else\n              {\n                v16 = (v3 - 1) * (v10 % v3);\n              }\n            }\n            v10 += v16;\n            v13 = v14;\n            v11 = 1;\n            v8 = 0LL;\n            v12 = 1;\n          }\n        }\n        v8 /= 8LL;\n      }\n      while ( v8 );\n      if ( v11 )\n        m = v10;\n      else\n        v10 = v17;\n      if ( v12 )\n        u = v3;\n      v17 = v10;\n      v5 = 0LL;\n    }\n    else\n    {\n      v5 = v7 % 11;\n      if ( aYnwtsflrabg[v7 % 11] == v4 )\n        v8 = v5 + 8 * b;\n    }\n    b = v8;\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  long long v5;\n  char *v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  long long v10;\n  char v11;\n  char v12;\n  long long v13;\n  long long v14;\n  char v15;\n  long long v16;\n  long long v17;\n  v4 = 0;\n  v5 = n;\n  v6 = p;\n  v17 = m;\n  while (1) {\n    v7 = v5 + 1;\n    n = v5 + 1;\n    if (!v5) {\n      p = v6 + 1;\n      v4 = *v6;\n      if (v4 <= 0) {\n        libmin_printf(\"%llx\\n\", v17);\n        libmin_success();\n      }\n      ++v6;\n    }\n    v8 = b;\n    v9 = b % 64;\n    if (v4 <= 46 && (v10 = v17, v11 = 0, v12 = 0, b)) {\n      do {\n        v13 = 19LL;\n        while (v13) {\n          v14 = v13 - 1;\n          v12 = 1;\n          v3 = 1LL << (4 * (unsigned char)(6177 % v13));\n          v15 = a1DiyK430x9gKc[--v13];\n          if ((unsigned char)(v15 - 42) == v8) {\n            v16 = v14;\n            if (v14 <= 15) {\n              if (v14 <= 9) {\n                v16 = 16 * v14;\n                if (v9 != 24) v16 = v14 + 16LL * (v9 == 25);\n              } else {\n                v16 = (v3 - 1) * (v10 % v3);\n              }\n            }\n            v10 += v16;\n            v13 = v14;\n            v11 = 1;\n            v8 = 0LL;\n            v12 = 1;\n          }\n        }\n        v8 /= 8LL;\n      } while (v8);\n      if (v11)\n        m = v10;\n      else\n        v10 = v17;\n      if (v12) u = v3;\n      v17 = v10;\n      v5 = 0LL;\n    } else {\n      v5 = v7 % 11;\n      if (aYnwtsflrabg[v7 % 11] == v4) v8 = v5 + 8 * b;\n    }\n    b = v8;\n  }\n}", "binary": "spelt2num/spelt2num.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x1821,%r8d\nmov    $0x1,%r11d\nlea    0x2eeb(%rip),%r10\npush   %r14\nxor    %r14d,%r14d\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    0x5149(%rip),%rbx\nmov    0x5152(%rip),%rax\nmov    0x4ed3(%rip),%r15\nmov    %rbx,0x8(%rsp)\nlea    0x1(%rax),%rsi\nmov    %rsi,0x513b(%rip)\ntest   %rax,%rax\njne    116d <main+0x6d>\nlea    0x1(%r15),%rax\nmov    %rax,0x4eb3(%rip)\nmovsbl (%r15),%r14d\ntest   %r14d,%r14d\njle    12dd <main+0x1dd>\nmov    %rax,%r15\nmov    0x50fc(%rip),%r9\nmov    %r9,%rax\nsar    $0x3f,%rax\nshr    $0x3a,%rax\nlea    (%r9,%rax,1),%r12\nand    $0x3f,%r12d\nsub    %rax,%r12\ncmp    $0x2e,%r14d\njg     128a <main+0x18a>\nxor    %r13d,%r13d\ncmp    $0x19,%r12\nmov    0x8(%rsp),%rbx\nsete   %r13b\nxor    %ebp,%ebp\nxor    %edx,%edx\nshl    $0x4,%r13\ntest   %r9,%r9\nje     128a <main+0x18a>\nnopl   (%rax)\nmov    $0x13,%esi\njmp    11f5 <main+0xf5>\nnop\nmov    %r8,%rax\nlea    -0x1(%rsi),%rdi\ncqto\nidiv   %rsi\nmov    %r11,%rax\nlea    0x0(,%rdx,4),%ecx\nmov    $0x1,%edx\nshl    %cl,%rax\nmov    %rax,%rcx\nmovsbl -0x1(%r10,%rsi,1),%eax\nmov    %rdi,%rsi\nsub    $0x2a,%eax\nmovzbl %al,%eax\ncmp    %r9,%rax\nje     1240 <main+0x140>\ntest   %rsi,%rsi\njne    11c0 <main+0xc0>\ntest   %r9,%r9\nlea    0x7(%r9),%rax\ncmovns %r9,%rax\nsar    $0x3,%rax\nmov    %rax,%r9\njne    11b8 <main+0xb8>\ntest   %bpl,%bpl\nje     12d3 <main+0x1d3>\nmov    %rbx,0x505a(%rip)\ntest   %dl,%dl\nje     1229 <main+0x129>\nmov    %rcx,0x5057(%rip)\nmov    %rbx,0x8(%rsp)\nxor    %eax,%eax\nmov    %r9,0x5039(%rip)\njmp    1142 <main+0x42>\nnopl   0x0(%rax)\nmov    %rdi,%rdx\ncmp    $0xf,%rdi\njg     125f <main+0x15f>\ncmp    $0x9,%rdi\njle    1278 <main+0x178>\nmov    %rbx,%rax\ncqto\nidiv   %rcx\nlea    -0x1(%rcx),%rax\nimul   %rax,%rdx\nadd    %rdx,%rbx\nmov    %rdi,%rsi\nmov    $0x1,%ebp\nxor    %r9d,%r9d\nmov    $0x1,%edx\njmp    11f5 <main+0xf5>\nnopl   0x0(%rax)\nshl    $0x4,%rdx\nlea    (%rdi,%r13,1),%rax\ncmp    $0x18,%r12\ncmovne %rax,%rdx\njmp    125f <main+0x15f>\nmovabs $0x2e8ba2e8ba2e8ba3,%rdx\nmov    %rsi,%rax\nimul   %rdx\nmov    %rdx,%rax\nmov    %rsi,%rdx\nsar    $0x3f,%rdx\nsar    %rax\nsub    %rdx,%rax\nlea    (%rax,%rax,4),%rdx\nlea    (%rax,%rdx,2),%rdx\nmov    %rsi,%rax\nsub    %rdx,%rax\nlea    0x2d5e(%rip),%rdx\nmovsbl (%rdx,%rax,1),%esi\nlea    (%rax,%r9,8),%rdx\ncmp    %r14d,%esi\ncmove  %rdx,%r9\njmp    1230 <main+0x130>\nmov    0x8(%rsp),%rbx\njmp    121e <main+0x11e>\nmov    0x8(%rsp),%rsi\nlea    0x2d2e(%rip),%rdi\nxor    %eax,%eax\ncall   34d0 <libmin_printf>\ncall   3710 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "spirograph/spirograph.c", "function_name": "main", "content": "/** Main function */\nint main(int argc, char **argv)\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "spirograph/spirograph.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  test();\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "spirograph/spirograph.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\ncall   1390 <test>\ncall   4530 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "spirograph/spirograph.c", "function_name": "spirograph", "content": "/**\n * @file\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Implementation of\n * [Spirograph](https://en.wikipedia.org/wiki/Spirograph)\n *\n * @details\n * Implementation of the program is based on the geometry shown in the figure\n * below:\n *\n * <a\n * href=\"https://commons.wikimedia.org/wiki/File:Resonance_Cascade.svg\"><img\n * src=\"https://upload.wikimedia.org/wikipedia/commons/3/39/Resonance_Cascade.svg\"\n * alt=\"Spirograph geometry from Wikipedia\" style=\"width: 250px\"/></a>\n */\n#include \"libmin.h\"\n\n/** Generate spirograph curve into arrays `x` and `y` such that the i^th point\n * in 2D is represented by `(x[i],y[i])`. The generating function is given by:\n * \\f{eqnarray*}{\n * x &=& R\\left[ (1-k) \\cos (t) + l\\cdot k\\cdot\\cos \\left(\\frac{1-k}{k}t\\right)\n * \\right]\\\\\n * y &=& R\\left[ (1-k) \\sin (t) - l\\cdot k\\cdot\\sin \\left(\\frac{1-k}{k}t\\right)\n * \\right] \\f}\n * where\n * * \\f$R\\f$ is the scaling parameter that we will consider \\f$=1\\f$\n * * \\f$l=\\frac{\\rho}{r}\\f$ is the relative distance of marker from the centre\n * of inner circle and \\f$0\\le l\\le1\\f$\n * * \\f$\\rho\\f$ is physical distance of marker from centre of inner circle\n * * \\f$r\\f$ is the radius of inner circle\n * * \\f$k=\\frac{r}{R}\\f$ is the ratio of radius of inner circle to outer circle\n * and \\f$0<k<1\\f$\n * * \\f$R\\f$ is the radius of outer circle\n * * \\f$t\\f$ is the angle of rotation of the point i.e., represents the time\n * parameter\n *\n * Since we are considering ratios, the actual values of \\f$r\\f$ and\n * \\f$R\\f$ are immaterial.\n *\n * @param [out] x output array containing absicca of points (must be\n * pre-allocated)\n * @param [out] y output array containing ordinates of points (must be\n * pre-allocated)\n * @param l the relative distance of marker from the centre of\n * inner circle and \\f$0\\le l\\le1\\f$\n * @param k the ratio of radius of inner circle to outer circle and\n * \\f$0<k<1\\f$\n * @param N number of sample points along the trajectory (higher = better\n * resolution but consumes more time and memory)\n * @param num_rot the number of rotations to perform (can be fractional value)\n */\nvoid spirograph(double *x, double *y, double l, double k, size_t N, double rot)\n{\n    double dt = rot * 2.f * M_PI / N;\n    double t = 0.f, R = 1.f;\n    const double k1 = 1.f - k;\n\n    for (size_t dk = 0; dk < N; dk++, t += dt)\n    {\n        x[dk] = R * (k1 * libmin_cos(t) + l * k * libmin_cos(k1 * t / k));\n        y[dk] = R * (k1 * libmin_sin(t) - l * k * libmin_sin(k1 * t / k));\n    }\n}\n"}, "pseudo": {"path": "spirograph/spirograph.host.O3.pseudo", "function_name": "spirograph", "address": "0x1230", "label": "spirograph", "content": "void __fastcall spirograph(double *x, double *y, double l, double k, __int64 N, double rot)\n{\n  double v7; // xmm2_8\n  double v8; // xmm1_8\n  double v9; // xmm2_8\n  double v10; // xmm1_8\n  __int64 v11; // r13\n  double v12; // xmm2_8\n  double v13; // xmm1_8\n  double k1_0; // [rsp+0h] [rbp-60h]\n  double v15; // [rsp+8h] [rbp-58h]\n  double v16; // [rsp+10h] [rbp-50h]\n  double dt; // [rsp+30h] [rbp-30h]\n\n  v7 = (rot + rot) * 3.141592653589793;\n  if ( N < 0 )\n    v8 = (double)(int)(N & 1 | ((unsigned __int64)N >> 1)) + (double)(int)(N & 1 | ((unsigned __int64)N >> 1));\n  else\n    v8 = (double)(int)N;\n  v9 = v7 / v8;\n  v10 = 1.0 - k;\n  k1_0 = 1.0 - k;\n  dt = v9;\n  if ( N )\n  {\n    v11 = 0LL;\n    v12 = 0.0;\n    v15 = l * k;\n    do\n    {\n      v16 = libmin_cos(v10) * k1_0;\n      x[v11] = libmin_cos(v10) * v15 + v16;\n      v13 = k1_0 * libmin_sin(v10);\n      v12 = v12 + dt;\n      v10 = v13 - libmin_sin(v13) * v15;\n      y[v11++] = v10;\n    }\n    while ( N != v11 );\n  }\n}\n"}, "pseudo_normalize": "void spirograph(double *x, double *y, double l, double k, long long N,\n                double rot) {\n  double v7;\n  double v8;\n  double v9;\n  double v10;\n  long long v11;\n  double v12;\n  double v13;\n  double k1_0;\n  double v15;\n  double v16;\n  double dt;\n  v7 = (rot + rot) * 3.141592653589793;\n  if (N < 0)\n    v8 = (double)(int)(N & 1 | ((unsigned long long)N >> 1)) +\n         (double)(int)(N & 1 | ((unsigned long long)N >> 1));\n  else\n    v8 = (double)(int)N;\n  v9 = v7 / v8;\n  v10 = 1.0 - k;\n  k1_0 = 1.0 - k;\n  dt = v9;\n  if (N) {\n    v11 = 0LL;\n    v12 = 0.0;\n    v15 = l * k;\n    do {\n      v16 = libmin_cos(v10) * k1_0;\n      x[v11] = libmin_cos(v10) * v15 + v16;\n      v13 = k1_0 * libmin_sin(v10);\n      v12 = v12 + dt;\n      v10 = v13 - libmin_sin(v13) * v15;\n      y[v11++] = v10;\n    } while (N != v11);\n  }\n}", "binary": "spirograph/spirograph.host.O3", "assembly": "<spirograph>:\nendbr64\npush   %r13\naddsd  %xmm2,%xmm2\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rdx,%rbx\nsub    $0x48,%rsp\nmovsd  %xmm1,0x30(%rsp)\nmulsd  0x4dbf(%rip),%xmm2\ntest   %rdx,%rdx\njs     1370 <spirograph+0x140>\npxor   %xmm1,%xmm1\ncvtsi2sd %rdx,%xmm1\ndivsd  %xmm1,%xmm2\nmovsd  0x30(%rsp),%xmm4\nmovsd  0x4da3(%rip),%xmm1\nsubsd  %xmm4,%xmm1\nmovsd  %xmm1,0x8(%rsp)\nmovsd  %xmm2,0x38(%rsp)\ntest   %rbx,%rbx\nje     135e <spirograph+0x12e>\nmulsd  %xmm4,%xmm0\nxor    %r13d,%r13d\npxor   %xmm2,%xmm2\nmovsd  %xmm0,0x10(%rsp)\nnopw   0x0(%rax,%rax,1)\nmovapd %xmm2,%xmm0\nmovsd  %xmm2,0x20(%rsp)\ncall   3d60 <libmin_cos>\nmovsd  0x8(%rsp),%xmm3\nmovsd  0x20(%rsp),%xmm2\nmulsd  %xmm3,%xmm0\nmulsd  %xmm2,%xmm3\ndivsd  0x30(%rsp),%xmm3\nmovsd  %xmm3,0x28(%rsp)\nmovsd  %xmm0,0x18(%rsp)\nmovapd %xmm3,%xmm0\ncall   3d60 <libmin_cos>\nmulsd  0x10(%rsp),%xmm0\nmovsd  0x20(%rsp),%xmm2\naddsd  0x18(%rsp),%xmm0\nmovsd  %xmm0,0x0(%rbp,%r13,8)\nmovapd %xmm2,%xmm0\ncall   4150 <libmin_sin>\nmovsd  0x8(%rsp),%xmm1\nmovsd  0x28(%rsp),%xmm3\nmulsd  %xmm0,%xmm1\nmovapd %xmm3,%xmm0\nmovsd  %xmm1,0x18(%rsp)\ncall   4150 <libmin_sin>\nmulsd  0x10(%rsp),%xmm0\nmovsd  0x18(%rsp),%xmm1\nmovsd  0x20(%rsp),%xmm2\naddsd  0x38(%rsp),%xmm2\nsubsd  %xmm0,%xmm1\nmovsd  %xmm1,(%r12,%r13,8)\nadd    $0x1,%r13\ncmp    %r13,%rbx\njne    12b0 <spirograph+0x80>\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nmov    %rdx,%rax\nand    $0x1,%edx\npxor   %xmm1,%xmm1\nshr    %rax\nor     %rdx,%rax\ncvtsi2sd %rax,%xmm1\naddsd  %xmm1,%xmm1\njmp    126b <spirograph+0x3b>\nxchg   %ax,%ax\n"}
{"source": {"path": "spirograph/spirograph.c", "function_name": "test", "content": "/**\n * @brief Test function to save resulting points to a CSV file.\n *\n */\nvoid test(void)\n{\n    size_t N = 500;\n    double l = 0.3, k = 0.75, rot = 10.;\n    double *x = (double *)libmin_malloc(N * sizeof(double));\n    double *y = (double *)libmin_malloc(N * sizeof(double));\n\n    spirograph(x, y, l, k, N, rot);\n\n    for (size_t i = 0; i < N; i++)\n    {\n        libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n    }\n\n    libmin_free(x);\n    libmin_free(y);\n}\n"}, "pseudo": {"path": "spirograph/spirograph.host.O3.pseudo", "function_name": "test", "address": "0x1390", "label": "test", "content": "void __cdecl test()\n{\n  double v0; // xmm1_8\n  __int64 v1; // r13\n  double *v2; // r12\n  double v3; // xmm2_8\n  double *v4; // rbp\n  double v5; // xmm1_8\n  double v6; // rbx\n  __int64 i; // rbx\n  double v8; // xmm0_8\n  double v9; // xmm1_8\n  double v10; // [rsp+18h] [rbp-30h]\n\n  v1 = 0LL;\n  v2 = (double *)libmin_malloc(0xFA0uLL);\n  v3 = 0.0;\n  v4 = (double *)libmin_malloc(0xFA0uLL);\n  do\n  {\n    v10 = libmin_cos(v0);\n    v5 = v10 * 0.25 + libmin_cos(v0) * 0.225;\n    v2[v1] = v5;\n    v6 = libmin_sin(v5);\n    v3 = v3 + 0.1256637061435917;\n    v0 = libmin_sin(v5) * 0.225;\n    v4[v1++] = v6 * 0.25 - v0;\n  }\n  while ( v1 != 500 );\n  for ( i = 0LL; i != 500; ++i )\n  {\n    v8 = v2[i];\n    v9 = v4[i];\n    libmin_printf(\"%.5lf, %.5lf\\n\", v8, v9);\n  }\n  libmin_free(v2);\n  libmin_free(v4);\n}\n"}, "pseudo_normalize": "void test() {\n  double v0;\n  long long v1;\n  double *v2;\n  double v3;\n  double *v4;\n  double v5;\n  double v6;\n  long long i;\n  double v8;\n  double v9;\n  double v10;\n  v1 = 0LL;\n  v2 = (double *)libmin_malloc(4000uLL);\n  v3 = 0.0;\n  v4 = (double *)libmin_malloc(4000uLL);\n  do {\n    v10 = libmin_cos(v0);\n    v5 = v10 * 0.25 + libmin_cos(v0) * 0.225;\n    v2[v1] = v5;\n    v6 = libmin_sin(v5);\n    v3 = v3 + 0.1256637061435917;\n    v0 = libmin_sin(v5) * 0.225;\n    v4[v1++] = v6 * 0.25 - v0;\n  } while (v1 != 500);\n  for (i = 0LL; i != 500; ++i) {\n    v8 = v2[i];\n    v9 = v4[i];\n    libmin_printf(\"%.5lf, %.5lf\\n\", v8, v9);\n  }\n  libmin_free(v2);\n  libmin_free(v4);\n}", "binary": "spirograph/spirograph.host.O3", "assembly": "<test>:\nendbr64\npush   %r13\nmov    $0xfa0,%edi\nxor    %r13d,%r13d\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\ncall   16b0 <libmin_malloc>\nmov    $0xfa0,%edi\nmov    %rax,%r12\ncall   16b0 <libmin_malloc>\npxor   %xmm2,%xmm2\nmov    %rax,%rbp\nnop\nmovapd %xmm2,%xmm0\nmovsd  %xmm2,0x8(%rsp)\ncall   3d60 <libmin_cos>\nmovsd  0x8(%rsp),%xmm2\nmovsd  0x4c4b(%rip),%xmm3\nmovsd  %xmm0,0x18(%rsp)\nmulsd  %xmm2,%xmm3\ndivsd  0x4c41(%rip),%xmm3\nmovapd %xmm3,%xmm0\nmovsd  %xmm3,0x10(%rsp)\ncall   3d60 <libmin_cos>\nmovsd  0x18(%rsp),%xmm1\nmulsd  0x4c2c(%rip),%xmm0\nmulsd  0x4c14(%rip),%xmm1\nmovsd  0x8(%rsp),%xmm2\naddsd  %xmm0,%xmm1\nmovapd %xmm2,%xmm0\nmovsd  %xmm1,(%r12,%r13,8)\ncall   4150 <libmin_sin>\nmovsd  0x10(%rsp),%xmm3\nmovq   %xmm0,%rbx\nmovapd %xmm3,%xmm0\ncall   4150 <libmin_sin>\nmovsd  0x8(%rsp),%xmm2\naddsd  0x4bf1(%rip),%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rbx,%xmm0\nmulsd  0x4bd8(%rip),%xmm1\nmulsd  0x4bc0(%rip),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,0x0(%rbp,%r13,8)\nadd    $0x1,%r13\ncmp    $0x1f4,%r13\njne    13c0 <test+0x30>\nxor    %ebx,%ebx\nlea    0x4b77(%rip),%r13\nnopl   (%rax)\nmovsd  (%r12,%rbx,8),%xmm0\nmovsd  0x0(%rbp,%rbx,8),%xmm1\nmov    %r13,%rdi\nmov    $0x2,%eax\nadd    $0x1,%rbx\ncall   39f0 <libmin_printf>\ncmp    $0x1f4,%rbx\njne    1490 <test+0x100>\nmov    %r12,%rdi\ncall   1760 <libmin_free>\nadd    $0x28,%rsp\nmov    %rbp,%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    1760 <libmin_free>\n"}
{"source": {"path": "sudoku-solver/sudoku-solver.c", "function_name": "isSafe", "content": "// Check if placing num at board[row][col] is valid.\nint isSafe(int row, int col, int num) {\n    // Check row for duplicates.\n    for (int i = 0; i < N; i++) {\n        if (board[row][i] == num)\n            return 0;\n    }\n    // Check column for duplicates.\n    for (int i = 0; i < N; i++) {\n        if (board[i][col] == num)\n            return 0;\n    }\n    // Check 3x3 subgrid for duplicates.\n    int startRow = row - row % 3;\n    int startCol = col - col % 3;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (board[startRow + i][startCol + j] == num)\n                return 0;\n        }\n    }\n    return 1;\n}\n"}, "pseudo": {"path": "sudoku-solver/sudoku-solver.host.O3.pseudo", "function_name": "isSafe", "address": "0x1250", "label": "isSafe", "content": "int __fastcall isSafe(int row, int col, int num)\n{\n  int *v3; // rcx\n  int v4; // edi\n  int v5; // esi\n  __int64 v6; // r9\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // rsi\n  __int64 v10; // rcx\n  __int64 v11; // rcx\n\n  v3 = board[row];\n  if ( num == *v3 )\n    return 0;\n  if ( num == v3[1] )\n    return 0;\n  if ( num == v3[2] )\n    return 0;\n  if ( num == v3[3] )\n    return 0;\n  if ( num == v3[4] )\n    return 0;\n  if ( num == v3[5] )\n    return 0;\n  if ( num == v3[6] )\n    return 0;\n  if ( num == v3[7] )\n    return 0;\n  if ( v3[8] == num )\n    return 0;\n  if ( num == board[0][col] )\n    return 0;\n  if ( num == board[1][col] )\n    return 0;\n  if ( num == board[2][col] )\n    return 0;\n  if ( num == board[3][col] )\n    return 0;\n  if ( num == board[4][col] )\n    return 0;\n  if ( num == board[5][col] )\n    return 0;\n  if ( num == board[6][col] )\n    return 0;\n  if ( num == board[7][col] )\n    return 0;\n  if ( board[8][col] == num )\n    return 0;\n  v4 = 3 * (row / 3);\n  v5 = 3 * (col / 3);\n  v6 = v5;\n  v7 = v4;\n  if ( num == board[v7][v5] )\n    return 0;\n  v8 = v5 + 1;\n  if ( num == board[0][v8 + v7 * 9] )\n    return 0;\n  v9 = v5 + 2;\n  if ( num == board[v4][v9] )\n    return 0;\n  v10 = v4 + 1;\n  if ( num == board[v10][v6] )\n    return 0;\n  if ( num == board[v10][v8] )\n    return 0;\n  if ( num == board[0][v9 + v10 * 9] )\n    return 0;\n  v11 = v4 + 2;\n  return num != board[v11][v6] && num != board[v11][v8] && board[0][v9 + v11 * 9] != num;\n}\n"}, "pseudo_normalize": "int isSafe(int row, int col, int num) {\n  int *v3;\n  int v4;\n  int v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  long long v10;\n  long long v11;\n  v3 = board[row];\n  if (num == *v3) return 0;\n  if (num == v3[1]) return 0;\n  if (num == v3[2]) return 0;\n  if (num == v3[3]) return 0;\n  if (num == v3[4]) return 0;\n  if (num == v3[5]) return 0;\n  if (num == v3[6]) return 0;\n  if (num == v3[7]) return 0;\n  if (v3[8] == num) return 0;\n  if (num == board[0][col]) return 0;\n  if (num == board[1][col]) return 0;\n  if (num == board[2][col]) return 0;\n  if (num == board[3][col]) return 0;\n  if (num == board[4][col]) return 0;\n  if (num == board[5][col]) return 0;\n  if (num == board[6][col]) return 0;\n  if (num == board[7][col]) return 0;\n  if (board[8][col] == num) return 0;\n  v4 = 3 * (row / 3);\n  v5 = 3 * (col / 3);\n  v6 = v5;\n  v7 = v4;\n  if (num == board[v7][v5]) return 0;\n  v8 = v5 + 1;\n  if (num == board[0][v8 + v7 * 9]) return 0;\n  v9 = v5 + 2;\n  if (num == board[v4][v9]) return 0;\n  v10 = v4 + 1;\n  if (num == board[v10][v6]) return 0;\n  if (num == board[v10][v8]) return 0;\n  if (num == board[0][v9 + v10 * 9]) return 0;\n  v11 = v4 + 2;\n  return num != board[v11][v6] && num != board[v11][v8] &&\n         board[0][v9 + v11 * 9] != num;\n}", "binary": "sudoku-solver/sudoku-solver.host.O3", "assembly": "<isSafe>:\nendbr64\nmov    %esi,%r8d\nmovslq %edi,%rsi\nmov    %edx,%eax\nlea    (%rsi,%rsi,8),%rcx\nlea    0x4db9(%rip),%rdx\nlea    (%rdx,%rcx,4),%rcx\ncmp    (%rcx),%eax\nje     13d8 <isSafe+0x188>\ncmp    0x4(%rcx),%eax\nje     13d8 <isSafe+0x188>\ncmp    0x8(%rcx),%eax\nje     13d8 <isSafe+0x188>\ncmp    0xc(%rcx),%eax\nje     13d8 <isSafe+0x188>\ncmp    0x10(%rcx),%eax\nje     13d8 <isSafe+0x188>\ncmp    0x14(%rcx),%eax\nje     13d8 <isSafe+0x188>\ncmp    0x18(%rcx),%eax\nje     13d8 <isSafe+0x188>\ncmp    0x1c(%rcx),%eax\nje     13d8 <isSafe+0x188>\ncmp    %eax,0x20(%rcx)\nje     13d8 <isSafe+0x188>\nmovslq %r8d,%rcx\ncmp    (%rdx,%rcx,4),%eax\nje     13d8 <isSafe+0x188>\ncmp    0x24(%rdx,%rcx,4),%eax\nje     13d8 <isSafe+0x188>\ncmp    0x48(%rdx,%rcx,4),%eax\nje     13d8 <isSafe+0x188>\ncmp    0x6c(%rdx,%rcx,4),%eax\nje     13d8 <isSafe+0x188>\ncmp    0x90(%rdx,%rcx,4),%eax\nje     13d8 <isSafe+0x188>\ncmp    0xb4(%rdx,%rcx,4),%eax\nje     13d8 <isSafe+0x188>\ncmp    0xd8(%rdx,%rcx,4),%eax\nje     13d8 <isSafe+0x188>\ncmp    0xfc(%rdx,%rcx,4),%eax\nje     13d8 <isSafe+0x188>\ncmp    %eax,0x120(%rdx,%rcx,4)\nje     13d8 <isSafe+0x188>\nimul   $0x55555556,%rsi,%rsi\nsar    $0x1f,%edi\nsar    $0x1f,%r8d\nimul   $0x55555556,%rcx,%rcx\nshr    $0x20,%rsi\nsub    %edi,%esi\nshr    $0x20,%rcx\nsub    %r8d,%ecx\nlea    (%rsi,%rsi,2),%edi\nmovslq %edi,%r10\nlea    (%rcx,%rcx,2),%esi\nmovslq %esi,%r9\nlea    (%r10,%r10,8),%rcx\nlea    (%rcx,%r9,1),%r8\ncmp    (%rdx,%r8,4),%eax\nje     13d8 <isSafe+0x188>\nlea    0x1(%rsi),%r8d\nmovslq %r8d,%r8\nadd    %r8,%rcx\ncmp    (%rdx,%rcx,4),%eax\nje     13d8 <isSafe+0x188>\nadd    $0x2,%esi\nlea    (%r10,%r10,8),%rcx\nmovslq %esi,%rsi\nadd    %rsi,%rcx\ncmp    (%rdx,%rcx,4),%eax\nje     13d8 <isSafe+0x188>\nlea    0x1(%rdi),%ecx\nmovslq %ecx,%rcx\nlea    (%rcx,%rcx,8),%rcx\nlea    (%rcx,%r9,1),%r10\ncmp    (%rdx,%r10,4),%eax\nje     13d8 <isSafe+0x188>\nlea    (%rcx,%r8,1),%r10\ncmp    (%rdx,%r10,4),%eax\nje     13d8 <isSafe+0x188>\nadd    %rsi,%rcx\ncmp    (%rdx,%rcx,4),%eax\nje     13d8 <isSafe+0x188>\nlea    0x2(%rdi),%ecx\nmovslq %ecx,%rcx\nlea    (%rcx,%rcx,8),%rcx\nadd    %rcx,%r9\ncmp    (%rdx,%r9,4),%eax\nje     13d8 <isSafe+0x188>\nadd    %rcx,%r8\ncmp    (%rdx,%r8,4),%eax\nje     13d8 <isSafe+0x188>\nadd    %rsi,%rcx\ncmp    %eax,(%rdx,%rcx,4)\nsetne  %al\nmovzbl %al,%eax\nret\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "sudoku-solver/sudoku-solver.c", "function_name": "main", "content": "int main() {\n    libmin_printf(\"Initial Sudoku Puzzle:\\n\");\n    printBoard();\n\n    if (solveSudoku()) {\n        libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n        printBoard();\n        libtarg_success();\n    } else {\n        libmin_printf(\"No solution found.\\n\");\n        libtarg_fail(1);\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "sudoku-solver/sudoku-solver.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if ( solveSudoku() )\n  {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if (solveSudoku()) {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}", "binary": "sudoku-solver/sudoku-solver.host.O3", "assembly": "<main>:\nendbr64\npush   %rax\npop    %rax\nlea    0x2efb(%rip),%rdi\nxor    %eax,%eax\nsub    $0x8,%rsp\ncall   38b0 <libmin_printf>\nxor    %eax,%eax\ncall   1770 <printBoard>\nxor    %eax,%eax\ncall   13e0 <solveSudoku>\ntest   %eax,%eax\nje     1144 <main+0x44>\nlea    0x2eef(%rip),%rdi\nxor    %eax,%eax\ncall   38b0 <libmin_printf>\nxor    %eax,%eax\ncall   1770 <printBoard>\ncall   17e0 <libtarg_success>\nlea    0x2eed(%rip),%rdi\nxor    %eax,%eax\ncall   38b0 <libmin_printf>\nmov    $0x1,%edi\ncall   1800 <libtarg_fail>\nnopl   0x0(%rax)\n"}
{"source": {"path": "sudoku-solver/sudoku-solver.c", "function_name": "printBoard", "content": "// Utility function to print the Sudoku board.\nvoid printBoard() {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            libmin_printf(\"%d \", board[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "sudoku-solver/sudoku-solver.host.O3.pseudo", "function_name": "printBoard", "address": "0x1770", "label": "printBoard", "content": "void __cdecl printBoard()\n{\n  int *v0; // rbp\n  int *v1; // rbx\n  int v2; // esi\n\n  v0 = board[1];\n  do\n  {\n    v1 = v0 - 9;\n    do\n    {\n      v2 = *v1++;\n      libmin_printf(\"%d \", v2);\n    }\n    while ( v1 != v0 );\n    v0 = v1 + 9;\n    libmin_printf((char *)\"\\n\");\n  }\n  while ( v1 + 9 != board[10] );\n}\n"}, "pseudo_normalize": "void printBoard() {\n  int *v0;\n  int *v1;\n  int v2;\n  v0 = board[1];\n  do {\n    v1 = v0 - 9;\n    do {\n      v2 = *v1++;\n      libmin_printf(\"%d \", v2);\n    } while (v1 != v0);\n    v0 = v1 + 9;\n    libmin_printf((char *)\"\\n\");\n  } while (v1 + 9 != board[10]);\n}", "binary": "sudoku-solver/sudoku-solver.host.O3", "assembly": "<printBoard>:\nendbr64\npush   %r14\npush   %r13\nlea    0x28cb(%rip),%r13\npush   %r12\nlea    0x287c(%rip),%r12\npush   %rbp\nlea    0x48b4(%rip),%rbp\npush   %rbx\nlea    0x144(%rbp),%r14\nnopl   0x0(%rax,%rax,1)\nlea    -0x24(%rbp),%rbx\nnopl   0x0(%rax)\nmov    (%rbx),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   38b0 <libmin_printf>\ncmp    %rbp,%rbx\njne    17a8 <printBoard+0x38>\nmov    %r13,%rdi\nxor    %eax,%eax\nlea    0x24(%rbx),%rbp\ncall   38b0 <libmin_printf>\ncmp    %r14,%rbp\njne    17a0 <printBoard+0x30>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "sudoku-solver/sudoku-solver.c", "function_name": "solveSudoku", "content": "// Recursively attempt to fill the Sudoku board.\nint solveSudoku() {\n    int row = -1;\n    int col = -1;\n    int emptyFound = 0;\n\n    // Find an empty cell.\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (board[i][j] == 0) {\n                row = i;\n                col = j;\n                emptyFound = 1;\n                break;\n            }\n        }\n        if (emptyFound)\n            break;\n    }\n\n    // No empty cell found; puzzle is solved.\n    if (!emptyFound)\n        return 1;\n\n    // Try placing numbers 1 to 9 in the empty cell.\n    for (int num = 1; num <= 9; num++) {\n        if (isSafe(row, col, num)) {\n            board[row][col] = num;\n            if (solveSudoku())\n                return 1;\n            board[row][col] = 0;  // Backtrack.\n        }\n    }\n    return 0;  // Trigger backtracking.\n}\n"}, "pseudo": {"path": "sudoku-solver/sudoku-solver.host.O3.pseudo", "function_name": "solveSudoku", "address": "0x13e0", "label": "solveSudoku", "content": "int __cdecl solveSudoku()\n{\n  int v0; // edx\n  int *i; // rax\n  int v2; // ecx\n  int v3; // r12d\n  int v5; // r14d\n  int v6; // r8d\n  int v7; // r15d\n  int v8; // ebx\n  __int64 v9; // r13\n  int v10; // r10d\n  unsigned int v11; // r9d\n  signed int v12; // r15d\n  int *v13; // rax\n  __int64 v14; // rdi\n  __int64 v15; // rcx\n  __int64 v16; // rcx\n  signed int v17; // [rsp+0h] [rbp-58h]\n  signed int v18; // [rsp+4h] [rbp-54h]\n  int v19; // [rsp+10h] [rbp-48h]\n  int v20; // [rsp+14h] [rbp-44h]\n  __int64 v21; // [rsp+18h] [rbp-40h]\n\n  v0 = 0;\n  for ( i = board[0]; ; i += 9 )\n  {\n    v2 = *i;\n    if ( !*i )\n    {\n      v3 = 0;\n      v5 = 0;\n      v6 = 2;\n      v7 = 1;\n      goto LABEL_14;\n    }\n    v3 = i[1];\n    if ( !v3 )\n    {\n      v6 = 2;\n      v7 = 1;\n      v5 = 1;\n      goto LABEL_14;\n    }\n    v3 = i[2];\n    if ( !v3 )\n    {\n      v6 = 2;\n      v7 = 1;\n      v5 = 2;\n      goto LABEL_14;\n    }\n    if ( !i[3] )\n    {\n      v6 = 5;\n      v7 = 4;\n      v3 = 3;\n      v5 = 3;\n      goto LABEL_14;\n    }\n    if ( !i[4] )\n    {\n      v6 = 5;\n      v7 = 4;\n      v3 = 3;\n      v5 = 4;\n      goto LABEL_14;\n    }\n    if ( !i[5] )\n    {\n      v6 = 5;\n      v7 = 4;\n      v3 = 3;\n      v5 = 5;\n      goto LABEL_14;\n    }\n    if ( !i[6] )\n    {\n      v6 = 8;\n      v7 = 7;\n      v3 = 6;\n      v5 = 6;\n      goto LABEL_14;\n    }\n    if ( !i[7] )\n    {\n      v6 = 8;\n      v7 = 7;\n      v3 = 6;\n      v5 = 7;\n      goto LABEL_14;\n    }\n    if ( !i[8] )\n      break;\n    if ( ++v0 == 9 )\n      return 1;\n  }\n  v6 = 8;\n  v7 = 7;\n  v3 = 6;\n  v5 = 8;\nLABEL_14:\n  v8 = 1;\n  v21 = v0;\n  v9 = v0;\n  v10 = v7;\n  v11 = 3 * (v0 / 3u);\n  v12 = v11;\n  v17 = v11 + 1;\n  v18 = v11 + 2;\n  while ( 1 )\n  {\n    if ( v8 != v2 )\n    {\n      v13 = board[v9];\n      if ( v8 != board[v9][1]\n        && v8 != v13[2]\n        && v8 != v13[3]\n        && v8 != v13[4]\n        && v8 != v13[5]\n        && v8 != v13[6]\n        && v8 != v13[7]\n        && v8 != v13[8]\n        && v8 != board[0][v5]\n        && v8 != board[1][v5]\n        && v8 != board[2][v5]\n        && v8 != board[3][v5]\n        && v8 != board[4][v5]\n        && v8 != board[5][v5]\n        && v8 != board[6][v5]\n        && v8 != board[7][v5]\n        && v8 != board[8][v5] )\n      {\n        v14 = v12;\n        if ( v8 != board[v14][v3] && v8 != board[0][v10 + v14 * 9] && v8 != board[v12][v6] )\n        {\n          v15 = v17;\n          if ( v8 != board[v15][v3] && v8 != board[v15][v10] && v8 != board[0][v6 + v15 * 9] )\n          {\n            v16 = v18;\n            if ( v8 != board[v16][v3] && v8 != board[v16][v10] && v8 != board[0][v6 + v16 * 9] )\n            {\n              v20 = v10;\n              v19 = v6;\n              board[v21][v5] = v8;\n              if ( solveSudoku() )\n                return 1;\n              v10 = v20;\n              v6 = v19;\n              board[v21][v5] = 0;\n            }\n          }\n        }\n      }\n    }\n    if ( ++v8 == 10 )\n      break;\n    v2 = board[v9][0];\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int solveSudoku() {\n  int v0;\n  int *i;\n  int v2;\n  int v3;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  long long v9;\n  int v10;\n  unsigned int v11;\n  signed int v12;\n  int *v13;\n  long long v14;\n  long long v15;\n  long long v16;\n  signed int v17;\n  signed int v18;\n  int v19;\n  int v20;\n  long long v21;\n  v0 = 0;\n  for (i = board[0];; i += 9) {\n    v2 = *i;\n    if (!*i) {\n      v3 = 0;\n      v5 = 0;\n      v6 = 2;\n      v7 = 1;\n      goto LABEL_14;\n    }\n    v3 = i[1];\n    if (!v3) {\n      v6 = 2;\n      v7 = 1;\n      v5 = 1;\n      goto LABEL_14;\n    }\n    v3 = i[2];\n    if (!v3) {\n      v6 = 2;\n      v7 = 1;\n      v5 = 2;\n      goto LABEL_14;\n    }\n    if (!i[3]) {\n      v6 = 5;\n      v7 = 4;\n      v3 = 3;\n      v5 = 3;\n      goto LABEL_14;\n    }\n    if (!i[4]) {\n      v6 = 5;\n      v7 = 4;\n      v3 = 3;\n      v5 = 4;\n      goto LABEL_14;\n    }\n    if (!i[5]) {\n      v6 = 5;\n      v7 = 4;\n      v3 = 3;\n      v5 = 5;\n      goto LABEL_14;\n    }\n    if (!i[6]) {\n      v6 = 8;\n      v7 = 7;\n      v3 = 6;\n      v5 = 6;\n      goto LABEL_14;\n    }\n    if (!i[7]) {\n      v6 = 8;\n      v7 = 7;\n      v3 = 6;\n      v5 = 7;\n      goto LABEL_14;\n    }\n    if (!i[8]) break;\n    if (++v0 == 9) return 1;\n  }\n  v6 = 8;\n  v7 = 7;\n  v3 = 6;\n  v5 = 8;\nLABEL_14:\n  v8 = 1;\n  v21 = v0;\n  v9 = v0;\n  v10 = v7;\n  v11 = 3 * (v0 / 3u);\n  v12 = v11;\n  v17 = v11 + 1;\n  v18 = v11 + 2;\n  while (1) {\n    if (v8 != v2) {\n      v13 = board[v9];\n      if (v8 != board[v9][1] && v8 != v13[2] && v8 != v13[3] && v8 != v13[4] &&\n          v8 != v13[5] && v8 != v13[6] && v8 != v13[7] && v8 != v13[8] &&\n          v8 != board[0][v5] && v8 != board[1][v5] && v8 != board[2][v5] &&\n          v8 != board[3][v5] && v8 != board[4][v5] && v8 != board[5][v5] &&\n          v8 != board[6][v5] && v8 != board[7][v5] && v8 != board[8][v5]) {\n        v14 = v12;\n        if (v8 != board[v14][v3] && v8 != board[0][v10 + v14 * 9] &&\n            v8 != board[v12][v6]) {\n          v15 = v17;\n          if (v8 != board[v15][v3] && v8 != board[v15][v10] &&\n              v8 != board[0][v6 + v15 * 9]) {\n            v16 = v18;\n            if (v8 != board[v16][v3] && v8 != board[v16][v10] &&\n                v8 != board[0][v6 + v16 * 9]) {\n              v20 = v10;\n              v19 = v6;\n              board[v21][v5] = v8;\n              if (solveSudoku()) return 1;\n              v10 = v20;\n              v6 = v19;\n              board[v21][v5] = 0;\n            }\n          }\n        }\n      }\n    }\n    if (++v8 == 10) break;\n    v2 = board[v9][0];\n  }\n  return 0;\n}", "binary": "sudoku-solver/sudoku-solver.host.O3", "assembly": "<solveSudoku>:\nendbr64\npush   %r15\nxor    %edx,%edx\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nlea    0x4c2a(%rip),%rbp\npush   %rbx\nmov    %rbp,%rax\nsub    $0x28,%rsp\nxchg   %ax,%ax\nmov    (%rax),%ecx\ntest   %ecx,%ecx\nje     148e <solveSudoku+0xae>\nmov    0x4(%rax),%r12d\ntest   %r12d,%r12d\nje     1694 <solveSudoku+0x2b4>\nmov    0x8(%rax),%r12d\ntest   %r12d,%r12d\nje     16ab <solveSudoku+0x2cb>\nmov    0xc(%rax),%r11d\ntest   %r11d,%r11d\nje     16c2 <solveSudoku+0x2e2>\nmov    0x10(%rax),%r10d\ntest   %r10d,%r10d\nje     16df <solveSudoku+0x2ff>\nmov    0x14(%rax),%r9d\ntest   %r9d,%r9d\nje     16fc <solveSudoku+0x31c>\nmov    0x18(%rax),%r8d\ntest   %r8d,%r8d\nje     1719 <solveSudoku+0x339>\nmov    0x1c(%rax),%edi\ntest   %edi,%edi\nje     1736 <solveSudoku+0x356>\nmov    0x20(%rax),%esi\ntest   %esi,%esi\nje     1753 <solveSudoku+0x373>\nadd    $0x1,%edx\nadd    $0x24,%rax\ncmp    $0x9,%edx\njne    1400 <solveSudoku+0x20>\nadd    $0x28,%rsp\nmov    $0x1,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxor    %r12d,%r12d\nxor    %r14d,%r14d\nmov    $0x2,%r8d\nmov    $0x1,%r15d\nmov    %edx,%eax\nmov    $0xaaaaaaab,%esi\nmovslq %edx,%rdx\nmov    $0x1,%ebx\nimul   %rsi,%rax\nlea    (%rdx,%rdx,8),%r10\nmov    %r10,0x18(%rsp)\nlea    0x0(,%r10,4),%r13\nmov    %r15d,%r10d\nshr    $0x21,%rax\nlea    (%rax,%rax,2),%r9d\nlea    0x1(%r9),%eax\nmov    %r9d,%r15d\nmov    %eax,(%rsp)\nlea    0x2(%r9),%eax\nmov    %eax,0x4(%rsp)\njmp    14ed <solveSudoku+0x10d>\nnopl   0x0(%rax,%rax,1)\nmov    0x0(%rbp,%r13,1),%ecx\ncmp    %ecx,%ebx\nje     1677 <solveSudoku+0x297>\nlea    0x0(%rbp,%r13,1),%rax\ncmp    0x4(%rax),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0x8(%rax),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0xc(%rax),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0x10(%rax),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0x14(%rax),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0x18(%rax),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0x1c(%rax),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0x20(%rax),%ebx\nje     1677 <solveSudoku+0x297>\nmovslq %r14d,%rax\ncmp    0x0(%rbp,%rax,4),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0x24(%rbp,%rax,4),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0x48(%rbp,%rax,4),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0x6c(%rbp,%rax,4),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0x90(%rbp,%rax,4),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0xb4(%rbp,%rax,4),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0xd8(%rbp,%rax,4),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0xfc(%rbp,%rax,4),%ebx\nje     1677 <solveSudoku+0x297>\ncmp    0x120(%rbp,%rax,4),%ebx\nje     1677 <solveSudoku+0x297>\nmovslq %r15d,%rcx\nmovslq %r12d,%rdx\nlea    (%rcx,%rcx,8),%rdi\nlea    (%rdi,%rdx,1),%rsi\ncmp    0x0(%rbp,%rsi,4),%ebx\nje     1677 <solveSudoku+0x297>\nmovslq %r10d,%rsi\nadd    %rsi,%rdi\ncmp    0x0(%rbp,%rdi,4),%ebx\nje     1677 <solveSudoku+0x297>\nmovslq %r8d,%rdi\nlea    (%rcx,%rcx,8),%rcx\nadd    %rdi,%rcx\ncmp    0x0(%rbp,%rcx,4),%ebx\nje     1677 <solveSudoku+0x297>\nmovslq (%rsp),%rcx\nlea    (%rcx,%rcx,8),%rcx\nlea    (%rcx,%rdx,1),%r11\ncmp    0x0(%rbp,%r11,4),%ebx\nje     1677 <solveSudoku+0x297>\nlea    (%rcx,%rsi,1),%r11\ncmp    0x0(%rbp,%r11,4),%ebx\nje     1677 <solveSudoku+0x297>\nadd    %rdi,%rcx\ncmp    0x0(%rbp,%rcx,4),%ebx\nje     1677 <solveSudoku+0x297>\nmovslq 0x4(%rsp),%rcx\nlea    (%rcx,%rcx,8),%rcx\nadd    %rcx,%rdx\ncmp    0x0(%rbp,%rdx,4),%ebx\nje     1677 <solveSudoku+0x297>\nadd    %rcx,%rsi\ncmp    0x0(%rbp,%rsi,4),%ebx\nje     1677 <solveSudoku+0x297>\nadd    %rdi,%rcx\ncmp    0x0(%rbp,%rcx,4),%ebx\nje     1677 <solveSudoku+0x297>\nmov    0x18(%rsp),%rsi\nmov    %r10d,0x14(%rsp)\nmov    %r8d,0x10(%rsp)\nlea    (%rsi,%rax,1),%rdx\nxor    %eax,%eax\nmov    %ebx,0x0(%rbp,%rdx,4)\nmov    %rdx,0x8(%rsp)\ncall   13e0 <solveSudoku>\ntest   %eax,%eax\njne    147a <solveSudoku+0x9a>\nmov    0x8(%rsp),%rdx\nmov    0x14(%rsp),%r10d\nmov    0x10(%rsp),%r8d\nmovl   $0x0,0x0(%rbp,%rdx,4)\nadd    $0x1,%ebx\ncmp    $0xa,%ebx\njne    14e8 <solveSudoku+0x108>\nadd    $0x28,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x2,%r8d\nmov    $0x1,%r15d\nmov    $0x1,%r14d\njmp    14a0 <solveSudoku+0xc0>\nmov    $0x2,%r8d\nmov    $0x1,%r15d\nmov    $0x2,%r14d\njmp    14a0 <solveSudoku+0xc0>\nmov    $0x5,%r8d\nmov    $0x4,%r15d\nmov    $0x3,%r12d\nmov    $0x3,%r14d\njmp    14a0 <solveSudoku+0xc0>\nmov    $0x5,%r8d\nmov    $0x4,%r15d\nmov    $0x3,%r12d\nmov    $0x4,%r14d\njmp    14a0 <solveSudoku+0xc0>\nmov    $0x5,%r8d\nmov    $0x4,%r15d\nmov    $0x3,%r12d\nmov    $0x5,%r14d\njmp    14a0 <solveSudoku+0xc0>\nmov    $0x8,%r8d\nmov    $0x7,%r15d\nmov    $0x6,%r12d\nmov    $0x6,%r14d\njmp    14a0 <solveSudoku+0xc0>\nmov    $0x8,%r8d\nmov    $0x7,%r15d\nmov    $0x6,%r12d\nmov    $0x7,%r14d\njmp    14a0 <solveSudoku+0xc0>\nmov    $0x8,%r8d\nmov    $0x7,%r15d\nmov    $0x6,%r12d\nmov    $0x8,%r14d\njmp    14a0 <solveSudoku+0xc0>\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "aggregate_height", "content": "int aggregate_height(int heights[BOARD_WIDTH]) {\n    int sum = 0;\n    for (int i = 0; i < BOARD_WIDTH; i++)\n        sum += heights[i];\n    return sum;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "aggregate_height", "address": "0x1b20", "label": "aggregate_height", "content": "int __fastcall aggregate_height(int *heights)\n{\n  __m128i v1; // xmm0\n  __m128i v2; // xmm0\n  __m128i v3; // xmm1\n\n  v1 = _mm_add_epi32(_mm_loadu_si128((const __m128i *)heights), _mm_loadu_si128((const __m128i *)heights + 1));\n  v2 = _mm_add_epi32(v1, _mm_srli_si128(v1, 8));\n  v3 = _mm_loadl_epi64((const __m128i *)heights + 2);\n  return _mm_cvtsi128_si32(v3)\n       + _mm_cvtsi128_si32(_mm_shuffle_epi32(v3, 229))\n       + _mm_cvtsi128_si32(_mm_add_epi32(v2, _mm_srli_si128(v2, 4)));\n}\n"}, "pseudo_normalize": "int aggregate_height(int *heights) {\n  __m128i v1;\n  __m128i v2;\n  __m128i v3;\n  v1 = _mm_add_epi32(_mm_loadu_si128((const __m128i *)heights),\n                     _mm_loadu_si128((const __m128i *)heights + 1));\n  v2 = _mm_add_epi32(v1, _mm_srli_si128(v1, 8));\n  v3 = _mm_loadl_epi64((const __m128i *)heights + 2);\n  return _mm_cvtsi128_si32(v3) + _mm_cvtsi128_si32(_mm_shuffle_epi32(v3, 229)) +\n         _mm_cvtsi128_si32(_mm_add_epi32(v2, _mm_srli_si128(v2, 4)));\n}", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<aggregate_height>:\nendbr64\nmovdqu (%rdi),%xmm0\nmovdqu 0x10(%rdi),%xmm3\npaddd  %xmm3,%xmm0\nmovdqa %xmm0,%xmm1\npsrldq $0x8,%xmm1\npaddd  %xmm1,%xmm0\nmovq   0x20(%rdi),%xmm1\nmovdqa %xmm0,%xmm2\npsrldq $0x4,%xmm2\nmovd   %xmm1,%ecx\npshufd $0xe5,%xmm1,%xmm4\nmovd   %xmm4,%edx\npaddd  %xmm2,%xmm0\nadd    %ecx,%edx\nmovd   %xmm0,%eax\nadd    %edx,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "best_move", "content": "// ------------------------\n// AI: Find the best move for a given piece on the current board.\n// ------------------------\nint best_move(const int board[BOARD_HEIGHT][BOARD_WIDTH], const Piece *piece, const Orientation **best_ori, int *best_offset, double *best_score, int best_board[BOARD_HEIGHT][BOARD_WIDTH], int *lines_cleared_out) {\n    double max_score = -1e9;\n    int move_found = 0;\n    int temp_board[BOARD_HEIGHT][BOARD_WIDTH];\n    int lines;\n    // For each orientation of the piece.\n    for (int o = 0; o < piece->numOrientations; o++) {\n        const Orientation *ori = &(piece->orientations[o]);\n        // Calculate the horizontal span of the orientation.\n        int min_x = 100, max_x = -100;\n        for (int i = 0; i < ori->numBlocks; i++) {\n            int bx = ori->blocks[i].x;\n            if (bx < min_x) min_x = bx;\n            if (bx > max_x) max_x = bx;\n        }\n        // Determine valid horizontal offsets so that the piece remains within the board.\n        int start = -min_x;\n        int end = BOARD_WIDTH - max_x;\n        for (int x = start; x < end; x++) {\n            if (simulate_board((int (*)[BOARD_WIDTH])board, ori, x, temp_board, &lines)) {\n                double score = evaluate_board(temp_board, lines);\n                if (score > max_score) {\n                    max_score = score;\n                    *best_score = score;\n                    *best_ori = ori;\n                    *best_offset = x;\n                    libmin_memcpy(best_board, temp_board, sizeof(int)*BOARD_HEIGHT*BOARD_WIDTH);\n                    *lines_cleared_out = lines;\n                    move_found = 1;\n                }\n            }\n        }\n    }\n    return move_found;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "best_move", "address": "0x21d0", "label": "best_move", "content": "int __fastcall best_move(\n        const int (*board)[10],\n        const Piece *piece,\n        const Orientation **best_ori,\n        int *best_offset,\n        double *best_score,\n        int (*best_board)[10],\n        int *lines_cleared_out)\n{\n  const Orientation *v7; // rbx\n  int numBlocks; // ecx\n  int x; // eax\n  int v10; // r9d\n  int v11; // edx\n  int v12; // edx\n  int v13; // edx\n  int v14; // edx\n  __int64 v15; // rdx\n  int v16; // esi\n  int v17; // r12d\n  int i; // r15d\n  double v19; // xmm0_8\n  int score; // [rsp+0h] [rbp-3C8h]\n  __int64 o; // [rsp+8h] [rbp-3C0h]\n  double max_score; // [rsp+10h] [rbp-3B8h]\n  int move_found; // [rsp+24h] [rbp-3A4h]\n  int lines; // [rsp+5Ch] [rbp-36Ch] BYREF\n  int temp_board[20][10]; // [rsp+60h] [rbp-368h] BYREF\n  unsigned __int64 v32; // [rsp+388h] [rbp-40h]\n\n  v32 = __readfsqword(0x28u);\n  if ( piece->numOrientations <= 0 )\n    return 0;\n  o = 0LL;\n  move_found = 0;\n  max_score = -1000000000.0;\n  do\n  {\n    v7 = &piece->orientations[o];\n    numBlocks = v7->numBlocks;\n    if ( v7->numBlocks <= 0 )\n    {\n      v17 = 110;\n      i = -100;\n      goto LABEL_38;\n    }\n    x = v7->blocks[0].x;\n    v10 = 100;\n    if ( x <= 100 )\n      v10 = v7->blocks[0].x;\n    if ( x < -100 )\n      x = -100;\n    if ( numBlocks != 1 )\n    {\n      v11 = v7->blocks[1].x;\n      if ( v10 > v11 )\n        v10 = v7->blocks[1].x;\n      if ( x < v11 )\n        x = v7->blocks[1].x;\n      if ( numBlocks != 2 )\n      {\n        v12 = v7->blocks[2].x;\n        if ( v10 > v12 )\n          v10 = v7->blocks[2].x;\n        if ( x < v12 )\n          x = v7->blocks[2].x;\n        if ( numBlocks != 3 )\n        {\n          v13 = v7->blocks[3].x;\n          if ( v10 > v13 )\n            v10 = v7->blocks[3].x;\n          if ( x < v13 )\n            x = v7->blocks[3].x;\n          if ( numBlocks != 4 )\n          {\n            v14 = v7[1].numBlocks;\n            if ( v10 > v14 )\n              v10 = v7[1].numBlocks;\n            if ( x < v14 )\n              x = v7[1].numBlocks;\n            if ( numBlocks != 5 )\n            {\n              v15 = 5LL;\n              do\n              {\n                v16 = v7->blocks[v15].x;\n                if ( v10 > v16 )\n                  v10 = v7->blocks[v15].x;\n                if ( x < v16 )\n                  x = v7->blocks[v15].x;\n                ++v15;\n              }\n              while ( numBlocks > (int)v15 );\n            }\n          }\n        }\n      }\n    }\n    v17 = 10 - x;\n    for ( i = -v10; i < v17; max_score = v19 )\n    {\nLABEL_38:\n      while ( 1 )\n      {\n        if ( simulate_board((int (*)[10])board, v7, i, temp_board, &lines) )\n        {\n          score = lines;\n          v19 = evaluate_board(temp_board, lines);\n          if ( v19 > max_score )\n            break;\n        }\n        if ( ++i >= v17 )\n          goto LABEL_41;\n      }\n      *best_score = v19;\n      *best_ori = v7;\n      *best_offset = i++;\n      libmin_memcpy(best_board, temp_board, 0x320uLL);\n      move_found = 1;\n      *lines_cleared_out = score;\n    }\nLABEL_41:\n    ++o;\n  }\n  while ( piece->numOrientations > (int)o );\n  return move_found;\n}\n"}, "pseudo_normalize": "int best_move(const int (*board)[10], const Piece *piece,\n              const Orientation **best_ori, int *best_offset,\n              double *best_score, int (*best_board)[10],\n              int *lines_cleared_out) {\n  const Orientation *v7;\n  int numBlocks;\n  int x;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  long long v15;\n  int v16;\n  int v17;\n  int i;\n  double v19;\n  int score;\n  long long o;\n  double max_score;\n  int move_found;\n  int lines;\n  int temp_board[20][10];\n  unsigned long long v32;\n  v32 = __readfsqword(40u);\n  if (piece->numOrientations <= 0) return 0;\n  o = 0LL;\n  move_found = 0;\n  max_score = -1000000000.0;\n  do {\n    v7 = &piece->orientations[o];\n    numBlocks = v7->numBlocks;\n    if (v7->numBlocks <= 0) {\n      v17 = 110;\n      i = -100;\n      goto LABEL_38;\n    }\n    x = v7->blocks[0].x;\n    v10 = 100;\n    if (x <= 100) v10 = v7->blocks[0].x;\n    if (x < -100) x = -100;\n    if (numBlocks != 1) {\n      v11 = v7->blocks[1].x;\n      if (v10 > v11) v10 = v7->blocks[1].x;\n      if (x < v11) x = v7->blocks[1].x;\n      if (numBlocks != 2) {\n        v12 = v7->blocks[2].x;\n        if (v10 > v12) v10 = v7->blocks[2].x;\n        if (x < v12) x = v7->blocks[2].x;\n        if (numBlocks != 3) {\n          v13 = v7->blocks[3].x;\n          if (v10 > v13) v10 = v7->blocks[3].x;\n          if (x < v13) x = v7->blocks[3].x;\n          if (numBlocks != 4) {\n            v14 = v7[1].numBlocks;\n            if (v10 > v14) v10 = v7[1].numBlocks;\n            if (x < v14) x = v7[1].numBlocks;\n            if (numBlocks != 5) {\n              v15 = 5LL;\n              do {\n                v16 = v7->blocks[v15].x;\n                if (v10 > v16) v10 = v7->blocks[v15].x;\n                if (x < v16) x = v7->blocks[v15].x;\n                ++v15;\n              } while (numBlocks > (int)v15);\n            }\n          }\n        }\n      }\n    }\n    v17 = 10 - x;\n    for (i = -v10; i < v17; max_score = v19) {\n    LABEL_38:\n      while (1) {\n        if (simulate_board((int(*)[10])board, v7, i, temp_board, &lines)) {\n          score = lines;\n          v19 = evaluate_board(temp_board, lines);\n          if (v19 > max_score) break;\n        }\n        if (++i >= v17) goto LABEL_41;\n      }\n      *best_score = v19;\n      *best_ori = v7;\n      *best_offset = i++;\n      libmin_memcpy(best_board, temp_board, 800uLL);\n      move_found = 1;\n      *lines_cleared_out = score;\n    }\n  LABEL_41:\n    ++o;\n  } while (piece->numOrientations > (int)o);\n  return move_found;\n}", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<best_move>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x398,%rsp\nmov    0x3d0(%rsp),%rax\nmov    %rsi,0x18(%rsp)\nmov    %rdx,0x28(%rsp)\nmov    %rcx,0x30(%rsp)\nmov    %r8,0x38(%rsp)\nmov    %r9,0x40(%rsp)\nmov    %rax,0x48(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x388(%rsp)\nxor    %eax,%eax\nmov    0x4(%rsi),%eax\ntest   %eax,%eax\njle    2429 <best_move+0x259>\nmovsd  0x31cf(%rip),%xmm2\nmov    %rdi,%r13\nlea    0x5c(%rsp),%r14\nlea    0x60(%rsp),%rbp\nmovq   $0x0,0x8(%rsp)\nmovl   $0x0,0x24(%rsp)\nmovsd  %xmm2,0x10(%rsp)\nnopl   (%rax)\nmov    0x18(%rsp),%rdi\nmov    0x8(%rsp),%rax\nmov    0x8(%rdi),%rdx\nlea    (%rax,%rax,8),%rax\nlea    (%rdx,%rax,4),%rbx\nmov    (%rbx),%ecx\ntest   %ecx,%ecx\njle    2418 <best_move+0x248>\nmov    0x4(%rbx),%eax\nmov    $0x64,%r9d\nmov    $0xffffff9c,%edx\ncmp    %r9d,%eax\ncmovle %eax,%r9d\ncmp    %edx,%eax\ncmovl  %edx,%eax\ncmp    $0x1,%ecx\nje     2308 <best_move+0x138>\nmov    0xc(%rbx),%edx\ncmp    %edx,%r9d\ncmovg  %edx,%r9d\ncmp    %edx,%eax\ncmovl  %edx,%eax\ncmp    $0x2,%ecx\nje     2308 <best_move+0x138>\nmov    0x14(%rbx),%edx\ncmp    %edx,%r9d\ncmovg  %edx,%r9d\ncmp    %edx,%eax\ncmovl  %edx,%eax\ncmp    $0x3,%ecx\nje     2308 <best_move+0x138>\nmov    0x1c(%rbx),%edx\ncmp    %edx,%r9d\ncmovg  %edx,%r9d\ncmp    %edx,%eax\ncmovl  %edx,%eax\ncmp    $0x4,%ecx\nje     2308 <best_move+0x138>\nmov    0x24(%rbx),%edx\ncmp    %edx,%r9d\ncmovg  %edx,%r9d\ncmp    %edx,%eax\ncmovl  %edx,%eax\ncmp    $0x5,%ecx\nje     2308 <best_move+0x138>\nmov    $0x5,%edx\nmov    0x4(%rbx,%rdx,8),%esi\ncmp    %esi,%r9d\ncmovg  %esi,%r9d\ncmp    %esi,%eax\ncmovl  %esi,%eax\nadd    $0x1,%rdx\ncmp    %edx,%ecx\njg     22ec <best_move+0x11c>\nnopl   0x0(%rax)\nmov    $0xa,%r12d\nneg    %r9d\nsub    %eax,%r12d\nmov    %r9d,%r15d\ncmp    %r12d,%r9d\njl     2335 <best_move+0x165>\njmp    23d0 <best_move+0x200>\nnopl   0x0(%rax)\nadd    $0x1,%r15d\ncmp    %r12d,%r15d\njge    23d0 <best_move+0x200>\nmov    %r14,%r8\nmov    %rbp,%rcx\nmov    %r15d,%edx\nmov    %rbx,%rsi\nmov    %r13,%rdi\ncall   1ee0 <simulate_board>\ntest   %eax,%eax\nje     2328 <best_move+0x158>\nmov    0x5c(%rsp),%ecx\nmov    %rbp,%rdi\nmov    %ecx,%esi\nmov    %ecx,(%rsp)\ncall   1ca0 <evaluate_board>\ncomisd 0x10(%rsp),%xmm0\nmov    (%rsp),%ecx\njbe    2328 <best_move+0x158>\nmov    0x38(%rsp),%rax\nmov    0x40(%rsp),%rdi\nmov    $0x320,%edx\nmov    %rbp,%rsi\nmov    %ecx,0x10(%rsp)\nmovsd  %xmm0,(%rax)\nmov    0x28(%rsp),%rax\nmovsd  %xmm0,(%rsp)\nmov    %rbx,(%rax)\nmov    0x30(%rsp),%rax\nmov    %r15d,(%rax)\nadd    $0x1,%r15d\ncall   2700 <libmin_memcpy>\nmov    0x10(%rsp),%ecx\nmov    0x48(%rsp),%rax\nmovl   $0x1,0x24(%rsp)\nmovsd  (%rsp),%xmm0\nmov    %ecx,(%rax)\nmovsd  %xmm0,0x10(%rsp)\ncmp    %r12d,%r15d\njl     2335 <best_move+0x165>\nnopl   0x0(%rax,%rax,1)\nmov    0x18(%rsp),%rsi\naddq   $0x1,0x8(%rsp)\nmov    0x8(%rsp),%rax\ncmp    %eax,0x4(%rsi)\njg     2258 <best_move+0x88>\nmov    0x388(%rsp),%rax\nsub    %fs:0x28,%rax\njne    2433 <best_move+0x263>\nmov    0x24(%rsp),%eax\nadd    $0x398,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x6e,%r12d\nmov    $0xffffff9c,%r15d\njmp    2335 <best_move+0x165>\nmovl   $0x0,0x24(%rsp)\njmp    23e9 <best_move+0x219>\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "bumpiness", "content": "int bumpiness(int heights[BOARD_WIDTH]) {\n    int bump = 0;\n    for (int i = 0; i < BOARD_WIDTH - 1; i++)\n        bump += libmin_abs(heights[i] - heights[i+1]);\n    return bump;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "bumpiness", "address": "0x1c60", "label": "bumpiness", "content": "int __fastcall bumpiness(int *heights)\n{\n  int v1; // r12d\n  int *v2; // rbp\n  int *v3; // rbx\n  int v4; // edi\n\n  v1 = 0;\n  v2 = heights + 9;\n  v3 = heights;\n  do\n  {\n    v4 = *v3 - v3[1];\n    ++v3;\n    v1 += libmin_abs(v4);\n  }\n  while ( v2 != v3 );\n  return v1;\n}\n"}, "pseudo_normalize": "int bumpiness(int *heights) {\n  int v1;\n  int *v2;\n  int *v3;\n  int v4;\n  v1 = 0;\n  v2 = heights + 9;\n  v3 = heights;\n  do {\n    v4 = *v3 - v3[1];\n    ++v3;\n    v1 += libmin_abs(v4);\n  } while (v2 != v3);\n  return v1;\n}", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<bumpiness>:\nendbr64\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nlea    0x24(%rdi),%rbp\npush   %rbx\nmov    %rdi,%rbx\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%edi\nsub    0x4(%rbx),%edi\nadd    $0x4,%rbx\ncall   26f0 <libmin_abs>\nadd    %eax,%r12d\ncmp    %rbx,%rbp\njne    1c78 <bumpiness+0x18>\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "check_collision", "content": "// Check whether placing an orientation at (offset_x, offset_y) causes a collision.\nint check_collision(int board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int offset_y) {\n    for (int i = 0; i < ori->numBlocks; i++) {\n        int x = offset_x + ori->blocks[i].x;\n        int y = offset_y + ori->blocks[i].y;\n        if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT)\n            return 1;\n        if (board[y][x] != 0)\n            return 1;\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "check_collision", "address": "0x16d0", "label": "check_collision", "content": "int __fastcall check_collision(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  int numBlocks; // esi\n  unsigned int v6; // r8d\n  unsigned int v7; // r9d\n  unsigned int v8; // r9d\n  unsigned int v9; // r8d\n  unsigned int v10; // r9d\n  unsigned int v11; // r8d\n  unsigned int v12; // r9d\n  unsigned int v13; // r8d\n  unsigned int v14; // r9d\n  unsigned int v15; // r8d\n  __int64 v16; // r9\n  unsigned int v17; // r10d\n  unsigned int v18; // r8d\n\n  numBlocks = ori->numBlocks;\n  if ( numBlocks <= 0 )\n    return 0;\n  v6 = offset_y + ori->blocks[0].y;\n  v7 = offset_x + ori->blocks[0].x;\n  if ( v6 <= 0x13 && v7 <= 9 && !(*board)[10 * v6 + v7] )\n  {\n    if ( numBlocks == 1 )\n      return 0;\n    v8 = offset_x + ori->blocks[1].x;\n    v9 = offset_y + ori->blocks[1].y;\n    if ( v8 <= 9 && v9 <= 0x13 && !(*board)[10 * v9 + v8] )\n    {\n      if ( numBlocks == 2 )\n        return 0;\n      v10 = offset_x + ori->blocks[2].x;\n      v11 = offset_y + ori->blocks[2].y;\n      if ( v10 <= 9 && v11 <= 0x13 && !(*board)[10 * v11 + v10] )\n      {\n        if ( numBlocks == 3 )\n          return 0;\n        v12 = offset_x + ori->blocks[3].x;\n        v13 = offset_y + ori->blocks[3].y;\n        if ( v12 <= 9 && v13 <= 0x13 && !(*board)[10 * v13 + v12] )\n        {\n          if ( numBlocks == 4 )\n            return 0;\n          v14 = offset_x + ori[1].numBlocks;\n          v15 = offset_y + ori[1].blocks[0].x;\n          if ( v14 <= 9 && v15 <= 0x13 && !(*board)[10 * v15 + v14] )\n          {\n            if ( numBlocks != 5 )\n            {\n              v16 = 5LL;\n              while ( 1 )\n              {\n                v17 = offset_x + ori->blocks[v16].x;\n                v18 = offset_y + ori->blocks[v16].y;\n                if ( v17 > 9 || v18 > 0x13 || (*board)[10 * v18 + v17] )\n                  break;\n                if ( numBlocks <= (int)++v16 )\n                  return 0;\n              }\n              return 1;\n            }\n            return 0;\n          }\n        }\n      }\n    }\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int check_collision(int (*board)[10], const Orientation *ori, int offset_x,\n                    int offset_y) {\n  int numBlocks;\n  unsigned int v6;\n  unsigned int v7;\n  unsigned int v8;\n  unsigned int v9;\n  unsigned int v10;\n  unsigned int v11;\n  unsigned int v12;\n  unsigned int v13;\n  unsigned int v14;\n  unsigned int v15;\n  long long v16;\n  unsigned int v17;\n  unsigned int v18;\n  numBlocks = ori->numBlocks;\n  if (numBlocks <= 0) return 0;\n  v6 = offset_y + ori->blocks[0].y;\n  v7 = offset_x + ori->blocks[0].x;\n  if (v6 <= 19 && v7 <= 9 && !(*board)[10 * v6 + v7]) {\n    if (numBlocks == 1) return 0;\n    v8 = offset_x + ori->blocks[1].x;\n    v9 = offset_y + ori->blocks[1].y;\n    if (v8 <= 9 && v9 <= 19 && !(*board)[10 * v9 + v8]) {\n      if (numBlocks == 2) return 0;\n      v10 = offset_x + ori->blocks[2].x;\n      v11 = offset_y + ori->blocks[2].y;\n      if (v10 <= 9 && v11 <= 19 && !(*board)[10 * v11 + v10]) {\n        if (numBlocks == 3) return 0;\n        v12 = offset_x + ori->blocks[3].x;\n        v13 = offset_y + ori->blocks[3].y;\n        if (v12 <= 9 && v13 <= 19 && !(*board)[10 * v13 + v12]) {\n          if (numBlocks == 4) return 0;\n          v14 = offset_x + ori[1].numBlocks;\n          v15 = offset_y + ori[1].blocks[0].x;\n          if (v14 <= 9 && v15 <= 19 && !(*board)[10 * v15 + v14]) {\n            if (numBlocks != 5) {\n              v16 = 5LL;\n              while (1) {\n                v17 = offset_x + ori->blocks[v16].x;\n                v18 = offset_y + ori->blocks[v16].y;\n                if (v17 > 9 || v18 > 19 || (*board)[10 * v18 + v17]) break;\n                if (numBlocks <= (int)++v16) return 0;\n              }\n              return 1;\n            }\n            return 0;\n          }\n        }\n      }\n    }\n  }\n  return 1;\n}", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<check_collision>:\nendbr64\nmov    %rsi,%rax\nmov    (%rsi),%esi\ntest   %esi,%esi\njle    1882 <check_collision+0x1b2>\nmov    0x8(%rax),%r8d\nmov    0x4(%rax),%r9d\nadd    %ecx,%r8d\nadd    %edx,%r9d\ncmp    $0x13,%r8d\nja     1878 <check_collision+0x1a8>\ncmp    $0x9,%r9d\nja     1878 <check_collision+0x1a8>\nmovslq %r8d,%r8\nmovslq %r9d,%r9\nlea    (%r8,%r8,4),%r8\nlea    (%rdi,%r8,8),%r8\nmov    (%r8,%r9,4),%r8d\ntest   %r8d,%r8d\njne    1878 <check_collision+0x1a8>\ncmp    $0x1,%esi\nje     186d <check_collision+0x19d>\nmov    0xc(%rax),%r9d\nmov    0x10(%rax),%r8d\nadd    %edx,%r9d\nadd    %ecx,%r8d\ncmp    $0x9,%r9d\nja     1878 <check_collision+0x1a8>\ncmp    $0x13,%r8d\nja     1878 <check_collision+0x1a8>\nmovslq %r8d,%r8\nmovslq %r9d,%r9\nlea    (%r8,%r8,4),%r8\nlea    (%rdi,%r8,8),%r8\nmov    (%r8,%r9,4),%r8d\ntest   %r8d,%r8d\njne    1878 <check_collision+0x1a8>\ncmp    $0x2,%esi\nje     186d <check_collision+0x19d>\nmov    0x14(%rax),%r9d\nmov    0x18(%rax),%r8d\nadd    %edx,%r9d\nadd    %ecx,%r8d\ncmp    $0x9,%r9d\nja     1878 <check_collision+0x1a8>\ncmp    $0x13,%r8d\nja     1878 <check_collision+0x1a8>\nmovslq %r8d,%r8\nmovslq %r9d,%r9\nlea    (%r8,%r8,4),%r8\nlea    (%rdi,%r8,8),%r8\nmov    (%r8,%r9,4),%r8d\ntest   %r8d,%r8d\njne    1878 <check_collision+0x1a8>\ncmp    $0x3,%esi\nje     186d <check_collision+0x19d>\nmov    0x1c(%rax),%r9d\nmov    0x20(%rax),%r8d\nadd    %edx,%r9d\nadd    %ecx,%r8d\ncmp    $0x9,%r9d\nja     1878 <check_collision+0x1a8>\ncmp    $0x13,%r8d\nja     1878 <check_collision+0x1a8>\nmovslq %r8d,%r8\nmovslq %r9d,%r9\nlea    (%r8,%r8,4),%r8\nlea    (%rdi,%r8,8),%r8\nmov    (%r8,%r9,4),%r8d\ntest   %r8d,%r8d\njne    1878 <check_collision+0x1a8>\ncmp    $0x4,%esi\nje     186d <check_collision+0x19d>\nmov    0x24(%rax),%r9d\nmov    0x28(%rax),%r8d\nadd    %edx,%r9d\nadd    %ecx,%r8d\ncmp    $0x9,%r9d\nja     1878 <check_collision+0x1a8>\ncmp    $0x13,%r8d\nja     1878 <check_collision+0x1a8>\nmovslq %r8d,%r8\nmovslq %r9d,%r9\nlea    (%r8,%r8,4),%r8\nlea    (%rdi,%r8,8),%r8\nmov    (%r8,%r9,4),%r8d\ntest   %r8d,%r8d\njne    1878 <check_collision+0x1a8>\ncmp    $0x5,%esi\nje     186d <check_collision+0x19d>\nmov    $0x5,%r9d\nmov    0x4(%rax,%r9,8),%r10d\nmov    0x8(%rax,%r9,8),%r8d\nadd    %edx,%r10d\nadd    %ecx,%r8d\ncmp    $0x9,%r10d\nja     1878 <check_collision+0x1a8>\ncmp    $0x13,%r8d\nja     1878 <check_collision+0x1a8>\nmovslq %r8d,%r8\nmovslq %r10d,%r10\nlea    (%r8,%r8,4),%r8\nlea    (%rdi,%r8,8),%r8\nmov    (%r8,%r10,4),%r8d\ntest   %r8d,%r8d\njne    1878 <check_collision+0x1a8>\nadd    $0x1,%r9\ncmp    %r9d,%esi\njg     1831 <check_collision+0x161>\nmov    %r8d,%eax\nret\nnopl   0x0(%rax)\nmov    $0x1,%r8d\nmov    %r8d,%eax\nret\nxor    %r8d,%r8d\njmp    186d <check_collision+0x19d>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "clear_lines", "content": "// Clear full lines from the board.\n// Returns the number of lines cleared.\nint clear_lines(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    int lines_cleared = 0;\n    for (int y = BOARD_HEIGHT - 1; y >= 0; y--) {\n        int full = 1;\n        for (int x = 0; x < BOARD_WIDTH; x++) {\n            if (board[y][x] == 0) {\n                full = 0;\n                break;\n            }\n        }\n        if (full) {\n            lines_cleared++;\n            // Move all rows above down one row.\n            for (int yy = y; yy > 0; yy--) {\n                for (int x = 0; x < BOARD_WIDTH; x++) {\n                    board[yy][x] = board[yy-1][x];\n                }\n            }\n            // Clear the top row.\n            for (int x = 0; x < BOARD_WIDTH; x++) {\n                board[0][x] = 0;\n            }\n            y++; // Recheck this row since new content was shifted down.\n        }\n    }\n    return lines_cleared;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "clear_lines", "address": "0x19a0", "label": "clear_lines", "content": "int __fastcall clear_lines(int (*board)[10])\n{\n  int v1; // esi\n  int v2; // r8d\n  __int64 v3; // rdx\n  int *v4; // rax\n  int *v5; // rdx\n  int v6; // ecx\n\n  v1 = 19;\n  v2 = 0;\n  do\n  {\n    v3 = 10LL * v1;\n    v4 = &(*board)[v3];\n    if ( (*board)[v3] && v4[1] && v4[2] && v4[3] && v4[4] && v4[5] && v4[6] && v4[7] && v4[8] && v4[9] )\n    {\n      if ( v1 )\n      {\n        v5 = &(*board)[v3 - 10 + -10 * (unsigned int)(v1 - 1)];\n        do\n        {\n          v6 = *(v4 - 10);\n          v4 -= 10;\n          v4[10] = v6;\n          v4[11] = v4[1];\n          v4[12] = v4[2];\n          v4[13] = v4[3];\n          v4[14] = v4[4];\n          v4[15] = v4[5];\n          v4[16] = v4[6];\n          v4[17] = v4[7];\n          v4[18] = v4[8];\n          v4[19] = v4[9];\n        }\n        while ( v5 != v4 );\n      }\n      *(_QWORD *)&(*board)[8] = 0LL;\n      ++v2;\n      *(_OWORD *)board = 0LL;\n      *(_OWORD *)&(*board)[4] = 0LL;\n    }\n    else\n    {\n      --v1;\n    }\n  }\n  while ( v1 != -1 );\n  return v2;\n}\n"}, "pseudo_normalize": "int clear_lines(int (*board)[10]) {\n  int v1;\n  int v2;\n  long long v3;\n  int *v4;\n  int *v5;\n  int v6;\n  v1 = 19;\n  v2 = 0;\n  do {\n    v3 = 10LL * v1;\n    v4 = &(*board)[v3];\n    if ((*board)[v3] && v4[1] && v4[2] && v4[3] && v4[4] && v4[5] && v4[6] &&\n        v4[7] && v4[8] && v4[9]) {\n      if (v1) {\n        v5 = &(*board)[v3 - 10 + -10 * (unsigned int)(v1 - 1)];\n        do {\n          v6 = *(v4 - 10);\n          v4 -= 10;\n          v4[10] = v6;\n          v4[11] = v4[1];\n          v4[12] = v4[2];\n          v4[13] = v4[3];\n          v4[14] = v4[4];\n          v4[15] = v4[5];\n          v4[16] = v4[6];\n          v4[17] = v4[7];\n          v4[18] = v4[8];\n          v4[19] = v4[9];\n        } while (v5 != v4);\n      }\n      *(uint64_t *)&(*board)[8] = 0LL;\n      ++v2;\n      *(long double *)board = 0LL;\n      *(long double *)&(*board)[4] = 0LL;\n    } else {\n      --v1;\n    }\n  } while (v1 != -1);\n  return v2;\n}", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<clear_lines>:\nendbr64\nmov    $0x13,%esi\nlea    -0x28(%rdi),%r9\npxor   %xmm0,%xmm0\nxor    %r8d,%r8d\nnopl   0x0(%rax)\nmovslq %esi,%rax\nlea    (%rax,%rax,4),%rdx\nshl    $0x3,%rdx\nlea    (%rdi,%rdx,1),%rax\nmov    (%rax),%ecx\ntest   %ecx,%ecx\nje     1ac0 <clear_lines+0x120>\nmov    0x4(%rax),%r11d\ntest   %r11d,%r11d\nje     1ac0 <clear_lines+0x120>\nmov    0x8(%rax),%r10d\ntest   %r10d,%r10d\nje     1ac0 <clear_lines+0x120>\nmov    0xc(%rax),%ecx\ntest   %ecx,%ecx\nje     1ac0 <clear_lines+0x120>\nmov    0x10(%rax),%r11d\ntest   %r11d,%r11d\nje     1ac0 <clear_lines+0x120>\nmov    0x14(%rax),%r10d\ntest   %r10d,%r10d\nje     1ac0 <clear_lines+0x120>\nmov    0x18(%rax),%ecx\ntest   %ecx,%ecx\nje     1ac0 <clear_lines+0x120>\nmov    0x1c(%rax),%r11d\ntest   %r11d,%r11d\nje     1ac0 <clear_lines+0x120>\nmov    0x20(%rax),%r10d\ntest   %r10d,%r10d\nje     1ac0 <clear_lines+0x120>\nmov    0x24(%rax),%ecx\ntest   %ecx,%ecx\nje     1ac0 <clear_lines+0x120>\ntest   %esi,%esi\nje     1a9a <clear_lines+0xfa>\nlea    -0x1(%rsi),%ecx\nadd    %r9,%rdx\nlea    (%rcx,%rcx,4),%rcx\nshl    $0x3,%rcx\nsub    %rcx,%rdx\nmov    -0x28(%rax),%ecx\nsub    $0x28,%rax\nmov    %ecx,0x28(%rax)\nmov    0x4(%rax),%ecx\nmov    %ecx,0x2c(%rax)\nmov    0x8(%rax),%ecx\nmov    %ecx,0x30(%rax)\nmov    0xc(%rax),%ecx\nmov    %ecx,0x34(%rax)\nmov    0x10(%rax),%ecx\nmov    %ecx,0x38(%rax)\nmov    0x14(%rax),%ecx\nmov    %ecx,0x3c(%rax)\nmov    0x18(%rax),%ecx\nmov    %ecx,0x40(%rax)\nmov    0x1c(%rax),%ecx\nmov    %ecx,0x44(%rax)\nmov    0x20(%rax),%ecx\nmov    %ecx,0x48(%rax)\nmov    0x24(%rax),%ecx\nmov    %ecx,0x4c(%rax)\ncmp    %rax,%rdx\njne    1a55 <clear_lines+0xb5>\nmovq   $0x0,0x20(%rdi)\nadd    $0x1,%r8d\nmovups %xmm0,(%rdi)\nmovups %xmm0,0x10(%rdi)\ncmp    $0xffffffff,%esi\njne    19b8 <clear_lines+0x18>\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\nsub    $0x1,%esi\njmp    1aad <clear_lines+0x10d>\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "count_holes", "content": "int count_holes(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    int holes = 0;\n    for (int x = 0; x < BOARD_WIDTH; x++) {\n        int block_found = 0;\n        for (int y = 0; y < BOARD_HEIGHT; y++) {\n            if (board[y][x] != 0)\n                block_found = 1;\n            else if (block_found)\n                holes++;\n        }\n    }\n    return holes;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "count_holes", "address": "0x1b70", "label": "count_holes", "content": "int __fastcall count_holes(int (*board)[10])\n{\n  __m128i v1; // xmm4\n  __m128i si128; // xmm5\n  int *v4; // rdx\n  int *v5; // rsi\n  const __m128i *v6; // rax\n  __m128i v7; // xmm0\n  __m128i v8; // xmm0\n  __m128i v9; // xmm1\n  __m128i v10; // xmm1\n  __m128i v11; // xmm2\n  int *v12; // rdx\n  int v13; // edi\n  __m128i v14; // xmm4\n  int result; // eax\n  int *v16; // rdx\n  int v17; // esi\n  int *v18; // rcx\n\n  v1 = 0LL;\n  si128 = _mm_load_si128((const __m128i *)&xmmword_53D0);\n  v4 = &(*board)[200];\n  v5 = &(*board)[208];\n  do\n  {\n    v6 = (const __m128i *)(v4 - 200);\n    v7 = 0LL;\n    do\n    {\n      v8 = _mm_cmpeq_epi32(v7, (__m128i)0LL);\n      v9 = _mm_loadu_si128(v6);\n      v6 = (const __m128i *)((char *)v6 + 40);\n      v10 = _mm_cmpeq_epi32(v9, (__m128i)0LL);\n      v11 = _mm_cmpeq_epi32(v8, (__m128i)0LL);\n      v7 = _mm_andnot_si128(_mm_and_si128(v8, v10), si128);\n      v1 = _mm_sub_epi32(v1, _mm_and_si128(v11, v10));\n    }\n    while ( v4 != (int *)v6 );\n    v4 += 4;\n  }\n  while ( v5 != v4 );\n  v12 = &(*board)[8];\n  v13 = 0;\n  v14 = _mm_add_epi32(v1, _mm_srli_si128(v1, 8));\n  result = _mm_cvtsi128_si32(_mm_add_epi32(v14, _mm_srli_si128(v14, 4)));\n  do\n  {\n    while ( !*v12 )\n    {\n      result -= (v13 == 0) - 1;\n      v12 += 10;\n      if ( v12 == v5 )\n        goto LABEL_9;\n    }\n    v12 += 10;\n    v13 = 1;\n  }\n  while ( v12 != v5 );\nLABEL_9:\n  v16 = &(*board)[9];\n  v17 = 0;\n  v18 = &(*board)[209];\n  do\n  {\n    while ( *v16 )\n    {\n      v16 += 10;\n      v17 = 1;\n      if ( v16 == v18 )\n        return result;\n    }\n    result -= (v17 == 0) - 1;\n    v16 += 10;\n  }\n  while ( v16 != v18 );\n  return result;\n}\n"}, "pseudo_normalize": "int count_holes(int (*board)[10]) {\n  __m128i v1;\n  __m128i si128;\n  int *v4;\n  int *v5;\n  const __m128i *v6;\n  __m128i v7;\n  __m128i v8;\n  __m128i v9;\n  __m128i v10;\n  __m128i v11;\n  int *v12;\n  int v13;\n  __m128i v14;\n  int result;\n  int *v16;\n  int v17;\n  int *v18;\n  v1 = 0LL;\n  si128 = _mm_load_si128((const __m128i *)&xmmword_53D0);\n  v4 = &(*board)[200];\n  v5 = &(*board)[208];\n  do {\n    v6 = (const __m128i *)(v4 - 200);\n    v7 = 0LL;\n    do {\n      v8 = _mm_cmpeq_epi32(v7, (__m128i)0LL);\n      v9 = _mm_loadu_si128(v6);\n      v6 = (const __m128i *)((char *)v6 + 40);\n      v10 = _mm_cmpeq_epi32(v9, (__m128i)0LL);\n      v11 = _mm_cmpeq_epi32(v8, (__m128i)0LL);\n      v7 = _mm_andnot_si128(_mm_and_si128(v8, v10), si128);\n      v1 = _mm_sub_epi32(v1, _mm_and_si128(v11, v10));\n    } while (v4 != (int *)v6);\n    v4 += 4;\n  } while (v5 != v4);\n  v12 = &(*board)[8];\n  v13 = 0;\n  v14 = _mm_add_epi32(v1, _mm_srli_si128(v1, 8));\n  result = _mm_cvtsi128_si32(_mm_add_epi32(v14, _mm_srli_si128(v14, 4)));\n  do {\n    while (!*v12) {\n      result -= (v13 == 0) - 1;\n      v12 += 10;\n      if (v12 == v5) goto LABEL_9;\n    }\n    v12 += 10;\n    v13 = 1;\n  } while (v12 != v5);\nLABEL_9:\n  v16 = &(*board)[9];\n  v17 = 0;\n  v18 = &(*board)[209];\n  do {\n    while (*v16) {\n      v16 += 10;\n      v17 = 1;\n      if (v16 == v18) return result;\n    }\n    result -= (v17 == 0) - 1;\n    v16 += 10;\n  } while (v16 != v18);\n  return result;\n}", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<count_holes>:\nendbr64\npxor   %xmm4,%xmm4\nmovdqa 0x3850(%rip),%xmm5\nmov    %rdi,%rcx\nlea    0x320(%rdi),%rdx\nlea    0x340(%rdi),%rsi\nmovdqa %xmm4,%xmm3\nlea    -0x320(%rdx),%rax\npxor   %xmm0,%xmm0\npcmpeqd %xmm3,%xmm0\nmovdqu (%rax),%xmm1\nadd    $0x28,%rax\npcmpeqd %xmm3,%xmm1\nmovdqa %xmm0,%xmm2\npcmpeqd %xmm3,%xmm2\npand   %xmm1,%xmm0\npandn  %xmm5,%xmm0\npand   %xmm1,%xmm2\npsubd  %xmm2,%xmm4\ncmp    %rax,%rdx\njne    1ba0 <count_holes+0x30>\nadd    $0x10,%rdx\ncmp    %rdx,%rsi\njne    1b95 <count_holes+0x25>\nmovdqa %xmm4,%xmm0\nlea    0x20(%rcx),%rdx\nxor    %edi,%edi\npsrldq $0x8,%xmm0\npaddd  %xmm0,%xmm4\nmovdqa %xmm4,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm4\nmovd   %xmm4,%eax\njmp    1c0f <count_holes+0x9f>\nnopl   0x0(%rax)\ncmp    $0x1,%edi\nsbb    $0xffffffff,%eax\nadd    $0x28,%rdx\ncmp    %rsi,%rdx\nje     1c25 <count_holes+0xb5>\nmov    (%rdx),%r8d\ntest   %r8d,%r8d\nje     1c00 <count_holes+0x90>\nadd    $0x28,%rdx\nmov    $0x1,%edi\ncmp    %rsi,%rdx\njne    1c0f <count_holes+0x9f>\nlea    0x24(%rcx),%rdx\nxor    %esi,%esi\nadd    $0x344,%rcx\njmp    1c46 <count_holes+0xd6>\nnopl   0x0(%rax)\nadd    $0x28,%rdx\nmov    $0x1,%esi\ncmp    %rcx,%rdx\nje     1c5b <count_holes+0xeb>\nmov    (%rdx),%edi\ntest   %edi,%edi\njne    1c38 <count_holes+0xc8>\ncmp    $0x1,%esi\nsbb    $0xffffffff,%eax\nadd    $0x28,%rdx\ncmp    %rcx,%rdx\njne    1c46 <count_holes+0xd6>\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "evaluate_board", "content": "// Evaluate a board state given the number of lines cleared by the last move.\ndouble evaluate_board(int board[BOARD_HEIGHT][BOARD_WIDTH], int lines_cleared) {\n    int heights[BOARD_WIDTH];\n    get_column_heights(board, heights);\n    int agg = aggregate_height(heights);\n    int holes = count_holes(board);\n    int bump = bumpiness(heights);\n    double score = WEIGHT_AGGREGATE_HEIGHT * agg +\n                   WEIGHT_COMPLETE_LINES * lines_cleared +\n                   WEIGHT_HOLES * holes +\n                   WEIGHT_BUMPINESS * bump;\n    return score;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "evaluate_board", "address": "0x1ca0", "label": "evaluate_board", "content": "double __fastcall evaluate_board(int (*board)[10], int lines_cleared)\n{\n  int *v3; // rsi\n  int *v4; // r13\n  int *v5; // rcx\n  int *v6; // rax\n  int v7; // edx\n  __m128i v8; // xmm0\n  __m128i v9; // xmm4\n  int *v10; // rcx\n  __m128i si128; // xmm5\n  int *m128i_i32; // rdx\n  __m128i v13; // xmm0\n  int v14; // r12d\n  const __m128i *v15; // rax\n  __m128i v16; // xmm0\n  __m128i v17; // xmm0\n  __m128i v18; // xmm1\n  __m128i v19; // xmm1\n  __m128i v20; // xmm2\n  int *v21; // rax\n  int v22; // edx\n  __m128i v23; // xmm4\n  int v24; // ebx\n  int *v25; // rax\n  int *v26; // rdx\n  int v27; // ecx\n  int v28; // r14d\n  int v29; // edi\n  int heights[10]; // [rsp+0h] [rbp-68h] BYREF\n  unsigned __int64 v32; // [rsp+28h] [rbp-40h] BYREF\n\n  v3 = (int *)board;\n  v32 = __readfsqword(0x28u);\n  v4 = heights;\n  v5 = heights;\n  do\n  {\n    *v5 = 0;\n    v6 = v3;\n    v7 = 0;\n    while ( !*v6 )\n    {\n      ++v7;\n      v6 += 10;\n      if ( v7 == 20 )\n        goto LABEL_6;\n    }\n    *v5 = 20 - v7;\nLABEL_6:\n    ++v5;\n    ++v3;\n  }\n  while ( v5 != (int *)&v32 );\n  v8 = _mm_add_epi32(_mm_load_si128((const __m128i *)heights), *(__m128i *)&heights[4]);\n  v9 = 0LL;\n  v10 = &(*board)[208];\n  si128 = _mm_load_si128((const __m128i *)&xmmword_53D0);\n  m128i_i32 = &(*board)[200];\n  v13 = _mm_add_epi32(v8, _mm_srli_si128(v8, 8));\n  v14 = heights[8] + heights[9] + _mm_cvtsi128_si32(_mm_add_epi32(v13, _mm_srli_si128(v13, 4)));\n  do\n  {\n    v15 = (const __m128i *)(m128i_i32 - 200);\n    v16 = 0LL;\n    do\n    {\n      v17 = _mm_cmpeq_epi32(v16, (__m128i)0LL);\n      v18 = _mm_loadu_si128(v15);\n      v15 = (const __m128i *)((char *)v15 + 40);\n      v19 = _mm_cmpeq_epi32(v18, (__m128i)0LL);\n      v20 = _mm_cmpeq_epi32(v17, (__m128i)0LL);\n      v16 = _mm_andnot_si128(_mm_and_si128(v17, v19), si128);\n      v9 = _mm_sub_epi32(v9, _mm_and_si128(v20, v19));\n    }\n    while ( v15 != (const __m128i *)m128i_i32 );\n    m128i_i32 = v15[1].m128i_i32;\n  }\n  while ( v10 != (int *)&v15[1] );\n  v21 = &(*board)[8];\n  v22 = 0;\n  v23 = _mm_add_epi32(v9, _mm_srli_si128(v9, 8));\n  v24 = _mm_cvtsi128_si32(_mm_add_epi32(v23, _mm_srli_si128(v23, 4)));\n  do\n  {\n    while ( !*v21 )\n    {\n      v24 -= (v22 == 0) - 1;\n      v21 += 10;\n      if ( v10 == v21 )\n        goto LABEL_15;\n    }\n    v21 += 10;\n    v22 = 1;\n  }\n  while ( v10 != v21 );\nLABEL_15:\n  v25 = &(*board)[9];\n  v26 = &(*board)[209];\n  v27 = 0;\n  do\n  {\n    while ( *v25 )\n    {\n      v25 += 10;\n      v27 = 1;\n      if ( v26 == v25 )\n        goto LABEL_19;\n    }\n    v24 -= (v27 == 0) - 1;\n    v25 += 10;\n  }\n  while ( v26 != v25 );\nLABEL_19:\n  v28 = 0;\n  do\n  {\n    v29 = *v4 - v4[1];\n    ++v4;\n    v28 += libmin_abs(v29);\n  }\n  while ( &heights[9] != v4 );\n  return (double)v14 * -0.510066 + (double)lines_cleared * 0.760666 + (double)v24 * -0.35663 + (double)v28 * -0.184483;\n}\n"}, "pseudo_normalize": "double evaluate_board(int (*board)[10], int lines_cleared) {\n  int *v3;\n  int *v4;\n  int *v5;\n  int *v6;\n  int v7;\n  __m128i v8;\n  __m128i v9;\n  int *v10;\n  __m128i si128;\n  int *m128i_i32;\n  __m128i v13;\n  int v14;\n  const __m128i *v15;\n  __m128i v16;\n  __m128i v17;\n  __m128i v18;\n  __m128i v19;\n  __m128i v20;\n  int *v21;\n  int v22;\n  __m128i v23;\n  int v24;\n  int *v25;\n  int *v26;\n  int v27;\n  int v28;\n  int v29;\n  int heights[10];\n  unsigned long long v32;\n  v3 = (int *)board;\n  v32 = __readfsqword(40u);\n  v4 = heights;\n  v5 = heights;\n  do {\n    *v5 = 0;\n    v6 = v3;\n    v7 = 0;\n    while (!*v6) {\n      ++v7;\n      v6 += 10;\n      if (v7 == 20) goto LABEL_6;\n    }\n    *v5 = 20 - v7;\n  LABEL_6:\n    ++v5;\n    ++v3;\n  } while (v5 != (int *)&v32);\n  v8 = _mm_add_epi32(_mm_load_si128((const __m128i *)heights),\n                     *(__m128i *)&heights[4]);\n  v9 = 0LL;\n  v10 = &(*board)[208];\n  si128 = _mm_load_si128((const __m128i *)&xmmword_53D0);\n  m128i_i32 = &(*board)[200];\n  v13 = _mm_add_epi32(v8, _mm_srli_si128(v8, 8));\n  v14 = heights[8] + heights[9] +\n        _mm_cvtsi128_si32(_mm_add_epi32(v13, _mm_srli_si128(v13, 4)));\n  do {\n    v15 = (const __m128i *)(m128i_i32 - 200);\n    v16 = 0LL;\n    do {\n      v17 = _mm_cmpeq_epi32(v16, (__m128i)0LL);\n      v18 = _mm_loadu_si128(v15);\n      v15 = (const __m128i *)((char *)v15 + 40);\n      v19 = _mm_cmpeq_epi32(v18, (__m128i)0LL);\n      v20 = _mm_cmpeq_epi32(v17, (__m128i)0LL);\n      v16 = _mm_andnot_si128(_mm_and_si128(v17, v19), si128);\n      v9 = _mm_sub_epi32(v9, _mm_and_si128(v20, v19));\n    } while (v15 != (const __m128i *)m128i_i32);\n    m128i_i32 = v15[1].m128i_i32;\n  } while (v10 != (int *)&v15[1]);\n  v21 = &(*board)[8];\n  v22 = 0;\n  v23 = _mm_add_epi32(v9, _mm_srli_si128(v9, 8));\n  v24 = _mm_cvtsi128_si32(_mm_add_epi32(v23, _mm_srli_si128(v23, 4)));\n  do {\n    while (!*v21) {\n      v24 -= (v22 == 0) - 1;\n      v21 += 10;\n      if (v10 == v21) goto LABEL_15;\n    }\n    v21 += 10;\n    v22 = 1;\n  } while (v10 != v21);\nLABEL_15:\n  v25 = &(*board)[9];\n  v26 = &(*board)[209];\n  v27 = 0;\n  do {\n    while (*v25) {\n      v25 += 10;\n      v27 = 1;\n      if (v26 == v25) goto LABEL_19;\n    }\n    v24 -= (v27 == 0) - 1;\n    v25 += 10;\n  } while (v26 != v25);\nLABEL_19:\n  v28 = 0;\n  do {\n    v29 = *v4 - v4[1];\n    ++v4;\n    v28 += libmin_abs(v29);\n  } while (&heights[9] != v4);\n  return (double)v14 * -0.510066 + (double)lines_cleared * 0.760666 +\n         (double)v24 * -0.35663 + (double)v28 * -0.184483;\n}", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<evaluate_board>:\nendbr64\npush   %r15\nmov    $0x14,%r9d\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %esi,%ebp\nmov    %rdi,%rsi\npush   %rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r13\nlea    0x28(%rsp),%r8\nmov    %r13,%rcx\nnopl   0x0(%rax,%rax,1)\nmovl   $0x0,(%rcx)\nmov    %rsi,%rax\nxor    %edx,%edx\njmp    1cfc <evaluate_board+0x5c>\nnopl   (%rax)\nadd    $0x1,%edx\nadd    $0x28,%rax\ncmp    $0x14,%edx\nje     1d0b <evaluate_board+0x6b>\nmov    (%rax),%r10d\ntest   %r10d,%r10d\nje     1cf0 <evaluate_board+0x50>\nmov    %r9d,%eax\nsub    %edx,%eax\nmov    %eax,(%rcx)\nadd    $0x4,%rcx\nadd    $0x4,%rsi\ncmp    %r8,%rcx\njne    1ce0 <evaluate_board+0x40>\nmovdqa (%rsp),%xmm0\npaddd  0x10(%rsp),%xmm0\npxor   %xmm4,%xmm4\nlea    0x340(%rdi),%rcx\nmov    0x20(%rsp),%edx\nmov    0x24(%rsp),%eax\nmovdqa %xmm4,%xmm3\nmovdqa %xmm0,%xmm1\nmovdqa 0x368a(%rip),%xmm5\npsrldq $0x8,%xmm1\nadd    %edx,%eax\nlea    0x320(%rdi),%rdx\npaddd  %xmm1,%xmm0\nmovdqa %xmm0,%xmm1\npsrldq $0x4,%xmm1\npaddd  %xmm1,%xmm0\nmovd   %xmm0,%r12d\nadd    %eax,%r12d\nlea    -0x320(%rdx),%rax\npxor   %xmm0,%xmm0\nnopl   0x0(%rax,%rax,1)\npcmpeqd %xmm3,%xmm0\nmovdqu (%rax),%xmm1\nadd    $0x28,%rax\npcmpeqd %xmm3,%xmm1\nmovdqa %xmm0,%xmm2\npcmpeqd %xmm3,%xmm2\npand   %xmm1,%xmm0\npandn  %xmm5,%xmm0\npand   %xmm1,%xmm2\npsubd  %xmm2,%xmm4\ncmp    %rdx,%rax\njne    1d80 <evaluate_board+0xe0>\nlea    0x10(%rax),%rdx\ncmp    %rdx,%rcx\njne    1d6d <evaluate_board+0xcd>\nmovdqa %xmm4,%xmm0\nlea    0x20(%rdi),%rax\nxor    %edx,%edx\npsrldq $0x8,%xmm0\npaddd  %xmm0,%xmm4\nmovdqa %xmm4,%xmm0\npsrldq $0x4,%xmm0\npaddd  %xmm0,%xmm4\nmovd   %xmm4,%ebx\njmp    1def <evaluate_board+0x14f>\nnopl   0x0(%rax)\ncmp    $0x1,%edx\nsbb    $0xffffffff,%ebx\nadd    $0x28,%rax\ncmp    %rax,%rcx\nje     1e05 <evaluate_board+0x165>\nmov    (%rax),%r8d\ntest   %r8d,%r8d\nje     1de0 <evaluate_board+0x140>\nadd    $0x28,%rax\nmov    $0x1,%edx\ncmp    %rax,%rcx\njne    1def <evaluate_board+0x14f>\nlea    0x24(%rdi),%rax\nlea    0x344(%rdi),%rdx\nxor    %ecx,%ecx\njmp    1e26 <evaluate_board+0x186>\nnopl   0x0(%rax)\nadd    $0x28,%rax\nmov    $0x1,%ecx\ncmp    %rax,%rdx\nje     1e3b <evaluate_board+0x19b>\nmov    (%rax),%esi\ntest   %esi,%esi\njne    1e18 <evaluate_board+0x178>\ncmp    $0x1,%ecx\nsbb    $0xffffffff,%ebx\nadd    $0x28,%rax\ncmp    %rax,%rdx\njne    1e26 <evaluate_board+0x186>\nlea    0x24(%r13),%r15\nxor    %r14d,%r14d\nnopw   0x0(%rax,%rax,1)\nmov    0x0(%r13),%edi\nsub    0x4(%r13),%edi\nadd    $0x4,%r13\ncall   26f0 <libmin_abs>\nadd    %eax,%r14d\ncmp    %r13,%r15\njne    1e48 <evaluate_board+0x1a8>\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sd %r12d,%xmm0\nmulsd  0x356a(%rip),%xmm0\ncvtsi2sd %ebp,%xmm1\nmulsd  0x3566(%rip),%xmm1\naddsd  %xmm1,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sd %ebx,%xmm1\nmulsd  0x355a(%rip),%xmm1\naddsd  %xmm1,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sd %r14d,%xmm1\nmulsd  0x354d(%rip),%xmm1\naddsd  %xmm1,%xmm0\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1ece <evaluate_board+0x22e>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "get_column_heights", "content": "// ------------------------\n// Heuristic Evaluation Functions\n// ------------------------\n\n// Compute the height of each column.\nvoid get_column_heights(int board[BOARD_HEIGHT][BOARD_WIDTH], int heights[BOARD_WIDTH]) {\n    for (int x = 0; x < BOARD_WIDTH; x++) {\n        heights[x] = 0;\n        for (int y = 0; y < BOARD_HEIGHT; y++) {\n            if (board[y][x] != 0) {\n                heights[x] = BOARD_HEIGHT - y;\n                break;\n            }\n        }\n    }\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "get_column_heights", "address": "0x1ad0", "label": "get_column_heights", "content": "void __fastcall get_column_heights(int (*board)[10], int *heights)\n{\n  int *v2; // rcx\n  int *v3; // rdx\n  int v4; // eax\n\n  v2 = &(*board)[10];\n  do\n  {\n    *heights = 0;\n    v3 = (int *)board;\n    v4 = 0;\n    while ( !*v3 )\n    {\n      ++v4;\n      v3 += 10;\n      if ( v4 == 20 )\n        goto LABEL_6;\n    }\n    *heights = 20 - v4;\nLABEL_6:\n    board = (int (*)[10])((char *)board + 4);\n    ++heights;\n  }\n  while ( board != (int (*)[10])v2 );\n}\n"}, "pseudo_normalize": "void get_column_heights(int (*board)[10], int *heights) {\n  int *v2;\n  int *v3;\n  int v4;\n  v2 = &(*board)[10];\n  do {\n    *heights = 0;\n    v3 = (int *)board;\n    v4 = 0;\n    while (!*v3) {\n      ++v4;\n      v3 += 10;\n      if (v4 == 20) goto LABEL_6;\n    }\n    *heights = 20 - v4;\n  LABEL_6:\n    board = (int(*)[10])((char *)board + 4);\n    ++heights;\n  } while (board != (int(*)[10])v2);\n}", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<get_column_heights>:\nendbr64\nlea    0x28(%rdi),%rcx\nmov    $0x14,%r8d\nxchg   %ax,%ax\nmovl   $0x0,(%rsi)\nmov    %rdi,%rdx\nxor    %eax,%eax\njmp    1afc <get_column_heights+0x2c>\nnopl   (%rax)\nadd    $0x1,%eax\nadd    $0x28,%rdx\ncmp    $0x14,%eax\nje     1b0b <get_column_heights+0x3b>\nmov    (%rdx),%r9d\ntest   %r9d,%r9d\nje     1af0 <get_column_heights+0x20>\nmov    %r8d,%edx\nsub    %eax,%edx\nmov    %edx,(%rsi)\nadd    $0x4,%rdi\nadd    $0x4,%rsi\ncmp    %rcx,%rdi\njne    1ae0 <get_column_heights+0x10>\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "main", "content": "// ------------------------\n// Main Simulation Loop\n// ------------------------\nint main(void) {\n    libmin_srand(42);\n    int board[BOARD_HEIGHT][BOARD_WIDTH];\n    create_board(board);\n    int move_count = 0;\n    int total_lines_cleared = 0;\n\n    while (1) {\n        const Piece *piece = random_piece();\n        const Orientation *best_ori;\n        int best_offset;\n        double best_score;\n        int new_board[BOARD_HEIGHT][BOARD_WIDTH];\n        int lines;\n        if (!best_move(board, piece, &best_ori, &best_offset, &best_score, new_board, &lines)) {\n            libmin_printf(\"Game over!\\n\");\n            break;\n        }\n        // Update board state.\n        libmin_memcpy(board, new_board, sizeof(board));\n        total_lines_cleared += lines;\n        move_count++;\n        // Print board every 10 moves.\n        if (move_count % 10 == 0) {\n            libmin_printf(\"After move %d, total lines cleared: %d, last move score: %f\\n\", move_count, total_lines_cleared, best_score);\n            print_board(board);\n        }\n    }\n    libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", move_count, total_lines_cleared);\n    print_board(board);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  const Piece *v3; // rsi\n  int *v4; // rbx\n  int *v5; // r15\n  __int64 v6; // rsi\n  __int64 v7; // [rsp-10h] [rbp-6E8h]\n  int move_count; // [rsp+8h] [rbp-6D0h]\n  int total_lines_cleared; // [rsp+Ch] [rbp-6CCh]\n  int best_offset; // [rsp+38h] [rbp-6A0h] BYREF\n  int lines; // [rsp+3Ch] [rbp-69Ch] BYREF\n  const Orientation *best_ori; // [rsp+40h] [rbp-698h] BYREF\n  double best_score; // [rsp+48h] [rbp-690h] BYREF\n  int board[20][10]; // [rsp+50h] [rbp-688h] BYREF\n  int new_board[20][10]; // [rsp+370h] [rbp-368h] BYREF\n  unsigned __int64 v16; // [rsp+698h] [rbp-40h]\n\n  v16 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  memset(board, 0, sizeof(board));\n  total_lines_cleared = 0;\n  move_count = 0;\n  while ( 1 )\n  {\n    v3 = &pieces[libmin_rand() % 7];\n    if ( !best_move(board, v3, &best_ori, &best_offset, &best_score, new_board, &lines) )\n      break;\n    libmin_memcpy(board, new_board, 0x320uLL);\n    ++move_count;\n    total_lines_cleared += lines;\n    if ( __ROR4__(-858993459 * move_count, 1) <= 0x19999999u )\n    {\n      v4 = board[1];\n      libmin_printf(\n        \"After move %d, total lines cleared: %d, last move score: %f\\n\",\n        move_count,\n        total_lines_cleared,\n        best_score);\n      do\n      {\n        v5 = v4 - 10;\n        do\n        {\n          v6 = 88LL;\n          if ( !*v5 )\n            v6 = 46LL;\n          ++v5;\n          libmin_printf(\"%c\", v6);\n        }\n        while ( v5 != v4 );\n        v4 += 10;\n        libmin_printf((char *)\"\\n\");\n      }\n      while ( v4 != new_board[1] );\n      libmin_printf((char *)\"\\n\");\n    }\n  }\n  libmin_printf(\"Game over!\\n\", v3, v7);\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", move_count, total_lines_cleared);\n  print_board(board);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  const Piece *v3;\n  int *v4;\n  int *v5;\n  long long v6;\n  long long v7;\n  int move_count;\n  int total_lines_cleared;\n  int best_offset;\n  int lines;\n  const Orientation *best_ori;\n  double best_score;\n  int board[20][10];\n  int new_board[20][10];\n  unsigned long long v16;\n  v16 = __readfsqword(40u);\n  libmin_srand(42u);\n  memset(board, 0, sizeof(board));\n  total_lines_cleared = 0;\n  move_count = 0;\n  while (1) {\n    v3 = &pieces[libmin_rand() % 7];\n    if (!best_move(board, v3, &best_ori, &best_offset, &best_score, new_board,\n                   &lines))\n      break;\n    libmin_memcpy(board, new_board, 800uLL);\n    ++move_count;\n    total_lines_cleared += lines;\n    if (__ROR4__(-858993459 * move_count, 1) <= 429496729u) {\n      v4 = board[1];\n      libmin_printf(\n          \"After move %d, total lines cleared: %d, last move score: %f\\n\",\n          move_count, total_lines_cleared, best_score);\n      do {\n        v5 = v4 - 10;\n        do {\n          v6 = 88LL;\n          if (!*v5) v6 = 46LL;\n          ++v5;\n          libmin_printf(\"%c\", v6);\n        } while (v5 != v4);\n        v4 += 10;\n        libmin_printf((char *)\"\\n\");\n      } while (v4 != new_board[1]);\n      libmin_printf((char *)\"\\n\");\n    }\n  }\n  libmin_printf(\"Game over!\\n\", v3, v7);\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\",\n                move_count, total_lines_cleared);\n  print_board(board);\n  libmin_success();\n}", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x2a,%edi\npush   %r14\npush   %r13\npush   %r12\nlea    0x3ef9(%rip),%r12\npush   %rbp\nlea    0x3ee4(%rip),%rbp\npush   %rbx\nsub    $0x6a8,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x698(%rsp)\nxor    %eax,%eax\nlea    0x50(%rsp),%r14\nlea    0x398(%rsp),%r13\ncall   4940 <libmin_srand>\npxor   %xmm0,%xmm0\nlea    0x370(%rsp),%rax\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x70(%rsp)\nmovaps %xmm0,0x80(%rsp)\nmovaps %xmm0,0x90(%rsp)\nmovaps %xmm0,0xa0(%rsp)\nmovaps %xmm0,0xb0(%rsp)\nmovaps %xmm0,0xc0(%rsp)\nmovaps %xmm0,0xd0(%rsp)\nmovaps %xmm0,0xe0(%rsp)\nmovaps %xmm0,0xf0(%rsp)\nmovaps %xmm0,0x100(%rsp)\nmovaps %xmm0,0x110(%rsp)\nmovaps %xmm0,0x120(%rsp)\nmovaps %xmm0,0x130(%rsp)\nmovaps %xmm0,0x140(%rsp)\nmovaps %xmm0,0x150(%rsp)\nmovaps %xmm0,0x160(%rsp)\nmovaps %xmm0,0x170(%rsp)\nmovaps %xmm0,0x180(%rsp)\nmovaps %xmm0,0x190(%rsp)\nmovaps %xmm0,0x1a0(%rsp)\nmovaps %xmm0,0x1b0(%rsp)\nmovaps %xmm0,0x1c0(%rsp)\nmovaps %xmm0,0x1d0(%rsp)\nmovaps %xmm0,0x1e0(%rsp)\nmovaps %xmm0,0x1f0(%rsp)\nmovaps %xmm0,0x200(%rsp)\nmovaps %xmm0,0x210(%rsp)\nmovaps %xmm0,0x220(%rsp)\nmovaps %xmm0,0x230(%rsp)\nmovaps %xmm0,0x240(%rsp)\nmovaps %xmm0,0x250(%rsp)\nmov    %rax,(%rsp)\nlea    0x48(%rsp),%rax\nmov    %rax,0x28(%rsp)\nlea    0x38(%rsp),%rax\nmov    %rax,0x10(%rsp)\nlea    0x40(%rsp),%rax\nmov    %rax,0x20(%rsp)\nlea    0x3c(%rsp),%rax\nmovl   $0x0,0xc(%rsp)\nmovl   $0x0,0x8(%rsp)\nmov    %rax,0x18(%rsp)\nmovaps %xmm0,0x260(%rsp)\nmovaps %xmm0,0x270(%rsp)\nmovaps %xmm0,0x280(%rsp)\nmovaps %xmm0,0x290(%rsp)\nmovaps %xmm0,0x2a0(%rsp)\nmovaps %xmm0,0x2b0(%rsp)\nmovaps %xmm0,0x2c0(%rsp)\nmovaps %xmm0,0x2d0(%rsp)\nmovaps %xmm0,0x2e0(%rsp)\nmovaps %xmm0,0x2f0(%rsp)\nmovaps %xmm0,0x300(%rsp)\nmovaps %xmm0,0x310(%rsp)\nmovaps %xmm0,0x320(%rsp)\nmovaps %xmm0,0x330(%rsp)\nmovaps %xmm0,0x340(%rsp)\nmovaps %xmm0,0x350(%rsp)\nmovaps %xmm0,0x360(%rsp)\nnopl   0x0(%rax)\ncall   49a0 <libmin_rand>\nsub    $0x8,%rsp\nmov    %r14,%rdi\nmov    %eax,%ecx\nmov    %eax,%edx\npush   0x20(%rsp)\nmov    0x10(%rsp),%r9\nimul   $0x24924925,%rcx,%rcx\nmov    0x38(%rsp),%r8\nshr    $0x20,%rcx\nsub    %ecx,%edx\nshr    %edx\nadd    %ecx,%edx\nshr    $0x2,%edx\nlea    0x0(,%rdx,8),%ecx\nsub    %edx,%ecx\nmov    0x30(%rsp),%rdx\nsub    %ecx,%eax\nlea    0x69b7(%rip),%rcx\nshl    $0x4,%rax\nlea    (%rcx,%rax,1),%rsi\nmov    0x20(%rsp),%rcx\ncall   21d0 <best_move>\npop    %rdx\npop    %rcx\ntest   %eax,%eax\nje     142e <main+0x32e>\nmov    (%rsp),%rsi\nmov    $0x320,%edx\nmov    %r14,%rdi\ncall   2700 <libmin_memcpy>\naddl   $0x1,0x8(%rsp)\nmov    0x8(%rsp),%eax\nmov    0x3c(%rsp),%ecx\nadd    %ecx,0xc(%rsp)\nimul   $0xcccccccd,%eax,%eax\nror    %eax\ncmp    $0x19999999,%eax\nja     1320 <main+0x220>\nmovsd  0x48(%rsp),%xmm0\nmov    0xc(%rsp),%edx\nlea    0x3c85(%rip),%rdi\nmov    $0x1,%eax\nmov    0x8(%rsp),%esi\nlea    0x78(%rsp),%rbx\ncall   4730 <libmin_printf>\nxchg   %ax,%ax\nlea    -0x28(%rbx),%r15\nnopl   0x0(%rax)\nmov    (%r15),%eax\nmov    $0x58,%esi\ntest   %eax,%eax\njne    13f9 <main+0x2f9>\nmov    $0x2e,%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x4,%r15\ncall   4730 <libmin_printf>\ncmp    %rbx,%r15\njne    13e8 <main+0x2e8>\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x28,%rbx\ncall   4730 <libmin_printf>\ncmp    %r13,%rbx\njne    13e0 <main+0x2e0>\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   4730 <libmin_printf>\njmp    1320 <main+0x220>\nlea    0x3bd2(%rip),%rdi\ncall   4730 <libmin_printf>\nmov    0xc(%rsp),%edx\nmov    0x8(%rsp),%esi\nxor    %eax,%eax\nlea    0x3bcd(%rip),%rdi\ncall   4730 <libmin_printf>\nmov    %r14,%rdi\ncall   2440 <print_board>\ncall   4b90 <libmin_success>\nmov    0x698(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1484 <main+0x384>\nadd    $0x6a8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "place_piece", "content": "// Place the piece on the board (modifies board)\nvoid place_piece(int board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int offset_y) {\n    for (int i = 0; i < ori->numBlocks; i++) {\n        int x = offset_x + ori->blocks[i].x;\n        int y = offset_y + ori->blocks[i].y;\n        board[y][x] = 1;\n    }\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "place_piece", "address": "0x1890", "label": "place_piece", "content": "void __fastcall place_piece(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  __int64 v5; // rsi\n  int *v6; // r9\n  int x; // r8d\n\n  if ( ori->numBlocks > 0 )\n  {\n    (*board)[10 * offset_y + 10 * ori->blocks[0].y + offset_x + ori->blocks[0].x] = 1;\n    if ( ori->numBlocks > 1 )\n    {\n      (*board)[10 * offset_y + 10 * ori->blocks[1].y + offset_x + ori->blocks[1].x] = 1;\n      if ( ori->numBlocks > 2 )\n      {\n        (*board)[10 * offset_y + 10 * ori->blocks[2].y + offset_x + ori->blocks[2].x] = 1;\n        if ( ori->numBlocks > 3 )\n        {\n          (*board)[10 * offset_y + 10 * ori->blocks[3].y + offset_x + ori->blocks[3].x] = 1;\n          if ( ori->numBlocks > 4 )\n          {\n            (*board)[10 * offset_y + 10 * ori[1].blocks[0].x + offset_x + ori[1].numBlocks] = 1;\n            if ( ori->numBlocks > 5 )\n            {\n              v5 = 5LL;\n              do\n              {\n                v6 = &(*board)[10 * offset_y + 10 * ori->blocks[v5].y];\n                x = ori->blocks[v5++].x;\n                v6[offset_x + x] = 1;\n              }\n              while ( ori->numBlocks > (int)v5 );\n            }\n          }\n        }\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void place_piece(int (*board)[10], const Orientation *ori, int offset_x,\n                 int offset_y) {\n  long long v5;\n  int *v6;\n  int x;\n  if (ori->numBlocks > 0) {\n    (*board)[10 * offset_y + 10 * ori->blocks[0].y + offset_x +\n             ori->blocks[0].x] = 1;\n    if (ori->numBlocks > 1) {\n      (*board)[10 * offset_y + 10 * ori->blocks[1].y + offset_x +\n               ori->blocks[1].x] = 1;\n      if (ori->numBlocks > 2) {\n        (*board)[10 * offset_y + 10 * ori->blocks[2].y + offset_x +\n                 ori->blocks[2].x] = 1;\n        if (ori->numBlocks > 3) {\n          (*board)[10 * offset_y + 10 * ori->blocks[3].y + offset_x +\n                   ori->blocks[3].x] = 1;\n          if (ori->numBlocks > 4) {\n            (*board)[10 * offset_y + 10 * ori[1].blocks[0].x + offset_x +\n                     ori[1].numBlocks] = 1;\n            if (ori->numBlocks > 5) {\n              v5 = 5LL;\n              do {\n                v6 = &(*board)[10 * offset_y + 10 * ori->blocks[v5].y];\n                x = ori->blocks[v5++].x;\n                v6[offset_x + x] = 1;\n              } while (ori->numBlocks > (int)v5);\n            }\n          }\n        }\n      }\n    }\n  }\n}", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<place_piece>:\nendbr64\nmov    %rsi,%rax\nmov    (%rsi),%esi\ntest   %esi,%esi\njle    1995 <place_piece+0x105>\nmov    0x8(%rax),%esi\nadd    %ecx,%esi\nmovslq %esi,%rsi\nlea    (%rsi,%rsi,4),%rsi\nlea    (%rdi,%rsi,8),%r8\nmov    0x4(%rax),%esi\nadd    %edx,%esi\nmovslq %esi,%rsi\nmovl   $0x1,(%r8,%rsi,4)\ncmpl   $0x1,(%rax)\njle    1995 <place_piece+0x105>\nmov    0x10(%rax),%esi\nadd    %ecx,%esi\nmovslq %esi,%rsi\nlea    (%rsi,%rsi,4),%rsi\nlea    (%rdi,%rsi,8),%r8\nmov    0xc(%rax),%esi\nadd    %edx,%esi\nmovslq %esi,%rsi\nmovl   $0x1,(%r8,%rsi,4)\ncmpl   $0x2,(%rax)\njle    1995 <place_piece+0x105>\nmov    0x18(%rax),%esi\nadd    %ecx,%esi\nmovslq %esi,%rsi\nlea    (%rsi,%rsi,4),%rsi\nlea    (%rdi,%rsi,8),%r8\nmov    0x14(%rax),%esi\nadd    %edx,%esi\nmovslq %esi,%rsi\nmovl   $0x1,(%r8,%rsi,4)\ncmpl   $0x3,(%rax)\njle    1995 <place_piece+0x105>\nmov    0x20(%rax),%esi\nadd    %ecx,%esi\nmovslq %esi,%rsi\nlea    (%rsi,%rsi,4),%rsi\nlea    (%rdi,%rsi,8),%r8\nmov    0x1c(%rax),%esi\nadd    %edx,%esi\nmovslq %esi,%rsi\nmovl   $0x1,(%r8,%rsi,4)\ncmpl   $0x4,(%rax)\njle    1995 <place_piece+0x105>\nmov    0x28(%rax),%esi\nadd    %ecx,%esi\nmovslq %esi,%rsi\nlea    (%rsi,%rsi,4),%rsi\nlea    (%rdi,%rsi,8),%r8\nmov    0x24(%rax),%esi\nadd    %edx,%esi\nmovslq %esi,%rsi\nmovl   $0x1,(%r8,%rsi,4)\ncmpl   $0x5,(%rax)\njle    1995 <place_piece+0x105>\nmov    $0x5,%esi\nmov    0x8(%rax,%rsi,8),%r8d\nadd    %ecx,%r8d\nmovslq %r8d,%r8\nlea    (%r8,%r8,4),%r8\nlea    (%rdi,%r8,8),%r9\nmov    0x4(%rax,%rsi,8),%r8d\nadd    $0x1,%rsi\nadd    %edx,%r8d\nmovslq %r8d,%r8\nmovl   $0x1,(%r9,%r8,4)\ncmp    %esi,(%rax)\njg     1967 <place_piece+0xd7>\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "print_board", "content": "// ------------------------\n// Board Display (text-based)\n// ------------------------\nvoid print_board(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    for (int y = 0; y < BOARD_HEIGHT; y++) {\n        for (int x = 0; x < BOARD_WIDTH; x++) {\n            libmin_printf(\"%c\", board[y][x] ? 'X' : '.');\n        }\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "print_board", "address": "0x2440", "label": "print_board", "content": "void __fastcall print_board(int (*board)[10])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n  __int64 v3; // rsi\n\n  v1 = &(*board)[10];\n  do\n  {\n    v2 = v1 - 10;\n    do\n    {\n      v3 = 88LL;\n      if ( !*v2 )\n        v3 = 46LL;\n      ++v2;\n      libmin_printf(\"%c\", v3);\n    }\n    while ( v2 != v1 );\n    v1 += 10;\n    libmin_printf((char *)\"\\n\");\n  }\n  while ( v1 != &(*board)[210] );\n  libmin_printf((char *)\"\\n\");\n}\n"}, "pseudo_normalize": "void print_board(int (*board)[10]) {\n  int *v1;\n  int *v2;\n  long long v3;\n  v1 = &(*board)[10];\n  do {\n    v2 = v1 - 10;\n    do {\n      v3 = 88LL;\n      if (!*v2) v3 = 46LL;\n      ++v2;\n      libmin_printf(\"%c\", v3);\n    } while (v2 != v1);\n    v1 += 10;\n    libmin_printf((char *)\"\\n\");\n  } while (v1 != &(*board)[210]);\n  libmin_printf((char *)\"\\n\");\n}", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<print_board>:\nendbr64\npush   %r14\nlea    0x2bc4(%rip),%r14\npush   %r13\nlea    0x348(%rdi),%r13\npush   %r12\nlea    0x2ba5(%rip),%r12\npush   %rbp\nlea    0x28(%rdi),%rbp\npush   %rbx\nnopl   (%rax)\nlea    -0x28(%rbp),%rbx\nnopl   0x0(%rax)\nmov    (%rbx),%eax\nmov    $0x58,%esi\ntest   %eax,%eax\njne    2480 <print_board+0x40>\nmov    $0x2e,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   4730 <libmin_printf>\ncmp    %rbp,%rbx\njne    2470 <print_board+0x30>\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x28,%rbp\ncall   4730 <libmin_printf>\ncmp    %r13,%rbp\njne    2468 <print_board+0x28>\npop    %rbx\nmov    %r14,%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %r14\njmp    4730 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "random_piece", "content": "// ------------------------\n// Random Piece Selection\n// ------------------------\nconst Piece* random_piece() {\n    int index = libmin_rand() % NUM_PIECES;\n    return &pieces[index];\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "random_piece", "address": "0x24c0", "label": "random_piece", "content": "const Piece *__cdecl random_piece()\n{\n  return &pieces[libmin_rand() % 7];\n}\n"}, "pseudo_normalize": "", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<random_piece>:\nendbr64\nsub    $0x8,%rsp\ncall   49a0 <libmin_rand>\nadd    $0x8,%rsp\nmov    %eax,%ecx\nmov    %eax,%edx\nimul   $0x24924925,%rcx,%rcx\nshr    $0x20,%rcx\nsub    %ecx,%edx\nshr    %edx\nadd    %ecx,%edx\nshr    $0x2,%edx\nlea    0x0(,%rdx,8),%ecx\nsub    %edx,%ecx\nlea    0x5827(%rip),%rdx\nsub    %ecx,%eax\nshl    $0x4,%rax\nadd    %rdx,%rax\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "simulate_board", "content": "// ------------------------\n// Simulation: Try dropping a piece and evaluating the resulting board.\n// ------------------------\n\n// Simulate dropping the piece (of a given orientation) at horizontal offset 'offset_x'.\n// The result is written into sim_board, and the number of lines cleared is returned via lines_cleared.\n// Returns 1 if placement is valid, 0 otherwise.\nint simulate_board(int orig_board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int sim_board[BOARD_HEIGHT][BOARD_WIDTH], int *lines_cleared) {\n    libmin_memcpy(sim_board, orig_board, sizeof(int) * BOARD_HEIGHT * BOARD_WIDTH);\n    int y = 0;\n    // Drop the piece until a collision is detected.\n    while (!check_collision(sim_board, ori, offset_x, y))\n        y++;\n    y--;  // last valid position\n    if (y < 0)\n        return 0;\n    place_piece(sim_board, ori, offset_x, y);\n    *lines_cleared = clear_lines(sim_board);\n    return 1;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O3.pseudo", "function_name": "simulate_board", "address": "0x1ee0", "label": "simulate_board", "content": "int __fastcall simulate_board(\n        int (*orig_board)[10],\n        const Orientation *ori,\n        int offset_x,\n        int (*sim_board)[10],\n        int *lines_cleared)\n{\n  int numBlocks; // ecx\n  int v10; // eax\n  int y; // esi\n  unsigned int v12; // edi\n  unsigned int v13; // edx\n  unsigned int v14; // r9d\n  unsigned int v15; // edx\n  unsigned int v16; // r9d\n  unsigned int v17; // edx\n  unsigned int v18; // r9d\n  unsigned int v19; // edx\n  unsigned int v20; // r9d\n  unsigned int v21; // edx\n  __int64 v22; // rdx\n  unsigned int v23; // r10d\n  unsigned int v24; // r9d\n  int v25; // edx\n  int v26; // r8d\n  __int64 v27; // rax\n  int *v28; // rsi\n  int x; // ecx\n  int v30; // eax\n\n  libmin_memcpy(sim_board, orig_board, 0x320uLL);\n  numBlocks = ori->numBlocks;\n  v10 = 0;\n  y = ori->blocks[0].y;\n  v12 = offset_x + ori->blocks[0].x;\n  while ( 1 )\n  {\n    if ( numBlocks > 0 )\n    {\n      v13 = v10 + y;\n      if ( v12 > 9 || v13 > 0x13 || (*sim_board)[10 * v13 + v12] )\n        goto LABEL_28;\n      if ( numBlocks != 1 )\n      {\n        v14 = offset_x + ori->blocks[1].x;\n        v15 = v10 + ori->blocks[1].y;\n        if ( v14 > 9 || v15 > 0x13 || (*sim_board)[10 * v15 + v14] )\n          goto LABEL_28;\n        if ( numBlocks != 2 )\n        {\n          v16 = offset_x + ori->blocks[2].x;\n          v17 = v10 + ori->blocks[2].y;\n          if ( v16 > 9 || v17 > 0x13 || (*sim_board)[10 * v17 + v16] )\n            goto LABEL_28;\n          if ( numBlocks != 3 )\n          {\n            v18 = offset_x + ori->blocks[3].x;\n            v19 = v10 + ori->blocks[3].y;\n            if ( v18 > 9 || v19 > 0x13 || (*sim_board)[10 * v19 + v18] )\n              goto LABEL_28;\n            if ( numBlocks != 4 )\n            {\n              v20 = offset_x + ori[1].numBlocks;\n              v21 = v10 + ori[1].blocks[0].x;\n              if ( v20 > 9 || v21 > 0x13 || (*sim_board)[10 * v21 + v20] )\n                goto LABEL_28;\n              if ( numBlocks != 5 )\n                break;\n            }\n          }\n        }\n      }\n    }\nLABEL_38:\n    ++v10;\n  }\n  v22 = 5LL;\n  while ( 1 )\n  {\n    v23 = offset_x + ori->blocks[v22].x;\n    v24 = v10 + ori->blocks[v22].y;\n    if ( v23 > 9 || v24 > 0x13 || (*sim_board)[10 * v24 + v23] )\n      break;\n    if ( numBlocks <= (int)++v22 )\n      goto LABEL_38;\n  }\nLABEL_28:\n  v25 = v10 - 1;\n  v26 = 0;\n  if ( v10 )\n  {\n    (*sim_board)[10 * v25 + 10 * y + v12] = 1;\n    if ( ori->numBlocks > 1 )\n    {\n      (*sim_board)[10 * v25 + 10 * ori->blocks[1].y + offset_x + ori->blocks[1].x] = 1;\n      if ( ori->numBlocks > 2 )\n      {\n        (*sim_board)[10 * v25 + 10 * ori->blocks[2].y + offset_x + ori->blocks[2].x] = 1;\n        if ( ori->numBlocks > 3 )\n        {\n          (*sim_board)[10 * v25 + 10 * ori->blocks[3].y + offset_x + ori->blocks[3].x] = 1;\n          if ( ori->numBlocks > 4 )\n          {\n            (*sim_board)[10 * v25 + 10 * ori[1].blocks[0].x + offset_x + ori[1].numBlocks] = 1;\n            if ( ori->numBlocks > 5 )\n            {\n              v27 = 5LL;\n              do\n              {\n                v28 = &(*sim_board)[10 * v25 + 10 * ori->blocks[v27].y];\n                x = ori->blocks[v27++].x;\n                v28[offset_x + x] = 1;\n              }\n              while ( ori->numBlocks > (int)v27 );\n            }\n          }\n        }\n      }\n    }\n    v30 = clear_lines(sim_board);\n    v26 = 1;\n    *lines_cleared = v30;\n  }\n  return v26;\n}\n"}, "pseudo_normalize": "int simulate_board(int (*orig_board)[10], const Orientation *ori, int offset_x,\n                   int (*sim_board)[10], int *lines_cleared) {\n  int numBlocks;\n  int v10;\n  int y;\n  unsigned int v12;\n  unsigned int v13;\n  unsigned int v14;\n  unsigned int v15;\n  unsigned int v16;\n  unsigned int v17;\n  unsigned int v18;\n  unsigned int v19;\n  unsigned int v20;\n  unsigned int v21;\n  long long v22;\n  unsigned int v23;\n  unsigned int v24;\n  int v25;\n  int v26;\n  long long v27;\n  int *v28;\n  int x;\n  int v30;\n  libmin_memcpy(sim_board, orig_board, 800uLL);\n  numBlocks = ori->numBlocks;\n  v10 = 0;\n  y = ori->blocks[0].y;\n  v12 = offset_x + ori->blocks[0].x;\n  while (1) {\n    if (numBlocks > 0) {\n      v13 = v10 + y;\n      if (v12 > 9 || v13 > 19 || (*sim_board)[10 * v13 + v12]) goto LABEL_28;\n      if (numBlocks != 1) {\n        v14 = offset_x + ori->blocks[1].x;\n        v15 = v10 + ori->blocks[1].y;\n        if (v14 > 9 || v15 > 19 || (*sim_board)[10 * v15 + v14]) goto LABEL_28;\n        if (numBlocks != 2) {\n          v16 = offset_x + ori->blocks[2].x;\n          v17 = v10 + ori->blocks[2].y;\n          if (v16 > 9 || v17 > 19 || (*sim_board)[10 * v17 + v16])\n            goto LABEL_28;\n          if (numBlocks != 3) {\n            v18 = offset_x + ori->blocks[3].x;\n            v19 = v10 + ori->blocks[3].y;\n            if (v18 > 9 || v19 > 19 || (*sim_board)[10 * v19 + v18])\n              goto LABEL_28;\n            if (numBlocks != 4) {\n              v20 = offset_x + ori[1].numBlocks;\n              v21 = v10 + ori[1].blocks[0].x;\n              if (v20 > 9 || v21 > 19 || (*sim_board)[10 * v21 + v20])\n                goto LABEL_28;\n              if (numBlocks != 5) break;\n            }\n          }\n        }\n      }\n    }\n  LABEL_38:\n    ++v10;\n  }\n  v22 = 5LL;\n  while (1) {\n    v23 = offset_x + ori->blocks[v22].x;\n    v24 = v10 + ori->blocks[v22].y;\n    if (v23 > 9 || v24 > 19 || (*sim_board)[10 * v24 + v23]) break;\n    if (numBlocks <= (int)++v22) goto LABEL_38;\n  }\nLABEL_28:\n  v25 = v10 - 1;\n  v26 = 0;\n  if (v10) {\n    (*sim_board)[10 * v25 + 10 * y + v12] = 1;\n    if (ori->numBlocks > 1) {\n      (*sim_board)[10 * v25 + 10 * ori->blocks[1].y + offset_x +\n                   ori->blocks[1].x] = 1;\n      if (ori->numBlocks > 2) {\n        (*sim_board)[10 * v25 + 10 * ori->blocks[2].y + offset_x +\n                     ori->blocks[2].x] = 1;\n        if (ori->numBlocks > 3) {\n          (*sim_board)[10 * v25 + 10 * ori->blocks[3].y + offset_x +\n                       ori->blocks[3].x] = 1;\n          if (ori->numBlocks > 4) {\n            (*sim_board)[10 * v25 + 10 * ori[1].blocks[0].x + offset_x +\n                         ori[1].numBlocks] = 1;\n            if (ori->numBlocks > 5) {\n              v27 = 5LL;\n              do {\n                v28 = &(*sim_board)[10 * v25 + 10 * ori->blocks[v27].y];\n                x = ori->blocks[v27++].x;\n                v28[offset_x + x] = 1;\n              } while (ori->numBlocks > (int)v27);\n            }\n          }\n        }\n      }\n    }\n    v30 = clear_lines(sim_board);\n    v26 = 1;\n    *lines_cleared = v30;\n  }\n  return v26;\n}", "binary": "tetris-sim/tetris-sim.host.O3", "assembly": "<simulate_board>:\nendbr64\npush   %r13\nmov    %edx,%r13d\nmov    $0x320,%edx\npush   %r12\nmov    %rcx,%r12\npush   %rbp\nmov    %r8,%rbp\npush   %rbx\nmov    %rsi,%rbx\nmov    %rdi,%rsi\nmov    %rcx,%rdi\nsub    $0x8,%rsp\ncall   2700 <libmin_memcpy>\nmov    0x4(%rbx),%edi\nmov    (%rbx),%ecx\nxor    %eax,%eax\nmov    0x8(%rbx),%esi\nadd    %r13d,%edi\nmovslq %edi,%r8\nnopw   0x0(%rax,%rax,1)\ntest   %ecx,%ecx\njle    21c0 <simulate_board+0x2e0>\nlea    (%rax,%rsi,1),%edx\ncmp    $0x9,%edi\nja     20b0 <simulate_board+0x1d0>\ncmp    $0x13,%edx\nja     20b0 <simulate_board+0x1d0>\nmovslq %edx,%rdx\nlea    (%rdx,%rdx,4),%rdx\nlea    (%r12,%rdx,8),%rdx\nmov    (%rdx,%r8,4),%r10d\ntest   %r10d,%r10d\njne    20b0 <simulate_board+0x1d0>\ncmp    $0x1,%ecx\nje     21c0 <simulate_board+0x2e0>\nmov    0xc(%rbx),%r9d\nmov    0x10(%rbx),%edx\nadd    %r13d,%r9d\nadd    %eax,%edx\ncmp    $0x9,%r9d\nja     20b0 <simulate_board+0x1d0>\ncmp    $0x13,%edx\nja     20b0 <simulate_board+0x1d0>\nmovslq %edx,%rdx\nmovslq %r9d,%r9\nlea    (%rdx,%rdx,4),%rdx\nlea    (%r12,%rdx,8),%rdx\nmov    (%rdx,%r9,4),%r9d\ntest   %r9d,%r9d\njne    20b0 <simulate_board+0x1d0>\ncmp    $0x2,%ecx\nje     21c0 <simulate_board+0x2e0>\nmov    0x14(%rbx),%r9d\nmov    0x18(%rbx),%edx\nadd    %r13d,%r9d\nadd    %eax,%edx\ncmp    $0x9,%r9d\nja     20b0 <simulate_board+0x1d0>\ncmp    $0x13,%edx\nja     20b0 <simulate_board+0x1d0>\nmovslq %edx,%rdx\nmovslq %r9d,%r9\nlea    (%rdx,%rdx,4),%rdx\nlea    (%r12,%rdx,8),%rdx\nmov    (%rdx,%r9,4),%edx\ntest   %edx,%edx\njne    20b0 <simulate_board+0x1d0>\ncmp    $0x3,%ecx\nje     21c0 <simulate_board+0x2e0>\nmov    0x1c(%rbx),%r9d\nmov    0x20(%rbx),%edx\nadd    %r13d,%r9d\nadd    %eax,%edx\ncmp    $0x9,%r9d\nja     20b0 <simulate_board+0x1d0>\ncmp    $0x13,%edx\nja     20b0 <simulate_board+0x1d0>\nmovslq %edx,%rdx\nmovslq %r9d,%r9\nlea    (%rdx,%rdx,4),%rdx\nlea    (%r12,%rdx,8),%rdx\nmov    (%rdx,%r9,4),%r11d\ntest   %r11d,%r11d\njne    20b0 <simulate_board+0x1d0>\ncmp    $0x4,%ecx\nje     21c0 <simulate_board+0x2e0>\nmov    0x24(%rbx),%r9d\nmov    0x28(%rbx),%edx\nadd    %r13d,%r9d\nadd    %eax,%edx\ncmp    $0x9,%r9d\nja     20b0 <simulate_board+0x1d0>\ncmp    $0x13,%edx\nja     20b0 <simulate_board+0x1d0>\nmovslq %edx,%rdx\nmovslq %r9d,%r9\nlea    (%rdx,%rdx,4),%rdx\nlea    (%r12,%rdx,8),%rdx\nmov    (%rdx,%r9,4),%r10d\ntest   %r10d,%r10d\njne    20b0 <simulate_board+0x1d0>\ncmp    $0x5,%ecx\nje     21c0 <simulate_board+0x2e0>\nmov    $0x5,%edx\njmp    2091 <simulate_board+0x1b1>\nnopl   0x0(%rax)\ncmp    $0x13,%r9d\nja     20b0 <simulate_board+0x1d0>\nmovslq %r9d,%r9\nmovslq %r10d,%r10\nlea    (%r9,%r9,4),%r9\nlea    (%r12,%r9,8),%r9\nmov    (%r9,%r10,4),%r9d\ntest   %r9d,%r9d\njne    20b0 <simulate_board+0x1d0>\nadd    $0x1,%rdx\ncmp    %edx,%ecx\njle    21c0 <simulate_board+0x2e0>\nmov    0x4(%rbx,%rdx,8),%r10d\nmov    0x8(%rbx,%rdx,8),%r9d\nadd    %r13d,%r10d\nadd    %eax,%r9d\ncmp    $0x9,%r10d\njbe    2068 <simulate_board+0x188>\nnopw   0x0(%rax,%rax,1)\nlea    -0x1(%rax),%edx\nxor    %r8d,%r8d\ntest   %eax,%eax\nje     21ae <simulate_board+0x2ce>\nlea    (%rdx,%rsi,1),%eax\nmovslq %edi,%rdi\ncltq\nlea    (%rax,%rax,4),%rax\nlea    (%r12,%rax,8),%rax\nmovl   $0x1,(%rax,%rdi,4)\ncmpl   $0x1,(%rbx)\njle    219d <simulate_board+0x2bd>\nmov    0x10(%rbx),%eax\nadd    %edx,%eax\ncltq\nlea    (%rax,%rax,4),%rax\nlea    (%r12,%rax,8),%rcx\nmov    0xc(%rbx),%eax\nadd    %r13d,%eax\ncltq\nmovl   $0x1,(%rcx,%rax,4)\ncmpl   $0x2,(%rbx)\njle    219d <simulate_board+0x2bd>\nmov    0x18(%rbx),%eax\nadd    %edx,%eax\ncltq\nlea    (%rax,%rax,4),%rax\nlea    (%r12,%rax,8),%rcx\nmov    0x14(%rbx),%eax\nadd    %r13d,%eax\ncltq\nmovl   $0x1,(%rcx,%rax,4)\ncmpl   $0x3,(%rbx)\njle    219d <simulate_board+0x2bd>\nmov    0x20(%rbx),%eax\nadd    %edx,%eax\ncltq\nlea    (%rax,%rax,4),%rax\nlea    (%r12,%rax,8),%rcx\nmov    0x1c(%rbx),%eax\nadd    %r13d,%eax\ncltq\nmovl   $0x1,(%rcx,%rax,4)\ncmpl   $0x4,(%rbx)\njle    219d <simulate_board+0x2bd>\nmov    0x28(%rbx),%eax\nadd    %edx,%eax\ncltq\nlea    (%rax,%rax,4),%rax\nlea    (%r12,%rax,8),%rcx\nmov    0x24(%rbx),%eax\nadd    %r13d,%eax\ncltq\nmovl   $0x1,(%rcx,%rax,4)\ncmpl   $0x5,(%rbx)\njle    219d <simulate_board+0x2bd>\nmov    $0x5,%eax\nmov    0x8(%rbx,%rax,8),%ecx\nadd    %edx,%ecx\nmovslq %ecx,%rcx\nlea    (%rcx,%rcx,4),%rcx\nlea    (%r12,%rcx,8),%rsi\nmov    0x4(%rbx,%rax,8),%ecx\nadd    $0x1,%rax\nadd    %r13d,%ecx\nmovslq %ecx,%rcx\nmovl   $0x1,(%rsi,%rcx,4)\ncmp    %eax,(%rbx)\njg     2173 <simulate_board+0x293>\nmov    %r12,%rdi\ncall   19a0 <clear_lines>\nmov    $0x1,%r8d\nmov    %eax,0x0(%rbp)\nadd    $0x8,%rsp\nmov    %r8d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nadd    $0x1,%eax\njmp    1f20 <simulate_board+0x40>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "fillArrayNull", "content": "/*\n * fills the array with 0\n */\nvoid fillArrayNull(NETWORK_DATA_TYPE* array, unsigned int size)\n{\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tarray[i] = (NETWORK_DATA_TYPE)0;\n\t}\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O3.pseudo", "function_name": "fillArrayNull", "address": "0x13b0", "label": "fillArrayNull", "content": "void __fastcall fillArrayNull(double *array, unsigned int size)\n{\n  if ( size )\n    memset(array, 0, 8LL * size);\n}\n"}, "pseudo_normalize": "", "binary": "tiny-NN/tiny-NN.host.O3", "assembly": "<fillArrayNull>:\nendbr64\ntest   %esi,%esi\nje     13d0 <fillArrayNull+0x20>\nmov    %esi,%esi\nlea    0x0(,%rsi,8),%rdx\nxor    %esi,%esi\njmp    10d0 <memset@plt>\nnopl   0x0(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "fillArrayRand", "content": "/*\n * fills the array with values from [-0.5,0.5]\n */\nvoid fillArrayRand(NETWORK_DATA_TYPE* array, unsigned int size)\n{\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tarray[i] = (NETWORK_DATA_TYPE)libmin_rand()/(NETWORK_DATA_TYPE)RAND_MAX - 0.5;\n\t}\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O3.pseudo", "function_name": "fillArrayRand", "address": "0x1350", "label": "fillArrayRand", "content": "void __fastcall fillArrayRand(double *array, unsigned int size)\n{\n  double *v2; // rbx\n\n  if ( size )\n  {\n    v2 = array;\n    do\n      *v2++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n    while ( v2 != &array[size] );\n  }\n}\n"}, "pseudo_normalize": "void fillArrayRand(double *array, unsigned int size) {\n  double *v2;\n  if (size) {\n    v2 = array;\n    do *v2++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n    while (v2 != &array[size]);\n  }\n}", "binary": "tiny-NN/tiny-NN.host.O3", "assembly": "<fillArrayRand>:\nendbr64\ntest   %esi,%esi\nje     13a8 <fillArrayRand+0x58>\npush   %rbp\nlea    -0x1(%rsi),%eax\npush   %rbx\nlea    0x8(%rdi,%rax,8),%rbp\nmov    %rdi,%rbx\nsub    $0x8,%rsp\nnopl   0x0(%rax)\ncall   3d80 <libmin_rand>\npxor   %xmm0,%xmm0\nadd    $0x8,%rbx\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x5cbc(%rip),%xmm0\nsubsd  0x5cbc(%rip),%xmm0\nmovsd  %xmm0,-0x8(%rbx)\ncmp    %rbp,%rbx\njne    1370 <fillArrayRand+0x20>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   (%rax)\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "g", "content": "/*\n * the sigmoid function\n */\ninline NETWORK_DATA_TYPE g(NETWORK_DATA_TYPE a)\n{\n\treturn 1.0 / (1.0 + libmin_exp(-1.0*a));\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O3.pseudo", "function_name": "g", "address": "0x12a0", "label": "g", "content": "double __fastcall g(double a1, double a)\n{\n  return 1.0 / (libmin_exp(a) + 1.0);\n}\n"}, "pseudo_normalize": "", "binary": "tiny-NN/tiny-NN.host.O3", "assembly": "<g>:\nendbr64\nsub    $0x8,%rsp\nxorpd  0x5d80(%rip),%xmm0\ncall   1a40 <libmin_exp>\nmovsd  0x5d83(%rip),%xmm1\nadd    $0x8,%rsp\naddsd  %xmm1,%xmm0\ndivsd  %xmm0,%xmm1\nmovapd %xmm1,%xmm0\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "g_deriv", "content": "//flavor!\n//#define FANCY\n#define OUTPUT\n\n/*\n * the derivative of the sigmoid function\n */\ninline NETWORK_DATA_TYPE g_deriv(NETWORK_DATA_TYPE a)\n{\n\tNETWORK_DATA_TYPE sigmoid = 1.0 / (1.0 + libmin_exp(-1.0*a));\n\n\treturn sigmoid*(1.0-sigmoid);\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O3.pseudo", "function_name": "g_deriv", "address": "0x1260", "label": "g_deriv", "content": "double __fastcall g_deriv(double a1, double a)\n{\n  double v2; // xmm0_8\n\n  v2 = libmin_exp(a);\n  return (1.0 - 1.0 / (v2 + 1.0)) * (1.0 / (v2 + 1.0));\n}\n"}, "pseudo_normalize": "", "binary": "tiny-NN/tiny-NN.host.O3", "assembly": "<g_deriv>:\nendbr64\nsub    $0x8,%rsp\nxorpd  0x5dc0(%rip),%xmm0\ncall   1a40 <libmin_exp>\nmovsd  0x5dc3(%rip),%xmm1\nadd    $0x8,%rsp\naddsd  %xmm1,%xmm0\nmovapd %xmm1,%xmm2\ndivsd  %xmm0,%xmm2\nsubsd  %xmm2,%xmm1\nmulsd  %xmm2,%xmm1\nmovapd %xmm1,%xmm0\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "main", "content": "int\nmain(void)\n{\n  libmin_srand(42);\n\ttrain(0.005, 0.01, 1.0, 0.4);\n\n\tlibmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm4_8\n\n  libmin_srand(0x2Au);\n  train(0.01, 1.0, 0.4, v3);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  libmin_srand(42u);\n  train(0.01, 1.0, 0.4, v3);\n  libmin_success();\n}", "binary": "tiny-NN/tiny-NN.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x2a,%edi\ncall   3d20 <libmin_srand>\nmovsd  0x5f26(%rip),%xmm3\nmovsd  0x5efe(%rip),%xmm2\nmovsd  0x5f1e(%rip),%xmm1\nmovsd  0x5f1e(%rip),%xmm0\ncall   13e0 <train>\ncall   4930 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "sampleSine", "content": "/*\n * samples the sin function from 'start' to 'end' with 'size' equidistant steps\n */\nvoid sampleSine(NETWORK_DATA_TYPE* input, NETWORK_DATA_TYPE* output, NETWORK_DATA_TYPE start, NETWORK_DATA_TYPE end, unsigned int size)\n{\n\tNETWORK_DATA_TYPE step = (end-start)/(NETWORK_DATA_TYPE)size;\n\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tinput[i] = start + step * (NETWORK_DATA_TYPE)i;\n\t\toutput[i] = libmin_sin(input[i]);\n\t}\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O3.pseudo", "function_name": "sampleSine", "address": "0x12d0", "label": "sampleSine", "content": "void __fastcall sampleSine(double *input, double *output, double start, double end, int size)\n{\n  __int64 v5; // r12\n  double v6; // xmm1_8\n  __int64 v7; // r13\n\n  v5 = (unsigned int)size;\n  v6 = (end - start) / (double)size;\n  if ( size )\n  {\n    v7 = 0LL;\n    do\n    {\n      input[v7] = (double)(int)v7 * v6 + start;\n      output[v7++] = libmin_sin(v6);\n    }\n    while ( v5 != v7 );\n  }\n}\n"}, "pseudo_normalize": "void sampleSine(double *input, double *output, double start, double end,\n                int size) {\n  long long v5;\n  double v6;\n  long long v7;\n  v5 = (unsigned int)size;\n  v6 = (end - start) / (double)size;\n  if (size) {\n    v7 = 0LL;\n    do {\n      input[v7] = (double)(int)v7 * v6 + start;\n      output[v7++] = libmin_sin(v6);\n    } while (v5 != v7);\n  }\n}", "binary": "tiny-NN/tiny-NN.host.O3", "assembly": "<sampleSine>:\nendbr64\npush   %r13\nsubsd  %xmm0,%xmm1\npush   %r12\nmov    %edx,%r12d\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmovsd  %xmm0,0x8(%rsp)\npxor   %xmm0,%xmm0\ncvtsi2sd %r12,%xmm0\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,(%rsp)\ntest   %edx,%edx\nje     1342 <sampleSine+0x72>\nmov    %rdi,%rbx\nmov    %rsi,%rbp\nxor    %r13d,%r13d\nnopw   0x0(%rax,%rax,1)\nmov    %r13d,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\nmulsd  (%rsp),%xmm0\naddsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,(%rbx,%r13,8)\ncall   4550 <libmin_sin>\nmovsd  %xmm0,0x0(%rbp,%r13,8)\nadd    $0x1,%r13\ncmp    %r13,%r12\njne    1310 <sampleSine+0x40>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   (%rax)\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "train", "content": "int train(NETWORK_DATA_TYPE eta, NETWORK_DATA_TYPE error_threshold, NETWORK_DATA_TYPE bias, NETWORK_DATA_TYPE alpha)\n{\n\n\tNETWORK_DATA_TYPE total_error = error_threshold + 1.0;//why?\n\n\t//data\n\tNETWORK_DATA_TYPE input[SAMPLE_COUNT];\n\tNETWORK_DATA_TYPE output[SAMPLE_COUNT];\n\n\t//NN container for NEURON_COUNT neurons\n\tNETWORK_DATA_TYPE NN_output = 0;\n\tNETWORK_DATA_TYPE weights_layer0_1[NEURON_COUNT*2]; //don't forget the bias :-) {PSSSTT: format = [input_w, bias_w, input_w, bias_w...]}\n\tNETWORK_DATA_TYPE weights_layer1_2[NEURON_COUNT];\n\n\tNETWORK_DATA_TYPE delta_weights_layer0_1[NEURON_COUNT*2]; //don't forget the bias :-) {PSSSTT: format = [input_w, bias_w, input_w, bias_w...]}\n\tNETWORK_DATA_TYPE delta_weights_layer1_2[NEURON_COUNT];\n\n\tNETWORK_DATA_TYPE delta_layer_2, delta_layer_1;\n\tNETWORK_DATA_TYPE a;\n\tNETWORK_DATA_TYPE g_layer_1[NEURON_COUNT];\n\tNETWORK_DATA_TYPE g_deriv_layer_1[NEURON_COUNT];\n\tNETWORK_DATA_TYPE delta_w_layer_2_1;\n\tNETWORK_DATA_TYPE delta_w_layer_1_0;\n\n\t//init the network\n\tfillArrayRand(weights_layer0_1,NEURON_COUNT*2);//random values for the weight 0->1\n\tfillArrayRand(weights_layer1_2,NEURON_COUNT);//random values for the weights 1->2\n\n\tfillArrayNull(delta_weights_layer0_1,NEURON_COUNT*2);\n\tfillArrayNull(delta_weights_layer1_2,NEURON_COUNT);\n\n\t//create the training data\n\tsampleSine(input, output, 0, 3.14, SAMPLE_COUNT);\n\n\t//train the network\n\tunsigned int iteration_count = 0;\n\n\twhile(total_error > error_threshold && iteration_count < MAX_ITERATIONS)\n\t{\n\t\ttotal_error = 0;//hmmm....\n\n\t\t//present the data to the NN\n\t\tunsigned int i;\n\t\tfor(i=0; i<SAMPLE_COUNT; ++i)\n\t\t{\n\t\t\t//propagate the sample forward\n\t\t\t//layer 0 -> 1 ... and layer 1->2\n\t\t\tunsigned int j;\n\t\t\tfor(j=0; j<NEURON_COUNT; ++j)\n\t\t\t{\n\t\t\t\ta = input[i] * weights_layer0_1[2*j] + bias * weights_layer0_1[2*j+1];\n\t\t\t\tg_layer_1[j] = g(a);\n\t\t\t\tg_deriv_layer_1[j] = g_deriv(a);\n\n\t\t\t\tNN_output += weights_layer1_2[j] * g_layer_1[j];\n\t\t\t}\n\n\t\t\t//calculate the errors\n\t\t\tdelta_layer_2 = NN_output - output[i];\n\t\t\ttotal_error += delta_layer_2*delta_layer_2;\n\n\t\t\t//backpropagate the deltas\n\t\t\t//layer 2->1 ... and 1->0\n\t\t\tfor(j=0; j<NEURON_COUNT; ++j)\n\t\t\t{\n\t\t\t\tdelta_layer_1 = g_deriv_layer_1[j] * weights_layer1_2[j] * delta_layer_2;\n\t\t\t\tdelta_w_layer_2_1 = delta_layer_2 * g_layer_1[j];\n\n\t\t\t\t//?\n\t\t\t\tweights_layer1_2[j] -= delta_w_layer_2_1 * eta + alpha*delta_weights_layer1_2[j] ;\n\t\t\t\tdelta_weights_layer1_2[j] = delta_w_layer_2_1 * eta + alpha*delta_weights_layer1_2[j] ;\n\n\t\t\t\tdelta_w_layer_1_0 = delta_layer_1 * input[i];\n\t\t\t\tweights_layer0_1[2*j] -= delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j];\n\t\t\t\tdelta_weights_layer0_1[2*j] = delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j];\n\n\t\t\t\tdelta_w_layer_1_0 = delta_layer_1 * bias;\n\t\t\t\tweights_layer0_1[2*j+1] -= delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j+1];\n\t\t\t\tdelta_weights_layer0_1[2*j+1] = delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j+1];\n\t\t\t}\n\n\t\t\t//update the weights (uppsi, did it already... but how?)\n\t\t\t#ifdef FANCY\n\t\t\tlibmin_printf(\"sample error %f, should %f is %f\\n\",delta_layer_2,output[i], NN_output);\n\t\t\t#endif\n\n\t\t\t//prepare for the next nerve wrecking round\n\t\t\tNN_output = 0;\n\t\t}\n\n\t\t#ifdef FANCY\n\t\tlibmin_printf(\"Total error %f\\n\\n\",total_error);\n\t\t#endif\n\n\t\t++iteration_count;\n\n\t\tfillArrayNull(delta_weights_layer0_1,NEURON_COUNT*2);\n\t\tfillArrayNull(delta_weights_layer1_2,NEURON_COUNT);\n\n\t\t#ifdef OUTPUT\n\t\tlibmin_printf(\"iteration %d Total error %f\\n\",iteration_count,total_error);\n\t\t#endif\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O3.pseudo", "function_name": "train", "address": "0x13e0", "label": "train", "content": "__int64 __fastcall train(double a1, double eta, double error_threshold, double bias, double alpha)\n{\n  double *v6; // rbp\n  double v7; // xmm1_8\n  double *v8; // rbp\n  __int64 v9; // rbx\n  unsigned __int64 v10; // r13\n  double v11; // xmm0_8\n  double v12; // xmm0_8\n  double v13; // xmm3_8\n  __m128d v14; // xmm5\n  double *v15; // rdx\n  double *v16; // rcx\n  __int64 v17; // rax\n  __m128d v18; // xmm6\n  double v19; // xmm0_8\n  __m128d v20; // xmm5\n  __m128d v21; // xmm1\n  __m128d v22; // xmm3\n  __m128d v23; // xmm0\n  __m128d v24; // xmm1\n  __m128d v25; // xmm4\n  __m128d v26; // xmm1\n  __m128d v27; // xmm0\n  __m128d v28; // xmm4\n  __m128d v29; // xmm0\n  __m128d v30; // xmm3\n  __m128d v31; // xmm3\n  double NN_output; // [rsp+0h] [rbp-718h]\n  double v34; // [rsp+8h] [rbp-710h]\n  double x; // [rsp+10h] [rbp-708h]\n  double v36; // [rsp+18h] [rbp-700h]\n  __m128d v37; // [rsp+20h] [rbp-6F8h]\n  __m128d v38; // [rsp+30h] [rbp-6E8h]\n  __m128d v39; // [rsp+40h] [rbp-6D8h]\n  __int64 v40; // [rsp+58h] [rbp-6C0h]\n  double total_error; // [rsp+60h] [rbp-6B8h]\n  unsigned int iteration_count; // [rsp+84h] [rbp-694h]\n  double input[20]; // [rsp+90h] [rbp-688h]\n  double output[20]; // [rsp+130h] [rbp-5E8h]\n  double weights_layer1_2[20]; // [rsp+1D0h] [rbp-548h] BYREF\n  double delta_weights_layer1_2[20]; // [rsp+270h] [rbp-4A8h] BYREF\n  double g_layer_1[20]; // [rsp+310h] [rbp-408h]\n  double g_deriv_layer_1[20]; // [rsp+3B0h] [rbp-368h]\n  double weights_layer0_1[40]; // [rsp+450h] [rbp-2C8h] BYREF\n  double delta_weights_layer0_1[49]; // [rsp+590h] [rbp-188h] BYREF\n\n  v6 = weights_layer0_1;\n  v7 = eta + 1.0;\n  *(_QWORD *)&delta_weights_layer0_1[41] = __readfsqword(0x28u);\n  do\n    *v6++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n  while ( delta_weights_layer0_1 != v6 );\n  v8 = weights_layer1_2;\n  do\n    *v8++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n  while ( v8 != delta_weights_layer1_2 );\n  v9 = 0LL;\n  memset(delta_weights_layer0_1, 0, 0x140uLL);\n  memset(delta_weights_layer1_2, 0, sizeof(delta_weights_layer1_2));\n  do\n  {\n    input[v9] = (double)(int)v9 * 0.157 + 0.0;\n    output[v9++] = libmin_sin(v7);\n  }\n  while ( v9 != 20 );\n  if ( v7 > eta )\n  {\n    iteration_count = 0;\n    v37 = _mm_unpacklo_pd((__m128d)*(unsigned __int64 *)&a1, (__m128d)*(unsigned __int64 *)&a1);\n    v39 = _mm_unpacklo_pd((__m128d)*(unsigned __int64 *)&bias, (__m128d)*(unsigned __int64 *)&bias);\n    v38 = _mm_unpacklo_pd(\n            (__m128d)*(unsigned __int64 *)&error_threshold,\n            (__m128d)*(unsigned __int64 *)&error_threshold);\n    do\n    {\n      v40 = 0LL;\n      total_error = 0.0;\n      do\n      {\n        NN_output = 0.0;\n        v10 = 0LL;\n        v36 = input[v40];\n        do\n        {\n          x = -(v36 * weights_layer0_1[v10 / 4] + error_threshold * weights_layer0_1[v10 / 4 + 1]);\n          v11 = libmin_exp(x);\n          g_layer_1[v10 / 8] = 1.0 / (v11 + 1.0);\n          v34 = 1.0 / (v11 + 1.0);\n          v12 = libmin_exp(x);\n          v13 = v34 * weights_layer1_2[v10 / 8] + NN_output;\n          NN_output = v13;\n          g_deriv_layer_1[v10 / 8] = (1.0 - 1.0 / (v12 + 1.0)) * (1.0 / (v12 + 1.0));\n          v10 += 8LL;\n        }\n        while ( v10 != 160 );\n        v14.m128d_f64[1] = 0.0;\n        v15 = weights_layer0_1;\n        v16 = delta_weights_layer0_1;\n        v14.m128d_f64[0] = v13 - output[v40];\n        v17 = 0LL;\n        v18 = _mm_unpacklo_pd((__m128d)*(unsigned __int64 *)&v36, (__m128d)*(unsigned __int64 *)&v36);\n        v19 = v14.m128d_f64[0] * v14.m128d_f64[0];\n        v20 = _mm_unpacklo_pd(v14, v14);\n        total_error = v19 + total_error;\n        do\n        {\n          v21 = *(__m128d *)&weights_layer1_2[v17];\n          v15 += 4;\n          v16 += 4;\n          v22 = _mm_mul_pd(_mm_mul_pd(*(__m128d *)&g_deriv_layer_1[v17], v21), v20);\n          v23 = _mm_add_pd(\n                  _mm_mul_pd(_mm_mul_pd(*(__m128d *)&g_layer_1[v17], v20), v37),\n                  _mm_mul_pd(*(__m128d *)&delta_weights_layer1_2[v17], v39));\n          *(__m128d *)&delta_weights_layer1_2[v17] = v23;\n          *(__m128d *)&weights_layer1_2[v17] = _mm_sub_pd(v21, v23);\n          v24 = (__m128d)*((_OWORD *)v16 - 2);\n          v25 = (__m128d)*((_OWORD *)v15 - 2);\n          v17 += 2LL;\n          v24.m128d_f64[1] = *(v16 - 2);\n          v25.m128d_f64[1] = *(v15 - 2);\n          v26 = _mm_add_pd(_mm_mul_pd(v24, v39), _mm_mul_pd(_mm_mul_pd(v18, v22), v37));\n          v27 = (__m128d)*((_OWORD *)v16 - 1);\n          v27.m128d_f64[0] = *(v16 - 3);\n          v28 = _mm_sub_pd(v25, v26);\n          v29 = _mm_add_pd(_mm_mul_pd(v27, v39), _mm_mul_pd(_mm_mul_pd(v22, v38), v37));\n          v30 = (__m128d)*((_OWORD *)v15 - 1);\n          v30.m128d_f64[0] = *(v15 - 3);\n          v31 = _mm_sub_pd(v30, v29);\n          *((__m128d *)v15 - 2) = _mm_unpacklo_pd(v28, v31);\n          *((__m128d *)v15 - 1) = _mm_unpackhi_pd(v28, v31);\n          *((__m128d *)v16 - 2) = _mm_unpacklo_pd(v26, v29);\n          *((__m128d *)v16 - 1) = _mm_unpackhi_pd(v26, v29);\n        }\n        while ( v17 != 20 );\n        ++v40;\n      }\n      while ( v40 != 20 );\n      ++iteration_count;\n      memset(delta_weights_layer0_1, 0, 0x140uLL);\n      memset(delta_weights_layer1_2, 0, sizeof(delta_weights_layer1_2));\n      libmin_printf(\"iteration %d Total error %f\\n\", iteration_count, total_error);\n    }\n    while ( total_error > eta && iteration_count != 10 );\n  }\n  return 0LL;\n}\n"}, "pseudo_normalize": "long long train(double a1, double eta, double error_threshold, double bias,\n                double alpha) {\n  double *v6;\n  double v7;\n  double *v8;\n  long long v9;\n  unsigned long long v10;\n  double v11;\n  double v12;\n  double v13;\n  __m128d v14;\n  double *v15;\n  double *v16;\n  long long v17;\n  __m128d v18;\n  double v19;\n  __m128d v20;\n  __m128d v21;\n  __m128d v22;\n  __m128d v23;\n  __m128d v24;\n  __m128d v25;\n  __m128d v26;\n  __m128d v27;\n  __m128d v28;\n  __m128d v29;\n  __m128d v30;\n  __m128d v31;\n  double NN_output;\n  double v34;\n  double x;\n  double v36;\n  __m128d v37;\n  __m128d v38;\n  __m128d v39;\n  long long v40;\n  double total_error;\n  unsigned int iteration_count;\n  double input[20];\n  double output[20];\n  double weights_layer1_2[20];\n  double delta_weights_layer1_2[20];\n  double g_layer_1[20];\n  double g_deriv_layer_1[20];\n  double weights_layer0_1[40];\n  double delta_weights_layer0_1[49];\n  v6 = weights_layer0_1;\n  v7 = eta + 1.0;\n  *(uint64_t *)&delta_weights_layer0_1[41] = __readfsqword(40u);\n  do *v6++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n  while (delta_weights_layer0_1 != v6);\n  v8 = weights_layer1_2;\n  do *v8++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n  while (v8 != delta_weights_layer1_2);\n  v9 = 0LL;\n  memset(delta_weights_layer0_1, 0, 320uLL);\n  memset(delta_weights_layer1_2, 0, sizeof(delta_weights_layer1_2));\n  do {\n    input[v9] = (double)(int)v9 * 0.157 + 0.0;\n    output[v9++] = libmin_sin(v7);\n  } while (v9 != 20);\n  if (v7 > eta) {\n    iteration_count = 0;\n    v37 = _mm_unpacklo_pd((__m128d) * (unsigned long long *)&a1,\n                          (__m128d) * (unsigned long long *)&a1);\n    v39 = _mm_unpacklo_pd((__m128d) * (unsigned long long *)&bias,\n                          (__m128d) * (unsigned long long *)&bias);\n    v38 = _mm_unpacklo_pd((__m128d) * (unsigned long long *)&error_threshold,\n                          (__m128d) * (unsigned long long *)&error_threshold);\n    do {\n      v40 = 0LL;\n      total_error = 0.0;\n      do {\n        NN_output = 0.0;\n        v10 = 0LL;\n        v36 = input[v40];\n        do {\n          x = -(v36 * weights_layer0_1[v10 / 4] +\n                error_threshold * weights_layer0_1[v10 / 4 + 1]);\n          v11 = libmin_exp(x);\n          g_layer_1[v10 / 8] = 1.0 / (v11 + 1.0);\n          v34 = 1.0 / (v11 + 1.0);\n          v12 = libmin_exp(x);\n          v13 = v34 * weights_layer1_2[v10 / 8] + NN_output;\n          NN_output = v13;\n          g_deriv_layer_1[v10 / 8] =\n              (1.0 - 1.0 / (v12 + 1.0)) * (1.0 / (v12 + 1.0));\n          v10 += 8LL;\n        } while (v10 != 160);\n        v14.m128d_f64[1] = 0.0;\n        v15 = weights_layer0_1;\n        v16 = delta_weights_layer0_1;\n        v14.m128d_f64[0] = v13 - output[v40];\n        v17 = 0LL;\n        v18 = _mm_unpacklo_pd((__m128d) * (unsigned long long *)&v36,\n                              (__m128d) * (unsigned long long *)&v36);\n        v19 = v14.m128d_f64[0] * v14.m128d_f64[0];\n        v20 = _mm_unpacklo_pd(v14, v14);\n        total_error = v19 + total_error;\n        do {\n          v21 = *(__m128d *)&weights_layer1_2[v17];\n          v15 += 4;\n          v16 += 4;\n          v22 = _mm_mul_pd(_mm_mul_pd(*(__m128d *)&g_deriv_layer_1[v17], v21),\n                           v20);\n          v23 = _mm_add_pd(\n              _mm_mul_pd(_mm_mul_pd(*(__m128d *)&g_layer_1[v17], v20), v37),\n              _mm_mul_pd(*(__m128d *)&delta_weights_layer1_2[v17], v39));\n          *(__m128d *)&delta_weights_layer1_2[v17] = v23;\n          *(__m128d *)&weights_layer1_2[v17] = _mm_sub_pd(v21, v23);\n          v24 = (__m128d) * ((long double *)v16 - 2);\n          v25 = (__m128d) * ((long double *)v15 - 2);\n          v17 += 2LL;\n          v24.m128d_f64[1] = *(v16 - 2);\n          v25.m128d_f64[1] = *(v15 - 2);\n          v26 = _mm_add_pd(_mm_mul_pd(v24, v39),\n                           _mm_mul_pd(_mm_mul_pd(v18, v22), v37));\n          v27 = (__m128d) * ((long double *)v16 - 1);\n          v27.m128d_f64[0] = *(v16 - 3);\n          v28 = _mm_sub_pd(v25, v26);\n          v29 = _mm_add_pd(_mm_mul_pd(v27, v39),\n                           _mm_mul_pd(_mm_mul_pd(v22, v38), v37));\n          v30 = (__m128d) * ((long double *)v15 - 1);\n          v30.m128d_f64[0] = *(v15 - 3);\n          v31 = _mm_sub_pd(v30, v29);\n          *((__m128d *)v15 - 2) = _mm_unpacklo_pd(v28, v31);\n          *((__m128d *)v15 - 1) = _mm_unpackhi_pd(v28, v31);\n          *((__m128d *)v16 - 2) = _mm_unpacklo_pd(v26, v29);\n          *((__m128d *)v16 - 1) = _mm_unpackhi_pd(v26, v29);\n        } while (v17 != 20);\n        ++v40;\n      } while (v40 != 20);\n      ++iteration_count;\n      memset(delta_weights_layer0_1, 0, 320uLL);\n      memset(delta_weights_layer1_2, 0, sizeof(delta_weights_layer1_2));\n      libmin_printf(\"iteration %d Total error %f\\n\", iteration_count,\n                    total_error);\n    } while (total_error > eta && iteration_count != 10);\n  }\n  return 0LL;\n}", "binary": "tiny-NN/tiny-NN.host.O3", "assembly": "<train>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmovq   %xmm0,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x6e8,%rsp\nmovsd  %xmm2,0x50(%rsp)\nmovsd  0x5c38(%rip),%xmm2\nlea    0x590(%rsp),%r12\nlea    0x450(%rsp),%r15\nmovsd  %xmm1,0x88(%rsp)\nmov    %r15,%rbp\naddsd  %xmm2,%xmm1\nmovsd  %xmm3,(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x6d8(%rsp)\nxor    %eax,%eax\nmov    %r12,0x68(%rsp)\nmovq   %xmm1,%rbx\ncall   3d80 <libmin_rand>\npxor   %xmm0,%xmm0\nadd    $0x8,%rbp\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x5be2(%rip),%xmm0\nsubsd  0x5be2(%rip),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\ncmp    %rbp,%r12\njne    144a <train+0x6a>\nlea    0x1d0(%rsp),%r14\nlea    0x270(%rsp),%r12\nmov    %r14,%rbp\ncall   3d80 <libmin_rand>\npxor   %xmm0,%xmm0\nadd    $0x8,%rbp\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x5ba1(%rip),%xmm0\nsubsd  0x5ba1(%rip),%xmm0\nmovsd  %xmm0,-0x8(%rbp)\ncmp    %r12,%rbp\njne    148b <train+0xab>\nmov    0x68(%rsp),%rdi\nxor    %eax,%eax\nmov    $0x28,%ecx\nxor    %ebp,%ebp\nmov    %rbx,0x8(%rsp)\nmov    %rbp,%rbx\nrep stos %rax,%es:(%rdi)\nmov    $0x14,%ecx\nmov    %r12,%rdi\nrep stos %rax,%es:(%rdi)\nlea    0x90(%rsp),%rax\nmov    %rax,0x70(%rsp)\nlea    0x130(%rsp),%rax\nmov    %rax,0x78(%rsp)\npxor   %xmm0,%xmm0\npxor   %xmm5,%xmm5\nmov    0x70(%rsp),%rax\ncvtsi2sd %ebx,%xmm0\nmulsd  0x5b48(%rip),%xmm0\naddsd  %xmm5,%xmm0\nmovsd  %xmm0,(%rax,%rbx,8)\ncall   4550 <libmin_sin>\nmov    0x78(%rsp),%rax\nmovsd  %xmm0,(%rax,%rbx,8)\nadd    $0x1,%rbx\ncmp    $0x14,%rbx\njne    14f7 <train+0x117>\nmov    0x8(%rsp),%rbx\nmovq   %rbx,%xmm5\ncomisd 0x88(%rsp),%xmm5\njbe    1829 <train+0x449>\nmovq   %r13,%xmm5\nlea    0x310(%rsp),%rbp\nmovl   $0x0,0x84(%rsp)\nlea    0x3b0(%rsp),%rbx\nunpcklpd %xmm5,%xmm5\nmovaps %xmm5,0x20(%rsp)\nmovsd  (%rsp),%xmm5\nunpcklpd %xmm5,%xmm5\nmovaps %xmm5,0x40(%rsp)\nmovsd  0x50(%rsp),%xmm5\nunpcklpd %xmm5,%xmm5\nmovaps %xmm5,0x30(%rsp)\nmovq   $0x0,0x58(%rsp)\nmovq   $0x0,0x60(%rsp)\nnopl   0x0(%rax,%rax,1)\nmov    0x70(%rsp),%rax\nmov    0x58(%rsp),%rdi\nmovq   $0x0,(%rsp)\nxor    %r13d,%r13d\nmovsd  (%rax,%rdi,1),%xmm5\nmovsd  %xmm5,0x18(%rsp)\nnopl   0x0(%rax,%rax,1)\nmovsd  0x18(%rsp),%xmm1\nmovsd  0x50(%rsp),%xmm0\nmulsd  (%r15,%r13,2),%xmm1\nmulsd  0x8(%r15,%r13,2),%xmm0\naddsd  %xmm0,%xmm1\nxorpd  0x5a3b(%rip),%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm1,0x10(%rsp)\ncall   1a40 <libmin_exp>\nmov    0x5a35(%rip),%rax\nmovsd  0x10(%rsp),%xmm1\nmovq   %rax,%xmm2\nmovq   %rax,%xmm3\naddsd  %xmm2,%xmm0\ndivsd  %xmm0,%xmm3\nmovapd %xmm1,%xmm0\nmovsd  %xmm3,0x0(%rbp,%r13,1)\nmovsd  %xmm3,0x8(%rsp)\ncall   1a40 <libmin_exp>\nmov    0x5a00(%rip),%rax\nmovsd  0x8(%rsp),%xmm3\nmulsd  (%r14,%r13,1),%xmm3\nmovq   %rax,%xmm2\nmovq   %rax,%xmm1\naddsd  (%rsp),%xmm3\naddsd  %xmm2,%xmm0\nmovsd  %xmm3,(%rsp)\ndivsd  %xmm0,%xmm1\nmovq   %rax,%xmm0\nsubsd  %xmm1,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rbx,%r13,1)\nadd    $0x8,%r13\ncmp    $0xa0,%r13\njne    15d0 <train+0x1f0>\nmov    0x78(%rsp),%rax\nmov    0x58(%rsp),%rsi\nmovapd %xmm3,%xmm5\nmov    %r15,%rdx\nmovsd  0x18(%rsp),%xmm6\nmov    0x68(%rsp),%rcx\nsubsd  (%rax,%rsi,1),%xmm5\nxor    %eax,%eax\nunpcklpd %xmm6,%xmm6\nmovapd %xmm5,%xmm0\nmulsd  %xmm5,%xmm0\nunpcklpd %xmm5,%xmm5\naddsd  0x60(%rsp),%xmm0\nmovsd  %xmm0,0x60(%rsp)\nnopl   0x0(%rax,%rax,1)\nmovapd 0x0(%rbp,%rax,1),%xmm0\nmovapd (%r14,%rax,1),%xmm1\nadd    $0x20,%rdx\nadd    $0x20,%rcx\nmovapd (%rbx,%rax,1),%xmm3\nmovapd (%r12,%rax,1),%xmm4\nmulpd  %xmm5,%xmm0\nmovapd 0x40(%rsp),%xmm7\nmovapd 0x20(%rsp),%xmm8\nmulpd  %xmm1,%xmm3\nmulpd  %xmm7,%xmm4\nmulpd  %xmm8,%xmm0\nmulpd  %xmm5,%xmm3\naddpd  %xmm4,%xmm0\nmovaps %xmm0,(%r12,%rax,1)\nsubpd  %xmm0,%xmm1\nmovapd %xmm6,%xmm0\nmulpd  %xmm3,%xmm0\nmulpd  0x30(%rsp),%xmm3\nmovaps %xmm1,(%r14,%rax,1)\nmovapd -0x20(%rcx),%xmm1\nmovapd -0x20(%rdx),%xmm4\nadd    $0x10,%rax\nmovhpd -0x10(%rcx),%xmm1\nmovhpd -0x10(%rdx),%xmm4\nmulpd  %xmm7,%xmm1\nmulpd  %xmm8,%xmm0\nmulpd  %xmm8,%xmm3\naddpd  %xmm0,%xmm1\nmovapd -0x10(%rcx),%xmm0\nmovlpd -0x18(%rcx),%xmm0\nmulpd  %xmm7,%xmm0\nsubpd  %xmm1,%xmm4\nmovapd %xmm4,%xmm7\naddpd  %xmm3,%xmm0\nmovapd -0x10(%rdx),%xmm3\nmovlpd -0x18(%rdx),%xmm3\nsubpd  %xmm0,%xmm3\nunpcklpd %xmm3,%xmm7\nunpckhpd %xmm3,%xmm4\nmovapd %xmm1,%xmm3\nunpcklpd %xmm0,%xmm3\nunpckhpd %xmm0,%xmm1\nmovaps %xmm7,-0x20(%rdx)\nmovaps %xmm4,-0x10(%rdx)\nmovaps %xmm3,-0x20(%rcx)\nmovaps %xmm1,-0x10(%rcx)\ncmp    $0xa0,%rax\njne    16d0 <train+0x2f0>\naddq   $0x8,0x58(%rsp)\nmov    0x58(%rsp),%rax\ncmp    $0xa0,%rax\njne    15a8 <train+0x1c8>\nmov    0x68(%rsp),%rdi\nxor    %eax,%eax\nmov    $0x28,%ecx\naddl   $0x1,0x84(%rsp)\nmov    0x84(%rsp),%r13d\nmovsd  0x60(%rsp),%xmm0\nrep stos %rax,%es:(%rdi)\nmov    $0x14,%ecx\nmov    %r12,%rdi\nrep stos %rax,%es:(%rdi)\nmov    %r13d,%esi\nlea    0x5800(%rip),%rdi\nmov    $0x1,%eax\ncall   3b10 <libmin_printf>\nmovsd  0x60(%rsp),%xmm5\ncomisd 0x88(%rsp),%xmm5\njbe    1829 <train+0x449>\ncmp    $0xa,%r13d\njne    1591 <train+0x1b1>\nmov    0x6d8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1850 <train+0x470>\nadd    $0x6e8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "addEdge", "content": " \n  \n// Function to add an edge to the graph \nvoid\naddEdge(struct Graph* graph, int v, int w) \n{ \n  struct List* newNode = createListNode(w); \n  newNode->next = graph->adj[v].next; \n  graph->adj[v].next = newNode; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O3.pseudo", "function_name": "addEdge", "address": "0x13f0", "label": "addEdge", "content": "void __fastcall addEdge(Graph *graph, int v, int w)\n{\n  List *v4; // rax\n  List *v5; // rsi\n  List *next; // rdx\n\n  v4 = (List *)libmin_malloc(0x10uLL);\n  v5 = &graph->adj[v];\n  v4->next = 0LL;\n  next = v5->next;\n  v4->data = w;\n  v4->next = next;\n  v5->next = v4;\n}\n"}, "pseudo_normalize": "void addEdge(Graph *graph, int v, int w) {\n  List *v4;\n  List *v5;\n  List *next;\n  v4 = (List *)libmin_malloc(16uLL);\n  v5 = &graph->adj[v];\n  v4->next = 0LL;\n  next = v5->next;\n  v4->data = w;\n  v4->next = next;\n  v5->next = v4;\n}", "binary": "topo-sort/topo-sort.host.O3", "assembly": "<addEdge>:\nendbr64\npush   %r12\nmov    %edx,%r12d\npush   %rbp\nmov    %rdi,%rbp\nmov    $0x10,%edi\npush   %rbx\nmov    %esi,%ebx\ncall   1c10 <libmin_malloc>\nmovslq %ebx,%rsi\nshl    $0x4,%rsi\nadd    0x8(%rbp),%rsi\nmovq   $0x0,0x8(%rax)\nmov    0x8(%rsi),%rdx\nmov    %r12d,(%rax)\nmov    %rdx,0x8(%rax)\nmov    %rax,0x8(%rsi)\npop    %rbx\npop    %rbp\npop    %r12\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "createGraph", "content": " \n  \n// Function to initialize a graph with V vertices \nstruct Graph *\ncreateGraph(int V) \n{ \n  struct Graph* graph = (struct Graph*)libmin_malloc(sizeof(struct Graph)); \n  graph->V = V; \n  graph->adj = (struct List*)libmin_malloc(V * sizeof(struct List)); \n  for (int i = 0; i < V; ++i)\n    graph->adj[i].next = NULL; \n  return graph; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O3.pseudo", "function_name": "createGraph", "address": "0x1380", "label": "createGraph", "content": "Graph *__fastcall createGraph(int V)\n{\n  Graph *v1; // rax\n  Graph *v2; // r12\n  List *v3; // rax\n  List **p_next; // rdx\n  __int64 v5; // rax\n\n  v1 = (Graph *)libmin_malloc(0x10uLL);\n  v1->V = V;\n  v2 = v1;\n  v3 = (List *)libmin_malloc(16LL * V);\n  v2->adj = v3;\n  if ( V > 0 )\n  {\n    p_next = &v3->next;\n    v5 = (__int64)&v3[(unsigned int)(V - 1) + 1].next;\n    do\n    {\n      *p_next = 0LL;\n      p_next += 2;\n    }\n    while ( p_next != (List **)v5 );\n  }\n  return v2;\n}\n"}, "pseudo_normalize": "Graph *createGraph(int V) {\n  Graph *v1;\n  Graph *v2;\n  List *v3;\n  List **p_next;\n  long long v5;\n  v1 = (Graph *)libmin_malloc(16uLL);\n  v1->V = V;\n  v2 = v1;\n  v3 = (List *)libmin_malloc(16LL * V);\n  v2->adj = v3;\n  if (V > 0) {\n    p_next = &v3->next;\n    v5 = (long long)&v3[(unsigned int)(V - 1) + 1].next;\n    do {\n      *p_next = 0LL;\n      p_next += 2;\n    } while (p_next != (List **)v5);\n  }\n  return v2;\n}", "binary": "topo-sort/topo-sort.host.O3", "assembly": "<createGraph>:\nendbr64\npush   %r12\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\nsub    $0x8,%rsp\ncall   1c10 <libmin_malloc>\nmovslq %ebx,%rdi\nmov    %ebx,(%rax)\nshl    $0x4,%rdi\nmov    %rax,%r12\ncall   1c10 <libmin_malloc>\nmov    %rax,0x8(%r12)\ntest   %ebx,%ebx\njle    13d8 <createGraph+0x58>\nlea    -0x1(%rbx),%ecx\nlea    0x8(%rax),%rdx\nshl    $0x4,%rcx\nlea    0x18(%rax,%rcx,1),%rax\nnopl   0x0(%rax)\nmovq   $0x0,(%rdx)\nadd    $0x10,%rdx\ncmp    %rax,%rdx\njne    13c8 <createGraph+0x48>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %r12\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "createListNode", "content": " \n  \n// Create a new node for the adjacency list \nstruct List *\ncreateListNode(int data) \n{ \n  struct List* newNode = (struct List*)libmin_malloc(sizeof(struct List)); \n  newNode->data = data; \n  newNode->next = NULL; \n  return newNode; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O3.pseudo", "function_name": "createListNode", "address": "0x1360", "label": "createListNode", "content": "List *__fastcall createListNode(int data)\n{\n  List *result; // rax\n\n  result = (List *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "List *createListNode(int data) {\n  List *result;\n  result = (List *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}", "binary": "topo-sort/topo-sort.host.O3", "assembly": "<createListNode>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\ncall   1c10 <libmin_malloc>\nmov    %ebx,(%rax)\nmovq   $0x0,0x8(%rax)\npop    %rbx\nret\nnopl   (%rax)\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "createStackNode", "content": " \n  \n// Create a new node for the stack \nstruct Stack *\ncreateStackNode(int data) \n{ \n  struct Stack* newNode = (struct Stack*)libmin_malloc(sizeof(struct Stack)); \n  newNode->data = data; \n  newNode->next = NULL; \n  return newNode; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O3.pseudo", "function_name": "createStackNode", "address": "0x1340", "label": "createStackNode", "content": "Stack *__fastcall createStackNode(int data)\n{\n  Stack *result; // rax\n\n  result = (Stack *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "Stack *createStackNode(int data) {\n  Stack *result;\n  result = (Stack *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}", "binary": "topo-sort/topo-sort.host.O3", "assembly": "<createStackNode>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\ncall   1c10 <libmin_malloc>\nmov    %ebx,(%rax)\nmovq   $0x0,0x8(%rax)\npop    %rbx\nret\nnopl   (%rax)\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "main", "content": " \n  \n// Driver program to test above functions \nint\nmain(void) \n{ \n  // Create a graph given in the above diagram \n  struct Graph* g = createGraph(6); \n  addEdge(g, 5, 2); \n  addEdge(g, 5, 0); \n  addEdge(g, 4, 0); \n  addEdge(g, 4, 1); \n  addEdge(g, 2, 3); \n  addEdge(g, 3, 1); \n  \n  libmin_printf(\"Topological Sorting Order: \"); \n  topologicalSort(g); \n  libmin_printf(\"\\n\");\n  \n  libmin_success();\n  return 0; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Graph *Graph; // rbp\n  List *v4; // rax\n  List *adj; // rdx\n  List *next; // rcx\n  List *v7; // rax\n  List *v8; // rdx\n  List *v9; // rcx\n  List *v10; // rax\n  List *v11; // rdx\n  List *v12; // rcx\n  List *v13; // rax\n  List *v14; // rdx\n  List *v15; // rcx\n  List *v16; // rax\n  List *v17; // rdx\n  List *v18; // rcx\n  List *v19; // rax\n  List *v20; // rdx\n  List *v21; // rcx\n\n  Graph = createGraph(6);\n  v4 = (List *)libmin_malloc(0x10uLL);\n  adj = Graph->adj;\n  v4->next = 0LL;\n  next = adj[5].next;\n  v4->data = 2;\n  v4->next = next;\n  adj[5].next = v4;\n  v7 = (List *)libmin_malloc(0x10uLL);\n  v8 = Graph->adj;\n  v7->next = 0LL;\n  v9 = v8[5].next;\n  v7->data = 0;\n  v7->next = v9;\n  v8[5].next = v7;\n  v10 = (List *)libmin_malloc(0x10uLL);\n  v11 = Graph->adj;\n  v10->next = 0LL;\n  v12 = v11[4].next;\n  v10->data = 0;\n  v10->next = v12;\n  v11[4].next = v10;\n  v13 = (List *)libmin_malloc(0x10uLL);\n  v14 = Graph->adj;\n  v13->next = 0LL;\n  v15 = v14[4].next;\n  v13->data = 1;\n  v13->next = v15;\n  v14[4].next = v13;\n  v16 = (List *)libmin_malloc(0x10uLL);\n  v17 = Graph->adj;\n  v16->next = 0LL;\n  v18 = v17[2].next;\n  v16->data = 3;\n  v16->next = v18;\n  v17[2].next = v16;\n  v19 = (List *)libmin_malloc(0x10uLL);\n  v20 = Graph->adj;\n  v19->next = 0LL;\n  v21 = v20[3].next;\n  v19->data = 1;\n  v19->next = v21;\n  v20[3].next = v19;\n  libmin_printf(\"Topological Sorting Order: \", argv);\n  topologicalSort(Graph);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  Graph *Graph;\n  List *v4;\n  List *adj;\n  List *next;\n  List *v7;\n  List *v8;\n  List *v9;\n  List *v10;\n  List *v11;\n  List *v12;\n  List *v13;\n  List *v14;\n  List *v15;\n  List *v16;\n  List *v17;\n  List *v18;\n  List *v19;\n  List *v20;\n  List *v21;\n  Graph = createGraph(6);\n  v4 = (List *)libmin_malloc(16uLL);\n  adj = Graph->adj;\n  v4->next = 0LL;\n  next = adj[5].next;\n  v4->data = 2;\n  v4->next = next;\n  adj[5].next = v4;\n  v7 = (List *)libmin_malloc(16uLL);\n  v8 = Graph->adj;\n  v7->next = 0LL;\n  v9 = v8[5].next;\n  v7->data = 0;\n  v7->next = v9;\n  v8[5].next = v7;\n  v10 = (List *)libmin_malloc(16uLL);\n  v11 = Graph->adj;\n  v10->next = 0LL;\n  v12 = v11[4].next;\n  v10->data = 0;\n  v10->next = v12;\n  v11[4].next = v10;\n  v13 = (List *)libmin_malloc(16uLL);\n  v14 = Graph->adj;\n  v13->next = 0LL;\n  v15 = v14[4].next;\n  v13->data = 1;\n  v13->next = v15;\n  v14[4].next = v13;\n  v16 = (List *)libmin_malloc(16uLL);\n  v17 = Graph->adj;\n  v16->next = 0LL;\n  v18 = v17[2].next;\n  v16->data = 3;\n  v16->next = v18;\n  v17[2].next = v16;\n  v19 = (List *)libmin_malloc(16uLL);\n  v20 = Graph->adj;\n  v19->next = 0LL;\n  v21 = v20[3].next;\n  v19->data = 1;\n  v19->next = v21;\n  v20[3].next = v19;\n  libmin_printf(\"Topological Sorting Order: \", argv);\n  topologicalSort(Graph);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}", "binary": "topo-sort/topo-sort.host.O3", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    $0x6,%edi\ncall   1380 <createGraph>\nmov    $0x10,%edi\nmov    %rax,%rbp\ncall   1c10 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x58(%rdx),%rcx\nmovl   $0x2,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x58(%rdx)\ncall   1c10 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x58(%rdx),%rcx\nmovl   $0x0,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x58(%rdx)\ncall   1c10 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x48(%rdx),%rcx\nmovl   $0x0,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x48(%rdx)\ncall   1c10 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x48(%rdx),%rcx\nmovl   $0x1,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x48(%rdx)\ncall   1c10 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nmov    0x28(%rdx),%rcx\nmovl   $0x3,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x28(%rdx)\ncall   1c10 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nlea    0x3df9(%rip),%rdi\nmovq   $0x0,0x8(%rax)\nmov    0x38(%rdx),%rcx\nmovl   $0x1,(%rax)\nmov    %rcx,0x8(%rax)\nmov    %rax,0x38(%rdx)\nxor    %eax,%eax\ncall   3f50 <libmin_printf>\nmov    %rbp,%rdi\ncall   18b0 <topologicalSort>\nlea    0x3de5(%rip),%rdi\nxor    %eax,%eax\ncall   3f50 <libmin_printf>\ncall   4190 <libmin_success>\nxor    %eax,%eax\npop    %rbp\nret\nnop\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "topologicalSort", "content": " \n  \n// The function to do Topological Sort. It uses recursive \n// topologicalSortUtil \nvoid topologicalSort(struct Graph* graph) \n{ \n    struct Stack* stack = NULL; \n  \n    // Mark all the vertices as not visited \n    int* visited = (int*)libmin_malloc(graph->V * sizeof(int)); \n    for (int i = 0; i < graph->V; ++i) { \n        visited[i] = FALSE; \n    } \n  \n    // Call the recursive helper function to store \n    // Topological Sort starting from all vertices one by \n    // one \n    for (int i = 0; i < graph->V; ++i) { \n        if (!visited[i]) { \n            topologicalSortUtil(graph, i, visited, &stack); \n        } \n    } \n  \n    // Print contents of stack \n    while (stack != NULL) { \n        libmin_printf(\"%d \", stack->data); \n        struct Stack* temp = stack; \n        stack = stack->next; \n        libmin_free(temp); \n    } \n  \n    // Free allocated memory \n    libmin_free(visited); \n    libmin_free(graph->adj); \n    libmin_free(graph); \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O3.pseudo", "function_name": "topologicalSort", "address": "0x18b0", "label": "topologicalSort", "content": "void __fastcall topologicalSort(Graph *graph)\n{\n  __int64 V; // rdi\n  int *v3; // r12\n  __int64 v4; // rax\n  int v5; // edx\n  __int64 v6; // rbx\n  int v7; // r14d\n  List *i; // rbp\n  __int64 data; // rsi\n  Stack *v10; // rax\n  Stack *v11; // rdx\n  Stack *j; // rax\n  Stack *v13; // rdi\n  Stack *stack[9]; // [rsp+0h] [rbp-48h] BYREF\n\n  V = graph->V;\n  stack[1] = (Stack *)__readfsqword(0x28u);\n  stack[0] = 0LL;\n  v3 = (int *)libmin_malloc(4 * V);\n  v4 = 0LL;\n  if ( graph->V > 0 )\n  {\n    do\n    {\n      v3[v4] = 0;\n      v5 = graph->V;\n      ++v4;\n    }\n    while ( graph->V > (int)v4 );\n    if ( v5 > 0 )\n    {\n      v6 = 0LL;\n      do\n      {\n        while ( 1 )\n        {\n          v7 = v6;\n          if ( !v3[v6] )\n            break;\n          if ( v5 <= (int)++v6 )\n            goto LABEL_11;\n        }\n        v3[v6] = 1;\n        for ( i = graph->adj[v6].next; i; i = i->next )\n        {\n          while ( 1 )\n          {\n            data = i->data;\n            if ( !v3[data] )\n              break;\n            i = i->next;\n            if ( !i )\n              goto LABEL_10;\n          }\n          topologicalSortUtil(graph, data, v3, stack);\n        }\nLABEL_10:\n        ++v6;\n        v10 = (Stack *)libmin_malloc(0x10uLL);\n        v11 = stack[0];\n        v10->data = v7;\n        v10->next = v11;\n        v5 = graph->V;\n        stack[0] = v10;\n      }\n      while ( v5 > (int)v6 );\n    }\n  }\nLABEL_11:\n  for ( j = stack[0]; stack[0]; j = stack[0] )\n  {\n    libmin_printf(\"%d \", j->data);\n    v13 = stack[0];\n    stack[0] = stack[0]->next;\n    libmin_free(v13);\n  }\n  libmin_free(v3);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}\n"}, "pseudo_normalize": "void topologicalSort(Graph *graph) {\n  long long V;\n  int *v3;\n  long long v4;\n  int v5;\n  long long v6;\n  int v7;\n  List *i;\n  long long data;\n  Stack *v10;\n  Stack *v11;\n  Stack *j;\n  Stack *v13;\n  Stack *stack[9];\n  V = graph->V;\n  stack[1] = (Stack *)__readfsqword(40u);\n  stack[0] = 0LL;\n  v3 = (int *)libmin_malloc(4 * V);\n  v4 = 0LL;\n  if (graph->V > 0) {\n    do {\n      v3[v4] = 0;\n      v5 = graph->V;\n      ++v4;\n    } while (graph->V > (int)v4);\n    if (v5 > 0) {\n      v6 = 0LL;\n      do {\n        while (1) {\n          v7 = v6;\n          if (!v3[v6]) break;\n          if (v5 <= (int)++v6) goto LABEL_11;\n        }\n        v3[v6] = 1;\n        for (i = graph->adj[v6].next; i; i = i->next) {\n          while (1) {\n            data = i->data;\n            if (!v3[data]) break;\n            i = i->next;\n            if (!i) goto LABEL_10;\n          }\n          topologicalSortUtil(graph, data, v3, stack);\n        }\n      LABEL_10:\n        ++v6;\n        v10 = (Stack *)libmin_malloc(16uLL);\n        v11 = stack[0];\n        v10->data = v7;\n        v10->next = v11;\n        v5 = graph->V;\n        stack[0] = v10;\n      } while (v5 > (int)v6);\n    }\n  }\nLABEL_11:\n  for (j = stack[0]; stack[0]; j = stack[0]) {\n    libmin_printf(\"%d \", j->data);\n    v13 = stack[0];\n    stack[0] = stack[0]->next;\n    libmin_free(v13);\n  }\n  libmin_free(v3);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}", "binary": "topo-sort/topo-sort.host.O3", "assembly": "<topologicalSort>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rdi,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmovslq (%rdi),%rdi\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmovq   $0x0,(%rsp)\nshl    $0x2,%rdi\ncall   1c10 <libmin_malloc>\nmov    0x0(%r13),%esi\nmov    %rax,%r12\nxor    %eax,%eax\ntest   %esi,%esi\njle    1990 <topologicalSort+0xe0>\nnopw   0x0(%rax,%rax,1)\nmovl   $0x0,(%r12,%rax,4)\nmov    0x0(%r13),%edx\nadd    $0x1,%rax\ncmp    %eax,%edx\njg     1900 <topologicalSort+0x50>\ntest   %edx,%edx\njle    1990 <topologicalSort+0xe0>\nxor    %ebx,%ebx\nmov    %rsp,%r15\njmp    1928 <topologicalSort+0x78>\nnop\nadd    $0x1,%rbx\ncmp    %ebx,%edx\njle    1990 <topologicalSort+0xe0>\nmov    (%r12,%rbx,4),%ecx\nmov    %ebx,%r14d\ntest   %ecx,%ecx\njne    1920 <topologicalSort+0x70>\nmov    %rbx,%rax\nmovl   $0x1,(%r12,%rbx,4)\nshl    $0x4,%rax\nadd    0x8(%r13),%rax\nmov    0x8(%rax),%rbp\ntest   %rbp,%rbp\nje     196b <topologicalSort+0xbb>\nmovslq 0x0(%rbp),%rax\nmov    %rax,%rsi\nmov    (%r12,%rax,4),%eax\ntest   %eax,%eax\nje     1a00 <topologicalSort+0x150>\nmov    0x8(%rbp),%rbp\ntest   %rbp,%rbp\njne    194f <topologicalSort+0x9f>\nmov    $0x10,%edi\nadd    $0x1,%rbx\ncall   1c10 <libmin_malloc>\nmov    (%rsp),%rdx\nmov    %r14d,(%rax)\nmov    %rdx,0x8(%rax)\nmov    0x0(%r13),%edx\nmov    %rax,(%rsp)\ncmp    %ebx,%edx\njg     1928 <topologicalSort+0x78>\nmov    (%rsp),%rax\nlea    0x3669(%rip),%rbx\ntest   %rax,%rax\nje     19c6 <topologicalSort+0x116>\nmov    (%rax),%esi\nmov    %rbx,%rdi\nxor    %eax,%eax\ncall   3f50 <libmin_printf>\nmov    (%rsp),%rdi\nmov    0x8(%rdi),%rax\nmov    %rax,(%rsp)\ncall   1cc0 <libmin_free>\nmov    (%rsp),%rax\ntest   %rax,%rax\njne    19a0 <topologicalSort+0xf0>\nmov    %r12,%rdi\ncall   1cc0 <libmin_free>\nmov    0x8(%r13),%rdi\ncall   1cc0 <libmin_free>\nmov    %r13,%rdi\ncall   1cc0 <libmin_free>\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1a20 <topologicalSort+0x170>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxchg   %ax,%ax\nmov    %r15,%rcx\nmov    %r12,%rdx\nmov    %r13,%rdi\ncall   1440 <topologicalSortUtil>\nmov    0x8(%rbp),%rbp\ntest   %rbp,%rbp\njne    194f <topologicalSort+0x9f>\njmp    196b <topologicalSort+0xbb>\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "topologicalSortUtil", "content": " \n  \n// A recursive function used by topologicalSort \nvoid\ntopologicalSortUtil(struct Graph* graph, int v, int visited[], struct Stack** stack) \n{ \n  visited[v] = TRUE; \n  \n  struct List* current = graph->adj[v].next; \n  while (current != NULL)\n  { \n    int adjacentVertex = current->data; \n    if (!visited[adjacentVertex]) \n      topologicalSortUtil(graph, adjacentVertex, visited, stack); \n    current = current->next; \n  } \n  \n  // Push the current vertex to stack which stores the \n  // result \n  struct Stack* newNode = createStackNode(v); \n  newNode->next = *stack; \n  *stack = newNode; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O3.pseudo", "function_name": "topologicalSortUtil", "address": "0x1440", "label": "topologicalSortUtil", "content": "void __fastcall topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack)\n{\n  Stack **v4; // r15\n  int *v5; // r15\n  Stack **v6; // r14\n  __int64 data; // rax\n  int *v8; // rsi\n  Stack *v9; // rax\n  Stack *v10; // rdx\n  __int64 v11; // rax\n  int *v12; // rsi\n  Stack *v13; // rax\n  Stack *v14; // rsi\n  Stack **v15; // r13\n  __int64 v16; // rax\n  int *v17; // rdx\n  Stack *v18; // rax\n  Stack *v19; // rsi\n  List *v20; // rax\n  Stack **v21; // r14\n  __int64 v22; // rax\n  int *v23; // rdx\n  Stack *v24; // rax\n  Stack *v25; // rdx\n  List *v26; // r13\n  Stack **v27; // rax\n  List *v28; // r14\n  Stack **v29; // r13\n  __int64 v30; // rax\n  int *v31; // rdx\n  Stack *v32; // rax\n  Stack *v33; // rdx\n  int *v34; // r14\n  List *v35; // r15\n  __int64 v36; // rax\n  int *v37; // rsi\n  Stack *v38; // rax\n  Stack *v39; // rdx\n  Stack **v40; // r15\n  List *v41; // r13\n  __int64 v42; // rax\n  int *v43; // rdx\n  int v44; // r12d\n  Stack *v45; // rax\n  Stack *v46; // rsi\n  List *v47; // rbp\n  Stack **v48; // r12\n  int *v49; // r15\n  __int64 v50; // rax\n  int *v51; // rdx\n  int v52; // r14d\n  Stack *v53; // rax\n  Stack *v54; // rdx\n  List *j; // rbx\n  __int64 v56; // rsi\n  Stack *v57; // rax\n  Stack *v58; // rdx\n  List *v59; // [rsp+10h] [rbp-88h]\n  List *next; // [rsp+18h] [rbp-80h]\n  List *i; // [rsp+20h] [rbp-78h]\n  List *current; // [rsp+28h] [rbp-70h]\n  int v63; // [rsp+30h] [rbp-68h]\n  int v64; // [rsp+34h] [rbp-64h]\n  int v65; // [rsp+38h] [rbp-60h]\n  int v66; // [rsp+3Ch] [rbp-5Ch]\n  int v67; // [rsp+40h] [rbp-58h]\n  int adjacentVertex; // [rsp+44h] [rbp-54h]\n  List *v69; // [rsp+48h] [rbp-50h]\n  List *v70; // [rsp+50h] [rbp-48h]\n  int v71; // [rsp+58h] [rbp-40h]\n\n  v4 = stack;\n  visited[v] = 1;\n  current = graph->adj[v].next;\n  if ( current )\n  {\n    v5 = visited;\n    v6 = stack;\n    do\n    {\n      data = current->data;\n      v8 = &v5[data];\n      adjacentVertex = current->data;\n      if ( !*v8 )\n      {\n        *v8 = 1;\n        for ( i = graph->adj[data].next; i; i = i->next )\n        {\n          v11 = i->data;\n          v12 = &v5[v11];\n          v67 = i->data;\n          if ( !*v12 )\n          {\n            *v12 = 1;\n            next = graph->adj[v11].next;\n            if ( next )\n            {\n              v15 = v6;\n              do\n              {\n                v16 = next->data;\n                v17 = &v5[v16];\n                v66 = next->data;\n                if ( !*v17 )\n                {\n                  *v17 = 1;\n                  v20 = &graph->adj[v16];\n                  if ( v20->next )\n                  {\n                    v59 = v20->next;\n                    v21 = v15;\n                    do\n                    {\n                      v22 = v59->data;\n                      v23 = &v5[v22];\n                      v65 = v59->data;\n                      if ( !*v23 )\n                      {\n                        *v23 = 1;\n                        v26 = graph->adj[v22].next;\n                        if ( v26 )\n                        {\n                          v27 = v21;\n                          v28 = v26;\n                          v29 = v27;\n                          do\n                          {\n                            v30 = v28->data;\n                            v31 = &v5[v30];\n                            v64 = v28->data;\n                            if ( !*v31 )\n                            {\n                              *v31 = 1;\n                              if ( graph->adj[v30].next )\n                              {\n                                v70 = v28;\n                                v34 = v5;\n                                v35 = graph->adj[v30].next;\n                                do\n                                {\n                                  v36 = v35->data;\n                                  v37 = &v34[v36];\n                                  v63 = v35->data;\n                                  if ( !*v37 )\n                                  {\n                                    *v37 = 1;\n                                    if ( graph->adj[v36].next )\n                                    {\n                                      v69 = v35;\n                                      v40 = v29;\n                                      v41 = graph->adj[v36].next;\n                                      do\n                                      {\n                                        v42 = v41->data;\n                                        v43 = &v34[v42];\n                                        v44 = v41->data;\n                                        if ( !*v43 )\n                                        {\n                                          *v43 = 1;\n                                          v47 = graph->adj[v42].next;\n                                          if ( v47 )\n                                          {\n                                            v71 = v44;\n                                            v48 = v40;\n                                            v49 = v34;\n                                            do\n                                            {\n                                              v50 = v47->data;\n                                              v51 = &v49[v50];\n                                              v52 = v47->data;\n                                              if ( !*v51 )\n                                              {\n                                                *v51 = 1;\n                                                for ( j = graph->adj[v50].next; j; j = j->next )\n                                                {\n                                                  while ( 1 )\n                                                  {\n                                                    v56 = j->data;\n                                                    if ( !v49[v56] )\n                                                      break;\n                                                    j = j->next;\n                                                    if ( !j )\n                                                      goto LABEL_50;\n                                                  }\n                                                  topologicalSortUtil(graph, v56, v49, v48);\n                                                }\nLABEL_50:\n                                                v57 = (Stack *)libmin_malloc(0x10uLL);\n                                                v57->next = 0LL;\n                                                v58 = *v48;\n                                                v57->data = v52;\n                                                v57->next = v58;\n                                                *v48 = v57;\n                                              }\n                                              v47 = v47->next;\n                                            }\n                                            while ( v47 );\n                                            v34 = v49;\n                                            v40 = v48;\n                                            v44 = v71;\n                                          }\n                                          v53 = (Stack *)libmin_malloc(0x10uLL);\n                                          v53->next = 0LL;\n                                          v54 = *v40;\n                                          v53->data = v44;\n                                          v53->next = v54;\n                                          *v40 = v53;\n                                        }\n                                        v41 = v41->next;\n                                      }\n                                      while ( v41 );\n                                      v29 = v40;\n                                      v35 = v69;\n                                    }\n                                    v45 = (Stack *)libmin_malloc(0x10uLL);\n                                    v45->next = 0LL;\n                                    v46 = *v29;\n                                    v45->data = v63;\n                                    v45->next = v46;\n                                    *v29 = v45;\n                                  }\n                                  v35 = v35->next;\n                                }\n                                while ( v35 );\n                                v5 = v34;\n                                v28 = v70;\n                              }\n                              v38 = (Stack *)libmin_malloc(0x10uLL);\n                              v38->next = 0LL;\n                              v39 = *v29;\n                              v38->data = v64;\n                              v38->next = v39;\n                              *v29 = v38;\n                            }\n                            v28 = v28->next;\n                          }\n                          while ( v28 );\n                          v21 = v29;\n                        }\n                        v32 = (Stack *)libmin_malloc(0x10uLL);\n                        v32->next = 0LL;\n                        v33 = *v21;\n                        v32->data = v65;\n                        v32->next = v33;\n                        *v21 = v32;\n                      }\n                      v59 = v59->next;\n                    }\n                    while ( v59 );\n                    v15 = v21;\n                  }\n                  v24 = (Stack *)libmin_malloc(0x10uLL);\n                  v24->next = 0LL;\n                  v25 = *v15;\n                  v24->data = v66;\n                  v24->next = v25;\n                  *v15 = v24;\n                }\n                next = next->next;\n              }\n              while ( next );\n              v6 = v15;\n            }\n            v18 = (Stack *)libmin_malloc(0x10uLL);\n            v18->next = 0LL;\n            v19 = *v6;\n            v18->data = v67;\n            v18->next = v19;\n            *v6 = v18;\n          }\n        }\n        v13 = (Stack *)libmin_malloc(0x10uLL);\n        v13->next = 0LL;\n        v14 = *v6;\n        v13->data = adjacentVertex;\n        v13->next = v14;\n        *v6 = v13;\n      }\n      current = current->next;\n    }\n    while ( current );\n    v4 = v6;\n  }\n  v9 = (Stack *)libmin_malloc(0x10uLL);\n  v9->next = 0LL;\n  v10 = *v4;\n  v9->data = v;\n  v9->next = v10;\n  *v4 = v9;\n}\n"}, "pseudo_normalize": "void topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack) {\n  Stack **v4;\n  int *v5;\n  Stack **v6;\n  long long data;\n  int *v8;\n  Stack *v9;\n  Stack *v10;\n  long long v11;\n  int *v12;\n  Stack *v13;\n  Stack *v14;\n  Stack **v15;\n  long long v16;\n  int *v17;\n  Stack *v18;\n  Stack *v19;\n  List *v20;\n  Stack **v21;\n  long long v22;\n  int *v23;\n  Stack *v24;\n  Stack *v25;\n  List *v26;\n  Stack **v27;\n  List *v28;\n  Stack **v29;\n  long long v30;\n  int *v31;\n  Stack *v32;\n  Stack *v33;\n  int *v34;\n  List *v35;\n  long long v36;\n  int *v37;\n  Stack *v38;\n  Stack *v39;\n  Stack **v40;\n  List *v41;\n  long long v42;\n  int *v43;\n  int v44;\n  Stack *v45;\n  Stack *v46;\n  List *v47;\n  Stack **v48;\n  int *v49;\n  long long v50;\n  int *v51;\n  int v52;\n  Stack *v53;\n  Stack *v54;\n  List *j;\n  long long v56;\n  Stack *v57;\n  Stack *v58;\n  List *v59;\n  List *next;\n  List *i;\n  List *current;\n  int v63;\n  int v64;\n  int v65;\n  int v66;\n  int v67;\n  int adjacentVertex;\n  List *v69;\n  List *v70;\n  int v71;\n  v4 = stack;\n  visited[v] = 1;\n  current = graph->adj[v].next;\n  if (current) {\n    v5 = visited;\n    v6 = stack;\n    do {\n      data = current->data;\n      v8 = &v5[data];\n      adjacentVertex = current->data;\n      if (!*v8) {\n        *v8 = 1;\n        for (i = graph->adj[data].next; i; i = i->next) {\n          v11 = i->data;\n          v12 = &v5[v11];\n          v67 = i->data;\n          if (!*v12) {\n            *v12 = 1;\n            next = graph->adj[v11].next;\n            if (next) {\n              v15 = v6;\n              do {\n                v16 = next->data;\n                v17 = &v5[v16];\n                v66 = next->data;\n                if (!*v17) {\n                  *v17 = 1;\n                  v20 = &graph->adj[v16];\n                  if (v20->next) {\n                    v59 = v20->next;\n                    v21 = v15;\n                    do {\n                      v22 = v59->data;\n                      v23 = &v5[v22];\n                      v65 = v59->data;\n                      if (!*v23) {\n                        *v23 = 1;\n                        v26 = graph->adj[v22].next;\n                        if (v26) {\n                          v27 = v21;\n                          v28 = v26;\n                          v29 = v27;\n                          do {\n                            v30 = v28->data;\n                            v31 = &v5[v30];\n                            v64 = v28->data;\n                            if (!*v31) {\n                              *v31 = 1;\n                              if (graph->adj[v30].next) {\n                                v70 = v28;\n                                v34 = v5;\n                                v35 = graph->adj[v30].next;\n                                do {\n                                  v36 = v35->data;\n                                  v37 = &v34[v36];\n                                  v63 = v35->data;\n                                  if (!*v37) {\n                                    *v37 = 1;\n                                    if (graph->adj[v36].next) {\n                                      v69 = v35;\n                                      v40 = v29;\n                                      v41 = graph->adj[v36].next;\n                                      do {\n                                        v42 = v41->data;\n                                        v43 = &v34[v42];\n                                        v44 = v41->data;\n                                        if (!*v43) {\n                                          *v43 = 1;\n                                          v47 = graph->adj[v42].next;\n                                          if (v47) {\n                                            v71 = v44;\n                                            v48 = v40;\n                                            v49 = v34;\n                                            do {\n                                              v50 = v47->data;\n                                              v51 = &v49[v50];\n                                              v52 = v47->data;\n                                              if (!*v51) {\n                                                *v51 = 1;\n                                                for (j = graph->adj[v50].next;\n                                                     j; j = j->next) {\n                                                  while (1) {\n                                                    v56 = j->data;\n                                                    if (!v49[v56]) break;\n                                                    j = j->next;\n                                                    if (!j) goto LABEL_50;\n                                                  }\n                                                  topologicalSortUtil(\n                                                      graph, v56, v49, v48);\n                                                }\n                                              LABEL_50:\n                                                v57 = (Stack *)libmin_malloc(\n                                                    16uLL);\n                                                v57->next = 0LL;\n                                                v58 = *v48;\n                                                v57->data = v52;\n                                                v57->next = v58;\n                                                *v48 = v57;\n                                              }\n                                              v47 = v47->next;\n                                            } while (v47);\n                                            v34 = v49;\n                                            v40 = v48;\n                                            v44 = v71;\n                                          }\n                                          v53 = (Stack *)libmin_malloc(16uLL);\n                                          v53->next = 0LL;\n                                          v54 = *v40;\n                                          v53->data = v44;\n                                          v53->next = v54;\n                                          *v40 = v53;\n                                        }\n                                        v41 = v41->next;\n                                      } while (v41);\n                                      v29 = v40;\n                                      v35 = v69;\n                                    }\n                                    v45 = (Stack *)libmin_malloc(16uLL);\n                                    v45->next = 0LL;\n                                    v46 = *v29;\n                                    v45->data = v63;\n                                    v45->next = v46;\n                                    *v29 = v45;\n                                  }\n                                  v35 = v35->next;\n                                } while (v35);\n                                v5 = v34;\n                                v28 = v70;\n                              }\n                              v38 = (Stack *)libmin_malloc(16uLL);\n                              v38->next = 0LL;\n                              v39 = *v29;\n                              v38->data = v64;\n                              v38->next = v39;\n                              *v29 = v38;\n                            }\n                            v28 = v28->next;\n                          } while (v28);\n                          v21 = v29;\n                        }\n                        v32 = (Stack *)libmin_malloc(16uLL);\n                        v32->next = 0LL;\n                        v33 = *v21;\n                        v32->data = v65;\n                        v32->next = v33;\n                        *v21 = v32;\n                      }\n                      v59 = v59->next;\n                    } while (v59);\n                    v15 = v21;\n                  }\n                  v24 = (Stack *)libmin_malloc(16uLL);\n                  v24->next = 0LL;\n                  v25 = *v15;\n                  v24->data = v66;\n                  v24->next = v25;\n                  *v15 = v24;\n                }\n                next = next->next;\n              } while (next);\n              v6 = v15;\n            }\n            v18 = (Stack *)libmin_malloc(16uLL);\n            v18->next = 0LL;\n            v19 = *v6;\n            v18->data = v67;\n            v18->next = v19;\n            *v6 = v18;\n          }\n        }\n        v13 = (Stack *)libmin_malloc(16uLL);\n        v13->next = 0LL;\n        v14 = *v6;\n        v13->data = adjacentVertex;\n        v13->next = v14;\n        *v6 = v13;\n      }\n      current = current->next;\n    } while (current);\n    v4 = v6;\n  }\n  v9 = (Stack *)libmin_malloc(16uLL);\n  v9->next = 0LL;\n  v10 = *v4;\n  v9->data = v;\n  v9->next = v10;\n  *v4 = v9;\n}", "binary": "topo-sort/topo-sort.host.O3", "assembly": "<topologicalSortUtil>:\nendbr64\npush   %r15\nmovslq %esi,%rax\nmov    %rcx,%r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x68,%rsp\nmovl   $0x1,(%rdx,%rax,4)\nshl    $0x4,%rax\nadd    0x8(%rdi),%rax\nmov    0x8(%rax),%rax\nmov    %rdi,0x8(%rsp)\nmov    %esi,0x5c(%rsp)\nmov    %rax,0x28(%rsp)\ntest   %rax,%rax\nje     14b0 <topologicalSortUtil+0x70>\nmov    %rdx,%r15\nmov    %rcx,%r14\nmov    0x28(%rsp),%rax\nmovslq (%rax),%rax\nlea    (%r15,%rax,4),%rsi\nmov    %eax,0x44(%rsp)\nmov    (%rsi),%ebx\ntest   %ebx,%ebx\nje     14e8 <topologicalSortUtil+0xa8>\nmov    0x28(%rsp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0x28(%rsp)\ntest   %rax,%rax\njne    1484 <topologicalSortUtil+0x44>\nmov    %r14,%r15\nmov    $0x10,%edi\ncall   1c10 <libmin_malloc>\nmov    0x5c(%rsp),%ecx\nmovq   $0x0,0x8(%rax)\nmov    (%r15),%rdx\nmov    %ecx,(%rax)\nmov    %rdx,0x8(%rax)\nmov    %rax,(%r15)\nadd    $0x68,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nmov    0x8(%rsp),%rcx\nshl    $0x4,%rax\nmovl   $0x1,(%rsi)\nadd    0x8(%rcx),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0x20(%rsp)\ntest   %rax,%rax\nje     1534 <topologicalSortUtil+0xf4>\nmov    0x20(%rsp),%rax\nmovslq (%rax),%rax\nlea    (%r15,%rax,4),%rsi\nmov    %eax,0x40(%rsp)\nmov    (%rsi),%r11d\ntest   %r11d,%r11d\nje     1560 <topologicalSortUtil+0x120>\nmov    0x20(%rsp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0x20(%rsp)\ntest   %rax,%rax\njne    1509 <topologicalSortUtil+0xc9>\nmov    $0x10,%edi\ncall   1c10 <libmin_malloc>\nmov    0x44(%rsp),%edi\nmovq   $0x0,0x8(%rax)\nmov    (%r14),%rsi\nmov    %edi,(%rax)\nmov    %rsi,0x8(%rax)\nmov    %rax,(%r14)\njmp    149a <topologicalSortUtil+0x5a>\nnopl   0x0(%rax,%rax,1)\nmov    0x8(%rsp),%rcx\nshl    $0x4,%rax\nmovl   $0x1,(%rsi)\nadd    0x8(%rcx),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0x18(%rsp)\ntest   %rax,%rax\nje     15b2 <topologicalSortUtil+0x172>\nmov    %r14,%r13\nmov    0x18(%rsp),%rax\nmovslq (%rax),%rax\nlea    (%r15,%rax,4),%rdx\nmov    %eax,0x3c(%rsp)\nmov    (%rdx),%r10d\ntest   %r10d,%r10d\nje     15e0 <topologicalSortUtil+0x1a0>\nmov    0x18(%rsp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0x18(%rsp)\ntest   %rax,%rax\njne    1584 <topologicalSortUtil+0x144>\nmov    %r13,%r14\nmov    $0x10,%edi\ncall   1c10 <libmin_malloc>\nmov    0x40(%rsp),%ecx\nmovq   $0x0,0x8(%rax)\nmov    (%r14),%rsi\nmov    %ecx,(%rax)\nmov    %rsi,0x8(%rax)\nmov    %rax,(%r14)\njmp    1521 <topologicalSortUtil+0xe1>\nnopl   0x0(%rax)\nmov    0x8(%rsp),%rdi\nshl    $0x4,%rax\nmovl   $0x1,(%rdx)\nadd    0x8(%rdi),%rax\nmov    0x8(%rax),%r12\ntest   %r12,%r12\nje     1632 <topologicalSortUtil+0x1f2>\nmov    %r12,0x10(%rsp)\nmov    %r13,%r14\nmov    0x10(%rsp),%rax\nmovslq (%rax),%rax\nlea    (%r15,%rax,4),%rdx\nmov    %eax,0x38(%rsp)\nmov    (%rdx),%r9d\ntest   %r9d,%r9d\nje     1660 <topologicalSortUtil+0x220>\nmov    0x10(%rsp),%rax\nmov    0x8(%rax),%rax\nmov    %rax,0x10(%rsp)\ntest   %rax,%rax\njne    1604 <topologicalSortUtil+0x1c4>\nmov    %r14,%r13\nmov    $0x10,%edi\ncall   1c10 <libmin_malloc>\nmov    0x3c(%rsp),%edi\nmovq   $0x0,0x8(%rax)\nmov    0x0(%r13),%rdx\nmov    %edi,(%rax)\nmov    %rdx,0x8(%rax)\nmov    %rax,0x0(%r13)\njmp    159c <topologicalSortUtil+0x15c>\nnopl   0x0(%rax,%rax,1)\nmov    0x8(%rsp),%rcx\nshl    $0x4,%rax\nmovl   $0x1,(%rdx)\nadd    0x8(%rcx),%rax\nmov    0x8(%rax),%r13\ntest   %r13,%r13\nje     16a4 <topologicalSortUtil+0x264>\nmov    %r14,%rax\nmov    %r13,%r14\nmov    %rax,%r13\nmovslq (%r14),%rax\nlea    (%r15,%rax,4),%rdx\nmov    %eax,0x34(%rsp)\nmov    (%rdx),%r8d\ntest   %r8d,%r8d\nje     16d0 <topologicalSortUtil+0x290>\nmov    0x8(%r14),%r14\ntest   %r14,%r14\njne    1685 <topologicalSortUtil+0x245>\nmov    %r13,%r14\nmov    $0x10,%edi\ncall   1c10 <libmin_malloc>\nmov    0x38(%rsp),%ecx\nmovq   $0x0,0x8(%rax)\nmov    (%r14),%rdx\nmov    %ecx,(%rax)\nmov    %rdx,0x8(%rax)\nmov    %rax,(%r14)\njmp    161c <topologicalSortUtil+0x1dc>\nnopl   0x0(%rax,%rax,1)\nmov    0x8(%rsp),%rdi\nshl    $0x4,%rax\nmovl   $0x1,(%rdx)\nadd    0x8(%rdi),%rax\nmov    0x8(%rax),%r8\ntest   %r8,%r8\nje     1719 <topologicalSortUtil+0x2d9>\nmov    %r14,0x50(%rsp)\nmov    %r15,%r14\nmov    %r8,%r15\nmovslq (%r15),%rax\nlea    (%r14,%rax,4),%rsi\nmov    %eax,0x30(%rsp)\nmov    (%rsi),%edi\ntest   %edi,%edi\nje     1748 <topologicalSortUtil+0x308>\nmov    0x8(%r15),%r15\ntest   %r15,%r15\njne    16f7 <topologicalSortUtil+0x2b7>\nmov    %r14,%r15\nmov    0x50(%rsp),%r14\nmov    $0x10,%edi\ncall   1c10 <libmin_malloc>\nmov    0x34(%rsp),%edi\nmovq   $0x0,0x8(%rax)\nmov    0x0(%r13),%rdx\nmov    %edi,(%rax)\nmov    %rdx,0x8(%rax)\nmov    %rax,0x0(%r13)\njmp    1698 <topologicalSortUtil+0x258>\nnopw   0x0(%rax,%rax,1)\nmov    0x8(%rsp),%rcx\nshl    $0x4,%rax\nmovl   $0x1,(%rsi)\nadd    0x8(%rcx),%rax\nmov    0x8(%rax),%r12\ntest   %r12,%r12\nje     1791 <topologicalSortUtil+0x351>\nmov    %r15,0x48(%rsp)\nmov    %r13,%r15\nmov    %r12,%r13\nmovslq 0x0(%r13),%rax\nlea    (%r14,%rax,4),%rdx\nmov    %rax,%r12\nmov    (%rdx),%esi\ntest   %esi,%esi\nje     17c0 <topologicalSortUtil+0x380>\nmov    0x8(%r13),%r13\ntest   %r13,%r13\njne    176f <topologicalSortUtil+0x32f>\nmov    %r15,%r13\nmov    0x48(%rsp),%r15\nmov    $0x10,%edi\ncall   1c10 <libmin_malloc>\nmov    0x30(%rsp),%ecx\nmovq   $0x0,0x8(%rax)\nmov    0x0(%r13),%rsi\nmov    %ecx,(%rax)\nmov    %rsi,0x8(%rax)\nmov    %rax,0x0(%r13)\njmp    1708 <topologicalSortUtil+0x2c8>\nnopw   0x0(%rax,%rax,1)\nmov    0x8(%rsp),%rcx\nshl    $0x4,%rax\nmovl   $0x1,(%rdx)\nadd    0x8(%rcx),%rax\nmov    0x8(%rax),%rbp\ntest   %rbp,%rbp\nje     180c <topologicalSortUtil+0x3cc>\nmov    %r12d,0x58(%rsp)\nmov    %r15,%r12\nmov    %r14,%r15\nmovslq 0x0(%rbp),%rax\nlea    (%r15,%rax,4),%rdx\nmov    %rax,%r14\nmov    (%rdx),%ecx\ntest   %ecx,%ecx\nje     1830 <topologicalSortUtil+0x3f0>\nmov    0x8(%rbp),%rbp\ntest   %rbp,%rbp\njne    17e7 <topologicalSortUtil+0x3a7>\nmov    %r15,%r14\nmov    %r12,%r15\nmov    0x58(%rsp),%r12d\nmov    $0x10,%edi\ncall   1c10 <libmin_malloc>\nmovq   $0x0,0x8(%rax)\nmov    (%r15),%rdx\nmov    %r12d,(%rax)\nmov    %rdx,0x8(%rax)\nmov    %rax,(%r15)\njmp    1780 <topologicalSortUtil+0x340>\nmov    0x8(%rsp),%rcx\nshl    $0x4,%rax\nmovl   $0x1,(%rdx)\nadd    0x8(%rcx),%rax\nmov    0x8(%rax),%rbx\ntest   %rbx,%rbx\nje     1863 <topologicalSortUtil+0x423>\nmovslq (%rbx),%rax\nmov    %rax,%rsi\nmov    (%r15,%rax,4),%eax\ntest   %eax,%eax\nje     1890 <topologicalSortUtil+0x450>\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\njne    184c <topologicalSortUtil+0x40c>\nmov    $0x10,%edi\ncall   1c10 <libmin_malloc>\nmovq   $0x0,0x8(%rax)\nmov    (%r12),%rdx\nmov    %r14d,(%rax)\nmov    %rdx,0x8(%rax)\nmov    %rax,(%r12)\njmp    17f8 <topologicalSortUtil+0x3b8>\nnopl   0x0(%rax)\nmov    0x8(%rsp),%rdi\nmov    %r12,%rcx\nmov    %r15,%rdx\ncall   1440 <topologicalSortUtil>\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\njne    184c <topologicalSortUtil+0x40c>\njmp    1863 <topologicalSortUtil+0x423>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "totient/totient.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tint argc=1; char **argv=NULL;\n\tint n;\n\tint j=0;\n\n\t/* Process command line */\n\twhile(++j < argc){\n\t\tif(argv[j][0] == '-')\n\t\t\tswitch(argv[j][1]){ \n\t\t\t\tcase '-':\n\t\t\t\t\t++j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\tcase 'V':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '?':\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'H':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",HELP);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tdefault:\n\t\t\t\t\tlibmin_printf(\"totient: unkown option %s\\n\", argv[j]);\n\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\tbreak;\n\t}\n\n\tif(j >= argc){\n\t\t//fprintf(stderr,\"totient: usage error.\\n\");\n\t\t//fprintf(stderr,\"%s\\n\",USAGE);\n\t\tn = 45457;\n\t}\n\telse\n\t  n = libmin_atoi(argv[j++]);\n\n\tif(n == 0){\n\t\tlibmin_printf(\"totient: not defined for n = 0.\\n\");\n\t\treturn 1;\n\t}\n\n\tlibmin_printf(\"phi(%d) = %d\\n\",n,phi(n));\n\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "totient/totient.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}", "binary": "totient/totient.host.O3", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0xb191,%edi\nmov    $0xb191,%esi\ncall   1230 <phi>\nlea    0x2ee6(%rip),%rdi\nmov    %eax,%edx\nxor    %eax,%eax\ncall   33e0 <libmin_printf>\ncall   3620 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "totient/totient.c", "function_name": "phi", "content": "static int phi(int n)\n{\n\tif(n<0)n=-n;\n\t/* handle a few trivial boundary cases */\n\tif(n<=1)return 0;\n\tif(n==2)return 1;\n\tif(n==3)return 2;\n\treturn phiphi(n,2);\n}\n"}, "pseudo": {"path": "totient/totient.host.O3.pseudo", "function_name": "phi", "address": "0x1230", "label": "phi", "content": "int __fastcall phi(int n)\n{\n  int v1; // ebx\n  int v2; // r12d\n  int v3; // r13d\n  int v4; // ecx\n  int v5; // eax\n  int v6; // ebp\n  int v7; // edi\n  int v9; // edx\n  int v10; // ecx\n  int v11; // eax\n\n  v1 = -n;\n  if ( n > 0 )\n    v1 = n;\n  v2 = 0;\n  if ( v1 > 1 )\n  {\n    v2 = 1;\n    if ( v1 != 2 )\n    {\n      v2 = 2;\n      v3 = 1;\n      if ( v1 != 3 )\n      {\n        while ( 1 )\n        {\n          v4 = 2;\n          do\n          {\n            v7 = v4++;\n            if ( v4 == v1 )\n              return v3 * v7;\n            v5 = v1 / v7;\n            v2 = v1 % v7;\n            v6 = v1 / v7;\n          }\n          while ( v1 % v7 );\n          v1 /= v7;\n          v9 = v5;\n          v10 = v7;\n          while ( v9 )\n          {\n            if ( v10 <= 0 )\n              v10 = -v10;\n            if ( v9 < v10 )\n            {\n              v11 = v10;\n              v10 = v9;\n              v9 = v11;\n            }\n            v9 %= v10;\n            if ( !v9 )\n            {\n              if ( v10 == 1 )\n              {\n                v3 *= phi(v7);\n                goto LABEL_20;\n              }\n              break;\n            }\n          }\n          v3 *= v7;\nLABEL_20:\n          if ( v6 <= 1 )\n            break;\n          if ( v6 == 2 )\n            return v3;\n          if ( v6 == 3 )\n            return 2 * v3;\n        }\n      }\n    }\n  }\n  return v2;\n}\n"}, "pseudo_normalize": "int phi(int n) {\n  int v1;\n  int v2;\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v9;\n  int v10;\n  int v11;\n  v1 = -n;\n  if (n > 0) v1 = n;\n  v2 = 0;\n  if (v1 > 1) {\n    v2 = 1;\n    if (v1 != 2) {\n      v2 = 2;\n      v3 = 1;\n      if (v1 != 3) {\n        while (1) {\n          v4 = 2;\n          do {\n            v7 = v4++;\n            if (v4 == v1) return v3 * v7;\n            v5 = v1 / v7;\n            v2 = v1 % v7;\n            v6 = v1 / v7;\n          } while (v1 % v7);\n          v1 /= v7;\n          v9 = v5;\n          v10 = v7;\n          while (v9) {\n            if (v10 <= 0) v10 = -v10;\n            if (v9 < v10) {\n              v11 = v10;\n              v10 = v9;\n              v9 = v11;\n            }\n            v9 %= v10;\n            if (!v9) {\n              if (v10 == 1) {\n                v3 *= phi(v7);\n                goto LABEL_20;\n              }\n              break;\n            }\n          }\n          v3 *= v7;\n        LABEL_20:\n          if (v6 <= 1) break;\n          if (v6 == 2) return v3;\n          if (v6 == 3) return 2 * v3;\n        }\n      }\n    }\n  }\n  return v2;\n}", "binary": "totient/totient.host.O3", "assembly": "<phi>:\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebx\nsub    $0x8,%rsp\nneg    %ebx\ncmovs  %edi,%ebx\nxor    %r12d,%r12d\ncmp    $0x1,%ebx\njle    128e <phi+0x5e>\nmov    $0x1,%r12d\ncmp    $0x2,%ebx\nje     128e <phi+0x5e>\nmov    $0x2,%r12d\nmov    $0x1,%r13d\ncmp    $0x3,%ebx\nje     128e <phi+0x5e>\nmov    $0x2,%ecx\njmp    127e <phi+0x4e>\nnopl   0x0(%rax)\nmov    %ebx,%eax\ncltd\nidiv   %edi\nmov    %edx,%r12d\nmov    %eax,%ebp\ntest   %edx,%edx\nje     12a0 <phi+0x70>\nmov    %ecx,%edi\nadd    $0x1,%ecx\ncmp    %ebx,%ecx\njne    1270 <phi+0x40>\nimul   %r13d,%edi\nmov    %edi,%r12d\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nmov    %eax,%ebx\nmov    %eax,%edx\nmov    %edi,%ecx\ncs nopw 0x0(%rax,%rax,1)\ntest   %ecx,%ecx\nje     1300 <phi+0xd0>\ntest   %edx,%edx\nje     1300 <phi+0xd0>\nmov    %ecx,%eax\nneg    %eax\ncmovns %eax,%ecx\ncmp    %ecx,%edx\njge    12c9 <phi+0x99>\nmov    %ecx,%eax\nmov    %edx,%ecx\nmov    %eax,%edx\nmov    %edx,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    12b0 <phi+0x80>\ncmp    $0x1,%ecx\njne    1300 <phi+0xd0>\ncall   1230 <phi>\nimul   %eax,%r13d\ncmp    $0x1,%ebp\njle    128e <phi+0x5e>\ncmp    $0x2,%ebp\nje     1306 <phi+0xd6>\ncmp    $0x3,%ebp\njne    1265 <phi+0x35>\nlea    0x0(%r13,%r13,1),%r12d\njmp    128e <phi+0x5e>\nnopw   0x0(%rax,%rax,1)\nimul   %edi,%r13d\njmp    12e0 <phi+0xb0>\nmov    %r13d,%r12d\njmp    128e <phi+0x5e>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "transcend/transcend.c", "function_name": "main", "content": "// --------------------------------- Main -------------------------------------\nint main(void) {\n  for (int f = 0; f < FN_COUNT; ++f) {\n    (void)run_fp64((fn_t)f);\n  }\n  libmin_success();\n}\n"}, "pseudo": {"path": "transcend/transcend.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double *v3; // r14\n  double *v4; // rax\n  double *v5; // r15\n  __int64 v6; // rcx\n  __int64 v7; // rdx\n  unsigned __int64 v8; // rsi\n  double v9; // xmm1_8\n  __int64 v10; // rax\n  double v11; // xmm0_8\n  double v12; // xmm0_8\n  unsigned __int64 v13; // rbp\n  __int64 v14; // rbx\n  __int64 v15; // rdx\n  double *v16; // rax\n  double v17; // xmm1_8\n  double v18; // xmm0_8\n  __int64 v19; // [rsp+0h] [rbp-58h]\n  __int64 v20; // [rsp+8h] [rbp-50h]\n  double x; // [rsp+18h] [rbp-40h]\n\n  v19 = 0LL;\nLABEL_2:\n  v3 = (double *)libmin_malloc(0x200uLL);\n  v4 = (double *)libmin_malloc(0x200uLL);\n  v5 = v4;\n  if ( !v3 || !v4 )\n  {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  v6 = 64LL;\n  v7 = 0LL;\n  v8 = 1LL;\n  v9 = 10.0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v8 ^= ((v8 ^ (v8 << 13)) >> 7) ^ (v8 << 13) ^ ((((v8 ^ (v8 << 13)) >> 7) ^ v8 ^ (v8 << 13)) << 17);\n      v10 = v7;\n      v11 = (double)(int)(v8 >> 11) * 1.110223024625157e-16;\n      if ( v19 != 3 )\n        break;\n      v3[v7] = v11 * 8.0 - 4.0;\nLABEL_6:\n      v7 = ((_BYTE)v7 + 1) & 0x3F;\n      if ( !--v6 )\n        goto LABEL_10;\n    }\n    if ( (_DWORD)v19 )\n    {\n      v3[v7] = v11 * 6.283185307179586 - 3.141592653589793;\n      goto LABEL_6;\n    }\n    v7 = ((_BYTE)v7 + 1) & 0x3F;\n    v3[v10] = v11 * 20.0 - 10.0;\n    if ( !--v6 )\n    {\nLABEL_10:\n      x = 0.0;\n      v20 = 10LL;\n      while ( 1 )\n      {\n        v13 = 0LL;\n        v14 = 0LL;\n        do\n        {\n          if ( v19 == 2 )\n          {\nLABEL_20:\n            v12 = libmin_cos(v9);\n            goto LABEL_13;\n          }\n          if ( (_DWORD)v19 == 3 )\n          {\n            v15 = v13 / 3 + (((v13 * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64) & 0xFFFFFFFFFFFFFFFELL);\n            if ( v13 == v15 )\n            {\nLABEL_12:\n              v12 = libmin_exp(v9);\n              goto LABEL_13;\n            }\n            if ( v13 - v15 != 1 )\n              goto LABEL_20;\n          }\n          else if ( (_DWORD)v19 != 1 )\n          {\n            goto LABEL_12;\n          }\n          v12 = libmin_sin(v9);\nLABEL_13:\n          v5[v14] = v12;\n          ++v13;\n          v9 = x;\n          v14 = ((_BYTE)v14 + 1) & 0x3F;\n          x = v12 * 1.0e-16 + x;\n        }\n        while ( v13 != 64 );\n        if ( !--v20 )\n        {\n          v16 = v5;\n          v17 = 0.0;\n          do\n          {\n            v18 = *v16;\n            v16 += 2;\n            v17 = v17 + v18 + *(v16 - 1);\n          }\n          while ( v16 != v5 + 64 );\n          argv = (const char **)FN_NAMES[v19];\n          libmin_printf(\n            \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n            (const char *)argv,\n            10,\n            64,\n            1,\n            640.0,\n            v17);\n          libmin_free(v3);\n          libmin_free(v5);\n          if ( ++v19 == 4 )\n            libmin_success();\n          goto LABEL_2;\n        }\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double *v3;\n  double *v4;\n  double *v5;\n  long long v6;\n  long long v7;\n  unsigned long long v8;\n  double v9;\n  long long v10;\n  double v11;\n  double v12;\n  unsigned long long v13;\n  long long v14;\n  long long v15;\n  double *v16;\n  double v17;\n  double v18;\n  long long v19;\n  long long v20;\n  double x;\n  v19 = 0LL;\nLABEL_2:\n  v3 = (double *)libmin_malloc(512uLL);\n  v4 = (double *)libmin_malloc(512uLL);\n  v5 = v4;\n  if (!v3 || !v4) {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  v6 = 64LL;\n  v7 = 0LL;\n  v8 = 1LL;\n  v9 = 10.0;\n  while (1) {\n    while (1) {\n      v8 ^= ((v8 ^ (v8 << 13)) >> 7) ^ (v8 << 13) ^\n            ((((v8 ^ (v8 << 13)) >> 7) ^ v8 ^ (v8 << 13)) << 17);\n      v10 = v7;\n      v11 = (double)(int)(v8 >> 11) * 1.110223024625157e-16;\n      if (v19 != 3) break;\n      v3[v7] = v11 * 8.0 - 4.0;\n    LABEL_6:\n      v7 = ((uint8_t)v7 + 1) & 63;\n      if (!--v6) goto LABEL_10;\n    }\n    if ((uint32_t)v19) {\n      v3[v7] = v11 * 6.283185307179586 - 3.141592653589793;\n      goto LABEL_6;\n    }\n    v7 = ((uint8_t)v7 + 1) & 63;\n    v3[v10] = v11 * 20.0 - 10.0;\n    if (!--v6) {\n    LABEL_10:\n      x = 0.0;\n      v20 = 10LL;\n      while (1) {\n        v13 = 0LL;\n        v14 = 0LL;\n        do {\n          if (v19 == 2) {\n          LABEL_20:\n            v12 = libmin_cos(v9);\n            goto LABEL_13;\n          }\n          if ((uint32_t)v19 == 3) {\n            v15 = v13 / 3 +\n                  (((v13 * (unsigned __int128)12297829382473034411LL) >> 64) &\n                   18446744073709551614LL);\n            if (v13 == v15) {\n            LABEL_12:\n              v12 = libmin_exp(v9);\n              goto LABEL_13;\n            }\n            if (v13 - v15 != 1) goto LABEL_20;\n          } else if ((uint32_t)v19 != 1) {\n            goto LABEL_12;\n          }\n          v12 = libmin_sin(v9);\n        LABEL_13:\n          v5[v14] = v12;\n          ++v13;\n          v9 = x;\n          v14 = ((uint8_t)v14 + 1) & 63;\n          x = v12 * 1.0e-16 + x;\n        } while (v13 != 64);\n        if (!--v20) {\n          v16 = v5;\n          v17 = 0.0;\n          do {\n            v18 = *v16;\n            v16 += 2;\n            v17 = v17 + v18 + *(v16 - 1);\n          } while (v16 != v5 + 64);\n          argv = (const char **)FN_NAMES[v19];\n          libmin_printf(\n              \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f \"\n              \"checksum=%f\\n\",\n              (const char *)argv, 10, 64, 1, 640.0, v17);\n          libmin_free(v3);\n          libmin_free(v5);\n          if (++v19 == 4) libmin_success();\n          goto LABEL_2;\n        }\n      }\n    }\n  }\n}", "binary": "transcend/transcend.host.O3", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovq   $0x0,(%rsp)\nmov    $0x200,%edi\nmov    (%rsp),%r12d\ncall   18a0 <libmin_malloc>\nmov    $0x200,%edi\nmov    %rax,%r14\ncall   18a0 <libmin_malloc>\nmov    %rax,%r15\ntest   %r14,%r14\nje     13a4 <main+0x284>\ntest   %rax,%rax\nje     13a4 <main+0x284>\nmovsd  0x5f36(%rip),%xmm5\nmovsd  0x5f16(%rip),%xmm4\nmov    $0x40,%ecx\nxor    %edx,%edx\nmovsd  0x5f0f(%rip),%xmm3\nmovsd  0x5eef(%rip),%xmm2\nmov    $0x1,%esi\nmovsd  0x5eea(%rip),%xmm1\njmp    11bf <main+0x9f>\nmulsd  0x5ef8(%rip),%xmm0\nsubsd  %xmm5,%xmm0\nmovsd  %xmm0,(%r14,%rdx,8)\nadd    $0x1,%rdx\nand    $0x3f,%edx\nsub    $0x1,%rcx\nje     1228 <main+0x108>\nmov    %rsi,%rax\npxor   %xmm0,%xmm0\nshl    $0xd,%rax\nxor    %rsi,%rax\nmov    %rax,%rsi\nshr    $0x7,%rsi\nxor    %rsi,%rax\nmov    %rax,%rsi\nshl    $0x11,%rsi\nxor    %rax,%rsi\nmov    %rsi,%rax\nshr    $0xb,%rax\ncmpq   $0x3,(%rsp)\ncvtsi2sd %rax,%xmm0\nlea    0x0(,%rdx,8),%rax\nmulsd  0x5e76(%rip),%xmm0\nje     11a0 <main+0x80>\ntest   %r12d,%r12d\njne    12e1 <main+0x1c1>\nmulsd  %xmm2,%xmm0\nadd    $0x1,%rdx\nand    $0x3f,%edx\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%r14,%rax,1)\nsub    $0x1,%rcx\njne    11bf <main+0x9f>\nmovq   $0x0,0x18(%rsp)\nmovq   $0xa,0x8(%rsp)\njmp    1286 <main+0x166>\nnopl   0x0(%rax)\ncmp    $0x1,%r12d\nje     12f8 <main+0x1d8>\ncall   16a0 <libmin_exp>\nmovsd  %xmm0,(%r15,%r13,1)\nmulsd  0x5e53(%rip),%xmm0\nadd    $0x1,%rbx\nadd    $0x1,%rbp\nmovsd  0x18(%rsp),%xmm1\nand    $0x3f,%ebx\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,0x18(%rsp)\ncmp    $0x40,%rbp\njne    1290 <main+0x170>\nsubq   $0x1,0x8(%rsp)\nje     1302 <main+0x1e2>\nxor    %ebp,%ebp\nxor    %ebx,%ebx\nnopw   0x0(%rax,%rax,1)\ncmpq   $0x2,(%rsp)\nmovsd  (%r14,%rbx,8),%xmm0\nlea    0x0(,%rbx,8),%r13\nje     12d7 <main+0x1b7>\ncmp    $0x3,%r12d\njne    1240 <main+0x120>\nmovabs $0xaaaaaaaaaaaaaaab,%rax\nmul    %rbp\nmov    %rdx,%rax\nand    $0xfffffffffffffffe,%rdx\nshr    %rax\nadd    %rax,%rdx\nmov    %rbp,%rax\nsub    %rdx,%rax\nje     124a <main+0x12a>\ncmp    $0x1,%rax\nje     12f8 <main+0x1d8>\ncall   4010 <libmin_cos>\njmp    124f <main+0x12f>\nmulsd  %xmm4,%xmm0\nsubsd  %xmm3,%xmm0\nmovsd  %xmm0,(%r14,%rax,1)\njmp    11b2 <main+0x92>\nnopl   0x0(%rax)\ncall   4400 <libmin_sin>\njmp    124f <main+0x12f>\nmov    %r15,%rax\nlea    0x200(%r15),%rdx\npxor   %xmm1,%xmm1\nmovsd  (%rax),%xmm0\nadd    $0x10,%rax\naddsd  %xmm0,%xmm1\nmovsd  -0x8(%rax),%xmm0\naddsd  %xmm0,%xmm1\ncmp    %rdx,%rax\njne    1310 <main+0x1f0>\nmov    (%rsp),%rbx\nmov    $0x1,%r8d\nmov    $0x40,%ecx\nlea    0x8a20(%rip),%rax\nmov    $0xa,%edx\nlea    0x5cdc(%rip),%rdi\nmov    (%rax,%rbx,8),%rsi\nmov    0x5d61(%rip),%rax\nadd    $0x1,%rbx\nmovq   %rax,%xmm0\nmov    $0x2,%eax\ncall   3be0 <libmin_printf>\nmov    %r14,%rdi\ncall   1950 <libmin_free>\nmov    %r15,%rdi\ncall   1950 <libmin_free>\nmov    %rbx,(%rsp)\nmovsd  0x18(%rsp),%xmm0\ncmp    $0x4,%rbx\njne    113a <main+0x1a>\ncall   47e0 <libmin_success>\nadd    $0x28,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x5c59(%rip),%rdi\nxor    %eax,%eax\ncall   3be0 <libmin_printf>\nmov    $0x1,%edi\ncall   1880 <libmin_fail>\njmp    116a <main+0x4a>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "uniquify/uniquify.c", "function_name": "main", "content": "int main(void) {\n    /* \n     * Define a statically allocated list of strings.\n     * Most strings are unique, with a few duplicates.\n     */\n    char *strings[] = {\n        \"banana\",\n        \"apple\",\n        \"orange\",\n        \"kiwi\",\n        \"grape\",\n        \"mango\",\n        \"strawberry\",\n        \"pear\",\n        \"pineapple\",\n        \"watermelon\",\n        \"blueberry\",\n        \"raspberry\",\n        \"apple\",   /* duplicate */\n        \"blackberry\",\n        \"cherry\",\n        \"banana\",  /* duplicate */\n        \"peach\",\n        \"apricot\",\n        \"plum\",\n        \"nectarine\",\n        \"cantaloupe\",\n        \"honeydew\",\n        \"lime\", /* duplicate */\n        \"papaya\",\n        \"passionfruit\",\n        \"guava\",\n        \"lychee\",\n        \"pomegranate\",\n        \"grapefruit\",\n        \"lemon\",\n        \"lime\",\n        \"tangerine\",\n        \"cranberry\",\n        \"fig\",\n        \"plum\" /* duplicate */\n    };\n    size_t n = sizeof(strings) / sizeof(strings[0]);\n\n    libmin_printf(\"Unsorted Strings:\\n\");\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s\\n\", strings[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* Sort the list using qsort from qsort.h/qsort.c */\n    libmin_qsort(strings, n, sizeof(char *), string_compare);\n\n    libmin_printf(\"Sorted Strings:\\n\");\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s\\n\", strings[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* Remove duplicates from the sorted list.\n     * Since duplicates become adjacent after sorting, we simply print the\n     * first occurrence and then any string that differs from its predecessor.\n     */\n    libmin_printf(\"Unique Strings:\\n\");\n    if (n > 0) {\n        libmin_printf(\"%s\\n\", strings[0]);\n        size_t unique_count = 1;\n        for (size_t i = 1; i < n; i++) {\n            if (libmin_strcmp(strings[i], strings[i - 1]) != 0) {\n                libmin_printf(\"%s\\n\", strings[i]);\n                unique_count++;\n            }\n        }\n        libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_count);\n    } else {\n        libmin_printf(\"No strings.\\n\");\n    }\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "uniquify/uniquify.host.O3.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char **v3; // rbx\n  char **v4; // rbp\n  const char *v5; // rsi\n  const char *v6; // rsi\n  char **v7; // rbx\n  int v8; // ebp\n  const char *v9; // rsi\n  char *strings[35]; // [rsp+0h] [rbp-148h] BYREF\n  _QWORD v11[6]; // [rsp+118h] [rbp-30h] BYREF\n\n  v11[0] = __readfsqword(0x28u);\n  qmemcpy(strings, &off_6020, sizeof(strings));\n  v3 = strings;\n  v4 = strings;\n  libmin_printf(\"Unsorted Strings:\\n\", &off_6020 + 35, envp);\n  do\n  {\n    v5 = *v4++;\n    libmin_printf(\"%s\\n\", v5);\n  }\n  while ( v4 != v11 );\n  libmin_printf((char *)\"\\n\");\n  libmin_qsort(strings, 0x23uLL, 8uLL, string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  do\n  {\n    v6 = *v3++;\n    libmin_printf(\"%s\\n\", v6);\n  }\n  while ( v3 != v11 );\n  v7 = &strings[1];\n  v8 = 1;\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  while ( 1 )\n  {\n    if ( libmin_strcmp(*v7, *(v7 - 1)) )\n    {\n      v9 = *v7++;\n      ++v8;\n      libmin_printf(\"%s\\n\", v9);\n      if ( v7 == v11 )\n      {\nLABEL_9:\n        libmin_printf(\"\\nTotal Unique Strings: %u\\n\", v8);\n        libmin_success();\n      }\n    }\n    else if ( ++v7 == v11 )\n    {\n      goto LABEL_9;\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  char **v3;\n  char **v4;\n  const char *v5;\n  const char *v6;\n  char **v7;\n  int v8;\n  const char *v9;\n  char *strings[35];\n  uint64_t v11[6];\n  v11[0] = __readfsqword(40u);\n  qmemcpy(strings, &off_6020, sizeof(strings));\n  v3 = strings;\n  v4 = strings;\n  libmin_printf(\"Unsorted Strings:\\n\", &off_6020 + 35, envp);\n  do {\n    v5 = *v4++;\n    libmin_printf(\"%s\\n\", v5);\n  } while (v4 != v11);\n  libmin_printf((char *)\"\\n\");\n  libmin_qsort(strings, 35uLL, 8uLL, string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  do {\n    v6 = *v3++;\n    libmin_printf(\"%s\\n\", v6);\n  } while (v3 != v11);\n  v7 = &strings[1];\n  v8 = 1;\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  while (1) {\n    if (libmin_strcmp(*v7, *(v7 - 1))) {\n      v9 = *v7++;\n      ++v8;\n      libmin_printf(\"%s\\n\", v9);\n      if (v7 == v11) {\n      LABEL_9:\n        libmin_printf(\"\\nTotal Unique Strings: %u\\n\", v8);\n        libmin_success();\n      }\n    } else if (++v7 == v11) {\n      goto LABEL_9;\n    }\n  }\n}", "binary": "uniquify/uniquify.host.O3", "assembly": "<main>:\nendbr64\npush   %r14\nlea    0x4ef3(%rip),%rsi\nmov    $0x23,%ecx\npush   %r13\nlea    0x2edc(%rip),%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x120,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x118(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r14\nmov    %rsp,%rdi\nlea    0x118(%rsp),%r12\nrep movsq %ds:(%rsi),%es:(%rdi)\nlea    0x2e93(%rip),%rdi\nmov    %r14,%rbx\nmov    %r14,%rbp\ncall   3470 <libmin_printf>\nnopl   0x0(%rax)\nmov    0x0(%rbp),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x8,%rbp\ncall   3470 <libmin_printf>\ncmp    %r12,%rbp\njne    1180 <main+0x60>\nlea    0x2e8c(%rip),%rbp\nxor    %eax,%eax\nmov    %rbp,%rdi\ncall   3470 <libmin_printf>\nmov    %r14,%rdi\nmov    $0x8,%edx\nlea    0x1d9(%rip),%rcx\nmov    $0x23,%esi\ncall   38c0 <libmin_qsort>\nlea    0x2e53(%rip),%rdi\nxor    %eax,%eax\ncall   3470 <libmin_printf>\nnop\nmov    (%rbx),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x8,%rbx\ncall   3470 <libmin_printf>\ncmp    %r12,%rbx\njne    11d0 <main+0xb0>\nmov    %rbp,%rdi\nxor    %eax,%eax\nlea    0x8(%rsp),%rbx\nmov    $0x1,%ebp\ncall   3470 <libmin_printf>\nlea    0x2e2b(%rip),%rdi\nxor    %eax,%eax\ncall   3470 <libmin_printf>\nmov    (%rsp),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   3470 <libmin_printf>\njmp    1229 <main+0x109>\nnopl   0x0(%rax,%rax,1)\nadd    $0x8,%rbx\ncmp    %r12,%rbx\nje     1253 <main+0x133>\nmov    -0x8(%rbx),%rsi\nmov    (%rbx),%rdi\ncall   38f0 <libmin_strcmp>\ntest   %eax,%eax\nje     1220 <main+0x100>\nmov    (%rbx),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x8,%rbx\nadd    $0x1,%rbp\ncall   3470 <libmin_printf>\ncmp    %r12,%rbx\njne    1229 <main+0x109>\nmov    %rbp,%rsi\nlea    0x2de0(%rip),%rdi\nxor    %eax,%eax\ncall   3470 <libmin_printf>\ncall   3980 <libmin_success>\nmov    0x118(%rsp),%rax\nsub    %fs:0x28,%rax\njne    128e <main+0x16e>\nadd    $0x120,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "uniquify/uniquify.c", "function_name": "string_compare", "content": "#include \"libmin.h\"\n\n/* Comparison function for strings.\n * qsort passes pointers to elements (here pointers to char pointers),\n * so we cast accordingly.\n */\nint string_compare(const void *a, const void *b) {\n    const char * const *str1 = (const char * const *) a;\n    const char * const *str2 = (const char * const *) b;\n    return libmin_strcmp(*str1, *str2);\n}\n"}, "pseudo": {"path": "uniquify/uniquify.host.O3.pseudo", "function_name": "string_compare", "address": "0x1390", "label": "string_compare", "content": "int __fastcall string_compare(const void *a, const void *b)\n{\n  return libmin_strcmp(*(const char **)a, *(const char **)b);\n}\n"}, "pseudo_normalize": "", "binary": "uniquify/uniquify.host.O3", "assembly": "<string_compare>:\nendbr64\nmov    (%rsi),%rsi\nmov    (%rdi),%rdi\njmp    38f0 <libmin_strcmp>\nnop\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "dot_prod", "content": "/**\n * Obtain the dot product of two 3D vectors.\n * @f[\n * \\vec{a}\\cdot\\vec{b}=a_xb_x + a_yb_y + a_zb_z\n * @f]\n * @param[in] a first vector\n * @param[in] b second vector\n * @returns resulting dot product\n */\ndouble dot_prod(const vec_3d *a, const vec_3d *b)\n{\n    double dot;\n    dot = a->x * b->x;\n    dot += a->y * b->y;\n    dot += a->z * b->z;\n\n    return dot;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O3.pseudo", "function_name": "dot_prod", "address": "0x1680", "label": "dot_prod", "content": "double __fastcall dot_prod(const vec_3d *a, const vec_3d *b)\n{\n  return a->z * b->z + a->y * b->y + a->x * b->x;\n}\n"}, "pseudo_normalize": "", "binary": "vectors-3d/vectors-3d.host.O3", "assembly": "<dot_prod>:\nendbr64\nmovsd  (%rdi),%xmm0\nmovsd  0x8(%rdi),%xmm1\nmulsd  (%rsi),%xmm0\nmulsd  0x8(%rsi),%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rdi),%xmm0\nmulsd  0x10(%rsi),%xmm0\naddsd  %xmm1,%xmm0\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "get_angle", "content": "/**\n * Obtain the angle between two given vectors.\n * @f[\\alpha=acos\\left(\\frac{\\vec{a} \\cdot \\vec{b}}{\\lVert\\vec{a}\\rVert \\cdot \\lVert\\vec{b}\\rVert}\\right)@f]\n * @param[in] a first input vector\n * @param[in] b second input vector\n * @returns angle between @f$\\vec{a}@f$ and @f$\\vec{b}@f$ in radians\n */\n\ndouble get_angle(const vec_3d *a, const vec_3d *b)\n{\n    double alpha, cos_alpha;\n    double norm_a = vector_norm(a); ///< The norm of vector a\n    double norm_b = vector_norm(b); ///< The norm of vector b\n    if (libmin_fabs(norm_a) < EPSILON || libmin_fabs(norm_b) < EPSILON) /// detect possible division by 0 - the angle is not defined in this case\n    {  \n        return NAN; \n    }\n\n    cos_alpha = dot_prod(a, b) / (norm_a * norm_b);\n    alpha = libmin_acos(cos_alpha); // delivers the radian\n    return alpha; // in range from -1 to 1\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O3.pseudo", "function_name": "get_angle", "address": "0x18c0", "label": "get_angle", "content": "double __fastcall get_angle(const vec_3d *a, const vec_3d *b)\n{\n  double v2; // xmm1_8\n  double norm_a; // [rsp+0h] [rbp-28h]\n  double norm_b; // [rsp+8h] [rbp-20h]\n\n  norm_a = libmin_sqrt(a->x * a->x + a->y * a->y);\n  v2 = b->x * b->x + b->y * b->y;\n  norm_b = libmin_sqrt(v2);\n  if ( libmin_fabs(v2) < 0.000000001 || libmin_fabs(v2) < 0.000000001 )\n    return NAN;\n  else\n    return libmin_acos(norm_b * norm_a);\n}\n"}, "pseudo_normalize": "double get_angle(const vec_3d *a, const vec_3d *b) {\n  double v2;\n  double norm_a;\n  double norm_b;\n  norm_a = libmin_sqrt(a->x * a->x + a->y * a->y);\n  v2 = b->x * b->x + b->y * b->y;\n  norm_b = libmin_sqrt(v2);\n  if (libmin_fabs(v2) < 0.000000001 || libmin_fabs(v2) < 0.000000001)\n    return NAN;\n  else\n    return libmin_acos(norm_b * norm_a);\n}", "binary": "vectors-3d/vectors-3d.host.O3", "assembly": "<get_angle>:\nendbr64\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x18,%rsp\nmovsd  (%rdi),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x8(%rdi),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rdi),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncall   4040 <libmin_sqrt>\nmovsd  %xmm0,(%rsp)\nmovsd  (%rbx),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x8(%rbx),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rbx),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncall   4040 <libmin_sqrt>\nmovsd  %xmm0,0x8(%rsp)\nmovsd  (%rsp),%xmm0\ncall   1ee0 <libmin_fabs>\nmovsd  0x378d(%rip),%xmm3\ncomisd %xmm0,%xmm3\njbe    1960 <get_angle+0xa0>\nmovsd  0x3787(%rip),%xmm0\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   0x0(%rax,%rax,1)\nmovsd  0x8(%rsp),%xmm0\ncall   1ee0 <libmin_fabs>\nmovsd  0x375d(%rip),%xmm4\ncomisd %xmm0,%xmm4\nja     1949 <get_angle+0x89>\nmovsd  0x0(%rbp),%xmm0\nmovsd  0x8(%rbp),%xmm1\nmulsd  (%rbx),%xmm0\nmulsd  0x8(%rbx),%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rbp),%xmm0\nmulsd  0x10(%rbx),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  0x8(%rsp),%xmm1\nmulsd  (%rsp),%xmm1\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\ndivsd  %xmm1,%xmm0\njmp    1ba0 <libmin_acos>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "get_cross_matrix", "content": "/**\n * The cross product of vectors can be represented as a matrix\n * multiplication operation. This function obtains the `3x3` matrix\n * of the cross-product operator from the first vector.\n * @f[\\begin{align*}\n * \\left(\\vec{a}\\times\\right)\\vec{b} &= \\tilde{A}_a\\vec{b}\\\\\n * \\tilde{A}_a &=\n * \\begin{bmatrix}0&-a_z&a_y\\\\a_z&0&-a_x\\\\-a_y&a_x&0\\end{bmatrix}\n * \\end{align*}@f]\n * @param[in] a input vector\n * @returns the `3x3` matrix for the cross product operator\n * @f$\\left(\\vec{a}\\times\\right)@f$\n */\nmat_3x3 get_cross_matrix(const vec_3d *a)\n{\n    mat_3x3 A = {{{0., -a->z, a->y}}, {{a->z, 0., -a->x}}, {{-a->y, a->x, 0.}}};\n    return A;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O3.pseudo", "function_name": "get_cross_matrix", "address": "0x1850", "label": "get_cross_matrix", "content": "mat_3x3 *__fastcall get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a)\n{\n  double z; // xmm3_8\n  double x; // xmm2_8\n  mat_3x3 *result; // rax\n  double y; // xmm0_8\n\n  z = a->z;\n  x = a->x;\n  result = retstr;\n  retstr->row1[0] = 0.0;\n  y = a->y;\n  *(_OWORD *)retstr->row2 = *(unsigned __int64 *)&z;\n  retstr->row1[2] = y;\n  retstr->row3[2] = 0.0;\n  retstr->row1[1] = -z;\n  retstr->row2[2] = -x;\n  retstr->row3[0] = -y;\n  retstr->row3[1] = x;\n  return result;\n}\n"}, "pseudo_normalize": "mat_3x3 *get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a) {\n  double z;\n  double x;\n  mat_3x3 *result;\n  double y;\n  z = a->z;\n  x = a->x;\n  result = retstr;\n  retstr->row1[0] = 0.0;\n  y = a->y;\n  *(long double *)retstr->row2 = *(unsigned long long *)&z;\n  retstr->row1[2] = y;\n  retstr->row3[2] = 0.0;\n  retstr->row1[1] = -z;\n  retstr->row2[2] = -x;\n  retstr->row3[0] = -y;\n  retstr->row3[1] = x;\n  return result;\n}", "binary": "vectors-3d/vectors-3d.host.O3", "assembly": "<get_cross_matrix>:\nendbr64\nmovsd  0x10(%rsi),%xmm3\nmovsd  (%rsi),%xmm2\nmov    %rdi,%rax\nmovq   $0x0,(%rdi)\nmovq   0x3831(%rip),%xmm1\nmovsd  0x8(%rsi),%xmm0\nmovq   $0x0,0x20(%rdi)\nmovapd %xmm3,%xmm4\nmovsd  %xmm3,0x18(%rdi)\nmovapd %xmm2,%xmm3\nxorpd  %xmm1,%xmm4\nmovsd  %xmm0,0x10(%rdi)\nxorpd  %xmm1,%xmm3\nxorpd  %xmm1,%xmm0\nmovq   $0x0,0x40(%rdi)\nmovsd  %xmm4,0x8(%rdi)\nmovsd  %xmm3,0x28(%rdi)\nmovsd  %xmm0,0x30(%rdi)\nmovsd  %xmm2,0x38(%rdi)\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "main", "content": "/**\n * @brief Main function\n *\n * @return 0 on exit\n */\nint main(void)\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm1_8\n  double v4; // xmm1_8\n  double v5; // xmm1_8\n  double v6; // xmm1_8\n  double v7; // [rsp+8h] [rbp-70h]\n  double v8; // [rsp+8h] [rbp-70h]\n  double angle; // [rsp+8h] [rbp-70h]\n  double v10; // [rsp+18h] [rbp-60h]\n  vec_3d a; // [rsp+20h] [rbp-58h] BYREF\n  vec_3d b; // [rsp+40h] [rbp-38h] BYREF\n  unsigned __int64 v13; // [rsp+58h] [rbp-20h]\n\n  v13 = __readfsqword(0x28u);\n  *(_OWORD *)&a.x = xmmword_50B0;\n  b.z = 1.0;\n  *(_OWORD *)&b.x = xmmword_50C0;\n  a.z = 3.0;\n  libmin_snprintf(vec_str_0, 0x63uLL, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", \"a\", 1.0, 2.0, 3.0);\n  libmin_printf(\"%s\", vec_str_0);\n  libmin_snprintf(vec_str_0, 0x63uLL, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", \"b\", 1.0, 1.0, 1.0);\n  libmin_printf(\"%s\", vec_str_0);\n  v3 = 1.0 * 1.0 + 2.0 * 2.0;\n  v7 = libmin_sqrt(v3);\n  libmin_printf(\"|a| = %.4lf\\n\", v7);\n  if ( libmin_fabs(v3) < 0.01 )\n  {\n    v4 = b.x * b.x + b.y * b.y;\n    v8 = libmin_sqrt(v4);\n    libmin_printf(\"|b| = %.4lf\\n\", v8);\n    if ( libmin_fabs(v4) < 0.01 )\n    {\n      v5 = a.y * b.y + a.x * b.x;\n      libmin_printf(\"Dot product: %lf\\n\", a.z * b.z + v5);\n      if ( libmin_fabs(v5) < 0.01 )\n      {\n        v10 = a.z * b.x - b.z * a.x;\n        libmin_printf(\"Vector product \");\n        libmin_snprintf(\n          vec_str_0,\n          0x63uLL,\n          \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\",\n          \"c\",\n          a.y * b.z - a.z * b.y,\n          v10,\n          b.y * a.x - a.y * b.x);\n        libmin_printf(\"%s\", vec_str_0);\n        if ( libmin_fabs(v10) < 0.01 )\n        {\n          v6 = v10 - 2.0;\n          if ( libmin_fabs(v10 - 2.0) < 0.01 )\n          {\n            if ( libmin_fabs(v6) < 0.01 )\n            {\n              angle = get_angle(&a, &b);\n              libmin_printf(\"The angle is %lf\\n\", angle);\n              if ( libmin_fabs(v6) < 0.01 )\n              {\n                libmin_printf(\"All tests passed!\\n\");\n                libmin_success();\n              }\n              libmin_fail(1);\n            }\n            libmin_fail(1);\n          }\n          libmin_fail(1);\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  double v4;\n  double v5;\n  double v6;\n  double v7;\n  double v8;\n  double angle;\n  double v10;\n  vec_3d a;\n  vec_3d b;\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  *(long double *)&a.x = xmmword_50B0;\n  b.z = 1.0;\n  *(long double *)&b.x = xmmword_50C0;\n  a.z = 3.0;\n  libmin_snprintf(vec_str_0, 99uLL,\n                  \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", \"a\", 1.0, 2.0,\n                  3.0);\n  libmin_printf(\"%s\", vec_str_0);\n  libmin_snprintf(vec_str_0, 99uLL,\n                  \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", \"b\", 1.0, 1.0,\n                  1.0);\n  libmin_printf(\"%s\", vec_str_0);\n  v3 = 1.0 * 1.0 + 2.0 * 2.0;\n  v7 = libmin_sqrt(v3);\n  libmin_printf(\"|a| = %.4lf\\n\", v7);\n  if (libmin_fabs(v3) < 0.01) {\n    v4 = b.x * b.x + b.y * b.y;\n    v8 = libmin_sqrt(v4);\n    libmin_printf(\"|b| = %.4lf\\n\", v8);\n    if (libmin_fabs(v4) < 0.01) {\n      v5 = a.y * b.y + a.x * b.x;\n      libmin_printf(\"Dot product: %lf\\n\", a.z * b.z + v5);\n      if (libmin_fabs(v5) < 0.01) {\n        v10 = a.z * b.x - b.z * a.x;\n        libmin_printf(\"Vector product \");\n        libmin_snprintf(vec_str_0, 99uLL,\n                        \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", \"c\",\n                        a.y * b.z - a.z * b.y, v10, b.y * a.x - a.y * b.x);\n        libmin_printf(\"%s\", vec_str_0);\n        if (libmin_fabs(v10) < 0.01) {\n          v6 = v10 - 2.0;\n          if (libmin_fabs(v10 - 2.0) < 0.01) {\n            if (libmin_fabs(v6) < 0.01) {\n              angle = get_angle(&a, &b);\n              libmin_printf(\"The angle is %lf\\n\", angle);\n              if (libmin_fabs(v6) < 0.01) {\n                libmin_printf(\"All tests passed!\\n\");\n                libmin_success();\n              }\n              libmin_fail(1);\n            }\n            libmin_fail(1);\n          }\n          libmin_fail(1);\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}", "binary": "vectors-3d/vectors-3d.host.O3", "assembly": "<main>:\nendbr64\npush   %r13\nlea    0x3efb(%rip),%r13\nlea    0x3f1e(%rip),%rcx\nmov    $0x63,%esi\npush   %r12\nmov    %r13,%rdx\nlea    0x3f0f(%rip),%r12\npush   %rbp\nlea    0x6153(%rip),%rbp\nmov    %rbp,%rdi\nsub    $0x60,%rsp\nmovapd 0x3f74(%rip),%xmm0\nmovsd  0x3f9c(%rip),%xmm2\nmov    %fs:0x28,%rax\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nmov    0x3f55(%rip),%rax\nmovaps %xmm0,0x20(%rsp)\nmovapd 0x3f58(%rip),%xmm0\nmov    %rax,0x50(%rsp)\nmov    0x3f44(%rip),%rax\nmovaps %xmm0,0x40(%rsp)\nmovq   %rax,%xmm1\nmov    0x3f2b(%rip),%rax\nmovsd  %xmm2,0x30(%rsp)\nmovq   %rax,%xmm0\nmov    $0x3,%eax\ncall   3f70 <libmin_snprintf>\nmov    %rbp,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3e30 <libmin_printf>\nmovsd  0x50(%rsp),%xmm2\nmov    %r13,%rdx\nmovsd  0x48(%rsp),%xmm1\nmovsd  0x40(%rsp),%xmm0\nmov    $0x63,%esi\nmov    %rbp,%rdi\nmov    $0x3,%eax\nlea    0x3e67(%rip),%rcx\ncall   3f70 <libmin_snprintf>\nmov    %rbp,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3e30 <libmin_printf>\nmovsd  0x20(%rsp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x28(%rsp),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x30(%rsp),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncall   4040 <libmin_sqrt>\nlea    0x3e21(%rip),%rdi\nmov    $0x1,%eax\nmovsd  %xmm0,0x8(%rsp)\ncall   3e30 <libmin_printf>\nmovsd  0x8(%rsp),%xmm0\nsubsd  0x3eb2(%rip),%xmm0\ncall   1ee0 <libmin_fabs>\nmovsd  0x3ead(%rip),%xmm6\ncomisd %xmm0,%xmm6\njbe    14b4 <main+0x3b4>\nmovsd  0x40(%rsp),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x48(%rsp),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x50(%rsp),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncall   4040 <libmin_sqrt>\nlea    0x3dc3(%rip),%rdi\nmov    $0x1,%eax\nmovsd  %xmm0,0x8(%rsp)\ncall   3e30 <libmin_printf>\nmovsd  0x8(%rsp),%xmm0\nsubsd  0x3e57(%rip),%xmm0\ncall   1ee0 <libmin_fabs>\nmovsd  0x3e42(%rip),%xmm7\ncomisd %xmm0,%xmm7\njbe    1517 <main+0x417>\nmovsd  0x20(%rsp),%xmm0\nmovsd  0x28(%rsp),%xmm1\nmov    $0x1,%eax\nlea    0x3d83(%rip),%rdi\nmulsd  0x40(%rsp),%xmm0\nmulsd  0x48(%rsp),%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x30(%rsp),%xmm0\nmulsd  0x50(%rsp),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncall   3e30 <libmin_printf>\nmovsd  0x8(%rsp),%xmm0\nsubsd  0x3df7(%rip),%xmm0\ncall   1ee0 <libmin_fabs>\nmovsd  0x3dda(%rip),%xmm6\ncomisd %xmm0,%xmm6\njbe    1508 <main+0x408>\nmovsd  0x28(%rsp),%xmm2\nmovsd  0x30(%rsp),%xmm1\nxor    %eax,%eax\nlea    0x3d30(%rip),%rdi\nmovsd  0x50(%rsp),%xmm4\nmovsd  0x48(%rsp),%xmm3\nmovapd %xmm2,%xmm0\nmovapd %xmm1,%xmm5\nmulsd  %xmm3,%xmm5\nmulsd  %xmm4,%xmm0\nsubsd  %xmm5,%xmm0\nmovsd  0x20(%rsp),%xmm5\nmulsd  %xmm5,%xmm4\nmovsd  %xmm0,0x8(%rsp)\nmovsd  0x40(%rsp),%xmm0\nmulsd  %xmm5,%xmm3\nmulsd  %xmm0,%xmm2\nmulsd  %xmm0,%xmm1\nsubsd  %xmm2,%xmm3\nsubsd  %xmm4,%xmm1\nmovsd  %xmm3,0x10(%rsp)\nmovsd  %xmm1,0x18(%rsp)\ncall   3e30 <libmin_printf>\nmovsd  0x18(%rsp),%xmm1\nmov    %r13,%rdx\nmovsd  0x10(%rsp),%xmm2\nmovsd  0x8(%rsp),%xmm0\nmov    $0x63,%esi\nmov    %rbp,%rdi\nmov    $0x3,%eax\nlea    0x3cbc(%rip),%rcx\ncall   3f70 <libmin_snprintf>\nmov    %rbp,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3e30 <libmin_printf>\nmovsd  0x3cdd(%rip),%xmm0\naddsd  0x8(%rsp),%xmm0\ncall   1ee0 <libmin_fabs>\nmovsd  0x3d0a(%rip),%xmm6\nmovsd  0x18(%rsp),%xmm1\ncomisd %xmm0,%xmm6\njbe    14ed <main+0x3ed>\nsubsd  0x3cba(%rip),%xmm1\nmovapd %xmm1,%xmm0\ncall   1ee0 <libmin_fabs>\nmovsd  0x3ce1(%rip),%xmm7\ncomisd %xmm0,%xmm7\njbe    14de <main+0x3de>\nmovsd  0x3c8f(%rip),%xmm0\naddsd  0x10(%rsp),%xmm0\ncall   1ee0 <libmin_fabs>\nmovsd  0x3cbc(%rip),%xmm6\ncomisd %xmm0,%xmm6\njbe    14cf <main+0x3cf>\nlea    0x40(%rsp),%rsi\nlea    0x20(%rsp),%rdi\ncall   18c0 <get_angle>\nlea    0x3c23(%rip),%rdi\nmov    $0x1,%eax\nmovsd  %xmm0,0x8(%rsp)\ncall   3e30 <libmin_printf>\nmovsd  0x8(%rsp),%xmm0\nsubsd  0x3c96(%rip),%xmm0\ncall   1ee0 <libmin_fabs>\nmovsd  0x3c71(%rip),%xmm7\ncomisd %xmm0,%xmm7\njbe    14c3 <main+0x3c3>\nlea    0x3bfd(%rip),%rdi\nxor    %eax,%eax\ncall   3e30 <libmin_printf>\ncall   4290 <libmin_success>\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1526 <main+0x426>\nadd    $0x60,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    $0x1,%edi\ncall   1f20 <libmin_fail>\njmp    124d <main+0x14d>\nmov    $0x1,%edi\ncall   1f20 <libmin_fail>\njmp    1485 <main+0x385>\nmov    $0x1,%edi\ncall   1f20 <libmin_fail>\njmp    143e <main+0x33e>\nmov    $0x1,%edi\ncall   1f20 <libmin_fail>\njmp    1419 <main+0x319>\nmov    $0x1,%edi\nmovsd  %xmm1,0x8(%rsp)\ncall   1f20 <libmin_fail>\nmovsd  0x8(%rsp),%xmm1\njmp    13f6 <main+0x2f6>\nmov    $0x1,%edi\ncall   1f20 <libmin_fail>\njmp    1320 <main+0x220>\nmov    $0x1,%edi\ncall   1f20 <libmin_fail>\njmp    12b8 <main+0x1b8>\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "print_vector", "content": "/**\n * Print formatted vector on stdout.\n * @param[in] a vector to print\n * @param[in] name  name of the vector\n * @returns string representation of vector\n */\nconst char *print_vector(const vec_3d *a, const char *name)\n{\n    static char vec_str[100];  // static to ensure the string life extends the\n                               // life of function\n\n    libmin_snprintf(vec_str, 99, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x,\n             a->y, a->z);\n    return vec_str;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O3.pseudo", "function_name": "print_vector", "address": "0x1730", "label": "print_vector", "content": "const char *__fastcall print_vector(const vec_3d *a, const char *name)\n{\n  libmin_snprintf(vec_str_0, 0x63uLL, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x, a->y, a->z);\n  return vec_str_0;\n}\n"}, "pseudo_normalize": "const char *print_vector(const vec_3d *a, const char *name) {\n  libmin_snprintf(vec_str_0, 99uLL,\n                  \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x,\n                  a->y, a->z);\n  return vec_str_0;\n}", "binary": "vectors-3d/vectors-3d.host.O3", "assembly": "<print_vector>:\nendbr64\npush   %r12\nlea    0x5b43(%rip),%r12\nmovsd  (%rdi),%xmm0\nmov    %rsi,%rcx\nmovsd  0x10(%rdi),%xmm2\nmovsd  0x8(%rdi),%xmm1\nmov    $0x63,%esi\nmov    %r12,%rdi\nlea    0x38ab(%rip),%rdx\nmov    $0x3,%eax\ncall   3f70 <libmin_snprintf>\nmov    %r12,%rax\npop    %r12\nret\nnopl   (%rax)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "unit_vec", "content": "/**\n * Obtain unit vector in the same direction as given vector.\n * @f[\\hat{a}=\\frac{\\vec{a}}{\\lVert\\vec{a}\\rVert}@f]\n * @param[in] a input vector\n * @returns n unit vector in the direction of @f$\\vec{a}@f$\n */\nvec_3d unit_vec(const vec_3d *a)\n{\n    vec_3d n = {0};\n\n    double norm = vector_norm(a);\n    if (libmin_fabs(norm) < EPSILON)\n    {  // detect possible divide by 0\n        return n;\n    }\n\n    if (norm != 1.0)  // perform division only if needed\n    {\n        n.x = a->x / norm;\n        n.y = a->y / norm;\n        n.z = a->z / norm;\n    }\n    return n;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O3.pseudo", "function_name": "unit_vec", "address": "0x17a0", "label": "unit_vec", "content": "vec_3d *__fastcall unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a)\n{\n  double v2; // xmm1_8\n  __m128d v3; // xmm0\n  __m128d v4; // xmm2\n  double v5; // xmm0_8\n  vec_3d *result; // rax\n  double norm; // [rsp+8h] [rbp-30h]\n  __m128d v8; // [rsp+10h] [rbp-28h]\n\n  v2 = a->x * a->x + a->y * a->y;\n  v3 = (__m128d)*(unsigned __int64 *)&a->z;\n  v3.m128d_f64[0] = libmin_sqrt(v2);\n  norm = v3.m128d_f64[0];\n  v8 = _mm_unpacklo_pd(v3, v3);\n  if ( libmin_fabs(v2) < 0.000000001 || norm == 1.0 )\n  {\n    v4 = 0LL;\n    v5 = 0.0;\n  }\n  else\n  {\n    v4 = _mm_div_pd(*(__m128d *)&a->x, v8);\n    v5 = a->z / norm;\n  }\n  *(__m128d *)&retstr->x = v4;\n  result = retstr;\n  retstr->z = v5;\n  return result;\n}\n"}, "pseudo_normalize": "vec_3d *unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a) {\n  double v2;\n  __m128d v3;\n  __m128d v4;\n  double v5;\n  vec_3d *result;\n  double norm;\n  __m128d v8;\n  v2 = a->x * a->x + a->y * a->y;\n  v3 = (__m128d) * (unsigned long long *)&a->z;\n  v3.m128d_f64[0] = libmin_sqrt(v2);\n  norm = v3.m128d_f64[0];\n  v8 = _mm_unpacklo_pd(v3, v3);\n  if (libmin_fabs(v2) < 0.000000001 || norm == 1.0) {\n    v4 = 0LL;\n    v5 = 0.0;\n  } else {\n    v4 = _mm_div_pd(*(__m128d *)&a->x, v8);\n    v5 = a->z / norm;\n  }\n  *(__m128d *)&retstr->x = v4;\n  result = retstr;\n  retstr->z = v5;\n  return result;\n}", "binary": "vectors-3d/vectors-3d.host.O3", "assembly": "<unit_vec>:\nendbr64\npush   %r12\nmov    %rdi,%r12\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x28,%rsp\nmovsd  (%rsi),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x8(%rsi),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rsi),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncall   4040 <libmin_sqrt>\nmovapd %xmm0,%xmm3\nmovsd  %xmm0,0x8(%rsp)\nunpcklpd %xmm3,%xmm3\nmovaps %xmm3,0x10(%rsp)\ncall   1ee0 <libmin_fabs>\nmovsd  0x38d4(%rip),%xmm2\ncomisd %xmm0,%xmm2\nja     1814 <unit_vec+0x74>\nmovsd  0x8(%rsp),%xmm1\nucomisd 0x38a0(%rip),%xmm1\njp     1838 <unit_vec+0x98>\njne    1838 <unit_vec+0x98>\npxor   %xmm2,%xmm2\npxor   %xmm0,%xmm0\nmovups %xmm2,(%r12)\nmov    %r12,%rax\nmovsd  %xmm0,0x10(%r12)\nadd    $0x28,%rsp\npop    %rbx\npop    %r12\nret\nnopl   0x0(%rax,%rax,1)\nmovsd  0x10(%rbx),%xmm0\nmovupd (%rbx),%xmm2\ndivpd  0x10(%rsp),%xmm2\ndivsd  %xmm1,%xmm0\njmp    181c <unit_vec+0x7c>\nnopl   (%rax)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "vector_add", "content": "/**\n * Add one vector to another. @f[\n * \\vec{c}=\\vec{a}+\\vec{b}=\\left(a_x+b_x\\right)\\hat{i}+\n * \\left(a_y+b_y\\right)\\hat{j}+\\left(a_z+b_z\\right)\\hat{k}@f]\n * @param[in] a vector to add to\n * @param[in] b vector to add\n * @returns resultant vector\n */\nvec_3d vector_add(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;\n    out.x = a->x + b->x;\n    out.y = a->y + b->y;\n    out.z = a->z + b->z;\n\n    return out;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O3.pseudo", "function_name": "vector_add", "address": "0x1650", "label": "vector_add", "content": "vec_3d *__fastcall vector_add(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  vec_3d *result; // rax\n  __m128d v4; // xmm1\n\n  result = retstr;\n  v4 = _mm_add_pd(*(__m128d *)&a->x, *(__m128d *)&b->x);\n  retstr->z = a->z + b->z;\n  *(__m128d *)&retstr->x = v4;\n  return result;\n}\n"}, "pseudo_normalize": "vec_3d *vector_add(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  vec_3d *result;\n  __m128d v4;\n  result = retstr;\n  v4 = _mm_add_pd(*(__m128d *)&a->x, *(__m128d *)&b->x);\n  retstr->z = a->z + b->z;\n  *(__m128d *)&retstr->x = v4;\n  return result;\n}", "binary": "vectors-3d/vectors-3d.host.O3", "assembly": "<vector_add>:\nendbr64\nmovupd (%rsi),%xmm1\nmovupd (%rdx),%xmm2\nmov    %rdi,%rax\nmovsd  0x10(%rsi),%xmm0\naddsd  0x10(%rdx),%xmm0\naddpd  %xmm2,%xmm1\nmovsd  %xmm0,0x10(%rdi)\nmovups %xmm1,(%rdi)\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "vector_norm", "content": "/**\n * Compute the norm a vector.\n * @f[\\lVert\\vec{a}\\rVert = \\sqrt{\\vec{a}\\cdot\\vec{a}} @f]\n * @param[in] a input vector\n * @returns norm of the given vector\n */\ndouble vector_norm(const vec_3d *a)\n{\n    double n = dot_prod(a, a);\n    n = libmin_sqrt(n);\n\n    return n;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O3.pseudo", "function_name": "vector_norm", "address": "0x1770", "label": "vector_norm", "content": "double __fastcall vector_norm(const vec_3d *a)\n{\n  return libmin_sqrt(a->x * a->x + a->y * a->y);\n}\n"}, "pseudo_normalize": "", "binary": "vectors-3d/vectors-3d.host.O3", "assembly": "<vector_norm>:\nendbr64\nmovsd  (%rdi),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x8(%rdi),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rdi),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\njmp    4040 <libmin_sqrt>\nnop\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "vector_prod", "content": "/**\n * Compute the vector product of two 3d vectors.\n * @f[\\begin{align*}\n * \\vec{a}\\times\\vec{b} &= \\begin{vmatrix}\n *  \\hat{i} & \\hat{j} & \\hat{k}\\\\\n *  a_x & a_y & a_z\\\\\n *  b_x & b_y & b_z\n *  \\end{vmatrix}\\\\\n *  &= \\left(a_yb_z-b_ya_z\\right)\\hat{i} - \\left(a_xb_z-b_xa_z\\right)\\hat{j}\n * + \\left(a_xb_y-b_xa_y\\right)\\hat{k} \\end{align*}\n * @f]\n * @param[in] a first vector @f$\\vec{a}@f$\n * @param[in] b second vector @f$\\vec{b}@f$\n * @returns resultant vector @f$\\vec{o}=\\vec{a}\\times\\vec{b}@f$\n */\nvec_3d vector_prod(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;  // better this way to avoid copying results to input\n                 // vectors themselves\n    out.x = a->y * b->z - a->z * b->y;\n    out.y = -a->x * b->z + a->z * b->x;\n    out.z = a->x * b->y - a->y * b->x;\n\n    return out;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O3.pseudo", "function_name": "vector_prod", "address": "0x16b0", "label": "vector_prod", "content": "vec_3d *__fastcall vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  double x; // xmm4_8\n  vec_3d *result; // rax\n  __m128d v5; // xmm3\n  __m128d v6; // xmm2\n  double v7; // xmm6_8\n  double v8; // xmm0_8\n  __m128d v9; // xmm5\n  __m128d v10; // xmm1\n\n  x = a->x;\n  result = retstr;\n  v5 = (__m128d)*(unsigned __int64 *)&a->y;\n  v6 = _mm_mul_pd(\n         _mm_shuffle_pd(*(__m128d *)&b->x, *(__m128d *)&b->x, 1),\n         _mm_unpacklo_pd((__m128d)*(unsigned __int64 *)&a->z, (__m128d)*(unsigned __int64 *)&a->z));\n  v7 = _mm_unpackhi_pd(*(__m128d *)&b->x, *(__m128d *)&b->x).m128d_f64[0];\n  v8 = b->x * v5.m128d_f64[0];\n  v9 = _mm_mul_pd(\n         _mm_unpacklo_pd(v5, _mm_xor_pd((__m128d)*(unsigned __int64 *)&a->x, (__m128d)xmmword_50A0)),\n         _mm_unpacklo_pd((__m128d)*(unsigned __int64 *)&b->z, (__m128d)*(unsigned __int64 *)&b->z));\n  v10 = _mm_add_pd(v9, v6);\n  v10.m128d_f64[0] = v9.m128d_f64[0] - v6.m128d_f64[0];\n  *(__m128d *)&retstr->x = v10;\n  retstr->z = v7 * x - v8;\n  return result;\n}\n"}, "pseudo_normalize": "vec_3d *vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a,\n                    const vec_3d *b) {\n  double x;\n  vec_3d *result;\n  __m128d v5;\n  __m128d v6;\n  double v7;\n  double v8;\n  __m128d v9;\n  __m128d v10;\n  x = a->x;\n  result = retstr;\n  v5 = (__m128d) * (unsigned long long *)&a->y;\n  v6 = _mm_mul_pd(_mm_shuffle_pd(*(__m128d *)&b->x, *(__m128d *)&b->x, 1),\n                  _mm_unpacklo_pd((__m128d) * (unsigned long long *)&a->z,\n                                  (__m128d) * (unsigned long long *)&a->z));\n  v7 = _mm_unpackhi_pd(*(__m128d *)&b->x, *(__m128d *)&b->x).m128d_f64[0];\n  v8 = b->x * v5.m128d_f64[0];\n  v9 = _mm_mul_pd(\n      _mm_unpacklo_pd(v5, _mm_xor_pd((__m128d) * (unsigned long long *)&a->x,\n                                     (__m128d)xmmword_50A0)),\n      _mm_unpacklo_pd((__m128d) * (unsigned long long *)&b->z,\n                      (__m128d) * (unsigned long long *)&b->z));\n  v10 = _mm_add_pd(v9, v6);\n  v10.m128d_f64[0] = v9.m128d_f64[0] - v6.m128d_f64[0];\n  *(__m128d *)&retstr->x = v10;\n  retstr->z = v7 * x - v8;\n  return result;\n}", "binary": "vectors-3d/vectors-3d.host.O3", "assembly": "<vector_prod>:\nendbr64\nmovupd (%rdx),%xmm0\nmovsd  (%rsi),%xmm4\nmov    %rdi,%rax\nmovsd  0x10(%rsi),%xmm1\nmovsd  0x8(%rsi),%xmm3\nmovapd %xmm0,%xmm2\nmovapd %xmm4,%xmm5\nxorpd  0x39c7(%rip),%xmm5\nunpcklpd %xmm1,%xmm1\nshufpd $0x1,%xmm0,%xmm2\nmovapd %xmm0,%xmm6\nmulpd  %xmm1,%xmm2\nmovapd %xmm3,%xmm1\nunpckhpd %xmm6,%xmm6\nmulsd  %xmm3,%xmm0\nunpcklpd %xmm5,%xmm1\nmovsd  0x10(%rdx),%xmm5\nunpcklpd %xmm5,%xmm5\nmulpd  %xmm5,%xmm1\nmovapd %xmm1,%xmm5\naddpd  %xmm2,%xmm1\nsubpd  %xmm2,%xmm5\nmovsd  %xmm5,%xmm1\nmovups %xmm1,(%rdi)\nmovapd %xmm6,%xmm1\nmulsd  %xmm4,%xmm1\nsubsd  %xmm0,%xmm1\nmovsd  %xmm1,0x10(%rdi)\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "vector_sub", "content": "/**\n * @addtogroup vec_3d 3D Vector operations\n * @{\n */\n\n/**\n * Subtract one vector from another. @f[\n * \\vec{c}=\\vec{a}-\\vec{b}=\\left(a_x-b_x\\right)\\hat{i}+\n * \\left(a_y-b_y\\right)\\hat{j}+\\left(a_z-b_z\\right)\\hat{k}@f]\n * @param[in] a vector to subtract from\n * @param[in] b vector to subtract\n * @returns resultant vector\n */\nvec_3d vector_sub(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;\n    out.x = a->x - b->x;\n    out.y = a->y - b->y;\n    out.z = a->z - b->z;\n\n    return out;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O3.pseudo", "function_name": "vector_sub", "address": "0x1620", "label": "vector_sub", "content": "vec_3d *__fastcall vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  vec_3d *result; // rax\n  __m128d v4; // xmm1\n\n  result = retstr;\n  v4 = _mm_sub_pd(*(__m128d *)&a->x, *(__m128d *)&b->x);\n  retstr->z = a->z - b->z;\n  *(__m128d *)&retstr->x = v4;\n  return result;\n}\n"}, "pseudo_normalize": "vec_3d *vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  vec_3d *result;\n  __m128d v4;\n  result = retstr;\n  v4 = _mm_sub_pd(*(__m128d *)&a->x, *(__m128d *)&b->x);\n  retstr->z = a->z - b->z;\n  *(__m128d *)&retstr->x = v4;\n  return result;\n}", "binary": "vectors-3d/vectors-3d.host.O3", "assembly": "<vector_sub>:\nendbr64\nmovupd (%rsi),%xmm1\nmovupd (%rdx),%xmm2\nmov    %rdi,%rax\nmovsd  0x10(%rsi),%xmm0\nsubsd  0x10(%rdx),%xmm0\nsubpd  %xmm2,%xmm1\nmovsd  %xmm0,0x10(%rdi)\nmovups %xmm1,(%rdi)\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "verlet/verlet.c", "function_name": "main", "content": " /* for NO_STDIO mode */\n\nint main(void) {\n  vb_init();\n\n  for (int s = 0; s < VB_STEPS; ++s) {\n    vb_step_avg((VB_FP)VB_DT);\n  }\n  uint64_t sum = vb_checksum();\n\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\",\n         VB_N, VB_STEPS, (double)VB_DT, (double)VB_K, VB_DIM,\n         (sizeof(VB_FP)==sizeof(double)) ? \"double\" : \"float\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", (uint32_t)((sum >> 32)), (uint32_t)(sum & (uint32_t)0xffffffffU));\n\n  libmin_success();\n}\n"}, "pseudo": {"path": "verlet/verlet.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rdi\n  int v4; // ecx\n  __m128i v5; // xmm7\n  __m128i v6; // xmm6\n  unsigned int v7; // ecx\n  unsigned int v8; // eax\n  unsigned int v9; // esi\n  __m128i v10; // xmm0\n  unsigned int v11; // esi\n  __m128d v12; // xmm1\n  __m128d v13; // xmm0\n  __m128d v14; // xmm1\n  int v15; // r11d\n  __int64 v16; // rax\n  __int64 i; // rax\n  __int64 j; // rax\n  __int64 v19; // rcx\n  unsigned __int64 v20; // rbx\n  __int64 v21; // rdi\n  double v22; // xmm1_8\n  unsigned __int64 v23; // rax\n\n  v3 = 0LL;\n  v4 = 305419896;\n  v5 = _mm_loadl_epi64((const __m128i *)&qword_4058);\n  v6 = _mm_loadl_epi64((const __m128i *)&qword_4060);\n  do\n  {\n    v7 = 1664525 * v4;\n    v8 = 1664525 * (v7 + 1013904223);\n    v9 = 1664525 * (v8 + 1013904223);\n    v10 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v7), _mm_cvtsi32_si128(v9));\n    v11 = 1664525 * (v9 + 1013904223);\n    v4 = v11 + 1013904223;\n    v12 = _mm_mul_pd(_mm_cvtepi32_pd(_mm_and_si128(_mm_add_epi32(v10, v5), v6)), (__m128d)xmmword_4080);\n    v13 = _mm_mul_pd(\n            _mm_cvtepi32_pd(_mm_and_si128(_mm_add_epi32(_mm_unpacklo_epi32(_mm_cvtsi32_si128(v8), _mm_cvtsi32_si128(v11)), v5), v6)),\n            (__m128d)xmmword_4080);\n    v14 = _mm_add_pd(_mm_add_pd(v12, v12), (__m128d)xmmword_4090);\n    *(__m128d *)&x[v3] = v14;\n    *(__m128d *)&a[v3] = _mm_mul_pd(v14, (__m128d)xmmword_40B0);\n    *(__m128d *)&v[v3] = _mm_mul_pd(_mm_add_pd(_mm_add_pd(v13, v13), (__m128d)xmmword_4090), (__m128d)xmmword_40A0);\n    v3 += 2LL;\n  }\n  while ( v3 != 256 );\n  v15 = 50;\n  do\n  {\n    v16 = 0LL;\n    qmemcpy(&a_old_0, a, 0x800uLL);\n    do\n    {\n      *(__m128d *)&x[v16] = _mm_add_pd(\n                              _mm_add_pd(_mm_mul_pd(*(__m128d *)&v[v16], (__m128d)xmmword_40C0), *(__m128d *)&x[v16]),\n                              _mm_mul_pd(*(__m128d *)((char *)&a_old_0 + v16 * 8), (__m128d)xmmword_40D0));\n      v16 += 2LL;\n    }\n    while ( v16 != 256 );\n    for ( i = 0LL; i != 256; i += 2LL )\n      *(__m128d *)&a[i] = _mm_mul_pd(*(__m128d *)&x[i], (__m128d)xmmword_40B0);\n    for ( j = 0LL; j != 256; j += 2LL )\n      *(__m128d *)&v[j] = _mm_add_pd(\n                            _mm_mul_pd(\n                              _mm_mul_pd(\n                                _mm_add_pd(*(__m128d *)&a[j], *(__m128d *)((char *)&a_old_0 + j * 8)),\n                                (__m128d)xmmword_40E0),\n                              (__m128d)xmmword_40C0),\n                            *(__m128d *)&v[j]);\n    --v15;\n  }\n  while ( v15 );\n  v19 = 0LL;\n  v20 = 0xCBF29CE484222325LL;\n  do\n  {\n    v21 = (unsigned int)(int)(x[v19] * 1000000.0);\n    v22 = v[v19++];\n    v23 = v20 ^ (v21 + (v20 >> 2) + (v20 << 6) - 0x61C8864680B583EBLL);\n    v20 = v23 ^ ((v23 >> 2) + (v23 << 6) + (unsigned int)(int)(v22 * 1000000.0) - 0x61C8864680B583EBLL);\n  }\n  while ( v19 != 256 );\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50, 0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(v20), v20);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  __m128i v5;\n  __m128i v6;\n  unsigned int v7;\n  unsigned int v8;\n  unsigned int v9;\n  __m128i v10;\n  unsigned int v11;\n  __m128d v12;\n  __m128d v13;\n  __m128d v14;\n  int v15;\n  long long v16;\n  long long i;\n  long long j;\n  long long v19;\n  unsigned long long v20;\n  long long v21;\n  double v22;\n  unsigned long long v23;\n  v3 = 0LL;\n  v4 = 305419896;\n  v5 = _mm_loadl_epi64((const __m128i *)&qword_4058);\n  v6 = _mm_loadl_epi64((const __m128i *)&qword_4060);\n  do {\n    v7 = 1664525 * v4;\n    v8 = 1664525 * (v7 + 1013904223);\n    v9 = 1664525 * (v8 + 1013904223);\n    v10 = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v7), _mm_cvtsi32_si128(v9));\n    v11 = 1664525 * (v9 + 1013904223);\n    v4 = v11 + 1013904223;\n    v12 = _mm_mul_pd(_mm_cvtepi32_pd(_mm_and_si128(_mm_add_epi32(v10, v5), v6)),\n                     (__m128d)xmmword_4080);\n    v13 =\n        _mm_mul_pd(_mm_cvtepi32_pd(_mm_and_si128(\n                       _mm_add_epi32(_mm_unpacklo_epi32(_mm_cvtsi32_si128(v8),\n                                                        _mm_cvtsi32_si128(v11)),\n                                     v5),\n                       v6)),\n                   (__m128d)xmmword_4080);\n    v14 = _mm_add_pd(_mm_add_pd(v12, v12), (__m128d)xmmword_4090);\n    *(__m128d *)&x[v3] = v14;\n    *(__m128d *)&a[v3] = _mm_mul_pd(v14, (__m128d)xmmword_40B0);\n    *(__m128d *)&v[v3] =\n        _mm_mul_pd(_mm_add_pd(_mm_add_pd(v13, v13), (__m128d)xmmword_4090),\n                   (__m128d)xmmword_40A0);\n    v3 += 2LL;\n  } while (v3 != 256);\n  v15 = 50;\n  do {\n    v16 = 0LL;\n    qmemcpy(&a_old_0, a, 2048uLL);\n    do {\n      *(__m128d *)&x[v16] = _mm_add_pd(\n          _mm_add_pd(_mm_mul_pd(*(__m128d *)&v[v16], (__m128d)xmmword_40C0),\n                     *(__m128d *)&x[v16]),\n          _mm_mul_pd(*(__m128d *)((char *)&a_old_0 + v16 * 8),\n                     (__m128d)xmmword_40D0));\n      v16 += 2LL;\n    } while (v16 != 256);\n    for (i = 0LL; i != 256; i += 2LL)\n      *(__m128d *)&a[i] = _mm_mul_pd(*(__m128d *)&x[i], (__m128d)xmmword_40B0);\n    for (j = 0LL; j != 256; j += 2LL)\n      *(__m128d *)&v[j] = _mm_add_pd(\n          _mm_mul_pd(\n              _mm_mul_pd(_mm_add_pd(*(__m128d *)&a[j],\n                                    *(__m128d *)((char *)&a_old_0 + j * 8)),\n                         (__m128d)xmmword_40E0),\n              (__m128d)xmmword_40C0),\n          *(__m128d *)&v[j]);\n    --v15;\n  } while (v15);\n  v19 = 0LL;\n  v20 = 14695981039346656037LL;\n  do {\n    v21 = (unsigned int)(int)(x[v19] * 1000000.0);\n    v22 = v[v19++];\n    v23 = v20 ^ (v21 + (v20 >> 2) + (v20 << 6) - 7046029254386353131LL);\n    v20 = v23 ^ ((v23 >> 2) + (v23 << 6) +\n                 (unsigned int)(int)(v22 * 1000000.0) - 7046029254386353131LL);\n  } while (v19 != 256);\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50,\n                0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(v20), v20);\n  libmin_success();\n}", "binary": "verlet/verlet.host.O3", "assembly": "<main>:\nendbr64\npush   %rbx\nmovapd 0x2f73(%rip),%xmm4\nxor    %edi,%edi\nmov    $0x12345678,%ecx\nmovq   0x2f3c(%rip),%xmm7\nmovapd 0x2f6c(%rip),%xmm2\nlea    0x6975(%rip),%r8\nlea    0x616e(%rip),%rdx\nmovq   0x2f26(%rip),%xmm6\nmovapd 0x2f5e(%rip),%xmm5\nlea    0x5957(%rip),%r9\nmovapd 0x2f5f(%rip),%xmm3\nimul   $0x19660d,%ecx,%ecx\nlea    0x3c6ef35f(%rcx),%eax\nmovd   %ecx,%xmm0\nimul   $0x19660d,%eax,%eax\nlea    0x3c6ef35f(%rax),%esi\nimul   $0x19660d,%esi,%esi\nmovd   %esi,%xmm1\nadd    $0x3c6ef35f,%esi\npunpckldq %xmm1,%xmm0\nimul   $0x19660d,%esi,%esi\npaddd  %xmm7,%xmm0\nmovd   %esi,%xmm8\nlea    0x3c6ef35f(%rsi),%ecx\npand   %xmm6,%xmm0\ncvtdq2pd %xmm0,%xmm1\nmulpd  %xmm4,%xmm1\nmovd   %eax,%xmm0\npunpckldq %xmm8,%xmm0\npaddd  %xmm7,%xmm0\npand   %xmm6,%xmm0\naddpd  %xmm1,%xmm1\ncvtdq2pd %xmm0,%xmm0\nmulpd  %xmm4,%xmm0\naddpd  %xmm2,%xmm1\naddpd  %xmm0,%xmm0\nmovaps %xmm1,(%r8,%rdi,1)\nmulpd  %xmm3,%xmm1\naddpd  %xmm2,%xmm0\nmovaps %xmm1,(%r9,%rdi,1)\nmulpd  %xmm5,%xmm0\nmovaps %xmm0,(%rdx,%rdi,1)\nadd    $0x10,%rdi\ncmp    $0x800,%rdi\njne    1151 <main+0x51>\nmovapd 0x2ec6(%rip),%xmm1\nmovapd 0x2ece(%rip),%xmm5\nmov    $0x32,%r11d\nlea    0x5091(%rip),%r10\nmovapd 0x2ec9(%rip),%xmm4\nmov    $0x100,%ecx\nmov    %r10,%rdi\nmov    %r9,%rsi\nxor    %eax,%eax\nrep movsq %ds:(%rsi),%es:(%rdi)\nnopw   0x0(%rax,%rax,1)\nmovapd (%r10,%rax,1),%xmm2\nmovapd (%rdx,%rax,1),%xmm0\nmulpd  %xmm5,%xmm2\nmulpd  %xmm1,%xmm0\naddpd  (%r8,%rax,1),%xmm0\naddpd  %xmm2,%xmm0\nmovaps %xmm0,(%r8,%rax,1)\nadd    $0x10,%rax\ncmp    $0x800,%rax\njne    1230 <main+0x130>\nxor    %eax,%eax\nmovapd (%r8,%rax,1),%xmm0\nmulpd  %xmm3,%xmm0\nmovaps %xmm0,(%r9,%rax,1)\nadd    $0x10,%rax\ncmp    $0x800,%rax\njne    1260 <main+0x160>\nxor    %eax,%eax\nnopl   (%rax)\nmovapd (%r9,%rax,1),%xmm0\naddpd  (%r10,%rax,1),%xmm0\nmulpd  %xmm4,%xmm0\nmulpd  %xmm1,%xmm0\naddpd  (%rdx,%rax,1),%xmm0\nmovaps %xmm0,(%rdx,%rax,1)\nadd    $0x10,%rax\ncmp    $0x800,%rax\njne    1280 <main+0x180>\nsub    $0x1,%r11d\njne    1217 <main+0x117>\nmovsd  0x2dad(%rip),%xmm0\nxor    %ecx,%ecx\nmovabs $0xcbf29ce484222325,%rbx\nmovabs $0x9e3779b97f4a7c15,%rsi\nmovsd  (%r8,%rcx,1),%xmm1\nmov    %rbx,%rax\nmov    %rbx,%rdi\nshr    $0x2,%rdi\nshl    $0x6,%rax\nmulsd  %xmm0,%xmm1\nadd    %rdi,%rax\nadd    %rsi,%rax\ncvttsd2si %xmm1,%rdi\nmovsd  (%rdx,%rcx,1),%xmm1\nadd    $0x8,%rcx\nmulsd  %xmm0,%xmm1\nadd    %rdi,%rax\nxor    %rbx,%rax\nmov    %rax,%rdi\ncvttsd2si %xmm1,%rbx\nshl    $0x6,%rdi\nadd    %rsi,%rbx\nadd    %rdi,%rbx\nmov    %rax,%rdi\nshr    $0x2,%rdi\nadd    %rdi,%rbx\nxor    %rax,%rbx\ncmp    $0x800,%rcx\njne    12d1 <main+0x1d1>\nmov    $0x2,%ecx\nmov    $0x32,%edx\nmov    $0x80,%esi\nmovsd  0x2d2a(%rip),%xmm1\nmovsd  0x2d72(%rip),%xmm0\nlea    0x2caf(%rip),%r8\nmov    $0x2,%eax\nlea    0x2cbf(%rip),%rdi\ncall   3550 <libmin_printf>\nmov    %ebx,%edx\nshr    $0x20,%rbx\nxor    %eax,%eax\nmov    %rbx,%rsi\nlea    0x2c93(%rip),%rdi\ncall   3550 <libmin_printf>\ncall   3790 <libmin_success>\nxor    %eax,%eax\npop    %rbx\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "weekday/weekday.c", "function_name": "dayOfWeek", "content": "#include \"libmin.h\"\n\nint\ndayOfWeek(int y, int m, int d)\n{\n  int t[]={0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};\n  y -= (m<3) ? 1 : 0;\n  return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;\n}\n"}, "pseudo": {"path": "weekday/weekday.host.O3.pseudo", "function_name": "dayOfWeek", "address": "0x1290", "label": "dayOfWeek", "content": "int __fastcall dayOfWeek(int y, int m, int d)\n{\n  int v4; // edi\n  int v5; // edx\n  __m128i si128; // xmm0\n  int t[12]; // [rsp+0h] [rbp-48h]\n  unsigned __int64 v9; // [rsp+38h] [rbp-10h]\n\n  v9 = __readfsqword(0x28u);\n  *(__m128i *)t = _mm_load_si128((const __m128i *)&xmmword_4040);\n  v4 = y - (m <= 2);\n  v5 = v4 + 3;\n  *(__m128i *)&t[4] = _mm_load_si128((const __m128i *)&xmmword_4050);\n  si128 = _mm_load_si128((const __m128i *)&xmmword_4060);\n  if ( v4 >= 0 )\n    v5 = v4;\n  *(__m128i *)&t[8] = si128;\n  return (d\n        + t[m - 1]\n        + ((int)((unsigned __int64)(1374389535LL * v4) >> 32) >> 7)\n        + v4\n        + (v5 >> 2)\n        - ((int)((unsigned __int64)(1374389535LL * v4) >> 32) >> 5))\n       % 7;\n}\n"}, "pseudo_normalize": "int dayOfWeek(int y, int m, int d) {\n  int v4;\n  int v5;\n  __m128i si128;\n  int t[12];\n  unsigned long long v9;\n  v9 = __readfsqword(40u);\n  *(__m128i *)t = _mm_load_si128((const __m128i *)&xmmword_4040);\n  v4 = y - (m <= 2);\n  v5 = v4 + 3;\n  *(__m128i *)&t[4] = _mm_load_si128((const __m128i *)&xmmword_4050);\n  si128 = _mm_load_si128((const __m128i *)&xmmword_4060);\n  if (v4 >= 0) v5 = v4;\n  *(__m128i *)&t[8] = si128;\n  return (d + t[m - 1] +\n          ((int)((unsigned long long)(1374389535LL * v4) >> 32) >> 7) + v4 +\n          (v5 >> 2) -\n          ((int)((unsigned long long)(1374389535LL * v4) >> 32) >> 5)) %\n         7;\n}", "binary": "weekday/weekday.host.O3", "assembly": "<dayOfWeek>:\nendbr64\nsub    $0x48,%rsp\nmov    %edx,%r8d\nmovdqa 0x2d9d(%rip),%xmm0\nmov    %esi,%eax\nmov    %fs:0x28,%rdx\nmov    %rdx,0x38(%rsp)\nxor    %edx,%edx\nxor    %edx,%edx\ncmp    $0x2,%esi\nsetle  %dl\nmovaps %xmm0,(%rsp)\nmovdqa 0x2d87(%rip),%xmm0\nsub    %edx,%edi\nlea    0x3(%rdi),%edx\nmovslq %edi,%rcx\nmovaps %xmm0,0x10(%rsp)\nmovdqa 0x2d82(%rip),%xmm0\ncmovns %edi,%edx\nimul   $0x51eb851f,%rcx,%rcx\nsub    $0x1,%eax\ncltq\nmovaps %xmm0,0x20(%rsp)\nsar    $0x2,%edx\nmov    %rcx,%rsi\nadd    %edi,%edx\nsar    $0x1f,%edi\nsar    $0x25,%rsi\nsar    $0x27,%rcx\nmov    %rsi,%r9\nmov    %edi,%esi\nsub    %edi,%ecx\nsub    %r9d,%esi\nadd    %esi,%edx\nadd    %ecx,%edx\nadd    (%rsp,%rax,4),%edx\nadd    %r8d,%edx\nmovslq %edx,%rax\nmov    %edx,%ecx\nimul   $0xffffffff92492493,%rax,%rax\nsar    $0x1f,%ecx\nshr    $0x20,%rax\nadd    %edx,%eax\nsar    $0x2,%eax\nsub    %ecx,%eax\nlea    0x0(,%rax,8),%ecx\nsub    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    0x38(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    1355 <dayOfWeek+0xc5>\nadd    $0x48,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "weekday/weekday.c", "function_name": "main", "content": "int\nmain(int argc, char** argv)\n{\n  const char *days[7]={\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[dayOfWeek(2024, 2, 20)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[dayOfWeek(1994, 4, 5)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[dayOfWeek(1975, 1, 1)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[dayOfWeek(1964, 2, 7)]);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "weekday/weekday.host.O3.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, \"Tuesday\");\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, \"Tuesday\");\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, \"Wednesday\");\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, \"Friday\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, \"Tuesday\");\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, \"Tuesday\");\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, \"Wednesday\");\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, \"Friday\");\n  libmin_success();\n}", "binary": "weekday/weekday.host.O3", "assembly": "<main>:\nendbr64\npush   %rbp\nlea    0x2f00(%rip),%rbp\nmov    $0x7e8,%ecx\nxor    %eax,%eax\nmov    %rbp,%rdi\nmov    $0x14,%edx\nmov    $0x2,%esi\nlea    0x2edd(%rip),%r8\ncall   3430 <libmin_printf>\nmov    %rbp,%rdi\nmov    $0x7ca,%ecx\nxor    %eax,%eax\nlea    0x2ec7(%rip),%r8\nmov    $0x5,%edx\nmov    $0x4,%esi\ncall   3430 <libmin_printf>\nmov    %rbp,%rdi\nmov    $0x7b7,%ecx\nxor    %eax,%eax\nlea    0x2eca(%rip),%r8\nmov    $0x1,%edx\nmov    $0x1,%esi\ncall   3430 <libmin_printf>\nmov    %rbp,%rdi\nmov    $0x7ac,%ecx\nxor    %eax,%eax\nlea    0x2eb4(%rip),%r8\nmov    $0x7,%edx\nmov    $0x2,%esi\ncall   3430 <libmin_printf>\ncall   3670 <libmin_success>\nxor    %eax,%eax\npop    %rbp\nret\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
