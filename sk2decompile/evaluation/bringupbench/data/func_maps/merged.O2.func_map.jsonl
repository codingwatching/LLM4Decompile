{"source": {"path": "ackermann/ackermann.c", "function_name": "ack", "content": "/* Implement Ackermann function as recursive function that remembers its values */\nunsigned\nack(unsigned x, unsigned y)\n{\n\tdepth++;\n\tif (depth > MAX_DEPTH)\n  {\n\t\tlibmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", MAX_DEPTH);\n\t\tlibmin_fail(1);\n\t}\n\tif (x >= MAX_X)\n  {\n\t\tlibmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", MAX_X);\n\t\tlibmin_fail(1);\n\t}\n\tif (y >= MAX_Y)\n  {\n\t\tlibmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", MAX_Y);\n\t\tlibmin_fail(1);\n\t}\n\tif (a[x][y])\n    return a[x][y];\n\tif (y==0)\n    return a[x][0] = x+1;\n\tif (x==0)\n    return a[0][y] = ack(1,y-1);\n  return a[x][y] = ack(ack(x-1,y),y-1);\n}\n"}, "pseudo": {"path": "ackermann/ackermann.host.O2.pseudo", "function_name": "ack", "address": "0x12b0", "label": "ack", "content": "unsigned int __fastcall ack(unsigned int x, unsigned int y)\n{\n  unsigned int result; // eax\n  unsigned int v3; // r15d\n  unsigned int v4; // eax\n\n  if ( ++depth > 0xFFFFFF )\n  {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 0xFFFFFF);\n    libmin_fail(1);\n  }\n  if ( x > 0xFFFE )\n  {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 0xFFFF);\n    libmin_fail(1);\n  }\n  if ( y > 0xF )\n  {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  result = a[x][y];\n  if ( !result )\n  {\n    if ( y )\n    {\n      v3 = y - 1;\n      if ( x )\n      {\n        v4 = ack(x - 1, y);\n        result = ack(v4, v3);\n        a[x][y] = result;\n      }\n      else\n      {\n        result = ack(1u, v3);\n        a[0][y] = result;\n      }\n    }\n    else\n    {\n      result = x + 1;\n      a[(unsigned __int64)x][0] = x + 1;\n    }\n  }\n  return result;\n}\n"}, "pseudo_normalize": "unsigned int ack(unsigned int x, unsigned int y) {\n  unsigned int result;\n  unsigned int v3;\n  unsigned int v4;\n  if (++depth > 16777215) {\n    libmin_printf(\"Maximum stack depth %d exceeded. Abort.\\n\", 16777215);\n    libmin_fail(1);\n  }\n  if (x > 65534) {\n    libmin_printf(\"Maximum x value %d exceeded. Abort. \\n\", 65535);\n    libmin_fail(1);\n  }\n  if (y > 15) {\n    libmin_printf(\"Maximum y value %d exceeded. Abort. \\n\", 16);\n    libmin_fail(1);\n  }\n  result = a[x][y];\n  if (!result) {\n    if (y) {\n      v3 = y - 1;\n      if (x) {\n        v4 = ack(x - 1, y);\n        result = ack(v4, v3);\n        a[x][y] = result;\n      } else {\n        result = ack(1u, v3);\n        a[0][y] = result;\n      }\n    } else {\n      result = x + 1;\n      a[(unsigned long long)x][0] = x + 1;\n    }\n  }\n  return result;\n}", "binary": "ackermann/ackermann.host.O2", "assembly": "<ack>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmov    %edi,%ebx\nsub    $0x8,%rsp\nmov    0x3fb8(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x3faf(%rip)\ncmp    $0xffffff,%eax\nja     13e0 <ack+0x130>\ncmp    $0xfffe,%ebx\nja     13b8 <ack+0x108>\ncmp    $0xf,%ebp\nja     1338 <ack+0x88>\nmov    %ebx,%r12d\nmov    %ebp,%r14d\nlea    0x3fa2(%rip),%r13\nmov    %r12,%rax\nshl    $0x4,%rax\nadd    %r14,%rax\nmov    0x0(%r13,%rax,4),%eax\ntest   %eax,%eax\njne    1324 <ack+0x74>\ntest   %ebp,%ebp\njne    1375 <ack+0xc5>\nmov    %r12,%rdx\nlea    0x1(%rbx),%eax\nshl    $0x6,%rdx\nmov    %eax,0x0(%r13,%rdx,1)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0x10,%esi\nxor    %eax,%eax\nmov    %ebx,%r12d\nmov    %ebp,%r14d\nlea    0x1d14(%rip),%rdi\nlea    0x3f4d(%rip),%r13\ncall   2990 <libmin_printf>\nmov    $0x1,%edi\ncall   1610 <libmin_fail>\nmov    %r12,%rax\nshl    $0x4,%rax\nadd    %r14,%rax\nmov    0x0(%r13,%rax,4),%eax\ntest   %eax,%eax\njne    1324 <ack+0x74>\nlea    -0x1(%rbp),%r15d\ntest   %ebx,%ebx\nje     1408 <ack+0x158>\nlea    -0x1(%rbx),%edi\nmov    %ebp,%esi\ncall   12b0 <ack>\nmov    %r15d,%esi\nmov    %eax,%edi\ncall   12b0 <ack>\nmov    %r12,%rdx\nshl    $0x4,%rdx\nadd    %r14,%rdx\nmov    %eax,0x0(%r13,%rdx,4)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0xffff,%esi\nlea    0x1c74(%rip),%rdi\nxor    %eax,%eax\ncall   2990 <libmin_printf>\nmov    $0x1,%edi\ncall   1610 <libmin_fail>\njmp    12ec <ack+0x3c>\nnopw   0x0(%rax,%rax,1)\nmov    $0xffffff,%esi\nlea    0x1c1c(%rip),%rdi\nxor    %eax,%eax\ncall   2990 <libmin_printf>\nmov    $0x1,%edi\ncall   1610 <libmin_fail>\njmp    12e0 <ack+0x30>\nnopw   0x0(%rax,%rax,1)\nmov    %r15d,%esi\nmov    $0x1,%edi\ncall   12b0 <ack>\nmov    %eax,0x0(%r13,%r14,4)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "ackermann/ackermann.c", "function_name": "main", "content": "\t\n\nint\nmain(void)\n{\n\tunsigned y,k; \n\n  max_depth = 0;\n\tfor(k=0;k<=AMAX;k++)\n  {\n\t\tlibmin_printf(\"\\nx+y=%d:\\n\\n\",k);\n\t\tfor(y=0;y<=k;y++)\n    {\n\t\t  depth = 0;  /* stack guard */\n\t\t\tlibmin_printf(\"A(%d,%d) = %d\\n\",k-y,y,ack(k-y,y));\n      if (depth > max_depth)\n        max_depth = depth;   \n\t\t}\n\t}\n  libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "ackermann/ackermann.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // r12d\n  unsigned int v5; // ebx\n  unsigned int v6; // eax\n\n  v3 = 1;\n  max_depth = 0;\n  while ( 1 )\n  {\n    v4 = v3 - 1;\n    v5 = 0;\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", v3 - 1);\n    do\n    {\n      depth = 0;\n      v6 = ack(v4 - v5, v5);\n      libmin_printf(\"A(%d,%d) = %d\\n\", v4 - v5, v5, v6);\n      if ( depth > max_depth )\n        max_depth = depth;\n      ++v5;\n    }\n    while ( v3 != v5 );\n    if ( ++v3 == 7 )\n    {\n      libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  unsigned int v5;\n  unsigned int v6;\n  v3 = 1;\n  max_depth = 0;\n  while (1) {\n    v4 = v3 - 1;\n    v5 = 0;\n    libmin_printf(\"\\nx+y=%d:\\n\\n\", v3 - 1);\n    do {\n      depth = 0;\n      v6 = ack(v4 - v5, v5);\n      libmin_printf(\"A(%d,%d) = %d\\n\", v4 - v5, v5, v6);\n      if (depth > max_depth) max_depth = depth;\n      ++v5;\n    } while (v3 != v5);\n    if (++v3 == 7) {\n      libmin_printf(\"Max recursive depth = %u\\n\", max_depth);\n      libmin_success();\n    }\n  }\n}", "binary": "ackermann/ackermann.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\nlea    0x1f77(%rip),%r14\npush   %r13\nlea    0x1f79(%rip),%r13\npush   %r12\npush   %rbp\nmov    $0x1,%ebp\npush   %rbx\nsub    $0x8,%rsp\nmovl   $0x0,0x4151(%rip)\nnop\nlea    -0x1(%rbp),%r12d\nmov    %r14,%rdi\nxor    %eax,%eax\nxor    %ebx,%ebx\nmov    %r12d,%esi\ncall   2990 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\nmovl   $0x0,0x4132(%rip)\nmov    %r12d,%r15d\nmov    %ebx,%esi\nsub    %ebx,%r15d\nmov    %r15d,%edi\ncall   12b0 <ack>\nmov    %ebx,%edx\nmov    %r15d,%esi\nmov    %r13,%rdi\nmov    %eax,%ecx\nxor    %eax,%eax\ncall   2990 <libmin_printf>\nmov    0x410b(%rip),%eax\ncmp    0x4101(%rip),%eax\njbe    1187 <main+0x87>\nmov    %eax,0x40f9(%rip)\nadd    $0x1,%ebx\ncmp    %ebx,%ebp\njne    1148 <main+0x48>\nadd    $0x1,%ebp\ncmp    $0x7,%ebp\njne    1130 <main+0x30>\nmov    0x40e4(%rip),%esi\nlea    0x1efd(%rip),%rdi\nxor    %eax,%eax\ncall   2990 <libmin_printf>\ncall   2bd0 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"}
{"source": {"path": "aes/aes.c", "function_name": "add_round_key", "content": "void add_round_key(uint8_t *s, const uint8_t *round_key) {\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] ^= round_key[i];\n}\n"}, "pseudo": {"path": "aes/aes.host.O2.pseudo", "function_name": "add_round_key", "address": "0x13f0", "label": "add_round_key", "content": "void __fastcall add_round_key(uint8_t *s, const uint8_t *round_key)\n{\n  __int64 i; // rax\n\n  for ( i = 0LL; i != 16; ++i )\n    s[i] ^= round_key[i];\n}\n"}, "pseudo_normalize": "", "binary": "aes/aes.host.O2", "assembly": "<add_round_key>:\nendbr64\nxor    %eax,%eax\ncs nopw 0x0(%rax,%rax,1)\nmovzbl (%rsi,%rax,1),%edx\nxor    %dl,(%rdi,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    1400 <add_round_key+0x10>\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "aes/aes.c", "function_name": "aes_decrypt", "content": "void aes_decrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t round_keys[(ROUNDS + 1) * BLK_SIZE];\n  key_expansion(key, round_keys);\n\n  add_round_key(data, round_keys + ROUNDS * BLK_SIZE);\n  for (int round = 9; round > 0; round--) {\n    inv_shift_rows(data);\n    inv_sub_bytes(data);\n    add_round_key(data, round_keys + round * BLK_SIZE);\n    inv_mix_columns(data);\n  }\n  inv_shift_rows(data);\n  inv_sub_bytes(data);\n  add_round_key(data, round_keys + 0 * BLK_SIZE);\n}\n"}, "pseudo": {"path": "aes/aes.host.O2.pseudo", "function_name": "aes_decrypt", "address": "0x18c0", "label": "aes_decrypt", "content": "void __fastcall aes_decrypt(uint8_t *data, const uint8_t *key)\n{\n  __int64 i; // rax\n  uint8_t *v3; // rbp\n  uint8_t *v4; // r12\n  uint8_t *v5; // r14\n  uint8_t *v6; // rax\n  __int64 v7; // rdx\n  __int64 j; // rax\n  __int64 v9; // rax\n  __int64 k; // rax\n  uint8_t round_keys[184]; // [rsp+0h] [rbp-F8h] BYREF\n  unsigned __int64 v12; // [rsp+B8h] [rbp-40h]\n\n  v12 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  for ( i = 0LL; i != 16; ++i )\n    data[i] ^= round_keys[i + 160];\n  v3 = &round_keys[144];\n  v4 = data + 16;\n  do\n  {\n    v5 = data;\n    inv_shift_rows(data);\n    v6 = data;\n    do\n    {\n      v7 = *v6++;\n      *(v6 - 1) = inv_sbox[v7];\n    }\n    while ( v4 != v6 );\n    for ( j = 0LL; j != 16; ++j )\n      data[j] ^= v3[j];\n    v3 -= 16;\n    inv_mix_columns(data);\n  }\n  while ( round_keys != v3 );\n  inv_shift_rows(data);\n  do\n  {\n    v9 = *v5++;\n    *(v5 - 1) = inv_sbox[v9];\n  }\n  while ( v4 != v5 );\n  for ( k = 0LL; k != 16; ++k )\n    data[k] ^= round_keys[k];\n}\n"}, "pseudo_normalize": "void aes_decrypt(uint8_t *data, const uint8_t *key) {\n  long long i;\n  uint8_t *v3;\n  uint8_t *v4;\n  uint8_t *v5;\n  uint8_t *v6;\n  long long v7;\n  long long j;\n  long long v9;\n  long long k;\n  uint8_t round_keys[184];\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  for (i = 0LL; i != 16; ++i) data[i] ^= round_keys[i + 160];\n  v3 = &round_keys[144];\n  v4 = data + 16;\n  do {\n    v5 = data;\n    inv_shift_rows(data);\n    v6 = data;\n    do {\n      v7 = *v6++;\n      *(v6 - 1) = inv_sbox[v7];\n    } while (v4 != v6);\n    for (j = 0LL; j != 16; ++j) data[j] ^= v3[j];\n    v3 -= 16;\n    inv_mix_columns(data);\n  } while (round_keys != v3);\n  inv_shift_rows(data);\n  do {\n    v9 = *v5++;\n    *(v5 - 1) = inv_sbox[v9];\n  } while (v4 != v5);\n  for (k = 0LL; k != 16; ++k) data[k] ^= round_keys[k];\n}", "binary": "aes/aes.host.O2", "assembly": "<aes_decrypt>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %rsi,%rdi\nsub    $0xc8,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0xb8(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r15\nmov    %r15,%rsi\ncall   16d0 <key_expansion>\nxor    %eax,%eax\nlea    0xa0(%rsp),%rcx\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rcx,%rax,1),%edx\nxor    %dl,(%rbx,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    1908 <aes_decrypt+0x48>\nlea    0x90(%rsp),%rbp\nlea    0x10(%rbx),%r12\nlea    0x46f4(%rip),%r13\nnopl   0x0(%rax)\nmov    %rbx,%rdi\nmov    %rbx,%r14\ncall   14f0 <inv_shift_rows>\nmov    %rbx,%rax\nxchg   %ax,%ax\nmovzbl (%rax),%edx\nadd    $0x1,%rax\nmovzbl 0x0(%r13,%rdx,1),%edx\nmov    %dl,-0x1(%rax)\ncmp    %rax,%r12\njne    1940 <aes_decrypt+0x80>\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmovzbl 0x0(%rbp,%rax,1),%edx\nxor    %dl,(%rbx,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    1960 <aes_decrypt+0xa0>\nmov    %rbx,%rdi\nsub    $0x10,%rbp\ncall   1640 <inv_mix_columns>\ncmp    %rbp,%r15\njne    1930 <aes_decrypt+0x70>\nmov    %rbx,%rdi\ncall   14f0 <inv_shift_rows>\nnopl   0x0(%rax,%rax,1)\nmovzbl (%r14),%eax\nadd    $0x1,%r14\nmovzbl 0x0(%r13,%rax,1),%eax\nmov    %al,-0x1(%r14)\ncmp    %r14,%r12\njne    1990 <aes_decrypt+0xd0>\nxor    %eax,%eax\nnopl   0x0(%rax)\nmovzbl (%r15,%rax,1),%edx\nxor    %dl,(%rbx,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    19b0 <aes_decrypt+0xf0>\nmov    0xb8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    19e7 <aes_decrypt+0x127>\nadd    $0xc8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax)\n"}
{"source": {"path": "aes/aes.c", "function_name": "aes_encrypt", "content": "void aes_encrypt(uint8_t *data, const uint8_t *key) {\n  uint8_t round_keys[(ROUNDS + 1) * BLK_SIZE];\n  key_expansion(key, round_keys);\n\n  add_round_key(data, round_keys);\n  for (int round = 1; round < ROUNDS; round++) {\n    sub_bytes(data);\n    shift_rows(data);\n    mix_columns(data);\n    add_round_key(data, round_keys + round * BLK_SIZE);\n  }\n  sub_bytes(data);\n  shift_rows(data);\n  add_round_key(data, round_keys + ROUNDS * BLK_SIZE);\n}\n"}, "pseudo": {"path": "aes/aes.host.O2.pseudo", "function_name": "aes_encrypt", "address": "0x1780", "label": "aes_encrypt", "content": "void __fastcall aes_encrypt(uint8_t *data, const uint8_t *key)\n{\n  __int64 v2; // r10\n  __int64 i; // rax\n  uint8_t *v4; // rbp\n  uint8_t *v5; // r12\n  uint8_t *v6; // r14\n  uint8_t *v7; // rax\n  __int64 v8; // rdx\n  __int64 j; // rax\n  __int64 v10; // rax\n  __int64 k; // rax\n  uint8_t round_keys[184]; // [rsp+0h] [rbp-F8h] BYREF\n  unsigned __int64 v13; // [rsp+B8h] [rbp-40h]\n\n  v13 = __readfsqword(0x28u);\n  key_expansion(key, round_keys);\n  for ( i = 0LL; i != 16; ++i )\n    data[i] ^= *(_BYTE *)(v2 + i);\n  v4 = &round_keys[16];\n  v5 = data + 16;\n  do\n  {\n    v6 = data;\n    v7 = data;\n    do\n    {\n      v8 = *v7++;\n      *(v7 - 1) = sbox[v8];\n    }\n    while ( v5 != v7 );\n    shift_rows(data);\n    mix_columns(data);\n    for ( j = 0LL; j != 16; ++j )\n      data[j] ^= v4[j];\n    v4 += 16;\n  }\n  while ( &round_keys[160] != v4 );\n  do\n  {\n    v10 = *v6++;\n    *(v6 - 1) = sbox[v10];\n  }\n  while ( v5 != v6 );\n  shift_rows(data);\n  for ( k = 0LL; k != 16; ++k )\n    data[k] ^= round_keys[k + 160];\n}\n"}, "pseudo_normalize": "void aes_encrypt(uint8_t *data, const uint8_t *key) {\n  long long v2;\n  long long i;\n  uint8_t *v4;\n  uint8_t *v5;\n  uint8_t *v6;\n  uint8_t *v7;\n  long long v8;\n  long long j;\n  long long v10;\n  long long k;\n  uint8_t round_keys[184];\n  unsigned long long v13;\n  v13 = __readfsqword(40u);\n  key_expansion(key, round_keys);\n  for (i = 0LL; i != 16; ++i) data[i] ^= *(uint8_t *)(v2 + i);\n  v4 = &round_keys[16];\n  v5 = data + 16;\n  do {\n    v6 = data;\n    v7 = data;\n    do {\n      v8 = *v7++;\n      *(v7 - 1) = sbox[v8];\n    } while (v5 != v7);\n    shift_rows(data);\n    mix_columns(data);\n    for (j = 0LL; j != 16; ++j) data[j] ^= v4[j];\n    v4 += 16;\n  } while (&round_keys[160] != v4);\n  do {\n    v10 = *v6++;\n    *(v6 - 1) = sbox[v10];\n  } while (v5 != v6);\n  shift_rows(data);\n  for (k = 0LL; k != 16; ++k) data[k] ^= round_keys[k + 160];\n}", "binary": "aes/aes.host.O2", "assembly": "<aes_encrypt>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nmov    %rsi,%rdi\nsub    $0xc8,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0xb8(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r10\nmov    %r10,%rsi\ncall   16d0 <key_expansion>\nxor    %eax,%eax\nnopl   0x0(%rax,%rax,1)\nmovzbl (%r10,%rax,1),%edx\nxor    %dl,(%rbx,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    17c0 <aes_encrypt+0x40>\nlea    0x10(%rsp),%rbp\nlea    0xa0(%rsp),%r15\nlea    0x493a(%rip),%r13\nlea    0x10(%rbx),%r12\nnopw   0x0(%rax,%rax,1)\nmov    %rbx,%r14\nmov    %rbx,%rax\ncs nopw 0x0(%rax,%rax,1)\nmovzbl (%rax),%edx\nadd    $0x1,%rax\nmovzbl 0x0(%r13,%rdx,1),%edx\nmov    %dl,-0x1(%rax)\ncmp    %rax,%r12\njne    1800 <aes_encrypt+0x80>\nmov    %rbx,%rdi\ncall   1480 <shift_rows>\nmov    %rbx,%rdi\ncall   1580 <mix_columns>\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmovzbl 0x0(%rbp,%rax,1),%edx\nxor    %dl,(%rbx,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    1830 <aes_encrypt+0xb0>\nadd    $0x10,%rbp\ncmp    %rbp,%r15\njne    17f0 <aes_encrypt+0x70>\nnopl   0x0(%rax,%rax,1)\nmovzbl (%r14),%eax\nadd    $0x1,%r14\nmovzbl 0x0(%r13,%rax,1),%eax\nmov    %al,-0x1(%r14)\ncmp    %r14,%r12\njne    1850 <aes_encrypt+0xd0>\nmov    %rbx,%rdi\ncall   1480 <shift_rows>\nxor    %eax,%eax\nnopl   0x0(%rax)\nmovzbl (%r15,%rax,1),%edx\nxor    %dl,(%rbx,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    1878 <aes_encrypt+0xf8>\nmov    0xb8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    18af <aes_encrypt+0x12f>\nadd    $0xc8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "aes/aes.c", "function_name": "gf256_mul2", "content": "/*\n * Multiply by 0x02 in GF(2^8) using the AES irreducible polynomial.\n * If the high bit is set, reduce the result modulo 0x11B by XORing with 0x1B.\n */\nuint8_t gf256_mul2(uint8_t x) { return (x << 1) ^ ((x & 0x80) ? 0x1b : 0x00); }\n"}, "pseudo": {"path": "aes/aes.host.O2.pseudo", "function_name": "gf256_mul2", "address": "0x1560", "label": "gf256_mul2", "content": "uint8_t __fastcall gf256_mul2(uint8_t x)\n{\n  uint8_t result; // al\n\n  result = 2 * x;\n  if ( (x & 0x80u) != 0 )\n    return (2 * x) ^ 0x1B;\n  return result;\n}\n"}, "pseudo_normalize": "uint8_t gf256_mul2(uint8_t x) {\n  uint8_t result;\n  result = 2 * x;\n  if ((x & 128u) != 0) return (2 * x) ^ 27;\n  return result;\n}", "binary": "aes/aes.host.O2", "assembly": "<gf256_mul2>:\nendbr64\nmovzbl %dil,%eax\nadd    %eax,%eax\nmov    %eax,%edx\nxor    $0x1b,%edx\ntest   %dil,%dil\ncmovs  %edx,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "aes/aes.c", "function_name": "inv_mix_columns", "content": "void inv_mix_columns(uint8_t *s) {\n  for (int i = 0; i < 4; i++) {\n    int c = i * 4;\n    uint8_t a = s[c];\n    uint8_t b = s[c + 1];\n    uint8_t c1 = s[c + 2];\n    uint8_t d = s[c + 3];\n\n    uint8_t a1 = gf256_mul2(gf256_mul2(a ^ c1));\n    uint8_t b1 = gf256_mul2(gf256_mul2(b ^ d));\n\n    s[c] ^= a1;\n    s[c + 1] ^= b1;\n    s[c + 2] ^= a1;\n    s[c + 3] ^= b1;\n  }\n  mix_columns(s);\n}\n"}, "pseudo": {"path": "aes/aes.host.O2.pseudo", "function_name": "inv_mix_columns", "address": "0x1640", "label": "inv_mix_columns", "content": "void __fastcall inv_mix_columns(uint8_t *s)\n{\n  uint8_t *v1; // rax\n  char v2; // cl\n  char v3; // dl\n  char v4; // cl\n  char v5; // dl\n  char v6; // si\n  char v7; // dl\n  char v8; // r9\n  bool v9; // sf\n  uint8_t v10; // si\n  uint8_t v11; // si\n  uint8_t v12; // cl\n  char v13; // si\n  uint8_t v14; // si\n  uint8_t v15; // dl\n\n  v1 = s;\n  do\n  {\n    v2 = v1[2] ^ *v1;\n    v3 = 2 * v2;\n    if ( v2 < 0 )\n      v3 = (2 * v2) ^ 0x1B;\n    v4 = 2 * v3;\n    if ( v3 < 0 )\n      v4 = (2 * v3) ^ 0x1B;\n    v5 = v1[3] ^ v1[1];\n    v6 = 2 * v5;\n    if ( v5 < 0 )\n      v6 = (2 * v5) ^ 0x1B;\n    v7 = 2 * v6;\n    v8 = (2 * v6) ^ 0x1B;\n    v9 = v6 < 0;\n    v10 = *v1;\n    if ( v9 )\n      v7 = v8;\n    v1 += 4;\n    v11 = v4 ^ v10;\n    v12 = *(v1 - 2) ^ v4;\n    *(v1 - 4) = v11;\n    v13 = *(v1 - 3);\n    *(v1 - 2) = v12;\n    v14 = v7 ^ v13;\n    v15 = *(v1 - 1) ^ v7;\n    *(v1 - 3) = v14;\n    *(v1 - 1) = v15;\n  }\n  while ( v1 != s + 16 );\n  mix_columns(s);\n}\n"}, "pseudo_normalize": "void inv_mix_columns(uint8_t *s) {\n  uint8_t *v1;\n  char v2;\n  char v3;\n  char v4;\n  char v5;\n  char v6;\n  char v7;\n  char v8;\n  bool v9;\n  uint8_t v10;\n  uint8_t v11;\n  uint8_t v12;\n  char v13;\n  uint8_t v14;\n  uint8_t v15;\n  v1 = s;\n  do {\n    v2 = v1[2] ^ *v1;\n    v3 = 2 * v2;\n    if (v2 < 0) v3 = (2 * v2) ^ 27;\n    v4 = 2 * v3;\n    if (v3 < 0) v4 = (2 * v3) ^ 27;\n    v5 = v1[3] ^ v1[1];\n    v6 = 2 * v5;\n    if (v5 < 0) v6 = (2 * v5) ^ 27;\n    v7 = 2 * v6;\n    v8 = (2 * v6) ^ 27;\n    v9 = v6 < 0;\n    v10 = *v1;\n    if (v9) v7 = v8;\n    v1 += 4;\n    v11 = v4 ^ v10;\n    v12 = *(v1 - 2) ^ v4;\n    *(v1 - 4) = v11;\n    v13 = *(v1 - 3);\n    *(v1 - 2) = v12;\n    v14 = v7 ^ v13;\n    v15 = *(v1 - 1) ^ v7;\n    *(v1 - 3) = v14;\n    *(v1 - 1) = v15;\n  } while (v1 != s + 16);\n  mix_columns(s);\n}", "binary": "aes/aes.host.O2", "assembly": "<inv_mix_columns>:\nendbr64\nmov    %rdi,%rax\nlea    0x10(%rdi),%r8\nmovzbl (%rax),%ecx\nxor    0x2(%rax),%cl\nmovzbl %cl,%edx\nadd    %edx,%edx\nmov    %edx,%esi\nxor    $0x1b,%esi\ntest   %cl,%cl\ncmovs  %esi,%edx\nmovzbl %dl,%ecx\nadd    %ecx,%ecx\nmov    %ecx,%esi\nxor    $0x1b,%esi\ntest   %dl,%dl\nmovzbl 0x1(%rax),%edx\ncmovs  %esi,%ecx\nxor    0x3(%rax),%dl\nmovzbl %dl,%esi\nadd    %esi,%esi\nmov    %esi,%r9d\nxor    $0x1b,%r9d\ntest   %dl,%dl\ncmovs  %r9d,%esi\nmovzbl %sil,%edx\nadd    %edx,%edx\nmov    %edx,%r9d\nxor    $0x1b,%r9d\ntest   %sil,%sil\nmovzbl (%rax),%esi\ncmovs  %r9d,%edx\nadd    $0x4,%rax\nxor    %ecx,%esi\nxor    -0x2(%rax),%cl\nmov    %sil,-0x4(%rax)\nmovzbl -0x3(%rax),%esi\nmov    %cl,-0x2(%rax)\nxor    %edx,%esi\nxor    -0x1(%rax),%dl\nmov    %sil,-0x3(%rax)\nmov    %dl,-0x1(%rax)\ncmp    %r8,%rax\njne    164b <inv_mix_columns+0xb>\njmp    1580 <mix_columns>\nnopl   0x0(%rax)\n"}
{"source": {"path": "aes/aes.c", "function_name": "inv_shift_rows", "content": "void inv_shift_rows(uint8_t *s) {\n  uint8_t res[BLK_SIZE];\n  uint8_t idx[BLK_SIZE] = {0, 13, 10, 7,  4,  1, 14, 11,\n                           8, 5,  2,  15, 12, 9, 6,  3};\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    res[i] = s[idx[i]];\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = res[i];\n}\n"}, "pseudo": {"path": "aes/aes.host.O2.pseudo", "function_name": "inv_shift_rows", "address": "0x14f0", "label": "inv_shift_rows", "content": "void __fastcall inv_shift_rows(uint8_t *s)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rax\n  uint8_t res[16]; // [rsp+0h] [rbp-38h] BYREF\n  __m128i idx; // [rsp+10h] [rbp-28h]\n  unsigned __int64 v5; // [rsp+28h] [rbp-10h]\n\n  v1 = 0LL;\n  v5 = __readfsqword(0x28u);\n  v2 = 0LL;\n  for ( idx = _mm_load_si128((const __m128i *)&xmmword_40C0); ; v1 = idx.m128i_u8[v2] )\n  {\n    res[v2++] = s[v1];\n    if ( v2 == 16 )\n      break;\n  }\n  *(__m128i *)s = _mm_load_si128((const __m128i *)res);\n}\n"}, "pseudo_normalize": "void inv_shift_rows(uint8_t *s) {\n  long long v1;\n  long long v2;\n  uint8_t res[16];\n  __m128i idx;\n  unsigned long long v5;\n  v1 = 0LL;\n  v5 = __readfsqword(40u);\n  v2 = 0LL;\n  for (idx = _mm_load_si128((const __m128i *)&xmmword_40C0);;\n       v1 = idx.m128i_u8[v2]) {\n    res[v2++] = s[v1];\n    if (v2 == 16) break;\n  }\n  *(__m128i *)s = _mm_load_si128((const __m128i *)res);\n}", "binary": "aes/aes.host.O2", "assembly": "<inv_shift_rows>:\nendbr64\nsub    $0x38,%rsp\nmovdqa 0x2bc0(%rip),%xmm0\nxor    %edx,%edx\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rcx\nmovaps %xmm0,0x10(%rsp)\njmp    1525 <inv_shift_rows+0x35>\nnopl   0x0(%rax)\nmovzbl 0x10(%rsp,%rax,1),%edx\nmovzbl (%rdi,%rdx,1),%edx\nmov    %dl,(%rcx,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    1520 <inv_shift_rows+0x30>\nmovdqa (%rsp),%xmm1\nmovups %xmm1,(%rdi)\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1553 <inv_shift_rows+0x63>\nadd    $0x38,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "aes/aes.c", "function_name": "inv_sub_bytes", "content": "void inv_sub_bytes(uint8_t *s) {\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = inv_sbox[s[i]];\n}\n"}, "pseudo": {"path": "aes/aes.host.O2.pseudo", "function_name": "inv_sub_bytes", "address": "0x1450", "label": "inv_sub_bytes", "content": "void __fastcall inv_sub_bytes(uint8_t *s)\n{\n  uint8_t *v1; // rcx\n  __int64 v2; // rax\n\n  v1 = s + 16;\n  do\n  {\n    v2 = *s++;\n    *(s - 1) = inv_sbox[v2];\n  }\n  while ( s != v1 );\n}\n"}, "pseudo_normalize": "void inv_sub_bytes(uint8_t *s) {\n  uint8_t *v1;\n  long long v2;\n  v1 = s + 16;\n  do {\n    v2 = *s++;\n    *(s - 1) = inv_sbox[v2];\n  } while (s != v1);\n}", "binary": "aes/aes.host.O2", "assembly": "<inv_sub_bytes>:\nendbr64\nlea    0x10(%rdi),%rcx\nlea    0x4bc1(%rip),%rdx\nnop\nmovzbl (%rdi),%eax\nadd    $0x1,%rdi\nmovzbl (%rdx,%rax,1),%eax\nmov    %al,-0x1(%rdi)\ncmp    %rcx,%rdi\njne    1460 <inv_sub_bytes+0x10>\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "aes/aes.c", "function_name": "key_expansion", "content": "// Simple 128-bit key expansion for 10 rounds\nvoid key_expansion(const uint8_t *key, uint8_t *round_keys) {\n  static const uint8_t rcon[10] = {0x01, 0x02, 0x04, 0x08, 0x10,\n                                   0x20, 0x40, 0x80, 0x1B, 0x36};\n  for (int i = 0; i < BLK_SIZE; i++)\n    round_keys[i] = key[i];\n\n  for (int i = 1; i <= ROUNDS; i++) {\n    uint8_t *prev = &round_keys[BLK_SIZE * (i - 1)];\n    uint8_t *curr = &round_keys[BLK_SIZE * i];\n    curr[0] = prev[0] ^ sbox[prev[13]] ^ rcon[i - 1];\n    curr[1] = prev[1] ^ sbox[prev[14]];\n    curr[2] = prev[2] ^ sbox[prev[15]];\n    curr[3] = prev[3] ^ sbox[prev[12]];\n    for (int j = 4; j < BLK_SIZE; j++)\n      curr[j] = curr[j - 4] ^ prev[j];\n  }\n}\n"}, "pseudo": {"path": "aes/aes.host.O2.pseudo", "function_name": "key_expansion", "address": "0x16d0", "label": "key_expansion", "content": "void __fastcall key_expansion(const uint8_t *key, uint8_t *round_keys)\n{\n  uint8_t *v2; // rcx\n  __int64 i; // rax\n  const uint8_t *v4; // r8\n  char j; // dl\n  uint8_t *v6; // rsi\n  uint8_t v7; // dl\n  __int64 v8; // rax\n  __int64 k; // rax\n\n  v2 = round_keys;\n  for ( i = 0LL; i != 16; ++i )\n    round_keys[i] = key[i];\n  v4 = rcon_0;\n  for ( j = 1; ; j = *v4 )\n  {\n    v6 = v2;\n    v2 += 16;\n    v7 = sbox[v6[13]] ^ *v6 ^ j;\n    v8 = v6[14];\n    v6[16] = v7;\n    v6[17] = v6[1] ^ sbox[v8];\n    v6[18] = v6[2] ^ sbox[v6[15]];\n    v6[19] = v6[3] ^ sbox[v6[12]];\n    for ( k = 4LL; ; v7 = v2[k - 4] )\n    {\n      v2[k] = v6[k] ^ v7;\n      if ( ++k == 16 )\n        break;\n    }\n    if ( &rcon_0[10] == ++v4 )\n      break;\n  }\n}\n"}, "pseudo_normalize": "void key_expansion(const uint8_t *key, uint8_t *round_keys) {\n  uint8_t *v2;\n  long long i;\n  const uint8_t *v4;\n  char j;\n  uint8_t *v6;\n  uint8_t v7;\n  long long v8;\n  long long k;\n  v2 = round_keys;\n  for (i = 0LL; i != 16; ++i) round_keys[i] = key[i];\n  v4 = rcon_0;\n  for (j = 1;; j = *v4) {\n    v6 = v2;\n    v2 += 16;\n    v7 = sbox[v6[13]] ^ *v6 ^ j;\n    v8 = v6[14];\n    v6[16] = v7;\n    v6[17] = v6[1] ^ sbox[v8];\n    v6[18] = v6[2] ^ sbox[v6[15]];\n    v6[19] = v6[3] ^ sbox[v6[12]];\n    for (k = 4LL;; v7 = v2[k - 4]) {\n      v2[k] = v6[k] ^ v7;\n      if (++k == 16) break;\n    }\n    if (&rcon_0[10] == ++v4) break;\n  }\n}", "binary": "aes/aes.host.O2", "assembly": "<key_expansion>:\nendbr64\nmov    %rsi,%rcx\nxor    %eax,%eax\nnopl   0x0(%rax)\nmovzbl (%rdi,%rax,1),%edx\nmov    %dl,(%rcx,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    16e0 <key_expansion+0x10>\nlea    0x29a8(%rip),%r8\nmov    $0x1,%edx\nlea    0x4a1c(%rip),%rdi\nlea    0xa(%r8),%r9\nnopl   0x0(%rax,%rax,1)\nmov    %rcx,%rsi\nadd    $0x10,%rcx\nmovzbl 0xd(%rsi),%eax\nxor    (%rsi),%dl\nxor    (%rdi,%rax,1),%dl\nmovzbl 0xe(%rsi),%eax\nmov    %dl,0x10(%rsi)\nmovzbl (%rdi,%rax,1),%eax\nxor    0x1(%rsi),%al\nmov    %al,0x11(%rsi)\nmovzbl 0xf(%rsi),%eax\nmovzbl (%rdi,%rax,1),%eax\nxor    0x2(%rsi),%al\nmov    %al,0x12(%rsi)\nmovzbl 0xc(%rsi),%eax\nmovzbl (%rdi,%rax,1),%eax\nxor    0x3(%rsi),%al\nmov    %al,0x13(%rsi)\nmov    $0x4,%eax\njmp    175d <key_expansion+0x8d>\nnopl   0x0(%rax)\nmovzbl -0x4(%rcx,%rax,1),%edx\nxor    (%rsi,%rax,1),%dl\nmov    %dl,(%rcx,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    1758 <key_expansion+0x88>\nadd    $0x1,%r8\ncmp    %r8,%r9\nje     177c <key_expansion+0xac>\nmovzbl (%r8),%edx\njmp    1710 <key_expansion+0x40>\nret\nnopl   (%rax)\n"}
{"source": {"path": "aes/aes.c", "function_name": "main", "content": "int main(void) {\n  uint8_t key[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,\n                     0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};\n\n  char *plaintext = \"This is a test!!\";\n  if (libmin_strlen(plaintext) != BLK_SIZE) {\n    libmin_fail(1);\n  }\n\n  uint8_t ciphertext[BLK_SIZE];\n  uint8_t decrypted[BLK_SIZE];\n\n  libmin_memcpy(ciphertext, plaintext, BLK_SIZE);\n  aes_encrypt(ciphertext, key);\n\n  uint8_t ref_ciphertext[BLK_SIZE] = {0xf8, 0x6e, 0x9e, 0x4e, 0x8d, 0x38,\n                                      0x05, 0xe9, 0x72, 0x9f, 0xf1, 0x55,\n                                      0xe5, 0x17, 0xbd, 0x65};\n\n  for (int i = 0; i < BLK_SIZE; i++) {\n    if (ref_ciphertext[i] != ciphertext[i]) {\n      libmin_printf(\"Ciphertext mismatch at byte %d\\n\", i);\n      libmin_printf(\"Expected: %02x, Got: %02x\\n\", ref_ciphertext[i],\n                    ciphertext[i]);\n      libmin_fail(2);\n    }\n  }\n\n  libmin_memcpy(decrypted, ciphertext, BLK_SIZE);\n  aes_decrypt(decrypted, key);\n\n  libmin_printf(\"AES Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  %s\\n\", plaintext);\n  libmin_printf(\"  ciphertext: \");\n  for (int i = 0; i < BLK_SIZE; i++) {\n    libmin_printf(\"%02x \", ciphertext[i]);\n  }\n\n  libmin_printf(\"\\n\");\n\n  libmin_printf(\"  decrypted:  \");\n  for (int i = 0; i < BLK_SIZE; i++) {\n    libmin_printf(\"%c\", decrypted[i]);\n  }\n  libmin_printf(\"\\n\");\n\n  for (int i = 0; i < BLK_SIZE; i++) {\n    if (decrypted[i] != plaintext[i]) {\n      libmin_fail(3);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "aes/aes.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint8_t *v3; // rbx\n  __int64 v4; // r13\n  uint8_t v5; // r15\n  int v6; // esi\n  uint8_t *v7; // rbx\n  __int64 v8; // rsi\n  __int64 v9; // rbx\n  int i; // eax\n  uint8_t key[16]; // [rsp+10h] [rbp-88h] BYREF\n  uint8_t ciphertext[16]; // [rsp+20h] [rbp-78h] BYREF\n  uint8_t decrypted[16]; // [rsp+30h] [rbp-68h] BYREF\n  __m128i ref_ciphertext; // [rsp+40h] [rbp-58h] BYREF\n  unsigned __int64 v15; // [rsp+58h] [rbp-40h]\n\n  v15 = __readfsqword(0x28u);\n  *(__m128i *)key = _mm_load_si128((const __m128i *)&xmmword_40D0);\n  if ( libmin_strlen(\"This is a test!!\") != 16 )\n    libmin_fail(1);\n  v3 = ciphertext;\n  v4 = 0LL;\n  v5 = -8;\n  libmin_memcpy(ciphertext, \"This is a test!!\", 0x10uLL);\n  aes_encrypt(ciphertext, key);\n  ref_ciphertext = _mm_load_si128((const __m128i *)&xmmword_40E0);\n  while ( ciphertext[v4] == v5 )\n  {\n    if ( ++v4 == 16 )\n    {\n      libmin_memcpy(decrypted, ciphertext, 0x10uLL);\n      aes_decrypt(decrypted, key);\n      libmin_printf(\"AES Cipher results:\\n\");\n      libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n      libmin_printf(\"  ciphertext: \");\n      do\n      {\n        v6 = *v3++;\n        libmin_printf(\"%02x \", v6);\n      }\n      while ( v3 != decrypted );\n      v7 = decrypted;\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"  decrypted:  \");\n      do\n      {\n        v8 = *v7++;\n        libmin_printf(\"%c\", v8);\n      }\n      while ( v7 != (uint8_t *)&ref_ciphertext );\n      v9 = 0LL;\n      libmin_printf((char *)\"\\n\");\n      for ( i = 84; decrypted[v9] == i; i = src[v9] )\n      {\n        if ( ++v9 == 16 )\n          libmin_success();\n      }\n      libmin_fail(3);\n    }\n    v5 = ref_ciphertext.m128i_u8[v4];\n  }\n  libmin_printf(\"Ciphertext mismatch at byte %d\\n\", v4);\n  libmin_printf(\"Expected: %02x, Got: %02x\\n\", v5, ciphertext[v4]);\n  libmin_fail(2);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  uint8_t *v3;\n  long long v4;\n  uint8_t v5;\n  int v6;\n  uint8_t *v7;\n  long long v8;\n  long long v9;\n  int i;\n  uint8_t key[16];\n  uint8_t ciphertext[16];\n  uint8_t decrypted[16];\n  __m128i ref_ciphertext;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  *(__m128i *)key = _mm_load_si128((const __m128i *)&xmmword_40D0);\n  if (libmin_strlen(\"This is a test!!\") != 16) libmin_fail(1);\n  v3 = ciphertext;\n  v4 = 0LL;\n  v5 = -8;\n  libmin_memcpy(ciphertext, \"This is a test!!\", 16uLL);\n  aes_encrypt(ciphertext, key);\n  ref_ciphertext = _mm_load_si128((const __m128i *)&xmmword_40E0);\n  while (ciphertext[v4] == v5) {\n    if (++v4 == 16) {\n      libmin_memcpy(decrypted, ciphertext, 16uLL);\n      aes_decrypt(decrypted, key);\n      libmin_printf(\"AES Cipher results:\\n\");\n      libmin_printf(\"  plaintext:  %s\\n\", \"This is a test!!\");\n      libmin_printf(\"  ciphertext: \");\n      do {\n        v6 = *v3++;\n        libmin_printf(\"%02x \", v6);\n      } while (v3 != decrypted);\n      v7 = decrypted;\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"  decrypted:  \");\n      do {\n        v8 = *v7++;\n        libmin_printf(\"%c\", v8);\n      } while (v7 != (uint8_t *)&ref_ciphertext);\n      v9 = 0LL;\n      libmin_printf((char *)\"\\n\");\n      for (i = 84; decrypted[v9] == i; i = src[v9]) {\n        if (++v9 == 16) libmin_success();\n      }\n      libmin_fail(3);\n    }\n    v5 = ref_ciphertext.m128i_u8[v4];\n  }\n  libmin_printf(\"Ciphertext mismatch at byte %d\\n\", v4);\n  libmin_printf(\"Expected: %02x, Got: %02x\\n\", v5, ciphertext[v4]);\n  libmin_fail(2);\n}", "binary": "aes/aes.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nlea    0x2ef1(%rip),%r12\npush   %rbp\nmov    %r12,%rdi\npush   %rbx\nsub    $0x68,%rsp\nmovdqa 0x2fac(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nmovaps %xmm0,0x10(%rsp)\ncall   3190 <libmin_strlen>\ncmp    $0x10,%rax\nje     114e <main+0x4e>\nmov    $0x1,%edi\ncall   1bd0 <libmin_fail>\nlea    0x20(%rsp),%rbx\nmov    $0x10,%edx\nmov    %r12,%rsi\nxor    %r13d,%r13d\nmov    %rbx,%rdi\nmov    $0xfffffff8,%r15d\nlea    0x40(%rsp),%rbp\ncall   1bf0 <libmin_memcpy>\nlea    0x10(%rsp),%rsi\nmov    %rbx,%rdi\nlea    0x2f00(%rip),%r14\nmov    %rsi,0x8(%rsp)\ncall   1780 <aes_encrypt>\nmovdqa 0x2f4e(%rip),%xmm0\nmovaps %xmm0,0x40(%rsp)\njmp    11a6 <main+0xa6>\nnopl   0x0(%rax)\nmovzbl 0x0(%r13,%rbp,1),%r15d\nmov    %r13d,%esi\ncmp    %r15b,(%rbx,%r13,1)\nje     11da <main+0xda>\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   2f80 <libmin_printf>\nmovzbl (%rbx,%r13,1),%edx\nmovzbl %r15b,%esi\nxor    %eax,%eax\nlea    0x2e4a(%rip),%rdi\ncall   2f80 <libmin_printf>\nmov    $0x2,%edi\ncall   1bd0 <libmin_fail>\nadd    $0x1,%r13\ncmp    $0x10,%r13\njne    11a0 <main+0xa0>\nlea    0x30(%rsp),%r13\nmov    $0x10,%edx\nmov    %rbx,%rsi\nmov    %r13,%rdi\nlea    0x2e6b(%rip),%r14\ncall   1bf0 <libmin_memcpy>\nmov    0x8(%rsp),%rsi\nmov    %r13,%rdi\ncall   18c0 <aes_decrypt>\nlea    0x2e1c(%rip),%rdi\nxor    %eax,%eax\ncall   2f80 <libmin_printf>\nmov    %r12,%rsi\nlea    0x2e20(%rip),%rdi\nxor    %eax,%eax\ncall   2f80 <libmin_printf>\nlea    0x2e24(%rip),%rdi\nxor    %eax,%eax\ncall   2f80 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\nmovzbl (%rbx),%esi\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   2f80 <libmin_printf>\ncmp    %r13,%rbx\njne    1240 <main+0x140>\nlea    0x2de6(%rip),%r15\nxor    %eax,%eax\nmov    %r13,%rbx\nmov    %r15,%rdi\nlea    0x2e0f(%rip),%r14\ncall   2f80 <libmin_printf>\nlea    0x2df4(%rip),%rdi\nxor    %eax,%eax\ncall   2f80 <libmin_printf>\nnop\nmovzbl (%rbx),%esi\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   2f80 <libmin_printf>\ncmp    %rbp,%rbx\njne    1280 <main+0x180>\nmov    %r15,%rdi\nxor    %eax,%eax\nxor    %ebx,%ebx\ncall   2f80 <libmin_printf>\nmov    $0x54,%eax\njmp    12b5 <main+0x1b5>\nnopl   0x0(%rax)\nmovsbl (%r12,%rbx,1),%eax\nmovzbl 0x0(%r13,%rbx,1),%edx\ncmp    %eax,%edx\nje     12c9 <main+0x1c9>\nmov    $0x3,%edi\ncall   1bd0 <libmin_fail>\nadd    $0x1,%rbx\ncmp    $0x10,%rbx\njne    12b0 <main+0x1b0>\ncall   31c0 <libmin_success>\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    12f9 <main+0x1f9>\nadd    $0x68,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\nxchg   %ax,%ax\n"}
{"source": {"path": "aes/aes.c", "function_name": "mix_columns", "content": "void mix_columns(uint8_t *s) {\n  for (int i = 0; i < 4; i++) {\n    int c = i * 4;\n    uint8_t a = s[c];\n    uint8_t b = s[c + 1];\n    uint8_t c1 = s[c + 2];\n    uint8_t d = s[c + 3];\n    uint8_t r = a ^ b ^ c1 ^ d;\n\n    uint8_t x = a ^ b;\n    x = gf256_mul2(x);\n    s[c] ^= x ^ r;\n\n    x = b ^ c1;\n    x = gf256_mul2(x);\n    s[c + 1] ^= x ^ r;\n\n    x = c1 ^ d;\n    x = gf256_mul2(x);\n    s[c + 2] ^= x ^ r;\n\n    x = d ^ a;\n    x = gf256_mul2(x);\n    s[c + 3] ^= x ^ r;\n  }\n}\n"}, "pseudo": {"path": "aes/aes.host.O2.pseudo", "function_name": "mix_columns", "address": "0x1580", "label": "mix_columns", "content": "void __fastcall mix_columns(uint8_t *s)\n{\n  uint8_t *v1; // rax\n  uint8_t *v2; // rdi\n  uint8_t v3; // cl\n  __int64 v4; // r9\n  char v5; // si\n  char v6; // dl\n  char v7; // r8\n  char v8; // si\n  char v9; // dl\n  bool v10; // sf\n  char v11; // si\n  char v12; // si\n  char v13; // cl\n  char v14; // dl\n  char v15; // cl\n  uint8_t v16; // dl\n\n  v1 = s;\n  v2 = s + 16;\n  do\n  {\n    v3 = *v1;\n    v4 = (unsigned __int8)(v1[3] ^ v1[2]);\n    v5 = *v1 ^ v1[1];\n    v6 = 2 * v5;\n    v7 = v4 ^ v5;\n    if ( v5 < 0 )\n      v6 = (2 * v5) ^ 0x1B;\n    v8 = v1[2] ^ v1[1];\n    *v1 ^= v7 ^ v6;\n    v9 = 2 * v8;\n    v10 = v8 < 0;\n    v11 = (2 * v8) ^ 0x1B;\n    if ( !v10 )\n      v11 = v9;\n    v1[1] ^= v11 ^ v7;\n    v12 = (2 * v4) ^ 0x1B;\n    if ( (v4 & 0x80u) == 0LL )\n      v12 = 2 * v4;\n    v13 = v1[3] ^ v3;\n    v1[2] ^= v12 ^ v7;\n    v14 = 2 * v13;\n    v10 = v13 < 0;\n    v15 = (2 * v13) ^ 0x1B;\n    if ( !v10 )\n      v15 = v14;\n    v16 = v1[3];\n    v1 += 4;\n    *(v1 - 1) = v15 ^ v7 ^ v16;\n  }\n  while ( v1 != v2 );\n}\n"}, "pseudo_normalize": "void mix_columns(uint8_t *s) {\n  uint8_t *v1;\n  uint8_t *v2;\n  uint8_t v3;\n  long long v4;\n  char v5;\n  char v6;\n  char v7;\n  char v8;\n  char v9;\n  bool v10;\n  char v11;\n  char v12;\n  char v13;\n  char v14;\n  char v15;\n  uint8_t v16;\n  v1 = s;\n  v2 = s + 16;\n  do {\n    v3 = *v1;\n    v4 = (unsigned char)(v1[3] ^ v1[2]);\n    v5 = *v1 ^ v1[1];\n    v6 = 2 * v5;\n    v7 = v4 ^ v5;\n    if (v5 < 0) v6 = (2 * v5) ^ 27;\n    v8 = v1[2] ^ v1[1];\n    *v1 ^= v7 ^ v6;\n    v9 = 2 * v8;\n    v10 = v8 < 0;\n    v11 = (2 * v8) ^ 27;\n    if (!v10) v11 = v9;\n    v1[1] ^= v11 ^ v7;\n    v12 = (2 * v4) ^ 27;\n    if ((v4 & 128u) == 0LL) v12 = 2 * v4;\n    v13 = v1[3] ^ v3;\n    v1[2] ^= v12 ^ v7;\n    v14 = 2 * v13;\n    v10 = v13 < 0;\n    v15 = (2 * v13) ^ 27;\n    if (!v10) v15 = v14;\n    v16 = v1[3];\n    v1 += 4;\n    *(v1 - 1) = v15 ^ v7 ^ v16;\n  } while (v1 != v2);\n}", "binary": "aes/aes.host.O2", "assembly": "<mix_columns>:\nendbr64\nmov    %rdi,%rax\nlea    0x10(%rdi),%rdi\nmovzbl (%rax),%ecx\nmovzbl 0x1(%rax),%esi\nmovzbl 0x2(%rax),%r9d\nxor    0x3(%rax),%r9b\nxor    %ecx,%esi\nmovzbl %sil,%edx\nmov    %esi,%r8d\nadd    %edx,%edx\nxor    %r9d,%r8d\nmov    %edx,%r10d\nxor    $0x1b,%r10d\ntest   %sil,%sil\nmov    %ecx,%esi\ncmovs  %r10d,%edx\nxor    %r8d,%esi\nxor    %esi,%edx\nmovzbl 0x1(%rax),%esi\nxor    0x2(%rax),%sil\nmov    %dl,(%rax)\nmovzbl %sil,%edx\nadd    %edx,%edx\nmov    %edx,%r10d\nxor    $0x1b,%r10d\ntest   %sil,%sil\nmov    %r10d,%esi\ncmovns %edx,%esi\nmovzbl 0x1(%rax),%edx\nxor    %r8d,%edx\nxor    %esi,%edx\nmov    %dl,0x1(%rax)\nmovzbl %r9b,%edx\nadd    %edx,%edx\nmov    %edx,%esi\nxor    $0x1b,%esi\ntest   %r9b,%r9b\ncmovns %edx,%esi\nmovzbl 0x2(%rax),%edx\nxor    0x3(%rax),%cl\nxor    %r8d,%edx\nxor    %esi,%edx\nmov    %dl,0x2(%rax)\nmovzbl %cl,%edx\nadd    %edx,%edx\nmov    %edx,%esi\nxor    $0x1b,%esi\ntest   %cl,%cl\nmov    %esi,%ecx\ncmovns %edx,%ecx\nmovzbl 0x3(%rax),%edx\nadd    $0x4,%rax\nxor    %r8d,%edx\nxor    %ecx,%edx\nmov    %dl,-0x1(%rax)\ncmp    %rdi,%rax\njne    158b <mix_columns+0xb>\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "aes/aes.c", "function_name": "shift_rows", "content": "void shift_rows(uint8_t *s) {\n  uint8_t res[BLK_SIZE];\n  uint8_t idx[BLK_SIZE] = {0, 5,  10, 15, 4,  9, 14, 3,\n                           8, 13, 2,  7,  12, 1, 6,  11};\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    res[i] = s[idx[i]];\n\n  for (int i = 0; i < BLK_SIZE; i++)\n    s[i] = res[i];\n}\n"}, "pseudo": {"path": "aes/aes.host.O2.pseudo", "function_name": "shift_rows", "address": "0x1480", "label": "shift_rows", "content": "void __fastcall shift_rows(uint8_t *s)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rax\n  uint8_t res[16]; // [rsp+0h] [rbp-38h] BYREF\n  __m128i idx; // [rsp+10h] [rbp-28h]\n  unsigned __int64 v5; // [rsp+28h] [rbp-10h]\n\n  v1 = 0LL;\n  v5 = __readfsqword(0x28u);\n  v2 = 0LL;\n  for ( idx = _mm_load_si128((const __m128i *)&xmmword_40B0); ; v1 = idx.m128i_u8[v2] )\n  {\n    res[v2++] = s[v1];\n    if ( v2 == 16 )\n      break;\n  }\n  *(__m128i *)s = _mm_load_si128((const __m128i *)res);\n}\n"}, "pseudo_normalize": "void shift_rows(uint8_t *s) {\n  long long v1;\n  long long v2;\n  uint8_t res[16];\n  __m128i idx;\n  unsigned long long v5;\n  v1 = 0LL;\n  v5 = __readfsqword(40u);\n  v2 = 0LL;\n  for (idx = _mm_load_si128((const __m128i *)&xmmword_40B0);;\n       v1 = idx.m128i_u8[v2]) {\n    res[v2++] = s[v1];\n    if (v2 == 16) break;\n  }\n  *(__m128i *)s = _mm_load_si128((const __m128i *)res);\n}", "binary": "aes/aes.host.O2", "assembly": "<shift_rows>:\nendbr64\nsub    $0x38,%rsp\nmovdqa 0x2c20(%rip),%xmm0\nxor    %edx,%edx\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rcx\nmovaps %xmm0,0x10(%rsp)\njmp    14b5 <shift_rows+0x35>\nnopl   0x0(%rax)\nmovzbl 0x10(%rsp,%rax,1),%edx\nmovzbl (%rdi,%rdx,1),%edx\nmov    %dl,(%rcx,%rax,1)\nadd    $0x1,%rax\ncmp    $0x10,%rax\njne    14b0 <shift_rows+0x30>\nmovdqa (%rsp),%xmm1\nmovups %xmm1,(%rdi)\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    14e3 <shift_rows+0x63>\nadd    $0x38,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "AddWords", "content": "/* AddWords -- build the list of candidates */\nvoid\nAddWords(void) {\n    char * pch = pchDictionary;     /* walk through the dictionary */\n\n    cpwCand = 0;\n\n    while (*pch) {\n        if ((pch[1] >= cchMinLength && pch[1]+cchMinLength <= cchPhraseLength)\n            || pch[1] == cchPhraseLength)\n\t    BuildWord(pch+2);\n        pch += *pch;\n    }\n\n    libmin_printf(\"%d candidates\\n\", cpwCand);\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "AddWords", "address": "0x1910", "label": "AddWords", "content": "void __cdecl AddWords()\n{\n  char *v0; // rbx\n  int v1; // edx\n\n  v0 = pchDictionary;\n  cpwCand = 0;\n  if ( *pchDictionary )\n  {\n    do\n    {\n      while ( 1 )\n      {\n        v1 = v0[1];\n        if ( (v1 < cchMinLength || v1 + cchMinLength > cchPhraseLength) && v1 != cchPhraseLength )\n          break;\n        BuildWord(v0 + 2);\n        v0 += *v0;\n        if ( !*v0 )\n          goto LABEL_8;\n      }\n      v0 += *v0;\n    }\n    while ( *v0 );\nLABEL_8:\n    libmin_printf(\"%d candidates\\n\", cpwCand);\n  }\n  else\n  {\n    libmin_printf(\"%d candidates\\n\", 0);\n  }\n}\n"}, "pseudo_normalize": "void AddWords() {\n  char *v0;\n  int v1;\n  v0 = pchDictionary;\n  cpwCand = 0;\n  if (*pchDictionary) {\n    do {\n      while (1) {\n        v1 = v0[1];\n        if ((v1 < cchMinLength || v1 + cchMinLength > cchPhraseLength) &&\n            v1 != cchPhraseLength)\n          break;\n        BuildWord(v0 + 2);\n        v0 += *v0;\n        if (!*v0) goto LABEL_8;\n      }\n      v0 += *v0;\n    } while (*v0);\n  LABEL_8:\n    libmin_printf(\"%d candidates\\n\", cpwCand);\n  } else {\n    libmin_printf(\"%d candidates\\n\", 0);\n  }\n}", "binary": "anagram/anagram.host.O2", "assembly": "<AddWords>:\nendbr64\npush   %rbx\nmov    0x36c9c(%rip),%rbx\nmovl   $0x0,0x36efa(%rip)\ncmpb   $0x0,(%rbx)\njne    194b <AddWords+0x3b>\njmp    1988 <AddWords+0x78>\nnopl   (%rax)\nadd    %edx,%eax\ncmp    %ecx,%eax\njg     195f <AddWords+0x4f>\nlea    0x2(%rbx),%rdi\ncall   17d0 <BuildWord>\nmovsbq (%rbx),%rax\nadd    %rax,%rbx\ncmpb   $0x0,(%rbx)\nje     196f <AddWords+0x5f>\nmovsbl 0x1(%rbx),%edx\nmov    0x366bb(%rip),%eax\nmov    0x36d15(%rip),%ecx\ncmp    %eax,%edx\njge    1930 <AddWords+0x20>\ncmp    %ecx,%edx\nje     1936 <AddWords+0x26>\nmovsbq (%rbx),%rax\nadd    %rax,%rbx\ncmpb   $0x0,(%rbx)\njne    194b <AddWords+0x3b>\nmov    0x36eab(%rip),%esi\nlea    0x2778(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\njmp    38e0 <libmin_printf>\nnopl   0x0(%rax)\nxor    %esi,%esi\nlea    0x2763(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\njmp    38e0 <libmin_printf>\nnopl   0x0(%rax)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "BuildMask", "content": "void BuildMask(char * pchPhrase) {\n    int i;\n    int ch;\n    unsigned iq;                        /* which Quad? */\n    int cbtUsed;                        /* bits used in the current Quad */\n    int cbtNeed;                        /* bits needed for current letter */\n    Quad qNeed;                         /* used to build the mask */\n\n    libmin_memset(alPhrase, 0, sizeof(Letter)*ALPHABET);\n    libmin_memset(aqMainMask, 0, sizeof(Quad)*MAX_QUADS);\n    libmin_memset(aqMainSign, 0, sizeof(Quad)*MAX_QUADS);\n/*\n    Zero(alPhrase);\n    Zero(aqMainMask);\n    Zero(aqMainSign);\n*/\n\n    /* Tabulate letter frequencies in the phrase */\n    cchPhraseLength = 0;\n    while ((ch = *pchPhrase++) != '\\0') {\n        if (isalpha(ch)) {\n            ch = tolower(ch);\n            lPhrase(ch).uFrequency++;\n            cchPhraseLength++;\n        }\n    }\n\n    /* Build  masks */\n    iq = 0;                             /* which quad being used */\n    cbtUsed = 0;                        /* bits used so far */\n\n    for (i = 0; i < ALPHABET; i++) {\n        if (alPhrase[i].uFrequency == 0) {\n            auGlobalFrequency[i] = ~0;  /* to make it sort last */\n        } else {\n            auGlobalFrequency[i] = 0;\n            for (cbtNeed = 1, qNeed = 1;\n                 alPhrase[i].uFrequency >= qNeed;\n                 cbtNeed++, qNeed <<= 1);\n            if (cbtUsed + cbtNeed > MASK_BITS) {\n                if (++iq >= MAX_QUADS)\n\t\t    Fatal(\"MAX_QUADS not large enough\\n\", 0);\n                cbtUsed = 0;\n            }\n            alPhrase[i].uBits = qNeed-1;\n            if (cbtUsed)\n\t\tqNeed <<= cbtUsed;\n            aqMainSign[iq] |= qNeed;\n            aqMainMask[iq] |= (Quad)alPhrase[i].uFrequency << cbtUsed;\n            alPhrase[i].uShift = cbtUsed;\n            alPhrase[i].iq = iq;\n            cbtUsed += cbtNeed;\n        }\n    }\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "BuildMask", "address": "0x14c0", "label": "BuildMask", "content": "void __fastcall BuildMask(char *pchPhrase)\n{\n  unsigned __int16 *v1; // rsi\n  unsigned __int64 v2; // rcx\n  int v3; // eax\n  __int64 v4; // rdx\n  unsigned __int16 v5; // dx\n  Letter *v6; // rbp\n  unsigned int *v7; // r13\n  unsigned int v8; // esi\n  unsigned int v9; // r8d\n  Letter *v10; // rdx\n  unsigned __int64 uFrequency; // rax\n  unsigned __int64 v12; // rbx\n  int v13; // r12d\n  unsigned int v14; // r10d\n  unsigned int v15; // r11d\n  __int64 v16; // rdi\n\n  libmin_memset(alPhrase, 0, 0x1A0uLL);\n  libmin_memset(aqMainMask, 0, 0x10uLL);\n  libmin_memset(aqMainSign, 0, 0x10uLL);\n  v1 = pctype;\n  v2 = (unsigned __int64)(pchPhrase + 1);\n  cchPhraseLength = 0;\n  v3 = *pchPhrase;\n  v4 = *pchPhrase;\n  if ( *pchPhrase )\n  {\n    do\n    {\n      v5 = v1[v4];\n      if ( (v5 & 3) != 0 )\n      {\n        if ( (v5 & 1) != 0 )\n          v3 += 32;\n        ++cchPhraseLength;\n        ++alPhrase[v3 - 97].uFrequency;\n      }\n      v4 = *(char *)v2++;\n      v3 = (char)v4;\n    }\n    while ( (_BYTE)v4 );\n  }\n  v6 = alPhrase;\n  v7 = auGlobalFrequency;\n  v8 = 0;\n  v9 = 0;\n  v10 = &alPhrase[26];\n  do\n  {\n    while ( 1 )\n    {\n      uFrequency = v6->uFrequency;\n      if ( (_DWORD)uFrequency )\n        break;\n      ++v6;\n      *v7++ = -1;\n      if ( v10 == v6 )\n        return;\n    }\n    *v7 = 0;\n    v12 = 1LL;\n    v13 = 1;\n    do\n    {\n      v12 *= 2LL;\n      ++v13;\n    }\n    while ( v12 <= uFrequency );\n    v14 = v12 - 1;\n    if ( (int)(v13 + v8) <= 32 )\n    {\n      v15 = v8;\n      if ( v8 )\n      {\n        v12 <<= v8;\n        v2 = v8;\n      }\n      else\n      {\n        v2 = 0LL;\n      }\n      v8 += v13;\n    }\n    else\n    {\n      if ( ++v9 > 1 )\n      {\n        libmin_printf(\"MAX_QUADS not large enough\\n\", 0LL, v10, v2);\n        libmin_fail(1);\n      }\n      v8 = v13;\n      v15 = 0;\n      v2 = 0LL;\n    }\n    v16 = v6->uFrequency;\n    v6->uBits = v14;\n    ++v6;\n    v6[-1].uShift = v15;\n    ++v7;\n    v6[-1].iq = v9;\n    aqMainSign[v9] |= v12;\n    aqMainMask[v9] |= v16 << v2;\n  }\n  while ( v10 != v6 );\n}\n"}, "pseudo_normalize": "void BuildMask(char *pchPhrase) {\n  unsigned short *v1;\n  unsigned long long v2;\n  int v3;\n  long long v4;\n  unsigned short v5;\n  Letter *v6;\n  unsigned int *v7;\n  unsigned int v8;\n  unsigned int v9;\n  Letter *v10;\n  unsigned long long uFrequency;\n  unsigned long long v12;\n  int v13;\n  unsigned int v14;\n  unsigned int v15;\n  long long v16;\n  libmin_memset(alPhrase, 0, 416uLL);\n  libmin_memset(aqMainMask, 0, 16uLL);\n  libmin_memset(aqMainSign, 0, 16uLL);\n  v1 = pctype;\n  v2 = (unsigned long long)(pchPhrase + 1);\n  cchPhraseLength = 0;\n  v3 = *pchPhrase;\n  v4 = *pchPhrase;\n  if (*pchPhrase) {\n    do {\n      v5 = v1[v4];\n      if ((v5 & 3) != 0) {\n        if ((v5 & 1) != 0) v3 += 32;\n        ++cchPhraseLength;\n        ++alPhrase[v3 - 97].uFrequency;\n      }\n      v4 = *(char *)v2++;\n      v3 = (char)v4;\n    } while ((uint8_t)v4);\n  }\n  v6 = alPhrase;\n  v7 = auGlobalFrequency;\n  v8 = 0;\n  v9 = 0;\n  v10 = &alPhrase[26];\n  do {\n    while (1) {\n      uFrequency = v6->uFrequency;\n      if ((uint32_t)uFrequency) break;\n      ++v6;\n      *v7++ = -1;\n      if (v10 == v6) return;\n    }\n    *v7 = 0;\n    v12 = 1LL;\n    v13 = 1;\n    do {\n      v12 *= 2LL;\n      ++v13;\n    } while (v12 <= uFrequency);\n    v14 = v12 - 1;\n    if ((int)(v13 + v8) <= 32) {\n      v15 = v8;\n      if (v8) {\n        v12 <<= v8;\n        v2 = v8;\n      } else {\n        v2 = 0LL;\n      }\n      v8 += v13;\n    } else {\n      if (++v9 > 1) {\n        libmin_printf(\"MAX_QUADS not large enough\\n\", 0LL, v10, v2);\n        libmin_fail(1);\n      }\n      v8 = v13;\n      v15 = 0;\n      v2 = 0LL;\n    }\n    v16 = v6->uFrequency;\n    v6->uBits = v14;\n    ++v6;\n    v6[-1].uShift = v15;\n    ++v7;\n    v6[-1].iq = v9;\n    aqMainSign[v9] |= v12;\n    aqMainMask[v9] |= v16 << v2;\n  } while (v10 != v6);\n}", "binary": "anagram/anagram.host.O2", "assembly": "<BuildMask>:\nendbr64\npush   %r15\nmov    $0x1a0,%edx\nxor    %esi,%esi\nlea    0x3718c(%rip),%r15\npush   %r14\nlea    0x37173(%rip),%r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nlea    0x37193(%rip),%rbx\nmov    %rbx,%rdi\nsub    $0x18,%rsp\ncall   2280 <libmin_memset>\nmov    $0x10,%edx\nxor    %esi,%esi\nmov    %r15,%rdi\ncall   2280 <libmin_memset>\nmov    $0x10,%edx\nxor    %esi,%esi\nmov    %r14,%rdi\ncall   2280 <libmin_memset>\nmov    0x36d8a(%rip),%rsi\nlea    0x1(%rbp),%rcx\nmovl   $0x0,0x37144(%rip)\nmovsbq 0x0(%rbp),%rax\nmov    %rax,%rdx\ntest   %eax,%eax\nje     1575 <BuildMask+0xb5>\nnopl   0x0(%rax,%rax,1)\nmovzwl (%rsi,%rdx,2),%edx\ntest   $0x3,%dl\nje     1566 <BuildMask+0xa6>\nand    $0x1,%edx\nlea    0x20(%rax),%edi\ncmovne %edi,%eax\naddl   $0x1,0x37117(%rip)\nsub    $0x61,%eax\ncltq\nshl    $0x4,%rax\naddl   $0x1,(%rbx,%rax,1)\nmovsbq (%rcx),%rdx\nadd    $0x1,%rcx\nmovsbl %dl,%eax\ntest   %eax,%eax\njne    1540 <BuildMask+0x80>\nlea    0x37104(%rip),%rbp\nlea    0x3705d(%rip),%r13\nxor    %esi,%esi\nxor    %r8d,%r8d\nlea    0x1a0(%rbp),%rdx\nlea    0x2b29(%rip),%r9\njmp    15b5 <BuildMask+0xf5>\nnopl   0x0(%rax,%rax,1)\nadd    $0x10,%rbp\nmovl   $0xffffffff,0x0(%r13)\nadd    $0x4,%r13\ncmp    %rbp,%rdx\nje     1625 <BuildMask+0x165>\nmov    0x0(%rbp),%eax\ntest   %eax,%eax\nje     15a0 <BuildMask+0xe0>\nmovl   $0x0,0x0(%r13)\nmov    $0x1,%ebx\nmov    $0x1,%r12d\nnop\nadd    %rbx,%rbx\nadd    $0x1,%r12d\ncmp    %rax,%rbx\njbe    15d0 <BuildMask+0x110>\nlea    (%r12,%rsi,1),%eax\nlea    -0x1(%rbx),%r10d\ncmp    $0x20,%eax\njle    1638 <BuildMask+0x178>\nadd    $0x1,%r8d\ncmp    $0x1,%r8d\nja     1650 <BuildMask+0x190>\nmov    %r12d,%esi\nxor    %r11d,%r11d\nxor    %ecx,%ecx\nmov    0x0(%rbp),%edi\nmov    %r8d,%eax\nmov    %r10d,0x8(%rbp)\nadd    $0x10,%rbp\nmov    %r11d,-0xc(%rbp)\nadd    $0x4,%r13\nshl    %cl,%rdi\nmov    %r8d,-0x4(%rbp)\nor     %rbx,(%r14,%rax,8)\nor     %rdi,(%r15,%rax,8)\ncmp    %rbp,%rdx\njne    15b5 <BuildMask+0xf5>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nmov    %esi,%r11d\ntest   %esi,%esi\nje     1695 <BuildMask+0x1d5>\nmov    %esi,%ecx\nshl    %cl,%rbx\nmov    %esi,%ecx\nmov    %eax,%esi\njmp    15fb <BuildMask+0x13b>\nnopw   0x0(%rax,%rax,1)\nmov    %r9,%rdi\nxor    %esi,%esi\nxor    %eax,%eax\nmov    %r10d,0xc(%rsp)\nmov    %r8d,0x8(%rsp)\ncall   38e0 <libmin_printf>\nmov    $0x1,%edi\ncall   1ff0 <libmin_fail>\nmov    0x8(%rsp),%r8d\nmov    %r12d,%esi\nxor    %r11d,%r11d\nmov    0xc(%rsp),%r10d\nxor    %ecx,%ecx\nlea    0x2a36(%rip),%r9\nlea    0x37190(%rip),%rdx\njmp    15fb <BuildMask+0x13b>\nxor    %ecx,%ecx\nmov    %eax,%esi\njmp    15fb <BuildMask+0x13b>\nxchg   %ax,%ax\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "BuildWord", "content": "/* BuildWord -- build a Word structure from an ASCII word\n * If the word does not fit, then do nothing.\n */\nvoid BuildWord(char * pchWord) {\n    unsigned char cchFrequency[ALPHABET];\n    int i;\n    char * pch = pchWord;\n    PWord pw;\n    int cchLength = 0;\n\n    libmin_memset(cchFrequency, 0, sizeof(unsigned char)*ALPHABET);\n    /* Zero(cchFrequency); */\n\n    /* Build frequency table */\n    while ((i = *pch++) != '\\0') {\n        if (!isalpha(i)) continue;\n        i = ch2i(tolower(i));\n        if (++cchFrequency[i] > alPhrase[i].uFrequency)\n\t    return;\n        ++cchLength;\n    }\n\n    Debug(wprint(pchWord);)\n\n    /* Update global count */\n    for (i = 0; i < ALPHABET; i++)\n        auGlobalFrequency[i] += cchFrequency[i];\n\n    /* Create a Word structure and fill it in, including building the\n     * bitfield of frequencies.\n     */\n    pw = NextWord();\n    libmin_memset(pw->aqMask, 0, sizeof(Quad)*MAX_QUADS);\n    /* Zero(pw->aqMask); */\n    pw->pchWord = pchWord;\n    pw->cchLength = cchLength;\n    for (i = 0; i < ALPHABET; i++) {\n        pw->aqMask[alPhrase[i].iq] |=\n            (Quad)cchFrequency[i] << alPhrase[i].uShift;\n    }\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "BuildWord", "address": "0x17d0", "label": "BuildWord", "content": "void __fastcall BuildWord(char *pchWord)\n{\n  int v1; // eax\n  unsigned __int16 *v2; // rsi\n  char *v3; // rcx\n  __int64 v4; // rdx\n  unsigned int v5; // r12d\n  unsigned __int16 v6; // dx\n  int v7; // r8d\n  int v8; // eax\n  unsigned __int8 v9; // dl\n  unsigned int *v10; // rax\n  unsigned __int8 *v11; // rdx\n  PWord Word; // r13\n  Letter *p_uShift; // rax\n  unsigned int uFrequency; // ecx\n  unsigned __int8 cchFrequency[26]; // [rsp+0h] [rbp+0h] BYREF\n  unsigned __int64 vars28; // [rsp+28h] [rbp+28h]\n\n  vars28 = __readfsqword(0x28u);\n  libmin_memset(cchFrequency, 0, 0x1AuLL);\n  v1 = *pchWord;\n  if ( *pchWord )\n  {\n    v2 = pctype;\n    v3 = pchWord + 1;\n    v4 = *pchWord;\n    v5 = 0;\n    while ( 1 )\n    {\n      v6 = v2[v4];\n      if ( (v6 & 3) != 0 )\n      {\n        v7 = v1 - 65;\n        v8 = v1 - 97;\n        if ( (v6 & 1) != 0 )\n          v8 = v7;\n        v9 = cchFrequency[v8] + 1;\n        cchFrequency[v8] = v9;\n        if ( v9 > alPhrase[v8].uFrequency )\n          return;\n        ++v5;\n      }\n      v4 = *v3++;\n      v1 = (char)v4;\n      if ( !(_BYTE)v4 )\n        goto LABEL_9;\n    }\n  }\n  v5 = 0;\nLABEL_9:\n  v10 = auGlobalFrequency;\n  v11 = cchFrequency;\n  do\n    *v10++ += *v11++;\n  while ( &auGlobalFrequency[26] != v10 );\n  Word = NextWord();\n  libmin_memset(Word, 0, 0x10uLL);\n  Word->pchWord = pchWord;\n  p_uShift = (Letter *)&alPhrase[0].uShift;\n  Word->cchLength = v5;\n  do\n  {\n    uFrequency = p_uShift->uFrequency;\n    ++p_uShift;\n    Word->aqMask[p_uShift[-1].uBits] |= (unsigned __int64)cchFrequency[0] << uFrequency;\n  }\n  while ( &alPhrase[26].uShift != (unsigned int *)p_uShift );\n}\n"}, "pseudo_normalize": "void BuildWord(char *pchWord) {\n  int v1;\n  unsigned short *v2;\n  char *v3;\n  long long v4;\n  unsigned int v5;\n  unsigned short v6;\n  int v7;\n  int v8;\n  unsigned char v9;\n  unsigned int *v10;\n  unsigned char *v11;\n  PWord Word;\n  Letter *p_uShift;\n  unsigned int uFrequency;\n  unsigned char cchFrequency[26];\n  unsigned long long vars28;\n  vars28 = __readfsqword(40u);\n  libmin_memset(cchFrequency, 0, 26uLL);\n  v1 = *pchWord;\n  if (*pchWord) {\n    v2 = pctype;\n    v3 = pchWord + 1;\n    v4 = *pchWord;\n    v5 = 0;\n    while (1) {\n      v6 = v2[v4];\n      if ((v6 & 3) != 0) {\n        v7 = v1 - 65;\n        v8 = v1 - 97;\n        if ((v6 & 1) != 0) v8 = v7;\n        v9 = cchFrequency[v8] + 1;\n        cchFrequency[v8] = v9;\n        if (v9 > alPhrase[v8].uFrequency) return;\n        ++v5;\n      }\n      v4 = *v3++;\n      v1 = (char)v4;\n      if (!(uint8_t)v4) goto LABEL_9;\n    }\n  }\n  v5 = 0;\nLABEL_9:\n  v10 = auGlobalFrequency;\n  v11 = cchFrequency;\n  do *v10++ += *v11++;\n  while (&auGlobalFrequency[26] != v10);\n  Word = NextWord();\n  libmin_memset(Word, 0, 16uLL);\n  Word->pchWord = pchWord;\n  p_uShift = (Letter *)&alPhrase[0].uShift;\n  Word->cchLength = v5;\n  do {\n    uFrequency = p_uShift->uFrequency;\n    ++p_uShift;\n    Word->aqMask[p_uShift[-1].uBits] |= (unsigned long long)cchFrequency[0]\n                                        << uFrequency;\n  } while (&alPhrase[26].uShift != (unsigned int *)p_uShift);\n}", "binary": "anagram/anagram.host.O2", "assembly": "<BuildWord>:\nendbr64\npush   %r13\nmov    $0x1a,%edx\nxor    %esi,%esi\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbp\nmov    %rbp,%rdi\ncall   2280 <libmin_memset>\nmovsbq (%rbx),%rax\ntest   %eax,%eax\nje     18f9 <BuildWord+0x129>\nmov    0x36a92(%rip),%rsi\nlea    0x1(%rbx),%rcx\nmov    %rax,%rdx\nxor    %r12d,%r12d\nlea    0x36e59(%rip),%rdi\nnopw   0x0(%rax,%rax,1)\nmovzwl (%rsi,%rdx,2),%edx\ntest   $0x3,%dl\nje     1863 <BuildWord+0x93>\nlea    -0x41(%rax),%r8d\nsub    $0x61,%eax\nand    $0x1,%edx\ncmovne %r8d,%eax\ncltq\nmovzbl (%rsp,%rax,1),%edx\nadd    $0x1,%edx\nmov    %dl,(%rsp,%rax,1)\nshl    $0x4,%rax\nmovzbl %dl,%edx\ncmp    (%rdi,%rax,1),%edx\nja     18de <BuildWord+0x10e>\nadd    $0x1,%r12d\nmovsbq (%rcx),%rdx\nadd    $0x1,%rcx\nmovsbl %dl,%eax\ntest   %eax,%eax\njne    1830 <BuildWord+0x60>\nlea    0x36d67(%rip),%rax\nmov    %rbp,%rdx\nlea    0x68(%rax),%rsi\nmovzbl (%rdx),%ecx\nadd    %ecx,(%rax)\nadd    $0x4,%rax\nadd    $0x1,%rdx\ncmp    %rax,%rsi\njne    1880 <BuildWord+0xb0>\ncall   1710 <NextWord>\nmov    $0x10,%edx\nxor    %esi,%esi\nmov    %rax,%r13\nmov    %rax,%rdi\ncall   2280 <libmin_memset>\nmov    %rbx,0x10(%r13)\nlea    0x36dd0(%rip),%rax\nmov    %r12d,0x18(%r13)\nlea    0x1a0(%rax),%rdi\nnop\nmovzbl 0x0(%rbp),%edx\nmov    (%rax),%ecx\nadd    $0x10,%rax\nadd    $0x1,%rbp\nmov    -0x8(%rax),%esi\nshl    %cl,%rdx\nor     %rdx,0x0(%r13,%rsi,8)\ncmp    %rax,%rdi\njne    18c0 <BuildWord+0xf0>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1901 <BuildWord+0x131>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nxor    %r12d,%r12d\njmp    1872 <BuildWord+0xa2>\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "CompareFrequency", "content": "int Cdecl CompareFrequency(char *pch1, char *pch2) {\n    return auGlobalFrequency[(int)(*pch1)] < auGlobalFrequency[(int)(*pch2)]\n        ?  -1 :\n           auGlobalFrequency[(int)(*pch1)] == auGlobalFrequency[(int)(*pch2)]\n        ?   0 : 1;\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "CompareFrequency", "address": "0x1310", "label": "CompareFrequency", "content": "int __fastcall CompareFrequency(char *pch1, char *pch2)\n{\n  __int64 v2; // rcx\n  int v3; // r8d\n  unsigned int v4; // edx\n\n  v2 = *pch1;\n  v3 = -1;\n  v4 = auGlobalFrequency[*pch2];\n  if ( auGlobalFrequency[v2] >= v4 )\n    return auGlobalFrequency[v2] != v4;\n  return v3;\n}\n"}, "pseudo_normalize": "int CompareFrequency(char *pch1, char *pch2) {\n  long long v2;\n  int v3;\n  unsigned int v4;\n  v2 = *pch1;\n  v3 = -1;\n  v4 = auGlobalFrequency[*pch2];\n  if (auGlobalFrequency[v2] >= v4) return auGlobalFrequency[v2] != v4;\n  return v3;\n}", "binary": "anagram/anagram.host.O2", "assembly": "<CompareFrequency>:\nendbr64\nmovsbq (%rsi),%rdx\nmovsbq (%rdi),%rcx\nlea    0x372bd(%rip),%rax\nmov    $0xffffffff,%r8d\nmov    (%rax,%rdx,4),%edx\ncmp    %edx,(%rax,%rcx,4)\njb     1339 <CompareFrequency+0x29>\nsetne  %r8b\nmovzbl %r8b,%r8d\nmov    %r8d,%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "DumpCandidates", "content": "void DumpCandidates(void) {\n    unsigned u;\n\n    for (u = 0; u < cpwCand; u++)\n        libmin_printf(StringFormat, apwCand[u]->pchWord, (u % 4 == 3) ? '\\n' : ' ');\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "DumpCandidates", "address": "0x19a0", "label": "DumpCandidates", "content": "void __cdecl DumpCandidates()\n{\n  __int64 v0; // rbx\n  __int64 v1; // rdx\n\n  if ( cpwCand )\n  {\n    v0 = 1LL;\n    v1 = 32LL;\n    while ( 1 )\n    {\n      libmin_printf(\"%15s%c\", *(const char **)(qword_38838[v0] + 16LL), v1);\n      if ( cpwCand <= (unsigned int)v0 )\n        break;\n      v1 = 10LL;\n      if ( (v0 & 3) != 3 )\n        v1 = 32LL;\n      ++v0;\n    }\n  }\n  libmin_printf((char *)\"\\n\");\n}\n"}, "pseudo_normalize": "void DumpCandidates() {\n  long long v0;\n  long long v1;\n  if (cpwCand) {\n    v0 = 1LL;\n    v1 = 32LL;\n    while (1) {\n      libmin_printf(\"%15s%c\", *(const char **)(qword_38838[v0] + 16LL), v1);\n      if (cpwCand <= (unsigned int)v0) break;\n      v1 = 10LL;\n      if ((v0 & 3) != 3) v1 = 32LL;\n      ++v0;\n    }\n  }\n  libmin_printf((char *)\"\\n\");\n}", "binary": "anagram/anagram.host.O2", "assembly": "<DumpCandidates>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x36e6c(%rip),%eax\ntest   %eax,%eax\nje     1a10 <DumpCandidates+0x70>\nmov    $0x1,%ebx\nmov    $0x20,%edx\nlea    0x36e6f(%rip),%r13\nmov    $0x20,%r12d\nlea    0x272d(%rip),%rbp\njmp    19f5 <DumpCandidates+0x55>\nnopl   0x0(%rax,%rax,1)\nmov    %ebx,%eax\nmov    $0xa,%edx\nand    $0x3,%eax\ncmp    $0x3,%eax\ncmovne %r12d,%edx\nadd    $0x1,%rbx\nmov    0x0(%r13,%rbx,8),%rax\nmov    %rbp,%rdi\nmov    0x10(%rax),%rsi\nxor    %eax,%eax\ncall   38e0 <libmin_printf>\ncmp    %ebx,0x36e12(%rip)\nja     19e0 <DumpCandidates+0x40>\nadd    $0x8,%rsp\nlea    0x2716(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    38e0 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "DumpWords", "content": ")                                       /* End of debug code */\n\nvoid DumpWords(void) {\n    int i;\n    for (i = 0; i < cpwLast; i++) wprint(apwSol[i]->pchWord);\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "DumpWords", "address": "0x1a30", "label": "DumpWords", "content": "void __cdecl DumpWords()\n{\n  __int64 v0; // rbx\n  PWord v1; // rax\n\n  if ( cpwLast > 0 )\n  {\n    v0 = 0LL;\n    do\n    {\n      v1 = apwSol[v0++];\n      libmin_printf(\"%s \", v1->pchWord);\n    }\n    while ( cpwLast > (int)v0 );\n  }\n  libmin_printf((char *)\"\\n\");\n}\n"}, "pseudo_normalize": "void DumpWords() {\n  long long v0;\n  PWord v1;\n  if (cpwLast > 0) {\n    v0 = 0LL;\n    do {\n      v1 = apwSol[v0++];\n      libmin_printf(\"%s \", v1->pchWord);\n    } while (cpwLast > (int)v0);\n  }\n  libmin_printf((char *)\"\\n\");\n}", "binary": "anagram/anagram.host.O2", "assembly": "<DumpWords>:\nendbr64\nmov    0x369c6(%rip),%eax\npush   %r12\npush   %rbp\npush   %rbx\ntest   %eax,%eax\njle    1a76 <DumpWords+0x46>\nxor    %ebx,%ebx\nlea    0x369d5(%rip),%r12\nlea    0x2689(%rip),%rbp\nnopw   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,8),%rax\nmov    %rbp,%rdi\nadd    $0x1,%rbx\nmov    0x10(%rax),%rsi\nxor    %eax,%eax\ncall   38e0 <libmin_printf>\ncmp    %ebx,0x3698c(%rip)\njg     1a58 <DumpWords+0x28>\npop    %rbx\nlea    0x26b3(%rip),%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\njmp    38e0 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "FindAnagram", "content": "void\nFindAnagram(Quad * pqMask, PPWord ppwStart, int iLetter)\n{\n    Quad aqNext[MAX_QUADS];\n    register PWord pw;\n    Quad qMask;\n    unsigned iq;\n    PPWord ppwEnd = &apwCand[0];\n    ppwEnd += cpwCand;\n\n    ;\n\n    Debug(libmin_printf(\"Trying :\"); DumpWord(pqMask); libmin_printf(\":\\n\");)\n\n    for (;;) {\n        iq = alPhrase[(int)achByFrequency[iLetter]].iq;\n        qMask = alPhrase[(int)achByFrequency[iLetter]].uBits <<\n                alPhrase[(int)achByFrequency[iLetter]].uShift;\n        if (pqMask[iq] & qMask) break;\n        iLetter++;\n    }\n\n    Debug(libmin_printf(\"Pivoting on %c\\n\", i2ch(achByFrequency[iLetter]));)\n\n    while (ppwStart < ppwEnd) {          /* Half of the program execution */\n        pw = *ppwStart;                  /* time is spent in these three */\n\n        Stat(if (++ulLowCount == 0) ++ulHighCount;)\n\n#if MAX_QUADS > 0\n        OneStep(0);                     /* lines of code. */\n#endif\n\n#if MAX_QUADS > 1\n        OneStep(1);\n#endif\n\n#if MAX_QUADS > 2\n        OneStep(2);\n#endif\n\n#if MAX_QUADS > 3\n        OneStep(3);\n#endif\n\n#if MAX_QUADS > 4\n            @@\"Add more unrolling steps here, please.\"@@\n#endif\n\n        /* If the pivot letter isn't present, defer this word until later */\n        if ((pw->aqMask[iq] & qMask) == 0) {\n            *ppwStart = *--ppwEnd;\n            *ppwEnd = pw;\n            continue;\n        }\n\n        /* If we get here, this means the word fits. */\n        apwSol[cpwLast++] = pw;\n        if (cchPhraseLength -= pw->cchLength) { /* recurse */\n            Debug(DumpWords();)\n            /* The recursive call scrambles the tail, so we have to be\n             * pessimistic.\n             */\n\t    ppwEnd = &apwCand[0];\n\t    ppwEnd += cpwCand;\n            FindAnagram(&aqNext[0],\n\t\t\tppwStart, iLetter);\n        } else DumpWords();             /* found one */\n        cchPhraseLength += pw->cchLength;\n        --cpwLast;\n        ppwStart++;\n        continue;\n    }\n\n    ;\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "FindAnagram", "address": "0x1a90", "label": "FindAnagram", "content": "void __fastcall FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter)\n{\n  int v3; // r14d\n  const char *pchWord; // rsi\n  Letter *v6; // rax\n  __int64 iq; // rbp\n  __int64 i; // rbx\n  __int64 v9; // rax\n  Letter *v10; // rax\n  PWord *v11; // r14\n  PPWord v12; // r15\n  Word *v13; // r13\n  Quad v14; // rbx\n  Word *v15; // rax\n  int v16; // edx\n  bool v17; // zf\n  int v18; // eax\n  unsigned int cchLength; // eax\n  PWord v20; // rax\n  __int64 v21; // [rsp+8h] [rbp-70h]\n  int iLettera; // [rsp+1Ch] [rbp-5Ch]\n  Quad aqNext[3]; // [rsp+20h] [rbp-58h] BYREF\n  unsigned __int64 v24; // [rsp+38h] [rbp-40h]\n\n  v3 = iLetter;\n  pchWord = (const char *)(iLetter + 1);\n  v24 = __readfsqword(0x28u);\n  v6 = &alPhrase[achByFrequency[iLetter]];\n  iq = v6->iq;\n  for ( i = v6->uBits << v6->uShift; (pqMask[iq] & (unsigned int)i) == 0; i = v10->uBits << v10->uShift )\n  {\n    v9 = achByFrequency[(_QWORD)pchWord];\n    v3 = (int)pchWord++;\n    v10 = &alPhrase[v9];\n    iq = v10->iq;\n  }\n  if ( &apwCand[cpwCand] > ppwStart )\n  {\n    v21 = i;\n    iLettera = v3;\n    v11 = &apwCand[cpwCand];\n    v12 = ppwStart;\n    while ( 1 )\n    {\n      v13 = *v12;\n      aqNext[0] = *pqMask - (*v12)->aqMask[0];\n      if ( (aqMainSign[0] & aqNext[0]) != 0 )\n        goto LABEL_14;\n      aqNext[1] = pqMask[1] - v13->aqMask[1];\n      v14 = aqMainSign[1] & aqNext[1];\n      if ( (aqMainSign[1] & aqNext[1]) != 0 )\n        goto LABEL_14;\n      if ( (v13->aqMask[iq] & v21) != 0 )\n        break;\n      v15 = *--v11;\n      *v12 = v15;\n      *v11 = v13;\nLABEL_9:\n      if ( v11 <= v12 )\n        return;\n    }\n    v16 = cpwLast + 1;\n    apwSol[cpwLast] = v13;\n    v17 = cchPhraseLength == v13->cchLength;\n    v18 = cchPhraseLength - v13->cchLength;\n    cpwLast = v16;\n    cchPhraseLength = v18;\n    if ( v17 )\n    {\n      if ( v16 > 0 )\n      {\n        do\n        {\n          v20 = apwSol[v14++];\n          pchWord = v20->pchWord;\n          libmin_printf(\"%s \", pchWord);\n        }\n        while ( cpwLast > (int)v14 );\n      }\n      libmin_printf((char *)\"\\n\", pchWord);\n    }\n    else\n    {\n      pchWord = (const char *)v12;\n      v11 = &apwCand[cpwCand];\n      FindAnagram(aqNext, v12, iLettera);\n    }\n    cchLength = v13->cchLength;\n    --cpwLast;\n    cchPhraseLength += cchLength;\nLABEL_14:\n    ++v12;\n    goto LABEL_9;\n  }\n}\n"}, "pseudo_normalize": "void FindAnagram(Quad *pqMask, PPWord ppwStart, int iLetter) {\n  int v3;\n  const char *pchWord;\n  Letter *v6;\n  long long iq;\n  long long i;\n  long long v9;\n  Letter *v10;\n  PWord *v11;\n  PPWord v12;\n  Word *v13;\n  Quad v14;\n  Word *v15;\n  int v16;\n  bool v17;\n  int v18;\n  unsigned int cchLength;\n  PWord v20;\n  long long v21;\n  int iLettera;\n  Quad aqNext[3];\n  unsigned long long v24;\n  v3 = iLetter;\n  pchWord = (const char *)(iLetter + 1);\n  v24 = __readfsqword(40u);\n  v6 = &alPhrase[achByFrequency[iLetter]];\n  iq = v6->iq;\n  for (i = v6->uBits << v6->uShift; (pqMask[iq] & (unsigned int)i) == 0;\n       i = v10->uBits << v10->uShift) {\n    v9 = achByFrequency[(uint64_t)pchWord];\n    v3 = (int)pchWord++;\n    v10 = &alPhrase[v9];\n    iq = v10->iq;\n  }\n  if (&apwCand[cpwCand] > ppwStart) {\n    v21 = i;\n    iLettera = v3;\n    v11 = &apwCand[cpwCand];\n    v12 = ppwStart;\n    while (1) {\n      v13 = *v12;\n      aqNext[0] = *pqMask - (*v12)->aqMask[0];\n      if ((aqMainSign[0] & aqNext[0]) != 0) goto LABEL_14;\n      aqNext[1] = pqMask[1] - v13->aqMask[1];\n      v14 = aqMainSign[1] & aqNext[1];\n      if ((aqMainSign[1] & aqNext[1]) != 0) goto LABEL_14;\n      if ((v13->aqMask[iq] & v21) != 0) break;\n      v15 = *--v11;\n      *v12 = v15;\n      *v11 = v13;\n    LABEL_9:\n      if (v11 <= v12) return;\n    }\n    v16 = cpwLast + 1;\n    apwSol[cpwLast] = v13;\n    v17 = cchPhraseLength == v13->cchLength;\n    v18 = cchPhraseLength - v13->cchLength;\n    cpwLast = v16;\n    cchPhraseLength = v18;\n    if (v17) {\n      if (v16 > 0) {\n        do {\n          v20 = apwSol[v14++];\n          pchWord = v20->pchWord;\n          libmin_printf(\"%s \", pchWord);\n        } while (cpwLast > (int)v14);\n      }\n      libmin_printf((char *)\"\\n\", pchWord);\n    } else {\n      pchWord = (const char *)v12;\n      v11 = &apwCand[cpwCand];\n      FindAnagram(aqNext, v12, iLettera);\n    }\n    cchLength = v13->cchLength;\n    --cpwLast;\n    cchPhraseLength += cchLength;\n  LABEL_14:\n    ++v12;\n    goto LABEL_9;\n  }\n}", "binary": "anagram/anagram.host.O2", "assembly": "<FindAnagram>:\nendbr64\npush   %r15\nlea    0x36b23(%rip),%r10\npush   %r14\nmov    %edx,%r14d\nlea    0x36d97(%rip),%rdx\npush   %r13\nmov    %rsi,%r13\nlea    0x1(%r14),%esi\npush   %r12\nmov    %rdi,%r12\nlea    0x36bc2(%rip),%rdi\nmovslq %esi,%rsi\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\nmov    0x36d43(%rip),%eax\nlea    (%rdx,%rax,8),%r15\nmovslq %r14d,%rax\nmovsbq (%r10,%rax,1),%rax\nshl    $0x4,%rax\nadd    %rdi,%rax\nmov    0x4(%rax),%ecx\nmov    0x8(%rax),%ebx\nmov    0xc(%rax),%ebp\nshl    %cl,%ebx\nmov    %rbx,%rax\nand    (%r12,%rbp,8),%rax\njne    1b2f <FindAnagram+0x9f>\nnopl   0x0(%rax)\nmovsbq (%r10,%rsi,1),%rax\nmov    %esi,%r14d\nadd    $0x1,%rsi\nshl    $0x4,%rax\nadd    %rdi,%rax\nmov    0x4(%rax),%ecx\nmov    0x8(%rax),%ebx\nmov    0xc(%rax),%ebp\nshl    %cl,%ebx\nmov    %rbx,%rax\nand    (%r12,%rbp,8),%rax\nje     1b08 <FindAnagram+0x78>\nlea    0x20(%rsp),%rax\nlea    0x368e5(%rip),%r10\nmov    %rax,0x10(%rsp)\ncmp    %r13,%r15\njbe    1bb7 <FindAnagram+0x127>\nmov    %rbx,0x8(%rsp)\nmov    %rbp,%rax\nmov    %r12,%rbp\nmov    %r14d,0x1c(%rsp)\nmov    %rax,%r12\nmov    %r15,%r14\nmov    %r13,%r15\nmov    (%r15),%r13\nmov    0x0(%rbp),%rax\nlea    0x36ae4(%rip),%rdx\nsub    0x0(%r13),%rax\nmov    %rax,0x20(%rsp)\nand    (%rdx),%rax\njne    1c40 <FindAnagram+0x1b0>\nmov    0x8(%rbp),%rbx\nsub    0x8(%r13),%rbx\nmov    %rbx,0x28(%rsp)\nand    0x36ac6(%rip),%rbx\njne    1c40 <FindAnagram+0x1b0>\nmov    0x8(%rsp),%rax\nand    0x0(%r13,%r12,8),%rax\njne    1be0 <FindAnagram+0x150>\nmov    -0x8(%r14),%rax\nsub    $0x8,%r14\nmov    %rax,(%r15)\nmov    %r13,(%r14)\ncmp    %r15,%r14\nja     1b5e <FindAnagram+0xce>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1c98 <FindAnagram+0x208>\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmovslq 0x36819(%rip),%rax\nlea    0x1(%rax),%edx\nmov    %r13,(%r10,%rax,8)\nmov    0x36a7c(%rip),%eax\nsub    0x18(%r13),%eax\nmov    %edx,0x36802(%rip)\nmov    %eax,0x36a6c(%rip)\nje     1c50 <FindAnagram+0x1c0>\nmov    0x36c14(%rip),%eax\nlea    0x36c2d(%rip),%rdx\nmov    0x10(%rsp),%rdi\nmov    %r15,%rsi\nlea    (%rdx,%rax,8),%r14\nmov    0x1c(%rsp),%edx\ncall   1a90 <FindAnagram>\nlea    0x367f1(%rip),%r10\nmov    0x18(%r13),%eax\nsubl   $0x1,0x367c6(%rip)\nadd    %eax,0x36a30(%rip)\nadd    $0x8,%r15\njmp    1bb2 <FindAnagram+0x122>\nnopl   0x0(%rax)\ntest   %edx,%edx\njle    1c81 <FindAnagram+0x1f1>\nnopl   0x0(%rax)\nmov    (%r10,%rbx,8),%rax\nlea    0x2478(%rip),%rdi\nadd    $0x1,%rbx\nmov    0x10(%rax),%rsi\nxor    %eax,%eax\ncall   38e0 <libmin_printf>\ncmp    %ebx,0x36788(%rip)\nlea    0x367a1(%rip),%r10\njg     1c58 <FindAnagram+0x1c8>\nlea    0x24a9(%rip),%rdi\nxor    %eax,%eax\ncall   38e0 <libmin_printf>\nlea    0x3678a(%rip),%r10\njmp    1c2f <FindAnagram+0x19f>\ncall   10c0 <__stack_chk_fail@plt>\nnopl   (%rax)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "GetPhrase", "content": "char * GetPhrase(char * pch) {\n    if (libmin_mgets(pch, 255, minput) == NULL) {\n\t    return NULL;\n    }\n    // libmin_printf(\"Processing: %s...\\n\", pch);\n    return(pch);\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "GetPhrase", "address": "0x1d20", "label": "GetPhrase", "content": "char *__fastcall GetPhrase(char *pch)\n{\n  char *v1; // r12\n\n  v1 = pch;\n  if ( !libmin_mgets(pch, 0xFFuLL, minput) )\n    return 0LL;\n  return v1;\n}\n"}, "pseudo_normalize": "char *GetPhrase(char *pch) {\n  char *v1;\n  v1 = pch;\n  if (!libmin_mgets(pch, 255uLL, minput)) return 0LL;\n  return v1;\n}", "binary": "anagram/anagram.host.O2", "assembly": "<GetPhrase>:\nendbr64\npush   %r12\nmov    0x362f3(%rip),%rdx\nmov    $0xff,%esi\nmov    %rdi,%r12\ncall   2340 <libmin_mgets>\ntest   %rax,%rax\nmov    $0x0,%eax\ncmove  %rax,%r12\nmov    %r12,%rax\npop    %r12\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "NewWord", "content": "PWord\nNewWord(void) {\n    PWord pw;\n\n    pw = (Word *)libmin_malloc(sizeof(Word));\n    if (pw == NULL)\n        Fatal(\"Out of memory after %d candidates\\n\", cpwCand);\n    return pw;\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "NewWord", "address": "0x16a0", "label": "NewWord", "content": "PWord __cdecl NewWord()\n{\n  PWord result; // rax\n\n  result = (PWord)libmin_malloc(0x20uLL);\n  if ( !result )\n  {\n    libmin_printf(\"Out of memory after %d candidates\\n\", cpwCand);\n    libmin_fail(1);\n  }\n  return result;\n}\n"}, "pseudo_normalize": "PWord NewWord() {\n  PWord result;\n  result = (PWord)libmin_malloc(32uLL);\n  if (!result) {\n    libmin_printf(\"Out of memory after %d candidates\\n\", cpwCand);\n    libmin_fail(1);\n  }\n  return result;\n}", "binary": "anagram/anagram.host.O2", "assembly": "<NewWord>:\nendbr64\npush   %r12\nmov    $0x20,%edi\ncall   20a0 <libmin_malloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     16c0 <NewWord+0x20>\nmov    %r12,%rax\npop    %r12\nret\nxchg   %ax,%ax\nmov    0x3715a(%rip),%esi\nlea    0x29bb(%rip),%rdi\nxor    %eax,%eax\ncall   38e0 <libmin_printf>\nmov    $0x1,%edi\ncall   1ff0 <libmin_fail>\nmov    %r12,%rax\npop    %r12\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "NextWord", "content": "/* NextWord -- get another candidate entry, creating if necessary */\nPWord NextWord(void) {\n    PWord pw;\n    if (cpwCand >= MAXCAND)\n\tFatal(\"Too many candidates\\n\", 0);\n    pw = apwCand[cpwCand++];\n    if (pw != NULL)\n\treturn pw;\n    apwCand[cpwCand-1] = NewWord();\n    return apwCand[cpwCand-1];\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "NextWord", "address": "0x1710", "label": "NextWord", "content": "PWord __cdecl NextWord()\n{\n  __int64 v0; // rbx\n  PWord result; // rax\n  Word *v2; // r12\n  unsigned int v3; // eax\n\n  if ( cpwCand > 0x1387 )\n  {\n    libmin_printf(\"Too many candidates\\n\", 0LL);\n    libmin_fail(1);\n  }\n  v0 = cpwCand;\n  result = apwCand[cpwCand++];\n  if ( !result )\n  {\n    v2 = (Word *)libmin_malloc(0x20uLL);\n    if ( !v2 )\n    {\n      libmin_printf(\"Out of memory after %d candidates\\n\", cpwCand);\n      libmin_fail(1);\n    }\n    v3 = cpwCand;\n    apwCand[v0] = v2;\n    return apwCand[v3 - 1];\n  }\n  return result;\n}\n"}, "pseudo_normalize": "PWord NextWord() {\n  long long v0;\n  PWord result;\n  Word *v2;\n  unsigned int v3;\n  if (cpwCand > 4999) {\n    libmin_printf(\"Too many candidates\\n\", 0LL);\n    libmin_fail(1);\n  }\n  v0 = cpwCand;\n  result = apwCand[cpwCand++];\n  if (!result) {\n    v2 = (Word *)libmin_malloc(32uLL);\n    if (!v2) {\n      libmin_printf(\"Out of memory after %d candidates\\n\", cpwCand);\n      libmin_fail(1);\n    }\n    v3 = cpwCand;\n    apwCand[v0] = v2;\n    return apwCand[v3 - 1];\n  }\n  return result;\n}", "binary": "anagram/anagram.host.O2", "assembly": "<NextWord>:\nendbr64\nmov    0x37106(%rip),%eax\npush   %r12\npush   %rbp\npush   %rbx\ncmp    $0x1387,%eax\nja     1750 <NextWord+0x40>\nlea    0x37114(%rip),%rbp\nmov    %eax,%ebx\nlea    0x1(%rax),%edx\nmov    0x0(%rbp,%rbx,8),%rax\nmov    %edx,0x370e4(%rip)\ntest   %rax,%rax\nje     1778 <NextWord+0x68>\npop    %rbx\npop    %rbp\npop    %r12\nret\ncs nopw 0x0(%rax,%rax,1)\nxor    %esi,%esi\nlea    0x2986(%rip),%rdi\nxor    %eax,%eax\ncall   38e0 <libmin_printf>\nmov    $0x1,%edi\ncall   1ff0 <libmin_fail>\nmov    0x370b0(%rip),%eax\njmp    1725 <NextWord+0x15>\nnopw   0x0(%rax,%rax,1)\nmov    $0x20,%edi\ncall   20a0 <libmin_malloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     17a8 <NextWord+0x98>\nmov    0x37090(%rip),%eax\nmov    %r12,0x0(%rbp,%rbx,8)\npop    %rbx\nsub    $0x1,%eax\nmov    0x0(%rbp,%rax,8),%rax\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nmov    0x37072(%rip),%esi\nlea    0x28d3(%rip),%rdi\nxor    %eax,%eax\ncall   38e0 <libmin_printf>\nmov    $0x1,%edi\ncall   1ff0 <libmin_fail>\njmp    178a <NextWord+0x7a>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "ReadDict", "content": "/* ReadDict -- read the dictionary file into memory and preprocess it\n *\n * A word of length cch in the dictionary is encoded as follows:\n *\n *    byte 0    = cch + 3\n *    byte 1    = number of letters in the word\n *    byte 2... = the word itself, null-terminated\n *\n * Observe that cch+3 is the length of the total encoding.  These\n * byte streams are concatenated, and terminated with a 0.\n */\n\nvoid ReadDict(char *pchFile) {\n    char * pch;\n    char * pchBase;\n    unsigned long ulLen;\n    unsigned cWords = 0;\n    unsigned cLetters;\n    int ch;\n\n    ulLen = libmin_msize(mwords) + 2 * (unsigned long)MAXWORDS;\n    pchBase = pchDictionary = (char *)libmin_malloc(ulLen);\n\n    if(pchDictionary == NULL)\n\tFatal(\"Unable to allocate memory for dictionary\\n\", 0);\n\n    libmin_mopen(mwords, \"r\");\n\n    while (!libmin_meof(mwords)) {\n        pch = pchBase+2;                /* reserve for length */\n        cLetters = 0;\n        while ((ch = libmin_mgetc(mwords)) != '\\n' && ch != EOF) {\n            if (isalpha(ch)) cLetters++;\n            *pch++ = ch;\n        }\n        *pch++ = '\\0';\n        *pchBase = pch - pchBase;\n        pchBase[1] = cLetters;\n        pchBase = pch;\n        cWords++;\n    }\n    libmin_mclose(mwords);\n\n    *pchBase++ = 0;\n\n    libmin_printf(\"main dictionary has %u entries\\n\", cWords);\n    if (cWords >= MAXWORDS)\n\t    Fatal(\"Dictionary too large; increase MAXWORDS\\n\", 0);\n    libmin_printf(\"%lu bytes wasted\\n\", ulLen - (pchBase - pchDictionary));\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "ReadDict", "address": "0x1360", "label": "ReadDict", "content": "void __fastcall ReadDict(char *pchFile)\n{\n  size_t v1; // r13\n  char *v2; // rbp\n  unsigned int v3; // r12d\n  _BYTE *v4; // r14\n  char v5; // bl\n  int v6; // eax\n\n  v1 = libmin_msize(mwords) + 52000;\n  pchDictionary = (char *)libmin_malloc(v1);\n  v2 = pchDictionary;\n  if ( !pchDictionary )\n  {\n    libmin_printf(\"Unable to allocate memory for dictionary\\n\", 0LL);\n    libmin_fail(1);\n  }\n  v3 = 0;\n  libmin_mopen(mwords, \"r\");\n  for ( ; !libmin_meof(mwords); v2 = v4 + 1 )\n  {\n    v4 = v2 + 2;\n    v5 = 0;\n    while ( 1 )\n    {\n      v6 = libmin_mgetc(mwords);\n      if ( v6 == -1 || v6 == 10 )\n        break;\n      v5 -= ((pctype[v6] & 3) == 0) - 1;\n      *v4++ = v6;\n    }\n    *v4 = 0;\n    ++v3;\n    v2[1] = v5;\n    *v2 = (_BYTE)v4 + 1 - (_BYTE)v2;\n  }\n  libmin_mclose(mwords);\n  *v2 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", v3);\n  if ( v3 > 0x658F )\n  {\n    libmin_printf(\"Dictionary too large; increase MAXWORDS\\n\", 0LL);\n    libmin_fail(1);\n  }\n  libmin_printf(\"%lu bytes wasted\\n\", v1 - (v2 + 1 - pchDictionary));\n}\n"}, "pseudo_normalize": "void ReadDict(char *pchFile) {\n  unsigned int v1;\n  char *v2;\n  unsigned int v3;\n  uint8_t *v4;\n  char v5;\n  int v6;\n  v1 = libmin_msize(mwords) + 52000;\n  pchDictionary = (char *)libmin_malloc(v1);\n  v2 = pchDictionary;\n  if (!pchDictionary) {\n    libmin_printf(\"Unable to allocate memory for dictionary\\n\", 0LL);\n    libmin_fail(1);\n  }\n  v3 = 0;\n  libmin_mopen(mwords, \"r\");\n  for (; !libmin_meof(mwords); v2 = v4 + 1) {\n    v4 = v2 + 2;\n    v5 = 0;\n    while (1) {\n      v6 = libmin_mgetc(mwords);\n      if (v6 == -1 || v6 == 10) break;\n      v5 -= ((pctype[v6] & 3) == 0) - 1;\n      *v4++ = v6;\n    }\n    *v4 = 0;\n    ++v3;\n    v2[1] = v5;\n    *v2 = (uint8_t)v4 + 1 - (uint8_t)v2;\n  }\n  libmin_mclose(mwords);\n  *v2 = 0;\n  libmin_printf(\"main dictionary has %u entries\\n\", v3);\n  if (v3 > 25999) {\n    libmin_printf(\"Dictionary too large; increase MAXWORDS\\n\", 0LL);\n    libmin_fail(1);\n  }\n  libmin_printf(\"%lu bytes wasted\\n\", v1 - (v2 + 1 - pchDictionary));\n}", "binary": "anagram/anagram.host.O2", "assembly": "<ReadDict>:\nendbr64\npush   %r14\nmov    0x36cf3(%rip),%rdi\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ncall   2570 <libmin_msize>\nlea    0xcb20(%rax),%r13\nmov    %r13,%rdi\ncall   20a0 <libmin_malloc>\nmov    %rax,0x3722a(%rip)\nmov    %rax,%rbp\ntest   %rax,%rax\nje     149e <ReadDict+0x13e>\nmov    0x36cbf(%rip),%rdi\nlea    0x2d03(%rip),%rsi\nxor    %r12d,%r12d\ncall   2520 <libmin_mopen>\nmov    0x36ca9(%rip),%rdi\ncall   22f0 <libmin_meof>\ntest   %eax,%eax\njne    1431 <ReadDict+0xd1>\nlea    0x2(%rbp),%r14\nxor    %ebx,%ebx\njmp    13f5 <ReadDict+0x95>\nnopl   0x0(%rax,%rax,1)\ncmp    $0xa,%eax\nje     1406 <ReadDict+0xa6>\nmov    0x36ecc(%rip),%rdx\nmovslq %eax,%rcx\nmovzwl (%rdx,%rcx,2),%edx\nand    $0x3,%edx\ncmp    $0x1,%dx\nsbb    $0xffffffff,%ebx\nadd    $0x1,%r14\nmov    %al,-0x1(%r14)\nmov    0x36c64(%rip),%rdi\ncall   2310 <libmin_mgetc>\ncmp    $0xffffffff,%eax\njne    13d0 <ReadDict+0x70>\nlea    0x1(%r14),%rax\nmovb   $0x0,(%r14)\nadd    $0x1,%r12d\nmov    %rax,%rdx\nmov    %bl,0x1(%rbp)\nsub    %rbp,%rdx\nmov    %dl,0x0(%rbp)\nmov    0x36c3b(%rip),%rdi\nmov    %rax,%rbp\ncall   22f0 <libmin_meof>\ntest   %eax,%eax\nje     13c0 <ReadDict+0x60>\nmov    0x36c28(%rip),%rdi\nlea    0x1(%rbp),%rbx\ncall   2240 <libmin_mclose>\nmovb   $0x0,0x0(%rbp)\nxor    %eax,%eax\nmov    %r12d,%esi\nlea    0x2be7(%rip),%rdi\ncall   38e0 <libmin_printf>\ncmp    $0x658f,%r12d\nja     1482 <ReadDict+0x122>\nsub    0x37152(%rip),%rbx\nmov    %r13,%rsi\nlea    0x2c3d(%rip),%rdi\nxor    %eax,%eax\nsub    %rbx,%rsi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\njmp    38e0 <libmin_printf>\nxor    %esi,%esi\nlea    0x2bcd(%rip),%rdi\nxor    %eax,%eax\ncall   38e0 <libmin_printf>\nmov    $0x1,%edi\ncall   1ff0 <libmin_fail>\njmp    145f <ReadDict+0xff>\nxor    %esi,%esi\nlea    0x2b61(%rip),%rdi\nxor    %eax,%eax\ncall   38e0 <libmin_printf>\nmov    $0x1,%edi\ncall   1ff0 <libmin_fail>\njmp    139a <ReadDict+0x3a>\nnopl   (%rax)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "SortCandidates", "content": "void SortCandidates(void) {\n    int i;\n\n    /* Sort the letters by frequency */\n    for (i = 0; i < ALPHABET; i++) achByFrequency[i] = i;\n    libmin_qsort(achByFrequency, ALPHABET, sizeof(char),\n          (int (*)(const void *, const void *))CompareFrequency);\n\n    libmin_printf(\"Order of search will be \");\n    for (i = 0; i < ALPHABET; i++)\n\t    libmin_putc(i2ch(achByFrequency[i]));\n    libmin_putc('\\n');\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "SortCandidates", "address": "0x1ca0", "label": "SortCandidates", "content": "void __cdecl SortCandidates()\n{\n  __int64 i; // rax\n  char *v1; // rbx\n  char v2; // al\n\n  for ( i = 0LL; i != 26; ++i )\n    achByFrequency[i] = i;\n  libmin_qsort(achByFrequency, 0x1AuLL, 1uLL, (int (*)(const void *, const void *))CompareFrequency);\n  v1 = achByFrequency;\n  libmin_printf(\"Order of search will be \");\n  do\n  {\n    v2 = *v1++;\n    libmin_putc(v2 + 97);\n  }\n  while ( v1 != &achByFrequency[26] );\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "void SortCandidates() {\n  long long i;\n  char *v1;\n  char v2;\n  for (i = 0LL; i != 26; ++i) achByFrequency[i] = i;\n  libmin_qsort(achByFrequency, 26uLL, 1uLL,\n               (int (*)(const void *, const void *))CompareFrequency);\n  v1 = achByFrequency;\n  libmin_printf(\"Order of search will be \");\n  do {\n    v2 = *v1++;\n    libmin_putc(v2 + 97);\n  } while (v1 != &achByFrequency[26]);\n  libmin_putc(10);\n}", "binary": "anagram/anagram.host.O2", "assembly": "<SortCandidates>:\nendbr64\npush   %rbp\nxor    %eax,%eax\nlea    0x36912(%rip),%rdi\npush   %rbx\nsub    $0x8,%rsp\nnopl   0x0(%rax,%rax,1)\nmov    %al,(%rdi,%rax,1)\nadd    $0x1,%rax\ncmp    $0x1a,%rax\njne    1cb8 <SortCandidates+0x18>\nlea    -0x9bc(%rip),%rcx\nmov    $0x1,%edx\nmov    $0x1a,%esi\ncall   3d20 <libmin_qsort>\nlea    0x368de(%rip),%rbx\nlea    0x2421(%rip),%rdi\nxor    %eax,%eax\ncall   38e0 <libmin_printf>\nlea    0x1a(%rbx),%rbp\nnopl   0x0(%rax)\nmovzbl (%rbx),%eax\nadd    $0x1,%rbx\nlea    0x61(%rax),%edi\nmovsbl %dil,%edi\ncall   3af0 <libmin_putc>\ncmp    %rbp,%rbx\njne    1cf8 <SortCandidates+0x58>\nadd    $0x8,%rsp\nmov    $0xa,%edi\npop    %rbx\npop    %rbp\njmp    3af0 <libmin_putc>\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "main", "content": "int \nmain(int cpchArgc, char **ppchArgv)\n{\n    ReadDict(ppchArgv[1]);\n\n    while (GetPhrase(&achPhrase[0]) != NULL) {\n        if (isdigit(achPhrase[0])) {\n            cchMinLength = libmin_atoi(achPhrase);\n            libmin_printf(\"New length: %d\\n\", cchMinLength);\n        } else if (achPhrase[0] == '?') {\n            DumpCandidates();\n        } else {\n            BuildMask(&achPhrase[0]);\n            AddWords();\n            if (cpwCand == 0 || cchPhraseLength == 0) continue;\n\n            Stat(ulHighCount = ulLowCount = 0;)\n            cpwLast = 0;\n            SortCandidates();\n            FindAnagram(&aqMainMask[0], &apwCand[0], 0);\n            Stat(libmin_printf(\"%lu:%lu probes\\n\", ulHighCount, ulLowCount);)\n        }\n    }\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  ReadDict((char *)argv[1]);\n  while ( libmin_mgets(achPhrase, 0xFFuLL, minput) )\n  {\n    if ( (pctype[achPhrase[0]] & 4) != 0 )\n    {\n      cchMinLength = libmin_atoi(achPhrase);\n      libmin_printf(\"New length: %d\\n\", cchMinLength);\n    }\n    else if ( achPhrase[0] == 63 )\n    {\n      DumpCandidates();\n    }\n    else\n    {\n      BuildMask(achPhrase);\n      AddWords();\n      if ( cpwCand )\n      {\n        if ( cchPhraseLength )\n        {\n          cpwLast = 0;\n          SortCandidates();\n          FindAnagram(aqMainMask, apwCand, 0);\n        }\n      }\n    }\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  ReadDict((char *)argv[1]);\n  while (libmin_mgets(achPhrase, 255uLL, minput)) {\n    if ((pctype[achPhrase[0]] & 4) != 0) {\n      cchMinLength = libmin_atoi(achPhrase);\n      libmin_printf(\"New length: %d\\n\", cchMinLength);\n    } else if (achPhrase[0] == 63) {\n      DumpCandidates();\n    } else {\n      BuildMask(achPhrase);\n      AddWords();\n      if (cpwCand) {\n        if (cchPhraseLength) {\n          cpwLast = 0;\n          SortCandidates();\n          FindAnagram(aqMainMask, apwCand, 0);\n        }\n      }\n    }\n  }\n  libmin_success();\n}", "binary": "anagram/anagram.host.O2", "assembly": "<main>:\nendbr64\npush   %r13\nlea    0x37713(%rip),%r13\npush   %r12\nlea    0x3752a(%rip),%r12\npush   %rbp\nlea    0x2fe5(%rip),%rbp\npush   %rbx\nlea    0x371ba(%rip),%rbx\nsub    $0x8,%rsp\nmov    0x8(%rsi),%rdi\ncall   1360 <ReadDict>\nnopl   0x0(%rax,%rax,1)\nmov    0x36ec1(%rip),%rdx\nmov    $0xff,%esi\nmov    %rbx,%rdi\ncall   2340 <libmin_mgets>\ntest   %rax,%rax\nje     1200 <main+0xe0>\nmovsbq (%rbx),%rcx\nmov    0x37128(%rip),%rdx\ntestb  $0x4,(%rdx,%rcx,2)\njne    11d0 <main+0xb0>\ncmp    $0x3f,%cl\nje     11f0 <main+0xd0>\nmov    %rbx,%rdi\ncall   14c0 <BuildMask>\ncall   1910 <AddWords>\nmov    0x37682(%rip),%edx\ntest   %edx,%edx\nje     1158 <main+0x38>\nmov    0x374c8(%rip),%eax\ntest   %eax,%eax\nje     1158 <main+0x38>\nmovl   $0x0,0x3724a(%rip)\ncall   1ca0 <SortCandidates>\nxor    %edx,%edx\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   1a90 <FindAnagram>\njmp    1158 <main+0x38>\nnopw   0x0(%rax,%rax,1)\nmov    %rbx,%rdi\ncall   1f30 <libmin_atoi>\nmov    %rbp,%rdi\nmov    %eax,%esi\nmov    %eax,0x36e2d(%rip)\nxor    %eax,%eax\ncall   38e0 <libmin_printf>\njmp    1158 <main+0x38>\nnop\ncall   19a0 <DumpCandidates>\njmp    1158 <main+0x38>\nnopw   0x0(%rax,%rax,1)\ncall   3e30 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "anagram/anagram.c", "function_name": "wprint", "content": "/* wprint -- print a word, followed by a space\n *\n * We would normally just use printf, but the string being printed is\n * is a huge pointer (on an IBM PC), so special care must be taken.\n */\nvoid wprint(char * pch) {\n    libmin_printf(\"%s \", pch);\n}\n"}, "pseudo": {"path": "anagram/anagram.host.O2.pseudo", "function_name": "wprint", "address": "0x16f0", "label": "wprint", "content": "void __fastcall wprint(char *pch)\n{\n  libmin_printf(\"%s \", pch);\n}\n"}, "pseudo_normalize": "", "binary": "anagram/anagram.host.O2", "assembly": "<wprint>:\nendbr64\nmov    %rdi,%rsi\nxor    %eax,%eax\nlea    0x29db(%rip),%rdi\njmp    38e0 <libmin_printf>\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "audio-codec/audio-codec.c", "function_name": "decode", "content": "/**\n * @brief 8bit alaw to 16bit pcm\n * @param out signed 16bit pcm array\n * @param in  unsigned 8bit alaw array\n * @param len length of alaw array\n * @returns void\n */\nvoid decode(int16_t *out, uint8_t *in, size_t len)\n{\n    uint8_t alaw = 0;\n    int32_t pcm = 0;\n    int32_t sign = 0;\n    int32_t eee = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        alaw = *in++;\n\n        /* Re-toggle toggled bits */\n        alaw ^= 0xD5;\n\n        /* Get sign bit */\n        sign = alaw & 0x80;\n\n        /* Get eee bits */\n        eee = (alaw & 0x70) >> 4;\n\n        /* Get abcd bits and add 1/2 quantization step */\n        pcm = (alaw & 0x0f) << 4 | 8;\n\n        /* If quantization level > 0, there need `1` bit before abcd bits */\n        pcm += eee ? 0x100 : 0x0;\n\n        /* Left shift according quantization level */\n        pcm <<= eee > 1 ? (eee - 1) : 0;\n\n        /* Use the right sign */\n        *out++ = sign ? -pcm : pcm;\n    }\n}\n"}, "pseudo": {"path": "audio-codec/audio-codec.host.O2.pseudo", "function_name": "decode", "address": "0x1440", "label": "decode", "content": "void __fastcall decode(int16_t *out, uint8_t *in, size_t len)\n{\n  __int64 v4; // rdx\n  int v5; // ecx\n  int v6; // r10d\n  int v7; // ecx\n  int v8; // eax\n  int v9; // eax\n\n  if ( len )\n  {\n    v4 = 0LL;\n    do\n    {\n      v5 = in[v4] ^ 0xD5;\n      v6 = (unsigned __int8)(16 * v5);\n      v7 = (v5 >> 4) & 7;\n      v8 = (v6 | 8) + ((v7 != 0) << 8);\n      if ( v7 <= 0 )\n        LOBYTE(v7) = 1;\n      v9 = v8 << (v7 - 1);\n      if ( (in[v4] & 0x80u) == 0 )\n        LOWORD(v9) = -(__int16)v9;\n      out[v4++] = v9;\n    }\n    while ( len != v4 );\n  }\n}\n"}, "pseudo_normalize": "void decode(int16_t *out, uint8_t *in, unsigned int len) {\n  long long v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  if (len) {\n    v4 = 0LL;\n    do {\n      v5 = in[v4] ^ 213;\n      v6 = (unsigned char)(16 * v5);\n      v7 = (v5 >> 4) & 7;\n      v8 = (v6 | 8) + ((v7 != 0) << 8);\n      if (v7 <= 0) LOBYTE(v7) = 1;\n      v9 = v8 << (v7 - 1);\n      if ((in[v4] & 128u) == 0) LOWORD(v9) = -(short)v9;\n      out[v4++] = v9;\n    } while (len != v4);\n  }\n}", "binary": "audio-codec/audio-codec.host.O2", "assembly": "<decode>:\nendbr64\nmov    %rdx,%r8\ntest   %rdx,%rdx\nje     14a3 <decode+0x63>\nxor    %edx,%edx\nxchg   %ax,%ax\nmovzbl (%rsi,%rdx,1),%r9d\nxor    $0xffffffd5,%r9d\nmovzbl %r9b,%eax\nmov    %eax,%ecx\nshl    $0x4,%eax\nmovzbl %al,%r10d\nsar    $0x4,%ecx\nxor    %eax,%eax\nor     $0x8,%r10d\nand    $0x7,%ecx\nsetne  %al\nshl    $0x8,%eax\nadd    %r10d,%eax\ntest   %ecx,%ecx\nmov    $0x1,%r10d\ncmovle %r10d,%ecx\nsub    $0x1,%ecx\nshl    %cl,%eax\nmov    %eax,%ecx\nneg    %ecx\ntest   %r9b,%r9b\ncmovs  %ecx,%eax\nmov    %ax,(%rdi,%rdx,2)\nadd    $0x1,%rdx\ncmp    %rdx,%r8\njne    1450 <decode+0x10>\nret\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "audio-codec/audio-codec.c", "function_name": "encode", "content": "/**\n * @brief 16bit pcm to 8bit alaw\n * @param out unsigned 8bit alaw array\n * @param in  signed 16bit pcm array\n * @param len length of pcm array\n * @returns void\n */\nvoid encode(uint8_t *out, int16_t *in, size_t len)\n{\n    uint8_t alaw = 0;\n    int16_t pcm = 0;\n    int32_t sign = 0;\n    int32_t abcd = 0;\n    int32_t eee = 0;\n    int32_t mask = 0;\n    for (size_t i = 0; i < len; i++)\n    {\n        pcm = *in++;\n        /* 0-7 kinds of quantization level from the table above */\n        eee = 7;\n        mask = 0x4000; /* 0x4000: '0b0100 0000 0000 0000' */\n\n        /* Get sign bit */\n        sign = (pcm & 0x8000) >> 8;\n\n        /* Turn negative pcm to positive */\n        /* The absolute value of a negative number may be larger than the size\n         * of the corresponding positive number, so here needs `-pcm -1` after\n         * taking the opposite number. */\n        pcm = sign ? (-pcm - 1) : pcm;\n\n        /* Get eee and abcd bit */\n        /* Use mask to locate the first `1` bit and quantization level at the\n         * same time */\n        while ((pcm & mask) == 0 && eee > 0)\n        {\n            eee--;\n            mask >>= 1;\n        }\n\n        /* The location of abcd bits is related with quantization level. Check\n         * the table above to determine how many bits to `>>` to get abcd */\n        abcd = (pcm >> (eee ? (eee + 3) : 4)) & 0x0f;\n\n        /* Put the quantization level number at right bit location to get eee\n         * bits */\n        eee <<= 4;\n\n        /* Splice results */\n        alaw = (sign | eee | abcd);\n\n        /* The standard specifies that all resulting even bits (LSB\n         * is even) are inverted before the octet is transmitted. This is to\n         * provide plenty of 0/1 transitions to facilitate the clock recovery\n         * process in the PCM receivers. Thus, a silent A-law encoded PCM\n         * channel has the 8 bit samples coded 0xD5 instead of 0x80 in the\n         * octets. (Reference from wiki above) */\n        *out++ = alaw ^ 0xD5;\n    }\n}\n"}, "pseudo": {"path": "audio-codec/audio-codec.host.O2.pseudo", "function_name": "encode", "address": "0x1390", "label": "encode", "content": "void __fastcall encode(uint8_t *out, int16_t *in, size_t len)\n{\n  __int64 v6; // rdi\n  int v7; // esi\n  int16_t v8; // dx\n  int v9; // r11d\n  int v10; // edx\n  int v11; // eax\n  char v12; // cl\n  char v13; // dl\n  char v14; // cl\n\n  v6 = 0LL;\n  if ( len )\n  {\n    do\n    {\n      v7 = in[v6];\n      v8 = in[v6];\n      v9 = (v7 >> 8) & 0x80;\n      if ( v9 )\n      {\n        v8 = ~v8;\n        v7 = v8;\n      }\n      if ( (v8 & 0x4000) != 0 )\n      {\n        v13 = 112;\n        v14 = 10;\n      }\n      else\n      {\n        v10 = 0x4000;\n        v11 = 7;\n        while ( 1 )\n        {\n          v10 >>= 1;\n          v12 = v11--;\n          if ( (v7 & v10) != 0 )\n            break;\n          if ( !v11 )\n          {\n            v13 = 0;\n            v14 = 4;\n            goto LABEL_9;\n          }\n        }\n        v13 = 16 * v11;\n        if ( v11 )\n          v14 = v12 + 2;\n        else\n          v14 = 4;\n      }\nLABEL_9:\n      out[v6++] = ((v7 >> v14) & 0xF | v9 | v13) ^ 0xD5;\n    }\n    while ( len != v6 );\n  }\n}\n"}, "pseudo_normalize": "void encode(uint8_t *out, int16_t *in, unsigned int len) {\n  long long v6;\n  int v7;\n  int16_t v8;\n  int v9;\n  int v10;\n  int v11;\n  char v12;\n  char v13;\n  char v14;\n  v6 = 0LL;\n  if (len) {\n    do {\n      v7 = in[v6];\n      v8 = in[v6];\n      v9 = (v7 >> 8) & 128;\n      if (v9) {\n        v8 = ~v8;\n        v7 = v8;\n      }\n      if ((v8 & 16384) != 0) {\n        v13 = 112;\n        v14 = 10;\n      } else {\n        v10 = 16384;\n        v11 = 7;\n        while (1) {\n          v10 >>= 1;\n          v12 = v11--;\n          if ((v7 & v10) != 0) break;\n          if (!v11) {\n            v13 = 0;\n            v14 = 4;\n            goto LABEL_9;\n          }\n        }\n        v13 = 16 * v11;\n        if (v11)\n          v14 = v12 + 2;\n        else\n          v14 = 4;\n      }\n    LABEL_9:\n      out[v6++] = ((v7 >> v14) & 15 | v9 | v13) ^ 213;\n    } while (len != v6);\n  }\n}", "binary": "audio-codec/audio-codec.host.O2", "assembly": "<encode>:\nendbr64\nmov    %rdi,%r8\nmov    %rsi,%r9\nmov    %rdx,%r10\nxor    %edi,%edi\ntest   %rdx,%rdx\nje     1408 <encode+0x78>\nnopl   0x0(%rax)\nmovswl (%r9,%rdi,2),%esi\nmov    %esi,%eax\nmov    %esi,%edx\nsar    $0x8,%eax\nand    $0x80,%eax\nmov    %eax,%r11d\nje     13c3 <encode+0x33>\nnot    %edx\nmovswl %dx,%esi\nand    $0x40,%dh\njne    141e <encode+0x8e>\nmov    $0x4000,%edx\nmov    $0x7,%eax\nnopw   0x0(%rax,%rax,1)\nsar    %edx\nmov    %eax,%ecx\nsub    $0x1,%eax\ntest   %esi,%edx\njne    1410 <encode+0x80>\ntest   %eax,%eax\njne    13d8 <encode+0x48>\nxor    %edx,%edx\nmov    $0x4,%ecx\nsar    %cl,%esi\nor     %r11d,%edx\nand    $0xf,%esi\nor     %esi,%edx\nxor    $0xffffffd5,%edx\nmov    %dl,(%r8,%rdi,1)\nadd    $0x1,%rdi\ncmp    %rdi,%r10\njne    13a8 <encode+0x18>\nret\nnopl   0x0(%rax)\nmov    %eax,%edx\nshl    $0x4,%edx\ntest   %eax,%eax\nje     142a <encode+0x9a>\nadd    $0x2,%ecx\njmp    13ee <encode+0x5e>\nmov    $0x70,%edx\nmov    $0xa,%ecx\njmp    13ee <encode+0x5e>\nmov    $0x4,%ecx\njmp    13ee <encode+0x5e>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "audio-codec/audio-codec.c", "function_name": "main", "content": "/**\n * @brief Main function\n * @param argc commandline argument count (ignored)\n * @param argv commandline array of arguments (ignored)\n * @returns 0 on exit\n */\nint main(int argc, char *argv[])\n{\n    /* output alaw encoded by encode() */\n    uint8_t coded[LEN];\n\n    /* output pcm decoded by decode() from coded[LEN] */\n    int16_t decoded[LEN];\n\n    test(pcm, coded, decoded, LEN);  // run self-test implementations\n\n    /* print test pcm inputs */\n    libmin_printf(\"inputs: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%d \", pcm[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* print encoded alaw */\n    libmin_printf(\"encode: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%u \", coded[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* print decoded pcm */\n    libmin_printf(\"decode: \");\n    for (size_t i = 0; i < LEN; i++)\n    {\n        libmin_printf(\"%d \", decoded[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* It can be seen that the encoded alaw is smaller than the input PCM, so\n     * the purpose of compression is achieved. And the decoded PCM is almost the\n     * same as the original input PCM, which verifies the correctness of the\n     * decoding. The reason why it is not exactly the same is that there is\n     * precision loss during encode / decode.  */\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "audio-codec/audio-codec.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  uint8_t *v4; // rbx\n  __int64 v5; // rbp\n  int16_t *v6; // r13\n  int v7; // esi\n  uint8_t *v8; // r14\n  int v9; // esi\n  int v10; // esi\n  int16_t decoded[8]; // [rsp+0h] [rbp-58h] BYREF\n  uint8_t coded[8]; // [rsp+10h] [rbp-48h] BYREF\n  unsigned __int64 v13; // [rsp+18h] [rbp-40h] BYREF\n\n  v3 = 0LL;\n  v13 = __readfsqword(0x28u);\n  encode(coded, pcm, 8uLL);\n  while ( coded[v3] == r_coded[v3] )\n  {\n    if ( ++v3 == 8 )\n    {\n      v4 = (uint8_t *)decoded;\n      v5 = 0LL;\n      decode(decoded, coded, 8uLL);\n      while ( decoded[v5] == r_decoded[v5] )\n      {\n        if ( ++v5 == 8 )\n        {\n          v6 = pcm;\n          libmin_printf(\"inputs: \");\n          do\n          {\n            v7 = *v6++;\n            libmin_printf(\"%d \", v7);\n          }\n          while ( v6 != &pcm[8] );\n          v8 = coded;\n          libmin_printf(\"\\n\");\n          libmin_printf(\"encode: \");\n          do\n          {\n            v9 = *v8++;\n            libmin_printf(\"%u \", v9);\n          }\n          while ( v8 != (uint8_t *)&v13 );\n          libmin_printf(\"\\n\");\n          libmin_printf(\"decode: \");\n          do\n          {\n            v10 = *(__int16 *)v4;\n            v4 += 2;\n            libmin_printf(\"%d \", v10);\n          }\n          while ( v4 != coded );\n          libmin_printf(\"\\n\");\n          libmin_success();\n        }\n      }\n      libmin_fail(1);\n    }\n  }\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  uint8_t *v4;\n  long long v5;\n  int16_t *v6;\n  int v7;\n  uint8_t *v8;\n  int v9;\n  int v10;\n  int16_t decoded[8];\n  uint8_t coded[8];\n  unsigned long long v13;\n  v3 = 0LL;\n  v13 = __readfsqword(40u);\n  encode(coded, pcm, 8uLL);\n  while (coded[v3] == r_coded[v3]) {\n    if (++v3 == 8) {\n      v4 = (uint8_t *)decoded;\n      v5 = 0LL;\n      decode(decoded, coded, 8uLL);\n      while (decoded[v5] == r_decoded[v5]) {\n        if (++v5 == 8) {\n          v6 = pcm;\n          libmin_printf(\"inputs: \");\n          do {\n            v7 = *v6++;\n            libmin_printf(\"%d \", v7);\n          } while (v6 != &pcm[8]);\n          v8 = coded;\n          libmin_printf(\"\\n\");\n          libmin_printf(\"encode: \");\n          do {\n            v9 = *v8++;\n            libmin_printf(\"%u \", v9);\n          } while (v8 != (uint8_t *)&v13);\n          libmin_printf(\"\\n\");\n          libmin_printf(\"decode: \");\n          do {\n            v10 = *(short *)v4;\n            v4 += 2;\n            libmin_printf(\"%d \", v10);\n          } while (v4 != coded);\n          libmin_printf(\"\\n\");\n          libmin_success();\n        }\n      }\n      libmin_fail(1);\n    }\n  }\n  libmin_fail(1);\n}", "binary": "audio-codec/audio-codec.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x8,%edx\nlea    0x3f1e(%rip),%rsi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nlea    0x3f00(%rip),%rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nlea    0x10(%rsp),%r12\nmov    %r12,%rdi\ncall   1390 <encode>\nnopl   0x0(%rax)\nmovzbl 0x0(%rbp,%rbx,1),%eax\ncmp    %al,(%r12,%rbx,1)\nje     115d <main+0x5d>\nmov    $0x1,%edi\ncall   1690 <libmin_fail>\nadd    $0x1,%rbx\ncmp    $0x8,%rbx\njne    1148 <main+0x48>\nmov    %rsp,%rbx\nmov    $0x8,%edx\nmov    %r12,%rsi\nxor    %ebp,%ebp\nmov    %rbx,%rdi\nlea    0x3e92(%rip),%r13\ncall   1440 <decode>\nnopl   0x0(%rax,%rax,1)\nmovzwl 0x0(%r13,%rbp,2),%eax\ncmp    %ax,(%rbx,%rbp,2)\nje     119e <main+0x9e>\nmov    $0x1,%edi\ncall   1690 <libmin_fail>\nadd    $0x1,%rbp\ncmp    $0x8,%rbp\njne    1188 <main+0x88>\nlea    0x1e55(%rip),%rdi\nxor    %eax,%eax\nlea    0x3e78(%rip),%r13\ncall   2a10 <libmin_printf>\nlea    0x10(%r13),%r14\nlea    0x1e45(%rip),%rbp\nnopl   0x0(%rax,%rax,1)\nmovswl 0x0(%r13),%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x2,%r13\ncall   2a10 <libmin_printf>\ncmp    %r14,%r13\njne    11d0 <main+0xd0>\nlea    0x1e22(%rip),%rdi\nxor    %eax,%eax\nlea    0x18(%rsp),%r15\nmov    %r12,%r14\ncall   2a10 <libmin_printf>\nlea    0x1e0e(%rip),%rdi\nxor    %eax,%eax\nlea    0x1e0e(%rip),%r13\ncall   2a10 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\nmovzbl (%r14),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%r14\ncall   2a10 <libmin_printf>\ncmp    %r15,%r14\njne    1218 <main+0x118>\nlea    0x1ddb(%rip),%rdi\nxor    %eax,%eax\ncall   2a10 <libmin_printf>\nlea    0x1ddc(%rip),%rdi\nxor    %eax,%eax\ncall   2a10 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\nmovswl (%rbx),%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x2,%rbx\ncall   2a10 <libmin_printf>\ncmp    %r12,%rbx\njne    1250 <main+0x150>\nlea    0x1da4(%rip),%rdi\nxor    %eax,%eax\ncall   2a10 <libmin_printf>\ncall   2c50 <libmin_success>\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    129a <main+0x19a>\nadd    $0x28,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\nnop\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "CheckTreeNodeRotation", "content": "TreeNode *CheckTreeNodeRotation(TreeNode *tnode,\n                                TreeNode *subtree, short *finished)\n{\n    /* this function will check to see if tnode's Balance factor indicates\n        that a rotation is needed. Subtree is the child link that was either\n        just added or possibly changed */\n    switch(tnode->Balance)  {\n        case 0:\n            /* nothing special, but we have balanced out properly, yay */\n            *finished = 1;\n            break;\n        case 2:\n            /* right heavy */\n            *finished = 1;\n            if(subtree->Balance == -1)   {\n                /* update balance factors */\n                if(subtree->Left->Balance == 1)    {\n                    subtree->Balance = 0;\n                    tnode->Balance = -1;\n                } else if(subtree->Left->Balance == -1)    {\n                    subtree->Balance = 1;\n                    tnode->Balance = 0;\n                } else\n                    subtree->Balance = tnode->Balance = 0;\n                subtree->Left->Balance = 0;\n                tnode = DoubleLeftRotation(tnode);\n            } else if(subtree->Balance == 1)   {\n                /* update balance factors */\n                subtree->Balance = tnode->Balance = 0;\n                tnode = SingleLeftRotation(tnode);\n            }\n            break;\n        case -2:\n            /* left heavy */\n            *finished = 1;\n            if(subtree->Balance == 1)  {\n                /* update balance factors */\n                if(subtree->Right->Balance == -1)    {\n                    subtree->Balance = 0;\n                    tnode->Balance = 1;\n                } else if(subtree->Right->Balance == 1)    {\n                    subtree->Balance = -1;\n                    tnode->Balance = 0;\n                } else\n                    subtree->Balance = tnode->Balance = 0;\n                subtree->Right->Balance = 0;\n                tnode = DoubleRightRotation(tnode);\n            } else if(subtree->Balance == -1)   {\n                /* update balance factors */\n                subtree->Balance = tnode->Balance = 0;\n                tnode = SingleRightRotation(tnode);\n            }\n    }\n    return tnode;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "CheckTreeNodeRotation", "address": "0x1c30", "label": "CheckTreeNodeRotation", "content": "TreeNode *__fastcall CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree, __int16 *finished)\n{\n  __int16 Balance; // cx\n  TreeNode *result; // rax\n  __int16 v5; // dx\n  TreeNodeTag *v6; // rdx\n  __int16 v7; // dx\n  TreeNodeTag *v8; // rdx\n  TreeNodeTag *v9; // rcx\n  TreeNodeTag *Left; // rdx\n  __int16 v11; // cx\n  TreeNodeTag *Right; // rcx\n  TreeNode *v13; // rdx\n  TreeNodeTag *v14; // rdx\n  __int16 v15; // cx\n  TreeNodeTag *v16; // rcx\n  TreeNode *v17; // rdx\n\n  Balance = tnode->Balance;\n  result = tnode;\n  if ( Balance )\n  {\n    if ( Balance == 2 )\n    {\n      *finished = 1;\n      v7 = subtree->Balance;\n      if ( v7 == -1 )\n      {\n        Left = subtree->Left;\n        v11 = subtree->Left->Balance;\n        if ( v11 == 1 )\n        {\n          subtree->Balance = 0;\n          tnode->Balance = -1;\n        }\n        else if ( v11 == -1 )\n        {\n          subtree->Balance = 1;\n          tnode->Balance = 0;\n        }\n        else\n        {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        Right = tnode->Right;\n        Left->Balance = 0;\n        v13 = Right->Left;\n        Right->Left = Right->Left->Right;\n        v13->Right = Right;\n        tnode->Right = v13->Left;\n        v13->Left = tnode;\n        return v13;\n      }\n      else if ( v7 == 1 )\n      {\n        v8 = tnode->Right;\n        tnode->Balance = 0;\n        v9 = v8->Left;\n        subtree->Balance = 0;\n        result = v8;\n        tnode->Right = v9;\n        v8->Left = tnode;\n      }\n    }\n    else if ( Balance == -2 )\n    {\n      *finished = 1;\n      v5 = subtree->Balance;\n      if ( v5 == 1 )\n      {\n        v14 = subtree->Right;\n        v15 = v14->Balance;\n        if ( v15 == -1 )\n        {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        }\n        else if ( v15 == 1 )\n        {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        }\n        else\n        {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        v16 = tnode->Left;\n        v14->Balance = 0;\n        v17 = v16->Right;\n        v16->Right = v17->Left;\n        v17->Left = v16;\n        tnode->Left = v17->Right;\n        v17->Right = tnode;\n        return v17;\n      }\n      else if ( v5 == -1 )\n      {\n        tnode->Balance = 0;\n        v6 = tnode->Left;\n        subtree->Balance = 0;\n        tnode->Left = v6->Right;\n        v6->Right = tnode;\n        return v6;\n      }\n    }\n  }\n  else\n  {\n    *finished = 1;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *CheckTreeNodeRotation(TreeNode *tnode, TreeNode *subtree,\n                                short *finished) {\n  short Balance;\n  TreeNode *result;\n  short v5;\n  TreeNodeTag *v6;\n  short v7;\n  TreeNodeTag *v8;\n  TreeNodeTag *v9;\n  TreeNodeTag *Left;\n  short v11;\n  TreeNodeTag *Right;\n  TreeNode *v13;\n  TreeNodeTag *v14;\n  short v15;\n  TreeNodeTag *v16;\n  TreeNode *v17;\n  Balance = tnode->Balance;\n  result = tnode;\n  if (Balance) {\n    if (Balance == 2) {\n      *finished = 1;\n      v7 = subtree->Balance;\n      if (v7 == -1) {\n        Left = subtree->Left;\n        v11 = subtree->Left->Balance;\n        if (v11 == 1) {\n          subtree->Balance = 0;\n          tnode->Balance = -1;\n        } else if (v11 == -1) {\n          subtree->Balance = 1;\n          tnode->Balance = 0;\n        } else {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        Right = tnode->Right;\n        Left->Balance = 0;\n        v13 = Right->Left;\n        Right->Left = Right->Left->Right;\n        v13->Right = Right;\n        tnode->Right = v13->Left;\n        v13->Left = tnode;\n        return v13;\n      } else if (v7 == 1) {\n        v8 = tnode->Right;\n        tnode->Balance = 0;\n        v9 = v8->Left;\n        subtree->Balance = 0;\n        result = v8;\n        tnode->Right = v9;\n        v8->Left = tnode;\n      }\n    } else if (Balance == -2) {\n      *finished = 1;\n      v5 = subtree->Balance;\n      if (v5 == 1) {\n        v14 = subtree->Right;\n        v15 = v14->Balance;\n        if (v15 == -1) {\n          subtree->Balance = 0;\n          tnode->Balance = 1;\n        } else if (v15 == 1) {\n          subtree->Balance = -1;\n          tnode->Balance = 0;\n        } else {\n          tnode->Balance = 0;\n          subtree->Balance = 0;\n        }\n        v16 = tnode->Left;\n        v14->Balance = 0;\n        v17 = v16->Right;\n        v16->Right = v17->Left;\n        v17->Left = v16;\n        tnode->Left = v17->Right;\n        v17->Right = tnode;\n        return v17;\n      } else if (v5 == -1) {\n        tnode->Balance = 0;\n        v6 = tnode->Left;\n        subtree->Balance = 0;\n        tnode->Left = v6->Right;\n        v6->Right = tnode;\n        return v6;\n      }\n    }\n  } else {\n    *finished = 1;\n  }\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<CheckTreeNodeRotation>:\nendbr64\nmovzwl 0x20(%rdi),%ecx\nmov    %rdi,%rax\ntest   %cx,%cx\nje     1cd8 <CheckTreeNodeRotation+0xa8>\ncmp    $0x2,%cx\nje     1c98 <CheckTreeNodeRotation+0x68>\ncmp    $0xfffe,%cx\nje     1c58 <CheckTreeNodeRotation+0x28>\nret\nnopl   0x0(%rax)\nmov    $0x1,%edi\nmov    %di,(%rdx)\nmovzwl 0x20(%rsi),%edx\ncmp    $0x1,%dx\nje     1d40 <CheckTreeNodeRotation+0x110>\ncmp    $0xffff,%dx\njne    1c50 <CheckTreeNodeRotation+0x20>\nxor    %edx,%edx\nxor    %ecx,%ecx\nmov    %dx,0x20(%rax)\nmov    (%rax),%rdx\nmov    %cx,0x20(%rsi)\nmov    0x8(%rdx),%rcx\nmov    %rcx,(%rax)\nmov    %rax,0x8(%rdx)\nmov    %rdx,%rax\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%r11d\nmov    %r11w,(%rdx)\nmovzwl 0x20(%rsi),%edx\ncmp    $0xffff,%dx\nje     1ce8 <CheckTreeNodeRotation+0xb8>\ncmp    $0x1,%dx\njne    1c50 <CheckTreeNodeRotation+0x20>\nmov    0x8(%rdi),%rdx\nxor    %r8d,%r8d\nxor    %r9d,%r9d\nmov    %r8w,0x20(%rdi)\nmov    (%rdx),%rcx\nmov    %r9w,0x20(%rsi)\nmov    %rdx,%rax\nmov    %rcx,0x8(%rdi)\nmov    %rdi,(%rdx)\nret\nnopl   0x0(%rax)\nmov    $0x1,%ecx\nmov    %cx,(%rdx)\nret\nnopl   0x0(%rax)\nmov    (%rsi),%rdx\nmovzwl 0x20(%rdx),%ecx\ncmp    $0x1,%cx\nje     1dd8 <CheckTreeNodeRotation+0x1a8>\ncmp    $0xffff,%cx\nje     1da8 <CheckTreeNodeRotation+0x178>\nxor    %r11d,%r11d\nxor    %ecx,%ecx\nmov    %r11w,0x20(%rdi)\nmov    %cx,0x20(%rsi)\nmov    0x8(%rax),%rcx\nxor    %r10d,%r10d\nmov    %r10w,0x20(%rdx)\nmov    (%rcx),%rdx\nmov    0x8(%rdx),%rsi\nmov    %rsi,(%rcx)\nmov    %rcx,0x8(%rdx)\nmov    (%rdx),%rcx\nmov    %rcx,0x8(%rax)\nmov    %rax,(%rdx)\nmov    %rdx,%rax\nret\nnopl   0x0(%rax)\nmov    0x8(%rsi),%rdx\nmovzwl 0x20(%rdx),%ecx\ncmp    $0xffff,%cx\nje     1dc0 <CheckTreeNodeRotation+0x190>\ncmp    $0x1,%cx\nje     1d90 <CheckTreeNodeRotation+0x160>\nxor    %edi,%edi\nxor    %r8d,%r8d\nmov    %di,0x20(%rax)\nmov    %r8w,0x20(%rsi)\nmov    (%rax),%rcx\nxor    %esi,%esi\nmov    %si,0x20(%rdx)\nmov    0x8(%rcx),%rdx\nmov    (%rdx),%rsi\nmov    %rsi,0x8(%rcx)\nmov    %rcx,(%rdx)\nmov    0x8(%rdx),%rcx\nmov    %rcx,(%rax)\nmov    %rax,0x8(%rdx)\nmov    %rdx,%rax\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0xffffffff,%r9d\nxor    %r10d,%r10d\nmov    %r9w,0x20(%rsi)\nmov    %r10w,0x20(%rax)\njmp    1d62 <CheckTreeNodeRotation+0x132>\nnopl   (%rax)\nmov    $0x1,%edi\nxor    %r8d,%r8d\nmov    %di,0x20(%rsi)\nmov    %r8w,0x20(%rax)\njmp    1d11 <CheckTreeNodeRotation+0xe1>\nxchg   %ax,%ax\nxor    %r11d,%r11d\nmov    $0x1,%ecx\nmov    %r11w,0x20(%rsi)\nmov    %cx,0x20(%rax)\njmp    1d62 <CheckTreeNodeRotation+0x132>\nnopl   0x0(%rax,%rax,1)\nxor    %r9d,%r9d\nmov    $0xffffffff,%r10d\nmov    %r9w,0x20(%rsi)\nmov    %r10w,0x20(%rdi)\njmp    1d11 <CheckTreeNodeRotation+0xe1>\n"}
{"source": {"path": "avl-tree/element.c", "function_name": "Compare", "content": "#include \"libmin.h\"\n#include \"element.h\"\n\nshort Compare(Element Data1, Element Data2)\n{\n    if(*Data1 > *Data2)\n        return 1;\n    else if(*Data1 < *Data2)\n        return -1;\n    return 0;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "Compare", "address": "0x1ad0", "label": "Compare", "content": "__int16 __fastcall Compare(Element Data1, Element Data2)\n{\n  int v2; // eax\n\n  LOWORD(v2) = 1;\n  if ( *Data1 <= *Data2 )\n    return -(*Data1 < *Data2);\n  return v2;\n}\n"}, "pseudo_normalize": "short Compare(Element Data1, Element Data2) {\n  int v2;\n  LOWORD(v2) = 1;\n  if (*Data1 <= *Data2) return -(*Data1 < *Data2);\n  return v2;\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<Compare>:\nendbr64\nmov    (%rsi),%edx\nmov    $0x1,%eax\ncmp    %edx,(%rdi)\njg     1ae7 <Compare+0x17>\nsetl   %al\nmovzbl %al,%eax\nneg    %eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DeleteByElement", "content": "TreeNode *DeleteByElement(TreeNode *rootNode, Element Item)\n{\n    short finished = 0;\n    TreeNode *newRoot = NULL;\n    newRoot = DeleteByElementRecursive(rootNode, Item, &finished);\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "DeleteByElement", "address": "0x2860", "label": "DeleteByElement", "content": "TreeNode *__fastcall DeleteByElement(TreeNode *rootNode, Element Item)\n{\n  __int16 finished; // [rsp+6h] [rbp-12h] BYREF\n  unsigned __int64 v4; // [rsp+8h] [rbp-10h]\n\n  v4 = __readfsqword(0x28u);\n  finished = 0;\n  return DeleteByElementRecursive(rootNode, Item, &finished);\n}\n"}, "pseudo_normalize": "TreeNode *DeleteByElement(TreeNode *rootNode, Element Item) {\n  short finished;\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  finished = 0;\n  return DeleteByElementRecursive(rootNode, Item, &finished);\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<DeleteByElement>:\nendbr64\nsub    $0x18,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nlea    0x6(%rsp),%rdx\nxor    %eax,%eax\nmov    %ax,0x6(%rsp)\ncall   26d0 <DeleteByElementRecursive>\nmov    0x8(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    289e <DeleteByElement+0x3e>\nadd    $0x18,%rsp\nret\ncall   10c0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DeleteByElementRecursive", "content": "TreeNode *DeleteByElementRecursive(TreeNode *rootNode,\n                                   Element Item, short *finished)\n{\n    TreeNode *subtree = NULL;\n    short comp = 0;\n    \n    /* found a leaf */\n    if(rootNode == NULL)\n        return NULL;\n    /* figure out where the node in question is in relation to the current */\n    comp = Compare(rootNode->Item, Item);\n    if(comp > 0)    {\n        /* buried somewhere in the right subtree */\n        subtree = DeleteByElementRecursive(rootNode->Right, Item, finished);\n        rootNode->Right = subtree;\n        if(!*finished && subtree != NULL)  {\n            rootNode->Balance--;\n            rootNode = CheckTreeNodeRotation(rootNode, subtree, finished);\n        }\n    } else if(comp < 0) {\n        subtree = DeleteByElementRecursive(rootNode->Left, Item, finished);\n        rootNode->Left = subtree;\n        if(!*finished && subtree != NULL)  {\n            rootNode->Balance++;\n            rootNode = CheckTreeNodeRotation(rootNode, subtree, finished);\n        }\n    } else {\n        /* found what we were looking for */\n        if(rootNode->Right == NULL) {\n            /* rootNode is replaced by the left child; can be null */\n            subtree = rootNode->Left;\n            libmin_free(rootNode->Name);\n            FreeElement(rootNode->Item);\n            libmin_free(rootNode);\n            rootNode = subtree;\n        } else if(rootNode->Right->Left == NULL)  {\n            /* rootNode is replaced by Right */\n            subtree = rootNode->Right;\n            subtree->Balance = rootNode->Balance;\n            subtree->Left = rootNode->Left;\n            libmin_free(rootNode->Name);\n            FreeElement(rootNode->Item);\n            libmin_free(rootNode);\n            rootNode = subtree;\n        } else {\n            /* rootNode is replaced by inorder successor */\n            /* re-using comp as another flag since it is 0 */\n            rootNode->Right = DeleteLeftMost(&rootNode, rootNode->Right, &comp);\n        }\n    }\n    return rootNode;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "DeleteByElementRecursive", "address": "0x26d0", "label": "DeleteByElementRecursive", "content": "TreeNode *__fastcall DeleteByElementRecursive(TreeNode *rootNode, Element Item, __int16 *finished)\n{\n  TreeNode *result; // rax\n  __int16 v5; // ax\n  TreeNode *v6; // rbx\n  TreeNodeTag *Right; // rax\n  TreeNode *v8; // rax\n  bool v9; // zf\n  TreeNode *v10; // rsi\n  TreeNode *v11; // rax\n  TreeNode *v12; // rsi\n  TreeNode *rootNodea; // [rsp+0h] [rbp-38h]\n  TreeNode *deletedNode; // [rsp+8h] [rbp-30h] BYREF\n  __int16 comp; // [rsp+16h] [rbp-22h] BYREF\n  unsigned __int64 v16; // [rsp+18h] [rbp-20h]\n\n  result = rootNode;\n  deletedNode = rootNode;\n  v16 = __readfsqword(0x28u);\n  comp = 0;\n  if ( rootNode )\n  {\n    v5 = Compare(rootNode->Item, Item);\n    comp = v5;\n    if ( v5 > 0 )\n    {\n      v8 = DeleteByElementRecursive(deletedNode->Right, Item, finished);\n      v9 = *finished == 0;\n      v10 = v8;\n      result = deletedNode;\n      deletedNode->Right = v10;\n      if ( v9 && v10 )\n      {\n        --result->Balance;\n        return CheckTreeNodeRotation(result, v10, finished);\n      }\n    }\n    else\n    {\n      v6 = deletedNode;\n      if ( !v5 )\n      {\n        Right = deletedNode->Right;\n        if ( Right )\n        {\n          if ( Right->Left )\n          {\n            v6->Right = DeleteLeftMost(&deletedNode, deletedNode->Right, &comp);\n            return deletedNode;\n          }\n          Right->Balance = deletedNode->Balance;\n          Right->Left = v6->Left;\n        }\n        else\n        {\n          Right = deletedNode->Left;\n        }\n        rootNodea = Right;\n        libmin_free(v6->Name);\n        FreeElement(deletedNode->Item);\n        libmin_free(deletedNode);\n        return rootNodea;\n      }\n      v11 = DeleteByElementRecursive(deletedNode->Left, Item, finished);\n      v9 = *finished == 0;\n      v12 = v11;\n      result = deletedNode;\n      deletedNode->Left = v12;\n      if ( v9 )\n      {\n        if ( v12 )\n        {\n          ++result->Balance;\n          return CheckTreeNodeRotation(result, v12, finished);\n        }\n      }\n    }\n  }\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *DeleteByElementRecursive(TreeNode *rootNode, Element Item,\n                                   short *finished) {\n  TreeNode *result;\n  short v5;\n  TreeNode *v6;\n  TreeNodeTag *Right;\n  TreeNode *v8;\n  bool v9;\n  TreeNode *v10;\n  TreeNode *v11;\n  TreeNode *v12;\n  TreeNode *rootNodea;\n  TreeNode *deletedNode;\n  short comp;\n  unsigned long long v16;\n  result = rootNode;\n  deletedNode = rootNode;\n  v16 = __readfsqword(40u);\n  comp = 0;\n  if (rootNode) {\n    v5 = Compare(rootNode->Item, Item);\n    comp = v5;\n    if (v5 > 0) {\n      v8 = DeleteByElementRecursive(deletedNode->Right, Item, finished);\n      v9 = *finished == 0;\n      v10 = v8;\n      result = deletedNode;\n      deletedNode->Right = v10;\n      if (v9 && v10) {\n        --result->Balance;\n        return CheckTreeNodeRotation(result, v10, finished);\n      }\n    } else {\n      v6 = deletedNode;\n      if (!v5) {\n        Right = deletedNode->Right;\n        if (Right) {\n          if (Right->Left) {\n            v6->Right = DeleteLeftMost(&deletedNode, deletedNode->Right, &comp);\n            return deletedNode;\n          }\n          Right->Balance = deletedNode->Balance;\n          Right->Left = v6->Left;\n        } else {\n          Right = deletedNode->Left;\n        }\n        rootNodea = Right;\n        libmin_free(v6->Name);\n        FreeElement(deletedNode->Item);\n        libmin_free(deletedNode);\n        return rootNodea;\n      }\n      v11 = DeleteByElementRecursive(deletedNode->Left, Item, finished);\n      v9 = *finished == 0;\n      v12 = v11;\n      result = deletedNode;\n      deletedNode->Left = v12;\n      if (v9) {\n        if (v12) {\n          ++result->Balance;\n          return CheckTreeNodeRotation(result, v12, finished);\n        }\n      }\n    }\n  }\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<DeleteByElementRecursive>:\nendbr64\npush   %r12\nmov    %rdx,%r12\nmov    %rdi,%rax\npush   %rbp\npush   %rbx\nsub    $0x20,%rsp\nmov    %rdi,0x8(%rsp)\nmov    %fs:0x28,%rdx\nmov    %rdx,0x18(%rsp)\nxor    %edx,%edx\nxor    %edx,%edx\nmov    %dx,0x16(%rsp)\ntest   %rdi,%rdi\nje     2760 <DeleteByElementRecursive+0x90>\nmov    0x10(%rdi),%rdi\nmov    %rsi,%rbp\ncall   1ad0 <Compare>\nmov    %ax,0x16(%rsp)\ntest   %ax,%ax\njg     2780 <DeleteByElementRecursive+0xb0>\nmov    0x8(%rsp),%rbx\njne    2800 <DeleteByElementRecursive+0x130>\nmov    0x8(%rbx),%rax\ntest   %rax,%rax\nje     2848 <DeleteByElementRecursive+0x178>\ncmpq   $0x0,(%rax)\nje     27c0 <DeleteByElementRecursive+0xf0>\nlea    0x16(%rsp),%rdx\nlea    0x8(%rsp),%rdi\nmov    %rax,%rsi\ncall   2610 <DeleteLeftMost>\nmov    %rax,0x8(%rbx)\nmov    0x8(%rsp),%rax\ncs nopw 0x0(%rax,%rax,1)\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    284d <DeleteByElementRecursive+0x17d>\nadd    $0x20,%rsp\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopl   (%rax)\nmov    0x8(%rsp),%rax\nmov    %rbp,%rsi\nmov    %r12,%rdx\nmov    0x8(%rax),%rdi\ncall   26d0 <DeleteByElementRecursive>\ncmpw   $0x0,(%r12)\nmov    %rax,%rsi\nmov    0x8(%rsp),%rax\nmov    %rsi,0x8(%rax)\njne    2760 <DeleteByElementRecursive+0x90>\ntest   %rsi,%rsi\nje     2760 <DeleteByElementRecursive+0x90>\nsubw   $0x1,0x20(%rax)\nmov    %r12,%rdx\nmov    %rax,%rdi\ncall   1c30 <CheckTreeNodeRotation>\njmp    2760 <DeleteByElementRecursive+0x90>\nnop\nmovzwl 0x20(%rbx),%edx\nmov    %dx,0x20(%rax)\nmov    (%rbx),%rdx\nmov    %rdx,(%rax)\nmov    0x18(%rbx),%rdi\nmov    %rax,(%rsp)\ncall   3410 <libmin_free>\nmov    0x8(%rsp),%rdx\nmov    0x10(%rdx),%rdi\ncall   1af0 <FreeElement>\nmov    0x8(%rsp),%rdi\ncall   3410 <libmin_free>\nmov    (%rsp),%rax\njmp    2760 <DeleteByElementRecursive+0x90>\nnopl   0x0(%rax)\nmov    (%rbx),%rdi\nmov    %rbp,%rsi\nmov    %r12,%rdx\ncall   26d0 <DeleteByElementRecursive>\ncmpw   $0x0,(%r12)\nmov    %rax,%rsi\nmov    0x8(%rsp),%rax\nmov    %rsi,(%rax)\njne    2760 <DeleteByElementRecursive+0x90>\ntest   %rsi,%rsi\nje     2760 <DeleteByElementRecursive+0x90>\naddw   $0x1,0x20(%rax)\nmov    %r12,%rdx\nmov    %rax,%rdi\ncall   1c30 <CheckTreeNodeRotation>\njmp    2760 <DeleteByElementRecursive+0x90>\nnopl   0x0(%rax,%rax,1)\nmov    (%rbx),%rax\njmp    27ce <DeleteByElementRecursive+0xfe>\ncall   10c0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DeleteLeftMost", "content": "TreeNode *DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode,\n                    short *finished)\n{\n    TreeNode *subtree = rootNode->Right;\n    if(rootNode == NULL)    {\n        libmin_printf(\"bailing!\\n\");\n        return NULL;\n    }\n    if(rootNode->Left == NULL)  {\n        libmin_free((*deletedNode)->Name);\n        FreeElement((*deletedNode)->Item);\n        (*deletedNode)->Name = rootNode->Name;\n        (*deletedNode)->Item = rootNode->Item;\n        libmin_free(rootNode);\n        rootNode = subtree;\n    } else {\n        rootNode->Left = DeleteLeftMost(deletedNode, rootNode->Left, finished);\n        if(!*finished)  {\n            rootNode->Balance++;\n            if(rootNode->Left != NULL)\n                rootNode = CheckTreeNodeRotation(rootNode, rootNode->Left,\n                                finished);\n        }\n    }\n    return rootNode;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "DeleteLeftMost", "address": "0x2610", "label": "DeleteLeftMost", "content": "TreeNode *__fastcall DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode, __int16 *finished)\n{\n  TreeNode *Right; // r14\n  TreeNode *Left; // rsi\n  TreeNode *v7; // rax\n  bool v8; // zf\n  TreeNode *v10; // rax\n\n  Right = rootNode->Right;\n  Left = rootNode->Left;\n  if ( Left )\n  {\n    v7 = DeleteLeftMost(deletedNode, Left, finished);\n    v8 = *finished == 0;\n    rootNode->Left = v7;\n    if ( v8 && (++rootNode->Balance, v7) )\n      return CheckTreeNodeRotation(rootNode, v7, finished);\n    else\n      return rootNode;\n  }\n  else\n  {\n    libmin_free((*deletedNode)->Name);\n    FreeElement((*deletedNode)->Item);\n    v10 = *deletedNode;\n    v10->Name = rootNode->Name;\n    v10->Item = rootNode->Item;\n    libmin_free(rootNode);\n    return Right;\n  }\n}\n"}, "pseudo_normalize": "TreeNode *DeleteLeftMost(TreeNode **deletedNode, TreeNode *rootNode,\n                         short *finished) {\n  TreeNode *Right;\n  TreeNode *Left;\n  TreeNode *v7;\n  bool v8;\n  TreeNode *v10;\n  Right = rootNode->Right;\n  Left = rootNode->Left;\n  if (Left) {\n    v7 = DeleteLeftMost(deletedNode, Left, finished);\n    v8 = *finished == 0;\n    rootNode->Left = v7;\n    if (v8 && (++rootNode->Balance, v7))\n      return CheckTreeNodeRotation(rootNode, v7, finished);\n    else\n      return rootNode;\n  } else {\n    libmin_free((*deletedNode)->Name);\n    FreeElement((*deletedNode)->Item);\n    v10 = *deletedNode;\n    v10->Name = rootNode->Name;\n    v10->Item = rootNode->Item;\n    libmin_free(rootNode);\n    return Right;\n  }\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<DeleteLeftMost>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %rsi,%rbp\nsub    $0x8,%rsp\nmov    0x8(%rsi),%r14\nmov    (%rsi),%rsi\ntest   %rsi,%rsi\nje     2688 <DeleteLeftMost+0x78>\nmov    %rdx,%r13\ncall   2610 <DeleteLeftMost>\ncmpw   $0x0,0x0(%r13)\nmov    %rax,0x0(%rbp)\nje     2660 <DeleteLeftMost+0x50>\nadd    $0x8,%rsp\nmov    %rbp,%r14\nmov    %r14,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopw   0x0(%rax,%rax,1)\naddw   $0x1,0x20(%rbp)\ntest   %rax,%rax\nje     2645 <DeleteLeftMost+0x35>\nadd    $0x8,%rsp\nmov    %r13,%rdx\nmov    %rbp,%rdi\nmov    %rax,%rsi\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\njmp    1c30 <CheckTreeNodeRotation>\nnopl   0x0(%rax,%rax,1)\nmov    (%rdi),%rax\nmov    0x18(%rax),%rdi\ncall   3410 <libmin_free>\nmov    (%r12),%rax\nmov    0x10(%rax),%rdi\ncall   1af0 <FreeElement>\nmov    (%r12),%rax\nmov    0x18(%rbp),%rdx\nmov    %rbp,%rdi\nmov    %rdx,0x18(%rax)\nmov    0x10(%rbp),%rdx\nmov    %rdx,0x10(%rax)\ncall   3410 <libmin_free>\nadd    $0x8,%rsp\nmov    %r14,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DoubleLeftRotation", "content": "TreeNode *DoubleLeftRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = SingleRightRotation(rootNode->Right);\n    rootNode->Right = newRoot;\n    newRoot = SingleLeftRotation(rootNode);\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "DoubleLeftRotation", "address": "0x1c00", "label": "DoubleLeftRotation", "content": "TreeNode *__fastcall DoubleLeftRotation(TreeNode *rootNode)\n{\n  TreeNodeTag *Right; // rdx\n  TreeNode *result; // rax\n\n  Right = rootNode->Right;\n  result = Right->Left;\n  Right->Left = Right->Left->Right;\n  result->Right = Right;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *DoubleLeftRotation(TreeNode *rootNode) {\n  TreeNodeTag *Right;\n  TreeNode *result;\n  Right = rootNode->Right;\n  result = Right->Left;\n  Right->Left = Right->Left->Right;\n  result->Right = Right;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<DoubleLeftRotation>:\nendbr64\nmov    0x8(%rdi),%rdx\nmov    (%rdx),%rax\nmov    0x8(%rax),%rcx\nmov    %rcx,(%rdx)\nmov    %rdx,0x8(%rax)\nmov    (%rax),%rdx\nmov    %rdx,0x8(%rdi)\nmov    %rdi,(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "DoubleRightRotation", "content": "TreeNode *DoubleRightRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = SingleLeftRotation(rootNode->Left);\n    rootNode->Left = newRoot;\n    newRoot = SingleRightRotation(rootNode);\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "DoubleRightRotation", "address": "0x1bd0", "label": "DoubleRightRotation", "content": "TreeNode *__fastcall DoubleRightRotation(TreeNode *rootNode)\n{\n  TreeNodeTag *Left; // rdx\n  TreeNode *result; // rax\n\n  Left = rootNode->Left;\n  result = rootNode->Left->Right;\n  Left->Right = result->Left;\n  result->Left = Left;\n  rootNode->Left = result->Right;\n  result->Right = rootNode;\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *DoubleRightRotation(TreeNode *rootNode) {\n  TreeNodeTag *Left;\n  TreeNode *result;\n  Left = rootNode->Left;\n  result = rootNode->Left->Right;\n  Left->Right = result->Left;\n  result->Left = Left;\n  rootNode->Left = result->Right;\n  result->Right = rootNode;\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<DoubleRightRotation>:\nendbr64\nmov    (%rdi),%rdx\nmov    0x8(%rdx),%rax\nmov    (%rax),%rcx\nmov    %rcx,0x8(%rdx)\nmov    %rdx,(%rax)\nmov    0x8(%rax),%rdx\nmov    %rdx,(%rdi)\nmov    %rdi,0x8(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "FindByElement", "content": "/*\n * A free AVLTree implementation written by Andrew Coleman\n * find out more cool things and licensing at http://penguincoder.org\n */\n#include \"libmin.h\"\n#include \"avlcore.h\"\n\nTreeNode *FindByElement(TreeNode *rootNode, Element Data)\n{\n    short comp;\n    TreeNode *Return;\n    \n    /* sanity checks */\n    if(Data == NULL)\n        return NULL;\n    else if(rootNode == NULL || rootNode->Item == NULL)  {\n        /* reached a leaf, and the data was not found */\n        return NULL;\n    }\n    \n    /* non recursive search because it really isn't neccessary right here */\n    Return = rootNode;\n    do    {\n        comp = Compare(Return->Item, Data);\n        if(comp < 0)\n            Return = Return->Left;\n        else if(comp > 0)\n            Return = Return->Right;\n    } while(Return != NULL && comp != 0);\n    return Return;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "FindByElement", "address": "0x1b00", "label": "FindByElement", "content": "TreeNode *__fastcall FindByElement(TreeNode *rootNode, Element Data)\n{\n  TreeNode *v2; // r12\n  int *Item; // rdi\n  __int16 v4; // ax\n\n  if ( !Data )\n    return 0LL;\n  v2 = rootNode;\n  if ( !rootNode )\n    return 0LL;\n  Item = rootNode->Item;\n  if ( !Item )\n    return 0LL;\n  while ( 1 )\n  {\n    v4 = Compare(Item, Data);\n    if ( v4 < 0 )\n    {\n      v2 = v2->Left;\n    }\n    else\n    {\n      if ( !v4 )\n        return v2;\n      v2 = v2->Right;\n    }\n    if ( !v2 )\n      break;\n    Item = v2->Item;\n  }\n  return v2;\n}\n"}, "pseudo_normalize": "TreeNode *FindByElement(TreeNode *rootNode, Element Data) {\n  TreeNode *v2;\n  int *Item;\n  short v4;\n  if (!Data) return 0LL;\n  v2 = rootNode;\n  if (!rootNode) return 0LL;\n  Item = rootNode->Item;\n  if (!Item) return 0LL;\n  while (1) {\n    v4 = Compare(Item, Data);\n    if (v4 < 0) {\n      v2 = v2->Left;\n    } else {\n      if (!v4) return v2;\n      v2 = v2->Right;\n    }\n    if (!v2) break;\n    Item = v2->Item;\n  }\n  return v2;\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<FindByElement>:\nendbr64\npush   %r12\npush   %rbx\nsub    $0x8,%rsp\ntest   %rsi,%rsi\nje     1b70 <FindByElement+0x70>\nmov    %rdi,%r12\ntest   %rdi,%rdi\nje     1b70 <FindByElement+0x70>\nmov    0x10(%rdi),%rdi\nmov    %rsi,%rbx\ntest   %rdi,%rdi\nje     1b70 <FindByElement+0x70>\nnopl   0x0(%rax)\nmov    %rbx,%rsi\ncall   1ad0 <Compare>\ntest   %ax,%ax\njs     1b48 <FindByElement+0x48>\njne    1b60 <FindByElement+0x60>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nmov    (%r12),%r12\ntest   %r12,%r12\nje     1b37 <FindByElement+0x37>\ntest   %ax,%ax\nje     1b37 <FindByElement+0x37>\nmov    0x10(%r12),%rdi\njmp    1b28 <FindByElement+0x28>\nnopl   (%rax)\nmov    0x8(%r12),%r12\njmp    1b4c <FindByElement+0x4c>\nnopw   0x0(%rax,%rax,1)\nxor    %r12d,%r12d\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %r12\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "avl-tree/element.c", "function_name": "FreeElement", "content": "void FreeElement(Element Data)\n{\n    libmin_free(Data);\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "FreeElement", "address": "0x1af0", "label": "FreeElement", "content": "void __fastcall FreeElement(Element Data)\n{\n  libmin_free(Data);\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<FreeElement>:\nendbr64\njmp    3410 <libmin_free>\nnopl   0x0(%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "Height", "content": "long Height(TreeNode *rootNode)\n{\n    /* recursive function to determine the height by comparing the height of\n        the left and right child and returning the larger value */\n    long lresult = 0, rresult = 0;\n    /* either the tree is empty or we found a leaf */\n    if(rootNode == NULL)\n        return 0;\n    lresult = Height(rootNode->Left);\n    rresult = Height(rootNode->Right);\n    /* minimum height is 1, but that's probably correct */\n    return (lresult > rresult ? lresult : rresult) + 1;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "Height", "address": "0x28b0", "label": "Height", "content": "__int64 __fastcall Height(TreeNode *rootNode)\n{\n  __int64 v1; // rbx\n  TreeNodeTag *Left; // r13\n  TreeNodeTag *v3; // r14\n  __int64 v4; // rbp\n  TreeNode ****v5; // rdx\n  TreeNode ***v6; // r15\n  TreeNode **v7; // rbp\n  __int64 v8; // rbx\n  __int64 v9; // rax\n  TreeNode **v10; // r15\n  __int64 v11; // rbp\n  __int64 v12; // rbp\n  __int64 v13; // rax\n  TreeNode ***v14; // rdx\n  __int64 v15; // rbx\n  TreeNode **v16; // rbx\n  __int64 v17; // r15\n  __int64 v18; // r15\n  __int64 v19; // rax\n  TreeNode **v20; // rdx\n  __int64 v21; // rbx\n  __int64 v22; // rbx\n  __int64 v23; // rax\n  TreeNode ****Right; // rdx\n  __int64 v25; // rbp\n  TreeNode ***v26; // r15\n  __int64 v27; // r14\n  TreeNode **v28; // r14\n  __int64 v29; // rbp\n  __int64 v30; // rax\n  TreeNode **v31; // r15\n  __int64 v32; // r14\n  __int64 v33; // r14\n  __int64 v34; // rax\n  TreeNode **v35; // r15\n  __int64 v36; // rbp\n  __int64 v37; // rbp\n  __int64 v38; // rax\n  TreeNodeTag *v39; // r14\n  __int64 v40; // rbx\n  TreeNode ****v41; // rdx\n  __int64 v42; // r13\n  TreeNode ***v43; // r15\n  TreeNode **v44; // rbx\n  __int64 v45; // r13\n  __int64 v46; // rax\n  TreeNode **v47; // r15\n  __int64 v48; // rbx\n  __int64 v49; // rbx\n  __int64 v50; // rax\n  TreeNode **v51; // r15\n  __int64 v52; // r13\n  __int64 v53; // r13\n  __int64 v54; // rax\n  TreeNode ****v55; // rdx\n  __int64 v56; // rbx\n  TreeNode ***v57; // r15\n  __int64 v58; // r14\n  TreeNode **v59; // r14\n  __int64 v60; // rbx\n  __int64 v61; // rax\n  TreeNode **v62; // r15\n  __int64 v63; // r14\n  __int64 v64; // r14\n  __int64 v65; // rax\n  TreeNode **v66; // r15\n  __int64 v67; // rbx\n  __int64 v68; // rbx\n  __int64 v69; // rax\n  TreeNodeTag *v70; // r12\n  __int64 v71; // rax\n  TreeNodeTag *v72; // r14\n  __int64 v73; // rbp\n  TreeNode ****v74; // rdx\n  __int64 v75; // r13\n  TreeNode ***v76; // r15\n  TreeNode **v77; // rbp\n  __int64 v78; // r13\n  __int64 v79; // rax\n  TreeNode **v80; // r15\n  __int64 v81; // rbp\n  __int64 v82; // rbp\n  __int64 v83; // rax\n  TreeNode ***v84; // rdx\n  __int64 v85; // r13\n  TreeNode **v86; // r13\n  __int64 v87; // r15\n  __int64 v88; // r15\n  __int64 v89; // rax\n  TreeNode **v90; // rdx\n  __int64 v91; // r13\n  __int64 v92; // r13\n  __int64 v93; // rax\n  TreeNode ****v94; // rdx\n  __int64 v95; // rbp\n  TreeNode ***v96; // r15\n  __int64 v97; // r14\n  TreeNode **v98; // r14\n  __int64 v99; // rbp\n  __int64 v100; // rax\n  TreeNode **v101; // r15\n  __int64 v102; // r14\n  __int64 v103; // r14\n  __int64 v104; // rax\n  TreeNode ***v105; // rdx\n  __int64 v106; // rbp\n  TreeNode **v107; // rbp\n  __int64 v108; // r15\n  __int64 v109; // r15\n  __int64 v110; // rax\n  TreeNode **v111; // rdx\n  __int64 v112; // rbp\n  __int64 v113; // rbp\n  __int64 v114; // rax\n  TreeNodeTag *v115; // r14\n  __int64 v116; // rax\n  TreeNode ****v117; // rdx\n  __int64 v118; // r13\n  TreeNode ***v119; // r15\n  __int64 v120; // r12\n  TreeNode **v121; // r12\n  __int64 v122; // r13\n  __int64 v123; // rax\n  TreeNode **v124; // r15\n  __int64 v125; // r12\n  __int64 v126; // r12\n  __int64 v127; // rax\n  TreeNode ***v128; // rdx\n  __int64 v129; // r13\n  TreeNode **v130; // r13\n  __int64 v131; // r15\n  __int64 v132; // r15\n  __int64 v133; // rax\n  TreeNode **v134; // rdx\n  __int64 v135; // r13\n  __int64 v136; // r13\n  __int64 v137; // rax\n  TreeNodeTag *v138; // r12\n  __int64 v139; // rax\n  TreeNode **p_Left; // r15\n  __int64 v141; // r14\n  __int64 v142; // r14\n  __int64 v143; // rax\n  TreeNode ***v144; // r12\n  __int64 v145; // rax\n  __int64 v146; // r15\n  __int64 v147; // r15\n  __int64 v148; // rax\n  TreeNode **v149; // rdx\n  __int64 v150; // rax\n  __int64 v151; // r12\n  __int64 v152; // rax\n  TreeNodeTag *v154; // [rsp+0h] [rbp-40h]\n  TreeNode ****v155; // [rsp+0h] [rbp-40h]\n  TreeNode ***v156; // [rsp+0h] [rbp-40h]\n  TreeNode **v157; // [rsp+0h] [rbp-40h]\n  TreeNode ****v158; // [rsp+0h] [rbp-40h]\n  TreeNode ****v159; // [rsp+0h] [rbp-40h]\n  TreeNodeTag *v160; // [rsp+0h] [rbp-40h]\n  TreeNode ****v161; // [rsp+0h] [rbp-40h]\n  TreeNode ****v162; // [rsp+0h] [rbp-40h]\n  TreeNode ****v163; // [rsp+0h] [rbp-40h]\n  TreeNodeTag *v164; // [rsp+0h] [rbp-40h]\n  TreeNode ****v165; // [rsp+0h] [rbp-40h]\n  TreeNode ***v166; // [rsp+0h] [rbp-40h]\n  TreeNode **v167; // [rsp+0h] [rbp-40h]\n  TreeNode ****v168; // [rsp+0h] [rbp-40h]\n  TreeNode ****v169; // [rsp+0h] [rbp-40h]\n  TreeNode ***v170; // [rsp+0h] [rbp-40h]\n  TreeNode **v171; // [rsp+0h] [rbp-40h]\n  TreeNodeTag *v172; // [rsp+0h] [rbp-40h]\n  TreeNode ****v173; // [rsp+0h] [rbp-40h]\n  TreeNode ***v174; // [rsp+0h] [rbp-40h]\n  TreeNode **v175; // [rsp+0h] [rbp-40h]\n  TreeNode **v176; // [rsp+0h] [rbp-40h]\n  TreeNode **v177; // [rsp+0h] [rbp-40h]\n\n  if ( !rootNode )\n    return 0LL;\n  v1 = 0LL;\n  Left = rootNode->Left;\n  if ( rootNode->Left )\n  {\n    v3 = Left->Left;\n    v4 = 0LL;\n    if ( Left->Left )\n    {\n      v5 = (TreeNode ****)v3->Left;\n      if ( v3->Left )\n      {\n        v6 = *v5;\n        if ( *v5 )\n        {\n          v7 = *v6;\n          if ( *v6 )\n          {\n            v154 = v3->Left;\n            v8 = Height(*v7);\n            v9 = Height(v7[1]);\n            v5 = (TreeNode ****)v154;\n            if ( v8 < v9 )\n              v8 = v9;\n            v1 = v8 + 1;\n          }\n          v10 = v6[1];\n          v11 = 0LL;\n          if ( v10 )\n          {\n            v155 = v5;\n            v12 = Height(*v10);\n            v13 = Height(v10[1]);\n            v5 = v155;\n            if ( v12 < v13 )\n              v12 = v13;\n            v11 = v12 + 1;\n          }\n          if ( v11 < v1 )\n            v11 = v1;\n          v4 = v11 + 1;\n        }\n        v14 = v5[1];\n        v15 = 0LL;\n        if ( v14 )\n        {\n          v16 = *v14;\n          v17 = 0LL;\n          if ( *v14 )\n          {\n            v156 = v14;\n            v18 = Height(*v16);\n            v19 = Height(v16[1]);\n            v14 = v156;\n            if ( v18 < v19 )\n              v18 = v19;\n            v17 = v18 + 1;\n          }\n          v20 = v14[1];\n          v21 = 0LL;\n          if ( v20 )\n          {\n            v157 = v20;\n            v22 = Height(*v20);\n            v23 = Height(v157[1]);\n            if ( v22 < v23 )\n              v22 = v23;\n            v21 = v22 + 1;\n          }\n          if ( v21 < v17 )\n            v21 = v17;\n          v15 = v21 + 1;\n        }\n        if ( v15 < v4 )\n          v15 = v4;\n        v1 = v15 + 1;\n      }\n      Right = (TreeNode ****)v3->Right;\n      v25 = 0LL;\n      if ( Right )\n      {\n        v26 = *Right;\n        v27 = 0LL;\n        if ( *Right )\n        {\n          v28 = *v26;\n          if ( *v26 )\n          {\n            v158 = Right;\n            v29 = Height(*v28);\n            v30 = Height(v28[1]);\n            Right = v158;\n            if ( v29 < v30 )\n              v29 = v30;\n            v25 = v29 + 1;\n          }\n          v31 = v26[1];\n          v32 = 0LL;\n          if ( v31 )\n          {\n            v159 = Right;\n            v33 = Height(*v31);\n            v34 = Height(v31[1]);\n            Right = v159;\n            if ( v33 < v34 )\n              v33 = v34;\n            v32 = v33 + 1;\n          }\n          if ( v32 < v25 )\n            v32 = v25;\n          v27 = v32 + 1;\n        }\n        v35 = (TreeNode **)Right[1];\n        v36 = 0LL;\n        if ( v35 )\n        {\n          v37 = Height(*v35);\n          v38 = Height(v35[1]);\n          if ( v37 < v38 )\n            v37 = v38;\n          v36 = v37 + 1;\n        }\n        if ( v36 < v27 )\n          v36 = v27;\n        v25 = v36 + 1;\n      }\n      if ( v25 < v1 )\n        v25 = v1;\n      v4 = v25 + 1;\n    }\n    v39 = Left->Right;\n    v40 = 0LL;\n    if ( v39 )\n    {\n      v41 = (TreeNode ****)v39->Left;\n      v42 = 0LL;\n      if ( v39->Left )\n      {\n        v43 = *v41;\n        if ( *v41 )\n        {\n          v44 = *v43;\n          if ( *v43 )\n          {\n            v160 = v39->Left;\n            v45 = Height(*v44);\n            v46 = Height(v44[1]);\n            v41 = (TreeNode ****)v160;\n            if ( v45 < v46 )\n              v45 = v46;\n            v42 = v45 + 1;\n          }\n          v47 = v43[1];\n          v48 = 0LL;\n          if ( v47 )\n          {\n            v161 = v41;\n            v49 = Height(*v47);\n            v50 = Height(v47[1]);\n            v41 = v161;\n            if ( v49 < v50 )\n              v49 = v50;\n            v48 = v49 + 1;\n          }\n          if ( v48 < v42 )\n            v48 = v42;\n          v40 = v48 + 1;\n        }\n        v51 = (TreeNode **)v41[1];\n        v52 = 0LL;\n        if ( v51 )\n        {\n          v53 = Height(*v51);\n          v54 = Height(v51[1]);\n          if ( v53 < v54 )\n            v53 = v54;\n          v52 = v53 + 1;\n        }\n        if ( v52 < v40 )\n          v52 = v40;\n        v42 = v52 + 1;\n      }\n      v55 = (TreeNode ****)v39->Right;\n      v56 = 0LL;\n      if ( v55 )\n      {\n        v57 = *v55;\n        v58 = 0LL;\n        if ( *v55 )\n        {\n          v59 = *v57;\n          if ( *v57 )\n          {\n            v162 = v55;\n            v60 = Height(*v59);\n            v61 = Height(v59[1]);\n            v55 = v162;\n            if ( v60 < v61 )\n              v60 = v61;\n            v56 = v60 + 1;\n          }\n          v62 = v57[1];\n          v63 = 0LL;\n          if ( v62 )\n          {\n            v163 = v55;\n            v64 = Height(*v62);\n            v65 = Height(v62[1]);\n            v55 = v163;\n            if ( v64 < v65 )\n              v64 = v65;\n            v63 = v64 + 1;\n          }\n          if ( v63 < v56 )\n            v63 = v56;\n          v58 = v63 + 1;\n        }\n        v66 = (TreeNode **)v55[1];\n        v67 = 0LL;\n        if ( v66 )\n        {\n          v68 = Height(*v66);\n          v69 = Height(v66[1]);\n          if ( v68 < v69 )\n            v68 = v69;\n          v67 = v68 + 1;\n        }\n        if ( v67 < v58 )\n          v67 = v58;\n        v56 = v67 + 1;\n      }\n      if ( v56 < v42 )\n        v56 = v42;\n      v40 = v56 + 1;\n    }\n    if ( v40 < v4 )\n      v40 = v4;\n    v1 = v40 + 1;\n  }\n  v70 = rootNode->Right;\n  v71 = 0LL;\n  if ( v70 )\n  {\n    v72 = v70->Left;\n    v73 = 0LL;\n    if ( v70->Left )\n    {\n      v74 = (TreeNode ****)v72->Left;\n      v75 = 0LL;\n      if ( v72->Left )\n      {\n        v76 = *v74;\n        if ( *v74 )\n        {\n          v77 = *v76;\n          if ( *v76 )\n          {\n            v164 = v72->Left;\n            v78 = Height(*v77);\n            v79 = Height(v77[1]);\n            v74 = (TreeNode ****)v164;\n            if ( v78 < v79 )\n              v78 = v79;\n            v75 = v78 + 1;\n          }\n          v80 = v76[1];\n          v81 = 0LL;\n          if ( v80 )\n          {\n            v165 = v74;\n            v82 = Height(*v80);\n            v83 = Height(v80[1]);\n            v74 = v165;\n            if ( v82 < v83 )\n              v82 = v83;\n            v81 = v82 + 1;\n          }\n          if ( v81 < v75 )\n            v81 = v75;\n          v73 = v81 + 1;\n        }\n        v84 = v74[1];\n        v85 = 0LL;\n        if ( v84 )\n        {\n          v86 = *v84;\n          v87 = 0LL;\n          if ( *v84 )\n          {\n            v166 = v84;\n            v88 = Height(*v86);\n            v89 = Height(v86[1]);\n            v84 = v166;\n            if ( v88 < v89 )\n              v88 = v89;\n            v87 = v88 + 1;\n          }\n          v90 = v84[1];\n          v91 = 0LL;\n          if ( v90 )\n          {\n            v167 = v90;\n            v92 = Height(*v90);\n            v93 = Height(v167[1]);\n            if ( v92 < v93 )\n              v92 = v93;\n            v91 = v92 + 1;\n          }\n          if ( v91 < v87 )\n            v91 = v87;\n          v85 = v91 + 1;\n        }\n        if ( v85 < v73 )\n          v85 = v73;\n        v75 = v85 + 1;\n      }\n      v94 = (TreeNode ****)v72->Right;\n      v95 = 0LL;\n      if ( v94 )\n      {\n        v96 = *v94;\n        v97 = 0LL;\n        if ( *v94 )\n        {\n          v98 = *v96;\n          if ( *v96 )\n          {\n            v168 = v94;\n            v99 = Height(*v98);\n            v100 = Height(v98[1]);\n            v94 = v168;\n            if ( v99 < v100 )\n              v99 = v100;\n            v95 = v99 + 1;\n          }\n          v101 = v96[1];\n          v102 = 0LL;\n          if ( v101 )\n          {\n            v169 = v94;\n            v103 = Height(*v101);\n            v104 = Height(v101[1]);\n            v94 = v169;\n            if ( v103 < v104 )\n              v103 = v104;\n            v102 = v103 + 1;\n          }\n          if ( v102 < v95 )\n            v102 = v95;\n          v97 = v102 + 1;\n        }\n        v105 = v94[1];\n        v106 = 0LL;\n        if ( v105 )\n        {\n          v107 = *v105;\n          v108 = 0LL;\n          if ( *v105 )\n          {\n            v170 = v105;\n            v109 = Height(*v107);\n            v110 = Height(v107[1]);\n            v105 = v170;\n            if ( v109 < v110 )\n              v109 = v110;\n            v108 = v109 + 1;\n          }\n          v111 = v105[1];\n          v112 = 0LL;\n          if ( v111 )\n          {\n            v171 = v111;\n            v113 = Height(*v111);\n            v114 = Height(v171[1]);\n            if ( v113 < v114 )\n              v113 = v114;\n            v112 = v113 + 1;\n          }\n          if ( v112 < v108 )\n            v112 = v108;\n          v106 = v112 + 1;\n        }\n        if ( v106 < v97 )\n          v106 = v97;\n        v95 = v106 + 1;\n      }\n      if ( v95 < v75 )\n        v95 = v75;\n      v73 = v95 + 1;\n    }\n    v115 = v70->Right;\n    v116 = 0LL;\n    if ( v115 )\n    {\n      v117 = (TreeNode ****)v115->Left;\n      v118 = 0LL;\n      if ( v115->Left )\n      {\n        v119 = *v117;\n        v120 = 0LL;\n        if ( *v117 )\n        {\n          v121 = *v119;\n          if ( *v119 )\n          {\n            v172 = v115->Left;\n            v122 = Height(*v121);\n            v123 = Height(v121[1]);\n            v117 = (TreeNode ****)v172;\n            if ( v122 < v123 )\n              v122 = v123;\n            v118 = v122 + 1;\n          }\n          v124 = v119[1];\n          v125 = 0LL;\n          if ( v124 )\n          {\n            v173 = v117;\n            v126 = Height(*v124);\n            v127 = Height(v124[1]);\n            v117 = v173;\n            if ( v126 < v127 )\n              v126 = v127;\n            v125 = v126 + 1;\n          }\n          if ( v125 < v118 )\n            v125 = v118;\n          v120 = v125 + 1;\n        }\n        v128 = v117[1];\n        v129 = 0LL;\n        if ( v128 )\n        {\n          v130 = *v128;\n          v131 = 0LL;\n          if ( *v128 )\n          {\n            v174 = v128;\n            v132 = Height(*v130);\n            v133 = Height(v130[1]);\n            v128 = v174;\n            if ( v132 < v133 )\n              v132 = v133;\n            v131 = v132 + 1;\n          }\n          v134 = v128[1];\n          v135 = 0LL;\n          if ( v134 )\n          {\n            v175 = v134;\n            v136 = Height(*v134);\n            v137 = Height(v175[1]);\n            if ( v136 < v137 )\n              v136 = v137;\n            v135 = v136 + 1;\n          }\n          if ( v135 < v131 )\n            v135 = v131;\n          v129 = v135 + 1;\n        }\n        if ( v129 < v120 )\n          v129 = v120;\n        v118 = v129 + 1;\n      }\n      v138 = v115->Right;\n      v139 = 0LL;\n      if ( v138 )\n      {\n        p_Left = &v138->Left->Left;\n        v141 = 0LL;\n        if ( v138->Left )\n        {\n          v142 = Height(*p_Left);\n          v143 = Height(p_Left[1]);\n          if ( v142 < v143 )\n            v142 = v143;\n          v141 = v142 + 1;\n        }\n        v144 = (TreeNode ***)v138->Right;\n        v145 = 0LL;\n        if ( v144 )\n        {\n          v146 = 0LL;\n          if ( *v144 )\n          {\n            v176 = *v144;\n            v147 = Height(**v144);\n            v148 = Height(v176[1]);\n            if ( v147 < v148 )\n              v147 = v148;\n            v146 = v147 + 1;\n          }\n          v149 = v144[1];\n          v150 = 0LL;\n          if ( v149 )\n          {\n            v177 = v144[1];\n            v151 = Height(*v149);\n            v152 = Height(v177[1]);\n            if ( v151 >= v152 )\n              v152 = v151;\n            v150 = v152 + 1;\n          }\n          if ( v150 < v146 )\n            v150 = v146;\n          v145 = v150 + 1;\n        }\n        if ( v145 < v141 )\n          v145 = v141;\n        v139 = v145 + 1;\n      }\n      if ( v139 < v118 )\n        v139 = v118;\n      v116 = v139 + 1;\n    }\n    if ( v116 < v73 )\n      v116 = v73;\n    v71 = v116 + 1;\n  }\n  if ( v71 < v1 )\n    v71 = v1;\n  return v71 + 1;\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<Height>:\nendbr64\ntest   %rdi,%rdi\nje     30e0 <Height+0x830>\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x18,%rsp\nmov    (%rdi),%r13\ntest   %r13,%r13\nje     2c66 <Height+0x3b6>\nmov    0x0(%r13),%r14\nxor    %ebp,%ebp\ntest   %r14,%r14\nje     2ac4 <Height+0x214>\nmov    (%r14),%rdx\ntest   %rdx,%rdx\nje     29f9 <Height+0x149>\nmov    (%rdx),%r15\ntest   %r15,%r15\nje     2970 <Height+0xc0>\nmov    (%r15),%rbp\ntest   %rbp,%rbp\nje     2931 <Height+0x81>\nmov    0x0(%rbp),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%rbp),%rdi\nmov    %rax,%rbx\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbx\ncmovl  %rax,%rbx\nadd    $0x1,%rbx\nmov    0x8(%r15),%r15\nxor    %ebp,%ebp\ntest   %r15,%r15\nje     2965 <Height+0xb5>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%rbp\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbp\ncmovl  %rax,%rbp\nadd    $0x1,%rbp\ncmp    %rbx,%rbp\ncmovl  %rbx,%rbp\nadd    $0x1,%rbp\nmov    0x8(%rdx),%rdx\nxor    %ebx,%ebx\ntest   %rdx,%rdx\nje     29ee <Height+0x13e>\nmov    (%rdx),%rbx\nxor    %r15d,%r15d\ntest   %rbx,%rbx\nje     29af <Height+0xff>\nmov    (%rbx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%rbx),%rdi\nmov    %rax,%r15\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r15\ncmovl  %rax,%r15\nadd    $0x1,%r15\nmov    0x8(%rdx),%rdx\nxor    %ebx,%ebx\ntest   %rdx,%rdx\nje     29e3 <Height+0x133>\nmov    (%rdx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\nmov    %rax,%rbx\nmov    0x8(%rdx),%rdi\ncall   28b0 <Height>\ncmp    %rax,%rbx\ncmovl  %rax,%rbx\nadd    $0x1,%rbx\ncmp    %r15,%rbx\ncmovl  %r15,%rbx\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\ncmovl  %rbp,%rbx\nadd    $0x1,%rbx\nmov    0x8(%r14),%rdx\nxor    %ebp,%ebp\ntest   %rdx,%rdx\nje     2ab9 <Height+0x209>\nmov    (%rdx),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     2a84 <Height+0x1d4>\nmov    (%r15),%r14\ntest   %r14,%r14\nje     2a44 <Height+0x194>\nmov    (%r14),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r14),%rdi\nmov    %rax,%rbp\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbp\ncmovl  %rax,%rbp\nadd    $0x1,%rbp\nmov    0x8(%r15),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     2a79 <Height+0x1c9>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%r14\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r14\ncmovl  %rax,%r14\nadd    $0x1,%r14\ncmp    %rbp,%r14\ncmovl  %rbp,%r14\nadd    $0x1,%r14\nmov    0x8(%rdx),%r15\nxor    %ebp,%ebp\ntest   %r15,%r15\nje     2aae <Height+0x1fe>\nmov    (%r15),%rdi\ncall   28b0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%rbp\ncall   28b0 <Height>\ncmp    %rax,%rbp\ncmovl  %rax,%rbp\nadd    $0x1,%rbp\ncmp    %r14,%rbp\ncmovl  %r14,%rbp\nadd    $0x1,%rbp\ncmp    %rbx,%rbp\ncmovl  %rbx,%rbp\nadd    $0x1,%rbp\nmov    0x8(%r13),%r14\nxor    %ebx,%ebx\ntest   %r14,%r14\nje     2c5b <Height+0x3ab>\nmov    (%r14),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     2b90 <Height+0x2e0>\nmov    (%rdx),%r15\ntest   %r15,%r15\nje     2b5a <Height+0x2aa>\nmov    (%r15),%rbx\ntest   %rbx,%rbx\nje     2b1b <Height+0x26b>\nmov    (%rbx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%rbx),%rdi\nmov    %rax,%r13\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r13\ncmovl  %rax,%r13\nadd    $0x1,%r13\nmov    0x8(%r15),%r15\nxor    %ebx,%ebx\ntest   %r15,%r15\nje     2b4f <Height+0x29f>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%rbx\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbx\ncmovl  %rax,%rbx\nadd    $0x1,%rbx\ncmp    %r13,%rbx\ncmovl  %r13,%rbx\nadd    $0x1,%rbx\nmov    0x8(%rdx),%r15\nxor    %r13d,%r13d\ntest   %r15,%r15\nje     2b85 <Height+0x2d5>\nmov    (%r15),%rdi\ncall   28b0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%r13\ncall   28b0 <Height>\ncmp    %rax,%r13\ncmovl  %rax,%r13\nadd    $0x1,%r13\ncmp    %rbx,%r13\ncmovl  %rbx,%r13\nadd    $0x1,%r13\nmov    0x8(%r14),%rdx\nxor    %ebx,%ebx\ntest   %rdx,%rdx\nje     2c50 <Height+0x3a0>\nmov    (%rdx),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     2c1b <Height+0x36b>\nmov    (%r15),%r14\ntest   %r14,%r14\nje     2bdb <Height+0x32b>\nmov    (%r14),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r14),%rdi\nmov    %rax,%rbx\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbx\ncmovl  %rax,%rbx\nadd    $0x1,%rbx\nmov    0x8(%r15),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     2c10 <Height+0x360>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%r14\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r14\ncmovl  %rax,%r14\nadd    $0x1,%r14\ncmp    %rbx,%r14\ncmovl  %rbx,%r14\nadd    $0x1,%r14\nmov    0x8(%rdx),%r15\nxor    %ebx,%ebx\ntest   %r15,%r15\nje     2c45 <Height+0x395>\nmov    (%r15),%rdi\ncall   28b0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%rbx\ncall   28b0 <Height>\ncmp    %rax,%rbx\ncmovl  %rax,%rbx\nadd    $0x1,%rbx\ncmp    %r14,%rbx\ncmovl  %r14,%rbx\nadd    $0x1,%rbx\ncmp    %r13,%rbx\ncmovl  %r13,%rbx\nadd    $0x1,%rbx\ncmp    %rbp,%rbx\ncmovl  %rbp,%rbx\nadd    $0x1,%rbx\nmov    0x8(%r12),%r12\nxor    %eax,%eax\ntest   %r12,%r12\nje     30be <Height+0x80e>\nmov    (%r12),%r14\nxor    %ebp,%ebp\ntest   %r14,%r14\nje     2eb9 <Height+0x609>\nmov    (%r14),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     2d99 <Height+0x4e9>\nmov    (%rdx),%r15\ntest   %r15,%r15\nje     2d0d <Height+0x45d>\nmov    (%r15),%rbp\ntest   %rbp,%rbp\nje     2cce <Height+0x41e>\nmov    0x0(%rbp),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%rbp),%rdi\nmov    %rax,%r13\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r13\ncmovl  %rax,%r13\nadd    $0x1,%r13\nmov    0x8(%r15),%r15\nxor    %ebp,%ebp\ntest   %r15,%r15\nje     2d02 <Height+0x452>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%rbp\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbp\ncmovl  %rax,%rbp\nadd    $0x1,%rbp\ncmp    %r13,%rbp\ncmovl  %r13,%rbp\nadd    $0x1,%rbp\nmov    0x8(%rdx),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     2d8e <Height+0x4de>\nmov    (%rdx),%r13\nxor    %r15d,%r15d\ntest   %r13,%r13\nje     2d4e <Height+0x49e>\nmov    0x0(%r13),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r13),%rdi\nmov    %rax,%r15\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r15\ncmovl  %rax,%r15\nadd    $0x1,%r15\nmov    0x8(%rdx),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     2d83 <Height+0x4d3>\nmov    (%rdx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\nmov    %rax,%r13\nmov    0x8(%rdx),%rdi\ncall   28b0 <Height>\ncmp    %rax,%r13\ncmovl  %rax,%r13\nadd    $0x1,%r13\ncmp    %r15,%r13\ncmovl  %r15,%r13\nadd    $0x1,%r13\ncmp    %rbp,%r13\ncmovl  %rbp,%r13\nadd    $0x1,%r13\nmov    0x8(%r14),%rdx\nxor    %ebp,%ebp\ntest   %rdx,%rdx\nje     2eae <Height+0x5fe>\nmov    (%rdx),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     2e24 <Height+0x574>\nmov    (%r15),%r14\ntest   %r14,%r14\nje     2de4 <Height+0x534>\nmov    (%r14),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r14),%rdi\nmov    %rax,%rbp\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%rbp\ncmovl  %rax,%rbp\nadd    $0x1,%rbp\nmov    0x8(%r15),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     2e19 <Height+0x569>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%r14\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r14\ncmovl  %rax,%r14\nadd    $0x1,%r14\ncmp    %rbp,%r14\ncmovl  %rbp,%r14\nadd    $0x1,%r14\nmov    0x8(%rdx),%rdx\nxor    %ebp,%ebp\ntest   %rdx,%rdx\nje     2ea3 <Height+0x5f3>\nmov    (%rdx),%rbp\nxor    %r15d,%r15d\ntest   %rbp,%rbp\nje     2e64 <Height+0x5b4>\nmov    0x0(%rbp),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%rbp),%rdi\nmov    %rax,%r15\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r15\ncmovl  %rax,%r15\nadd    $0x1,%r15\nmov    0x8(%rdx),%rdx\nxor    %ebp,%ebp\ntest   %rdx,%rdx\nje     2e98 <Height+0x5e8>\nmov    (%rdx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\nmov    %rax,%rbp\nmov    0x8(%rdx),%rdi\ncall   28b0 <Height>\ncmp    %rax,%rbp\ncmovl  %rax,%rbp\nadd    $0x1,%rbp\ncmp    %r15,%rbp\ncmovl  %r15,%rbp\nadd    $0x1,%rbp\ncmp    %r14,%rbp\ncmovl  %r14,%rbp\nadd    $0x1,%rbp\ncmp    %r13,%rbp\ncmovl  %r13,%rbp\nadd    $0x1,%rbp\nmov    0x8(%r12),%r14\nxor    %eax,%eax\ntest   %r14,%r14\nje     30b3 <Height+0x803>\nmov    (%r14),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     2fe2 <Height+0x732>\nmov    (%rdx),%r15\nxor    %r12d,%r12d\ntest   %r15,%r15\nje     2f56 <Height+0x6a6>\nmov    (%r15),%r12\ntest   %r12,%r12\nje     2f16 <Height+0x666>\nmov    (%r12),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r12),%rdi\nmov    %rax,%r13\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r13\ncmovl  %rax,%r13\nadd    $0x1,%r13\nmov    0x8(%r15),%r15\nxor    %r12d,%r12d\ntest   %r15,%r15\nje     2f4b <Height+0x69b>\nmov    (%r15),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%r12\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r12\ncmovl  %rax,%r12\nadd    $0x1,%r12\ncmp    %r13,%r12\ncmovl  %r13,%r12\nadd    $0x1,%r12\nmov    0x8(%rdx),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     2fd7 <Height+0x727>\nmov    (%rdx),%r13\nxor    %r15d,%r15d\ntest   %r13,%r13\nje     2f97 <Height+0x6e7>\nmov    0x0(%r13),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%r13),%rdi\nmov    %rax,%r15\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\ncmp    %rax,%r15\ncmovl  %rax,%r15\nadd    $0x1,%r15\nmov    0x8(%rdx),%rdx\nxor    %r13d,%r13d\ntest   %rdx,%rdx\nje     2fcc <Height+0x71c>\nmov    (%rdx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\nmov    %rax,%r13\nmov    0x8(%rdx),%rdi\ncall   28b0 <Height>\ncmp    %rax,%r13\ncmovl  %rax,%r13\nadd    $0x1,%r13\ncmp    %r15,%r13\ncmovl  %r15,%r13\nadd    $0x1,%r13\ncmp    %r12,%r13\ncmovl  %r12,%r13\nadd    $0x1,%r13\nmov    0x8(%r14),%r12\nxor    %eax,%eax\ntest   %r12,%r12\nje     30a8 <Height+0x7f8>\nmov    (%r12),%r15\nxor    %r14d,%r14d\ntest   %r15,%r15\nje     301c <Height+0x76c>\nmov    (%r15),%rdi\ncall   28b0 <Height>\nmov    0x8(%r15),%rdi\nmov    %rax,%r14\ncall   28b0 <Height>\ncmp    %rax,%r14\ncmovl  %rax,%r14\nadd    $0x1,%r14\nmov    0x8(%r12),%r12\nxor    %eax,%eax\ntest   %r12,%r12\nje     309d <Height+0x7ed>\nmov    (%r12),%rdx\nxor    %r15d,%r15d\ntest   %rdx,%rdx\nje     305d <Height+0x7ad>\nmov    (%rdx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\nmov    %rax,%r15\nmov    0x8(%rdx),%rdi\ncall   28b0 <Height>\ncmp    %rax,%r15\ncmovl  %rax,%r15\nadd    $0x1,%r15\nmov    0x8(%r12),%rdx\nxor    %eax,%eax\ntest   %rdx,%rdx\nje     3092 <Height+0x7e2>\nmov    (%rdx),%rdi\nmov    %rdx,0x8(%rsp)\ncall   28b0 <Height>\nmov    0x8(%rsp),%rdx\nmov    %rax,%r12\nmov    0x8(%rdx),%rdi\ncall   28b0 <Height>\ncmp    %rax,%r12\ncmovge %r12,%rax\nadd    $0x1,%rax\ncmp    %r15,%rax\ncmovl  %r15,%rax\nadd    $0x1,%rax\ncmp    %r14,%rax\ncmovl  %r14,%rax\nadd    $0x1,%rax\ncmp    %r13,%rax\ncmovl  %r13,%rax\nadd    $0x1,%rax\ncmp    %rbp,%rax\ncmovl  %rbp,%rax\nadd    $0x1,%rax\ncmp    %rbx,%rax\ncmovl  %rbx,%rax\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\nadd    $0x1,%rax\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "Insert", "content": "TreeNode *Insert(TreeNode *tnode, Element Item, char *Name)\n{\n    /* flag for the recursive function */\n    short done = 0;\n    /* run and return the recursive insert */\n    return InsertNode(tnode, Item, Name, &done);\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "Insert", "address": "0x1f30", "label": "Insert", "content": "TreeNode *__fastcall Insert(TreeNode *tnode, Element Item, char *Name)\n{\n  __int16 done; // [rsp+6h] [rbp-12h] BYREF\n  unsigned __int64 v5; // [rsp+8h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  done = 0;\n  return InsertNode(tnode, Item, Name, &done);\n}\n"}, "pseudo_normalize": "TreeNode *Insert(TreeNode *tnode, Element Item, char *Name) {\n  short done;\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  done = 0;\n  return InsertNode(tnode, Item, Name, &done);\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<Insert>:\nendbr64\nsub    $0x18,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nlea    0x6(%rsp),%rcx\nxor    %eax,%eax\nmov    %ax,0x6(%rsp)\ncall   1df0 <InsertNode>\nmov    0x8(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    1f6e <Insert+0x3e>\nadd    $0x18,%rsp\nret\ncall   10c0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "InsertNode", "content": "TreeNode *InsertNode(TreeNode *tnode, Element Item,\n                     char *Name, short *finished)\n{\n    TreeNode *subtree = NULL;\n    short comp = 0;\n    \n    if(tnode == NULL)    {\n        /* found the spot that the TreeNode belongs */\n        tnode = libmin_malloc(sizeof(TreeNode));\n        /* malloc problem, return NULL */\n        if(tnode == NULL)\n            return NULL;\n        else    {\n            /* default settings for a new node */\n            tnode->Left = NULL;\n            tnode->Right = NULL;\n            tnode->Item = Item;\n            tnode->Name = Name;\n            tnode->Balance = 0;\n        }\n    } else {\n        /* need to find the new node, don't check for a 0,\n           cos its already in teh tree, foo */\n        comp = Compare(Item, tnode->Item);\n        if(comp < 0)    {\n            /* go left */\n            subtree = InsertNode(tnode->Left, Item, Name, finished);\n            /* if this is NULL, there is problem. quit now */\n            if(subtree == NULL)\n                return NULL;\n            /* you are not finished until Balance == 0, reached the root\n                or a rotation has occured */\n            if(!*finished)\n                tnode->Balance--;\n            tnode->Left = subtree;\n        } else if(comp > 0)    {\n            /* go right */\n            subtree = InsertNode(tnode->Right, Item, Name, finished);\n            if(subtree == NULL)\n                return NULL;\n            if(!*finished)\n                tnode->Balance++;\n            tnode->Right = subtree;\n        } else\n            /* got a dupe, return NULL */\n            return NULL;\n\n        /* check if a rotation is neccessary */\n        if(!*finished)  {\n            tnode = CheckTreeNodeRotation(tnode, subtree, finished);\n        }\n    }\n    return tnode;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "InsertNode", "address": "0x1df0", "label": "InsertNode", "content": "TreeNode *__fastcall InsertNode(TreeNode *tnode, Element Item, char *Name, __int16 *finished)\n{\n  __int16 v6; // ax\n  TreeNode *inserted; // rax\n  TreeNode *v8; // rsi\n  __int16 v9; // dx\n  TreeNode *result; // rax\n  TreeNode *v11; // rax\n  __int16 v12; // dx\n\n  if ( tnode )\n  {\n    v6 = Compare(Item, tnode->Item);\n    if ( v6 >= 0 )\n    {\n      if ( v6 )\n      {\n        inserted = InsertNode(tnode->Right, Item, Name, finished);\n        v8 = inserted;\n        if ( inserted )\n        {\n          v9 = *finished;\n          if ( !*finished )\n          {\n            ++tnode->Balance;\n            v9 = *finished;\n          }\n          tnode->Right = inserted;\n          result = tnode;\n          if ( v9 )\n            return result;\n          return CheckTreeNodeRotation(tnode, v8, finished);\n        }\n      }\n      return 0LL;\n    }\n    v11 = InsertNode(tnode->Left, Item, Name, finished);\n    v8 = v11;\n    if ( !v11 )\n      return 0LL;\n    v12 = *finished;\n    if ( !*finished )\n    {\n      --tnode->Balance;\n      v12 = *finished;\n    }\n    tnode->Left = v11;\n    result = tnode;\n    if ( !v12 )\n      return CheckTreeNodeRotation(tnode, v8, finished);\n  }\n  else\n  {\n    result = (TreeNode *)libmin_malloc(0x28uLL);\n    if ( result )\n    {\n      result->Left = 0LL;\n      result->Right = 0LL;\n      result->Item = Item;\n      result->Name = Name;\n      result->Balance = 0;\n    }\n  }\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *InsertNode(TreeNode *tnode, Element Item, char *Name,\n                     short *finished) {\n  short v6;\n  TreeNode *inserted;\n  TreeNode *v8;\n  short v9;\n  TreeNode *result;\n  TreeNode *v11;\n  short v12;\n  if (tnode) {\n    v6 = Compare(Item, tnode->Item);\n    if (v6 >= 0) {\n      if (v6) {\n        inserted = InsertNode(tnode->Right, Item, Name, finished);\n        v8 = inserted;\n        if (inserted) {\n          v9 = *finished;\n          if (!*finished) {\n            ++tnode->Balance;\n            v9 = *finished;\n          }\n          tnode->Right = inserted;\n          result = tnode;\n          if (v9) return result;\n          return CheckTreeNodeRotation(tnode, v8, finished);\n        }\n      }\n      return 0LL;\n    }\n    v11 = InsertNode(tnode->Left, Item, Name, finished);\n    v8 = v11;\n    if (!v11) return 0LL;\n    v12 = *finished;\n    if (!*finished) {\n      --tnode->Balance;\n      v12 = *finished;\n    }\n    tnode->Left = v11;\n    result = tnode;\n    if (!v12) return CheckTreeNodeRotation(tnode, v8, finished);\n  } else {\n    result = (TreeNode *)libmin_malloc(40uLL);\n    if (result) {\n      result->Left = 0LL;\n      result->Right = 0LL;\n      result->Item = Item;\n      result->Name = Name;\n      result->Balance = 0;\n    }\n  }\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<InsertNode>:\nendbr64\npush   %r14\nmov    %rdx,%r14\npush   %r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nsub    $0x8,%rsp\ntest   %rdi,%rdi\nje     1e80 <InsertNode+0x90>\nmov    0x10(%rdi),%rsi\nmov    %rdi,%rbp\nmov    %r12,%rdi\nmov    %rcx,%r13\ncall   1ad0 <Compare>\ntest   %ax,%ax\njs     1ed0 <InsertNode+0xe0>\nje     1e70 <InsertNode+0x80>\nmov    0x8(%rbp),%rdi\nmov    %r12,%rsi\nmov    %r13,%rcx\nmov    %r14,%rdx\ncall   1df0 <InsertNode>\nmov    %rax,%rsi\ntest   %rax,%rax\nje     1e70 <InsertNode+0x80>\nmovzwl 0x0(%r13),%edx\ntest   %dx,%dx\nje     1ec0 <InsertNode+0xd0>\nmov    %rsi,0x8(%rbp)\nmov    %rbp,%rax\ntest   %dx,%dx\nje     1f0e <InsertNode+0x11e>\nadd    $0x8,%rsp\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopw   0x0(%rax,%rax,1)\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nxchg   %ax,%ax\nmov    $0x28,%edi\ncall   3360 <libmin_malloc>\ntest   %rax,%rax\nje     1e5b <InsertNode+0x6b>\nxor    %edx,%edx\nmovq   $0x0,(%rax)\nmovq   $0x0,0x8(%rax)\nmov    %r12,0x10(%rax)\nmov    %r14,0x18(%rax)\nmov    %dx,0x20(%rax)\nadd    $0x8,%rsp\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\naddw   $0x1,0x20(%rbp)\nmovzwl 0x0(%r13),%edx\njmp    1e4b <InsertNode+0x5b>\nnop\nmov    0x0(%rbp),%rdi\nmov    %r12,%rsi\nmov    %r13,%rcx\nmov    %r14,%rdx\ncall   1df0 <InsertNode>\nmov    %rax,%rsi\ntest   %rax,%rax\nje     1e70 <InsertNode+0x80>\nmovzwl 0x0(%r13),%edx\ntest   %dx,%dx\njne    1efe <InsertNode+0x10e>\nsubw   $0x1,0x20(%rbp)\nmovzwl 0x0(%r13),%edx\nmov    %rsi,0x0(%rbp)\nmov    %rbp,%rax\ntest   %dx,%dx\njne    1e5b <InsertNode+0x6b>\nadd    $0x8,%rsp\nmov    %r13,%rdx\nmov    %rbp,%rdi\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\njmp    1c30 <CheckTreeNodeRotation>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "IsEmpty", "content": "short IsEmpty(TreeNode *rootNode)\n{\n    return (rootNode == NULL);\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "IsEmpty", "address": "0x1b80", "label": "IsEmpty", "content": "__int16 __fastcall IsEmpty(TreeNode *rootNode)\n{\n  return rootNode == 0LL;\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<IsEmpty>:\nendbr64\nxor    %eax,%eax\ntest   %rdi,%rdi\nsete   %al\nret\nnopl   (%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "MakeEmpty", "content": "void MakeEmpty(TreeNode *rootNode)\n{\n    /* this function is pretty simple, just traverses the tree and starts\n        free'ing from the bottom up */\n    if(rootNode == NULL)\n        return;\n    MakeEmpty(rootNode->Left);\n    MakeEmpty(rootNode->Right);\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "MakeEmpty", "address": "0x1f80", "label": "MakeEmpty", "content": "void __fastcall MakeEmpty(TreeNode *rootNode)\n{\n  TreeNodeTag *Left; // r12\n  TreeNodeTag *v2; // r13\n  TreeNodeTag *v3; // r14\n  TreeNodeTag *v4; // r15\n  TreeNodeTag *Right; // r15\n  TreeNodeTag *v6; // r14\n  TreeNodeTag *v7; // r15\n  TreeNodeTag *v8; // r15\n  TreeNodeTag *v9; // r13\n  TreeNodeTag *v10; // r14\n  TreeNodeTag *v11; // r15\n  TreeNodeTag *v12; // r15\n  TreeNodeTag *v13; // r14\n  TreeNodeTag *v14; // r15\n  TreeNodeTag *v15; // r15\n  TreeNodeTag *v16; // r12\n  TreeNodeTag *v17; // r13\n  TreeNodeTag *v18; // r14\n  TreeNodeTag *v19; // r15\n  TreeNodeTag *v20; // r15\n  TreeNodeTag *v21; // r14\n  TreeNodeTag *v22; // r15\n  TreeNodeTag *v23; // rbx\n  TreeNodeTag *v24; // rbx\n  TreeNodeTag *v25; // r15\n  TreeNodeTag *v26; // rbx\n  TreeNodeTag *v27; // rbx\n  TreeNodeTag *v28; // r13\n  TreeNodeTag *v29; // r14\n  TreeNodeTag *v30; // r15\n  TreeNode *v31; // rbx\n  TreeNodeTag *v32; // r15\n  TreeNodeTag *v33; // r14\n  TreeNodeTag *v34; // r15\n  TreeNodeTag *v35; // r15\n\n  if ( rootNode )\n  {\n    Left = rootNode->Left;\n    if ( rootNode->Left )\n    {\n      v2 = Left->Left;\n      if ( Left->Left )\n      {\n        v3 = v2->Left;\n        if ( v2->Left )\n        {\n          v4 = v3->Left;\n          if ( v3->Left )\n          {\n            MakeEmpty(v4->Left);\n            MakeEmpty(v4->Right);\n            FreeElement(v4->Item);\n            libmin_free(v4->Name);\n            libmin_free(v4);\n          }\n          Right = v3->Right;\n          if ( Right )\n          {\n            MakeEmpty(Right->Left);\n            MakeEmpty(Right->Right);\n            FreeElement(Right->Item);\n            libmin_free(Right->Name);\n            libmin_free(Right);\n          }\n          FreeElement(v3->Item);\n          libmin_free(v3->Name);\n          libmin_free(v3);\n        }\n        v6 = v2->Right;\n        if ( v6 )\n        {\n          v7 = v6->Left;\n          if ( v6->Left )\n          {\n            MakeEmpty(v7->Left);\n            MakeEmpty(v7->Right);\n            FreeElement(v7->Item);\n            libmin_free(v7->Name);\n            libmin_free(v7);\n          }\n          v8 = v6->Right;\n          if ( v8 )\n          {\n            MakeEmpty(v8->Left);\n            MakeEmpty(v8->Right);\n            FreeElement(v8->Item);\n            libmin_free(v8->Name);\n            libmin_free(v8);\n          }\n          FreeElement(v6->Item);\n          libmin_free(v6->Name);\n          libmin_free(v6);\n        }\n        FreeElement(v2->Item);\n        libmin_free(v2->Name);\n        libmin_free(v2);\n      }\n      v9 = Left->Right;\n      if ( v9 )\n      {\n        v10 = v9->Left;\n        if ( v9->Left )\n        {\n          v11 = v10->Left;\n          if ( v10->Left )\n          {\n            MakeEmpty(v11->Left);\n            MakeEmpty(v11->Right);\n            FreeElement(v11->Item);\n            libmin_free(v11->Name);\n            libmin_free(v11);\n          }\n          v12 = v10->Right;\n          if ( v12 )\n          {\n            MakeEmpty(v12->Left);\n            MakeEmpty(v12->Right);\n            FreeElement(v12->Item);\n            libmin_free(v12->Name);\n            libmin_free(v12);\n          }\n          FreeElement(v10->Item);\n          libmin_free(v10->Name);\n          libmin_free(v10);\n        }\n        v13 = v9->Right;\n        if ( v13 )\n        {\n          v14 = v13->Left;\n          if ( v13->Left )\n          {\n            MakeEmpty(v14->Left);\n            MakeEmpty(v14->Right);\n            FreeElement(v14->Item);\n            libmin_free(v14->Name);\n            libmin_free(v14);\n          }\n          v15 = v13->Right;\n          if ( v15 )\n          {\n            MakeEmpty(v15->Left);\n            MakeEmpty(v15->Right);\n            FreeElement(v15->Item);\n            libmin_free(v15->Name);\n            libmin_free(v15);\n          }\n          FreeElement(v13->Item);\n          libmin_free(v13->Name);\n          libmin_free(v13);\n        }\n        FreeElement(v9->Item);\n        libmin_free(v9->Name);\n        libmin_free(v9);\n      }\n      FreeElement(Left->Item);\n      libmin_free(Left->Name);\n      libmin_free(Left);\n    }\n    v16 = rootNode->Right;\n    if ( v16 )\n    {\n      v17 = v16->Left;\n      if ( v16->Left )\n      {\n        v18 = v17->Left;\n        if ( v17->Left )\n        {\n          v19 = v18->Left;\n          if ( v18->Left )\n          {\n            MakeEmpty(v19->Left);\n            MakeEmpty(v19->Right);\n            FreeElement(v19->Item);\n            libmin_free(v19->Name);\n            libmin_free(v19);\n          }\n          v20 = v18->Right;\n          if ( v20 )\n          {\n            MakeEmpty(v20->Left);\n            MakeEmpty(v20->Right);\n            FreeElement(v20->Item);\n            libmin_free(v20->Name);\n            libmin_free(v20);\n          }\n          FreeElement(v18->Item);\n          libmin_free(v18->Name);\n          libmin_free(v18);\n        }\n        v21 = v17->Right;\n        if ( v21 )\n        {\n          v22 = v21->Left;\n          if ( v21->Left )\n          {\n            v23 = v22->Left;\n            if ( v22->Left )\n            {\n              MakeEmpty(v23->Left);\n              MakeEmpty(v23->Right);\n              FreeElement(v23->Item);\n              libmin_free(v23->Name);\n              libmin_free(v23);\n            }\n            v24 = v22->Right;\n            if ( v24 )\n            {\n              MakeEmpty(v24->Left);\n              MakeEmpty(v24->Right);\n              FreeElement(v24->Item);\n              libmin_free(v24->Name);\n              libmin_free(v24);\n            }\n            FreeElement(v22->Item);\n            libmin_free(v22->Name);\n            libmin_free(v22);\n          }\n          v25 = v21->Right;\n          if ( v25 )\n          {\n            v26 = v25->Left;\n            if ( v25->Left )\n            {\n              MakeEmpty(v26->Left);\n              MakeEmpty(v26->Right);\n              FreeElement(v26->Item);\n              libmin_free(v26->Name);\n              libmin_free(v26);\n            }\n            v27 = v25->Right;\n            if ( v27 )\n            {\n              MakeEmpty(v27->Left);\n              MakeEmpty(v27->Right);\n              FreeElement(v27->Item);\n              libmin_free(v27->Name);\n              libmin_free(v27);\n            }\n            FreeElement(v25->Item);\n            libmin_free(v25->Name);\n            libmin_free(v25);\n          }\n          FreeElement(v21->Item);\n          libmin_free(v21->Name);\n          libmin_free(v21);\n        }\n        FreeElement(v17->Item);\n        libmin_free(v17->Name);\n        libmin_free(v17);\n      }\n      v28 = v16->Right;\n      if ( v28 )\n      {\n        v29 = v28->Left;\n        if ( v28->Left )\n        {\n          v30 = v29->Left;\n          if ( v29->Left )\n          {\n            v31 = v30->Left;\n            if ( v30->Left )\n            {\n              MakeEmpty(v31->Left);\n              MakeEmpty(v31->Right);\n              FreeElement(v31->Item);\n              libmin_free(v31->Name);\n              libmin_free(v31);\n            }\n            MakeEmpty(v30->Right);\n            FreeElement(v30->Item);\n            libmin_free(v30->Name);\n            libmin_free(v30);\n          }\n          v32 = v29->Right;\n          if ( v32 )\n          {\n            MakeEmpty(v32->Left);\n            MakeEmpty(v32->Right);\n            FreeElement(v32->Item);\n            libmin_free(v32->Name);\n            libmin_free(v32);\n          }\n          FreeElement(v29->Item);\n          libmin_free(v29->Name);\n          libmin_free(v29);\n        }\n        v33 = v28->Right;\n        if ( v33 )\n        {\n          v34 = v33->Left;\n          if ( v33->Left )\n          {\n            MakeEmpty(v34->Left);\n            MakeEmpty(v34->Right);\n            FreeElement(v34->Item);\n            libmin_free(v34->Name);\n            libmin_free(v34);\n          }\n          v35 = v33->Right;\n          if ( v35 )\n          {\n            MakeEmpty(v35->Left);\n            MakeEmpty(v35->Right);\n            FreeElement(v35->Item);\n            libmin_free(v35->Name);\n            libmin_free(v35);\n          }\n          FreeElement(v33->Item);\n          libmin_free(v33->Name);\n          libmin_free(v33);\n        }\n        FreeElement(v28->Item);\n        libmin_free(v28->Name);\n        libmin_free(v28);\n      }\n      FreeElement(v16->Item);\n      libmin_free(v16->Name);\n      libmin_free(v16);\n    }\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}\n"}, "pseudo_normalize": "void MakeEmpty(TreeNode *rootNode) {\n  TreeNodeTag *Left;\n  TreeNodeTag *v2;\n  TreeNodeTag *v3;\n  TreeNodeTag *v4;\n  TreeNodeTag *Right;\n  TreeNodeTag *v6;\n  TreeNodeTag *v7;\n  TreeNodeTag *v8;\n  TreeNodeTag *v9;\n  TreeNodeTag *v10;\n  TreeNodeTag *v11;\n  TreeNodeTag *v12;\n  TreeNodeTag *v13;\n  TreeNodeTag *v14;\n  TreeNodeTag *v15;\n  TreeNodeTag *v16;\n  TreeNodeTag *v17;\n  TreeNodeTag *v18;\n  TreeNodeTag *v19;\n  TreeNodeTag *v20;\n  TreeNodeTag *v21;\n  TreeNodeTag *v22;\n  TreeNodeTag *v23;\n  TreeNodeTag *v24;\n  TreeNodeTag *v25;\n  TreeNodeTag *v26;\n  TreeNodeTag *v27;\n  TreeNodeTag *v28;\n  TreeNodeTag *v29;\n  TreeNodeTag *v30;\n  TreeNode *v31;\n  TreeNodeTag *v32;\n  TreeNodeTag *v33;\n  TreeNodeTag *v34;\n  TreeNodeTag *v35;\n  if (rootNode) {\n    Left = rootNode->Left;\n    if (rootNode->Left) {\n      v2 = Left->Left;\n      if (Left->Left) {\n        v3 = v2->Left;\n        if (v2->Left) {\n          v4 = v3->Left;\n          if (v3->Left) {\n            MakeEmpty(v4->Left);\n            MakeEmpty(v4->Right);\n            FreeElement(v4->Item);\n            libmin_free(v4->Name);\n            libmin_free(v4);\n          }\n          Right = v3->Right;\n          if (Right) {\n            MakeEmpty(Right->Left);\n            MakeEmpty(Right->Right);\n            FreeElement(Right->Item);\n            libmin_free(Right->Name);\n            libmin_free(Right);\n          }\n          FreeElement(v3->Item);\n          libmin_free(v3->Name);\n          libmin_free(v3);\n        }\n        v6 = v2->Right;\n        if (v6) {\n          v7 = v6->Left;\n          if (v6->Left) {\n            MakeEmpty(v7->Left);\n            MakeEmpty(v7->Right);\n            FreeElement(v7->Item);\n            libmin_free(v7->Name);\n            libmin_free(v7);\n          }\n          v8 = v6->Right;\n          if (v8) {\n            MakeEmpty(v8->Left);\n            MakeEmpty(v8->Right);\n            FreeElement(v8->Item);\n            libmin_free(v8->Name);\n            libmin_free(v8);\n          }\n          FreeElement(v6->Item);\n          libmin_free(v6->Name);\n          libmin_free(v6);\n        }\n        FreeElement(v2->Item);\n        libmin_free(v2->Name);\n        libmin_free(v2);\n      }\n      v9 = Left->Right;\n      if (v9) {\n        v10 = v9->Left;\n        if (v9->Left) {\n          v11 = v10->Left;\n          if (v10->Left) {\n            MakeEmpty(v11->Left);\n            MakeEmpty(v11->Right);\n            FreeElement(v11->Item);\n            libmin_free(v11->Name);\n            libmin_free(v11);\n          }\n          v12 = v10->Right;\n          if (v12) {\n            MakeEmpty(v12->Left);\n            MakeEmpty(v12->Right);\n            FreeElement(v12->Item);\n            libmin_free(v12->Name);\n            libmin_free(v12);\n          }\n          FreeElement(v10->Item);\n          libmin_free(v10->Name);\n          libmin_free(v10);\n        }\n        v13 = v9->Right;\n        if (v13) {\n          v14 = v13->Left;\n          if (v13->Left) {\n            MakeEmpty(v14->Left);\n            MakeEmpty(v14->Right);\n            FreeElement(v14->Item);\n            libmin_free(v14->Name);\n            libmin_free(v14);\n          }\n          v15 = v13->Right;\n          if (v15) {\n            MakeEmpty(v15->Left);\n            MakeEmpty(v15->Right);\n            FreeElement(v15->Item);\n            libmin_free(v15->Name);\n            libmin_free(v15);\n          }\n          FreeElement(v13->Item);\n          libmin_free(v13->Name);\n          libmin_free(v13);\n        }\n        FreeElement(v9->Item);\n        libmin_free(v9->Name);\n        libmin_free(v9);\n      }\n      FreeElement(Left->Item);\n      libmin_free(Left->Name);\n      libmin_free(Left);\n    }\n    v16 = rootNode->Right;\n    if (v16) {\n      v17 = v16->Left;\n      if (v16->Left) {\n        v18 = v17->Left;\n        if (v17->Left) {\n          v19 = v18->Left;\n          if (v18->Left) {\n            MakeEmpty(v19->Left);\n            MakeEmpty(v19->Right);\n            FreeElement(v19->Item);\n            libmin_free(v19->Name);\n            libmin_free(v19);\n          }\n          v20 = v18->Right;\n          if (v20) {\n            MakeEmpty(v20->Left);\n            MakeEmpty(v20->Right);\n            FreeElement(v20->Item);\n            libmin_free(v20->Name);\n            libmin_free(v20);\n          }\n          FreeElement(v18->Item);\n          libmin_free(v18->Name);\n          libmin_free(v18);\n        }\n        v21 = v17->Right;\n        if (v21) {\n          v22 = v21->Left;\n          if (v21->Left) {\n            v23 = v22->Left;\n            if (v22->Left) {\n              MakeEmpty(v23->Left);\n              MakeEmpty(v23->Right);\n              FreeElement(v23->Item);\n              libmin_free(v23->Name);\n              libmin_free(v23);\n            }\n            v24 = v22->Right;\n            if (v24) {\n              MakeEmpty(v24->Left);\n              MakeEmpty(v24->Right);\n              FreeElement(v24->Item);\n              libmin_free(v24->Name);\n              libmin_free(v24);\n            }\n            FreeElement(v22->Item);\n            libmin_free(v22->Name);\n            libmin_free(v22);\n          }\n          v25 = v21->Right;\n          if (v25) {\n            v26 = v25->Left;\n            if (v25->Left) {\n              MakeEmpty(v26->Left);\n              MakeEmpty(v26->Right);\n              FreeElement(v26->Item);\n              libmin_free(v26->Name);\n              libmin_free(v26);\n            }\n            v27 = v25->Right;\n            if (v27) {\n              MakeEmpty(v27->Left);\n              MakeEmpty(v27->Right);\n              FreeElement(v27->Item);\n              libmin_free(v27->Name);\n              libmin_free(v27);\n            }\n            FreeElement(v25->Item);\n            libmin_free(v25->Name);\n            libmin_free(v25);\n          }\n          FreeElement(v21->Item);\n          libmin_free(v21->Name);\n          libmin_free(v21);\n        }\n        FreeElement(v17->Item);\n        libmin_free(v17->Name);\n        libmin_free(v17);\n      }\n      v28 = v16->Right;\n      if (v28) {\n        v29 = v28->Left;\n        if (v28->Left) {\n          v30 = v29->Left;\n          if (v29->Left) {\n            v31 = v30->Left;\n            if (v30->Left) {\n              MakeEmpty(v31->Left);\n              MakeEmpty(v31->Right);\n              FreeElement(v31->Item);\n              libmin_free(v31->Name);\n              libmin_free(v31);\n            }\n            MakeEmpty(v30->Right);\n            FreeElement(v30->Item);\n            libmin_free(v30->Name);\n            libmin_free(v30);\n          }\n          v32 = v29->Right;\n          if (v32) {\n            MakeEmpty(v32->Left);\n            MakeEmpty(v32->Right);\n            FreeElement(v32->Item);\n            libmin_free(v32->Name);\n            libmin_free(v32);\n          }\n          FreeElement(v29->Item);\n          libmin_free(v29->Name);\n          libmin_free(v29);\n        }\n        v33 = v28->Right;\n        if (v33) {\n          v34 = v33->Left;\n          if (v33->Left) {\n            MakeEmpty(v34->Left);\n            MakeEmpty(v34->Right);\n            FreeElement(v34->Item);\n            libmin_free(v34->Name);\n            libmin_free(v34);\n          }\n          v35 = v33->Right;\n          if (v35) {\n            MakeEmpty(v35->Left);\n            MakeEmpty(v35->Right);\n            FreeElement(v35->Item);\n            libmin_free(v35->Name);\n            libmin_free(v35);\n          }\n          FreeElement(v33->Item);\n          libmin_free(v33->Name);\n          libmin_free(v33);\n        }\n        FreeElement(v28->Item);\n        libmin_free(v28->Name);\n        libmin_free(v28);\n      }\n      FreeElement(v16->Item);\n      libmin_free(v16->Name);\n      libmin_free(v16);\n    }\n    FreeElement(rootNode->Item);\n    libmin_free(rootNode->Name);\n    libmin_free(rootNode);\n  }\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<MakeEmpty>:\nendbr64\ntest   %rdi,%rdi\nje     2608 <MakeEmpty+0x688>\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    (%rdi),%r12\ntest   %r12,%r12\nje     224d <MakeEmpty+0x2cd>\nmov    (%r12),%r13\ntest   %r13,%r13\nje     20ed <MakeEmpty+0x16d>\nmov    0x0(%r13),%r14\ntest   %r14,%r14\nje     2045 <MakeEmpty+0xc5>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     1ff7 <MakeEmpty+0x77>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     202b <MakeEmpty+0xab>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3410 <libmin_free>\nmov    %r14,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r13),%r14\ntest   %r14,%r14\nje     20d3 <MakeEmpty+0x153>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     2085 <MakeEmpty+0x105>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     20b9 <MakeEmpty+0x139>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3410 <libmin_free>\nmov    %r14,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r13),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r13),%rdi\ncall   3410 <libmin_free>\nmov    %r13,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r12),%r13\ntest   %r13,%r13\nje     2231 <MakeEmpty+0x2b1>\nmov    0x0(%r13),%r14\ntest   %r14,%r14\nje     2189 <MakeEmpty+0x209>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     213b <MakeEmpty+0x1bb>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     216f <MakeEmpty+0x1ef>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3410 <libmin_free>\nmov    %r14,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r13),%r14\ntest   %r14,%r14\nje     2217 <MakeEmpty+0x297>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     21c9 <MakeEmpty+0x249>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     21fd <MakeEmpty+0x27d>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3410 <libmin_free>\nmov    %r14,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r13),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r13),%rdi\ncall   3410 <libmin_free>\nmov    %r13,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r12),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r12),%rdi\ncall   3410 <libmin_free>\nmov    %r12,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%rbp),%r12\ntest   %r12,%r12\nje     25dc <MakeEmpty+0x65c>\nmov    (%r12),%r13\ntest   %r13,%r13\nje     2451 <MakeEmpty+0x4d1>\nmov    0x0(%r13),%r14\ntest   %r14,%r14\nje     22f5 <MakeEmpty+0x375>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     22a7 <MakeEmpty+0x327>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     22db <MakeEmpty+0x35b>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3410 <libmin_free>\nmov    %r14,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r13),%r14\ntest   %r14,%r14\nje     2437 <MakeEmpty+0x4b7>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     238f <MakeEmpty+0x40f>\nmov    (%r15),%rbx\ntest   %rbx,%rbx\nje     2341 <MakeEmpty+0x3c1>\nmov    (%rbx),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%rbx),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%rbx),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%rbx),%rdi\ncall   3410 <libmin_free>\nmov    %rbx,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r15),%rbx\ntest   %rbx,%rbx\nje     2375 <MakeEmpty+0x3f5>\nmov    (%rbx),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%rbx),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%rbx),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%rbx),%rdi\ncall   3410 <libmin_free>\nmov    %rbx,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     241d <MakeEmpty+0x49d>\nmov    (%r15),%rbx\ntest   %rbx,%rbx\nje     23cf <MakeEmpty+0x44f>\nmov    (%rbx),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%rbx),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%rbx),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%rbx),%rdi\ncall   3410 <libmin_free>\nmov    %rbx,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r15),%rbx\ntest   %rbx,%rbx\nje     2403 <MakeEmpty+0x483>\nmov    (%rbx),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%rbx),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%rbx),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%rbx),%rdi\ncall   3410 <libmin_free>\nmov    %rbx,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3410 <libmin_free>\nmov    %r14,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r13),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r13),%rdi\ncall   3410 <libmin_free>\nmov    %r13,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r12),%r13\ntest   %r13,%r13\nje     25c0 <MakeEmpty+0x640>\nmov    0x0(%r13),%r14\ntest   %r14,%r14\nje     2518 <MakeEmpty+0x598>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     24ca <MakeEmpty+0x54a>\nmov    (%r15),%rbx\ntest   %rbx,%rbx\nje     24a7 <MakeEmpty+0x527>\nmov    (%rbx),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%rbx),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%rbx),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%rbx),%rdi\ncall   3410 <libmin_free>\nmov    %rbx,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     24fe <MakeEmpty+0x57e>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3410 <libmin_free>\nmov    %r14,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r13),%r14\ntest   %r14,%r14\nje     25a6 <MakeEmpty+0x626>\nmov    (%r14),%r15\ntest   %r15,%r15\nje     2558 <MakeEmpty+0x5d8>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x8(%r14),%r15\ntest   %r15,%r15\nje     258c <MakeEmpty+0x60c>\nmov    (%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x8(%r15),%rdi\ncall   1f80 <MakeEmpty>\nmov    0x10(%r15),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r15),%rdi\ncall   3410 <libmin_free>\nmov    %r15,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r14),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r14),%rdi\ncall   3410 <libmin_free>\nmov    %r14,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r13),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r13),%rdi\ncall   3410 <libmin_free>\nmov    %r13,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%r12),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%r12),%rdi\ncall   3410 <libmin_free>\nmov    %r12,%rdi\ncall   3410 <libmin_free>\nmov    0x10(%rbp),%rdi\ncall   1af0 <FreeElement>\nmov    0x18(%rbp),%rdi\ncall   3410 <libmin_free>\nadd    $0x8,%rsp\nmov    %rbp,%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    3410 <libmin_free>\nnopl   0x0(%rax)\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "SingleLeftRotation", "content": "TreeNode *SingleLeftRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = NULL;\n    newRoot = rootNode->Right;\n    rootNode->Right = newRoot->Left;\n    newRoot->Left = rootNode;\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "SingleLeftRotation", "address": "0x1bb0", "label": "SingleLeftRotation", "content": "TreeNode *__fastcall SingleLeftRotation(TreeNode *rootNode)\n{\n  TreeNode *result; // rax\n\n  result = rootNode->Right;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *SingleLeftRotation(TreeNode *rootNode) {\n  TreeNode *result;\n  result = rootNode->Right;\n  rootNode->Right = result->Left;\n  result->Left = rootNode;\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<SingleLeftRotation>:\nendbr64\nmov    0x8(%rdi),%rax\nmov    (%rax),%rdx\nmov    %rdx,0x8(%rdi)\nmov    %rdi,(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "avl-tree/avlcore.c", "function_name": "SingleRightRotation", "content": "TreeNode *SingleRightRotation(TreeNode *rootNode)\n{\n    TreeNode *newRoot = NULL;\n    newRoot = rootNode->Left;\n    rootNode->Left = newRoot->Right;\n    newRoot->Right = rootNode;\n    return newRoot;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "SingleRightRotation", "address": "0x1b90", "label": "SingleRightRotation", "content": "TreeNode *__fastcall SingleRightRotation(TreeNode *rootNode)\n{\n  TreeNode *result; // rax\n\n  result = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  result->Right = rootNode;\n  return result;\n}\n"}, "pseudo_normalize": "TreeNode *SingleRightRotation(TreeNode *rootNode) {\n  TreeNode *result;\n  result = rootNode->Left;\n  rootNode->Left = rootNode->Left->Right;\n  result->Right = rootNode;\n  return result;\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<SingleRightRotation>:\nendbr64\nmov    (%rdi),%rax\nmov    0x8(%rax),%rdx\nmov    %rdx,(%rdi)\nmov    %rdi,0x8(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "avl-tree/avl-tree.c", "function_name": "breadth", "content": "long breadth(TreeNode *start)\n{\n    if(start == NULL)\n        return (long)0;\n    if(start->Left == NULL && start->Right == NULL)\n        return (long)1;\n    return (long)(breadth(start->Left) + breadth(start->Right));\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "breadth", "address": "0x1760", "label": "breadth", "content": "__int64 __fastcall breadth(TreeNode *start)\n{\n  TreeNode *v1; // rcx\n  TreeNodeTag *Left; // r15\n  TreeNodeTag *v3; // r15\n  TreeNodeTag *v4; // rbx\n  __int64 v5; // r15\n  TreeNodeTag *v6; // rbp\n  __int64 v7; // rbx\n  TreeNodeTag *Right; // r12\n  __int64 v9; // rbp\n  TreeNodeTag *v10; // r13\n  __int64 v11; // r12\n  __int64 *v12; // rbx\n  __int64 v13; // rbp\n  __int64 v14; // r14\n  __int64 v15; // r15\n  __int64 v16; // rax\n  __int64 v17; // r15\n  __int64 v18; // r15\n  __int64 v19; // rcx\n  __int64 v22; // rax\n  __int64 v23; // [rsp+0h] [rbp-98h]\n  __int64 v24; // [rsp+8h] [rbp-90h]\n  __int64 v25; // [rsp+10h] [rbp-88h]\n  TreeNode *v26; // [rsp+18h] [rbp-80h]\n  TreeNodeTag *v27; // [rsp+20h] [rbp-78h]\n  TreeNodeTag *v28; // [rsp+28h] [rbp-70h]\n  TreeNodeTag *v29; // [rsp+30h] [rbp-68h]\n  __int64 v30; // [rsp+38h] [rbp-60h]\n  __int64 v31; // [rsp+40h] [rbp-58h]\n  TreeNodeTag *v32; // [rsp+48h] [rbp-50h]\n  TreeNodeTag *v33; // [rsp+50h] [rbp-48h]\n  __int64 v34; // [rsp+58h] [rbp-40h]\n\n  if ( !start )\n    return 0LL;\n  v1 = start;\n  v24 = 0LL;\n  do\n  {\nLABEL_3:\n    while ( 1 )\n    {\n      v23 = 0LL;\n      if ( !v1->Left )\n        break;\n      v26 = v1;\n      Left = v1->Left;\n      do\n      {\nLABEL_5:\n        while ( 2 )\n        {\n          if ( Left->Left )\n          {\n            v25 = 0LL;\n            v27 = Left;\n            v3 = Left->Left;\n            do\n            {\n              while ( 1 )\n              {\n                v4 = v3->Left;\n                if ( !v3->Left )\n                  break;\n                v28 = v3;\n                v5 = 0LL;\n                do\n                {\n                  while ( 1 )\n                  {\n                    v6 = v4->Left;\n                    if ( !v4->Left )\n                      break;\n                    v30 = v5;\n                    v29 = v4;\n                    v7 = 0LL;\n                    do\n                    {\n                      while ( 1 )\n                      {\n                        Right = v6->Left;\n                        if ( !v6->Left )\n                          break;\n                        v31 = v7;\n                        v32 = v6;\n                        v9 = 0LL;\n                        do\n                        {\n                          while ( 1 )\n                          {\n                            v10 = Right->Left;\n                            if ( !Right->Left )\n                              break;\n                            v34 = v9;\n                            v33 = Right;\n                            v11 = 0LL;\n                            do\n                            {\n                              while ( 1 )\n                              {\n                                v12 = (__int64 *)v10->Left;\n                                v13 = 0LL;\n                                if ( !v10->Left )\n                                  break;\n                                do\n                                {\n                                  while ( 1 )\n                                  {\n                                    v14 = *v12;\n                                    v15 = 0LL;\n                                    if ( !*v12 )\n                                      break;\n                                    while ( 1 )\n                                    {\n                                      while ( *(_QWORD *)v14 )\n                                      {\n                                        v16 = breadth(*(TreeNode **)v14);\n                                        v14 = *(_QWORD *)(v14 + 8);\n                                        v15 += v16;\n                                        if ( !v14 )\n                                        {\n                                          v12 = (__int64 *)v12[1];\n                                          v13 += v15;\n                                          goto LABEL_20;\n                                        }\n                                      }\n                                      v14 = *(_QWORD *)(v14 + 8);\n                                      if ( !v14 )\n                                        break;\n                                      v15 += breadth(0LL);\n                                    }\n                                    v12 = (__int64 *)v12[1];\n                                    v13 += v15 + 1;\nLABEL_20:\n                                    if ( !v12 )\n                                    {\n                                      v10 = v10->Right;\n                                      v11 += v13;\n                                      goto LABEL_22;\n                                    }\n                                  }\n                                  v12 = (__int64 *)v12[1];\n                                }\n                                while ( v12 );\n                                v10 = v10->Right;\n                                v11 += v13 + 1;\nLABEL_22:\n                                if ( !v10 )\n                                {\n                                  v17 = v11;\n                                  Right = v33->Right;\n                                  v9 = v17 + v34;\n                                  goto LABEL_24;\n                                }\n                              }\n                              v10 = v10->Right;\n                            }\n                            while ( v10 );\n                            v9 = v34 + v11 + 1;\n                            Right = v33->Right;\nLABEL_24:\n                            if ( !Right )\n                            {\n                              v18 = v9;\n                              v6 = v32->Right;\n                              v7 = v18 + v31;\n                              goto LABEL_26;\n                            }\n                          }\n                          Right = Right->Right;\n                        }\n                        while ( Right );\n                        v7 = v9 + v31 + 1;\n                        v6 = v32->Right;\nLABEL_26:\n                        if ( !v6 )\n                        {\n                          v19 = v7;\n                          v4 = v29->Right;\n                          v5 = v19 + v30;\n                          goto LABEL_28;\n                        }\n                      }\n                      v6 = v6->Right;\n                    }\n                    while ( v6 );\n                    v5 = v30 + v7 + 1;\n                    v4 = v29->Right;\nLABEL_28:\n                    if ( !v4 )\n                    {\n                      v25 += v5;\n                      v3 = v28->Right;\n                      goto LABEL_30;\n                    }\n                  }\n                  v4 = v4->Right;\n                }\n                while ( v4 );\n                v22 = v5 + v25 + 1;\n                v3 = v28->Right;\n                v25 = v22;\nLABEL_30:\n                if ( !v3 )\n                {\n                  v23 += v25;\n                  Left = v27->Right;\n                  if ( Left )\n                    goto LABEL_5;\n                  goto LABEL_32;\n                }\n              }\n              v3 = v3->Right;\n            }\n            while ( v3 );\n            Left = v27->Right;\n            v23 += v25 + 1;\n            if ( Left )\n              continue;\nLABEL_32:\n            v24 += v23;\n            v1 = v26->Right;\n            if ( v1 )\n              goto LABEL_3;\n            return v24;\n          }\n          break;\n        }\n        Left = Left->Right;\n      }\n      while ( Left );\n      v1 = v26->Right;\n      v24 += v23 + 1;\n      if ( !v1 )\n        return v24;\n    }\n    v1 = v1->Right;\n  }\n  while ( v1 );\n  return v24 + 1;\n}\n"}, "pseudo_normalize": "long long breadth(TreeNode *start) {\n  TreeNode *v1;\n  TreeNodeTag *Left;\n  TreeNodeTag *v3;\n  TreeNodeTag *v4;\n  long long v5;\n  TreeNodeTag *v6;\n  long long v7;\n  TreeNodeTag *Right;\n  long long v9;\n  TreeNodeTag *v10;\n  long long v11;\n  long long *v12;\n  long long v13;\n  long long v14;\n  long long v15;\n  long long v16;\n  long long v17;\n  long long v18;\n  long long v19;\n  long long v22;\n  long long v23;\n  long long v24;\n  long long v25;\n  TreeNode *v26;\n  TreeNodeTag *v27;\n  TreeNodeTag *v28;\n  TreeNodeTag *v29;\n  long long v30;\n  long long v31;\n  TreeNodeTag *v32;\n  TreeNodeTag *v33;\n  long long v34;\n  if (!start) return 0LL;\n  v1 = start;\n  v24 = 0LL;\n  do {\n  LABEL_3:\n    while (1) {\n      v23 = 0LL;\n      if (!v1->Left) break;\n      v26 = v1;\n      Left = v1->Left;\n      do {\n      LABEL_5:\n        while (2) {\n          if (Left->Left) {\n            v25 = 0LL;\n            v27 = Left;\n            v3 = Left->Left;\n            do {\n              while (1) {\n                v4 = v3->Left;\n                if (!v3->Left) break;\n                v28 = v3;\n                v5 = 0LL;\n                do {\n                  while (1) {\n                    v6 = v4->Left;\n                    if (!v4->Left) break;\n                    v30 = v5;\n                    v29 = v4;\n                    v7 = 0LL;\n                    do {\n                      while (1) {\n                        Right = v6->Left;\n                        if (!v6->Left) break;\n                        v31 = v7;\n                        v32 = v6;\n                        v9 = 0LL;\n                        do {\n                          while (1) {\n                            v10 = Right->Left;\n                            if (!Right->Left) break;\n                            v34 = v9;\n                            v33 = Right;\n                            v11 = 0LL;\n                            do {\n                              while (1) {\n                                v12 = (long long *)v10->Left;\n                                v13 = 0LL;\n                                if (!v10->Left) break;\n                                do {\n                                  while (1) {\n                                    v14 = *v12;\n                                    v15 = 0LL;\n                                    if (!*v12) break;\n                                    while (1) {\n                                      while (*(uint64_t *)v14) {\n                                        v16 = breadth(*(TreeNode **)v14);\n                                        v14 = *(uint64_t *)(v14 + 8);\n                                        v15 += v16;\n                                        if (!v14) {\n                                          v12 = (long long *)v12[1];\n                                          v13 += v15;\n                                          goto LABEL_20;\n                                        }\n                                      }\n                                      v14 = *(uint64_t *)(v14 + 8);\n                                      if (!v14) break;\n                                      v15 += breadth(0LL);\n                                    }\n                                    v12 = (long long *)v12[1];\n                                    v13 += v15 + 1;\n                                  LABEL_20:\n                                    if (!v12) {\n                                      v10 = v10->Right;\n                                      v11 += v13;\n                                      goto LABEL_22;\n                                    }\n                                  }\n                                  v12 = (long long *)v12[1];\n                                } while (v12);\n                                v10 = v10->Right;\n                                v11 += v13 + 1;\n                              LABEL_22:\n                                if (!v10) {\n                                  v17 = v11;\n                                  Right = v33->Right;\n                                  v9 = v17 + v34;\n                                  goto LABEL_24;\n                                }\n                              }\n                              v10 = v10->Right;\n                            } while (v10);\n                            v9 = v34 + v11 + 1;\n                            Right = v33->Right;\n                          LABEL_24:\n                            if (!Right) {\n                              v18 = v9;\n                              v6 = v32->Right;\n                              v7 = v18 + v31;\n                              goto LABEL_26;\n                            }\n                          }\n                          Right = Right->Right;\n                        } while (Right);\n                        v7 = v9 + v31 + 1;\n                        v6 = v32->Right;\n                      LABEL_26:\n                        if (!v6) {\n                          v19 = v7;\n                          v4 = v29->Right;\n                          v5 = v19 + v30;\n                          goto LABEL_28;\n                        }\n                      }\n                      v6 = v6->Right;\n                    } while (v6);\n                    v5 = v30 + v7 + 1;\n                    v4 = v29->Right;\n                  LABEL_28:\n                    if (!v4) {\n                      v25 += v5;\n                      v3 = v28->Right;\n                      goto LABEL_30;\n                    }\n                  }\n                  v4 = v4->Right;\n                } while (v4);\n                v22 = v5 + v25 + 1;\n                v3 = v28->Right;\n                v25 = v22;\n              LABEL_30:\n                if (!v3) {\n                  v23 += v25;\n                  Left = v27->Right;\n                  if (Left) goto LABEL_5;\n                  goto LABEL_32;\n                }\n              }\n              v3 = v3->Right;\n            } while (v3);\n            Left = v27->Right;\n            v23 += v25 + 1;\n            if (Left) continue;\n          LABEL_32:\n            v24 += v23;\n            v1 = v26->Right;\n            if (v1) goto LABEL_3;\n            return v24;\n          }\n          break;\n        }\n        Left = Left->Right;\n      } while (Left);\n      v1 = v26->Right;\n      v24 += v23 + 1;\n      if (!v1) return v24;\n    }\n    v1 = v1->Right;\n  } while (v1);\n  return v24 + 1;\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<breadth>:\nendbr64\ntest   %rdi,%rdi\nje     1ac6 <breadth+0x366>\npush   %r15\nxor    %r8d,%r8d\nmov    %rdi,%rcx\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x68,%rsp\nmov    %r8,0x8(%rsp)\nmov    (%rcx),%rsi\nmovq   $0x0,(%rsp)\ntest   %rsi,%rsi\nje     1aab <breadth+0x34b>\nmov    %rcx,0x18(%rsp)\nmov    %rsi,%r15\nmov    (%r15),%rcx\nxor    %r11d,%r11d\ntest   %rcx,%rcx\nje     1a74 <breadth+0x314>\nmov    %r11,0x10(%rsp)\nmov    %r15,0x20(%rsp)\nmov    %rcx,%r15\nmov    (%r15),%rbx\nxor    %r11d,%r11d\ntest   %rbx,%rbx\nje     1a3e <breadth+0x2de>\nmov    %r15,0x28(%rsp)\nmov    %r11,%r15\nmov    (%rbx),%rbp\nxor    %ecx,%ecx\ntest   %rbp,%rbp\nje     1944 <breadth+0x1e4>\nmov    %r15,0x38(%rsp)\nmov    %rbx,0x30(%rsp)\nmov    %rcx,%rbx\nmov    0x0(%rbp),%r12\nxor    %r15d,%r15d\ntest   %r12,%r12\nje     19d4 <breadth+0x274>\nmov    %rbx,0x40(%rsp)\nmov    %rbp,0x48(%rsp)\nmov    %r15,%rbp\nmov    (%r12),%r13\nxor    %r15d,%r15d\ntest   %r13,%r13\nje     19ab <breadth+0x24b>\nmov    %rbp,0x58(%rsp)\nmov    %r12,0x50(%rsp)\nmov    %r15,%r12\nnopw   0x0(%rax,%rax,1)\nmov    0x0(%r13),%rbx\nxor    %ebp,%ebp\ntest   %rbx,%rbx\nje     1a00 <breadth+0x2a0>\nnop\nmov    (%rbx),%r14\nxor    %r15d,%r15d\ntest   %r14,%r14\nje     1990 <breadth+0x230>\nnop\nmov    (%r14),%rdi\ntest   %rdi,%rdi\nje     1970 <breadth+0x210>\ncall   1760 <breadth>\nmov    0x8(%r14),%r14\nadd    %rax,%r15\ntest   %r14,%r14\njne    1850 <breadth+0xf0>\nmov    0x8(%rbx),%rbx\nadd    %r15,%rbp\ntest   %rbx,%rbx\njne    1840 <breadth+0xe0>\nmov    0x8(%r13),%r13\nadd    %rbp,%r12\ntest   %r13,%r13\njne    1830 <breadth+0xd0>\nmov    %r12,%r15\nmov    0x50(%rsp),%r12\nmov    0x58(%rsp),%rbp\nmov    0x8(%r12),%r12\nadd    %r15,%rbp\ntest   %r12,%r12\njne    180d <breadth+0xad>\nmov    %rbp,%r15\nmov    0x48(%rsp),%rbp\nmov    0x40(%rsp),%rbx\nmov    0x8(%rbp),%rbp\nadd    %r15,%rbx\ntest   %rbp,%rbp\njne    17f0 <breadth+0x90>\nmov    %rbx,%rcx\nmov    0x30(%rsp),%rbx\nmov    0x38(%rsp),%r15\nmov    0x8(%rbx),%rbx\nadd    %rcx,%r15\ntest   %rbx,%rbx\njne    17d5 <breadth+0x75>\nmov    %r15,%r11\nmov    0x28(%rsp),%r15\nadd    %r11,0x10(%rsp)\nmov    0x8(%r15),%r15\ntest   %r15,%r15\njne    17be <breadth+0x5e>\nmov    0x20(%rsp),%r15\nmov    0x10(%rsp),%r11\nadd    %r11,(%rsp)\nmov    0x8(%r15),%r15\ntest   %r15,%r15\njne    17a2 <breadth+0x42>\nmov    0x18(%rsp),%rcx\nmov    (%rsp),%rdx\nadd    %rdx,0x8(%rsp)\nmov    0x8(%rcx),%rcx\ntest   %rcx,%rcx\njne    1786 <breadth+0x26>\nmov    0x8(%rsp),%r8\nadd    $0x68,%rsp\nmov    %r8,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\njne    17d5 <breadth+0x75>\nmov    0x10(%rsp),%rax\nmov    %r15,%r11\nmov    0x28(%rsp),%r15\nlea    0x1(%r11,%rax,1),%rax\nmov    0x8(%r15),%r15\nmov    %rax,0x10(%rsp)\njmp    18ee <breadth+0x18e>\nxchg   %ax,%ax\nmov    0x8(%r14),%r14\ntest   %r14,%r14\nje     1a30 <breadth+0x2d0>\nxor    %edi,%edi\ncall   1760 <breadth>\nadd    %rax,%r15\njmp    1850 <breadth+0xf0>\nnopl   0x0(%rax)\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\njne    1840 <breadth+0xe0>\nmov    0x8(%r13),%r13\nlea    0x1(%rbp,%r12,1),%r12\njmp    1880 <breadth+0x120>\nmov    0x8(%r12),%r12\ntest   %r12,%r12\njne    180d <breadth+0xad>\nmov    %rbp,%r15\nmov    0x40(%rsp),%rbx\nmov    0x48(%rsp),%rbp\nlea    0x1(%r15,%rbx,1),%rbx\nmov    0x8(%rbp),%rbp\njmp    18b7 <breadth+0x157>\nmov    0x8(%rbp),%rbp\ntest   %rbp,%rbp\njne    17f0 <breadth+0x90>\nmov    %rbx,%rcx\nmov    0x38(%rsp),%r15\nmov    0x30(%rsp),%rbx\nlea    0x1(%r15,%rcx,1),%r15\nmov    0x8(%rbx),%rbx\njmp    18d4 <breadth+0x174>\nnopl   0x0(%rax)\nmov    0x8(%r13),%r13\ntest   %r13,%r13\njne    1830 <breadth+0xd0>\nmov    %r12,%r15\nmov    0x58(%rsp),%rbp\nmov    0x50(%rsp),%r12\nlea    0x1(%rbp,%r15,1),%rbp\nmov    0x8(%r12),%r12\njmp    189a <breadth+0x13a>\nnopl   0x0(%rax)\nmov    0x8(%rbx),%rbx\nlea    0x1(%r15,%rbp,1),%rbp\njmp    1874 <breadth+0x114>\nmov    0x8(%r15),%r15\ntest   %r15,%r15\njne    17be <breadth+0x5e>\nmov    0x20(%rsp),%r15\nmov    (%rsp),%rax\nmov    0x10(%rsp),%r11\nmov    0x8(%r15),%r15\nlea    0x1(%rax,%r11,1),%rax\nmov    %rax,(%rsp)\ntest   %r15,%r15\njne    17a2 <breadth+0x42>\njmp    1912 <breadth+0x1b2>\nmov    0x8(%r15),%r15\ntest   %r15,%r15\njne    17a2 <breadth+0x42>\nmov    0x18(%rsp),%rcx\nmov    0x8(%rsp),%rdx\nmov    (%rsp),%rax\nmov    0x8(%rcx),%rcx\nlea    0x1(%rax,%rdx,1),%rax\nmov    %rax,0x8(%rsp)\ntest   %rcx,%rcx\njne    1786 <breadth+0x26>\njmp    192d <breadth+0x1cd>\nmov    0x8(%rcx),%rcx\ntest   %rcx,%rcx\njne    1786 <breadth+0x26>\nmov    0x8(%rsp),%r8\nadd    $0x1,%r8\njmp    1932 <breadth+0x1d2>\nxor    %eax,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "avl-tree/avl-tree.c", "function_name": "main", "content": "int main(int argc, char** argv)\n{\n    TreeNode *tree = NULL, *newTree = NULL;\n    Element newItem = NULL;\n    char *itemName = NULL;\n    long i = 0, topsize = 0, tick = 0, last = 0;\n    long height = 0, oldheight = 0;\n    \n    /* get the command argument, used for a custom size parameter */\n    topsize = 25;\n    tick = topsize / 20;\n    \n    libmin_srand(42);\n    libmin_printf(\"Start  -->  Finished\\n\");\n    for(i = 0; i < topsize; i++) {\n        newItem = libmin_malloc(sizeof(Element));\n        itemName = libmin_malloc(sizeof(char) * 11);\n        libmin_snprintf(itemName, 11, \"Name%ld\", i);\n        do  {\n            *newItem = libmin_rand();\n            newTree = Insert(tree, newItem, itemName);\n            if(newTree == NULL) {\n                if(last == *newItem)    {\n                    libmin_free(itemName);\n                    libmin_free(newItem);\n                    libmin_printf(\"going to try and skip: %ld\\n\", *newItem);\n                    break;\n                } else\n                    last = *newItem;\n            }\n        } while(newTree == NULL);\n        if(i % tick == 0)   {\n            libmin_printf(\".\");\n        }\n        tree = newTree;\n    }\n    libmin_printf(\"\\n\");\n    \n    /* test out the delete functionality */\n    libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *tree->Item);\n    newTree = DeleteByElement(tree, tree->Item);\n    if(newTree == NULL)\n        libmin_printf(\"failure!\\n\");\n    else {\n        tree = newTree;\n        libmin_printf(\"success! new root is %ld\\n\", *tree->Item);\n    }\n    libmin_printf(\"\\nGoing to delete leftMost child... \");\n    for(newTree = tree;\n        newTree != NULL && newTree->Left != NULL;\n        newTree = newTree->Left)    {}\n    if(newTree != NULL) {\n        libmin_printf(\"found item: %ld\\n\", *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n    }\n    /* duplicated from left side */\n    libmin_printf(\"\\nGoing to delete rightMost child... \");\n    for(newTree = tree;\n        newTree != NULL && newTree->Right != NULL;\n        newTree = newTree->Right)   {}\n    if(newTree != NULL) {\n        libmin_printf(\"found item: %ld\\n\", *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n    }\n    libmin_printf(\"\\n\");\n\t\n    if(topsize <= 25)\n        printTree(tree, 0);\n    libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\",\n           breadth(tree->Left), breadth(tree->Right));\n    oldheight = Height(tree->Left);\n    libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\",\n           oldheight, Height(tree->Right));\n\n    last = (long)(INT_MAX / 2);\n    for(i = 0; i < 3; i++)  {\n        libmin_printf(\"\\n\");\n        height = libmin_rand() % oldheight;\n        libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\",\n                oldheight, height);\n        newTree = tree;\n        do  {\n            if(newTree->Left == NULL)   {\n                if(newTree->Right == NULL)\n                    break;\n                tick = last + 1;\n            } else if(newTree->Right == NULL)\n                tick = last - 1;\n            else\n                tick = libmin_rand();\n            newTree = (tick >= last ? newTree->Right : newTree->Left);\n            height--;\n        } while(height > 0);\n        libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                newTree->Name, *newTree->Item);\n        newTree = DeleteByElement(tree, newTree->Item);\n        if(newTree == NULL)\n            libmin_printf(\"failure!\\n\");\n        else {\n            libmin_printf(\"success! new root: %ld\\n\", *newTree->Item);\n            tree = newTree;\n        }\n        oldheight = (int)(oldheight * 0.6);\n    }\n    \n    MakeEmpty(tree);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // r14\n  __int64 v4; // r13\n  TreeNode *v5; // r12\n  int *v6; // rbx\n  char *v7; // rbp\n  TreeNode *v8; // r15\n  TreeNode *v9; // rax\n  TreeNode *v10; // rbx\n  TreeNode *v11; // rax\n  TreeNode *v12; // r12\n  TreeNode *v13; // rax\n  TreeNode *v14; // r12\n  TreeNode *v15; // rax\n  TreeNode *v16; // rbx\n  TreeNode *v17; // rax\n  TreeNode *v18; // rbp\n  __int64 v19; // rax\n  __int64 v20; // r9\n  __int64 v21; // rbx\n  __int64 v22; // rax\n  TreeNode *v23; // r12\n  __int64 v24; // r14\n  TreeNode *Left; // rax\n  TreeNode *Right; // rsi\n  TreeNode *v27; // rax\n  bool v28; // zf\n  __int64 v29; // [rsp+0h] [rbp-48h]\n  TreeNode *newTree; // [rsp+8h] [rbp-40h]\n\n  v3 = 0LL;\n  v4 = 0LL;\n  v5 = 0LL;\n  libmin_srand(0x2Au);\n  libmin_printf(\"Start  -->  Finished\\n\", argv);\n  while ( 1 )\n  {\n    v6 = (int *)libmin_malloc(8uLL);\n    v7 = (char *)libmin_malloc(0xBuLL);\n    libmin_snprintf(v7, 0xBuLL, \"Name%ld\", v3);\n    while ( 1 )\n    {\n      *v6 = libmin_rand();\n      v8 = Insert(v5, v6, v7);\n      if ( v8 )\n        goto LABEL_2;\n      if ( *v6 == v4 )\n        break;\n      v4 = *v6;\n    }\n    libmin_free(v7);\n    libmin_free(v6);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*v6);\nLABEL_2:\n    ++v3;\n    libmin_printf(\".\");\n    if ( v3 == 25 )\n      break;\n    v5 = v8;\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\", *(unsigned int *)v8->Item);\n  v9 = DeleteByElement(v8, v8->Item);\n  v10 = v9;\n  if ( v9 )\n  {\n    libmin_printf(\"success! new root is %ld\\n\", *(unsigned int *)v9->Item);\n  }\n  else\n  {\n    v10 = v8;\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf(\"\\nGoing to delete leftMost child... \");\n  v11 = v10;\n  do\n  {\n    v12 = v11;\n    v11 = v11->Left;\n  }\n  while ( v11 );\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)v12->Item);\n  v13 = DeleteByElement(v10, v12->Item);\n  v14 = v13;\n  if ( v13 )\n  {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v13->Item);\n  }\n  else\n  {\n    v14 = v10;\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf(\"\\nGoing to delete rightMost child... \");\n  v15 = v14;\n  do\n  {\n    v16 = v15;\n    v15 = v15->Right;\n  }\n  while ( v15 );\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)v16->Item);\n  v17 = DeleteByElement(v14, v16->Item);\n  v18 = v17;\n  if ( v17 )\n  {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v17->Item);\n  }\n  else\n  {\n    v18 = v14;\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf((char *)\"\\n\");\n  printTree_0(v18, 0LL);\n  breadth(v18->Right);\n  v19 = breadth(v18->Left);\n  libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v19, v20);\n  v21 = Height(v18->Left);\n  v22 = Height(v18->Right);\n  libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", v21, v22);\n  v29 = 3LL;\nLABEL_20:\n  v23 = v18;\n  libmin_printf((char *)\"\\n\");\n  v24 = libmin_rand() % v21;\n  libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\", v21, v24);\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      Left = v23->Left;\n      Right = v23->Right;\n      if ( !v23->Left )\n      {\n        if ( !Right )\n          goto LABEL_28;\n        goto LABEL_27;\n      }\n      if ( Right )\n        break;\nLABEL_24:\n      --v24;\n      v23 = Left;\n      if ( v24 <= 0 )\n        goto LABEL_28;\n    }\n    if ( libmin_rand() <= 0x3FFFFFFE )\n    {\n      Left = v23->Left;\n      goto LABEL_24;\n    }\n    Right = v23->Right;\nLABEL_27:\n    --v24;\n    v23 = Right;\n    if ( v24 <= 0 )\n    {\nLABEL_28:\n      libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\", v23->Name, *(unsigned int *)v23->Item);\n      v27 = DeleteByElement(v18, v23->Item);\n      if ( v27 )\n      {\n        newTree = v27;\n        libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v27->Item);\n        v18 = newTree;\n      }\n      else\n      {\n        libmin_printf(\"failure!\\n\");\n      }\n      v28 = v29-- == 1;\n      v21 = (int)((double)(int)v21 * 0.6);\n      if ( v28 )\n      {\n        MakeEmpty(v18);\n        libmin_success();\n      }\n      goto LABEL_20;\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  TreeNode *v5;\n  int *v6;\n  char *v7;\n  TreeNode *v8;\n  TreeNode *v9;\n  TreeNode *v10;\n  TreeNode *v11;\n  TreeNode *v12;\n  TreeNode *v13;\n  TreeNode *v14;\n  TreeNode *v15;\n  TreeNode *v16;\n  TreeNode *v17;\n  TreeNode *v18;\n  long long v19;\n  long long v20;\n  long long v21;\n  long long v22;\n  TreeNode *v23;\n  long long v24;\n  TreeNode *Left;\n  TreeNode *Right;\n  TreeNode *v27;\n  bool v28;\n  long long v29;\n  TreeNode *newTree;\n  v3 = 0LL;\n  v4 = 0LL;\n  v5 = 0LL;\n  libmin_srand(42u);\n  libmin_printf(\"Start  -->  Finished\\n\", argv);\n  while (1) {\n    v6 = (int *)libmin_malloc(8uLL);\n    v7 = (char *)libmin_malloc(11uLL);\n    libmin_snprintf(v7, 11uLL, \"Name%ld\", v3);\n    while (1) {\n      *v6 = libmin_rand();\n      v8 = Insert(v5, v6, v7);\n      if (v8) goto LABEL_2;\n      if (*v6 == v4) break;\n      v4 = *v6;\n    }\n    libmin_free(v7);\n    libmin_free(v6);\n    libmin_printf(\"going to try and skip: %ld\\n\", (unsigned int)*v6);\n  LABEL_2:\n    ++v3;\n    libmin_printf(\".\");\n    if (v3 == 25) break;\n    v5 = v8;\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"\\nGoing to delete the rootNode: %ld\\n\",\n                *(unsigned int *)v8->Item);\n  v9 = DeleteByElement(v8, v8->Item);\n  v10 = v9;\n  if (v9) {\n    libmin_printf(\"success! new root is %ld\\n\", *(unsigned int *)v9->Item);\n  } else {\n    v10 = v8;\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf(\"\\nGoing to delete leftMost child... \");\n  v11 = v10;\n  do {\n    v12 = v11;\n    v11 = v11->Left;\n  } while (v11);\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)v12->Item);\n  v13 = DeleteByElement(v10, v12->Item);\n  v14 = v13;\n  if (v13) {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v13->Item);\n  } else {\n    v14 = v10;\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf(\"\\nGoing to delete rightMost child... \");\n  v15 = v14;\n  do {\n    v16 = v15;\n    v15 = v15->Right;\n  } while (v15);\n  libmin_printf(\"found item: %ld\\n\", *(unsigned int *)v16->Item);\n  v17 = DeleteByElement(v14, v16->Item);\n  v18 = v17;\n  if (v17) {\n    libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v17->Item);\n  } else {\n    v18 = v14;\n    libmin_printf(\"failure!\\n\");\n  }\n  libmin_printf((char *)\"\\n\");\n  printTree_0(v18, 0LL);\n  breadth(v18->Right);\n  v19 = breadth(v18->Left);\n  libmin_printf(\"breadth of left tree: %ld right subtree: %ld\\n\", v19, v20);\n  v21 = Height(v18->Left);\n  v22 = Height(v18->Right);\n  libmin_printf(\"height of left subtree: %ld right subtree: %ld\\n\", v21, v22);\n  v29 = 3LL;\nLABEL_20:\n  v23 = v18;\n  libmin_printf((char *)\"\\n\");\n  v24 = libmin_rand() % v21;\n  libmin_printf(\"Going to delete a node at depth (max depth %ld): %ld\\n\", v21,\n                v24);\n  while (1) {\n    while (1) {\n      Left = v23->Left;\n      Right = v23->Right;\n      if (!v23->Left) {\n        if (!Right) goto LABEL_28;\n        goto LABEL_27;\n      }\n      if (Right) break;\n    LABEL_24:\n      --v24;\n      v23 = Left;\n      if (v24 <= 0) goto LABEL_28;\n    }\n    if (libmin_rand() <= 1073741822) {\n      Left = v23->Left;\n      goto LABEL_24;\n    }\n    Right = v23->Right;\n  LABEL_27:\n    --v24;\n    v23 = Right;\n    if (v24 <= 0) {\n    LABEL_28:\n      libmin_printf(\"Found a node to delete with Name '%s' and Item %ld\\n\",\n                    v23->Name, *(unsigned int *)v23->Item);\n      v27 = DeleteByElement(v18, v23->Item);\n      if (v27) {\n        newTree = v27;\n        libmin_printf(\"success! new root: %ld\\n\", *(unsigned int *)v27->Item);\n        v18 = newTree;\n      } else {\n        libmin_printf(\"failure!\\n\");\n      }\n      v28 = v29-- == 1;\n      v21 = (int)((double)(int)v21 * 0.6);\n      if (v28) {\n        MakeEmpty(v18);\n        libmin_success();\n      }\n      goto LABEL_20;\n    }\n  }\n}", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x2a,%edi\npush   %r14\nxor    %r14d,%r14d\npush   %r13\nxor    %r13d,%r13d\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   4b10 <libmin_srand>\nlea    0x3ede(%rip),%rdi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\njmp    1177 <main+0x57>\nnopl   (%rax)\nlea    0x3f05(%rip),%rdi\nxor    %eax,%eax\nadd    $0x1,%r14\ncall   4900 <libmin_printf>\ncmp    $0x19,%r14\nje     1205 <main+0xe5>\nmov    %r15,%r12\nmov    $0x8,%edi\ncall   3360 <libmin_malloc>\nmov    $0xb,%edi\nmov    %rax,%rbx\ncall   3360 <libmin_malloc>\nmov    %r14,%rcx\nmov    $0xb,%esi\nlea    0x3ea3(%rip),%rdx\nmov    %rax,%rbp\nmov    %rax,%rdi\nxor    %eax,%eax\ncall   4a40 <libmin_snprintf>\nnopw   0x0(%rax,%rax,1)\ncall   4b70 <libmin_rand>\nmov    %rbp,%rdx\nmov    %rbx,%rsi\nmov    %r12,%rdi\nmov    %eax,(%rbx)\ncall   1f30 <Insert>\nmov    %rax,%r15\ntest   %rax,%rax\njne    1158 <main+0x38>\nmovslq (%rbx),%rax\ncmp    %r13,%rax\nje     11e0 <main+0xc0>\nmov    %rax,%r13\njmp    11b0 <main+0x90>\nnopw   0x0(%rax,%rax,1)\nmov    %rbp,%rdi\ncall   3410 <libmin_free>\nmov    %rbx,%rdi\ncall   3410 <libmin_free>\nmov    (%rbx),%esi\nlea    0x3e4f(%rip),%rdi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\njmp    1158 <main+0x38>\nlea    0x3e62(%rip),%r13\nxor    %eax,%eax\nmov    %r13,%rdi\ncall   4900 <libmin_printf>\nmov    0x10(%r15),%rax\nlea    0x3e97(%rip),%rdi\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\nmov    0x10(%r15),%rsi\nmov    %r15,%rdi\ncall   2860 <DeleteByElement>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     14b2 <main+0x392>\nmov    0x10(%rax),%rax\nlea    0x3e23(%rip),%rdi\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\nlea    0x3e83(%rip),%rdi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\nmov    %rbx,%rax\nnopw   0x0(%rax,%rax,1)\nmov    %rax,%r12\nmov    (%rax),%rax\ntest   %rax,%rax\njne    1270 <main+0x150>\nmov    0x10(%r12),%rax\nlea    0x3e03(%rip),%rbp\nmov    %rbp,%rdi\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\nmov    0x10(%r12),%rsi\nmov    %rbx,%rdi\ncall   2860 <DeleteByElement>\nmov    %rax,%r12\ntest   %rax,%rax\nje     14de <main+0x3be>\nmov    0x10(%rax),%rax\nlea    0x3de4(%rip),%rdi\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\nlea    0x3e41(%rip),%rdi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\nmov    %r12,%rax\nnopl   0x0(%rax)\nmov    %rax,%rbx\nmov    0x8(%rax),%rax\ntest   %rax,%rax\njne    12d8 <main+0x1b8>\nmov    0x10(%rbx),%rax\nmov    %rbp,%rdi\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\nmov    0x10(%rbx),%rsi\nmov    %r12,%rdi\ncall   2860 <DeleteByElement>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     14c8 <main+0x3a8>\nmov    0x10(%rax),%rax\nlea    0x3d84(%rip),%rdi\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\nmov    %r13,%rdi\nxor    %eax,%eax\nlea    0x3e64(%rip),%r15\ncall   4900 <libmin_printf>\nxor    %esi,%esi\nmov    %rbp,%rdi\ncall   15f0 <printTree.part.0>\nmov    0x8(%rbp),%rdi\ncall   1760 <breadth>\nmov    0x0(%rbp),%rdi\nmov    %rax,%r9\ncall   1760 <breadth>\nmov    %r9,%rdx\nlea    0x3dd6(%rip),%rdi\nmov    %rax,%rsi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\nmov    0x0(%rbp),%rdi\ncall   28b0 <Height>\nmov    0x8(%rbp),%rdi\nmov    %rax,%rbx\ncall   28b0 <Height>\nmov    %rbx,%rsi\nlea    0x3ddd(%rip),%rdi\nmov    %rax,%rdx\nxor    %eax,%eax\ncall   4900 <libmin_printf>\nmovq   $0x3,(%rsp)\nmov    %r13,%rdi\nxor    %eax,%eax\nmov    %rbp,%r12\ncall   4900 <libmin_printf>\ncall   4b70 <libmin_rand>\nmov    %rbx,%rsi\nmov    %r15,%rdi\nmov    %eax,%eax\ncqto\nidiv   %rbx\nxor    %eax,%eax\nmov    %rdx,%r14\ncall   4900 <libmin_printf>\njmp    13e5 <main+0x2c5>\ntest   %rsi,%rsi\nje     13d9 <main+0x2b9>\ncall   4b70 <libmin_rand>\ncmp    $0x3ffffffe,%eax\nja     1498 <main+0x378>\nmov    (%r12),%rax\nsub    $0x1,%r14\nmov    %rax,%r12\ntest   %r14,%r14\njle    1404 <main+0x2e4>\nmov    (%r12),%rax\nmov    0x8(%r12),%rsi\ntest   %rax,%rax\njne    13c0 <main+0x2a0>\ntest   %rsi,%rsi\nje     1404 <main+0x2e4>\nsub    $0x1,%r14\nmov    %rsi,%r12\ntest   %r14,%r14\njg     13e5 <main+0x2c5>\nmov    0x10(%r12),%rax\nmov    0x18(%r12),%rsi\nlea    0x3db3(%rip),%rdi\nmov    (%rax),%edx\nxor    %eax,%eax\ncall   4900 <libmin_printf>\nmov    0x10(%r12),%rsi\nmov    %rbp,%rdi\ncall   2860 <DeleteByElement>\nmov    %rax,%rdx\ntest   %rax,%rax\nje     14a2 <main+0x382>\nmov    0x10(%rax),%rax\nlea    0x3c5d(%rip),%rdi\nmov    %rdx,0x8(%rsp)\nmov    (%rax),%esi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\nmov    0x8(%rsp),%rbp\npxor   %xmm0,%xmm0\nsubq   $0x1,(%rsp)\ncvtsi2sd %rbx,%xmm0\nmulsd  0x3d99(%rip),%xmm0\ncvttsd2si %xmm0,%ebx\nmovslq %ebx,%rbx\njne    1395 <main+0x275>\nmov    %rbp,%rdi\ncall   1f80 <MakeEmpty>\ncall   4d50 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    0x8(%r12),%rsi\njmp    13f8 <main+0x2d8>\nlea    0x3bbd(%rip),%rdi\nxor    %eax,%eax\ncall   4900 <libmin_printf>\njmp    1451 <main+0x331>\nlea    0x3bad(%rip),%rdi\nxor    %eax,%eax\nmov    %r15,%rbx\ncall   4900 <libmin_printf>\njmp    1256 <main+0x136>\nlea    0x3b97(%rip),%rdi\nxor    %eax,%eax\nmov    %r12,%rbp\ncall   4900 <libmin_printf>\njmp    1320 <main+0x200>\nlea    0x3b81(%rip),%rdi\nxor    %eax,%eax\nmov    %rbx,%r12\ncall   4900 <libmin_printf>\njmp    12c0 <main+0x1a0>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "avl-tree/avl-tree.c", "function_name": "printTree", "content": "/* A balanced binary search tree(AVLTree) implementation\n * Written by Coleman\n * Released under GNU GPL Version 2 or later(http://www.gnu.org/)\n */\n#include \"libmin.h\"\n#include \"element.h\"\n#include \"avlcore.h\"\n\n#define MAXELEMENTSIZE 500000\n\nvoid printTree(TreeNode *start, long level)\n{\n    long i = 0;\n    if(start == NULL)\n        return;\n    libmin_printf(\"%s -> %ld, Balance %d\\n\", start->Name,\n\t\t\t\t*start->Item, start->Balance);\n    for(i = 0; i < level; i++)\n        libmin_printf(\" \");\n    libmin_printf(\"Left: \");\n    printTree(start->Left, level + 1);\n    libmin_printf(\"\\n\");\n    for(i = 0; i < level; i++)\n        libmin_printf(\" \");\n    libmin_printf(\"Right: \");\n    printTree(start->Right, level + 1);\n    if(level == 0)\n        libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "avl-tree/avl-tree.host.O2.pseudo", "function_name": "printTree", "address": "0x1740", "label": "printTree", "content": "void __fastcall printTree(TreeNode *start, __int64 level)\n{\n  if ( start )\n    printTree_0(start, level);\n}\n"}, "pseudo_normalize": "", "binary": "avl-tree/avl-tree.host.O2", "assembly": "<printTree>:\nendbr64\ntest   %rdi,%rdi\nje     1750 <printTree+0x10>\njmp    15f0 <printTree.part.0>\nxchg   %ax,%ax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "banner/banner.c", "function_name": "main", "content": "int\nmain(void)\n{ \n\tint ch;\n\n\twhile ((ch = libmin_getopt(argc, argv, \"w:tdh\")) != -1)\n\t\tswitch (ch) {\n\t\tcase 'd':\n\t\t\tdebug = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twidth = libmin_atoi(optarg);\n\t\t\tif (width <= 0)\n\t\t\t\tlibmin_printf(\"error: illegal argument for -w option\\n\");\n\t\t\tbreak;\n\t\tcase '?': case 'h':\n\t\tdefault:\n\t\t\tlibmin_printf(\"usage: banner [-w width]\\n\");\n\t\t\tlibmin_fail(1);\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tfor (i = 0; i < width; i++) {\n\t\tj = i * 132 / width;\n\t\tprint[j] = 1;\n\t}\n\n\t/* Have now read in the data. Next get the message to be printed. */\n\tif (*argv) {\n\t\tlibmin_strncpy(message, *argv, sizeof message);\n\t\twhile (*++argv) {\n\t\t\tlibmin_strncat(message, \" \", sizeof message);\n\t\t\tlibmin_strncat(message, *argv, sizeof message);\n\t\t}\n\t\tnchars = libmin_strlen(message);\n\t} else {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n\t}\n\n\t/* some debugging print statements */\n\tif (debug) {\n\t\tlibmin_printf(\"int asc_ptr[128] = {\\n\");\n\t\tfor (i = 0; i < 128; i++) {\n\t\t\tlibmin_printf(\"%4d,   \",asc_ptr[i]);\n\t\t\tif ((i+1) % 8 == 0)\n\t\t\t\tlibmin_printf(\"\\n\");\n\t\t}\n\t\tlibmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n\t\tlibmin_printf(\"  /*   \");\n\t\tfor (i = 0; i < 10; i++) libmin_printf(\" %3d  \",i);\n\t\tlibmin_printf(\"   */\\n\");\n\t\tfor (i = 0; i < NBYTES; i += 10) {\n\t\t\tlibmin_printf(\"/* %4d */  \",i);\n\t\t\tfor (j = i; j < i+10; j++) { \n\t\t\t\tx = data_table[j] & 0377;\n\t\t\t\tlibmin_printf(\" %3d, \",x);\n\t\t\t}\n\t\t\tlibmin_putc('\\n');\n\t\t}\n\t\tlibmin_printf(\"};\\n\");\n\t}\n\n\t/* check message to make sure it's legal */\n\tj = 0;\n\tfor (i = 0; i < nchars; i++)\n\t\tif ((uint8_t) message[i] >= NCHARS ||\n\t\t    asc_ptr[(uint8_t) message[i]] == 0) {\n\t\t\tlibmin_printf(\"The character is not in my character set\\n\");\n\t\t\tj++;\n\t\t}\n\tif (j)\n\t\tlibmin_fail(1);\n\n\t/* Now have message. Print it one character at a time.  */\n\n\tfor (i = 0; i < nchars; i++) {\n\t\tfor (j = 0; j < DWIDTH; j++) line[j] = ' ';\n\t\tpc = asc_ptr[(uint8_t) message[i]];\n\t\tterm = 0;\n\t\tmax = 0;\n\t\tlinen = 0;\n\t\twhile (!term) {\n\t\t\tif (pc < 0 || pc >= NBYTES) {\n\t\t\t\tlibmin_printf(\"bad pc: %d\\n\",pc);\n\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\t\tx = data_table[pc] & 0377;\n\t\t\tif (x >= 128) {\n\t\t\t\tif (x>192) term++;\n\t\t\t\tx = x & 63;\n\t\t\t\twhile (x--) {\n\t\t\t\t\tif (print[linen++]) {\n\t\t\t\t\t\tfor (j=0; j <= max; j++)\n\t\t\t\t\t\t\tif (print[j])\n\t\t\t\t\t\t\t\tlibmin_putc(line[j]);\n\t\t\t\t\t\tlibmin_putc('\\n');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < DWIDTH; j++) line[j] = ' ';\n\t\t\t\tpc++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty = data_table[pc+1];\n\t\t\t\t/* compensate for narrow teminals */\n#ifdef notdef\n\t\t\t\tx = (x*width + (DWIDTH/2)) / DWIDTH;\n\t\t\t\ty = (y*width + (DWIDTH/2)) / DWIDTH;\n#endif\n\t\t\t\tmax = x+y;\n\t\t\t\twhile (x < max) line[x++] = '#';\n\t\t\t\tpc += 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tlibmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "banner/banner.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int v4; // edi\n  char **v5; // r9\n  int v6; // r8d\n  int v7; // esi\n  int v8; // eax\n  int v9; // eax\n  bool v10; // zf\n  int v11; // eax\n  __int64 v12; // rax\n  int v13; // eax\n  unsigned int v14; // r15d\n  int v15; // ecx\n  int v16; // r8d\n  char v17; // di\n  int v18; // eax\n  char *v19; // rdx\n  int v20; // esi\n  int v21; // r9d\n  int v22; // r8d\n  int v23; // eax\n  int v24; // r14d\n  int v25; // eax\n  int v26; // eax\n  int v27; // esi\n  int v28; // esi\n  int v29; // eax\n\n  while ( 1 )\n  {\n    v3 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if ( v3 == -1 )\n      break;\n    if ( v3 == 100 )\n    {\n      debug = 1;\n    }\n    else\n    {\n      if ( v3 != 119 )\n      {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if ( width <= 0 )\n        libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  v4 = width;\n  i = 0;\n  ::argc -= optind;\n  v5 = &::argv[optind];\n  ::argv = v5;\n  if ( width > 0 )\n  {\n    v6 = 132 * width;\n    v7 = 0;\n    do\n    {\n      v8 = v7;\n      v7 += 132;\n      v9 = v8 / v4;\n      print[v9] = 1;\n    }\n    while ( v6 != v7 );\n    j = v9;\n    i = v4;\n  }\n  if ( !*v5 )\n  {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n  }\n  libmin_strncpy(message, *v5, 0x400uLL);\n  v10 = ::argv[1] == 0LL;\n  for ( ++::argv; !v10; ++::argv )\n  {\n    libmin_strncat(message, \" \", 0x400uLL);\n    libmin_strncat(message, *::argv, 0x400uLL);\n    v10 = ::argv[1] == 0LL;\n  }\n  nchars = libmin_strlen(message);\n  if ( debug )\n  {\n    libmin_printf(\"int asc_ptr[128] = {\\n\");\n    v26 = 0;\n    i = 0;\n    do\n    {\n      while ( 1 )\n      {\n        libmin_printf(\"%4d,   \", asc_ptr[v26]);\n        v26 = i + 1;\n        if ( (((_BYTE)i + 1) & 7) == 0 )\n          break;\n        ++i;\n        if ( v26 > 127 )\n          goto LABEL_53;\n      }\n      libmin_printf((char *)\"\\n\");\n      v26 = i + 1;\n      i = v26;\n    }\n    while ( v26 <= 127 );\nLABEL_53:\n    libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n    libmin_printf(\"  /*   \");\n    v27 = 0;\n    i = 0;\n    do\n    {\n      libmin_printf(\" %3d  \", v27);\n      v27 = i + 1;\n      i = v27;\n    }\n    while ( v27 <= 9 );\n    libmin_printf(\"   */\\n\");\n    v28 = 0;\n    i = 0;\n    do\n    {\n      libmin_printf(\"/* %4d */  \", v28);\n      v29 = i;\n      j = i;\n      do\n      {\n        x = (unsigned __int8)data_table[v29];\n        libmin_printf(\" %3d, \", x);\n        v29 = j + 1;\n        j = v29;\n      }\n      while ( v29 <= i + 9 );\n      libmin_putc(10);\n      v28 = i + 10;\n      i = v28;\n    }\n    while ( v28 <= 9270 );\n    libmin_printf(\"};\\n\");\n  }\n  v11 = 0;\n  j = 0;\n  i = 0;\n  if ( nchars > 0 )\n  {\n    do\n    {\n      v12 = message[v11];\n      if ( (v12 & 0x80u) != 0LL || !asc_ptr[v12] )\n      {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++j;\n      }\n      v11 = ++i;\n    }\n    while ( i < nchars );\n    if ( j )\n      libmin_fail(1);\n  }\n  v13 = 0;\n  for ( i = 0; i < nchars; v13 = i )\n  {\n    memset(line, 32, sizeof(line));\n    v14 = asc_ptr[(unsigned __int8)message[v13]];\n    j = 132;\n    pc = v14;\n    term = 0;\n    max = 0;\n    linen = 0;\n    do\n    {\n      if ( v14 > 0x2436 )\n      {\n        libmin_printf(\"bad pc: %d\\n\", v14);\n        libmin_fail(1);\n      }\n      v15 = (unsigned __int8)data_table[v14];\n      x = v15;\n      if ( (v15 & 0x80u) == 0 )\n      {\n        v23 = data_table[v14 + 1];\n        v24 = v15 + v23;\n        y = v23;\n        max = v15 + v23;\n        if ( v15 < v15 + v23 )\n        {\n          memset(&line[v15], 35, (unsigned int)(v23 - 1) + 1LL);\n          x = v24;\n        }\n        v14 += 2;\n      }\n      else\n      {\n        if ( v15 > 192 )\n          ++term;\n        v16 = v15 & 0x3F;\nLABEL_30:\n        v17 = 0;\n        v18 = linen;\n        v19 = &print[linen];\n        v20 = v16 + linen;\n        v21 = v16 + linen - 1;\n        while ( 1 )\n        {\n          v22 = v21 - v18;\n          if ( v20 == v18 )\n            break;\n          ++v19;\n          ++v18;\n          v17 = 1;\n          if ( *(v19 - 1) )\n          {\n            linen = v18;\n            v25 = 0;\n            x = v22;\n            for ( j = 0; j <= max; v25 = j )\n            {\n              if ( print[v25] )\n                libmin_putc(line[v25]);\n              ++j;\n            }\n            libmin_putc(10);\n            v16 = x;\n            goto LABEL_30;\n          }\n        }\n        x = v21 - v18;\n        if ( v17 )\n          linen = v20;\n        memset(line, 32, sizeof(line));\n        v14 = pc + 1;\n        j = 132;\n      }\n      pc = v14;\n    }\n    while ( !term );\n    ++i;\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  char **v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  bool v10;\n  int v11;\n  long long v12;\n  int v13;\n  unsigned int v14;\n  int v15;\n  int v16;\n  char v17;\n  int v18;\n  char *v19;\n  int v20;\n  int v21;\n  int v22;\n  int v23;\n  int v24;\n  int v25;\n  int v26;\n  int v27;\n  int v28;\n  int v29;\n  while (1) {\n    v3 = libmin_getopt(::argc, ::argv, \"w:tdh\");\n    if (v3 == -1) break;\n    if (v3 == 100) {\n      debug = 1;\n    } else {\n      if (v3 != 119) {\n        libmin_printf(\"usage: banner [-w width]\\n\");\n        libmin_fail(1);\n      }\n      width = libmin_atoi(optarg);\n      if (width <= 0) libmin_printf(\"error: illegal argument for -w option\\n\");\n    }\n  }\n  v4 = width;\n  i = 0;\n  ::argc -= optind;\n  v5 = &::argv[optind];\n  ::argv = v5;\n  if (width > 0) {\n    v6 = 132 * width;\n    v7 = 0;\n    do {\n      v8 = v7;\n      v7 += 132;\n      v9 = v8 / v4;\n      print[v9] = 1;\n    } while (v6 != v7);\n    j = v9;\n    i = v4;\n  }\n  if (!*v5) {\n    libmin_printf(\"No message to print.\\n\");\n    libmin_fail(1);\n  }\n  libmin_strncpy(message, *v5, 1024uLL);\n  v10 = ::argv[1] == 0LL;\n  for (++::argv; !v10; ++::argv) {\n    libmin_strncat(message, \" \", 1024uLL);\n    libmin_strncat(message, *::argv, 1024uLL);\n    v10 = ::argv[1] == 0LL;\n  }\n  nchars = libmin_strlen(message);\n  if (debug) {\n    libmin_printf(\"int asc_ptr[128] = {\\n\");\n    v26 = 0;\n    i = 0;\n    do {\n      while (1) {\n        libmin_printf(\"%4d,   \", asc_ptr[v26]);\n        v26 = i + 1;\n        if ((((uint8_t)i + 1) & 7) == 0) break;\n        ++i;\n        if (v26 > 127) goto LABEL_53;\n      }\n      libmin_printf((char *)\"\\n\");\n      v26 = i + 1;\n      i = v26;\n    } while (v26 <= 127);\n  LABEL_53:\n    libmin_printf(\"};\\nchar data_table[NBYTES] = {\\n\");\n    libmin_printf(\"  \\n\");\n    v28 = 0;\n    i = 0;\n    do {\n      libmin_printf(\"  \", v28);\n      v29 = i;\n      j = i;\n      do {\n        x = (unsigned char)data_table[v29];\n        libmin_printf(\" %3d, \", x);\n        v29 = j + 1;\n        j = v29;\n      } while (v29 <= i + 9);\n      libmin_putc(10);\n      v28 = i + 10;\n      i = v28;\n    } while (v28 <= 9270);\n    libmin_printf(\"};\\n\");\n  }\n  v11 = 0;\n  j = 0;\n  i = 0;\n  if (nchars > 0) {\n    do {\n      v12 = message[v11];\n      if ((v12 & 128u) != 0LL || !asc_ptr[v12]) {\n        libmin_printf(\"The character is not in my character set\\n\");\n        ++j;\n      }\n      v11 = ++i;\n    } while (i < nchars);\n    if (j) libmin_fail(1);\n  }\n  v13 = 0;\n  for (i = 0; i < nchars; v13 = i) {\n    memset(line, 32, sizeof(line));\n    v14 = asc_ptr[(unsigned char)message[v13]];\n    j = 132;\n    pc = v14;\n    term = 0;\n    max = 0;\n    linen = 0;\n    do {\n      if (v14 > 9270) {\n        libmin_printf(\"bad pc: %d\\n\", v14);\n        libmin_fail(1);\n      }\n      v15 = (unsigned char)data_table[v14];\n      x = v15;\n      if ((v15 & 128u) == 0) {\n        v23 = data_table[v14 + 1];\n        v24 = v15 + v23;\n        y = v23;\n        max = v15 + v23;\n        if (v15 < v15 + v23) {\n          memset(&line[v15], 35, (unsigned int)(v23 - 1) + 1LL);\n          x = v24;\n        }\n        v14 += 2;\n      } else {\n        if (v15 > 192) ++term;\n        v16 = v15 & 63;\n      LABEL_30:\n        v17 = 0;\n        v18 = linen;\n        v19 = &print[linen];\n        v20 = v16 + linen;\n        v21 = v16 + linen - 1;\n        while (1) {\n          v22 = v21 - v18;\n          if (v20 == v18) break;\n          ++v19;\n          ++v18;\n          v17 = 1;\n          if (*(v19 - 1)) {\n            linen = v18;\n            v25 = 0;\n            x = v22;\n            for (j = 0; j <= max; v25 = j) {\n              if (print[v25]) libmin_putc(line[v25]);\n              ++j;\n            }\n            libmin_putc(10);\n            v16 = x;\n            goto LABEL_30;\n          }\n        }\n        x = v21 - v18;\n        if (v17) linen = v20;\n        memset(line, 32, sizeof(line));\n        v14 = pc + 1;\n        j = 132;\n      }\n      pc = v14;\n    } while (!term);\n    ++i;\n  }\n  libmin_success();\n}", "binary": "banner/banner.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nlea    0x2ed5(%rip),%r12\npush   %rbp\nlea    0x2f3f(%rip),%rbp\npush   %rbx\nlea    0x2f51(%rip),%rbx\nsub    $0x18,%rsp\nnopw   0x0(%rax,%rax,1)\nmov    0x7ec9(%rip),%rsi\nmov    0x7eb3(%rip),%edi\nmov    %rbx,%rdx\ncall   1c20 <libmin_getopt>\ncmp    $0xffffffff,%eax\nje     11b8 <main+0x98>\ncmp    $0x64,%eax\nje     118a <main+0x6a>\ncmp    $0x77,%eax\nje     1196 <main+0x76>\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nmov    $0x1,%edi\ncall   1c00 <libmin_fail>\njmp    1150 <main+0x30>\nmovl   $0x1,0x8150(%rip)\njmp    1150 <main+0x30>\nmov    0x86a3(%rip),%rdi\ncall   1b40 <libmin_atoi>\nmov    %eax,0x7e6c(%rip)\ntest   %eax,%eax\njg     1150 <main+0x30>\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\njmp    1150 <main+0x30>\nmovslq 0x80b5(%rip),%rax\nmov    0x7e4f(%rip),%edi\nmovl   $0x0,0x8111(%rip)\nmov    0x7e4a(%rip),%rdx\nsub    %eax,0x7e34(%rip)\nlea    (%rdx,%rax,8),%r9\nmov    %r9,0x7e39(%rip)\ntest   %edi,%edi\njle    1224 <main+0x104>\nimul   $0x84,%edi,%r8d\nxor    %esi,%esi\nlea    0x8105(%rip),%r15\nnopl   0x0(%rax,%rax,1)\nmov    %esi,%eax\nadd    $0x84,%esi\ncltd\nidiv   %edi\nmovslq %eax,%rdx\nmovb   $0x1,(%r15,%rdx,1)\ncmp    %esi,%r8d\njne    1200 <main+0xe0>\nmov    %eax,0x80be(%rip)\nmov    %edi,0x80bc(%rip)\nmov    (%r9),%rsi\ntest   %rsi,%rsi\nje     1846 <main+0x726>\nlea    0x8169(%rip),%rax\nmov    $0x400,%edx\nlea    0x2e91(%rip),%rbx\nmov    %rax,%rdi\nmov    %rax,(%rsp)\ncall   3450 <libmin_strncpy>\nmov    0x7dca(%rip),%rax\nlea    0x8(%rax),%rdx\ncmpq   $0x0,0x8(%rax)\nmov    %rdx,0x7dba(%rip)\nje     12ac <main+0x18c>\nmov    (%rsp),%r14\nmov    $0x400,%edx\nmov    %rbx,%rsi\nmov    %r14,%rdi\ncall   3400 <libmin_strncat>\nmov    0x7d9d(%rip),%rax\nmov    $0x400,%edx\nmov    %r14,%rdi\nmov    (%rax),%rsi\ncall   3400 <libmin_strncat>\nmov    0x7d86(%rip),%rax\nlea    0x8(%rax),%rdx\ncmpq   $0x0,0x8(%rax)\nmov    %rdx,0x7d76(%rip)\njne    1268 <main+0x148>\nmov    (%rsp),%rdi\ncall   33d0 <libmin_strlen>\nmov    %eax,0x8015(%rip)\nmov    0x8022(%rip),%r9d\ntest   %r9d,%r9d\njne    16c7 <main+0x5a7>\nmov    0x7ffe(%rip),%r8d\nxor    %eax,%eax\nlea    0x80c5(%rip),%rbx\nmovl   $0x0,0x7ff7(%rip)\nmov    %rbx,(%rsp)\nlea    0x2d60(%rip),%rbp\nlea    0x5269(%rip),%rbx\nmovl   $0x0,0x7fdf(%rip)\ntest   %r8d,%r8d\njle    1362 <main+0x242>\ncs nopw 0x0(%rax,%rax,1)\nmov    (%rsp),%rcx\ncltq\nmovsbq (%rcx,%rax,1),%rax\ntest   %al,%al\njs     1326 <main+0x206>\nmov    (%rbx,%rax,4),%edi\ntest   %edi,%edi\njne    1337 <main+0x217>\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\naddl   $0x1,0x7fa5(%rip)\nmov    0x7fa3(%rip),%eax\nadd    $0x1,%eax\ncmp    0x7f8a(%rip),%eax\nmov    %eax,0x7f94(%rip)\njl     1310 <main+0x1f0>\nmov    0x7f88(%rip),%esi\ntest   %esi,%esi\nje     1362 <main+0x242>\nmov    $0x1,%edi\ncall   1c00 <libmin_fail>\nlea    0x8037(%rip),%rbx\nmov    0x7f61(%rip),%ecx\nxor    %eax,%eax\nmovl   $0x0,0x7f65(%rip)\nmov    %rbx,(%rsp)\nlea    0x51da(%rip),%rbx\nmovabs $0x2020202020202020,%r12\nmovabs $0x2020202020202020,%r13\nmov    %rbx,0x8(%rsp)\nlea    0x83fa(%rip),%rbp\nlea    0x2d73(%rip),%rbx\ntest   %ecx,%ecx\njle    15c8 <main+0x4a8>\nnopl   (%rax)\nmov    (%rsp),%rcx\ncltq\nmov    %r12,0x83db(%rip)\nmov    %r13,0x83dc(%rip)\nmovzbl (%rcx,%rax,1),%eax\nmov    0x8(%rsp),%rcx\nmov    %r12,0x83d4(%rip)\nmov    %r13,0x83d5(%rip)\nmov    (%rcx,%rax,4),%r15d\nmov    %r12,0x83d2(%rip)\nmov    %r13,0x83d3(%rip)\nmov    %r12,0x83d4(%rip)\nmov    %r13,0x83d5(%rip)\nmov    %r12,0x83d6(%rip)\nmov    %r13,0x83d7(%rip)\nmov    %r12,0x83d8(%rip)\nmov    %r13,0x83d9(%rip)\nmov    %r12,0x83da(%rip)\nmov    %r13,0x83db(%rip)\nmov    %r12,0x83dc(%rip)\nmov    %r13,0x83dd(%rip)\nmovl   $0x20202020,0x83db(%rip)\nmovl   $0x84,0x7e8d(%rip)\nmov    %r15d,0x7e76(%rip)\nmovl   $0x0,0x7e68(%rip)\nmovl   $0x0,0x7e6a(%rip)\nmovl   $0x0,0x7e64(%rip)\nnopl   0x0(%rax)\ncmp    $0x2436,%r15d\nja     16a0 <main+0x580>\nmovslq %r15d,%rax\nmovzbl (%rbx,%rax,1),%ecx\nmov    %ecx,0x7e32(%rip)\nmov    %ecx,%eax\ntest   %cl,%cl\njns    15e0 <main+0x4c0>\ncmp    $0xc0,%ecx\njle    14ab <main+0x38b>\naddl   $0x1,0x7e1d(%rip)\nmov    %eax,%r8d\nlea    0x7e4b(%rip),%r15\nand    $0x3f,%r8d\nmovslq 0x7e18(%rip),%rdx\nxor    %edi,%edi\nmov    %rdx,%rax\nadd    %r15,%rdx\nlea    (%r8,%rax,1),%esi\nlea    -0x1(%r8,%rax,1),%r9d\njmp    14ee <main+0x3ce>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rdx\nadd    $0x1,%eax\nmov    $0x1,%edi\ncmpb   $0x0,-0x1(%rdx)\njne    1630 <main+0x510>\nmov    %r9d,%r8d\nsub    %eax,%r8d\ncmp    %eax,%esi\njne    14d8 <main+0x3b8>\nmov    %r8d,0x7dc5(%rip)\ntest   %dil,%dil\nje     150a <main+0x3ea>\nmov    %esi,0x7dce(%rip)\nmov    0x7dbc(%rip),%eax\nmov    %r12,0x8289(%rip)\nmov    %r13,0x828a(%rip)\nmov    %r12,0x828b(%rip)\nlea    0x1(%rax),%r15d\nmov    %r13,0x8288(%rip)\nmov    %r12,0x8289(%rip)\nmov    %r13,0x828a(%rip)\nmov    %r12,0x828b(%rip)\nmov    %r13,0x828c(%rip)\nmov    %r12,0x828d(%rip)\nmov    %r13,0x828e(%rip)\nmov    %r12,0x828f(%rip)\nmov    %r13,0x8290(%rip)\nmov    %r12,0x8291(%rip)\nmov    %r13,0x8292(%rip)\nmov    %r12,0x8293(%rip)\nmov    %r13,0x8294(%rip)\nmovl   $0x20202020,0x8292(%rip)\nmovl   $0x84,0x7d44(%rip)\nmov    0x7d2a(%rip),%eax\nmov    %r15d,0x7d27(%rip)\ntest   %eax,%eax\nje     1478 <main+0x358>\nmov    0x7d2d(%rip),%eax\nadd    $0x1,%eax\ncmp    0x7d14(%rip),%eax\nmov    %eax,0x7d1e(%rip)\njl     13b8 <main+0x298>\ncall   34a0 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxchg   %ax,%ax\nlea    0x1(%r15),%eax\ncltq\nmovsbl (%rbx,%rax,1),%eax\nlea    (%rcx,%rax,1),%r14d\nmov    %eax,0x7ccc(%rip)\nmov    %r14d,0x7cd9(%rip)\ncmp    %r14d,%ecx\njge    161f <main+0x4ff>\nlea    -0x1(%rax),%edx\nmovslq %ecx,%rcx\nmov    $0x23,%esi\nadd    $0x1,%rdx\nlea    (%rcx,%rbp,1),%rdi\ncall   10d0 <memset@plt>\nmov    %r14d,0x7ca5(%rip)\nadd    $0x2,%r15d\njmp    1598 <main+0x478>\nnopl   0x0(%rax,%rax,1)\nmov    0x7c9e(%rip),%edx\nmov    %eax,0x7c9c(%rip)\nxor    %eax,%eax\nmov    %r8d,0x7c7f(%rip)\nmovl   $0x0,0x7c8d(%rip)\ntest   %edx,%edx\njns    166f <main+0x54f>\njmp    1688 <main+0x568>\nnopl   (%rax)\nmov    0x7c7e(%rip),%eax\nadd    $0x1,%eax\ncmp    0x7c6d(%rip),%eax\nmov    %eax,0x7c6f(%rip)\njg     1688 <main+0x568>\ncltq\ncmpb   $0x0,(%r15,%rax,1)\nje     1658 <main+0x538>\nmovsbl 0x0(%rbp,%rax,1),%edi\ncall   33c0 <libmin_putc>\njmp    1658 <main+0x538>\nnopl   0x0(%rax)\nmov    $0xa,%edi\ncall   33c0 <libmin_putc>\nmov    0x7c2b(%rip),%r8d\njmp    14b9 <main+0x399>\nxchg   %ax,%ax\nmov    %r15d,%esi\nlea    0x2a51(%rip),%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nmov    $0x1,%edi\ncall   1c00 <libmin_fail>\nmov    0x7c0a(%rip),%r15d\njmp    1485 <main+0x365>\nlea    0x4e92(%rip),%rbx\nlea    0x29db(%rip),%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nlea    0x29cb(%rip),%rbp\nmov    %rbx,0x8(%rsp)\nxor    %eax,%eax\nmovl   $0x0,0x7bec(%rip)\nlea    0x29cb(%rip),%rbx\njmp    1708 <main+0x5e8>\nmov    %eax,0x7bdd(%rip)\ncmp    $0x7f,%eax\njg     1747 <main+0x627>\nmov    0x8(%rsp),%rcx\ncltq\nmov    %rbx,%rdi\nmov    (%rcx,%rax,4),%esi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nmov    0x7bbe(%rip),%eax\nadd    $0x1,%eax\ntest   $0x7,%al\njne    16fd <main+0x5dd>\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nmov    0x7ba7(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x7b9e(%rip)\ncmp    $0x7f,%eax\njle    1708 <main+0x5e8>\nlea    0x28e2(%rip),%rdi\nxor    %eax,%eax\nlea    0x297f(%rip),%rbx\ncall   31b0 <libmin_printf>\nlea    0x296b(%rip),%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nxor    %esi,%esi\nmovl   $0x0,0x7b6a(%rip)\nmov    %rbx,%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nmov    0x7b5a(%rip),%eax\nlea    0x1(%rax),%esi\nmov    %esi,0x7b51(%rip)\ncmp    $0x9,%esi\njle    1776 <main+0x656>\nlea    0x2942(%rip),%rdi\nxor    %eax,%eax\nlea    0x2940(%rip),%r12\ncall   31b0 <libmin_printf>\nlea    0x2970(%rip),%rbx\nxor    %esi,%esi\nmovl   $0x0,0x7b24(%rip)\nlea    0x292d(%rip),%rbp\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nmov    0x7b0d(%rip),%eax\nmov    %eax,0x7b03(%rip)\nnopl   0x0(%rax)\ncltq\nmov    %rbp,%rdi\nmovzbl (%rbx,%rax,1),%esi\nxor    %eax,%eax\nmov    %esi,0x7ad3(%rip)\ncall   31b0 <libmin_printf>\nmov    0x7ae0(%rip),%eax\nmov    0x7ade(%rip),%ecx\nadd    $0x1,%eax\nlea    0x9(%rcx),%edx\nmov    %eax,0x7ace(%rip)\ncmp    %edx,%eax\njle    17e0 <main+0x6c0>\nmov    $0xa,%edi\ncall   33c0 <libmin_putc>\nmov    0x7abe(%rip),%eax\nlea    0xa(%rax),%esi\nmov    %esi,0x7ab5(%rip)\ncmp    $0x2436,%esi\njle    17c3 <main+0x6a3>\nlea    0x28bd(%rip),%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\njmp    12cb <main+0x1ab>\nlea    0x284d(%rip),%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nmov    $0x1,%edi\ncall   1c00 <libmin_fail>\njmp    12bb <main+0x19b>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_builtin", "content": "// ------------------------------\n// Bit-counting Kernel 3: Compiler built-in popcount (GCC/Clang)\n// ------------------------------\nunsigned int count_bits_builtin(uint32_t x) {\n    return __builtin_popcount(x);\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O2.pseudo", "function_name": "count_bits_builtin", "address": "0x1540", "label": "count_bits_builtin", "content": "unsigned int __fastcall count_bits_builtin(uint32_t x)\n{\n  return _popcountdi2(x);\n}\n"}, "pseudo_normalize": "", "binary": "bit-kernels/bit-kernels.host.O2", "assembly": "<count_bits_builtin>:\nendbr64\nsub    $0x8,%rsp\nmov    %edi,%edi\ncall   32f0 <__popcountdi2>\nadd    $0x8,%rsp\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_kernighan", "content": "// ------------------------------\n// Bit-counting Kernel 2: Kernighan's algorithm\n// ------------------------------\nunsigned int count_bits_kernighan(uint32_t x) {\n    unsigned int count = 0;\n    while (x) {\n        x &= (x - 1);\n        count++;\n    }\n    return count;\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O2.pseudo", "function_name": "count_bits_kernighan", "address": "0x1520", "label": "count_bits_kernighan", "content": "unsigned int __fastcall count_bits_kernighan(uint32_t x)\n{\n  unsigned int i; // r8d\n\n  for ( i = 0; x; x &= x - 1 )\n    ++i;\n  return i;\n}\n"}, "pseudo_normalize": "", "binary": "bit-kernels/bit-kernels.host.O2", "assembly": "<count_bits_kernighan>:\nendbr64\nxor    %r8d,%r8d\ntest   %edi,%edi\nje     153b <count_bits_kernighan+0x1b>\nnopl   0x0(%rax,%rax,1)\nlea    -0x1(%rdi),%eax\nadd    $0x1,%r8d\nand    %eax,%edi\njne    1530 <count_bits_kernighan+0x10>\nmov    %r8d,%eax\nret\nnop\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_naive", "content": "// ------------------------------\n// Bit-counting Kernel 1: Naive method\n// ------------------------------\nunsigned int count_bits_naive(uint32_t x) {\n    unsigned int count = 0;\n    while (x) {\n        count += (x & 1);\n        x >>= 1;\n    }\n    return count;\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O2.pseudo", "function_name": "count_bits_naive", "address": "0x14f0", "label": "count_bits_naive", "content": "unsigned int __fastcall count_bits_naive(uint32_t x)\n{\n  unsigned int result; // eax\n\n  for ( result = 0; x; x >>= 1 )\n    result += x & 1;\n  return result;\n}\n"}, "pseudo_normalize": "", "binary": "bit-kernels/bit-kernels.host.O2", "assembly": "<count_bits_naive>:\nendbr64\nxor    %eax,%eax\ntest   %edi,%edi\nje     1510 <count_bits_naive+0x20>\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%edx\nand    $0x1,%edx\nadd    %edx,%eax\nshr    %edi\njne    1500 <count_bits_naive+0x10>\nret\nnopl   0x0(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_parallel", "content": "// ------------------------------\n// Bit-counting Kernel 5: Parallel counting (SWAR algorithm)\n// ------------------------------\nunsigned int count_bits_parallel(uint32_t x) {\n    // Subtract pairs of bits\n    x = x - ((x >> 1) & 0x55555555);\n    // Sum bits in nibble groups\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    // Aggregate counts in bytes\n    x = (x + (x >> 4)) & 0x0F0F0F0F;\n    // Multiply and shift out the sum\n    return (x * 0x01010101) >> 24;\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O2.pseudo", "function_name": "count_bits_parallel", "address": "0x15f0", "label": "count_bits_parallel", "content": "unsigned int __fastcall count_bits_parallel(uint32_t x)\n{\n  uint32_t v1; // edx\n\n  v1 = (((x - ((x >> 1) & 0x55555555)) >> 2) & 0x33333333) + ((x - ((x >> 1) & 0x55555555)) & 0x33333333);\n  return (16843009 * ((v1 + (v1 >> 4)) & 0xF0F0F0F)) >> 24;\n}\n"}, "pseudo_normalize": "unsigned int count_bits_parallel(uint32_t x) {\n  uint32_t v1;\n  v1 = (((x - ((x >> 1) & 1431655765)) >> 2) & 858993459) +\n       ((x - ((x >> 1) & 1431655765)) & 858993459);\n  return (16843009 * ((v1 + (v1 >> 4)) & 252645135)) >> 24;\n}", "binary": "bit-kernels/bit-kernels.host.O2", "assembly": "<count_bits_parallel>:\nendbr64\nmov    %edi,%eax\nshr    %eax\nand    $0x55555555,%eax\nsub    %eax,%edi\nmov    %edi,%edx\nshr    $0x2,%edi\nand    $0x33333333,%edx\nand    $0x33333333,%edi\nadd    %edi,%edx\nmov    %edx,%eax\nshr    $0x4,%eax\nadd    %edx,%eax\nand    $0xf0f0f0f,%eax\nimul   $0x1010101,%eax,%eax\nshr    $0x18,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "count_bits_table", "content": "  \n// Use the table to compute popcount for a 32-bit integer.\nunsigned int count_bits_table(uint32_t x) {\n    return popcount_table[x & 0xFF] +\n           popcount_table[(x >> 8) & 0xFF] +\n           popcount_table[(x >> 16) & 0xFF] +\n           popcount_table[(x >> 24) & 0xFF];\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O2.pseudo", "function_name": "count_bits_table", "address": "0x15c0", "label": "count_bits_table", "content": "unsigned int __fastcall count_bits_table(uint32_t x)\n{\n  return popcount_table[BYTE2(x)]\n       + popcount_table[BYTE1(x)]\n       + popcount_table[(unsigned __int8)x]\n       + popcount_table[HIBYTE(x)];\n}\n"}, "pseudo_normalize": "", "binary": "bit-kernels/bit-kernels.host.O2", "assembly": "<count_bits_table>:\nendbr64\nmov    %edi,%eax\nlea    0x4cb3(%rip),%rcx\nmov    %edi,%edx\nmovzbl %dil,%esi\nshr    $0x18,%eax\nmov    (%rcx,%rax,4),%eax\nadd    (%rcx,%rsi,4),%eax\nmovzbl %dh,%esi\nshr    $0x10,%edx\nmov    %esi,%esi\nmovzbl %dl,%edx\nadd    (%rcx,%rsi,4),%eax\nadd    (%rcx,%rdx,4),%eax\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "init_popcount_table", "content": "// ------------------------------\n// Bit-counting Kernel 4: Table lookup\n// ------------------------------\n// Initialize the lookup table for 8-bit popcount.\nvoid init_popcount_table() {\n    for (int i = 0; i < TABLE_SIZE; i++) {\n        unsigned int count = 0;\n        int value = i;\n        while (value) {\n            count += (value & 1);\n            value >>= 1;\n        }\n        popcount_table[i] = count;\n    }\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O2.pseudo", "function_name": "init_popcount_table", "address": "0x1560", "label": "init_popcount_table", "content": "void __cdecl init_popcount_table()\n{\n  __int64 v0; // rsi\n  unsigned int v1; // edx\n  int v2; // eax\n\n  v0 = 0LL;\nLABEL_5:\n  popcount_table[0] = 0;\n  do\n  {\n    ++v0;\n    v1 = 0;\n    v2 = v0;\n    if ( !v0 )\n      goto LABEL_5;\n    do\n    {\n      v1 += v2 & 1;\n      v2 >>= 1;\n    }\n    while ( v2 );\n    popcount_table[v0] = v1;\n  }\n  while ( v0 != 255 );\n}\n"}, "pseudo_normalize": "void init_popcount_table() {\n  long long v0;\n  unsigned int v1;\n  int v2;\n  v0 = 0LL;\nLABEL_5:\n  popcount_table[0] = 0;\n  do {\n    ++v0;\n    v1 = 0;\n    v2 = v0;\n    if (!v0) goto LABEL_5;\n    do {\n      v1 += v2 & 1;\n      v2 >>= 1;\n    } while (v2);\n    popcount_table[v0] = v1;\n  } while (v0 != 255);\n}", "binary": "bit-kernels/bit-kernels.host.O2", "assembly": "<init_popcount_table>:\nendbr64\nxor    %esi,%esi\nlea    0x4d13(%rip),%rdi\nxor    %edx,%edx\nmov    %esi,%eax\ntest   %rsi,%rsi\nje     15a4 <init_popcount_table+0x44>\ncs nopw 0x0(%rax,%rax,1)\nmov    %eax,%ecx\nand    $0x1,%ecx\nadd    %ecx,%edx\nsar    %eax\njne    1580 <init_popcount_table+0x20>\nmov    %edx,(%rdi,%rsi,4)\ncmp    $0xff,%rsi\nje     15b0 <init_popcount_table+0x50>\nadd    $0x1,%rsi\nxor    %edx,%edx\nmov    %esi,%eax\ntest   %rsi,%rsi\njne    1580 <init_popcount_table+0x20>\nmovl   $0x0,0x4cd2(%rip)\njmp    1597 <init_popcount_table+0x37>\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "bit-kernels/bit-kernels.c", "function_name": "main", "content": "// ------------------------------\n// Main testing function\n// ------------------------------\nint main(void) {\n    // Seed random generator\n    libmin_srand(42);\n    \n    // Initialize lookup table for table lookup method.\n    init_popcount_table();\n    \n    // Allocate an array of NUM_ELEMENTS random 32-bit numbers.\n    uint32_t *numbers = libmin_malloc(NUM_ELEMENTS * sizeof(uint32_t));\n    if (numbers == NULL) {\n        libmin_printf(\"ERROR: Memory allocation error!\\n\");\n        return 1;\n    }\n    \n    // Fill the array with random 32-bit numbers.\n    for (size_t i = 0; i < NUM_ELEMENTS; i++) {\n        // Combine two calls to rand() to create a 32-bit number.\n        numbers[i] = ((uint32_t)libmin_rand() << 16) | (libmin_rand() & 0xFFFF);\n    }\n    \n    // Variables to sum total bit counts for each method.\n    unsigned long long total_naive = 0;\n    unsigned long long total_kernighan = 0;\n    unsigned long long total_builtin = 0;\n    unsigned long long total_table = 0;\n    unsigned long long total_parallel = 0;\n    \n    // Process each number.\n    for (size_t i = 0; i < NUM_ELEMENTS; i++) {\n        uint32_t val = numbers[i];\n        unsigned int naive   = count_bits_naive(val);\n        unsigned int kernighan = count_bits_kernighan(val);\n        unsigned int builtin = count_bits_builtin(val);\n        unsigned int table   = count_bits_table(val);\n        unsigned int parallel = count_bits_parallel(val);\n        \n        // Verify that all methods agree.\n        if (naive != kernighan || naive != builtin || naive != table || naive != parallel) {\n            libmin_printf(\"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, table=%u, parallel=%u\\n\",\n                   val, naive, kernighan, builtin, table, parallel);\n        }\n        \n        // Accumulate totals.\n        total_naive   += naive;\n        total_kernighan += kernighan;\n        total_builtin += builtin;\n        total_table   += table;\n        total_parallel += parallel;\n        \n        // For demonstration, print the first 5 numbers with their popcount from each method.\n        if (i < 5) {\n            libmin_printf(\"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, parallel=%2u\\n\",\n                   val, naive, kernighan, builtin, table, parallel);\n        }\n    }\n    \n    // Print overall totals for comparison.\n    libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", NUM_ELEMENTS);\n    libmin_printf(\"Naive         : %llu\\n\", total_naive);\n    libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n    libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n    libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n    libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n    \n    // Clean up\n    libmin_free(numbers);\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "bit-kernels/bit-kernels.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  uint32_t *v3; // r12\n  unsigned int v4; // ebx\n  unsigned __int64 v5; // r11\n  unsigned __int64 v6; // r15\n  uint32_t v7; // ebx\n  uint32_t v8; // r12d\n  unsigned int v9; // r13d\n  uint32_t v10; // eax\n  int v11; // r8d\n  unsigned int v12; // r14d\n  unsigned int v13; // edx\n  unsigned int v14; // ebp\n  const char **v16; // [rsp-8h] [rbp-80h]\n  bool builtin; // [rsp+8h] [rbp-70h]\n  int builtina; // [rsp+8h] [rbp-70h]\n  uint32_t *numbers; // [rsp+10h] [rbp-68h]\n  unsigned __int64 total_builtin; // [rsp+18h] [rbp-60h]\n  unsigned __int64 total_table; // [rsp+20h] [rbp-58h]\n  unsigned __int64 total_parallel; // [rsp+28h] [rbp-50h]\n  unsigned __int64 total_naive; // [rsp+30h] [rbp-48h]\n  unsigned __int64 total_kernighan; // [rsp+38h] [rbp-40h]\n\n  libmin_srand(0x2Au);\n  init_popcount_table();\n  numbers = (uint32_t *)libmin_malloc(0x190uLL);\n  v3 = numbers;\n  if ( numbers )\n  {\n    do\n    {\n      ++v3;\n      v4 = libmin_rand();\n      *(v3 - 1) = (unsigned __int16)libmin_rand() | (v4 << 16);\n    }\n    while ( numbers + 100 != v3 );\n    total_parallel = 0LL;\n    v5 = 0LL;\n    total_table = 0LL;\n    total_builtin = 0LL;\n    total_kernighan = 0LL;\n    total_naive = 0LL;\n    while ( 1 )\n    {\n      v6 = v5;\n      v7 = numbers[v5];\n      if ( v7 )\n      {\n        v8 = numbers[v5];\n        v9 = 0;\n        do\n        {\n          v9 += v8 & 1;\n          v8 >>= 1;\n        }\n        while ( v8 );\n        v10 = numbers[v5];\n        do\n        {\n          ++v8;\n          v10 &= v10 - 1;\n        }\n        while ( v10 );\n        builtin = v8 != v9;\n        total_naive += v9;\n        total_kernighan += v8;\n      }\n      else\n      {\n        builtin = 0;\n        v9 = 0;\n        v8 = 0;\n      }\n      v11 = _popcountdi2(v7, argv);\n      v12 = popcount_table[BYTE2(v7)]\n          + popcount_table[BYTE1(v7)]\n          + popcount_table[(unsigned __int8)v7]\n          + popcount_table[HIBYTE(v7)];\n      v13 = (((v7 - ((v7 >> 1) & 0x55555555)) >> 2) & 0x33333333) + ((v7 - ((v7 >> 1) & 0x55555555)) & 0x33333333);\n      v14 = (16843009 * ((v13 + (v13 >> 4)) & 0xF0F0F0F)) >> 24;\n      if ( v11 != v9 || builtin || v9 != v12 || v9 != v14 )\n      {\n        builtina = v11;\n        libmin_printf(\n          \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, table=%u, parallel=%u\\n\",\n          v7,\n          v9,\n          v8,\n          v11,\n          v12,\n          (16843009 * ((v13 + (v13 >> 4)) & 0xF0F0F0F)) >> 24);\n        argv = v16;\n        v11 = builtina;\n      }\n      v5 = v6 + 1;\n      total_builtin += v11;\n      total_table += v12;\n      total_parallel += v14;\n      if ( v6 <= 4 )\n      {\n        argv = (const char **)v7;\n        libmin_printf(\n          \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, parallel=%2u\\n\",\n          v7,\n          v9,\n          v8,\n          v11,\n          v12,\n          v14);\n        v5 = v6 + 1;\n      }\n      else if ( v6 == 99 )\n      {\n        libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n        libmin_printf(\"Naive         : %llu\\n\", total_naive);\n        libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n        libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n        libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n        libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n        libmin_free(numbers);\n        libmin_success();\n      }\n    }\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  uint32_t *v3;\n  unsigned int v4;\n  unsigned long long v5;\n  unsigned long long v6;\n  uint32_t v7;\n  uint32_t v8;\n  unsigned int v9;\n  uint32_t v10;\n  int v11;\n  unsigned int v12;\n  unsigned int v13;\n  unsigned int v14;\n  const char **v16;\n  bool builtin;\n  int builtina;\n  uint32_t *numbers;\n  unsigned long long total_builtin;\n  unsigned long long total_table;\n  unsigned long long total_parallel;\n  unsigned long long total_naive;\n  unsigned long long total_kernighan;\n  libmin_srand(42u);\n  init_popcount_table();\n  numbers = (uint32_t *)libmin_malloc(400uLL);\n  v3 = numbers;\n  if (numbers) {\n    do {\n      ++v3;\n      v4 = libmin_rand();\n      *(v3 - 1) = (unsigned short)libmin_rand() | (v4 << 16);\n    } while (numbers + 100 != v3);\n    total_parallel = 0LL;\n    v5 = 0LL;\n    total_table = 0LL;\n    total_builtin = 0LL;\n    total_kernighan = 0LL;\n    total_naive = 0LL;\n    while (1) {\n      v6 = v5;\n      v7 = numbers[v5];\n      if (v7) {\n        v8 = numbers[v5];\n        v9 = 0;\n        do {\n          v9 += v8 & 1;\n          v8 >>= 1;\n        } while (v8);\n        v10 = numbers[v5];\n        do {\n          ++v8;\n          v10 &= v10 - 1;\n        } while (v10);\n        builtin = v8 != v9;\n        total_naive += v9;\n        total_kernighan += v8;\n      } else {\n        builtin = 0;\n        v9 = 0;\n        v8 = 0;\n      }\n      v11 = _popcountdi2(v7, argv);\n      v12 = popcount_table[BYTE2(v7)] + popcount_table[BYTE1(v7)] +\n            popcount_table[(unsigned char)v7] + popcount_table[HIBYTE(v7)];\n      v13 = (((v7 - ((v7 >> 1) & 1431655765)) >> 2) & 858993459) +\n            ((v7 - ((v7 >> 1) & 1431655765)) & 858993459);\n      v14 = (16843009 * ((v13 + (v13 >> 4)) & 252645135)) >> 24;\n      if (v11 != v9 || builtin || v9 != v12 || v9 != v14) {\n        builtina = v11;\n        libmin_printf(\n            \"Mismatch for value 0x%08X: naive=%u, kernighan=%u, builtin=%u, \"\n            \"table=%u, parallel=%u\\n\",\n            v7, v9, v8, v11, v12,\n            (16843009 * ((v13 + (v13 >> 4)) & 252645135)) >> 24);\n        argv = v16;\n        v11 = builtina;\n      }\n      v5 = v6 + 1;\n      total_builtin += v11;\n      total_table += v12;\n      total_parallel += v14;\n      if (v6 <= 4) {\n        argv = (const char **)v7;\n        libmin_printf(\n            \"Value 0x%08X: naive=%2u, kernighan=%2u, builtin=%2u, table=%2u, \"\n            \"parallel=%2u\\n\",\n            v7, v9, v8, v11, v12, v14);\n        v5 = v6 + 1;\n      } else if (v6 == 99) {\n        libmin_printf(\"\\nTotal bit count over %d numbers:\\n\", 100);\n        libmin_printf(\"Naive         : %llu\\n\", total_naive);\n        libmin_printf(\"Kernighan     : %llu\\n\", total_kernighan);\n        libmin_printf(\"Built-in      : %llu\\n\", total_builtin);\n        libmin_printf(\"Table Lookup  : %llu\\n\", total_table);\n        libmin_printf(\"Parallel      : %llu\\n\", total_parallel);\n        libmin_free(numbers);\n        libmin_success();\n      }\n    }\n  }\n  libmin_printf(\"ERROR: Memory allocation error!\\n\", argv);\n  return 1;\n}", "binary": "bit-kernels/bit-kernels.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x2a,%edi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\ncall   3050 <libmin_srand>\nxor    %eax,%eax\ncall   1560 <init_popcount_table>\nmov    $0x190,%edi\ncall   18a0 <libmin_malloc>\nmov    %rax,0x10(%rsp)\nmov    %rax,%r12\nlea    0x190(%rax),%rbp\ntest   %rax,%rax\nje     13df <main+0x2bf>\nnopl   (%rax)\ncall   30b0 <libmin_rand>\nadd    $0x4,%r12\nmov    %eax,%ebx\ncall   30b0 <libmin_rand>\nshl    $0x10,%ebx\nmovzwl %ax,%eax\nor     %eax,%ebx\nmov    %ebx,-0x4(%r12)\ncmp    %r12,%rbp\njne    1168 <main+0x48>\nmovq   $0x0,0x28(%rsp)\nxor    %r11d,%r11d\nmovq   $0x0,0x20(%rsp)\nmovq   $0x0,0x18(%rsp)\nmovq   $0x0,0x38(%rsp)\nmovq   $0x0,0x30(%rsp)\nnopw   0x0(%rax,%rax,1)\nmov    0x10(%rsp),%rax\nmov    %r11,%r15\nmov    (%rax,%r11,4),%ebx\ntest   %ebx,%ebx\nje     13a0 <main+0x280>\nmov    %ebx,%r12d\nxor    %r13d,%r13d\nnopw   0x0(%rax,%rax,1)\nmov    %r12d,%eax\nand    $0x1,%eax\nadd    %eax,%r13d\nshr    %r12d\njne    11e0 <main+0xc0>\nmov    %ebx,%eax\nlea    -0x1(%rax),%edx\nadd    $0x1,%r12d\nand    %edx,%eax\njne    11f0 <main+0xd0>\ncmp    %r13d,%r12d\nmov    %r13d,%eax\nsetne  0x8(%rsp)\nadd    %rax,0x30(%rsp)\nmov    %r12d,%eax\nadd    %rax,0x38(%rsp)\nmov    %ebx,%edi\ncall   32f0 <__popcountdi2>\nmov    %ebx,%edx\nlea    0x505d(%rip),%r10\nshr    $0x18,%edx\nmov    %eax,%r8d\nmovzbl %bl,%eax\nmov    (%r10,%rdx,4),%r14d\nadd    (%r10,%rax,4),%r14d\nmovzbl %bh,%eax\nmov    %ebx,%edx\nmov    %eax,%eax\nshr    %edx\nadd    (%r10,%rax,4),%r14d\nmov    %ebx,%eax\nand    $0x55555555,%edx\nshr    $0x10,%eax\nmovzbl %al,%eax\nadd    (%r10,%rax,4),%r14d\nmov    %ebx,%eax\nsub    %edx,%eax\nmov    %eax,%edx\nshr    $0x2,%eax\nand    $0x33333333,%edx\nand    $0x33333333,%eax\nadd    %eax,%edx\nmov    %edx,%ebp\nshr    $0x4,%ebp\nadd    %edx,%ebp\nand    $0xf0f0f0f,%ebp\nimul   $0x1010101,%ebp,%ebp\nshr    $0x18,%ebp\ncmp    %r13d,%r8d\njne    1370 <main+0x250>\ncmpb   $0x0,0x8(%rsp)\njne    1370 <main+0x250>\ncmp    %r14d,%r13d\njne    1370 <main+0x250>\ncmp    %ebp,%r13d\njne    1370 <main+0x250>\nmovslq %r8d,%rax\nlea    0x1(%r15),%r11\nadd    %rax,0x18(%rsp)\nmov    %r14d,%eax\nadd    %rax,0x20(%rsp)\nmov    %ebp,%eax\nadd    %rax,0x28(%rsp)\ncmp    $0x4,%r15\njbe    13b0 <main+0x290>\ncmp    $0x64,%r11\njne    11c0 <main+0xa0>\nmov    $0x64,%esi\nlea    0x2df8(%rip),%rdi\nxor    %eax,%eax\ncall   2e40 <libmin_printf>\nmov    0x30(%rsp),%rsi\nlea    0x2e08(%rip),%rdi\nxor    %eax,%eax\ncall   2e40 <libmin_printf>\nmov    0x38(%rsp),%rsi\nlea    0x2e0b(%rip),%rdi\nxor    %eax,%eax\ncall   2e40 <libmin_printf>\nmov    0x18(%rsp),%rsi\nlea    0x2e0e(%rip),%rdi\nxor    %eax,%eax\ncall   2e40 <libmin_printf>\nmov    0x20(%rsp),%rsi\nlea    0x2e11(%rip),%rdi\nxor    %eax,%eax\ncall   2e40 <libmin_printf>\nmov    0x28(%rsp),%rsi\nlea    0x2e14(%rip),%rdi\nxor    %eax,%eax\ncall   2e40 <libmin_printf>\nmov    0x10(%rsp),%rdi\ncall   1950 <libmin_free>\ncall   3290 <libmin_success>\nxor    %eax,%eax\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\nsub    $0x8,%rsp\nmov    %r12d,%ecx\nmov    %ebx,%esi\nmov    %r14d,%r9d\npush   %rbp\nmov    %r13d,%edx\nlea    0x2ca9(%rip),%rdi\nxor    %eax,%eax\nmov    %r8d,0x18(%rsp)\ncall   2e40 <libmin_printf>\npop    %rcx\npop    %rsi\nmov    0x8(%rsp),%r8d\njmp    12a5 <main+0x185>\nnop\nmovb   $0x0,0x8(%rsp)\nxor    %r13d,%r13d\nxor    %r12d,%r12d\njmp    1213 <main+0xf3>\nmov    %r11,0x8(%rsp)\nsub    $0x8,%rsp\nmov    %r13d,%edx\nmov    %r14d,%r9d\npush   %rbp\nmov    %r12d,%ecx\nmov    %ebx,%esi\nlea    0x2cbc(%rip),%rdi\nxor    %eax,%eax\ncall   2e40 <libmin_printf>\npop    %rax\npop    %rdx\nmov    0x8(%rsp),%r11\njmp    11c0 <main+0xa0>\nlea    0x2c22(%rip),%rdi\ncall   2e40 <libmin_printf>\nmov    $0x1,%eax\njmp    1357 <main+0x237>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "F", "content": "/**\n * @brief compression function F\n *\n * Securely mixes the values in block m into\n * the state vector h. Value at v[14] is also\n * inverted if this is the final block to be\n * compressed.\n *\n * @param h the state vector\n * @param m message vector to be compressed into h\n * @param t 128-bit offset counter\n * @param f flag to indicate whether this is the final block\n *\n * @returns void\n */\nstatic void F(uint64_t h[8], block_t m, u128 t, int f)\n{\n    int i;\n    block_t v;\n\n    /* v[0..7] := h[0..7] */\n    for (i = 0; i < 8; i++)\n    {\n        v[i] = h[i];\n    }\n    /* v[8..15] := IV[0..7] */\n    for (; i < 16; i++)\n    {\n        v[i] = blake2b_iv[i - 8];\n    }\n\n    v[12] ^= t[0]; /* v[12] ^ (t mod 2**w) */\n    v[13] ^= t[1]; /* v[13] ^ (t >> w) */\n\n    if (f)\n    {\n        v[14] = ~v[14];\n    }\n\n    for (i = 0; i < 12; i++)\n    {\n        const uint8_t *s = blake2b_sigma[i];\n\n        G(v, 0, 4, 8, 12, m[s[0]], m[s[1]]);\n        G(v, 1, 5, 9, 13, m[s[2]], m[s[3]]);\n        G(v, 2, 6, 10, 14, m[s[4]], m[s[5]]);\n        G(v, 3, 7, 11, 15, m[s[6]], m[s[7]]);\n\n        G(v, 0, 5, 10, 15, m[s[8]], m[s[9]]);\n        G(v, 1, 6, 11, 12, m[s[10]], m[s[11]]);\n        G(v, 2, 7, 8, 13, m[s[12]], m[s[13]]);\n        G(v, 3, 4, 9, 14, m[s[14]], m[s[15]]);\n    }\n\n    for (i = 0; i < 8; i++)\n    {\n        h[i] ^= v[i] ^ v[i + 8];\n    }\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O2.pseudo", "function_name": "F", "address": "0x12a0", "label": "F", "content": "void __fastcall F(uint64_t *h, uint64_t *m, uint64_t *t, int f)\n{\n  uint64_t *v4; // r12\n  __m128i v5; // xmm1\n  __m128i v6; // xmm2\n  __m128i v7; // xmm3\n  uint64_t v8; // rax\n  __int64 v9; // rdx\n  __int64 v10; // rax\n  __int64 v11; // r11\n  __int64 v12; // r11\n  __int64 v13; // r11\n  __int64 v14; // r11\n  __int64 v15; // r11\n  __int64 v16; // r11\n  __int64 v17; // r11\n  const uint8_t *v18; // r11\n  uint64_t *v19; // rdx\n  uint64_t v20; // rax\n  block_t v; // [rsp+0h] [rbp-B8h] BYREF\n  char v22; // [rsp+80h] [rbp-38h] BYREF\n  unsigned __int64 v23; // [rsp+88h] [rbp-30h]\n\n  v4 = h;\n  v5 = _mm_loadu_si128((const __m128i *)h + 1);\n  v23 = __readfsqword(0x28u);\n  v6 = _mm_loadu_si128((const __m128i *)h + 2);\n  v7 = _mm_loadu_si128((const __m128i *)h + 3);\n  *(__m128i *)v = _mm_loadu_si128((const __m128i *)h);\n  v[8] = 0x6A09E667F3BCC908LL;\n  v[9] = 0xBB67AE8584CAA73BLL;\n  v[10] = 0x3C6EF372FE94F82BLL;\n  v[11] = 0xA54FF53A5F1D36F1LL;\n  v[15] = 0x5BE0CD19137E2179LL;\n  v[12] = *t ^ 0x510E527FADE682D1LL;\n  v[13] = t[1] ^ 0x9B05688C2B3E6C1FLL;\n  v8 = 0xE07C265404BE4294LL;\n  if ( !f )\n    v8 = 0x1F83D9ABFB41BD6BLL;\n  *(__m128i *)&v[2] = v5;\n  v9 = 0LL;\n  *(__m128i *)&v[4] = v6;\n  v[14] = v8;\n  v10 = 1LL;\n  *(__m128i *)&v[6] = v7;\n  while ( 1 )\n  {\n    G(v, 0, 4u, 8u, 0xCu, m[v9], m[v10]);\n    G(v, 1u, 5u, 9u, 0xDu, m[*(unsigned __int8 *)(v11 - 16)], m[*(unsigned __int8 *)(v11 - 15)]);\n    G(v, 2u, 6u, 0xAu, 0xEu, m[*(unsigned __int8 *)(v12 - 14)], m[*(unsigned __int8 *)(v12 - 13)]);\n    G(v, 3u, 7u, 0xBu, 0xFu, m[*(unsigned __int8 *)(v13 - 12)], m[*(unsigned __int8 *)(v13 - 11)]);\n    G(v, 0, 5u, 0xAu, 0xFu, m[*(unsigned __int8 *)(v14 - 10)], m[*(unsigned __int8 *)(v14 - 9)]);\n    G(v, 1u, 6u, 0xBu, 0xCu, m[*(unsigned __int8 *)(v15 - 8)], m[*(unsigned __int8 *)(v15 - 7)]);\n    G(v, 2u, 7u, 8u, 0xDu, m[*(unsigned __int8 *)(v16 - 6)], m[*(unsigned __int8 *)(v16 - 5)]);\n    G(v, 3u, 4u, 9u, 0xEu, m[*(unsigned __int8 *)(v17 - 4)], m[*(unsigned __int8 *)(v17 - 3)]);\n    if ( v18 == &blake2b_sigma[12][2] )\n      break;\n    v10 = *(v18 - 1);\n    v9 = *(v18 - 2);\n  }\n  v19 = &v[8];\n  do\n  {\n    v20 = *(++v19 - 9) ^ *v4;\n    *v4++ = *(v19 - 1) ^ v20;\n  }\n  while ( v19 != (uint64_t *)&v22 );\n}\n"}, "pseudo_normalize": "void F(uint64_t *h, uint64_t *m, uint64_t *t, int f) {\n  uint64_t *v4;\n  __m128i v5;\n  __m128i v6;\n  __m128i v7;\n  uint64_t v8;\n  long long v9;\n  long long v10;\n  long long v11;\n  long long v12;\n  long long v13;\n  long long v14;\n  long long v15;\n  long long v16;\n  long long v17;\n  const uint8_t *v18;\n  uint64_t *v19;\n  uint64_t v20;\n  block_t v;\n  char v22;\n  unsigned long long v23;\n  v4 = h;\n  v5 = _mm_loadu_si128((const __m128i *)h + 1);\n  v23 = __readfsqword(40u);\n  v6 = _mm_loadu_si128((const __m128i *)h + 2);\n  v7 = _mm_loadu_si128((const __m128i *)h + 3);\n  *(__m128i *)v = _mm_loadu_si128((const __m128i *)h);\n  v[8] = 7640891576956012808LL;\n  v[9] = 13503953896175478587LL;\n  v[10] = 4354685564936845355LL;\n  v[11] = 11912009170470909681LL;\n  v[15] = 6620516959819538809LL;\n  v[12] = *t ^ 5840696475078001361LL;\n  v[13] = t[1] ^ 11170449401992604703LL;\n  v8 = 16175846103906665108LL;\n  if (!f) v8 = 2270897969802886507LL;\n  *(__m128i *)&v[2] = v5;\n  v9 = 0LL;\n  *(__m128i *)&v[4] = v6;\n  v[14] = v8;\n  v10 = 1LL;\n  *(__m128i *)&v[6] = v7;\n  while (1) {\n    G(v, 0, 4u, 8u, 12u, m[v9], m[v10]);\n    G(v, 1u, 5u, 9u, 13u, m[*(unsigned char *)(v11 - 16)],\n      m[*(unsigned char *)(v11 - 15)]);\n    G(v, 2u, 6u, 10u, 14u, m[*(unsigned char *)(v12 - 14)],\n      m[*(unsigned char *)(v12 - 13)]);\n    G(v, 3u, 7u, 11u, 15u, m[*(unsigned char *)(v13 - 12)],\n      m[*(unsigned char *)(v13 - 11)]);\n    G(v, 0, 5u, 10u, 15u, m[*(unsigned char *)(v14 - 10)],\n      m[*(unsigned char *)(v14 - 9)]);\n    G(v, 1u, 6u, 11u, 12u, m[*(unsigned char *)(v15 - 8)],\n      m[*(unsigned char *)(v15 - 7)]);\n    G(v, 2u, 7u, 8u, 13u, m[*(unsigned char *)(v16 - 6)],\n      m[*(unsigned char *)(v16 - 5)]);\n    G(v, 3u, 4u, 9u, 14u, m[*(unsigned char *)(v17 - 4)],\n      m[*(unsigned char *)(v17 - 3)]);\n    if (v18 == &blake2b_sigma[12][2]) break;\n    v10 = *(v18 - 1);\n    v9 = *(v18 - 2);\n  }\n  v19 = &v[8];\n  do {\n    v20 = *(++v19 - 9) ^ *v4;\n    *v4++ = *(v19 - 1) ^ v20;\n  } while (v19 != (uint64_t *)&v22);\n}", "binary": "blake2b/blake2b.host.O2", "assembly": "<F>:\npush   %r13\nlea    0x2db9(%rip),%r11\npush   %r12\nlea    0xc0(%r11),%r13\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x98,%rsp\nmovdqu (%rdi),%xmm0\nmovdqu 0x10(%rdi),%xmm1\nmov    %fs:0x28,%rax\nmov    %rax,0x88(%rsp)\nxor    %eax,%eax\nmovdqu 0x20(%rdi),%xmm2\nmovdqu 0x30(%rdi),%xmm3\nmov    %rsp,%rbp\nmovabs $0x6a09e667f3bcc908,%rax\nmovaps %xmm0,(%rsp)\nmov    %rax,0x40(%rsp)\nmovabs $0xbb67ae8584caa73b,%rax\nmov    %rax,0x48(%rsp)\nmovabs $0x3c6ef372fe94f82b,%rax\nmov    %rax,0x50(%rsp)\nmovabs $0xa54ff53a5f1d36f1,%rax\nmov    %rax,0x58(%rsp)\nmovabs $0x5be0cd19137e2179,%rax\nmov    %rax,0x78(%rsp)\nmovabs $0x510e527fade682d1,%rax\nxor    (%rdx),%rax\nmov    %rax,0x60(%rsp)\nmovabs $0x9b05688c2b3e6c1f,%rax\nxor    0x8(%rdx),%rax\ntest   %ecx,%ecx\nmovabs $0x1f83d9abfb41bd6b,%rdx\nmov    %rax,0x68(%rsp)\nmovabs $0xe07c265404be4294,%rax\ncmove  %rdx,%rax\nmovaps %xmm1,0x10(%rsp)\nxor    %edx,%edx\nmovaps %xmm2,0x20(%rsp)\nmov    %rax,0x70(%rsp)\nmov    $0x1,%eax\nmovaps %xmm3,0x30(%rsp)\njmp    13a2 <F+0x102>\nnopl   (%rax)\nmovzbl -0x1(%r11),%eax\nmovzbl -0x2(%r11),%edx\npush   (%rbx,%rax,8)\nmov    (%rbx,%rdx,8),%r9\nmov    $0xc,%r8d\nxor    %esi,%esi\nmov    $0x8,%ecx\nmov    $0x4,%edx\nmov    %rbp,%rdi\nadd    $0x10,%r11\ncall   1230 <G>\nmovzbl -0xf(%r11),%edx\nmovzbl -0x10(%r11),%eax\nmov    $0xd,%r8d\nmov    $0x9,%ecx\nmov    $0x1,%esi\nmov    %rbp,%rdi\npush   (%rbx,%rdx,8)\nmov    (%rbx,%rax,8),%r9\nmov    $0x5,%edx\ncall   1230 <G>\nmovzbl -0xd(%r11),%edx\nmovzbl -0xe(%r11),%eax\nmov    $0xe,%r8d\nmov    $0xa,%ecx\nmov    $0x2,%esi\nmov    %rbp,%rdi\npush   (%rbx,%rdx,8)\nmov    (%rbx,%rax,8),%r9\nmov    $0x6,%edx\ncall   1230 <G>\nmovzbl -0xb(%r11),%edx\nmovzbl -0xc(%r11),%eax\nmov    $0xf,%r8d\nmov    $0xb,%ecx\nmov    $0x3,%esi\nmov    %rbp,%rdi\npush   (%rbx,%rdx,8)\nmov    (%rbx,%rax,8),%r9\nmov    $0x7,%edx\ncall   1230 <G>\nmovzbl -0x9(%r11),%edx\nadd    $0x20,%rsp\nxor    %esi,%esi\nmovzbl -0xa(%r11),%eax\nmov    $0xf,%r8d\nmov    $0xa,%ecx\nmov    %rbp,%rdi\npush   (%rbx,%rdx,8)\nmov    $0x5,%edx\nmov    (%rbx,%rax,8),%r9\ncall   1230 <G>\nmovzbl -0x7(%r11),%edx\nmovzbl -0x8(%r11),%eax\nmov    $0xc,%r8d\nmov    $0xb,%ecx\nmov    $0x1,%esi\nmov    %rbp,%rdi\npush   (%rbx,%rdx,8)\nmov    (%rbx,%rax,8),%r9\nmov    $0x6,%edx\ncall   1230 <G>\nmovzbl -0x5(%r11),%edx\nmovzbl -0x6(%r11),%eax\nmov    $0xd,%r8d\nmov    $0x8,%ecx\nmov    $0x2,%esi\nmov    %rbp,%rdi\npush   (%rbx,%rdx,8)\nmov    (%rbx,%rax,8),%r9\nmov    $0x7,%edx\ncall   1230 <G>\nmovzbl -0x3(%r11),%edx\nmovzbl -0x4(%r11),%eax\nmov    $0xe,%r8d\nmov    $0x9,%ecx\nmov    $0x3,%esi\nmov    %rbp,%rdi\npush   (%rbx,%rdx,8)\nmov    (%rbx,%rax,8),%r9\nmov    $0x4,%edx\ncall   1230 <G>\nadd    $0x20,%rsp\ncmp    %r13,%r11\njne    1398 <F+0xf8>\nlea    0x40(%rsp),%rdx\nlea    0x80(%rsp),%rcx\nnopl   0x0(%rax)\nmov    (%r12),%rax\nadd    $0x8,%rdx\nxor    -0x48(%rdx),%rax\nadd    $0x8,%r12\nxor    -0x8(%rdx),%rax\nmov    %rax,-0x8(%r12)\ncmp    %rcx,%rdx\njne    1528 <F+0x288>\nmov    0x88(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1567 <F+0x2c7>\nadd    $0x98,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax)\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "G", "content": "/**\n * @brief blake2b mixing function G\n *\n * Shuffles values in block v depending on\n * provided indeces a, b, c, and d. x and y\n * are also mixed into the block.\n *\n * @param v array of words to be mixed\n * @param a first index\n * @param b second index\n * @param c third index\n * @param d fourth index\n * @param x first word being mixed into v\n * @param y second word being mixed into y\n *\n * @returns void\n */\nstatic void G(block_t v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x,\n              uint64_t y)\n{\n    v[a] += v[b] + x;\n    v[d] = ROTR64(v[d] ^ v[a], R1);\n    v[c] += v[d];\n    v[b] = ROTR64(v[b] ^ v[c], R2);\n    v[a] += v[b] + y;\n    v[d] = ROTR64(v[d] ^ v[a], R3);\n    v[c] += v[d];\n    v[b] = ROTR64(v[b] ^ v[c], R4);\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O2.pseudo", "function_name": "G", "address": "0x1230", "label": "G", "content": "void __fastcall G(uint64_t *v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x, uint64_t y)\n{\n  uint64_t *v7; // rdx\n  uint64_t *v8; // rsi\n  __int64 v9; // r10\n  uint64_t *v10; // rcx\n  uint64_t *v11; // rdi\n  uint64_t v12; // r9\n  uint64_t v13; // r9\n  uint64_t v14; // r9\n  uint64_t v15; // r9\n  uint64_t v16; // rax\n  uint64_t v17; // rax\n  uint64_t v18; // rax\n\n  v7 = &v[b];\n  v8 = &v[a];\n  v9 = c;\n  v10 = &v[d];\n  v11 = &v[v9];\n  v12 = *v8 + *v7 + x;\n  *v8 = v12;\n  v13 = __ROL8__(*v10 ^ v12, 32);\n  *v10 = v13;\n  v14 = *v11 + v13;\n  *v11 = v14;\n  v15 = __ROR8__(*v7 ^ v14, 24);\n  *v7 = v15;\n  v16 = v15 + y + *v8;\n  *v8 = v16;\n  v17 = __ROR8__(*v10 ^ v16, 16);\n  *v10 = v17;\n  v18 = *v11 + v17;\n  *v11 = v18;\n  *v7 = __ROL8__(*v7 ^ v18, 1);\n}\n"}, "pseudo_normalize": "void G(uint64_t *v, uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint64_t x,\n       uint64_t y) {\n  uint64_t *v7;\n  uint64_t *v8;\n  long long v9;\n  uint64_t *v10;\n  uint64_t *v11;\n  uint64_t v12;\n  uint64_t v13;\n  uint64_t v14;\n  uint64_t v15;\n  uint64_t v16;\n  uint64_t v17;\n  uint64_t v18;\n  v7 = &v[b];\n  v8 = &v[a];\n  v9 = c;\n  v10 = &v[d];\n  v11 = &v[v9];\n  v12 = *v8 + *v7 + x;\n  *v8 = v12;\n  v13 = __ROL8__(*v10 ^ v12, 32);\n  *v10 = v13;\n  v14 = *v11 + v13;\n  *v11 = v14;\n  v15 = __ROR8__(*v7 ^ v14, 24);\n  *v7 = v15;\n  v16 = v15 + y + *v8;\n  *v8 = v16;\n  v17 = __ROR8__(*v10 ^ v16, 16);\n  *v10 = v17;\n  v18 = *v11 + v17;\n  *v11 = v18;\n  *v7 = __ROL8__(*v7 ^ v18, 1);\n}", "binary": "blake2b/blake2b.host.O2", "assembly": "<G>:\nmovzbl %sil,%esi\nmovzbl %dl,%edx\nmovzbl %r8b,%r8d\nmov    %ecx,%r10d\nlea    (%rdi,%rdx,8),%rdx\nlea    (%rdi,%rsi,8),%rsi\nmovzbl %r10b,%r10d\nadd    (%rdx),%r9\nlea    (%rdi,%r8,8),%rcx\nlea    (%rdi,%r10,8),%rdi\nadd    (%rsi),%r9\nmov    %r9,(%rsi)\nxor    (%rcx),%r9\nrol    $0x20,%r9\nmov    %r9,(%rcx)\nadd    (%rdi),%r9\nmov    %r9,(%rdi)\nxor    (%rdx),%r9\nror    $0x18,%r9\nmov    %r9,(%rdx)\nmov    (%rsi),%rax\nadd    0x8(%rsp),%rax\nadd    %r9,%rax\nmov    %rax,(%rsi)\nxor    (%rcx),%rax\nror    $0x10,%rax\nmov    %rax,(%rcx)\nadd    (%rdi),%rax\nmov    %rax,(%rdi)\nxor    (%rdx),%rax\nrol    %rax\nmov    %rax,(%rdx)\nret\nnopl   (%rax)\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "blake2b", "content": "/**\n * @brief blake2b hash function\n *\n * This is the front-end function that sets up the argument for BLAKE2B().\n *\n * @param message the message to be hashed\n * @param len length of message (0 <= len < 2**128) (depends on sizeof(size_t)\n * for this implementation)\n * @param key optional secret key\n * @param kk length of optional secret key (0 <= kk <= 64)\n * @param nn length of output digest (1 <= nn < 64)\n *\n * @returns NULL if heap memory couldn't be allocated. Otherwise heap allocated\n * memory nn bytes large\n */\nuint8_t *blake2b(const uint8_t *message, size_t len, const uint8_t *key,\n                 uint8_t kk, uint8_t nn)\n{\n    uint8_t *dest = NULL;\n    uint64_t long_hold;\n    size_t dd, has_key, i;\n    size_t block_index, word_in_block;\n    u128 ll;\n    block_t *blocks;\n\n    if (message == NULL)\n    {\n        len = 0;\n    }\n    if (key == NULL)\n    {\n        kk = 0;\n    }\n\n    kk = MIN(kk, KK_MAX);\n    nn = MIN(nn, NN_MAX);\n\n    dd = MAX(CEIL(kk, bb) + CEIL(len, bb), 1);\n\n    blocks = libmin_calloc(dd, sizeof(block_t));\n    if (blocks == NULL)\n    {\n        return NULL;\n    }\n\n    dest = libmin_malloc(nn * sizeof(uint8_t));\n    if (dest == NULL)\n    {\n        libmin_free(blocks);\n        return NULL;\n    }\n\n    /* If there is a secret key it occupies the first block */\n    for (i = 0; i < kk; i++)\n    {\n        long_hold = key[i];\n        long_hold <<= 8 * (i % 8);\n\n        word_in_block = (i % bb) / 8;\n        /* block_index will always be 0 because kk <= 64 and bb = 128*/\n        blocks[0][word_in_block] |= long_hold;\n    }\n\n    has_key = kk > 0 ? 1 : 0;\n\n    for (i = 0; i < len; i++)\n    {\n        /* long_hold exists because the bit-shifting will overflow if we don't\n         * store the value */\n        long_hold = message[i];\n        long_hold <<= 8 * (i % 8);\n\n        block_index = has_key + (i / bb);\n        word_in_block = (i % bb) / 8;\n\n        blocks[block_index][word_in_block] |= long_hold;\n    }\n\n    u128_fill(ll, len);\n\n    BLAKE2B(dest, blocks, dd, ll, kk, nn);\n\n    libmin_free(blocks);\n\n    return dest;\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O2.pseudo", "function_name": "blake2b", "address": "0x1620", "label": "blake2b", "content": "uint8_t *__fastcall blake2b(const uint8_t *message, size_t len, const uint8_t *key, uint8_t kk, uint8_t nn)\n{\n  size_t v7; // rbx\n  size_t v8; // rbp\n  uint8_t v9; // al\n  __int64 v10; // rdx\n  uint8_t v11; // al\n  size_t v12; // r13\n  uint8_t v13; // r12\n  uint64_t *v14; // r13\n  uint8_t *v15; // r12\n  unsigned __int64 v16; // rax\n  char v17; // cl\n  __int64 v18; // rsi\n  unsigned __int64 v19; // rdi\n  unsigned __int64 v20; // rsi\n  __int64 v21; // r8\n  unsigned __int64 v22; // rax\n  unsigned __int64 v23; // rdi\n  char v24; // cl\n  unsigned __int64 v25; // rbx\n  uint64_t *v26; // r12\n  uint64_t v27; // rax\n  unsigned __int64 v28; // rsi\n  __int64 v29; // rdx\n  uint64_t v30; // r8\n  uint8_t dest; // [rsp+0h] [rbp-D8h]\n  uint8_t *desta; // [rsp+0h] [rbp-D8h]\n  size_t dd; // [rsp+8h] [rbp-D0h]\n  uint8_t kka; // [rsp+17h] [rbp-C1h]\n  uint8_t nna; // [rsp+18h] [rbp-C0h]\n  size_t nnb; // [rsp+18h] [rbp-C0h]\n  __int64 v39; // [rsp+20h] [rbp-B8h]\n  __int64 v40; // [rsp+28h] [rbp-B0h]\n  u128 ll; // [rsp+30h] [rbp-A8h] BYREF\n  uint64_t t; // [rsp+40h] [rbp-98h] BYREF\n  __int64 v43; // [rsp+48h] [rbp-90h]\n  uint64_t h[17]; // [rsp+50h] [rbp-88h] BYREF\n\n  kka = kk;\n  h[9] = __readfsqword(0x28u);\n  if ( message )\n  {\n    v7 = len;\n    v8 = ((len & 0x7F) != 0) + (len >> 7);\n  }\n  else\n  {\n    v8 = 0LL;\n    v7 = 0LL;\n  }\n  if ( key )\n  {\n    v9 = 64;\n    v10 = kk != 0;\n    v8 += v10;\n    if ( kk <= 0x40u )\n      v9 = kk;\n    dest = v9;\n  }\n  else\n  {\n    dest = 0;\n    v10 = 0LL;\n    kka = 0;\n  }\n  v39 = v10;\n  v11 = 64;\n  v12 = 1LL;\n  if ( nn <= 0x40u )\n    v11 = nn;\n  if ( v8 )\n    v12 = v8;\n  nna = v11;\n  v13 = v11;\n  dd = v12;\n  v14 = (uint64_t *)libmin_calloc(v12, 0x80uLL);\n  if ( !v14 )\n    return 0LL;\n  v40 = v13;\n  v15 = (uint8_t *)libmin_malloc(v13);\n  if ( v15 )\n  {\n    v16 = 0LL;\n    if ( dest )\n    {\n      do\n      {\n        v17 = v16;\n        v18 = key[v16];\n        v19 = v16++;\n        v14[v19 >> 3] |= v18 << (8 * (v17 & 7u));\n      }\n      while ( v16 != dest );\n    }\n    v20 = 0LL;\n    if ( v7 )\n    {\n      do\n      {\n        v21 = message[v20];\n        v22 = v20 >> 7;\n        v23 = v20 >> 3;\n        v24 = v20++ & 7;\n        v14[16 * v39 + 16 * v22 + (v23 & 0xF)] |= v21 << (8 * v24);\n      }\n      while ( v7 != v20 );\n    }\n    ll[0] = v7;\n    h[1] = 0xBB67AE8584CAA73BLL;\n    h[2] = 0x3C6EF372FE94F82BLL;\n    h[3] = 0xA54FF53A5F1D36F1LL;\n    h[4] = 0x510E527FADE682D1LL;\n    h[5] = 0x9B05688C2B3E6C1FLL;\n    h[6] = 0x1F83D9ABFB41BD6BLL;\n    h[7] = 0x5BE0CD19137E2179LL;\n    ll[1] = 0LL;\n    t = 0LL;\n    v43 = 0LL;\n    h[0] = nna ^ (dest << 8) ^ 0x1010000u ^ 0x6A09E667F3BCC908LL;\n    if ( v8 > 1 )\n    {\n      desta = v15;\n      nnb = v7;\n      v25 = 0LL;\n      v26 = v14;\n      v27 = 0LL;\n      while ( 1 )\n      {\n        ++v25;\n        t = v27 + 128;\n        F(h, v26, &t, 0);\n        if ( v25 >= dd - 1 )\n          break;\n        v27 = t;\n        if ( t > 0xFFFFFFFFFFFFFF7ELL )\n          ++v43;\n        v26 += 16;\n      }\n      v15 = desta;\n      v7 = nnb;\n    }\n    if ( kka )\n    {\n      if ( v7 > 0xFFFFFFFFFFFFFF7ELL )\n        ll[1] = 1LL;\n      ll[0] = v7 + 128;\n    }\n    F(h, &v14[16 * dd - 16], ll, 1);\n    v28 = 0LL;\n    if ( nn )\n    {\n      do\n      {\n        if ( (v28 & 7) == 0 )\n        {\n          v29 = 0LL;\n          v30 = h[v28 >> 3];\n          do\n          {\n            *((_BYTE *)&h[8] + v29) = (v30 & (255LL << (8 * (unsigned __int8)v29))) >> (8 * (unsigned __int8)v29);\n            ++v29;\n          }\n          while ( v29 != 8 );\n        }\n        v15[v28] = *((_BYTE *)&h[8] + (v28 & 7));\n        ++v28;\n      }\n      while ( v40 != v28 );\n    }\n  }\n  libmin_free(v14);\n  return v15;\n}\n"}, "pseudo_normalize": "uint8_t *blake2b(const uint8_t *message, unsigned int len, const uint8_t *key,\n                 uint8_t kk, uint8_t nn) {\n  unsigned int v7;\n  unsigned int v8;\n  uint8_t v9;\n  long long v10;\n  uint8_t v11;\n  unsigned int v12;\n  uint8_t v13;\n  uint64_t *v14;\n  uint8_t *v15;\n  unsigned long long v16;\n  char v17;\n  long long v18;\n  unsigned long long v19;\n  unsigned long long v20;\n  long long v21;\n  unsigned long long v22;\n  unsigned long long v23;\n  char v24;\n  unsigned long long v25;\n  uint64_t *v26;\n  uint64_t v27;\n  unsigned long long v28;\n  long long v29;\n  uint64_t v30;\n  uint8_t dest;\n  uint8_t *desta;\n  unsigned int dd;\n  uint8_t kka;\n  uint8_t nna;\n  unsigned int nnb;\n  long long v39;\n  long long v40;\n  u128 ll;\n  uint64_t t;\n  long long v43;\n  uint64_t h[17];\n  kka = kk;\n  h[9] = __readfsqword(40u);\n  if (message) {\n    v7 = len;\n    v8 = ((len & 127) != 0) + (len >> 7);\n  } else {\n    v8 = 0LL;\n    v7 = 0LL;\n  }\n  if (key) {\n    v9 = 64;\n    v10 = kk != 0;\n    v8 += v10;\n    if (kk <= 64u) v9 = kk;\n    dest = v9;\n  } else {\n    dest = 0;\n    v10 = 0LL;\n    kka = 0;\n  }\n  v39 = v10;\n  v11 = 64;\n  v12 = 1LL;\n  if (nn <= 64u) v11 = nn;\n  if (v8) v12 = v8;\n  nna = v11;\n  v13 = v11;\n  dd = v12;\n  v14 = (uint64_t *)libmin_calloc(v12, 128uLL);\n  if (!v14) return 0LL;\n  v40 = v13;\n  v15 = (uint8_t *)libmin_malloc(v13);\n  if (v15) {\n    v16 = 0LL;\n    if (dest) {\n      do {\n        v17 = v16;\n        v18 = key[v16];\n        v19 = v16++;\n        v14[v19 >> 3] |= v18 << (8 * (v17 & 7u));\n      } while (v16 != dest);\n    }\n    v20 = 0LL;\n    if (v7) {\n      do {\n        v21 = message[v20];\n        v22 = v20 >> 7;\n        v23 = v20 >> 3;\n        v24 = v20++ & 7;\n        v14[16 * v39 + 16 * v22 + (v23 & 15)] |= v21 << (8 * v24);\n      } while (v7 != v20);\n    }\n    ll[0] = v7;\n    h[1] = 13503953896175478587LL;\n    h[2] = 4354685564936845355LL;\n    h[3] = 11912009170470909681LL;\n    h[4] = 5840696475078001361LL;\n    h[5] = 11170449401992604703LL;\n    h[6] = 2270897969802886507LL;\n    h[7] = 6620516959819538809LL;\n    ll[1] = 0LL;\n    t = 0LL;\n    v43 = 0LL;\n    h[0] = nna ^ (dest << 8) ^ 16842752u ^ 7640891576956012808LL;\n    if (v8 > 1) {\n      desta = v15;\n      nnb = v7;\n      v25 = 0LL;\n      v26 = v14;\n      v27 = 0LL;\n      while (1) {\n        ++v25;\n        t = v27 + 128;\n        F(h, v26, &t, 0);\n        if (v25 >= dd - 1) break;\n        v27 = t;\n        if (t > 18446744073709551486LL) ++v43;\n        v26 += 16;\n      }\n      v15 = desta;\n      v7 = nnb;\n    }\n    if (kka) {\n      if (v7 > 18446744073709551486LL) ll[1] = 1LL;\n      ll[0] = v7 + 128;\n    }\n    F(h, &v14[16 * dd - 16], ll, 1);\n    v28 = 0LL;\n    if (nn) {\n      do {\n        if ((v28 & 7) == 0) {\n          v29 = 0LL;\n          v30 = h[v28 >> 3];\n          do {\n            *((uint8_t *)&h[8] + v29) =\n                (v30 & (255LL << (8 * (unsigned char)v29))) >>\n                (8 * (unsigned char)v29);\n            ++v29;\n          } while (v29 != 8);\n        }\n        v15[v28] = *((uint8_t *)&h[8] + (v28 & 7));\n        ++v28;\n      } while (v40 != v28);\n    }\n  }\n  libmin_free(v14);\n  return v15;\n}", "binary": "blake2b/blake2b.host.O2", "assembly": "<blake2b>:\nendbr64\npush   %r15\nmov    %rdx,%r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xa8,%rsp\nmov    %r8d,0x10(%rsp)\nmov    %cl,0x17(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x98(%rsp)\nxor    %eax,%eax\ntest   %rdi,%rdi\nje     19b0 <blake2b+0x390>\nxor    %r9d,%r9d\nmov    %rsi,%rax\ntest   $0x7f,%sil\nmov    %rsi,%rbx\nsetne  %r9b\nshr    $0x7,%rax\nlea    (%r9,%rax,1),%rbp\ntest   %r15,%r15\nje     19a0 <blake2b+0x380>\nxor    %edx,%edx\ntest   %cl,%cl\nmov    $0x40,%eax\nsetne  %dl\nadd    %rdx,%rbp\ncmp    %al,%cl\ncmovbe %ecx,%eax\nmov    %al,(%rsp)\nmov    %rdx,0x20(%rsp)\nmov    0x10(%rsp),%edx\nmov    $0x40,%eax\nmov    $0x1,%r13d\nmov    $0x80,%esi\ncmp    %al,%dl\ncmovbe %edx,%eax\ntest   %rbp,%rbp\ncmovne %rbp,%r13\nmov    %al,0x18(%rsp)\nmov    %eax,%r12d\nmov    %r13,%rdi\nmov    %r13,0x8(%rsp)\ncall   2040 <libmin_calloc>\nmov    %rax,%r13\ntest   %rax,%rax\nje     19b9 <blake2b+0x399>\nmovzbl %r12b,%eax\nmov    %rax,%rdi\nmov    %rax,0x28(%rsp)\ncall   1f70 <libmin_malloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1970 <blake2b+0x350>\nmovzbl (%rsp),%r10d\nxor    %eax,%eax\nmov    0x20(%rsp),%rdx\ntest   %r10b,%r10b\nje     1735 <blake2b+0x115>\nnopl   0x0(%rax)\nmov    %eax,%ecx\nmovzbl (%r15,%rax,1),%esi\nmov    %rax,%rdi\nadd    $0x1,%rax\nand    $0x7,%ecx\nshr    $0x3,%rdi\nshl    $0x3,%ecx\nshl    %cl,%rsi\nor     %rsi,0x0(%r13,%rdi,8)\ncmp    %r10,%rax\njne    1710 <blake2b+0xf0>\nxor    %esi,%esi\ntest   %rbx,%rbx\nje     1778 <blake2b+0x158>\nnopl   0x0(%rax)\nmov    %rsi,%rax\nmov    %rsi,%rdi\nmov    %esi,%ecx\nmovzbl (%r14,%rsi,1),%r8d\nshr    $0x7,%rax\nshr    $0x3,%rdi\nand    $0x7,%ecx\nadd    $0x1,%rsi\nadd    %rdx,%rax\nand    $0xf,%edi\nshl    $0x3,%ecx\nshl    $0x7,%rax\nshl    %cl,%r8\nadd    %r13,%rax\nor     %r8,(%rax,%rdi,8)\ncmp    %rsi,%rbx\njne    1740 <blake2b+0x120>\nmovzbl 0x18(%rsp),%edx\nmov    %rbx,0x30(%rsp)\nmovabs $0xbb67ae8584caa73b,%rax\nlea    0x50(%rsp),%r15\nmov    %rax,0x58(%rsp)\nmovabs $0x3c6ef372fe94f82b,%rax\nmov    %rax,0x60(%rsp)\nmovabs $0xa54ff53a5f1d36f1,%rax\nmov    %rax,0x68(%rsp)\nmovabs $0x510e527fade682d1,%rax\nmov    %rax,0x70(%rsp)\nmovabs $0x9b05688c2b3e6c1f,%rax\nmov    %rax,0x78(%rsp)\nmovabs $0x1f83d9abfb41bd6b,%rax\nmov    %rax,0x80(%rsp)\nmovabs $0x5be0cd19137e2179,%rax\nmov    %rax,0x88(%rsp)\nmovzbl (%rsp),%eax\nmovq   $0x0,0x38(%rsp)\nmovq   $0x0,0x40(%rsp)\nshl    $0x8,%eax\nmovq   $0x0,0x48(%rsp)\nxor    %edx,%eax\nmovabs $0x6a09e667f3bcc908,%rdx\nxor    $0x1010000,%eax\ncltq\nxor    %rdx,%rax\nmov    %rax,0x50(%rsp)\ncmp    $0x1,%rbp\njbe    18b2 <blake2b+0x292>\nmov    0x8(%rsp),%rax\nxor    %r14d,%r14d\nlea    0x40(%rsp),%rdi\nmov    %r12,(%rsp)\nmov    %rbx,0x18(%rsp)\nlea    0x50(%rsp),%r15\nmov    %r14,%rbx\nmov    %r13,%r12\nlea    -0x1(%rax),%rdx\nmov    %rdi,%r14\nxor    %eax,%eax\nmov    %rdx,%rbp\njmp    1887 <blake2b+0x267>\nnopl   0x0(%rax,%rax,1)\nmov    0x40(%rsp),%rax\ncmp    $0xffffffffffffff7e,%rax\njbe    1883 <blake2b+0x263>\naddq   $0x1,0x48(%rsp)\nsub    $0xffffffffffffff80,%r12\nsub    $0xffffffffffffff80,%rax\nxor    %ecx,%ecx\nmov    %r14,%rdx\nmov    %r12,%rsi\nmov    %r15,%rdi\nadd    $0x1,%rbx\nmov    %rax,0x40(%rsp)\ncall   12a0 <F>\ncmp    %rbp,%rbx\njb     1870 <blake2b+0x250>\nmov    (%rsp),%r12\nmov    0x18(%rsp),%rbx\ncmpb   $0x0,0x17(%rsp)\nje     18d4 <blake2b+0x2b4>\ncmp    $0xffffffffffffff7e,%rbx\njbe    18cb <blake2b+0x2ab>\nmovq   $0x1,0x38(%rsp)\nsub    $0xffffffffffffff80,%rbx\nmov    %rbx,0x30(%rsp)\nmov    0x8(%rsp),%rax\nlea    0x30(%rsp),%rdx\nmov    $0x1,%ecx\nmov    %r15,%rdi\nshl    $0x7,%rax\nlea    -0x80(%r13,%rax,1),%rsi\ncall   12a0 <F>\nxor    %esi,%esi\ncmpb   $0x0,0x10(%rsp)\nmov    0x28(%rsp),%r11\nmov    $0xff,%r10d\njne    1926 <blake2b+0x306>\njmp    1970 <blake2b+0x350>\nnopw   0x0(%rax,%rax,1)\nmovzbl 0x90(%rsp,%r9,1),%eax\nmov    %al,(%r12,%rsi,1)\nadd    $0x1,%rsi\ncmp    %rsi,%r11\nje     1970 <blake2b+0x350>\nmov    %rsi,%r9\nand    $0x7,%r9d\njne    1910 <blake2b+0x2f0>\nmov    %rsi,%rax\nxor    %edx,%edx\nlea    0x90(%rsp),%rdi\nshr    $0x3,%rax\nmov    0x50(%rsp,%rax,8),%r8\nnopl   (%rax)\nlea    0x0(,%rdx,8),%ecx\nmov    %r10,%rax\nshl    %cl,%rax\nand    %r8,%rax\nshr    %cl,%rax\nmov    %al,(%rdi,%rdx,1)\nadd    $0x1,%rdx\ncmp    $0x8,%rdx\njne    1948 <blake2b+0x328>\njmp    1910 <blake2b+0x2f0>\nnopw   0x0(%rax,%rax,1)\nmov    %r13,%rdi\ncall   2020 <libmin_free>\nmov    0x98(%rsp),%rax\nsub    %fs:0x28,%rax\njne    19be <blake2b+0x39e>\nadd    $0xa8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovb   $0x0,(%rsp)\nxor    %edx,%edx\nmovb   $0x0,0x17(%rsp)\njmp    1699 <blake2b+0x79>\nxor    %ebp,%ebp\nxor    %ebx,%ebx\njmp    1679 <blake2b+0x59>\nxor    %r12d,%r12d\njmp    1978 <blake2b+0x358>\ncall   10c0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "main", "content": "/**\n * @brief main function\n *\n * @returns 0 on successful program exit\n */\nint main()\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  test();\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "blake2b/blake2b.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nxor    %eax,%eax\ncall   19d0 <test>\ncall   3750 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "blake2b/blake2b.c", "function_name": "test", "content": "/**\n * @brief testing function\n *\n * @returns void\n */\nstatic void test()\n{\n    uint8_t *digest = NULL;\n\n    /* \"abc\" example straight out of RFC-7693 */\n    uint8_t abc[3] = {'a', 'b', 'c'};\n    uint8_t abc_answer[64] = {\n        0xBA, 0x80, 0xA5, 0x3F, 0x98, 0x1C, 0x4D, 0x0D, 0x6A, 0x27, 0x97,\n        0xB6, 0x9F, 0x12, 0xF6, 0xE9, 0x4C, 0x21, 0x2F, 0x14, 0x68, 0x5A,\n        0xC4, 0xB7, 0x4B, 0x12, 0xBB, 0x6F, 0xDB, 0xFF, 0xA2, 0xD1, 0x7D,\n        0x87, 0xC5, 0x39, 0x2A, 0xAB, 0x79, 0x2D, 0xC2, 0x52, 0xD5, 0xDE,\n        0x45, 0x33, 0xCC, 0x95, 0x18, 0xD3, 0x8A, 0xA8, 0xDB, 0xF1, 0x92,\n        0x5A, 0xB9, 0x23, 0x86, 0xED, 0xD4, 0x00, 0x99, 0x23};\n\n    digest = blake2b(abc, 3, NULL, 0, 64);\n    assert_bytes(abc_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t key_answer[64] = {\n        0x10, 0xeb, 0xb6, 0x77, 0x00, 0xb1, 0x86, 0x8e, 0xfb, 0x44, 0x17,\n        0x98, 0x7a, 0xcf, 0x46, 0x90, 0xae, 0x9d, 0x97, 0x2f, 0xb7, 0xa5,\n        0x90, 0xc2, 0xf0, 0x28, 0x71, 0x79, 0x9a, 0xaa, 0x47, 0x86, 0xb5,\n        0xe9, 0x96, 0xe8, 0xf0, 0xf4, 0xeb, 0x98, 0x1f, 0xc2, 0x14, 0xb0,\n        0x05, 0xf4, 0x2d, 0x2f, 0xf4, 0x23, 0x34, 0x99, 0x39, 0x16, 0x53,\n        0xdf, 0x7a, 0xef, 0xcb, 0xc1, 0x3f, 0xc5, 0x15, 0x68};\n\n    digest = blake2b(NULL, 0, key, 64, 64);\n    assert_bytes(key_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t zero[1] = {0};\n    uint8_t zero_key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t zero_answer[64] = {\n        0x96, 0x1f, 0x6d, 0xd1, 0xe4, 0xdd, 0x30, 0xf6, 0x39, 0x01, 0x69,\n        0x0c, 0x51, 0x2e, 0x78, 0xe4, 0xb4, 0x5e, 0x47, 0x42, 0xed, 0x19,\n        0x7c, 0x3c, 0x5e, 0x45, 0xc5, 0x49, 0xfd, 0x25, 0xf2, 0xe4, 0x18,\n        0x7b, 0x0b, 0xc9, 0xfe, 0x30, 0x49, 0x2b, 0x16, 0xb0, 0xd0, 0xbc,\n        0x4e, 0xf9, 0xb0, 0xf3, 0x4c, 0x70, 0x03, 0xfa, 0xc0, 0x9a, 0x5e,\n        0xf1, 0x53, 0x2e, 0x69, 0x43, 0x02, 0x34, 0xce, 0xbd};\n\n    digest = blake2b(zero, 1, zero_key, 64, 64);\n    assert_bytes(zero_answer, digest, 64);\n\n    libmin_free(digest);\n\n    uint8_t filled[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t filled_key[64] = {\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,\n        0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,\n        0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,\n        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f};\n    uint8_t filled_answer[64] = {\n        0x65, 0x67, 0x6d, 0x80, 0x06, 0x17, 0x97, 0x2f, 0xbd, 0x87, 0xe4,\n        0xb9, 0x51, 0x4e, 0x1c, 0x67, 0x40, 0x2b, 0x7a, 0x33, 0x10, 0x96,\n        0xd3, 0xbf, 0xac, 0x22, 0xf1, 0xab, 0xb9, 0x53, 0x74, 0xab, 0xc9,\n        0x42, 0xf1, 0x6e, 0x9a, 0xb0, 0xea, 0xd3, 0x3b, 0x87, 0xc9, 0x19,\n        0x68, 0xa6, 0xe5, 0x09, 0xe1, 0x19, 0xff, 0x07, 0x78, 0x7b, 0x3e,\n        0xf4, 0x83, 0xe1, 0xdc, 0xdc, 0xcf, 0x6e, 0x30, 0x22};\n\n    digest = blake2b(filled, 64, filled_key, 64, 64);\n    assert_bytes(filled_answer, digest, 64);\n\n    libmin_free(digest);\n\n    libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}\n"}, "pseudo": {"path": "blake2b/blake2b.host.O2.pseudo", "function_name": "test", "address": "0x19d0", "label": "test", "content": "void __cdecl test()\n{\n  uint8_t *v0; // rbp\n  uint8_t v1; // dl\n  uint8_t *v2; // rbp\n  uint8_t v3; // dl\n  uint8_t *v4; // rbp\n  uint8_t v5; // dl\n  uint8_t *v6; // rsi\n  uint8_t v7; // dl\n  uint8_t zero[1]; // [rsp+Ch] [rbp-21Ch] BYREF\n  uint8_t abc[3]; // [rsp+Dh] [rbp-21Bh] BYREF\n  uint8_t abc_answer[64]; // [rsp+10h] [rbp-218h] BYREF\n  uint8_t key[64]; // [rsp+50h] [rbp-1D8h] BYREF\n  uint8_t key_answer[64]; // [rsp+90h] [rbp-198h] BYREF\n  uint8_t zero_key[64]; // [rsp+D0h] [rbp-158h] BYREF\n  uint8_t zero_answer[64]; // [rsp+110h] [rbp-118h] BYREF\n  uint8_t filled[64]; // [rsp+150h] [rbp-D8h] BYREF\n  uint8_t filled_key[64]; // [rsp+190h] [rbp-98h] BYREF\n  uint8_t filled_answer[64]; // [rsp+1D0h] [rbp-58h] BYREF\n  unsigned __int64 v18; // [rsp+218h] [rbp-10h]\n\n  v18 = __readfsqword(0x28u);\n  *(__m128i *)abc_answer = _mm_load_si128((const __m128i *)&xmmword_4120);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(__m128i *)&abc_answer[16] = _mm_load_si128((const __m128i *)&xmmword_4130);\n  *(__m128i *)&abc_answer[32] = _mm_load_si128((const __m128i *)&xmmword_4140);\n  *(__m128i *)&abc_answer[48] = _mm_load_si128((const __m128i *)&xmmword_4150);\n  v0 = blake2b(abc, 3uLL, 0LL, 0, 0x40u);\n  assert_bytes(abc_answer, v0, v1);\n  libmin_free(v0);\n  *(__m128i *)key = _mm_load_si128((const __m128i *)&xmmword_4160);\n  *(__m128i *)key_answer = _mm_load_si128((const __m128i *)&xmmword_41A0);\n  *(__m128i *)&key[16] = _mm_load_si128((const __m128i *)&xmmword_4170);\n  *(__m128i *)&key_answer[16] = _mm_load_si128((const __m128i *)&xmmword_41B0);\n  *(__m128i *)&key[32] = _mm_load_si128((const __m128i *)&xmmword_4180);\n  *(__m128i *)&key_answer[32] = _mm_load_si128((const __m128i *)&xmmword_41C0);\n  *(__m128i *)&key[48] = _mm_load_si128((const __m128i *)&xmmword_4190);\n  *(__m128i *)&key_answer[48] = _mm_load_si128((const __m128i *)&xmmword_41D0);\n  v2 = blake2b(0LL, 0LL, key, 0x40u, 0x40u);\n  assert_bytes(key_answer, v2, v3);\n  libmin_free(v2);\n  *(__m128i *)zero_answer = _mm_load_si128((const __m128i *)&xmmword_41E0);\n  *(__m128i *)zero_key = _mm_load_si128((const __m128i *)&xmmword_4160);\n  *(__m128i *)&zero_answer[16] = _mm_load_si128((const __m128i *)&xmmword_41F0);\n  *(__m128i *)&zero_key[16] = _mm_load_si128((const __m128i *)&xmmword_4170);\n  *(__m128i *)&zero_answer[32] = _mm_load_si128((const __m128i *)&xmmword_4200);\n  *(__m128i *)&zero_key[32] = _mm_load_si128((const __m128i *)&xmmword_4180);\n  *(__m128i *)&zero_answer[48] = _mm_load_si128((const __m128i *)&xmmword_4210);\n  *(__m128i *)&zero_key[48] = _mm_load_si128((const __m128i *)&xmmword_4190);\n  zero[0] = 0;\n  v4 = blake2b(zero, 1uLL, zero_key, 0x40u, 0x40u);\n  assert_bytes(zero_answer, v4, v5);\n  libmin_free(v4);\n  *(__m128i *)&filled[48] = _mm_load_si128((const __m128i *)&xmmword_4190);\n  *(_OWORD *)&filled_key[48] = *(_OWORD *)&filled[48];\n  *(__m128i *)filled = _mm_load_si128((const __m128i *)&xmmword_4160);\n  *(__m128i *)filled_answer = _mm_load_si128((const __m128i *)&xmmword_4220);\n  *(__m128i *)&filled[16] = _mm_load_si128((const __m128i *)&xmmword_4170);\n  *(__m128i *)&filled_answer[16] = _mm_load_si128((const __m128i *)&xmmword_4230);\n  *(__m128i *)&filled[32] = _mm_load_si128((const __m128i *)&xmmword_4180);\n  *(__m128i *)&filled_answer[32] = _mm_load_si128((const __m128i *)&xmmword_4240);\n  *(_OWORD *)filled_key = *(_OWORD *)filled;\n  *(_OWORD *)&filled_key[16] = *(_OWORD *)&filled[16];\n  *(_OWORD *)&filled_key[32] = *(_OWORD *)&filled[32];\n  *(__m128i *)&filled_answer[48] = _mm_load_si128((const __m128i *)&xmmword_4250);\n  v6 = blake2b(filled, 0x40uLL, filled_key, 0x40u, 0x40u);\n  assert_bytes(filled_answer, v6, v7);\n  libmin_free(v6);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}\n"}, "pseudo_normalize": "void test() {\n  uint8_t *v0;\n  uint8_t v1;\n  uint8_t *v2;\n  uint8_t v3;\n  uint8_t *v4;\n  uint8_t v5;\n  uint8_t *v6;\n  uint8_t v7;\n  uint8_t zero[1];\n  uint8_t abc[3];\n  uint8_t abc_answer[64];\n  uint8_t key[64];\n  uint8_t key_answer[64];\n  uint8_t zero_key[64];\n  uint8_t zero_answer[64];\n  uint8_t filled[64];\n  uint8_t filled_key[64];\n  uint8_t filled_answer[64];\n  unsigned long long v18;\n  v18 = __readfsqword(40u);\n  *(__m128i *)abc_answer = _mm_load_si128((const __m128i *)&xmmword_4120);\n  qmemcpy(abc, \"abc\", sizeof(abc));\n  *(__m128i *)&abc_answer[16] = _mm_load_si128((const __m128i *)&xmmword_4130);\n  *(__m128i *)&abc_answer[32] = _mm_load_si128((const __m128i *)&xmmword_4140);\n  *(__m128i *)&abc_answer[48] = _mm_load_si128((const __m128i *)&xmmword_4150);\n  v0 = blake2b(abc, 3uLL, 0LL, 0, 64u);\n  assert_bytes(abc_answer, v0, v1);\n  libmin_free(v0);\n  *(__m128i *)key = _mm_load_si128((const __m128i *)&xmmword_4160);\n  *(__m128i *)key_answer = _mm_load_si128((const __m128i *)&xmmword_41A0);\n  *(__m128i *)&key[16] = _mm_load_si128((const __m128i *)&xmmword_4170);\n  *(__m128i *)&key_answer[16] = _mm_load_si128((const __m128i *)&xmmword_41B0);\n  *(__m128i *)&key[32] = _mm_load_si128((const __m128i *)&xmmword_4180);\n  *(__m128i *)&key_answer[32] = _mm_load_si128((const __m128i *)&xmmword_41C0);\n  *(__m128i *)&key[48] = _mm_load_si128((const __m128i *)&xmmword_4190);\n  *(__m128i *)&key_answer[48] = _mm_load_si128((const __m128i *)&xmmword_41D0);\n  v2 = blake2b(0LL, 0LL, key, 64u, 64u);\n  assert_bytes(key_answer, v2, v3);\n  libmin_free(v2);\n  *(__m128i *)zero_answer = _mm_load_si128((const __m128i *)&xmmword_41E0);\n  *(__m128i *)zero_key = _mm_load_si128((const __m128i *)&xmmword_4160);\n  *(__m128i *)&zero_answer[16] = _mm_load_si128((const __m128i *)&xmmword_41F0);\n  *(__m128i *)&zero_key[16] = _mm_load_si128((const __m128i *)&xmmword_4170);\n  *(__m128i *)&zero_answer[32] = _mm_load_si128((const __m128i *)&xmmword_4200);\n  *(__m128i *)&zero_key[32] = _mm_load_si128((const __m128i *)&xmmword_4180);\n  *(__m128i *)&zero_answer[48] = _mm_load_si128((const __m128i *)&xmmword_4210);\n  *(__m128i *)&zero_key[48] = _mm_load_si128((const __m128i *)&xmmword_4190);\n  zero[0] = 0;\n  v4 = blake2b(zero, 1uLL, zero_key, 64u, 64u);\n  assert_bytes(zero_answer, v4, v5);\n  libmin_free(v4);\n  *(__m128i *)&filled[48] = _mm_load_si128((const __m128i *)&xmmword_4190);\n  *(long double *)&filled_key[48] = *(long double *)&filled[48];\n  *(__m128i *)filled = _mm_load_si128((const __m128i *)&xmmword_4160);\n  *(__m128i *)filled_answer = _mm_load_si128((const __m128i *)&xmmword_4220);\n  *(__m128i *)&filled[16] = _mm_load_si128((const __m128i *)&xmmword_4170);\n  *(__m128i *)&filled_answer[16] =\n      _mm_load_si128((const __m128i *)&xmmword_4230);\n  *(__m128i *)&filled[32] = _mm_load_si128((const __m128i *)&xmmword_4180);\n  *(__m128i *)&filled_answer[32] =\n      _mm_load_si128((const __m128i *)&xmmword_4240);\n  *(long double *)filled_key = *(long double *)filled;\n  *(long double *)&filled_key[16] = *(long double *)&filled[16];\n  *(long double *)&filled_key[32] = *(long double *)&filled[32];\n  *(__m128i *)&filled_answer[48] =\n      _mm_load_si128((const __m128i *)&xmmword_4250);\n  v6 = blake2b(filled, 64uLL, filled_key, 64u, 64u);\n  assert_bytes(filled_answer, v6, v7);\n  libmin_free(v6);\n  libmin_printf(\"INFO: All tests have successfully passed!\\n\");\n}", "binary": "blake2b/blake2b.host.O2", "assembly": "<test>:\npush   %rbp\nxor    %ecx,%ecx\nxor    %edx,%edx\nmov    $0x40,%r8d\nmov    $0x3,%esi\nsub    $0x220,%rsp\nmovdqa 0x2731(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x218(%rsp)\nxor    %eax,%eax\nlea    0xd(%rsp),%rdi\nmov    $0x6261,%eax\nmovb   $0x63,0xf(%rsp)\nmovaps %xmm0,0x10(%rsp)\nmovdqa 0x2712(%rip),%xmm0\nmov    %ax,0xd(%rsp)\nmovaps %xmm0,0x20(%rsp)\nmovdqa 0x2710(%rip),%xmm0\nmovaps %xmm0,0x30(%rsp)\nmovdqa 0x2713(%rip),%xmm0\nmovaps %xmm0,0x40(%rsp)\ncall   1620 <blake2b>\nlea    0x10(%rsp),%rdi\nmov    %rax,%rbp\nmov    %rax,%rsi\ncall   1570 <assert_bytes.constprop.0>\nmov    %rbp,%rdi\ncall   2020 <libmin_free>\nmovdqa 0x2739(%rip),%xmm4\nxor    %esi,%esi\nmovdqa 0x26ef(%rip),%xmm3\nmovdqa 0x26f7(%rip),%xmm2\nmovdqa 0x26ff(%rip),%xmm1\nlea    0x50(%rsp),%rdx\nxor    %edi,%edi\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmovaps %xmm3,0x50(%rsp)\nmovdqa 0x26f0(%rip),%xmm0\nmovaps %xmm4,0x90(%rsp)\nmovdqa 0x2700(%rip),%xmm4\nmovaps %xmm2,0x60(%rsp)\nmovaps %xmm4,0xa0(%rsp)\nmovdqa 0x26fb(%rip),%xmm4\nmovaps %xmm1,0x70(%rsp)\nmovaps %xmm4,0xb0(%rsp)\nmovdqa 0x26f6(%rip),%xmm4\nmovaps %xmm0,0x80(%rsp)\nmovaps %xmm4,0xc0(%rsp)\ncall   1620 <blake2b>\nlea    0x90(%rsp),%rdi\nmov    %rax,%rbp\nmov    %rax,%rsi\ncall   1570 <assert_bytes.constprop.0>\nmov    %rbp,%rdi\ncall   2020 <libmin_free>\nmovdqa 0x26ce(%rip),%xmm4\nmovdqa 0x2646(%rip),%xmm3\nlea    0xd0(%rsp),%rdx\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nlea    0xc(%rsp),%rdi\nmovdqa 0x2636(%rip),%xmm2\nmovaps %xmm4,0x110(%rsp)\nmovdqa 0x26a6(%rip),%xmm4\nmov    $0x1,%esi\nmovdqa 0x2629(%rip),%xmm1\nmovdqa 0x2631(%rip),%xmm0\nmovaps %xmm3,0xd0(%rsp)\nmovaps %xmm4,0x120(%rsp)\nmovdqa 0x2689(%rip),%xmm4\nmovaps %xmm2,0xe0(%rsp)\nmovaps %xmm4,0x130(%rsp)\nmovdqa 0x2681(%rip),%xmm4\nmovaps %xmm1,0xf0(%rsp)\nmovaps %xmm4,0x140(%rsp)\nmovaps %xmm0,0x100(%rsp)\nmovb   $0x0,0xc(%rsp)\ncall   1620 <blake2b>\nlea    0x110(%rsp),%rdi\nmov    %rax,%rbp\nmov    %rax,%rsi\ncall   1570 <assert_bytes.constprop.0>\nmov    %rbp,%rdi\ncall   2020 <libmin_free>\nmovdqa 0x25bc(%rip),%xmm0\nmovdqa 0x2584(%rip),%xmm3\nlea    0x190(%rsp),%rdx\nmov    $0x40,%r8d\nmov    $0x40,%ecx\nmovdqa 0x2579(%rip),%xmm2\nmovdqa 0x2581(%rip),%xmm1\nmovaps %xmm0,0x180(%rsp)\nlea    0x150(%rsp),%rdi\nmov    $0x40,%esi\nmovaps %xmm0,0x1c0(%rsp)\nmovdqa 0x25fc(%rip),%xmm0\nmovaps %xmm3,0x150(%rsp)\nmovaps %xmm0,0x1d0(%rsp)\nmovdqa 0x25f4(%rip),%xmm0\nmovaps %xmm2,0x160(%rsp)\nmovaps %xmm0,0x1e0(%rsp)\nmovdqa 0x25ec(%rip),%xmm0\nmovaps %xmm1,0x170(%rsp)\nmovaps %xmm0,0x1f0(%rsp)\nmovdqa 0x25e4(%rip),%xmm0\nmovaps %xmm3,0x190(%rsp)\nmovaps %xmm2,0x1a0(%rsp)\nmovaps %xmm1,0x1b0(%rsp)\nmovaps %xmm0,0x200(%rsp)\ncall   1620 <blake2b>\nlea    0x1d0(%rsp),%rdi\nmov    %rax,%rbp\nmov    %rax,%rsi\ncall   1570 <assert_bytes.constprop.0>\nmov    %rbp,%rdi\ncall   2020 <libmin_free>\nxor    %eax,%eax\nlea    0x237b(%rip),%rdi\ncall   3510 <libmin_printf>\nmov    0x218(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1cd6 <test+0x306>\nadd    $0x220,%rsp\npop    %rbp\nret\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "bloom-filter/bloom-filter.c", "function_name": "bad_search", "content": "#include \"libmin.h\"\n#include \"tinybloom.h\"\n\n#define NUM_ITEMS 2048\n#define NUM_BUCKETS NUM_ITEMS * 4\n\nint bad_search(const unsigned int* array, unsigned int target, size_t size)\n{\n\tint i;\n\tfor(i = 0; i < size; i++)\n\t\tif(array[i] == target) return 1;\n\n\treturn 0;\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O2.pseudo", "function_name": "bad_search", "address": "0x1430", "label": "bad_search", "content": "int __fastcall bad_search(const unsigned int *array, unsigned int target, size_t size)\n{\n  __int64 v3; // rax\n\n  if ( !size )\n    return 0;\n  v3 = 0LL;\n  while ( array[v3] != target )\n  {\n    if ( ++v3 == size )\n      return 0;\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int bad_search(const unsigned int *array, unsigned int target,\n               unsigned int size) {\n  long long v3;\n  if (!size) return 0;\n  v3 = 0LL;\n  while (array[v3] != target) {\n    if (++v3 == size) return 0;\n  }\n  return 1;\n}", "binary": "bloom-filter/bloom-filter.host.O2", "assembly": "<bad_search>:\nendbr64\ntest   %rdx,%rdx\nje     1458 <bad_search+0x28>\nxor    %eax,%eax\njmp    1449 <bad_search+0x19>\nnopl   (%rax)\nadd    $0x1,%rax\ncmp    %rdx,%rax\nje     1458 <bad_search+0x28>\ncmp    %esi,(%rdi,%rax,4)\njne    1440 <bad_search+0x10>\nmov    $0x1,%eax\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "bloom-filter/tinybloom.c", "function_name": "bfilter_add", "content": "void bfilter_add(const bloom_filter* bFilter, const unsigned* input)\n{\n\tSETBIT(bFilter->filter, *input % bFilter->num_buckets);\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O2.pseudo", "function_name": "bfilter_add", "address": "0x14f0", "label": "bfilter_add", "content": "void __fastcall bfilter_add(const bloom_filter *bFilter, const unsigned int *input)\n{\n  bFilter->filter[(*input % bFilter->num_buckets) >> 5] |= 1 << (*input % bFilter->num_buckets);\n}\n"}, "pseudo_normalize": "", "binary": "bloom-filter/bloom-filter.host.O2", "assembly": "<bfilter_add>:\nendbr64\nmov    (%rsi),%eax\nxor    %edx,%edx\nmov    $0x1,%esi\ndivl   0x10(%rdi)\nmov    0x8(%rdi),%rdi\nmov    %edx,%eax\nmov    %edx,%ecx\nshr    $0x5,%eax\nshl    %cl,%esi\nor     %esi,(%rdi,%rax,4)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "bloom-filter/tinybloom.c", "function_name": "bfilter_check", "content": "int bfilter_check(const bloom_filter* bFilter, const unsigned* input)\n{\n\treturn GETBIT(bFilter->filter, *input % bFilter->num_buckets);\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O2.pseudo", "function_name": "bfilter_check", "address": "0x1520", "label": "bfilter_check", "content": "int __fastcall bfilter_check(const bloom_filter *bFilter, const unsigned int *input)\n{\n  return (bFilter->filter[(*input % bFilter->num_buckets) >> 5] & (1 << (*input % bFilter->num_buckets))) != 0;\n}\n"}, "pseudo_normalize": "", "binary": "bloom-filter/bloom-filter.host.O2", "assembly": "<bfilter_check>:\nendbr64\nmov    (%rsi),%eax\nxor    %edx,%edx\ndivl   0x10(%rdi)\nmov    0x8(%rdi),%rdi\nmov    $0x1,%eax\nmov    %edx,%esi\nmov    %edx,%ecx\nshr    $0x5,%esi\nshl    %cl,%eax\nand    (%rdi,%rsi,4),%eax\nsetne  %al\nmovzbl %al,%eax\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "bloom-filter/tinybloom.c", "function_name": "bfilter_intersect", "content": "int bfilter_intersect(bloom_filter* a, bloom_filter* b)\n{\n\tif(a->filter_size != b->filter_size) return 1;\n\n\tint i;\n\tfor(i = 0; i < a->filter_size; i++)\n\t\ta->filter[i] |= b->filter[i];\n\n\treturn 0;\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O2.pseudo", "function_name": "bfilter_intersect", "address": "0x1550", "label": "bfilter_intersect", "content": "int __fastcall bfilter_intersect(bloom_filter *a, bloom_filter *b)\n{\n  size_t filter_size; // rax\n  int v3; // r8d\n  unsigned int *filter; // rdx\n  unsigned int *v5; // rdi\n  __int64 v6; // rsi\n  unsigned __int64 v7; // rax\n\n  filter_size = a->filter_size;\n  v3 = 1;\n  if ( a->filter_size == b->filter_size )\n  {\n    if ( filter_size )\n    {\n      filter = a->filter;\n      v5 = b->filter;\n      v6 = 4 * filter_size;\n      v7 = 0LL;\n      do\n      {\n        filter[v7 / 4] |= v5[v7 / 4];\n        v7 += 4LL;\n      }\n      while ( v6 != v7 );\n    }\n    return 0;\n  }\n  return v3;\n}\n"}, "pseudo_normalize": "int bfilter_intersect(bloom_filter *a, bloom_filter *b) {\n  unsigned int filter_size;\n  int v3;\n  unsigned int *filter;\n  unsigned int *v5;\n  long long v6;\n  unsigned long long v7;\n  filter_size = a->filter_size;\n  v3 = 1;\n  if (a->filter_size == b->filter_size) {\n    if (filter_size) {\n      filter = a->filter;\n      v5 = b->filter;\n      v6 = 4 * filter_size;\n      v7 = 0LL;\n      do {\n        filter[v7 / 4] |= v5[v7 / 4];\n        v7 += 4LL;\n      } while (v6 != v7);\n    }\n    return 0;\n  }\n  return v3;\n}", "binary": "bloom-filter/bloom-filter.host.O2", "assembly": "<bfilter_intersect>:\nendbr64\nmov    (%rdi),%rax\nmov    $0x1,%r8d\ncmp    (%rsi),%rax\njne    1592 <bfilter_intersect+0x42>\ntest   %rax,%rax\nje     158f <bfilter_intersect+0x3f>\nmov    0x8(%rdi),%rdx\nmov    0x8(%rsi),%rdi\nlea    0x0(,%rax,4),%rsi\nxor    %eax,%eax\nnopl   0x0(%rax)\nmov    (%rdi,%rax,1),%ecx\nor     %ecx,(%rdx,%rax,1)\nadd    $0x4,%rax\ncmp    %rax,%rsi\njne    1580 <bfilter_intersect+0x30>\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "bloom-filter/tinybloom.c", "function_name": "destroy_bfilter", "content": "void destroy_bfilter(bloom_filter* bFilter)\n{\n\tif(bFilter->filter) libmin_free(bFilter->filter);\n\tif(bFilter) libmin_free(bFilter);\n\n\tbFilter->filter = NULL;\n\tbFilter = NULL;\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O2.pseudo", "function_name": "destroy_bfilter", "address": "0x14c0", "label": "destroy_bfilter", "content": "void __fastcall destroy_bfilter(bloom_filter *bFilter)\n{\n  unsigned int *filter; // rdi\n\n  filter = bFilter->filter;\n  if ( filter )\n    libmin_free(filter);\n  libmin_free(bFilter);\n  bFilter->filter = 0LL;\n}\n"}, "pseudo_normalize": "void destroy_bfilter(bloom_filter *bFilter) {\n  unsigned int *filter;\n  filter = bFilter->filter;\n  if (filter) libmin_free(filter);\n  libmin_free(bFilter);\n  bFilter->filter = 0LL;\n}", "binary": "bloom-filter/bloom-filter.host.O2", "assembly": "<destroy_bfilter>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\nmov    0x8(%rdi),%rdi\ntest   %rdi,%rdi\nje     14d6 <destroy_bfilter+0x16>\ncall   18c0 <libmin_free>\nmov    %rbx,%rdi\ncall   18c0 <libmin_free>\nmovq   $0x0,0x8(%rbx)\npop    %rbx\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "bloom-filter/bloom-filter.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tunsigned false_positives = 0, true_positives = 0;\n\tunsigned false_negatives = 0, true_negatives = 0;\n\n\tunsigned* filter_contents = libmin_malloc(sizeof(unsigned) * NUM_ITEMS);\n\tunsigned* test_array = libmin_malloc(sizeof(unsigned) * NUM_ITEMS);\n\n\t// Create a bloom filter with (2 << 13) buckets\n\tbloom_filter* bFilter = create_bfilter(NUM_BUCKETS);\n\n\tlibmin_printf(\"Using %lu kilobytes for filter.\\n\\n\", (bFilter->filter_size * sizeof(unsigned)) / 1024);\n\n\tlibmin_srand(42);\n\n\tint i;\n\tfor(i = 0; i < NUM_ITEMS; i++)\n\t{\n\t\tfilter_contents[i] = libmin_rand();\n\t\tbfilter_add(bFilter, &filter_contents[i]);\n\n\t\t// Fill our test array with a 50/50 mix of numbers that have been entered into the filter, and random numbers\n\t\tif(libmin_rand() & 1)\n\t\t\ttest_array[i] = filter_contents[i];\n\t\telse\n\t\t\ttest_array[i] = libmin_rand();\n\t}\n\n\tfor(i = 0; i < NUM_ITEMS; i++)\n\t{\n\t\tint filter_present = 0;\n\t\tint array_present = 0;\n\n\t\tfilter_present = bfilter_check(bFilter, &test_array[i]);\n\n\t\tarray_present = bad_search(filter_contents, test_array[i], NUM_ITEMS);\n\n\t\tif(array_present && filter_present) \t   true_positives++;\n\t\telse if(!array_present && !filter_present) true_negatives++;\n\t\telse if(!array_present && filter_present)  false_positives++;\n\t\telse if(array_present && !filter_present)  false_negatives++;\n\t}\n\n\tlibmin_printf(\"True positives: %i\\n\"\n\t\t\"True negatives: %i\\n\"\n\t\t\"False positives: %i\\n\"\n\t\t\"False negatives: %i\\n\",\n\t\ttrue_positives, true_negatives, false_positives, false_negatives);\n\n\tfloat success_rate = ((100.0f / NUM_ITEMS) * (true_positives + true_negatives));\n\tlibmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_rate);\n\n\tif(success_rate < 80.0f) libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n\n\tif(false_negatives) libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n\telse libmin_printf(\"Test PASSED.\\n\");\n\n\tlibmin_free(test_array);\n\tlibmin_free(filter_contents);\n\tdestroy_bfilter(bFilter);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "bloom-filter/bloom-filter.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  unsigned int *v3; // r12\n  unsigned int *v4; // r14\n  unsigned int *v5; // rbx\n  unsigned int *v6; // r13\n  const unsigned int *v7; // r15\n  bloom_filter *bfilter; // rbp\n  unsigned int v9; // eax\n  int v10; // ebx\n  int v11; // eax\n  unsigned int *v12; // rdx\n  int success_rate; // [rsp+Ch] [rbp-4Ch]\n  float success_ratea; // [rsp+Ch] [rbp-4Ch]\n  unsigned int true_negatives; // [rsp+10h] [rbp-48h]\n  unsigned int false_negatives; // [rsp+14h] [rbp-44h]\n  unsigned int *test_array; // [rsp+18h] [rbp-40h]\n\n  v3 = (unsigned int *)libmin_malloc(0x2000uLL);\n  v4 = v3 + 2048;\n  v5 = v3;\n  v6 = (unsigned int *)libmin_malloc(0x2000uLL);\n  test_array = v6;\n  v7 = v6;\n  bfilter = create_bfilter(0x2000uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\", (4 * bfilter->filter_size) >> 10);\n  libmin_srand(0x2Au);\n  do\n  {\n    *v5 = libmin_rand();\n    bfilter_add(bfilter, v5);\n    if ( (libmin_rand() & 1) != 0 )\n      v9 = *v5;\n    else\n      v9 = libmin_rand();\n    ++v5;\n    *v6++ = v9;\n  }\n  while ( v5 != v4 );\n  true_negatives = 0;\n  v10 = 0;\n  false_negatives = 0;\n  success_rate = 0;\n  while ( 1 )\n  {\n    v11 = bfilter_check(bfilter, v7);\n    v12 = v3;\n    while ( *v7 != *v12 )\n    {\n      if ( ++v12 == v4 )\n      {\n        if ( v11 )\n          ++success_rate;\n        else\n          ++true_negatives;\n        goto LABEL_12;\n      }\n    }\n    if ( v11 )\n      ++v10;\n    else\n      ++false_negatives;\nLABEL_12:\n    if ( ++v7 == test_array + 2048 )\n    {\n      libmin_printf(\n        \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse negatives: %i\\n\",\n        v10,\n        true_negatives,\n        success_rate,\n        false_negatives);\n      success_ratea = (float)(int)(v10 + true_negatives) * 0.048828125;\n      libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_ratea);\n      if ( success_ratea < 80.0 )\n        libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n      if ( false_negatives )\n        libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n      else\n        libmin_printf(\"Test PASSED.\\n\");\n      libmin_free(test_array);\n      libmin_free(v3);\n      destroy_bfilter(bfilter);\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  unsigned int *v3;\n  unsigned int *v4;\n  unsigned int *v5;\n  unsigned int *v6;\n  const unsigned int *v7;\n  bloom_filter *bfilter;\n  unsigned int v9;\n  int v10;\n  int v11;\n  unsigned int *v12;\n  int success_rate;\n  float success_ratea;\n  unsigned int true_negatives;\n  unsigned int false_negatives;\n  unsigned int *test_array;\n  v3 = (unsigned int *)libmin_malloc(8192uLL);\n  v4 = v3 + 2048;\n  v5 = v3;\n  v6 = (unsigned int *)libmin_malloc(8192uLL);\n  test_array = v6;\n  v7 = v6;\n  bfilter = create_bfilter(8192uLL);\n  libmin_printf(\"Using %lu kilobytes for filter.\\n\\n\",\n                (4 * bfilter->filter_size) >> 10);\n  libmin_srand(42u);\n  do {\n    *v5 = libmin_rand();\n    bfilter_add(bfilter, v5);\n    if ((libmin_rand() & 1) != 0)\n      v9 = *v5;\n    else\n      v9 = libmin_rand();\n    ++v5;\n    *v6++ = v9;\n  } while (v5 != v4);\n  true_negatives = 0;\n  v10 = 0;\n  false_negatives = 0;\n  success_rate = 0;\n  while (1) {\n    v11 = bfilter_check(bfilter, v7);\n    v12 = v3;\n    while (*v7 != *v12) {\n      if (++v12 == v4) {\n        if (v11)\n          ++success_rate;\n        else\n          ++true_negatives;\n        goto LABEL_12;\n      }\n    }\n    if (v11)\n      ++v10;\n    else\n      ++false_negatives;\n  LABEL_12:\n    if (++v7 == test_array + 2048) {\n      libmin_printf(\n          \"True positives: %i\\nTrue negatives: %i\\nFalse positives: %i\\nFalse \"\n          \"negatives: %i\\n\",\n          v10, true_negatives, success_rate, false_negatives);\n      success_ratea = (float)(int)(v10 + true_negatives) * 0.048828125;\n      libmin_printf(\"\\n%3.2f%% success rate\\n\\n\", success_ratea);\n      if (success_ratea < 80.0)\n        libmin_printf(\"WARNING: Success rate less than 80%%.\\n\\n\");\n      if (false_negatives)\n        libmin_printf(\"**ERROR:** Test FAILED.\\n\");\n      else\n        libmin_printf(\"Test PASSED.\\n\");\n      libmin_free(test_array);\n      libmin_free(v3);\n      destroy_bfilter(bfilter);\n      libmin_success();\n    }\n  }\n}", "binary": "bloom-filter/bloom-filter.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x2000,%edi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\ncall   1810 <libmin_malloc>\nmov    $0x2000,%edi\nmov    %rax,%r12\ncall   1810 <libmin_malloc>\nmov    $0x2000,%edi\nlea    0x2000(%r12),%r14\nmov    %r12,%rbx\nmov    %rax,%r13\nmov    %rax,0x18(%rsp)\ncall   1460 <create_bfilter>\nlea    0x2e9b(%rip),%rdi\nmov    %r13,%r15\nmov    %rax,%rbp\nmov    (%rax),%rax\nlea    0x0(,%rax,4),%rsi\nxor    %eax,%eax\nshr    $0xa,%rsi\ncall   2db0 <libmin_printf>\nmov    $0x2a,%edi\ncall   2fc0 <libmin_srand>\njmp    11ab <main+0x8b>\nnopl   (%rax)\nmov    (%rbx),%eax\nadd    $0x4,%rbx\nmov    %eax,0x0(%r13)\nadd    $0x4,%r13\ncmp    %r14,%rbx\nje     11cd <main+0xad>\ncall   3020 <libmin_rand>\nmov    %rbx,%rsi\nmov    %rbp,%rdi\nmov    %eax,(%rbx)\ncall   14f0 <bfilter_add>\ncall   3020 <libmin_rand>\ntest   $0x1,%al\njne    1198 <main+0x78>\ncall   3020 <libmin_rand>\njmp    119a <main+0x7a>\nmov    0x18(%rsp),%rax\nmovl   $0x0,0x10(%rsp)\nxor    %ebx,%ebx\nmovl   $0x0,0x14(%rsp)\nmovl   $0x0,0xc(%rsp)\nlea    0x2000(%rax),%r13\nnopl   0x0(%rax,%rax,1)\nmov    %r15,%rsi\nmov    %rbp,%rdi\ncall   1520 <bfilter_check>\nmov    (%r15),%ecx\nmov    %r12,%rdx\njmp    121d <main+0xfd>\nnopl   0x0(%rax,%rax,1)\nadd    $0x4,%rdx\ncmp    %r14,%rdx\nje     12f0 <main+0x1d0>\ncmp    (%rdx),%ecx\njne    1210 <main+0xf0>\ntest   %eax,%eax\nje     130a <main+0x1ea>\nadd    $0x1,%ebx\nadd    $0x4,%r15\ncmp    %r13,%r15\njne    11f8 <main+0xd8>\nmov    0x10(%rsp),%r15d\nmov    0x14(%rsp),%r8d\nmov    %ebx,%esi\nxor    %eax,%eax\nmov    0xc(%rsp),%ecx\nlea    0x2de2(%rip),%rdi\nmov    %r15d,%edx\ncall   2db0 <libmin_printf>\nmov    %r15d,%eax\npxor   %xmm1,%xmm1\npxor   %xmm0,%xmm0\nadd    %ebx,%eax\nlea    0x2e3e(%rip),%rdi\nmov    %eax,%eax\ncvtsi2ss %rax,%xmm1\nmulss  0x2e6f(%rip),%xmm1\nmov    $0x1,%eax\ncvtss2sd %xmm1,%xmm0\nmovss  %xmm1,0xc(%rsp)\ncall   2db0 <libmin_printf>\nmovss  0x2e57(%rip),%xmm0\nmovss  0xc(%rsp),%xmm1\ncomiss %xmm1,%xmm0\nja     1324 <main+0x204>\nmov    0x14(%rsp),%eax\ntest   %eax,%eax\nje     1314 <main+0x1f4>\nlea    0x2e0d(%rip),%rdi\nxor    %eax,%eax\ncall   2db0 <libmin_printf>\nmov    0x18(%rsp),%rdi\ncall   18c0 <libmin_free>\nmov    %r12,%rdi\ncall   18c0 <libmin_free>\nmov    %rbp,%rdi\ncall   14c0 <destroy_bfilter>\ncall   3200 <libmin_success>\nadd    $0x28,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\ntest   %eax,%eax\njne    1300 <main+0x1e0>\naddl   $0x1,0x10(%rsp)\njmp    122c <main+0x10c>\nxchg   %ax,%ax\naddl   $0x1,0xc(%rsp)\njmp    122c <main+0x10c>\naddl   $0x1,0x14(%rsp)\njmp    122c <main+0x10c>\nlea    0x2dbe(%rip),%rdi\nxor    %eax,%eax\ncall   2db0 <libmin_printf>\njmp    12ba <main+0x19a>\nlea    0x2d55(%rip),%rdi\nxor    %eax,%eax\ncall   2db0 <libmin_printf>\njmp    12a4 <main+0x184>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "boyer-moore-search/boyer-moore-search.c", "function_name": "badCharHeuristic", "content": "#define NO_OF_CHARS 256\n\n// The preprocessing function for Boyer Moore's\n// bad character heuristic\nvoid badCharHeuristic(char *str, int size, int badchar[NO_OF_CHARS])\n{\n\t// Initialize all occurrences as -1\n\tfor(int i = 0; i < NO_OF_CHARS; i++)\n  {\n\t\tbadchar[i] = -1;\n  }\n\n\t// Fill the actual value of last occurrence of a character\n\tfor(int i = 0; i < size; i++)\n  {\n\t\tbadchar[(int)str[i]] = i;\n  }\n}\n"}, "pseudo": {"path": "boyer-moore-search/boyer-moore-search.host.O2.pseudo", "function_name": "badCharHeuristic", "address": "0x15d0", "label": "badCharHeuristic", "content": "void __fastcall badCharHeuristic(char *str, int size, int *badchar)\n{\n  __int64 i; // rax\n\n  *(_QWORD *)badchar = -1LL;\n  *((_QWORD *)badchar + 127) = -1LL;\n  memset(\n    (void *)((unsigned __int64)(badchar + 2) & 0xFFFFFFFFFFFFFFF8LL),\n    0xFFu,\n    8LL * (((unsigned int)badchar - (((_DWORD)badchar + 8) & 0xFFFFFFF8) + 1024) >> 3));\n  if ( size > 0 )\n  {\n    for ( i = 0LL; i != size; ++i )\n      badchar[str[i]] = i;\n  }\n}\n"}, "pseudo_normalize": "void badCharHeuristic(char *str, int size, int *badchar) {\n  long long i;\n  *(uint64_t *)badchar = -1LL;\n  *((uint64_t *)badchar + 127) = -1LL;\n  memset((void *)((unsigned long long)(badchar + 2) & 18446744073709551608LL),\n         255u,\n         8LL * (((unsigned int)badchar -\n                 (((uint32_t)badchar + 8) & 4294967288) + 1024) >>\n                3));\n  if (size > 0) {\n    for (i = 0LL; i != size; ++i) badchar[str[i]] = i;\n  }\n}", "binary": "boyer-moore-search/boyer-moore-search.host.O2", "assembly": "<badCharHeuristic>:\nendbr64\nmov    %rdi,%r8\nlea    0x8(%rdx),%rdi\nmov    %rdx,%rcx\nmov    $0xffffffffffffffff,%rax\nand    $0xfffffffffffffff8,%rdi\nmovq   $0xffffffffffffffff,(%rdx)\nmovq   $0xffffffffffffffff,0x3f8(%rdx)\nsub    %rdi,%rcx\nadd    $0x400,%ecx\nshr    $0x3,%ecx\nrep stos %rax,%es:(%rdi)\ntest   %esi,%esi\njle    1629 <badCharHeuristic+0x59>\nmovslq %esi,%rsi\nxor    %eax,%eax\nnopl   0x0(%rax,%rax,1)\nmovsbq (%r8,%rax,1),%rcx\nmov    %eax,(%rdx,%rcx,4)\nadd    $0x1,%rax\ncmp    %rax,%rsi\njne    1618 <badCharHeuristic+0x48>\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "boyer-moore-search/boyer-moore-search.c", "function_name": "main", "content": "int\nmain(void) \n{ \n  int n = libmin_strlen(inp_txt); // String lengths are public\n  int m = libmin_strlen(inp_pat); // String lengths are public\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  \n  char txt[n];\n  for (int k=0; k < n; k++)\n    txt[k] = inp_txt[k];\n\n  char pat[m];\n  for (int k=0; k < m; k++)\n    pat[k] = inp_pat[k];\n\n  // Return vector\n  int ret[n];\n  for(int i=0; i<n; i++) ret[i] = FALSE; \n\t\n\n  // Run search\n  search(txt, n, pat, m, ret);\n\n  // print results\n  for(int i=0; i<n; i++)\n  {\n    if(ret[i]) \n    { \n      libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "boyer-moore-search/boyer-moore-search.host.O2.pseudo", "function_name": "main", "address": "0x1140", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char *v3; // rax\n  int v4; // r13d\n  int v5; // r14d\n  int v6; // ecx\n  __int64 v7; // rbx\n  __int64 v8; // rdx\n  int *v9; // rsi\n  __int16 v10; // dx\n  signed __int64 v11; // rdx\n  void *v12; // rsp\n  unsigned int v13; // ecx\n  __int64 v14; // rdx\n  unsigned __int64 v15; // rax\n  __int16 v16; // dx\n  signed __int64 v17; // rdx\n  void *v18; // rsp\n  char *v19; // r9\n  __int64 v20; // rdx\n  unsigned __int64 v21; // rax\n  __int16 v22; // dx\n  __int64 v23; // rdx\n  unsigned __int64 v24; // rax\n  __int16 v25; // dx\n  signed __int64 v26; // rdx\n  void *v27; // rsp\n  char *v28; // r9\n  __int64 v29; // rdx\n  unsigned __int64 v30; // rax\n  __int16 v31; // dx\n  signed __int64 v32; // rdx\n  void *v33; // rsp\n  __int64 v34; // r12\n  __int64 v35; // rbx\n  __int64 v36; // rax\n  signed __int64 v37; // rdx\n  void *v38; // rsp\n  __int64 v39; // rax\n  unsigned __int64 v40; // rdx\n  __int16 v41; // ax\n  signed __int64 v42; // rax\n  void *v43; // rsp\n  __int64 v44; // rax\n  unsigned __int64 v45; // rdx\n  __int16 v46; // ax\n  signed __int64 v47; // rax\n  void *v48; // rsp\n  int v50[1022]; // [rsp+8h] [rbp-1060h] BYREF\n  _BYTE v51[12]; // [rsp+1008h] [rbp-60h] BYREF\n  unsigned int v52; // [rsp+1014h] [rbp-54h]\n  char *txt; // [rsp+1018h] [rbp-50h]\n  char *n; // [rsp+1020h] [rbp-48h]\n  unsigned __int64 v55; // [rsp+1030h] [rbp-38h]\n\n  v55 = __readfsqword(0x28u);\n  v3 = (char *)libmin_strlen(inp_txt);\n  v4 = (int)v3;\n  n = v3;\n  v5 = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", v4, v5);\n  v6 = (int)n;\n  v7 = (int)n;\n  v8 = (int)n + 15LL;\n  v9 = (int *)&v51[-(v8 & 0xFFFFFFFFFFFFF000LL)];\n  v10 = v8 & 0xFFF0;\n  if ( v51 != (_BYTE *)v9 )\n  {\n    while ( v50 != v9 )\n      ;\n  }\n  v11 = v10 & 0xFFF;\n  v12 = alloca(v11);\n  if ( v11 )\n    *(_QWORD *)((char *)&v50[-2] + v11) = *(_QWORD *)((char *)&v50[-2] + v11);\n  txt = (char *)v50;\n  if ( v6 > 0 )\n  {\n    LODWORD(n) = v6 - 1;\n    memcpy(v50, inp_txt, (unsigned int)(v6 - 1) + 1LL);\n    v13 = (unsigned int)n;\n    v14 = v5 + 15LL;\n    v15 = v14 & 0xFFFFFFFFFFFFF000LL;\n    v16 = v14 & 0xFFF0;\n    while ( v50 != (int *)((char *)v50 - v15) )\n      ;\n    v17 = v16 & 0xFFF;\n    v18 = alloca(v17);\n    if ( v17 )\n      *(_QWORD *)((char *)&v50[-2] + v17) = *(_QWORD *)((char *)&v50[-2] + v17);\n    v19 = (char *)v50;\n    if ( v5 > 0 )\n    {\n      v52 = v13;\n      n = (char *)v50;\n      memcpy(v50, inp_pat, (unsigned int)(v5 - 1) + 1LL);\n      v13 = v52;\n      v19 = n;\n      v44 = 4 * v7 + 15;\n      v45 = v44 & 0xFFFFFFFFFFFFF000LL;\n      v46 = v44 & 0xFFF0;\n      while ( v50 != (int *)((char *)v50 - v45) )\n        ;\n      v47 = v46 & 0xFFF;\n      v48 = alloca(v47);\n      if ( v47 )\n        *(_QWORD *)((char *)&v50[-2] + v47) = *(_QWORD *)((char *)&v50[-2] + v47);\n    }\n    else\n    {\n      v20 = 4 * v7 + 15;\n      v21 = v20 & 0xFFFFFFFFFFFFF000LL;\n      v22 = v20 & 0xFFF0;\n      while ( v50 != (int *)((char *)v50 - v21) )\n        ;\n      v32 = v22 & 0xFFF;\n      v33 = alloca(v32);\n      if ( v32 )\n        *(_QWORD *)((char *)&v50[-2] + v32) = *(_QWORD *)((char *)&v50[-2] + v32);\n    }\n    v34 = v13;\n    n = v19;\n    v35 = 0LL;\n    memset(v50, 0, 4LL * v13 + 4);\n    search(txt, v4, n, v5, v50);\n    while ( 1 )\n    {\n      if ( v50[v35] )\n      {\n        libmin_printf(\"pattern occurs at shift = %d\\n\", v35);\n        v36 = v35 + 1;\n        if ( v34 == v35 )\n          goto LABEL_29;\n      }\n      else\n      {\n        v36 = v35 + 1;\n        if ( v34 == v35 )\n          goto LABEL_29;\n      }\n      v35 = v36;\n    }\n  }\n  v23 = v5 + 15LL;\n  v24 = v23 & 0xFFFFFFFFFFFFF000LL;\n  v25 = v23 & 0xFFF0;\n  while ( v50 != (int *)((char *)v50 - v24) )\n    ;\n  v26 = v25 & 0xFFF;\n  v27 = alloca(v26);\n  if ( v26 )\n    *(_QWORD *)((char *)&v50[-2] + v26) = *(_QWORD *)((char *)&v50[-2] + v26);\n  v28 = (char *)v50;\n  if ( v5 <= 0 )\n  {\n    v39 = 4 * v7 + 15;\n    v40 = v39 & 0xFFFFFFFFFFFFF000LL;\n    v41 = v39 & 0xFFF0;\n    while ( v50 != (int *)((char *)v50 - v40) )\n      ;\n    v42 = v41 & 0xFFF;\n    v43 = alloca(v42);\n    if ( v42 )\n      *(_QWORD *)((char *)&v50[-2] + v42) = *(_QWORD *)((char *)&v50[-2] + v42);\n  }\n  else\n  {\n    n = (char *)v50;\n    memcpy(v50, inp_pat, (unsigned int)(v5 - 1) + 1LL);\n    v28 = n;\n    v29 = 4 * v7 + 15;\n    v30 = v29 & 0xFFFFFFFFFFFFF000LL;\n    v31 = v29 & 0xFFF0;\n    while ( v50 != (int *)((char *)v50 - v30) )\n      ;\n    v37 = v31 & 0xFFF;\n    v38 = alloca(v37);\n    if ( v37 )\n      *(_QWORD *)((char *)&v50[-2] + v37) = *(_QWORD *)((char *)&v50[-2] + v37);\n  }\n  search(txt, v4, v28, v5, v50);\nLABEL_29:\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  char *v3;\n  int v4;\n  int v5;\n  int v6;\n  long long v7;\n  long long v8;\n  int *v9;\n  short v10;\n  signed long long v11;\n  void *v12;\n  unsigned int v13;\n  long long v14;\n  unsigned long long v15;\n  short v16;\n  signed long long v17;\n  void *v18;\n  char *v19;\n  long long v20;\n  unsigned long long v21;\n  short v22;\n  long long v23;\n  unsigned long long v24;\n  short v25;\n  signed long long v26;\n  void *v27;\n  char *v28;\n  long long v29;\n  unsigned long long v30;\n  short v31;\n  signed long long v32;\n  void *v33;\n  long long v34;\n  long long v35;\n  long long v36;\n  signed long long v37;\n  void *v38;\n  long long v39;\n  unsigned long long v40;\n  short v41;\n  signed long long v42;\n  void *v43;\n  long long v44;\n  unsigned long long v45;\n  short v46;\n  signed long long v47;\n  void *v48;\n  int v50[1022];\n  uint8_t v51[12];\n  unsigned int v52;\n  char *txt;\n  char *n;\n  unsigned long long v55;\n  v55 = __readfsqword(40u);\n  v3 = (char *)libmin_strlen(inp_txt);\n  v4 = (int)v3;\n  n = v3;\n  v5 = libmin_strlen(inp_pat);\n  libmin_printf(\"n = %d, m = %d\\n\", v4, v5);\n  v6 = (int)n;\n  v7 = (int)n;\n  v8 = (int)n + 15LL;\n  v9 = (int *)&v51[-(v8 & 18446744073709547520LL)];\n  v10 = v8 & 65520;\n  if (v51 != (uint8_t *)v9) {\n    while (v50 != v9)\n      ;\n  }\n  v11 = v10 & 4095;\n  v12 = alloca(v11);\n  if (v11)\n    *(uint64_t *)((char *)&v50[-2] + v11) =\n        *(uint64_t *)((char *)&v50[-2] + v11);\n  txt = (char *)v50;\n  if (v6 > 0) {\n    LODWORD(n) = v6 - 1;\n    memcpy(v50, inp_txt, (unsigned int)(v6 - 1) + 1LL);\n    v13 = (unsigned int)n;\n    v14 = v5 + 15LL;\n    v15 = v14 & 18446744073709547520LL;\n    v16 = v14 & 65520;\n    while (v50 != (int *)((char *)v50 - v15))\n      ;\n    v17 = v16 & 4095;\n    v18 = alloca(v17);\n    if (v17)\n      *(uint64_t *)((char *)&v50[-2] + v17) =\n          *(uint64_t *)((char *)&v50[-2] + v17);\n    v19 = (char *)v50;\n    if (v5 > 0) {\n      v52 = v13;\n      n = (char *)v50;\n      memcpy(v50, inp_pat, (unsigned int)(v5 - 1) + 1LL);\n      v13 = v52;\n      v19 = n;\n      v44 = 4 * v7 + 15;\n      v45 = v44 & 18446744073709547520LL;\n      v46 = v44 & 65520;\n      while (v50 != (int *)((char *)v50 - v45))\n        ;\n      v47 = v46 & 4095;\n      v48 = alloca(v47);\n      if (v47)\n        *(uint64_t *)((char *)&v50[-2] + v47) =\n            *(uint64_t *)((char *)&v50[-2] + v47);\n    } else {\n      v20 = 4 * v7 + 15;\n      v21 = v20 & 18446744073709547520LL;\n      v22 = v20 & 65520;\n      while (v50 != (int *)((char *)v50 - v21))\n        ;\n      v32 = v22 & 4095;\n      v33 = alloca(v32);\n      if (v32)\n        *(uint64_t *)((char *)&v50[-2] + v32) =\n            *(uint64_t *)((char *)&v50[-2] + v32);\n    }\n    v34 = v13;\n    n = v19;\n    v35 = 0LL;\n    memset(v50, 0, 4LL * v13 + 4);\n    search(txt, v4, n, v5, v50);\n    while (1) {\n      if (v50[v35]) {\n        libmin_printf(\"pattern occurs at shift = %d\\n\", v35);\n        v36 = v35 + 1;\n        if (v34 == v35) goto LABEL_29;\n      } else {\n        v36 = v35 + 1;\n        if (v34 == v35) goto LABEL_29;\n      }\n      v35 = v36;\n    }\n  }\n  v23 = v5 + 15LL;\n  v24 = v23 & 18446744073709547520LL;\n  v25 = v23 & 65520;\n  while (v50 != (int *)((char *)v50 - v24))\n    ;\n  v26 = v25 & 4095;\n  v27 = alloca(v26);\n  if (v26)\n    *(uint64_t *)((char *)&v50[-2] + v26) =\n        *(uint64_t *)((char *)&v50[-2] + v26);\n  v28 = (char *)v50;\n  if (v5 <= 0) {\n    v39 = 4 * v7 + 15;\n    v40 = v39 & 18446744073709547520LL;\n    v41 = v39 & 65520;\n    while (v50 != (int *)((char *)v50 - v40))\n      ;\n    v42 = v41 & 4095;\n    v43 = alloca(v42);\n    if (v42)\n      *(uint64_t *)((char *)&v50[-2] + v42) =\n          *(uint64_t *)((char *)&v50[-2] + v42);\n  } else {\n    n = (char *)v50;\n    memcpy(v50, inp_pat, (unsigned int)(v5 - 1) + 1LL);\n    v28 = n;\n    v29 = 4 * v7 + 15;\n    v30 = v29 & 18446744073709547520LL;\n    v31 = v29 & 65520;\n    while (v50 != (int *)((char *)v50 - v30))\n      ;\n    v37 = v31 & 4095;\n    v38 = alloca(v37);\n    if (v37)\n      *(uint64_t *)((char *)&v50[-2] + v37) =\n          *(uint64_t *)((char *)&v50[-2] + v37);\n  }\n  search(txt, v4, v28, v5, v50);\nLABEL_29:\n  libmin_success();\n}", "binary": "boyer-moore-search/boyer-moore-search.host.O2", "assembly": "<main>:\nendbr64\npush   %rbp\nlea    0x3ed4(%rip),%r9\nmov    %r9,%rdi\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nlea    0x41bf(%rip),%r12\npush   %rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x38(%rbp)\nxor    %eax,%eax\ncall   2eb0 <libmin_strlen>\nmov    %r12,%rdi\nmov    %eax,%r13d\nmov    %rax,-0x48(%rbp)\ncall   2eb0 <libmin_strlen>\nmov    %r13d,%esi\nlea    0x1e71(%rip),%rdi\nmov    %eax,%edx\nmov    %rax,%r14\nmov    %eax,%r15d\nxor    %eax,%eax\ncall   2ca0 <libmin_printf>\nmov    -0x48(%rbp),%rcx\nmov    %rsp,%rsi\nlea    0x3e70(%rip),%r9\nmovslq %ecx,%rbx\nlea    0xf(%rbx),%rax\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nsub    %rax,%rsi\nand    $0xfffffffffffffff0,%rdx\ncmp    %rsi,%rsp\nje     11e1 <main+0xa1>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\ncmp    %rsi,%rsp\njne    11cc <main+0x8c>\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\njne    1298 <main+0x158>\nmov    %rsp,-0x50(%rbp)\ntest   %ecx,%ecx\njle    12ab <main+0x16b>\nlea    -0x1(%rcx),%edx\nmov    %r9,%rsi\nmov    %rsp,%rdi\nmov    %edx,-0x48(%rbp)\nadd    $0x1,%rdx\ncall   1110 <memcpy@plt>\nmovslq %r14d,%rax\nmov    %rsp,%rsi\nmov    -0x48(%rbp),%ecx\nadd    $0xf,%rax\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nand    $0xfffffffffffffff0,%rdx\nsub    %rax,%rsi\ncmp    %rsi,%rsp\nje     1248 <main+0x108>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1231 <main+0xf1>\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\njne    12a3 <main+0x163>\nmov    %rsp,%r9\ntest   %r14d,%r14d\njg     1465 <main+0x325>\nlea    0xf(,%rbx,4),%rax\nmov    %rsp,%rsi\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nand    $0xfffffffffffffff0,%rdx\nsub    %rax,%rsi\ncmp    %rsi,%rsp\nje     134d <main+0x20d>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    127d <main+0x13d>\norq    $0x0,-0x8(%rsp,%rdx,1)\njmp    11f3 <main+0xb3>\norq    $0x0,-0x8(%rsp,%rdx,1)\njmp    1256 <main+0x116>\nmovslq %r14d,%rax\nmov    %rsp,%rcx\nadd    $0xf,%rax\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nand    $0xfffffffffffffff0,%rdx\nsub    %rax,%rcx\ncmp    %rcx,%rsp\nje     12dc <main+0x19c>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    12c5 <main+0x185>\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\nje     12f0 <main+0x1b0>\norq    $0x0,-0x8(%rsp,%rdx,1)\nmov    %rsp,%r9\ntest   %r14d,%r14d\njle    141d <main+0x2dd>\nlea    -0x1(%r14),%edx\nmov    %r12,%rsi\nmov    %rsp,%rdi\nmov    %r9,-0x48(%rbp)\nadd    $0x1,%rdx\ncall   1110 <memcpy@plt>\nlea    0xf(,%rbx,4),%rax\nmov    %rsp,%rcx\nmov    -0x48(%rbp),%r9\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nand    $0xfffffffffffffff0,%rdx\nsub    %rax,%rcx\ncmp    %rcx,%rsp\nje     13f2 <main+0x2b2>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1332 <main+0x1f2>\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\nje     1361 <main+0x221>\norq    $0x0,-0x8(%rsp,%rdx,1)\nmov    %ecx,%r12d\nmov    %rsp,%r14\nxor    %esi,%esi\nmov    %r9,-0x48(%rbp)\nlea    0x4(,%r12,4),%rdx\nmov    %r14,%rdi\nxor    %ebx,%ebx\ncall   10e0 <memset@plt>\nmov    -0x48(%rbp),%rdx\nmov    -0x50(%rbp),%rdi\nmov    %r13d,%esi\nmov    %r14,%r8\nmov    %r15d,%ecx\nlea    0x1c7d(%rip),%r13\ncall   1630 <search>\njmp    13ac <main+0x26c>\nxchg   %ax,%ax\nlea    0x1(%rbx),%rax\ncmp    %rbx,%r12\nje     13c9 <main+0x289>\nmov    %rax,%rbx\nmov    (%r14,%rbx,4),%eax\nmov    %ebx,%esi\ntest   %eax,%eax\nje     13a0 <main+0x260>\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   2ca0 <libmin_printf>\nlea    0x1(%rbx),%rax\ncmp    %rbx,%r12\njne    13a9 <main+0x269>\ncall   2ee0 <libmin_success>\nmov    -0x38(%rbp),%rax\nsub    %fs:0x28,%rax\njne    14b9 <main+0x379>\nlea    -0x28(%rbp),%rsp\nxor    %eax,%eax\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\nje     1406 <main+0x2c6>\norq    $0x0,-0x8(%rsp,%rdx,1)\nmov    -0x50(%rbp),%rdi\nmov    %rsp,%r8\nmov    %r15d,%ecx\nmov    %r9,%rdx\nmov    %r13d,%esi\ncall   1630 <search>\njmp    13c9 <main+0x289>\nlea    0xf(,%rbx,4),%rdx\nmov    %rsp,%rcx\nmov    %rdx,%rax\nand    $0xfffffffffffff000,%rdx\nand    $0xfffffffffffffff0,%rax\nsub    %rdx,%rcx\ncmp    %rcx,%rsp\nje     1450 <main+0x310>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    1439 <main+0x2f9>\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     1406 <main+0x2c6>\norq    $0x0,-0x8(%rsp,%rax,1)\njmp    1406 <main+0x2c6>\nlea    -0x1(%r14),%edx\nmov    %r12,%rsi\nmov    %rsp,%rdi\nmov    %ecx,-0x54(%rbp)\nadd    $0x1,%rdx\nmov    %r9,-0x48(%rbp)\ncall   1110 <memcpy@plt>\nmov    %rsp,%rsi\nmov    -0x54(%rbp),%ecx\nmov    -0x48(%rbp),%r9\nlea    0xf(,%rbx,4),%rdx\nmov    %rdx,%rax\nand    $0xfffffffffffff000,%rdx\nand    $0xfffffffffffffff0,%rax\nsub    %rdx,%rsi\ncmp    %rsi,%rsp\nje     14be <main+0x37e>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\njmp    14a2 <main+0x362>\ncall   10d0 <__stack_chk_fail@plt>\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     1361 <main+0x221>\norq    $0x0,-0x8(%rsp,%rax,1)\njmp    1361 <main+0x221>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "boyer-moore-search/boyer-moore-search.c", "function_name": "search", "content": "/* A pattern searching function that uses Bad\nCharacter Heuristic of Boyer Moore Algorithm */\nvoid search(char *txt, int n, char *pat, int m, int *ret)\n{\n\tint badchar[NO_OF_CHARS];\n\n\t/* Fill the bad character array by calling\n\tthe preprocessing function badCharHeuristic()\n\tfor given pattern */\n\tbadCharHeuristic(pat, m, badchar);\n\n\tint s = 0; // s is shift of the pattern with\n\t\t\t\t     // respect to text\n  \n\tfor(int l=0; l<=(n - m); l++)\n\t{\n    //Early exit if not data-oblivious... \n    if (s > (n-m)) break;\n\n\t\tint idx = m-1;\n\n\t\t/* Keep reducing index idx of pattern while\n\t\tcharacters of pattern and text are\n\t\tmatching at this shift s */\n\t\twhile(idx >= 0 && pat[idx] == txt[s+idx])\n    {\n\t\t\tidx--;\n    }\n\n\t\t/* If the pattern is present at current\n\t\tshift, then index idx will become -1 after\n\t\tthe above loop */\n    int cond = (idx < 0);\n    if(cond)\n    {\n      ret[s] = TRUE; \n\t\t\ts += (s+m < n)? m-badchar[(int)txt[s+m]] : 1;\n    }\n\t\telse \n    {\n      int s_shift = idx - badchar[(int)txt[s+idx]];\n\t\t\ts += 1 > s_shift ? 1 : s_shift;\n    }\n\t}\n}\n"}, "pseudo": {"path": "boyer-moore-search/boyer-moore-search.host.O2.pseudo", "function_name": "search", "address": "0x1630", "label": "search", "content": "void __fastcall search(char *txt, int n, char *pat, int m, int *ret)\n{\n  __int64 v8; // rax\n  int v9; // r13d\n  int v10; // r12d\n  int v11; // ebp\n  int v12; // r9d\n  __int64 v13; // r14\n  __int64 v14; // rax\n  __int64 v15; // rdx\n  int v16; // ecx\n  int v17; // eax\n  int v18; // eax\n  int badchar[258]; // [rsp+0h] [rbp-438h] BYREF\n  unsigned __int64 v20; // [rsp+408h] [rbp-30h]\n\n  v20 = __readfsqword(0x28u);\n  memset(badchar, 0xFFu, 0x400uLL);\n  v8 = 0LL;\n  if ( m > 0 )\n  {\n    do\n    {\n      badchar[pat[v8]] = v8;\n      ++v8;\n    }\n    while ( m != v8 );\n  }\n  v9 = n - m;\n  if ( n - m >= 0 )\n  {\n    v10 = m - 1;\n    v11 = 0;\n    v12 = 0;\n    do\n    {\n      v13 = v12;\n      if ( v10 < 0 )\n      {\nLABEL_16:\n        ret[v13] = 1;\n        if ( m + v12 < n )\n          v18 = m - badchar[txt[m + v12]];\n        else\n          v18 = 1;\n        v12 += v18;\n      }\n      else\n      {\n        v13 = v12;\n        v14 = v10;\n        while ( 1 )\n        {\n          v15 = txt[v12 + v14];\n          if ( pat[v14] != (_BYTE)v15 )\n            break;\n          if ( (int)--v14 < 0 )\n            goto LABEL_16;\n        }\n        v16 = v14 - badchar[v15];\n        if ( v16 <= 0 )\n          v16 = 1;\n        v12 += v16;\n      }\n      v17 = ++v11;\n      if ( v12 >= v11 )\n        v17 = v12;\n    }\n    while ( v9 >= v17 );\n  }\n}\n"}, "pseudo_normalize": "void search(char *txt, int n, char *pat, int m, int *ret) {\n  long long v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  long long v13;\n  long long v14;\n  long long v15;\n  int v16;\n  int v17;\n  int v18;\n  int badchar[258];\n  unsigned long long v20;\n  v20 = __readfsqword(40u);\n  memset(badchar, 255u, 1024uLL);\n  v8 = 0LL;\n  if (m > 0) {\n    do {\n      badchar[pat[v8]] = v8;\n      ++v8;\n    } while (m != v8);\n  }\n  v9 = n - m;\n  if (n - m >= 0) {\n    v10 = m - 1;\n    v11 = 0;\n    v12 = 0;\n    do {\n      v13 = v12;\n      if (v10 < 0) {\n      LABEL_16:\n        ret[v13] = 1;\n        if (m + v12 < n)\n          v18 = m - badchar[txt[m + v12]];\n        else\n          v18 = 1;\n        v12 += v18;\n      } else {\n        v13 = v12;\n        v14 = v10;\n        while (1) {\n          v15 = txt[v12 + v14];\n          if (pat[v14] != (uint8_t)v15) break;\n          if ((int)--v14 < 0) goto LABEL_16;\n        }\n        v16 = v14 - badchar[v15];\n        if (v16 <= 0) v16 = 1;\n        v12 += v16;\n      }\n      v17 = ++v11;\n      if (v12 >= v11) v17 = v12;\n    } while (v9 >= v17);\n  }\n}", "binary": "boyer-moore-search/boyer-moore-search.host.O2", "assembly": "<search>:\nendbr64\npush   %r14\nmov    %esi,%r11d\nmov    %rdx,%rsi\nmov    %rdi,%r10\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %ecx,%ebx\nmov    $0x80,%ecx\nsub    $0x410,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x408(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdx\nmov    $0xffffffffffffffff,%rax\nmov    %rdx,%rdi\nrep stos %rax,%es:(%rdi)\nmovslq %ebx,%rcx\nxor    %eax,%eax\ntest   %ebx,%ebx\njle    1691 <search+0x61>\nnop\nmovsbq (%rsi,%rax,1),%rdx\nmov    %eax,(%rsp,%rdx,4)\nadd    $0x1,%rax\ncmp    %rax,%rcx\njne    1680 <search+0x50>\nmov    %r11d,%r13d\nsub    %ebx,%r13d\njs     16f5 <search+0xc5>\nlea    -0x1(%rbx),%r12d\nxor    %ebp,%ebp\nxor    %r9d,%r9d\nnopw   0x0(%rax,%rax,1)\nmovslq %r9d,%r14\ntest   %r12d,%r12d\njs     1720 <search+0xf0>\nmovslq %r9d,%r14\nmovslq %r12d,%rax\nlea    (%r10,%r14,1),%rdi\njmp    16c8 <search+0x98>\nnopl   0x0(%rax)\nsub    $0x1,%rax\ntest   %eax,%eax\njs     1720 <search+0xf0>\nmovsbq (%rdi,%rax,1),%rdx\nmov    %eax,%ecx\ncmp    %dl,(%rsi,%rax,1)\nje     16c0 <search+0x90>\nsub    (%rsp,%rdx,4),%ecx\nmov    $0x1,%eax\ntest   %ecx,%ecx\ncmovle %eax,%ecx\nadd    %ecx,%r9d\nadd    $0x1,%ebp\ncmp    %ebp,%r9d\nmov    %ebp,%eax\ncmovge %r9d,%eax\ncmp    %eax,%r13d\njge    16a8 <search+0x78>\nmov    0x408(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1750 <search+0x120>\nadd    $0x410,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nlea    (%rbx,%r9,1),%eax\nmovl   $0x1,(%r8,%r14,4)\ncmp    %r11d,%eax\njl     1740 <search+0x110>\nmov    $0x1,%eax\nadd    %eax,%r9d\njmp    16e4 <search+0xb4>\nnopl   0x0(%rax,%rax,1)\ncltq\nmov    %ebx,%edi\nmovsbq (%r10,%rax,1),%rax\nsub    (%rsp,%rax,4),%edi\nmov    %edi,%eax\njmp    1736 <search+0x106>\ncall   10d0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "bubble-sort/bubble-sort.c", "function_name": "bubblesort", "content": "void\nbubblesort(int *data, unsigned size)\n{\n  for (unsigned i=0; i < size-1; i++)\n  {\n    int swapped = FALSE;\n    for (unsigned j=0; j < size-1; j++)\n    {\n      if (data[j] > data[j+1])\n      {\n        int tmp = data[j];\n        data[j] = data[j+1];\n        data[j+1] = tmp;\n        swapped = TRUE;\n        swaps++;\n      }\n    }\n    // done?\n    if (!swapped)\n      break;\n  }\n}\n"}, "pseudo": {"path": "bubble-sort/bubble-sort.host.O2.pseudo", "function_name": "bubblesort", "address": "0x1330", "label": "bubblesort", "content": "void __fastcall bubblesort(int *data, unsigned int size)\n{\n  unsigned int v2; // esi\n  int v3; // ebx\n  int v4; // eax\n  int v5; // r11d\n  __int64 v6; // rdx\n  int *v7; // r9\n  int *v8; // rcx\n  int v9; // r8d\n\n  v2 = size - 1;\n  if ( v2 )\n  {\n    v3 = 0;\nLABEL_3:\n    while ( 2 )\n    {\n      v4 = 0;\n      v5 = 0;\n      v6 = 0LL;\n      do\n      {\n        while ( 1 )\n        {\n          v7 = &data[v6];\n          v6 = (unsigned int)(v4 + 1);\n          v8 = &data[v6];\n          v9 = *v7;\n          ++v4;\n          if ( *v7 <= *v8 )\n            break;\n          *v7 = *v8;\n          v5 = 1;\n          *v8 = v9;\n          ++swaps;\n          if ( (unsigned int)v6 >= v2 )\n          {\n            if ( ++v3 < v2 )\n              goto LABEL_3;\n            return;\n          }\n        }\n      }\n      while ( (unsigned int)v6 < v2 );\n      if ( v5 )\n      {\n        if ( ++v3 < v2 )\n          continue;\n      }\n      break;\n    }\n  }\n}\n"}, "pseudo_normalize": "void bubblesort(int *data, unsigned int size) {\n  unsigned int v2;\n  int v3;\n  int v4;\n  int v5;\n  long long v6;\n  int *v7;\n  int *v8;\n  int v9;\n  v2 = size - 1;\n  if (v2) {\n    v3 = 0;\n  LABEL_3:\n    while (2) {\n      v4 = 0;\n      v5 = 0;\n      v6 = 0LL;\n      do {\n        while (1) {\n          v7 = &data[v6];\n          v6 = (unsigned int)(v4 + 1);\n          v8 = &data[v6];\n          v9 = *v7;\n          ++v4;\n          if (*v7 <= *v8) break;\n          *v7 = *v8;\n          v5 = 1;\n          *v8 = v9;\n          ++swaps;\n          if ((unsigned int)v6 >= v2) {\n            if (++v3 < v2) goto LABEL_3;\n            return;\n          }\n        }\n      } while ((unsigned int)v6 < v2);\n      if (v5) {\n        if (++v3 < v2) continue;\n      }\n      break;\n    }\n  }\n}", "binary": "bubble-sort/bubble-sort.host.O2", "assembly": "<bubblesort>:\nendbr64\nsub    $0x1,%esi\nje     13a2 <bubblesort+0x72>\npush   %rbx\nxor    %ebx,%ebx\nnopl   0x0(%rax)\nxor    %eax,%eax\nxor    %r11d,%r11d\nxor    %edx,%edx\nnopw   0x0(%rax,%rax,1)\nlea    (%rdi,%rdx,4),%r9\nlea    0x1(%rax),%edx\nlea    (%rdi,%rdx,4),%rcx\nmov    (%r9),%r8d\nmov    %rdx,%rax\nmov    (%rcx),%r10d\ncmp    %r10d,%r8d\njle    1390 <bubblesort+0x60>\nmov    %r10d,(%r9)\nmov    $0x1,%r11d\nmov    %r8d,(%rcx)\naddq   $0x1,0x3f03(%rip)\ncmp    %esi,%edx\njb     1350 <bubblesort+0x20>\nadd    $0x1,%ebx\ncmp    %esi,%ebx\njb     1340 <bubblesort+0x10>\npop    %rbx\nret\nnopw   0x0(%rax,%rax,1)\ncmp    %esi,%edx\njb     1350 <bubblesort+0x20>\ntest   %r11d,%r11d\nje     1388 <bubblesort+0x58>\nadd    $0x1,%ebx\ncmp    %esi,%ebx\njb     1340 <bubblesort+0x10>\njmp    1388 <bubblesort+0x58>\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "bubble-sort/bubble-sort.c", "function_name": "main", "content": "int\nmain(void)\n{\n  // initialize the pseudo-RNG\n  libmin_srand(42);\n  // mysrand(time(NULL));\n\n  // initialize the array to sort\n  for (unsigned i=0; i < DATASET_SIZE; i++)\n    data[i] = libmin_rand();\n  print_data(data, DATASET_SIZE);\n\n  {\n    // performance monitoring\n    libtarg_start_perf();\n\n    bubblesort(data, DATASET_SIZE);\n\n    libtarg_stop_perf();\n  }\n  print_data(data, DATASET_SIZE);\n\n  // check the array\n  for (unsigned i=0; i < DATASET_SIZE-1; i++)\n  {\n    if (data[i] > data[i+1])\n    {\n      libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n      return -1;\n    }\n  }\n  libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n  libmin_printf(\"INFO: data is properly sorted.\\n\");\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "bubble-sort/bubble-sort.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // rbp\n  int *v4; // rbx\n  int v5; // edx\n  int *v6; // rax\n  int v7; // ecx\n\n  v3 = &data[256];\n  v4 = data;\n  libmin_srand(0x2Au);\n  do\n    *v4++ = libmin_rand();\n  while ( v4 != v3 );\n  print_data(data, 0x100u);\n  libtarg_start_perf();\n  bubblesort(data, 0x100u);\n  libtarg_stop_perf();\n  print_data(data, 0x100u);\n  v5 = data[0];\n  v6 = &data[1];\n  while ( 1 )\n  {\n    v7 = v5;\n    v5 = *v6;\n    if ( *v6 < v7 )\n      break;\n    if ( ++v6 == v3 )\n    {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  int *v4;\n  int v5;\n  int *v6;\n  int v7;\n  v3 = &data[256];\n  v4 = data;\n  libmin_srand(42u);\n  do *v4++ = libmin_rand();\n  while (v4 != v3);\n  print_data(data, 256u);\n  libtarg_start_perf();\n  bubblesort(data, 256u);\n  libtarg_stop_perf();\n  print_data(data, 256u);\n  v5 = data[0];\n  v6 = &data[1];\n  while (1) {\n    v7 = v5;\n    v5 = *v6;\n    if (*v6 < v7) break;\n    if (++v6 == v3) {\n      libmin_printf(\"INFO: %lu swaps executed.\\n\", swaps);\n      libmin_printf(\"INFO: data is properly sorted.\\n\");\n      libmin_success();\n    }\n  }\n  libmin_printf(\"ERROR: data is not properly sorted.\\n\");\n  return -1;\n}", "binary": "bubble-sort/bubble-sort.host.O2", "assembly": "<main>:\nendbr64\npush   %r12\nmov    $0x2a,%edi\nlea    0x418e(%rip),%r12\npush   %rbp\nlea    0x400(%r12),%rbp\npush   %rbx\nmov    %r12,%rbx\ncall   2b00 <libmin_srand>\nnopl   0x0(%rax)\ncall   2b60 <libmin_rand>\nadd    $0x4,%rbx\nmov    %eax,-0x4(%rbx)\ncmp    %rbp,%rbx\njne    1128 <main+0x28>\nmov    $0x100,%esi\nmov    %r12,%rdi\ncall   12d0 <print_data>\nxor    %eax,%eax\ncall   1480 <libtarg_start_perf>\nmov    $0x100,%esi\nmov    %r12,%rdi\ncall   1330 <bubblesort>\nxor    %eax,%eax\ncall   1500 <libtarg_stop_perf>\nmov    $0x100,%esi\nmov    %r12,%rdi\ncall   12d0 <print_data>\nmov    0x412c(%rip),%edx\nlea    0x4129(%rip),%rax\njmp    1189 <main+0x89>\nnopl   (%rax)\nadd    $0x4,%rax\ncmp    %rbp,%rax\nje     11a9 <main+0xa9>\nmov    %edx,%ecx\nmov    (%rax),%edx\ncmp    %ecx,%edx\njge    1180 <main+0x80>\nlea    0x1ea8(%rip),%rdi\nxor    %eax,%eax\ncall   28f0 <libmin_printf>\nmov    $0xffffffff,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    0x40d0(%rip),%rsi\nlea    0x1e6a(%rip),%rdi\nxor    %eax,%eax\ncall   28f0 <libmin_printf>\nlea    0x1ea3(%rip),%rdi\nxor    %eax,%eax\ncall   28f0 <libmin_printf>\ncall   2d40 <libmin_success>\nxor    %eax,%eax\njmp    11a4 <main+0xa4>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "bubble-sort/bubble-sort.c", "function_name": "print_data", "content": "void\nprint_data(int *data, unsigned size)\n{\n  libmin_printf(\"DATA DUMP:\\n\");\n  for (unsigned i=0; i < size; i++)\n    libmin_printf(\"  data[%u] = %d\\n\", i, data[i]);\n}\n"}, "pseudo": {"path": "bubble-sort/bubble-sort.host.O2.pseudo", "function_name": "print_data", "address": "0x12d0", "label": "print_data", "content": "void __fastcall print_data(int *data, unsigned int size)\n{\n  __int64 v2; // rbp\n  __int64 v3; // rbx\n  int v4; // edx\n  int v5; // esi\n\n  v2 = size;\n  libmin_printf(\"DATA DUMP:\\n\");\n  if ( size )\n  {\n    v3 = 0LL;\n    do\n    {\n      v4 = data[v3];\n      v5 = v3++;\n      libmin_printf(\"  data[%u] = %d\\n\", v5, v4);\n    }\n    while ( v3 != v2 );\n  }\n}\n"}, "pseudo_normalize": "void print_data(int *data, unsigned int size) {\n  long long v2;\n  long long v3;\n  int v4;\n  int v5;\n  v2 = size;\n  libmin_printf(\"DATA DUMP:\\n\");\n  if (size) {\n    v3 = 0LL;\n    do {\n      v4 = data[v3];\n      v5 = v3++;\n      libmin_printf(\"  data[%u] = %d\\n\", v5, v4);\n    } while (v3 != v2);\n  }\n}", "binary": "bubble-sort/bubble-sort.host.O2", "assembly": "<print_data>:\nendbr64\npush   %r13\nxor    %eax,%eax\npush   %r12\nmov    %rdi,%r12\nlea    0x1d20(%rip),%rdi\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nsub    $0x8,%rsp\ncall   28f0 <libmin_printf>\ntest   %ebp,%ebp\nje     1319 <print_data+0x49>\nxor    %ebx,%ebx\nlea    0x1d12(%rip),%r13\nxchg   %ax,%ax\nmov    (%r12,%rbx,4),%edx\nmov    %ebx,%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   28f0 <libmin_printf>\ncmp    %rbp,%rbx\njne    1300 <print_data+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "enum_declaration", "content": "void enum_declaration() {\n    // parse enum [id] { a = 1, b = 3, ...}\n    long i;\n    i = 0;\n    while (token != '}') {\n        if (token != Id) {\n            libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, token);\n            libmin_fail(-1);\n        }\n        next();\n        if (token == Assign) {\n            // like {a=10}\n            next();\n            if (token != Num) {\n                libmin_printf(\"%ld: bad enum initializer\\n\", line);\n                libmin_fail(-1);\n            }\n            i = token_val;\n            next();\n        }\n\n        current_id[Class] = Num;\n        current_id[Type] = INT;\n        current_id[Value] = i++;\n\n        if (token == ',') {\n            next();\n        }\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O2.pseudo", "function_name": "enum_declaration", "address": "0x34f0", "label": "enum_declaration", "content": "void __cdecl enum_declaration()\n{\n  __int64 v0; // rdx\n  __int64 v1; // rbp\n  __int64 v2; // rbx\n  __int64 *v3; // rax\n\n  v0 = token;\n  if ( token != 125 )\n  {\n    v1 = 0LL;\n    do\n    {\n      while ( 1 )\n      {\n        if ( v0 != 133 )\n        {\n          libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, v0);\n          libmin_fail(-1);\n        }\n        v2 = v1;\n        next();\n        v0 = token;\n        if ( token == 142 )\n        {\n          next();\n          if ( token != 128 )\n          {\n            libmin_printf(\"%ld: bad enum initializer\\n\", line);\n            libmin_fail(-1);\n          }\n          v2 = token_val;\n          next();\n          v0 = token;\n        }\n        v3 = current_id;\n        v1 = v2 + 1;\n        current_id[4] = 128LL;\n        v3[3] = 1LL;\n        v3[5] = v2;\n        if ( v0 == 44 )\n          break;\n        if ( v0 == 125 )\n          return;\n      }\n      next();\n      v0 = token;\n    }\n    while ( token != 125 );\n  }\n}\n"}, "pseudo_normalize": "void enum_declaration() {\n  long long v0;\n  long long v1;\n  long long v2;\n  long long *v3;\n  v0 = token;\n  if (token != 125) {\n    v1 = 0LL;\n    do {\n      while (1) {\n        if (v0 != 133) {\n          libmin_printf(\"%ld: bad enum identifier %ld\\n\", line, v0);\n          libmin_fail(-1);\n        }\n        v2 = v1;\n        next();\n        v0 = token;\n        if (token == 142) {\n          next();\n          if (token != 128) {\n            libmin_printf(\"%ld: bad enum initializer\\n\", line);\n            libmin_fail(-1);\n          }\n          v2 = token_val;\n          next();\n          v0 = token;\n        }\n        v3 = current_id;\n        v1 = v2 + 1;\n        current_id[4] = 128LL;\n        v3[3] = 1LL;\n        v3[5] = v2;\n        if (v0 == 44) break;\n        if (v0 == 125) return;\n      }\n      next();\n      v0 = token;\n    } while (token != 125);\n  }\n}", "binary": "c-interp/c-interp.host.O2", "assembly": "<enum_declaration>:\nendbr64\nmov    0x6e55(%rip),%rdx\ncmp    $0x7d,%rdx\nje     3600 <enum_declaration+0x110>\npush   %r13\nlea    0x3be8(%rip),%r13\npush   %r12\nlea    0x3bc1(%rip),%r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nsub    $0x8,%rsp\njmp    352e <enum_declaration+0x3e>\nnopl   0x0(%rax)\ncmp    $0x7d,%rdx\nje     35a5 <enum_declaration+0xb5>\ncmp    $0x85,%rdx\nje     3552 <enum_declaration+0x62>\nmov    0x6d92(%rip),%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nxor    %eax,%eax\nmov    %rbp,%rbx\ncall   1580 <next>\nmov    0x6ded(%rip),%rdx\ncmp    $0x8e,%rdx\nje     35b0 <enum_declaration+0xc0>\nmov    0x6d6d(%rip),%rax\nlea    0x1(%rbx),%rbp\nmovq   $0x80,0x20(%rax)\nmovq   $0x1,0x18(%rax)\nmov    %rbx,0x28(%rax)\ncmp    $0x2c,%rdx\njne    3528 <enum_declaration+0x38>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x6db1(%rip),%rdx\ncmp    $0x7d,%rdx\njne    352e <enum_declaration+0x3e>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nxor    %eax,%eax\ncall   1580 <next>\ncmpq   $0x80,0x6d8e(%rip)\nje     35df <enum_declaration+0xef>\nmov    0x6d05(%rip),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nxor    %eax,%eax\nmov    0x6ce0(%rip),%rbx\ncall   1580 <next>\nmov    0x6d5c(%rip),%rdx\njmp    356c <enum_declaration+0x7c>\nnopl   0x0(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "eval", "content": "long eval() {\n    long op, *tmp;\n    cycle = 0;\n    while (1) {\n        cycle ++;\n        op = *pc++; // get next operation code\n\n        // print debug info\n        if (debug) {\n            libmin_printf(\"%ld> %.4s\", cycle,\n                   & \"LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,\"\n                   \"OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\"\n                   \"OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT\"[op * 5]);\n            if (op <= ADJ)\n                libmin_printf(\" %ld\\n\", *pc);\n            else\n                libmin_printf(\"\\n\");\n        }\n        if (op == IMM)       {ax = *pc++;}                                     // load immediate value to ax\n        else if (op == LC)   {ax = *(char *)ax;}                               // load character to ax, address in ax\n        else if (op == LI)   {ax = *(long *)ax;}                                // load integer to ax, address in ax\n        else if (op == SC)   {ax = *(char *)*sp++ = ax;}                       // save character to address, value in ax, address on stack\n        else if (op == SI)   {*(long *)*sp++ = ax;}                             // save integer to address, value in ax, address on stack\n        else if (op == PUSH) {*--sp = ax;}                                     // push the value of ax onto the stack\n        else if (op == JMP)  {pc = (long *)*pc;}                                // jump to the address\n        else if (op == JZ)   {pc = ax ? pc + 1 : (long *)*pc;}                   // jump if ax is zero\n        else if (op == JNZ)  {pc = ax ? (long *)*pc : pc + 1;}                   // jump if ax is not zero\n        else if (op == CALL) {*--sp = (long)(pc+1); pc = (long *)*pc;}           // call subroutine\n        //else if (op == RET)  {pc = (long *)*sp++;}                              // return from subroutine;\n        else if (op == ENT)  {*--sp = (long)bp; bp = sp; sp = sp - *pc++;}      // make new stack frame\n        else if (op == ADJ)  {sp = sp + *pc++;}                                // add esp, <size>\n        else if (op == LEV)  {sp = bp; bp = (long *)*sp++; pc = (long *)*sp++;}  // restore call frame and PC\n        else if (op == LEA)  {ax = (long)(bp + *pc++);}                         // load address for arguments.\n\n        else if (op == OR)  ax = *sp++ | ax;\n        else if (op == XOR) ax = *sp++ ^ ax;\n        else if (op == AND) ax = *sp++ & ax;\n        else if (op == EQ)  ax = *sp++ == ax;\n        else if (op == NE)  ax = *sp++ != ax;\n        else if (op == LT)  ax = *sp++ < ax;\n        else if (op == LE)  ax = *sp++ <= ax;\n        else if (op == GT)  ax = *sp++ >  ax;\n        else if (op == GE)  ax = *sp++ >= ax;\n        else if (op == SHL) ax = *sp++ << ax;\n        else if (op == SHR) ax = *sp++ >> ax;\n        else if (op == ADD) ax = *sp++ + ax;\n        else if (op == SUB) ax = *sp++ - ax;\n        else if (op == MUL) ax = *sp++ * ax;\n        else if (op == DIV) ax = *sp++ / ax;\n        else if (op == MOD) ax = *sp++ % ax;\n\n        else if (op == EXIT) { libmin_printf(\"exit(%ld)\", *sp); return *sp;}\n        // else if (op == OPEN) { ax = open((char *)sp[1], sp[0]); }\n        // else if (op == CLOS) { ax = close(*sp);}\n        // else if (op == READ) { ax = read(sp[2], (char *)sp[1], *sp); }\n        else if (op == PRTF) { tmp = sp + pc[1]; ax = libmin_printf((char *)tmp[-1], tmp[-2], tmp[-3], tmp[-4], tmp[-5], tmp[-6]); }\n        // else if (op == MALC) { ax = (long)malloc(*sp);}\n        else if (op == MSET) { ax = (long)libmin_memset((char *)sp[2], sp[1], *sp);}\n        else if (op == MCMP) { ax = libmin_memcmp((char *)sp[2], (char *)sp[1], *sp);}\n        else {\n            libmin_printf(\"unknown instruction:%ld\\n\", op);\n            return -1;\n        }\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O2.pseudo", "function_name": "eval", "address": "0x3e90", "label": "eval", "content": "__int64 __cdecl eval()\n{\n  __int64 *v0; // rax\n  __int64 i; // rsi\n  __int64 v2; // rsi\n  __int64 v3; // r14\n  __int64 *v5; // rax\n  __int64 v6; // rax\n  __int64 v7; // rdx\n  __int64 v8; // rax\n  __int64 *v9; // rdx\n  __int64 v10; // rax\n  __int64 v11; // rax\n  bool v12; // al\n  bool v13; // al\n  bool v14; // al\n  bool v15; // al\n  bool v16; // al\n  bool v17; // al\n  __int64 *v18; // rax\n  char v19; // al\n  _BYTE *v20; // rdx\n  _QWORD *v21; // rax\n  __int64 *v22; // rax\n  __int64 *v23; // rdx\n  __int64 *v24; // rax\n  __int64 **v25; // rax\n  __int64 *v26; // rdx\n\n  v0 = pc;\n  for ( i = 0LL; ; i = cycle )\n  {\n    v2 = i + 1;\n    cycle = v2;\n    v3 = *v0;\n    pc = v0 + 1;\n    if ( !debug )\n      goto LABEL_3;\n    libmin_printf(\"%ld> %.4s\", v2, &aLeaImmJmpCallJ[5 * v3]);\n    if ( v3 > 7 )\n      break;\n    libmin_printf((char *)\" %ld\\n\", *pc);\nLABEL_3:\n    if ( v3 != 1 )\n      goto LABEL_4;\n    v0 = pc + 1;\n    qword_A2F0 = *pc;\nLABEL_6:\n    ;\n  }\n  libmin_printf((char *)\"\\n\");\n  if ( (unsigned __int64)v3 <= 0x25 )\n  {\nLABEL_4:\n    switch ( v3 )\n    {\n      case 0LL:\n        v0 = pc + 1;\n        qword_A2F0 = (__int64)&qword_A300[*pc];\n        goto LABEL_6;\n      case 2LL:\n        v0 = (__int64 *)*pc;\n        goto LABEL_6;\n      case 3LL:\n        v26 = qword_A2F8;\n        v25 = (__int64 **)pc;\n        --qword_A2F8;\n        *(v26 - 1) = (__int64)(pc + 1);\n        goto LABEL_44;\n      case 4LL:\n        v25 = (__int64 **)pc;\n        if ( qword_A2F0 )\n          v0 = pc + 1;\n        else\nLABEL_44:\n          v0 = *v25;\n        goto LABEL_6;\n      case 5LL:\n        v0 = pc + 1;\n        if ( qword_A2F0 )\n          v0 = (__int64 *)*pc;\n        goto LABEL_6;\n      case 6LL:\n        v24 = qword_A2F8;\n        *(qword_A2F8 - 1) = (__int64)qword_A300;\n        qword_A300 = v24 - 1;\n        v0 = pc + 1;\n        qword_A2F8 = &qword_A300[-*pc];\n        goto LABEL_6;\n      case 7LL:\n        v0 = pc + 1;\n        qword_A2F8 += *pc;\n        goto LABEL_6;\n      case 8LL:\n        v22 = qword_A300;\n        qword_A300 = (__int64 *)*qword_A300;\n        v23 = v22 + 2;\n        v0 = (__int64 *)v22[1];\n        qword_A2F8 = v23;\n        goto LABEL_6;\n      case 9LL:\n        qword_A2F0 = *(_QWORD *)qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 10LL:\n        qword_A2F0 = *(char *)qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 11LL:\n        v21 = (_QWORD *)*qword_A2F8++;\n        *v21 = qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 12LL:\n        v19 = qword_A2F0;\n        v20 = (_BYTE *)*qword_A2F8++;\n        *v20 = qword_A2F0;\n        qword_A2F0 = v19;\n        v0 = pc;\n        goto LABEL_6;\n      case 13LL:\n        v18 = qword_A2F8--;\n        *(v18 - 1) = qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 14LL:\n        qword_A2F0 |= *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 15LL:\n        qword_A2F0 ^= *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 16LL:\n        qword_A2F0 &= *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 17LL:\n        v17 = *qword_A2F8++ == qword_A2F0;\n        qword_A2F0 = v17;\n        v0 = pc;\n        goto LABEL_6;\n      case 18LL:\n        v16 = *qword_A2F8++ != qword_A2F0;\n        qword_A2F0 = v16;\n        v0 = pc;\n        goto LABEL_6;\n      case 19LL:\n        v15 = *qword_A2F8++ < qword_A2F0;\n        qword_A2F0 = v15;\n        v0 = pc;\n        goto LABEL_6;\n      case 20LL:\n        v14 = *qword_A2F8++ > qword_A2F0;\n        qword_A2F0 = v14;\n        v0 = pc;\n        goto LABEL_6;\n      case 21LL:\n        v13 = *qword_A2F8++ <= qword_A2F0;\n        qword_A2F0 = v13;\n        v0 = pc;\n        goto LABEL_6;\n      case 22LL:\n        v12 = *qword_A2F8++ >= qword_A2F0;\n        qword_A2F0 = v12;\n        v0 = pc;\n        goto LABEL_6;\n      case 23LL:\n        v11 = *qword_A2F8++;\n        qword_A2F0 = v11 << qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 24LL:\n        v10 = *qword_A2F8++;\n        qword_A2F0 = v10 >> qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 25LL:\n        qword_A2F0 += *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 26LL:\n        qword_A2F0 = *qword_A2F8 - qword_A2F0;\n        v0 = pc;\n        ++qword_A2F8;\n        goto LABEL_6;\n      case 27LL:\n        v9 = qword_A2F8++;\n        qword_A2F0 *= *v9;\n        v0 = pc;\n        goto LABEL_6;\n      case 28LL:\n        v8 = *qword_A2F8++;\n        qword_A2F0 = v8 / qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 29LL:\n        v6 = *qword_A2F8++;\n        v7 = v6 % qword_A2F0;\n        v0 = pc;\n        qword_A2F0 = v7;\n        goto LABEL_6;\n      case 33LL:\n        v5 = &qword_A2F8[pc[1]];\n        qword_A2F0 = libmin_printf((char *)*(v5 - 1), *(v5 - 2), *(v5 - 3), *(v5 - 4), *(v5 - 5), *(v5 - 6));\n        v0 = pc;\n        goto LABEL_6;\n      case 35LL:\n        qword_A2F0 = (__int64)libmin_memset((void *)qword_A2F8[2], *((_DWORD *)qword_A2F8 + 2), *qword_A2F8);\n        v0 = pc;\n        goto LABEL_6;\n      case 36LL:\n        qword_A2F0 = libmin_memcmp((const void *)qword_A2F8[2], (const void *)qword_A2F8[1], *qword_A2F8);\n        v0 = pc;\n        goto LABEL_6;\n      case 37LL:\n        libmin_printf(\"exit(%ld)\", *qword_A2F8);\n        return *qword_A2F8;\n      default:\n        break;\n    }\n  }\n  libmin_printf(\"unknown instruction:%ld\\n\", v3);\n  return -1LL;\n}\n"}, "pseudo_normalize": "long long eval() {\n  long long *v0;\n  long long i;\n  long long v2;\n  long long v3;\n  long long *v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long *v9;\n  long long v10;\n  long long v11;\n  bool v12;\n  bool v13;\n  bool v14;\n  bool v15;\n  bool v16;\n  bool v17;\n  long long *v18;\n  char v19;\n  uint8_t *v20;\n  uint64_t *v21;\n  long long *v22;\n  long long *v23;\n  long long *v24;\n  long long **v25;\n  long long *v26;\n  v0 = pc;\n  for (i = 0LL;; i = cycle) {\n    v2 = i + 1;\n    cycle = v2;\n    v3 = *v0;\n    pc = v0 + 1;\n    if (!debug) goto LABEL_3;\n    libmin_printf(\"%ld> %.4s\", v2, &aLeaImmJmpCallJ[5 * v3]);\n    if (v3 > 7) break;\n    libmin_printf((char *)\" %ld\\n\", *pc);\n  LABEL_3:\n    if (v3 != 1) goto LABEL_4;\n    v0 = pc + 1;\n    qword_A2F0 = *pc;\n  LABEL_6:;\n  }\n  libmin_printf((char *)\"\\n\");\n  if ((unsigned long long)v3 <= 37) {\n  LABEL_4:\n    switch (v3) {\n      case 0LL:\n        v0 = pc + 1;\n        qword_A2F0 = (long long)&qword_A300[*pc];\n        goto LABEL_6;\n      case 2LL:\n        v0 = (long long *)*pc;\n        goto LABEL_6;\n      case 3LL:\n        v26 = qword_A2F8;\n        v25 = (long long **)pc;\n        --qword_A2F8;\n        *(v26 - 1) = (long long)(pc + 1);\n        goto LABEL_44;\n      case 4LL:\n        v25 = (long long **)pc;\n        if (qword_A2F0)\n          v0 = pc + 1;\n        else\n        LABEL_44:\n          v0 = *v25;\n        goto LABEL_6;\n      case 5LL:\n        v0 = pc + 1;\n        if (qword_A2F0) v0 = (long long *)*pc;\n        goto LABEL_6;\n      case 6LL:\n        v24 = qword_A2F8;\n        *(qword_A2F8 - 1) = (long long)qword_A300;\n        qword_A300 = v24 - 1;\n        v0 = pc + 1;\n        qword_A2F8 = &qword_A300[-*pc];\n        goto LABEL_6;\n      case 7LL:\n        v0 = pc + 1;\n        qword_A2F8 += *pc;\n        goto LABEL_6;\n      case 8LL:\n        v22 = qword_A300;\n        qword_A300 = (long long *)*qword_A300;\n        v23 = v22 + 2;\n        v0 = (long long *)v22[1];\n        qword_A2F8 = v23;\n        goto LABEL_6;\n      case 9LL:\n        qword_A2F0 = *(uint64_t *)qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 10LL:\n        qword_A2F0 = *(char *)qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 11LL:\n        v21 = (uint64_t *)*qword_A2F8++;\n        *v21 = qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 12LL:\n        v19 = qword_A2F0;\n        v20 = (uint8_t *)*qword_A2F8++;\n        *v20 = qword_A2F0;\n        qword_A2F0 = v19;\n        v0 = pc;\n        goto LABEL_6;\n      case 13LL:\n        v18 = qword_A2F8--;\n        *(v18 - 1) = qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 14LL:\n        qword_A2F0 |= *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 15LL:\n        qword_A2F0 ^= *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 16LL:\n        qword_A2F0 &= *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 17LL:\n        v17 = *qword_A2F8++ == qword_A2F0;\n        qword_A2F0 = v17;\n        v0 = pc;\n        goto LABEL_6;\n      case 18LL:\n        v16 = *qword_A2F8++ != qword_A2F0;\n        qword_A2F0 = v16;\n        v0 = pc;\n        goto LABEL_6;\n      case 19LL:\n        v15 = *qword_A2F8++ < qword_A2F0;\n        qword_A2F0 = v15;\n        v0 = pc;\n        goto LABEL_6;\n      case 20LL:\n        v14 = *qword_A2F8++ > qword_A2F0;\n        qword_A2F0 = v14;\n        v0 = pc;\n        goto LABEL_6;\n      case 21LL:\n        v13 = *qword_A2F8++ <= qword_A2F0;\n        qword_A2F0 = v13;\n        v0 = pc;\n        goto LABEL_6;\n      case 22LL:\n        v12 = *qword_A2F8++ >= qword_A2F0;\n        qword_A2F0 = v12;\n        v0 = pc;\n        goto LABEL_6;\n      case 23LL:\n        v11 = *qword_A2F8++;\n        qword_A2F0 = v11 << qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 24LL:\n        v10 = *qword_A2F8++;\n        qword_A2F0 = v10 >> qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 25LL:\n        qword_A2F0 += *qword_A2F8++;\n        v0 = pc;\n        goto LABEL_6;\n      case 26LL:\n        qword_A2F0 = *qword_A2F8 - qword_A2F0;\n        v0 = pc;\n        ++qword_A2F8;\n        goto LABEL_6;\n      case 27LL:\n        v9 = qword_A2F8++;\n        qword_A2F0 *= *v9;\n        v0 = pc;\n        goto LABEL_6;\n      case 28LL:\n        v8 = *qword_A2F8++;\n        qword_A2F0 = v8 / qword_A2F0;\n        v0 = pc;\n        goto LABEL_6;\n      case 29LL:\n        v6 = *qword_A2F8++;\n        v7 = v6 % qword_A2F0;\n        v0 = pc;\n        qword_A2F0 = v7;\n        goto LABEL_6;\n      case 33LL:\n        v5 = &qword_A2F8[pc[1]];\n        qword_A2F0 = libmin_printf((char *)*(v5 - 1), *(v5 - 2), *(v5 - 3),\n                                   *(v5 - 4), *(v5 - 5), *(v5 - 6));\n        v0 = pc;\n        goto LABEL_6;\n      case 35LL:\n        qword_A2F0 = (long long)libmin_memset(\n            (void *)qword_A2F8[2], *((uint32_t *)qword_A2F8 + 2), *qword_A2F8);\n        v0 = pc;\n        goto LABEL_6;\n      case 36LL:\n        qword_A2F0 = libmin_memcmp((const void *)qword_A2F8[2],\n                                   (const void *)qword_A2F8[1], *qword_A2F8);\n        v0 = pc;\n        goto LABEL_6;\n      case 37LL:\n        libmin_printf(\"exit(%ld)\", *qword_A2F8);\n        return *qword_A2F8;\n      default:\n        break;\n    }\n  }\n  libmin_printf(\"unknown instruction:%ld\\n\", v3);\n  return -1LL;\n}", "binary": "c-interp/c-interp.host.O2", "assembly": "<eval>:\nendbr64\nmov    0x646d(%rip),%rax\npush   %r14\nxor    %esi,%esi\npush   %r13\nlea    0x3309(%rip),%r13\npush   %r12\nlea    0x3307(%rip),%r12\npush   %rbp\nlea    0x3291(%rip),%rbp\npush   %rbx\nlea    0x38c7(%rip),%rbx\nnopl   0x0(%rax)\nadd    $0x1,%rsi\nlea    0x8(%rax),%rdx\ncmpq   $0x0,0x6488(%rip)\nmov    %rsi,0x6409(%rip)\nmov    (%rax),%r14\nmov    %rdx,0x641f(%rip)\njne    3f30 <eval+0xa0>\ncmp    $0x1,%r14\nje     3f08 <eval+0x78>\ncmp    $0x25,%r14\nja     3f7c <eval+0xec>\nmovslq (%rbx,%r14,4),%rax\nadd    %rbx,%rax\nnotrack jmp *%rax\nnopl   (%rax)\nmov    0x63f9(%rip),%rdx\nlea    0x8(%rdx),%rax\nmov    (%rdx),%rdx\nmov    %rdx,0x63d3(%rip)\nmov    0x63c4(%rip),%rsi\njmp    3ec8 <eval+0x38>\ncs nopw 0x0(%rax,%rax,1)\nlea    (%r14,%r14,4),%rdx\nxor    %eax,%eax\nmov    %rbp,%rdi\nadd    %r12,%rdx\ncall   5f60 <libmin_printf>\ncmp    $0x7,%r14\njg     3f68 <eval+0xd8>\nmov    0x63ba(%rip),%rax\nlea    0x30d3(%rip),%rdi\nmov    (%rax),%rsi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\njmp    3eeb <eval+0x5b>\nnopl   0x0(%rax)\nxor    %eax,%eax\nmov    %r13,%rdi\ncall   5f60 <libmin_printf>\ncmp    $0x25,%r14\njbe    3efb <eval+0x6b>\nmov    %r14,%rsi\nlea    0x31d8(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\npop    %rbx\nmov    $0xffffffffffffffff,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   (%rax)\nmov    0x6351(%rip),%rax\nlea    0x31a6(%rip),%rdi\nmov    (%rax),%rsi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    0x6339(%rip),%rax\npop    %rbx\npop    %rbp\npop    %r12\nmov    (%rax),%rax\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nmov    0x6321(%rip),%rax\nmov    0x8(%rax),%rsi\nmov    0x10(%rax),%rdi\nmov    (%rax),%rdx\ncall   4a40 <libmin_memcmp>\ncltq\nmov    %rax,0x6300(%rip)\nmov    0x6311(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   0x0(%rax)\nmov    0x62f1(%rip),%rax\nmov    0x10(%rax),%rdi\nmov    (%rax),%rdx\nmov    0x8(%rax),%esi\ncall   4ab0 <libmin_memset>\nmov    %rax,0x62d3(%rip)\nmov    0x62e4(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   0x0(%rax)\nmov    0x62d1(%rip),%rax\nmov    0x8(%rax),%rdx\nmov    0x62b6(%rip),%rax\nlea    (%rax,%rdx,8),%rax\nmov    -0x20(%rax),%rcx\nmov    -0x18(%rax),%rdx\nmov    -0x10(%rax),%rsi\nmov    -0x8(%rax),%rdi\nmov    -0x30(%rax),%r9\nmov    -0x28(%rax),%r8\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\ncltq\nmov    %rax,0x6282(%rip)\nmov    0x6293(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopw   0x0(%rax,%rax,1)\nmov    0x6271(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rdx,0x6263(%rip)\ncqto\nidivq  0x6252(%rip)\nmov    0x6263(%rip),%rax\nmov    %rdx,0x6244(%rip)\njmp    3f1d <eval+0x8d>\nnopl   0x0(%rax)\nmov    0x6239(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rdx,0x622b(%rip)\ncqto\nidivq  0x621a(%rip)\nmov    %rax,0x6213(%rip)\nmov    0x6224(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   0x0(%rax)\nmov    0x6201(%rip),%rdx\nlea    0x8(%rdx),%rax\nmov    %rax,0x61f6(%rip)\nmov    0x61e7(%rip),%rax\nimul   (%rdx),%rax\nmov    %rax,0x61dc(%rip)\nmov    0x61ed(%rip),%rax\njmp    3f1d <eval+0x8d>\nmov    0x61d1(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nsub    0x61bb(%rip),%rax\nmov    %rax,0x61b4(%rip)\nmov    0x61c5(%rip),%rax\nmov    %rdx,0x61ae(%rip)\njmp    3f1d <eval+0x8d>\nnop\nmov    0x61a1(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nadd    %rax,0x618b(%rip)\nmov    %rdx,0x618c(%rip)\nmov    0x6195(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   0x0(%rax,%rax,1)\nmov    0x6171(%rip),%rax\nmov    0x6162(%rip),%rcx\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rdx,0x615c(%rip)\nsar    %cl,%rax\nmov    %rax,0x614a(%rip)\nmov    0x615b(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopw   0x0(%rax,%rax,1)\nmov    0x6139(%rip),%rax\nmov    0x612a(%rip),%rcx\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rdx,0x6124(%rip)\nshl    %cl,%rax\nmov    %rax,0x6112(%rip)\nmov    0x6123(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopw   0x0(%rax,%rax,1)\nmov    0x6101(%rip),%rax\nmov    0x60f2(%rip),%rcx\ncmp    %rcx,(%rax)\nlea    0x8(%rax),%rdx\nsetge  %al\nmov    %rdx,0x60e9(%rip)\nmovzbl %al,%eax\nmov    %rax,0x60d7(%rip)\nmov    0x60e8(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   (%rax)\nmov    0x60c9(%rip),%rax\nmov    0x60ba(%rip),%rcx\ncmp    %rcx,(%rax)\nlea    0x8(%rax),%rdx\nsetle  %al\nmov    %rdx,0x60b1(%rip)\nmovzbl %al,%eax\nmov    %rax,0x609f(%rip)\nmov    0x60b0(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   (%rax)\nmov    0x6091(%rip),%rax\nmov    0x6082(%rip),%rcx\ncmp    %rcx,(%rax)\nlea    0x8(%rax),%rdx\nsetg   %al\nmov    %rdx,0x6079(%rip)\nmovzbl %al,%eax\nmov    %rax,0x6067(%rip)\nmov    0x6078(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   (%rax)\nmov    0x6059(%rip),%rax\nmov    0x604a(%rip),%rcx\ncmp    %rcx,(%rax)\nlea    0x8(%rax),%rdx\nsetl   %al\nmov    %rdx,0x6041(%rip)\nmovzbl %al,%eax\nmov    %rax,0x602f(%rip)\nmov    0x6040(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   (%rax)\nmov    0x6021(%rip),%rax\nmov    0x6012(%rip),%rcx\ncmp    %rcx,(%rax)\nlea    0x8(%rax),%rdx\nsetne  %al\nmov    %rdx,0x6009(%rip)\nmovzbl %al,%eax\nmov    %rax,0x5ff7(%rip)\nmov    0x6008(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   (%rax)\nmov    0x5fe9(%rip),%rax\nmov    0x5fda(%rip),%rcx\ncmp    %rcx,(%rax)\nlea    0x8(%rax),%rdx\nsete   %al\nmov    %rdx,0x5fd1(%rip)\nmovzbl %al,%eax\nmov    %rax,0x5fbf(%rip)\nmov    0x5fd0(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   (%rax)\nmov    0x5fb1(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nand    %rax,0x5f9b(%rip)\nmov    %rdx,0x5f9c(%rip)\nmov    0x5fa5(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   0x0(%rax,%rax,1)\nmov    0x5f81(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nxor    %rax,0x5f6b(%rip)\nmov    %rdx,0x5f6c(%rip)\nmov    0x5f75(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   0x0(%rax,%rax,1)\nmov    0x5f51(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nor     %rax,0x5f3b(%rip)\nmov    %rdx,0x5f3c(%rip)\nmov    0x5f45(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   0x0(%rax,%rax,1)\nmov    0x5f21(%rip),%rax\nlea    -0x8(%rax),%rdx\nmov    %rdx,0x5f16(%rip)\nmov    0x5f07(%rip),%rdx\nmov    %rdx,-0x8(%rax)\nmov    0x5f14(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   0x0(%rax)\nmov    0x5ef1(%rip),%rdx\nmov    0x5ee2(%rip),%rax\nlea    0x8(%rdx),%rcx\nmov    (%rdx),%rdx\nmov    %rcx,0x5edc(%rip)\nmov    %al,(%rdx)\nmovsbq %al,%rax\nmov    %rax,0x5ec7(%rip)\nmov    0x5ed8(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   (%rax)\nmov    0x5eb9(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    (%rax),%rax\nmov    %rdx,0x5eab(%rip)\nmov    0x5e9c(%rip),%rdx\nmov    %rdx,(%rax)\nmov    0x5eaa(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   0x0(%rax,%rax,1)\nmov    0x5e81(%rip),%rax\nmovsbq (%rax),%rax\nmov    %rax,0x5e76(%rip)\nmov    0x5e87(%rip),%rax\njmp    3f1d <eval+0x8d>\ncs nopw 0x0(%rax,%rax,1)\nmov    0x5e59(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x5e4f(%rip)\nmov    0x5e60(%rip),%rax\njmp    3f1d <eval+0x8d>\nnopl   (%rax)\nmov    0x5e49(%rip),%rax\nmov    (%rax),%rdx\nmov    %rdx,0x5e3f(%rip)\nlea    0x10(%rax),%rdx\nmov    0x8(%rax),%rax\nmov    %rdx,0x5e28(%rip)\njmp    3f1d <eval+0x8d>\nnopl   (%rax)\nmov    0x5e29(%rip),%rdx\nlea    0x8(%rdx),%rax\nmov    (%rdx),%rdx\nshl    $0x3,%rdx\nadd    %rdx,0x5e07(%rip)\njmp    3f1d <eval+0x8d>\ncs nopw 0x0(%rax,%rax,1)\nmov    0x5df1(%rip),%rax\nmov    0x5df2(%rip),%rcx\nmov    %rcx,-0x8(%rax)\nmov    0x5def(%rip),%rcx\nlea    -0x8(%rax),%rdx\nmov    %rdx,0x5ddc(%rip)\nlea    0x8(%rcx),%rax\nmov    (%rcx),%rcx\nshl    $0x3,%rcx\nsub    %rcx,%rdx\nmov    %rdx,0x5dbf(%rip)\njmp    3f1d <eval+0x8d>\nxchg   %ax,%ax\nmov    0x5dc1(%rip),%rdx\ncmpq   $0x0,0x5da1(%rip)\nlea    0x8(%rdx),%rax\nje     3f1d <eval+0x8d>\nmov    (%rdx),%rax\njmp    3f1d <eval+0x8d>\nnopl   0x0(%rax)\ncmpq   $0x0,0x5d80(%rip)\nmov    0x5d91(%rip),%rax\nje     45a9 <eval+0x719>\nadd    $0x8,%rax\njmp    3f1d <eval+0x8d>\nnopw   0x0(%rax,%rax,1)\nmov    0x5d69(%rip),%rdx\nmov    0x5d72(%rip),%rax\nlea    -0x8(%rdx),%rcx\nmov    %rcx,0x5d57(%rip)\nlea    0x8(%rax),%rcx\nmov    %rcx,-0x8(%rdx)\nmov    (%rax),%rax\njmp    3f1d <eval+0x8d>\nnopl   0x0(%rax)\nmov    0x5d49(%rip),%rax\nmov    (%rax),%rax\njmp    3f1d <eval+0x8d>\nnopw   0x0(%rax,%rax,1)\nmov    0x5d31(%rip),%rdx\nmov    (%rdx),%rcx\nlea    0x8(%rdx),%rax\nmov    0x5d1b(%rip),%rdx\nlea    (%rdx,%rcx,8),%rdx\nmov    %rdx,0x5d00(%rip)\njmp    3f1d <eval+0x8d>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "expression", "content": "void expression(long level) {\n    // expressions have various format.\n    // but majorly can be divided into two parts: unit and operator\n    // for example `(char) *a[10] = (int *) func(b > 0 ? 10 : 20);\n    // `a[10]` is an unit while `*` is an operator.\n    // `func(...)` in total is an unit.\n    // so we should first parse those unit and unary operators\n    // and then the binary ones\n    //\n    // also the expression can be in the following types:\n    //\n    // 1. unit_unary ::= unit | unit unary_op | unary_op unit\n    // 2. expr ::= unit_unary (bin_op unit_unary ...)\n\n    // unit_unary()\n    long *id;\n    long tmp;\n    long *addr;\n    {\n        if (!token) {\n            libmin_printf(\"%ld: unexpected token EOF of expression\\n\", line);\n            libmin_fail(-1);\n        }\n        if (token == Num) {\n            match(Num);\n\n            // emit code\n            *++text = IMM;\n            *++text = token_val;\n            expr_type = INT;\n        }\n        else if (token == '\"') {\n            // continous string \"abc\" \"abc\"\n\n\n            // emit code\n            *++text = IMM;\n            *++text = token_val;\n\n            match('\"');\n            // store the rest strings\n            while (token == '\"') {\n                match('\"');\n            }\n\n            // append the end of string character '\\0', all the data are default\n            // to 0, so just move data one position forward.\n            data = (char *)(((long)data + sizeof(long)) & (-sizeof(long)));\n            expr_type = PTR;\n        }\n        else if (token == Sizeof) {\n            // sizeof is actually an unary operator\n            // now only `sizeof(int)`, `sizeof(char)` and `sizeof(*...)` are\n            // supported.\n            match(Sizeof);\n            match('(');\n            expr_type = INT;\n\n            if (token == Int) {\n                match(Int);\n            } else if (token == Char) {\n                match(Char);\n                expr_type = CHAR;\n            }\n\n            while (token == Mul) {\n                match(Mul);\n                expr_type = expr_type + PTR;\n            }\n\n            match(')');\n\n            // emit code\n            *++text = IMM;\n            *++text = (expr_type == CHAR) ? sizeof(char) : sizeof(long);\n\n            expr_type = INT;\n        }\n        else if (token == Id) {\n            // there are several type when occurs to Id\n            // but this is unit, so it can only be\n            // 1. function call\n            // 2. Enum variable\n            // 3. global/local variable\n            match(Id);\n\n            id = current_id;\n\n            if (token == '(') {\n                // function call\n                match('(');\n\n                // pass in arguments\n                tmp = 0; // number of arguments\n                while (token != ')') {\n                    expression(Assign);\n                    *++text = PUSH;\n                    tmp ++;\n\n                    if (token == ',') {\n                        match(',');\n                    }\n\n                }\n                match(')');\n\n                // emit code\n                if (id[Class] == Sys) {\n                    // system functions\n                    *++text = id[Value];\n                }\n                else if (id[Class] == Fun) {\n                    // function call\n                    *++text = CALL;\n                    *++text = id[Value];\n                }\n                else {\n                    libmin_printf(\"%ld: bad function call\\n\", line);\n                    libmin_fail(-1);\n                }\n\n                // clean the stack for arguments\n                if (tmp > 0) {\n                    *++text = ADJ;\n                    *++text = tmp;\n                }\n                expr_type = id[Type];\n            }\n            else if (id[Class] == Num) {\n                // enum variable\n                *++text = IMM;\n                *++text = id[Value];\n                expr_type = INT;\n            }\n            else {\n                // variable\n                if (id[Class] == Loc) {\n                    *++text = LEA;\n                    *++text = index_of_bp - id[Value];\n                }\n                else if (id[Class] == Glo) {\n                    *++text = IMM;\n                    *++text = id[Value];\n                }\n                else {\n                    libmin_printf(\"%ld: undefined variable\\n\", line);\n                    libmin_fail(-1);\n                }\n\n                // emit code, default behaviour is to load the value of the\n                // address which is stored in `ax`\n                expr_type = id[Type];\n                *++text = (expr_type == CHAR) ? LC : LI;\n            }\n        }\n        else if (token == '(') {\n            // cast or parenthesis\n            match('(');\n            if (token == Int || token == Char) {\n                tmp = (token == Char) ? CHAR : INT; // cast type\n                match(token);\n                while (token == Mul) {\n                    match(Mul);\n                    tmp = tmp + PTR;\n                }\n\n                match(')');\n\n                expression(Inc); // cast has precedence as Inc(++)\n\n                expr_type  = tmp;\n            } else {\n                // normal parenthesis\n                expression(Assign);\n                match(')');\n            }\n        }\n        else if (token == Mul) {\n            // dereference *<addr>\n            match(Mul);\n            expression(Inc); // dereference has the same precedence as Inc(++)\n\n            if (expr_type >= PTR) {\n                expr_type = expr_type - PTR;\n            } else {\n                libmin_printf(\"%ld: bad dereference\\n\", line);\n                libmin_fail(-1);\n            }\n\n            *++text = (expr_type == CHAR) ? LC : LI;\n        }\n        else if (token == And) {\n            // get the address of\n            match(And);\n            expression(Inc); // get the address of\n            if (*text == LC || *text == LI) {\n                text --;\n            } else {\n                libmin_printf(\"%ld: bad address of\\n\", line);\n                libmin_fail(-1);\n            }\n\n            expr_type = expr_type + PTR;\n        }\n        else if (token == '!') {\n            // not\n            match('!');\n            expression(Inc);\n\n            // emit code, use <expr> == 0\n            *++text = PUSH;\n            *++text = IMM;\n            *++text = 0;\n            *++text = EQ;\n\n            expr_type = INT;\n        }\n        else if (token == '~') {\n            // bitwise not\n            match('~');\n            expression(Inc);\n\n            // emit code, use <expr> XOR -1\n            *++text = PUSH;\n            *++text = IMM;\n            *++text = -1;\n            *++text = XOR;\n\n            expr_type = INT;\n        }\n        else if (token == Add) {\n            // +var, do nothing\n            match(Add);\n            expression(Inc);\n\n            expr_type = INT;\n        }\n        else if (token == Sub) {\n            // -var\n            match(Sub);\n\n            if (token == Num) {\n                *++text = IMM;\n                *++text = -token_val;\n                match(Num);\n            } else {\n\n                *++text = IMM;\n                *++text = -1;\n                *++text = PUSH;\n                expression(Inc);\n                *++text = MUL;\n            }\n\n            expr_type = INT;\n        }\n        else if (token == Inc || token == Dec) {\n            tmp = token;\n            match(token);\n            expression(Inc);\n            if (*text == LC) {\n                *text = PUSH;  // to duplicate the address\n                *++text = LC;\n            } else if (*text == LI) {\n                *text = PUSH;\n                *++text = LI;\n            } else {\n                libmin_printf(\"%ld: bad lvalue of pre-increment\\n\", line);\n                libmin_fail(-1);\n            }\n            *++text = PUSH;\n            *++text = IMM;\n            *++text = (expr_type > PTR) ? sizeof(long) : sizeof(char);\n            *++text = (tmp == Inc) ? ADD : SUB;\n            *++text = (expr_type == CHAR) ? SC : SI;\n        }\n        else {\n            libmin_printf(\"%ld: bad expression\\n\", line);\n            libmin_fail(-1);\n        }\n    }\n\n    // binary operator and postfix operators.\n    {\n        while (token >= level) {\n            // handle according to current operator's precedence\n            tmp = expr_type;\n            if (token == Assign) {\n                // var = expr;\n                match(Assign);\n                if (*text == LC || *text == LI) {\n                    *text = PUSH; // save the lvalue's pointer\n                } else {\n                    libmin_printf(\"%ld: bad lvalue in assignment\\n\", line);\n                    libmin_fail(-1);\n                }\n                expression(Assign);\n\n                expr_type = tmp;\n                *++text = (expr_type == CHAR) ? SC : SI;\n            }\n            else if (token == Cond) {\n                // expr ? a : b;\n                match(Cond);\n                *++text = JZ;\n                addr = ++text;\n                expression(Assign);\n                if (token == ':') {\n                    match(':');\n                } else {\n                    libmin_printf(\"%ld: missing colon in conditional\\n\", line);\n                    libmin_fail(-1);\n                }\n                *addr = (long)(text + 3);\n                *++text = JMP;\n                addr = ++text;\n                expression(Cond);\n                *addr = (long)(text + 1);\n            }\n            else if (token == Lor) {\n                // logic or\n                match(Lor);\n                *++text = JNZ;\n                addr = ++text;\n                expression(Lan);\n                *addr = (long)(text + 1);\n                expr_type = INT;\n            }\n            else if (token == Lan) {\n                // logic and\n                match(Lan);\n                *++text = JZ;\n                addr = ++text;\n                expression(Or);\n                *addr = (long)(text + 1);\n                expr_type = INT;\n            }\n            else if (token == Or) {\n                // bitwise or\n                match(Or);\n                *++text = PUSH;\n                expression(Xor);\n                *++text = OR;\n                expr_type = INT;\n            }\n            else if (token == Xor) {\n                // bitwise xor\n                match(Xor);\n                *++text = PUSH;\n                expression(And);\n                *++text = XOR;\n                expr_type = INT;\n            }\n            else if (token == And) {\n                // bitwise and\n                match(And);\n                *++text = PUSH;\n                expression(Eq);\n                *++text = AND;\n                expr_type = INT;\n            }\n            else if (token == Eq) {\n                // equal ==\n                match(Eq);\n                *++text = PUSH;\n                expression(Ne);\n                *++text = EQ;\n                expr_type = INT;\n            }\n            else if (token == Ne) {\n                // not equal !=\n                match(Ne);\n                *++text = PUSH;\n                expression(Lt);\n                *++text = NE;\n                expr_type = INT;\n            }\n            else if (token == Lt) {\n                // less than\n                match(Lt);\n                *++text = PUSH;\n                expression(Shl);\n                *++text = LT;\n                expr_type = INT;\n            }\n            else if (token == Gt) {\n                // greater than\n                match(Gt);\n                *++text = PUSH;\n                expression(Shl);\n                *++text = GT;\n                expr_type = INT;\n            }\n            else if (token == Le) {\n                // less than or equal to\n                match(Le);\n                *++text = PUSH;\n                expression(Shl);\n                *++text = LE;\n                expr_type = INT;\n            }\n            else if (token == Ge) {\n                // greater than or equal to\n                match(Ge);\n                *++text = PUSH;\n                expression(Shl);\n                *++text = GE;\n                expr_type = INT;\n            }\n            else if (token == Shl) {\n                // shift left\n                match(Shl);\n                *++text = PUSH;\n                expression(Add);\n                *++text = SHL;\n                expr_type = INT;\n            }\n            else if (token == Shr) {\n                // shift right\n                match(Shr);\n                *++text = PUSH;\n                expression(Add);\n                *++text = SHR;\n                expr_type = INT;\n            }\n            else if (token == Add) {\n                // add\n                match(Add);\n                *++text = PUSH;\n                expression(Mul);\n\n                expr_type = tmp;\n                if (expr_type > PTR) {\n                    // pointer type, and not `char *`\n                    *++text = PUSH;\n                    *++text = IMM;\n                    *++text = sizeof(long);\n                    *++text = MUL;\n                }\n                *++text = ADD;\n            }\n            else if (token == Sub) {\n                // sub\n                match(Sub);\n                *++text = PUSH;\n                expression(Mul);\n                if (tmp > PTR && tmp == expr_type) {\n                    // pointer subtraction\n                    *++text = SUB;\n                    *++text = PUSH;\n                    *++text = IMM;\n                    *++text = sizeof(long);\n                    *++text = DIV;\n                    expr_type = INT;\n                } else if (tmp > PTR) {\n                    // pointer movement\n                    *++text = PUSH;\n                    *++text = IMM;\n                    *++text = sizeof(long);\n                    *++text = MUL;\n                    *++text = SUB;\n                    expr_type = tmp;\n                } else {\n                    // numeral subtraction\n                    *++text = SUB;\n                    expr_type = tmp;\n                }\n            }\n            else if (token == Mul) {\n                // multiply\n                match(Mul);\n                *++text = PUSH;\n                expression(Inc);\n                *++text = MUL;\n                expr_type = tmp;\n            }\n            else if (token == Div) {\n                // divide\n                match(Div);\n                *++text = PUSH;\n                expression(Inc);\n                *++text = DIV;\n                expr_type = tmp;\n            }\n            else if (token == Mod) {\n                // Modulo\n                match(Mod);\n                *++text = PUSH;\n                expression(Inc);\n                *++text = MOD;\n                expr_type = tmp;\n            }\n            else if (token == Inc || token == Dec) {\n                // postfix inc(++) and dec(--)\n                // we will increase the value to the variable and decrease it\n                // on `ax` to get its original value.\n                if (*text == LI) {\n                    *text = PUSH;\n                    *++text = LI;\n                }\n                else if (*text == LC) {\n                    *text = PUSH;\n                    *++text = LC;\n                }\n                else {\n                    libmin_printf(\"%ld: bad value in increment\\n\", line);\n                    libmin_fail(-1);\n                }\n\n                *++text = PUSH;\n                *++text = IMM;\n                *++text = (expr_type > PTR) ? sizeof(long) : sizeof(char);\n                *++text = (token == Inc) ? ADD : SUB;\n                *++text = (expr_type == CHAR) ? SC : SI;\n                *++text = PUSH;\n                *++text = IMM;\n                *++text = (expr_type > PTR) ? sizeof(long) : sizeof(char);\n                *++text = (token == Inc) ? SUB : ADD;\n                match(token);\n            }\n            else if (token == Brak) {\n                // array access var[xx]\n                match(Brak);\n                *++text = PUSH;\n                expression(Assign);\n                match(']');\n\n                if (tmp > PTR) {\n                    // pointer, `not char *`\n                    *++text = PUSH;\n                    *++text = IMM;\n                    *++text = sizeof(long);\n                    *++text = MUL;\n                }\n                else if (tmp < PTR) {\n                    libmin_printf(\"%ld: pointer type expected\\n\", line);\n                    libmin_fail(-1);\n                }\n                expr_type = tmp - PTR;\n                *++text = ADD;\n                *++text = (expr_type == CHAR) ? LC : LI;\n            }\n            else {\n                libmin_printf(\"%ld: compiler error, token = %ld\\n\", line, token);\n                libmin_fail(-1);\n            }\n        }\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O2.pseudo", "function_name": "expression", "address": "0x1d20", "label": "expression", "content": "void __fastcall expression(__int64 level)\n{\n  __int64 v2; // rbp\n  __int64 v3; // rbp\n  __int64 i; // rax\n  __int64 v5; // r15\n  _QWORD *v6; // rax\n  char *v7; // rdx\n  __int64 v8; // rdx\n  char *v9; // rcx\n  _QWORD *v10; // rax\n  char *v11; // rdx\n  _QWORD *v12; // rdx\n  _QWORD *v13; // rax\n  __int64 v14; // rcx\n  __int64 v15; // rdx\n  bool v16; // zf\n  __int64 v17; // rdi\n  __int64 v18; // rsi\n  char *v19; // rdx\n  char *v20; // rdx\n  char *v21; // rdx\n  char *v22; // rdx\n  char *v23; // rdx\n  _QWORD *v24; // rax\n  _QWORD *v25; // rdx\n  _QWORD *v26; // rax\n  char *v27; // rdx\n  char *v28; // rdx\n  char *v29; // rdx\n  char *v30; // rdx\n  char *v31; // rdx\n  char *v32; // rdx\n  char *v33; // rdx\n  char *v34; // rdx\n  _QWORD *v35; // rdx\n  _QWORD *v36; // rax\n  __int64 v37; // rcx\n  char *v38; // rdx\n  _QWORD *v39; // r15\n  _QWORD *v40; // r15\n  __int64 v41; // rdi\n  char *v42; // rax\n  char *v43; // rdx\n  char *v44; // rax\n  _QWORD *v45; // rdx\n  _QWORD *v46; // rax\n  __int64 v47; // rcx\n  __int64 v48; // rdx\n  __int64 v49; // rcx\n  char *v50; // rcx\n  _QWORD *v51; // rax\n  char *v52; // rdx\n  __int64 v53; // rax\n  bool v54; // cf\n  _QWORD *v55; // rdx\n  char *v56; // rcx\n  __int64 *v57; // rbp\n  __int64 v58; // rax\n  _QWORD *v59; // rax\n  char *v60; // rcx\n  __int64 v61; // rax\n  _QWORD *v62; // rax\n  char *v63; // rdx\n  _QWORD *v64; // rax\n  char *v65; // rdx\n  _QWORD *v66; // rax\n  char *v67; // rcx\n  __int64 v68; // r12\n  char *v69; // rdx\n  __int64 v70; // rax\n  __int64 v71; // rax\n  _QWORD *v72; // rax\n  char *v73; // rdx\n  _QWORD *v74; // rax\n  char *v75; // rdx\n  _QWORD *v76; // rax\n  __int64 v77; // rsi\n  _QWORD *v78; // rax\n  char *v79; // [rsp+8h] [rbp-40h]\n\n  v2 = token;\n  if ( !token )\n  {\n    libmin_printf(\"%ld: unexpected token EOF of expression\\n\", line);\n    libmin_fail(-1);\n  }\n  if ( token == 128 )\n  {\n    next();\n    v10 = text;\n    expr_type = 1LL;\n    v11 = (char *)text + 16;\n    *((_QWORD *)text + 1) = 1LL;\n    text = v11;\n    v10[2] = token_val;\n    v8 = token;\n    goto LABEL_13;\n  }\n  if ( token > 163 )\n  {\nLABEL_25:\n    libmin_printf(\"%ld: bad expression\\n\", line);\n    libmin_fail(-1);\n  }\n  if ( token > 125 )\n  {\n    switch ( token )\n    {\n      case 126LL:\n        next();\n        expression(162LL);\n        v62 = text;\n        expr_type = 1LL;\n        v63 = (char *)text + 32;\n        *((_QWORD *)text + 1) = 13LL;\n        text = v63;\n        v8 = token;\n        v62[2] = 1LL;\n        v62[3] = -1LL;\n        v62[4] = 15LL;\n        goto LABEL_13;\n      case 133LL:\n        next();\n        v8 = token;\n        v57 = current_id;\n        if ( token == 40 )\n        {\n          v68 = 0LL;\n          next();\n          if ( token != 41 )\n          {\n            do\n            {\n              ++v68;\n              expression(142LL);\n              v69 = (char *)text + 8;\n              *((_QWORD *)text + 1) = 13LL;\n              v70 = token;\n              text = v69;\n              if ( token == 44 )\n              {\n                next();\n                v70 = token;\n              }\n            }\n            while ( v70 != 41 );\n          }\n          next();\n          v71 = v57[4];\n          if ( v71 == 130 )\n          {\n            v78 = text;\n            text = (char *)text + 8;\n            v78[1] = v57[5];\n          }\n          else\n          {\n            if ( v71 != 129 )\n            {\n              libmin_printf(\"%ld: bad function call\\n\", line);\n              libmin_fail(-1);\n            }\n            v72 = text;\n            v73 = (char *)text + 16;\n            *((_QWORD *)text + 1) = 3LL;\n            text = v73;\n            v72[2] = v57[5];\n          }\n          if ( v68 )\n          {\n            v74 = text;\n            v75 = (char *)text + 16;\n            *((_QWORD *)text + 1) = 7LL;\n            text = v75;\n            v74[2] = v68;\n          }\n          v8 = token;\n          expr_type = v57[3];\n        }\n        else\n        {\n          v58 = current_id[4];\n          if ( v58 == 128 )\n          {\n            v66 = text;\n            expr_type = 1LL;\n            v67 = (char *)text + 16;\n            *((_QWORD *)text + 1) = 1LL;\n            text = v67;\n            v66[2] = v57[5];\n          }\n          else\n          {\n            if ( v58 == 132 )\n            {\n              v76 = text;\n              v77 = index_of_bp;\n              *((_QWORD *)text + 1) = 0LL;\n              v60 = (char *)(v76 + 2);\n              v76[2] = v77 - v57[5];\n            }\n            else\n            {\n              if ( v58 != 131 )\n              {\n                libmin_printf(\"%ld: undefined variable\\n\", line);\n                libmin_fail(-1);\n              }\n              v59 = text;\n              *((_QWORD *)text + 1) = 1LL;\n              v60 = (char *)(v59 + 2);\n              v59[2] = v57[5];\n            }\n            v61 = v57[3];\n            text = v60 + 8;\n            expr_type = v61;\n            *((_QWORD *)v60 + 1) = (v61 == 0) + 9LL;\n          }\n        }\n        goto LABEL_13;\n      case 140LL:\n        next();\n        if ( token != 40 )\n        {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n          libmin_fail(-1);\n        }\n        next();\n        v53 = token;\n        expr_type = 1LL;\n        if ( token == 138 )\n        {\n          next();\n          v53 = token;\n        }\n        else if ( token == 134 )\n        {\n          next();\n          v53 = token;\n          expr_type = 0LL;\n        }\n        while ( v53 == 159 )\n        {\n          next();\n          expr_type += 2LL;\n          v53 = token;\n        }\n        if ( v53 != 41 )\n        {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n          libmin_fail(-1);\n        }\n        next();\n        v54 = expr_type == 0;\n        v55 = text;\n        expr_type = 1LL;\n        v56 = (char *)text + 16;\n        *((_QWORD *)text + 1) = 1LL;\n        text = v56;\n        v55[2] = (-(__int64)v54 & 0xFFFFFFFFFFFFFFF9LL) + 8;\n        v8 = token;\n        goto LABEL_13;\n      case 148LL:\n        next();\n        expression(162LL);\n        if ( (unsigned __int64)(*(_QWORD *)text - 9LL) > 1 )\n        {\n          libmin_printf(\"%ld: bad address of\\n\", line);\n          libmin_fail(-1);\n        }\n        text = (char *)text - 8;\n        expr_type += 2LL;\n        v8 = token;\n        goto LABEL_13;\n      case 157LL:\n        next();\n        expression(162LL);\n        v8 = token;\n        expr_type = 1LL;\n        goto LABEL_13;\n      case 158LL:\n        next();\n        v51 = text;\n        v16 = token == 128;\n        *((_QWORD *)text + 1) = 1LL;\n        if ( v16 )\n        {\n          text = v51 + 2;\n          v51[2] = -token_val;\n          next();\n        }\n        else\n        {\n          v51[2] = -1LL;\n          v51[3] = 13LL;\n          text = v51 + 3;\n          expression(162LL);\n          v52 = (char *)text + 8;\n          *((_QWORD *)text + 1) = 27LL;\n          text = v52;\n        }\n        expr_type = 1LL;\n        v8 = token;\n        goto LABEL_13;\n      case 159LL:\n        next();\n        expression(162LL);\n        if ( expr_type <= 1 )\n        {\n          libmin_printf(\"%ld: bad dereference\\n\", line);\n          libmin_fail(-1);\n        }\n        expr_type -= 2LL;\n        v50 = (char *)text + 8;\n        *((_QWORD *)text + 1) = (expr_type == 0) + 9LL;\n        v8 = token;\n        text = v50;\n        goto LABEL_13;\n      case 162LL:\n      case 163LL:\n        next();\n        expression(162LL);\n        v45 = text;\n        if ( *(_QWORD *)text == 10LL )\n        {\n          *(_QWORD *)text = 13LL;\n          v46 = v45 + 1;\n          v45[1] = 10LL;\n        }\n        else\n        {\n          if ( *(_QWORD *)text != 9LL )\n          {\n            libmin_printf(\"%ld: bad lvalue of pre-increment\\n\", line);\n            libmin_fail(-1);\n          }\n          *(_QWORD *)text = 13LL;\n          v46 = v45 + 1;\n          v45[1] = 9LL;\n        }\n        v47 = expr_type;\n        v46[1] = 13LL;\n        v46[2] = 1LL;\n        if ( v47 > 2 )\n        {\n          v46[3] = 8LL;\n          v49 = 11LL;\n          v48 = (v2 != 162) + 25LL;\n        }\n        else\n        {\n          v46[3] = 1LL;\n          v48 = (v2 != 162) + 25LL;\n          v49 = 12LL - (v47 != 0);\n        }\n        v46[4] = v48;\n        text = v46 + 5;\n        v8 = token;\n        v46[5] = v49;\n        goto LABEL_13;\n      default:\n        goto LABEL_25;\n    }\n  }\n  if ( token == 34 )\n  {\n    v64 = text;\n    v65 = (char *)text + 16;\n    *((_QWORD *)text + 1) = 1LL;\n    text = v65;\n    v64[2] = token_val;\n    do\n    {\n      next();\n      v8 = token;\n    }\n    while ( token == 34 );\n    expr_type = 2LL;\n    data = (char *)((unsigned __int64)(data + 8) & 0xFFFFFFFFFFFFFFF8LL);\n    goto LABEL_13;\n  }\n  if ( token != 40 )\n  {\n    if ( token == 33 )\n    {\n      next();\n      expression(162LL);\n      v6 = text;\n      expr_type = 1LL;\n      v7 = (char *)text + 32;\n      *((_QWORD *)text + 1) = 13LL;\n      text = v7;\n      v8 = token;\n      v6[2] = 1LL;\n      v6[3] = 0LL;\n      v6[4] = 17LL;\n      goto LABEL_13;\n    }\n    goto LABEL_25;\n  }\n  next();\n  if ( ((token - 134) & 0xFFFFFFFFFFFFFFFBLL) != 0 )\n  {\n    expression(142LL);\n    if ( token != 41 )\n    {\n      libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n      libmin_fail(-1);\n    }\n    next();\n    v8 = token;\n  }\n  else\n  {\n    v3 = token != 134;\n    next();\n    for ( i = token; token == 159; i = token )\n    {\n      v3 += 2LL;\n      next();\n    }\n    if ( i != 41 )\n    {\n      libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n      libmin_fail(-1);\n    }\n    next();\n    expression(162LL);\n    expr_type = v3;\n    v8 = token;\n  }\nLABEL_13:\n  if ( level <= v8 )\n  {\n    do\n    {\n      v5 = expr_type;\n      if ( v8 == 142 )\n      {\n        next();\n        if ( (unsigned __int64)(*(_QWORD *)text - 9LL) > 1 )\n        {\n          libmin_printf(\"%ld: bad lvalue in assignment\\n\", line);\n          libmin_fail(-1);\n        }\n        *(_QWORD *)text = 13LL;\n        expression(142LL);\n        expr_type = v5;\n        v9 = (char *)text + 8;\n        *((_QWORD *)text + 1) = (v5 == 0) + 11LL;\n        text = v9;\n      }\n      else\n      {\n        switch ( v8 )\n        {\n          case 143LL:\n            next();\n            v38 = (char *)text;\n            *((_QWORD *)text + 1) = 4LL;\n            v79 = v38;\n            text = v38 + 16;\n            expression(142LL);\n            if ( token != 58 )\n            {\n              libmin_printf(\"%ld: missing colon in conditional\\n\", line);\n              libmin_fail(-1);\n            }\n            next();\n            v39 = text;\n            *((_QWORD *)v79 + 2) = (char *)text + 24;\n            v39[1] = 2LL;\n            text = v39 + 2;\n            expression(143LL);\n            v39[2] = (char *)text + 8;\n            break;\n          case 144LL:\n            next();\n            v40 = text;\n            v41 = 145LL;\n            v44 = (char *)text + 16;\n            *((_QWORD *)text + 1) = 5LL;\n            text = v44;\n            goto LABEL_60;\n          case 145LL:\n            next();\n            v40 = text;\n            v41 = 146LL;\n            v42 = (char *)text + 16;\n            *((_QWORD *)text + 1) = 4LL;\n            text = v42;\nLABEL_60:\n            expression(v41);\n            v40[2] = (char *)text + 8;\n            expr_type = 1LL;\n            break;\n          case 146LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(147LL);\n            expr_type = 1LL;\n            v43 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 14LL;\n            text = v43;\n            break;\n          case 147LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(148LL);\n            expr_type = 1LL;\n            v27 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 15LL;\n            text = v27;\n            break;\n          case 148LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(149LL);\n            expr_type = 1LL;\n            v34 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 16LL;\n            text = v34;\n            break;\n          case 149LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(150LL);\n            expr_type = 1LL;\n            v32 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 17LL;\n            text = v32;\n            break;\n          case 150LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(151LL);\n            expr_type = 1LL;\n            v33 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 18LL;\n            text = v33;\n            break;\n          case 151LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(155LL);\n            expr_type = 1LL;\n            v28 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 19LL;\n            text = v28;\n            break;\n          case 152LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(155LL);\n            expr_type = 1LL;\n            v29 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 20LL;\n            text = v29;\n            break;\n          case 153LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(155LL);\n            expr_type = 1LL;\n            v30 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 21LL;\n            text = v30;\n            break;\n          case 154LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(155LL);\n            expr_type = 1LL;\n            v31 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 22LL;\n            text = v31;\n            break;\n          case 155LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(157LL);\n            expr_type = 1LL;\n            v22 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 23LL;\n            text = v22;\n            break;\n          case 156LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(157LL);\n            expr_type = 1LL;\n            v23 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 24LL;\n            text = v23;\n            break;\n          case 157LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(159LL);\n            expr_type = v5;\n            v24 = text;\n            if ( v5 > 2 )\n            {\n              v25 = text;\n              *((_QWORD *)text + 1) = 13LL;\n              v24 = v25 + 4;\n              v25[2] = 1LL;\n              v25[3] = 8LL;\n              v25[4] = 27LL;\n            }\n            v24[1] = 25LL;\n            text = v24 + 1;\n            break;\n          case 158LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(159LL);\n            v26 = text;\n            if ( v5 > 2 )\n            {\n              if ( expr_type == v5 )\n              {\n                *((_QWORD *)text + 1) = 26LL;\n                v26[2] = 13LL;\n                v26[3] = 1LL;\n                v26[4] = 8LL;\n                text = v26 + 5;\n                v26[5] = 28LL;\n                expr_type = 1LL;\n              }\n              else\n              {\n                *((_QWORD *)text + 1) = 13LL;\n                v26[2] = 1LL;\n                v26[3] = 8LL;\n                v26[4] = 27LL;\n                text = v26 + 5;\n                v26[5] = 26LL;\n                expr_type = v5;\n              }\n            }\n            else\n            {\n              *((_QWORD *)text + 1) = 26LL;\n              text = v26 + 1;\n              expr_type = v5;\n            }\n            break;\n          case 159LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(162LL);\n            expr_type = v5;\n            v20 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 27LL;\n            text = v20;\n            break;\n          case 160LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(162LL);\n            expr_type = v5;\n            v21 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 28LL;\n            text = v21;\n            break;\n          case 161LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(162LL);\n            expr_type = v5;\n            v19 = (char *)text + 8;\n            *((_QWORD *)text + 1) = 29LL;\n            text = v19;\n            break;\n          case 162LL:\n          case 163LL:\n            v12 = text;\n            if ( *(_QWORD *)text == 9LL )\n            {\n              *(_QWORD *)text = 13LL;\n              v13 = v12 + 1;\n              v12[1] = 9LL;\n            }\n            else\n            {\n              if ( *(_QWORD *)text != 10LL )\n              {\n                libmin_printf(\"%ld: bad value in increment\\n\", line);\n                libmin_fail(-1);\n              }\n              *(_QWORD *)text = 13LL;\n              v13 = v12 + 1;\n              v12[1] = 10LL;\n            }\n            v14 = expr_type;\n            v15 = 8LL;\n            v13[1] = 13LL;\n            v13[2] = 1LL;\n            if ( v14 <= 2 )\n              v15 = 1LL;\n            v16 = token == 162;\n            v13[3] = v15;\n            if ( v16 )\n            {\n              v17 = 25LL;\n              v18 = 26LL;\n            }\n            else\n            {\n              v17 = 26LL;\n              v18 = 25LL;\n            }\n            v13[4] = v17;\n            v13[5] = 12LL - (v14 != 0);\n            v13[8] = v15;\n            v13[9] = v18;\n            v13[6] = 13LL;\n            v13[7] = 1LL;\n            text = v13 + 9;\n            next();\n            break;\n          case 164LL:\n            next();\n            text = (char *)text + 8;\n            *(_QWORD *)text = 13LL;\n            expression(142LL);\n            if ( token != 93 )\n            {\n              libmin_printf(\"%ld: expected token: %ld\\n\", line, 93LL);\n              libmin_fail(-1);\n            }\n            next();\n            if ( v5 <= 2 )\n            {\n              if ( v5 != 2 )\n              {\n                libmin_printf(\"%ld: pointer type expected\\n\", line);\n                libmin_fail(-1);\n              }\n              v36 = text;\n              v37 = 10LL;\n              expr_type = 0LL;\n              *((_QWORD *)text + 1) = 25LL;\n            }\n            else\n            {\n              v35 = text;\n              *((_QWORD *)text + 1) = 13LL;\n              v36 = v35 + 4;\n              v35[2] = 1LL;\n              v35[3] = 8LL;\n              v35[4] = 27LL;\n              v35[5] = 25LL;\n              expr_type = v5 - 2;\n              v37 = 9LL;\n            }\n            v36[2] = v37;\n            text = v36 + 2;\n            break;\n          default:\n            libmin_printf(\"%ld: compiler error, token = %ld\\n\", line, v8);\n            libmin_fail(-1);\n        }\n      }\n      v8 = token;\n    }\n    while ( token >= level );\n  }\n}\n"}, "pseudo_normalize": "", "binary": "c-interp/c-interp.host.O2", "assembly": "<expression>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x18,%rsp\nmov    0x8614(%rip),%rbp\ntest   %rbp,%rbp\nje     1fa0 <expression+0x280>\ncmp    $0x80,%rbp\nje     1fd3 <expression+0x2b3>\ncmp    $0xa3,%rbp\njg     2020 <expression+0x300>\ncmp    $0x7d,%rbp\njle    1d88 <expression+0x68>\nlea    -0x7e(%rbp),%rax\ncmp    $0x25,%rax\nja     2020 <expression+0x300>\nlea    0x591e(%rip),%rdx\nmovslq (%rdx,%rax,4),%rax\nadd    %rdx,%rax\nnotrack jmp *%rax\nnopl   0x0(%rax)\ncmp    $0x22,%rbp\nje     2ca8 <expression+0xf88>\ncmp    $0x28,%rbp\njne    1e95 <expression+0x175>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x85a6(%rip),%rax\nlea    -0x86(%rax),%rdx\ntest   $0xfffffffffffffffb,%rdx\njne    2dba <expression+0x109a>\nxor    %ebp,%ebp\ncmp    $0x86,%rax\nsetne  %bpl\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x8578(%rip),%rax\ncmp    $0x9f,%rax\njne    1dfa <expression+0xda>\nxor    %eax,%eax\nadd    $0x2,%rbp\ncall   1580 <next>\nmov    0x855e(%rip),%rax\ncmp    $0x9f,%rax\nje     1de0 <expression+0xc0>\ncmp    $0x29,%rax\nje     312f <expression+0x140f>\nmov    0x84c5(%rip),%rsi\nlea    0x5202(%rip),%rdi\nmov    $0x29,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    $0xa2,%edi\ncall   1d20 <expression>\nmov    %rbp,0x847f(%rip)\nmov    0x8510(%rip),%rdx\nlea    0x54d1(%rip),%r12\nlea    0x58e2(%rip),%rbp\nlea    0x5267(%rip),%r14\nlea    0x51b8(%rip),%r13\ncmp    %rdx,%rbx\njg     1f66 <expression+0x246>\nmov    0x844c(%rip),%r15\ncmp    $0x8e,%rdx\nje     1f00 <expression+0x1e0>\nlea    -0x8f(%rdx),%rax\ncmp    $0x15,%rax\nja     2c84 <expression+0xf64>\nmovslq 0x0(%rbp,%rax,4),%rax\nadd    %rbp,%rax\nnotrack jmp *%rax\ncmp    $0x21,%rbp\njne    2020 <expression+0x300>\nxor    %eax,%eax\ncall   1580 <next>\nmov    $0xa2,%edi\ncall   1d20 <expression>\nmov    0x8491(%rip),%rax\nmovq   $0x1,0x83f6(%rip)\nlea    0x20(%rax),%rdx\nmovq   $0xd,0x8(%rax)\nmov    %rdx,0x8473(%rip)\nmov    0x8474(%rip),%rdx\nmovq   $0x1,0x10(%rax)\nmovq   $0x0,0x18(%rax)\nmovq   $0x11,0x20(%rax)\njmp    1e40 <expression+0x120>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x843a(%rip),%rdx\nmov    (%rdx),%rax\nsub    $0x9,%rax\ncmp    $0x1,%rax\nja     1f78 <expression+0x258>\nmovq   $0xd,(%rdx)\nmov    $0x8e,%edi\ncall   1d20 <expression>\nmov    0x8415(%rip),%rdx\ncmp    $0x1,%r15\nmov    $0xb,%eax\nadc    $0x0,%rax\nmov    %r15,0x8371(%rip)\nlea    0x8(%rdx),%rcx\nmov    %rax,0x8(%rdx)\nmov    %rcx,0x83f2(%rip)\nmov    0x83f3(%rip),%rdx\ncmp    %rbx,%rdx\njge    1e65 <expression+0x145>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nmov    0x8351(%rip),%rsi\nlea    0x534a(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\njmp    1f22 <expression+0x202>\nnopl   0x0(%rax)\nmov    0x8329(%rip),%rsi\nlea    0x52ca(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x838a(%rip),%rbp\ncmp    $0x80,%rbp\njne    1d52 <expression+0x32>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x8367(%rip),%rax\nmovq   $0x1,0x82cc(%rip)\nlea    0x10(%rax),%rdx\nmovq   $0x1,0x8(%rax)\nmov    %rdx,0x8349(%rip)\nmov    0x82c2(%rip),%rdx\nmov    %rdx,0x10(%rax)\nmov    0x833f(%rip),%rdx\njmp    1e40 <expression+0x120>\ncs nopw 0x0(%rax,%rax,1)\nmov    0x82a9(%rip),%rsi\nlea    0x505c(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x830a(%rip),%rdx\njmp    1e40 <expression+0x120>\nnopl   0x0(%rax,%rax,1)\nmov    0x82f1(%rip),%rdx\nmov    (%rdx),%rax\ncmp    $0x9,%rax\nje     2f37 <expression+0x1217>\ncmp    $0xa,%rax\njne    2d8f <expression+0x106f>\nmovq   $0xd,(%rdx)\nlea    0x8(%rdx),%rax\nmovq   $0xa,0x8(%rdx)\nmov    0x8230(%rip),%rcx\nmov    $0x8,%edx\nmov    $0x1,%esi\nmovq   $0xd,0x8(%rax)\nmovq   $0x1,0x10(%rax)\ncmp    $0x2,%rcx\ncmovle %rsi,%rdx\ncmpq   $0xa2,0x829b(%rip)\nmov    %rdx,0x18(%rax)\nje     2f6c <expression+0x124c>\nneg    %rcx\nmov    $0x1a,%edi\nmov    $0x19,%esi\nsbb    %rcx,%rcx\nadd    $0xc,%rcx\nmov    %rdi,0x20(%rax)\nmov    %rcx,0x28(%rax)\nmov    %rdx,0x40(%rax)\nlea    0x48(%rax),%rdx\nmov    %rsi,0x48(%rax)\nmovq   $0xd,0x30(%rax)\nmovq   $0x1,0x38(%rax)\nxor    %eax,%eax\nmov    %rdx,0x8248(%rip)\ncall   1580 <next>\njmp    1f56 <expression+0x236>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x822a(%rip),%rax\nmov    $0xa2,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x821a(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x8206(%rip),%rax\nmov    %r15,0x816f(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x1d,0x8(%rax)\nmov    %rdx,0x81ec(%rip)\njmp    1f56 <expression+0x236>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x81d2(%rip),%rax\nmov    $0xa2,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x81c2(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x81ae(%rip),%rax\nmov    %r15,0x8117(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x1b,0x8(%rax)\nmov    %rdx,0x8194(%rip)\njmp    1f56 <expression+0x236>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x817a(%rip),%rax\nmov    $0xa2,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x816a(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x8156(%rip),%rax\nmov    %r15,0x80bf(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x1c,0x8(%rax)\nmov    %rdx,0x813c(%rip)\njmp    1f56 <expression+0x236>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x8122(%rip),%rax\nmov    $0x9d,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x8112(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x80fe(%rip),%rax\nmovq   $0x1,0x8063(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x17,0x8(%rax)\nmov    %rdx,0x80e0(%rip)\njmp    1f56 <expression+0x236>\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x80ca(%rip),%rax\nmov    $0x9d,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x80ba(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x80a6(%rip),%rax\nmovq   $0x1,0x800b(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x18,0x8(%rax)\nmov    %rdx,0x8088(%rip)\njmp    1f56 <expression+0x236>\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x8072(%rip),%rax\nmov    $0x9f,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x8062(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    %r15,0x7fbe(%rip)\nmov    0x8047(%rip),%rax\ncmp    $0x2,%r15\njle    2332 <expression+0x612>\nmov    0x803a(%rip),%rdx\nmovq   $0xd,0x8(%rdx)\nlea    0x20(%rdx),%rax\nmovq   $0x1,0x10(%rdx)\nmovq   $0x8,0x18(%rdx)\nmovq   $0x1b,0x20(%rdx)\nlea    0x8(%rax),%rdx\nmovq   $0x19,0x8(%rax)\nmov    %rdx,0x8003(%rip)\njmp    1f56 <expression+0x236>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7fea(%rip),%rax\nmov    $0x9f,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7fda(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x7fc6(%rip),%rax\ncmp    $0x2,%r15\njg     2d10 <expression+0xff0>\nlea    0x8(%rax),%rdx\nmovq   $0x1a,0x8(%rax)\nmov    %rdx,0x7fa9(%rip)\nmov    %r15,0x7f12(%rip)\njmp    1f56 <expression+0x236>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7f8a(%rip),%rax\nmov    $0x94,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7f7a(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x7f66(%rip),%rax\nmovq   $0x1,0x7ecb(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0xf,0x8(%rax)\nmov    %rdx,0x7f48(%rip)\njmp    1f56 <expression+0x236>\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7f32(%rip),%rax\nmov    $0x9b,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7f22(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x7f0e(%rip),%rax\nmovq   $0x1,0x7e73(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x13,0x8(%rax)\nmov    %rdx,0x7ef0(%rip)\njmp    1f56 <expression+0x236>\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7eda(%rip),%rax\nmov    $0x9b,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7eca(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x7eb6(%rip),%rax\nmovq   $0x1,0x7e1b(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x14,0x8(%rax)\nmov    %rdx,0x7e98(%rip)\njmp    1f56 <expression+0x236>\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7e82(%rip),%rax\nmov    $0x9b,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7e72(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x7e5e(%rip),%rax\nmovq   $0x1,0x7dc3(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x15,0x8(%rax)\nmov    %rdx,0x7e40(%rip)\njmp    1f56 <expression+0x236>\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7e2a(%rip),%rax\nmov    $0x9b,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7e1a(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x7e06(%rip),%rax\nmovq   $0x1,0x7d6b(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x16,0x8(%rax)\nmov    %rdx,0x7de8(%rip)\njmp    1f56 <expression+0x236>\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7dd2(%rip),%rax\nmov    $0x96,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7dc2(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x7dae(%rip),%rax\nmovq   $0x1,0x7d13(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x11,0x8(%rax)\nmov    %rdx,0x7d90(%rip)\njmp    1f56 <expression+0x236>\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7d7a(%rip),%rax\nmov    $0x97,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7d6a(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x7d56(%rip),%rax\nmovq   $0x1,0x7cbb(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x12,0x8(%rax)\nmov    %rdx,0x7d38(%rip)\njmp    1f56 <expression+0x236>\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7d22(%rip),%rax\nmov    $0x95,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7d12(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x7cfe(%rip),%rax\nmovq   $0x1,0x7c63(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0x10,0x8(%rax)\nmov    %rdx,0x7ce0(%rip)\njmp    1f56 <expression+0x236>\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7cca(%rip),%rax\nmov    $0x8e,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7cba(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\ncmpq   $0x5d,0x7cad(%rip)\nje     2f60 <expression+0x1240>\nmov    0x7c20(%rip),%rsi\nmov    %r13,%rdi\nmov    $0x5d,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nlea    -0x2(%r15),%rcx\ncmp    $0x2,%r15\njle    2d60 <expression+0x1040>\nmov    0x7c6a(%rip),%rdx\nmovq   $0xd,0x8(%rdx)\nlea    0x20(%rdx),%rax\nmovq   $0x1,0x10(%rdx)\nmovq   $0x8,0x18(%rdx)\nmovq   $0x1b,0x20(%rdx)\nmovq   $0x19,0x8(%rax)\nmov    %rcx,0x7ba7(%rip)\nmov    $0x9,%ecx\nlea    0x10(%rax),%rdx\nmov    %rcx,0x10(%rax)\nmov    %rdx,0x7c23(%rip)\njmp    1f56 <expression+0x236>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7c0a(%rip),%rdx\nmov    $0x8e,%edi\nmovq   $0x4,0x8(%rdx)\nlea    0x10(%rdx),%rax\nmov    %rdx,0x8(%rsp)\nmov    %rax,0x7bed(%rip)\ncall   1d20 <expression>\ncmpq   $0x3a,0x7be8(%rip)\nmov    0x8(%rsp),%rdx\nje     2f4f <expression+0x122f>\nmov    0x7b56(%rip),%rsi\nlea    0x4b6f(%rip),%rdi\nxor    %eax,%eax\nmov    %rdx,0x8(%rsp)\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x8(%rsp),%rdx\nmov    0x7ba5(%rip),%r15\nmov    $0x8f,%edi\nlea    0x18(%r15),%rax\nmov    %rax,0x10(%rdx)\nlea    0x10(%r15),%rax\nmovq   $0x2,0x8(%r15)\nmov    %rax,0x7b85(%rip)\ncall   1d20 <expression>\nmov    0x7b79(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x10(%r15)\njmp    1f56 <expression+0x236>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7b5a(%rip),%r15\nmov    $0x92,%edi\nlea    0x10(%r15),%rax\nmovq   $0x4,0x8(%r15)\nmov    %rax,0x7b42(%rip)\ncall   1d20 <expression>\nmov    0x7b36(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,0x10(%r15)\nmovq   $0x1,0x7a93(%rip)\njmp    1f56 <expression+0x236>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7b0a(%rip),%rax\nmov    $0x93,%edi\nlea    0x8(%rax),%rdx\nmov    %rdx,0x7afa(%rip)\nmovq   $0xd,0x8(%rax)\ncall   1d20 <expression>\nmov    0x7ae6(%rip),%rax\nmovq   $0x1,0x7a4b(%rip)\nlea    0x8(%rax),%rdx\nmovq   $0xe,0x8(%rax)\nmov    %rdx,0x7ac8(%rip)\njmp    1f56 <expression+0x236>\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7ab2(%rip),%r15\nmov    $0x91,%edi\nlea    0x10(%r15),%rax\nmovq   $0x5,0x8(%r15)\nmov    %rax,0x7a9a(%rip)\njmp    2806 <expression+0xae6>\nxor    %eax,%eax\ncall   1580 <next>\nmov    $0xa2,%edi\ncall   1d20 <expression>\nmov    0x7a7d(%rip),%rdx\nmov    (%rdx),%rax\ncmp    $0xa,%rax\nje     2e52 <expression+0x1132>\ncmp    $0x9,%rax\njne    2fb3 <expression+0x1293>\nmovq   $0xd,(%rdx)\nlea    0x8(%rdx),%rax\nmovq   $0x9,0x8(%rdx)\nmov    0x79bc(%rip),%rcx\nmovq   $0xd,0x8(%rax)\nmovq   $0x1,0x10(%rax)\ncmp    $0x2,%rcx\njg     2f85 <expression+0x1265>\nxor    %edx,%edx\ncmp    $0xa2,%rbp\nmovq   $0x1,0x18(%rax)\nsetne  %dl\nadd    $0x19,%rdx\nneg    %rcx\nsbb    %rcx,%rcx\nadd    $0xc,%rcx\nmov    %rdx,0x20(%rax)\nlea    0x28(%rax),%rdx\nmov    %rdx,0x7a01(%rip)\nmov    0x7a02(%rip),%rdx\nmov    %rcx,0x28(%rax)\njmp    1e40 <expression+0x120>\nxor    %eax,%eax\ncall   1580 <next>\nmov    $0xa2,%edi\ncall   1d20 <expression>\nmov    0x7949(%rip),%rax\ncmp    $0x1,%rax\njle    2f0c <expression+0x11ec>\nsub    $0x2,%rax\nmov    %rax,0x7934(%rip)\nmov    0x79bd(%rip),%rdx\ncmp    $0x1,%rax\nmov    $0x9,%eax\nadc    $0x0,%rax\nlea    0x8(%rdx),%rcx\nmov    %rax,0x8(%rdx)\nmov    0x79a9(%rip),%rdx\nmov    %rcx,0x799a(%rip)\njmp    1e40 <expression+0x120>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7987(%rip),%rax\ncmpq   $0x80,0x7984(%rip)\nmovq   $0x1,0x8(%rax)\nje     2e6a <expression+0x114a>\nmovq   $0xffffffffffffffff,0x10(%rax)\nlea    0x18(%rax),%rdx\nmov    $0xa2,%edi\nmovq   $0xd,0x18(%rax)\nmov    %rdx,0x794e(%rip)\ncall   1d20 <expression>\nmov    0x7942(%rip),%rax\nlea    0x8(%rax),%rdx\nmovq   $0x1b,0x8(%rax)\nmov    %rdx,0x792f(%rip)\nmovq   $0x1,0x7894(%rip)\nmov    0x7925(%rip),%rdx\njmp    1e40 <expression+0x120>\nxor    %eax,%eax\ncall   1580 <next>\nmov    $0xa2,%edi\ncall   1d20 <expression>\nmov    0x7908(%rip),%rdx\nmovq   $0x1,0x7865(%rip)\njmp    1e40 <expression+0x120>\nxor    %eax,%eax\ncall   1580 <next>\nmov    $0xa2,%edi\ncall   1d20 <expression>\nmov    0x78d8(%rip),%rdx\nmov    (%rdx),%rax\nsub    $0x9,%rax\ncmp    $0x1,%rax\nja     2e2e <expression+0x110e>\nsub    $0x8,%rdx\nmov    %rdx,0x78bc(%rip)\naddq   $0x2,0x7824(%rip)\nmov    0x78b5(%rip),%rdx\njmp    1e40 <expression+0x120>\nxor    %eax,%eax\ncall   1580 <next>\ncmpq   $0x28,0x78a1(%rip)\nje     2e8f <expression+0x116f>\nmov    0x7814(%rip),%rsi\nlea    0x4551(%rip),%rdi\nmov    $0x28,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x7870(%rip),%rax\nmovq   $0x1,0x77cd(%rip)\ncmp    $0x8a,%rax\nje     30b0 <expression+0x1390>\ncmp    $0x86,%rax\njne    2b1e <expression+0xdfe>\njmp    313b <expression+0x141b>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\naddq   $0x2,0x77a1(%rip)\nmov    0x7832(%rip),%rax\ncmp    $0x9f,%rax\nje     2b08 <expression+0xde8>\ncmp    $0x29,%rax\nje     2fa7 <expression+0x1287>\nmov    0x7799(%rip),%rsi\nlea    0x44d6(%rip),%rdi\nmov    $0x29,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\ncmpq   $0x1,0x775c(%rip)\nmov    0x77e5(%rip),%rdx\nmovq   $0x1,0x774a(%rip)\nsbb    %rax,%rax\nand    $0xfffffffffffffff9,%rax\nlea    0x10(%rdx),%rcx\nmovq   $0x1,0x8(%rdx)\nadd    $0x8,%rax\nmov    %rcx,0x77bc(%rip)\nmov    %rax,0x10(%rdx)\nmov    0x77b9(%rip),%rdx\njmp    1e40 <expression+0x120>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x77a6(%rip),%rdx\nmov    0x772f(%rip),%rbp\ncmp    $0x28,%rdx\nje     2fde <expression+0x12be>\nmov    0x20(%rbp),%rax\ncmp    $0x80,%rax\nje     2eda <expression+0x11ba>\ncmp    $0x84,%rax\nje     30c3 <expression+0x13a3>\ncmp    $0x83,%rax\njne    30ea <expression+0x13ca>\nmov    0x775e(%rip),%rax\nmovq   $0x1,0x8(%rax)\nmov    0x28(%rbp),%rsi\nlea    0x10(%rax),%rcx\nmov    %rsi,0x10(%rax)\nmov    0x18(%rbp),%rax\nlea    0x8(%rcx),%rsi\nmov    %rsi,0x773b(%rip)\ncmp    $0x1,%rax\nmov    %rax,0x76a0(%rip)\nmov    $0x9,%eax\nadc    $0x0,%rax\nmov    %rax,0x8(%rcx)\njmp    1e40 <expression+0x120>\nxor    %eax,%eax\ncall   1580 <next>\nmov    $0xa2,%edi\ncall   1d20 <expression>\nmov    0x7706(%rip),%rax\nmovq   $0x1,0x766b(%rip)\nlea    0x20(%rax),%rdx\nmovq   $0xd,0x8(%rax)\nmov    %rdx,0x76e8(%rip)\nmov    0x76e9(%rip),%rdx\nmovq   $0x1,0x10(%rax)\nmovq   $0xffffffffffffffff,0x18(%rax)\nmovq   $0xf,0x20(%rax)\njmp    1e40 <expression+0x120>\nmov    0x7645(%rip),%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\njmp    1f56 <expression+0x236>\nnopl   0x0(%rax)\nmov    0x7699(%rip),%rax\nlea    0x10(%rax),%rdx\nmovq   $0x1,0x8(%rax)\nmov    %rdx,0x7686(%rip)\nmov    0x75ff(%rip),%rdx\nmov    %rdx,0x10(%rax)\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7672(%rip),%rdx\ncmp    $0x22,%rdx\nje     2cd0 <expression+0xfb0>\nmov    0x7645(%rip),%rax\nmovq   $0x2,0x75c2(%rip)\nadd    $0x8,%rax\nand    $0xfffffffffffffff8,%rax\nmov    %rax,0x762b(%rip)\njmp    1e40 <expression+0x120>\nnopw   0x0(%rax,%rax,1)\ncmp    %r15,0x75a1(%rip)\nlea    0x28(%rax),%rdx\nje     2e9b <expression+0x117b>\nmovq   $0xd,0x8(%rax)\nmovq   $0x1,0x10(%rax)\nmovq   $0x8,0x18(%rax)\nmovq   $0x1b,0x20(%rax)\nmov    %rdx,0x7600(%rip)\nmovq   $0x1a,0x28(%rax)\nmov    %r15,0x7561(%rip)\njmp    1f56 <expression+0x236>\nnopl   0x0(%rax)\nmov    %rcx,0x8(%rsp)\njne    2e02 <expression+0x10e2>\nmov    0x75d6(%rip),%rax\nmov    $0xa,%ecx\nmovq   $0x0,0x7536(%rip)\nmovq   $0x19,0x8(%rax)\njmp    2716 <expression+0x9f6>\nmov    0x753a(%rip),%rsi\nlea    0x4302(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x7593(%rip),%rax\njmp    2081 <expression+0x361>\nmov    $0x8e,%edi\ncall   1d20 <expression>\ncmpq   $0x29,0x7584(%rip)\nje     311c <expression+0x13fc>\nmov    0x74f7(%rip),%rsi\nmov    $0x29,%edx\nlea    0x422f(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x7553(%rip),%rdx\njmp    1e40 <expression+0x120>\nmov    0x74c7(%rip),%rsi\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x7524(%rip),%rax\nmov    0x8(%rsp),%rcx\njmp    2702 <expression+0x9e2>\nmov    0x749b(%rip),%rsi\nlea    0x4239(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\njmp    2a8c <expression+0xd6c>\nmovq   $0xd,(%rdx)\nlea    0x8(%rdx),%rax\nmovq   $0xa,0x8(%rdx)\njmp    28f5 <expression+0xbd5>\nlea    0x10(%rax),%rdx\nmov    %rdx,0x74d3(%rip)\nmov    0x744c(%rip),%rdx\nneg    %rdx\nmov    %rdx,0x10(%rax)\nxor    %eax,%eax\ncall   1580 <next>\njmp    2a19 <expression+0xcf9>\nxor    %eax,%eax\ncall   1580 <next>\njmp    2ad9 <expression+0xdb9>\nmovq   $0x1a,0x8(%rax)\nmovq   $0xd,0x10(%rax)\nmovq   $0x1,0x18(%rax)\nmovq   $0x8,0x20(%rax)\nmov    %rdx,0x7486(%rip)\nmovq   $0x1c,0x28(%rax)\nmovq   $0x1,0x73e3(%rip)\njmp    1f56 <expression+0x236>\nmov    0x7467(%rip),%rax\nmovq   $0x1,0x73cc(%rip)\nlea    0x10(%rax),%rcx\nmovq   $0x1,0x8(%rax)\nmov    %rcx,0x7449(%rip)\nmov    0x28(%rbp),%rcx\nmov    %rcx,0x10(%rax)\njmp    1e40 <expression+0x120>\nmov    0x73bd(%rip),%rsi\nlea    0x4145(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x7386(%rip),%rax\njmp    2984 <expression+0xc64>\nmovq   $0xd,(%rdx)\nlea    0x8(%rdx),%rax\nmovq   $0x9,0x8(%rdx)\njmp    2081 <expression+0x361>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x8(%rsp),%rdx\njmp    279c <expression+0xa7c>\nxor    %eax,%eax\ncall   1580 <next>\njmp    26c9 <expression+0x9a9>\nneg    %rcx\nmov    $0x19,%edi\nmov    $0x1a,%esi\nsbb    %rcx,%rcx\nadd    $0xc,%rcx\njmp    20d3 <expression+0x3b3>\nxor    %edx,%edx\ncmp    $0xa2,%rbp\nmovq   $0x8,0x18(%rax)\nmov    $0xb,%ecx\nsetne  %dl\nadd    $0x19,%rdx\njmp    2938 <expression+0xc18>\nxor    %eax,%eax\ncall   1580 <next>\njmp    2b54 <expression+0xe34>\nmov    0x7316(%rip),%rsi\nlea    0x42e7(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x736f(%rip),%rax\njmp    28f5 <expression+0xbd5>\nxor    %eax,%eax\nxor    %r12d,%r12d\ncall   1580 <next>\ncmpq   $0x29,0x7360(%rip)\nje     3031 <expression+0x1311>\nmov    $0x8e,%edi\nadd    $0x1,%r12\ncall   1d20 <expression>\nmov    0x7341(%rip),%rax\nlea    0x8(%rax),%rdx\nmovq   $0xd,0x8(%rax)\nmov    0x7336(%rip),%rax\nmov    %rdx,0x7327(%rip)\ncmp    $0x2c,%rax\nje     3159 <expression+0x1439>\ncmp    $0x29,%rax\njne    2ff2 <expression+0x12d2>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x20(%rbp),%rax\ncmp    $0x82,%rax\nje     3190 <expression+0x1470>\ncmp    $0x81,%rax\njne    316c <expression+0x144c>\nmov    0x72ed(%rip),%rax\nlea    0x10(%rax),%rdx\nmovq   $0x3,0x8(%rax)\nmov    %rdx,0x72da(%rip)\nmov    0x28(%rbp),%rdx\nmov    %rdx,0x10(%rax)\ntest   %r12,%r12\nje     3099 <expression+0x1379>\nmov    0x72c6(%rip),%rax\nlea    0x10(%rax),%rdx\nmovq   $0x7,0x8(%rax)\nmov    %rdx,0x72b3(%rip)\nmov    %r12,0x10(%rax)\nmov    0x18(%rbp),%rax\nmov    0x72ac(%rip),%rdx\nmov    %rax,0x720d(%rip)\njmp    1e40 <expression+0x120>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7292(%rip),%rax\njmp    2b1e <expression+0xdfe>\nmov    0x727e(%rip),%rax\nmov    0x71df(%rip),%rsi\nmovq   $0x0,0x8(%rax)\nsub    0x28(%rbp),%rsi\nlea    0x10(%rax),%rcx\nmov    %rsi,0x10(%rax)\njmp    2bfe <expression+0xede>\nmov    0x71df(%rip),%rsi\nlea    0x3f4e(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x7238(%rip),%rcx\nmov    0x7239(%rip),%rdx\njmp    2bfe <expression+0xede>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7226(%rip),%rdx\njmp    1e40 <expression+0x120>\nxor    %eax,%eax\ncall   1580 <next>\njmp    1e28 <expression+0x108>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7207(%rip),%rax\nmovq   $0x0,0x7164(%rip)\njmp    2b1e <expression+0xdfe>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x71e9(%rip),%rax\njmp    302b <expression+0x130b>\nmov    0x715d(%rip),%rsi\nlea    0x3eb4(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\njmp    3076 <expression+0x1356>\nmov    0x71b1(%rip),%rax\nlea    0x8(%rax),%rdx\nmov    %rdx,0x71a6(%rip)\nmov    0x28(%rbp),%rdx\nmov    %rdx,0x8(%rax)\njmp    3076 <expression+0x1356>\nnop\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "function_body", "content": "void function_body() {\n    // type func_name (...) {...}\n    //                   -->|   |<--\n\n    // ... {\n    // 1. local declarations\n    // 2. statements\n    // }\n\n    long pos_local; // position of local variables on the stack.\n    long type;\n    pos_local = index_of_bp;\n\n    while (token == Int || token == Char) {\n        // local variable declaration, just like global ones.\n        basetype = (token == Int) ? INT : CHAR;\n        match(token);\n\n        while (token != ';') {\n            type = basetype;\n            while (token == Mul) {\n                match(Mul);\n                type = type + PTR;\n            }\n\n            if (token != Id) {\n                // invalid declaration\n                libmin_printf(\"%ld: bad local declaration\\n\", line);\n                libmin_fail(-1);\n            }\n            if (current_id[Class] == Loc) {\n                // identifier exists\n                libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n                libmin_fail(-1);\n            }\n            match(Id);\n\n            // store the local variable\n            current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;\n            current_id[BType]  = current_id[Type];  current_id[Type]   = type;\n            current_id[BValue] = current_id[Value]; current_id[Value]  = ++pos_local;   // index of current parameter\n\n            if (token == ',') {\n                match(',');\n            }\n        }\n        match(';');\n    }\n\n    // save the stack size for local variables\n    *++text = ENT;\n    *++text = pos_local - index_of_bp;\n\n    // statements\n    while (token != '}') {\n        statement();\n    }\n\n    // emit code for leaving the sub function\n    *++text = LEV;\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O2.pseudo", "function_name": "function_body", "address": "0x37f0", "label": "function_body", "content": "void __cdecl function_body()\n{\n  __int64 v0; // rdx\n  bool v1; // al\n  __int64 v2; // rbp\n  __int64 v3; // rax\n  __int64 v4; // rbx\n  __int64 *v5; // rax\n  __int64 v6; // rdx\n  __int64 v7; // rdx\n  __int64 v8; // rdx\n  __int64 v9; // rbp\n  _QWORD *v10; // rcx\n  _QWORD *v11; // rax\n\n  v0 = token;\n  v1 = token == 138;\n  v2 = index_of_bp;\n  if ( ((token - 134) & 0xFFFFFFFFFFFFFFFBLL) != 0 )\n  {\n    v9 = 0LL;\n  }\n  else\n  {\n    do\n    {\n      basetype = v1;\n      while ( 1 )\n      {\n        next();\n        v3 = token;\n        if ( token == 59 )\n          break;\n        while ( 1 )\n        {\n          v4 = basetype;\n          if ( v3 == 159 )\n          {\n            do\n            {\n              v4 += 2LL;\n              next();\n              v3 = token;\n            }\n            while ( token == 159 );\n          }\n          if ( v3 != 133 )\n          {\n            libmin_printf(\"%ld: bad local declaration\\n\", line);\n            libmin_fail(-1);\n          }\n          if ( current_id[4] == 132 )\n          {\n            libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n            libmin_fail(-1);\n          }\n          if ( token != 133 )\n          {\n            libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n            libmin_fail(-1);\n          }\n          next();\n          v5 = current_id;\n          ++v2;\n          v6 = current_id[4];\n          current_id[4] = 132LL;\n          v5[7] = v6;\n          v7 = v5[3];\n          v5[3] = v4;\n          v5[6] = v7;\n          v8 = v5[5];\n          v5[5] = v2;\n          v5[8] = v8;\n          v3 = token;\n          if ( token == 44 )\n            break;\n          if ( token == 59 )\n            goto LABEL_13;\n        }\n      }\nLABEL_13:\n      next();\n      v0 = token;\n      v1 = token == 138;\n    }\n    while ( ((token - 134) & 0xFFFFFFFFFFFFFFFBLL) == 0 );\n    v9 = v2 - index_of_bp;\n  }\n  v10 = text;\n  v11 = (char *)text + 16;\n  *((_QWORD *)text + 1) = 6LL;\n  text = v11;\n  v10[2] = v9;\n  if ( v0 != 125 )\n  {\n    do\n      statement();\n    while ( token != 125 );\n    v11 = text;\n  }\n  v11[1] = 8LL;\n  text = v11 + 1;\n}\n"}, "pseudo_normalize": "void function_body() {\n  long long v0;\n  bool v1;\n  long long v2;\n  long long v3;\n  long long v4;\n  long long *v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  uint64_t *v10;\n  uint64_t *v11;\n  v0 = token;\n  v1 = token == 138;\n  v2 = index_of_bp;\n  if (((token - 134) & 18446744073709551611LL) != 0) {\n    v9 = 0LL;\n  } else {\n    do {\n      basetype = v1;\n      while (1) {\n        next();\n        v3 = token;\n        if (token == 59) break;\n        while (1) {\n          v4 = basetype;\n          if (v3 == 159) {\n            do {\n              v4 += 2LL;\n              next();\n              v3 = token;\n            } while (token == 159);\n          }\n          if (v3 != 133) {\n            libmin_printf(\"%ld: bad local declaration\\n\", line);\n            libmin_fail(-1);\n          }\n          if (current_id[4] == 132) {\n            libmin_printf(\"%ld: duplicate local declaration\\n\", line);\n            libmin_fail(-1);\n          }\n          if (token != 133) {\n            libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n            libmin_fail(-1);\n          }\n          next();\n          v5 = current_id;\n          ++v2;\n          v6 = current_id[4];\n          current_id[4] = 132LL;\n          v5[7] = v6;\n          v7 = v5[3];\n          v5[3] = v4;\n          v5[6] = v7;\n          v8 = v5[5];\n          v5[5] = v2;\n          v5[8] = v8;\n          v3 = token;\n          if (token == 44) break;\n          if (token == 59) goto LABEL_13;\n        }\n      }\n    LABEL_13:\n      next();\n      v0 = token;\n      v1 = token == 138;\n    } while (((token - 134) & 18446744073709551611LL) == 0);\n    v9 = v2 - index_of_bp;\n  }\n  v10 = text;\n  v11 = (char *)text + 16;\n  *((uint64_t *)text + 1) = 6LL;\n  text = v11;\n  v10[2] = v9;\n  if (v0 != 125) {\n    do statement();\n    while (token != 125);\n    v11 = text;\n  }\n  v11[1] = 8LL;\n  text = v11 + 1;\n}", "binary": "c-interp/c-interp.host.O2", "assembly": "<function_body>:\nendbr64\nmov    0x6b55(%rip),%rdx\npush   %r14\npush   %r13\ncmp    $0x8a,%rdx\nlea    -0x86(%rdx),%rcx\npush   %r12\nsete   %al\npush   %rbp\nmov    0x6a96(%rip),%rbp\npush   %rbx\ntest   $0xfffffffffffffffb,%rcx\njne    3a08 <function_body+0x218>\nlea    0x38e2(%rip),%r13\nlea    0x3b52(%rip),%r14\nlea    0x37d7(%rip),%r12\nnopl   (%rax)\nmovzbl %al,%eax\nmov    %rax,0x6a76(%rip)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x6af8(%rip),%rax\ncmp    $0x3b,%rax\nje     3949 <function_body+0x159>\nmov    0x6a57(%rip),%rbx\ncmp    $0x9f,%rax\njne    3892 <function_body+0xa2>\nnopl   0x0(%rax)\nxor    %eax,%eax\nadd    $0x2,%rbx\ncall   1580 <next>\nmov    0x6ac6(%rip),%rax\ncmp    $0x9f,%rax\nje     3878 <function_body+0x88>\ncmp    $0x85,%rax\nje     38b5 <function_body+0xc5>\nmov    0x6a2f(%rip),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x6a24(%rip),%rax\ncmpq   $0x84,0x20(%rax)\nje     39e8 <function_body+0x1f8>\ncmpq   $0x85,0x6a7b(%rip)\nje     39d8 <function_body+0x1e8>\nmov    0x69ee(%rip),%rsi\nmov    %r12,%rdi\nmov    $0x85,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x69de(%rip),%rax\nadd    $0x1,%rbp\nmov    0x20(%rax),%rdx\nmovq   $0x84,0x20(%rax)\nmov    %rdx,0x38(%rax)\nmov    0x18(%rax),%rdx\nmov    %rbx,0x18(%rax)\nmov    %rdx,0x30(%rax)\nmov    0x28(%rax),%rdx\nmov    %rbp,0x28(%rax)\nmov    %rdx,0x40(%rax)\nmov    0x6a1b(%rip),%rax\ncmp    $0x2c,%rax\nje     384a <function_body+0x5a>\ncmp    $0x3b,%rax\njne    3862 <function_body+0x72>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x69f9(%rip),%rdx\ncmp    $0x8a,%rdx\nlea    -0x86(%rdx),%rcx\nsete   %al\ntest   $0xfffffffffffffffb,%rcx\nje     3840 <function_body+0x50>\nsub    0x6934(%rip),%rbp\nmov    0x69c5(%rip),%rcx\nlea    0x10(%rcx),%rax\nmovq   $0x6,0x8(%rcx)\nmov    %rax,0x69b2(%rip)\nmov    %rbp,0x10(%rcx)\ncmp    $0x7d,%rdx\nje     39b8 <function_body+0x1c8>\nxor    %eax,%eax\ncall   31b0 <statement>\ncmpq   $0x7d,0x69a1(%rip)\njne    39a0 <function_body+0x1b0>\nmov    0x6990(%rip),%rax\nlea    0x8(%rax),%rdx\nmovq   $0x8,0x8(%rax)\npop    %rbx\nmov    %rdx,0x697c(%rip)\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\njmp    38fb <function_body+0x10b>\nnopl   0x0(%rax)\nmov    0x68e1(%rip),%rsi\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\njmp    38ca <function_body+0xda>\nxor    %ebp,%ebp\njmp    397c <function_body+0x18c>\nnop\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "function_declaration", "content": "void function_declaration() {\n    // type func_name (...) {...}\n    //               | this part\n\n    match('(');\n    function_parameter();\n    match(')');\n    match('{');\n    function_body();\n    //match('}');\n\n    // unwind local variable declarations for all local variables.\n    current_id = symbols;\n    while (current_id[Token]) {\n        if (current_id[Class] == Loc) {\n            current_id[Class] = current_id[BClass];\n            current_id[Type]  = current_id[BType];\n            current_id[Value] = current_id[BValue];\n        }\n        current_id = current_id + IdSize;\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O2.pseudo", "function_name": "function_declaration", "address": "0x3a10", "label": "function_declaration", "content": "void __cdecl function_declaration()\n{\n  bool v0; // zf\n  __int64 *v1; // rax\n  __int64 *v2; // rdx\n\n  if ( token != 40 )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n    libmin_fail(-1);\n  }\n  next();\n  function_parameter();\n  if ( token != 41 )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n    libmin_fail(-1);\n  }\n  next();\n  if ( token != 123 )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, 123LL);\n    libmin_fail(-1);\n  }\n  next();\n  function_body();\n  v0 = *(_QWORD *)symbols == 0LL;\n  current_id = (__int64 *)symbols;\n  if ( !v0 )\n  {\n    v1 = (__int64 *)((char *)symbols + 72);\n    do\n    {\n      v2 = v1;\n      if ( *(v1 - 5) == 132 )\n      {\n        *(v1 - 5) = *(v1 - 2);\n        *(v1 - 6) = *(v1 - 3);\n        *(v1 - 4) = *(v1 - 1);\n      }\n      v1 += 9;\n    }\n    while ( *(v1 - 9) );\n    current_id = v2;\n  }\n}\n"}, "pseudo_normalize": "void function_declaration() {\n  bool v0;\n  long long *v1;\n  long long *v2;\n  if (token != 40) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n    libmin_fail(-1);\n  }\n  next();\n  function_parameter();\n  if (token != 41) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n    libmin_fail(-1);\n  }\n  next();\n  if (token != 123) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, 123LL);\n    libmin_fail(-1);\n  }\n  next();\n  function_body();\n  v0 = *(uint64_t *)symbols == 0LL;\n  current_id = (long long *)symbols;\n  if (!v0) {\n    v1 = (long long *)((char *)symbols + 72);\n    do {\n      v2 = v1;\n      if (*(v1 - 5) == 132) {\n        *(v1 - 5) = *(v1 - 2);\n        *(v1 - 6) = *(v1 - 3);\n        *(v1 - 4) = *(v1 - 1);\n      }\n      v1 += 9;\n    } while (*(v1 - 9));\n    current_id = v2;\n  }\n}", "binary": "c-interp/c-interp.host.O2", "assembly": "<function_declaration>:\nendbr64\nsub    $0x8,%rsp\ncmpq   $0x28,0x6930(%rip)\nje     3b18 <function_declaration+0x108>\nmov    0x68a3(%rip),%rsi\nlea    0x35e0(%rip),%rdi\nmov    $0x28,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nxor    %eax,%eax\ncall   3610 <function_parameter>\ncmpq   $0x29,0x68f7(%rip)\nje     3b38 <function_declaration+0x128>\nmov    0x686a(%rip),%rsi\nlea    0x35a7(%rip),%rdi\nmov    $0x29,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\ncmpq   $0x7b,0x68c5(%rip)\nje     3b28 <function_declaration+0x118>\nmov    0x6838(%rip),%rsi\nlea    0x3575(%rip),%rdi\nmov    $0x7b,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nxor    %eax,%eax\ncall   37f0 <function_body>\nmov    0x6815(%rip),%rax\ncmpq   $0x0,(%rax)\nmov    %rax,0x6812(%rip)\nje     3b0f <function_declaration+0xff>\nadd    $0x48,%rax\nnopl   0x0(%rax)\ncmpq   $0x84,-0x28(%rax)\nmov    %rax,%rdx\njne    3afd <function_declaration+0xed>\nmov    -0x10(%rax),%rcx\nmov    %rcx,-0x28(%rax)\nmov    -0x18(%rax),%rcx\nmov    %rcx,-0x30(%rax)\nmov    -0x8(%rax),%rcx\nmov    %rcx,-0x20(%rax)\nadd    $0x48,%rax\ncmpq   $0x0,-0x48(%rax)\njne    3ad8 <function_declaration+0xc8>\nmov    %rdx,0x67d1(%rip)\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\njmp    3a4a <function_declaration+0x3a>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\njmp    3ab5 <function_declaration+0xa5>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\njmp    3a83 <function_declaration+0x73>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "function_parameter", "content": "void function_parameter() {\n    long type;\n    long params;\n    params = 0;\n    while (token != ')') {\n        // int name, ...\n        type = INT;\n        if (token == Int) {\n            match(Int);\n        } else if (token == Char) {\n            type = CHAR;\n            match(Char);\n        }\n\n        // pointer type\n        while (token == Mul) {\n            match(Mul);\n            type = type + PTR;\n        }\n\n        // parameter name\n        if (token != Id) {\n            libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        if (current_id[Class] == Loc) {\n            libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n            libmin_fail(-1);\n        }\n\n        match(Id);\n        // store the local variable\n        current_id[BClass] = current_id[Class]; current_id[Class]  = Loc;\n        current_id[BType]  = current_id[Type];  current_id[Type]   = type;\n        current_id[BValue] = current_id[Value]; current_id[Value]  = params++;   // index of current parameter\n\n        if (token == ',') {\n            match(',');\n        }\n    }\n    index_of_bp = params+1;\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O2.pseudo", "function_name": "function_parameter", "address": "0x3610", "label": "function_parameter", "content": "void __cdecl function_parameter()\n{\n  __int64 v0; // rax\n  __int64 v1; // rbp\n  __int64 v2; // rbx\n  __int64 *v3; // rax\n  __int64 v4; // rdx\n  __int64 v5; // rdx\n  __int64 v6; // rdx\n\n  v0 = token;\n  if ( token != 41 )\n  {\n    v1 = 0LL;\n    if ( token == 138 )\n      goto LABEL_15;\nLABEL_3:\n    v2 = 1LL;\n    if ( v0 == 134 )\n    {\n      v2 = 0LL;\n      next();\n      v0 = token;\n    }\n    while ( 1 )\n    {\n      while ( v0 == 159 )\n      {\n        v2 += 2LL;\n        next();\n        v0 = token;\n      }\n      if ( v0 != 133 )\n      {\n        libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( current_id[4] == 132 )\n      {\n        libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if ( token != 133 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n        libmin_fail(-1);\n      }\n      next();\n      v3 = current_id;\n      v4 = current_id[4];\n      current_id[4] = 132LL;\n      v3[7] = v4;\n      v5 = v3[3];\n      v3[3] = v2;\n      v3[6] = v5;\n      v6 = v3[5];\n      v3[5] = v1;\n      v3[8] = v6;\n      v0 = token;\n      if ( token == 44 )\n      {\n        next();\n        v0 = token;\n        if ( token == 41 )\n        {\nLABEL_19:\n          index_of_bp = v1 + 2;\n          return;\n        }\n      }\n      else if ( token == 41 )\n      {\n        goto LABEL_19;\n      }\n      ++v1;\n      if ( v0 != 138 )\n        goto LABEL_3;\nLABEL_15:\n      v2 = 1LL;\n      next();\n      v0 = token;\n    }\n  }\n  index_of_bp = 1LL;\n}\n"}, "pseudo_normalize": "void function_parameter() {\n  long long v0;\n  long long v1;\n  long long v2;\n  long long *v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  v0 = token;\n  if (token != 41) {\n    v1 = 0LL;\n    if (token == 138) goto LABEL_15;\n  LABEL_3:\n    v2 = 1LL;\n    if (v0 == 134) {\n      v2 = 0LL;\n      next();\n      v0 = token;\n    }\n    while (1) {\n      while (v0 == 159) {\n        v2 += 2LL;\n        next();\n        v0 = token;\n      }\n      if (v0 != 133) {\n        libmin_printf(\"%ld: bad parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (current_id[4] == 132) {\n        libmin_printf(\"%ld: duplicate parameter declaration\\n\", line);\n        libmin_fail(-1);\n      }\n      if (token != 133) {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n        libmin_fail(-1);\n      }\n      next();\n      v3 = current_id;\n      v4 = current_id[4];\n      current_id[4] = 132LL;\n      v3[7] = v4;\n      v5 = v3[3];\n      v3[3] = v2;\n      v3[6] = v5;\n      v6 = v3[5];\n      v3[5] = v1;\n      v3[8] = v6;\n      v0 = token;\n      if (token == 44) {\n        next();\n        v0 = token;\n        if (token == 41) {\n        LABEL_19:\n          index_of_bp = v1 + 2;\n          return;\n        }\n      } else if (token == 41) {\n        goto LABEL_19;\n      }\n      ++v1;\n      if (v0 != 138) goto LABEL_3;\n    LABEL_15:\n      v2 = 1LL;\n      next();\n      v0 = token;\n    }\n  }\n  index_of_bp = 1LL;\n}", "binary": "c-interp/c-interp.host.O2", "assembly": "<function_parameter>:\nendbr64\nmov    0x6d35(%rip),%rax\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ncmp    $0x29,%rax\nje     37d5 <function_parameter+0x1c5>\nxor    %ebp,%ebp\nlea    0x3d0a(%rip),%r13\nlea    0x3d23(%rip),%r14\nlea    0x39d0(%rip),%r12\ncmp    $0x8a,%rax\nje     3740 <function_parameter+0x130>\nmov    $0x1,%ebx\ncmp    $0x86,%rax\njne    367a <function_parameter+0x6a>\njmp    37c0 <function_parameter+0x1b0>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nadd    $0x2,%rbx\ncall   1580 <next>\nmov    0x6cd6(%rip),%rax\ncmp    $0x9f,%rax\nje     3668 <function_parameter+0x58>\ncmp    $0x85,%rax\nje     36a5 <function_parameter+0x95>\nmov    0x6c3f(%rip),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x6c34(%rip),%rax\ncmpq   $0x84,0x20(%rax)\nje     3770 <function_parameter+0x160>\ncmpq   $0x85,0x6c8b(%rip)\nje     3760 <function_parameter+0x150>\nmov    0x6bfe(%rip),%rsi\nmov    %r12,%rdi\nmov    $0x85,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x6bee(%rip),%rax\nmov    0x20(%rax),%rdx\nmovq   $0x84,0x20(%rax)\nmov    %rdx,0x38(%rax)\nmov    0x18(%rax),%rdx\nmov    %rbx,0x18(%rax)\nlea    0x1(%rbp),%rbx\nmov    %rdx,0x30(%rax)\nmov    0x28(%rax),%rdx\nmov    %rbp,0x28(%rax)\nmov    %rdx,0x40(%rax)\nmov    0x6c2b(%rip),%rax\ncmp    $0x2c,%rax\nje     3790 <function_parameter+0x180>\ncmp    $0x29,%rax\nje     37a4 <function_parameter+0x194>\nmov    %rbx,%rbp\ncmp    $0x8a,%rax\njne    3650 <function_parameter+0x40>\nxor    %eax,%eax\nmov    $0x1,%ebx\ncall   1580 <next>\nmov    0x6bfd(%rip),%rax\njmp    367a <function_parameter+0x6a>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   1580 <next>\njmp    36eb <function_parameter+0xdb>\nnopl   0x0(%rax)\nmov    0x6b59(%rip),%rsi\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\njmp    36ba <function_parameter+0xaa>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x6bb2(%rip),%rax\ncmp    $0x29,%rax\njne    3731 <function_parameter+0x121>\nadd    $0x2,%rbp\npop    %rbx\nmov    %rbp,0x6b00(%rip)\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nxor    %ebx,%ebx\ncall   1580 <next>\nmov    0x6b80(%rip),%rax\njmp    367a <function_parameter+0x6a>\nmov    $0x1,%ebp\npop    %rbx\nmov    %rbp,0x6ace(%rip)\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "global_declaration", "content": "void global_declaration() {\n    // long [*]id [; | (...) {...}]\n\n\n    long type; // tmp, actual type for variable\n\n    basetype = INT;\n\n    // parse enum, this should be treated alone.\n    if (token == Enum) {\n        // enum [id] { a = 10, b = 20, ... }\n        match(Enum);\n        if (token != '{') {\n            match(Id); // skip the [id] part\n        }\n        if (token == '{') {\n            // parse the assign part\n            match('{');\n            enum_declaration();\n            match('}');\n        }\n\n        match(';');\n        return;\n    }\n\n    // parse type information\n    if (token == Int) {\n        match(Int);\n    }\n    else if (token == Char) {\n        match(Char);\n        basetype = CHAR;\n    }\n\n    // parse the comma seperated variable declaration.\n    while (token != ';' && token != '}') {\n        type = basetype;\n        // parse pointer type, note that there may exist `int ****x;`\n        while (token == Mul) {\n            match(Mul);\n            type = type + PTR;\n        }\n\n        if (token != Id) {\n            // invalid declaration\n            libmin_printf(\"%ld: bad global declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        if (current_id[Class]) {\n            // identifier exists\n            libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n            libmin_fail(-1);\n        }\n        match(Id);\n        current_id[Type] = type;\n\n        if (token == '(') {\n            current_id[Class] = Fun;\n            current_id[Value] = (long)(text + 1); // the memory address of function\n            function_declaration();\n        } else {\n            // variable declaration\n            current_id[Class] = Glo; // global variable\n            current_id[Value] = (long)data; // assign memory address\n            data = data + sizeof(long);\n        }\n\n        if (token == ',') {\n            match(',');\n        }\n    }\n    next();\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O2.pseudo", "function_name": "global_declaration", "address": "0x3b50", "label": "global_declaration", "content": "void __cdecl global_declaration()\n{\n  __int64 v0; // rax\n  __int64 v1; // rbx\n  __int64 *v2; // rdx\n  char *v3; // rcx\n  void *v4; // rax\n  __int64 v5; // rax\n\n  v0 = token;\n  basetype = 1LL;\n  if ( token == 136 )\n  {\n    next();\n    if ( token == 123 )\n      goto LABEL_24;\n    if ( token != 133 )\n    {\n      libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n      libmin_fail(-1);\n    }\n    next();\n    v5 = token;\n    if ( token == 123 )\n    {\nLABEL_24:\n      next();\n      enum_declaration();\n      if ( token != 125 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 125LL);\n        libmin_fail(-1);\n      }\n      next();\n      v5 = token;\n    }\n    if ( v5 != 59 )\n    {\n      libmin_printf(\"%ld: expected token: %ld\\n\", line, 59LL);\n      libmin_fail(-1);\n    }\n  }\n  else\n  {\n    if ( token == 138 )\n    {\n      next();\n      v0 = token;\n    }\n    else if ( token == 134 )\n    {\n      next();\n      v0 = token;\n      basetype = 0LL;\n    }\nLABEL_5:\n    if ( v0 != 59 )\n    {\n      while ( v0 != 125 )\n      {\n        v1 = basetype;\n        if ( v0 == 159 )\n        {\n          do\n          {\n            v1 += 2LL;\n            next();\n            v0 = token;\n          }\n          while ( token == 159 );\n        }\n        if ( v0 != 133 )\n        {\n          libmin_printf(\"%ld: bad global declaration\\n\", line);\n          libmin_fail(-1);\n        }\n        if ( current_id[4] )\n        {\n          libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n          libmin_fail(-1);\n        }\n        if ( token != 133 )\n        {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n          libmin_fail(-1);\n        }\n        next();\n        v2 = current_id;\n        v0 = token;\n        current_id[3] = v1;\n        if ( v0 == 40 )\n        {\n          v4 = text;\n          v2[4] = 129LL;\n          v2[5] = (__int64)v4 + 8;\n          function_declaration();\n          v0 = token;\n        }\n        else\n        {\n          v3 = data;\n          v2[4] = 131LL;\n          v2[5] = (__int64)v3;\n          data = v3 + 8;\n        }\n        if ( v0 != 44 )\n          goto LABEL_5;\n        next();\n        v0 = token;\n        if ( token == 59 )\n          break;\n      }\n    }\n  }\n  next();\n}\n"}, "pseudo_normalize": "void global_declaration() {\n  long long v0;\n  long long v1;\n  long long *v2;\n  char *v3;\n  void *v4;\n  long long v5;\n  v0 = token;\n  basetype = 1LL;\n  if (token == 136) {\n    next();\n    if (token == 123) goto LABEL_24;\n    if (token != 133) {\n      libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n      libmin_fail(-1);\n    }\n    next();\n    v5 = token;\n    if (token == 123) {\n    LABEL_24:\n      next();\n      enum_declaration();\n      if (token != 125) {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 125LL);\n        libmin_fail(-1);\n      }\n      next();\n      v5 = token;\n    }\n    if (v5 != 59) {\n      libmin_printf(\"%ld: expected token: %ld\\n\", line, 59LL);\n      libmin_fail(-1);\n    }\n  } else {\n    if (token == 138) {\n      next();\n      v0 = token;\n    } else if (token == 134) {\n      next();\n      v0 = token;\n      basetype = 0LL;\n    }\n  LABEL_5:\n    if (v0 != 59) {\n      while (v0 != 125) {\n        v1 = basetype;\n        if (v0 == 159) {\n          do {\n            v1 += 2LL;\n            next();\n            v0 = token;\n          } while (token == 159);\n        }\n        if (v0 != 133) {\n          libmin_printf(\"%ld: bad global declaration\\n\", line);\n          libmin_fail(-1);\n        }\n        if (current_id[4]) {\n          libmin_printf(\"%ld: duplicate global declaration\\n\", line);\n          libmin_fail(-1);\n        }\n        if (token != 133) {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 133LL);\n          libmin_fail(-1);\n        }\n        next();\n        v2 = current_id;\n        v0 = token;\n        current_id[3] = v1;\n        if (v0 == 40) {\n          v4 = text;\n          v2[4] = 129LL;\n          v2[5] = (long long)v4 + 8;\n          function_declaration();\n          v0 = token;\n        } else {\n          v3 = data;\n          v2[4] = 131LL;\n          v2[5] = (long long)v3;\n          data = v3 + 8;\n        }\n        if (v0 != 44) goto LABEL_5;\n        next();\n        v0 = token;\n        if (token == 59) break;\n      }\n    }\n  }\n  next();\n}", "binary": "c-interp/c-interp.host.O2", "assembly": "<global_declaration>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x67eb(%rip),%rax\nmovq   $0x1,0x6750(%rip)\ncmp    $0x88,%rax\nje     3d5b <global_declaration+0x20b>\ncmp    $0x8a,%rax\nje     3d2a <global_declaration+0x1da>\ncmp    $0x86,%rax\nje     3d3d <global_declaration+0x1ed>\nlea    0x3592(%rip),%r12\nlea    0x380e(%rip),%r13\nlea    0x346b(%rip),%rbp\nnopl   0x0(%rax)\ncmp    $0x3b,%rax\nje     3cb4 <global_declaration+0x164>\ncmp    $0x7d,%rax\nje     3cb4 <global_declaration+0x164>\nmov    0x66f5(%rip),%rbx\ncmp    $0x9f,%rax\njne    3bf2 <global_declaration+0xa2>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nadd    $0x2,%rbx\ncall   1580 <next>\nmov    0x6766(%rip),%rax\ncmp    $0x9f,%rax\nje     3bd8 <global_declaration+0x88>\ncmp    $0x85,%rax\nje     3c15 <global_declaration+0xc5>\nmov    0x66cf(%rip),%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x66c4(%rip),%rax\ncmpq   $0x0,0x20(%rax)\njne    3cd8 <global_declaration+0x188>\ncmpq   $0x85,0x671e(%rip)\nje     3cc8 <global_declaration+0x178>\nmov    0x6691(%rip),%rsi\nmov    %rbp,%rdi\nmov    $0x85,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x6681(%rip),%rdx\nmov    0x66ea(%rip),%rax\nmov    %rbx,0x18(%rdx)\ncmp    $0x28,%rax\nje     3d00 <global_declaration+0x1b0>\nmov    0x66b5(%rip),%rcx\nmovq   $0x83,0x20(%rdx)\nmov    %rcx,0x28(%rdx)\nadd    $0x8,%rcx\nmov    %rcx,0x669e(%rip)\ncmp    $0x2c,%rax\njne    3bb0 <global_declaration+0x60>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x66a6(%rip),%rax\ncmp    $0x3b,%rax\njne    3bba <global_declaration+0x6a>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    1580 <next>\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\njmp    3c58 <global_declaration+0x108>\nnopl   0x0(%rax)\nmov    0x65f1(%rip),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\njmp    3c27 <global_declaration+0xd7>\nnopl   0x0(%rax,%rax,1)\nmov    0x6641(%rip),%rax\nmovq   $0x81,0x20(%rdx)\nadd    $0x8,%rax\nmov    %rax,0x28(%rdx)\nxor    %eax,%eax\ncall   3a10 <function_declaration>\nmov    0x662b(%rip),%rax\njmp    3c92 <global_declaration+0x142>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x6618(%rip),%rax\njmp    3b94 <global_declaration+0x44>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x6605(%rip),%rax\nmovq   $0x0,0x656a(%rip)\njmp    3b94 <global_declaration+0x44>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x65e7(%rip),%rax\ncmp    $0x7b,%rax\njne    3db8 <global_declaration+0x268>\nxor    %eax,%eax\ncall   1580 <next>\nxor    %eax,%eax\ncall   34f0 <enum_declaration>\ncmpq   $0x7d,0x65cb(%rip)\nje     3e36 <global_declaration+0x2e6>\nmov    0x653e(%rip),%rsi\nmov    $0x7d,%edx\nlea    0x3276(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x659a(%rip),%rax\njmp    3df5 <global_declaration+0x2a5>\ncmp    $0x85,%rax\nje     3e2d <global_declaration+0x2dd>\nmov    0x6509(%rip),%rsi\nlea    0x3246(%rip),%rdi\nmov    $0x85,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x6565(%rip),%rax\ncmp    $0x7b,%rax\nje     3d6f <global_declaration+0x21f>\ncmp    $0x3b,%rax\nje     3cb4 <global_declaration+0x164>\nmov    0x64ca(%rip),%rsi\nlea    0x3207(%rip),%rdi\nmov    $0x3b,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nadd    $0x8,%rsp\nmov    $0xffffffff,%edi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    47e0 <libmin_fail>\nxor    %eax,%eax\ncall   1580 <next>\njmp    3de4 <global_declaration+0x294>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x650c(%rip),%rax\njmp    3df5 <global_declaration+0x2a5>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "main", "content": "int main(int _argc, char **_argv)\n{\n\n    long i;\n    long *tmp;\n\n    int argc = 2;\n    char *myargv[2] = { \"c-interp\", \"hello.c\" };\n    char **argv = myargv;\n\n    argc--;\n    argv++;\n\n#if 0\n    // parse arguments\n    if (argc > 0 && **argv == '-' && (*argv)[1] == 's') {\n        assembly = 1;\n        --argc;\n        ++argv;\n    }\n    if (argc > 0 && **argv == '-' && (*argv)[1] == 'd') {\n        debug = 1;\n        --argc;\n        ++argv;\n    }\n    if (argc < 1) {\n        libmin_printf(\"usage: xc [-s] [-d] file ...\\n\");\n        return -1;\n    }\n#endif\n\n    libmin_mopen(mhello, \"r\");\n\n    poolsize = 256 * 1024; // arbitrary size\n    line = 1;\n\n    // allocate memory\n    if (!(text = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n        return -1;\n    }\n    if (!(data = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n        return -1;\n    }\n    if (!(stack = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n    }\n    if (!(symbols = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n        return -1;\n    }\n\n    libmin_memset(text, 0, poolsize);\n    libmin_memset(data, 0, poolsize);\n    libmin_memset(stack, 0, poolsize);\n    libmin_memset(symbols, 0, poolsize);\n\n    old_text = text;\n\n    src = \"char else enum if int return sizeof while \"\n          \"open read close printf malloc memset memcmp exit void main\";\n\n     // add keywords to symbol table\n    i = Char;\n    while (i <= While) {\n        next();\n        current_id[Token] = i++;\n    }\n\n    // add library to symbol table\n    i = OPEN;\n    while (i <= EXIT) {\n        next();\n        current_id[Class] = Sys;\n        current_id[Type] = INT;\n        current_id[Value] = i++;\n    }\n\n    next(); current_id[Token] = Char; // handle void type\n    next(); idmain = current_id; // keep track of main\n\n    if (!(src = old_src = libmin_malloc(poolsize))) {\n        libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n        return -1;\n    }\n    // read the source file\n    if ((i = libmin_mread(src, poolsize-1, mhello)) <= 0) {\n        libmin_printf(\"read() returned %ld\\n\", i);\n        return -1;\n    }\n    src[i] = 0; // add EOF character\n    libmin_mclose(mhello);\n\n    program();\n\n    if (!(pc = (long *)idmain[Value])) {\n        libmin_printf(\"main() not defined\\n\");\n        return -1;\n    }\n\n    // dump_text();\n    if (assembly) {\n        // only for compile\n        return 0;\n    }\n\n    // setup stack\n    sp = (long *)((long)stack + poolsize);\n    *--sp = EXIT; // call exit if main returns\n    *--sp = PUSH; tmp = sp;\n    *--sp = 1;\n    *--sp = (long)argv;\n    *--sp = (long)tmp;\n\n    (void)eval();\n\n    libmin_success();\n    return 9;\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  __int64 v4; // rdx\n  __int64 v5; // rbx\n  __int64 *v6; // rax\n  __int64 v7; // rdx\n  signed __int64 v8; // rax\n  int result; // eax\n  char *v10; // rax\n  char *myargv[2]; // [rsp+0h] [rbp-28h] BYREF\n  unsigned __int64 v12; // [rsp+18h] [rbp-10h]\n\n  v12 = __readfsqword(0x28u);\n  myargv[1] = \"hello.c\";\n  libmin_mopen(mhello, \"r\");\n  poolsize = 0x40000LL;\n  line = 1LL;\n  text = libmin_malloc(0x40000uLL);\n  if ( text )\n  {\n    data = (char *)libmin_malloc(poolsize);\n    if ( data )\n    {\n      stack = libmin_malloc(poolsize);\n      if ( stack )\n      {\n        symbols = libmin_malloc(poolsize);\n        if ( symbols )\n        {\n          v3 = 134LL;\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (__int64 *)text;\n          src = \"char else enum if int return sizeof while open read close printf malloc memset memcmp exit void main\";\n          do\n          {\n            next();\n            v4 = v3++;\n            *current_id = v4;\n          }\n          while ( v3 != 142 );\n          v5 = 30LL;\n          do\n          {\n            next();\n            v6 = current_id;\n            v7 = v5++;\n            current_id[4] = 130LL;\n            v6[3] = 1LL;\n            v6[5] = v7;\n          }\n          while ( v5 != 38 );\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          old_src = (char *)libmin_malloc(poolsize);\n          src = old_src;\n          if ( old_src )\n          {\n            v8 = libmin_mread(old_src, poolsize - 1, mhello);\n            if ( v8 <= 0 )\n            {\n              libmin_printf(\"read() returned %ld\\n\", v8);\n              return -1;\n            }\n            else\n            {\n              src[v8] = 0;\n              libmin_mclose(mhello);\n              program();\n              pc = (__int64 *)idmain[5];\n              if ( pc )\n              {\n                result = 0;\n                if ( !assembly )\n                {\n                  v10 = (char *)stack + poolsize;\n                  *((_QWORD *)v10 - 4) = &myargv[1];\n                  *((_QWORD *)v10 - 1) = 37LL;\n                  *((_QWORD *)v10 - 2) = 13LL;\n                  *((_QWORD *)v10 - 3) = 1LL;\n                  qword_A2F8 = (__int64 *)(v10 - 40);\n                  *((_QWORD *)v10 - 5) = v10 - 16;\n                  eval();\n                  libmin_success();\n                }\n              }\n              else\n              {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            }\n          }\n          else\n          {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        }\n        else\n        {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      }\n      else\n      {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    }\n    else\n    {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  }\n  else\n  {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long *v6;\n  long long v7;\n  signed long long v8;\n  int result;\n  char *v10;\n  char *myargv[2];\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  myargv[1] = \"hello.c\";\n  libmin_mopen(mhello, \"r\");\n  poolsize = 262144LL;\n  line = 1LL;\n  text = libmin_malloc(262144uLL);\n  if (text) {\n    data = (char *)libmin_malloc(poolsize);\n    if (data) {\n      stack = libmin_malloc(poolsize);\n      if (stack) {\n        symbols = libmin_malloc(poolsize);\n        if (symbols) {\n          v3 = 134LL;\n          libmin_memset(text, 0, poolsize);\n          libmin_memset(data, 0, poolsize);\n          libmin_memset(stack, 0, poolsize);\n          libmin_memset(symbols, 0, poolsize);\n          old_text = (long long *)text;\n          src =\n              \"char else enum if int return sizeof while open read close \"\n              \"printf malloc memset memcmp exit void main\";\n          do {\n            next();\n            v4 = v3++;\n            *current_id = v4;\n          } while (v3 != 142);\n          v5 = 30LL;\n          do {\n            next();\n            v6 = current_id;\n            v7 = v5++;\n            current_id[4] = 130LL;\n            v6[3] = 1LL;\n            v6[5] = v7;\n          } while (v5 != 38);\n          next();\n          *current_id = 134LL;\n          next();\n          idmain = current_id;\n          old_src = (char *)libmin_malloc(poolsize);\n          src = old_src;\n          if (old_src) {\n            v8 = libmin_mread(old_src, poolsize - 1, mhello);\n            if (v8 <= 0) {\n              libmin_printf(\"read() returned %ld\\n\", v8);\n              return -1;\n            } else {\n              src[v8] = 0;\n              libmin_mclose(mhello);\n              program();\n              pc = (long long *)idmain[5];\n              if (pc) {\n                result = 0;\n                if (!assembly) {\n                  v10 = (char *)stack + poolsize;\n                  *((uint64_t *)v10 - 4) = &myargv[1];\n                  *((uint64_t *)v10 - 1) = 37LL;\n                  *((uint64_t *)v10 - 2) = 13LL;\n                  *((uint64_t *)v10 - 3) = 1LL;\n                  qword_A2F8 = (long long *)(v10 - 40);\n                  *((uint64_t *)v10 - 5) = v10 - 16;\n                  eval();\n                  libmin_success();\n                }\n              } else {\n                libmin_printf(\"main() not defined\\n\");\n                return -1;\n              }\n            }\n          } else {\n            libmin_printf(\"could not malloc(%ld) for source area\\n\", poolsize);\n            return -1;\n          }\n        } else {\n          libmin_printf(\"could not malloc(%ld) for symbol table\\n\", poolsize);\n          return -1;\n        }\n      } else {\n        libmin_printf(\"could not malloc(%ld) for stack area\\n\", poolsize);\n        return -1;\n      }\n    } else {\n      libmin_printf(\"could not malloc(%ld) for data area\\n\", poolsize);\n      return -1;\n    }\n  } else {\n    libmin_printf(\"could not malloc(%ld) for text area\\n\", poolsize);\n    return -1;\n  }\n  return result;\n}", "binary": "c-interp/c-interp.host.O2", "assembly": "<main>:\nendbr64\npush   %rbx\nlea    0x605c(%rip),%rsi\nsub    $0x20,%rsp\nmov    0x8ee9(%rip),%rdi\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nlea    0x602b(%rip),%rax\nmov    %rax,(%rsp)\nlea    0x6029(%rip),%rax\nmov    %rax,0x8(%rsp)\ncall   4b20 <libmin_mopen>\nmov    $0x40000,%edi\nmovq   $0x40000,0x919f(%rip)\nmovq   $0x1,0x9154(%rip)\ncall   4890 <libmin_malloc>\nmov    %rax,0x91c0(%rip)\ntest   %rax,%rax\nje     145c <main+0x33c>\nmov    0x9178(%rip),%rdi\ncall   4890 <libmin_malloc>\nmov    %rax,0x918c(%rip)\ntest   %rax,%rax\nje     1441 <main+0x321>\nmov    0x915c(%rip),%rdi\ncall   4890 <libmin_malloc>\nmov    %rax,0x9180(%rip)\ntest   %rax,%rax\nje     1429 <main+0x309>\nmov    0x9140(%rip),%rdi\ncall   4890 <libmin_malloc>\nmov    %rax,0x90fc(%rip)\ntest   %rax,%rax\nje     1411 <main+0x2f1>\nmov    0x9124(%rip),%rdx\nmov    0x9155(%rip),%rdi\nxor    %esi,%esi\nmov    $0x86,%ebx\ncall   4ab0 <libmin_memset>\nmov    0x910a(%rip),%rdx\nmov    0x9123(%rip),%rdi\nxor    %esi,%esi\ncall   4ab0 <libmin_memset>\nmov    0x90f5(%rip),%rdx\nmov    0x911e(%rip),%rdi\nxor    %esi,%esi\ncall   4ab0 <libmin_memset>\nmov    0x90e0(%rip),%rdx\nmov    0x90a1(%rip),%rdi\nxor    %esi,%esi\ncall   4ab0 <libmin_memset>\nmov    0x9103(%rip),%rax\nmov    %rax,0x90ec(%rip)\nlea    0x6225(%rip),%rax\nmov    %rax,0x90c6(%rip)\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x9072(%rip),%rax\nmov    %rbx,%rdx\nadd    $0x1,%rbx\nmov    %rdx,(%rax)\ncmp    $0x8e,%rbx\njne    1260 <main+0x140>\nmov    $0x1e,%ebx\ncs nopw 0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x9042(%rip),%rax\nmov    %rbx,%rdx\nadd    $0x1,%rbx\nmovq   $0x82,0x20(%rax)\nmovq   $0x1,0x18(%rax)\nmov    %rdx,0x28(%rax)\ncmp    $0x26,%rbx\njne    1290 <main+0x170>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x9013(%rip),%rax\nmovq   $0x86,(%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x8ffe(%rip),%rax\nmov    0x9027(%rip),%rdi\nmov    %rax,0x9038(%rip)\ncall   4890 <libmin_malloc>\nmov    %rax,0x901c(%rip)\nmov    %rax,%rdi\nmov    %rax,0x901a(%rip)\ntest   %rax,%rax\nje     13f7 <main+0x2d7>\nmov    0x8ffa(%rip),%rax\nmov    0x8d03(%rip),%rdx\nlea    -0x1(%rax),%rsi\ncall   4b70 <libmin_mread>\ntest   %rax,%rax\njle    13e1 <main+0x2c1>\nmov    0x8fea(%rip),%rdx\nmovb   $0x0,(%rdx,%rax,1)\nmov    0x8cdf(%rip),%rdi\ncall   4a30 <libmin_mclose>\nxor    %eax,%eax\ncall   3e50 <program>\nmov    0x8fd4(%rip),%rax\nmov    0x28(%rax),%rax\nmov    %rax,0x8fa9(%rip)\ntest   %rax,%rax\nje     1477 <main+0x357>\nxor    %eax,%eax\ncmpq   $0x0,0x8fe6(%rip)\njne    13c7 <main+0x2a7>\nmov    0x8f95(%rip),%rax\nlea    0x8(%rsp),%rdx\nadd    0x8fb9(%rip),%rax\nmov    %rdx,-0x20(%rax)\nlea    -0x28(%rax),%rdx\nmovq   $0x25,-0x8(%rax)\nmovq   $0xd,-0x10(%rax)\nmovq   $0x1,-0x18(%rax)\nmov    %rdx,0x8f4a(%rip)\nlea    -0x10(%rax),%rdx\nmov    %rdx,-0x28(%rax)\nxor    %eax,%eax\ncall   3e90 <eval>\ncall   6200 <libmin_success>\nmov    $0x9,%eax\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    148b <main+0x36b>\nadd    $0x20,%rsp\npop    %rbx\nret\nmov    %rax,%rsi\nlea    0x5d9f(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13c7 <main+0x2a7>\nmov    0x8f12(%rip),%rsi\nlea    0x60db(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13c7 <main+0x2a7>\nmov    0x8ef8(%rip),%rsi\nlea    0x6031(%rip),%rdi\ncall   5f60 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13c7 <main+0x2a7>\nmov    0x8ee0(%rip),%rsi\nlea    0x5ff1(%rip),%rdi\ncall   5f60 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13c7 <main+0x2a7>\nmov    0x8ec8(%rip),%rsi\nlea    0x5fb1(%rip),%rdi\ncall   5f60 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13c7 <main+0x2a7>\nmov    0x8ead(%rip),%rsi\nlea    0x5f6e(%rip),%rdi\ncall   5f60 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13c7 <main+0x2a7>\nlea    0x5d21(%rip),%rdi\ncall   5f60 <libmin_printf>\nor     $0xffffffff,%eax\njmp    13c7 <main+0x2a7>\ncall   10c0 <__stack_chk_fail@plt>\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "match", "content": "void match(long tk) {\n    if (token == tk) {\n        next();\n    } else {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n        libmin_fail(-1);\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O2.pseudo", "function_name": "match", "address": "0x1cd0", "label": "match", "content": "void __fastcall match(__int64 tk)\n{\n  if ( token != tk )\n  {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}\n"}, "pseudo_normalize": "void match(long long tk) {\n  if (token != tk) {\n    libmin_printf(\"%ld: expected token: %ld\\n\", line, tk);\n    libmin_fail(-1);\n  }\n  next();\n}", "binary": "c-interp/c-interp.host.O2", "assembly": "<match>:\nendbr64\ncmp    %rdi,0x8675(%rip)\nje     1d10 <match+0x40>\nsub    $0x8,%rsp\nmov    0x85e8(%rip),%rsi\nmov    %rdi,%rdx\nxor    %eax,%eax\nlea    0x5320(%rip),%rdi\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\nadd    $0x8,%rsp\njmp    47e0 <libmin_fail>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\njmp    1580 <next>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "next", "content": " // index of bp pointer on stack\n\nvoid next() {\n    char *last_pos;\n    long hash;\n\n    while ((token = *src) != 0) {\n        ++src;\n\n        if (token == '\\n') {\n            if (assembly) {\n                // print compile info\n                libmin_printf(\"%ld: %.*s\", line, (int)(src-old_src), old_src);\n                old_src = src;\n\n                while (old_text < text) {\n                    libmin_printf(\"%8.4s\", & \"LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,\"\n                                      \"OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,\"\n                                      \"OPEN,READ,CLOS,PRTF,MALC,MSET,MCMP,EXIT\"[*++old_text * 5]);\n\n                    if (*old_text <= ADJ)\n                        libmin_printf(\" %ld\\n\", *++old_text);\n                    else\n                        libmin_printf(\"\\n\");\n                }\n            }\n            ++line;\n        }\n        else if (token == '#') {\n            // skip macro, because we will not support it\n            while (*src != 0 && *src != '\\n') {\n                src++;\n            }\n        }\n        else if ((token >= 'a' && token <= 'z') || (token >= 'A' && token <= 'Z') || (token == '_')) {\n\n            // parse identifier\n            last_pos = src - 1;\n            hash = token;\n\n            while ((*src >= 'a' && *src <= 'z') || (*src >= 'A' && *src <= 'Z') || (*src >= '0' && *src <= '9') || (*src == '_')) {\n                hash = hash * 147 + *src;\n                src++;\n            }\n\n            // look for existing identifier, linear search\n            current_id = symbols;\n            while (current_id[Token]) {\n                if (current_id[Hash] == hash && !libmin_memcmp((char *)current_id[Name], last_pos, src - last_pos)) {\n                    //found one, return\n                    token = current_id[Token];\n                    return;\n                }\n                current_id = current_id + IdSize;\n            }\n\n\n            // store new ID\n            current_id[Name] = (long)last_pos;\n            current_id[Hash] = hash;\n            token = current_id[Token] = Id;\n            return;\n        }\n        else if (token >= '0' && token <= '9') {\n            // parse number, three kinds: dec(123) hex(0x123) oct(017)\n            token_val = token - '0';\n            if (token_val > 0) {\n                // dec, starts with [1-9]\n                while (*src >= '0' && *src <= '9') {\n                    token_val = token_val*10 + *src++ - '0';\n                }\n            } else {\n                // starts with number 0\n                if (*src == 'x' || *src == 'X') {\n                    //hex\n                    token = *++src;\n                    while ((token >= '0' && token <= '9') || (token >= 'a' && token <= 'f') || (token >= 'A' && token <= 'F')) {\n                        token_val = token_val * 16 + (token & 15) + (token >= 'A' ? 9 : 0);\n                        token = *++src;\n                    }\n                } else {\n                    // oct\n                    while (*src >= '0' && *src <= '7') {\n                        token_val = token_val*8 + *src++ - '0';\n                    }\n                }\n            }\n\n            token = Num;\n            return;\n        }\n        else if (token == '/') {\n            if (*src == '/') {\n                // skip comments\n                while (*src != 0 && *src != '\\n') {\n                    ++src;\n                }\n            } else {\n                // divide operator\n                token = Div;\n                return;\n            }\n        }\n        else if (token == '\"' || token == '\\'') {\n            // parse string literal, currently, the only supported escape\n            // character is '\\n', store the string literal into data.\n            last_pos = data;\n            while (*src != 0 && *src != token) {\n                token_val = *src++;\n                if (token_val == '\\\\') {\n                    // escape character\n                    token_val = *src++;\n                    if (token_val == 'n') {\n                        token_val = '\\n';\n                    }\n                }\n\n                if (token == '\"') {\n                    *data++ = token_val;\n                }\n            }\n\n            src++;\n            // if it is a single character, return Num token\n            if (token == '\"') {\n                token_val = (long)last_pos;\n            } else {\n                token = Num;\n            }\n\n            return;\n        }\n        else if (token == '=') {\n            // parse '==' and '='\n            if (*src == '=') {\n                src ++;\n                token = Eq;\n            } else {\n                token = Assign;\n            }\n            return;\n        }\n        else if (token == '+') {\n            // parse '+' and '++'\n            if (*src == '+') {\n                src ++;\n                token = Inc;\n            } else {\n                token = Add;\n            }\n            return;\n        }\n        else if (token == '-') {\n            // parse '-' and '--'\n            if (*src == '-') {\n                src ++;\n                token = Dec;\n            } else {\n                token = Sub;\n            }\n            return;\n        }\n        else if (token == '!') {\n            // parse '!='\n            if (*src == '=') {\n                src++;\n                token = Ne;\n            }\n            return;\n        }\n        else if (token == '<') {\n            // parse '<=', '<<' or '<'\n            if (*src == '=') {\n                src ++;\n                token = Le;\n            } else if (*src == '<') {\n                src ++;\n                token = Shl;\n            } else {\n                token = Lt;\n            }\n            return;\n        }\n        else if (token == '>') {\n            // parse '>=', '>>' or '>'\n            if (*src == '=') {\n                src ++;\n                token = Ge;\n            } else if (*src == '>') {\n                src ++;\n                token = Shr;\n            } else {\n                token = Gt;\n            }\n            return;\n        }\n        else if (token == '|') {\n            // parse '|' or '||'\n            if (*src == '|') {\n                src ++;\n                token = Lor;\n            } else {\n                token = Or;\n            }\n            return;\n        }\n        else if (token == '&') {\n            // parse '&' and '&&'\n            if (*src == '&') {\n                src ++;\n                token = Lan;\n            } else {\n                token = And;\n            }\n            return;\n        }\n        else if (token == '^') {\n            token = Xor;\n            return;\n        }\n        else if (token == '%') {\n            token = Mod;\n            return;\n        }\n        else if (token == '*') {\n            token = Mul;\n            return;\n        }\n        else if (token == '[') {\n            token = Brak;\n            return;\n        }\n        else if (token == '?') {\n            token = Cond;\n            return;\n        }\n        else if (token == '~' || token == ';' || token == '{' || token == '}' || token == '(' || token == ')' || token == ']' || token == ',' || token == ':') {\n            // directly return the character as token;\n            return;\n        }\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O2.pseudo", "function_name": "next", "address": "0x1580", "label": "next", "content": "void __cdecl next()\n{\n  char *v0; // r14\n  __int64 v1; // rbx\n  char v2; // dl\n  char *v3; // rax\n  __int64 v4; // rdx\n  __int64 *v5; // rax\n  bool v6; // zf\n  char *v7; // rax\n  __int64 v8; // rbx\n  char v9; // al\n  char *v10; // r14\n  __int64 v11; // rdx\n  char *v12; // rax\n  char *v13; // r8\n  __int64 v14; // rax\n  __int64 v15; // rdx\n  char v16; // al\n  char v17; // al\n  char *v18; // rax\n  __int64 *v19; // rdx\n  __int64 v20; // rsi\n  char *v21; // r14\n  __int64 v22; // rdx\n  char *v23; // rax\n  char *v24; // rax\n  __int64 i; // rdx\n  __int64 v26; // rax\n\n  v0 = src;\n  v1 = *src;\n  token = v1;\n  if ( !v1 )\n    return;\n  v2 = v1;\n  while ( 1 )\n  {\n    v3 = v0 + 1;\n    src = v0 + 1;\n    if ( v1 == 10 )\n    {\n      if ( assembly )\n      {\n        libmin_printf(\"%ld: %.*s\", line, (_DWORD)v3 - (_DWORD)old_src, old_src);\n        v3 = src;\n        v19 = old_text;\n        old_src = src;\n        if ( text > old_text )\n        {\n          do\n          {\n            old_text = v19 + 1;\n            libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * v19[1]]);\n            if ( *old_text <= 7 )\n            {\n              v20 = old_text[1];\n              ++old_text;\n              libmin_printf((char *)\" %ld\\n\", v20);\n            }\n            else\n            {\n              libmin_printf((char *)\"\\n\");\n            }\n            v19 = old_text;\n          }\n          while ( old_text < text );\n          v3 = src;\n        }\n      }\n      ++line;\n      v2 = *v3;\n      v0 = v3;\n      goto LABEL_20;\n    }\n    if ( v1 == 35 )\n    {\n      v2 = v0[1];\n      if ( v2 == 10 || !v2 )\n      {\n        ++v0;\n      }\n      else\n      {\n        v7 = v0 + 2;\n        do\n        {\n          src = v7;\n          v2 = *v7;\n          v0 = v7++;\n        }\n        while ( v2 && v2 != 10 );\n      }\n      goto LABEL_20;\n    }\n    if ( (unsigned __int8)((v2 & 0xDF) - 65) <= 0x19u )\n      break;\n    switch ( v2 )\n    {\n      case '!':\n        if ( v0[1] == 61 )\n        {\n          token = 150LL;\n          src = v0 + 2;\n        }\n        return;\n      case '\"':\n      case '\\'':\n        v13 = data;\n        while ( 1 )\n        {\n          v15 = *v3;\n          src = v3 + 1;\n          if ( !(_BYTE)v15 || v15 == token )\n            break;\n          token_val = *v3;\n          if ( token_val == 92 )\n          {\n            src = v3 + 2;\n            v14 = v3[1];\n            if ( v14 == 110 )\n              v14 = 10LL;\n            token_val = v14;\n          }\n          if ( token == 34 )\n          {\n            v24 = data++;\n            *v24 = token_val;\n          }\n          v3 = src;\n        }\n        if ( token != 34 )\n          goto LABEL_33;\n        token_val = (__int64)v13;\n        return;\n      case '%':\n        token = 161LL;\n        return;\n      case '&':\n        if ( v0[1] == 38 )\n        {\n          token = 145LL;\n          src = v0 + 2;\n        }\n        else\n        {\n          token = 148LL;\n        }\n        return;\n      case '(':\n      case ')':\n      case ',':\n      case ':':\n      case ';':\n      case ']':\n      case '{':\n      case '}':\n      case '~':\n        return;\n      case '*':\n        token = 159LL;\n        return;\n      case '+':\n        if ( v0[1] == 43 )\n        {\n          token = 162LL;\n          src = v0 + 2;\n        }\n        else\n        {\n          token = 157LL;\n        }\n        return;\n      case '-':\n        if ( v0[1] == 45 )\n        {\n          token = 163LL;\n          src = v0 + 2;\n        }\n        else\n        {\n          token = 158LL;\n        }\n        return;\n      case '/':\n        if ( v0[1] != 47 )\n        {\n          token = 160LL;\n          return;\n        }\n        v18 = v0 + 2;\n        do\n        {\n          src = v18;\n          v2 = *v18;\n          v0 = v18++;\n        }\n        while ( v2 && v2 != 10 );\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        v8 = v1 - 48;\n        token_val = v8;\n        v9 = v0[1];\n        if ( v8 )\n        {\n          v21 = v0 + 2;\n          if ( (unsigned __int8)(v9 - 48) <= 9u )\n          {\n            do\n            {\n              src = v21;\n              v22 = *(v21 - 1);\n              v23 = v21++;\n              v8 = v22 + 10 * v8 - 48;\n              token_val = v8;\n            }\n            while ( (unsigned __int8)(*v23 - 48) <= 9u );\n          }\n        }\n        else\n        {\n          if ( (v9 & 0xDF) == 0x58 )\n          {\n            src = v0 + 2;\n            for ( i = v0[2]; ; i = *src )\n            {\n              token = i;\n              if ( (unsigned __int64)(i - 48) > 9 )\n              {\n                if ( (i & 0xFFFFFFFFFFFFFFDFLL) - 65 > 5 )\n                  goto LABEL_33;\n                v26 = (i & 0xF) + 16 * token_val;\n                if ( i > 64 )\n                  v26 += 9LL;\n              }\n              else\n              {\n                v26 = (i & 0xF) + 16 * token_val;\n              }\n              token_val = v26;\n              ++src;\n            }\n          }\n          v10 = v0 + 2;\n          if ( (unsigned __int8)(v9 - 48) <= 7u )\n          {\n            do\n            {\n              src = v10;\n              v11 = *(v10 - 1);\n              v12 = v10++;\n              v8 = v11 + 8 * v8 - 48;\n              token_val = v8;\n            }\n            while ( (unsigned __int8)(*v12 - 48) <= 7u );\n          }\n        }\nLABEL_33:\n        token = 128LL;\n        return;\n      case '<':\n        v17 = v0[1];\n        if ( v17 == 61 )\n        {\n          token = 153LL;\n          src = v0 + 2;\n        }\n        else if ( v17 == 60 )\n        {\n          token = 155LL;\n          src = v0 + 2;\n        }\n        else\n        {\n          token = 151LL;\n        }\n        return;\n      case '=':\n        if ( v0[1] == 61 )\n        {\n          token = 149LL;\n          src = v0 + 2;\n        }\n        else\n        {\n          token = 142LL;\n        }\n        return;\n      case '>':\n        v16 = v0[1];\n        if ( v16 == 61 )\n        {\n          token = 154LL;\n          src = v0 + 2;\n        }\n        else if ( v16 == 62 )\n        {\n          token = 156LL;\n          src = v0 + 2;\n        }\n        else\n        {\n          token = 152LL;\n        }\n        return;\n      case '?':\n        token = 143LL;\n        return;\n      case '[':\n        token = 164LL;\n        return;\n      case '^':\n        token = 147LL;\n        return;\n      case '_':\n        v1 = 95LL;\n        goto LABEL_8;\n      case '|':\n        if ( v0[1] == 124 )\n        {\n          token = 144LL;\n          src = v0 + 2;\n        }\n        else\n        {\n          token = 146LL;\n        }\n        return;\n      default:\n        v2 = *++v0;\n        break;\n    }\nLABEL_20:\n    v1 = v2;\n    token = v2;\n    if ( !v2 )\n      return;\n  }\nLABEL_8:\n  while ( 1 )\n  {\n    v4 = *v3;\n    if ( (unsigned __int8)((*v3 & 0xDF) - 65) > 0x19u && (unsigned __int8)(v4 - 48) > 9u && (_BYTE)v4 != 95 )\n      break;\n    src = ++v3;\n    v1 = v4 + 147 * v1;\n  }\n  v5 = (__int64 *)symbols;\n  v6 = *(_QWORD *)symbols == 0LL;\n  current_id = (__int64 *)symbols;\n  if ( v6 )\n  {\nLABEL_81:\n    *v5 = 133LL;\n    v5[2] = (__int64)v0;\n    v5[1] = v1;\n    token = 133LL;\n  }\n  else\n  {\n    while ( v5[1] != v1 || libmin_memcmp((const void *)v5[2], v0, src - v0) )\n    {\n      v5 = current_id + 9;\n      v6 = current_id[9] == 0;\n      current_id += 9;\n      if ( v6 )\n        goto LABEL_81;\n    }\n    token = *current_id;\n  }\n}\n"}, "pseudo_normalize": "void next() {\n  char *v0;\n  long long v1;\n  char v2;\n  char *v3;\n  long long v4;\n  long long *v5;\n  bool v6;\n  char *v7;\n  long long v8;\n  char v9;\n  char *v10;\n  long long v11;\n  char *v12;\n  char *v13;\n  long long v14;\n  long long v15;\n  char v16;\n  char v17;\n  char *v18;\n  long long *v19;\n  long long v20;\n  char *v21;\n  long long v22;\n  char *v23;\n  char *v24;\n  long long i;\n  long long v26;\n  v0 = src;\n  v1 = *src;\n  token = v1;\n  if (!v1) return;\n  v2 = v1;\n  while (1) {\n    v3 = v0 + 1;\n    src = v0 + 1;\n    if (v1 == 10) {\n      if (assembly) {\n        libmin_printf(\"%ld: %.*s\", line, (uint32_t)v3 - (uint32_t)old_src,\n                      old_src);\n        v3 = src;\n        v19 = old_text;\n        old_src = src;\n        if (text > old_text) {\n          do {\n            old_text = v19 + 1;\n            libmin_printf(\"%8.4s\", &aLeaImmJmpCallJ[5 * v19[1]]);\n            if (*old_text <= 7) {\n              v20 = old_text[1];\n              ++old_text;\n              libmin_printf((char *)\" %ld\\n\", v20);\n            } else {\n              libmin_printf((char *)\"\\n\");\n            }\n            v19 = old_text;\n          } while (old_text < text);\n          v3 = src;\n        }\n      }\n      ++line;\n      v2 = *v3;\n      v0 = v3;\n      goto LABEL_20;\n    }\n    if (v1 == 35) {\n      v2 = v0[1];\n      if (v2 == 10 || !v2) {\n        ++v0;\n      } else {\n        v7 = v0 + 2;\n        do {\n          src = v7;\n          v2 = *v7;\n          v0 = v7++;\n        } while (v2 && v2 != 10);\n      }\n      goto LABEL_20;\n    }\n    if ((unsigned char)((v2 & 223) - 65) <= 25u) break;\n    switch (v2) {\n      case '!':\n        if (v0[1] == 61) {\n          token = 150LL;\n          src = v0 + 2;\n        }\n        return;\n      case '\"':\n      case '\\'':\n        v13 = data;\n        while (1) {\n          v15 = *v3;\n          src = v3 + 1;\n          if (!(uint8_t)v15 || v15 == token) break;\n          token_val = *v3;\n          if (token_val == 92) {\n            src = v3 + 2;\n            v14 = v3[1];\n            if (v14 == 110) v14 = 10LL;\n            token_val = v14;\n          }\n          if (token == 34) {\n            v24 = data++;\n            *v24 = token_val;\n          }\n          v3 = src;\n        }\n        if (token != 34) goto LABEL_33;\n        token_val = (long long)v13;\n        return;\n      case '%':\n        token = 161LL;\n        return;\n      case '&':\n        if (v0[1] == 38) {\n          token = 145LL;\n          src = v0 + 2;\n        } else {\n          token = 148LL;\n        }\n        return;\n      case '(':\n      case ')':\n      case ',':\n      case ':':\n      case ';':\n      case ']':\n      case '{':\n      case '}':\n      case '~':\n        return;\n      case '*':\n        token = 159LL;\n        return;\n      case '+':\n        if (v0[1] == 43) {\n          token = 162LL;\n          src = v0 + 2;\n        } else {\n          token = 157LL;\n        }\n        return;\n      case '-':\n        if (v0[1] == 45) {\n          token = 163LL;\n          src = v0 + 2;\n        } else {\n          token = 158LL;\n        }\n        return;\n      case '/':\n        if (v0[1] != 47) {\n          token = 160LL;\n          return;\n        }\n        v18 = v0 + 2;\n        do {\n          src = v18;\n          v2 = *v18;\n          v0 = v18++;\n        } while (v2 && v2 != 10);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n        v8 = v1 - 48;\n        token_val = v8;\n        v9 = v0[1];\n        if (v8) {\n          v21 = v0 + 2;\n          if ((unsigned char)(v9 - 48) <= 9u) {\n            do {\n              src = v21;\n              v22 = *(v21 - 1);\n              v23 = v21++;\n              v8 = v22 + 10 * v8 - 48;\n              token_val = v8;\n            } while ((unsigned char)(*v23 - 48) <= 9u);\n          }\n        } else {\n          if ((v9 & 223) == 88) {\n            src = v0 + 2;\n            for (i = v0[2];; i = *src) {\n              token = i;\n              if ((unsigned long long)(i - 48) > 9) {\n                if ((i & 18446744073709551583LL) - 65 > 5) goto LABEL_33;\n                v26 = (i & 15) + 16 * token_val;\n                if (i > 64) v26 += 9LL;\n              } else {\n                v26 = (i & 15) + 16 * token_val;\n              }\n              token_val = v26;\n              ++src;\n            }\n          }\n          v10 = v0 + 2;\n          if ((unsigned char)(v9 - 48) <= 7u) {\n            do {\n              src = v10;\n              v11 = *(v10 - 1);\n              v12 = v10++;\n              v8 = v11 + 8 * v8 - 48;\n              token_val = v8;\n            } while ((unsigned char)(*v12 - 48) <= 7u);\n          }\n        }\n      LABEL_33:\n        token = 128LL;\n        return;\n      case '<':\n        v17 = v0[1];\n        if (v17 == 61) {\n          token = 153LL;\n          src = v0 + 2;\n        } else if (v17 == 60) {\n          token = 155LL;\n          src = v0 + 2;\n        } else {\n          token = 151LL;\n        }\n        return;\n      case '=':\n        if (v0[1] == 61) {\n          token = 149LL;\n          src = v0 + 2;\n        } else {\n          token = 142LL;\n        }\n        return;\n      case '>':\n        v16 = v0[1];\n        if (v16 == 61) {\n          token = 154LL;\n          src = v0 + 2;\n        } else if (v16 == 62) {\n          token = 156LL;\n          src = v0 + 2;\n        } else {\n          token = 152LL;\n        }\n        return;\n      case '?':\n        token = 143LL;\n        return;\n      case '[':\n        token = 164LL;\n        return;\n      case '^':\n        token = 147LL;\n        return;\n      case '_':\n        v1 = 95LL;\n        goto LABEL_8;\n      case '|':\n        if (v0[1] == 124) {\n          token = 144LL;\n          src = v0 + 2;\n        } else {\n          token = 146LL;\n        }\n        return;\n      default:\n        v2 = *++v0;\n        break;\n    }\n  LABEL_20:\n    v1 = v2;\n    token = v2;\n    if (!v2) return;\n  }\nLABEL_8:\n  while (1) {\n    v4 = *v3;\n    if ((unsigned char)((*v3 & 223) - 65) > 25u &&\n        (unsigned char)(v4 - 48) > 9u && (uint8_t)v4 != 95)\n      break;\n    src = ++v3;\n    v1 = v4 + 147 * v1;\n  }\n  v5 = (long long *)symbols;\n  v6 = *(uint64_t *)symbols == 0LL;\n  current_id = (long long *)symbols;\n  if (v6) {\n  LABEL_81:\n    *v5 = 133LL;\n    v5[2] = (long long)v0;\n    v5[1] = v1;\n    token = 133LL;\n  } else {\n    while (v5[1] != v1 || libmin_memcmp((const void *)v5[2], v0, src - v0)) {\n      v5 = current_id + 9;\n      v6 = current_id[9] == 0;\n      current_id += 9;\n      if (v6) goto LABEL_81;\n    }\n    token = *current_id;\n  }\n}", "binary": "c-interp/c-interp.host.O2", "assembly": "<next>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x8d87(%rip),%r14\nmovsbq (%r14),%rbx\nmov    %rbx,0x8dac(%rip)\ntest   %rbx,%rbx\nje     16b6 <next+0x136>\nmov    %rbx,%rdx\nlea    0x5f69(%rip),%rbp\nlea    0x5a46(%rip),%r13\nlea    0x5bec(%rip),%r12\nlea    0x1(%r14),%rax\nmov    %rax,0x8d50(%rip)\ncmp    $0xa,%rbx\nje     16c8 <next+0x148>\ncmp    $0x23,%rbx\nje     1700 <next+0x180>\nmov    %edx,%ecx\nand    $0xffffffdf,%ecx\nsub    $0x41,%ecx\ncmp    $0x19,%cl\njbe    162a <next+0xaa>\nsub    $0x21,%edx\ncmp    $0x5d,%dl\nja     1740 <next+0x1c0>\nmovzbl %dl,%edx\nmovslq 0x0(%rbp,%rdx,4),%rdx\nadd    %rbp,%rdx\nnotrack jmp *%rdx\nnopl   0x0(%rax,%rax,1)\nlea    (%rbx,%rbx,8),%rcx\nadd    $0x1,%rax\nlea    (%rbx,%rcx,8),%rcx\nmov    %rax,0x8cfd(%rip)\nlea    (%rbx,%rcx,2),%rbx\nadd    %rdx,%rbx\nmovsbq (%rax),%rdx\nmov    %edx,%ecx\nand    $0xffffffdf,%ecx\nsub    $0x41,%ecx\ncmp    $0x19,%cl\njbe    1610 <next+0x90>\nlea    -0x30(%rdx),%ecx\ncmp    $0x9,%cl\njbe    1610 <next+0x90>\ncmp    $0x5f,%dl\nje     1610 <next+0x90>\nmov    0x8c89(%rip),%rax\ncmpq   $0x0,(%rax)\nmov    %rax,0x8c86(%rip)\njne    1685 <next+0x105>\njmp    1aa0 <next+0x520>\nnopl   0x0(%rax)\nmov    0x8c71(%rip),%rdx\nlea    0x48(%rdx),%rax\ncmpq   $0x0,0x48(%rdx)\nmov    %rax,0x8c61(%rip)\nje     1aa0 <next+0x520>\ncmp    %rbx,0x8(%rax)\njne    1668 <next+0xe8>\nmov    0x8c8e(%rip),%rdx\nmov    0x10(%rax),%rdi\nmov    %r14,%rsi\nsub    %r14,%rdx\ncall   4a40 <libmin_memcmp>\ntest   %eax,%eax\njne    1668 <next+0xe8>\nmov    0x8c34(%rip),%rax\nmov    (%rax),%rax\nmov    %rax,0x8c9a(%rip)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\ncmpq   $0x0,0x8c88(%rip)\njne    19c8 <next+0x448>\naddq   $0x1,0x8bf2(%rip)\nmovzbl (%rax),%edx\nmov    %rax,%r14\nmovsbq %dl,%rbx\nmov    %rbx,0x8c61(%rip)\ntest   %rbx,%rbx\njne    15c5 <next+0x45>\njmp    16b6 <next+0x136>\nnopw   0x0(%rax,%rax,1)\nmovzbl 0x1(%r14),%edx\ncmp    $0xa,%dl\nje     1bbf <next+0x63f>\ntest   %dl,%dl\nje     1bbf <next+0x63f>\nlea    0x2(%r14),%rax\nnopw   0x0(%rax,%rax,1)\nmov    %rax,0x8bf9(%rip)\nmovzbl (%rax),%edx\nmov    %rax,%r14\nadd    $0x1,%rax\ntest   %dl,%dl\nje     16e4 <next+0x164>\ncmp    $0xa,%dl\njne    1720 <next+0x1a0>\njmp    16e4 <next+0x164>\nnopl   0x0(%rax)\nmovzbl 0x1(%r14),%edx\nmov    %rax,%r14\njmp    16e4 <next+0x164>\nnopw   0x0(%rax,%rax,1)\nsub    $0x30,%rbx\nmov    %rbx,0x8b6d(%rip)\nmovzbl 0x1(%r14),%eax\njne    1abf <next+0x53f>\nmov    %eax,%edx\nand    $0xffffffdf,%edx\ncmp    $0x58,%dl\nje     1bf8 <next+0x678>\nsub    $0x30,%eax\nadd    $0x2,%r14\ncmp    $0x7,%al\nja     17b0 <next+0x230>\nnop\nmov    %r14,0x8b99(%rip)\nmovsbq -0x1(%r14),%rdx\nmov    %r14,%rax\nadd    $0x1,%r14\nlea    -0x30(%rdx,%rbx,8),%rbx\nmov    %rbx,0x8b29(%rip)\nmovzbl (%rax),%eax\nsub    $0x30,%eax\ncmp    $0x7,%al\njbe    1780 <next+0x200>\nnopl   0x0(%rax)\nmovq   $0x80,0x8b95(%rip)\njmp    16b6 <next+0x136>\nmov    0x8b69(%rip),%r8\nmov    $0xa,%edi\nmov    0x8b7d(%rip),%rcx\njmp    181e <next+0x29e>\nnopl   (%rax)\ncmp    %rcx,%rdx\nje     1831 <next+0x2b1>\nmovsbq (%rax),%rdx\nmov    %rdx,0x8ae0(%rip)\ncmp    $0x5c,%rdx\njne    180d <next+0x28d>\nlea    0x2(%rax),%rdx\nmov    %rdx,0x8b27(%rip)\nmovsbq 0x1(%rax),%rax\ncmp    $0x6e,%rax\ncmove  %rdi,%rax\nmov    %rax,0x8abb(%rip)\ncmp    $0x22,%rcx\nje     1bd1 <next+0x651>\nmov    0x8b02(%rip),%rax\nmovsbq (%rax),%rdx\nlea    0x1(%rax),%rsi\nmov    %rsi,0x8af3(%rip)\ntest   %dl,%dl\njne    17d8 <next+0x258>\ncmp    $0x22,%rcx\njne    17b0 <next+0x230>\nmov    %r8,0x8a86(%rip)\njmp    16b6 <next+0x136>\ncmpb   $0x3d,0x1(%r14)\njne    16b6 <next+0x136>\nmovq   $0x96,0x8af3(%rip)\nadd    $0x2,%r14\nmov    %r14,0x8ab8(%rip)\njmp    16b6 <next+0x136>\nmovq   $0x8f,0x8ad8(%rip)\njmp    16b6 <next+0x136>\nmovq   $0xa1,0x8ac8(%rip)\njmp    16b6 <next+0x136>\ncmpb   $0x26,0x1(%r14)\nje     1b38 <next+0x5b8>\nmovq   $0x94,0x8aad(%rip)\njmp    16b6 <next+0x136>\ncmpb   $0x3d,0x1(%r14)\nje     1b1d <next+0x59d>\nmovq   $0x8e,0x8a92(%rip)\njmp    16b6 <next+0x136>\nmovzbl 0x1(%r14),%eax\ncmp    $0x3d,%al\nje     1ba4 <next+0x624>\ncmp    $0x3e,%al\nje     1c85 <next+0x705>\nmovq   $0x98,0x8a6d(%rip)\njmp    16b6 <next+0x136>\nmovq   $0xa4,0x8a5d(%rip)\njmp    16b6 <next+0x136>\nmovq   $0x93,0x8a4d(%rip)\njmp    16b6 <next+0x136>\ncmpb   $0x7c,0x1(%r14)\nje     1b02 <next+0x582>\nmovq   $0x92,0x8a32(%rip)\njmp    16b6 <next+0x136>\nmovzbl 0x1(%r14),%eax\ncmp    $0x3d,%al\nje     1b89 <next+0x609>\ncmp    $0x3c,%al\nje     1ca0 <next+0x720>\nmovq   $0x97,0x8a0d(%rip)\njmp    16b6 <next+0x136>\nmovq   $0x9f,0x89fd(%rip)\njmp    16b6 <next+0x136>\ncmpb   $0x2b,0x1(%r14)\nje     1b6e <next+0x5ee>\nmovq   $0x9d,0x89e2(%rip)\njmp    16b6 <next+0x136>\ncmpb   $0x2d,0x1(%r14)\nje     1b53 <next+0x5d3>\nmovq   $0x9e,0x89c7(%rip)\njmp    16b6 <next+0x136>\ncmpb   $0x2f,0x1(%r14)\njne    1cbb <next+0x73b>\nlea    0x2(%r14),%rax\njmp    19a9 <next+0x429>\nnop\ncmp    $0xa,%dl\nje     16e4 <next+0x164>\nmov    %rax,0x8970(%rip)\nmovzbl (%rax),%edx\nmov    %rax,%r14\nadd    $0x1,%rax\ntest   %dl,%dl\njne    19a0 <next+0x420>\njmp    16e4 <next+0x164>\nnopl   0x0(%rax,%rax,1)\nmov    0x8949(%rip),%rcx\nmov    0x88fa(%rip),%rsi\nmov    %eax,%edx\nmov    %r13,%rdi\nsub    0x8937(%rip),%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    0x8931(%rip),%rax\nmov    0x8942(%rip),%rdx\ncmp    %rdx,0x894b(%rip)\nmov    %rax,0x8914(%rip)\njbe    16d6 <next+0x156>\nlea    0x57a7(%rip),%r14\nlea    0x55f6(%rip),%rbx\nlea    0x5609(%rip),%r15\njmp    1a51 <next+0x4d1>\nnopl   0x0(%rax)\nmov    0x8(%rax),%rsi\nlea    0x8(%rax),%rdx\nmov    %r15,%rdi\nxor    %eax,%eax\nmov    %rdx,0x88fc(%rip)\ncall   5f60 <libmin_printf>\nmov    0x88f0(%rip),%rdx\ncmp    0x88f9(%rip),%rdx\njae    1a90 <next+0x510>\nlea    0x8(%rdx),%rax\nmov    %rbx,%rdi\nmov    %rax,0x88d9(%rip)\nmov    0x8(%rdx),%rax\nlea    (%rax,%rax,4),%rsi\nxor    %eax,%eax\nadd    %r14,%rsi\ncall   5f60 <libmin_printf>\nmov    0x88c0(%rip),%rax\ncmpq   $0x7,(%rax)\njle    1a28 <next+0x4a8>\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\njmp    1a41 <next+0x4c1>\nnopw   0x0(%rax,%rax,1)\nmov    0x8889(%rip),%rax\njmp    16d6 <next+0x156>\nnopl   0x0(%rax)\nmovq   $0x85,(%rax)\nmov    %r14,0x10(%rax)\nmov    %rbx,0x8(%rax)\nmovq   $0x85,0x8896(%rip)\njmp    16b6 <next+0x136>\nsub    $0x30,%eax\nadd    $0x2,%r14\ncmp    $0x9,%al\nja     17b0 <next+0x230>\nxchg   %ax,%ax\nmov    %r14,0x8849(%rip)\nmovsbq -0x1(%r14),%rdx\nlea    (%rbx,%rbx,4),%rcx\nmov    %r14,%rax\nadd    $0x1,%r14\nlea    -0x30(%rdx,%rcx,2),%rbx\nmov    %rbx,0x87d5(%rip)\nmovzbl (%rax),%eax\nsub    $0x30,%eax\ncmp    $0x9,%al\njbe    1ad0 <next+0x550>\njmp    17b0 <next+0x230>\nmovq   $0x90,0x8843(%rip)\nadd    $0x2,%r14\nmov    %r14,0x8808(%rip)\njmp    16b6 <next+0x136>\nmovq   $0x95,0x8828(%rip)\nadd    $0x2,%r14\nmov    %r14,0x87ed(%rip)\njmp    16b6 <next+0x136>\nmovq   $0x91,0x880d(%rip)\nadd    $0x2,%r14\nmov    %r14,0x87d2(%rip)\njmp    16b6 <next+0x136>\nmovq   $0xa3,0x87f2(%rip)\nadd    $0x2,%r14\nmov    %r14,0x87b7(%rip)\njmp    16b6 <next+0x136>\nmovq   $0xa2,0x87d7(%rip)\nadd    $0x2,%r14\nmov    %r14,0x879c(%rip)\njmp    16b6 <next+0x136>\nmovq   $0x99,0x87bc(%rip)\nadd    $0x2,%r14\nmov    %r14,0x8781(%rip)\njmp    16b6 <next+0x136>\nmovq   $0x9a,0x87a1(%rip)\nadd    $0x2,%r14\nmov    %r14,0x8766(%rip)\njmp    16b6 <next+0x136>\nmov    %rax,%r14\njmp    16e4 <next+0x164>\nmov    $0x5f,%ebx\njmp    162a <next+0xaa>\nmov    0x8758(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x874d(%rip)\nmov    0x86de(%rip),%rdx\nmov    %dl,(%rax)\nmov    0x872d(%rip),%rax\njmp    17cc <next+0x24c>\nlea    0x2(%r14),%rax\nmov    %rax,0x871d(%rip)\nmovsbq 0x2(%r14),%rdx\njmp    1c61 <next+0x6e1>\nnopw   0x0(%rax,%rax,1)\nmov    %rdx,%rax\nand    $0xffffffffffffffdf,%rax\nsub    $0x41,%rax\ncmp    $0x5,%rax\nja     17b0 <next+0x230>\nmov    0x869c(%rip),%rax\nmov    %rdx,%rcx\nand    $0xf,%ecx\nshl    $0x4,%rax\nadd    %rcx,%rax\ncmp    $0x40,%rdx\njle    1c43 <next+0x6c3>\nadd    $0x9,%rax\nmov    %rax,0x867e(%rip)\nmov    0x86cf(%rip),%rax\nlea    0x1(%rax),%rdx\nmov    %rdx,0x86c4(%rip)\nmovsbq 0x1(%rax),%rdx\nlea    -0x30(%rdx),%rax\nmov    %rdx,0x86e4(%rip)\ncmp    $0x9,%rax\nja     1c10 <next+0x690>\nmov    0x864f(%rip),%rax\nand    $0xf,%edx\nshl    $0x4,%rax\nadd    %rdx,%rax\njmp    1c43 <next+0x6c3>\nmovq   $0x9c,0x86c0(%rip)\nadd    $0x2,%r14\nmov    %r14,0x8685(%rip)\njmp    16b6 <next+0x136>\nmovq   $0x9b,0x86a5(%rip)\nadd    $0x2,%r14\nmov    %r14,0x866a(%rip)\njmp    16b6 <next+0x136>\nmovq   $0xa0,0x868a(%rip)\njmp    16b6 <next+0x136>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "program", "content": "void program() {\n    // get next token\n    next();\n    while (token > 0) {\n        global_declaration();\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O2.pseudo", "function_name": "program", "address": "0x3e50", "label": "program", "content": "void __cdecl program()\n{\n  next();\n  while ( token > 0 )\n    global_declaration();\n}\n"}, "pseudo_normalize": "", "binary": "c-interp/c-interp.host.O2", "assembly": "<program>:\nendbr64\nsub    $0x8,%rsp\nxor    %eax,%eax\ncall   1580 <next>\ncmpq   $0x0,0x64e9(%rip)\njle    3e81 <program+0x31>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   3b50 <global_declaration>\ncmpq   $0x0,0x64d1(%rip)\njg     3e70 <program+0x20>\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "c-interp/c-interp.c", "function_name": "statement", "content": "void statement() {\n    // there are 8 kinds of statements here:\n    // 1. if (...) <statement> [else <statement>]\n    // 2. while (...) <statement>\n    // 3. { <statement> }\n    // 4. return xxx;\n    // 5. <empty statement>;\n    // 6. expression; (expression end with semicolon)\n\n    long *a, *b; // bess for branch control\n\n    if (token == If) {\n        // if (...) <statement> [else <statement>]\n        //\n        //   if (...)           <cond>\n        //                      JZ a\n        //     <statement>      <statement>\n        //   else:              JMP b\n        // a:\n        //     <statement>      <statement>\n        // b:                   b:\n        //\n        //\n        match(If);\n        match('(');\n        expression(Assign);  // parse condition\n        match(')');\n\n        // emit code for if\n        *++text = JZ;\n        b = ++text;\n\n        statement();         // parse statement\n        if (token == Else) { // parse else\n            match(Else);\n\n            // emit code for JMP B\n            *b = (long)(text + 3);\n            *++text = JMP;\n            b = ++text;\n\n            statement();\n        }\n\n        *b = (long)(text + 1);\n    }\n    else if (token == While) {\n        //\n        // a:                     a:\n        //    while (<cond>)        <cond>\n        //                          JZ b\n        //     <statement>          <statement>\n        //                          JMP a\n        // b:                     b:\n        match(While);\n\n        a = text + 1;\n\n        match('(');\n        expression(Assign);\n        match(')');\n\n        *++text = JZ;\n        b = ++text;\n\n        statement();\n\n        *++text = JMP;\n        *++text = (long)a;\n        *b = (long)(text + 1);\n    }\n    else if (token == '{') {\n        // { <statement> ... }\n        match('{');\n\n        while (token != '}') {\n            statement();\n        }\n\n        match('}');\n    }\n    else if (token == Return) {\n        // return [expression];\n        match(Return);\n\n        if (token != ';') {\n            expression(Assign);\n        }\n\n        match(';');\n\n        // emit code for return\n        *++text = LEV;\n    }\n    else if (token == ';') {\n        // empty statement\n        match(';');\n    }\n    else {\n        // a = b; or function_call();\n        expression(Assign);\n        match(';');\n    }\n}\n"}, "pseudo": {"path": "c-interp/c-interp.host.O2.pseudo", "function_name": "statement", "address": "0x31b0", "label": "statement", "content": "void __cdecl statement()\n{\n  _QWORD *v0; // rbp\n  _QWORD *v1; // rbx\n  char *v2; // rdx\n  char *v3; // rbp\n  _QWORD *v4; // rbx\n  _QWORD *v5; // rax\n  void *v6; // rdx\n\n  switch ( token )\n  {\n    case 137LL:\n      next();\n      if ( token != 40 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n        libmin_fail(-1);\n      }\n      next();\n      expression(142LL);\n      if ( token != 41 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n        libmin_fail(-1);\n      }\n      next();\n      v0 = text;\n      *((_QWORD *)text + 1) = 4LL;\n      v1 = v0 + 2;\n      text = v0 + 2;\n      statement();\n      if ( token == 135 )\n      {\n        next();\n        v1 = (char *)text + 16;\n        v0[2] = (char *)text + 24;\n        *(v1 - 1) = 2LL;\n        text = v1;\n        statement();\n      }\n      *v1 = (char *)text + 8;\n      break;\n    case 141LL:\n      next();\n      v3 = (char *)text + 8;\n      if ( token != 40 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n        libmin_fail(-1);\n      }\n      next();\n      expression(142LL);\n      if ( token != 41 )\n      {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n        libmin_fail(-1);\n      }\n      next();\n      v4 = text;\n      *((_QWORD *)text + 1) = 4LL;\n      text = v4 + 2;\n      statement();\n      v5 = text;\n      *((_QWORD *)text + 1) = 2LL;\n      v6 = v5 + 2;\n      v5 += 3;\n      *(v5 - 1) = v3;\n      text = v6;\n      v4[2] = v5;\n      break;\n    case 123LL:\n      next();\n      while ( token != 125 )\n        statement();\n      goto LABEL_10;\n    case 139LL:\n      next();\n      if ( token != 59 )\n      {\n        expression(142LL);\n        if ( token != 59 )\n        {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 59LL);\n          libmin_fail(-1);\n        }\n      }\n      next();\n      v2 = (char *)text + 8;\n      *((_QWORD *)text + 1) = 8LL;\n      text = v2;\n      break;\n    default:\n      if ( token != 59 )\n      {\n        expression(142LL);\n        if ( token != 59 )\n        {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 59LL);\n          libmin_fail(-1);\n        }\n      }\nLABEL_10:\n      next();\n      return;\n  }\n}\n"}, "pseudo_normalize": "void statement() {\n  uint64_t *v0;\n  uint64_t *v1;\n  char *v2;\n  char *v3;\n  uint64_t *v4;\n  uint64_t *v5;\n  void *v6;\n  switch (token) {\n    case 137LL:\n      next();\n      if (token != 40) {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n        libmin_fail(-1);\n      }\n      next();\n      expression(142LL);\n      if (token != 41) {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n        libmin_fail(-1);\n      }\n      next();\n      v0 = text;\n      *((uint64_t *)text + 1) = 4LL;\n      v1 = v0 + 2;\n      text = v0 + 2;\n      statement();\n      if (token == 135) {\n        next();\n        v1 = (char *)text + 16;\n        v0[2] = (char *)text + 24;\n        *(v1 - 1) = 2LL;\n        text = v1;\n        statement();\n      }\n      *v1 = (char *)text + 8;\n      break;\n    case 141LL:\n      next();\n      v3 = (char *)text + 8;\n      if (token != 40) {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 40LL);\n        libmin_fail(-1);\n      }\n      next();\n      expression(142LL);\n      if (token != 41) {\n        libmin_printf(\"%ld: expected token: %ld\\n\", line, 41LL);\n        libmin_fail(-1);\n      }\n      next();\n      v4 = text;\n      *((uint64_t *)text + 1) = 4LL;\n      text = v4 + 2;\n      statement();\n      v5 = text;\n      *((uint64_t *)text + 1) = 2LL;\n      v6 = v5 + 2;\n      v5 += 3;\n      *(v5 - 1) = v3;\n      text = v6;\n      v4[2] = v5;\n      break;\n    case 123LL:\n      next();\n      while (token != 125) statement();\n      goto LABEL_10;\n    case 139LL:\n      next();\n      if (token != 59) {\n        expression(142LL);\n        if (token != 59) {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 59LL);\n          libmin_fail(-1);\n        }\n      }\n      next();\n      v2 = (char *)text + 8;\n      *((uint64_t *)text + 1) = 8LL;\n      text = v2;\n      break;\n    default:\n      if (token != 59) {\n        expression(142LL);\n        if (token != 59) {\n          libmin_printf(\"%ld: expected token: %ld\\n\", line, 59LL);\n          libmin_fail(-1);\n        }\n      }\n    LABEL_10:\n      next();\n      return;\n  }\n}", "binary": "c-interp/c-interp.host.O2", "assembly": "<statement>:\nendbr64\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x718f(%rip),%rax\ncmp    $0x89,%rax\nje     3260 <statement+0xb0>\ncmp    $0x8d,%rax\nje     3370 <statement+0x1c0>\ncmp    $0x7b,%rax\nje     3230 <statement+0x80>\ncmp    $0x8b,%rax\nje     3320 <statement+0x170>\ncmp    $0x3b,%rax\nje     3252 <statement+0xa2>\nmov    $0x8e,%edi\ncall   1d20 <expression>\ncmpq   $0x3b,0x714d(%rip)\nje     3252 <statement+0xa2>\nmov    0x70c4(%rip),%rsi\nlea    0x3e01(%rip),%rdi\nmov    $0x3b,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nadd    $0x8,%rsp\nmov    $0xffffffff,%edi\npop    %rbx\npop    %rbp\njmp    47e0 <libmin_fail>\nnop\nxor    %eax,%eax\ncall   1580 <next>\ncmpq   $0x7d,0x7111(%rip)\nje     3252 <statement+0xa2>\nxor    %eax,%eax\ncall   31b0 <statement>\ncmpq   $0x7d,0x7100(%rip)\njne    3241 <statement+0x91>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\njmp    1580 <next>\nnop\nxor    %eax,%eax\ncall   1580 <next>\ncmpq   $0x28,0x70e1(%rip)\nje     3360 <statement+0x1b0>\nmov    0x7054(%rip),%rsi\nlea    0x3d91(%rip),%rdi\nmov    $0x28,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    $0x8e,%edi\ncall   1d20 <expression>\ncmpq   $0x29,0x70a5(%rip)\nje     3440 <statement+0x290>\nmov    0x7018(%rip),%rsi\nlea    0x3d55(%rip),%rdi\nmov    $0x29,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x706c(%rip),%rbp\nxor    %eax,%eax\nmovq   $0x4,0x8(%rbp)\nlea    0x10(%rbp),%rbx\nmov    %rbx,0x7057(%rip)\ncall   31b0 <statement>\ncmpq   $0x87,0x704f(%rip)\nje     34b8 <statement+0x308>\nmov    0x703a(%rip),%rax\nadd    $0x8,%rax\nmov    %rax,(%rbx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\ncmpq   $0x3b,0x7021(%rip)\njne    3450 <statement+0x2a0>\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x7005(%rip),%rax\nlea    0x8(%rax),%rdx\nmovq   $0x8,0x8(%rax)\nmov    %rdx,0x6ff2(%rip)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   (%rax)\nxor    %eax,%eax\ncall   1580 <next>\njmp    3299 <statement+0xe9>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x6fca(%rip),%rax\ncmpq   $0x28,0x6fca(%rip)\nlea    0x8(%rax),%rbp\nje     34a8 <statement+0x2f8>\nmov    0x6f39(%rip),%rsi\nlea    0x3c76(%rip),%rdi\nmov    $0x28,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    $0x8e,%edi\ncall   1d20 <expression>\ncmpq   $0x29,0x6f8a(%rip)\nje     3498 <statement+0x2e8>\nmov    0x6efd(%rip),%rsi\nlea    0x3c3a(%rip),%rdi\nmov    $0x29,%edx\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\nmov    0x6f51(%rip),%rbx\nmovq   $0x4,0x8(%rbx)\nlea    0x10(%rbx),%rax\nmov    %rax,0x6f3e(%rip)\nxor    %eax,%eax\ncall   31b0 <statement>\nmov    0x6f30(%rip),%rax\nmovq   $0x2,0x8(%rax)\nlea    0x10(%rax),%rdx\nadd    $0x18,%rax\nmov    %rbp,-0x8(%rax)\nmov    %rdx,0x6f15(%rip)\nmov    %rax,0x10(%rbx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nxchg   %ax,%ax\nxor    %eax,%eax\ncall   1580 <next>\njmp    32d5 <statement+0x125>\nnopl   0x0(%rax)\nmov    $0x8e,%edi\ncall   1d20 <expression>\ncmpq   $0x3b,0x6eee(%rip)\nje     3335 <statement+0x185>\nmov    0x6e61(%rip),%rsi\nmov    $0x3b,%edx\nlea    0x3b99(%rip),%rdi\nxor    %eax,%eax\ncall   5f60 <libmin_printf>\nmov    $0xffffffff,%edi\ncall   47e0 <libmin_fail>\njmp    333c <statement+0x18c>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\njmp    33f0 <statement+0x240>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\njmp    33b4 <statement+0x204>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncall   1580 <next>\nmov    0x6e82(%rip),%rbx\nlea    0x18(%rbx),%rax\nadd    $0x10,%rbx\nmov    %rax,0x10(%rbp)\nxor    %eax,%eax\nmovq   $0x2,-0x8(%rbx)\nmov    %rbx,0x6e65(%rip)\ncall   31b0 <statement>\njmp    3307 <statement+0x157>\nnopl   (%rax)\n"}
{"source": {"path": "ccmac/ccmac.c", "function_name": "main", "content": " // [0,1)\n\nint\nmain(void)\n{\n  const size_t n = (size_t)N_ELEMS, stride = (size_t)STRIDE;\n  rng = (SEED?SEED:1);\n\n  // Inputs and outputs\n  double *x = (double*)libmin_malloc(n*sizeof(double));\n  double *y = (double*)libmin_malloc(n*sizeof(double));\n  if(!x || !y){ libmin_printf(\"alloc failed\\n\"); libmin_fail(1); }\n\n  // Coefficients c[0..DEGREE] in a reasonable range\n  double *c = (double*)libmin_malloc((DEGREE+1)*sizeof(double));\n  if(!c){ libmin_printf(\"alloc failed\\n\"); libmin_fail(1); }\n  for(int k=0;k<=DEGREE;k++){ c[k] = -1.0 + 2.0*urand01(); }\n\n  // Inputs in [-1,1] to keep values bounded\n  for(size_t i=0, idx=0;i<n;i++, idx=(idx+stride)%n){\n    x[idx] = -1.0 + 2.0*urand01();\n    y[idx] = 0.0;\n  }\n\n  volatile double sink = 0.0;\n\n  for(uint64_t it=0; it<(uint64_t)N_ITER; ++it){\n    for(size_t i=0, idx=0;i<n;i++, idx=(idx+stride)%n){\n      double acc = c[DEGREE];\n      // Horner loop: DEGREE FMAs (or mul+add if fma not used)\n      for(int k=DEGREE-1;k>=0;k--)\n        acc = fma(acc, x[idx], c[k]);\n      y[idx] = acc;\n      sink += acc * 1e-16;\n    }\n  }\n\n  // Report\n  const double ops = (double)N_ITER * (double)n * (double)(2*DEGREE); // FMA counted as 2 flops\n  double checksum = 0.0; for(size_t i=0;i<n;i++) checksum += y[i];\n\n  libmin_printf(\"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n         DEGREE, (unsigned)N_ITER, n, stride, ops, checksum);\n\n  libmin_free(c); libmin_free((void*)x); libmin_free((void*)y);\n\n  libmin_success();\n}\n"}, "pseudo": {"path": "ccmac/ccmac.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double *v3; // r13\n  double *v4; // rax\n  double *v5; // r12\n  double *v6; // rbp\n  uint64_t v7; // rax\n  double *v8; // rcx\n  __int64 v9; // rsi\n  __int64 v10; // rcx\n  double *v11; // rdi\n  double *v12; // rdx\n  double v13; // xmm0_8\n  __int64 v14; // r9\n  __int64 v15; // rcx\n  __int64 v16; // rsi\n  double v17; // xmm0_8\n  double *v18; // rax\n  double *v19; // rdx\n  double *v20; // rax\n  double v21; // xmm1_8\n  double sink; // [rsp+8h] [rbp-20h]\n\n  rng = 1LL;\n  v3 = (double *)libmin_malloc(0x200uLL);\n  v4 = (double *)libmin_malloc(0x200uLL);\n  v5 = v4;\n  if ( v3 && v4 )\n  {\n    v6 = (double *)libmin_malloc(0x88uLL);\n    if ( v6 )\n    {\n      v7 = rng;\n      v8 = v6;\n      do\n      {\n        ++v8;\n        v7 ^= ((v7 ^ (v7 << 13)) >> 7) ^ (v7 << 13) ^ ((((v7 ^ (v7 << 13)) >> 7) ^ v7 ^ (v7 << 13)) << 17);\n        *(v8 - 1) = (double)(int)(v7 >> 11) * 1.110223024625157e-16\n                  + (double)(int)(v7 >> 11) * 1.110223024625157e-16\n                  - 1.0;\n      }\n      while ( v6 + 17 != v8 );\n      v9 = 64LL;\n      v10 = 0LL;\n      do\n      {\n        v7 ^= ((v7 ^ (v7 << 13)) >> 7) ^ (v7 << 13) ^ ((((v7 ^ (v7 << 13)) >> 7) ^ v7 ^ (v7 << 13)) << 17);\n        v11 = &v3[v10];\n        v12 = &v5[v10];\n        v10 = ((_BYTE)v10 + 1) & 0x3F;\n        v13 = (double)(int)(v7 >> 11) * 1.110223024625157e-16 + (double)(int)(v7 >> 11) * 1.110223024625157e-16 - 1.0;\n        *v11 = v13;\n        *v12 = 0.0;\n        --v9;\n      }\n      while ( v9 );\n      *v11 = v13;\n      v14 = 100LL;\n      rng = v7;\n      *v12 = 0.0;\n      sink = 0.0;\n      while ( 1 )\n      {\n        v15 = 0LL;\n        v16 = 64LL;\n        do\n        {\n          v17 = v6[16];\n          v18 = v6 + 15;\n          do\n          {\n            v19 = v18--;\n            v17 = v17 * v3[v15] + v18[1];\n          }\n          while ( v6 != v19 );\n          v5[v15] = v17;\n          v15 = ((_BYTE)v15 + 1) & 0x3F;\n          sink = v17 * 1.0e-16 + sink;\n          --v16;\n        }\n        while ( v16 );\n        if ( !--v14 )\n        {\n          v20 = v5;\n          v21 = 0.0;\n          do\n            v21 = v21 + *v20++;\n          while ( v5 + 64 != v20 );\n          libmin_printf(\n            \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n            16,\n            100,\n            64,\n            1,\n            204800.0,\n            v21);\n          libmin_free(v6);\n          libmin_free(v3);\n          libmin_free(v5);\n          libmin_success();\n        }\n      }\n    }\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  libmin_printf(\"alloc failed\\n\", argv);\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double *v3;\n  double *v4;\n  double *v5;\n  double *v6;\n  uint64_t v7;\n  double *v8;\n  long long v9;\n  long long v10;\n  double *v11;\n  double *v12;\n  double v13;\n  long long v14;\n  long long v15;\n  long long v16;\n  double v17;\n  double *v18;\n  double *v19;\n  double *v20;\n  double v21;\n  double sink;\n  rng = 1LL;\n  v3 = (double *)libmin_malloc(512uLL);\n  v4 = (double *)libmin_malloc(512uLL);\n  v5 = v4;\n  if (v3 && v4) {\n    v6 = (double *)libmin_malloc(136uLL);\n    if (v6) {\n      v7 = rng;\n      v8 = v6;\n      do {\n        ++v8;\n        v7 ^= ((v7 ^ (v7 << 13)) >> 7) ^ (v7 << 13) ^\n              ((((v7 ^ (v7 << 13)) >> 7) ^ v7 ^ (v7 << 13)) << 17);\n        *(v8 - 1) = (double)(int)(v7 >> 11) * 1.110223024625157e-16 +\n                    (double)(int)(v7 >> 11) * 1.110223024625157e-16 - 1.0;\n      } while (v6 + 17 != v8);\n      v9 = 64LL;\n      v10 = 0LL;\n      do {\n        v7 ^= ((v7 ^ (v7 << 13)) >> 7) ^ (v7 << 13) ^\n              ((((v7 ^ (v7 << 13)) >> 7) ^ v7 ^ (v7 << 13)) << 17);\n        v11 = &v3[v10];\n        v12 = &v5[v10];\n        v10 = ((uint8_t)v10 + 1) & 63;\n        v13 = (double)(int)(v7 >> 11) * 1.110223024625157e-16 +\n              (double)(int)(v7 >> 11) * 1.110223024625157e-16 - 1.0;\n        *v11 = v13;\n        *v12 = 0.0;\n        --v9;\n      } while (v9);\n      *v11 = v13;\n      v14 = 100LL;\n      rng = v7;\n      *v12 = 0.0;\n      sink = 0.0;\n      while (1) {\n        v15 = 0LL;\n        v16 = 64LL;\n        do {\n          v17 = v6[16];\n          v18 = v6 + 15;\n          do {\n            v19 = v18--;\n            v17 = v17 * v3[v15] + v18[1];\n          } while (v6 != v19);\n          v5[v15] = v17;\n          v15 = ((uint8_t)v15 + 1) & 63;\n          sink = v17 * 1.0e-16 + sink;\n          --v16;\n        } while (v16);\n        if (!--v14) {\n          v20 = v5;\n          v21 = 0.0;\n          do v21 = v21 + *v20++;\n          while (v5 + 64 != v20);\n          libmin_printf(\n              \"horner64 degree=%d N_ITER=%u n=%u stride=%u ops=%f \"\n              \"checksum=%f\\n\",\n              16, 100, 64, 1, 204800.0, v21);\n          libmin_free(v6);\n          libmin_free(v3);\n          libmin_free(v5);\n          libmin_success();\n        }\n      }\n    }\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  libmin_printf(\"alloc failed\\n\", argv);\n  libmin_fail(1);\n}", "binary": "ccmac/ccmac.host.O2", "assembly": "<main>:\nendbr64\npush   %r13\nmov    $0x200,%edi\npush   %r12\npush   %rbp\nsub    $0x10,%rsp\nmovq   $0x1,0x4133(%rip)\ncall   1710 <libmin_malloc>\nmov    $0x200,%edi\nmov    %rax,%r13\ncall   1710 <libmin_malloc>\nmov    %rax,%r12\ntest   %r13,%r13\nje     1355 <main+0x235>\ntest   %rax,%rax\nje     1355 <main+0x235>\nmov    $0x88,%edi\ncall   1710 <libmin_malloc>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     1372 <main+0x252>\nmov    0x40ef(%rip),%rax\nmovsd  0x1ecf(%rip),%xmm1\nmov    %rbp,%rcx\nlea    0x88(%rbp),%rsi\nmovsd  0x1ec5(%rip),%xmm2\nmov    %rax,%rdx\npxor   %xmm0,%xmm0\nadd    $0x8,%rcx\nshl    $0xd,%rdx\nxor    %rax,%rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nxor    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x11,%rax\nxor    %rdx,%rax\nmov    %rax,%rdx\nshr    $0xb,%rdx\ncvtsi2sd %rdx,%xmm0\nmulsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\nsubsd  %xmm2,%xmm0\nmovsd  %xmm0,-0x8(%rcx)\ncmp    %rcx,%rsi\njne    119b <main+0x7b>\nmov    $0x40,%esi\nxor    %ecx,%ecx\nmov    %rax,%rdx\npxor   %xmm0,%xmm0\nshl    $0xd,%rdx\nxor    %rax,%rdx\nmov    %rdx,%rax\nshr    $0x7,%rax\nxor    %rax,%rdx\nmov    %rdx,%rax\nshl    $0x11,%rax\nxor    %rdx,%rax\nlea    0x0(,%rcx,8),%rdx\nadd    $0x1,%rcx\nmov    %rax,%r8\nlea    0x0(%r13,%rdx,1),%rdi\nadd    %r12,%rdx\nand    $0x3f,%ecx\nshr    $0xb,%r8\ncvtsi2sd %r8,%xmm0\nmulsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\nsubsd  %xmm2,%xmm0\nmovsd  %xmm0,(%rdi)\nmovq   $0x0,(%rdx)\nsub    $0x1,%rsi\njne    11ea <main+0xca>\nmovsd  %xmm0,(%rdi)\nmovsd  0x1e10(%rip),%xmm2\nlea    0x78(%rbp),%r8\nmov    $0x64,%r9d\nmov    %rax,0x4007(%rip)\nmovq   $0x0,(%rdx)\nmovq   $0x0,0x8(%rsp)\nxor    %ecx,%ecx\nmov    $0x40,%esi\nmovsd  0x80(%rbp),%xmm0\nmovsd  0x0(%r13,%rcx,8),%xmm1\nlea    0x0(,%rcx,8),%rdi\nmov    %r8,%rax\nnopw   0x0(%rax,%rax,1)\nmulsd  %xmm1,%xmm0\nmov    %rax,%rdx\nsub    $0x8,%rax\naddsd  0x8(%rax),%xmm0\ncmp    %rdx,%rbp\njne    12a0 <main+0x180>\nmovsd  %xmm0,(%r12,%rdi,1)\nmulsd  %xmm2,%xmm0\nmovsd  0x8(%rsp),%xmm1\nadd    $0x1,%rcx\nand    $0x3f,%ecx\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,0x8(%rsp)\nsub    $0x1,%rsi\njne    1280 <main+0x160>\nsub    $0x1,%r9\njne    1279 <main+0x159>\nmov    %r12,%rax\nlea    0x200(%r12),%rdx\npxor   %xmm1,%xmm1\naddsd  (%rax),%xmm1\nadd    $0x8,%rax\ncmp    %rax,%rdx\njne    12f1 <main+0x1d1>\nmov    $0x1,%r8d\nmov    $0x40,%ecx\nmov    $0x64,%edx\nmovsd  0x1d5a(%rip),%xmm0\nmov    $0x10,%esi\nlea    0x1cf6(%rip),%rdi\nmov    $0x2,%eax\ncall   2cb0 <libmin_printf>\nmov    %rbp,%rdi\ncall   17c0 <libmin_free>\nmov    %r13,%rdi\ncall   17c0 <libmin_free>\nmov    %r12,%rdi\ncall   17c0 <libmin_free>\ncall   2ef0 <libmin_success>\nadd    $0x10,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\nlea    0x1ca8(%rip),%rdi\nxor    %eax,%eax\ncall   2cb0 <libmin_printf>\nmov    $0x1,%edi\ncall   1660 <libmin_fail>\njmp    1164 <main+0x44>\nlea    0x1c8b(%rip),%rdi\nxor    %eax,%eax\ncall   2cb0 <libmin_printf>\nmov    $0x1,%edi\ncall   1660 <libmin_fail>\njmp    117a <main+0x5a>\nnop\n"}
{"source": {"path": "checkers/functions.c", "function_name": "all_possible_moves", "content": "// function which returns the number of valid target squares a piece at \n// source defined by col/row can make, given a board_t input. \n// Also writes each into a static variable of type valid_moves_t\n\t// sorry for lack of abstraction, very confusing  with different static \n\t// and local variables when abstracted into a function\n\t// so ultimately deemed better in this format\nint all_possible_moves(board_t board_input, char col, char row, \n\tvalid_moves_t valid_moves, int black_action) {\n\tint num_possibles = 0, is_tower = 0;\n\tif ((piece_at_location(board_input, col, row) == CELL_BTOWER)\n\t\t|| (piece_at_location(board_input, col, row) == CELL_WTOWER)) {\n\t\tis_tower = 1;\n\t}\n\t\n\t// iterate through possible tower movement vectors\n\tif (is_tower) {\n\t\tfor (int i=0; i<NUM_TOWER_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + tower_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + tower_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t// otherwise, if target cell occupied by opposing piece, \n\t\t\t\t// capture move possible\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * tower_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * tower_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// iterate through possible black piece movement vectors\n\tif (piece_at_location(board_input, col, row) == CELL_BPIECE) {\n\t\tfor (int i=0; i<NUM_PIECE_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + black_piece_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + black_piece_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * black_piece_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * black_piece_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// iterate through possible white piece movement vectors\n\tif (piece_at_location(board_input, col, row) == CELL_WPIECE) {\n\t\tfor (int i=0; i<NUM_PIECE_MOVEMENTS; i++) {\n\t\t\tint possible_col1, possible_row1;\n\t\t\tpossible_col1 = char_to_col(col) + white_piece_movements[i][0];\n\t\t\tpossible_row1 = char_to_row(row) + white_piece_movements[i][1];\n\t\t\tchar p_col1, p_row1;\n\t\t\tp_col1 = col_to_char(possible_col1);\n\t\t\tp_row1 = row_to_char(possible_row1);\n\t\t\t\n\t\t\tint error_check = check_move_error_1_to_5(board_input, \n\t\t\t\tcol, row, p_col1, p_row1, black_action);\n\t\t\t\n\t\t\t// if no issue with movement, add to valid_moves_t static variable\n\t\t\tif (error_check == NO_ERRORS_1_TO_5) {\n\t\t\t\tvalid_moves[num_possibles][0] = p_col1;\n\t\t\t\tvalid_moves[num_possibles][1] = p_row1;\n\t\t\t\tnum_possibles += 1;\n\t\t\t}\n\t\t\t\n\t\t\tint capture_possible = 0;\n\t\t\tif (error_check == 4) {\n\t\t\t\tif (black_action) {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_WTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ((piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BPIECE)\n\t\t\t\t\t\t|| \n\t\t\t\t\t(piece_at_location(board_input, p_col1, p_row1) \n\t\t\t\t\t\t== CELL_BTOWER)) {\n\t\t\t\t\t\tcapture_possible = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (capture_possible) {\n\t\t\t\tint possible_col2, possible_row2;\n\t\t\t\tpossible_col2 = char_to_col(col) + \n\t\t\t\t\t(CAPTURE_JUMP * white_piece_movements[i][0]);\n\t\t\t\tpossible_row2 = char_to_row(row) + \n\t\t\t\t\t(CAPTURE_JUMP * white_piece_movements[i][1]);\n\t\t\t\tchar p_col2, p_row2;\n\t\t\t\tp_col2 = col_to_char(possible_col2);\n\t\t\t\tp_row2 = row_to_char(possible_row2);\n\t\t\t\t\n\t\t\t\tint error_check_2 = check_move_error_1_to_5(board_input, \n\t\t\t\t\tcol, row, p_col2, p_row2, black_action);\n\t\t\t\t\n\t\t\t\tif (error_check_2 == NO_ERRORS_1_TO_5) {\n\t\t\t\t\tvalid_moves[num_possibles][0] = p_col2;\n\t\t\t\t\tvalid_moves[num_possibles][1] = p_row2;\n\t\t\t\t\tnum_possibles += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn num_possibles;\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "all_possible_moves", "address": "0x1a60", "label": "all_possible_moves", "content": "int __fastcall all_possible_moves(\n        unsigned __int8 (*board_input)[8],\n        char col,\n        char row,\n        square_t *valid_moves,\n        int black_action)\n{\n  int v5; // r9d\n  unsigned __int8 v7; // al\n  int v8; // r11d\n  int *v10; // r10\n  int v11; // r13d\n  char v12; // r12\n  int v13; // eax\n  __int64 v14; // r10\n  int v15; // r11d\n  char *v16; // rax\n  int *v17; // r10\n  int v18; // r13d\n  int v19; // r12d\n  int v20; // ebx\n  int v21; // eax\n  __int64 v22; // r10\n  int v23; // r11d\n  __int64 v24; // rax\n  char *v25; // rax\n  int *v26; // r10\n  int v27; // r13d\n  int v28; // ebp\n  int v29; // eax\n  __int64 v30; // r10\n  __int64 v31; // rax\n  char *v32; // rax\n  char v33; // al\n  char v34; // r13\n  char v35; // r11\n  char *v36; // rax\n  char v37; // al\n  __int64 v38; // rax\n  char *v39; // rax\n  char v40; // al\n  char v41; // r11\n  __int64 v42; // rax\n  char *v43; // rax\n  int v44; // [rsp+0h] [rbp-60h]\n  int num_possibles; // [rsp+4h] [rbp-5Ch]\n  char v47; // [rsp+10h] [rbp-50h]\n  int v48; // [rsp+10h] [rbp-50h]\n  int v49; // [rsp+10h] [rbp-50h]\n  int v50; // [rsp+14h] [rbp-4Ch]\n  int v51; // [rsp+14h] [rbp-4Ch]\n  int v52; // [rsp+14h] [rbp-4Ch]\n  int possible_col1; // [rsp+18h] [rbp-48h]\n  int possible_col1a; // [rsp+18h] [rbp-48h]\n  int possible_col1b; // [rsp+18h] [rbp-48h]\n  unsigned __int8 *v56; // [rsp+20h] [rbp-40h]\n  __int64 v57; // [rsp+28h] [rbp-38h]\n\n  v5 = black_action;\n  v44 = col - 64;\n  v56 = &(*board_input)[8 * v44 - 8];\n  v57 = row - 49;\n  v7 = v56[v57];\n  if ( v7 != 87 )\n  {\n    v8 = 0;\n    if ( v7 != 66 )\n    {\n      if ( v7 == 98 )\n        goto LABEL_11;\n      goto LABEL_4;\n    }\n  }\n  v10 = tower_movements[0];\n  v47 = row - 48;\n  num_possibles = 0;\n  do\n  {\n    v11 = *v10;\n    possible_col1 = *v10 + v44;\n    v50 = v10[1];\n    v12 = *v10 + col;\n    v13 = check_move_error_1_to_5(board_input, col, row, v12, v47 + v50 + 48, v5);\n    if ( !v13 )\n    {\n      v16 = &(*valid_moves)[2 * num_possibles];\n      *v16 = v12;\n      v16[1] = v47 + v50 + 48;\n      ++num_possibles;\n      goto LABEL_9;\n    }\n    if ( v13 == 4 )\n    {\n      v33 = (*board_input)[8 * v12 - 569 + v15] & 0xDF;\n      if ( v5 )\n      {\n        if ( v33 != 87 )\n          goto LABEL_9;\n      }\n      else if ( v33 != 66 )\n      {\n        goto LABEL_9;\n      }\n      v34 = v11 + possible_col1 + 64;\n      if ( !check_move_error_1_to_5(board_input, col, row, v34, v50 + v47 + v50 + 48, v5) )\n      {\n        v36 = &(*valid_moves)[2 * num_possibles];\n        *v36 = v34;\n        v36[1] = v35;\n        ++num_possibles;\n      }\n    }\nLABEL_9:\n    v10 = (int *)(v14 + 8);\n  }\n  while ( white_piece_movements != (int (*)[2])v10 );\n  v8 = num_possibles;\n  v7 = v56[v57];\n  if ( v7 == 98 )\n  {\nLABEL_11:\n    v17 = black_piece_movements[0];\n    v18 = v8;\n    while ( 1 )\n    {\n      v48 = *v17;\n      v51 = v17[1];\n      v19 = col + *v17;\n      possible_col1a = v44 + *v17;\n      v20 = (char)(col + *v17);\n      v21 = check_move_error_1_to_5(board_input, col, row, col + *v17, row + v51, v5);\n      if ( v21 )\n      {\n        if ( v21 == 4 )\n        {\n          v40 = (*board_input)[8 * v20 - 569 + v23] & 0xDF;\n          if ( v5 )\n          {\n            if ( v40 == 87 )\n            {\nLABEL_36:\n              if ( !check_move_error_1_to_5(board_input, col, row, v48 + possible_col1a + 64, v51 + row + v51, v5) )\n              {\n                v42 = v18++;\n                v43 = &(*valid_moves)[2 * v42];\n                *v43 = v41;\n                v43[1] = v51 + row + v51;\n              }\n            }\n          }\n          else if ( v40 == 66 )\n          {\n            goto LABEL_36;\n          }\n        }\n      }\n      else\n      {\n        v24 = v18++;\n        v25 = &(*valid_moves)[2 * v24];\n        *v25 = v19;\n        v25[1] = row + v51;\n      }\n      v17 = (int *)(v22 + 8);\n      if ( WHITE == (char *)v17 )\n      {\n        v8 = v18;\n        if ( v56[v57] != 119 )\n          return v8;\nLABEL_16:\n        v26 = white_piece_movements[0];\n        while ( 2 )\n        {\n          v49 = *v26;\n          v52 = v26[1];\n          v27 = col + *v26;\n          possible_col1b = v44 + *v26;\n          v28 = (char)(col + *v26);\n          v29 = check_move_error_1_to_5(board_input, col, row, col + *v26, row + v52, v5);\n          if ( !v29 )\n          {\n            v31 = v8++;\n            v32 = &(*valid_moves)[2 * v31];\n            *v32 = v27;\n            v32[1] = row + v52;\n            goto LABEL_19;\n          }\n          if ( v29 == 4 )\n          {\n            v37 = (*board_input)[8 * v28 - 569 + (char)(row + v52)] & 0xDF;\n            if ( v5 )\n            {\n              if ( v37 == 87 )\n                goto LABEL_31;\n            }\n            else if ( v37 == 66 )\n            {\nLABEL_31:\n              if ( !check_move_error_1_to_5(board_input, col, row, v49 + possible_col1b + 64, v52 + row + v52, v5) )\n              {\n                v38 = v8++;\n                v39 = &(*valid_moves)[2 * v38];\n                *v39 = v49 + possible_col1b + 64;\n                v39[1] = v52 + row + v52;\n              }\n            }\n          }\nLABEL_19:\n          v26 = (int *)(v30 + 8);\n          if ( black_piece_movements == (int (*)[2])v26 )\n            return v8;\n          continue;\n        }\n      }\n    }\n  }\nLABEL_4:\n  if ( v7 == 119 )\n    goto LABEL_16;\n  return v8;\n}\n"}, "pseudo_normalize": "int all_possible_moves(unsigned char (*board_input)[8], char col, char row,\n                       square_t *valid_moves, int black_action) {\n  int v5;\n  unsigned char v7;\n  int v8;\n  int *v10;\n  int v11;\n  char v12;\n  int v13;\n  long long v14;\n  int v15;\n  char *v16;\n  int *v17;\n  int v18;\n  int v19;\n  int v20;\n  int v21;\n  long long v22;\n  int v23;\n  long long v24;\n  char *v25;\n  int *v26;\n  int v27;\n  int v28;\n  int v29;\n  long long v30;\n  long long v31;\n  char *v32;\n  char v33;\n  char v34;\n  char v35;\n  char *v36;\n  char v37;\n  long long v38;\n  char *v39;\n  char v40;\n  char v41;\n  long long v42;\n  char *v43;\n  int v44;\n  int num_possibles;\n  char v47;\n  int v48;\n  int v49;\n  int v50;\n  int v51;\n  int v52;\n  int possible_col1;\n  int possible_col1a;\n  int possible_col1b;\n  unsigned char *v56;\n  long long v57;\n  v5 = black_action;\n  v44 = col - 64;\n  v56 = &(*board_input)[8 * v44 - 8];\n  v57 = row - 49;\n  v7 = v56[v57];\n  if (v7 != 87) {\n    v8 = 0;\n    if (v7 != 66) {\n      if (v7 == 98) goto LABEL_11;\n      goto LABEL_4;\n    }\n  }\n  v10 = tower_movements[0];\n  v47 = row - 48;\n  num_possibles = 0;\n  do {\n    v11 = *v10;\n    possible_col1 = *v10 + v44;\n    v50 = v10[1];\n    v12 = *v10 + col;\n    v13 =\n        check_move_error_1_to_5(board_input, col, row, v12, v47 + v50 + 48, v5);\n    if (!v13) {\n      v16 = &(*valid_moves)[2 * num_possibles];\n      *v16 = v12;\n      v16[1] = v47 + v50 + 48;\n      ++num_possibles;\n      goto LABEL_9;\n    }\n    if (v13 == 4) {\n      v33 = (*board_input)[8 * v12 - 569 + v15] & 223;\n      if (v5) {\n        if (v33 != 87) goto LABEL_9;\n      } else if (v33 != 66) {\n        goto LABEL_9;\n      }\n      v34 = v11 + possible_col1 + 64;\n      if (!check_move_error_1_to_5(board_input, col, row, v34,\n                                   v50 + v47 + v50 + 48, v5)) {\n        v36 = &(*valid_moves)[2 * num_possibles];\n        *v36 = v34;\n        v36[1] = v35;\n        ++num_possibles;\n      }\n    }\n  LABEL_9:\n    v10 = (int *)(v14 + 8);\n  } while (white_piece_movements != (int(*)[2])v10);\n  v8 = num_possibles;\n  v7 = v56[v57];\n  if (v7 == 98) {\n  LABEL_11:\n    v17 = black_piece_movements[0];\n    v18 = v8;\n    while (1) {\n      v48 = *v17;\n      v51 = v17[1];\n      v19 = col + *v17;\n      possible_col1a = v44 + *v17;\n      v20 = (char)(col + *v17);\n      v21 = check_move_error_1_to_5(board_input, col, row, col + *v17,\n                                    row + v51, v5);\n      if (v21) {\n        if (v21 == 4) {\n          v40 = (*board_input)[8 * v20 - 569 + v23] & 223;\n          if (v5) {\n            if (v40 == 87) {\n            LABEL_36:\n              if (!check_move_error_1_to_5(board_input, col, row,\n                                           v48 + possible_col1a + 64,\n                                           v51 + row + v51, v5)) {\n                v42 = v18++;\n                v43 = &(*valid_moves)[2 * v42];\n                *v43 = v41;\n                v43[1] = v51 + row + v51;\n              }\n            }\n          } else if (v40 == 66) {\n            goto LABEL_36;\n          }\n        }\n      } else {\n        v24 = v18++;\n        v25 = &(*valid_moves)[2 * v24];\n        *v25 = v19;\n        v25[1] = row + v51;\n      }\n      v17 = (int *)(v22 + 8);\n      if (WHITE == (char *)v17) {\n        v8 = v18;\n        if (v56[v57] != 119) return v8;\n      LABEL_16:\n        v26 = white_piece_movements[0];\n        while (2) {\n          v49 = *v26;\n          v52 = v26[1];\n          v27 = col + *v26;\n          possible_col1b = v44 + *v26;\n          v28 = (char)(col + *v26);\n          v29 = check_move_error_1_to_5(board_input, col, row, col + *v26,\n                                        row + v52, v5);\n          if (!v29) {\n            v31 = v8++;\n            v32 = &(*valid_moves)[2 * v31];\n            *v32 = v27;\n            v32[1] = row + v52;\n            goto LABEL_19;\n          }\n          if (v29 == 4) {\n            v37 = (*board_input)[8 * v28 - 569 + (char)(row + v52)] & 223;\n            if (v5) {\n              if (v37 == 87) goto LABEL_31;\n            } else if (v37 == 66) {\n            LABEL_31:\n              if (!check_move_error_1_to_5(board_input, col, row,\n                                           v49 + possible_col1b + 64,\n                                           v52 + row + v52, v5)) {\n                v38 = v8++;\n                v39 = &(*valid_moves)[2 * v38];\n                *v39 = v49 + possible_col1b + 64;\n                v39[1] = v52 + row + v52;\n              }\n            }\n          }\n        LABEL_19:\n          v26 = (int *)(v30 + 8);\n          if (black_piece_movements == (int(*)[2])v26) return v8;\n          continue;\n        }\n      }\n    }\n  }\nLABEL_4:\n  if (v7 == 119) goto LABEL_16;\n  return v8;\n}", "binary": "checkers/checkers.host.O2", "assembly": "<all_possible_moves>:\nendbr64\npush   %r15\nmovsbl %sil,%r15d\nmov    %r8d,%r9d\npush   %r14\nlea    -0x40(%r15),%eax\nmovsbl %dl,%r14d\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x30,%rsp\nmov    %eax,(%rsp)\ncltq\nmov    %rcx,0x8(%rsp)\nlea    -0x8(%rdi,%rax,8),%rcx\nlea    -0x31(%r14),%eax\ncltq\nmov    %rcx,0x20(%rsp)\nmov    %rax,0x28(%rsp)\nmovzbl (%rcx,%rax,1),%eax\ncmp    $0x57,%al\nje     1ad8 <all_possible_moves+0x78>\nxor    %r11d,%r11d\ncmp    $0x42,%al\nje     1ad8 <all_possible_moves+0x78>\ncmp    $0x62,%al\nje     1b81 <all_possible_moves+0x121>\ncmp    $0x77,%al\nje     1c1a <all_possible_moves+0x1ba>\nadd    $0x30,%rsp\nmov    %r11d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nlea    -0x30(%r14),%eax\nxor    %r11d,%r11d\nlea    0x657a(%rip),%r10\nmov    %eax,0x10(%rsp)\nmov    %r11d,0x4(%rsp)\nmov    (%rsp),%eax\nmov    (%r10),%r13d\nlea    0x0(%r13,%rax,1),%edx\nmov    0x4(%r10),%eax\nmov    %edx,%esi\nmov    %edx,0x18(%rsp)\nmov    %r14d,%edx\nmov    %eax,0x14(%rsp)\nadd    0x10(%rsp),%eax\nlea    0x40(%rsi),%r12d\nmov    %r15d,%esi\nlea    0x30(%rax),%ebp\nmovsbl %r12b,%ebx\nmov    %eax,0x1c(%rsp)\nmovsbl %bpl,%r11d\nmov    %ebx,%ecx\nmov    %r11d,%r8d\ncall   1870 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    1ca0 <all_possible_moves+0x240>\nmovslq 0x4(%rsp),%rax\nmov    0x8(%rsp),%rdx\nmov    %rax,%rcx\nlea    (%rdx,%rax,2),%rax\nadd    $0x1,%ecx\nmov    %r12b,(%rax)\nmov    %bpl,0x1(%rax)\nmov    %ecx,0x4(%rsp)\nadd    $0x8,%r10\nlea    0x651f(%rip),%rax\ncmp    %r10,%rax\njne    1aef <all_possible_moves+0x8f>\nmov    0x20(%rsp),%rax\nmov    0x28(%rsp),%rsi\nmov    0x4(%rsp),%r11d\nmovzbl (%rax,%rsi,1),%eax\ncmp    $0x62,%al\njne    1ab7 <all_possible_moves+0x57>\nlea    -0x30(%r14),%eax\nlea    0x6504(%rip),%r10\nmov    %r11d,%r13d\nmov    %eax,0x4(%rsp)\nmov    (%r10),%eax\nmov    0x4(%r10),%esi\nmov    %r14d,%edx\nmov    %eax,0x10(%rsp)\nadd    (%rsp),%eax\nmov    %esi,0x14(%rsp)\nadd    0x4(%rsp),%esi\nlea    0x40(%rax),%r12d\nmov    %eax,0x18(%rsp)\nmov    %esi,%eax\nmovsbl %r12b,%ebx\nlea    0x30(%rax),%ebp\nmov    %esi,0x1c(%rsp)\nmov    %ebx,%ecx\nmov    %r15d,%esi\nmovsbl %bpl,%r11d\nmov    %r11d,%r8d\ncall   1870 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    1dc8 <all_possible_moves+0x368>\nmov    0x8(%rsp),%rsi\nmovslq %r13d,%rax\nadd    $0x1,%r13d\nlea    (%rsi,%rax,2),%rax\nmov    %r12b,(%rax)\nmov    %bpl,0x1(%rax)\nadd    $0x8,%r10\nlea    0x64a4(%rip),%rax\ncmp    %r10,%rax\njne    1b93 <all_possible_moves+0x133>\nmov    0x20(%rsp),%rax\nmov    0x28(%rsp),%rbx\nmov    %r13d,%r11d\nmovzbl (%rax,%rbx,1),%eax\ncmp    $0x77,%al\njne    1abf <all_possible_moves+0x5f>\nlea    -0x30(%r14),%eax\nlea    0x645b(%rip),%r10\nmov    %eax,0x4(%rsp)\nmov    (%r10),%eax\nmov    0x4(%r10),%ebx\nmov    %r14d,%edx\nmov    %r15d,%esi\nmov    %eax,0x10(%rsp)\nadd    (%rsp),%eax\nmov    %ebx,0x14(%rsp)\nadd    0x4(%rsp),%ebx\nlea    0x40(%rax),%r13d\nmov    %eax,0x18(%rsp)\nmov    %ebx,%eax\nmovsbl %r13b,%ebp\nlea    0x30(%rax),%r12d\nmov    %ebx,0x1c(%rsp)\nmov    %ebp,%ecx\nmovsbl %r12b,%ebx\nmov    %ebx,%r8d\ncall   1870 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    1d40 <all_possible_moves+0x2e0>\nmov    0x8(%rsp),%rsi\nmovslq %r11d,%rax\nadd    $0x1,%r11d\nlea    (%rsi,%rax,2),%rax\nmov    %r13b,(%rax)\nmov    %r12b,0x1(%rax)\nadd    $0x8,%r10\nlea    0x63fd(%rip),%rax\ncmp    %r10,%rax\njne    1c29 <all_possible_moves+0x1c9>\njmp    1abf <all_possible_moves+0x5f>\nnopl   (%rax)\ncmp    $0x4,%eax\njne    1b56 <all_possible_moves+0xf6>\nsub    $0x40,%ebx\nsub    $0x31,%r11d\nmovslq %ebx,%rbx\nmovslq %r11d,%r11\nlea    (%rdi,%rbx,8),%rax\nmovzbl -0x8(%r11,%rax,1),%eax\nand    $0xffffffdf,%eax\ntest   %r9d,%r9d\njne    1d30 <all_possible_moves+0x2d0>\ncmp    $0x42,%al\njne    1b56 <all_possible_moves+0xf6>\nmovzbl 0x18(%rsp),%eax\nmovzbl 0x1c(%rsp),%esi\nmov    %r14d,%edx\nlea    0x40(%r13,%rax,1),%r13d\nmovzbl 0x14(%rsp),%eax\nmovsbl %r13b,%ecx\nlea    0x30(%rax,%rsi,1),%r11d\nmov    %r15d,%esi\nmovsbl %r11b,%r8d\ncall   1870 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    1b56 <all_possible_moves+0xf6>\nmovslq 0x4(%rsp),%rax\nmov    0x8(%rsp),%rbx\nmov    %rax,%rdx\nlea    (%rbx,%rax,2),%rax\nadd    $0x1,%edx\nmov    %r13b,(%rax)\nmov    %r11b,0x1(%rax)\nmov    %edx,0x4(%rsp)\njmp    1b56 <all_possible_moves+0xf6>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x57,%al\nje     1cd0 <all_possible_moves+0x270>\njmp    1b56 <all_possible_moves+0xf6>\nnopl   0x0(%rax)\ncmp    $0x4,%eax\njne    1c88 <all_possible_moves+0x228>\nsub    $0x40,%ebp\nsub    $0x31,%ebx\nmovslq %ebp,%rbp\nmovslq %ebx,%rbx\nlea    (%rdi,%rbp,8),%rax\nmovzbl -0x8(%rbx,%rax,1),%eax\nand    $0xffffffdf,%eax\ntest   %r9d,%r9d\njne    1e60 <all_possible_moves+0x400>\ncmp    $0x42,%al\njne    1c88 <all_possible_moves+0x228>\nmovzbl 0x10(%rsp),%eax\nmovzbl 0x18(%rsp),%esi\nmovzbl 0x1c(%rsp),%edx\nlea    0x40(%rax,%rsi,1),%ebx\nmovzbl 0x14(%rsp),%eax\nmov    %r15d,%esi\nmovsbl %bl,%ecx\nlea    0x30(%rax,%rdx,1),%ebp\nmov    %r14d,%edx\nmovsbl %bpl,%r8d\ncall   1870 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    1c88 <all_possible_moves+0x228>\nmov    0x8(%rsp),%rsi\nmovslq %r11d,%rax\nadd    $0x1,%r11d\nlea    (%rsi,%rax,2),%rax\nmov    %bl,(%rax)\nmov    %bpl,0x1(%rax)\njmp    1c88 <all_possible_moves+0x228>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x4,%eax\njne    1bf1 <all_possible_moves+0x191>\nsub    $0x40,%ebx\nsub    $0x31,%r11d\nmovslq %ebx,%rbx\nmovslq %r11d,%r11\nlea    (%rdi,%rbx,8),%rax\nmovzbl -0x8(%r11,%rax,1),%eax\nand    $0xffffffdf,%eax\ntest   %r9d,%r9d\njne    1e50 <all_possible_moves+0x3f0>\ncmp    $0x42,%al\njne    1bf1 <all_possible_moves+0x191>\nmovzbl 0x10(%rsp),%eax\nmovzbl 0x18(%rsp),%edx\nmov    %r15d,%esi\nmovzbl 0x1c(%rsp),%ebx\nlea    0x40(%rax,%rdx,1),%r11d\nmovzbl 0x14(%rsp),%eax\nmov    %r14d,%edx\nmovsbl %r11b,%ecx\nlea    0x30(%rax,%rbx,1),%ebx\nmovsbl %bl,%r8d\ncall   1870 <check_move_error_1_to_5>\ntest   %eax,%eax\njne    1bf1 <all_possible_moves+0x191>\nmov    0x8(%rsp),%rsi\nmovslq %r13d,%rax\nadd    $0x1,%r13d\nlea    (%rsi,%rax,2),%rax\nmov    %r11b,(%rax)\nmov    %bl,0x1(%rax)\njmp    1bf1 <all_possible_moves+0x191>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x57,%al\nje     1df8 <all_possible_moves+0x398>\njmp    1bf1 <all_possible_moves+0x191>\nnopl   0x0(%rax)\ncmp    $0x57,%al\nje     1d72 <all_possible_moves+0x312>\njmp    1c88 <all_possible_moves+0x228>\nnopl   (%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "board_cost", "content": "// function to return board cost for board_t input\nint board_cost(board_t board_input) {\n\tint b_count=0, B_count=0, w_count=0, W_count=0;\n\tfor (int i=0; i<BOARD_SIZE;i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\tif (board_input[i][j] == CELL_BPIECE) {\n\t\t\t\tb_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_BTOWER) {\n\t\t\t\tB_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_WPIECE) {\n\t\t\t\tw_count += 1;\n\t\t\t}\n\t\t\tif (board_input[i][j] == CELL_WTOWER) {\n\t\t\t\tW_count += 1;\n\t\t\t}\n\t\t}\n\t}\n\tint cost = b_count + (3 * B_count) - w_count - (3 * W_count);\n\treturn cost;\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "board_cost", "address": "0x1f30", "label": "board_cost", "content": "int __fastcall board_cost(unsigned __int8 (*board_input)[8])\n{\n  unsigned __int8 *v1; // rcx\n  unsigned __int8 *v2; // r10\n  int v3; // esi\n  int v4; // r8d\n  int v5; // edi\n  int v6; // r9d\n  unsigned __int8 *v7; // rax\n  unsigned __int8 v8; // dl\n\n  v1 = &(*board_input)[8];\n  v2 = &(*board_input)[72];\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  do\n  {\n    v7 = v1 - 8;\n    do\n    {\n      while ( 1 )\n      {\n        v8 = *v7;\n        if ( *v7 != 98 )\n          break;\n        ++v7;\n        ++v6;\n        if ( v7 == v1 )\n          goto LABEL_9;\n      }\n      switch ( v8 )\n      {\n        case 'B':\n          ++v5;\n          break;\n        case 'w':\n          ++v4;\n          break;\n        case 'W':\n          ++v3;\n          break;\n      }\n      ++v7;\n    }\n    while ( v7 != v1 );\nLABEL_9:\n    v1 = v7 + 8;\n  }\n  while ( v7 + 8 != v2 );\n  return -3 * v3 + v6 + 3 * v5 - v4;\n}\n"}, "pseudo_normalize": "int board_cost(unsigned char (*board_input)[8]) {\n  unsigned char *v1;\n  unsigned char *v2;\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  unsigned char *v7;\n  unsigned char v8;\n  v1 = &(*board_input)[8];\n  v2 = &(*board_input)[72];\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  v6 = 0;\n  do {\n    v7 = v1 - 8;\n    do {\n      while (1) {\n        v8 = *v7;\n        if (*v7 != 98) break;\n        ++v7;\n        ++v6;\n        if (v7 == v1) goto LABEL_9;\n      }\n      switch (v8) {\n        case 'B':\n          ++v5;\n          break;\n        case 'w':\n          ++v4;\n          break;\n        case 'W':\n          ++v3;\n          break;\n      }\n      ++v7;\n    } while (v7 != v1);\n  LABEL_9:\n    v1 = v7 + 8;\n  } while (v7 + 8 != v2);\n  return -3 * v3 + v6 + 3 * v5 - v4;\n}", "binary": "checkers/checkers.host.O2", "assembly": "<board_cost>:\nendbr64\nlea    0x8(%rdi),%rcx\nlea    0x48(%rdi),%r10\nxor    %esi,%esi\nxor    %r8d,%r8d\nxor    %edi,%edi\nxor    %r9d,%r9d\ncs nopw 0x0(%rax,%rax,1)\nlea    -0x8(%rcx),%rax\njmp    1f77 <board_cost+0x47>\ncs nopw 0x0(%rax,%rax,1)\ncmp    $0x42,%dl\nje     1fb8 <board_cost+0x88>\ncmp    $0x77,%dl\njne    1faa <board_cost+0x7a>\nadd    $0x1,%r8d\nadd    $0x1,%rax\ncmp    %rcx,%rax\nje     1f8c <board_cost+0x5c>\nmovzbl (%rax),%edx\ncmp    $0x62,%dl\njne    1f60 <board_cost+0x30>\nadd    $0x1,%rax\nadd    $0x1,%r9d\ncmp    %rcx,%rax\njne    1f77 <board_cost+0x47>\nlea    0x8(%rax),%rcx\ncmp    %r10,%rcx\njne    1f50 <board_cost+0x20>\nlea    (%rdi,%rdi,2),%eax\nlea    0x0(,%rsi,4),%edx\nadd    %r9d,%eax\nsub    %edx,%esi\nsub    %r8d,%eax\nadd    %esi,%eax\nret\ncmp    $0x57,%dl\njne    1f6e <board_cost+0x3e>\nadd    $0x1,%esi\njmp    1f6e <board_cost+0x3e>\nnopl   0x0(%rax)\nadd    $0x1,%edi\njmp    1f6e <board_cost+0x3e>\nnopl   (%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "change_board", "content": "// adjust a board_t variable with a given input move\nvoid change_board(board_t* board, char col1, char row1, char col2, char row2) {\n\tchar being_moved_temp = piece_at_location(*board, col1, row1);\n\t\n\t// make source cell empty\n\t(*board)[char_to_col(col1) - 1][char_to_row(row1) - 1] = CELL_EMPTY;\n\t\n\t// consider, if piece reached end, it must be promoted\n\tif ((being_moved_temp == CELL_BPIECE) && (row2 == END_ROW_BLACK)) {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1]\n\t\t\t= CELL_BTOWER;\n\t}\n\telse if ((being_moved_temp == CELL_WPIECE) && (row2 == END_ROW_WHITE)) {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1]\n\t\t\t= CELL_WTOWER;\n\t}\n\t// otherwise make target cell the piece being moved\n\telse {\n\t\t(*board)[char_to_col(col2) - 1][char_to_row(row2) - 1] \n\t\t\t= being_moved_temp;\n\t}\n\t// if capturing, captured middle piece must be removed as well\n\tif (libmin_abs(char_to_col(col2) - char_to_col(col1)) == CAPTURE_JUMP) {\n\t\tint middle_col = min(char_to_col(col1), char_to_col(col2)) + 1;\n\t\tint middle_row = min(char_to_row(row1), char_to_row(row2)) + 1;\n\t\t(*board)[middle_col - 1][middle_row - 1] = CELL_EMPTY;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "change_board", "address": "0x1960", "label": "change_board", "content": "void __fastcall change_board(board_t *board, char col1, char row1, char col2, char row2)\n{\n  int v6; // esi\n  __int64 v9; // rax\n  int v11; // ebx\n  unsigned __int8 v12; // r8\n  int v13; // eax\n  int v14; // eax\n  __int64 v15; // rcx\n  __int64 v16; // rbx\n  int v17; // esi\n  int v18; // eax\n\n  v6 = row1;\n  v9 = row1 - 49;\n  v11 = col2;\n  v12 = (*board)[col1 - 65][v9];\n  (*board)[col1 - 65][v9] = 48;\n  v13 = col2 - 65;\n  if ( v12 == 98 && row2 == 49 )\n  {\n    (*board)[v13][0] = 66;\n  }\n  else if ( v12 == 119 && row2 == 56 )\n  {\n    (*board)[v13][7] = 87;\n  }\n  else\n  {\n    (*board)[v13 - 6][row2 - 1] = v12;\n  }\n  v14 = libmin_abs(col2 - col1);\n  v15 = col1 - 64;\n  if ( v14 == 2 )\n  {\n    v16 = v11 - 64;\n    if ( col1 >= col2 )\n      v15 = v16;\n    v17 = v6 - 48;\n    v18 = row2 - 48;\n    if ( row1 < row2 )\n      v18 = v17;\n    (*board)[v15][v18] = 48;\n  }\n}\n"}, "pseudo_normalize": "void change_board(board_t *board, char col1, char row1, char col2, char row2) {\n  int v6;\n  long long v9;\n  int v11;\n  unsigned char v12;\n  int v13;\n  int v14;\n  long long v15;\n  long long v16;\n  int v17;\n  int v18;\n  v6 = row1;\n  v9 = row1 - 49;\n  v11 = col2;\n  v12 = (*board)[col1 - 65][v9];\n  (*board)[col1 - 65][v9] = 48;\n  v13 = col2 - 65;\n  if (v12 == 98 && row2 == 49) {\n    (*board)[v13][0] = 66;\n  } else if (v12 == 119 && row2 == 56) {\n    (*board)[v13][7] = 87;\n  } else {\n    (*board)[v13 - 6][row2 - 1] = v12;\n  }\n  v14 = libmin_abs(col2 - col1);\n  v15 = col1 - 64;\n  if (v14 == 2) {\n    v16 = v11 - 64;\n    if (col1 >= col2) v15 = v16;\n    v17 = v6 - 48;\n    v18 = row2 - 48;\n    if (row1 < row2) v18 = v17;\n    (*board)[v15][v18] = 48;\n  }\n}", "binary": "checkers/checkers.host.O2", "assembly": "<change_board>:\nendbr64\npush   %r15\nmov    %esi,%r15d\nmovsbl %dl,%esi\npush   %r14\nlea    -0x31(%rsi),%eax\nmov    %ecx,%r14d\npush   %r13\nmov    %edx,%r13d\nmovsbl %r15b,%edx\ncltq\npush   %r12\nmov    %r8d,%r12d\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nlea    -0x40(%rdx),%ebx\nmovslq %ebx,%rcx\nmovsbl %r14b,%ebx\nlea    (%rdi,%rcx,8),%rdi\nsub    $0x18,%rsp\nmovzbl -0x8(%rax,%rdi,1),%r8d\nlea    -0x41(%rdx),%edi\nmovslq %edi,%rdi\nlea    0x0(%rbp,%rdi,8),%rdi\nmovb   $0x30,(%rdi,%rax,1)\nlea    -0x41(%rbx),%eax\ncmp    $0x62,%r8b\njne    1a20 <change_board+0xc0>\ncmp    $0x31,%r12b\njne    1a20 <change_board+0xc0>\ncltq\nmovb   $0x42,0x0(%rbp,%rax,8)\nmov    %ebx,%edi\nmov    %rcx,0x8(%rsp)\nsub    %edx,%edi\nmov    %esi,0x4(%rsp)\ncall   2a00 <libmin_abs>\nmov    0x4(%rsp),%esi\nmov    0x8(%rsp),%rcx\ncmp    $0x2,%eax\njne    1a0e <change_board+0xae>\nsub    $0x40,%ebx\nmovsbl %r12b,%eax\ncmp    %r14b,%r15b\nmovslq %ebx,%rbx\ncmovge %rbx,%rcx\nsub    $0x30,%esi\nsub    $0x30,%eax\ncmp    %r12b,%r13b\ncmovl  %esi,%eax\nlea    0x0(%rbp,%rcx,8),%rdx\ncltq\nmovb   $0x30,(%rdx,%rax,1)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\ncmp    $0x77,%r8b\njne    1a38 <change_board+0xd8>\ncmp    $0x38,%r12b\njne    1a38 <change_board+0xd8>\ncltq\nmovb   $0x57,0x7(%rbp,%rax,8)\njmp    19c6 <change_board+0x66>\nnopl   (%rax)\nmovsbl %r12b,%edi\ncltq\nsub    $0x31,%edi\nlea    0x0(%rbp,%rax,8),%rax\nmovslq %edi,%rdi\nmov    %r8b,(%rax,%rdi,1)\njmp    19c6 <change_board+0x66>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "char_to_col", "content": "// convert column coordinate character position into column number\n// offset from A + 1 to give col number\nint char_to_col(char col) { \n\tint ascii_value = (int) col;\n\treturn ascii_value - ASCII_A + 1;}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "char_to_col", "address": "0x1760", "label": "char_to_col", "content": "int __fastcall char_to_col(char col)\n{\n  return col - 64;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O2", "assembly": "<char_to_col>:\nendbr64\nmovsbl %dil,%eax\nsub    $0x40,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "char_to_row", "content": "// convert row coordinate character position into row number\n// offset from 1 + 1 to give row number\nint char_to_row(char row) { \n\tint ascii_value = (int) row;\n\treturn ascii_value - ASCII_1 + 1;}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "char_to_row", "address": "0x1770", "label": "char_to_row", "content": "int __fastcall char_to_row(char row)\n{\n  return row - 48;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O2", "assembly": "<char_to_row>:\nendbr64\nmovsbl %dil,%eax\nsub    $0x30,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "check_move_error_1_to_5", "content": "// lazy evaluation, systematically check for move errors 1-5\n\t// if any found, print error message and return error code\nint check_move_error_1_to_5(board_t board_input, \n\tchar col1, char row1, char col2, char row2, int black_action) {\n\t// error 1\n\tif (outside_of_board(col1, row1)) {\n\t\treturn 1;\n\t}\n\t// error 2\n\tif (outside_of_board(col2, row2)) {\n\t\treturn 2;\n\t}\n\t// error 3\n\tif (piece_at_location(board_input, col1, row1) == CELL_EMPTY) {\n\t\treturn 3;\n\t}\n\t// error 4\n\tif (piece_at_location(board_input, col2, row2) != CELL_EMPTY) {\n\t\treturn 4;\n\t}\n\t// error 5 \n\tif (black_action) {\n\t\tif ((piece_at_location(board_input, col1, row1) == CELL_WPIECE)\n\t\t\t|| \n\t\t(piece_at_location(board_input, col1, row1) == CELL_WTOWER)) {\n\t\t\treturn 5;\n\t\t}\n\t}\n\telse {\n\t\tif ((piece_at_location(board_input, col1, row1) == CELL_BPIECE)\n\t\t\t|| \n\t\t(piece_at_location(board_input, col1, row1) == CELL_BTOWER)) {\n\t\t\treturn 5;\n\t\t}\n\t}\n\treturn NO_ERRORS_1_TO_5;\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "check_move_error_1_to_5", "address": "0x1870", "label": "check_move_error_1_to_5", "content": "int __fastcall check_move_error_1_to_5(\n        unsigned __int8 (*board_input)[8],\n        char col1,\n        char row1,\n        char col2,\n        char row2,\n        int black_action)\n{\n  unsigned __int8 v6; // dl\n  int result; // eax\n  unsigned __int8 v8; // r8\n  unsigned __int8 v9; // dl\n  char v10; // dl\n\n  if ( (unsigned __int8)(col1 - 65) > 7u )\n    return 1;\n  v6 = row1 - 49;\n  if ( v6 > 7u )\n    return 1;\n  if ( (unsigned __int8)(col2 - 65) > 7u )\n    return 2;\n  v8 = row2 - 49;\n  if ( v8 > 7u )\n    return 2;\n  v9 = (*board_input)[8 * (char)(col1 - 64) - 8 + (char)v6];\n  if ( v9 == 48 )\n    return 3;\n  result = 4;\n  if ( (*board_input)[8 * (char)(col2 - 64) - 8 + (char)v8] == 48 )\n  {\n    v10 = v9 & 0xDF;\n    if ( black_action )\n      return 5 * (v10 == 87);\n    else\n      return 5 * (v10 == 66);\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int check_move_error_1_to_5(unsigned char (*board_input)[8], char col1,\n                            char row1, char col2, char row2, int black_action) {\n  unsigned char v6;\n  int result;\n  unsigned char v8;\n  unsigned char v9;\n  char v10;\n  if ((unsigned char)(col1 - 65) > 7u) return 1;\n  v6 = row1 - 49;\n  if (v6 > 7u) return 1;\n  if ((unsigned char)(col2 - 65) > 7u) return 2;\n  v8 = row2 - 49;\n  if (v8 > 7u) return 2;\n  v9 = (*board_input)[8 * (char)(col1 - 64) - 8 + (char)v6];\n  if (v9 == 48) return 3;\n  result = 4;\n  if ((*board_input)[8 * (char)(col2 - 64) - 8 + (char)v8] == 48) {\n    v10 = v9 & 223;\n    if (black_action)\n      return 5 * (v10 == 87);\n    else\n      return 5 * (v10 == 66);\n  }\n  return result;\n}", "binary": "checkers/checkers.host.O2", "assembly": "<check_move_error_1_to_5>:\nendbr64\nmov    %esi,%eax\nlea    -0x41(%rsi),%esi\ncmp    $0x7,%sil\nja     1887 <check_move_error_1_to_5+0x17>\nsub    $0x31,%edx\ncmp    $0x7,%dl\njbe    1890 <check_move_error_1_to_5+0x20>\nmov    $0x1,%eax\nret\nnopl   (%rax)\nlea    -0x41(%rcx),%esi\ncmp    $0x7,%sil\nja     18a3 <check_move_error_1_to_5+0x33>\nsub    $0x31,%r8d\ncmp    $0x7,%r8b\njbe    18b0 <check_move_error_1_to_5+0x40>\nmov    $0x2,%eax\nret\nnopl   0x0(%rax)\nsub    $0x40,%eax\nmovsbq %dl,%rdx\nmovsbq %al,%rax\nlea    (%rdi,%rax,8),%rax\nmovzbl -0x8(%rdx,%rax,1),%edx\ncmp    $0x30,%dl\nje     18f9 <check_move_error_1_to_5+0x89>\nsub    $0x40,%ecx\nmovsbq %r8b,%r8\nmov    $0x4,%eax\nmovsbq %cl,%rcx\nlea    (%rdi,%rcx,8),%rcx\ncmpb   $0x30,-0x8(%r8,%rcx,1)\njne    18fe <check_move_error_1_to_5+0x8e>\nand    $0xffffffdf,%edx\ntest   %r9d,%r9d\nje     18ff <check_move_error_1_to_5+0x8f>\nxor    %eax,%eax\ncmp    $0x57,%dl\nsete   %al\nlea    (%rax,%rax,4),%eax\nret\nmov    $0x3,%eax\nret\nxor    %eax,%eax\ncmp    $0x42,%dl\nsete   %al\nlea    (%rax,%rax,4),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "col_to_char", "content": "// reverse char_to_col\nchar col_to_char(int col) {return (char) (ASCII_A + col - 1);}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "col_to_char", "address": "0x1780", "label": "col_to_char", "content": "char __fastcall col_to_char(int col)\n{\n  return col + 64;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O2", "assembly": "<col_to_char>:\nendbr64\nlea    0x40(%rdi),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "fill_print_initial", "content": "#include \"libmin.h\"\n\n#include \"consttypes.h\"\n#include \"functions.h\"\n\n// fill and print information on the initial board configuration\nvoid fill_print_initial(board_t* board) {\n\t// specify initial setup \n\tlibmin_printf(\"BOARD SIZE: %dx%d\\n\", BOARD_SIZE, BOARD_SIZE);\n\tlibmin_printf(\"#BLACK PIECES: %d\\n\", ORIGINAL_PIECES_COUNT);\n\tlibmin_printf(\"#WHITE PIECES: %d\\n\", ORIGINAL_PIECES_COUNT);\n\t\n\t// fill board with the original board configuration\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\tint filled = 0; \n\t\t\tfor (int k=0; k<ORIGINAL_PIECES_COUNT; k++) {\n\t\t\t\tif ((char_to_col(white_initial_squares[k][0]) == i + 1) && \n\t\t\t\t\t(char_to_row(white_initial_squares[k][1]) == j + 1)) {\n\t\t\t\t\t\t(*board)[i][j] = CELL_WPIECE;\n\t\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k=0; k<ORIGINAL_PIECES_COUNT; k++) {\n\t\t\t\tif ((char_to_col(black_initial_squares[k][0]) == i + 1) && \n\t\t\t\t\t(char_to_row(black_initial_squares[k][1]) == j + 1)) {\n\t\t\t\t\t\t(*board)[i][j] = CELL_BPIECE;\n\t\t\t\t\t\tfilled = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (filled == 0) {\n\t\t\t\t(*board)[i][j] = '0';\n\t\t\t}\n\t\t}\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "fill_print_initial", "address": "0x1630", "label": "fill_print_initial", "content": "void __fastcall fill_print_initial(board_t *board)\n{\n  int v2; // ecx\n  unsigned __int8 *v3; // r9\n  int v4; // r8d\n  char *v5; // rax\n  int v6; // r10d\n  char *v7; // rax\n\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  v2 = 0;\n  do\n  {\n    ++v2;\n    v3 = (unsigned __int8 *)board;\n    v4 = 0;\n    do\n    {\n      ++v4;\n      v5 = white_initial_squares;\n      v6 = 0;\n      do\n      {\n        while ( v2 != *v5 - 64 || v5[1] - 48 != v4 )\n        {\n          v5 += 2;\n          if ( &white_initial_squares[24] == v5 )\n            goto LABEL_8;\n        }\n        v5 += 2;\n        *v3 = 119;\n        v6 = 1;\n      }\n      while ( &white_initial_squares[24] != v5 );\nLABEL_8:\n      v7 = black_initial_squares;\n      do\n      {\n        while ( v2 != *v7 - 64 || v7[1] - 48 != v4 )\n        {\n          v7 += 2;\n          if ( &black_initial_squares[24] == v7 )\n            goto LABEL_13;\n        }\n        v7 += 2;\n        *v3 = 98;\n        v6 = 1;\n      }\n      while ( &black_initial_squares[24] != v7 );\nLABEL_13:\n      if ( !v6 )\n        *v3 = 48;\n      ++v3;\n    }\n    while ( v4 != 8 );\n    board = (board_t *)((char *)board + 8);\n  }\n  while ( v2 != 8 );\n}\n"}, "pseudo_normalize": "void fill_print_initial(board_t *board) {\n  int v2;\n  unsigned char *v3;\n  int v4;\n  char *v5;\n  int v6;\n  char *v7;\n  libmin_printf(\"BOARD SIZE: %dx%d\\n\", 8, 8);\n  libmin_printf(\"#BLACK PIECES: %d\\n\", 12);\n  libmin_printf(\"#WHITE PIECES: %d\\n\", 12);\n  v2 = 0;\n  do {\n    ++v2;\n    v3 = (unsigned char *)board;\n    v4 = 0;\n    do {\n      ++v4;\n      v5 = white_initial_squares;\n      v6 = 0;\n      do {\n        while (v2 != *v5 - 64 || v5[1] - 48 != v4) {\n          v5 += 2;\n          if (&white_initial_squares[24] == v5) goto LABEL_8;\n        }\n        v5 += 2;\n        *v3 = 119;\n        v6 = 1;\n      } while (&white_initial_squares[24] != v5);\n    LABEL_8:\n      v7 = black_initial_squares;\n      do {\n        while (v2 != *v7 - 64 || v7[1] - 48 != v4) {\n          v7 += 2;\n          if (&black_initial_squares[24] == v7) goto LABEL_13;\n        }\n        v7 += 2;\n        *v3 = 98;\n        v6 = 1;\n      } while (&black_initial_squares[24] != v7);\n    LABEL_13:\n      if (!v6) *v3 = 48;\n      ++v3;\n    } while (v4 != 8);\n    board = (board_t *)((char *)board + 8);\n  } while (v2 != 8);\n}", "binary": "checkers/checkers.host.O2", "assembly": "<fill_print_initial>:\nendbr64\npush   %rbx\nmov    $0x8,%edx\nmov    %rdi,%rbx\nmov    $0x8,%esi\nlea    0x3a15(%rip),%rdi\nxor    %eax,%eax\ncall   4290 <libmin_printf>\nmov    $0xc,%esi\nlea    0x3a15(%rip),%rdi\nxor    %eax,%eax\ncall   4290 <libmin_printf>\nmov    $0xc,%esi\nlea    0x3a15(%rip),%rdi\nxor    %eax,%eax\ncall   4290 <libmin_printf>\nmov    %rbx,%r11\nxor    %ecx,%ecx\nlea    0x6a46(%rip),%rdi\nlea    0x6a5f(%rip),%rsi\nadd    $0x1,%ecx\nmov    %r11,%r9\nxor    %r8d,%r8d\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%r8d\nlea    0x6a2d(%rip),%rax\nxor    %r10d,%r10d\njmp    16b9 <fill_print_initial+0x89>\nnopl   0x0(%rax,%rax,1)\nadd    $0x2,%rax\ncmp    %rax,%rsi\nje     16e8 <fill_print_initial+0xb8>\nmovsbl (%rax),%edx\nsub    $0x40,%edx\ncmp    %edx,%ecx\njne    16b0 <fill_print_initial+0x80>\nmovsbl 0x1(%rax),%edx\nsub    $0x30,%edx\ncmp    %r8d,%edx\njne    16b0 <fill_print_initial+0x80>\nadd    $0x2,%rax\nmovb   $0x77,(%r9)\nmov    $0x1,%r10d\ncmp    %rax,%rsi\njne    16b9 <fill_print_initial+0x89>\nnopw   0x0(%rax,%rax,1)\nlea    0x69c1(%rip),%rax\njmp    1701 <fill_print_initial+0xd1>\nnopl   0x0(%rax)\nadd    $0x2,%rax\ncmp    %rax,%rdi\nje     1730 <fill_print_initial+0x100>\nmovsbl (%rax),%edx\nsub    $0x40,%edx\ncmp    %edx,%ecx\njne    16f8 <fill_print_initial+0xc8>\nmovsbl 0x1(%rax),%edx\nsub    $0x30,%edx\ncmp    %r8d,%edx\njne    16f8 <fill_print_initial+0xc8>\nadd    $0x2,%rax\nmovb   $0x62,(%r9)\nmov    $0x1,%r10d\ncmp    %rax,%rdi\njne    1701 <fill_print_initial+0xd1>\nnopw   0x0(%rax,%rax,1)\ntest   %r10d,%r10d\njne    1739 <fill_print_initial+0x109>\nmovb   $0x30,(%r9)\nadd    $0x1,%r9\ncmp    $0x8,%r8d\njne    1698 <fill_print_initial+0x68>\nadd    $0x8,%r11\ncmp    $0x8,%ecx\njne    1689 <fill_print_initial+0x59>\npop    %rbx\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "free_tree", "content": "// free up the space taken by the tree, and the linked lists in the nodes\n\t// done recursively\nvoid free_tree(tree_node_t* node) {\n\t// base case, node is leaf\n\tif (node->children_count == 0) {\n\t\tlibmin_free(node);\n\t}\n\t// recursive case, have to recurse down to the leaf of the node first\n\telse {\n\t\t// we need to kill each child node...that sounds horrible...\n\t\t\t// 'free' each child node...better...\n\t\tlinked_list_member_t* list_member = (node->children_list).first;\n\t\t\t// list_member is used as an iterating item\n\t\ttree_node_t* child_node;\n\t\tfor (int i=0; i<(node->children_count); i++) {\n\t\t\tchild_node = (tree_node_t*)(list_member->child_node);\n\t\t\tfree_tree(child_node);\n\t\t\t\n\t\t\t// once we free the subtree fathered by the child\n\t\t\t\t// we are free to unlink the list member too\n\t\t\tlinked_list_member_t* redundant_list_member = list_member;\n\t\t\tlist_member = list_member->next;\n\t\t\tlibmin_free(redundant_list_member);\n\t\t}\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "free_tree", "address": "0x2460", "label": "free_tree", "content": "void __fastcall free_tree(tree_node_t *node)\n{\n  int children_count; // r11d\n  int v2; // r10d\n  int v3; // r9d\n  int v4; // r8d\n  int v5; // edi\n  int v6; // esi\n  _QWORD *v7; // r15\n  _QWORD *v8; // r12\n  int v9; // ecx\n  bool v10; // cc\n  __int64 *v11; // r13\n  __int64 v12; // rbp\n  int v13; // edx\n  _QWORD *v14; // r12\n  int v15; // ebx\n  __int64 v16; // r14\n  int v17; // eax\n  bool v18; // cc\n  __int64 v19; // r15\n  int v20; // eax\n  __int64 v21; // rbx\n  int v22; // r14d\n  void *v23; // rdi\n  _QWORD *v24; // r14\n  int v25; // eax\n  _QWORD *v26; // rbx\n  int v27; // ecx\n  __int64 *v28; // rbx\n  void **v29; // rbx\n  void **v30; // rbx\n  void **v31; // rbx\n  void **v32; // rbx\n  linked_list_member_t *next; // rbx\n  _QWORD *v34; // [rsp+8h] [rbp-C0h]\n  int v35; // [rsp+10h] [rbp-B8h]\n  int v36; // [rsp+14h] [rbp-B4h]\n  void **block; // [rsp+18h] [rbp-B0h]\n  _QWORD *v38; // [rsp+20h] [rbp-A8h]\n  int v39; // [rsp+28h] [rbp-A0h]\n  int v40; // [rsp+2Ch] [rbp-9Ch]\n  void *v41; // [rsp+30h] [rbp-98h]\n  _QWORD *v42; // [rsp+38h] [rbp-90h]\n  void **m; // [rsp+40h] [rbp-88h]\n  void *v44; // [rsp+48h] [rbp-80h]\n  int v45; // [rsp+50h] [rbp-78h]\n  int v46; // [rsp+54h] [rbp-74h]\n  void **k; // [rsp+58h] [rbp-70h]\n  void *v48; // [rsp+60h] [rbp-68h]\n  linked_list_member_t *redundant_list_member; // [rsp+68h] [rbp-60h]\n  void *child_node; // [rsp+70h] [rbp-58h]\n  void **j; // [rsp+78h] [rbp-50h]\n  int i; // [rsp+80h] [rbp-48h]\n  int v53; // [rsp+84h] [rbp-44h]\n\n  children_count = node->children_count;\n  if ( children_count )\n  {\n    if ( children_count > 0 )\n    {\n      i = 0;\n      for ( redundant_list_member = node->children_list.first; ; redundant_list_member = next )\n      {\n        v2 = *((_DWORD *)redundant_list_member->child_node + 19);\n        child_node = redundant_list_member->child_node;\n        if ( v2 )\n        {\n          if ( v2 > 0 )\n          {\n            v53 = 0;\n            for ( j = (void **)*((_QWORD *)child_node + 10); ; j = v32 )\n            {\n              v3 = *((_DWORD *)*j + 19);\n              v48 = *j;\n              if ( v3 )\n              {\n                if ( v3 > 0 )\n                {\n                  v46 = 0;\n                  for ( k = (void **)*((_QWORD *)v48 + 10); ; k = v31 )\n                  {\n                    v4 = *((_DWORD *)*k + 19);\n                    v44 = *k;\n                    if ( v4 )\n                    {\n                      if ( v4 > 0 )\n                      {\n                        v45 = 0;\n                        for ( m = (void **)*((_QWORD *)v44 + 10); ; m = v30 )\n                        {\n                          v5 = *((_DWORD *)*m + 19);\n                          v41 = *m;\n                          if ( v5 )\n                          {\n                            if ( v5 > 0 )\n                            {\n                              v36 = 0;\n                              for ( block = (void **)*((_QWORD *)v41 + 10); ; block = v29 )\n                              {\n                                v6 = *((_DWORD *)*block + 19);\n                                v34 = *block;\n                                if ( v6 )\n                                {\n                                  if ( v6 > 0 )\n                                  {\n                                    v35 = 0;\n                                    v7 = (_QWORD *)v34[10];\n                                    v8 = (_QWORD *)*v7;\n                                    v9 = *(_DWORD *)(*v7 + 76LL);\n                                    v10 = v9 <= 0;\n                                    if ( v9 )\n                                    {\nLABEL_19:\n                                      if ( v10 )\n                                        goto LABEL_32;\n                                      v39 = 0;\n                                      v11 = (__int64 *)v8[10];\n                                      v38 = v7;\n                                      v42 = v8;\n                                      while ( 1 )\n                                      {\n                                        v12 = *v11;\n                                        v13 = *(_DWORD *)(*v11 + 76);\n                                        if ( v13 )\n                                        {\n                                          if ( v13 > 0 )\n                                          {\n                                            v14 = *(_QWORD **)(v12 + 80);\n                                            v15 = 0;\n                                            v16 = *v14;\n                                            v17 = *(_DWORD *)(*v14 + 76LL);\n                                            v18 = v17 <= 0;\n                                            if ( v17 )\n                                            {\nLABEL_24:\n                                              if ( !v18 )\n                                              {\n                                                v19 = *(_QWORD *)(v16 + 80);\n                                                v20 = v15;\n                                                v21 = v16;\n                                                v22 = 0;\n                                                do\n                                                {\n                                                  v40 = v20;\n                                                  ++v22;\n                                                  free_tree(*(tree_node_t **)v19);\n                                                  v23 = (void *)v19;\n                                                  v19 = *(_QWORD *)(v19 + 8);\n                                                  libmin_free(v23);\n                                                  v20 = v40;\n                                                }\n                                                while ( v22 < *(_DWORD *)(v21 + 76) );\n                                                v15 = v40;\n                                              }\n                                              goto LABEL_28;\n                                            }\n                                            while ( 1 )\n                                            {\n                                              libmin_free((void *)v16);\nLABEL_28:\n                                              v24 = (_QWORD *)v14[1];\n                                              ++v15;\n                                              libmin_free(v14);\n                                              if ( v15 >= *(_DWORD *)(v12 + 76) )\n                                                break;\n                                              v14 = v24;\n                                              v16 = *v24;\n                                              v25 = *(_DWORD *)(v16 + 76);\n                                              v18 = v25 <= 0;\n                                              if ( v25 )\n                                                goto LABEL_24;\n                                            }\n                                          }\n                                        }\n                                        else\n                                        {\n                                          libmin_free((void *)*v11);\n                                        }\n                                        v28 = (__int64 *)v11[1];\n                                        libmin_free(v11);\n                                        if ( ++v39 >= *((_DWORD *)v42 + 19) )\n                                        {\n                                          v7 = v38;\n                                          goto LABEL_32;\n                                        }\n                                        v11 = v28;\n                                      }\n                                    }\n                                    while ( 1 )\n                                    {\n                                      libmin_free(v8);\nLABEL_32:\n                                      v26 = (_QWORD *)v7[1];\n                                      libmin_free(v7);\n                                      if ( ++v35 >= *((_DWORD *)v34 + 19) )\n                                        break;\n                                      v7 = v26;\n                                      v8 = (_QWORD *)*v26;\n                                      v27 = *(_DWORD *)(*v26 + 76LL);\n                                      v10 = v27 <= 0;\n                                      if ( v27 )\n                                        goto LABEL_19;\n                                    }\n                                  }\n                                }\n                                else\n                                {\n                                  libmin_free(*block);\n                                }\n                                v29 = (void **)block[1];\n                                libmin_free(block);\n                                if ( ++v36 >= *((_DWORD *)v41 + 19) )\n                                  break;\n                              }\n                            }\n                          }\n                          else\n                          {\n                            libmin_free(*m);\n                          }\n                          v30 = (void **)m[1];\n                          libmin_free(m);\n                          if ( ++v45 >= *((_DWORD *)v44 + 19) )\n                            break;\n                        }\n                      }\n                    }\n                    else\n                    {\n                      libmin_free(*k);\n                    }\n                    v31 = (void **)k[1];\n                    libmin_free(k);\n                    if ( ++v46 >= *((_DWORD *)v48 + 19) )\n                      break;\n                  }\n                }\n              }\n              else\n              {\n                libmin_free(*j);\n              }\n              v32 = (void **)j[1];\n              libmin_free(j);\n              if ( ++v53 >= *((_DWORD *)child_node + 19) )\n                break;\n            }\n          }\n        }\n        else\n        {\n          libmin_free(redundant_list_member->child_node);\n        }\n        next = redundant_list_member->next;\n        libmin_free(redundant_list_member);\n        if ( node->children_count <= ++i )\n          break;\n      }\n    }\n  }\n  else\n  {\n    libmin_free(node);\n  }\n}\n"}, "pseudo_normalize": "void free_tree(tree_node_t *node) {\n  int children_count;\n  int v2;\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  uint64_t *v7;\n  uint64_t *v8;\n  int v9;\n  bool v10;\n  long long *v11;\n  long long v12;\n  int v13;\n  uint64_t *v14;\n  int v15;\n  long long v16;\n  int v17;\n  bool v18;\n  long long v19;\n  int v20;\n  long long v21;\n  int v22;\n  void *v23;\n  uint64_t *v24;\n  int v25;\n  uint64_t *v26;\n  int v27;\n  long long *v28;\n  void **v29;\n  void **v30;\n  void **v31;\n  void **v32;\n  linked_list_member_t *next;\n  uint64_t *v34;\n  int v35;\n  int v36;\n  void **block;\n  uint64_t *v38;\n  int v39;\n  int v40;\n  void *v41;\n  uint64_t *v42;\n  void **m;\n  void *v44;\n  int v45;\n  int v46;\n  void **k;\n  void *v48;\n  linked_list_member_t *redundant_list_member;\n  void *child_node;\n  void **j;\n  int i;\n  int v53;\n  children_count = node->children_count;\n  if (children_count) {\n    if (children_count > 0) {\n      i = 0;\n      for (redundant_list_member = node->children_list.first;;\n           redundant_list_member = next) {\n        v2 = *((uint32_t *)redundant_list_member->child_node + 19);\n        child_node = redundant_list_member->child_node;\n        if (v2) {\n          if (v2 > 0) {\n            v53 = 0;\n            for (j = (void **)*((uint64_t *)child_node + 10);; j = v32) {\n              v3 = *((uint32_t *)*j + 19);\n              v48 = *j;\n              if (v3) {\n                if (v3 > 0) {\n                  v46 = 0;\n                  for (k = (void **)*((uint64_t *)v48 + 10);; k = v31) {\n                    v4 = *((uint32_t *)*k + 19);\n                    v44 = *k;\n                    if (v4) {\n                      if (v4 > 0) {\n                        v45 = 0;\n                        for (m = (void **)*((uint64_t *)v44 + 10);; m = v30) {\n                          v5 = *((uint32_t *)*m + 19);\n                          v41 = *m;\n                          if (v5) {\n                            if (v5 > 0) {\n                              v36 = 0;\n                              for (block = (void **)*((uint64_t *)v41 + 10);;\n                                   block = v29) {\n                                v6 = *((uint32_t *)*block + 19);\n                                v34 = *block;\n                                if (v6) {\n                                  if (v6 > 0) {\n                                    v35 = 0;\n                                    v7 = (uint64_t *)v34[10];\n                                    v8 = (uint64_t *)*v7;\n                                    v9 = *(uint32_t *)(*v7 + 76LL);\n                                    v10 = v9 <= 0;\n                                    if (v9) {\n                                    LABEL_19:\n                                      if (v10) goto LABEL_32;\n                                      v39 = 0;\n                                      v11 = (long long *)v8[10];\n                                      v38 = v7;\n                                      v42 = v8;\n                                      while (1) {\n                                        v12 = *v11;\n                                        v13 = *(uint32_t *)(*v11 + 76);\n                                        if (v13) {\n                                          if (v13 > 0) {\n                                            v14 = *(uint64_t **)(v12 + 80);\n                                            v15 = 0;\n                                            v16 = *v14;\n                                            v17 = *(uint32_t *)(*v14 + 76LL);\n                                            v18 = v17 <= 0;\n                                            if (v17) {\n                                            LABEL_24:\n                                              if (!v18) {\n                                                v19 = *(uint64_t *)(v16 + 80);\n                                                v20 = v15;\n                                                v21 = v16;\n                                                v22 = 0;\n                                                do {\n                                                  v40 = v20;\n                                                  ++v22;\n                                                  free_tree(\n                                                      *(tree_node_t **)v19);\n                                                  v23 = (void *)v19;\n                                                  v19 = *(uint64_t *)(v19 + 8);\n                                                  libmin_free(v23);\n                                                  v20 = v40;\n                                                } while (\n                                                    v22 <\n                                                    *(uint32_t *)(v21 + 76));\n                                                v15 = v40;\n                                              }\n                                              goto LABEL_28;\n                                            }\n                                            while (1) {\n                                              libmin_free((void *)v16);\n                                            LABEL_28:\n                                              v24 = (uint64_t *)v14[1];\n                                              ++v15;\n                                              libmin_free(v14);\n                                              if (v15 >=\n                                                  *(uint32_t *)(v12 + 76))\n                                                break;\n                                              v14 = v24;\n                                              v16 = *v24;\n                                              v25 = *(uint32_t *)(v16 + 76);\n                                              v18 = v25 <= 0;\n                                              if (v25) goto LABEL_24;\n                                            }\n                                          }\n                                        } else {\n                                          libmin_free((void *)*v11);\n                                        }\n                                        v28 = (long long *)v11[1];\n                                        libmin_free(v11);\n                                        if (++v39 >= *((uint32_t *)v42 + 19)) {\n                                          v7 = v38;\n                                          goto LABEL_32;\n                                        }\n                                        v11 = v28;\n                                      }\n                                    }\n                                    while (1) {\n                                      libmin_free(v8);\n                                    LABEL_32:\n                                      v26 = (uint64_t *)v7[1];\n                                      libmin_free(v7);\n                                      if (++v35 >= *((uint32_t *)v34 + 19))\n                                        break;\n                                      v7 = v26;\n                                      v8 = (uint64_t *)*v26;\n                                      v27 = *(uint32_t *)(*v26 + 76LL);\n                                      v10 = v27 <= 0;\n                                      if (v27) goto LABEL_19;\n                                    }\n                                  }\n                                } else {\n                                  libmin_free(*block);\n                                }\n                                v29 = (void **)block[1];\n                                libmin_free(block);\n                                if (++v36 >= *((uint32_t *)v41 + 19)) break;\n                              }\n                            }\n                          } else {\n                            libmin_free(*m);\n                          }\n                          v30 = (void **)m[1];\n                          libmin_free(m);\n                          if (++v45 >= *((uint32_t *)v44 + 19)) break;\n                        }\n                      }\n                    } else {\n                      libmin_free(*k);\n                    }\n                    v31 = (void **)k[1];\n                    libmin_free(k);\n                    if (++v46 >= *((uint32_t *)v48 + 19)) break;\n                  }\n                }\n              } else {\n                libmin_free(*j);\n              }\n              v32 = (void **)j[1];\n              libmin_free(j);\n              if (++v53 >= *((uint32_t *)child_node + 19)) break;\n            }\n          }\n        } else {\n          libmin_free(redundant_list_member->child_node);\n        }\n        next = redundant_list_member->next;\n        libmin_free(redundant_list_member);\n        if (node->children_count <= ++i) break;\n      }\n    }\n  } else {\n    libmin_free(node);\n  }\n}", "binary": "checkers/checkers.host.O2", "assembly": "<free_tree>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x98,%rsp\nmov    0x4c(%rdi),%r11d\nmov    %rdi,0x88(%rsp)\ntest   %r11d,%r11d\nje     2807 <free_tree+0x3a7>\njle    27f5 <free_tree+0x395>\nmov    0x88(%rsp),%rax\nmovl   $0x0,0x80(%rsp)\nmov    0x50(%rax),%rax\nmov    %rax,0x68(%rsp)\nmov    0x68(%rsp),%rax\nmov    (%rax),%rax\nmov    0x4c(%rax),%r10d\nmov    %rax,0x70(%rsp)\ntest   %r10d,%r10d\nje     27b9 <free_tree+0x359>\njle    27c1 <free_tree+0x361>\nmovl   $0x0,0x84(%rsp)\nmov    0x70(%rsp),%rax\nmov    0x50(%rax),%rax\nmov    %rax,0x78(%rsp)\nmov    0x78(%rsp),%rax\nmov    (%rax),%rax\nmov    0x4c(%rax),%r9d\nmov    %rax,0x60(%rsp)\ntest   %r9d,%r9d\nje     2780 <free_tree+0x320>\njle    2788 <free_tree+0x328>\nmov    0x60(%rsp),%rax\nmovl   $0x0,0x54(%rsp)\nmov    0x50(%rax),%rax\nmov    %rax,0x58(%rsp)\nmov    0x58(%rsp),%rax\nmov    (%rax),%rax\nmov    0x4c(%rax),%r8d\nmov    %rax,0x48(%rsp)\ntest   %r8d,%r8d\nje     274d <free_tree+0x2ed>\njle    2755 <free_tree+0x2f5>\nmov    0x48(%rsp),%rax\nmovl   $0x0,0x50(%rsp)\nmov    0x50(%rax),%rax\nmov    %rax,0x40(%rsp)\nmov    0x40(%rsp),%rax\nmov    (%rax),%rax\nmov    0x4c(%rax),%edi\nmov    %rax,0x30(%rsp)\ntest   %edi,%edi\nje     271a <free_tree+0x2ba>\njle    2722 <free_tree+0x2c2>\nmov    0x30(%rsp),%rax\nmovl   $0x0,0x14(%rsp)\nmov    0x50(%rax),%rax\nmov    %rax,0x18(%rsp)\nmov    0x18(%rsp),%rax\nmov    (%rax),%rax\nmov    0x4c(%rax),%esi\nmov    %rax,0x8(%rsp)\ntest   %esi,%esi\nje     26e7 <free_tree+0x287>\njle    26ef <free_tree+0x28f>\nmov    0x8(%rsp),%rax\nmovl   $0x0,0x10(%rsp)\nmov    0x50(%rax),%r15\nmov    (%r15),%r12\nmov    0x4c(%r12),%ecx\ntest   %ecx,%ecx\nje     26a7 <free_tree+0x247>\njle    2675 <free_tree+0x215>\nmovl   $0x0,0x28(%rsp)\nmov    0x50(%r12),%r13\nmov    %r15,0x20(%rsp)\nmov    %r12,0x38(%rsp)\nmov    0x0(%r13),%rbp\nmov    0x4c(%rbp),%edx\ntest   %edx,%edx\nje     26b8 <free_tree+0x258>\njle    26c0 <free_tree+0x260>\nmov    0x50(%rbp),%r12\nxor    %ebx,%ebx\nmov    (%r12),%r14\nmov    0x4c(%r14),%eax\ntest   %eax,%eax\nje     2664 <free_tree+0x204>\njle    2640 <free_tree+0x1e0>\nxor    %ecx,%ecx\nmov    0x50(%r14),%r15\nmov    %ebx,%eax\nmov    %r14,%rbx\nmov    %ecx,%r14d\nmov    (%r15),%rdi\nmov    %eax,0x2c(%rsp)\nadd    $0x1,%r14d\ncall   2460 <free_tree>\nmov    %r15,%rdi\nmov    0x8(%r15),%r15\ncall   2b70 <libmin_free>\ncmp    0x4c(%rbx),%r14d\nmov    0x2c(%rsp),%eax\njl     2618 <free_tree+0x1b8>\nmov    %eax,%ebx\nmov    %r12,%rdi\nmov    0x8(%r12),%r14\nadd    $0x1,%ebx\ncall   2b70 <libmin_free>\ncmp    0x4c(%rbp),%ebx\njge    26c0 <free_tree+0x260>\nmov    %r14,%r12\nmov    (%r12),%r14\nmov    0x4c(%r14),%eax\ntest   %eax,%eax\njne    2608 <free_tree+0x1a8>\nmov    %r14,%rdi\ncall   2b70 <libmin_free>\njmp    2640 <free_tree+0x1e0>\nxchg   %ax,%ax\nmov    0x20(%rsp),%r15\nmov    %r15,%rdi\nmov    0x8(%r15),%rbx\ncall   2b70 <libmin_free>\nmov    0x8(%rsp),%rdx\naddl   $0x1,0x10(%rsp)\nmov    0x10(%rsp),%eax\ncmp    0x4c(%rdx),%eax\njge    26ef <free_tree+0x28f>\nmov    %rbx,%r15\nmov    (%r15),%r12\nmov    0x4c(%r12),%ecx\ntest   %ecx,%ecx\njne    25c4 <free_tree+0x164>\nmov    %r12,%rdi\ncall   2b70 <libmin_free>\njmp    2675 <free_tree+0x215>\nnopl   0x0(%rax)\nmov    %rbp,%rdi\ncall   2b70 <libmin_free>\nmov    %r13,%rdi\nmov    0x8(%r13),%rbx\ncall   2b70 <libmin_free>\nmov    0x38(%rsp),%rsi\naddl   $0x1,0x28(%rsp)\nmov    0x28(%rsp),%eax\ncmp    0x4c(%rsi),%eax\njge    2670 <free_tree+0x210>\nmov    %rbx,%r13\njmp    25e1 <free_tree+0x181>\nmov    %rax,%rdi\ncall   2b70 <libmin_free>\nmov    0x18(%rsp),%rdi\nmov    0x8(%rdi),%rbx\ncall   2b70 <libmin_free>\nmov    0x30(%rsp),%rsi\naddl   $0x1,0x14(%rsp)\nmov    0x14(%rsp),%eax\ncmp    0x4c(%rsi),%eax\njge    2722 <free_tree+0x2c2>\nmov    %rbx,0x18(%rsp)\njmp    2585 <free_tree+0x125>\nmov    %rax,%rdi\ncall   2b70 <libmin_free>\nmov    0x40(%rsp),%rdi\nmov    0x8(%rdi),%rbx\ncall   2b70 <libmin_free>\nmov    0x48(%rsp),%rsi\naddl   $0x1,0x50(%rsp)\nmov    0x50(%rsp),%eax\ncmp    0x4c(%rsi),%eax\njge    2755 <free_tree+0x2f5>\nmov    %rbx,0x40(%rsp)\njmp    2551 <free_tree+0xf1>\nmov    %rax,%rdi\ncall   2b70 <libmin_free>\nmov    0x58(%rsp),%rdi\nmov    0x8(%rdi),%rbx\ncall   2b70 <libmin_free>\nmov    0x60(%rsp),%rcx\naddl   $0x1,0x54(%rsp)\nmov    0x54(%rsp),%eax\ncmp    0x4c(%rcx),%eax\njge    2788 <free_tree+0x328>\nmov    %rbx,0x58(%rsp)\njmp    251b <free_tree+0xbb>\nmov    %rax,%rdi\ncall   2b70 <libmin_free>\nmov    0x78(%rsp),%rdi\nmov    0x8(%rdi),%rbx\ncall   2b70 <libmin_free>\nmov    0x70(%rsp),%rsi\naddl   $0x1,0x84(%rsp)\nmov    0x84(%rsp),%eax\ncmp    0x4c(%rsi),%eax\njge    27c1 <free_tree+0x361>\nmov    %rbx,0x78(%rsp)\njmp    24e5 <free_tree+0x85>\nmov    %rax,%rdi\ncall   2b70 <libmin_free>\nmov    0x68(%rsp),%rdi\nmov    0x8(%rdi),%rbx\ncall   2b70 <libmin_free>\nmov    0x88(%rsp),%rsi\naddl   $0x1,0x80(%rsp)\nmov    0x80(%rsp),%eax\ncmp    %eax,0x4c(%rsi)\njle    27f5 <free_tree+0x395>\nmov    %rbx,0x68(%rsp)\njmp    24ac <free_tree+0x4c>\nadd    $0x98,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nadd    $0x98,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    2b70 <libmin_free>\nnopl   (%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "generate_node_children", "content": "// find and link node children for a given tree/subtree root \nvoid generate_node_children(tree_node_t* node, int depth) {\n\t// iterate through board to find checkers belonging to the player \n\t\t// note: done in row-major order\n\tint generated_children = 0;\n\tfor (int j=0; j<BOARD_SIZE;j++) {\n\t\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\t\tchar checker = (node->board_state)[i][j];\n\t\t\tif (movable_checker(node->black_action, checker)) {\n\t\t\t\t// if a checker belonging to the colour with action is found\n\t\t\t\t\t// generate all valid moves and create a tree node for each\n\t\t\t\tstatic valid_moves_t valid_moves; \n\t\t\t\tchar col = col_to_char(i+1);\n\t\t\t\tchar row = row_to_char(j+1);\n\t\t\t\tint num_possibles = all_possible_moves((node->board_state), \n\t\t\t\t\tcol, row, valid_moves, (node->black_action));\n\t\t\t\tfor (int k=0; k<num_possibles; k++) {\n\t\t\t\t\t// define the source cell and target cell\n\t\t\t\t\tchar col1 = col;\n\t\t\t\t\tchar row1 = row;\n\t\t\t\t\tchar col2 = valid_moves[k][0];\n\t\t\t\t\tchar row2 = valid_moves[k][1];\n\t\t\t\t\t\n\t\t\t\t\tlink_new_node(node, col1, row1, col2, row2, depth);\n\t\t\t\t\tgenerated_children += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnode->children_count = generated_children;\n\t\t// update children count; useful for accessing tree later\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "generate_node_children", "address": "0x21c0", "label": "generate_node_children", "content": "void __fastcall generate_node_children(tree_node_t *node, int depth)\n{\n  tree_node_t *v2; // r15\n  __int64 v3; // rbx\n  tree_node_t *v4; // r13\n  char v5; // r12\n  int black_action; // r8d\n  char v7; // al\n  char v8; // bp\n  int v9; // eax\n  char *v10; // r15\n  char *v11; // rbx\n  char v12; // cl\n  char v13; // r8\n  unsigned __int8 *board_input; // [rsp+8h] [rbp-60h]\n  __int64 v15; // [rsp+10h] [rbp-58h]\n  int num_possibles; // [rsp+20h] [rbp-48h]\n  int generated_children; // [rsp+24h] [rbp-44h]\n\n  v2 = node;\n  board_input = node->board_state[0];\n  generated_children = 0;\n  do\n  {\n    v3 = 1LL;\n    v4 = v2;\n    v5 = 49 - (_BYTE)node + (_BYTE)v2;\n    do\n    {\n      while ( 1 )\n      {\n        black_action = node->black_action;\n        v7 = *(_BYTE *)(&v4->depth + 2 * v3) & 0xDF;\n        if ( !black_action )\n          break;\n        if ( v7 == 66 )\n          goto LABEL_7;\nLABEL_4:\n        if ( ++v3 == 9 )\n          goto LABEL_11;\n      }\n      if ( v7 != 87 )\n        goto LABEL_4;\nLABEL_7:\n      v8 = v3 + 64;\n      v9 = all_possible_moves(\n             (unsigned __int8 (*)[8])board_input,\n             v3 + 64,\n             v5,\n             (square_t *)valid_moves_0_0,\n             black_action);\n      num_possibles = v9;\n      if ( v9 <= 0 )\n        goto LABEL_4;\n      v10 = valid_moves_0_0;\n      v15 = v3;\n      v11 = &valid_moves_0_0[2 * (v9 - 1) + 2];\n      do\n      {\n        v12 = *v10;\n        v13 = v10[1];\n        v10 += 2;\n        link_new_node(node, v8, v5, v12, v13, depth);\n      }\n      while ( v10 != v11 );\n      generated_children += num_possibles;\n      v3 = v15 + 1;\n    }\n    while ( v15 != 8 );\nLABEL_11:\n    v2 = (tree_node_t *)((char *)&v4->depth + 1);\n  }\n  while ( board_input != (unsigned __int8 *)((char *)&v4->depth + 1) );\n  node->children_count = generated_children;\n}\n"}, "pseudo_normalize": "void generate_node_children(tree_node_t *node, int depth) {\n  tree_node_t *v2;\n  long long v3;\n  tree_node_t *v4;\n  char v5;\n  int black_action;\n  char v7;\n  char v8;\n  int v9;\n  char *v10;\n  char *v11;\n  char v12;\n  char v13;\n  unsigned char *board_input;\n  long long v15;\n  int num_possibles;\n  int generated_children;\n  v2 = node;\n  board_input = node->board_state[0];\n  generated_children = 0;\n  do {\n    v3 = 1LL;\n    v4 = v2;\n    v5 = 49 - (uint8_t)node + (uint8_t)v2;\n    do {\n      while (1) {\n        black_action = node->black_action;\n        v7 = *(uint8_t *)(&v4->depth + 2 * v3) & 223;\n        if (!black_action) break;\n        if (v7 == 66) goto LABEL_7;\n      LABEL_4:\n        if (++v3 == 9) goto LABEL_11;\n      }\n      if (v7 != 87) goto LABEL_4;\n    LABEL_7:\n      v8 = v3 + 64;\n      v9 = all_possible_moves((unsigned char(*)[8])board_input, v3 + 64, v5,\n                              (square_t *)valid_moves_0_0, black_action);\n      num_possibles = v9;\n      if (v9 <= 0) goto LABEL_4;\n      v10 = valid_moves_0_0;\n      v15 = v3;\n      v11 = &valid_moves_0_0[2 * (v9 - 1) + 2];\n      do {\n        v12 = *v10;\n        v13 = v10[1];\n        v10 += 2;\n        link_new_node(node, v8, v5, v12, v13, depth);\n      } while (v10 != v11);\n      generated_children += num_possibles;\n      v3 = v15 + 1;\n    } while (v15 != 8);\n  LABEL_11:\n    v2 = (tree_node_t *)((char *)&v4->depth + 1);\n  } while (board_input != (unsigned char *)((char *)&v4->depth + 1));\n  node->children_count = generated_children;\n}", "binary": "checkers/checkers.host.O2", "assembly": "<generate_node_children>:\nendbr64\npush   %r15\nlea    0x8(%rdi),%rax\nmov    %rdi,%r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rax,0x8(%rsp)\nmov    $0x31,%eax\nsub    %edi,%eax\nmov    %esi,0x2c(%rsp)\nmovl   $0x0,0x24(%rsp)\nmov    %eax,0x28(%rsp)\nnopl   0x0(%rax,%rax,1)\nmov    0x28(%rsp),%eax\nmov    $0x1,%ebx\nmov    %r15,%r13\nlea    (%rax,%r15,1),%r12d\njmp    222a <generate_node_children+0x6a>\nnopw   0x0(%rax,%rax,1)\ncmp    $0x42,%al\nje     2240 <generate_node_children+0x80>\nadd    $0x1,%rbx\ncmp    $0x9,%rbx\nje     22d8 <generate_node_children+0x118>\nmovzbl 0x0(%r13,%rbx,8),%eax\nmov    0x48(%r14),%r8d\nand    $0xffffffdf,%eax\ntest   %r8d,%r8d\njne    2218 <generate_node_children+0x58>\ncmp    $0x57,%al\njne    221c <generate_node_children+0x5c>\nmov    0x8(%rsp),%rdi\nlea    0x40(%rbx),%ebp\nlea    0x6121(%rip),%rcx\nmov    %r12d,%edx\nmov    %ebp,%esi\ncall   1a60 <all_possible_moves>\nmov    %eax,0x20(%rsp)\ntest   %eax,%eax\njle    221c <generate_node_children+0x5c>\nlea    0x6108(%rip),%r15\nlea    -0x1(%rax),%edx\nmov    %r13,0x18(%rsp)\nmov    %r14,%r13\nlea    0x2(%r15),%rcx\nmov    %r12d,%r14d\nmov    0x2c(%rsp),%r12d\nmov    %rbx,0x10(%rsp)\nlea    (%rcx,%rdx,2),%rax\nmov    %rax,%rbx\nmovsbl (%r15),%ecx\nmovsbl 0x1(%r15),%r8d\nmov    %r12d,%r9d\nmov    %r14d,%edx\nmov    %ebp,%esi\nmov    %r13,%rdi\nadd    $0x2,%r15\ncall   20e0 <link_new_node>\ncmp    %rbx,%r15\njne    228b <generate_node_children+0xcb>\nmov    0x10(%rsp),%rbx\nmov    0x20(%rsp),%esi\nmov    %r14d,%r12d\nmov    %r13,%r14\nadd    %esi,0x24(%rsp)\nmov    0x18(%rsp),%r13\nadd    $0x1,%rbx\ncmp    $0x9,%rbx\njne    222a <generate_node_children+0x6a>\nnopl   0x0(%rax,%rax,1)\nmov    %r13,%r15\nadd    $0x1,%r15\ncmp    %r15,0x8(%rsp)\njne    2200 <generate_node_children+0x40>\nmov    0x24(%rsp),%eax\nmov    %eax,0x4c(%r14)\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "generate_tree_depth_3", "content": "// generate a tree of depth 3 containing the tree_node's \nvoid generate_tree_depth_3(tree_node_t* level_0_node) {\n\t// generate the first generation children\n\tgenerate_node_children(level_0_node, 1);\n\t\n\t// generate second generation children for each first generation child\n\tlinked_list_member_t* list_member_1 = (level_0_node->children_list).first;\n\ttree_node_t* level_1_node;\n\tfor (int i=0; i<(level_0_node->children_count); i++) {\n\t\tlevel_1_node = (tree_node_t*)(list_member_1->child_node);\n\t\tgenerate_node_children(level_1_node, 2);\n\t\t\n\t\t// generate third generation children for each second generation child\n\t\tlinked_list_member_t* list_member_2 \n\t\t\t= (level_1_node->children_list).first;\n\t\ttree_node_t* level_2_node;\n\t\tfor (int j=0; j<(level_1_node->children_count); j++) {\n\t\t\tlevel_2_node = (tree_node_t*)(list_member_2->child_node);\n\t\t\tgenerate_node_children(level_2_node, 3);\n\t\t\tlist_member_2 = list_member_2->next;\n\t\t}\n\t\t\n\t\tlist_member_1 = list_member_1->next;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "generate_tree_depth_3", "address": "0x2310", "label": "generate_tree_depth_3", "content": "void __fastcall generate_tree_depth_3(tree_node_t *level_0_node)\n{\n  linked_list_member_t *first; // r13\n  int v2; // r14d\n  tree_node_t *child_node; // r12\n  linked_list_member_t *v4; // rbx\n  int v5; // ebp\n\n  generate_node_children(level_0_node, 1);\n  first = level_0_node->children_list.first;\n  if ( level_0_node->children_count > 0 )\n  {\n    v2 = 0;\n    do\n    {\n      child_node = (tree_node_t *)first->child_node;\n      generate_node_children((tree_node_t *)first->child_node, 2);\n      v4 = child_node->children_list.first;\n      if ( child_node->children_count > 0 )\n      {\n        v5 = 0;\n        do\n        {\n          ++v5;\n          generate_node_children((tree_node_t *)v4->child_node, 3);\n          v4 = v4->next;\n        }\n        while ( child_node->children_count > v5 );\n      }\n      first = first->next;\n      ++v2;\n    }\n    while ( level_0_node->children_count > v2 );\n  }\n}\n"}, "pseudo_normalize": "void generate_tree_depth_3(tree_node_t *level_0_node) {\n  linked_list_member_t *first;\n  int v2;\n  tree_node_t *child_node;\n  linked_list_member_t *v4;\n  int v5;\n  generate_node_children(level_0_node, 1);\n  first = level_0_node->children_list.first;\n  if (level_0_node->children_count > 0) {\n    v2 = 0;\n    do {\n      child_node = (tree_node_t *)first->child_node;\n      generate_node_children((tree_node_t *)first->child_node, 2);\n      v4 = child_node->children_list.first;\n      if (child_node->children_count > 0) {\n        v5 = 0;\n        do {\n          ++v5;\n          generate_node_children((tree_node_t *)v4->child_node, 3);\n          v4 = v4->next;\n        } while (child_node->children_count > v5);\n      }\n      first = first->next;\n      ++v2;\n    } while (level_0_node->children_count > v2);\n  }\n}", "binary": "checkers/checkers.host.O2", "assembly": "<generate_tree_depth_3>:\nendbr64\npush   %r15\nmov    $0x1,%esi\nmov    %rdi,%r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   21c0 <generate_node_children>\nmov    0x4c(%r15),%edx\nmov    0x50(%r15),%r13\ntest   %edx,%edx\njle    2391 <generate_tree_depth_3+0x81>\nxor    %r14d,%r14d\nxchg   %ax,%ax\nmov    0x0(%r13),%r12\nmov    $0x2,%esi\nmov    %r12,%rdi\ncall   21c0 <generate_node_children>\nmov    0x4c(%r12),%eax\nmov    0x50(%r12),%rbx\ntest   %eax,%eax\njle    2383 <generate_tree_depth_3+0x73>\nxor    %ebp,%ebp\nnopl   0x0(%rax)\nmov    (%rbx),%rdi\nmov    $0x3,%esi\nadd    $0x1,%ebp\ncall   21c0 <generate_node_children>\nmov    0x8(%rbx),%rbx\ncmp    %ebp,0x4c(%r12)\njg     2368 <generate_tree_depth_3+0x58>\nmov    0x8(%r13),%r13\nadd    $0x1,%r14d\ncmp    %r14d,0x4c(%r15)\njg     2340 <generate_tree_depth_3+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"}
{"source": {"path": "checkers/functions.c", "function_name": "link_new_node", "content": "void link_new_node(tree_node_t* parent_node,\n\tchar col1, char row1, char col2, char row2, int depth) {\n\t// create a new tree node ready to link\n\t\t// first copy over new board after move is made\n\ttree_node_t* new_node = (tree_node_t*)libmin_malloc(sizeof(tree_node_t));\n\tnew_node->depth = depth;\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\t(new_node->board_state)[i][j] = (parent_node->board_state)[i][j];\n\t\t}\n\t}\n\tchange_board((board_t*)(&(new_node->board_state)), col1, row1, col2, row2);\n\t\n\tnew_node->move_info[0][0] = col1;\n\tnew_node->move_info[0][1] = row1;\n\tnew_node->move_info[1][0] = col2;\n\tnew_node->move_info[1][1] = row2;\n\tnew_node->black_action = !(parent_node->black_action);\n\t\t// change of turn\n\tnew_node->children_list = initial_children;\n\tnew_node->children_count = 0;\n\t\n\t// create a list member to contain the address of the new node, \n\t\t// which is dynamically linked to children_list of the parent node\n\tlinked_list_member_t* new_list_member\n\t\t= (linked_list_member_t*)libmin_malloc(sizeof(linked_list_member_t));\n\tnew_list_member->child_node = (void*)new_node; // raw address of new node\n\tnew_list_member->next = NULL;\n\t\n\t// link the new list member to the parent node children_list\n\tif ((parent_node->children_list).first == NULL) {\n\t\t(parent_node->children_list).first = new_list_member;\n\t}\n\t\n\tif ((parent_node->children_list).last == NULL) {\n\t\t(parent_node->children_list).last = new_list_member;\n\t}\n\telse {\n\t\t((parent_node->children_list).last)->next = new_list_member;\n\t\t(parent_node->children_list).last = new_list_member;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "link_new_node", "address": "0x20e0", "label": "link_new_node", "content": "void __fastcall link_new_node(tree_node_t *parent_node, char col1, char row1, char col2, char row2, int depth)\n{\n  __m128i *v9; // rbx\n  unsigned __int8 *v10; // rax\n  int black_action; // edx\n  __m128i v12; // xmm0\n  linked_list_member_t *v13; // rax\n  bool v14; // zf\n  linked_list_member_t *last; // rdx\n\n  v9 = (__m128i *)libmin_malloc(0x60uLL);\n  v9->m128i_i32[0] = depth;\n  v10 = (unsigned __int8 *)memmove(&v9->m128i_u64[1], parent_node->board_state, 0x40uLL);\n  change_board((board_t *)v10, col1, row1, col2, row2);\n  v9->m128i_i8[4] = col1;\n  v9->m128i_i8[5] = row1;\n  v9->m128i_i8[6] = col2;\n  v9->m128i_i8[7] = row2;\n  black_action = parent_node->black_action;\n  v12 = _mm_loadu_si128((const __m128i *)&initial_children);\n  v9[4].m128i_i32[3] = 0;\n  v9[5] = v12;\n  v9[4].m128i_i32[2] = black_action == 0;\n  v13 = (linked_list_member_t *)libmin_malloc(0x10uLL);\n  v14 = parent_node->children_list.first == 0LL;\n  v13->child_node = v9;\n  v13->next = 0LL;\n  if ( v14 )\n    parent_node->children_list.first = v13;\n  last = parent_node->children_list.last;\n  if ( last )\n    last->next = v13;\n  parent_node->children_list.last = v13;\n}\n"}, "pseudo_normalize": "void link_new_node(tree_node_t *parent_node, char col1, char row1, char col2,\n                   char row2, int depth) {\n  __m128i *v9;\n  unsigned char *v10;\n  int black_action;\n  __m128i v12;\n  linked_list_member_t *v13;\n  bool v14;\n  linked_list_member_t *last;\n  v9 = (__m128i *)libmin_malloc(96uLL);\n  v9->m128i_i32[0] = depth;\n  v10 = (unsigned char *)memmove(&v9->m128i_u64[1], parent_node->board_state,\n                                 64uLL);\n  change_board((board_t *)v10, col1, row1, col2, row2);\n  v9->m128i_i8[4] = col1;\n  v9->m128i_i8[5] = row1;\n  v9->m128i_i8[6] = col2;\n  v9->m128i_i8[7] = row2;\n  black_action = parent_node->black_action;\n  v12 = _mm_loadu_si128((const __m128i *)&initial_children);\n  v9[4].m128i_i32[3] = 0;\n  v9[5] = v12;\n  v9[4].m128i_i32[2] = black_action == 0;\n  v13 = (linked_list_member_t *)libmin_malloc(16uLL);\n  v14 = parent_node->children_list.first == 0LL;\n  v13->child_node = v9;\n  v13->next = 0LL;\n  if (v14) parent_node->children_list.first = v13;\n  last = parent_node->children_list.last;\n  if (last) last->next = v13;\n  parent_node->children_list.last = v13;\n}", "binary": "checkers/checkers.host.O2", "assembly": "<link_new_node>:\nendbr64\npush   %r15\nmov    %esi,%r15d\npush   %r14\nmov    %edx,%r14d\npush   %r13\nmov    %ecx,%r13d\npush   %r12\nmov    %r8d,%r12d\npush   %rbp\nmov    %rdi,%rbp\nmov    $0x60,%edi\npush   %rbx\nsub    $0x18,%rsp\nmov    %r9d,0xc(%rsp)\ncall   2ac0 <libmin_malloc>\nmov    0xc(%rsp),%r9d\nlea    0x8(%rbp),%rsi\nmov    $0x40,%edx\nlea    0x8(%rax),%rdi\nmov    %rax,%rbx\nmov    %r9d,(%rax)\ncall   1110 <memmove@plt>\nmovsbl %r13b,%ecx\nmovsbl %r14b,%edx\nmovsbl %r15b,%esi\nmov    %rax,%rdi\nmovsbl %r12b,%r8d\ncall   1960 <change_board>\nmov    %r15b,0x4(%rbx)\nxor    %eax,%eax\nmov    $0x10,%edi\nmov    %r14b,0x5(%rbx)\nmov    %r13b,0x6(%rbx)\nmov    %r12b,0x7(%rbx)\nmov    0x48(%rbp),%edx\nmovdqu 0x61f9(%rip),%xmm0\nmovl   $0x0,0x4c(%rbx)\ntest   %edx,%edx\nsete   %al\nmovups %xmm0,0x50(%rbx)\nmov    %eax,0x48(%rbx)\ncall   2ac0 <libmin_malloc>\ncmpq   $0x0,0x50(%rbp)\nmov    %rbx,(%rax)\nmovq   $0x0,0x8(%rax)\nje     21b1 <link_new_node+0xd1>\nmov    0x58(%rbp),%rdx\ntest   %rdx,%rdx\nje     219e <link_new_node+0xbe>\nmov    %rax,0x8(%rdx)\nmov    %rax,0x58(%rbp)\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %rax,0x50(%rbp)\njmp    2191 <link_new_node+0xb1>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/checkers.c", "function_name": "main", "content": "int\nmain(int argc, char *argv[])\n{\n  libmin_mopen(infile, \"r\");\n\n  board_t* board = (board_t*)libmin_malloc(sizeof(board_t)); // main board pointer\n\n  fill_print_initial(board);\n  print_board(board);\n    \n  int black_action = 1, action = 1, error; //, board_cost;\n  char col1, row1, col2, row2; \n\t// col1/row1 is source cell,  col2/row2 is target cell\n\t// deliberately kept separate, square_t type not used\n\t\n\t// scan input moves\n\tchar buf[64];\n\tlibmin_mgets(buf, 64, infile);\n\twhile (libmin_sscanf(buf, \"%c%c-%c%c\\n\", &col1, &row1, &col2, &row2)==4) {\n\t\t// check errors 1-5, terminate function if any found\n\t\terror = check_move_error_1_to_5(*board, col1, row1, col2, row2, \n\t\t\tblack_action);\n\t\tif (error) {\n\t\t\tprint_error_message(error);\n\t\t\tlibmin_fail(error);\n\t\t}\n\t\t// check error 6\n\t\t\t// all the possible moves of the source cell are generated\n\t\t\t// and the target cell is checked against those\n\t\tstatic valid_moves_t valid_moves;\n\t\tint num_possibles = all_possible_moves(*board, col1, row1, valid_moves, \n\t\t\tblack_action);\n\t\tint illegal = 1;\n\t\tfor (int i=0;i<num_possibles;i++) {\n\t\t\tif ((valid_moves[i][0] == col2) && (valid_moves[i][1] == row2)) {\n\t\t\t\tillegal = 0;\n\t\t\t}\n\t\t}\n\t\t// if target_cell input is not in all legal moves, it must be illegal\n\t\t\t// return main function with error exit code 6\n\t\tif (illegal) {\n\t\t\tprint_error_message(6);\n\t\t\tlibmin_fail(6);\n\t\t}\n\t\t\n\t\tchange_board(board, col1, row1, col2, row2);\n\t\t\n\t\tprint_move_information(0, black_action, *board, col1, row1, col2, row2, \n\t\t\taction);\n\t\t\n\t\tprint_board(board);\n\t\t\n\t\t// change the action to opposite colour, iterate the move counts\n\t\tblack_action = !black_action;\n\t\taction += 1;\n\n    // get the next move\n    libmin_mgets(buf, 64, infile);\n\t}\n\t\n\tchar next_action = col1;\n\t\t// on last scanf call, col1 will pickup any trailing P or A instruction\n\t\t\t// naming isn't great, hence a reassignment to better variable name\n\t\n\t// stages 1 and 2\n\tint repititions=0; \n\tif (next_action == 'A') { // stage 1\n\t\trepititions = 1;\n\t}\n\tif (next_action == 'P') { // stage 2\n\t\trepititions = 100;\n\t}\n\t\t\t\n\tfor (int i=0; i<repititions; i++) {\n\t\t// stage 1\n\t\t\t// create the level 0 node first, and fill with relevent info.\n\t\ttree_node_t* level_0_node = (tree_node_t*)libmin_malloc(sizeof(tree_node_t));\n\t\tlevel_0_node->depth = 0;\n\t\tfor (int i=0; i<BOARD_SIZE;i++) {\n\t\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\t\t(level_0_node->board_state)[i][j] = (*board)[i][j];\n\t\t\t}\n\t\t}\n\t\tlevel_0_node->black_action = black_action;\n\t\tlevel_0_node->children_count = 0;\n\t\tlevel_0_node->children_list = initial_children;\n\t\t\n\t\tgenerate_tree_depth_3(level_0_node);\n\t\t\n\t\t// check if there isn't any possible moves, indicating game over\n\t\tif (level_0_node->children_count == 0) {\n\t\t\tif (black_action) {\n\t\t\t\tlibmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlibmin_printf(\"%s WIN!\\n\", BLACK);\n        libmin_success();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// now we journey into the tree, and implement the minimax decision rule\n\t\tint best_score = move_score_forced(level_0_node); \n\t\t\t// this is the best possible score we can have\n\t\t\n\t\t// find the choice node which yields this score\n\t\tlinked_list_member_t* list_member = (level_0_node->children_list).first;\n\t\ttree_node_t* choice_node = NULL;\n\t\tfor (int i=0; i<(level_0_node->children_count); i++) {\n\t\t\tchoice_node = (tree_node_t*)(list_member->child_node);\n\t\t\tif (move_score_forced(choice_node) == best_score) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_member = list_member->next;\n\t\t}\n\t\t\n\t\tchange_board(board, \n\t\t\t(choice_node->move_info)[0][0], \n\t\t\t(choice_node->move_info)[0][1],\n\t\t\t(choice_node->move_info)[1][0],\n\t\t\t(choice_node->move_info)[1][1]);\n\t\t\n\t\tprint_move_information(1, black_action, *board, \n\t\t\t(choice_node->move_info)[0][0], \n\t\t\t(choice_node->move_info)[0][1], \n\t\t\t(choice_node->move_info)[1][0], \n\t\t\t(choice_node->move_info)[1][1], \n\t\t\taction);\n\t\t\n\t\tprint_board(board);\n\t\t\n\t\tblack_action = !black_action;\n\t\taction += 1;\n\t\t\n\t\tfree_tree(level_0_node); // free space occupied by the tree\n\t\t\t// no need for it anymore\n\t}\n\t\n\tlibmin_free(board);\n  libmin_success(); // exit program with the success code\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "main", "address": "0x1150", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r14d\n  int v4; // r13d\n  unsigned __int8 *v5; // r15\n  int v6; // eax\n  int v7; // eax\n  char *v8; // rdx\n  int v9; // esi\n  char *v10; // rax\n  int v11; // esi\n  int v12; // edx\n  unsigned __int8 *v13; // r12\n  __m128i *v14; // rax\n  unsigned __int8 *v15; // rcx\n  __m128i *v16; // rbp\n  __m128i *v17; // rsi\n  __int64 i; // rax\n  __m128i v19; // xmm0\n  int v20; // eax\n  __int64 v21; // r15\n  int v22; // ebx\n  __int32 v23; // r13d\n  char *v24; // r14\n  int v25; // [rsp-8h] [rbp-C0h]\n  int black_action; // [rsp+0h] [rbp-B8h]\n  int action; // [rsp+8h] [rbp-B0h]\n  int codea; // [rsp+10h] [rbp-A8h]\n  unsigned __int8 *code; // [rsp+10h] [rbp-A8h]\n  int v30; // [rsp+1Ch] [rbp-9Ch]\n  char v31; // [rsp+2Ch] [rbp-8Ch] BYREF\n  char v32; // [rsp+2Dh] [rbp-8Bh] BYREF\n  char v33; // [rsp+2Eh] [rbp-8Ah] BYREF\n  char v34; // [rsp+2Fh] [rbp-89h] BYREF\n  char s[72]; // [rsp+30h] [rbp-88h] BYREF\n  unsigned __int64 v36; // [rsp+78h] [rbp-40h]\n\n  v3 = 1;\n  v4 = 1;\n  v36 = __readfsqword(0x28u);\n  libmin_mopen(infile, \"r\");\n  v5 = (unsigned __int8 *)libmin_malloc(0x40uLL);\n  fill_print_initial((board_t *)v5);\n  print_board((board_t *)v5);\n  libmin_mgets(s, 0x40uLL, infile);\n  while ( libmin_sscanf(s, \"%c%c-%c%c\\n\", &v31, &v32, &v33, &v34) == 4 )\n  {\n    v6 = check_move_error_1_to_5((unsigned __int8 (*)[8])v5, v31, v32, v33, v34, v4);\n    if ( v6 )\n    {\n      codea = v6;\n      print_error_message(v6);\n      libmin_fail(codea);\n    }\n    v7 = all_possible_moves((unsigned __int8 (*)[8])v5, v31, v32, (square_t *)valid_moves_0, v4);\n    if ( v7 <= 0 )\n      goto LABEL_12;\n    v8 = valid_moves_0;\n    v9 = 1;\n    v10 = &valid_moves_0[2 * (v7 - 1) + 2];\n    do\n    {\n      if ( *v8 == v33 && v8[1] == v34 )\n        v9 = 0;\n      v8 += 2;\n    }\n    while ( v8 != v10 );\n    if ( v9 )\n    {\nLABEL_12:\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board((board_t *)v5, v31, v32, v33, v34);\n    v25 = v3;\n    v11 = v4;\n    v4 ^= 1u;\n    ++v3;\n    print_move_information(0, v11, (unsigned __int8 (*)[8])v5, v31, v32, v33, v34, v25);\n    print_board((board_t *)v5);\n    libmin_mgets(s, 0x40uLL, infile);\n  }\n  action = v3;\n  if ( v31 == 65 )\n  {\n    v12 = 1;\n  }\n  else\n  {\n    v12 = 100;\n    if ( v31 != 80 )\n      goto LABEL_30;\n  }\n  black_action = v4;\n  v13 = v5 + 64;\n  v30 = v3 + v12;\n  code = v5;\n  do\n  {\n    v14 = (__m128i *)libmin_malloc(0x60uLL);\n    v15 = code;\n    v14->m128i_i32[0] = 0;\n    v16 = v14;\n    v17 = v14;\n    do\n    {\n      for ( i = 0LL; i != 8; ++i )\n        v17->m128i_i8[i + 8] = v15[i];\n      v15 += 8;\n      v17 = (__m128i *)((char *)v17 + 8);\n    }\n    while ( v15 != v13 );\n    v19 = _mm_loadu_si128((const __m128i *)&initial_children);\n    v16[4].m128i_i32[3] = 0;\n    v16[4].m128i_i32[2] = black_action;\n    v16[5] = v19;\n    generate_tree_depth_3((tree_node_t *)v16);\n    if ( !v16[4].m128i_i32[3] )\n    {\n      if ( black_action )\n      {\n        libmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", BLACK);\n      libmin_success();\n    }\n    v20 = move_score_forced((tree_node_t *)v16);\n    v21 = v16[5].m128i_i64[0];\n    v22 = v20;\n    if ( v16[4].m128i_i32[3] <= 0 )\n      main_cold();\n    v23 = 0;\n    do\n    {\n      v24 = *(char **)v21;\n      if ( move_score_forced(*(tree_node_t **)v21) == v22 )\n        break;\n      v21 = *(_QWORD *)(v21 + 8);\n      ++v23;\n    }\n    while ( v16[4].m128i_i32[3] > v23 );\n    change_board((board_t *)code, v24[4], v24[5], v24[6], v24[7]);\n    print_move_information(1, black_action, (unsigned __int8 (*)[8])code, v24[4], v24[5], v24[6], v24[7], action);\n    print_board((board_t *)code);\n    ++action;\n    black_action ^= 1u;\n    free_tree((tree_node_t *)v16);\n  }\n  while ( action != v30 );\n  v5 = code;\nLABEL_30:\n  libmin_free(v5);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  unsigned char *v5;\n  int v6;\n  int v7;\n  char *v8;\n  int v9;\n  char *v10;\n  int v11;\n  int v12;\n  unsigned char *v13;\n  __m128i *v14;\n  unsigned char *v15;\n  __m128i *v16;\n  __m128i *v17;\n  long long i;\n  __m128i v19;\n  int v20;\n  long long v21;\n  int v22;\n  int v23;\n  char *v24;\n  int v25;\n  int black_action;\n  int action;\n  int codea;\n  unsigned char *code;\n  int v30;\n  char v31;\n  char v32;\n  char v33;\n  char v34;\n  char s[72];\n  unsigned long long v36;\n  v3 = 1;\n  v4 = 1;\n  v36 = __readfsqword(40u);\n  libmin_mopen(infile, \"r\");\n  v5 = (unsigned char *)libmin_malloc(64uLL);\n  fill_print_initial((board_t *)v5);\n  print_board((board_t *)v5);\n  libmin_mgets(s, 64uLL, infile);\n  while (libmin_sscanf(s, \"%c%c-%c%c\\n\", &v31, &v32, &v33, &v34) == 4) {\n    v6 = check_move_error_1_to_5((unsigned char(*)[8])v5, v31, v32, v33, v34,\n                                 v4);\n    if (v6) {\n      codea = v6;\n      print_error_message(v6);\n      libmin_fail(codea);\n    }\n    v7 = all_possible_moves((unsigned char(*)[8])v5, v31, v32,\n                            (square_t *)valid_moves_0, v4);\n    if (v7 <= 0) goto LABEL_12;\n    v8 = valid_moves_0;\n    v9 = 1;\n    v10 = &valid_moves_0[2 * (v7 - 1) + 2];\n    do {\n      if (*v8 == v33 && v8[1] == v34) v9 = 0;\n      v8 += 2;\n    } while (v8 != v10);\n    if (v9) {\n    LABEL_12:\n      print_error_message(6);\n      libmin_fail(6);\n    }\n    change_board((board_t *)v5, v31, v32, v33, v34);\n    v25 = v3;\n    v11 = v4;\n    v4 ^= 1u;\n    ++v3;\n    print_move_information(0, v11, (unsigned char(*)[8])v5, v31, v32, v33, v34,\n                           v25);\n    print_board((board_t *)v5);\n    libmin_mgets(s, 64uLL, infile);\n  }\n  action = v3;\n  if (v31 == 65) {\n    v12 = 1;\n  } else {\n    v12 = 100;\n    if (v31 != 80) goto LABEL_30;\n  }\n  black_action = v4;\n  v13 = v5 + 64;\n  v30 = v3 + v12;\n  code = v5;\n  do {\n    v14 = (__m128i *)libmin_malloc(96uLL);\n    v15 = code;\n    v14->m128i_i32[0] = 0;\n    v16 = v14;\n    v17 = v14;\n    do {\n      for (i = 0LL; i != 8; ++i) v17->m128i_i8[i + 8] = v15[i];\n      v15 += 8;\n      v17 = (__m128i *)((char *)v17 + 8);\n    } while (v15 != v13);\n    v19 = _mm_loadu_si128((const __m128i *)&initial_children);\n    v16[4].m128i_i32[3] = 0;\n    v16[4].m128i_i32[2] = black_action;\n    v16[5] = v19;\n    generate_tree_depth_3((tree_node_t *)v16);\n    if (!v16[4].m128i_i32[3]) {\n      if (black_action) {\n        libmin_printf(\"%s WIN!\\n\", WHITE);\n        libmin_success();\n      }\n      libmin_printf(\"%s WIN!\\n\", BLACK);\n      libmin_success();\n    }\n    v20 = move_score_forced((tree_node_t *)v16);\n    v21 = v16[5].m128i_i64[0];\n    v22 = v20;\n    if (v16[4].m128i_i32[3] <= 0) main_cold();\n    v23 = 0;\n    do {\n      v24 = *(char **)v21;\n      if (move_score_forced(*(tree_node_t **)v21) == v22) break;\n      v21 = *(uint64_t *)(v21 + 8);\n      ++v23;\n    } while (v16[4].m128i_i32[3] > v23);\n    change_board((board_t *)code, v24[4], v24[5], v24[6], v24[7]);\n    print_move_information(1, black_action, (unsigned char(*)[8])code, v24[4],\n                           v24[5], v24[6], v24[7], action);\n    print_board((board_t *)code);\n    ++action;\n    black_action ^= 1u;\n    free_tree((tree_node_t *)v16);\n  } while (action != v30);\n  v5 = code;\nLABEL_30:\n  libmin_free(v5);\n  libmin_success();\n}", "binary": "checkers/checkers.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nlea    0x3ea7(%rip),%rsi\npush   %r14\nmov    $0x1,%r14d\npush   %r13\nmov    $0x1,%r13d\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x88,%rsp\nmov    0x6ea1(%rip),%rdi\nmov    %fs:0x28,%rax\nmov    %rax,0x78(%rsp)\nxor    %eax,%eax\nlea    0x30(%rsp),%rbx\nlea    0x2f(%rsp),%r12\ncall   2ee0 <libmin_mopen>\nmov    $0x40,%edi\nlea    0x2e(%rsp),%rbp\ncall   2ac0 <libmin_malloc>\nmov    %rax,%r15\nmov    %rax,%rdi\ncall   1630 <fill_print_initial>\nmov    %r15,%rdi\ncall   17a0 <print_board>\nmov    0x6e59(%rip),%rdx\nmov    $0x40,%esi\nmov    %rbx,%rdi\ncall   2d00 <libmin_mgets>\nlea    0x2d(%rsp),%rax\nmov    %rax,0x8(%rsp)\nlea    0x2c(%rsp),%rax\nmov    %rax,(%rsp)\nnopw   0x0(%rax,%rax,1)\nmov    0x8(%rsp),%rcx\nmov    (%rsp),%rdx\nxor    %eax,%eax\nmov    %r12,%r9\nmov    %rbp,%r8\nlea    0x3eea(%rip),%rsi\nmov    %rbx,%rdi\ncall   44a0 <libmin_sscanf>\ncmp    $0x4,%eax\njne    1342 <main+0x1f2>\nmovsbl 0x2e(%rsp),%ecx\nmovsbl 0x2d(%rsp),%edx\nmov    %r15,%rdi\nmov    %r13d,%r9d\nmovsbl 0x2c(%rsp),%esi\nmovsbl 0x2f(%rsp),%r8d\ncall   1870 <check_move_error_1_to_5>\nmov    %eax,%edi\ntest   %eax,%eax\njne    132b <main+0x1db>\nmovsbl 0x2d(%rsp),%edx\nmovsbl 0x2c(%rsp),%esi\nmov    %r13d,%r8d\nmov    %r15,%rdi\nlea    0x70f6(%rip),%rcx\ncall   1a60 <all_possible_moves>\ntest   %eax,%eax\njle    1307 <main+0x1b7>\nlea    0x70e2(%rip),%rdx\nsub    $0x1,%eax\nmovsbl 0x2e(%rsp),%ecx\nmovsbl 0x2f(%rsp),%r8d\nlea    0x2(%rdx),%rdi\nmov    $0x1,%esi\nlea    (%rdi,%rax,2),%rax\ncmp    %cl,(%rdx)\njne    1296 <main+0x146>\nxor    %edi,%edi\ncmp    %r8b,0x1(%rdx)\ncmove  %edi,%esi\nadd    $0x2,%rdx\ncmp    %rax,%rdx\njne    1289 <main+0x139>\ntest   %esi,%esi\njne    1307 <main+0x1b7>\nmovsbl 0x2d(%rsp),%edx\nmovsbl 0x2c(%rsp),%esi\nmov    %r15,%rdi\ncall   1960 <change_board>\nmovsbl 0x2c(%rsp),%ecx\npush   %r14\nmov    %r13d,%esi\nmovsbl 0x37(%rsp),%eax\nmov    %r15,%rdx\nxor    %edi,%edi\nxor    $0x1,%r13d\nadd    $0x1,%r14d\npush   %rax\nmovsbl 0x3e(%rsp),%r9d\nmovsbl 0x3d(%rsp),%r8d\ncall   1fc0 <print_move_information>\nmov    %r15,%rdi\ncall   17a0 <print_board>\nmov    0x6d2e(%rip),%rdx\nmov    %rbx,%rdi\nmov    $0x40,%esi\ncall   2d00 <libmin_mgets>\npop    %rdi\npop    %r8\njmp    11f0 <main+0xa0>\nmov    $0x6,%edi\ncall   1e80 <print_error_message>\nmov    $0x6,%edi\ncall   2a10 <libmin_fail>\nmovsbl 0x2f(%rsp),%r8d\nmovsbl 0x2e(%rsp),%ecx\njmp    12a3 <main+0x153>\nmov    %eax,0x10(%rsp)\ncall   1e80 <print_error_message>\nmov    0x10(%rsp),%edi\ncall   2a10 <libmin_fail>\njmp    1243 <main+0xf3>\nmovzbl 0x2c(%rsp),%eax\nmov    %r14d,0x8(%rsp)\ncmp    $0x41,%al\nje     1522 <main+0x3d2>\nmov    $0x64,%edx\ncmp    $0x50,%al\njne    14d2 <main+0x382>\nadd    0x8(%rsp),%edx\nmov    %r13d,(%rsp)\nlea    0x40(%r15),%r12\nmov    %edx,0x1c(%rsp)\nmov    %r15,0x10(%rsp)\ncs nopw 0x0(%rax,%rax,1)\nmov    $0x60,%edi\ncall   2ac0 <libmin_malloc>\nmov    0x10(%rsp),%rcx\nmovl   $0x0,(%rax)\nmov    %rax,%rbp\nmov    %rax,%rsi\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmovzbl (%rcx,%rax,1),%edx\nmov    %dl,0x8(%rsi,%rax,1)\nadd    $0x1,%rax\ncmp    $0x8,%rax\njne    13a8 <main+0x258>\nadd    $0x8,%rcx\nadd    $0x8,%rsi\ncmp    %r12,%rcx\njne    13a0 <main+0x250>\nmov    (%rsp),%ebx\nmovdqu 0x6f8e(%rip),%xmm0\nmovl   $0x0,0x4c(%rbp)\nmov    %rbp,%rdi\nmov    %ebx,0x48(%rbp)\nmovups %xmm0,0x50(%rbp)\ncall   2310 <generate_tree_depth_3>\nmov    0x4c(%rbp),%esi\ntest   %esi,%esi\njne    1411 <main+0x2c1>\ntest   %ebx,%ebx\nje     1503 <main+0x3b3>\nlea    0x6ca2(%rip),%rsi\nlea    0x3c01(%rip),%rdi\nxor    %eax,%eax\ncall   4290 <libmin_printf>\ncall   4a20 <libmin_success>\nmov    %rbp,%rdi\ncall   23a0 <move_score_forced>\nmov    0x4c(%rbp),%ecx\nmov    0x50(%rbp),%r15\nmov    %eax,%ebx\ntest   %ecx,%ecx\njle    1140 <main.cold>\nxor    %r13d,%r13d\njmp    143e <main+0x2ee>\nnop\nmov    0x8(%r15),%r15\nadd    $0x1,%r13d\ncmp    %r13d,0x4c(%rbp)\njle    144d <main+0x2fd>\nmov    (%r15),%r14\nmov    %r14,%rdi\ncall   23a0 <move_score_forced>\ncmp    %ebx,%eax\njne    1430 <main+0x2e0>\nmov    0x10(%rsp),%r15\nmovsbl 0x6(%r14),%ecx\nmovsbl 0x5(%r14),%edx\nmovsbl 0x4(%r14),%esi\nmovsbl 0x7(%r14),%r8d\nmov    %r15,%rdi\ncall   1960 <change_board>\nmov    0x8(%rsp),%ebx\nmovsbl 0x6(%r14),%r9d\nmov    %r15,%rdx\nmovsbl 0x5(%r14),%r8d\nmovsbl 0x4(%r14),%ecx\nmov    $0x1,%edi\npush   %rbx\nmovsbl 0x7(%r14),%eax\nmov    %r15,%r14\nadd    $0x1,%ebx\npush   %rax\nmov    0x10(%rsp),%r15d\nmov    %r15d,%esi\ncall   1fc0 <print_move_information>\nmov    %r14,%rdi\ncall   17a0 <print_board>\nmov    %r15d,%eax\nmov    %rbp,%rdi\nmov    %ebx,0x18(%rsp)\nxor    $0x1,%eax\nmov    %eax,0x10(%rsp)\ncall   2460 <free_tree>\npop    %rax\npop    %rdx\ncmp    0x1c(%rsp),%ebx\njne    1380 <main+0x230>\nmov    0x10(%rsp),%r15\nmov    %r15,%rdi\ncall   2b70 <libmin_free>\ncall   4a20 <libmin_success>\nmov    0x78(%rsp),%rax\nsub    %fs:0x28,%rax\njne    152c <main+0x3dc>\nadd    $0x88,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x6b9c(%rip),%rsi\nlea    0x3af5(%rip),%rdi\nxor    %eax,%eax\ncall   4290 <libmin_printf>\ncall   4a20 <libmin_success>\njmp    1411 <main+0x2c1>\nmov    $0x1,%edx\njmp    1361 <main+0x211>\ncall   10d0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "min", "content": "// simple function to return the smaller of two integers, \n\t// if it is the same, it returns the number\nint min(int a, int b) {\n\tif (a < b) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn b;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "min", "address": "0x1e70", "label": "min", "content": "int __fastcall min(int a, int b)\n{\n  int result; // eax\n\n  result = b;\n  if ( a <= b )\n    return a;\n  return result;\n}\n"}, "pseudo_normalize": "int min(int a, int b) {\n  int result;\n  result = b;\n  if (a <= b) return a;\n  return result;\n}", "binary": "checkers/checkers.host.O2", "assembly": "<min>:\nendbr64\ncmp    %esi,%edi\nmov    %esi,%eax\ncmovle %edi,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "movable_checker", "content": "// check whether a given square contains a movable checker depending on the turn\nint movable_checker(int black_action, char checker) {\n\tif ((black_action) && ((checker == CELL_BPIECE) || \n\t\t\t(checker == CELL_BTOWER))) {\n\t\treturn 1;\n\t}\n\telse if ((!black_action) && ((checker == CELL_WPIECE) || \n\t\t\t(checker == CELL_WTOWER))) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "movable_checker", "address": "0x20b0", "label": "movable_checker", "content": "int __fastcall movable_checker(int black_action, char checker)\n{\n  char v2; // si\n\n  v2 = checker & 0xDF;\n  if ( black_action )\n    return v2 == 66;\n  else\n    return v2 == 87;\n}\n"}, "pseudo_normalize": "int movable_checker(int black_action, char checker) {\n  char v2;\n  v2 = checker & 223;\n  if (black_action)\n    return v2 == 66;\n  else\n    return v2 == 87;\n}", "binary": "checkers/checkers.host.O2", "assembly": "<movable_checker>:\nendbr64\nand    $0xffffffdf,%esi\ntest   %edi,%edi\nje     20c8 <movable_checker+0x18>\nxor    %eax,%eax\ncmp    $0x42,%sil\nsete   %al\nret\nnopl   (%rax)\nxor    %eax,%eax\ncmp    $0x57,%sil\nsete   %al\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "move_score_forced", "content": "// recursively find the forced best score of an option branch\n\t// applies the minimax decision rule and assumes player rationality\n\t// according to this rule\nint move_score_forced(tree_node_t* node) {\n\t// base case, we have reached a leaf\n\tif (node->children_count == 0) {\n\t\t// note: if the leaf is less than depth 3, we return int_min/max\n\t\t\t// as specified in the assignment\n\t\tif (node->depth != 3) {\n\t\t\tif (node->black_action) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint leaf_cost = board_cost(node->board_state);\n\t\treturn leaf_cost;\n\t}\n\t\n\t// recursive case\n\telse {\n\t\tint max_score = INT_MIN, min_score = INT_MAX;\n\t\tlinked_list_member_t* list_member = (node->children_list).first;\n\t\ttree_node_t* child_node;\n\t\t// iterate through children to find scores\n\t\tfor (int i=0; i<(node->children_count); i++) {\n\t\t\tchild_node = (tree_node_t*)(list_member->child_node);\n\t\t\tint child_score = move_score_forced(child_node);\n\t\t\tif (child_score > max_score) {\n\t\t\t\tmax_score = child_score;\n\t\t\t}\n\t\t\tif (child_score < min_score) {\n\t\t\t\tmin_score = child_score;\n\t\t\t}\n\t\t\tlist_member = list_member->next;\n\t\t}\n\t\t\n\t\t// black and white make rational actions!!\n\t\tif (node->black_action) {\n\t\t\treturn max_score;\n\t\t}\n\t\telse {\n\t\t\treturn min_score;\n\t\t}\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "move_score_forced", "address": "0x23a0", "label": "move_score_forced", "content": "int __fastcall move_score_forced(tree_node_t *node)\n{\n  int children_count; // r13d\n  int v2; // r12d\n  linked_list_member_t *first; // r15\n  int v5; // r14d\n  int v6; // ebx\n  int v7; // eax\n\n  children_count = node->children_count;\n  if ( children_count )\n  {\n    if ( children_count <= 0 )\n    {\n      v6 = 0x7FFFFFFF;\n      v2 = 0x80000000;\n    }\n    else\n    {\n      first = node->children_list.first;\n      v5 = 0;\n      v6 = 0x7FFFFFFF;\n      v2 = 0x80000000;\n      while ( 1 )\n      {\n        v7 = move_score_forced((tree_node_t *)first->child_node);\n        if ( v2 < v7 )\n          v2 = v7;\n        if ( v6 > v7 )\n          v6 = v7;\n        if ( children_count == ++v5 )\n          break;\n        first = first->next;\n      }\n    }\n    if ( !node->black_action )\n      return v6;\n    return v2;\n  }\n  if ( node->depth != 3 )\n    return 0x7FFFFFFF - ((node->black_action == 0) - 1);\n  return board_cost(node->board_state);\n}\n"}, "pseudo_normalize": "int move_score_forced(tree_node_t *node) {\n  int children_count;\n  int v2;\n  linked_list_member_t *first;\n  int v5;\n  int v6;\n  int v7;\n  children_count = node->children_count;\n  if (children_count) {\n    if (children_count <= 0) {\n      v6 = 2147483647;\n      v2 = 2147483648;\n    } else {\n      first = node->children_list.first;\n      v5 = 0;\n      v6 = 2147483647;\n      v2 = 2147483648;\n      while (1) {\n        v7 = move_score_forced((tree_node_t *)first->child_node);\n        if (v2 < v7) v2 = v7;\n        if (v6 > v7) v6 = v7;\n        if (children_count == ++v5) break;\n        first = first->next;\n      }\n    }\n    if (!node->black_action) return v6;\n    return v2;\n  }\n  if (node->depth != 3) return 2147483647 - ((node->black_action == 0) - 1);\n  return board_cost(node->board_state);\n}", "binary": "checkers/checkers.host.O2", "assembly": "<move_score_forced>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\nmov    0x4c(%rdi),%r13d\ntest   %r13d,%r13d\njne    23e8 <move_score_forced+0x48>\ncmpl   $0x3,(%rdi)\nje     2440 <move_score_forced+0xa0>\ncmpl   $0x1,0x48(%rdi)\nmov    $0x7fffffff,%r12d\nsbb    $0xffffffff,%r12d\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\njle    2420 <move_score_forced+0x80>\nmov    0x50(%rdi),%r15\nxor    %r14d,%r14d\nmov    $0x7fffffff,%ebx\nmov    $0x80000000,%r12d\nmov    (%r15),%rdi\ncall   23a0 <move_score_forced>\ncmp    %eax,%r12d\ncmovl  %eax,%r12d\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\nadd    $0x1,%r14d\ncmp    %r14d,%r13d\nje     242b <move_score_forced+0x8b>\nmov    0x8(%r15),%r15\njmp    23fc <move_score_forced+0x5c>\nnop\nmov    $0x7fffffff,%ebx\nmov    $0x80000000,%r12d\nmov    0x48(%rbp),%eax\ntest   %eax,%eax\ncmove  %ebx,%r12d\njmp    23d1 <move_score_forced+0x31>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x8,%rsp\nlea    0x8(%rdi),%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    1f30 <board_cost>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "outside_of_board", "content": "// check if a col/row input is outside of the board\nint outside_of_board(char col, char row) {\n\tif ((char_to_col(col) < 1) || (char_to_col(col) > BOARD_SIZE) \n\t\t|| (char_to_row(row) < 1) || (char_to_row(row) > BOARD_SIZE)) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "outside_of_board", "address": "0x1910", "label": "outside_of_board", "content": "int __fastcall outside_of_board(char col, char row)\n{\n  return (unsigned __int8)(row - 49) > 7u || (unsigned __int8)(col - 65) > 7u;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O2", "assembly": "<outside_of_board>:\nendbr64\nsub    $0x41,%edi\ncmp    $0x7,%dil\nseta   %al\nsub    $0x31,%esi\ncmp    $0x7,%sil\nseta   %dl\nor     %edx,%eax\nmovzbl %al,%eax\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "checkers/functions.c", "function_name": "piece_at_location", "content": "// return piece at a given character col/row input for a board_t input\nchar piece_at_location(board_t board_input, char col, char row) {\n\treturn board_input[char_to_col(col) - 1][char_to_row(row) - 1];\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "piece_at_location", "address": "0x1930", "label": "piece_at_location", "content": "char __fastcall piece_at_location(unsigned __int8 (*board_input)[8], char col, char row)\n{\n  return (*board_input)[8 * col - 569 + row];\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O2", "assembly": "<piece_at_location>:\nendbr64\nmovsbl %sil,%esi\nmovsbl %dl,%edx\nsub    $0x40,%esi\nsub    $0x31,%edx\nmovslq %esi,%rsi\nmovslq %edx,%rdx\nlea    (%rdi,%rsi,8),%rax\nmovzbl -0x8(%rdx,%rax,1),%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "print_board", "content": "// print a nice visual representation of the board given a board_t input\nvoid print_board(board_t* board_input) {\n\tlibmin_printf(\"     A   B   C   D   E   F   G   H\"); \n\t// note: main loop iterating through board row, sub loop iterates column\n\t\t// hence switched around iterating variables for clarity\n\tfor (int j=0; j<BOARD_SIZE; j++) {//row\n\t\tfor (int i=0; i<BOARD_SIZE; i++) {//column\n\t\t\tif (i==0) { \n\t\t\t\tlibmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n\t\t\t\tlibmin_printf(\" %d |\", j + 1);\n\t\t\t}\n\t\t\tif ((*board_input)[i][j] == CELL_EMPTY) {\n\t\t\t\tlibmin_printf(\" . |\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlibmin_printf(\" %c |\", (*board_input)[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tlibmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "print_board", "address": "0x17a0", "label": "print_board", "content": "void __fastcall print_board(board_t *board_input)\n{\n  int v1; // r12d\n  __int64 i; // r15\n  __int64 v4; // rsi\n\n  v1 = 0;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  do\n  {\n    ++v1;\n    for ( i = 0LL; i != 8; ++i )\n    {\n      while ( 1 )\n      {\n        if ( !i )\n        {\n          libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n          libmin_printf(\" %d |\", v1);\n        }\n        v4 = (*board_input)[i][0];\n        if ( (_BYTE)v4 == 48 )\n          break;\n        ++i;\n        libmin_printf(\" %c |\", v4);\n        if ( i == 8 )\n          goto LABEL_8;\n      }\n      libmin_printf(\" . |\");\n    }\nLABEL_8:\n    board_input = (board_t *)((char *)board_input + 1);\n  }\n  while ( v1 != 8 );\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}\n"}, "pseudo_normalize": "void print_board(board_t *board_input) {\n  int v1;\n  long long i;\n  long long v4;\n  v1 = 0;\n  libmin_printf(\"     A   B   C   D   E   F   G   H\");\n  do {\n    ++v1;\n    for (i = 0LL; i != 8; ++i) {\n      while (1) {\n        if (!i) {\n          libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n          libmin_printf(\" %d |\", v1);\n        }\n        v4 = (*board_input)[i][0];\n        if ((uint8_t)v4 == 48) break;\n        ++i;\n        libmin_printf(\" %c |\", v4);\n        if (i == 8) goto LABEL_8;\n      }\n      libmin_printf(\" . |\");\n    }\n  LABEL_8:\n    board_input = (board_t *)((char *)board_input + 1);\n  } while (v1 != 8);\n  libmin_printf(\"\\n   +---+---+---+---+---+---+---+---+\\n\");\n}", "binary": "checkers/checkers.host.O2", "assembly": "<print_board>:\nendbr64\npush   %r15\nxor    %eax,%eax\npush   %r14\nlea    0x3987(%rip),%r14\npush   %r13\nlea    0x38e3(%rip),%r13\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nlea    0x38db(%rip),%rbp\npush   %rbx\nmov    %rdi,%rbx\nlea    0x393e(%rip),%rdi\nsub    $0x8,%rsp\ncall   4290 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r12d\nxor    %r15d,%r15d\njmp    1804 <print_board+0x64>\nnopl   0x0(%rax)\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x1,%r15\ncall   4290 <libmin_printf>\ncmp    $0x8,%r15\nje     1828 <print_board+0x88>\ntest   %r15,%r15\nje     1850 <print_board+0xb0>\nmovzbl (%rbx,%r15,8),%esi\ncmp    $0x30,%sil\njne    17f0 <print_board+0x50>\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%r15\ncall   4290 <libmin_printf>\ncmp    $0x8,%r15\njne    1804 <print_board+0x64>\nadd    $0x1,%rbx\ncmp    $0x8,%r12d\njne    17e0 <print_board+0x40>\nadd    $0x8,%rsp\nmov    %r14,%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    4290 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   4290 <libmin_printf>\nmov    %r12d,%esi\nlea    0x3833(%rip),%rdi\nxor    %eax,%eax\ncall   4290 <libmin_printf>\njmp    1809 <print_board+0x69>\nnopl   (%rax)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "print_error_message", "content": "// simple function to print various error messages\nvoid print_error_message(int error_code) {\n\tif (error_code == 1) {\n\t\tlibmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n\t}\n\tif (error_code == 2) {\n\t\tlibmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n\t}\n\tif (error_code == 3) {\n\t\tlibmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n\t}\n\tif (error_code == 4) {\n\t\tlibmin_printf(\"ERROR: Target cell is not empty.\\n\");\n\t}\n\tif (error_code == 5) {\n\t\tlibmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n\t}\n\tif (error_code == 6) {\n\t\tlibmin_printf(\"ERROR: Illegal action.\\n\");\n\t}\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "print_error_message", "address": "0x1e80", "label": "print_error_message", "content": "void __fastcall print_error_message(int error_code)\n{\n  switch ( error_code )\n  {\n    case 1:\n      libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n      break;\n    case 2:\n      libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n      break;\n    case 3:\n      libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n      break;\n    case 4:\n      libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n      break;\n    case 5:\n      libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n      break;\n    case 6:\n      libmin_printf(\"ERROR: Illegal action.\\n\");\n      break;\n  }\n}\n"}, "pseudo_normalize": "void print_error_message(int error_code) {\n  switch (error_code) {\n    case 1:\n      libmin_printf(\"ERROR: Source cell is outside of the board.\\n\");\n      break;\n    case 2:\n      libmin_printf(\"ERROR: Target cell is outside of the board.\\n\");\n      break;\n    case 3:\n      libmin_printf(\"ERROR: Source cell is emtpy.\\n\");\n      break;\n    case 4:\n      libmin_printf(\"ERROR: Target cell is not empty.\\n\");\n      break;\n    case 5:\n      libmin_printf(\"ERROR: Source cell holds opponent's piece/tower.\\n\");\n      break;\n    case 6:\n      libmin_printf(\"ERROR: Illegal action.\\n\");\n      break;\n  }\n}", "binary": "checkers/checkers.host.O2", "assembly": "<print_error_message>:\nendbr64\nsub    $0x8,%rsp\ncmp    $0x1,%edi\nje     1f18 <print_error_message+0x98>\ncmp    $0x2,%edi\nje     1f00 <print_error_message+0x80>\ncmp    $0x3,%edi\nje     1eb8 <print_error_message+0x38>\ncmp    $0x4,%edi\njne    1ed0 <print_error_message+0x50>\nlea    0x3319(%rip),%rdi\nxor    %eax,%eax\nadd    $0x8,%rsp\njmp    4290 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\nlea    0x31e9(%rip),%rdi\nxor    %eax,%eax\nadd    $0x8,%rsp\njmp    4290 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\ncmp    $0x5,%edi\njne    1ee7 <print_error_message+0x67>\nlea    0x330c(%rip),%rdi\nxor    %eax,%eax\nadd    $0x8,%rsp\njmp    4290 <libmin_printf>\ncmp    $0x6,%edi\njne    1f0e <print_error_message+0x8e>\nlea    0x31d3(%rip),%rdi\nxor    %eax,%eax\nadd    $0x8,%rsp\njmp    4290 <libmin_printf>\nxchg   %ax,%ax\nlea    0x3289(%rip),%rdi\nxor    %eax,%eax\ncall   4290 <libmin_printf>\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\nlea    0x3241(%rip),%rdi\nxor    %eax,%eax\ncall   4290 <libmin_printf>\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "print_move_information", "content": "//print some headers regarding move information\nvoid print_move_information(int generated_move, int black_action, \n\tboard_t board_input, int col1, int row1, int col2, int row2, int action) {\n\tlibmin_printf(\"=====================================\\n\");\n\tif (generated_move) {\n\t\tlibmin_printf(\"*** \");\n\t}\n\tif (black_action) {\n\t\tlibmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", \n\t\t\tBLACK, action, col1, row1, col2, row2);\n\t}\n\telse {\n\t\tlibmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", \n\t\t\tWHITE, action, col1, row1, col2, row2);\n\t}\n\tlibmin_printf(\"BOARD COST: %d\\n\", board_cost(board_input));\n}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "print_move_information", "address": "0x1fc0", "label": "print_move_information", "content": "void __fastcall print_move_information(\n        int generated_move,\n        int black_action,\n        unsigned __int8 (*board_input)[8],\n        int col1,\n        int row1,\n        int col2,\n        int row2,\n        int action)\n{\n  int v12; // eax\n\n  libmin_printf(\"=====================================\\n\");\n  if ( generated_move )\n    libmin_printf(\"*** \");\n  if ( black_action )\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      BLACK,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  else\n    libmin_printf(\n      \"%s ACTION #%d: %c%c-%c%c\\n\",\n      WHITE,\n      action,\n      (unsigned int)col1,\n      (unsigned int)row1,\n      (unsigned int)col2,\n      (unsigned int)row2);\n  v12 = board_cost(board_input);\n  libmin_printf(\"BOARD COST: %d\\n\", v12);\n}\n"}, "pseudo_normalize": "void print_move_information(int generated_move, int black_action,\n                            unsigned char (*board_input)[8], int col1, int row1,\n                            int col2, int row2, int action) {\n  int v12;\n  libmin_printf(\"=====================================\\n\");\n  if (generated_move) libmin_printf(\"*** \");\n  if (black_action)\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", BLACK, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  else\n    libmin_printf(\"%s ACTION #%d: %c%c-%c%c\\n\", WHITE, action,\n                  (unsigned int)col1, (unsigned int)row1, (unsigned int)col2,\n                  (unsigned int)row2);\n  v12 = board_cost(board_input);\n  libmin_printf(\"BOARD COST: %d\\n\", v12);\n}", "binary": "checkers/checkers.host.O2", "assembly": "<print_move_information>:\nendbr64\npush   %r15\nxor    %eax,%eax\npush   %r14\npush   %r13\nmov    %r9d,%r13d\npush   %r12\nmov    %ecx,%r12d\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nmov    %r8d,%ebx\nsub    $0x18,%rsp\nmov    0x50(%rsp),%r15d\nmov    0x58(%rsp),%r14d\nmov    %edi,0xc(%rsp)\nlea    0x322b(%rip),%rdi\nmov    %esi,0x8(%rsp)\ncall   4290 <libmin_printf>\nmov    0xc(%rsp),%r10d\ntest   %r10d,%r10d\njne    2098 <print_move_information+0xd8>\nmov    0x8(%rsp),%edi\ntest   %edi,%edi\nje     2068 <print_move_information+0xa8>\nsub    $0x8,%rsp\nmov    %r12d,%ecx\nlea    0x6084(%rip),%rsi\nxor    %eax,%eax\npush   %r15\nmov    %r13d,%r9d\nmov    %ebx,%r8d\nmov    %r14d,%edx\nlea    0x30ad(%rip),%rdi\ncall   4290 <libmin_printf>\npop    %rcx\npop    %rsi\nmov    %rbp,%rdi\ncall   1f30 <board_cost>\nadd    $0x18,%rsp\nlea    0x30ad(%rip),%rdi\npop    %rbx\nmov    %eax,%esi\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    4290 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\nsub    $0x8,%rsp\nmov    %r14d,%edx\nmov    %r13d,%r9d\nmov    %ebx,%r8d\npush   %r15\nmov    %r12d,%ecx\nlea    0x601f(%rip),%rsi\nxor    %eax,%eax\nlea    0x3059(%rip),%rdi\ncall   4290 <libmin_printf>\npop    %rax\npop    %rdx\njmp    203d <print_move_information+0x7d>\nnopl   0x0(%rax,%rax,1)\nlea    0x303f(%rip),%rdi\nxor    %eax,%eax\ncall   4290 <libmin_printf>\njmp    200c <print_move_information+0x4c>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "checkers/functions.c", "function_name": "row_to_char", "content": "// reverse char_to_row\nchar row_to_char(int row) {return (char) (ASCII_1 + row - 1);}\n"}, "pseudo": {"path": "checkers/checkers.host.O2.pseudo", "function_name": "row_to_char", "address": "0x1790", "label": "row_to_char", "content": "char __fastcall row_to_char(int row)\n{\n  return row + 48;\n}\n"}, "pseudo_normalize": "", "binary": "checkers/checkers.host.O2", "assembly": "<row_to_char>:\nendbr64\nlea    0x30(%rdi),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "cipher/cipher.c", "function_name": "decipher", "content": "void\ndecipher(uint32_t *const in,\n\t uint32_t *const out,\n\t const uint32_t *const key)\n{\n  uint32_t y=in[0], z=in[1], sum=0xC6EF3720, delta=0x9E3779B9;\n  uint32_t a=key[0], b=key[1], c=key[2], d=key[3], n=32;\n\n  /* sum = delta<<5, in general sum = delta * n */\n  while (n-->0)\n    {\n      z -= ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);\n      y -= ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);\n      sum -= delta;\n    }\n  out[0]=y; out[1]=z;\n}\n"}, "pseudo": {"path": "cipher/cipher.host.O2.pseudo", "function_name": "decipher", "address": "0x1360", "label": "decipher", "content": "void __fastcall decipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t v4; // ecx\n  uint32_t v5; // esi\n  uint32_t v6; // r11d\n  uint32_t v7; // r9d\n  uint32_t v8; // r8d\n  uint32_t v9; // edi\n  int v10; // edx\n\n  v4 = in[1];\n  v5 = *in;\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  v10 = -957401312;\n  do\n  {\n    v4 -= (v5 + v10) ^ (v9 + (v5 >> 5)) ^ (v8 + 16 * v5);\n    v5 -= (v4 + v10) ^ (v7 + (v4 >> 5)) ^ (v6 + 16 * v4);\n    v10 += 1640531527;\n  }\n  while ( v10 );\n  *out = v5;\n  out[1] = v4;\n}\n"}, "pseudo_normalize": "void decipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint32_t v7;\n  uint32_t v8;\n  uint32_t v9;\n  int v10;\n  v4 = in[1];\n  v5 = *in;\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  v10 = -957401312;\n  do {\n    v4 -= (v5 + v10) ^ (v9 + (v5 >> 5)) ^ (v8 + 16 * v5);\n    v5 -= (v4 + v10) ^ (v7 + (v4 >> 5)) ^ (v6 + 16 * v4);\n    v10 += 1640531527;\n  } while (v10);\n  *out = v5;\n  out[1] = v4;\n}", "binary": "cipher/cipher.host.O2", "assembly": "<decipher>:\nendbr64\npush   %rbx\nmov    %rsi,%r10\nmov    0x4(%rdi),%ecx\nmov    (%rdi),%esi\nmov    (%rdx),%r11d\nmov    0x4(%rdx),%r9d\nmov    0x8(%rdx),%r8d\nmov    0xc(%rdx),%edi\nmov    $0xc6ef3720,%edx\nmov    %esi,%eax\nmov    %esi,%ebx\nshl    $0x4,%eax\nshr    $0x5,%ebx\nadd    %edi,%ebx\nadd    %r8d,%eax\nxor    %ebx,%eax\nlea    (%rsi,%rdx,1),%ebx\nxor    %ebx,%eax\nsub    %eax,%ecx\nmov    %ecx,%eax\nmov    %ecx,%ebx\nshl    $0x4,%eax\nshr    $0x5,%ebx\nadd    %r9d,%ebx\nadd    %r11d,%eax\nxor    %ebx,%eax\nlea    (%rcx,%rdx,1),%ebx\nxor    %ebx,%eax\nsub    %eax,%esi\nadd    $0x61c88647,%edx\njne    1380 <decipher+0x20>\nmov    %esi,(%r10)\npop    %rbx\nmov    %ecx,0x4(%r10)\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "cipher/cipher.c", "function_name": "encipher", "content": "#include \"libmin.h\"\n\nvoid\nencipher(uint32_t *const in,\n\t uint32_t *const out,\n\t const uint32_t *const key)\n{\n  uint32_t y=in[0], z=in[1], sum=0, delta=0x9E3779B9;\n  uint32_t a=key[0], b=key[1], c=key[2], d=key[3], n=32;\n\n  while (n-->0)\n    {\n      sum += delta;\n      y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);\n      z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);\n    }\n  out[0]=y; out[1]=z;\n}\n"}, "pseudo": {"path": "cipher/cipher.host.O2.pseudo", "function_name": "encipher", "address": "0x12f0", "label": "encipher", "content": "void __fastcall encipher(uint32_t *const in, uint32_t *const out, const uint32_t *const key)\n{\n  uint32_t v4; // ecx\n  uint32_t v5; // esi\n  uint32_t v6; // r11d\n  uint32_t v7; // r9d\n  uint32_t v8; // r8d\n  uint32_t v9; // edi\n  int i; // edx\n\n  v4 = in[1];\n  v5 = *in;\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  for ( i = 0; i != -957401312; v4 += (i + v5) ^ (v9 + (v5 >> 5)) ^ (v8 + 16 * v5) )\n  {\n    i -= 1640531527;\n    v5 += (i + v4) ^ (v7 + (v4 >> 5)) ^ (v6 + 16 * v4);\n  }\n  *out = v5;\n  out[1] = v4;\n}\n"}, "pseudo_normalize": "void encipher(uint32_t *const in, uint32_t *const out,\n              const uint32_t *const key) {\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint32_t v7;\n  uint32_t v8;\n  uint32_t v9;\n  int i;\n  v4 = in[1];\n  v5 = *in;\n  v6 = *key;\n  v7 = key[1];\n  v8 = key[2];\n  v9 = key[3];\n  for (i = 0; i != -957401312;\n       v4 += (i + v5) ^ (v9 + (v5 >> 5)) ^ (v8 + 16 * v5)) {\n    i -= 1640531527;\n    v5 += (i + v4) ^ (v7 + (v4 >> 5)) ^ (v6 + 16 * v4);\n  }\n  *out = v5;\n  out[1] = v4;\n}", "binary": "cipher/cipher.host.O2", "assembly": "<encipher>:\nendbr64\npush   %rbx\nmov    %rsi,%r10\nmov    0x4(%rdi),%ecx\nmov    (%rdi),%esi\nmov    (%rdx),%r11d\nmov    0x4(%rdx),%r9d\nmov    0x8(%rdx),%r8d\nmov    0xc(%rdx),%edi\nxor    %edx,%edx\nnopl   (%rax)\nmov    %ecx,%eax\nmov    %ecx,%ebx\nsub    $0x61c88647,%edx\nshl    $0x4,%eax\nshr    $0x5,%ebx\nadd    %r9d,%ebx\nadd    %r11d,%eax\nxor    %ebx,%eax\nlea    (%rdx,%rcx,1),%ebx\nxor    %ebx,%eax\nadd    %eax,%esi\nmov    %esi,%eax\nmov    %esi,%ebx\nshl    $0x4,%eax\nshr    $0x5,%ebx\nadd    %edi,%ebx\nadd    %r8d,%eax\nxor    %ebx,%eax\nlea    (%rdx,%rsi,1),%ebx\nxor    %ebx,%eax\nadd    %eax,%ecx\ncmp    $0xc6ef3720,%edx\njne    1310 <encipher+0x20>\nmov    %esi,(%r10)\npop    %rbx\nmov    %ecx,0x4(%r10)\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "cipher/cipher.c", "function_name": "main", "content": "int\nmain(void)\n{\n\n  encipher(plaintext, ciphertext, keytext);\n  if (ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1])\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if (newplain[0] != plaintext[0] || newplain[1] != plaintext[1])\n    libmin_fail(2);\n  \n  libmin_printf(\"TEA Cipher results:\\n\");\n  libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n  libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0], ciphertext[1]);\n  libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "cipher/cipher.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  encipher(plaintext, ciphertext, keytext);\n  if ( ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1] )\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if ( newplain[0] == plaintext[0] && newplain[1] == plaintext[1] )\n  {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0], ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  encipher(plaintext, ciphertext, keytext);\n  if (ciphertext[0] != cipherref[0] || ciphertext[1] != cipherref[1])\n    libmin_fail(1);\n  decipher(ciphertext, newplain, keytext);\n  if (newplain[0] == plaintext[0] && newplain[1] == plaintext[1]) {\n    libmin_printf(\"TEA Cipher results:\\n\");\n    libmin_printf(\"  plaintext:  0x%08x 0x%08x\\n\", plaintext[0], plaintext[1]);\n    libmin_printf(\"  ciphertext: 0x%08x 0x%08x\\n\", ciphertext[0],\n                  ciphertext[1]);\n    libmin_printf(\"  newplain:   0x%08x 0x%08x\\n\", newplain[0], newplain[1]);\n    libmin_success();\n  }\n  libmin_fail(2);\n}", "binary": "cipher/cipher.host.O2", "assembly": "<main>:\nendbr64\npush   %r12\nlea    0x3f13(%rip),%r12\nlea    0x3f04(%rip),%rdi\npush   %rbp\nlea    0x417c(%rip),%rbp\nmov    %r12,%rdx\nmov    %rbp,%rsi\nsub    $0x8,%rsp\ncall   12f0 <encipher>\nmov    0x3edf(%rip),%eax\ncmp    %eax,0x4161(%rip)\njne    1147 <main+0x47>\nmov    0x3ed5(%rip),%eax\ncmp    %eax,0x4157(%rip)\nje     1151 <main+0x51>\nmov    $0x1,%edi\ncall   15b0 <libmin_fail>\nmov    %r12,%rdx\nlea    0x4135(%rip),%rsi\nmov    %rbp,%rdi\ncall   1360 <decipher>\nmov    0x3eaf(%rip),%eax\ncmp    %eax,0x4121(%rip)\njne    117f <main+0x7f>\nmov    0x3ea5(%rip),%eax\ncmp    %eax,0x4117(%rip)\nje     1189 <main+0x89>\nmov    $0x2,%edi\ncall   15b0 <libmin_fail>\nlea    0x1e74(%rip),%rdi\nxor    %eax,%eax\ncall   2930 <libmin_printf>\nmov    0x3e7f(%rip),%edx\nmov    0x3e75(%rip),%esi\nxor    %eax,%eax\nlea    0x1e6d(%rip),%rdi\ncall   2930 <libmin_printf>\nmov    0x40e5(%rip),%edx\nmov    0x40db(%rip),%esi\nxor    %eax,%eax\nlea    0x1e70(%rip),%rdi\ncall   2930 <libmin_printf>\nmov    0x40c3(%rip),%edx\nmov    0x40b9(%rip),%esi\nxor    %eax,%eax\nlea    0x1e73(%rip),%rdi\ncall   2930 <libmin_printf>\ncall   2b70 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "congrad/congrad.c", "function_name": "main", "content": "int main(void) {\n    cg_build_matrix(CG_N);\n    cg_solve(CG_N);\n    uint64_t sum = cg_checksum(CG_N*CG_N);\n\n    libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\",\n           CG_N, CG_ITERS, (uint32_t)(sum >> 32), (uint32_t)sum);\n\n    libmin_success();\n}\n"}, "pseudo": {"path": "congrad/congrad.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // edx\n  int v4; // r11d\n  int *v5; // r9\n  int v6; // eax\n  __int64 v7; // rcx\n  __int64 v8; // rcx\n  int v9; // ecx\n  __int64 v10; // rsi\n  int v11; // esi\n  int v12; // edx\n  double *v13; // rax\n  double *v14; // rdx\n  __int64 i; // rax\n  double v16; // xmm0_8\n  double *v17; // rax\n  double v18; // xmm6_8\n  double v19; // xmm0_8\n  int v20; // ebx\n  __int64 v21; // xmm4_8\n  double v22; // xmm5_8\n  __int64 v23; // rax\n  double v24; // xmm2_8\n  double v25; // xmm0_8\n  double *v26; // rsi\n  double v27; // xmm1_8\n  double *v28; // rcx\n  double *v29; // rax\n  double v30; // xmm0_8\n  double v31; // xmm1_8\n  double *v32; // rcx\n  double *v33; // rax\n  double v34; // xmm0_8\n  double *v35; // rax\n  double v36; // xmm1_8\n  double v37; // xmm0_8\n  double *v38; // rax\n  double v39; // xmm0_8\n  unsigned __int64 v40; // rcx\n  double v41; // xmm0_8\n\n  v3 = 0;\n  v4 = 0;\n  v5 = &row_ptr[1];\n  v6 = 1;\n  row_ptr[0] = 0;\n  col_idx[0] = 0;\n  val[0] = 4.0;\n  while ( 1 )\n  {\n    if ( v3 <= 991 )\n    {\n      v7 = v6++;\n      col_idx[v7] = v3 + 32;\n      val[v7] = -1.0;\n    }\n    if ( (v3 & 0x1F) != 0 )\n    {\n      v8 = v6++;\n      col_idx[v8] = v3 - 1;\n      val[v8] = -1.0;\n    }\n    v9 = v3 + 1;\n    if ( v4 != 31 )\n    {\n      v10 = v6++;\n      col_idx[v10] = v9;\n      val[v10] = -1.0;\n    }\n    if ( v3 == 1023 )\n    {\n      row_ptr[1024] = v6;\n      v12 = cg_rng;\n      memset(x, 0, sizeof(x));\n      v13 = b;\n      do\n      {\n        ++v13;\n        v12 = 1664525 * v12 + 1013904223;\n        *(v13 - 1) = (double)(v12 & 0xFFFFFF) * 0.00000005960464477539062;\n      }\n      while ( &b[1024] != v13 );\n      cg_rng = v12;\n      cg_spmv(x, (const double *)&stru_3F8.st_value, v12);\n      for ( i = 0LL; i != 1024; ++i )\n      {\n        v16 = b[i] - Ap[i];\n        r[i] = v16;\n        p[i] = v16;\n      }\n      v17 = &b[-1024];\n      v18 = 0.0;\n      do\n      {\n        v19 = *v17++;\n        v18 = v18 + v19 * v19;\n      }\n      while ( b != v17 );\n      v20 = 25;\n      while ( 1 )\n      {\n        cg_spmv(p, (const double *)&stru_3F8.st_value, (int)v14);\n        v23 = 0LL;\n        v24 = v22;\n        do\n        {\n          v25 = p[v23] * Ap[v23];\n          ++v23;\n          v24 = v24 + v25;\n        }\n        while ( v23 != 1024 );\n        v26 = x;\n        v27 = v18 / v24;\n        v14 = p;\n        v28 = p;\n        v29 = x;\n        do\n        {\n          v30 = *v28;\n          ++v29;\n          ++v28;\n          *(v29 - 1) = v30 * v27 + *(v29 - 1);\n        }\n        while ( val != v29 );\n        *(_QWORD *)&v31 = *(_QWORD *)&v27 ^ v21;\n        v32 = Ap;\n        v33 = r;\n        do\n        {\n          v34 = *v32;\n          ++v33;\n          ++v32;\n          *(v33 - 1) = v34 * v31 + *(v33 - 1);\n        }\n        while ( b != v33 );\n        v35 = r;\n        v36 = v22;\n        do\n        {\n          v37 = *v35++;\n          v36 = v36 + v37 * v37;\n        }\n        while ( b != v35 );\n        if ( v36 < 1.0e-12 )\n          break;\n        v38 = r;\n        do\n        {\n          v39 = *v14;\n          *v14++ = v39 * (v36 / v18) + *v38++;\n        }\n        while ( b != v38 );\n        if ( !--v20 )\n          break;\n        v18 = v36;\n      }\n      v40 = 0x9E3779B97F4A7C15LL;\n      do\n      {\n        v41 = *v26++;\n        v40 ^= (v40 >> 2) + (v40 << 6) + (unsigned int)(int)(v41 * 1000000.0);\n      }\n      while ( val != v26 );\n      libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25, HIDWORD(v40), v40);\n      libmin_success();\n    }\n    *v5 = v6;\n    v11 = v6 + 1;\n    col_idx[v6] = v9;\n    v4 = v9 & 0x1F;\n    val[v6] = 4.0;\n    if ( v9 > 31 )\n    {\n      v6 += 2;\n      col_idx[v11] = v3 - 31;\n      val[v11] = -1.0;\n    }\n    else\n    {\n      ++v6;\n    }\n    ++v5;\n    ++v3;\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int *v5;\n  int v6;\n  long long v7;\n  long long v8;\n  int v9;\n  long long v10;\n  int v11;\n  int v12;\n  double *v13;\n  double *v14;\n  long long i;\n  double v16;\n  double *v17;\n  double v18;\n  double v19;\n  int v20;\n  long long v21;\n  double v22;\n  long long v23;\n  double v24;\n  double v25;\n  double *v26;\n  double v27;\n  double *v28;\n  double *v29;\n  double v30;\n  double v31;\n  double *v32;\n  double *v33;\n  double v34;\n  double *v35;\n  double v36;\n  double v37;\n  double *v38;\n  double v39;\n  unsigned long long v40;\n  double v41;\n  v3 = 0;\n  v4 = 0;\n  v5 = &row_ptr[1];\n  v6 = 1;\n  row_ptr[0] = 0;\n  col_idx[0] = 0;\n  val[0] = 4.0;\n  while (1) {\n    if (v3 <= 991) {\n      v7 = v6++;\n      col_idx[v7] = v3 + 32;\n      val[v7] = -1.0;\n    }\n    if ((v3 & 31) != 0) {\n      v8 = v6++;\n      col_idx[v8] = v3 - 1;\n      val[v8] = -1.0;\n    }\n    v9 = v3 + 1;\n    if (v4 != 31) {\n      v10 = v6++;\n      col_idx[v10] = v9;\n      val[v10] = -1.0;\n    }\n    if (v3 == 1023) {\n      row_ptr[1024] = v6;\n      v12 = cg_rng;\n      memset(x, 0, sizeof(x));\n      v13 = b;\n      do {\n        ++v13;\n        v12 = 1664525 * v12 + 1013904223;\n        *(v13 - 1) = (double)(v12 & 16777215) * 0.00000005960464477539062;\n      } while (&b[1024] != v13);\n      cg_rng = v12;\n      cg_spmv(x, (const double *)&stru_3F8.st_value, v12);\n      for (i = 0LL; i != 1024; ++i) {\n        v16 = b[i] - Ap[i];\n        r[i] = v16;\n        p[i] = v16;\n      }\n      v17 = &b[-1024];\n      v18 = 0.0;\n      do {\n        v19 = *v17++;\n        v18 = v18 + v19 * v19;\n      } while (b != v17);\n      v20 = 25;\n      while (1) {\n        cg_spmv(p, (const double *)&stru_3F8.st_value, (int)v14);\n        v23 = 0LL;\n        v24 = v22;\n        do {\n          v25 = p[v23] * Ap[v23];\n          ++v23;\n          v24 = v24 + v25;\n        } while (v23 != 1024);\n        v26 = x;\n        v27 = v18 / v24;\n        v14 = p;\n        v28 = p;\n        v29 = x;\n        do {\n          v30 = *v28;\n          ++v29;\n          ++v28;\n          *(v29 - 1) = v30 * v27 + *(v29 - 1);\n        } while (val != v29);\n        *(uint64_t *)&v31 = *(uint64_t *)&v27 ^ v21;\n        v32 = Ap;\n        v33 = r;\n        do {\n          v34 = *v32;\n          ++v33;\n          ++v32;\n          *(v33 - 1) = v34 * v31 + *(v33 - 1);\n        } while (b != v33);\n        v35 = r;\n        v36 = v22;\n        do {\n          v37 = *v35++;\n          v36 = v36 + v37 * v37;\n        } while (b != v35);\n        if (v36 < 1.0e-12) break;\n        v38 = r;\n        do {\n          v39 = *v14;\n          *v14++ = v39 * (v36 / v18) + *v38++;\n        } while (b != v38);\n        if (!--v20) break;\n        v18 = v36;\n      }\n      v40 = 11400714819323198485LL;\n      do {\n        v41 = *v26++;\n        v40 ^= (v40 >> 2) + (v40 << 6) + (unsigned int)(int)(v41 * 1000000.0);\n      } while (val != v26);\n      libmin_printf(\"cg: N=%d iters=%d checksum=0x%08x%08x\\n\", 32, 25,\n                    HIDWORD(v40), v40);\n      libmin_success();\n    }\n    *v5 = v6;\n    v11 = v6 + 1;\n    col_idx[v6] = v9;\n    v4 = v9 & 31;\n    val[v6] = 4.0;\n    if (v9 > 31) {\n      v6 += 2;\n      col_idx[v11] = v3 - 31;\n      val[v11] = -1.0;\n    } else {\n      ++v6;\n    }\n    ++v5;\n    ++v3;\n  }\n}", "binary": "congrad/congrad.host.O2", "assembly": "<main>:\nendbr64\nmovsd  0x1f24(%rip),%xmm1\npush   %r14\nxor    %edx,%edx\nxor    %r11d,%r11d\npush   %r13\nmovsd  0x1f1b(%rip),%xmm0\nlea    0x1d180(%rip),%r9\nmov    $0x1,%eax\npush   %r12\nlea    0x1816e(%rip),%r8\nlea    0xe167(%rip),%rdi\npush   %rbp\nmovl   $0x0,0x1d15c(%rip)\npush   %rbx\nmovl   $0x0,0x18151(%rip)\nmovsd  %xmm1,0xe149(%rip)\njmp    1178 <main+0x78>\nnopl   0x0(%rax)\nmovslq %esi,%rsi\nsub    $0x1f,%edx\nadd    $0x2,%eax\nmov    %edx,(%r8,%rsi,4)\nmovsd  %xmm0,(%rdi,%rsi,8)\nadd    $0x4,%r9\nmov    %ecx,%edx\ncmp    $0x3df,%edx\njg     1192 <main+0x92>\nmovslq %eax,%rcx\nlea    0x20(%rdx),%esi\nadd    $0x1,%eax\nmov    %esi,(%r8,%rcx,4)\nmovsd  %xmm0,(%rdi,%rcx,8)\ntest   $0x1f,%dl\nje     11a9 <main+0xa9>\nmovslq %eax,%rcx\nlea    -0x1(%rdx),%esi\nadd    $0x1,%eax\nmov    %esi,(%r8,%rcx,4)\nmovsd  %xmm0,(%rdi,%rcx,8)\nlea    0x1(%rdx),%ecx\ncmp    $0x1f,%r11d\nje     11c1 <main+0xc1>\nmovslq %eax,%rsi\nadd    $0x1,%eax\nmov    %ecx,(%r8,%rsi,4)\nmovsd  %xmm0,(%rdi,%rsi,8)\ncmp    $0x400,%ecx\nje     11f0 <main+0xf0>\nmovslq %eax,%r10\nmov    %ecx,%r11d\nmov    %eax,(%r9)\nlea    0x1(%rax),%esi\nmov    %ecx,(%r8,%r10,4)\nand    $0x1f,%r11d\nmovsd  %xmm1,(%rdi,%r10,8)\ncmp    $0x1f,%ecx\njg     1160 <main+0x60>\nmov    %esi,%eax\njmp    1172 <main+0x72>\nlea    0xc0a9(%rip),%r8\nmov    %eax,0x1e0a3(%rip)\nmov    $0x400,%ecx\nxor    %eax,%eax\nlea    0xa095(%rip),%rbx\nmov    %r8,%rdi\nmov    0x3dfc(%rip),%edx\nmovsd  0x1e24(%rip),%xmm1\nrep stos %rax,%es:(%rdi)\nlea    0x2000(%rbx),%rsi\nmov    %rbx,%rax\nnopl   0x0(%rax)\nimul   $0x19660d,%edx,%edx\npxor   %xmm0,%xmm0\nadd    $0x8,%rax\nadd    $0x3c6ef35f,%edx\nmov    %edx,%ecx\nand    $0xffffff,%ecx\ncvtsi2sd %ecx,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rax)\ncmp    %rax,%rsi\njne    1230 <main+0x130>\nmov    %r8,%rdi\nmov    $0x400,%esi\nmov    %edx,0x3da4(%rip)\nlea    0x402d(%rip),%r13\ncall   1590 <cg_spmv.constprop.0>\nlea    0x8021(%rip),%r14\nxor    %eax,%eax\nlea    0x6018(%rip),%rdi\nnopl   0x0(%rax,%rax,1)\nmovsd  (%rbx,%rax,1),%xmm0\nsubsd  0x0(%r13,%rax,1),%xmm0\nmovsd  %xmm0,(%r14,%rax,1)\nmovsd  %xmm0,(%rdi,%rax,1)\nadd    $0x8,%rax\ncmp    $0x2000,%rax\njne    1290 <main+0x190>\nlea    0x9fe6(%rip),%rbp\npxor   %xmm5,%xmm5\nlea    -0x2000(%rbp),%rax\nmovapd %xmm5,%xmm6\nnopl   0x0(%rax)\nmovsd  (%rax),%xmm0\nadd    $0x8,%rax\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm6\ncmp    %rax,%rbp\njne    12d0 <main+0x1d0>\nmovq   0x1d73(%rip),%xmm4\nmovsd  0x1d53(%rip),%xmm3\nmov    $0x19,%ebx\nlea    0xdf9f(%rip),%r12\nnopl   0x0(%rax)\nmov    $0x400,%esi\ncall   1590 <cg_spmv.constprop.0>\nxor    %eax,%eax\nmovapd %xmm5,%xmm2\nnopl   0x0(%rax,%rax,1)\nmovsd  (%rdi,%rax,1),%xmm0\nmulsd  0x0(%r13,%rax,1),%xmm0\nadd    $0x8,%rax\naddsd  %xmm0,%xmm2\ncmp    $0x2000,%rax\njne    1320 <main+0x220>\nmovapd %xmm6,%xmm1\nlea    0x5f59(%rip),%rdi\nlea    0xbf52(%rip),%rsi\ndivsd  %xmm2,%xmm1\nmov    %rdi,%rdx\nmov    %rdi,%rcx\nmov    %rsi,%rax\nnopl   0x0(%rax,%rax,1)\nmovsd  (%rcx),%xmm0\nadd    $0x8,%rax\nadd    $0x8,%rcx\nmulsd  %xmm1,%xmm0\naddsd  -0x8(%rax),%xmm0\nmovsd  %xmm0,-0x8(%rax)\ncmp    %rax,%r12\njne    1360 <main+0x260>\nxorpd  %xmm4,%xmm1\nlea    0x3f16(%rip),%rcx\nmov    %r14,%rax\nnopl   (%rax)\nmovsd  (%rcx),%xmm0\nadd    $0x8,%rax\nadd    $0x8,%rcx\nmulsd  %xmm1,%xmm0\naddsd  -0x8(%rax),%xmm0\nmovsd  %xmm0,-0x8(%rax)\ncmp    %rax,%rbp\njne    1390 <main+0x290>\nmov    %r14,%rax\nmovapd %xmm5,%xmm1\ncs nopw 0x0(%rax,%rax,1)\nmovsd  (%rax),%xmm0\nadd    $0x8,%rax\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\ncmp    %rax,%rbp\njne    13c0 <main+0x2c0>\ncomisd %xmm1,%xmm3\nja     1420 <main+0x320>\nmovapd %xmm1,%xmm2\nmov    %r14,%rax\ndivsd  %xmm6,%xmm2\ncs nopw 0x0(%rax,%rax,1)\nmovsd  (%rdx),%xmm0\nadd    $0x8,%rax\nadd    $0x8,%rdx\nmulsd  %xmm2,%xmm0\naddsd  -0x8(%rax),%xmm0\nmovsd  %xmm0,-0x8(%rdx)\ncmp    %rax,%rbp\njne    13f0 <main+0x2f0>\nsub    $0x1,%ebx\nje     1420 <main+0x320>\nmovapd %xmm1,%xmm6\njmp    1308 <main+0x208>\nnopl   (%rax)\nmovsd  0x1c28(%rip),%xmm1\nmovabs $0x9e3779b97f4a7c15,%rcx\nnopw   0x0(%rax,%rax,1)\nmovsd  (%rsi),%xmm0\nmov    %rcx,%rdx\nmov    %rcx,%rdi\nadd    $0x8,%rsi\nshl    $0x6,%rdx\nshr    $0x2,%rdi\nmulsd  %xmm1,%xmm0\nadd    %rdi,%rdx\ncvttsd2si %xmm0,%rax\nadd    %rdx,%rax\nxor    %rax,%rcx\ncmp    %rsi,%r12\njne    1438 <main+0x338>\nmov    %ecx,%r8d\nmov    $0x19,%edx\nshr    $0x20,%rcx\nxor    %eax,%eax\nmov    $0x20,%esi\nlea    0x1b89(%rip),%rdi\ncall   2b50 <libmin_printf>\ncall   2d90 <libmin_success>\npop    %rbx\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "board_full", "content": "// Check if board is full.\nint board_full(int board[ROWS][COLS]) {\n    for (int c = 0; c < COLS; c++)\n        if (valid_move(board, c))\n            return 0;\n    return 1;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "board_full", "address": "0x1400", "label": "board_full", "content": "int __fastcall board_full(int (*board)[7])\n{\n  int *v1; // rdx\n  int result; // eax\n\n  v1 = &(*board)[7];\n  while ( 1 )\n  {\n    result = (*board)[0];\n    if ( !(*board)[0] )\n      break;\n    board = (int (*)[7])((char *)board + 4);\n    if ( board == (int (*)[7])v1 )\n      return 1;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int board_full(int (*board)[7]) {\n  int *v1;\n  int result;\n  v1 = &(*board)[7];\n  while (1) {\n    result = (*board)[0];\n    if (!(*board)[0]) break;\n    board = (int(*)[7])((char *)board + 4);\n    if (board == (int(*)[7])v1) return 1;\n  }\n  return result;\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<board_full>:\nendbr64\nlea    0x1c(%rdi),%rdx\nnopl   0x0(%rax,%rax,1)\nmov    (%rdi),%eax\ntest   %eax,%eax\nje     1424 <board_full+0x24>\nadd    $0x4,%rdi\ncmp    %rdx,%rdi\njne    1410 <board_full+0x10>\nmov    $0x1,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "check_win", "content": "// -------------------------------------------------\n// Game Evaluation: Check for win.\n// -------------------------------------------------\n\n// Check horizontal, vertical, and two diagonals for four in a row.\nint check_win(int board[ROWS][COLS], int player) {\n    // Horizontal check\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r][c+1] == player &&\n                board[r][c+2] == player && board[r][c+3] == player)\n                return 1;\n        }\n    }\n    // Vertical check\n    for (int c = 0; c < COLS; c++) {\n        for (int r = 0; r < ROWS - 3; r++) {\n            if (board[r][c] == player && board[r+1][c] == player &&\n                board[r+2][c] == player && board[r+3][c] == player)\n                return 1;\n        }\n    }\n    // Diagonal (positive slope)\n    for (int r = 3; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r-1][c+1] == player &&\n                board[r-2][c+2] == player && board[r-3][c+3] == player)\n                return 1;\n        }\n    }\n    // Diagonal (negative slope)\n    for (int r = 0; r < ROWS - 3; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            if (board[r][c] == player && board[r+1][c+1] == player &&\n                board[r+2][c+2] == player && board[r+3][c+3] == player)\n                return 1;\n        }\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "check_win", "address": "0x1430", "label": "check_win", "content": "int __fastcall check_win(int (*board)[7], int player)\n{\n  int *v3; // rcx\n  int *v4; // rax\n  int *v5; // rcx\n  int *v6; // r8\n  int *v7; // rax\n  int *v8; // rcx\n  int *v9; // r9\n  int *v10; // rsi\n  __int64 v11; // rax\n  int *v12; // rcx\n  int *v13; // rdi\n  int *v14; // rsi\n  int *v15; // r8\n  int *v16; // r9\n  __int64 v17; // rax\n\n  v3 = &(*board)[4];\nLABEL_2:\n  v4 = v3 - 4;\n  while ( *v4 != player || v4[1] != player || v4[2] != player || v4[3] != player )\n  {\n    if ( ++v4 == v3 )\n    {\n      v3 = v4 + 7;\n      if ( v4 + 7 != &(*board)[46] )\n        goto LABEL_2;\n      v5 = &(*board)[21];\n      v6 = &(*board)[28];\nLABEL_7:\n      v7 = v5 - 21;\n      while ( *v7 != player || v7[7] != player || v7[14] != player || v7[21] != player )\n      {\n        v7 += 7;\n        if ( v7 == v5 )\n        {\n          v5 = v7 + 1;\n          if ( v7 + 1 != v6 )\n            goto LABEL_7;\n          v8 = &(*board)[7];\nLABEL_12:\n          v9 = v8;\n          v10 = v8 + 14;\n          v11 = 0LL;\n          v8 += 7;\n          while ( v10[v11] != player || v8[v11 + 1] != player || v9[v11 + 2] != player || v9[v11 - 4] != player )\n          {\n            if ( ++v11 == 4 )\n            {\n              if ( v8 != v6 )\n                goto LABEL_12;\n              v12 = &(*board)[14];\n              v13 = &(*board)[35];\nLABEL_17:\n              v14 = v12 - 14;\n              v15 = v12 - 7;\n              v16 = v12;\n              v17 = 0LL;\n              v12 += 7;\n              while ( v14[v17] != player || v15[v17 + 1] != player || v16[v17 + 2] != player || v12[v17 + 3] != player )\n              {\n                if ( ++v17 == 4 )\n                {\n                  if ( v12 != v13 )\n                    goto LABEL_17;\n                  return 0;\n                }\n              }\n              return 1;\n            }\n          }\n          return 1;\n        }\n      }\n      return 1;\n    }\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int check_win(int (*board)[7], int player) {\n  int *v3;\n  int *v4;\n  int *v5;\n  int *v6;\n  int *v7;\n  int *v8;\n  int *v9;\n  int *v10;\n  long long v11;\n  int *v12;\n  int *v13;\n  int *v14;\n  int *v15;\n  int *v16;\n  long long v17;\n  v3 = &(*board)[4];\nLABEL_2:\n  v4 = v3 - 4;\n  while (*v4 != player || v4[1] != player || v4[2] != player ||\n         v4[3] != player) {\n    if (++v4 == v3) {\n      v3 = v4 + 7;\n      if (v4 + 7 != &(*board)[46]) goto LABEL_2;\n      v5 = &(*board)[21];\n      v6 = &(*board)[28];\n    LABEL_7:\n      v7 = v5 - 21;\n      while (*v7 != player || v7[7] != player || v7[14] != player ||\n             v7[21] != player) {\n        v7 += 7;\n        if (v7 == v5) {\n          v5 = v7 + 1;\n          if (v7 + 1 != v6) goto LABEL_7;\n          v8 = &(*board)[7];\n        LABEL_12:\n          v9 = v8;\n          v10 = v8 + 14;\n          v11 = 0LL;\n          v8 += 7;\n          while (v10[v11] != player || v8[v11 + 1] != player ||\n                 v9[v11 + 2] != player || v9[v11 - 4] != player) {\n            if (++v11 == 4) {\n              if (v8 != v6) goto LABEL_12;\n              v12 = &(*board)[14];\n              v13 = &(*board)[35];\n            LABEL_17:\n              v14 = v12 - 14;\n              v15 = v12 - 7;\n              v16 = v12;\n              v17 = 0LL;\n              v12 += 7;\n              while (v14[v17] != player || v15[v17 + 1] != player ||\n                     v16[v17 + 2] != player || v12[v17 + 3] != player) {\n                if (++v17 == 4) {\n                  if (v12 != v13) goto LABEL_17;\n                  return 0;\n                }\n              }\n              return 1;\n            }\n          }\n          return 1;\n        }\n      }\n      return 1;\n    }\n  }\n  return 1;\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<check_win>:\nendbr64\nmov    %esi,%edx\nlea    0x10(%rdi),%rcx\nlea    0xb8(%rdi),%rsi\nnopl   0x0(%rax)\nlea    -0x10(%rcx),%rax\ncmp    %edx,(%rax)\nje     14f8 <check_win+0xc8>\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    144c <check_win+0x1c>\nlea    0x1c(%rax),%rcx\ncmp    %rsi,%rcx\njne    1448 <check_win+0x18>\nlea    0x54(%rdi),%rcx\nlea    0x70(%rdi),%r8\nxchg   %ax,%ax\nlea    -0x54(%rcx),%rax\ncmp    %edx,(%rax)\nje     1520 <check_win+0xf0>\nadd    $0x1c,%rax\ncmp    %rcx,%rax\njne    1474 <check_win+0x44>\nlea    0x4(%rax),%rcx\ncmp    %r8,%rcx\njne    1470 <check_win+0x40>\nlea    0x1c(%rdi),%rcx\nmov    %rcx,%r9\nlea    0x38(%rcx),%rsi\nxor    %eax,%eax\nadd    $0x1c,%rcx\nlea    -0x1c(%r9),%r10\ncmp    %edx,(%rsi,%rax,1)\nje     1540 <check_win+0x110>\nadd    $0x4,%rax\ncmp    $0x10,%rax\njne    14a3 <check_win+0x73>\ncmp    %r8,%rcx\njne    1492 <check_win+0x62>\nlea    0x38(%rdi),%rcx\nadd    $0x8c,%rdi\nlea    -0x38(%rcx),%rsi\nlea    -0x1c(%rcx),%r8\nmov    %rcx,%r9\nxor    %eax,%eax\nadd    $0x1c,%rcx\ncmp    %edx,(%rsi,%rax,1)\nje     1568 <check_win+0x138>\nadd    $0x4,%rax\ncmp    $0x10,%rax\njne    14d7 <check_win+0xa7>\ncmp    %rdi,%rcx\njne    14c6 <check_win+0x96>\nxor    %eax,%eax\nret\nnopw   0x0(%rax,%rax,1)\ncmp    %edx,0x4(%rax)\njne    1454 <check_win+0x24>\ncmp    %edx,0x8(%rax)\njne    1454 <check_win+0x24>\ncmp    %edx,0xc(%rax)\njne    1454 <check_win+0x24>\nmov    $0x1,%eax\nret\nnopl   0x0(%rax)\ncmp    %edx,0x1c(%rax)\njne    147c <check_win+0x4c>\ncmp    %edx,0x38(%rax)\njne    147c <check_win+0x4c>\ncmp    %edx,0x54(%rax)\njne    147c <check_win+0x4c>\njmp    1513 <check_win+0xe3>\nnopl   (%rax)\ncmp    %edx,0x4(%rcx,%rax,1)\njne    14ac <check_win+0x7c>\ncmp    %edx,0x8(%r9,%rax,1)\njne    14ac <check_win+0x7c>\ncmp    %edx,0xc(%r10,%rax,1)\njne    14ac <check_win+0x7c>\njmp    1513 <check_win+0xe3>\nnopw   0x0(%rax,%rax,1)\ncmp    %edx,0x4(%r8,%rax,1)\njne    14e0 <check_win+0xb0>\ncmp    %edx,0x8(%r9,%rax,1)\njne    14e0 <check_win+0xb0>\ncmp    %edx,0xc(%rcx,%rax,1)\njne    14e0 <check_win+0xb0>\njmp    1513 <check_win+0xe3>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "evaluate_window", "content": "// -------------------------------------------------\n// Heuristic Evaluation Function\n// -------------------------------------------------\n\n// Evaluate a window of 4 cells for scoring.\nint evaluate_window(int window[4], int player) {\n    int score = 0;\n    int opp = (player == 1) ? 2 : 1;\n    int count_player = 0, count_opp = 0, count_empty = 0;\n    for (int i = 0; i < 4; i++) {\n        if (window[i] == player) count_player++;\n        else if (window[i] == opp) count_opp++;\n        else count_empty++;\n    }\n    if (count_player == 4)\n        score += 100;\n    else if (count_player == 3 && count_empty == 1)\n        score += 5;\n    else if (count_player == 2 && count_empty == 2)\n        score += 2;\n    if (count_opp == 3 && count_empty == 1)\n        score -= 4;\n    return score;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "evaluate_window", "address": "0x1590", "label": "evaluate_window", "content": "int __fastcall evaluate_window(int *window, int player)\n{\n  int *v2; // r9\n  int v3; // edx\n  int v4; // r10d\n  int v5; // ecx\n  int result; // eax\n\n  v2 = window + 4;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  do\n  {\n    if ( *window == player )\n    {\n      ++v5;\n    }\n    else if ( *window == (player == 1) + 1 )\n    {\n      ++v4;\n    }\n    else\n    {\n      ++v3;\n    }\n    ++window;\n  }\n  while ( window != v2 );\n  if ( v5 == 4 )\n  {\n    result = 100;\n  }\n  else if ( v5 != 3 || (result = 5, v3 != 1) )\n  {\n    if ( v5 == 2 )\n    {\n      result = 2;\n      if ( v3 == 2 )\n        return result;\n    }\n    result = 0;\n  }\n  if ( v4 == 3 && v3 == 1 )\n    result -= 4;\n  return result;\n}\n"}, "pseudo_normalize": "int evaluate_window(int *window, int player) {\n  int *v2;\n  int v3;\n  int v4;\n  int v5;\n  int result;\n  v2 = window + 4;\n  v3 = 0;\n  v4 = 0;\n  v5 = 0;\n  do {\n    if (*window == player) {\n      ++v5;\n    } else if (*window == (player == 1) + 1) {\n      ++v4;\n    } else {\n      ++v3;\n    }\n    ++window;\n  } while (window != v2);\n  if (v5 == 4) {\n    result = 100;\n  } else if (v5 != 3 || (result = 5, v3 != 1)) {\n    if (v5 == 2) {\n      result = 2;\n      if (v3 == 2) return result;\n    }\n    result = 0;\n  }\n  if (v4 == 3 && v3 == 1) result -= 4;\n  return result;\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<evaluate_window>:\nendbr64\nxor    %r8d,%r8d\ncmp    $0x1,%esi\nlea    0x10(%rdi),%r9\nsete   %r8b\nxor    %edx,%edx\nxor    %r10d,%r10d\nxor    %ecx,%ecx\nadd    $0x1,%r8d\nmov    (%rdi),%eax\ncmp    %esi,%eax\nje     15f0 <evaluate_window+0x60>\ncmp    %r8d,%eax\nje     15f8 <evaluate_window+0x68>\nadd    $0x1,%edx\nadd    $0x4,%rdi\ncmp    %r9,%rdi\njne    15ad <evaluate_window+0x1d>\ncmp    $0x1,%edx\nsete   %sil\ncmp    $0x4,%ecx\nje     1618 <evaluate_window+0x88>\ncmp    $0x3,%ecx\njne    1600 <evaluate_window+0x70>\nmov    $0x5,%eax\ntest   %sil,%sil\nje     1600 <evaluate_window+0x70>\ncmp    $0x3,%r10d\njne    15ee <evaluate_window+0x5e>\nlea    -0x4(%rax),%edx\ntest   %sil,%sil\ncmovne %edx,%eax\nret\nnop\nadd    $0x1,%ecx\njmp    15bb <evaluate_window+0x2b>\nnopl   (%rax)\nadd    $0x1,%r10d\njmp    15bb <evaluate_window+0x2b>\nxchg   %ax,%ax\ncmp    $0x2,%ecx\njne    160f <evaluate_window+0x7f>\nmov    $0x2,%eax\ncmp    $0x2,%edx\nje     15ee <evaluate_window+0x5e>\nxor    %eax,%eax\njmp    15df <evaluate_window+0x4f>\nnopl   0x0(%rax,%rax,1)\nmov    $0x64,%eax\njmp    15df <evaluate_window+0x4f>\nnop\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "get_next_open_row", "content": "// Returns the lowest available row in the given column (or -1 if full).\nint get_next_open_row(int board[ROWS][COLS], int col) {\n    for (int r = ROWS - 1; r >= 0; r--) {\n        if (board[r][col] == EMPTY)\n            return r;\n    }\n    return -1;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "get_next_open_row", "address": "0x1350", "label": "get_next_open_row", "content": "int __fastcall get_next_open_row(int (*board)[7], int col)\n{\n  int result; // eax\n  int *v3; // rdx\n\n  result = 5;\n  v3 = &(*board)[col + 35];\n  do\n  {\n    if ( !*v3 )\n      break;\n    --result;\n    v3 -= 7;\n  }\n  while ( result != -1 );\n  return result;\n}\n"}, "pseudo_normalize": "int get_next_open_row(int (*board)[7], int col) {\n  int result;\n  int *v3;\n  result = 5;\n  v3 = &(*board)[col + 35];\n  do {\n    if (!*v3) break;\n    --result;\n    v3 -= 7;\n  } while (result != -1);\n  return result;\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<get_next_open_row>:\nendbr64\nmovslq %esi,%rsi\nmov    $0x5,%eax\nlea    0x8c(%rdi,%rsi,4),%rdx\nmov    (%rdx),%ecx\ntest   %ecx,%ecx\nje     1376 <get_next_open_row+0x26>\nsub    $0x1,%eax\nsub    $0x1c,%rdx\ncmp    $0xffffffff,%eax\njne    1364 <get_next_open_row+0x14>\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "init_board", "content": "#include \"libmin.h\"\n\n#define ROWS 6\n#define COLS 7\n#define MAX_DEPTH 4\n\n// Players: 1 and 2. Board cells: 0 = empty.\n#define EMPTY 0\n\n// Scoring constants for evaluation\n#define WIN_SCORE 100000\n#define LOSS_SCORE -100000\n\n// -------------------------------------------------\n// Board Helpers\n// -------------------------------------------------\nvoid init_board(int board[ROWS][COLS]) {\n    for (int r = 0; r < ROWS; r++)\n        for (int c = 0; c < COLS; c++)\n            board[r][c] = EMPTY;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "init_board", "address": "0x1230", "label": "init_board", "content": "void __fastcall init_board(int (*board)[7])\n{\n  int v1; // eax\n  unsigned __int64 v2; // rdi\n\n  *(_QWORD *)board = 0LL;\n  v1 = (int)board;\n  v2 = (unsigned __int64)&(*board)[2];\n  *(_QWORD *)(v2 + 152) = 0LL;\n  memset((void *)(v2 & 0xFFFFFFFFFFFFFFF8LL), 0, 8 * ((v1 - (v2 & 0xFFFFFFF8) + 168) >> 3));\n}\n"}, "pseudo_normalize": "void init_board(int (*board)[7]) {\n  int v1;\n  unsigned long long v2;\n  *(uint64_t *)board = 0LL;\n  v1 = (int)board;\n  v2 = (unsigned long long)&(*board)[2];\n  *(uint64_t *)(v2 + 152) = 0LL;\n  memset((void *)(v2 & 18446744073709551608LL), 0,\n         8 * ((v1 - (v2 & 4294967288) + 168) >> 3));\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<init_board>:\nendbr64\nmovq   $0x0,(%rdi)\nmov    %rdi,%rax\nlea    0x8(%rdi),%rdi\nmovq   $0x0,0x98(%rdi)\nand    $0xfffffffffffffff8,%rdi\nsub    %rdi,%rax\nlea    0xa8(%rax),%ecx\nxor    %eax,%eax\nshr    $0x3,%ecx\nrep stos %rax,%es:(%rdi)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "main", "content": "int main(void) {\n    libmin_srand(42);\n    libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\");\n    play_game();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  libmin_printf(\"Connect Four: Minimax AI Self-Play\\n\", argv);\n  play_game();\n  libmin_success();\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x2a,%edi\ncall   3580 <libmin_srand>\nlea    0x2f57(%rip),%rdi\nxor    %eax,%eax\ncall   3370 <libmin_printf>\nxor    %eax,%eax\ncall   1c90 <play_game>\ncall   37c0 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "make_move", "content": "// Make a move: drop piece for player into col. Returns row where piece lands, or -1 if invalid.\nint make_move(int board[ROWS][COLS], int col, int player) {\n    if (!valid_move(board, col))\n        return -1;\n    int row = get_next_open_row(board, col);\n    board[row][col] = player;\n    return row;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "make_move", "address": "0x1380", "label": "make_move", "content": "int __fastcall make_move(int (*board)[7], int col, int player)\n{\n  int *v3; // rax\n  int v4; // r8d\n\n  if ( (*board)[col] )\n    return -1;\n  v3 = &(*board)[35];\n  v4 = 5;\n  while ( v3[col] )\n  {\n    --v4;\n    v3 -= 7;\n    if ( v4 == -1 )\n    {\n      v3 = &(*board)[-7];\n      break;\n    }\n  }\n  v3[col] = player;\n  return v4;\n}\n"}, "pseudo_normalize": "int make_move(int (*board)[7], int col, int player) {\n  int *v3;\n  int v4;\n  if ((*board)[col]) return -1;\n  v3 = &(*board)[35];\n  v4 = 5;\n  while (v3[col]) {\n    --v4;\n    v3 -= 7;\n    if (v4 == -1) {\n      v3 = &(*board)[-7];\n      break;\n    }\n  }\n  v3[col] = player;\n  return v4;\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<make_move>:\nendbr64\nmovslq %esi,%rsi\nmov    (%rdi,%rsi,4),%r8d\ntest   %r8d,%r8d\njne    13bd <make_move+0x3d>\nlea    0x8c(%rdi),%rax\nmov    $0x5,%r8d\nmov    (%rax,%rsi,4),%ecx\ntest   %ecx,%ecx\nje     13b6 <make_move+0x36>\nsub    $0x1,%r8d\nsub    $0x1c,%rax\ncmp    $0xffffffff,%r8d\njne    139d <make_move+0x1d>\nlea    -0x1c(%rdi),%rax\nmov    %edx,(%rax,%rsi,4)\nmov    %r8d,%eax\nret\nmov    $0xffffffff,%r8d\njmp    13b9 <make_move+0x39>\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "minimax", "content": "// -------------------------------------------------\n// Minimax with Alpha-Beta Pruning and Random Tie-Breaking\n// -------------------------------------------------\n\n// Returns evaluation score. If at top level, best_move will be set (column index).\nint minimax(int board[ROWS][COLS], int depth, int alpha, int beta, int maximizingPlayer, int player, int *best_move) {\n    int opp = (player == 1) ? 2 : 1;\n    // Check terminal conditions or depth limit\n    if (depth == 0 || board_full(board) || check_win(board, player) || check_win(board, opp)) {\n        int ts = terminal_score(board, player);\n        if (ts == 0) { // non-terminal leaf at depth 0: use heuristic\n            return score_position(board, player);\n        } else {\n            return ts;\n        }\n    }\n    \n    int valid_cols[COLS];\n    int valid_count = 0;\n    for (int c = 0; c < COLS; c++) {\n        if (valid_move(board, c))\n            valid_cols[valid_count++] = c;\n    }\n    \n    int best_score;\n    // For random tie-breaking, we keep an array of moves with best scores.\n    int best_moves[COLS];\n    int best_moves_count = 0;\n    \n    if (maximizingPlayer) {\n        best_score = INT_MIN;\n        for (int i = 0; i < valid_count; i++) {\n            int col = valid_cols[i];\n            make_move(board, col, player);\n            int score = minimax(board, depth - 1, alpha, beta, 0, player, NULL);\n            undo_move(board, col);\n            // Random tie breaking: if equal score, record all such moves.\n            if (score > best_score) {\n                best_score = score;\n                best_moves_count = 0;\n                best_moves[best_moves_count++] = col;\n            } else if (score == best_score) {\n                best_moves[best_moves_count++] = col;\n            }\n            if (best_score > alpha)\n                alpha = best_score;\n            if (alpha >= beta)\n                break;\n        }\n    } else {\n        best_score = INT_MAX;\n        for (int i = 0; i < valid_count; i++) {\n            int col = valid_cols[i];\n            make_move(board, col, opp);\n            int score = minimax(board, depth - 1, alpha, beta, 1, player, NULL);\n            undo_move(board, col);\n            if (score < best_score) {\n                best_score = score;\n                best_moves_count = 0;\n                best_moves[best_moves_count++] = col;\n            } else if (score == best_score) {\n                best_moves[best_moves_count++] = col;\n            }\n            if (best_score < beta)\n                beta = best_score;\n            if (alpha >= beta)\n                break;\n        }\n    }\n    \n    // At top level, choose a random move from the best moves if available.\n    if (depth == MAX_DEPTH && best_moves_count > 0 && best_move != NULL) {\n        int chosen = best_moves[libmin_rand() % best_moves_count];\n        *best_move = chosen;\n    }\n    return best_score;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "minimax", "address": "0x1840", "label": "minimax", "content": "int __fastcall minimax(\n        int (*board)[7],\n        int depth,\n        int alpha,\n        int beta,\n        int maximizingPlayer,\n        int player,\n        int *best_move)\n{\n  int v9; // ebp\n  int *v11; // rax\n  int v13; // r12d\n  int v14; // r11d\n  int v15; // edx\n  int v16; // ecx\n  int v17; // esi\n  __int64 i; // rax\n  __int64 v19; // rdi\n  int v20; // r9d\n  int v21; // ebp\n  int *v22; // r15\n  __int64 v23; // rbx\n  int v24; // r10d\n  int *v25; // rax\n  bool v26; // zf\n  int v27; // eax\n  int *v28; // rdx\n  int v29; // ebx\n  int v30; // r9d\n  int *v31; // r15\n  int v32; // ebp\n  __int64 v33; // rbx\n  int v34; // r10d\n  int *v35; // rax\n  int v36; // eax\n  int *v37; // rcx\n  int best_moves_counta; // [rsp+10h] [rbp-B8h]\n  int alphab; // [rsp+14h] [rbp-B4h]\n  int alphac; // [rsp+14h] [rbp-B4h]\n  int betaa; // [rsp+18h] [rbp-B0h]\n  int betab; // [rsp+18h] [rbp-B0h]\n  int betac; // [rsp+18h] [rbp-B0h]\n  int v46; // [rsp+1Ch] [rbp-ACh]\n  int v47; // [rsp+1Ch] [rbp-ACh]\n  int v48; // [rsp+28h] [rbp-A0h]\n  int deptha; // [rsp+30h] [rbp-98h]\n  int v50; // [rsp+38h] [rbp-90h]\n  int v51; // [rsp+38h] [rbp-90h]\n  int v52; // [rsp+3Ch] [rbp-8Ch]\n  int valid_cols[8]; // [rsp+40h] [rbp-88h] BYREF\n  int best_moves[10]; // [rsp+60h] [rbp-68h]\n  unsigned __int64 v55; // [rsp+88h] [rbp-40h]\n\n  v55 = __readfsqword(0x28u);\n  v9 = (player == 1) + 1;\n  if ( depth )\n  {\n    v11 = (int *)board;\n    while ( *v11 )\n    {\n      if ( ++v11 == &(*board)[7] )\n        goto LABEL_5;\n    }\n    v13 = 100000;\n    if ( check_win(board, player) )\n      return v13;\n    v13 = -100000;\n    betaa = beta;\n    best_moves_counta = check_win(board, v9);\n    if ( best_moves_counta )\n      return v13;\n    v15 = alpha;\n    v16 = betaa;\n    v17 = 0;\n    for ( i = 0LL; i != 7; ++i )\n    {\n      if ( !(*board)[i] )\n      {\n        v19 = v17++;\n        valid_cols[v19] = i;\n      }\n    }\n    if ( v14 )\n    {\n      if ( v17 )\n      {\n        deptha = depth;\n        v20 = player;\n        v50 = depth - 1;\n        v21 = alpha;\n        v22 = valid_cols;\n        v13 = 0x80000000;\n        do\n        {\n          v23 = *v22;\n          v24 = *v22;\n          if ( !(*board)[v23] )\n          {\n            v25 = &(*board)[35];\n            do\n            {\n              if ( !v25[v23] )\n                break;\n              v26 = v25 == (int *)board;\n              v25 -= 7;\n            }\n            while ( !v26 );\n            v25[v23] = v20;\n          }\n          v46 = v24;\n          betab = v20;\n          alphab = v16;\n          v27 = minimax(board, v50, v21, v16, 0, v20, 0LL);\n          v28 = (int *)board;\n          v16 = alphab;\n          v20 = betab;\n          while ( !v28[v23] )\n          {\n            v28 += 7;\n            if ( &(*board)[42] == v28 )\n              goto LABEL_25;\n          }\n          v28[v23] = 0;\nLABEL_25:\n          if ( v27 <= v13 )\n          {\n            if ( v27 == v13 )\n              best_moves[best_moves_counta++] = v46;\n          }\n          else\n          {\n            best_moves[0] = v46;\n            v13 = v27;\n            best_moves_counta = 1;\n          }\n          if ( v21 < v13 )\n            v21 = v13;\n          if ( v21 >= alphab )\n            break;\n          ++v22;\n        }\n        while ( v22 != &valid_cols[v17 - 1 + 1] );\n        v29 = deptha;\nLABEL_51:\n        if ( best_move != 0LL && v29 == 4 && best_moves_counta > 0 )\n          *best_move = best_moves[libmin_rand() % best_moves_counta];\n        return v13;\n      }\n      return 0x80000000;\n    }\n    else\n    {\n      v13 = 0x7FFFFFFF;\n      if ( v17 )\n      {\n        v52 = depth;\n        v30 = player;\n        v51 = depth - 1;\n        v13 = 0x7FFFFFFF;\n        v31 = valid_cols;\n        best_moves_counta = 0;\n        v48 = v9;\n        v32 = betaa;\n        do\n        {\n          v33 = *v31;\n          v34 = *v31;\n          if ( !(*board)[v33] )\n          {\n            v35 = &(*board)[35];\n            do\n            {\n              if ( !v35[v33] )\n                break;\n              v26 = v35 == (int *)board;\n              v35 -= 7;\n            }\n            while ( !v26 );\n            v35[v33] = v48;\n          }\n          v47 = v34;\n          betac = v30;\n          alphac = v15;\n          v36 = minimax(board, v51, v15, v32, 1, v30, 0LL);\n          v37 = (int *)board;\n          v15 = alphac;\n          v30 = betac;\n          while ( !v37[v33] )\n          {\n            v37 += 7;\n            if ( &(*board)[42] == v37 )\n              goto LABEL_44;\n          }\n          v37[v33] = 0;\nLABEL_44:\n          if ( v36 >= v13 )\n          {\n            if ( v36 == v13 )\n              best_moves[best_moves_counta++] = v47;\n          }\n          else\n          {\n            best_moves[0] = v47;\n            v13 = v36;\n            best_moves_counta = 1;\n          }\n          if ( v32 > v13 )\n            v32 = v13;\n          if ( v32 <= alphac )\n            break;\n          ++v31;\n        }\n        while ( v31 != &valid_cols[v17 - 1 + 1] );\n        v29 = v52;\n        goto LABEL_51;\n      }\n    }\n  }\n  else\n  {\nLABEL_5:\n    if ( check_win(board, player) )\n    {\n      return 100000;\n    }\n    else\n    {\n      if ( !check_win(board, v9) )\n        return score_position(board, player);\n      return -100000;\n    }\n  }\n  return v13;\n}\n"}, "pseudo_normalize": "int minimax(int (*board)[7], int depth, int alpha, int beta,\n            int maximizingPlayer, int player, int *best_move) {\n  int v9;\n  int *v11;\n  int v13;\n  int v14;\n  int v15;\n  int v16;\n  int v17;\n  long long i;\n  long long v19;\n  int v20;\n  int v21;\n  int *v22;\n  long long v23;\n  int v24;\n  int *v25;\n  bool v26;\n  int v27;\n  int *v28;\n  int v29;\n  int v30;\n  int *v31;\n  int v32;\n  long long v33;\n  int v34;\n  int *v35;\n  int v36;\n  int *v37;\n  int best_moves_counta;\n  int alphab;\n  int alphac;\n  int betaa;\n  int betab;\n  int betac;\n  int v46;\n  int v47;\n  int v48;\n  int deptha;\n  int v50;\n  int v51;\n  int v52;\n  int valid_cols[8];\n  int best_moves[10];\n  unsigned long long v55;\n  v55 = __readfsqword(40u);\n  v9 = (player == 1) + 1;\n  if (depth) {\n    v11 = (int *)board;\n    while (*v11) {\n      if (++v11 == &(*board)[7]) goto LABEL_5;\n    }\n    v13 = 100000;\n    if (check_win(board, player)) return v13;\n    v13 = -100000;\n    betaa = beta;\n    best_moves_counta = check_win(board, v9);\n    if (best_moves_counta) return v13;\n    v15 = alpha;\n    v16 = betaa;\n    v17 = 0;\n    for (i = 0LL; i != 7; ++i) {\n      if (!(*board)[i]) {\n        v19 = v17++;\n        valid_cols[v19] = i;\n      }\n    }\n    if (v14) {\n      if (v17) {\n        deptha = depth;\n        v20 = player;\n        v50 = depth - 1;\n        v21 = alpha;\n        v22 = valid_cols;\n        v13 = 2147483648;\n        do {\n          v23 = *v22;\n          v24 = *v22;\n          if (!(*board)[v23]) {\n            v25 = &(*board)[35];\n            do {\n              if (!v25[v23]) break;\n              v26 = v25 == (int *)board;\n              v25 -= 7;\n            } while (!v26);\n            v25[v23] = v20;\n          }\n          v46 = v24;\n          betab = v20;\n          alphab = v16;\n          v27 = minimax(board, v50, v21, v16, 0, v20, 0LL);\n          v28 = (int *)board;\n          v16 = alphab;\n          v20 = betab;\n          while (!v28[v23]) {\n            v28 += 7;\n            if (&(*board)[42] == v28) goto LABEL_25;\n          }\n          v28[v23] = 0;\n        LABEL_25:\n          if (v27 <= v13) {\n            if (v27 == v13) best_moves[best_moves_counta++] = v46;\n          } else {\n            best_moves[0] = v46;\n            v13 = v27;\n            best_moves_counta = 1;\n          }\n          if (v21 < v13) v21 = v13;\n          if (v21 >= alphab) break;\n          ++v22;\n        } while (v22 != &valid_cols[v17 - 1 + 1]);\n        v29 = deptha;\n      LABEL_51:\n        if (best_move != 0LL && v29 == 4 && best_moves_counta > 0)\n          *best_move = best_moves[libmin_rand() % best_moves_counta];\n        return v13;\n      }\n      return 2147483648;\n    } else {\n      v13 = 2147483647;\n      if (v17) {\n        v52 = depth;\n        v30 = player;\n        v51 = depth - 1;\n        v13 = 2147483647;\n        v31 = valid_cols;\n        best_moves_counta = 0;\n        v48 = v9;\n        v32 = betaa;\n        do {\n          v33 = *v31;\n          v34 = *v31;\n          if (!(*board)[v33]) {\n            v35 = &(*board)[35];\n            do {\n              if (!v35[v33]) break;\n              v26 = v35 == (int *)board;\n              v35 -= 7;\n            } while (!v26);\n            v35[v33] = v48;\n          }\n          v47 = v34;\n          betac = v30;\n          alphac = v15;\n          v36 = minimax(board, v51, v15, v32, 1, v30, 0LL);\n          v37 = (int *)board;\n          v15 = alphac;\n          v30 = betac;\n          while (!v37[v33]) {\n            v37 += 7;\n            if (&(*board)[42] == v37) goto LABEL_44;\n          }\n          v37[v33] = 0;\n        LABEL_44:\n          if (v36 >= v13) {\n            if (v36 == v13) best_moves[best_moves_counta++] = v47;\n          } else {\n            best_moves[0] = v47;\n            v13 = v36;\n            best_moves_counta = 1;\n          }\n          if (v32 > v13) v32 = v13;\n          if (v32 <= alphac) break;\n          ++v31;\n        } while (v31 != &valid_cols[v17 - 1 + 1]);\n        v29 = v52;\n        goto LABEL_51;\n      }\n    }\n  } else {\n  LABEL_5:\n    if (check_win(board, player)) {\n      return 100000;\n    } else {\n      if (!check_win(board, v9)) return score_position(board, player);\n      return -100000;\n    }\n  }\n  return v13;\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<minimax>:\nendbr64\npush   %r15\nmov    %r9d,%r15d\npush   %r14\nmov    %rdi,%r14\npush   %r13\npush   %r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nsub    $0x98,%rsp\nmov    0xd0(%rsp),%rax\nmov    %rax,0x8(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x88(%rsp)\nxor    %eax,%eax\ncmp    $0x1,%r9d\nsete   %bpl\nadd    $0x1,%ebp\ntest   %esi,%esi\nje     18b1 <minimax+0x71>\nmov    %esi,%ebx\nmov    %r8d,%r11d\nlea    0x1c(%rdi),%rsi\nmov    %rdi,%rax\nnopl   0x0(%rax,%rax,1)\nmov    (%rax),%r8d\ntest   %r8d,%r8d\nje     1910 <minimax+0xd0>\nadd    $0x4,%rax\ncmp    %rsi,%rax\njne    18a0 <minimax+0x60>\nmov    %r15d,%esi\nmov    %r14,%rdi\ncall   1430 <check_win>\ntest   %eax,%eax\njne    1a90 <minimax+0x250>\nmov    %ebp,%esi\nmov    %r14,%rdi\ncall   1430 <check_win>\ntest   %eax,%eax\njne    1c84 <minimax+0x444>\nmov    0x88(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1c7f <minimax+0x43f>\nadd    $0x98,%rsp\nmov    %r15d,%esi\nmov    %r14,%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    1620 <score_position>\nnopl   0x0(%rax)\nmov    %r15d,%esi\nmov    %r14,%rdi\nmov    %edx,0x14(%rsp)\nmov    $0x186a0,%r12d\nmov    %ecx,0x10(%rsp)\ncall   1430 <check_win>\ntest   %eax,%eax\njne    1a96 <minimax+0x256>\nmov    0x10(%rsp),%ecx\nmov    %ebp,%esi\nmov    %r14,%rdi\nmov    $0xfffe7960,%r12d\nmov    %ecx,0x18(%rsp)\ncall   1430 <check_win>\nmov    %eax,0x10(%rsp)\ntest   %eax,%eax\njne    1a96 <minimax+0x256>\nmov    0x14(%rsp),%edx\nmov    0x18(%rsp),%ecx\nxor    %esi,%esi\nxor    %eax,%eax\nnopl   0x0(%rax)\nmov    (%r14,%rax,4),%edi\ntest   %edi,%edi\njne    197a <minimax+0x13a>\nmovslq %esi,%rdi\nadd    $0x1,%esi\nmov    %eax,0x40(%rsp,%rdi,4)\nadd    $0x1,%rax\ncmp    $0x7,%rax\njne    1968 <minimax+0x128>\ntest   %r11d,%r11d\nje     1ac8 <minimax+0x288>\ntest   %esi,%esi\nje     1c74 <minimax+0x434>\nlea    -0x1(%rbx),%eax\nmov    %ebx,0x30(%rsp)\nlea    0x40(%rsp),%r13\nmov    %r15d,%r9d\nmov    %eax,0x38(%rsp)\nlea    -0x1(%rsi),%eax\nlea    0xa8(%r14),%r11\nmov    %edx,%ebp\nlea    0x44(%rsp,%rax,4),%rax\nmov    %r13,%r15\nmov    $0x80000000,%r12d\nmov    %r11,%r13\nmov    %rax,0x28(%rsp)\nlea    0x8c(%r14),%rax\nmov    %rax,0x20(%rsp)\nmovslq (%r15),%rbx\nmov    (%r14,%rbx,4),%eax\nmov    %rbx,%r10\ntest   %eax,%eax\njne    1a02 <minimax+0x1c2>\nmov    0x20(%rsp),%rax\nmov    (%rax,%rbx,4),%r11d\ntest   %r11d,%r11d\nje     19fe <minimax+0x1be>\nlea    -0x1c(%rax),%rdx\ncmp    %r14,%rax\nmov    %rdx,%rax\njne    19e9 <minimax+0x1a9>\nmov    %r9d,(%rax,%rbx,4)\nmov    %r10d,0x1c(%rsp)\nsub    $0x8,%rsp\nxor    %r8d,%r8d\nmov    %ebp,%edx\npush   $0x0\nmov    0x48(%rsp),%esi\nmov    %r14,%rdi\nmov    %r9d,0x28(%rsp)\nmov    %ecx,0x24(%rsp)\ncall   1840 <minimax>\npop    %rdi\npop    %r8\nmov    %r14,%rdx\nmov    0x1c(%rsp),%r10d\nmov    0x14(%rsp),%ecx\nmov    0x18(%rsp),%r9d\nmov    (%rdx,%rbx,4),%esi\ntest   %esi,%esi\njne    1c68 <minimax+0x428>\nadd    $0x1c,%rdx\ncmp    %rdx,%r13\njne    1a3b <minimax+0x1fb>\ncmp    %r12d,%eax\njle    1c18 <minimax+0x3d8>\nmov    %r10d,0x60(%rsp)\nmov    %eax,%r12d\nmovl   $0x1,0x10(%rsp)\ncmp    %r12d,%ebp\ncmovl  %r12d,%ebp\ncmp    %ecx,%ebp\njge    1a82 <minimax+0x242>\nadd    $0x4,%r15\ncmp    0x28(%rsp),%r15\njne    19d6 <minimax+0x196>\nmov    0x30(%rsp),%ebx\njmp    1bd5 <minimax+0x395>\nnopl   0x0(%rax,%rax,1)\nmov    $0x186a0,%r12d\nmov    0x88(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1c7f <minimax+0x43f>\nadd    $0x98,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x7fffffff,%r12d\ntest   %esi,%esi\nje     1a96 <minimax+0x256>\nlea    -0x1(%rbx),%eax\nmov    %ebx,0x3c(%rsp)\nlea    0x40(%rsp),%r10\nmov    %r15d,%r9d\nmov    %eax,0x38(%rsp)\nlea    -0x1(%rsi),%eax\nmov    $0x7fffffff,%r12d\nmov    %r10,%r15\nlea    0x44(%rsp,%rax,4),%rax\nlea    0xa8(%r14),%r11\nmovl   $0x0,0x10(%rsp)\nmov    %rax,0x30(%rsp)\nlea    0x8c(%r14),%rax\nmov    %r11,%r13\nmov    %rax,0x20(%rsp)\nmov    %ebp,0x28(%rsp)\nmov    %ecx,%ebp\nmovslq (%r15),%rbx\nmov    (%r14,%rbx,4),%eax\nmov    %rbx,%r10\ntest   %eax,%eax\njne    1b4e <minimax+0x30e>\nmov    0x20(%rsp),%rax\nmov    (%rax,%rbx,4),%r11d\ntest   %r11d,%r11d\nje     1b47 <minimax+0x307>\nlea    -0x1c(%rax),%rcx\ncmp    %r14,%rax\nmov    %rcx,%rax\njne    1b32 <minimax+0x2f2>\nmov    0x28(%rsp),%edi\nmov    %edi,(%rax,%rbx,4)\nmov    %r10d,0x1c(%rsp)\nsub    $0x8,%rsp\nmov    %ebp,%ecx\nmov    %r14,%rdi\npush   $0x0\nmov    0x48(%rsp),%esi\nmov    $0x1,%r8d\nmov    %r9d,0x28(%rsp)\nmov    %edx,0x24(%rsp)\ncall   1840 <minimax>\npop    %rdi\npop    %r8\nmov    %r14,%rcx\nmov    0x1c(%rsp),%r10d\nmov    0x14(%rsp),%edx\nmov    0x18(%rsp),%r9d\nmov    (%rcx,%rbx,4),%esi\ntest   %esi,%esi\njne    1c58 <minimax+0x418>\nadd    $0x1c,%rcx\ncmp    %rcx,%r13\njne    1b8a <minimax+0x34a>\ncmp    %r12d,%eax\njge    1c38 <minimax+0x3f8>\nmov    %r10d,0x60(%rsp)\nmov    %eax,%r12d\nmovl   $0x1,0x10(%rsp)\ncmp    %r12d,%ebp\ncmovg  %r12d,%ebp\ncmp    %edx,%ebp\njle    1bd1 <minimax+0x391>\nadd    $0x4,%r15\ncmp    0x30(%rsp),%r15\njne    1b1f <minimax+0x2df>\nmov    0x3c(%rsp),%ebx\ncmp    $0x4,%ebx\nmov    0x8(%rsp),%rbx\nsete   %dl\ntest   %rbx,%rbx\nsetne  %al\ntest   %al,%dl\nje     1a96 <minimax+0x256>\nmov    0x10(%rsp),%r15d\ntest   %r15d,%r15d\njle    1a96 <minimax+0x256>\ncall   35e0 <libmin_rand>\nxor    %edx,%edx\ndiv    %r15d\nmov    0x60(%rsp,%rdx,4),%eax\nmov    %eax,(%rbx)\njmp    1a96 <minimax+0x256>\nnopl   0x0(%rax)\njne    1a68 <minimax+0x228>\nmovslq 0x10(%rsp),%rax\nmov    %r10d,0x60(%rsp,%rax,4)\nlea    0x1(%rax),%eax\nmov    %eax,0x10(%rsp)\njmp    1a68 <minimax+0x228>\nnopl   0x0(%rax)\njne    1bb7 <minimax+0x377>\nmovslq 0x10(%rsp),%rax\nmov    %r10d,0x60(%rsp,%rax,4)\nlea    0x1(%rax),%eax\nmov    %eax,0x10(%rsp)\njmp    1bb7 <minimax+0x377>\nnopl   0x0(%rax)\nmovl   $0x0,(%rcx,%rbx,4)\njmp    1b9e <minimax+0x35e>\nnopl   0x0(%rax)\nmovl   $0x0,(%rdx,%rbx,4)\njmp    1a4f <minimax+0x20f>\nmov    $0x80000000,%r12d\njmp    1a96 <minimax+0x256>\ncall   10b0 <__stack_chk_fail@plt>\nmov    $0xfffe7960,%r12d\njmp    1a96 <minimax+0x256>\nnop\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "play_game", "content": "// -------------------------------------------------\n// Main Simulation Loop: Self-play game using minimax\n// -------------------------------------------------\nvoid play_game() {\n    int board[ROWS][COLS];\n    init_board(board);\n    \n    int current_player = 1; // Player 1 starts.\n    int move_number = 0;\n    \n    print_board(board);\n    \n    while (1) {\n        move_number++;\n        int best_move = -1;\n        // For both players, we use minimax to choose a move.\n        int score = minimax(board, MAX_DEPTH, INT_MIN, INT_MAX, 1, current_player, &best_move);\n        if (best_move == -1 || !valid_move(board, best_move)) {\n            // No valid move found => game over.\n            break;\n        }\n        make_move(board, best_move, current_player);\n        libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", move_number, current_player, best_move, score);\n        print_board(board);\n        \n        if (check_win(board, current_player)) {\n            libmin_printf(\"Player %d wins!\\n\", current_player);\n            break;\n        }\n        if (board_full(board)) {\n            libmin_printf(\"Game is a draw.\\n\");\n            break;\n        }\n        // Switch players.\n        current_player = (current_player == 1) ? 2 : 1;\n    }\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "play_game", "address": "0x1c90", "label": "play_game", "content": "void __cdecl play_game()\n{\n  int v0; // r15d\n  int v1; // ebp\n  int v2; // eax\n  int v3; // r9d\n  int *v4; // rdx\n  int *v5; // rbx\n  int *v6; // rcx\n  char v7; // [rsp+0h] [rbp-104h] BYREF\n  int best_move; // [rsp+18h] [rbp-ECh] BYREF\n  int board[6][7]; // [rsp+1Ch] [rbp-E8h] BYREF\n  unsigned __int64 v10; // [rsp+C4h] [rbp-40h]\n\n  v0 = 1;\n  v1 = 0;\n  v10 = __readfsqword(0x28u);\n  memset(board, 0, sizeof(board));\n  print_board(board);\n  while ( 1 )\n  {\n    best_move = -1;\n    ++v1;\n    v2 = minimax(board, 4, 0x80000000, 0x7FFFFFFF, 1, v0, &best_move);\n    v3 = best_move;\n    if ( best_move == -1 || board[0][best_move] )\n      break;\n    v4 = board[5];\n    v5 = board[0];\n    if ( board[5][best_move] )\n    {\n      while ( 1 )\n      {\n        v6 = v4 - 7;\n        if ( v4 == (int *)board )\n          break;\n        v4 -= 7;\n        if ( !v6[best_move] )\n          goto LABEL_7;\n      }\n      v4 = (int *)&v7;\n    }\nLABEL_7:\n    v4[best_move] = v0;\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", v1, v0, v3, v2);\n    print_board(board);\n    if ( check_win(board, v0) )\n    {\n      libmin_printf(\"Player %d wins!\\n\", v0);\n      return;\n    }\n    while ( *v5 )\n    {\n      if ( board[1] == ++v5 )\n      {\n        libmin_printf(\"Game is a draw.\\n\");\n        return;\n      }\n    }\n    v0 = 3 - v0;\n  }\n}\n"}, "pseudo_normalize": "void play_game() {\n  int v0;\n  int v1;\n  int v2;\n  int v3;\n  int *v4;\n  int *v5;\n  int *v6;\n  char v7;\n  int best_move;\n  int board[6][7];\n  unsigned long long v10;\n  v0 = 1;\n  v1 = 0;\n  v10 = __readfsqword(40u);\n  memset(board, 0, sizeof(board));\n  print_board(board);\n  while (1) {\n    best_move = -1;\n    ++v1;\n    v2 = minimax(board, 4, 2147483648, 2147483647, 1, v0, &best_move);\n    v3 = best_move;\n    if (best_move == -1 || board[0][best_move]) break;\n    v4 = board[5];\n    v5 = board[0];\n    if (board[5][best_move]) {\n      while (1) {\n        v6 = v4 - 7;\n        if (v4 == (int *)board) break;\n        v4 -= 7;\n        if (!v6[best_move]) goto LABEL_7;\n      }\n      v4 = (int *)&v7;\n    }\n  LABEL_7:\n    v4[best_move] = v0;\n    libmin_printf(\"Move %d: Player %d drops in column %d (score=%d)\\n\", v1, v0,\n                  v3, v2);\n    print_board(board);\n    if (check_win(board, v0)) {\n      libmin_printf(\"Player %d wins!\\n\", v0);\n      return;\n    }\n    while (*v5) {\n      if (board[1] == ++v5) {\n        libmin_printf(\"Game is a draw.\\n\");\n        return;\n      }\n    }\n    v0 = 3 - v0;\n  }\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<play_game>:\nendbr64\npush   %r15\nmov    $0x15,%ecx\nmov    $0x1,%r15d\npush   %r14\npush   %r13\nlea    0x238c(%rip),%r13\npush   %r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nsub    $0xc8,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0xb8(%rsp)\nxor    %eax,%eax\nlea    0x10(%rsp),%r14\nlea    0xc(%rsp),%r12\nmov    %r14,%rdi\nrep stos %rax,%es:(%rdi)\nmov    %r14,%rdi\ncall   1270 <print_board>\nnopl   0x0(%rax)\nsub    $0x8,%rsp\nmov    %r15d,%r9d\nmov    $0x1,%r8d\nmov    %r14,%rdi\nmovl   $0xffffffff,0x14(%rsp)\nmov    $0x7fffffff,%ecx\nmov    $0x80000000,%edx\nadd    $0x1,%ebp\npush   %r12\nmov    $0x4,%esi\ncall   1840 <minimax>\nmov    0x1c(%rsp),%r9d\npop    %r10\nmov    %eax,%r8d\npop    %r11\ncmp    $0xffffffff,%r9d\nje     1dc5 <play_game+0x135>\nmovslq %r9d,%rsi\nmov    0x10(%rsp,%rsi,4),%edi\ntest   %edi,%edi\njne    1dc5 <play_game+0x135>\nlea    0x9c(%rsp),%rdx\nmov    %r14,%rbx\nmov    (%rdx,%rsi,4),%ecx\ntest   %ecx,%ecx\nje     1d70 <play_game+0xe0>\nlea    -0x1c(%rdx),%rcx\ncmp    %r14,%rdx\nje     1e00 <play_game+0x170>\nmov    %rcx,%rdx\nmov    (%rdx,%rsi,4),%ecx\ntest   %ecx,%ecx\njne    1d50 <play_game+0xc0>\nnopw   0x0(%rax,%rax,1)\nmov    %r15d,(%rdx,%rsi,4)\nmov    %r9d,%ecx\nmov    %ebp,%esi\nmov    %r15d,%edx\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   3370 <libmin_printf>\nmov    %r14,%rdi\ncall   1270 <print_board>\nmov    %r15d,%esi\nmov    %r14,%rdi\ncall   1430 <check_win>\ntest   %eax,%eax\njne    1e0a <play_game+0x17a>\nlea    0x1c(%r14),%rax\nnopl   0x0(%rax)\nmov    (%rbx),%edx\ntest   %edx,%edx\nje     1df0 <play_game+0x160>\nadd    $0x4,%rbx\ncmp    %rbx,%rax\njne    1da8 <play_game+0x118>\nlea    0x2262(%rip),%rdi\nxor    %eax,%eax\ncall   3370 <libmin_printf>\nmov    0xb8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1e1d <play_game+0x18d>\nadd    $0xc8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x3,%eax\nsub    %r15d,%eax\nmov    %eax,%r15d\njmp    1ce8 <play_game+0x58>\nlea    -0xc(%rsp),%rdx\njmp    1d70 <play_game+0xe0>\nmov    %r15d,%esi\nlea    0x21fb(%rip),%rdi\nxor    %eax,%eax\ncall   3370 <libmin_printf>\njmp    1dc5 <play_game+0x135>\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "print_board", "content": "void print_board(int board[ROWS][COLS]) {\n    libmin_printf(\"\\n\");\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS; c++) {\n            char ch = board[r][c] == 1 ? 'X' : (board[r][c] == 2 ? 'O' : '.');\n            libmin_printf(\"%c \", ch);\n        }\n        libmin_printf(\"\\n\");\n    }\n    for (int c = 0; c < COLS; c++) {\n        libmin_printf(\"%d \", c);\n    }\n    libmin_printf(\"\\n\\n\");\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "print_board", "address": "0x1270", "label": "print_board", "content": "void __fastcall print_board(int (*board)[7])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n  __int64 v3; // rsi\n  int i; // ebx\n  int v5; // esi\n\n  v1 = &(*board)[7];\n  libmin_printf(\"\\n\");\n  do\n  {\n    v2 = v1 - 7;\n    do\n    {\n      v3 = 88LL;\n      if ( *v2 != 1 )\n      {\n        v3 = 79LL;\n        if ( *v2 != 2 )\n          v3 = 46LL;\n      }\n      ++v2;\n      libmin_printf(\"%c \", v3);\n    }\n    while ( v2 != v1 );\n    v1 = v2 + 7;\n    libmin_printf(\"\\n\");\n  }\n  while ( v2 + 7 != &(*board)[49] );\n  for ( i = 0; i != 7; ++i )\n  {\n    v5 = i;\n    libmin_printf(\"%d \", v5);\n  }\n  libmin_printf(\"\\n\\n\");\n}\n"}, "pseudo_normalize": "void print_board(int (*board)[7]) {\n  int *v1;\n  int *v2;\n  long long v3;\n  int i;\n  int v5;\n  v1 = &(*board)[7];\n  libmin_printf(\"\\n\");\n  do {\n    v2 = v1 - 7;\n    do {\n      v3 = 88LL;\n      if (*v2 != 1) {\n        v3 = 79LL;\n        if (*v2 != 2) v3 = 46LL;\n      }\n      ++v2;\n      libmin_printf(\"%c \", v3);\n    } while (v2 != v1);\n    v1 = v2 + 7;\n    libmin_printf(\"\\n\");\n  } while (v2 + 7 != &(*board)[49]);\n  for (i = 0; i != 7; ++i) {\n    v5 = i;\n    libmin_printf(\"%d \", v5);\n  }\n  libmin_printf(\"\\n\\n\");\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<print_board>:\nendbr64\npush   %r14\nlea    0x2d90(%rip),%r14\nxor    %eax,%eax\npush   %r13\nmov    %rdi,%r13\nmov    %r14,%rdi\npush   %r12\nlea    0x2d74(%rip),%r12\npush   %rbp\nlea    0x1c(%r13),%rbp\nadd    $0xc4,%r13\npush   %rbx\ncall   3370 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\nlea    -0x1c(%rbp),%rbx\nnopl   0x0(%rax)\nmov    (%rbx),%eax\nmov    $0x58,%esi\ncmp    $0x1,%eax\nje     12cc <print_board+0x5c>\ncmp    $0x2,%eax\nmov    $0x4f,%esi\nmov    $0x2e,%eax\ncmovne %eax,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   3370 <libmin_printf>\ncmp    %rbp,%rbx\njne    12b0 <print_board+0x40>\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    0x1c(%rbx),%rbp\ncall   3370 <libmin_printf>\ncmp    %r13,%rbp\njne    12a8 <print_board+0x38>\nxor    %ebx,%ebx\nlea    0x2d0d(%rip),%rbp\nnopl   0x0(%rax,%rax,1)\nmov    %ebx,%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   3370 <libmin_printf>\ncmp    $0x7,%ebx\njne    1300 <print_board+0x90>\npop    %rbx\nlea    0x2cf0(%rip),%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %r14\njmp    3370 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "score_position", "content": "// Score the board from the perspective of \"player\".\nint score_position(int board[ROWS][COLS], int player) {\n    int score = 0;\n    int window[4];\n    int center_count = 0;\n    // Score center column: pieces in the center are more valuable.\n    for (int r = 0; r < ROWS; r++) {\n        if (board[r][COLS/2] == player)\n            center_count++;\n    }\n    score += center_count * 3;\n\n    // Horizontal\n    for (int r = 0; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Vertical\n    for (int c = 0; c < COLS; c++) {\n        for (int r = 0; r < ROWS - 3; r++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r+i][c];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Positive diagonal\n    for (int r = 3; r < ROWS; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r-i][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    // Negative diagonal\n    for (int r = 0; r < ROWS - 3; r++) {\n        for (int c = 0; c < COLS - 3; c++) {\n            for (int i = 0; i < 4; i++)\n                window[i] = board[r+i][c+i];\n            score += evaluate_window(window, player);\n        }\n    }\n    return score;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "score_position", "address": "0x1620", "label": "score_position", "content": "int __fastcall score_position(int (*board)[7], int player)\n{\n  int v2; // edx\n  int *v3; // rax\n  int v4; // ecx\n  int *v5; // r13\n  const __m128i *v6; // r12\n  __m128i v7; // xmm0\n  __int64 i; // r13\n  int v9; // r14d\n  int *v10; // rbp\n  int *v11; // rax\n  int *v12; // rdx\n  int v13; // ecx\n  int v14; // r13d\n  int *v15; // rbp\n  int *v16; // rax\n  int *v17; // rdx\n  int v18; // ecx\n  int j; // ebp\n  int v20; // r13d\n  int *v21; // r14\n  int *v22; // rax\n  int *v23; // rdx\n  int v24; // ecx\n  int v25; // eax\n  int v26; // r11d\n  int v27; // r11d\n  __int64 v29; // [rsp+8h] [rbp-60h]\n  __int64 v30; // [rsp+8h] [rbp-60h]\n  int window[4]; // [rsp+10h] [rbp-58h] BYREF\n  char v32; // [rsp+20h] [rbp-48h] BYREF\n  unsigned __int64 v33; // [rsp+28h] [rbp-40h]\n\n  v2 = 0;\n  v33 = __readfsqword(0x28u);\n  v3 = &(*board)[3];\n  do\n  {\n    v4 = *v3 == player;\n    v3 += 7;\n    v2 += v4;\n  }\n  while ( v3 != &(*board)[45] );\n  v5 = &(*board)[4];\n  do\n  {\n    v6 = (const __m128i *)(v5 - 4);\n    do\n    {\n      v7 = _mm_loadu_si128(v6);\n      v6 = (const __m128i *)((char *)v6 + 4);\n      *(__m128i *)window = v7;\n      evaluate_window(window, player);\n    }\n    while ( v6 != (const __m128i *)v5 );\n    v5 = &v6[1].m128i_i32[3];\n  }\n  while ( (int *)((char *)&v6[1].m128i_u64[1] + 4) != &(*board)[46] );\n  for ( i = 0LL; i != 7; ++i )\n  {\n    v9 = 0;\n    v10 = &(*board)[i];\n    do\n    {\n      v11 = window;\n      v12 = v10;\n      do\n      {\n        v13 = *v12;\n        ++v11;\n        v12 += 7;\n        *(v11 - 1) = v13;\n      }\n      while ( v11 != (int *)&v32 );\n      ++v9;\n      v10 += 7;\n      evaluate_window(window, player);\n    }\n    while ( v9 != 3 );\n  }\n  v29 = 21LL;\n  do\n  {\n    v14 = 0;\n    v15 = &(*board)[v29];\n    do\n    {\n      v16 = window;\n      v17 = v15;\n      do\n      {\n        v18 = *v17;\n        ++v16;\n        v17 -= 6;\n        *(v16 - 1) = v18;\n      }\n      while ( v16 != (int *)&v32 );\n      ++v14;\n      ++v15;\n      evaluate_window(window, player);\n    }\n    while ( v14 != 4 );\n    ++v9;\n    v29 += 7LL;\n  }\n  while ( v9 != 6 );\n  v30 = 0LL;\n  for ( j = 0; j != 3; ++j )\n  {\n    v20 = 0;\n    v21 = &(*board)[v30];\n    do\n    {\n      v22 = window;\n      v23 = v21;\n      do\n      {\n        v24 = *v23;\n        ++v22;\n        v23 += 8;\n        *(v22 - 1) = v24;\n      }\n      while ( v22 != (int *)&v32 );\n      ++v20;\n      ++v21;\n      v25 = evaluate_window(window, player);\n      v27 = v25 + v26;\n    }\n    while ( v20 != 4 );\n    v30 += 7LL;\n  }\n  return v27;\n}\n"}, "pseudo_normalize": "int score_position(int (*board)[7], int player) {\n  int v2;\n  int *v3;\n  int v4;\n  int *v5;\n  const __m128i *v6;\n  __m128i v7;\n  long long i;\n  int v9;\n  int *v10;\n  int *v11;\n  int *v12;\n  int v13;\n  int v14;\n  int *v15;\n  int *v16;\n  int *v17;\n  int v18;\n  int j;\n  int v20;\n  int *v21;\n  int *v22;\n  int *v23;\n  int v24;\n  int v25;\n  int v26;\n  int v27;\n  long long v29;\n  long long v30;\n  int window[4];\n  char v32;\n  unsigned long long v33;\n  v2 = 0;\n  v33 = __readfsqword(40u);\n  v3 = &(*board)[3];\n  do {\n    v4 = *v3 == player;\n    v3 += 7;\n    v2 += v4;\n  } while (v3 != &(*board)[45]);\n  v5 = &(*board)[4];\n  do {\n    v6 = (const __m128i *)(v5 - 4);\n    do {\n      v7 = _mm_loadu_si128(v6);\n      v6 = (const __m128i *)((char *)v6 + 4);\n      *(__m128i *)window = v7;\n      evaluate_window(window, player);\n    } while (v6 != (const __m128i *)v5);\n    v5 = &v6[1].m128i_i32[3];\n  } while ((int *)((char *)&v6[1].m128i_u64[1] + 4) != &(*board)[46]);\n  for (i = 0LL; i != 7; ++i) {\n    v9 = 0;\n    v10 = &(*board)[i];\n    do {\n      v11 = window;\n      v12 = v10;\n      do {\n        v13 = *v12;\n        ++v11;\n        v12 += 7;\n        *(v11 - 1) = v13;\n      } while (v11 != (int *)&v32);\n      ++v9;\n      v10 += 7;\n      evaluate_window(window, player);\n    } while (v9 != 3);\n  }\n  v29 = 21LL;\n  do {\n    v14 = 0;\n    v15 = &(*board)[v29];\n    do {\n      v16 = window;\n      v17 = v15;\n      do {\n        v18 = *v17;\n        ++v16;\n        v17 -= 6;\n        *(v16 - 1) = v18;\n      } while (v16 != (int *)&v32);\n      ++v14;\n      ++v15;\n      evaluate_window(window, player);\n    } while (v14 != 4);\n    ++v9;\n    v29 += 7LL;\n  } while (v9 != 6);\n  v30 = 0LL;\n  for (j = 0; j != 3; ++j) {\n    v20 = 0;\n    v21 = &(*board)[v30];\n    do {\n      v22 = window;\n      v23 = v21;\n      do {\n        v24 = *v23;\n        ++v22;\n        v23 += 8;\n        *(v22 - 1) = v24;\n      } while (v22 != (int *)&v32);\n      ++v20;\n      ++v21;\n      v25 = evaluate_window(window, player);\n      v27 = v25 + v26;\n    } while (v20 != 4);\n    v30 += 7LL;\n  }\n  return v27;\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<score_position>:\nendbr64\npush   %r15\nxor    %edx,%edx\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %esi,%ebx\nmov    %rdi,%rsi\nadd    $0xb4,%rsi\nsub    $0x38,%rsp\nmov    %rdi,(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nlea    0xc(%rdi),%rax\nnopl   0x0(%rax,%rax,1)\nxor    %ecx,%ecx\ncmp    %ebx,(%rax)\nsete   %cl\nadd    $0x1c,%rax\nadd    %ecx,%edx\ncmp    %rsi,%rax\njne    1660 <score_position+0x40>\nmov    (%rsp),%rax\nlea    (%rdx,%rdx,2),%r11d\nlea    0x10(%rsp),%r15\nlea    0x10(%rax),%r13\nlea    0xb8(%rax),%r14\nnopw   0x0(%rax,%rax,1)\nlea    -0x10(%r13),%r12\nmovdqu (%r12),%xmm0\nmov    %ebx,%esi\nmov    %r15,%rdi\nadd    $0x4,%r12\nmovaps %xmm0,0x10(%rsp)\ncall   1590 <evaluate_window>\nadd    %eax,%r11d\ncmp    %r13,%r12\njne    1694 <score_position+0x74>\nlea    0x1c(%r12),%r13\ncmp    %r14,%r13\njne    1690 <score_position+0x70>\nxor    %r13d,%r13d\nlea    0x20(%rsp),%r12\nnopw   0x0(%rax,%rax,1)\nmov    (%rsp),%rax\nxor    %r14d,%r14d\nlea    (%rax,%r13,4),%rbp\nmov    %r15,%rax\nmov    %rbp,%rdx\nmov    (%rdx),%ecx\nadd    $0x4,%rax\nadd    $0x1c,%rdx\nmov    %ecx,-0x4(%rax)\ncmp    %r12,%rax\njne    16e1 <score_position+0xc1>\nmov    %ebx,%esi\nmov    %r15,%rdi\nadd    $0x1,%r14d\nadd    $0x1c,%rbp\ncall   1590 <evaluate_window>\nadd    %eax,%r11d\ncmp    $0x3,%r14d\njne    16db <score_position+0xbb>\nadd    $0x1,%r13\ncmp    $0x7,%r13\njne    16d0 <score_position+0xb0>\nmovq   $0x15,0x8(%rsp)\nmov    (%rsp),%rax\nmov    0x8(%rsp),%rdi\nxor    %r13d,%r13d\nlea    (%rax,%rdi,4),%rbp\nmov    %r15,%rax\nmov    %rbp,%rdx\nmov    (%rdx),%ecx\nadd    $0x4,%rax\nsub    $0x18,%rdx\nmov    %ecx,-0x4(%rax)\ncmp    %r12,%rax\njne    1737 <score_position+0x117>\nmov    %ebx,%esi\nmov    %r15,%rdi\nadd    $0x1,%r13d\nadd    $0x4,%rbp\ncall   1590 <evaluate_window>\nadd    %eax,%r11d\ncmp    $0x4,%r13d\njne    1731 <score_position+0x111>\nadd    $0x1,%r14d\naddq   $0x7,0x8(%rsp)\ncmp    $0x6,%r14d\njne    1721 <score_position+0x101>\nmovq   $0x0,0x8(%rsp)\nxor    %ebp,%ebp\nmov    (%rsp),%rax\nmov    0x8(%rsp),%rdi\nxor    %r13d,%r13d\nlea    (%rax,%rdi,4),%r14\nmov    %r15,%rax\nmov    %r14,%rdx\nmov    (%rdx),%ecx\nadd    $0x4,%rax\nadd    $0x20,%rdx\nmov    %ecx,-0x4(%rax)\ncmp    %r12,%rax\njne    1795 <score_position+0x175>\nmov    %ebx,%esi\nmov    %r15,%rdi\nadd    $0x1,%r13d\nadd    $0x4,%r14\ncall   1590 <evaluate_window>\nadd    %eax,%r11d\ncmp    $0x4,%r13d\njne    178f <score_position+0x16f>\nadd    $0x1,%ebp\naddq   $0x7,0x8(%rsp)\ncmp    $0x3,%ebp\njne    177f <score_position+0x15f>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    17f2 <score_position+0x1d2>\nadd    $0x38,%rsp\nmov    %r11d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "terminal_score", "content": "// Check if terminal state has been reached and return a score.\n// If player wins, return WIN_SCORE; if opponent wins, return LOSS_SCORE; if draw return 0.\nint terminal_score(int board[ROWS][COLS], int player) {\n    int opp = (player == 1) ? 2 : 1;\n    if (check_win(board, player))\n        return WIN_SCORE;\n    if (check_win(board, opp))\n        return LOSS_SCORE;\n    return 0;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "terminal_score", "address": "0x1800", "label": "terminal_score", "content": "int __fastcall terminal_score(int (*board)[7], int player)\n{\n  int v2; // r8d\n  int *v3; // r11\n  int result; // eax\n\n  v2 = check_win(board, player);\n  result = 100000;\n  if ( !v2 )\n  {\n    result = check_win((int (*)[7])v3, (player == 1) + 1);\n    if ( result )\n      return -100000;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int terminal_score(int (*board)[7], int player) {\n  int v2;\n  int *v3;\n  int result;\n  v2 = check_win(board, player);\n  result = 100000;\n  if (!v2) {\n    result = check_win((int(*)[7])v3, (player == 1) + 1);\n    if (result) return -100000;\n  }\n  return result;\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<terminal_score>:\nendbr64\npush   %rbp\nxor    %ebp,%ebp\ncmp    $0x1,%esi\nmov    %rdi,%r11\nsete   %bpl\nadd    $0x1,%ebp\ncall   1430 <check_win>\nmov    %eax,%r8d\nmov    $0x186a0,%eax\ntest   %r8d,%r8d\njne    1834 <terminal_score+0x34>\nmov    %ebp,%esi\nmov    %r11,%rdi\ncall   1430 <check_win>\ntest   %eax,%eax\njne    1836 <terminal_score+0x36>\npop    %rbp\nret\nmov    $0xfffe7960,%eax\npop    %rbp\nret\nnopl   (%rax)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "undo_move", "content": "// Undo a move in the given column (remove the top piece).\nvoid undo_move(int board[ROWS][COLS], int col) {\n    for (int r = 0; r < ROWS; r++) {\n        if (board[r][col] != EMPTY) {\n            board[r][col] = EMPTY;\n            break;\n        }\n    }\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "undo_move", "address": "0x13d0", "label": "undo_move", "content": "void __fastcall undo_move(int (*board)[7], int col)\n{\n  int *v2; // rax\n\n  v2 = &(*board)[42];\n  while ( !(*board)[col] )\n  {\n    if ( ++board == (int (*)[7])v2 )\n      return;\n  }\n  (*board)[col] = 0;\n}\n"}, "pseudo_normalize": "void undo_move(int (*board)[7], int col) {\n  int *v2;\n  v2 = &(*board)[42];\n  while (!(*board)[col]) {\n    if (++board == (int(*)[7])v2) return;\n  }\n  (*board)[col] = 0;\n}", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<undo_move>:\nendbr64\nlea    0xa8(%rdi),%rax\nmovslq %esi,%rsi\nmov    (%rdi,%rsi,4),%edx\ntest   %edx,%edx\njne    13f0 <undo_move+0x20>\nadd    $0x1c,%rdi\ncmp    %rax,%rdi\njne    13de <undo_move+0xe>\nret\nnop\nmovl   $0x0,(%rdi,%rsi,4)\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "connect4-minimax/connect4-minimax.c", "function_name": "valid_move", "content": "// Returns 1 if the column is not full.\nint valid_move(int board[ROWS][COLS], int col) {\n    return board[0][col] == EMPTY;\n}\n"}, "pseudo": {"path": "connect4-minimax/connect4-minimax.host.O2.pseudo", "function_name": "valid_move", "address": "0x1330", "label": "valid_move", "content": "int __fastcall valid_move(int (*board)[7], int col)\n{\n  return (*board)[col] == 0;\n}\n"}, "pseudo_normalize": "", "binary": "connect4-minimax/connect4-minimax.host.O2", "assembly": "<valid_move>:\nendbr64\nmovslq %esi,%rsi\nxor    %eax,%eax\nmov    (%rdi,%rsi,4),%edx\ntest   %edx,%edx\nsete   %al\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "comparePoints", "content": "// Comparator for sorting points with respect to global pivot p0.\n// Returns a negative number if a comes before b (i.e. a has a smaller polar angle),\n// zero if they are collinear (in which case the closer one comes first),\n// and a positive number otherwise.\nint comparePoints(Point a, Point b) {\n    int o = orientation(p0, a, b);\n    if (o == 0) {\n        // Collinear; sort by distance to p0.\n        return distanceSq(p0, a) - distanceSq(p0, b);\n    }\n    // If a is counterclockwise to b then a comes first.\n    return (o < 0) ? -1 : 1;\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O2.pseudo", "function_name": "comparePoints", "address": "0x1460", "label": "comparePoints", "content": "int __fastcall comparePoints(Point a, Point b)\n{\n  int v2; // edx\n\n  v2 = (a.y - p0.y) * (b.x - a.x) - (a.x - p0.x) * (b.y - a.y);\n  if ( v2 )\n    return 2 * (v2 > 0) - 1;\n  else\n    return (a.y - p0.y) * (a.y - p0.y)\n         + (a.x - p0.x) * (a.x - p0.x)\n         - ((b.y - p0.y) * (b.y - p0.y)\n          + (b.x - p0.x) * (b.x - p0.x));\n}\n"}, "pseudo_normalize": "int comparePoints(Point a, Point b) {\n  int v2;\n  v2 = (a.y - p0.y) * (b.x - a.x) - (a.x - p0.x) * (b.y - a.y);\n  if (v2)\n    return 2 * (v2 > 0) - 1;\n  else\n    return (a.y - p0.y) * (a.y - p0.y) + (a.x - p0.x) * (a.x - p0.x) -\n           ((b.y - p0.y) * (b.y - p0.y) + (b.x - p0.x) * (b.x - p0.x));\n}", "binary": "convex-hull/convex-hull.host.O2", "assembly": "<comparePoints>:\nendbr64\nmov    %rdi,%r9\nmov    %rsi,%rcx\nmov    0x3dff(%rip),%r11d\nmov    %esi,%edx\nsar    $0x20,%r9\nmov    0x3df6(%rip),%r10d\nmov    %edi,%eax\nsub    %edi,%edx\nsar    $0x20,%rcx\nmov    %r9d,%r8d\nsub    %r11d,%eax\nmov    %ecx,%edi\nsub    %r10d,%r8d\nsub    %r9d,%edi\nimul   %r8d,%edx\nimul   %eax,%edi\nsub    %edi,%edx\ntest   %edx,%edx\nje     14b0 <comparePoints+0x50>\nsetg   %al\nmovzbl %al,%eax\nlea    -0x1(%rax,%rax,1),%eax\nret\nnopl   0x0(%rax)\nsub    %r11d,%esi\nimul   %eax,%eax\nsub    %r10d,%ecx\nimul   %r8d,%r8d\nimul   %esi,%esi\nimul   %ecx,%ecx\nadd    %r8d,%eax\nadd    %ecx,%esi\nsub    %esi,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "distanceSq", "content": "// Computes the squared Euclidean distance between points p and q.\nint distanceSq(Point p, Point q) {\n    int dx = q.x - p.x;\n    int dy = q.y - p.y;\n    return dx * dx + dy * dy;\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O2.pseudo", "function_name": "distanceSq", "address": "0x1440", "label": "distanceSq", "content": "int __fastcall distanceSq(Point p, Point q)\n{\n  return (q.y - p.y) * (q.y - p.y) + (q.x - p.x) * (q.x - p.x);\n}\n"}, "pseudo_normalize": "", "binary": "convex-hull/convex-hull.host.O2", "assembly": "<distanceSq>:\nendbr64\nmov    %esi,%eax\nsar    $0x20,%rsi\nsub    %edi,%eax\nsar    $0x20,%rdi\nsub    %edi,%esi\nimul   %eax,%eax\nimul   %esi,%esi\nadd    %esi,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "main", "content": "int main() {\n    // Seed the random number generator with a fixed value for reproducibility.\n    libmin_srand(42);\n\n    // Generate a set of random points.\n    Point points[NUM_POINTS];\n    for (int i = 0; i < NUM_POINTS; i++) {\n        points[i].x = libmin_rand() % 101;  // x in range [0, 100]\n        points[i].y = libmin_rand() % 101;  // y in range [0, 100]\n    }\n\n    // Find the pivot: the point with the lowest y-coordinate.\n    // On a tie, choose the point with the lowest x-coordinate.\n    int minIdx = 0;\n    for (int i = 1; i < NUM_POINTS; i++) {\n        if (points[i].y < points[minIdx].y ||\n           (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x)) {\n            minIdx = i;\n        }\n    }\n    // Swap the pivot with the first element.\n    Point temp = points[0];\n    points[0] = points[minIdx];\n    points[minIdx] = temp;\n    p0 = points[0];  // Set the global pivot.\n\n    // Sort the remaining points according to the polar angle relative to p0.\n    sortPoints(points, NUM_POINTS);\n\n    // Allocate an array to store the convex hull points.\n    Point hull[NUM_POINTS];\n    int hullSize = 0;\n\n    // Apply the Graham scan: iterate through all points.\n    for (int i = 0; i < NUM_POINTS; i++) {\n        // While the last two points in the hull and the current point do not make\n        // a counterclockwise turn, remove the top of the hull.\n        while (hullSize >= 2 &&\n               orientation(hull[hullSize - 2], hull[hullSize - 1], points[i]) <= 0) {\n            hullSize--;  // Pop the last point.\n        }\n        hull[hullSize++] = points[i];  // Push the current point.\n    }\n\n    // Print the convex hull result.\n    libmin_printf(\"Convex Hull Points (in order):\\n\");\n    for (int i = 0; i < hullSize; i++) {\n        libmin_printf(\"(%d, %d)\\n\", hull[i].x, hull[i].y);\n    }\n\n    // Optionally, compute a checksum (sum of coordinates) and print hull size.\n    int checksum = 0;\n    for (int i = 0; i < hullSize; i++) {\n        checksum += hull[i].x + hull[i].y;\n    }\n    libmin_printf(\"Hull size: %d, Checksum: %d\\n\", hullSize, checksum);\n\n    libtarg_success();\n    return 0;\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Point *v3; // rbx\n  Point *v4; // r13\n  int *p_y; // rdx\n  int v6; // eax\n  __int64 v7; // rcx\n  int y; // esi\n  Point v9; // rax\n  __int64 v10; // rsi\n  int v11; // r12d\n  __int64 v12; // rcx\n  Point *v13; // rdx\n  int x; // eax\n  int v15; // r8d\n  Point *v16; // r9\n  int v17; // r10d\n  Point v18; // rax\n  Point *v19; // rbp\n  Point *v20; // r13\n  int v21; // edx\n  int v22; // esi\n  int v23; // edx\n  int v24; // eax\n  __int64 v25; // [rsp+8h] [rbp-360h]\n  Point points[50]; // [rsp+10h] [rbp-358h] BYREF\n  Point hull[50]; // [rsp+1A0h] [rbp-1C8h] BYREF\n  unsigned __int64 v28; // [rsp+338h] [rbp-30h]\n\n  v28 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  v3 = points;\n  v4 = points;\n  do\n  {\n    ++v4;\n    v4[-1].x = libmin_rand() % 0x65;\n    v4[-1].y = libmin_rand() % 0x65;\n  }\n  while ( v4 != hull );\n  p_y = &points[1].y;\n  v6 = 1;\n  v7 = 0LL;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      y = points[v7].y;\n      if ( *p_y >= y )\n        break;\n      v7 = v6;\nLABEL_8:\n      ++v6;\n      p_y += 2;\n      if ( v6 == 50 )\n      {\nLABEL_9:\n        v9 = points[0];\n        v10 = 50LL;\n        v11 = 0;\n        points[0] = points[v7];\n        points[v7] = v9;\n        p0 = points[0];\n        sortPoints(points, 50);\n        while ( 1 )\n        {\n          v12 = v11;\n          v13 = &hull[v11];\n          if ( v11 > 1 )\n          {\n            do\n            {\n              x = v13[-1].x;\n              v15 = v13[-1].y;\n              v16 = v13;\n              v17 = v12 - 1;\n              --v13;\n              v10 = (unsigned int)((v3->x - x) * (v15 - v16[-2].y));\n              if ( (int)v10 > (v3->y - v15) * (x - v16[-2].x) )\n                break;\n              v12 = v17;\n            }\n            while ( v17 > 1 );\n          }\n          v18 = *v3++;\n          v11 = v12 + 1;\n          hull[v12] = v18;\n          if ( v3 == hull )\n          {\n            v25 = v12;\n            v19 = v3;\n            libmin_printf(\"Convex Hull Points (in order):\\n\", v10, v13);\n            v20 = &hull[v25 + 1];\n            do\n            {\n              v21 = v19->y;\n              v22 = v19->x;\n              ++v19;\n              libmin_printf(\"(%d, %d)\\n\", v22, v21);\n            }\n            while ( v20 != v19 );\n            v23 = 0;\n            do\n            {\n              v24 = v3->y;\n              ++v3;\n              v23 += v3[-1].x + v24;\n            }\n            while ( v3 != v20 );\n            libmin_printf(\"Hull size: %d, Checksum: %d\\n\", v11, v23);\n            libtarg_success();\n          }\n        }\n      }\n    }\n    if ( *p_y == y && *(p_y - 1) < points[v7].x )\n    {\n      v7 = v6;\n      goto LABEL_8;\n    }\n    ++v6;\n    p_y += 2;\n    if ( v6 == 50 )\n      goto LABEL_9;\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  Point *v3;\n  Point *v4;\n  int *p_y;\n  int v6;\n  long long v7;\n  int y;\n  Point v9;\n  long long v10;\n  int v11;\n  long long v12;\n  Point *v13;\n  int x;\n  int v15;\n  Point *v16;\n  int v17;\n  Point v18;\n  Point *v19;\n  Point *v20;\n  int v21;\n  int v22;\n  int v23;\n  int v24;\n  long long v25;\n  Point points[50];\n  Point hull[50];\n  unsigned long long v28;\n  v28 = __readfsqword(40u);\n  libmin_srand(42u);\n  v3 = points;\n  v4 = points;\n  do {\n    ++v4;\n    v4[-1].x = libmin_rand() % 101;\n    v4[-1].y = libmin_rand() % 101;\n  } while (v4 != hull);\n  p_y = &points[1].y;\n  v6 = 1;\n  v7 = 0LL;\n  while (1) {\n    while (1) {\n      y = points[v7].y;\n      if (*p_y >= y) break;\n      v7 = v6;\n    LABEL_8:\n      ++v6;\n      p_y += 2;\n      if (v6 == 50) {\n      LABEL_9:\n        v9 = points[0];\n        v10 = 50LL;\n        v11 = 0;\n        points[0] = points[v7];\n        points[v7] = v9;\n        p0 = points[0];\n        sortPoints(points, 50);\n        while (1) {\n          v12 = v11;\n          v13 = &hull[v11];\n          if (v11 > 1) {\n            do {\n              x = v13[-1].x;\n              v15 = v13[-1].y;\n              v16 = v13;\n              v17 = v12 - 1;\n              --v13;\n              v10 = (unsigned int)((v3->x - x) * (v15 - v16[-2].y));\n              if ((int)v10 > (v3->y - v15) * (x - v16[-2].x)) break;\n              v12 = v17;\n            } while (v17 > 1);\n          }\n          v18 = *v3++;\n          v11 = v12 + 1;\n          hull[v12] = v18;\n          if (v3 == hull) {\n            v25 = v12;\n            v19 = v3;\n            libmin_printf(\"Convex Hull Points (in order):\\n\", v10, v13);\n            v20 = &hull[v25 + 1];\n            do {\n              v21 = v19->y;\n              v22 = v19->x;\n              ++v19;\n              libmin_printf(\"(%d, %d)\\n\", v22, v21);\n            } while (v20 != v19);\n            v23 = 0;\n            do {\n              v24 = v3->y;\n              ++v3;\n              v23 += v3[-1].x + v24;\n            } while (v3 != v20);\n            libmin_printf(\"Hull size: %d, Checksum: %d\\n\", v11, v23);\n            libtarg_success();\n          }\n        }\n      }\n    }\n    if (*p_y == y && *(p_y - 1) < points[v7].x) {\n      v7 = v6;\n      goto LABEL_8;\n    }\n    ++v6;\n    p_y += 2;\n    if (v6 == 50) goto LABEL_9;\n  }\n}", "binary": "convex-hull/convex-hull.host.O2", "assembly": "<main>:\nendbr64\npush   %r14\nmov    $0x2a,%edi\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x340,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x338(%rsp)\nxor    %eax,%eax\nlea    0x10(%rsp),%r12\nlea    0x1a0(%rsp),%rbp\ncall   2d20 <libmin_srand>\nmov    %r12,%rbx\nmov    %r12,%r13\nnopl   0x0(%rax,%rax,1)\ncall   2d80 <libmin_rand>\nadd    $0x8,%r13\nmov    %eax,%ecx\nmov    %eax,%edx\nimul   $0x446f8657,%rcx,%rcx\nshr    $0x20,%rcx\nsub    %ecx,%edx\nshr    %edx\nadd    %ecx,%edx\nshr    $0x6,%edx\nimul   $0x65,%edx,%edx\nsub    %edx,%eax\nmov    %eax,-0x8(%r13)\ncall   2d80 <libmin_rand>\nmov    %eax,%ecx\nmov    %eax,%edx\nimul   $0x446f8657,%rcx,%rcx\nshr    $0x20,%rcx\nsub    %ecx,%edx\nshr    %edx\nadd    %ecx,%edx\nshr    $0x6,%edx\nimul   $0x65,%edx,%edx\nsub    %edx,%eax\nmov    %eax,-0x4(%r13)\ncmp    %rbp,%r13\njne    1148 <main+0x48>\nlea    0x1c(%rsp),%rdx\nmov    $0x1,%eax\nxor    %ecx,%ecx\njmp    11c2 <main+0xc2>\nnopl   0x0(%rax,%rax,1)\nje     12f0 <main+0x1f0>\nadd    $0x1,%eax\nadd    $0x8,%rdx\ncmp    $0x32,%eax\nje     11d9 <main+0xd9>\nmov    0x14(%rsp,%rcx,8),%esi\ncmp    %esi,(%rdx)\njge    11b0 <main+0xb0>\nmovslq %eax,%rcx\nadd    $0x1,%eax\nadd    $0x8,%rdx\ncmp    $0x32,%eax\njne    11c2 <main+0xc2>\nmov    0x10(%rsp),%rax\nmov    0x10(%rsp,%rcx,8),%rdx\nmov    %r12,%rdi\nmov    $0x32,%esi\nxor    %r12d,%r12d\nmov    %rdx,0x10(%rsp)\nmov    %rax,0x10(%rsp,%rcx,8)\nmov    0x10(%rsp),%rax\nmov    %rax,0x406c(%rip)\ncall   14d0 <sortPoints>\nnopl   0x0(%rax)\nmovslq %r12d,%rax\nmovslq %r12d,%rcx\nlea    0x0(%rbp,%rax,8),%rdx\ncmp    $0x1,%ecx\njle    1260 <main+0x160>\nmov    -0x8(%rdx),%eax\nmov    -0x4(%rdx),%r8d\nmov    %rdx,%r9\nlea    -0x1(%rcx),%r10d\nmov    (%rbx),%edi\nsub    $0x8,%rdx\nmov    %r8d,%esi\nsub    -0xc(%r9),%esi\nsub    %eax,%edi\nsub    -0x10(%r9),%eax\nimul   %edi,%esi\nmov    0x4(%rbx),%edi\nsub    %r8d,%edi\nimul   %edi,%eax\ncmp    %eax,%esi\njg     1260 <main+0x160>\nmovslq %r10d,%rcx\ncmp    $0x1,%ecx\njg     1220 <main+0x120>\nnopl   0x0(%rax)\nmov    (%rbx),%rax\nadd    $0x8,%rbx\nlea    0x1(%rcx),%r12d\nmov    %rax,0x1a0(%rsp,%rcx,8)\ncmp    %rbp,%rbx\njne    1210 <main+0x110>\nlea    0x1d89(%rip),%rdi\nxor    %eax,%eax\nmov    %rcx,0x8(%rsp)\nmov    %rbx,%rbp\ncall   2b10 <libmin_printf>\nmov    0x8(%rsp),%rcx\nlea    0x1d8e(%rip),%r14\nlea    0x1a8(%rsp,%rcx,8),%r13\nnopw   0x0(%rax,%rax,1)\nmov    0x4(%rbp),%edx\nmov    0x0(%rbp),%esi\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x8,%rbp\ncall   2b10 <libmin_printf>\ncmp    %rbp,%r13\njne    12a8 <main+0x1a8>\nxor    %edx,%edx\nnopl   0x0(%rax,%rax,1)\nmov    0x4(%rbx),%eax\nadd    $0x8,%rbx\nadd    -0x8(%rbx),%eax\nadd    %eax,%edx\ncmp    %r13,%rbx\njne    12c8 <main+0x1c8>\nmov    %r12d,%esi\nlea    0x1d4f(%rip),%rdi\nxor    %eax,%eax\ncall   2b10 <libmin_printf>\ncall   15d0 <libtarg_success>\nnop\nmov    0x10(%rsp,%rcx,8),%esi\ncmp    %esi,-0x4(%rdx)\njge    11b6 <main+0xb6>\nmovslq %eax,%rcx\njmp    11cd <main+0xcd>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "orientation", "content": "// Returns the orientation of the triplet (p, q, r).\n//  0  : p, q, r are collinear\n// -1  : counterclockwise turn (left turn)\n//  1  : clockwise turn (right turn)\nint orientation(Point p, Point q, Point r) {\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0)\n        return 0;\n    return (val > 0) ? 1 : -1;\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O2.pseudo", "function_name": "orientation", "address": "0x1400", "label": "orientation", "content": "int __fastcall orientation(Point p, Point q, Point r)\n{\n  int result; // eax\n\n  result = (r.x - q.x) * (q.y - p.y) - (r.y - q.y) * (q.x - p.x);\n  if ( result )\n    return 2 * (result > 0) - 1;\n  return result;\n}\n"}, "pseudo_normalize": "int orientation(Point p, Point q, Point r) {\n  int result;\n  result = (r.x - q.x) * (q.y - p.y) - (r.y - q.y) * (q.x - p.x);\n  if (result) return 2 * (result > 0) - 1;\n  return result;\n}", "binary": "convex-hull/convex-hull.host.O2", "assembly": "<orientation>:\nendbr64\nmov    %rsi,%rcx\nmov    %rdi,%r8\nsar    $0x20,%rcx\nsar    $0x20,%r8\nmov    %ecx,%eax\nsub    %r8d,%eax\nmov    %edx,%r8d\nsar    $0x20,%rdx\nsub    %esi,%r8d\nsub    %ecx,%edx\nsub    %edi,%esi\nimul   %r8d,%eax\nimul   %edx,%esi\nsub    %esi,%eax\ntest   %eax,%eax\nje     143c <orientation+0x3c>\nsetg   %al\nmovzbl %al,%eax\nlea    -0x1(%rax,%rax,1),%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "convex-hull/convex-hull.c", "function_name": "sortPoints", "content": "// A simple insertion sort for an array of Points.\nvoid sortPoints(Point points[], int n) {\n    for (int i = 1; i < n; i++) {\n        Point key = points[i];\n        int j = i - 1;\n        while (j >= 0 && comparePoints(points[j], key) > 0) {\n            points[j + 1] = points[j];\n            j--;\n        }\n        points[j + 1] = key;\n    }\n}\n"}, "pseudo": {"path": "convex-hull/convex-hull.host.O2.pseudo", "function_name": "sortPoints", "address": "0x14d0", "label": "sortPoints", "content": "void __fastcall sortPoints(Point *points, int n)\n{\n  __int64 v2; // rbp\n  int x; // r11d\n  int y; // r10d\n  __int64 v5; // rax\n  int v6; // edx\n  int v7; // ecx\n  int v8; // r8d\n  int v9; // edx\n  int v10; // ecx\n  Point *v11; // rax\n\n  if ( n > 1 )\n  {\n    v2 = 0LL;\n    do\n    {\n      x = points[v2 + 1].x;\n      y = points[v2 + 1].y;\n      v5 = v2;\n      do\n      {\n        v6 = points[v5].x;\n        v7 = x - v6;\n        v8 = points[v5].y - p0.y;\n        v9 = v6 - p0.x;\n        v10 = v8 * v7 - v9 * (y - points[v5].y);\n        if ( v10 )\n        {\n          if ( v10 <= 0 )\n          {\n            v11 = &points[(int)v5 + 1];\n            goto LABEL_10;\n          }\n        }\n        else if ( v8 * v8 + v9 * v9 <= (y - p0.y) * (y - p0.y) + (x - p0.x) * (x - p0.x) )\n        {\n          v11 = &points[(int)v5 + 1];\n          goto LABEL_10;\n        }\n        points[v5 + 1] = points[v5];\n        --v5;\n      }\n      while ( (_DWORD)v5 != -1 );\n      v11 = points;\nLABEL_10:\n      ++v2;\n      v11->x = x;\n      v11->y = y;\n    }\n    while ( n - 1 != v2 );\n  }\n}\n"}, "pseudo_normalize": "void sortPoints(Point *points, int n) {\n  long long v2;\n  int x;\n  int y;\n  long long v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  Point *v11;\n  if (n > 1) {\n    v2 = 0LL;\n    do {\n      x = points[v2 + 1].x;\n      y = points[v2 + 1].y;\n      v5 = v2;\n      do {\n        v6 = points[v5].x;\n        v7 = x - v6;\n        v8 = points[v5].y - p0.y;\n        v9 = v6 - p0.x;\n        v10 = v8 * v7 - v9 * (y - points[v5].y);\n        if (v10) {\n          if (v10 <= 0) {\n            v11 = &points[(int)v5 + 1];\n            goto LABEL_10;\n          }\n        } else if (v8 * v8 + v9 * v9 <=\n                   (y - p0.y) * (y - p0.y) + (x - p0.x) * (x - p0.x)) {\n          v11 = &points[(int)v5 + 1];\n          goto LABEL_10;\n        }\n        points[v5 + 1] = points[v5];\n        --v5;\n      } while ((uint32_t)v5 != -1);\n      v11 = points;\n    LABEL_10:\n      ++v2;\n      v11->x = x;\n      v11->y = y;\n    } while (n - 1 != v2);\n  }\n}", "binary": "convex-hull/convex-hull.host.O2", "assembly": "<sortPoints>:\nendbr64\ncmp    $0x1,%esi\njle    15c5 <sortPoints+0xf5>\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nlea    -0x1(%rsi),%r12d\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nlea    0x3d7c(%rip),%rbx\nnopl   0x0(%rax)\nmov    0x8(%rdi,%rbp,8),%r11d\nmov    0xc(%rdi,%rbp,8),%r10d\nmov    %rbp,%rax\njmp    1528 <sortPoints+0x58>\nnopw   0x0(%rax,%rax,1)\njle    1590 <sortPoints+0xc0>\nmov    (%rdi,%rax,8),%rdx\nmov    %rdx,0x8(%rdi,%rax,8)\nsub    $0x1,%rax\ncmp    $0xffffffff,%eax\nje     15c0 <sortPoints+0xf0>\nmov    (%rdi,%rax,8),%esi\nmov    0x4(%rdi,%rax,8),%r15d\nmov    %r11d,%ecx\nmov    %eax,%r9d\nmov    (%rbx),%r14d\nmov    0x3d34(%rip),%r13d\nmov    %esi,%edx\nsub    %esi,%ecx\nmov    %r15d,%r8d\nmov    %r10d,%esi\nsub    %r13d,%r8d\nsub    %r14d,%edx\nsub    %r15d,%esi\nimul   %r8d,%ecx\nimul   %edx,%esi\nsub    %esi,%ecx\ntest   %ecx,%ecx\njne    1510 <sortPoints+0x40>\nmov    %r11d,%ecx\nimul   %edx,%edx\nmov    %r10d,%esi\nsub    %r14d,%ecx\nimul   %r8d,%r8d\nsub    %r13d,%esi\nimul   %ecx,%ecx\nimul   %esi,%esi\nadd    %r8d,%edx\nadd    %esi,%ecx\ncmp    %ecx,%edx\njg     1512 <sortPoints+0x42>\nlea    0x1(%rax),%eax\ncltq\nlea    (%rdi,%rax,8),%rax\njmp    159b <sortPoints+0xcb>\nnopl   (%rax)\nadd    $0x1,%r9d\nmovslq %r9d,%r9\nlea    (%rdi,%r9,8),%rax\nadd    $0x1,%rbp\nmov    %r11d,(%rax)\nmov    %r10d,0x4(%rax)\ncmp    %rbp,%r12\njne    14f8 <sortPoints+0x28>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    %rdi,%rax\njmp    159b <sortPoints+0xcb>\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PFunc_1", "content": " /* PProc_8 */\n\n\nEnumeration PFunc_1 (Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val)\n/*************************************************/\n    /* executed three times                                         */\n    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */\n    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */\n    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */\n{\n  Capital_Letter        Ch_1_Loc;\n  Capital_Letter        Ch_2_Loc;\n\n  Ch_1_Loc = Ch_1_Par_Val;\n  Ch_2_Loc = Ch_1_Loc;\n  if (Ch_2_Loc != Ch_2_Par_Val)\n    /* then, executed */\n    return (Ident_1);\n  else  /* not executed */\n     {\n     Ch_1_Glob = Ch_1_Loc;\n     return (Ident_2);\n     }\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O2.pseudo", "function_name": "PFunc_1", "address": "0x1970", "label": "PFunc_1", "content": "Enumeration __fastcall PFunc_1(Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val)\n{\n  Enumeration result; // eax\n\n  result = Ident_1;\n  if ( Ch_1_Par_Val == Ch_2_Par_Val )\n  {\n    Ch_1_Glob[0] = Ch_1_Par_Val;\n    return 1;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "Enumeration PFunc_1(Capital_Letter Ch_1_Par_Val, Capital_Letter Ch_2_Par_Val) {\n  Enumeration result;\n  result = Ident_1;\n  if (Ch_1_Par_Val == Ch_2_Par_Val) {\n    Ch_1_Glob[0] = Ch_1_Par_Val;\n    return 1;\n  }\n  return result;\n}", "binary": "dhrystone/dhrystone.host.O2", "assembly": "<PFunc_1>:\nendbr64\nxor    %eax,%eax\ncmp    %sil,%dil\nje     1980 <PFunc_1+0x10>\nret\nnopl   0x0(%rax)\nmov    %dil,0x58fd(%rip)\nmov    $0x1,%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PFunc_2", "content": " /* PFunc_1 */\n\n\nBoolean PFunc_2 (Str_30 Str_1_Par_Ref, Str_30 Str_2_Par_Ref)\n/*************************************************/\n    /* executed once */\n    /* Str_1_Par_Ref == \"DHRYSTONE PROGRAM, 1'ST STRING\" */\n    /* Str_2_Par_Ref == \"DHRYSTONE PROGRAM, 2'ND STRING\" */\n{\n  REG One_Thirty        Int_Loc;\n      Capital_Letter    Ch_Loc = 0;\n\n  Int_Loc = 2;\n  while (Int_Loc <= 2) /* loop body executed once */\n    if (PFunc_1 (Str_1_Par_Ref[Int_Loc], Str_2_Par_Ref[Int_Loc+1]) == Ident_1)\n      /* then, executed */\n       {\n       Ch_Loc = 'A';\n       Int_Loc += 1;\n       } /* if, while */\n  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')\n    /* then, not executed */\n    Int_Loc = 7;\n  if (Ch_Loc == 'R')\n    /* then, not executed */\n    return (true);\n  else /* executed */\n     {\n     if (libmin_strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)\n      /* then, not executed */\n        {\n        Int_Loc += 7;\n        Int_Glob = Int_Loc;\n        return (true);\n        }\n     else /* executed */\n        return (false);\n     } /* if Ch_Loc */\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O2.pseudo", "function_name": "PFunc_2", "address": "0x1990", "label": "PFunc_2", "content": "Boolean __fastcall PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref)\n{\n  char v2; // r8\n  char v3; // cl\n  int v4; // eax\n  Boolean v5; // r8d\n\n  v3 = 0;\n  while ( Str_2_Par_Ref[3] == Str_1_Par_Ref[2] )\n  {\n    v3 = 1;\n    v2 = Str_2_Par_Ref[3];\n  }\n  if ( v3 )\n    Ch_1_Glob[0] = v2;\n  v4 = libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref);\n  v5 = 0;\n  if ( v4 > 0 )\n  {\n    Int_Glob = 10;\n    return 1;\n  }\n  return v5;\n}\n"}, "pseudo_normalize": "Boolean PFunc_2(char *Str_1_Par_Ref, char *Str_2_Par_Ref) {\n  char v2;\n  char v3;\n  int v4;\n  Boolean v5;\n  v3 = 0;\n  while (Str_2_Par_Ref[3] == Str_1_Par_Ref[2]) {\n    v3 = 1;\n    v2 = Str_2_Par_Ref[3];\n  }\n  if (v3) Ch_1_Glob[0] = v2;\n  v4 = libmin_strcmp(Str_1_Par_Ref, Str_2_Par_Ref);\n  v5 = 0;\n  if (v4 > 0) {\n    Int_Glob = 10;\n    return 1;\n  }\n  return v5;\n}", "binary": "dhrystone/dhrystone.host.O2", "assembly": "<PFunc_2>:\nendbr64\nsub    $0x8,%rsp\nmovzbl 0x3(%rsi),%eax\nmovzbl 0x2(%rdi),%edx\nxor    %ecx,%ecx\ncmp    %dl,%al\nje     19d8 <PFunc_2+0x48>\ntest   %cl,%cl\nje     19b1 <PFunc_2+0x21>\nmov    %r8b,0x58d3(%rip)\ncall   3150 <libmin_strcmp>\nxor    %r8d,%r8d\ntest   %eax,%eax\njle    19cd <PFunc_2+0x3d>\nmovl   $0xa,0x58c1(%rip)\nmov    $0x1,%r8d\nmov    %r8d,%eax\nadd    $0x8,%rsp\nret\nnopl   (%rax)\nmov    $0x1,%ecx\nmov    %eax,%r8d\njmp    19a2 <PFunc_2+0x12>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PFunc_3", "content": " /* PFunc_2 */\n\n\nBoolean PFunc_3 (Enumeration Enum_Par_Val)\n/***************************/\n    /* executed once        */\n    /* Enum_Par_Val == Ident_3 */\n{\n  Enumeration Enum_Loc;\n\n  Enum_Loc = Enum_Par_Val;\n  if (Enum_Loc == Ident_3)\n    /* then, executed */\n    return (true);\n  else /* not executed */\n    return (false);\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O2.pseudo", "function_name": "PFunc_3", "address": "0x19f0", "label": "PFunc_3", "content": "Boolean __fastcall PFunc_3(Enumeration Enum_Par_Val)\n{\n  return Enum_Par_Val == Ident_3;\n}\n"}, "pseudo_normalize": "", "binary": "dhrystone/dhrystone.host.O2", "assembly": "<PFunc_3>:\nendbr64\nxor    %eax,%eax\ncmp    $0x2,%edi\nsete   %al\nret\nnopl   (%rax)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PProc_6", "content": "int\nPProc_6 (Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par)\n/*********************************/\n    /* executed once */\n    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */\n{\n  *Enum_Ref_Par = Enum_Val_Par;\n  if (! PFunc_3 (Enum_Val_Par))\n    /* then, not executed */\n    *Enum_Ref_Par = Ident_4;\n  switch (Enum_Val_Par)\n     {\n     case Ident_1:\n        *Enum_Ref_Par = Ident_1;\n        break;\n     case Ident_2:\n        if (Int_Glob > 100)\n           /* then */\n           *Enum_Ref_Par = Ident_1;\n        else\n           *Enum_Ref_Par = Ident_4;\n        break;\n     case Ident_3: /* executed */\n        *Enum_Ref_Par = Ident_2;\n        break;\n     case Ident_4:\n        break;\n     case Ident_5:\n        *Enum_Ref_Par = Ident_3;\n        break;\n     } /* switch */\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O2.pseudo", "function_name": "PProc_6", "address": "0x18a0", "label": "PProc_6", "content": "int __fastcall PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par)\n{\n  if ( Enum_Val_Par == Ident_3 )\n  {\n    *Enum_Ref_Par = Ident_2;\n    return 0;\n  }\n  else\n  {\n    *Enum_Ref_Par = Ident_4;\n    if ( Enum_Val_Par == Ident_2 )\n    {\n      if ( Int_Glob <= 100 )\n        return 0;\n    }\n    else if ( (unsigned int)Enum_Val_Par > Ident_2 )\n    {\n      if ( Enum_Val_Par == Ident_5 )\n        *Enum_Ref_Par = Ident_3;\n      return 0;\n    }\n    *Enum_Ref_Par = Ident_1;\n    return 0;\n  }\n}\n"}, "pseudo_normalize": "int PProc_6(Enumeration Enum_Val_Par, Enumeration *Enum_Ref_Par) {\n  if (Enum_Val_Par == Ident_3) {\n    *Enum_Ref_Par = Ident_2;\n    return 0;\n  } else {\n    *Enum_Ref_Par = Ident_4;\n    if (Enum_Val_Par == Ident_2) {\n      if (Int_Glob <= 100) return 0;\n    } else if ((unsigned int)Enum_Val_Par > Ident_2) {\n      if (Enum_Val_Par == Ident_5) *Enum_Ref_Par = Ident_3;\n      return 0;\n    }\n    *Enum_Ref_Par = Ident_1;\n    return 0;\n  }\n}", "binary": "dhrystone/dhrystone.host.O2", "assembly": "<PProc_6>:\nendbr64\ncmp    $0x2,%edi\nje     18e0 <PProc_6+0x40>\nmovl   $0x3,(%rsi)\ncmp    $0x1,%edi\nje     18c8 <PProc_6+0x28>\njbe    18d1 <PProc_6+0x31>\ncmp    $0x4,%edi\njne    18c1 <PProc_6+0x21>\nmovl   $0x2,(%rsi)\nxor    %eax,%eax\nret\nnopl   0x0(%rax)\ncmpl   $0x64,0x59b9(%rip)\njle    18c1 <PProc_6+0x21>\nmovl   $0x0,(%rsi)\nxor    %eax,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmovl   $0x1,(%rsi)\nxor    %eax,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PProc_7", "content": " /* PProc_6 */\n\n\nint\nPProc_7 (int Int_1_Par_Val, int Int_2_Par_Val, int *Int_Par_Ref)\n/**********************************************/\n    /* executed three times                                      */\n    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */\n    /*                  Int_Par_Ref becomes 7                    */\n    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */\n    /*                  Int_Par_Ref becomes 17                   */\n    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */\n    /*                  Int_Par_Ref becomes 18                   */\n{\n  One_Fifty Int_Loc;\n\n  Int_Loc = Int_1_Par_Val + 2;\n  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O2.pseudo", "function_name": "PProc_7", "address": "0x18f0", "label": "PProc_7", "content": "int __fastcall PProc_7(int Int_1_Par_Val, int Int_2_Par_Val, int *Int_Par_Ref)\n{\n  *Int_Par_Ref = Int_1_Par_Val + Int_2_Par_Val + 2;\n  return 0;\n}\n"}, "pseudo_normalize": "", "binary": "dhrystone/dhrystone.host.O2", "assembly": "<PProc_7>:\nendbr64\nlea    0x2(%rdi,%rsi,1),%eax\nmov    %eax,(%rdx)\nxor    %eax,%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "PProc_8", "content": " /* PProc_7 */\n\n\nint PProc_8 (Arr_1_Dim Arr_1_Par_Ref,\n             Arr_2_Dim Arr_2_Par_Ref,\n             int Int_1_Par_Val,\n             int Int_2_Par_Val)\n/*********************************************************************/\n    /* executed once      */\n    /* Int_Par_Val_1 == 3 */\n    /* Int_Par_Val_2 == 7 */\n{\n  REG One_Fifty Int_Index;\n  REG One_Fifty Int_Loc;\n\n  Int_Loc = Int_1_Par_Val + 5;\n  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;\n  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];\n  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;\n  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)\n     Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;\n  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;\n  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];\n  Int_Glob = 5;\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O2.pseudo", "function_name": "PProc_8", "address": "0x1900", "label": "PProc_8", "content": "int __fastcall PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val, int Int_2_Par_Val)\n{\n  int v4; // r8d\n  __int64 v5; // rdx\n  int *v6; // r9\n  __int64 v7; // rcx\n  int *v8; // rax\n\n  v4 = Int_1_Par_Val + 5;\n  v5 = Int_1_Par_Val;\n  v6 = &Arr_1_Par_Ref[v4];\n  *v6 = Int_2_Par_Val;\n  v6[1] = Int_2_Par_Val;\n  v6[30] = v4;\n  v7 = 50LL * v4;\n  v8 = &(*Arr_2_Par_Ref)[v7 + v5];\n  ++v8[4];\n  v8[5] = v4;\n  v8[6] = v4;\n  LODWORD(v8) = *v6;\n  Int_Glob = 5;\n  (*Arr_2_Par_Ref)[v7 + 1005 + v5] = (int)v8;\n  return 0;\n}\n"}, "pseudo_normalize": "int PProc_8(int *Arr_1_Par_Ref, int (*Arr_2_Par_Ref)[50], int Int_1_Par_Val,\n            int Int_2_Par_Val) {\n  int v4;\n  long long v5;\n  int *v6;\n  long long v7;\n  int *v8;\n  v4 = Int_1_Par_Val + 5;\n  v5 = Int_1_Par_Val;\n  v6 = &Arr_1_Par_Ref[v4];\n  *v6 = Int_2_Par_Val;\n  v6[1] = Int_2_Par_Val;\n  v6[30] = v4;\n  v7 = 50LL * v4;\n  v8 = &(*Arr_2_Par_Ref)[v7 + v5];\n  ++v8[4];\n  v8[5] = v4;\n  v8[6] = v4;\n  LODWORD(v8) = *v6;\n  Int_Glob = 5;\n  (*Arr_2_Par_Ref)[v7 + 1005 + v5] = (int)v8;\n  return 0;\n}", "binary": "dhrystone/dhrystone.host.O2", "assembly": "<PProc_8>:\nendbr64\nlea    0x5(%rdx),%r8d\nmovslq %edx,%rdx\nmovslq %r8d,%r10\nshl    $0x2,%rdx\nlea    0x0(,%r10,4),%rax\nlea    (%rdi,%rax,1),%r9\nmov    %ecx,(%r9)\nmov    %ecx,0x4(%rdi,%rax,1)\nmov    %r8d,0x78(%rdi,%rax,1)\nadd    %r10,%rax\nlea    (%rax,%rax,4),%rcx\nshl    $0x3,%rcx\nlea    (%rcx,%rdx,1),%rax\nadd    %rsi,%rax\nadd    %rcx,%rsi\naddl   $0x1,0x10(%rax)\nmov    %r8d,0x14(%rax)\nmov    %r8d,0x18(%rax)\nmov    (%r9),%eax\nmovl   $0x5,0x5930(%rip)\nmov    %eax,0xfb4(%rdx,%rsi,1)\nxor    %eax,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "dhrystone/dhrystone.c", "function_name": "main", "content": "int\nmain(void)\n/*****/\n\n  /* main program, corresponds to procedures        */\n  /* Main and Proc_0 in the Ada version             */\n{\n  int nofr = 10;\n\n        One_Fifty       Int_1_Loc;\n  REG   One_Fifty       Int_2_Loc;\n        One_Fifty       Int_3_Loc;\n  REG   char            Ch_Index;\n        Enumeration     Enum_Loc;\n        Str_30          Str_1_Loc;\n        Str_30          Str_2_Loc;\n  REG   int             Run_Index;\n  REG   int             Pnumber_of_runs;\n\n  /* Initializations */\n\n  Next_Ptr_Glob = &rec1;\n  Ptr_Glob = &rec2;\n\n  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;\n  Ptr_Glob->Discr                       = Ident_1;\n  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;\n  Ptr_Glob->variant.var_1.Int_Comp      = 40;\n  libmin_strcpy (Ptr_Glob->variant.var_1.Str_Comp,\n          \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy (Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n\n  Arr_2_Glob [8][7] = 10;\n        /* Was missing in published program. Without this statement,    */\n        /* Arr_2_Glob [8][7] would have an undefined value.             */\n        /* Warning: With 16-Bit processors and Pnumber_of_runs > 32000,  */\n        /* overflow may occur for this array element.                   */\n\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf(\"\\n\");\n\n  Pnumber_of_runs = nofr; // HCH\n\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\",Pnumber_of_runs);\n\n  /***************/\n  /* Start timer */\n  /***************/\n\n  for (Run_Index = 1; Run_Index <= Pnumber_of_runs; ++Run_Index)\n  {\n\n    Proc_5();\n    Proc_4();\n      /* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */\n    Int_1_Loc = 2;\n    Int_2_Loc = 3;\n    libmin_strcpy (Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    Enum_Loc = Ident_2;\n    Bool_Glob = ! PFunc_2 (Str_1_Loc, Str_2_Loc);\n      /* Bool_Glob == 1 */\n    while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */\n    {\n      Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;\n        /* Int_3_Loc == 7 */\n      PProc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);\n        /* Int_3_Loc == 7 */\n      Int_1_Loc += 1;\n    } /* while */\n      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */\n    PProc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);\n      /* Int_Glob == 5 */\n    Proc_1 (Ptr_Glob);\n    for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)\n                             /* loop body executed twice */\n    {\n      if (Enum_Loc == PFunc_1 (Ch_Index, 'C'))\n          /* then, not executed */\n        {\n        PProc_6 (Ident_1, &Enum_Loc);\n        libmin_strcpy (Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n        Int_2_Loc = Run_Index;\n        Int_Glob = Run_Index;\n        }\n    }\n      /* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */\n    Int_2_Loc = Int_2_Loc * Int_1_Loc;\n    Int_1_Loc = Int_2_Loc / Int_3_Loc;\n    Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;\n      /* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */\n    Proc_2 (&Int_1_Loc);\n      /* Int_1_Loc == 5 */\n\n  } /* loop \"for Run_Index\" */\n\n  /**************/\n  /* Stop timer */\n  /**************/\n\n  libmin_printf(\"Execution ends\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n  libmin_printf(\"\\n\");\n  libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Ch_1_Glob:           %c\\n\", Ch_1_Glob);\n  libmin_printf(\"        should be:   %c\\n\", 'A');\n  libmin_printf(\"Ch_2_Glob:           %c\\n\", Ch_2_Glob);\n  libmin_printf(\"        should be:   %c\\n\", 'B');\n  libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n  libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n  libmin_printf(\"Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 2);\n  libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 17);\n  libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Next_Ptr_Glob->\\n\");\n  libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n  libmin_printf(\"        should be:   (implementation-dependent), same as above\\n\");\n  libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n  libmin_printf(\"        should be:   %d\\n\", 0);\n  libmin_printf(\"  Enum_Comp:         %d\\n\",\n         Next_Ptr_Glob->variant.var_1.Enum_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"  Int_Comp:          %d\\n\",\n         Next_Ptr_Glob->variant.var_1.Int_Comp);\n  libmin_printf(\"        should be:   %d\\n\", 18);\n  libmin_printf(\"  Str_Comp:          %s\\n\",\n                                Next_Ptr_Glob->variant.var_1.Str_Comp);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n  libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 5);\n  libmin_printf(\"Int_2_Loc:           %d\\n\", Int_2_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 13);\n  libmin_printf(\"Int_3_Loc:           %d\\n\", Int_3_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 7);\n  libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n  libmin_printf(\"        should be:   %d\\n\", 1);\n  libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n  libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n  libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "dhrystone/dhrystone.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char v3; // r12\n  unsigned int v4; // ebx\n  char v5; // cl\n  int v6; // eax\n  Rec_Pointer v7; // rax\n  record *Ptr_Comp; // rdx\n  const __m128i *v9; // roff\n  __int64 v10; // rcx\n  const __m128i *v11; // rcx\n  record::$98AA0AC6CE8BC7DC2524F5EAD0F75F51 *Discr; // rsi\n  __int64 v13; // rdx\n  int v14; // r15d\n  __int64 v15; // rcx\n  int v16; // r9d\n  int v17; // r10d\n  int v18; // r8d\n  int v19; // eax\n  __int64 v20; // rcx\n  One_Fifty Int_1_Loc; // [rsp+4h] [rbp-94h]\n  Enumeration Enum_Loc; // [rsp+8h] [rbp-90h]\n  int v23; // [rsp+Ch] [rbp-8Ch]\n  char Str_1_Loc[32]; // [rsp+10h] [rbp-88h] BYREF\n  char Str_2_Loc[40]; // [rsp+30h] [rbp-68h] BYREF\n  unsigned __int64 v26; // [rsp+58h] [rbp-40h]\n\n  v26 = __readfsqword(0x28u);\n  Ptr_Glob = &rec2;\n  rec2.variant.var_1.Int_Comp = 40;\n  v4 = 1;\n  Next_Ptr_Glob = &rec1;\n  rec2.Ptr_Comp = &rec1;\n  *(_QWORD *)&rec2.Discr = 0x200000000LL;\n  libmin_strcpy(rec2.variant.var_1.Str_Comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", 10);\n  while ( 1 )\n  {\n    Ch_1_Glob[0] = 65;\n    Bool_Glob = 1;\n    Ch_2_Glob[0] = 66;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    v5 = 0;\n    while ( Str_2_Loc[3] == Str_1_Loc[2] )\n    {\n      v5 = 1;\n      v3 = Str_2_Loc[3];\n    }\n    if ( v5 )\n      Ch_1_Glob[0] = v3;\n    v6 = libmin_strcmp(Str_1_Loc, Str_2_Loc);\n    *(_QWORD *)&Arr_1_Glob[8] = 0x700000007LL;\n    Arr_1_Glob[38] = 8;\n    Arr_2_Glob[28][8] = 7;\n    ++Arr_2_Glob[8][7];\n    Bool_Glob = v6 <= 0;\n    *(_QWORD *)&Arr_2_Glob[8][8] = 0x800000008LL;\n    v7 = Ptr_Glob;\n    Int_Glob = 5;\n    Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    v9 = (const __m128i *)Ptr_Glob;\n    *(__m128i *)&Ptr_Comp->Ptr_Comp = _mm_loadu_si128((const __m128i *)Ptr_Glob);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 2) = _mm_loadu_si128(v9 + 1);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 10) = _mm_loadu_si128((const __m128i *)(&v7->variant.var_3 + 10));\n    v10 = *(_QWORD *)(&v7->variant.var_3 + 18);\n    Ptr_Comp->variant.var_1.Int_Comp = 5;\n    *(_QWORD *)(&Ptr_Comp->variant.var_3 + 18) = v10;\n    Ptr_Comp->Ptr_Comp = v7->Ptr_Comp;\n    v11 = (const __m128i *)v7->Ptr_Comp;\n    Ptr_Comp->Ptr_Comp = v7->Ptr_Comp;\n    v7->variant.var_1.Int_Comp = 17;\n    Discr = (record::$98AA0AC6CE8BC7DC2524F5EAD0F75F51 *)(unsigned int)Ptr_Comp->Discr;\n    if ( (_DWORD)Discr )\n    {\n      *(__m128i *)&v7->Ptr_Comp = _mm_loadu_si128(v11);\n      *(__m128i *)(&v7->variant.var_3 + 2) = _mm_loadu_si128(v11 + 1);\n      *(__m128i *)(&v7->variant.var_3 + 10) = _mm_loadu_si128(v11 + 2);\n      v13 = v11[3].m128i_i64[0];\n      *(_QWORD *)(&v7->variant.var_3 + 18) = v13;\n    }\n    else\n    {\n      Ptr_Comp->variant.var_1.Int_Comp = 6;\n      Discr = &Ptr_Comp->variant;\n      PProc_6(v7->variant.var_1.Enum_Comp, &Ptr_Comp->variant.var_1.Enum_Comp);\n      *(_QWORD *)v13 = v20;\n      *(_DWORD *)(v13 + 16) = 18;\n    }\n    v14 = 65;\n    v15 = 3LL;\n    v16 = 1;\n    v17 = 13;\n    v18 = 1;\n    if ( Ch_2_Glob[0] > 64 )\n    {\n      while ( Ch_2_Glob[0] >= (char)++v14 )\n      {\n        while ( 1 )\n        {\n          v19 = 0;\n          if ( (_BYTE)v14 == 67 )\n          {\n            Ch_1_Glob[0] = 67;\n            v19 = 1;\n          }\n          if ( v16 != v19 )\n            break;\n          Discr = (record::$98AA0AC6CE8BC7DC2524F5EAD0F75F51 *)\"DHRYSTONE PROGRAM, 3'RD STRING\";\n          ++v14;\n          libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n          v16 = 0;\n          Int_Glob = v4;\n          v15 = v4;\n          if ( Ch_2_Glob[0] < (char)v14 )\n            goto LABEL_14;\n        }\n      }\nLABEL_14:\n      v13 = (unsigned int)((3 * (int)v15) >> 31);\n      v18 = 3 * (int)v15 / 7;\n      v17 = 7 * (3 * v15 - 7) - v18;\n    }\n    if ( Ch_1_Glob[0] == 65 )\n      v18 = v18 + 9 - Int_Glob;\n    if ( ++v4 == 11 )\n    {\n      v23 = v17;\n      Enum_Loc = v16;\n      Int_1_Loc = v18;\n      libmin_printf(\"Execution ends\\n\", Discr, v13, v15);\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 65LL);\n      libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 66LL);\n      libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n      libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n      libmin_printf((char *)\"Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\", Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 2);\n      libmin_printf(\"  Int_Comp:          %d\\n\", Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 17);\n      libmin_printf(\"  Str_Comp:          %s\\n\", Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Next_Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent), same as above\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\", Next_Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"  Int_Comp:          %d\\n\", Next_Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 18);\n      libmin_printf(\"  Str_Comp:          %s\\n\", Next_Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Int_2_Loc:           %d\\n\", v23);\n      libmin_printf(\"        should be:   %d\\n\", 13);\n      libmin_printf(\"Int_3_Loc:           %d\\n\", 7);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n      libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  char v3;\n  unsigned int v4;\n  char v5;\n  int v6;\n  Rec_Pointer v7;\n  record *Ptr_Comp;\n  const __m128i *v9;\n  long long v10;\n  const __m128i *v11;\n  record::$98AA0AC6CE8BC7DC2524F5EAD0F75F51 *Discr;\n  long long v13;\n  int v14;\n  long long v15;\n  int v16;\n  int v17;\n  int v18;\n  int v19;\n  long long v20;\n  One_Fifty Int_1_Loc;\n  Enumeration Enum_Loc;\n  int v23;\n  char Str_1_Loc[32];\n  char Str_2_Loc[40];\n  unsigned long long v26;\n  v26 = __readfsqword(40u);\n  Ptr_Glob = &rec2;\n  rec2.variant.var_1.Int_Comp = 40;\n  v4 = 1;\n  Next_Ptr_Glob = &rec1;\n  rec2.Ptr_Comp = &rec1;\n  *(uint64_t *)&rec2.Discr = 8589934592LL;\n  libmin_strcpy(rec2.variant.var_1.Str_Comp, \"DHRYSTONE PROGRAM, SOME STRING\");\n  libmin_strcpy(Str_1_Loc, \"DHRYSTONE PROGRAM, 1'ST STRING\");\n  Arr_2_Glob[8][7] = 10;\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Dhrystone Benchmark, Version 2.1 (Language: C)\\n\");\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Execution starts, %d runs through Dhrystone\\n\", 10);\n  while (1) {\n    Ch_1_Glob[0] = 65;\n    Bool_Glob = 1;\n    Ch_2_Glob[0] = 66;\n    libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 2'ND STRING\");\n    v5 = 0;\n    while (Str_2_Loc[3] == Str_1_Loc[2]) {\n      v5 = 1;\n      v3 = Str_2_Loc[3];\n    }\n    if (v5) Ch_1_Glob[0] = v3;\n    v6 = libmin_strcmp(Str_1_Loc, Str_2_Loc);\n    *(uint64_t *)&Arr_1_Glob[8] = 30064771079LL;\n    Arr_1_Glob[38] = 8;\n    Arr_2_Glob[28][8] = 7;\n    ++Arr_2_Glob[8][7];\n    Bool_Glob = v6 <= 0;\n    *(uint64_t *)&Arr_2_Glob[8][8] = 34359738376LL;\n    v7 = Ptr_Glob;\n    Int_Glob = 5;\n    Ptr_Comp = Ptr_Glob->Ptr_Comp;\n    v9 = (const __m128i *)Ptr_Glob;\n    *(__m128i *)&Ptr_Comp->Ptr_Comp =\n        _mm_loadu_si128((const __m128i *)Ptr_Glob);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 2) = _mm_loadu_si128(v9 + 1);\n    *(__m128i *)(&Ptr_Comp->variant.var_3 + 10) =\n        _mm_loadu_si128((const __m128i *)(&v7->variant.var_3 + 10));\n    v10 = *(uint64_t *)(&v7->variant.var_3 + 18);\n    Ptr_Comp->variant.var_1.Int_Comp = 5;\n    *(uint64_t *)(&Ptr_Comp->variant.var_3 + 18) = v10;\n    Ptr_Comp->Ptr_Comp = v7->Ptr_Comp;\n    v11 = (const __m128i *)v7->Ptr_Comp;\n    Ptr_Comp->Ptr_Comp = v7->Ptr_Comp;\n    v7->variant.var_1.Int_Comp = 17;\n    Discr = (record::$98AA0AC6CE8BC7DC2524F5EAD0F75F51 *)(unsigned int)\n                Ptr_Comp->Discr;\n    if ((uint32_t)Discr) {\n      *(__m128i *)&v7->Ptr_Comp = _mm_loadu_si128(v11);\n      *(__m128i *)(&v7->variant.var_3 + 2) = _mm_loadu_si128(v11 + 1);\n      *(__m128i *)(&v7->variant.var_3 + 10) = _mm_loadu_si128(v11 + 2);\n      v13 = v11[3].m128i_i64[0];\n      *(uint64_t *)(&v7->variant.var_3 + 18) = v13;\n    } else {\n      Ptr_Comp->variant.var_1.Int_Comp = 6;\n      Discr = &Ptr_Comp->variant;\n      PProc_6(v7->variant.var_1.Enum_Comp, &Ptr_Comp->variant.var_1.Enum_Comp);\n      *(uint64_t *)v13 = v20;\n      *(uint32_t *)(v13 + 16) = 18;\n    }\n    v14 = 65;\n    v15 = 3LL;\n    v16 = 1;\n    v17 = 13;\n    v18 = 1;\n    if (Ch_2_Glob[0] > 64) {\n      while (Ch_2_Glob[0] >= (char)++v14) {\n        while (1) {\n          v19 = 0;\n          if ((uint8_t)v14 == 67) {\n            Ch_1_Glob[0] = 67;\n            v19 = 1;\n          }\n          if (v16 != v19) break;\n          Discr = (record::$98AA0AC6CE8BC7DC2524F5EAD0F75F51\n                       *)\"DHRYSTONE PROGRAM, 3'RD STRING\";\n          ++v14;\n          libmin_strcpy(Str_2_Loc, \"DHRYSTONE PROGRAM, 3'RD STRING\");\n          v16 = 0;\n          Int_Glob = v4;\n          v15 = v4;\n          if (Ch_2_Glob[0] < (char)v14) goto LABEL_14;\n        }\n      }\n    LABEL_14:\n      v13 = (unsigned int)((3 * (int)v15) >> 31);\n      v18 = 3 * (int)v15 / 7;\n      v17 = 7 * (3 * v15 - 7) - v18;\n    }\n    if (Ch_1_Glob[0] == 65) v18 = v18 + 9 - Int_Glob;\n    if (++v4 == 11) {\n      v23 = v17;\n      Enum_Loc = v16;\n      Int_1_Loc = v18;\n      libmin_printf(\"Execution ends\\n\", Discr, v13, v15);\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Final values of the variables used in the benchmark:\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_printf(\"Int_Glob:            %d\\n\", Int_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Bool_Glob:           %d\\n\", Bool_Glob);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Ch_1_Glob:           %c\\n\", (unsigned int)Ch_1_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 65LL);\n      libmin_printf(\"Ch_2_Glob:           %c\\n\", (unsigned int)Ch_2_Glob[0]);\n      libmin_printf(\"        should be:   %c\\n\", 66LL);\n      libmin_printf(\"Arr_1_Glob[8]:       %d\\n\", Arr_1_Glob[8]);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Arr_2_Glob[8][7]:    %d\\n\", Arr_2_Glob[8][7]);\n      libmin_printf(\"        should be:   Pnumber_of_runs + 10\\n\");\n      libmin_printf((char *)\"Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\"        should be:   (implementation-dependent)\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\",\n                    Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 2);\n      libmin_printf(\"  Int_Comp:          %d\\n\",\n                    Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 17);\n      libmin_printf(\"  Str_Comp:          %s\\n\",\n                    Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Next_Ptr_Glob->\\n\");\n      libmin_printf(\"  Ptr_Comp:          (implementation-dependent)\\n\");\n      libmin_printf(\n          \"        should be:   (implementation-dependent), same as above\\n\");\n      libmin_printf(\"  Discr:             %d\\n\", Next_Ptr_Glob->Discr);\n      libmin_printf(\"        should be:   %d\\n\", 0);\n      libmin_printf(\"  Enum_Comp:         %d\\n\",\n                    Next_Ptr_Glob->variant.var_1.Enum_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"  Int_Comp:          %d\\n\",\n                    Next_Ptr_Glob->variant.var_1.Int_Comp);\n      libmin_printf(\"        should be:   %d\\n\", 18);\n      libmin_printf(\"  Str_Comp:          %s\\n\",\n                    Next_Ptr_Glob->variant.var_1.Str_Comp);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, SOME STRING\\n\");\n      libmin_printf(\"Int_1_Loc:           %d\\n\", Int_1_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 5);\n      libmin_printf(\"Int_2_Loc:           %d\\n\", v23);\n      libmin_printf(\"        should be:   %d\\n\", 13);\n      libmin_printf(\"Int_3_Loc:           %d\\n\", 7);\n      libmin_printf(\"        should be:   %d\\n\", 7);\n      libmin_printf(\"Enum_Loc:            %d\\n\", Enum_Loc);\n      libmin_printf(\"        should be:   %d\\n\", 1);\n      libmin_printf(\"Str_1_Loc:           %s\\n\", Str_1_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 1'ST STRING\\n\");\n      libmin_printf(\"Str_2_Loc:           %s\\n\", Str_2_Loc);\n      libmin_printf(\"        should be:   DHRYSTONE PROGRAM, 2'ND STRING\\n\");\n      libmin_printf((char *)\"\\n\");\n      libmin_success();\n    }\n  }\n}", "binary": "dhrystone/dhrystone.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nlea    0x2efb(%rip),%rsi\npush   %r14\nmovabs $0x700000007,%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    0x897a(%rip),%rbx\nlea    0x14(%rbx),%rdi\nsub    $0x68,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x58(%rsp)\nlea    0x899d(%rip),%rax\nlea    0x10(%rsp),%r13\nlea    0x30(%rsp),%rbp\nmov    %rbx,0x89cc(%rip)\nmovl   $0x28,0x8952(%rip)\nmov    $0x1,%ebx\nmov    %rax,0x89ae(%rip)\nmov    %rax,0x892f(%rip)\nmovabs $0x200000000,%rax\nmov    %rax,0x8926(%rip)\ncall   31b0 <libmin_strcpy>\nlea    0x2e9a(%rip),%rsi\nmov    %r13,%rdi\ncall   31b0 <libmin_strcpy>\nlea    0x3253(%rip),%rdi\nxor    %eax,%eax\nmovl   $0xa,0x6753(%rip)\ncall   2f40 <libmin_printf>\nlea    0x2e93(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nlea    0x322d(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    $0xa,%esi\nlea    0x2ea2(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nnopl   (%rax)\nlea    0x2ec1(%rip),%rsi\nmov    %rbp,%rdi\nmovb   $0x41,0x6093(%rip)\nmovl   $0x1,0x8891(%rip)\nmovb   $0x42,0x8886(%rip)\ncall   31b0 <libmin_strcpy>\nmovzbl 0x33(%rsp),%eax\nmovzbl 0x12(%rsp),%edx\nxor    %ecx,%ecx\ncmp    %dl,%al\nje     1770 <main+0x670>\ntest   %cl,%cl\nje     1226 <main+0x126>\nmov    %r12b,0x605e(%rip)\nmov    %rbp,%rsi\nmov    %r13,%rdi\ncall   3150 <libmin_strcmp>\nmov    %r14,0x87a8(%rip)\nmovl   $0x8,0x8816(%rip)\ntest   %eax,%eax\nmovl   $0x7,0x7652(%rip)\nsetle  %al\nmovzbl %al,%eax\naddl   $0x1,0x66a1(%rip)\nmov    %eax,0x882b(%rip)\nmovabs $0x800000008,%rax\nmov    %rax,0x668e(%rip)\nmov    0x88a7(%rip),%rax\nmovl   $0x5,0x6005(%rip)\nmov    (%rax),%rdx\nmovdqu (%rax),%xmm0\nmovups %xmm0,(%rdx)\nmovdqu 0x10(%rax),%xmm1\nmovups %xmm1,0x10(%rdx)\nmovdqu 0x20(%rax),%xmm2\nmovups %xmm2,0x20(%rdx)\nmov    0x30(%rax),%rcx\nmovl   $0x5,0x10(%rdx)\nmov    %rcx,0x30(%rdx)\nmov    (%rax),%rcx\nmov    %rcx,(%rdx)\nmov    (%rax),%rcx\nmov    %rcx,(%rdx)\nmovl   $0x11,0x10(%rax)\nmov    0x8(%rdx),%esi\ntest   %esi,%esi\nje     1780 <main+0x680>\nmovdqu (%rcx),%xmm3\nmovups %xmm3,(%rax)\nmovdqu 0x10(%rcx),%xmm4\nmovups %xmm4,0x10(%rax)\nmovdqu 0x20(%rcx),%xmm5\nmovups %xmm5,0x20(%rax)\nmov    0x30(%rcx),%rdx\nmov    %rdx,0x30(%rax)\ncmpb   $0x40,0x8794(%rip)\nmov    $0x41,%r15d\nmov    $0x3,%ecx\nmov    $0x1,%r9d\nmov    $0xd,%r10d\nmov    $0x1,%r8d\njle    1392 <main+0x292>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r15d\ncmp    %r15b,0x8765(%rip)\njl     1365 <main+0x265>\nxor    %eax,%eax\ncmp    $0x43,%r15b\njne    1339 <main+0x239>\nmovb   $0x43,0x5f50(%rip)\nmov    $0x1,%eax\ncmp    %eax,%r9d\njne    1318 <main+0x218>\nlea    0x2d83(%rip),%rsi\nmov    %rbp,%rdi\nadd    $0x1,%r15d\ncall   31b0 <libmin_strcpy>\nxor    %r9d,%r9d\nmov    %ebx,0x5f2e(%rip)\nmov    %ebx,%ecx\ncmp    %r15b,0x8725(%rip)\njge    1325 <main+0x225>\nlea    (%rcx,%rcx,2),%eax\nmovslq %eax,%r8\ncltd\nimul   $0xffffffff92492493,%r8,%r8\nshr    $0x20,%r8\nadd    %eax,%r8d\nsub    $0x7,%eax\nsar    $0x2,%r8d\nlea    0x0(,%rax,8),%r10d\nsub    %edx,%r8d\nsub    %eax,%r10d\nsub    %r8d,%r10d\ncmpb   $0x41,0x5eeb(%rip)\njne    13a6 <main+0x2a6>\nadd    $0x9,%r8d\nsub    0x5ee2(%rip),%r8d\nadd    $0x1,%ebx\ncmp    $0xb,%ebx\njne    11e0 <main+0xe0>\nlea    0x2eec(%rip),%rdi\nxor    %eax,%eax\nmov    %r10d,0xc(%rsp)\nlea    0x2f07(%rip),%r12\nmov    %r9d,0x8(%rsp)\nlea    0x2f46(%rip),%r14\nlea    0x2fbc(%rip),%rbx\nmov    %r8d,0x4(%rsp)\nlea    0x2fc9(%rip),%r15\ncall   2f40 <libmin_printf>\nlea    0x2ffe(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nlea    0x2ce8(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nlea    0x2fe2(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x5e6d(%rip),%esi\nlea    0x2e93(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    $0x5,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x864e(%rip),%esi\nlea    0x2ea2(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    $0x1,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmovsbl 0x5e22(%rip),%esi\nlea    0x2e97(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    %r14,%rdi\nmov    $0x41,%esi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmovsbl 0x8602(%rip),%esi\nlea    0x2ea5(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    %r14,%rdi\nmov    $0x42,%esi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x8537(%rip),%esi\nxor    %eax,%eax\nlea    0x2e99(%rip),%rdi\nlea    0x2f0f(%rip),%r14\ncall   2f40 <libmin_printf>\nmov    $0x7,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x6429(%rip),%esi\nlea    0x2e8a(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nlea    0x2c38(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nxor    %eax,%eax\nlea    0x2eee(%rip),%rdi\ncall   2f40 <libmin_printf>\nlea    0x2c4c(%rip),%rdx\nxor    %eax,%eax\nmov    %rdx,%rdi\ncall   2f40 <libmin_printf>\nlea    0x2c73(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x85fd(%rip),%rax\nlea    0x2e53(%rip),%r11\nmov    %r11,%rdi\nmov    0x8(%rax),%esi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nxor    %esi,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x85d6(%rip),%rax\nmov    %rbx,%rdi\nmov    0xc(%rax),%esi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    $0x2,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x85b3(%rip),%rax\nmov    %r15,%rdi\nmov    0x10(%rax),%esi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    $0x11,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x8590(%rip),%rax\nmov    %r14,%rdi\nlea    0x14(%rax),%rsi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nlea    0x2c1b(%rip),%rcx\nxor    %eax,%eax\nmov    %rcx,%rdi\ncall   2f40 <libmin_printf>\nlea    0x2e2b(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nlea    0x2b8c(%rip),%rdx\nxor    %eax,%eax\nmov    %rdx,%rdi\ncall   2f40 <libmin_printf>\nlea    0x2c23(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x8535(%rip),%rax\nlea    0x2d93(%rip),%r11\nmov    %r11,%rdi\nmov    0x8(%rax),%esi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nxor    %esi,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x850e(%rip),%rax\nmov    %rbx,%rdi\nmov    0xc(%rax),%esi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    $0x1,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x84eb(%rip),%rax\nmov    %r15,%rdi\nmov    0x10(%rax),%esi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    $0x12,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x84c8(%rip),%rax\nmov    %r14,%rdi\nlea    0x14(%rax),%rsi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nlea    0x2b5b(%rip),%rcx\nxor    %eax,%eax\nmov    %rcx,%rdi\ncall   2f40 <libmin_printf>\nmov    0x4(%rsp),%esi\nlea    0x2d78(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    $0x5,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0xc(%rsp),%esi\nlea    0x2d70(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    $0xd,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    $0x7,%esi\nlea    0x2d67(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    $0x7,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    0x8(%rsp),%esi\nlea    0x2d5f(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    $0x1,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nmov    %r13,%rsi\nlea    0x2d58(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nxor    %eax,%eax\nlea    0x2b2a(%rip),%rdi\ncall   2f40 <libmin_printf>\nmov    %rbp,%rsi\nlea    0x2d52(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nlea    0x2b45(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\nlea    0x2cb7(%rip),%rdi\nxor    %eax,%eax\ncall   2f40 <libmin_printf>\ncall   3200 <libmin_success>\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    17a2 <main+0x6a2>\nadd    $0x68,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\nmov    $0x1,%ecx\nmov    %eax,%r12d\njmp    1213 <main+0x113>\nnopl   (%rax)\nmovl   $0x6,0x10(%rdx)\nmov    0xc(%rax),%edi\nlea    0xc(%rdx),%rsi\ncall   18a0 <PProc_6>\nmov    %rcx,(%rdx)\nmovl   $0x12,0x10(%rdx)\njmp    12ed <main+0x1ed>\ncall   10b0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "distinctness/distinctness.c", "function_name": "isDistinct", "content": "int\nisDistinct(int elements[], int *pdup)\n{\n  int tree[SIZE][3];\n  *pdup = INT_MAX;\n\n\tfor(int i = 0; i < SIZE;i++){\n\t\ttree[i][0] = INT_MAX;\n\t\ttree[i][1] = INT_MAX;\n\t\ttree[i][2] = INT_MAX;\n\t}\t\n\t\n\ttree[0][0] = elements[0];\n\tint location = 0;\n\n\tfor(int i = 1; i < SIZE; i++){\n\t\tint temp = 0;\n\t\tint value = tree[0][0];\n\t\tint left = tree[0][1];\n\t\tint right = tree[0][2];\n\n\t\twhile(value != INT_MAX){\n\t\t\tif(elements[i] > value){\n\t\t\t\tif(right != INT_MAX){\n\t\t\t\t\tvalue = tree[right][0];\n\t\t\t\t\tleft = tree[right][1];\n\t\t\t\t\ttemp = right;\n\t\t\t\t\tright = tree[right][2];\n\t\t\t\t}else{\n\t\t\t\t\ttree[location+1][0] = elements[i];\n\t\t\t\t\ttree[temp][2] = location + 1;\n\t\t\t\t\tlocation++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(elements[i] < value){\n\t\t\t\tif(left != INT_MAX){\n\t\t\t\t\tvalue = tree[left][0];\n\t\t\t\t\tright = tree[left][2];\n\t\t\t\t\ttemp = left;\n\t\t\t\t\tleft = tree[left][1];\n\t\t\t\t}else{\n\t\t\t\t\ttree[temp][1] = location+1;\n\t\t\t\t\ttree[location+1][0] = elements[i];\n\t\t\t\t\tlocation++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n        *pdup = elements[i];\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n"}, "pseudo": {"path": "distinctness/distinctness.host.O2.pseudo", "function_name": "isDistinct", "address": "0x12a0", "label": "isDistinct", "content": "int __fastcall isDistinct(int *elements, int *pdup)\n{\n  int *v3; // rax\n  int v4; // r9d\n  int *v5; // r8\n  int *v6; // r11\n  int v7; // ebx\n  int v8; // esi\n  int v9; // ecx\n  int v10; // edi\n  int v11; // eax\n  __int64 v12; // rbp\n  int tree[128][3]; // [rsp+0h] [rbp-628h] BYREF\n  char v15; // [rsp+600h] [rbp-28h] BYREF\n  unsigned __int64 v16; // [rsp+608h] [rbp-20h]\n\n  v16 = __readfsqword(0x28u);\n  *pdup = 0x7FFFFFFF;\n  v3 = tree[0];\n  do\n  {\n    *v3 = 0x7FFFFFFF;\n    v3 += 3;\n    *(v3 - 2) = 0x7FFFFFFF;\n    *(v3 - 1) = 0x7FFFFFFF;\n  }\n  while ( &v15 != (char *)v3 );\n  v4 = *elements;\n  v5 = elements + 1;\n  v6 = elements + 128;\n  v7 = 0;\n  tree[0][0] = *elements;\nLABEL_4:\n  while ( 2 )\n  {\n    while ( 1 )\n    {\n      v8 = tree[0][1];\n      v9 = tree[0][2];\n      if ( v4 != 0x7FFFFFFF )\n        break;\nLABEL_12:\n      if ( ++v5 == v6 )\n        return 1;\n    }\n    v10 = *v5;\n    v11 = v4;\n    v12 = 0LL;\n    while ( 1 )\n    {\n      while ( v10 > v11 )\n      {\n        if ( v9 == 0x7FFFFFFF )\n        {\n          ++v7;\n          ++v5;\n          tree[v7][0] = v10;\n          tree[v12][2] = v7;\n          if ( v5 != v6 )\n            goto LABEL_4;\n          return 1;\n        }\n        v12 = v9;\n        v11 = tree[v9][0];\n        v8 = tree[v9][1];\n        v9 = tree[v9][2];\n        if ( v11 == 0x7FFFFFFF )\n          goto LABEL_12;\n      }\n      if ( v10 >= v11 )\n      {\n        *pdup = v10;\n        return 0;\n      }\n      if ( v8 == 0x7FFFFFFF )\n        break;\n      v12 = v8;\n      v11 = tree[v8][0];\n      v9 = tree[v8][2];\n      v8 = tree[v8][1];\n      if ( v11 == 0x7FFFFFFF )\n        goto LABEL_12;\n    }\n    ++v7;\n    ++v5;\n    tree[v12][1] = v7;\n    tree[v7][0] = v10;\n    if ( v5 != v6 )\n      continue;\n    return 1;\n  }\n}\n"}, "pseudo_normalize": "int isDistinct(int *elements, int *pdup) {\n  int *v3;\n  int v4;\n  int *v5;\n  int *v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  long long v12;\n  int tree[128][3];\n  char v15;\n  unsigned long long v16;\n  v16 = __readfsqword(40u);\n  *pdup = 2147483647;\n  v3 = tree[0];\n  do {\n    *v3 = 2147483647;\n    v3 += 3;\n    *(v3 - 2) = 2147483647;\n    *(v3 - 1) = 2147483647;\n  } while (&v15 != (char *)v3);\n  v4 = *elements;\n  v5 = elements + 1;\n  v6 = elements + 128;\n  v7 = 0;\n  tree[0][0] = *elements;\nLABEL_4:\n  while (2) {\n    while (1) {\n      v8 = tree[0][1];\n      v9 = tree[0][2];\n      if (v4 != 2147483647) break;\n    LABEL_12:\n      if (++v5 == v6) return 1;\n    }\n    v10 = *v5;\n    v11 = v4;\n    v12 = 0LL;\n    while (1) {\n      while (v10 > v11) {\n        if (v9 == 2147483647) {\n          ++v7;\n          ++v5;\n          tree[v7][0] = v10;\n          tree[v12][2] = v7;\n          if (v5 != v6) goto LABEL_4;\n          return 1;\n        }\n        v12 = v9;\n        v11 = tree[v9][0];\n        v8 = tree[v9][1];\n        v9 = tree[v9][2];\n        if (v11 == 2147483647) goto LABEL_12;\n      }\n      if (v10 >= v11) {\n        *pdup = v10;\n        return 0;\n      }\n      if (v8 == 2147483647) break;\n      v12 = v8;\n      v11 = tree[v8][0];\n      v9 = tree[v8][2];\n      v8 = tree[v8][1];\n      if (v11 == 2147483647) goto LABEL_12;\n    }\n    ++v7;\n    ++v5;\n    tree[v12][1] = v7;\n    tree[v7][0] = v10;\n    if (v5 != v6) continue;\n    return 1;\n  }\n}", "binary": "distinctness/distinctness.host.O2", "assembly": "<isDistinct>:\nendbr64\npush   %rbp\nmov    %rsi,%r10\npush   %rbx\nsub    $0x618,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x608(%rsp)\nxor    %eax,%eax\nmovl   $0x7fffffff,(%rsi)\nmov    %rsp,%rax\nlea    0x600(%rsp),%rdx\nnopl   0x0(%rax)\nmovl   $0x7fffffff,(%rax)\nadd    $0xc,%rax\nmovl   $0x7fffffff,-0x8(%rax)\nmovl   $0x7fffffff,-0x4(%rax)\ncmp    %rax,%rdx\njne    12d8 <isDistinct+0x38>\nmov    (%rdi),%r9d\nlea    0x4(%rdi),%r8\nlea    0x200(%rdi),%r11\nxor    %ebx,%ebx\nmov    %r9d,(%rsp)\nmov    0x4(%rsp),%esi\nmov    0x8(%rsp),%ecx\ncmp    $0x7fffffff,%r9d\nje     137e <isDistinct+0xde>\nmov    (%r8),%edi\nmov    %r9d,%eax\nxor    %ebp,%ebp\njmp    1350 <isDistinct+0xb0>\nnopl   0x0(%rax)\ncmp    $0x7fffffff,%ecx\nje     1390 <isDistinct+0xf0>\nmovslq %ecx,%rax\nmovslq %ecx,%rbp\nlea    (%rax,%rax,2),%rdx\nshl    $0x2,%rdx\nmov    (%rsp,%rdx,1),%eax\nmov    0x4(%rsp,%rdx,1),%esi\nmov    0x8(%rsp,%rdx,1),%ecx\ncmp    $0x7fffffff,%eax\nje     137e <isDistinct+0xde>\ncmp    %eax,%edi\njg     1328 <isDistinct+0x88>\njge    13b8 <isDistinct+0x118>\ncmp    $0x7fffffff,%esi\nje     13da <isDistinct+0x13a>\nmovslq %esi,%rax\nmovslq %esi,%rbp\nlea    (%rax,%rax,2),%rdx\nshl    $0x2,%rdx\nmov    (%rsp,%rdx,1),%eax\nmov    0x8(%rsp,%rdx,1),%ecx\nmov    0x4(%rsp,%rdx,1),%esi\ncmp    $0x7fffffff,%eax\njne    1350 <isDistinct+0xb0>\nadd    $0x4,%r8\ncmp    %r11,%r8\njne    1309 <isDistinct+0x69>\nmov    $0x1,%eax\njmp    13bd <isDistinct+0x11d>\nxchg   %ax,%ax\nadd    $0x1,%ebx\nadd    $0x4,%r8\nmovslq %ebx,%rax\nlea    (%rax,%rax,2),%rax\nmov    %edi,(%rsp,%rax,4)\nlea    0x0(%rbp,%rbp,2),%rax\nmov    %ebx,0x8(%rsp,%rax,4)\ncmp    %r11,%r8\njne    1309 <isDistinct+0x69>\njmp    1387 <isDistinct+0xe7>\nnopl   (%rax)\nmov    %edi,(%r10)\nxor    %eax,%eax\nmov    0x608(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    13ff <isDistinct+0x15f>\nadd    $0x618,%rsp\npop    %rbx\npop    %rbp\nret\nadd    $0x1,%ebx\nlea    0x0(%rbp,%rbp,2),%rax\nadd    $0x4,%r8\nmov    %ebx,0x4(%rsp,%rax,4)\nmovslq %ebx,%rax\nlea    (%rax,%rax,2),%rax\nmov    %edi,(%rsp,%rax,4)\ncmp    %r11,%r8\njne    1309 <isDistinct+0x69>\njmp    1387 <isDistinct+0xe7>\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "distinctness/distinctness.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int dup1, dup2;\n  int res1, res2;\n\n  res1 = isDistinct(elements1, &dup1);\n  res2 = isDistinct(elements2, &dup2);\n\n  if (res1)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n\telse\n\t\tlibmin_printf(\"The elements of `elements1' are not distinct (e.g., %d is duplicated)\\n\", dup1);\n\t\n  if (res2)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n\telse\n\t\tlibmin_printf(\"The elements of `elements2' are not distinct (e.g., %d is duplicated)\\n\", dup2);\n\n\tlibmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "distinctness/distinctness.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // ebx\n  int dup1; // [rsp+0h] [rbp-28h] BYREF\n  int dup2; // [rsp+4h] [rbp-24h] BYREF\n  unsigned __int64 v7; // [rsp+8h] [rbp-20h]\n\n  v7 = __readfsqword(0x28u);\n  v3 = isDistinct(elements1, &dup1);\n  v4 = isDistinct(elements2, &dup2);\n  if ( v3 )\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements1' are not distinct (e.g., %d is duplicated)\\n\", dup1);\n  if ( v4 )\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\"The elements of `elements2' are not distinct (e.g., %d is duplicated)\\n\", dup2);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int dup1;\n  int dup2;\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  v3 = isDistinct(elements1, &dup1);\n  v4 = isDistinct(elements2, &dup2);\n  if (v3)\n    libmin_printf(\"The elements of `elements1' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements1' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup1);\n  if (v4)\n    libmin_printf(\"The elements of `elements2' are distinct\\n\");\n  else\n    libmin_printf(\n        \"The elements of `elements2' are not distinct (e.g., %d is \"\n        \"duplicated)\\n\",\n        dup2);\n  libmin_success();\n}", "binary": "distinctness/distinctness.host.O2", "assembly": "<main>:\nendbr64\npush   %rbp\nlea    0x4114(%rip),%rdi\npush   %rbx\nsub    $0x18,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rsi\ncall   12a0 <isDistinct>\nlea    0x4(%rsp),%rsi\nlea    0x3eeb(%rip),%rdi\nmov    %eax,%ebp\ncall   12a0 <isDistinct>\nmov    %eax,%ebx\ntest   %ebp,%ebp\nje     1180 <main+0x80>\nlea    0x1ebf(%rip),%rdi\nxor    %eax,%eax\ncall   2950 <libmin_printf>\ntest   %ebx,%ebx\nje     1193 <main+0x93>\nlea    0x1f25(%rip),%rdi\nxor    %eax,%eax\ncall   2950 <libmin_printf>\ncall   2b90 <libmin_success>\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    11a7 <main+0xa7>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nret\nmov    (%rsp),%esi\nlea    0x1eae(%rip),%rdi\nxor    %eax,%eax\ncall   2950 <libmin_printf>\njmp    1150 <main+0x50>\nmov    0x4(%rsp),%esi\nlea    0x1f12(%rip),%rdi\nxor    %eax,%eax\ncall   2950 <libmin_printf>\njmp    1162 <main+0x62>\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax)\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "db_from_ampl", "content": "/* db_from_ampl() - find loudness (in dB) from\n   the complex amplitude.\n*/\nint db_from_ampl(fixed re, fixed im)\n{\n  static int loud2[N_LOUD] = {0};\n  int v;\n  int i;\n\n  if(loud2[0] == 0) {\n    loud2[0] = (int)Loudampl[0] * (int)Loudampl[0];\n    for(i=1; i<N_LOUD; ++i) {\n      v = (int)Loudampl[i] * (int)Loudampl[i];\n      loud2[i] = v;\n      loud2[i-1] = (loud2[i-1]+v) / 2;\n    }\n  }\n\n  v = (int)re * (int)re + (int)im * (int)im;\n\n  for(i=0; i<N_LOUD; ++i)\n    if(loud2[i] <= v)\n      break;\n\n  return (-i);\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O2.pseudo", "function_name": "db_from_ampl", "address": "0x1670", "label": "db_from_ampl", "content": "int __fastcall db_from_ampl(int re, int im)\n{\n  int v2; // ecx\n  int *v4; // rsi\n  int *v5; // rdx\n  int v6; // eax\n  int v7; // eax\n  __int64 i; // rdx\n\n  v2 = loud2_0[0];\n  if ( !loud2_0[0] )\n  {\n    v4 = &Loudampl[1];\n    v5 = loud2_0;\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    do\n    {\n      v6 = *v4;\n      ++v5;\n      ++v4;\n      v7 = v6 * v6;\n      *v5 = v7;\n      *(v5 - 1) = (*(v5 - 1) + v7) / 2;\n    }\n    while ( v5 != &loud2_0[99] );\n    v2 = loud2_0[0];\n  }\n  for ( i = 0LL; ; v2 = loud2_0[i] )\n  {\n    if ( re * re + im * im >= v2 )\n      return -(int)i;\n    if ( ++i == 100 )\n      break;\n  }\n  return -100;\n}\n"}, "pseudo_normalize": "int db_from_ampl(int re, int im) {\n  int v2;\n  int *v4;\n  int *v5;\n  int v6;\n  int v7;\n  long long i;\n  v2 = loud2_0[0];\n  if (!loud2_0[0]) {\n    v4 = &Loudampl[1];\n    v5 = loud2_0;\n    loud2_0[0] = Loudampl[0] * Loudampl[0];\n    do {\n      v6 = *v4;\n      ++v5;\n      ++v4;\n      v7 = v6 * v6;\n      *v5 = v7;\n      *(v5 - 1) = (*(v5 - 1) + v7) / 2;\n    } while (v5 != &loud2_0[99]);\n    v2 = loud2_0[0];\n  }\n  for (i = 0LL;; v2 = loud2_0[i]) {\n    if (re * re + im * im >= v2) return -(int)i;\n    if (++i == 100) break;\n  }\n  return -100;\n}", "binary": "fft-int/fft-int.host.O2", "assembly": "<db_from_ampl>:\nendbr64\nmov    0x7da6(%rip),%ecx\nmov    %edi,%r8d\nmov    %esi,%r10d\nlea    0x7d99(%rip),%r9\ntest   %ecx,%ecx\njne    16d9 <db_from_ampl+0x69>\nmov    0x698f(%rip),%eax\nlea    0x698c(%rip),%rsi\nmov    %r9,%rdx\nlea    0x18c(%r9),%rdi\nimul   %eax,%eax\nmov    %eax,0x7d75(%rip)\nnopl   0x0(%rax,%rax,1)\nmov    (%rsi),%eax\nadd    $0x4,%rdx\nadd    $0x4,%rsi\nimul   %eax,%eax\nmov    %eax,(%rdx)\nadd    -0x4(%rdx),%eax\nmov    %eax,%ecx\nshr    $0x1f,%ecx\nadd    %ecx,%eax\nsar    %eax\nmov    %eax,-0x4(%rdx)\ncmp    %rdi,%rdx\njne    16b0 <db_from_ampl+0x40>\nmov    0x7d47(%rip),%ecx\nimul   %r8d,%r8d\nxor    %edx,%edx\nimul   %r10d,%r10d\nlea    (%r8,%r10,1),%esi\njmp    16fe <db_from_ampl+0x8e>\nnopl   0x0(%rax)\nadd    $0x1,%rdx\ncmp    $0x64,%rdx\nje     1707 <db_from_ampl+0x97>\nmov    (%r9,%rdx,4),%ecx\nmov    %edx,%eax\ncmp    %ecx,%esi\njl     16f0 <db_from_ampl+0x80>\nneg    %eax\nret\nmov    $0xffffff9c,%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "fix_fft", "content": "/* fix_fft() - perform fast Fourier transform.\n\n   if n>0 FFT is done, if n<0 inverse FFT is done\n   fr[n],fi[n] are real,imaginary arrays, INPUT AND RESULT.\n   size of data = 2**m\n   set inverse to 0=dft, 1=idft\n*/\nint\nfix_fft(fixed fr[], fixed fi[], int m, int inverse)\n{\n  int mr,nn,i,j,l,k,istep, n, scale, shift;\n  fixed qr,qi,tr,ti,wr,wi;\n\n  n = 1<<m;\n\n  if(n > N_WAVE)\n    return -1;\n\n  mr = 0;\n  nn = n - 1;\n  scale = 0;\n\n  /* decimation in time - re-order data */\n  for(m=1; m<=nn; ++m) {\n    l = n;\n    do {\n      l >>= 1;\n    } while(mr+l > nn);\n    mr = (mr & (l-1)) + l;\n\n    if(mr <= m) continue;\n    tr = fr[m];\n    fr[m] = fr[mr];\n    fr[mr] = tr;\n    ti = fi[m];\n    fi[m] = fi[mr];\n    fi[mr] = ti;\n  }\n\n  l = 1;\n  k = LOG2_N_WAVE-1;\n  while(l < n) {\n    if(inverse) {\n      /* variable scaling, depending upon data */\n      shift = 0;\n      for(i=0; i<n; ++i) {\n\tj = fr[i];\n\tif(j < 0)\n\t  j = -j;\n\tm = fi[i];\n\tif(m < 0)\n\t  m = -m;\n\tif(j > 16383 || m > 16383) {\n\t  shift = 1;\n\t  break;\n\t}\n      }\n      if(shift)\n\t++scale;\n    } else {\n      /* fixed scaling, for proper normalization -\n\t there will be log2(n) passes, so this\n\t results in an overall factor of 1/n,\n\t distributed to maximize arithmetic accuracy. */\n      shift = 1;\n    }\n    /* it may not be obvious, but the shift will be performed\n       on each data point exactly once, during this pass. */\n    istep = l << 1;\n    for(m=0; m<l; ++m) {\n      j = m << k;\n      /* 0 <= j < N_WAVE/2 */\n      wr =  Sinewave[j+N_WAVE/4];\n      wi = -Sinewave[j];\n      if(inverse)\n\twi = -wi;\n      if(shift) {\n\twr >>= 1;\n\twi >>= 1;\n      }\n      for(i=m; i<n; i+=istep) {\n\tj = i + l;\n\ttr = fix_mpy(wr,fr[j]) -\n\t  fix_mpy(wi,fi[j]);\n\tti = fix_mpy(wr,fi[j]) +\n\t  fix_mpy(wi,fr[j]);\n\tqr = fr[i];\n\tqi = fi[i];\n\tif(shift) {\n\t  qr >>= 1;\n\t  qi >>= 1;\n\t}\n\tfr[j] = qr - tr;\n\tfi[j] = qi - ti;\n\tfr[i] = qr + tr;\n\tfi[i] = qi + ti;\n      }\n    }\n    --k;\n    l = istep;\n  }\n\n  return scale;\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O2.pseudo", "function_name": "fix_fft", "address": "0x1320", "label": "fix_fft", "content": "int __fastcall fix_fft(int *fr, int *fi, int m, int inverse)\n{\n  int v4; // eax\n  int v6; // esi\n  int v8; // r14d\n  __int64 v9; // rdi\n  int v10; // ecx\n  __int64 v11; // r8\n  int v12; // eax\n  int v13; // r9d\n  __int64 v14; // rax\n  int *v15; // rdx\n  int *v16; // rax\n  int v17; // edi\n  int v18; // ebx\n  __int64 v19; // r10\n  __int64 v20; // rbp\n  int *v21; // r11\n  int *v22; // r10\n  int v23; // r8d\n  int v24; // r9d\n  __int64 j; // rax\n  int v26; // ecx\n  int v27; // esi\n  int v28; // ecx\n  int v29; // edi\n  int v30; // edx\n  int v31; // esi\n  __int64 v32; // rax\n  int v33; // esi\n  int v34; // edx\n  int v35; // edx\n  __int64 i; // [rsp+0h] [rbp-58h]\n  char k; // [rsp+8h] [rbp-50h]\n  __int64 v40; // [rsp+10h] [rbp-48h]\n  int istep; // [rsp+18h] [rbp-40h]\n  int scale; // [rsp+1Ch] [rbp-3Ch]\n\n  v4 = 1 << m;\n  if ( 1 << m > 1024 )\n    return -1;\n  v6 = v4 - 1;\n  v8 = 1 << m;\n  if ( v4 - 1 > 0 )\n  {\n    v9 = 1LL;\n    v10 = 0;\n    v11 = (unsigned int)(v4 - 2) + 2LL;\n    do\n    {\n      v12 = v8;\n      do\n        v12 >>= 1;\n      while ( v12 + v10 > v6 );\n      v10 = (v10 & (v12 - 1)) + v12;\n      if ( v10 > (int)v9 )\n      {\n        v13 = fr[v9];\n        v14 = v10;\n        v15 = &fr[v14];\n        v16 = &fi[v14];\n        fr[v9] = *v15;\n        *v15 = v13;\n        LODWORD(v15) = fi[v9];\n        fi[v9] = *v16;\n        *v16 = (int)v15;\n      }\n      ++v9;\n    }\n    while ( v11 != v9 );\n  }\n  scale = 0;\n  if ( v8 > 1 )\n  {\n    v17 = 1;\n    k = 9;\n    v18 = 1;\n    if ( inverse )\n      goto LABEL_23;\nLABEL_11:\n    while ( 1 )\n    {\n      i = 0LL;\n      istep = 2 * v17;\n      v19 = v17;\n      v20 = 2 * v17;\n      v40 = v17;\n      v21 = &fr[v19];\n      v22 = &fi[v19];\n      do\n      {\n        v23 = Sinewave[(_DWORD)i << k];\n        v24 = Sinewave[((_DWORD)i << k) + 256];\n        if ( !inverse )\n          v23 = -Sinewave[(_DWORD)i << k];\n        if ( v18 )\n        {\n          v24 >>= 1;\n          v23 >>= 1;\n        }\n        for ( j = i; v8 > (int)j; j += v20 )\n        {\n          v26 = v21[j];\n          v27 = v23 * v26;\n          v28 = ((v24 * v26) >> 15) - ((v23 * v22[j]) >> 15);\n          v29 = fr[j];\n          v30 = (v27 >> 15) + ((v24 * v22[j]) >> 15);\n          v31 = fi[j];\n          if ( v18 )\n          {\n            v29 >>= 1;\n            v31 >>= 1;\n          }\n          v21[j] = v29 - v28;\n          v22[j] = v31 - v30;\n          fr[j] = v28 + v29;\n          fi[j] = v30 + v31;\n        }\n        ++i;\n      }\n      while ( v40 != i );\n      --k;\n      if ( v8 <= istep )\n        break;\n      v17 = istep;\n      v18 = 1;\n      if ( inverse )\n      {\nLABEL_23:\n        v32 = 0LL;\n        while ( 1 )\n        {\n          v33 = fi[v32];\n          v34 = -fr[v32];\n          if ( fr[v32] > 0 )\n            v34 = fr[v32];\n          if ( v34 > 0x3FFF )\n            break;\n          v35 = -v33;\n          if ( v33 > 0 )\n            v35 = fi[v32];\n          if ( v35 > 0x3FFF )\n            break;\n          if ( v8 == ++v32 )\n          {\n            v18 = 0;\n            goto LABEL_11;\n          }\n        }\n        ++scale;\n        v18 = 1;\n      }\n    }\n  }\n  return scale;\n}\n"}, "pseudo_normalize": "int fix_fft(int *fr, int *fi, int m, int inverse) {\n  int v4;\n  int v6;\n  int v8;\n  long long v9;\n  int v10;\n  long long v11;\n  int v12;\n  int v13;\n  long long v14;\n  int *v15;\n  int *v16;\n  int v17;\n  int v18;\n  long long v19;\n  long long v20;\n  int *v21;\n  int *v22;\n  int v23;\n  int v24;\n  long long j;\n  int v26;\n  int v27;\n  int v28;\n  int v29;\n  int v30;\n  int v31;\n  long long v32;\n  int v33;\n  int v34;\n  int v35;\n  long long i;\n  char k;\n  long long v40;\n  int istep;\n  int scale;\n  v4 = 1 << m;\n  if (1 << m > 1024) return -1;\n  v6 = v4 - 1;\n  v8 = 1 << m;\n  if (v4 - 1 > 0) {\n    v9 = 1LL;\n    v10 = 0;\n    v11 = (unsigned int)(v4 - 2) + 2LL;\n    do {\n      v12 = v8;\n      do v12 >>= 1;\n      while (v12 + v10 > v6);\n      v10 = (v10 & (v12 - 1)) + v12;\n      if (v10 > (int)v9) {\n        v13 = fr[v9];\n        v14 = v10;\n        v15 = &fr[v14];\n        v16 = &fi[v14];\n        fr[v9] = *v15;\n        *v15 = v13;\n        LODWORD(v15) = fi[v9];\n        fi[v9] = *v16;\n        *v16 = (int)v15;\n      }\n      ++v9;\n    } while (v11 != v9);\n  }\n  scale = 0;\n  if (v8 > 1) {\n    v17 = 1;\n    k = 9;\n    v18 = 1;\n    if (inverse) goto LABEL_23;\n  LABEL_11:\n    while (1) {\n      i = 0LL;\n      istep = 2 * v17;\n      v19 = v17;\n      v20 = 2 * v17;\n      v40 = v17;\n      v21 = &fr[v19];\n      v22 = &fi[v19];\n      do {\n        v23 = Sinewave[(uint32_t)i << k];\n        v24 = Sinewave[((uint32_t)i << k) + 256];\n        if (!inverse) v23 = -Sinewave[(uint32_t)i << k];\n        if (v18) {\n          v24 >>= 1;\n          v23 >>= 1;\n        }\n        for (j = i; v8 > (int)j; j += v20) {\n          v26 = v21[j];\n          v27 = v23 * v26;\n          v28 = ((v24 * v26) >> 15) - ((v23 * v22[j]) >> 15);\n          v29 = fr[j];\n          v30 = (v27 >> 15) + ((v24 * v22[j]) >> 15);\n          v31 = fi[j];\n          if (v18) {\n            v29 >>= 1;\n            v31 >>= 1;\n          }\n          v21[j] = v29 - v28;\n          v22[j] = v31 - v30;\n          fr[j] = v28 + v29;\n          fi[j] = v30 + v31;\n        }\n        ++i;\n      } while (v40 != i);\n      --k;\n      if (v8 <= istep) break;\n      v17 = istep;\n      v18 = 1;\n      if (inverse) {\n      LABEL_23:\n        v32 = 0LL;\n        while (1) {\n          v33 = fi[v32];\n          v34 = -fr[v32];\n          if (fr[v32] > 0) v34 = fr[v32];\n          if (v34 > 16383) break;\n          v35 = -v33;\n          if (v33 > 0) v35 = fi[v32];\n          if (v35 > 16383) break;\n          if (v8 == ++v32) {\n            v18 = 0;\n            goto LABEL_11;\n          }\n        }\n        ++scale;\n        v18 = 1;\n      }\n    }\n  }\n  return scale;\n}", "binary": "fft-int/fft-int.host.O2", "assembly": "<fix_fft>:\nendbr64\npush   %r15\nmov    $0x1,%eax\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %ecx,-0x1c(%rsp)\nmov    %edx,%ecx\nshl    %cl,%eax\ncmp    $0x400,%eax\njg     155e <fix_fft+0x23e>\nmov    %rsi,%r12\nlea    -0x1(%rax),%esi\nmov    %rdi,%r13\nmov    %eax,%r14d\ntest   %esi,%esi\njle    13ba <fix_fft+0x9a>\nlea    -0x2(%rax),%r8d\nmov    $0x1,%edi\nxor    %ecx,%ecx\nadd    $0x2,%r8\nnopl   (%rax)\nmov    %r14d,%eax\nnopl   0x0(%rax,%rax,1)\nsar    %eax\nlea    (%rax,%rcx,1),%edx\ncmp    %esi,%edx\njg     1370 <fix_fft+0x50>\nlea    -0x1(%rax),%edx\nand    %ecx,%edx\nlea    (%rdx,%rax,1),%ecx\ncmp    %edi,%ecx\njle    13b1 <fix_fft+0x91>\nmovslq %ecx,%rax\nmov    0x0(%r13,%rdi,4),%r9d\nshl    $0x2,%rax\nlea    0x0(%r13,%rax,1),%rdx\nadd    %r12,%rax\nmov    (%rdx),%r10d\nmov    %r10d,0x0(%r13,%rdi,4)\nmov    %r9d,(%rdx)\nmov    (%r12,%rdi,4),%edx\nmov    (%rax),%r9d\nmov    %r9d,(%r12,%rdi,4)\nmov    %edx,(%rax)\nadd    $0x1,%rdi\ncmp    %rdi,%r8\njne    1368 <fix_fft+0x48>\nmovl   $0x0,-0xc(%rsp)\ncmp    $0x1,%r14d\njle    1566 <fix_fft+0x246>\nmov    -0x1c(%rsp),%ecx\nmovslq %r14d,%rax\nmov    $0x1,%edi\nmovl   $0x9,-0x20(%rsp)\nmov    %rax,-0x8(%rsp)\nmov    $0x1,%ebx\ntest   %ecx,%ecx\njne    150d <fix_fft+0x1ed>\nnopw   0x0(%rax,%rax,1)\nmovq   $0x0,-0x28(%rsp)\nlea    (%rdi,%rdi,1),%eax\nmovslq %edi,%rcx\nmov    %eax,-0x10(%rsp)\nlea    0x0(,%rcx,4),%r10\nmovslq %eax,%rbp\nmov    %rcx,-0x18(%rsp)\nlea    0x0(%r13,%r10,1),%r11\nadd    %r12,%r10\nnopl   0x0(%rax,%rax,1)\nmovzbl -0x20(%rsp),%ecx\nmov    -0x28(%rsp),%eax\nshl    %cl,%eax\nlea    0x6d86(%rip),%rcx\nlea    0x100(%rax),%edx\ncltq\nmov    (%rcx,%rax,4),%r8d\nmovslq %edx,%rdx\nmov    (%rcx,%rdx,4),%r9d\nmov    -0x1c(%rsp),%edx\nmov    %r8d,%eax\nneg    %eax\ntest   %edx,%edx\ncmove  %eax,%r8d\ntest   %ebx,%ebx\nje     1466 <fix_fft+0x146>\nsar    %r9d\nsar    %r8d\nmov    -0x28(%rsp),%rax\ncmp    %eax,%r14d\njle    14d6 <fix_fft+0x1b6>\nmov    (%r11,%rax,4),%esi\nmov    (%r10,%rax,4),%edx\nmov    %esi,%ecx\nimul   %r8d,%esi\nmov    %edx,%edi\nimul   %r9d,%ecx\nimul   %r8d,%edi\nimul   %r9d,%edx\nsar    $0xf,%esi\nsar    $0xf,%ecx\nsar    $0xf,%edi\nsar    $0xf,%edx\nsub    %edi,%ecx\nmov    0x0(%r13,%rax,4),%edi\nadd    %esi,%edx\nmov    (%r12,%rax,4),%esi\ntest   %ebx,%ebx\nje     14ad <fix_fft+0x18d>\nsar    %edi\nsar    %esi\nmov    %edi,%r15d\nadd    %ecx,%edi\nsub    %ecx,%r15d\nmov    %r15d,(%r11,%rax,4)\nmov    %esi,%r15d\nadd    %edx,%esi\nsub    %edx,%r15d\nmov    %r15d,(%r10,%rax,4)\nmov    %edi,0x0(%r13,%rax,4)\nmov    %esi,(%r12,%rax,4)\nadd    %rbp,%rax\ncmp    %eax,%r14d\njg     1470 <fix_fft+0x150>\naddq   $0x1,-0x28(%rsp)\nmov    -0x28(%rsp),%rax\ncmp    %rax,-0x18(%rsp)\njne    1428 <fix_fft+0x108>\nsubl   $0x1,-0x20(%rsp)\ncmp    -0x10(%rsp),%r14d\njle    1566 <fix_fft+0x246>\nmov    -0x1c(%rsp),%ecx\nmov    -0x10(%rsp),%edi\nmov    $0x1,%ebx\ntest   %ecx,%ecx\nje     13f8 <fix_fft+0xd8>\nmov    -0x8(%rsp),%r8\nxor    %eax,%eax\nnopl   0x0(%rax)\nmov    0x0(%r13,%rax,4),%ecx\nmov    (%r12,%rax,4),%esi\nmov    %ecx,%edx\nneg    %edx\ncmovs  %ecx,%edx\ncmp    $0x3fff,%edx\njg     154f <fix_fft+0x22f>\nmov    %esi,%edx\nneg    %edx\ncmovs  %esi,%edx\ncmp    $0x3fff,%edx\njg     154f <fix_fft+0x22f>\nadd    $0x1,%rax\ncmp    %rax,%r8\njne    1518 <fix_fft+0x1f8>\nxor    %ebx,%ebx\njmp    13f8 <fix_fft+0xd8>\naddl   $0x1,-0xc(%rsp)\nmov    $0x1,%ebx\njmp    13f8 <fix_fft+0xd8>\nmovl   $0xffffffff,-0xc(%rsp)\nmov    -0xc(%rsp),%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "fix_loud", "content": "/* fix_loud() - compute loudness of freq-spectrum components.\n   n should be ntot/2, where ntot was passed to fix_fft();\n   6 dB is added to account for the omitted alias components.\n   scale_shift should be the result of fix_fft(), if the time-series\n   was obtained from an inverse FFT, 0 otherwise.\n   loud[] is the loudness, in dB wrt 32767; will be +10 to -N_LOUD.\n*/\nvoid\nfix_loud(fixed loud[], fixed fr[], fixed fi[], int n, int scale_shift)\n{\n  int i, max;\n\n  max = 0;\n  if(scale_shift > 0)\n    max = 10;\n  scale_shift = (scale_shift+1) * 6;\n\n  for(i=0; i<n; ++i) {\n    loud[i] = db_from_ampl(fr[i],fi[i]) + scale_shift;\n    if(loud[i] > max)\n      loud[i] = max;\n  }\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O2.pseudo", "function_name": "fix_loud", "address": "0x1710", "label": "fix_loud", "content": "void __fastcall fix_loud(int *loud, int *fr, int *fi, int n, int scale_shift)\n{\n  int v5; // r12d\n  __int64 v7; // rbx\n  __int64 i; // r13\n  int v9; // eax\n  int v10; // r11d\n\n  v5 = 2 * (3 * scale_shift + 3);\n  if ( n > 0 )\n  {\n    v7 = n;\n    for ( i = 0LL; i != v7; ++i )\n    {\n      v9 = v5 + db_from_ampl(fr[i], fi[i]);\n      if ( v9 > v10 )\n        v9 = v10;\n      loud[i] = v9;\n    }\n  }\n}\n"}, "pseudo_normalize": "void fix_loud(int *loud, int *fr, int *fi, int n, int scale_shift) {\n  int v5;\n  long long v7;\n  long long i;\n  int v9;\n  int v10;\n  v5 = 2 * (3 * scale_shift + 3);\n  if (n > 0) {\n    v7 = n;\n    for (i = 0LL; i != v7; ++i) {\n      v9 = v5 + db_from_ampl(fr[i], fi[i]);\n      if (v9 > v10) v9 = v10;\n      loud[i] = v9;\n    }\n  }\n}", "binary": "fft-int/fft-int.host.O2", "assembly": "<fix_loud>:\nendbr64\npush   %r15\nxor    %r11d,%r11d\nmov    $0xa,%eax\ntest   %r8d,%r8d\npush   %r14\ncmovg  %eax,%r11d\npush   %r13\npush   %r12\nlea    0x3(%r8,%r8,2),%r12d\npush   %rbp\nadd    %r12d,%r12d\npush   %rbx\ntest   %ecx,%ecx\njle    1775 <fix_loud+0x65>\nmov    %rdi,%rbp\nmov    %rsi,%r14\nmov    %rdx,%r15\nmovslq %ecx,%rbx\nxor    %r13d,%r13d\nnopl   0x0(%rax,%rax,1)\nmov    (%r15,%r13,4),%esi\nmov    (%r14,%r13,4),%edi\ncall   1670 <db_from_ampl>\nadd    %r12d,%eax\ncmp    %r11d,%eax\ncmovg  %r11d,%eax\nmov    %eax,0x0(%rbp,%r13,4)\nadd    $0x1,%r13\ncmp    %rbx,%r13\njne    1750 <fix_loud+0x40>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "fix_mpy", "content": "/* fix_mpy() - fixed-point multiplication */\nfixed\nfix_mpy(fixed a, fixed b)\n{\n  FIX_MPY(a,a,b);\n  return a;\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O2.pseudo", "function_name": "fix_mpy", "address": "0x1780", "label": "fix_mpy", "content": "int __fastcall fix_mpy(int a, int b)\n{\n  return (b * a) >> 15;\n}\n"}, "pseudo_normalize": "", "binary": "fft-int/fft-int.host.O2", "assembly": "<fix_mpy>:\nendbr64\nimul   %esi,%edi\nmov    %edi,%eax\nsar    $0xf,%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "iscale", "content": "/* iscale() - scale an integer value by (numer/denom) */\nint\niscale(int value, int numer, int denom)\n{\n  return (int) value * (int)numer/(int)denom;\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O2.pseudo", "function_name": "iscale", "address": "0x1790", "label": "iscale", "content": "int __fastcall iscale(int value, int numer, int denom)\n{\n  return numer * value / denom;\n}\n"}, "pseudo_normalize": "", "binary": "fft-int/fft-int.host.O2", "assembly": "<iscale>:\nendbr64\nmov    %edi,%eax\nmov    %edx,%r8d\nimul   %esi,%eax\ncltd\nidiv   %r8d\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "fft-int/fft-int.c", "function_name": "window", "content": "/* window() - apply a Hanning window       */\nvoid\nwindow(fixed fr[], int n)\n{\n  int i,j,k;\n\n  j = N_WAVE/n;\n  n >>= 1;\n  for(i=0,k=N_WAVE/4; i<n; ++i,k+=j)\n    FIX_MPY(fr[i],fr[i],16384-(Sinewave[k]>>1));\n  n <<= 1;\n  for(k-=j; i<n; ++i,k-=j)\n    FIX_MPY(fr[i],fr[i],16384-(Sinewave[k]>>1));\n}\n"}, "pseudo": {"path": "fft-int/fft-int.host.O2.pseudo", "function_name": "window", "address": "0x1580", "label": "window", "content": "void __fastcall window(int *fr, int n)\n{\n  int v2; // r10d\n  int v3; // eax\n  int *v5; // rcx\n  int *v6; // r9\n  int *v8; // rdi\n  __int64 v9; // r13\n  int v10; // esi\n  signed int v11; // r8d\n  int v12; // r13d\n  int *v13; // rcx\n  __int64 v14; // rax\n  int *v15; // rdi\n  int *v16; // r9\n  int v17; // esi\n\n  v2 = n >> 1;\n  v3 = 1024 / n;\n  if ( n >> 1 > 0 )\n  {\n    v5 = fr;\n    v6 = fr + 1;\n    v8 = &Sinewave[256];\n    v9 = (unsigned int)(v2 - 1);\n    do\n    {\n      v10 = *v8;\n      ++v5;\n      v8 += v3;\n      *(v5 - 1) = (*(v5 - 1) * (0x4000 - (v10 >> 1))) >> 15;\n    }\n    while ( v5 != &v6[v9] );\n    v11 = n & 0xFFFFFFFE;\n    v12 = v3 * v9 + 256;\n    if ( v2 < v11 )\n    {\n      v13 = &fr[v2];\n      v14 = 4LL * -v3;\n      v15 = &Sinewave[v12];\n      v16 = &v6[v2 + (unsigned __int64)(unsigned int)(v11 - 1 - v2)];\n      do\n      {\n        v17 = *v15;\n        ++v13;\n        v15 = (int *)((char *)v15 + v14);\n        *(v13 - 1) = (*(v13 - 1) * (0x4000 - (v17 >> 1))) >> 15;\n      }\n      while ( v13 != v16 );\n    }\n  }\n}\n"}, "pseudo_normalize": "void window(int *fr, int n) {\n  int v2;\n  int v3;\n  int *v5;\n  int *v6;\n  int *v8;\n  long long v9;\n  int v10;\n  signed int v11;\n  int v12;\n  int *v13;\n  long long v14;\n  int *v15;\n  int *v16;\n  int v17;\n  v2 = n >> 1;\n  v3 = 1024 / n;\n  if (n >> 1 > 0) {\n    v5 = fr;\n    v6 = fr + 1;\n    v8 = &Sinewave[256];\n    v9 = (unsigned int)(v2 - 1);\n    do {\n      v10 = *v8;\n      ++v5;\n      v8 += v3;\n      *(v5 - 1) = (*(v5 - 1) * (16384 - (v10 >> 1))) >> 15;\n    } while (v5 != &v6[v9]);\n    v11 = n & 4294967294;\n    v12 = v3 * v9 + 256;\n    if (v2 < v11) {\n      v13 = &fr[v2];\n      v14 = 4LL * -v3;\n      v15 = &Sinewave[v12];\n      v16 = &v6[v2 + (unsigned long long)(unsigned int)(v11 - 1 - v2)];\n      do {\n        v17 = *v15;\n        ++v13;\n        v15 = (int *)((char *)v15 + v14);\n        *(v13 - 1) = (*(v13 - 1) * (16384 - (v17 >> 1))) >> 15;\n      } while (v13 != v16);\n    }\n  }\n}", "binary": "fft-int/fft-int.host.O2", "assembly": "<window>:\nendbr64\nmov    $0x400,%eax\nmov    %esi,%r10d\ncltd\nsar    %r10d\nidiv   %esi\ntest   %r10d,%r10d\njle    1660 <window+0xe0>\nmov    %rdi,%r11\npush   %r13\nlea    -0x1(%r10),%edx\nmov    %rdi,%rcx\npush   %r12\nlea    0x4(%r11),%r9\nmov    %esi,%r8d\nlea    0x7009(%rip),%rdi\npush   %rbp\nmov    %rdx,%r13\nlea    (%r9,%rdx,4),%r12\nmov    $0x4000,%ebp\npush   %rbx\nmovslq %eax,%rbx\nshl    $0x2,%rbx\nnopl   0x0(%rax)\nmov    (%rdi),%esi\nmov    %ebp,%edx\nadd    $0x4,%rcx\nadd    %rbx,%rdi\nsar    %esi\nsub    %esi,%edx\nimul   -0x4(%rcx),%edx\nsar    $0xf,%edx\nmov    %edx,-0x4(%rcx)\ncmp    %r12,%rcx\njne    15d0 <window+0x50>\nimul   %eax,%r13d\nand    $0xfffffffe,%r8d\nadd    $0x100,%r13d\ncmp    %r8d,%r10d\njge    1657 <window+0xd7>\nsub    $0x1,%r8d\nmovslq %r10d,%rdx\nneg    %eax\nmovslq %r13d,%r13\nsub    %r10d,%r8d\nlea    0x6ba8(%rip),%rsi\nlea    (%r11,%rdx,4),%rcx\ncltq\nadd    %rdx,%r8\nshl    $0x2,%rax\nlea    (%rsi,%r13,4),%rdi\nlea    (%r9,%r8,4),%r9\nmov    $0x4000,%r8d\nnopl   0x0(%rax,%rax,1)\nmov    (%rdi),%esi\nmov    %r8d,%edx\nadd    $0x4,%rcx\nadd    %rax,%rdi\nsar    %esi\nsub    %esi,%edx\nimul   -0x4(%rcx),%edx\nsar    $0xf,%edx\nmov    %edx,-0x4(%rcx)\ncmp    %r9,%rcx\njne    1638 <window+0xb8>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nxchg   %ax,%ax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "flood-fill/flood-fill.c", "function_name": "main", "content": " \nint\nmain()\n{\n\n  // start node\n  int x = 3, y = 9;    // having a target color `X`\n\n  // replacement color, NOTE: must be a new color!\n  char replacement = 'C';\n\n  // print the colors before replacement\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", replacement, x, y); printMatrix(mat);\n\n  // replace the target color with a replacement color using DFS\n  floodfill(mat, x, y, replacement);\n\n  // print the colors after replacement\n  libmin_printf(\"\\nAFTER:\\n\"); printMatrix(mat);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "flood-fill/flood-fill.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char (*)[10])mat);\n  floodfill((char (*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char (*)[10])mat);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"\\nBEFORE flooding `%c' @ (%d,%d):\\n\", 67LL, 3, 9);\n  printMatrix((char(*)[10])mat);\n  floodfill((char(*)[10])mat, 3, 9, 67);\n  libmin_printf(\"\\nAFTER:\\n\");\n  printMatrix((char(*)[10])mat);\n  libmin_success();\n}", "binary": "flood-fill/flood-fill.host.O2", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    $0x9,%ecx\nlea    0x3f4f(%rip),%rbp\nxor    %eax,%eax\nmov    $0x3,%edx\nmov    $0x43,%esi\nlea    0x1ef4(%rip),%rdi\ncall   2900 <libmin_printf>\nmov    %rbp,%rdi\ncall   1350 <printMatrix>\nmov    $0x43,%ecx\nmov    $0x9,%edx\nmov    %rbp,%rdi\nmov    $0x3,%esi\ncall   1260 <floodfill>\nlea    0x1eba(%rip),%rdi\nxor    %eax,%eax\ncall   2900 <libmin_printf>\nmov    %rbp,%rdi\ncall   1350 <printMatrix>\ncall   2b40 <libmin_success>\nxor    %eax,%eax\npop    %rbp\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "flood-fill/flood-fill.c", "function_name": "printMatrix", "content": " \n// Utility function to print a matrix\nvoid\nprintMatrix(char mat[M][N])\n{\n  for (int i = 0; i < M; i++)\n  {\n    for (int j = 0; j < N; j++)\n      libmin_printf(\"  %c\", mat[i][j]);\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo": {"path": "flood-fill/flood-fill.host.O2.pseudo", "function_name": "printMatrix", "address": "0x1350", "label": "printMatrix", "content": "void __fastcall printMatrix(char (*mat)[10])\n{\n  char *v1; // rbp\n  char *v2; // rbx\n  __int64 v3; // rsi\n\n  v1 = &(*mat)[10];\n  do\n  {\n    v2 = v1 - 10;\n    do\n    {\n      v3 = (unsigned int)*v2++;\n      libmin_printf(\"  %c\", v3);\n    }\n    while ( v2 != v1 );\n    v1 = v2 + 10;\n    libmin_printf((char *)\"\\n\");\n  }\n  while ( v2 + 10 != &(*mat)[110] );\n}\n"}, "pseudo_normalize": "void printMatrix(char (*mat)[10]) {\n  char *v1;\n  char *v2;\n  long long v3;\n  v1 = &(*mat)[10];\n  do {\n    v2 = v1 - 10;\n    do {\n      v3 = (unsigned int)*v2++;\n      libmin_printf(\"  %c\", v3);\n    } while (v2 != v1);\n    v1 = v2 + 10;\n    libmin_printf((char *)\"\\n\");\n  } while (v2 + 10 != &(*mat)[110]);\n}", "binary": "flood-fill/flood-fill.host.O2", "assembly": "<printMatrix>:\nendbr64\npush   %r14\nlea    0x1cb3(%rip),%r14\npush   %r13\nlea    0x6e(%rdi),%r13\npush   %r12\nlea    0x1c98(%rip),%r12\npush   %rbp\nlea    0xa(%rdi),%rbp\npush   %rbx\nnopw   0x0(%rax,%rax,1)\nlea    -0xa(%rbp),%rbx\nnopl   0x0(%rax)\nmovsbl (%rbx),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   2900 <libmin_printf>\ncmp    %rbp,%rbx\njne    1380 <printMatrix+0x30>\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    0xa(%rbx),%rbp\ncall   2900 <libmin_printf>\ncmp    %r13,%rbp\njne    1378 <printMatrix+0x28>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "avaliatokens", "content": "/* ---------------------------------------------------------------------- */\nvoid avaliatokens(char *aux[SBUFF],  int frac[MYMAX], int i) /* analyzes the tokens, to check the fractions */\n{\n    int j, k = 0;\n    char *token2;\n    int mist;\n\n    /* 1 mist first fraction */\n    if(((libmin_strcmp(aux[2], \"+\") == 0) || (libmin_strcmp(aux[2], \"-\") == 0) || (libmin_strcmp(aux[2], \"*\") == 0) || (libmin_strcmp(aux[2], \"/\") == 0)) && i == 4)\n        mist = 1;\n    /* 1 mist second fraction */\n    if(((libmin_strcmp(aux[1], \"+\") == 0) || (libmin_strcmp(aux[1], \"-\") == 0) || (libmin_strcmp(aux[1], \"*\") == 0) || (libmin_strcmp(aux[1], \"/\") == 0)) && i == 4)\n        mist = 2;\n    \n    for(j = 0; j < i; j++)\n    {\n        if((libmin_strcmp(aux[j], \"+\") == 0))\n        {\n            frac[MYMAX - 1] = 1;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"-\") == 0))\n        {\n            frac[MYMAX - 1] = 2;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"*\") == 0))\n        {\n            frac[MYMAX - 1] = 3;\n            j++;\n        }\n        if((libmin_strcmp(aux[j], \"/\") == 0))\n        {\n            frac[MYMAX - 1] = 4;\n            j++;\n        }\n\n        token2 = libmin_strtok(aux[j], \"/\"); /* divides the equation into tokens */\n        while(token2 != NULL)\n        {\n            frac[k] = libmin_atoi(token2); /* stores tokens in the array */\n            token2 = libmin_strtok(NULL, \"/\");\n            k++;\n        }\n    }\n    misto(mist, frac, i);\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O2.pseudo", "function_name": "avaliatokens", "address": "0x15f0", "label": "avaliatokens", "content": "void __fastcall avaliatokens(char **aux, int *frac, int i)\n{\n  int v4; // ebp\n  int v5; // r14d\n  char **v6; // rbx\n  char *v7; // rdi\n  __int64 v8; // rbx\n  __int64 v9; // [rsp+0h] [rbp-58h]\n  int v11; // [rsp+1Ch] [rbp-3Ch]\n\n  if ( libmin_strcmp(aux[2], \"+\") && libmin_strcmp(aux[2], asc_40C8) && libmin_strcmp(aux[2], &asc_40C8[2]) )\n    libmin_strcmp(aux[2], &asc_40C8[4]);\n  if ( libmin_strcmp(aux[1], \"+\")\n    && libmin_strcmp(aux[1], asc_40C8)\n    && libmin_strcmp(aux[1], &asc_40C8[2])\n    && libmin_strcmp(aux[1], &asc_40C8[4])\n    || i != 4 )\n  {\n    v11 = 1;\n    if ( i <= 0 )\n      goto LABEL_18;\n  }\n  else\n  {\n    v11 = 2;\n  }\n  v4 = 0;\n  v5 = 0;\n  do\n  {\n    v6 = &aux[v5];\n    v9 = v5;\n    if ( !libmin_strcmp(*v6, \"+\") )\n    {\n      ++v5;\n      frac[10] = 1;\n      v6 = &aux[v9 + 1];\n    }\n    if ( !libmin_strcmp(*v6, asc_40C8) )\n    {\n      frac[10] = 2;\n      v6 = &aux[++v5];\n    }\n    if ( !libmin_strcmp(*v6, &asc_40C8[2]) )\n    {\n      frac[10] = 3;\n      v6 = &aux[++v5];\n    }\n    if ( !libmin_strcmp(*v6, &asc_40C8[4]) )\n    {\n      frac[10] = 4;\n      v6 = &aux[++v5];\n    }\n    v7 = libmin_strtok(*v6, &asc_40C8[4]);\n    if ( v7 )\n    {\n      v8 = v4 + 1;\n      do\n      {\n        v4 = v8;\n        frac[v8++ - 1] = libmin_atoi(v7);\n        v7 = libmin_strtok(0LL, &asc_40C8[4]);\n      }\n      while ( v7 );\n    }\n    ++v5;\n  }\n  while ( i > v5 );\nLABEL_18:\n  misto(v11, frac, i);\n}\n"}, "pseudo_normalize": "void avaliatokens(char **aux, int *frac, int i) {\n  int v4;\n  int v5;\n  char **v6;\n  char *v7;\n  long long v8;\n  long long v9;\n  int v11;\n  if (libmin_strcmp(aux[2], \"+\") && libmin_strcmp(aux[2], asc_40C8) &&\n      libmin_strcmp(aux[2], &asc_40C8[2]))\n    libmin_strcmp(aux[2], &asc_40C8[4]);\n  if (libmin_strcmp(aux[1], \"+\") && libmin_strcmp(aux[1], asc_40C8) &&\n          libmin_strcmp(aux[1], &asc_40C8[2]) &&\n          libmin_strcmp(aux[1], &asc_40C8[4]) ||\n      i != 4) {\n    v11 = 1;\n    if (i <= 0) goto LABEL_18;\n  } else {\n    v11 = 2;\n  }\n  v4 = 0;\n  v5 = 0;\n  do {\n    v6 = &aux[v5];\n    v9 = v5;\n    if (!libmin_strcmp(*v6, \"+\")) {\n      ++v5;\n      frac[10] = 1;\n      v6 = &aux[v9 + 1];\n    }\n    if (!libmin_strcmp(*v6, asc_40C8)) {\n      frac[10] = 2;\n      v6 = &aux[++v5];\n    }\n    if (!libmin_strcmp(*v6, &asc_40C8[2])) {\n      frac[10] = 3;\n      v6 = &aux[++v5];\n    }\n    if (!libmin_strcmp(*v6, &asc_40C8[4])) {\n      frac[10] = 4;\n      v6 = &aux[++v5];\n    }\n    v7 = libmin_strtok(*v6, &asc_40C8[4]);\n    if (v7) {\n      v8 = v4 + 1;\n      do {\n        v4 = v8;\n        frac[v8++ - 1] = libmin_atoi(v7);\n        v7 = libmin_strtok(0LL, &asc_40C8[4]);\n      } while (v7);\n    }\n    ++v5;\n  } while (i > v5);\nLABEL_18:\n  misto(v11, frac, i);\n}", "binary": "frac-calc/frac-calc.host.O2", "assembly": "<avaliatokens>:\nendbr64\npush   %r15\nmov    %rdi,%r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rsi,%r12\nlea    0x2abd(%rip),%rsi\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    0x10(%rdi),%rdi\nmov    %edx,0x18(%rsp)\ncall   37e0 <libmin_strcmp>\ntest   %eax,%eax\njne    178f <avaliatokens+0x19f>\nmov    0x8(%r15),%rdi\nlea    0x2a97(%rip),%rsi\ncall   37e0 <libmin_strcmp>\ntest   %eax,%eax\njne    17ea <avaliatokens+0x1fa>\ncmpl   $0x4,0x18(%rsp)\nje     17dd <avaliatokens+0x1ed>\nmov    0x18(%rsp),%eax\nmovl   $0x1,0x1c(%rsp)\ntest   %eax,%eax\njle    1771 <avaliatokens+0x181>\nlea    0x2a66(%rip),%rax\nxor    %ebp,%ebp\nxor    %r14d,%r14d\nmov    %rax,0x8(%rsp)\nlea    0x2a57(%rip),%rax\nlea    0x2a52(%rip),%r13\nmov    %rax,0x10(%rsp)\nnop\nmovslq %r14d,%rdx\nlea    0x2a3c(%rip),%rsi\nshl    $0x3,%rdx\nlea    (%r15,%rdx,1),%rbx\nmov    %rdx,(%rsp)\nmov    (%rbx),%rdi\ncall   37e0 <libmin_strcmp>\ntest   %eax,%eax\njne    16b8 <avaliatokens+0xc8>\nmov    (%rsp),%rdx\nadd    $0x1,%r14d\nmovl   $0x1,0x28(%r12)\nlea    0x8(%r15,%rdx,1),%rbx\nmov    0x8(%rsp),%rsi\nmov    (%rbx),%rdi\ncall   37e0 <libmin_strcmp>\ntest   %eax,%eax\njne    16dd <avaliatokens+0xed>\nmovl   $0x2,0x28(%r12)\nadd    $0x1,%r14d\nmovslq %r14d,%rax\nlea    (%r15,%rax,8),%rbx\nmov    0x10(%rsp),%rsi\nmov    (%rbx),%rdi\ncall   37e0 <libmin_strcmp>\ntest   %eax,%eax\njne    1702 <avaliatokens+0x112>\nmovl   $0x3,0x28(%r12)\nadd    $0x1,%r14d\nmovslq %r14d,%rax\nlea    (%r15,%rax,8),%rbx\nmov    (%rbx),%rdi\nmov    %r13,%rsi\ncall   37e0 <libmin_strcmp>\ntest   %eax,%eax\njne    1725 <avaliatokens+0x135>\nmovl   $0x4,0x28(%r12)\nadd    $0x1,%r14d\nmovslq %r14d,%rax\nlea    (%r15,%rax,8),%rbx\nmov    (%rbx),%rdi\nmov    %r13,%rsi\ncall   38e0 <libmin_strtok>\nmov    %rax,%rdi\ntest   %rax,%rax\nje     1762 <avaliatokens+0x172>\nadd    $0x1,%ebp\nmovslq %ebp,%rbx\nxchg   %ax,%ax\ncall   1d80 <libmin_atoi>\nxor    %edi,%edi\nmov    %r13,%rsi\nmov    %ebx,%ebp\nmov    %eax,-0x4(%r12,%rbx,4)\nadd    $0x1,%rbx\ncall   38e0 <libmin_strtok>\nmov    %rax,%rdi\ntest   %rax,%rax\njne    1740 <avaliatokens+0x150>\nadd    $0x1,%r14d\ncmp    %r14d,0x18(%rsp)\njg     1680 <avaliatokens+0x90>\nmov    0x18(%rsp),%edx\nmov    0x1c(%rsp),%edi\nadd    $0x28,%rsp\nmov    %r12,%rsi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    1520 <misto>\nlea    0x2932(%rip),%rax\nmov    0x10(%r15),%rdi\nmov    %rax,%rsi\ncall   37e0 <libmin_strcmp>\ntest   %eax,%eax\nje     1624 <avaliatokens+0x34>\nlea    0x2919(%rip),%rax\nmov    0x10(%r15),%rdi\nmov    %rax,%rsi\ncall   37e0 <libmin_strcmp>\ntest   %eax,%eax\nje     1624 <avaliatokens+0x34>\nlea    0x2900(%rip),%r13\nmov    0x10(%r15),%rdi\nmov    %r13,%rsi\ncall   37e0 <libmin_strcmp>\njmp    1624 <avaliatokens+0x34>\nmovl   $0x2,0x1c(%rsp)\njmp    165b <avaliatokens+0x6b>\nlea    0x28d7(%rip),%rax\nmov    0x8(%r15),%rdi\nmov    %rax,%rsi\ncall   37e0 <libmin_strcmp>\ntest   %eax,%eax\nje     163c <avaliatokens+0x4c>\nlea    0x28be(%rip),%rax\nmov    0x8(%r15),%rdi\nmov    %rax,%rsi\ncall   37e0 <libmin_strcmp>\ntest   %eax,%eax\nje     163c <avaliatokens+0x4c>\nlea    0x28a5(%rip),%r13\nmov    0x8(%r15),%rdi\nmov    %r13,%rsi\ncall   37e0 <libmin_strcmp>\ntest   %eax,%eax\nje     163c <avaliatokens+0x4c>\njmp    1647 <avaliatokens+0x57>\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "calcula", "content": "/* ---------------------------------------------------------------------- */\nfloat calcula(int frac[MYMAX], int r[MYMAX]) /* computes the fraction */\n{\n    float dec = 0, a, b;\n\n    r[0] = frac[1] * frac[3]; /* mmc */\n    switch(frac[MYMAX - 1]) /* operation */\n    {\n        case 1: /* + */\n            r[1] = (r[0] / frac[1]) * frac[0] + (r[0] / frac[3]) * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 2: /* - */\n            r[1] = (r[0] / frac[1]) * frac[0] - (r[0] / frac[3]) * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 3: /* * */\n            r[1] = frac[0] * frac[2];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n        case 4: /* / */\n            r[0] = frac[1] * frac[2];\n            r[1] = frac[0] * frac[3];\n            a = r[1];\n            b = r[0];\n            dec = a / b; /* decimal */\n            simplifica(r);\n            break;\n    }\n\n    return dec;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O2.pseudo", "function_name": "calcula", "address": "0x1900", "label": "calcula", "content": "float __fastcall calcula(int *frac, int *r)\n{\n  int v2; // ecx\n  int v4; // esi\n  int v5; // esi\n  int v6; // edi\n  float result; // xmm0_4\n  int v8; // r8d\n  int v9; // ecx\n  int v10; // esi\n  int v11; // edi\n  int v12; // eax\n  int v13; // esi\n  int v14; // edi\n\n  v2 = frac[3] * frac[1];\n  *r = v2;\n  v4 = frac[10];\n  if ( v4 == 3 )\n  {\n    v12 = frac[2] * *frac;\n    v13 = 1;\n    r[1] = v12;\n    v14 = v12;\n    result = (float)v12 / (float)v2;\n    do\n    {\n      if ( !(v14 % v13) && !(v2 % v13) )\n      {\n        v14 /= v13;\n        v2 /= v13;\n      }\n      ++v13;\n    }\n    while ( v13 != 13 );\n    r[3] = v14;\n    r[4] = v2;\n  }\n  else if ( v4 > 3 )\n  {\n    if ( v4 != 4 )\n      return 0.0;\n    v8 = frac[2] * frac[1];\n    v9 = 1;\n    *r = v8;\n    v10 = frac[3] * *frac;\n    r[1] = v10;\n    result = (float)v10 / (float)v8;\n    do\n    {\n      if ( !(v10 % v9) && !(v8 % v9) )\n      {\n        v10 /= v9;\n        v8 /= v9;\n      }\n      ++v9;\n    }\n    while ( v9 != 13 );\n    r[3] = v10;\n    r[4] = v8;\n  }\n  else\n  {\n    if ( v4 != 1 )\n    {\n      if ( v4 == 2 )\n      {\n        v5 = 1;\n        v6 = *frac * (v2 / frac[1]) - frac[2] * (v2 / frac[3]);\n        r[1] = v6;\n        result = (float)v6 / (float)v2;\n        do\n        {\n          if ( !(v6 % v5) && !(v2 % v5) )\n          {\n            v6 /= v5;\n            v2 /= v5;\n          }\n          ++v5;\n        }\n        while ( v5 != 13 );\n        r[3] = v6;\n        r[4] = v2;\n        return result;\n      }\n      return 0.0;\n    }\n    v11 = *frac * (v2 / frac[1]) + frac[2] * (v2 / frac[3]);\n    r[1] = v11;\n    result = (float)v11 / (float)v2;\n    do\n    {\n      if ( !(v11 % v4) && !(v2 % v4) )\n      {\n        v11 /= v4;\n        v2 /= v4;\n      }\n      ++v4;\n    }\n    while ( v4 != 13 );\n    r[3] = v11;\n    r[4] = v2;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "float calcula(int *frac, int *r) {\n  int v2;\n  int v4;\n  int v5;\n  int v6;\n  float result;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  v2 = frac[3] * frac[1];\n  *r = v2;\n  v4 = frac[10];\n  if (v4 == 3) {\n    v12 = frac[2] * *frac;\n    v13 = 1;\n    r[1] = v12;\n    v14 = v12;\n    result = (float)v12 / (float)v2;\n    do {\n      if (!(v14 % v13) && !(v2 % v13)) {\n        v14 /= v13;\n        v2 /= v13;\n      }\n      ++v13;\n    } while (v13 != 13);\n    r[3] = v14;\n    r[4] = v2;\n  } else if (v4 > 3) {\n    if (v4 != 4) return 0.0;\n    v8 = frac[2] * frac[1];\n    v9 = 1;\n    *r = v8;\n    v10 = frac[3] * *frac;\n    r[1] = v10;\n    result = (float)v10 / (float)v8;\n    do {\n      if (!(v10 % v9) && !(v8 % v9)) {\n        v10 /= v9;\n        v8 /= v9;\n      }\n      ++v9;\n    } while (v9 != 13);\n    r[3] = v10;\n    r[4] = v8;\n  } else {\n    if (v4 != 1) {\n      if (v4 == 2) {\n        v5 = 1;\n        v6 = *frac * (v2 / frac[1]) - frac[2] * (v2 / frac[3]);\n        r[1] = v6;\n        result = (float)v6 / (float)v2;\n        do {\n          if (!(v6 % v5) && !(v2 % v5)) {\n            v6 /= v5;\n            v2 /= v5;\n          }\n          ++v5;\n        } while (v5 != 13);\n        r[3] = v6;\n        r[4] = v2;\n        return result;\n      }\n      return 0.0;\n    }\n    v11 = *frac * (v2 / frac[1]) + frac[2] * (v2 / frac[3]);\n    r[1] = v11;\n    result = (float)v11 / (float)v2;\n    do {\n      if (!(v11 % v4) && !(v2 % v4)) {\n        v11 /= v4;\n        v2 /= v4;\n      }\n      ++v4;\n    } while (v4 != 13);\n    r[3] = v11;\n    r[4] = v2;\n  }\n  return result;\n}", "binary": "frac-calc/frac-calc.host.O2", "assembly": "<calcula>:\nendbr64\nmov    0x4(%rdi),%ecx\nimul   0xc(%rdi),%ecx\nmov    %rsi,%r9\nmov    %ecx,(%rsi)\nmov    0x28(%rdi),%esi\ncmp    $0x3,%esi\nje     1a78 <calcula+0x178>\njg     19a0 <calcula+0xa0>\ncmp    $0x1,%esi\nje     1a10 <calcula+0x110>\ncmp    $0x2,%esi\njne    1a08 <calcula+0x108>\nmov    %ecx,%eax\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\ncltd\ncvtsi2ss %ecx,%xmm1\nidivl  0x4(%rdi)\nimul   (%rdi),%eax\nmov    %eax,%esi\nmov    %ecx,%eax\ncltd\nidivl  0xc(%rdi)\nimul   0x8(%rdi),%eax\nmov    %esi,%edi\nmov    $0x1,%esi\nsub    %eax,%edi\ncvtsi2ss %edi,%xmm0\nmov    %edi,0x4(%r9)\ndivss  %xmm1,%xmm0\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%eax\ncltd\nidiv   %esi\nmov    %eax,%r8d\ntest   %edx,%edx\njne    198a <calcula+0x8a>\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\ncmove  %r8d,%edi\ncmove  %eax,%ecx\nadd    $0x1,%esi\ncmp    $0xd,%esi\njne    1970 <calcula+0x70>\nmov    %edi,0xc(%r9)\nmov    %ecx,0x10(%r9)\nret\nnopl   0x0(%rax,%rax,1)\ncmp    $0x4,%esi\njne    1a08 <calcula+0x108>\nmov    0x4(%rdi),%r8d\nimul   0x8(%rdi),%r8d\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\nmov    $0x1,%ecx\nmov    %r8d,(%r9)\nmov    (%rdi),%esi\ncvtsi2ss %r8d,%xmm1\nimul   0xc(%rdi),%esi\ncvtsi2ss %esi,%xmm0\nmov    %esi,0x4(%r9)\ndivss  %xmm1,%xmm0\nnopl   (%rax)\nmov    %esi,%eax\ncltd\nidiv   %ecx\nmov    %eax,%edi\ntest   %edx,%edx\njne    19f2 <calcula+0xf2>\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\ncmove  %edi,%esi\ncmove  %eax,%r8d\nadd    $0x1,%ecx\ncmp    $0xd,%ecx\njne    19d8 <calcula+0xd8>\nmov    %esi,0xc(%r9)\nmov    %r8d,0x10(%r9)\nret\nnopl   0x0(%rax,%rax,1)\npxor   %xmm0,%xmm0\nret\nnopl   (%rax)\nmov    %ecx,%eax\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\ncltd\ncvtsi2ss %ecx,%xmm1\nidivl  0x4(%rdi)\nimul   (%rdi),%eax\nmov    %eax,%r8d\nmov    %ecx,%eax\ncltd\nidivl  0xc(%rdi)\nimul   0x8(%rdi),%eax\nlea    (%r8,%rax,1),%edi\ncvtsi2ss %edi,%xmm0\nmov    %edi,0x4(%r9)\ndivss  %xmm1,%xmm0\nnopw   0x0(%rax,%rax,1)\nmov    %edi,%eax\ncltd\nidiv   %esi\nmov    %eax,%r8d\ntest   %edx,%edx\njne    1a62 <calcula+0x162>\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\ncmove  %r8d,%edi\ncmove  %eax,%ecx\nadd    $0x1,%esi\ncmp    $0xd,%esi\njne    1a48 <calcula+0x148>\nmov    %edi,0xc(%r9)\nmov    %ecx,0x10(%r9)\nret\nnopl   0x0(%rax,%rax,1)\nmov    (%rdi),%eax\nimul   0x8(%rdi),%eax\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2ss %ecx,%xmm1\nmov    $0x1,%esi\ncvtsi2ss %eax,%xmm0\nmov    %eax,0x4(%r9)\nmov    %eax,%edi\ndivss  %xmm1,%xmm0\nnopl   (%rax)\nmov    %edi,%eax\ncltd\nidiv   %esi\nmov    %eax,%r8d\ntest   %edx,%edx\njne    1aba <calcula+0x1ba>\nmov    %ecx,%eax\ncltd\nidiv   %esi\ntest   %edx,%edx\ncmove  %r8d,%edi\ncmove  %eax,%ecx\nadd    $0x1,%esi\ncmp    $0xd,%esi\njne    1aa0 <calcula+0x1a0>\nmov    %edi,0xc(%r9)\nmov    %ecx,0x10(%r9)\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "copyr", "content": "/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief Prints version and copyright information and exit\n * @details Prints version and copyright information (usually called by opt -V)\n * @return Void\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nvoid copyr(void)\n{\n    IFDEBUG(\"copyr()\");\n    libmin_printf(\"%s - Version %s\\n\", \"frac\", VERSION);\n    libmin_printf(\"\\nCopyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author takes no responsability to any damage this software may inflige in your data.\\n\\n\", 2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n    if(verb > 3) libmin_printf(\"copyr(): Verbose: %d\\n\", verb); /* -vvvv */\n    libmin_fail(1);\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O2.pseudo", "function_name": "copyr", "address": "0x1460", "label": "copyr", "content": "void __cdecl __noreturn copyr()\n{\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n    \"\\n\"\n    \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http://gnu.org/licenses/gpl.html>. This  is  free  software: you are fr\"\n    \"ee to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. USE IT AS IT IS. The author \"\n    \"takes no responsability to any damage this software may inflige in your data.\\n\"\n    \"\\n\",\n    2018,\n    \"Iago Gade Gusmao Carrazzoni\",\n    \"iagocarrazzoni@gmail.com\");\n  if ( verb <= 3 )\n    libmin_fail(1);\n  libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "void __noreturn copyr() {\n  libmin_printf(\"%s - Version %s\\n\", \"frac\", \"20180915.214818\");\n  libmin_printf(\n      \"\\n\"\n      \"Copyright (C) %d %s <%s>, GNU GPL version 2 <http:\n      \"ee to change and redistribute it. There is NO WARRANTY, to the extent \"\n      \"permitted by law. USE IT AS IT IS. The author \"\n      \"takes no responsability to any damage this software may inflige in your \"\n      \"data.\\n\"\n      \"\\n\",\n      2018, \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  if (verb <= 3) libmin_fail(1);\n  libmin_printf(\"copyr(): Verbose: %d\\n\", verb);\n  libmin_fail(1);\n}", "binary": "frac-calc/frac-calc.host.O2", "assembly": "<copyr>:\nendbr64\nsub    $0x8,%rsp\nlea    0x2c0b(%rip),%rdx\nlea    0x2ba2(%rip),%rsi\nxor    %eax,%eax\nlea    0x2c0b(%rip),%rdi\ncall   35d0 <libmin_printf>\nmov    $0x7e2,%esi\nxor    %eax,%eax\nlea    0x2bb3(%rip),%rcx\nlea    0x2bc5(%rip),%rdx\nlea    0x2d78(%rip),%rdi\ncall   35d0 <libmin_printf>\nmov    0x5e01(%rip),%esi\ncmp    $0x3,%esi\njg     14c0 <copyr+0x60>\nmov    $0x1,%edi\nadd    $0x8,%rsp\njmp    1e40 <libmin_fail>\nxchg   %ax,%ax\nlea    0x2bd4(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nmov    $0x1,%edi\nadd    $0x8,%rsp\njmp    1e40 <libmin_fail>\nnopl   0x0(%rax)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "divtokens", "content": "/* ---------------------------------------------------------------------- */\nvoid divtokens(char exp[SBUFF],  int frac[MYMAX]) /* break the string in tokens */\n{\n    char *token; /* token pointer */\n    char exp2[SBUFF];\n    char *aux[SBUFF];\n    int i = 0;\n\n    libmin_strcpy(exp2, exp); /* to maintain the original expression untouched */\n\n    token = libmin_strtok(exp2, \" \"); /* divides the equation into tokens */\n    while(token != NULL)\n    {\n        aux[i] = token;\n        token = libmin_strtok(NULL, \" \");\n        i++;\n    }\n\n    frac[MYMAX - 2] = i; /* number of elements of the expression */\n\n    avaliatokens(aux, frac, i);\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O2.pseudo", "function_name": "divtokens", "address": "0x1840", "label": "divtokens", "content": "void __fastcall divtokens(char *exp, int *frac)\n{\n  char *v2; // rax\n  __int64 v3; // rbx\n  int v4; // edx\n  char *aux[60]; // [rsp+0h] [rbp-258h] BYREF\n  char exp2[72]; // [rsp+1E0h] [rbp-78h] BYREF\n  unsigned __int64 v7; // [rsp+228h] [rbp-30h]\n\n  v7 = __readfsqword(0x28u);\n  libmin_strcpy(exp2, exp);\n  v2 = libmin_strtok(exp2, &asc_40C8[6]);\n  if ( v2 )\n  {\n    v3 = 1LL;\n    do\n    {\n      aux[v3 - 1] = v2;\n      v2 = libmin_strtok(0LL, &asc_40C8[6]);\n      v4 = v3++;\n    }\n    while ( v2 );\n  }\n  else\n  {\n    v4 = 0;\n  }\n  frac[9] = v4;\n  avaliatokens(aux, frac, v4);\n}\n"}, "pseudo_normalize": "void divtokens(char *exp, int *frac) {\n  char *v2;\n  long long v3;\n  int v4;\n  char *aux[60];\n  char exp2[72];\n  unsigned long long v7;\n  v7 = __readfsqword(40u);\n  libmin_strcpy(exp2, exp);\n  v2 = libmin_strtok(exp2, &asc_40C8[6]);\n  if (v2) {\n    v3 = 1LL;\n    do {\n      aux[v3 - 1] = v2;\n      v2 = libmin_strtok(0LL, &asc_40C8[6]);\n      v4 = v3++;\n    } while (v2);\n  } else {\n    v4 = 0;\n  }\n  frac[9] = v4;\n  avaliatokens(aux, frac, v4);\n}", "binary": "frac-calc/frac-calc.host.O2", "assembly": "<divtokens>:\nendbr64\npush   %r13\npush   %r12\nmov    %rsi,%r12\nmov    %rdi,%rsi\npush   %rbp\nlea    0x2878(%rip),%rbp\npush   %rbx\nsub    $0x238,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x228(%rsp)\nxor    %eax,%eax\nlea    0x1e0(%rsp),%r13\nmov    %r13,%rdi\ncall   3840 <libmin_strcpy>\nmov    %rbp,%rsi\nmov    %r13,%rdi\ncall   38e0 <libmin_strtok>\ntest   %rax,%rax\nje     18f0 <divtokens+0xb0>\nmov    $0x1,%ebx\nmov    %rsp,%r13\nnopl   0x0(%rax)\nmov    %rbp,%rsi\nxor    %edi,%edi\nmov    %rax,-0x8(%r13,%rbx,8)\ncall   38e0 <libmin_strtok>\nmov    %ebx,%edx\nadd    $0x1,%rbx\ntest   %rax,%rax\njne    18a0 <divtokens+0x60>\nmov    %edx,0x24(%r12)\nmov    %r12,%rsi\nmov    %r13,%rdi\ncall   15f0 <avaliatokens>\nmov    0x228(%rsp),%rax\nsub    %fs:0x28,%rax\njne    18f7 <divtokens+0xb7>\nadd    $0x238,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax,%rax,1)\nxor    %edx,%edx\nmov    %rsp,%r13\njmp    18ba <divtokens+0x7a>\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "frac_init", "content": "/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief This function initializes some operations before start\n * @details Details to be written in\n * multiple lines\n *\n * @pre You need to call foo() before calling this function\n *\n * @param[in] i Input parameter that does bla\n * @param[out] o Parameter that outputs ble\n * @param[in,out] z The @a z variable is used as input and output\n *\n * @retval 0 Returned when bli\n * @retval 1 Error code: function returned blo\n *\n * @par Example\n * @code\n *    if(x == funcexample(i, o, z))\n *       printf(\"And that is it\\n\");\n * @endcode\n *\n * @return Void\n *\n * @warning Be carefull with blu\n * @todo Need to implement it. Its empty now. This doxygen tags are overwhelming.\n * Mandatory tags are: ingroup, brief, details, param, return, author and date.\n * The others are optional.\n *\n * @deprecated This function will be deactivated in version +11\n * @see help()\n * @see copyr()\n * @bug There is a bug with x greater than y\n * @note You can read more about it at <<a href=\"http://www.upe.br\">www.upe.br</a>>\n *\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n * @copyright Use this tag only if not the same as the whole file\n *\n */\nvoid frac_init(char exp[SBUFF])\n{\n    /* IFDEBUG(\"frac_init()\"); */\n    libmin_printf(\"-------------------\\n\");\n    libmin_printf(\"FRACTION CALCULATOR\\nPlease entry the desired operation:\\n(It is necessary to add a space between the fractions, like a/b + c/d)\\n-> \");\n    libmin_mgets(exp, SBUFF, minput); /* expression input */\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O2.pseudo", "function_name": "frac_init", "address": "0x14e0", "label": "frac_init", "content": "void __fastcall frac_init(char *exp)\n{\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\"FRACTION CALCULATOR\\n\"\n                \"Please entry the desired operation:\\n\"\n                \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n                \"-> \");\n  libmin_mgets(exp, 0x3CuLL, minput);\n}\n"}, "pseudo_normalize": "void frac_init(char *exp) {\n  libmin_printf(\"-------------------\\n\");\n  libmin_printf(\n      \"FRACTION CALCULATOR\\n\"\n      \"Please entry the desired operation:\\n\"\n      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n      \"-> \");\n  libmin_mgets(exp, 60uLL, minput);\n}", "binary": "frac-calc/frac-calc.host.O2", "assembly": "<frac_init>:\nendbr64\npush   %rbp\nxor    %eax,%eax\nmov    %rdi,%rbp\nlea    0x2bc0(%rip),%rdi\ncall   35d0 <libmin_printf>\nlea    0x2e5b(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nmov    0x5b15(%rip),%rdx\nmov    %rbp,%rdi\npop    %rbp\nmov    $0x3c,%esi\njmp    2090 <libmin_mgets>\nnopl   0x0(%rax)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "help", "content": "/* functions */\n/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief Prints help information and exit\n * @details Prints help information (usually called by opt -h)\n * @return Void\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nvoid help(void)\n{\n    IFDEBUG(\"help()\");\n    libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n    libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n    libmin_printf(\"\\nOptions:\\n\");\n    libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n    libmin_printf(\"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n    libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n    /* add more options here */\n    libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n    libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n    libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\", \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n    libmin_fail(1);\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O2.pseudo", "function_name": "help", "address": "0x13b0", "label": "help", "content": "void __cdecl __noreturn help()\n{\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\", \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "void __noreturn help() {\n  libmin_printf(\"%s - %s\\n\", \"frac\", \"Fraction Calculator\");\n  libmin_printf(\"\\nUsage: %s [-h|-v]\\n\", \"frac\");\n  libmin_printf(\"\\nOptions:\\n\");\n  libmin_printf(\"\\t-h,  --help\\n\\t\\tShow this help.\\n\");\n  libmin_printf(\n      \"\\t-V,  --version\\n\\t\\tShow version and copyright information.\\n\");\n  libmin_printf(\"\\t-v,  --verbose\\n\\t\\tSet verbose level (cumulative).\\n\");\n  libmin_printf(\"\\nExit status:\\n\\t0 if ok.\\n\\t1 some error occurred.\\n\");\n  libmin_printf(\"\\nTodo:\\n\\tLong options not implemented yet.\\n\");\n  libmin_printf(\"\\nAuthor:\\n\\tWritten by %s <%s>\\n\\n\",\n                \"Iago Gade Gusmao Carrazzoni\", \"iagocarrazzoni@gmail.com\");\n  libmin_fail(1);\n}", "binary": "frac-calc/frac-calc.host.O2", "assembly": "<help>:\nendbr64\npush   %rbp\nlea    0x2c5c(%rip),%rbp\nlea    0x2c41(%rip),%rdx\nxor    %eax,%eax\nmov    %rbp,%rsi\nlea    0x2c4e(%rip),%rdi\ncall   35d0 <libmin_printf>\nmov    %rbp,%rsi\nlea    0x2c48(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nlea    0x2c4e(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nlea    0x2cfe(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nlea    0x2d10(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nlea    0x2d42(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nlea    0x2d6c(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nlea    0x2d96(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nlea    0x2db8(%rip),%rdi\nlea    0x2bfe(%rip),%rdx\nxor    %eax,%eax\nlea    0x2c0e(%rip),%rsi\ncall   35d0 <libmin_printf>\nmov    $0x1,%edi\npop    %rbp\njmp    1e40 <libmin_fail>\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "main", "content": " /* print the results */\n\n/* main */\n/* ---------------------------------------------------------------------- */\n/**\n * @ingroup GroupUnique\n * @brief This is the main event of the evening\n * @details Ladies and Gentleman... It's tiiiime!\n * Fightiiiiing at the blue corner,\n * he, who has compiled more C code than any other adversary in the history,\n * he, who has developed UNIX and Linux, and is an inspiration to maaany languages\n * and compilers, the GNU C Compiler, GCC!\n * Fightiiiiing at the red corner, the challenger, in his first fight, lacking of any\n * valid experience but angrily, blindly, and no doubtfully, will try to\n * compile this program without errors. He, the student, the apprentice,\n * the developer, iggc!!\n *\n * @param[in] argc Argument counter\n * @param[in] argv Argument strings (argument values)\n *\n * @retval 0 If succeed (EXIT_SUCCESS).\n * @retval 1 Or another error code if failed.\n *\n * @par Example\n * @code\n *    $./frac -h\n * @endcode\n *\n * @warning   Be carefull with...\n * @bug There is a bug with...\n * @todo Need to do...\n * @note You can read more about it at <<a href=\"http://www.upe.br\">www.upe.br</a>>\n * @author Iago Gade Gusmao Carrazzoni\n * @version 20180915.214818\n * @date 2018-09-15\n *\n */\nint main(int argc, char *argv[])\n{\n    int opt; /* return from getopt() */\n    char exp[SBUFF]; /* expression */\n    int frac[MYMAX];\n    int r[MYMAX];\n    float dec;\n    char rep[SBUFF];\n    int repi = 1;\n\n    /* IFDEBUG(\"Starting optarg loop...\"); */\n\n    /* getopt() configured options:\n     *        -h  help\n     *        -V  version\n     *        -v  verbose\n     */\n    opterr = 0;\n    while((opt = libmin_getopt(argc, argv, \"vhV\")) != EOF)\n        switch(opt)\n        {\n            case 'h':\n                help();\n                break;\n            case 'V':\n                copyr();\n                break;\n            case 'v':\n                verb++;\n                break;\n            case '?':\n            default:\n                libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", argv[0], argv[0]);\n                return 1;\n        }\n\n    if(verb)\n        libmin_printf(\"Verbose level set at: %d\\n\", verb);\n\n    do\n    {\n        frac_init(exp); /* initialization function */\n        divtokens(exp, frac); /* break the string in tokens */\n        dec = calcula(frac, r); /* computes the fraction */\n        print(exp, r, dec, frac); /* prints the results */\n        libmin_printf(\"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, SBUFF, minput);\n        repi = libmin_atoi(rep);\n    }while(repi == 1);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  float v5; // xmm0_4\n  int frac[12]; // [rsp+0h] [rbp-128h] BYREF\n  int r[12]; // [rsp+30h] [rbp-F8h] BYREF\n  char exp[64]; // [rsp+60h] [rbp-C8h] BYREF\n  char rep[72]; // [rsp+A0h] [rbp-88h] BYREF\n  unsigned __int64 v10; // [rsp+E8h] [rbp-40h]\n\n  v10 = __readfsqword(0x28u);\n  opterr = 0;\n  while ( 1 )\n  {\n    v3 = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if ( v3 == -1 )\n    {\n      if ( verb )\n        libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      do\n      {\n        libmin_printf(\"-------------------\\n\");\n        libmin_printf(\"FRACTION CALCULATOR\\n\"\n                      \"Please entry the desired operation:\\n\"\n                      \"(It is necessary to add a space between the fractions, like a/b + c/d)\\n\"\n                      \"-> \");\n        libmin_mgets(exp, 0x3CuLL, minput);\n        divtokens(exp, frac);\n        v5 = calcula(frac, r);\n        print(exp, r, v5, frac);\n        libmin_printf(\"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 0x3CuLL, minput);\n      }\n      while ( libmin_atoi(rep) == 1 );\n      libmin_success();\n    }\n    if ( v3 == 104 )\n      help();\n    if ( v3 != 118 )\n      break;\n    ++verb;\n  }\n  if ( v3 == 86 )\n    copyr();\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  int v3;\n  float v5;\n  int frac[12];\n  int r[12];\n  char exp[64];\n  char rep[72];\n  unsigned long long v10;\n  v10 = __readfsqword(40u);\n  opterr = 0;\n  while (1) {\n    v3 = libmin_getopt(argc, (char *const *)argv, \"vhV\");\n    if (v3 == -1) {\n      if (verb) libmin_printf(\"Verbose level set at: %d\\n\", verb);\n      do {\n        libmin_printf(\"-------------------\\n\");\n        libmin_printf(\n            \"FRACTION CALCULATOR\\n\"\n            \"Please entry the desired operation:\\n\"\n            \"(It is necessary to add a space between the fractions, like a/b + \"\n            \"c/d)\\n\"\n            \"-> \");\n        libmin_mgets(exp, 60uLL, minput);\n        divtokens(exp, frac);\n        v5 = calcula(frac, r);\n        print(exp, r, v5, frac);\n        libmin_printf(\n            \"\\nDo you want to do another operation?\\nenter 1 for yes\\n\");\n        libmin_mgets(rep, 60uLL, minput);\n      } while (libmin_atoi(rep) == 1);\n      libmin_success();\n    }\n    if (v3 == 104) help();\n    if (v3 != 118) break;\n    ++verb;\n  }\n  if (v3 == 86) copyr();\n  libmin_printf(\"Type\\n\\t$man %s\\nor\\n\\t$%s -h\\nfor help.\\n\\n\", *argv, *argv);\n  return 1;\n}", "binary": "frac-calc/frac-calc.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nlea    0x2f9d(%rip),%r12\npush   %rbp\nmov    %edi,%ebp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0xf8,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0xe8(%rsp)\nxor    %eax,%eax\nmovl   $0x0,0x6112(%rip)\nmov    %r12,%rdx\nmov    %rbx,%rsi\nmov    %ebp,%edi\ncall   1e60 <libmin_getopt>\ncmp    $0xffffffff,%eax\nje     11ec <main+0xcc>\ncmp    $0x68,%eax\nje     11c8 <main+0xa8>\ncmp    $0x76,%eax\nje     11e0 <main+0xc0>\ncmp    $0x56,%eax\nje     11d0 <main+0xb0>\nmov    (%rbx),%rsi\nlea    0x32b7(%rip),%rdi\nxor    %eax,%eax\nmov    %rsi,%rdx\ncall   35d0 <libmin_printf>\nmov    $0x1,%eax\nmov    0xe8(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    12ba <main+0x19a>\nadd    $0xf8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\ncall   13b0 <help>\njmp    115e <main+0x3e>\nnop\ncall   1460 <copyr>\njmp    115e <main+0x3e>\nnopw   0x0(%rax,%rax,1)\naddl   $0x1,0x60c5(%rip)\njmp    115e <main+0x3e>\nmov    0x60ba(%rip),%esi\ntest   %esi,%esi\njne    12a7 <main+0x187>\nlea    0x2eb0(%rip),%r15\nlea    0x3150(%rip),%r14\nmov    %rsp,%rbx\nlea    0x60(%rsp),%rbp\nlea    0x30(%rsp),%r13\nlea    0xa0(%rsp),%r12\nnopl   (%rax)\nmov    %r15,%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nmov    %r14,%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nmov    0x5de5(%rip),%rdx\nmov    $0x3c,%esi\nmov    %rbp,%rdi\ncall   2090 <libmin_mgets>\nmov    %rbx,%rsi\nmov    %rbp,%rdi\ncall   1840 <divtokens>\nmov    %r13,%rsi\nmov    %rbx,%rdi\ncall   1900 <calcula>\nmov    %rbx,%rdx\nmov    %r13,%rsi\nmov    %rbp,%rdi\ncall   1b10 <print>\nlea    0x31f5(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nmov    0x5d9f(%rip),%rdx\nmov    %r12,%rdi\nmov    $0x3c,%esi\ncall   2090 <libmin_mgets>\nmov    %r12,%rdi\ncall   1d80 <libmin_atoi>\ncmp    $0x1,%eax\nje     1220 <main+0x100>\ncall   3990 <libmin_success>\nxor    %eax,%eax\njmp    1198 <main+0x78>\nlea    0x2e26(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\njmp    11fa <main+0xda>\ncall   10c0 <__stack_chk_fail@plt>\nnop\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "misto", "content": "/* ---------------------------------------------------------------------- */\nvoid misto(int mist, int frac[MYMAX], int i) /* fraction to mixed number */\n{\n    /* 2 fractions no mist */\n    if(i == 3)\n    {\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    /* 1 mist first fraction */\n    if(mist == 1)\n    {\n        frac[0] = frac[2] * frac[0] + frac[1]; /* num */\n        frac[1] = frac[2]; /* den */\n        frac[2] = frac[3]; /* num */\n        frac[3] = frac[4]; /* den */\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n\n        return;\n    }\n    /* 1 mist second fraction */\n    if(mist == 2)\n    {\n        frac[2] = frac[4] * frac[2] + frac[3];\n        frac[3] = frac[4];\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    /* 2 mist */\n    if(i == 5)\n    {\n        frac[0] = frac[2] * frac[0] + frac[1]; /* num */\n        frac[1] = frac[2]; /* den */\n        frac[2] = frac[5] * frac[3] + frac[4]; /* num */\n        frac[3] = frac[5]; /* den */\n        frac[MYMAX - 2] = frac[0]; /* num 1 */\n        frac[MYMAX - 3] = frac[1]; /* den 1 */\n        frac[MYMAX - 4] = frac[2]; /* num 2 */\n        frac[MYMAX - 5] = frac[3]; /* den 2*/ \n        return;\n    }\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O2.pseudo", "function_name": "misto", "address": "0x1520", "label": "misto", "content": "void __fastcall misto(int mist, int *frac, int i)\n{\n  int v4; // ecx\n  int v5; // edx\n  int v6; // esi\n  int v7; // esi\n  int v8; // edi\n  int v9; // ecx\n  int v10; // esi\n  int v11; // edx\n  int v12; // edx\n  int v13; // ecx\n  int v14; // edi\n  int v15; // edx\n  int v16; // esi\n\n  if ( i == 3 )\n  {\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  }\n  else if ( mist == 1 )\n  {\n    v13 = frac[2];\n    v14 = frac[3];\n    v15 = frac[1] + v13 * *frac;\n    frac[1] = v13;\n    *frac = v15;\n    frac[2] = v14;\n    v16 = frac[4];\n    frac[9] = v15;\n    frac[3] = v16;\n    frac[8] = v13;\n    frac[7] = v14;\n    frac[6] = v16;\n  }\n  else if ( mist == 2 )\n  {\n    v4 = frac[4];\n    v5 = frac[3] + v4 * frac[2];\n    frac[3] = v4;\n    frac[2] = v5;\n    v6 = *frac;\n    frac[7] = v5;\n    frac[9] = v6;\n    v7 = frac[1];\n    frac[6] = v4;\n    frac[8] = v7;\n  }\n  else if ( i == 5 )\n  {\n    v8 = frac[2];\n    v9 = frac[1] + v8 * *frac;\n    frac[1] = v8;\n    *frac = v9;\n    v10 = frac[5];\n    v11 = frac[3];\n    frac[9] = v9;\n    frac[3] = v10;\n    v12 = frac[4] + v10 * v11;\n    frac[8] = v8;\n    frac[2] = v12;\n    frac[7] = v12;\n    frac[6] = v10;\n  }\n}\n"}, "pseudo_normalize": "void misto(int mist, int *frac, int i) {\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  int v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  int v15;\n  int v16;\n  if (i == 3) {\n    frac[9] = *frac;\n    frac[8] = frac[1];\n    frac[7] = frac[2];\n    frac[6] = frac[3];\n  } else if (mist == 1) {\n    v13 = frac[2];\n    v14 = frac[3];\n    v15 = frac[1] + v13 * *frac;\n    frac[1] = v13;\n    *frac = v15;\n    frac[2] = v14;\n    v16 = frac[4];\n    frac[9] = v15;\n    frac[3] = v16;\n    frac[8] = v13;\n    frac[7] = v14;\n    frac[6] = v16;\n  } else if (mist == 2) {\n    v4 = frac[4];\n    v5 = frac[3] + v4 * frac[2];\n    frac[3] = v4;\n    frac[2] = v5;\n    v6 = *frac;\n    frac[7] = v5;\n    frac[9] = v6;\n    v7 = frac[1];\n    frac[6] = v4;\n    frac[8] = v7;\n  } else if (i == 5) {\n    v8 = frac[2];\n    v9 = frac[1] + v8 * *frac;\n    frac[1] = v8;\n    *frac = v9;\n    v10 = frac[5];\n    v11 = frac[3];\n    frac[9] = v9;\n    frac[3] = v10;\n    v12 = frac[4] + v10 * v11;\n    frac[8] = v8;\n    frac[2] = v12;\n    frac[7] = v12;\n    frac[6] = v10;\n  }\n}", "binary": "frac-calc/frac-calc.host.O2", "assembly": "<misto>:\nendbr64\nmov    %rsi,%rax\ncmp    $0x3,%edx\nje     1540 <misto+0x20>\ncmp    $0x1,%edi\nje     15c0 <misto+0xa0>\ncmp    $0x2,%edi\nje     1560 <misto+0x40>\ncmp    $0x5,%edx\nje     1588 <misto+0x68>\nret\nmov    (%rsi),%edx\nmov    %edx,0x24(%rsi)\nmov    0x4(%rsi),%edx\nmov    %edx,0x20(%rsi)\nmov    0x8(%rsi),%edx\nmov    %edx,0x1c(%rsi)\nmov    0xc(%rsi),%edx\nmov    %edx,0x18(%rsi)\nret\nnopl   0x0(%rax,%rax,1)\nmov    0x10(%rsi),%ecx\nmov    0x8(%rsi),%edx\nimul   %ecx,%edx\nadd    0xc(%rsi),%edx\nmov    %ecx,0xc(%rsi)\nmov    %edx,0x8(%rsi)\nmov    (%rsi),%esi\nmov    %edx,0x1c(%rax)\nmov    %esi,0x24(%rax)\nmov    0x4(%rax),%esi\nmov    %ecx,0x18(%rax)\nmov    %esi,0x20(%rax)\nret\nnopl   0x0(%rax)\nmov    0x8(%rsi),%edi\nmov    (%rsi),%ecx\nimul   %edi,%ecx\nadd    0x4(%rsi),%ecx\nmov    %edi,0x4(%rsi)\nmov    %ecx,(%rsi)\nmov    0x14(%rsi),%esi\nmov    0xc(%rax),%edx\nmov    %ecx,0x24(%rax)\nmov    %esi,0xc(%rax)\nimul   %esi,%edx\nadd    0x10(%rax),%edx\nmov    %edi,0x20(%rax)\nmov    %edx,0x8(%rax)\nmov    %edx,0x1c(%rax)\nmov    %esi,0x18(%rax)\nret\nnopw   0x0(%rax,%rax,1)\nmov    0x8(%rsi),%ecx\nmov    (%rsi),%edx\nmov    0xc(%rsi),%edi\nimul   %ecx,%edx\nadd    0x4(%rsi),%edx\nmov    %ecx,0x4(%rsi)\nmov    %edx,(%rsi)\nmov    %edi,0x8(%rsi)\nmov    0x10(%rsi),%esi\nmov    %edx,0x24(%rax)\nmov    %esi,0xc(%rax)\nmov    %ecx,0x20(%rax)\nmov    %edi,0x1c(%rax)\nmov    %esi,0x18(%rax)\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "print", "content": "/* ---------------------------------------------------------------------- */\nvoid print(char exp[SBUFF], int r[MYMAX], float dec, int frac[MYMAX]) /* print the results */\n{\n    char op;\n\n    if(frac[MYMAX - 1] == 1)\n        op = '+';\n    if(frac[MYMAX - 1] == 2)\n        op = '-';\n    if(frac[MYMAX - 1] == 3)\n        op = '*';\n    if(frac[MYMAX - 1] == 4)\n        op = '/';\n    \n    libmin_printf(\"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\", exp, frac[MYMAX - 2], frac[MYMAX - 3], op, frac[MYMAX - 4], frac[MYMAX - 5], r[1], r[0], r[3], r[4], dec);\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O2.pseudo", "function_name": "print", "address": "0x1b10", "label": "print", "content": "void __fastcall print(char *exp, int *r, float dec, int *frac)\n{\n  int v4; // eax\n  __int64 v5; // r8\n\n  v4 = frac[10];\n  v5 = 45LL;\n  if ( v4 != 2 )\n  {\n    v5 = 42LL;\n    if ( v4 != 3 )\n      v5 = 4 * (unsigned int)(v4 == 4) + 43;\n  }\n  libmin_printf(\n    \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: %d/%d\\nDECIMAL: %.3f\\n\",\n    exp,\n    frac[9],\n    frac[8],\n    v5,\n    frac[7],\n    frac[6],\n    r[1],\n    *r,\n    r[3],\n    r[4],\n    dec);\n}\n"}, "pseudo_normalize": "void print(char *exp, int *r, float dec, int *frac) {\n  int v4;\n  long long v5;\n  v4 = frac[10];\n  v5 = 45LL;\n  if (v4 != 2) {\n    v5 = 42LL;\n    if (v4 != 3) v5 = 4 * (unsigned int)(v4 == 4) + 43;\n  }\n  libmin_printf(\n      \"\\nEXPRESSION: %sFRACTION: %d/%d %c %d/%d\\nINTERMEDIATE: %d/%d\\nRESULT: \"\n      \"%d/%d\\nDECIMAL: %.3f\\n\",\n      exp, frac[9], frac[8], v5, frac[7], frac[6], r[1], *r, r[3], r[4], dec);\n}", "binary": "frac-calc/frac-calc.host.O2", "assembly": "<print>:\nendbr64\nsub    $0x8,%rsp\nmov    0x28(%rdx),%eax\nmov    %rdi,%r10\nmov    $0x2d,%r8d\ncmp    $0x2,%eax\nje     1b34 <print+0x24>\nmov    $0x2a,%r8d\ncmp    $0x3,%eax\njne    1b80 <print+0x70>\nmov    0x10(%rsi),%eax\nsub    $0x8,%rsp\nmov    0x20(%rdx),%ecx\nlea    0x289b(%rip),%rdi\nmov    0x24(%rdx),%r11d\ncvtss2sd %xmm0,%xmm0\npush   %rax\nmov    0xc(%rsi),%eax\npush   %rax\nmov    (%rsi),%eax\npush   %rax\nmov    0x4(%rsi),%eax\nmov    %r10,%rsi\npush   %rax\nmov    0x18(%rdx),%eax\npush   %rax\nmov    0x1c(%rdx),%r9d\nmov    $0x1,%eax\nmov    %r11d,%edx\ncall   35d0 <libmin_printf>\nadd    $0x38,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nxor    %r8d,%r8d\ncmp    $0x4,%eax\nsete   %r8b\nlea    0x2b(,%r8,4),%r8d\njmp    1b34 <print+0x24>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "frac-calc/frac-calc.c", "function_name": "simplifica", "content": "/* ---------------------------------------------------------------------- */\nvoid simplifica(int r[MYMAX]) /* simplifies the result */\n{\n    int i;\n    int aux1, aux2;\n\n    aux1 = r[1];\n    aux2 = r[0];\n\n    for(i = 1; i < MYMAX + 2; i++)\n    {\n        if(aux1%i == 0 && aux2%i == 0) /* simplified */\n        {\n            aux1 /= i;\n            aux2 /= i;\n        }\n    }\n    r[3] = aux1;\n    r[4] = aux2;\n\n    return;\n}\n"}, "pseudo": {"path": "frac-calc/frac-calc.host.O2.pseudo", "function_name": "simplifica", "address": "0x1ad0", "label": "simplifica", "content": "void __fastcall simplifica(int *r)\n{\n  int v1; // esi\n  int v2; // r8d\n  int i; // ecx\n\n  v1 = r[1];\n  v2 = *r;\n  for ( i = 1; i != 13; ++i )\n  {\n    if ( !(v1 % i) && !(v2 % i) )\n    {\n      v1 /= i;\n      v2 /= i;\n    }\n  }\n  r[3] = v1;\n  r[4] = v2;\n}\n"}, "pseudo_normalize": "void simplifica(int *r) {\n  int v1;\n  int v2;\n  int i;\n  v1 = r[1];\n  v2 = *r;\n  for (i = 1; i != 13; ++i) {\n    if (!(v1 % i) && !(v2 % i)) {\n      v1 /= i;\n      v2 /= i;\n    }\n  }\n  r[3] = v1;\n  r[4] = v2;\n}", "binary": "frac-calc/frac-calc.host.O2", "assembly": "<simplifica>:\nendbr64\nmov    0x4(%rdi),%esi\nmov    (%rdi),%r8d\nmov    $0x1,%ecx\nnop\nmov    %esi,%eax\ncltd\nidiv   %ecx\nmov    %eax,%r9d\ntest   %edx,%edx\njne    1afc <simplifica+0x2c>\nmov    %r8d,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\ncmove  %r9d,%esi\ncmove  %eax,%r8d\nadd    $0x1,%ecx\ncmp    $0xd,%ecx\njne    1ae0 <simplifica+0x10>\nmov    %esi,0xc(%rdi)\nmov    %r8d,0x10(%rdi)\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "fuzzy-match/fuzzy-match.c", "function_name": "fuzzy_match", "content": "/*\n * Returns score if each character in pattern is found sequentially within str.\n * Returns INT32_MIN otherwise.\n */\nint32_t fuzzy_match(const char *restrict pattern, const char *restrict str)\n{\n\tconst int unmatched_letter_penalty = -1;\n\tconst size_t slen = libmin_strlen(str);\n\tconst size_t plen = libmin_strlen(pattern);\n\tint32_t score = 100;\n\n\tif (*pattern == '\\0') {\n\t\treturn score;\n\t}\n\tif (slen < plen) {\n\t\treturn INT32_MIN;\n\t}\n\n\t/* We can already penalise any unused letters. */\n\tscore += unmatched_letter_penalty * (int32_t)(slen - plen);\n\n\t/* Perform the match. */\n\tscore = fuzzy_match_recurse(pattern, str, score, TRUE);\n\n\treturn score;\n}\n"}, "pseudo": {"path": "fuzzy-match/fuzzy-match.host.O2.pseudo", "function_name": "fuzzy_match", "address": "0x24f0", "label": "fuzzy_match", "content": "int32_t __fastcall fuzzy_match(const char *pattern, const char *str)\n{\n  size_t v2; // rbx\n  size_t v3; // rax\n\n  v2 = libmin_strlen(str);\n  v3 = libmin_strlen(pattern);\n  if ( !*pattern )\n    return 100;\n  if ( v2 < v3 )\n    return 0x80000000;\n  return fuzzy_match_recurse(pattern, str, v3 - v2 + 100, 1);\n}\n"}, "pseudo_normalize": "int32_t fuzzy_match(const char *pattern, const char *str) {\n  unsigned int v2;\n  unsigned int v3;\n  v2 = libmin_strlen(str);\n  v3 = libmin_strlen(pattern);\n  if (!*pattern) return 100;\n  if (v2 < v3) return 2147483648;\n  return fuzzy_match_recurse(pattern, str, v3 - v2 + 100, 1);\n}", "binary": "fuzzy-match/fuzzy-match.host.O2", "assembly": "<fuzzy_match>:\nendbr64\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\nmov    %rsi,%rdi\npush   %rbx\ncall   3cd0 <libmin_strlen>\nmov    %rbp,%rdi\nmov    %rax,%rbx\ncall   3cd0 <libmin_strlen>\ncmpb   $0x0,0x0(%rbp)\nje     2538 <fuzzy_match+0x48>\ncmp    %rax,%rbx\njb     2548 <fuzzy_match+0x58>\nsub    %ebx,%eax\nmov    %r12,%rsi\npop    %rbx\nmov    %rbp,%rdi\nlea    0x64(%rax),%edx\npop    %rbp\nmov    $0x1,%ecx\npop    %r12\njmp    2360 <fuzzy_match_recurse>\nnopl   (%rax)\nmov    $0x64,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x80000000,%eax\njmp    253d <fuzzy_match+0x4d>\nnop\n"}
{"source": {"path": "fuzzy-match/fuzzy-match.c", "function_name": "fuzzy_match_recurse", "content": "/*\n * Recursively match the whole of pattern against str.\n * The score parameter is the score of the previously matched character.\n *\n * This reaches a maximum recursion depth of strlen(pattern) + 1. However, the\n * stack usage is small (the maximum I've seen on x86_64 is 144 bytes with\n * gcc -O3), so this shouldn't matter unless pattern contains thousands of\n * characters.\n */\nint32_t fuzzy_match_recurse(\n\t\tconst char *restrict pattern,\n\t\tconst char *restrict str,\n\t\tint32_t score,\n\t\tint first_char)\n{\n\tif (*pattern == '\\0') {\n\t\t/* We've matched the full pattern. */\n\t\treturn score;\n\t}\n\n\tconst char *match = str;\n\tconst char search[2] = { *pattern, '\\0' };\n\n\tint32_t best_score = INT32_MIN;\n\n\t/*\n\t * Find all occurrences of the next pattern character in str, and\n\t * recurse on them.\n\t */\n\twhile ((match = libmin_strcasestr(match, search)) != NULL) {\n\t\tint32_t subscore = fuzzy_match_recurse(\n\t\t\t\tpattern + 1,\n\t\t\t\tmatch + 1,\n\t\t\t\tcompute_score(match - str, first_char, match),\n\t\t\t\tFALSE);\n\t\tbest_score = MAX(best_score, subscore);\n\t\tmatch++;\n\t}\n\n\tif (best_score == INT32_MIN) {\n\t\t/* We couldn't match the rest of the pattern. */\n\t\treturn INT32_MIN;\n\t} else {\n\t\treturn score + best_score;\n\t}\n}\n"}, "pseudo": {"path": "fuzzy-match/fuzzy-match.host.O2.pseudo", "function_name": "fuzzy_match_recurse", "address": "0x2360", "label": "fuzzy_match_recurse", "content": "int32_t __fastcall fuzzy_match_recurse(const char *pattern, const char *str, int32_t score, int first_char)\n{\n  int32_t v4; // r12d\n  char v5; // al\n  int v7; // ebp\n  int v8; // edi\n  char v9; // r15\n  char *i; // rax\n  char v12; // si\n  int32_t v13; // edx\n  int v14; // ecx\n  int32_t matched; // eax\n  unsigned __int16 v17; // r8\n  const char *match; // [rsp+0h] [rbp-58h]\n  char search[2]; // [rsp+16h] [rbp-42h] BYREF\n  unsigned __int64 v21; // [rsp+18h] [rbp-40h]\n\n  v4 = score;\n  v21 = __readfsqword(0x28u);\n  v5 = *pattern;\n  if ( *pattern )\n  {\n    v7 = (int)str;\n    v8 = (int)str;\n    search[0] = v5;\n    v9 = first_char ^ 1;\n    search[1] = 0;\n    v4 = 0x80000000;\n    for ( i = libmin_strcasestr(str, search); i; i = libmin_strcasestr(match, search) )\n    {\n      v12 = ((int)i - v7 > 0) | v9 & 1;\n      if ( ((_DWORD)i - v7) | first_char )\n      {\n        if ( !v12 )\n        {\n          LOBYTE(v8) = (_DWORD)i == v7;\n          v13 = ((first_char & v8) << 31 >> 31) & 0xF;\nLABEL_6:\n          v14 = -5 * ((_DWORD)i - v7);\n          if ( v14 < -15 )\n            v14 = -15;\n          v13 += v14;\n          goto LABEL_9;\n        }\n        v13 = 0;\n      }\n      else\n      {\n        v13 = 15;\n        if ( !v12 )\n          goto LABEL_6;\n      }\n      v17 = pctype[(unsigned __int8)*i];\n      if ( (v17 & 1) != 0 && (pctype[(unsigned __int8)*(i - 1)] & 2) != 0 )\n        v13 += 30;\n      if ( (v17 & 7) != 0 && (pctype[(unsigned __int8)*(i - 1)] & 7) == 0 )\n        v13 += 30;\n      if ( (first_char & 1) != 0 && (_DWORD)i == v7 )\n      {\n        v13 += 15;\n        goto LABEL_6;\n      }\n      if ( first_char )\n        goto LABEL_6;\nLABEL_9:\n      match = i + 1;\n      matched = fuzzy_match_recurse(pattern + 1, i + 1, v13, 0);\n      v8 = (int)match;\n      if ( v4 < matched )\n        v4 = matched;\n    }\n    if ( v4 != 0x80000000 )\n      v4 += score;\n  }\n  return v4;\n}\n"}, "pseudo_normalize": "int32_t fuzzy_match_recurse(const char *pattern, const char *str, int32_t score,\n                            int first_char) {\n  int32_t v4;\n  char v5;\n  int v7;\n  int v8;\n  char v9;\n  char *i;\n  char v12;\n  int32_t v13;\n  int v14;\n  int32_t matched;\n  unsigned short v17;\n  const char *match;\n  char search[2];\n  unsigned long long v21;\n  v4 = score;\n  v21 = __readfsqword(40u);\n  v5 = *pattern;\n  if (*pattern) {\n    v7 = (int)str;\n    v8 = (int)str;\n    search[0] = v5;\n    v9 = first_char ^ 1;\n    search[1] = 0;\n    v4 = 2147483648;\n    for (i = libmin_strcasestr(str, search); i;\n         i = libmin_strcasestr(match, search)) {\n      v12 = ((int)i - v7 > 0) | v9 & 1;\n      if (((uint32_t)i - v7) | first_char) {\n        if (!v12) {\n          LOBYTE(v8) = (uint32_t)i == v7;\n          v13 = ((first_char & v8) << 31 >> 31) & 15;\n        LABEL_6:\n          v14 = -5 * ((uint32_t)i - v7);\n          if (v14 < -15) v14 = -15;\n          v13 += v14;\n          goto LABEL_9;\n        }\n        v13 = 0;\n      } else {\n        v13 = 15;\n        if (!v12) goto LABEL_6;\n      }\n      v17 = pctype[(unsigned char)*i];\n      if ((v17 & 1) != 0 && (pctype[(unsigned char)*(i - 1)] & 2) != 0)\n        v13 += 30;\n      if ((v17 & 7) != 0 && (pctype[(unsigned char)*(i - 1)] & 7) == 0)\n        v13 += 30;\n      if ((first_char & 1) != 0 && (uint32_t)i == v7) {\n        v13 += 15;\n        goto LABEL_6;\n      }\n      if (first_char) goto LABEL_6;\n    LABEL_9:\n      match = i + 1;\n      matched = fuzzy_match_recurse(pattern + 1, i + 1, v13, 0);\n      v8 = (int)match;\n      if (v4 < matched) v4 = matched;\n    }\n    if (v4 != 2147483648) v4 += score;\n  }\n  return v4;\n}", "binary": "fuzzy-match/fuzzy-match.host.O2", "assembly": "<fuzzy_match_recurse>:\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %edx,%r12d\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %edx,0xc(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmovzbl (%rdi),%eax\ntest   %al,%al\nje     244f <fuzzy_match_recurse+0xef>\nmov    %rsi,%r8\nlea    0x16(%rsp),%r14\nmov    %rdi,%r13\nmov    %rsi,%rbp\nmov    %ecx,%r15d\nmov    %r14,%rsi\nmov    %r8,%rdi\nmov    %al,0x16(%rsp)\nxor    $0x1,%r15d\nmovb   $0x0,0x17(%rsp)\nmov    %ecx,%ebx\nmov    $0x80000000,%r12d\ncall   3d00 <libmin_strcasestr>\ntest   %rax,%rax\nje     2441 <fuzzy_match_recurse+0xe1>\nmov    %rax,%rcx\nmov    %r15d,%esi\nsub    %rbp,%rcx\ncmp    %ebp,%eax\nsete   %dil\nand    $0x1,%esi\ntest   %ecx,%ecx\nsetg   %dl\nor     %edx,%esi\nmov    %ebx,%edx\nor     %ecx,%edx\nje     2478 <fuzzy_match_recurse+0x118>\nmov    %edi,%edx\nand    %ebx,%edx\ntest   %sil,%sil\njne    24e2 <fuzzy_match_recurse+0x182>\nshl    $0x1f,%edx\nsar    $0x1f,%edx\nand    $0xf,%edx\nlea    (%rcx,%rcx,4),%ecx\nmov    $0xfffffff1,%esi\nneg    %ecx\ncmp    %esi,%ecx\ncmovl  %esi,%ecx\nadd    %ecx,%edx\nlea    0x1(%rax),%r8\nlea    0x1(%r13),%rdi\nxor    %ecx,%ecx\nmov    %r8,%rsi\nmov    %r8,(%rsp)\ncall   2360 <fuzzy_match_recurse>\nmov    (%rsp),%r8\nmov    %r14,%rsi\ncmp    %eax,%r12d\nmov    %r8,%rdi\ncmovl  %eax,%r12d\ncall   3d00 <libmin_strcasestr>\ntest   %rax,%rax\njne    23c6 <fuzzy_match_recurse+0x66>\ncmp    $0x80000000,%r12d\nje     244f <fuzzy_match_recurse+0xef>\nadd    0xc(%rsp),%r12d\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    24dd <fuzzy_match_recurse+0x17d>\nadd    $0x28,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nmov    $0xf,%edx\ntest   %sil,%sil\nje     23ff <fuzzy_match_recurse+0x9f>\nmov    0x527b(%rip),%rsi\nmovzbl (%rax),%r8d\nmovzwl (%rsi,%r8,2),%r8d\ntest   $0x1,%r8b\nje     24ae <fuzzy_match_recurse+0x14e>\nmovzbl -0x1(%rax),%r10d\nlea    0x1e(%rdx),%r9d\ntestb  $0x2,(%rsi,%r10,2)\ncmovne %r9d,%edx\nand    $0x7,%r8d\nje     24c6 <fuzzy_match_recurse+0x166>\nmovzbl -0x1(%rax),%r9d\nlea    0x1e(%rdx),%r8d\ntestb  $0x7,(%rsi,%r9,2)\ncmove  %r8d,%edx\ntest   $0x1,%bl\nje     24d0 <fuzzy_match_recurse+0x170>\ntest   %dil,%dil\njne    24e6 <fuzzy_match_recurse+0x186>\ntest   %ebx,%ebx\nje     2410 <fuzzy_match_recurse+0xb0>\njmp    23ff <fuzzy_match_recurse+0x9f>\ncall   20b0 <__stack_chk_fail@plt>\nxor    %edx,%edx\njmp    2486 <fuzzy_match_recurse+0x126>\nadd    $0xf,%edx\njmp    23ff <fuzzy_match_recurse+0x9f>\nxchg   %ax,%ax\n"}
{"source": {"path": "fuzzy-match/fuzzy-match.c", "function_name": "main", "content": "int\nmain(void)\n{\n  {\n\t  const char *pattern = \"core\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  {\n\t  const char *pattern = \"work\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  {\n\t  const char *pattern = \"sam\";\n    libmin_printf(\"Matches for `%s':\\n\", pattern);\n    for (int i=0; entries[i] != NULL; i++)\n    {\n\t\t  int32_t score = fuzzy_match(pattern, entries[i]);\n\t\t  if (score != INT32_MIN) {\n\t\t\t  libmin_printf(\"  %3d|%s\\n\", score, entries[i]);\n\t\t  }\n\t  }\n    libmin_printf(\"\\n\");\n  }\n\n  libmin_success();\t\n  return 0;\n}\n"}, "pseudo": {"path": "fuzzy-match/fuzzy-match.host.O2.pseudo", "function_name": "main", "address": "0x2100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  const char *v3; // rsi\n  const char **v4; // rbx\n  int32_t v5; // esi\n  const char *v6; // rsi\n  const char **v7; // r14\n  int32_t v8; // esi\n  const char *v9; // rsi\n  const char **v10; // rbx\n  int32_t v11; // esi\n\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  v3 = entries[0];\n  if ( entries[0] )\n  {\n    v4 = entries;\n    do\n    {\n      v5 = fuzzy_match(\"core\", v3);\n      if ( v5 != 0x80000000 )\n        libmin_printf(\"  %3d|%s\\n\", v5, *v4);\n      v3 = v4[1];\n      ++v4;\n    }\n    while ( v3 );\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  v6 = entries[0];\n  if ( entries[0] )\n  {\n    v7 = entries;\n    do\n    {\n      v8 = fuzzy_match(\"work\", v6);\n      if ( v8 != 0x80000000 )\n        libmin_printf(\"  %3d|%s\\n\", v8, *v7);\n      v6 = v7[1];\n      ++v7;\n    }\n    while ( v6 );\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  v9 = entries[0];\n  if ( entries[0] )\n  {\n    v10 = entries;\n    do\n    {\n      v11 = fuzzy_match(\"sam\", v9);\n      if ( v11 != 0x80000000 )\n        libmin_printf(\"  %3d|%s\\n\", v11, *v10);\n      v9 = v10[1];\n      ++v10;\n    }\n    while ( v9 );\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  const char *v3;\n  const char **v4;\n  int32_t v5;\n  const char *v6;\n  const char **v7;\n  int32_t v8;\n  const char *v9;\n  const char **v10;\n  int32_t v11;\n  libmin_printf(\"Matches for `%s':\\n\", \"core\");\n  v3 = entries[0];\n  if (entries[0]) {\n    v4 = entries;\n    do {\n      v5 = fuzzy_match(\"core\", v3);\n      if (v5 != 2147483648) libmin_printf(\"  %3d|%s\\n\", v5, *v4);\n      v3 = v4[1];\n      ++v4;\n    } while (v3);\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"work\");\n  v6 = entries[0];\n  if (entries[0]) {\n    v7 = entries;\n    do {\n      v8 = fuzzy_match(\"work\", v6);\n      if (v8 != 2147483648) libmin_printf(\"  %3d|%s\\n\", v8, *v7);\n      v6 = v7[1];\n      ++v7;\n    } while (v6);\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Matches for `%s':\\n\", \"sam\");\n  v9 = entries[0];\n  if (entries[0]) {\n    v10 = entries;\n    do {\n      v11 = fuzzy_match(\"sam\", v9);\n      if (v11 != 2147483648) libmin_printf(\"  %3d|%s\\n\", v11, *v10);\n      v9 = v10[1];\n      ++v10;\n    } while (v9);\n  }\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}", "binary": "fuzzy-match/fuzzy-match.host.O2", "assembly": "<main>:\nendbr64\npush   %r14\nxor    %eax,%eax\npush   %r13\npush   %r12\nlea    0x1ef6(%rip),%r12\npush   %rbp\nlea    0x1ee9(%rip),%rbp\nmov    %r12,%rdi\npush   %rbx\nmov    %rbp,%rsi\ncall   3ac0 <libmin_printf>\nmov    0x4ef2(%rip),%rsi\ntest   %rsi,%rsi\nje     2173 <main+0x73>\nlea    0x4ee6(%rip),%rbx\nlea    0x1edb(%rip),%r13\nnopl   0x0(%rax)\nmov    %rbp,%rdi\ncall   24f0 <fuzzy_match>\nmov    %eax,%esi\ncmp    $0x80000000,%eax\nje     2166 <main+0x66>\nmov    (%rbx),%rdx\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x8(%rbx),%rsi\nadd    $0x8,%rbx\ntest   %rsi,%rsi\njne    2148 <main+0x48>\nlea    0x1ea0(%rip),%rbp\nxor    %eax,%eax\nlea    0x1ea3(%rip),%rbx\nmov    %rbp,%rdi\ncall   3ac0 <libmin_printf>\nmov    %rbx,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x4e81(%rip),%rsi\ntest   %rsi,%rsi\nje     21e3 <main+0xe3>\nlea    0x4e75(%rip),%r14\nlea    0x1e6a(%rip),%r13\nnopw   0x0(%rax,%rax,1)\nmov    %rbx,%rdi\ncall   24f0 <fuzzy_match>\nmov    %eax,%esi\ncmp    $0x80000000,%eax\nje     21d6 <main+0xd6>\nmov    (%r14),%rdx\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x8(%r14),%rsi\nadd    $0x8,%r14\ntest   %rsi,%rsi\njne    21b8 <main+0xb8>\nmov    %rbp,%rdi\nxor    %eax,%eax\nlea    0x1e3c(%rip),%r13\ncall   3ac0 <libmin_printf>\nmov    %r13,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x4e18(%rip),%rsi\ntest   %rsi,%rsi\nje     224b <main+0x14b>\nlea    0x4e0c(%rip),%rbx\nlea    0x1e01(%rip),%r12\nnopl   0x0(%rax,%rax,1)\nmov    %r13,%rdi\ncall   24f0 <fuzzy_match>\nmov    %eax,%esi\ncmp    $0x80000000,%eax\nje     223e <main+0x13e>\nmov    (%rbx),%rdx\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\nmov    0x8(%rbx),%rsi\nadd    $0x8,%rbx\ntest   %rsi,%rsi\njne    2220 <main+0x120>\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   3ac0 <libmin_printf>\ncall   3d50 <libmin_success>\npop    %rbx\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "fy-shuffle/fy-shuffle.c", "function_name": "fy_shuffle", "content": "void\nfy_shuffle(int *array, int n)\n{\n  int i, j, tmp;\n\n  for (i = n - 1; i > 0; i--)\n  {\n    j = rand_int(i + 1);\n    libmin_assert(i >= 0 && i < n && j >= 0 && j < n);\n    tmp = array[j];\n    array[j] = array[i];\n    array[i] = tmp;\n  }\n}\n"}, "pseudo": {"path": "fy-shuffle/fy-shuffle.host.O2.pseudo", "function_name": "fy_shuffle", "address": "0x1440", "label": "fy_shuffle", "content": "void __fastcall fy_shuffle(int *array, int n)\n{\n  __int64 v2; // rbp\n  int v3; // r12d\n  signed int v4; // eax\n  int v5; // ebx\n  int *v6; // rax\n  int v7; // edx\n\n  LODWORD(v2) = n - 1;\n  if ( n - 1 > 0 )\n  {\n    v2 = (int)v2;\n    do\n    {\n      v3 = v2 + 1;\n      do\n        v4 = libmin_rand();\n      while ( 0x7FFFFFFF - 0x7FFFFFFF % ((int)v2 + 1) <= v4 );\n      v5 = v4 % v3;\n      if ( n <= (int)v2 || v5 < 0 || n <= v5 )\n        libmin_fail(1);\n      v6 = &array[v4 % v3];\n      v7 = *v6;\n      *v6 = array[v2];\n      array[v2--] = v7;\n    }\n    while ( (int)v2 > 0 );\n  }\n}\n"}, "pseudo_normalize": "void fy_shuffle(int *array, int n) {\n  long long v2;\n  int v3;\n  signed int v4;\n  int v5;\n  int *v6;\n  int v7;\n  LODWORD(v2) = n - 1;\n  if (n - 1 > 0) {\n    v2 = (int)v2;\n    do {\n      v3 = v2 + 1;\n      do v4 = libmin_rand();\n      while (2147483647 - 2147483647 % ((int)v2 + 1) <= v4);\n      v5 = v4 % v3;\n      if (n <= (int)v2 || v5 < 0 || n <= v5) libmin_fail(1);\n      v6 = &array[v4 % v3];\n      v7 = *v6;\n      *v6 = array[v2];\n      array[v2--] = v7;\n    } while ((int)v2 > 0);\n  }\n}", "binary": "fy-shuffle/fy-shuffle.host.O2", "assembly": "<fy_shuffle>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\nlea    -0x1(%rsi),%ebp\npush   %rbx\nsub    $0x8,%rsp\ntest   %ebp,%ebp\njle    14b9 <fy_shuffle+0x79>\nmov    %rdi,%r13\nmov    %esi,%r15d\nmovslq %ebp,%rbp\nmov    $0x7fffffff,%r14d\nnopl   0x0(%rax,%rax,1)\nmov    %r14d,%eax\nlea    0x1(%rbp),%r12d\nmov    %r14d,%ebx\ncltd\nidiv   %r12d\nsub    %edx,%ebx\ncall   2d10 <libmin_rand>\ncmp    %eax,%ebx\njle    1480 <fy_shuffle+0x40>\ncltd\nidiv   %r12d\nmovslq %edx,%rbx\ncmp    %ebp,%r15d\njle    14d0 <fy_shuffle+0x90>\ntest   %ebx,%ebx\njs     14d0 <fy_shuffle+0x90>\ncmp    %ebx,%r15d\njle    14d0 <fy_shuffle+0x90>\nlea    0x0(%r13,%rbx,4),%rax\nmov    0x0(%r13,%rbp,4),%ecx\nmov    (%rax),%edx\nmov    %ecx,(%rax)\nmov    %edx,0x0(%r13,%rbp,4)\nsub    $0x1,%rbp\ntest   %ebp,%ebp\njg     1470 <fy_shuffle+0x30>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%edi\ncall   1720 <libmin_fail>\njmp    149e <fy_shuffle+0x5e>\nnopl   0x0(%rax)\n"}
{"source": {"path": "fy-shuffle/fy-shuffle.c", "function_name": "main", "content": "int\nmain(void)\n{\n  /* initialize random seed: */\n  libmin_srand(42);\n\n  for (int k = 0; k < 8; k++)\n  {\n    print(\"A (before): \", a, SZ_A);\n    fy_shuffle(a, SZ_A);\n    print(\"A (after):  \", a, SZ_A);\n\n    print(\"B (before): \", b, SZ_B);\n    fy_shuffle(b, SZ_B);\n    print(\"B (after):  \", b, SZ_B);\n  }\n  \n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "fy-shuffle/fy-shuffle.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // r12\n  int *v4; // rbx\n  int v5; // esi\n  int v6; // ebp\n  int *v7; // r14\n  signed int v8; // eax\n  int v9; // edx\n  int v10; // ecx\n  int *v11; // rax\n  int v12; // edx\n  int v13; // esi\n  int *v14; // r12\n  int *v15; // rbx\n  int v16; // esi\n  int v17; // ebp\n  int *v18; // r14\n  signed int v19; // eax\n  int v20; // edx\n  int v21; // ecx\n  int *v22; // rax\n  int v23; // edx\n  int v24; // esi\n  int v25; // [rsp+Ch] [rbp-3Ch]\n\n  libmin_srand(0x2Au);\n  v25 = 8;\n  while ( 1 )\n  {\n    libmin_printf(\"%s\", \"A (before): \");\n    v3 = a;\n    v4 = a;\n    do\n    {\n      v5 = *v4++;\n      libmin_printf(\"%2d \", v5);\n    }\n    while ( v4 != &mti );\n    v6 = 11;\n    libmin_printf(\"\\n\");\n    v7 = &a[10];\n    do\n    {\n      do\n        v8 = libmin_rand();\n      while ( 0x7FFFFFFF - 0x7FFFFFFF % v6 <= v8 );\n      v9 = v8 % v6;\n      if ( v8 % v6 < 0 )\n        libmin_fail(1);\n      v10 = *v7--;\n      --v6;\n      v11 = &a[v9];\n      v12 = *v11;\n      *v11 = v10;\n      v7[1] = v12;\n    }\n    while ( v7 != a );\n    libmin_printf(\"%s\", \"A (after):  \");\n    do\n    {\n      v13 = *v3++;\n      libmin_printf(\"%2d \", v13);\n    }\n    while ( v3 != &mti );\n    v14 = b;\n    libmin_printf(\"\\n\");\n    v15 = b;\n    libmin_printf(\"%s\", \"B (before): \");\n    do\n    {\n      v16 = *v15++;\n      libmin_printf(\"%2d \", v16);\n    }\n    while ( &unk_506C != (_UNKNOWN *)v15 );\n    v17 = 19;\n    libmin_printf(\"\\n\");\n    v18 = &b[18];\n    do\n    {\n      do\n        v19 = libmin_rand();\n      while ( 0x7FFFFFFF - 0x7FFFFFFF % v17 <= v19 );\n      v20 = v19 % v17;\n      if ( v19 % v17 < 0 )\n        libmin_fail(1);\n      v21 = *v18--;\n      --v17;\n      v22 = &b[v20];\n      v23 = *v22;\n      *v22 = v21;\n      v18[1] = v23;\n    }\n    while ( v18 != b );\n    libmin_printf(\"%s\", \"B (after):  \");\n    do\n    {\n      v24 = *v14++;\n      libmin_printf(\"%2d \", v24);\n    }\n    while ( v14 != (int *)&unk_506C );\n    libmin_printf(\"\\n\");\n    if ( !--v25 )\n      libmin_success();\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  int *v4;\n  int v5;\n  int v6;\n  int *v7;\n  signed int v8;\n  int v9;\n  int v10;\n  int *v11;\n  int v12;\n  int v13;\n  int *v14;\n  int *v15;\n  int v16;\n  int v17;\n  int *v18;\n  signed int v19;\n  int v20;\n  int v21;\n  int *v22;\n  int v23;\n  int v24;\n  int v25;\n  libmin_srand(42u);\n  v25 = 8;\n  while (1) {\n    libmin_printf(\"%s\", \"A (before): \");\n    v3 = a;\n    v4 = a;\n    do {\n      v5 = *v4++;\n      libmin_printf(\"%2d \", v5);\n    } while (v4 != &mti);\n    v6 = 11;\n    libmin_printf(\"\\n\");\n    v7 = &a[10];\n    do {\n      do v8 = libmin_rand();\n      while (2147483647 - 2147483647 % v6 <= v8);\n      v9 = v8 % v6;\n      if (v8 % v6 < 0) libmin_fail(1);\n      v10 = *v7--;\n      --v6;\n      v11 = &a[v9];\n      v12 = *v11;\n      *v11 = v10;\n      v7[1] = v12;\n    } while (v7 != a);\n    libmin_printf(\"%s\", \"A (after):  \");\n    do {\n      v13 = *v3++;\n      libmin_printf(\"%2d \", v13);\n    } while (v3 != &mti);\n    v14 = b;\n    libmin_printf(\"\\n\");\n    v15 = b;\n    libmin_printf(\"%s\", \"B (before): \");\n    do {\n      v16 = *v15++;\n      libmin_printf(\"%2d \", v16);\n    } while (&unk_506C != (void *)v15);\n    v17 = 19;\n    libmin_printf(\"\\n\");\n    v18 = &b[18];\n    do {\n      do v19 = libmin_rand();\n      while (2147483647 - 2147483647 % v17 <= v19);\n      v20 = v19 % v17;\n      if (v19 % v17 < 0) libmin_fail(1);\n      v21 = *v18--;\n      --v17;\n      v22 = &b[v20];\n      v23 = *v22;\n      *v22 = v21;\n      v18[1] = v23;\n    } while (v18 != b);\n    libmin_printf(\"%s\", \"B (after):  \");\n    do {\n      v24 = *v14++;\n      libmin_printf(\"%2d \", v24);\n    } while (v14 != (int *)&unk_506C);\n    libmin_printf(\"\\n\");\n    if (!--v25) libmin_success();\n  }\n}", "binary": "fy-shuffle/fy-shuffle.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x2a,%edi\nmov    $0x7fffffff,%r15d\npush   %r14\npush   %r13\nlea    0x1eeb(%rip),%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   2cb0 <libmin_srand>\nmovl   $0x8,0xc(%rsp)\nnopl   0x0(%rax)\nlea    0x1ecf(%rip),%rsi\nlea    0x1ebe(%rip),%rdi\nxor    %eax,%eax\ncall   2aa0 <libmin_printf>\nlea    0x3f2c(%rip),%r12\nmov    %r12,%rbx\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   2aa0 <libmin_printf>\nlea    0x3f35(%rip),%rax\ncmp    %rax,%rbx\njne    1160 <main+0x60>\nlea    0x1e89(%rip),%rdi\nxor    %eax,%eax\nmov    $0xb,%ebp\ncall   2aa0 <libmin_printf>\nlea    0x3f12(%rip),%r14\ncs nopw 0x0(%rax,%rax,1)\nmov    %r15d,%eax\nmov    %r15d,%ebx\ncltd\nidiv   %ebp\nsub    %edx,%ebx\nnopl   0x0(%rax,%rax,1)\ncall   2d10 <libmin_rand>\ncmp    %eax,%ebx\njle    11b0 <main+0xb0>\ncltd\nidiv   %ebp\nmovslq %edx,%rbx\ntest   %ebx,%ebx\njns    11cd <main+0xcd>\nmov    $0x1,%edi\ncall   1720 <libmin_fail>\nlea    0x3eac(%rip),%rax\nmov    (%r14),%ecx\nsub    $0x4,%r14\nsub    $0x1,%ebp\nlea    (%rax,%rbx,4),%rax\nmov    (%rax),%edx\nmov    %ecx,(%rax)\nmov    %edx,0x4(%r14)\ncmp    %r12,%r14\njne    11a0 <main+0xa0>\nlea    0x1e25(%rip),%rsi\nlea    0x1e07(%rip),%rdi\nxor    %eax,%eax\ncall   2aa0 <libmin_printf>\nnopl   0x0(%rax)\nmov    (%r12),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%r12\ncall   2aa0 <libmin_printf>\nlea    0x3e8b(%rip),%rax\ncmp    %rax,%r12\njne    1208 <main+0x108>\nlea    0x1ddf(%rip),%rdi\nxor    %eax,%eax\nlea    0x3dea(%rip),%r12\ncall   2aa0 <libmin_printf>\nlea    0x1de6(%rip),%rsi\nxor    %eax,%eax\nmov    %r12,%rbx\nlea    0x1db6(%rip),%rdi\ncall   2aa0 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\nmov    (%rbx),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   2aa0 <libmin_printf>\nlea    0x3dfd(%rip),%rax\ncmp    %rbx,%rax\njne    1258 <main+0x158>\nlea    0x1d91(%rip),%rdi\nxor    %eax,%eax\nmov    $0x13,%ebp\ncall   2aa0 <libmin_printf>\nlea    0x3dda(%rip),%r14\nxchg   %ax,%ax\nmov    %r15d,%eax\nmov    %r15d,%ebx\ncltd\nidiv   %ebp\nsub    %edx,%ebx\nnopl   0x0(%rax,%rax,1)\ncall   2d10 <libmin_rand>\ncmp    %eax,%ebx\njle    12a0 <main+0x1a0>\ncltd\nidiv   %ebp\nmovslq %edx,%rbx\ntest   %ebx,%ebx\njns    12bd <main+0x1bd>\nmov    $0x1,%edi\ncall   1720 <libmin_fail>\nlea    0x3d5c(%rip),%rax\nmov    (%r14),%ecx\nsub    $0x4,%r14\nsub    $0x1,%ebp\nlea    (%rax,%rbx,4),%rax\nmov    (%rax),%edx\nmov    %ecx,(%rax)\nmov    %edx,0x4(%r14)\ncmp    %r12,%r14\njne    1290 <main+0x190>\nlea    0x1d4f(%rip),%rsi\nlea    0x1d17(%rip),%rdi\nxor    %eax,%eax\ncall   2aa0 <libmin_printf>\nnopl   0x0(%rax)\nmov    (%r12),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%r12\ncall   2aa0 <libmin_printf>\nlea    0x3d5b(%rip),%rax\ncmp    %rax,%r12\njne    12f8 <main+0x1f8>\nxor    %eax,%eax\nlea    0x1ced(%rip),%rdi\ncall   2aa0 <libmin_printf>\nsubl   $0x1,0xc(%rsp)\njne    1138 <main+0x38>\ncall   2ef0 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "fy-shuffle/fy-shuffle.c", "function_name": "print", "content": "void\nprint(const char *prefix, int *array, int n)\n{\n  libmin_printf(\"%s\", prefix);\n  for (int i = 0; i < n; i++)\n    libmin_printf(\"%2d \", array[i]);\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "fy-shuffle/fy-shuffle.host.O2.pseudo", "function_name": "print", "address": "0x14e0", "label": "print", "content": "void __fastcall print(const char *prefix, int *array, int n)\n{\n  int *v4; // rbx\n  int *v5; // r12\n  int v6; // esi\n\n  v4 = array;\n  libmin_printf(\"%s\", prefix);\n  if ( n > 0 )\n  {\n    v5 = &array[n - 1 + 1];\n    do\n    {\n      v6 = *v4++;\n      libmin_printf(\"%2d \", v6);\n    }\n    while ( v4 != v5 );\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void print(const char *prefix, int *array, int n) {\n  int *v4;\n  int *v5;\n  int v6;\n  v4 = array;\n  libmin_printf(\"%s\", prefix);\n  if (n > 0) {\n    v5 = &array[n - 1 + 1];\n    do {\n      v6 = *v4++;\n      libmin_printf(\"%2d \", v6);\n    } while (v4 != v5);\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "fy-shuffle/fy-shuffle.host.O2", "assembly": "<print>:\nendbr64\npush   %r12\nxor    %eax,%eax\npush   %rbp\nmov    %edx,%ebp\npush   %rbx\nmov    %rsi,%rbx\nmov    %rdi,%rsi\nlea    0x1b0b(%rip),%rdi\ncall   2aa0 <libmin_printf>\ntest   %ebp,%ebp\njle    152d <print+0x4d>\nlea    -0x1(%rbp),%eax\nlea    0x1afb(%rip),%rbp\nlea    0x4(%rbx,%rax,4),%r12\nnopl   0x0(%rax)\nmov    (%rbx),%esi\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   2aa0 <libmin_printf>\ncmp    %r12,%rbx\njne    1518 <print+0x38>\npop    %rbx\nlea    0x1ad7(%rip),%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\njmp    2aa0 <libmin_printf>\nnop\n"}
{"source": {"path": "gcd-list/gcd-list.c", "function_name": "gcd", "content": "/**\n * @file\n * @brief This program aims at calculating the GCD of n numbers by division\n * method\n *\n * @see gcd_iterative_euclidean.cpp, gcd_recursive_euclidean.cpp\n */\n#include \"libmin.h\"\n\n/** Compute GCD using division algorithm\n *\n * @param[in] a array of integers to compute GCD for\n * @param[in] n number of integers in array `a`\n */\nuint32_t\ngcd(uint32_t *a, unsigned n)\n{\n  unsigned j = 1;  // to access all elements of the array starting from 1\n  uint32_t gcd = a[0];\n  while (j < n)\n  {\n    if (a[j] % gcd == 0)  // value of gcd is as needed so far\n      j++;              // so we check for next element\n    else\n      gcd = a[j] % gcd;  // calculating GCD by division method\n  }\n  return gcd;\n}\n"}, "pseudo": {"path": "gcd-list/gcd-list.host.O2.pseudo", "function_name": "gcd", "address": "0x1310", "label": "gcd", "content": "uint32_t __fastcall gcd(uint32_t *a, unsigned int n)\n{\n  uint32_t v2; // r8d\n  uint32_t *v3; // rcx\n  unsigned int v4; // edi\n\n  v2 = *a;\n  v3 = a + 1;\n  v4 = 1;\n  while ( v4 < n )\n  {\n    if ( *v3 % v2 )\n    {\n      v2 = *v3 % v2;\n    }\n    else\n    {\n      ++v4;\n      ++v3;\n    }\n  }\n  return v2;\n}\n"}, "pseudo_normalize": "uint32_t gcd(uint32_t *a, unsigned int n) {\n  uint32_t v2;\n  uint32_t *v3;\n  unsigned int v4;\n  v2 = *a;\n  v3 = a + 1;\n  v4 = 1;\n  while (v4 < n) {\n    if (*v3 % v2) {\n      v2 = *v3 % v2;\n    } else {\n      ++v4;\n      ++v3;\n    }\n  }\n  return v2;\n}", "binary": "gcd-list/gcd-list.host.O2", "assembly": "<gcd>:\nendbr64\nmov    (%rdi),%r8d\nlea    0x4(%rdi),%rcx\nmov    $0x1,%edi\njmp    1336 <gcd+0x26>\nnopw   0x0(%rax,%rax,1)\nmov    (%rcx),%eax\nxor    %edx,%edx\ndiv    %r8d\ntest   %edx,%edx\nje     1340 <gcd+0x30>\nmov    %edx,%r8d\ncmp    %esi,%edi\njb     1328 <gcd+0x18>\nmov    %r8d,%eax\nret\nxchg   %ax,%ax\nadd    $0x1,%edi\nadd    $0x4,%rcx\njmp    1336 <gcd+0x26>\nnopl   0x0(%rax)\n"}
{"source": {"path": "gcd-list/gcd-list.c", "function_name": "main", "content": "/** Main function */\nint\nmain(void)\n{\n  // initialize RNG\n  libmin_srand(42);\n\n  unsigned n = 64;\n  uint32_t *a = (uint32_t *)libmin_malloc(sizeof(uint32_t)*n);\n  for (unsigned i = 0; i < n; i++)\n    a[i] = (libmin_rand() % 10000000) * 37;\n\n  libmin_printf(\"INFO: a[%d] = { \", n);\n  for (unsigned i = 0; i < n; i++)\n    libmin_printf(\"%d, \", a[i]);\n  libmin_printf(\" }\\n\");\n\n  uint32_t gcd_of_n;\n  gcd_of_n = gcd(a, n);\n  libmin_printf(\"GCD of list: %u\\n\", gcd_of_n);\n\n  libmin_free(a);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "gcd-list/gcd-list.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // r12\n  int *v4; // rbx\n  int *v5; // rbp\n  int *v6; // r13\n  int v7; // esi\n  unsigned int v8; // esi\n  int *v9; // rcx\n\n  libmin_srand(0x2Au);\n  v3 = (int *)libmin_malloc(0x100uLL);\n  v4 = v3;\n  v5 = v3 + 64;\n  v6 = v3;\n  do\n    *v6++ = 37 * (libmin_rand() % 0x989680);\n  while ( v6 != v5 );\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  do\n  {\n    v7 = *v4++;\n    libmin_printf(\"%d, \", v7);\n  }\n  while ( v4 != v5 );\n  libmin_printf(\" }\\n\");\n  v8 = *v3;\n  v9 = v3 + 1;\n  while ( v9 != v5 )\n  {\n    if ( *v9 % v8 )\n      v8 = *v9 % v8;\n    else\n      ++v9;\n  }\n  libmin_printf(\"GCD of list: %u\\n\", v8);\n  libmin_free(v3);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  int *v4;\n  int *v5;\n  int *v6;\n  int v7;\n  unsigned int v8;\n  int *v9;\n  libmin_srand(42u);\n  v3 = (int *)libmin_malloc(256uLL);\n  v4 = v3;\n  v5 = v3 + 64;\n  v6 = v3;\n  do *v6++ = 37 * (libmin_rand() % 10000000);\n  while (v6 != v5);\n  libmin_printf(\"INFO: a[%d] = { \", 64);\n  do {\n    v7 = *v4++;\n    libmin_printf(\"%d, \", v7);\n  } while (v4 != v5);\n  libmin_printf(\" }\\n\");\n  v8 = *v3;\n  v9 = v3 + 1;\n  while (v9 != v5) {\n    if (*v9 % v8)\n      v8 = *v9 % v8;\n    else\n      ++v9;\n  }\n  libmin_printf(\"GCD of list: %u\\n\", v8);\n  libmin_free(v3);\n  libmin_success();\n}", "binary": "gcd-list/gcd-list.host.O2", "assembly": "<main>:\nendbr64\npush   %r13\nmov    $0x2a,%edi\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   2d70 <libmin_srand>\nmov    $0x100,%edi\ncall   15c0 <libmin_malloc>\nmov    %rax,%r12\nmov    %rax,%rbx\nlea    0x100(%rax),%rbp\nmov    %rax,%r13\nnopw   0x0(%rax,%rax,1)\ncall   2dd0 <libmin_rand>\nadd    $0x4,%r13\nmov    %eax,%edx\nimul   $0x6b5fca6b,%rdx,%rdx\nshr    $0x36,%rdx\nimul   $0x989680,%edx,%edx\nsub    %edx,%eax\nlea    (%rax,%rax,8),%edx\nlea    (%rax,%rdx,4),%eax\nmov    %eax,-0x4(%r13)\ncmp    %rbp,%r13\njne    1158 <main+0x38>\nmov    $0x40,%esi\nlea    0x2e73(%rip),%rdi\nxor    %eax,%eax\ncall   2b60 <libmin_printf>\nlea    0x2e76(%rip),%r13\nnop\nmov    (%rbx),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   2b60 <libmin_printf>\ncmp    %rbp,%rbx\njne    11a0 <main+0x80>\nlea    0x2e5e(%rip),%rdi\nxor    %eax,%eax\ncall   2b60 <libmin_printf>\nmov    (%r12),%esi\nlea    0x4(%r12),%rcx\njmp    11dc <main+0xbc>\nxchg   %ax,%ax\nmov    (%rcx),%eax\nxor    %edx,%edx\ndiv    %esi\ntest   %edx,%edx\nje     1210 <main+0xf0>\nmov    %edx,%esi\ncmp    %rbp,%rcx\njne    11d0 <main+0xb0>\nlea    0x2e36(%rip),%rdi\nxor    %eax,%eax\ncall   2b60 <libmin_printf>\nmov    %r12,%rdi\ncall   1670 <libmin_free>\ncall   2fb0 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nadd    $0x4,%rcx\njmp    11dc <main+0xbc>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "grad-descent/grad-descent.c", "function_name": "derivateWRTBias", "content": "double\nderivateWRTBias(double weight, double bias)\n{\n\tdouble sum = 0;\n\t\n\tfor(int i = 0; i<M; i++){\n\t\tsum = (double)(sum + (Y[i] - (weight * X[i] + bias)));\n\t}\n\t\n\treturn ((double)-2.0 * sum)/M;\n}\n"}, "pseudo": {"path": "grad-descent/grad-descent.host.O2.pseudo", "function_name": "derivateWRTBias", "address": "0x12d0", "label": "derivateWRTBias", "content": "double __fastcall derivateWRTBias(double a1, double weight, double bias)\n{\n  __int64 v3; // rax\n  double v4; // xmm4_8\n  double v5; // xmm3_8\n  double v6; // xmm2_8\n\n  v3 = 0LL;\n  v4 = 0.0;\n  do\n  {\n    v5 = X[v3];\n    v6 = Y[v3++];\n    v4 = v4 + v6 - (v5 * a1 + weight);\n  }\n  while ( v3 != 50 );\n  return v4 * -2.0 / 50.0;\n}\n"}, "pseudo_normalize": "double derivateWRTBias(double a1, double weight, double bias) {\n  long long v3;\n  double v4;\n  double v5;\n  double v6;\n  v3 = 0LL;\n  v4 = 0.0;\n  do {\n    v5 = X[v3];\n    v6 = Y[v3++];\n    v4 = v4 + v6 - (v5 * a1 + weight);\n  } while (v3 != 50);\n  return v4 * -2.0 / 50.0;\n}", "binary": "grad-descent/grad-descent.host.O2", "assembly": "<derivateWRTBias>:\nendbr64\nxor    %eax,%eax\npxor   %xmm4,%xmm4\nlea    0x3edf(%rip),%rcx\nlea    0x3d38(%rip),%rdx\nnopl   0x0(%rax,%rax,1)\nmovsd  (%rdx,%rax,1),%xmm3\nmovsd  (%rcx,%rax,1),%xmm2\nadd    $0x8,%rax\nmulsd  %xmm0,%xmm3\naddsd  %xmm1,%xmm3\nsubsd  %xmm3,%xmm2\naddsd  %xmm2,%xmm4\ncmp    $0x190,%rax\njne    12f0 <derivateWRTBias+0x20>\nmulsd  0x1d12(%rip),%xmm4\ndivsd  0x1d12(%rip),%xmm4\nmovapd %xmm4,%xmm0\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "grad-descent/grad-descent.c", "function_name": "derivateWRTWeight", "content": "double\nderivateWRTWeight(double weight, double bias)\n{\n\tdouble sum = 0;\n\t\n\tfor(int i = 0; i<M; i++){\n\t\tsum = (double)(sum + (X[i]*(Y[i] - (weight * X[i] + bias))));\n\t}\n\t\n\treturn ((double)-2.0 * sum)/M;\n}\n"}, "pseudo": {"path": "grad-descent/grad-descent.host.O2.pseudo", "function_name": "derivateWRTWeight", "address": "0x1270", "label": "derivateWRTWeight", "content": "double __fastcall derivateWRTWeight(double a1, double weight, double bias)\n{\n  __int64 v4; // rax\n  double v5; // xmm0_8\n  double v6; // xmm4_8\n  double v7; // xmm2_8\n\n  v4 = 0LL;\n  v5 = 0.0;\n  do\n  {\n    v6 = X[v4];\n    v7 = Y[v4++];\n    v5 = v5 + (v7 - (v6 * a1 + weight)) * v6;\n  }\n  while ( v4 != 50 );\n  return v5 * -2.0 / 50.0;\n}\n"}, "pseudo_normalize": "double derivateWRTWeight(double a1, double weight, double bias) {\n  long long v4;\n  double v5;\n  double v6;\n  double v7;\n  v4 = 0LL;\n  v5 = 0.0;\n  do {\n    v6 = X[v4];\n    v7 = Y[v4++];\n    v5 = v5 + (v7 - (v6 * a1 + weight)) * v6;\n  } while (v4 != 50);\n  return v5 * -2.0 / 50.0;\n}", "binary": "grad-descent/grad-descent.host.O2", "assembly": "<derivateWRTWeight>:\nendbr64\nmovapd %xmm0,%xmm5\nxor    %eax,%eax\npxor   %xmm0,%xmm0\nlea    0x3d9b(%rip),%rcx\nlea    0x3f34(%rip),%rdx\nnopl   0x0(%rax)\nmovsd  (%rcx,%rax,1),%xmm4\nmovsd  (%rdx,%rax,1),%xmm2\nadd    $0x8,%rax\nmovapd %xmm4,%xmm3\nmulsd  %xmm5,%xmm3\naddsd  %xmm1,%xmm3\nsubsd  %xmm3,%xmm2\nmulsd  %xmm4,%xmm2\naddsd  %xmm2,%xmm0\ncmp    $0x190,%rax\njne    1290 <derivateWRTWeight+0x20>\nmulsd  0x1d6a(%rip),%xmm0\ndivsd  0x1d6a(%rip),%xmm0\nret\nnop\n"}
{"source": {"path": "grad-descent/grad-descent.c", "function_name": "gradientDescent", "content": "void\ngradientDescent(double *pweight, double *pbias)\n{\n\tfor (unsigned i = 0; i<200; i++)\n  {\n\t\t*pweight = (double)(*pweight - (L*derivateWRTWeight(*pweight, *pbias)));\n\t\t*pbias =(double)(*pbias - (L*derivateWRTBias(*pweight, *pbias)));\t\t\n\t}\n}\n"}, "pseudo": {"path": "grad-descent/grad-descent.host.O2.pseudo", "function_name": "gradientDescent", "address": "0x1330", "label": "gradientDescent", "content": "void __fastcall gradientDescent(double *pweight, double *pbias)\n{\n  double v2; // xmm7_8\n  int v5; // esi\n  double v6; // xmm8_8\n  __int64 v7; // rax\n  double v8; // xmm6_8\n  double v9; // xmm2_8\n  double v10; // xmm0_8\n  __int64 v11; // rax\n  double v12; // xmm2_8\n  double v13; // xmm8_8\n  double v14; // xmm7_8\n  double v15; // xmm1_8\n  double v16; // xmm0_8\n\n  v2 = *pbias;\n  v5 = 200;\n  do\n  {\n    v6 = *pweight;\n    v7 = 0LL;\n    v8 = 0.0;\n    do\n    {\n      v9 = X[v7];\n      v10 = Y[v7++];\n      v8 = v8 + (v10 - (v6 * v9 + v2)) * v9;\n    }\n    while ( v7 != 50 );\n    v11 = 0LL;\n    v12 = 0.0;\n    v13 = v6 - v8 * -2.0 / 50.0 * L;\n    *pweight = v13;\n    v14 = *pbias;\n    do\n    {\n      v15 = X[v11];\n      v16 = Y[v11++];\n      v12 = v12 + v16 - (v15 * v13 + v14);\n    }\n    while ( v11 != 50 );\n    v2 = v14 - v12 * -2.0 / 50.0 * L;\n    *pbias = v2;\n    --v5;\n  }\n  while ( v5 );\n}\n"}, "pseudo_normalize": "void gradientDescent(double *pweight, double *pbias) {\n  double v2;\n  int v5;\n  double v6;\n  long long v7;\n  double v8;\n  double v9;\n  double v10;\n  long long v11;\n  double v12;\n  double v13;\n  double v14;\n  double v15;\n  double v16;\n  v2 = *pbias;\n  v5 = 200;\n  do {\n    v6 = *pweight;\n    v7 = 0LL;\n    v8 = 0.0;\n    do {\n      v9 = X[v7];\n      v10 = Y[v7++];\n      v8 = v8 + (v10 - (v6 * v9 + v2)) * v9;\n    } while (v7 != 50);\n    v11 = 0LL;\n    v12 = 0.0;\n    v13 = v6 - v8 * -2.0 / 50.0 * L;\n    *pweight = v13;\n    v14 = *pbias;\n    do {\n      v15 = X[v11];\n      v16 = Y[v11++];\n      v12 = v12 + v16 - (v15 * v13 + v14);\n    } while (v11 != 50);\n    v2 = v14 - v12 * -2.0 / 50.0 * L;\n    *pbias = v2;\n    --v5;\n  } while (v5);\n}", "binary": "grad-descent/grad-descent.host.O2", "assembly": "<gradientDescent>:\nendbr64\nmovsd  0x1cf4(%rip),%xmm4\nmovsd  (%rsi),%xmm7\nmov    %rdi,%r8\npxor   %xmm5,%xmm5\nmovsd  0x1ce9(%rip),%xmm3\nmov    %rsi,%rdi\nlea    0x3cc7(%rip),%rcx\nmov    $0xc8,%esi\nlea    0x3e5b(%rip),%rdx\nnopl   (%rax)\nmovsd  (%r8),%xmm8\nxor    %eax,%eax\nmovapd %xmm5,%xmm6\nnopl   0x0(%rax,%rax,1)\nmovsd  (%rcx,%rax,1),%xmm2\nmovapd %xmm8,%xmm1\nmovsd  (%rdx,%rax,1),%xmm0\nadd    $0x8,%rax\nmulsd  %xmm2,%xmm1\naddsd  %xmm7,%xmm1\nsubsd  %xmm1,%xmm0\nmulsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm6\ncmp    $0x190,%rax\njne    1378 <gradientDescent+0x48>\nmulsd  %xmm4,%xmm6\nxor    %eax,%eax\nmovapd %xmm5,%xmm2\ndivsd  %xmm3,%xmm6\nmulsd  0x3f93(%rip),%xmm6\nsubsd  %xmm6,%xmm8\nmovsd  %xmm8,(%r8)\nmovsd  (%rdi),%xmm7\nnopl   0x0(%rax,%rax,1)\nmovsd  (%rcx,%rax,1),%xmm1\nmovsd  (%rdx,%rax,1),%xmm0\nadd    $0x8,%rax\nmulsd  %xmm8,%xmm1\naddsd  %xmm7,%xmm1\nsubsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm2\ncmp    $0x190,%rax\njne    13d0 <gradientDescent+0xa0>\nmulsd  %xmm4,%xmm2\ndivsd  %xmm3,%xmm2\nmulsd  0x3f49(%rip),%xmm2\nsubsd  %xmm2,%xmm7\nmovsd  %xmm7,(%rdi)\nsub    $0x1,%esi\njne    1368 <gradientDescent+0x38>\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "grad-descent/grad-descent.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tdouble weight = 0;\n\tdouble bias = 0;\n\n\tgradientDescent(&weight, &bias);\n\tlibmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "grad-descent/grad-descent.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double weight; // [rsp+8h] [rbp-20h] BYREF\n  double bias[3]; // [rsp+10h] [rbp-18h] BYREF\n\n  *(_QWORD *)&bias[1] = __readfsqword(0x28u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double weight;\n  double bias[3];\n  *(uint64_t *)&bias[1] = __readfsqword(40u);\n  weight = 0.0;\n  bias[0] = 0.0;\n  gradientDescent(&weight, bias);\n  libmin_printf(\"The function is: %.4lfx + %.4lf\\n\", weight, bias[0]);\n  libmin_success();\n}", "binary": "grad-descent/grad-descent.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nlea    0x10(%rsp),%rsi\nlea    0x8(%rsp),%rdi\nmovq   $0x0,0x8(%rsp)\nmovq   $0x0,0x10(%rsp)\ncall   1330 <gradientDescent>\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x8(%rsp),%xmm0\nlea    0x1ebc(%rip),%rdi\nmov    $0x2,%eax\ncall   2960 <libmin_printf>\ncall   2ba0 <libmin_success>\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1172 <main+0x72>\nxor    %eax,%eax\nadd    $0x28,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "DFS_test", "content": "void DFS_test() {\n   int i, j;\n\n   for(i = 0; i < 5; i++) {   // set adjacency {\n      for(j = 0; j < 5; j++) // matrix to 0\n         adjMatrix[i][j] = 0;\n   }\n\n   addVertex();   // 0\n   addVertex();   // 1\n   addVertex();   // 2\n   addVertex();   // 3\n   addVertex();   // 4\n\n   addEdge_DFS(0, 1);    // S - A\n   addEdge_DFS(0, 2);    // S - B\n   addEdge_DFS(0, 3);    // S - C\n   addEdge_DFS(1, 4);    // A - D\n   addEdge_DFS(2, 4);    // B - D\n   addEdge_DFS(3, 4);    // C - D\n\n   depthFirstSearch();\n\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "DFS_test", "address": "0x1c20", "label": "DFS_test", "content": "void __cdecl DFS_test()\n{\n  int *v0; // rax\n  Vertex *v1; // rax\n  int v2; // ecx\n  Vertex *v3; // rax\n  int v4; // ecx\n  Vertex *v5; // rax\n  int v6; // ecx\n  Vertex *v7; // rax\n  int v8; // ecx\n  Vertex *v9; // rax\n  int v10; // edx\n\n  v0 = adjMatrix[0];\n  do\n  {\n    *v0 = 0;\n    v0 += 5;\n    *(v0 - 4) = 0;\n    *(v0 - 3) = 0;\n    *(v0 - 2) = 0;\n    *(v0 - 1) = 0;\n  }\n  while ( adjMatrix[5] != v0 );\n  v1 = (Vertex *)libmin_malloc(4uLL);\n  v1->visited = 0;\n  v2 = vertexCount + 1;\n  lstVertices[vertexCount] = v1;\n  vertexCount = v2;\n  v3 = (Vertex *)libmin_malloc(4uLL);\n  v3->visited = 0;\n  v4 = vertexCount + 1;\n  lstVertices[vertexCount] = v3;\n  vertexCount = v4;\n  v5 = (Vertex *)libmin_malloc(4uLL);\n  v5->visited = 0;\n  v6 = vertexCount + 1;\n  lstVertices[vertexCount] = v5;\n  vertexCount = v6;\n  v7 = (Vertex *)libmin_malloc(4uLL);\n  v7->visited = 0;\n  v8 = vertexCount + 1;\n  lstVertices[vertexCount] = v7;\n  vertexCount = v8;\n  v9 = (Vertex *)libmin_malloc(4uLL);\n  v9->visited = 0;\n  v10 = vertexCount;\n  adjMatrix[1][0] = 1;\n  lstVertices[vertexCount] = v9;\n  *(_QWORD *)&adjMatrix[0][2] = 0x100000001LL;\n  *(_QWORD *)&adjMatrix[1][4] = 0x100000001LL;\n  *(_QWORD *)&adjMatrix[2][4] = 0x100000001LL;\n  *(_QWORD *)&adjMatrix[4][2] = 0x100000001LL;\n  vertexCount = v10 + 1;\n  adjMatrix[0][1] = 1;\n  adjMatrix[3][4] = 1;\n  adjMatrix[4][1] = 1;\n  depthFirstSearch();\n}\n"}, "pseudo_normalize": "void DFS_test() {\n  int *v0;\n  Vertex *v1;\n  int v2;\n  Vertex *v3;\n  int v4;\n  Vertex *v5;\n  int v6;\n  Vertex *v7;\n  int v8;\n  Vertex *v9;\n  int v10;\n  v0 = adjMatrix[0];\n  do {\n    *v0 = 0;\n    v0 += 5;\n    *(v0 - 4) = 0;\n    *(v0 - 3) = 0;\n    *(v0 - 2) = 0;\n    *(v0 - 1) = 0;\n  } while (adjMatrix[5] != v0);\n  v1 = (Vertex *)libmin_malloc(4uLL);\n  v1->visited = 0;\n  v2 = vertexCount + 1;\n  lstVertices[vertexCount] = v1;\n  vertexCount = v2;\n  v3 = (Vertex *)libmin_malloc(4uLL);\n  v3->visited = 0;\n  v4 = vertexCount + 1;\n  lstVertices[vertexCount] = v3;\n  vertexCount = v4;\n  v5 = (Vertex *)libmin_malloc(4uLL);\n  v5->visited = 0;\n  v6 = vertexCount + 1;\n  lstVertices[vertexCount] = v5;\n  vertexCount = v6;\n  v7 = (Vertex *)libmin_malloc(4uLL);\n  v7->visited = 0;\n  v8 = vertexCount + 1;\n  lstVertices[vertexCount] = v7;\n  vertexCount = v8;\n  v9 = (Vertex *)libmin_malloc(4uLL);\n  v9->visited = 0;\n  v10 = vertexCount;\n  adjMatrix[1][0] = 1;\n  lstVertices[vertexCount] = v9;\n  *(uint64_t *)&adjMatrix[0][2] = 4294967297LL;\n  *(uint64_t *)&adjMatrix[1][4] = 4294967297LL;\n  *(uint64_t *)&adjMatrix[2][4] = 4294967297LL;\n  *(uint64_t *)&adjMatrix[4][2] = 4294967297LL;\n  vertexCount = v10 + 1;\n  adjMatrix[0][1] = 1;\n  adjMatrix[3][4] = 1;\n  adjMatrix[4][1] = 1;\n  depthFirstSearch();\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<DFS_test>:\nendbr64\npush   %rbx\nlea    0x5674(%rip),%rax\nlea    0x64(%rax),%rdx\nmovl   $0x0,(%rax)\nadd    $0x14,%rax\nmovl   $0x0,-0x10(%rax)\nmovl   $0x0,-0xc(%rax)\nmovl   $0x0,-0x8(%rax)\nmovl   $0x0,-0x4(%rax)\ncmp    %rax,%rdx\njne    1c30 <DFS_test+0x10>\nmov    $0x4,%edi\nlea    0x56b9(%rip),%rbx\ncall   2300 <libmin_malloc>\nmov    $0x4,%edi\nmovl   $0x0,(%rax)\nmovslq 0x5602(%rip),%rdx\nlea    0x1(%rdx),%ecx\nmov    %rax,(%rbx,%rdx,8)\nmov    %ecx,0x55f5(%rip)\ncall   2300 <libmin_malloc>\nmov    $0x4,%edi\nmovl   $0x0,(%rax)\nmovslq 0x55de(%rip),%rdx\nlea    0x1(%rdx),%ecx\nmov    %rax,(%rbx,%rdx,8)\nmov    %ecx,0x55d1(%rip)\ncall   2300 <libmin_malloc>\nmov    $0x4,%edi\nmovl   $0x0,(%rax)\nmovslq 0x55ba(%rip),%rdx\nlea    0x1(%rdx),%ecx\nmov    %rax,(%rbx,%rdx,8)\nmov    %ecx,0x55ad(%rip)\ncall   2300 <libmin_malloc>\nmov    $0x4,%edi\nmovl   $0x0,(%rax)\nmovslq 0x5596(%rip),%rdx\nlea    0x1(%rdx),%ecx\nmov    %rax,(%rbx,%rdx,8)\nmov    %ecx,0x5589(%rip)\ncall   2300 <libmin_malloc>\nmovl   $0x0,(%rax)\nmovslq 0x5577(%rip),%rdx\nmovl   $0x1,0x55a1(%rip)\nmov    %rax,(%rbx,%rdx,8)\nlea    0x1(%rdx),%ecx\npop    %rbx\nmovabs $0x100000001,%rax\nmov    %rax,0x557c(%rip)\nmov    %rax,0x5591(%rip)\nmov    %rax,0x559e(%rip)\nmov    %rax,0x55b7(%rip)\nxor    %eax,%eax\nmov    %ecx,0x5537(%rip)\nmovl   $0x1,0x5551(%rip)\nmovl   $0x1,0x558f(%rip)\nmovl   $0x1,0x558d(%rip)\njmp    1b20 <depthFirstSearch>\nnopl   0x0(%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "addEdge", "content": "void addEdge(struct Graph* graph, int src, int dest) {\n    // Add edge from src to dest\n    struct node* newNode = createNode(dest);\n    newNode->next = graph->adjLists[src];\n    graph->adjLists[src] = newNode;\n\n    // Add edge from dest to src\n    newNode = createNode(src);\n    newNode->next = graph->adjLists[dest];\n    graph->adjLists[dest] = newNode;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "addEdge", "address": "0x1320", "label": "addEdge", "content": "void __fastcall addEdge(Graph *graph, int src, int dest)\n{\n  __int64 v3; // rbx\n  node *v4; // rax\n  node **adjLists; // rdx\n  node **v6; // rdx\n  node *v7; // rax\n  node **v8; // rdx\n  node **v9; // rdx\n\n  v3 = dest;\n  v4 = (node *)libmin_malloc(0x10uLL);\n  adjLists = graph->adjLists;\n  v4->next = 0LL;\n  v6 = &adjLists[src];\n  v4->vertex = v3;\n  v4->next = *v6;\n  *v6 = v4;\n  v7 = (node *)libmin_malloc(0x10uLL);\n  v8 = graph->adjLists;\n  v7->next = 0LL;\n  v9 = &v8[v3];\n  v7->vertex = src;\n  v7->next = *v9;\n  *v9 = v7;\n}\n"}, "pseudo_normalize": "void addEdge(Graph *graph, int src, int dest) {\n  long long v3;\n  node *v4;\n  node **adjLists;\n  node **v6;\n  node *v7;\n  node **v8;\n  node **v9;\n  v3 = dest;\n  v4 = (node *)libmin_malloc(16uLL);\n  adjLists = graph->adjLists;\n  v4->next = 0LL;\n  v6 = &adjLists[src];\n  v4->vertex = v3;\n  v4->next = *v6;\n  *v6 = v4;\n  v7 = (node *)libmin_malloc(16uLL);\n  v8 = graph->adjLists;\n  v7->next = 0LL;\n  v9 = &v8[v3];\n  v7->vertex = src;\n  v7->next = *v9;\n  *v9 = v7;\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<addEdge>:\nendbr64\npush   %r12\nmov    %rdi,%r12\nmov    $0x10,%edi\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmovslq %edx,%rbx\ncall   2300 <libmin_malloc>\nmov    0x8(%r12),%rdx\nmovslq %ebp,%rcx\nmov    $0x10,%edi\nmovq   $0x0,0x8(%rax)\nlea    (%rdx,%rcx,8),%rdx\nmov    %ebx,(%rax)\nmov    (%rdx),%rcx\nmov    %rcx,0x8(%rax)\nmov    %rax,(%rdx)\ncall   2300 <libmin_malloc>\nmov    0x8(%r12),%rdx\nmovq   $0x0,0x8(%rax)\nlea    (%rdx,%rbx,8),%rdx\nmov    %ebp,(%rax)\nmov    (%rdx),%rcx\nmov    %rcx,0x8(%rax)\nmov    %rax,(%rdx)\npop    %rbx\npop    %rbp\npop    %r12\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "addEdge_DFS", "content": "void addEdge_DFS(int start,int end) {\n   adjMatrix[start][end] = 1;\n   adjMatrix[end][start] = 1;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "addEdge_DFS", "address": "0x1a90", "label": "addEdge_DFS", "content": "void __fastcall addEdge_DFS(int start, int end)\n{\n  adjMatrix[start][end] = 1;\n  adjMatrix[end][start] = 1;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<addEdge_DFS>:\nendbr64\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nlea    0x57ff(%rip),%rdx\nlea    (%rdi,%rdi,4),%rax\nadd    %rsi,%rax\nmovl   $0x1,(%rdx,%rax,4)\nlea    (%rsi,%rsi,4),%rax\nadd    %rdi,%rax\nmovl   $0x1,(%rdx,%rax,4)\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "addVertex", "content": "void addVertex() {\n   struct Vertex* vertex = (struct Vertex*)libmin_malloc(sizeof(struct Vertex));\n   vertex->visited = FALSE;\n   lstVertices[vertexCount++] = vertex;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "addVertex", "address": "0x1a50", "label": "addVertex", "content": "void __cdecl addVertex()\n{\n  Vertex *v0; // rax\n  __int64 v1; // rdx\n\n  v0 = (Vertex *)libmin_malloc(4uLL);\n  v0->visited = 0;\n  v1 = vertexCount++;\n  lstVertices[v1] = v0;\n}\n"}, "pseudo_normalize": "void addVertex() {\n  Vertex *v0;\n  long long v1;\n  v0 = (Vertex *)libmin_malloc(4uLL);\n  v0->visited = 0;\n  v1 = vertexCount++;\n  lstVertices[v1] = v0;\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<addVertex>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x4,%edi\ncall   2300 <libmin_malloc>\nmovl   $0x0,(%rax)\nmovslq 0x5811(%rip),%rdx\nlea    0x1(%rdx),%ecx\nmov    %ecx,0x5808(%rip)\nlea    0x58a1(%rip),%rcx\nmov    %rax,(%rcx,%rdx,8)\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "bfs", "content": "void bfs(struct Graph* graph, int startVertex) {\n    struct queue* q = createQueue();\n\n    graph->visited[startVertex] = 1;\n    enqueue(q, startVertex);\n\n    while(!isEmpty(q)){\n        printQueue(q);\n        int currentVertex = dequeue(q);\n        libmin_printf(\"Visited %d\\n\", currentVertex);\n       struct node* temp = graph->adjLists[currentVertex];\n\n       while(temp) {\n            int adjVertex = temp->vertex;\n            if(graph->visited[adjVertex] == 0){\n                graph->visited[adjVertex] = 1;\n                enqueue(q, adjVertex);\n            }\n            temp = temp->next;\n       }\n    }\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "bfs", "address": "0x1540", "label": "bfs", "content": "void __fastcall bfs(Graph *graph, int startVertex)\n{\n  queue *v2; // rax\n  queue *v3; // rbp\n  int rear; // eax\n  int front; // edx\n  int v6; // eax\n  int v7; // edx\n  int v8; // eax\n  __int64 v9; // rsi\n  __int64 v10; // rbx\n  node *v11; // rbx\n  __int64 vertex; // rsi\n  int *v13; // rax\n  int v14; // eax\n  int v15; // eax\n\n  v2 = (queue *)libmin_malloc(0xA8uLL);\n  *(_QWORD *)&v2->front = -1LL;\n  v3 = v2;\n  graph->visited[startVertex] = 1;\n  rear = v2->rear;\n  if ( rear == 39 )\n  {\n    libmin_printf(\"Queue is Full!!\\n\");\n    v6 = v3->rear;\n  }\n  else\n  {\n    front = v3->front;\n    if ( front == -1 )\n      front = 0;\n    v6 = rear + 1;\n    v3->rear = v6;\n    v3->front = front;\n    v3->items[v6] = startVertex;\n  }\n  if ( v6 != -1 )\n  {\n    while ( 1 )\n    {\n      printQueue(v3);\n      v7 = v3->rear;\n      if ( v7 == -1 )\n      {\n        v10 = 0x1FFFFFFFFFFFFFFFLL;\n        libmin_printf(\"Queue is empty\\n\");\n        LODWORD(v9) = -1;\n      }\n      else\n      {\n        v8 = v3->front + 1;\n        v9 = v3->items[v3->front];\n        v3->front = v8;\n        v10 = v9;\n        if ( v7 < v8 )\n        {\n          libmin_printf(\"Resetting queue...\\n\");\n          *(_QWORD *)&v3->front = -1LL;\n        }\n      }\n      libmin_printf(\"Visited %d\\n\", v9);\n      v11 = graph->adjLists[v10];\n      if ( v11 )\n        break;\nLABEL_17:\n      if ( v3->rear == -1 )\n        return;\n    }\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        vertex = v11->vertex;\n        v13 = &graph->visited[vertex];\n        if ( !*v13 )\n          break;\nLABEL_11:\n        v11 = v11->next;\n        if ( !v11 )\n          goto LABEL_17;\n      }\n      *v13 = 1;\n      v14 = v3->rear;\n      if ( v14 == 39 )\n      {\n        libmin_printf(\"Queue is Full!!\\n\", vertex, vertex);\n        goto LABEL_11;\n      }\n      if ( v3->front == -1 )\n        v3->front = 0;\n      v15 = v14 + 1;\n      v11 = v11->next;\n      v3->rear = v15;\n      v3->items[v15] = vertex;\n      if ( !v11 )\n        goto LABEL_17;\n    }\n  }\n}\n"}, "pseudo_normalize": "void bfs(Graph *graph, int startVertex) {\n  queue *v2;\n  queue *v3;\n  int rear;\n  int front;\n  int v6;\n  int v7;\n  int v8;\n  long long v9;\n  long long v10;\n  node *v11;\n  long long vertex;\n  int *v13;\n  int v14;\n  int v15;\n  v2 = (queue *)libmin_malloc(168uLL);\n  *(uint64_t *)&v2->front = -1LL;\n  v3 = v2;\n  graph->visited[startVertex] = 1;\n  rear = v2->rear;\n  if (rear == 39) {\n    libmin_printf(\"Queue is Full!!\\n\");\n    v6 = v3->rear;\n  } else {\n    front = v3->front;\n    if (front == -1) front = 0;\n    v6 = rear + 1;\n    v3->rear = v6;\n    v3->front = front;\n    v3->items[v6] = startVertex;\n  }\n  if (v6 != -1) {\n    while (1) {\n      printQueue(v3);\n      v7 = v3->rear;\n      if (v7 == -1) {\n        v10 = 2305843009213693951LL;\n        libmin_printf(\"Queue is empty\\n\");\n        LODWORD(v9) = -1;\n      } else {\n        v8 = v3->front + 1;\n        v9 = v3->items[v3->front];\n        v3->front = v8;\n        v10 = v9;\n        if (v7 < v8) {\n          libmin_printf(\"Resetting queue...\\n\");\n          *(uint64_t *)&v3->front = -1LL;\n        }\n      }\n      libmin_printf(\"Visited %d\\n\", v9);\n      v11 = graph->adjLists[v10];\n      if (v11) break;\n    LABEL_17:\n      if (v3->rear == -1) return;\n    }\n    while (1) {\n      while (1) {\n        vertex = v11->vertex;\n        v13 = &graph->visited[vertex];\n        if (!*v13) break;\n      LABEL_11:\n        v11 = v11->next;\n        if (!v11) goto LABEL_17;\n      }\n      *v13 = 1;\n      v14 = v3->rear;\n      if (v14 == 39) {\n        libmin_printf(\"Queue is Full!!\\n\", vertex, vertex);\n        goto LABEL_11;\n      }\n      if (v3->front == -1) v3->front = 0;\n      v15 = v14 + 1;\n      v11 = v11->next;\n      v3->rear = v15;\n      v3->items[v15] = vertex;\n      if (!v11) goto LABEL_17;\n    }\n  }\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<bfs>:\nendbr64\npush   %r15\nmov    %rdi,%r15\nmov    $0xa8,%edi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %esi,%ebx\nsub    $0x18,%rsp\ncall   2300 <libmin_malloc>\nmovslq %ebx,%rdx\nmovq   $0xffffffffffffffff,0xa0(%rax)\nmov    %rax,%rbp\nmov    0x10(%r15),%rax\nmovl   $0x1,(%rax,%rdx,4)\nmov    0xa4(%rbp),%eax\ncmp    $0x27,%eax\nje     1700 <bfs+0x1c0>\nmov    0xa0(%rbp),%edx\nxor    %esi,%esi\ncmp    $0xffffffff,%edx\ncmove  %esi,%edx\nadd    $0x1,%eax\nmov    %eax,0xa4(%rbp)\nmov    %edx,0xa0(%rbp)\nmovslq %eax,%rdx\nmov    %ebx,0x0(%rbp,%rdx,4)\ncmp    $0xffffffff,%eax\nje     168e <bfs+0x14e>\nlea    0x2a8e(%rip),%r12\nlea    0x2a4e(%rip),%r14\nlea    0x2a36(%rip),%r13\nmov    %rbp,%rdi\ncall   14c0 <printQueue>\nmov    0xa4(%rbp),%edx\ncmp    $0xffffffff,%edx\nje     16b0 <bfs+0x170>\nmovslq 0xa0(%rbp),%rsi\nmovslq 0x0(%rbp,%rsi,4),%rbx\nmov    %rsi,%rax\nadd    $0x1,%eax\nmov    %rbx,%rsi\nmov    %eax,0xa0(%rbp)\nshl    $0x3,%rbx\ncmp    %eax,%edx\njl     16d0 <bfs+0x190>\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nmov    0x8(%r15),%rax\nmov    (%rax,%rbx,1),%rbx\ntest   %rbx,%rbx\njne    1631 <bfs+0xf1>\njmp    1681 <bfs+0x141>\nnopl   (%rax)\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\nje     1681 <bfs+0x141>\nmovslq (%rbx),%rsi\nmov    0x10(%r15),%rax\nlea    (%rax,%rsi,4),%rax\nmov    %rsi,%rdx\nmov    (%rax),%ecx\ntest   %ecx,%ecx\njne    1628 <bfs+0xe8>\nmovl   $0x1,(%rax)\nmov    0xa4(%rbp),%eax\ncmp    $0x27,%eax\nje     16a0 <bfs+0x160>\ncmpl   $0xffffffff,0xa0(%rbp)\njne    1669 <bfs+0x129>\nmovl   $0x0,0xa0(%rbp)\nadd    $0x1,%eax\nmov    0x8(%rbx),%rbx\nmov    %eax,0xa4(%rbp)\ncltq\nmov    %edx,0x0(%rbp,%rax,4)\ntest   %rbx,%rbx\njne    1631 <bfs+0xf1>\ncmpl   $0xffffffff,0xa4(%rbp)\njne    15ce <bfs+0x8e>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\njmp    1628 <bfs+0xe8>\nnop\nmov    %r14,%rdi\nxor    %eax,%eax\nmov    $0xfffffffffffffff8,%rbx\ncall   38a0 <libmin_printf>\nmov    $0xffffffff,%esi\njmp    160c <bfs+0xcc>\nnopl   0x0(%rax,%rax,1)\nlea    0x294e(%rip),%rdi\nxor    %eax,%eax\nmov    %esi,0xc(%rsp)\ncall   38a0 <libmin_printf>\nmov    0xc(%rsp),%esi\nmovq   $0xffffffffffffffff,0xa0(%rbp)\njmp    160c <bfs+0xcc>\ncs nopw 0x0(%rax,%rax,1)\nlea    0x28fd(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nmov    0xa4(%rbp),%eax\njmp    15b0 <bfs+0x70>\nnopl   0x0(%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "bfs_test", "content": "void bfs_test(){\n    struct Graph* graph = createGraph(6);\n    addEdge(graph, 0, 1);\n    addEdge(graph, 0, 2);\n    addEdge(graph, 1, 2);\n    addEdge(graph, 1, 4);\n    addEdge(graph, 1, 3);\n    addEdge(graph, 2, 4);\n    addEdge(graph, 3, 4);\n\n    bfs(graph, 0);\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "bfs_test", "address": "0x1720", "label": "bfs_test", "content": "void __cdecl bfs_test()\n{\n  Graph *v0; // rax\n  Graph *v1; // rbp\n  int *v2; // rax\n  node **adjLists; // rdx\n  __int64 i; // rcx\n\n  v0 = (Graph *)libmin_malloc(0x18uLL);\n  v0->numVertices = 6;\n  v1 = v0;\n  v0->adjLists = (node **)libmin_malloc(0x30uLL);\n  v2 = (int *)libmin_malloc(0x18uLL);\n  adjLists = v1->adjLists;\n  v1->visited = v2;\n  if ( adjLists < (node **)v2 + 3 && v2 < (int *)adjLists + 12 )\n  {\n    for ( i = 0LL; i != 6; ++i )\n    {\n      adjLists[i] = 0LL;\n      v2[i] = 0;\n    }\n  }\n  else\n  {\n    *(_OWORD *)adjLists = 0LL;\n    *((_OWORD *)adjLists + 1) = 0LL;\n    *((_OWORD *)adjLists + 2) = 0LL;\n    *((_QWORD *)v2 + 2) = 0LL;\n    *(_OWORD *)v2 = 0LL;\n  }\n  addEdge(v1, 0, 1);\n  addEdge(v1, 0, 2);\n  addEdge(v1, 1, 2);\n  addEdge(v1, 1, 4);\n  addEdge(v1, 1, 3);\n  addEdge(v1, 2, 4);\n  addEdge(v1, 3, 4);\n  bfs(v1, 0);\n}\n"}, "pseudo_normalize": "void bfs_test() {\n  Graph *v0;\n  Graph *v1;\n  int *v2;\n  node **adjLists;\n  long long i;\n  v0 = (Graph *)libmin_malloc(24uLL);\n  v0->numVertices = 6;\n  v1 = v0;\n  v0->adjLists = (node **)libmin_malloc(48uLL);\n  v2 = (int *)libmin_malloc(24uLL);\n  adjLists = v1->adjLists;\n  v1->visited = v2;\n  if (adjLists < (node **)v2 + 3 && v2 < (int *)adjLists + 12) {\n    for (i = 0LL; i != 6; ++i) {\n      adjLists[i] = 0LL;\n      v2[i] = 0;\n    }\n  } else {\n    *(long double *)adjLists = 0LL;\n    *((long double *)adjLists + 1) = 0LL;\n    *((long double *)adjLists + 2) = 0LL;\n    *((uint64_t *)v2 + 2) = 0LL;\n    *(long double *)v2 = 0LL;\n  }\n  addEdge(v1, 0, 1);\n  addEdge(v1, 0, 2);\n  addEdge(v1, 1, 2);\n  addEdge(v1, 1, 4);\n  addEdge(v1, 1, 3);\n  addEdge(v1, 2, 4);\n  addEdge(v1, 3, 4);\n  bfs(v1, 0);\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<bfs_test>:\nendbr64\npush   %rbp\nmov    $0x18,%edi\ncall   2300 <libmin_malloc>\nmov    $0x30,%edi\nmovl   $0x6,(%rax)\nmov    %rax,%rbp\ncall   2300 <libmin_malloc>\nmov    $0x18,%edi\nmov    %rax,0x8(%rbp)\ncall   2300 <libmin_malloc>\nmov    0x8(%rbp),%rdx\nlea    0x18(%rax),%rcx\nmov    %rax,0x10(%rbp)\ncmp    %rcx,%rdx\njae    176e <bfs_test+0x4e>\nlea    0x30(%rdx),%rcx\ncmp    %rcx,%rax\njb     1810 <bfs_test+0xf0>\npxor   %xmm0,%xmm0\nmovups %xmm0,(%rdx)\nmovups %xmm0,0x10(%rdx)\nmovups %xmm0,0x20(%rdx)\nmovq   $0x0,0x10(%rax)\nmovups %xmm0,(%rax)\nmov    %rbp,%rdi\nmov    $0x1,%edx\nxor    %esi,%esi\ncall   1320 <addEdge>\nmov    %rbp,%rdi\nmov    $0x2,%edx\nxor    %esi,%esi\ncall   1320 <addEdge>\nmov    %rbp,%rdi\nmov    $0x2,%edx\nmov    $0x1,%esi\ncall   1320 <addEdge>\nmov    %rbp,%rdi\nmov    $0x4,%edx\nmov    $0x1,%esi\ncall   1320 <addEdge>\nmov    %rbp,%rdi\nmov    $0x3,%edx\nmov    $0x1,%esi\ncall   1320 <addEdge>\nmov    %rbp,%rdi\nmov    $0x4,%edx\nmov    $0x2,%esi\ncall   1320 <addEdge>\nmov    %rbp,%rdi\nmov    $0x3,%esi\nmov    $0x4,%edx\ncall   1320 <addEdge>\nmov    %rbp,%rdi\nxor    %esi,%esi\npop    %rbp\njmp    1540 <bfs>\nnopl   0x0(%rax,%rax,1)\nxor    %ecx,%ecx\nnopw   0x0(%rax,%rax,1)\nmovq   $0x0,(%rdx,%rcx,8)\nmovl   $0x0,(%rax,%rcx,4)\nadd    $0x1,%rcx\ncmp    $0x6,%rcx\njne    1818 <bfs_test+0xf8>\njmp    1788 <bfs_test+0x68>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "bubbleSort", "content": "void bubbleSort(struct Node *start) {\n    int swapped;\n    struct Node *ptr1;\n    struct Node *lptr = NULL;\n\n    if (start == NULL)\n        return;\n\n    do{\n        swapped = 0;\n        ptr1 = start;\n\n        while (ptr1->next != lptr){\n            if (ptr1->data > ptr1->next->data){\n                swap(ptr1, ptr1->next);\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    }\n    while (swapped);\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "bubbleSort", "address": "0x1880", "label": "bubbleSort", "content": "void __fastcall bubbleSort(Node *start)\n{\n  Node *next; // r10\n  Node *v2; // r8\n  Node *v3; // rax\n  Node *v4; // rcx\n  int v5; // r9d\n  int data; // edx\n\n  if ( start )\n  {\n    next = start->next;\n    v2 = 0LL;\n    if ( next )\n    {\n      do\n      {\n        v3 = next;\n        v4 = start;\n        v5 = 0;\n        while ( 1 )\n        {\n          data = v4->data;\n          if ( v4->data > v3->data )\n          {\n            v4->data = v3->data;\n            v5 = 1;\n            v3->data = data;\n          }\n          v4 = v3;\n          if ( v3->next == v2 )\n            break;\n          v3 = v3->next;\n        }\n        if ( !v5 )\n          break;\n        v2 = v3;\n      }\n      while ( v3 != next );\n    }\n  }\n}\n"}, "pseudo_normalize": "void bubbleSort(Node *start) {\n  Node *next;\n  Node *v2;\n  Node *v3;\n  Node *v4;\n  int v5;\n  int data;\n  if (start) {\n    next = start->next;\n    v2 = 0LL;\n    if (next) {\n      do {\n        v3 = next;\n        v4 = start;\n        v5 = 0;\n        while (1) {\n          data = v4->data;\n          if (v4->data > v3->data) {\n            v4->data = v3->data;\n            v5 = 1;\n            v3->data = data;\n          }\n          v4 = v3;\n          if (v3->next == v2) break;\n          v3 = v3->next;\n        }\n        if (!v5) break;\n        v2 = v3;\n      } while (v3 != next);\n    }\n  }\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<bubbleSort>:\nendbr64\ntest   %rdi,%rdi\nje     18d6 <bubbleSort+0x56>\nmov    0x8(%rdi),%r10\nxor    %r8d,%r8d\ncmp    %r10,%r8\nje     18d6 <bubbleSort+0x56>\nnopl   (%rax)\nmov    %r10,%rax\nmov    %rdi,%rcx\nxor    %r9d,%r9d\njmp    18ab <bubbleSort+0x2b>\nnopl   0x0(%rax,%rax,1)\nmov    %rdx,%rax\nmov    (%rcx),%edx\nmov    (%rax),%esi\ncmp    %esi,%edx\njle    18bd <bubbleSort+0x3d>\nmov    %esi,(%rcx)\nmov    $0x1,%r9d\nmov    %edx,(%rax)\nmov    0x8(%rax),%rdx\nmov    %rax,%rcx\ncmp    %r8,%rdx\njne    18a8 <bubbleSort+0x28>\ntest   %r9d,%r9d\nje     18d6 <bubbleSort+0x56>\nmov    %rax,%r8\ncmp    %r10,%r8\njne    1898 <bubbleSort+0x18>\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "createGraph", "content": "struct Graph* createGraph(int vertices) {\n    int i;\n    struct Graph* graph = (struct Graph*)libmin_malloc(sizeof(struct Graph));\n    graph->numVertices = vertices;\n\n    graph->adjLists = (struct node**)libmin_malloc(vertices * sizeof(struct node*));\n    graph->visited = (int*)libmin_malloc(vertices * sizeof(int));\n\n    for (i = 0; i < vertices; i++) {\n        graph->adjLists[i] = NULL;\n        graph->visited[i] = 0;\n    }\n\n    return graph;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "createGraph", "address": "0x1260", "label": "createGraph", "content": "Graph *__fastcall createGraph(int vertices)\n{\n  __int64 v1; // r13\n  size_t v2; // r14\n  size_t v3; // r15\n  Graph *v4; // rax\n  Graph *v5; // r12\n  int *v6; // rax\n  node **adjLists; // rdi\n  int *v8; // rbp\n  __int64 v10; // rax\n\n  v1 = vertices;\n  v2 = vertices;\n  v3 = vertices;\n  v4 = (Graph *)libmin_malloc(0x18uLL);\n  v4->numVertices = vertices;\n  v5 = v4;\n  v4->adjLists = (node **)libmin_malloc(v2 * 8);\n  v6 = (int *)libmin_malloc(v3 * 4);\n  v5->visited = v6;\n  if ( vertices > 0 )\n  {\n    adjLists = v5->adjLists;\n    v8 = v6;\n    if ( v6 < (int *)&adjLists[v2] && adjLists < (node **)&v6[v3] )\n    {\n      v10 = 0LL;\n      do\n      {\n        adjLists[v10] = 0LL;\n        v8[v10++] = 0;\n      }\n      while ( v1 != v10 );\n    }\n    else\n    {\n      memset(adjLists, 0, 8 * v1);\n      memset(v8, 0, 4 * v1);\n    }\n  }\n  return v5;\n}\n"}, "pseudo_normalize": "Graph *createGraph(int vertices) {\n  long long v1;\n  unsigned int v2;\n  unsigned int v3;\n  Graph *v4;\n  Graph *v5;\n  int *v6;\n  node **adjLists;\n  int *v8;\n  long long v10;\n  v1 = vertices;\n  v2 = vertices;\n  v3 = vertices;\n  v4 = (Graph *)libmin_malloc(24uLL);\n  v4->numVertices = vertices;\n  v5 = v4;\n  v4->adjLists = (node **)libmin_malloc(v2 * 8);\n  v6 = (int *)libmin_malloc(v3 * 4);\n  v5->visited = v6;\n  if (vertices > 0) {\n    adjLists = v5->adjLists;\n    v8 = v6;\n    if (v6 < (int *)&adjLists[v2] && adjLists < (node **)&v6[v3]) {\n      v10 = 0LL;\n      do {\n        adjLists[v10] = 0LL;\n        v8[v10++] = 0;\n      } while (v1 != v10);\n    } else {\n      memset(adjLists, 0, 8 * v1);\n      memset(v8, 0, 4 * v1);\n    }\n  }\n  return v5;\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<createGraph>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmovslq %edi,%r13\nmov    $0x18,%edi\npush   %r12\nlea    0x0(,%r13,8),%r14\nlea    0x0(,%r13,4),%r15\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   2300 <libmin_malloc>\nmov    %r14,%rdi\nmov    %r13d,(%rax)\nmov    %rax,%r12\ncall   2300 <libmin_malloc>\nmov    %r15,%rdi\nmov    %rax,0x8(%r12)\ncall   2300 <libmin_malloc>\nmov    %rax,0x10(%r12)\ntest   %r13d,%r13d\njle    12e6 <createGraph+0x86>\nmov    0x8(%r12),%rdi\nmov    %rax,%rbp\nlea    (%rdi,%r14,1),%rax\ncmp    %rax,%rbp\njae    12cf <createGraph+0x6f>\nlea    0x0(%rbp,%r15,1),%rax\ncmp    %rax,%rdi\njb     12f8 <createGraph+0x98>\nmov    %r14,%rdx\nxor    %esi,%esi\ncall   10d0 <memset@plt>\nmov    %r15,%rdx\nxor    %esi,%esi\nmov    %rbp,%rdi\ncall   10d0 <memset@plt>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmovq   $0x0,(%rdi,%rax,8)\nmovl   $0x0,0x0(%rbp,%rax,4)\nadd    $0x1,%rax\ncmp    %rax,%r13\njne    1300 <createGraph+0xa0>\njmp    12e6 <createGraph+0x86>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "createNode", "content": "struct node* createNode(int v) {\n    struct node* newNode = (struct node*)libmin_malloc(sizeof(struct node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "createNode", "address": "0x1240", "label": "createNode", "content": "node *__fastcall createNode(int v)\n{\n  node *result; // rax\n\n  result = (node *)libmin_malloc(0x10uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "node *createNode(int v) {\n  node *result;\n  result = (node *)libmin_malloc(16uLL);\n  result->vertex = v;\n  result->next = 0LL;\n  return result;\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<createNode>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\ncall   2300 <libmin_malloc>\nmov    %ebx,(%rax)\nmovq   $0x0,0x8(%rax)\npop    %rbx\nret\nnopl   (%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "createQueue", "content": "struct queue* createQueue() {\n    struct queue* q = (struct queue*)libmin_malloc(sizeof(struct queue));\n    q->front = -1;\n    q->rear = -1;\n    return q;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "createQueue", "address": "0x1390", "label": "createQueue", "content": "queue *__cdecl createQueue()\n{\n  queue *result; // rax\n\n  result = (queue *)libmin_malloc(0xA8uLL);\n  *(_QWORD *)&result->front = -1LL;\n  return result;\n}\n"}, "pseudo_normalize": "queue *createQueue() {\n  queue *result;\n  result = (queue *)libmin_malloc(168uLL);\n  *(uint64_t *)&result->front = -1LL;\n  return result;\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<createQueue>:\nendbr64\nsub    $0x8,%rsp\nmov    $0xa8,%edi\ncall   2300 <libmin_malloc>\nmovq   $0xffffffffffffffff,0xa0(%rax)\nadd    $0x8,%rsp\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "depthFirstSearch", "content": "void depthFirstSearch() {\n   int i;\n\n   lstVertices[0]->visited = TRUE;\n\n\n   push(0);\n\n   while(!isStackEmpty()) {\n      int unvisitedVertex = getAdjUnvisitedVertex(peek());\n\n      if(unvisitedVertex == -1) {\n         pop();\n      } else {\n         lstVertices[unvisitedVertex]->visited = TRUE;\n         push(unvisitedVertex);\n      }\n   }\n\n   for(i = 0;i < vertexCount;i++) {\n      lstVertices[i]->visited = FALSE;\n   }\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "depthFirstSearch", "address": "0x1b20", "label": "depthFirstSearch", "content": "void __cdecl depthFirstSearch()\n{\n  Vertex *v0; // r10\n  int v1; // edx\n  int v2; // edi\n  __int64 v3; // rax\n  int *v4; // rcx\n  __int64 v5; // rax\n  Vertex *v6; // rsi\n  __int64 i; // rax\n\n  v0 = lstVertices[0];\n  lstVertices[0]->visited = 1;\n  v1 = vertexCount;\n  v2 = ++top;\n  stack[top] = 0;\n  if ( v2 != -1 )\n  {\n    v3 = 0LL;\n    if ( v1 <= 0 )\n      goto LABEL_9;\nLABEL_3:\n    v4 = adjMatrix[v3];\n    v5 = 0LL;\n    do\n    {\n      if ( v4[v5] == 1 )\n      {\n        v6 = lstVertices[v5];\n        if ( !v6->visited )\n        {\n          v6->visited = 1;\n          v2 = ++top;\n          stack[top] = v5;\n          v1 = vertexCount;\n          if ( v2 != -1 )\n            goto LABEL_8;\n          goto LABEL_10;\n        }\n      }\n      ++v5;\n    }\n    while ( v1 > (int)v5 );\nLABEL_9:\n    while ( 1 )\n    {\n      top = --v2;\n      if ( v2 == -1 )\n        break;\nLABEL_8:\n      v3 = stack[v2];\n      if ( v1 > 0 )\n        goto LABEL_3;\n    }\n  }\nLABEL_10:\n  if ( v1 > 0 )\n  {\n    for ( i = 0LL; ; v0 = lstVertices[i] )\n    {\n      v0->visited = 0;\n      if ( vertexCount <= (int)++i )\n        break;\n    }\n  }\n}\n"}, "pseudo_normalize": "void depthFirstSearch() {\n  Vertex *v0;\n  int v1;\n  int v2;\n  long long v3;\n  int *v4;\n  long long v5;\n  Vertex *v6;\n  long long i;\n  v0 = lstVertices[0];\n  lstVertices[0]->visited = 1;\n  v1 = vertexCount;\n  v2 = ++top;\n  stack[top] = 0;\n  if (v2 != -1) {\n    v3 = 0LL;\n    if (v1 <= 0) goto LABEL_9;\n  LABEL_3:\n    v4 = adjMatrix[v3];\n    v5 = 0LL;\n    do {\n      if (v4[v5] == 1) {\n        v6 = lstVertices[v5];\n        if (!v6->visited) {\n          v6->visited = 1;\n          v2 = ++top;\n          stack[top] = v5;\n          v1 = vertexCount;\n          if (v2 != -1) goto LABEL_8;\n          goto LABEL_10;\n        }\n      }\n      ++v5;\n    } while (v1 > (int)v5);\n  LABEL_9:\n    while (1) {\n      top = --v2;\n      if (v2 == -1) break;\n    LABEL_8:\n      v3 = stack[v2];\n      if (v1 > 0) goto LABEL_3;\n    }\n  }\nLABEL_10:\n  if (v1 > 0) {\n    for (i = 0LL;; v0 = lstVertices[i]) {\n      v0->visited = 0;\n      if (vertexCount <= (int)++i) break;\n    }\n  }\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<depthFirstSearch>:\nendbr64\nmov    0x57f5(%rip),%r10\nlea    0x581e(%rip),%r9\nmovl   $0x1,(%r10)\nmov    0x54d1(%rip),%eax\nmov    0x573b(%rip),%edx\nlea    0x1(%rax),%edi\nmovslq %edi,%rax\nmov    %edi,0x54bf(%rip)\nmovl   $0x0,(%r9,%rax,4)\ncmp    $0xffffffff,%edi\nje     1bee <depthFirstSearch+0xce>\nxor    %eax,%eax\nlea    0x5735(%rip),%r11\nlea    0x57ae(%rip),%r8\ntest   %edx,%edx\njle    1be0 <depthFirstSearch+0xc0>\ncs nopw 0x0(%rax,%rax,1)\nlea    (%rax,%rax,4),%rax\nlea    (%r11,%rax,4),%rcx\nxor    %eax,%eax\njmp    1b98 <depthFirstSearch+0x78>\nnopl   0x0(%rax)\nadd    $0x1,%rax\ncmp    %eax,%edx\njle    1be0 <depthFirstSearch+0xc0>\ncmpl   $0x1,(%rcx,%rax,4)\njne    1b90 <depthFirstSearch+0x70>\nmov    (%r8,%rax,8),%rsi\ncmpl   $0x0,(%rsi)\njne    1b90 <depthFirstSearch+0x70>\nmovl   $0x1,(%rsi)\nmov    0x545d(%rip),%edi\nadd    $0x1,%edi\nmovslq %edi,%rdx\nmov    %edi,0x5451(%rip)\nmov    %eax,(%r9,%rdx,4)\nmov    0x56b7(%rip),%edx\ncmp    $0xffffffff,%edi\nje     1bee <depthFirstSearch+0xce>\nmovslq %edi,%rax\nmovslq (%r9,%rax,4),%rax\ntest   %edx,%edx\njg     1b80 <depthFirstSearch+0x60>\nnopl   0x0(%rax)\nsub    $0x1,%edi\nmov    %edi,0x5427(%rip)\ncmp    $0xffffffff,%edi\njne    1bce <depthFirstSearch+0xae>\ntest   %edx,%edx\njle    1c17 <depthFirstSearch+0xf7>\nxor    %eax,%eax\nlea    0x5725(%rip),%rdx\njmp    1c04 <depthFirstSearch+0xe4>\nnopl   (%rax)\nmov    (%rdx,%rax,8),%r10\nmovl   $0x0,(%r10)\nadd    $0x1,%rax\ncmp    %eax,0x566b(%rip)\njg     1c00 <depthFirstSearch+0xe0>\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "dequeue", "content": "int dequeue(struct queue* q){\n    int item;\n    if(isEmpty(q)){\n        libmin_printf(\"Queue is empty\\n\");\n        item = -1;\n    }\n    else{\n        item = q->items[q->front];\n        q->front++;\n        if(q->front > q->rear){\n            libmin_printf(\"Resetting queue...\\n\");\n            q->front = q->rear = -1;\n        }\n    }\n    return item;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "dequeue", "address": "0x1430", "label": "dequeue", "content": "int __fastcall dequeue(queue *q)\n{\n  int rear; // edx\n  int v2; // r12d\n  int v3; // eax\n  int result; // eax\n\n  rear = q->rear;\n  if ( rear == -1 )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  }\n  else\n  {\n    v2 = q->items[q->front];\n    v3 = q->front + 1;\n    q->front = v3;\n    if ( v3 > rear )\n    {\n      libmin_printf(\"Resetting queue...\\n\");\n      result = v2;\n      *(_QWORD *)&q->front = -1LL;\n    }\n    else\n    {\n      return v2;\n    }\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int dequeue(queue *q) {\n  int rear;\n  int v2;\n  int v3;\n  int result;\n  rear = q->rear;\n  if (rear == -1) {\n    libmin_printf(\"Queue is empty\\n\");\n    return -1;\n  } else {\n    v2 = q->items[q->front];\n    v3 = q->front + 1;\n    q->front = v3;\n    if (v3 > rear) {\n      libmin_printf(\"Resetting queue...\\n\");\n      result = v2;\n      *(uint64_t *)&q->front = -1LL;\n    } else {\n      return v2;\n    }\n  }\n  return result;\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<dequeue>:\nendbr64\npush   %r12\npush   %rbx\nsub    $0x8,%rsp\nmov    0xa4(%rdi),%edx\ncmp    $0xffffffff,%edx\nje     1498 <dequeue+0x68>\nmovslq 0xa0(%rdi),%rcx\nmov    %rdi,%rbx\nmov    %rcx,%rax\nmov    (%rdi,%rcx,4),%r12d\nadd    $0x1,%eax\nmov    %eax,0xa0(%rdi)\ncmp    %edx,%eax\njg     1470 <dequeue+0x40>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %r12\nret\nnop\nlea    0x2bae(%rip),%rdi\nxor    %eax,%eax\ncall   38a0 <libmin_printf>\nmov    %r12d,%eax\nmovq   $0xffffffffffffffff,0xa0(%rbx)\nadd    $0x8,%rsp\npop    %rbx\npop    %r12\nret\nnopl   0x0(%rax)\nlea    0x2b76(%rip),%rdi\nxor    %eax,%eax\nmov    $0xffffffff,%r12d\ncall   38a0 <libmin_printf>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "enqueue", "content": "void enqueue(struct queue* q, int value){\n    if(q->rear == 40-1){\n        libmin_printf(\"Queue is Full!!\\n\");\n    } else {\n        if(q->front == -1)\n            q->front = 0;\n        q->rear++;\n        q->items[q->rear] = value;\n    }\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "enqueue", "address": "0x13e0", "label": "enqueue", "content": "void __fastcall enqueue(queue *q, int value)\n{\n  int rear; // eax\n  int v3; // eax\n\n  rear = q->rear;\n  if ( rear == 39 )\n  {\n    libmin_printf(\"Queue is Full!!\\n\", value);\n  }\n  else\n  {\n    if ( q->front == -1 )\n      q->front = 0;\n    v3 = rear + 1;\n    q->rear = v3;\n    q->items[v3] = value;\n  }\n}\n"}, "pseudo_normalize": "void enqueue(queue *q, int value) {\n  int rear;\n  int v3;\n  rear = q->rear;\n  if (rear == 39) {\n    libmin_printf(\"Queue is Full!!\\n\", value);\n  } else {\n    if (q->front == -1) q->front = 0;\n    v3 = rear + 1;\n    q->rear = v3;\n    q->items[v3] = value;\n  }\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<enqueue>:\nendbr64\nmov    0xa4(%rdi),%eax\ncmp    $0x27,%eax\nje     1418 <enqueue+0x38>\ncmpl   $0xffffffff,0xa0(%rdi)\njne    1402 <enqueue+0x22>\nmovl   $0x0,0xa0(%rdi)\nadd    $0x1,%eax\nmov    %eax,0xa4(%rdi)\ncltq\nmov    %esi,(%rdi,%rax,4)\nret\nnopl   0x0(%rax)\nlea    0x2be5(%rip),%rdi\nxor    %eax,%eax\njmp    38a0 <libmin_printf>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "getAdjUnvisitedVertex", "content": "int getAdjUnvisitedVertex(int vertexIndex) {\n   int i;\n\n   for(i = 0; i < vertexCount; i++) {\n      if(adjMatrix[vertexIndex][i] == 1 && lstVertices[i]->visited == FALSE) {\n         return i;\n      }\n   }\n\n   return -1;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "getAdjUnvisitedVertex", "address": "0x1ac0", "label": "getAdjUnvisitedVertex", "content": "int __fastcall getAdjUnvisitedVertex(int vertexIndex)\n{\n  __int64 v1; // rax\n\n  if ( vertexCount <= 0 )\n  {\nLABEL_7:\n    LODWORD(v1) = -1;\n  }\n  else\n  {\n    v1 = 0LL;\n    while ( adjMatrix[vertexIndex][v1] != 1 || lstVertices[v1]->visited )\n    {\n      if ( vertexCount <= (int)++v1 )\n        goto LABEL_7;\n    }\n  }\n  return v1;\n}\n"}, "pseudo_normalize": "int getAdjUnvisitedVertex(int vertexIndex) {\n  long long v1;\n  if (vertexCount <= 0) {\n  LABEL_7:\n    LODWORD(v1) = -1;\n  } else {\n    v1 = 0LL;\n    while (adjMatrix[vertexIndex][v1] != 1 || lstVertices[v1]->visited) {\n      if (vertexCount <= (int)++v1) goto LABEL_7;\n    }\n  }\n  return v1;\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<getAdjUnvisitedVertex>:\nendbr64\nmov    0x57b6(%rip),%edx\ntest   %edx,%edx\njle    1b10 <getAdjUnvisitedVertex+0x50>\nmovslq %edi,%rdi\nlea    0x57c8(%rip),%rax\nlea    (%rdi,%rdi,4),%rcx\nlea    0x583d(%rip),%rdi\nlea    (%rax,%rcx,4),%rcx\nxor    %eax,%eax\njmp    1af8 <getAdjUnvisitedVertex+0x38>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rax\ncmp    %eax,%edx\njle    1b10 <getAdjUnvisitedVertex+0x50>\ncmpl   $0x1,(%rcx,%rax,4)\nmov    %eax,%r8d\njne    1af0 <getAdjUnvisitedVertex+0x30>\nmov    (%rdi,%rax,8),%rsi\nmov    (%rsi),%esi\ntest   %esi,%esi\njne    1af0 <getAdjUnvisitedVertex+0x30>\nmov    %r8d,%eax\nret\nnop\nmov    $0xffffffff,%r8d\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "insertAtTheBegin", "content": "void insertAtTheBegin(struct Node **start_ref, int data) {\n    struct Node *ptr1 = (struct Node*)libmin_malloc(sizeof(struct Node));\n    ptr1->data = data;\n    ptr1->next = *start_ref;\n    *start_ref = ptr1;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "insertAtTheBegin", "address": "0x1840", "label": "insertAtTheBegin", "content": "void __fastcall insertAtTheBegin(Node **start_ref, int data)\n{\n  Node *v2; // rax\n  Node *v3; // rdx\n\n  v2 = (Node *)libmin_malloc(0x10uLL);\n  v3 = *start_ref;\n  v2->data = data;\n  v2->next = v3;\n  *start_ref = v2;\n}\n"}, "pseudo_normalize": "void insertAtTheBegin(Node **start_ref, int data) {\n  Node *v2;\n  Node *v3;\n  v2 = (Node *)libmin_malloc(16uLL);\n  v3 = *start_ref;\n  v2->data = data;\n  v2->next = v3;\n  *start_ref = v2;\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<insertAtTheBegin>:\nendbr64\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nmov    %rdi,%rbx\nmov    $0x10,%edi\nsub    $0x8,%rsp\ncall   2300 <libmin_malloc>\nmov    (%rbx),%rdx\nmov    %ebp,(%rax)\nmov    %rdx,0x8(%rax)\nmov    %rax,(%rbx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "isEmpty", "content": "int isEmpty(struct queue* q) {\n    if(q->rear == -1)\n        return 1;\n    else\n        return 0;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "isEmpty", "address": "0x13c0", "label": "isEmpty", "content": "int __fastcall isEmpty(queue *q)\n{\n  return q->rear == -1;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<isEmpty>:\nendbr64\nxor    %eax,%eax\ncmpl   $0xffffffff,0xa4(%rdi)\nsete   %al\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "isStackEmpty", "content": "int isStackEmpty() {\n   return top == -1;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "isStackEmpty", "address": "0x1a30", "label": "isStackEmpty", "content": "int __cdecl isStackEmpty()\n{\n  return top == -1;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<isStackEmpty>:\nendbr64\nxor    %eax,%eax\ncmpl   $0xffffffff,0x55d3(%rip)\nsete   %al\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "link_list", "content": "void link_list() {\n    int arr[] = {12, 56, 2, 11, 1, 90};\n    int i;\n\n    struct Node *start = NULL;\n\n    for (i = 0; i< 6; i++)\n        insertAtTheBegin(&start, arr[i]);\n\n    bubbleSort(start);\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "link_list", "address": "0x18e0", "label": "link_list", "content": "void __cdecl link_list()\n{\n  int v0; // r12d\n  int *v1; // rbx\n  int *v2; // rax\n  int *v3; // r8\n  int *v4; // rdx\n  int *v5; // rsi\n  int v6; // r9d\n  int v7; // ecx\n  int arr[6]; // [rsp+0h] [rbp+0h] BYREF\n  unsigned __int64 vars18; // [rsp+18h] [rbp+18h] BYREF\n\n  v0 = 12;\n  v1 = 0LL;\n  vars18 = __readfsqword(0x28u);\n  *(_QWORD *)&arr[2] = 0xB00000002LL;\n  arr[1] = 56;\n  *(_QWORD *)&arr[4] = 0x5A00000001LL;\n  while ( 1 )\n  {\n    v2 = (int *)libmin_malloc(0x10uLL);\n    *v2 = v0;\n    *((_QWORD *)v2 + 1) = v1;\n    if ( &vars18 == (unsigned __int64 *)arr )\n      break;\n    v0 = arr[0];\n    v1 = v2;\n  }\n  v3 = 0LL;\n  if ( v1 )\n  {\n    do\n    {\n      v4 = v1;\n      v5 = v2;\n      v6 = 0;\n      while ( 1 )\n      {\n        v7 = *v5;\n        if ( *v5 > *v4 )\n        {\n          *v5 = *v4;\n          v6 = 1;\n          *v4 = v7;\n        }\n        v5 = v4;\n        if ( *((int **)v4 + 1) == v3 )\n          break;\n        v4 = (int *)*((_QWORD *)v4 + 1);\n      }\n      if ( !v6 )\n        break;\n      v3 = v4;\n    }\n    while ( v4 != v1 );\n  }\n}\n"}, "pseudo_normalize": "void link_list() {\n  int v0;\n  int *v1;\n  int *v2;\n  int *v3;\n  int *v4;\n  int *v5;\n  int v6;\n  int v7;\n  int arr[6];\n  unsigned long long vars18;\n  v0 = 12;\n  v1 = 0LL;\n  vars18 = __readfsqword(40u);\n  *(uint64_t *)&arr[2] = 47244640258LL;\n  arr[1] = 56;\n  *(uint64_t *)&arr[4] = 386547056641LL;\n  while (1) {\n    v2 = (int *)libmin_malloc(16uLL);\n    *v2 = v0;\n    *((uint64_t *)v2 + 1) = v1;\n    if (&vars18 == (unsigned long long *)arr) break;\n    v0 = arr[0];\n    v1 = v2;\n  }\n  v3 = 0LL;\n  if (v1) {\n    do {\n      v4 = v1;\n      v5 = v2;\n      v6 = 0;\n      while (1) {\n        v7 = *v5;\n        if (*v5 > *v4) {\n          *v5 = *v4;\n          v6 = 1;\n          *v4 = v7;\n        }\n        v5 = v4;\n        if (*((int **)v4 + 1) == v3) break;\n        v4 = (int *)*((uint64_t *)v4 + 1);\n      }\n      if (!v6) break;\n      v3 = v4;\n    } while (v4 != v1);\n  }\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<link_list>:\nendbr64\npush   %r13\npush   %r12\nmov    $0xc,%r12d\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbp\nlea    0x18(%rsp),%r13\nmovabs $0xb00000002,%rax\nmov    %rax,0x8(%rsp)\nmovabs $0x5a00000001,%rax\nmovl   $0x38,0x4(%rsp)\nmov    %rax,0x10(%rsp)\njmp    1947 <link_list+0x67>\ncs nopw 0x0(%rax,%rax,1)\nmov    0x0(%rbp),%r12d\nmov    %rax,%rbx\nmov    $0x10,%edi\nadd    $0x4,%rbp\ncall   2300 <libmin_malloc>\nmov    %r12d,(%rax)\nmov    %rbx,0x8(%rax)\ncmp    %rbp,%r13\njne    1940 <link_list+0x60>\nxor    %r8d,%r8d\ncmp    %rbx,%r8\nje     19ae <link_list+0xce>\nnopl   0x0(%rax)\nmov    %rbx,%rdx\nmov    %rax,%rsi\nxor    %r9d,%r9d\njmp    1983 <link_list+0xa3>\nnopl   0x0(%rax,%rax,1)\nmov    %rcx,%rdx\nmov    (%rsi),%ecx\nmov    (%rdx),%edi\ncmp    %edi,%ecx\njle    1995 <link_list+0xb5>\nmov    %edi,(%rsi)\nmov    $0x1,%r9d\nmov    %ecx,(%rdx)\nmov    0x8(%rdx),%rcx\nmov    %rdx,%rsi\ncmp    %r8,%rcx\njne    1980 <link_list+0xa0>\ntest   %r9d,%r9d\nje     19ae <link_list+0xce>\nmov    %rdx,%r8\ncmp    %rbx,%r8\njne    1970 <link_list+0x90>\nmov    0x18(%rsp),%rax\nsub    %fs:0x28,%rax\njne    19c9 <link_list+0xe9>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   10c0 <__stack_chk_fail@plt>\nxchg   %ax,%ax\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "main", "content": "int\nmain(void)\n{\n\n    bfs_test();\n\n    link_list();\n\n    DFS_test();\n\n    towers_test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  bfs_test();\n  link_list();\n  DFS_test();\n  towers_test();\n  libmin_success();\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nxor    %eax,%eax\ncall   1720 <bfs_test>\nxor    %eax,%eax\ncall   18e0 <link_list>\nxor    %eax,%eax\ncall   1c20 <DFS_test>\ncall   1fd0 <towers_test>\ncall   3ae0 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "peek", "content": "int peek() {\n   return stack[top];\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "peek", "address": "0x1a10", "label": "peek", "content": "int __cdecl peek()\n{\n  return stack[top];\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<peek>:\nendbr64\nmovslq 0x55f5(%rip),%rdx\nlea    0x592e(%rip),%rax\nmov    (%rax,%rdx,4),%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "pop", "content": "int pop() {\n   return stack[top--];\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "pop", "address": "0x19f0", "label": "pop", "content": "int __cdecl pop()\n{\n  __int64 v0; // rax\n\n  v0 = top--;\n  return stack[v0];\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<pop>:\nendbr64\nmovslq 0x5615(%rip),%rax\nlea    -0x1(%rax),%edx\nmov    %edx,0x560c(%rip)\nlea    0x5945(%rip),%rdx\nmov    (%rdx,%rax,4),%eax\nret\nnop\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "printQueue", "content": "void printQueue(struct queue *q) {\n    int i = q->front;\n    if(isEmpty(q)) {\n        libmin_printf(\"Queue is empty\\n\");\n    } else {\n        libmin_printf(\"Queue contains: \");\n        for(i = q->front; i < q->rear + 1; i++) {\n            libmin_printf(\"%d \", q->items[i]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "printQueue", "address": "0x14c0", "label": "printQueue", "content": "void __fastcall printQueue(queue *q)\n{\n  __int64 i; // rbx\n  int v2; // esi\n\n  if ( q->rear == -1 )\n  {\n    libmin_printf(\"Queue is empty\\n\");\n  }\n  else\n  {\n    libmin_printf(\"Queue contains: \");\n    for ( i = q->front; q->rear >= (int)i; ++i )\n    {\n      v2 = q->items[i];\n      libmin_printf(\"%d \", v2);\n    }\n    libmin_printf((char *)\"\\n\");\n  }\n}\n"}, "pseudo_normalize": "void printQueue(queue *q) {\n  long long i;\n  int v2;\n  if (q->rear == -1) {\n    libmin_printf(\"Queue is empty\\n\");\n  } else {\n    libmin_printf(\"Queue contains: \");\n    for (i = q->front; q->rear >= (int)i; ++i) {\n      v2 = q->items[i];\n      libmin_printf(\"%d \", v2);\n    }\n    libmin_printf((char *)\"\\n\");\n  }\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<printQueue>:\nendbr64\ncmpl   $0xffffffff,0xa4(%rdi)\nje     1530 <printQueue+0x70>\npush   %r12\nxor    %eax,%eax\npush   %rbp\nmov    %rdi,%rbp\nlea    0x2b5d(%rip),%rdi\npush   %rbx\ncall   38a0 <libmin_printf>\nmovslq 0xa0(%rbp),%rbx\ncmp    0xa4(%rbp),%ebx\njg     151a <printQueue+0x5a>\nlea    0x2b52(%rip),%r12\nnopl   0x0(%rax,%rax,1)\nmov    0x0(%rbp,%rbx,4),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   38a0 <libmin_printf>\ncmp    %ebx,0xa4(%rbp)\njge    1500 <printQueue+0x40>\npop    %rbx\nlea    0x2af1(%rip),%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\njmp    38a0 <libmin_printf>\nnopl   0x0(%rax)\nlea    0x2ade(%rip),%rdi\nxor    %eax,%eax\njmp    38a0 <libmin_printf>\nxchg   %ax,%ax\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "push", "content": "void push(int item) {\n   stack[++top] = item;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "push", "address": "0x19d0", "label": "push", "content": "void __fastcall push(int item)\n{\n  stack[++top] = item;\n}\n"}, "pseudo_normalize": "", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<push>:\nendbr64\nmov    0x5636(%rip),%eax\nlea    0x596f(%rip),%rdx\nadd    $0x1,%eax\nmov    %eax,0x5626(%rip)\ncltq\nmov    %edi,(%rdx,%rax,4)\nret\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "swap", "content": "void swap(struct Node *a, struct Node *b) {\n    int temp = a->data;\n    a->data = b->data;\n    b->data = temp;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "swap", "address": "0x1870", "label": "swap", "content": "void __fastcall swap(Node *a, Node *b)\n{\n  int data; // eax\n\n  data = a->data;\n  a->data = b->data;\n  b->data = data;\n}\n"}, "pseudo_normalize": "void swap(Node *a, Node *b) {\n  int data;\n  data = a->data;\n  a->data = b->data;\n  b->data = data;\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<swap>:\nendbr64\nmov    (%rdi),%eax\nmov    (%rsi),%edx\nmov    %edx,(%rdi)\nmov    %eax,(%rsi)\nret\nnopl   (%rax)\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "towers", "content": "int\ntowers(int num, char frompeg, char topeg, char auxpeg)\n{\n    if (num == 1){\n        return 0;\n    }\n    towers(num - 1, frompeg, auxpeg, topeg);\n    towers(num - 1, auxpeg, topeg, frompeg);\n    return 0;\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "towers", "address": "0x1d70", "label": "towers", "content": "int __fastcall towers(int num, char frompeg, char topeg, char auxpeg)\n{\n  if ( (unsigned int)(num - 1) <= 2 )\n    return 0;\n  if ( num != 4 && num != 5 )\n  {\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int towers(int num, char frompeg, char topeg, char auxpeg) {\n  if ((unsigned int)(num - 1) <= 2) return 0;\n  if (num != 4 && num != 5) {\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n    towers(num - 5, topeg, frompeg, auxpeg);\n    towers(num - 5, frompeg, auxpeg, topeg);\n    towers(num - 5, auxpeg, topeg, frompeg);\n  }\n  return 0;\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<towers>:\nendbr64\nlea    -0x1(%rdi),%eax\ncmp    $0x2,%eax\njbe    1fc0 <towers+0x250>\npush   %r14\nmovsbl %sil,%r14d\npush   %r13\nmovsbl %dl,%r13d\npush   %r12\nmovsbl %cl,%r12d\npush   %rbp\nsub    $0x8,%rsp\ncmp    $0x4,%edi\nje     1fac <towers+0x23c>\ncmp    $0x5,%edi\nje     1fac <towers+0x23c>\nlea    -0x5(%rdi),%ebp\nmov    %r13d,%ecx\nmov    %r12d,%edx\nmov    %r14d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r14d,%ecx\nmov    %r13d,%edx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r12d,%ecx\nmov    %r14d,%edx\nmov    %r13d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r13d,%ecx\nmov    %r12d,%edx\nmov    %r14d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r14d,%ecx\nmov    %r13d,%edx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r12d,%ecx\nmov    %r14d,%edx\nmov    %r13d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r13d,%ecx\nmov    %r12d,%edx\nmov    %r14d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r14d,%ecx\nmov    %r13d,%edx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r12d,%ecx\nmov    %r14d,%edx\nmov    %r13d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r13d,%ecx\nmov    %r12d,%edx\nmov    %r14d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r14d,%ecx\nmov    %r13d,%edx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r12d,%ecx\nmov    %r14d,%edx\nmov    %r13d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r13d,%ecx\nmov    %r12d,%edx\nmov    %r14d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r14d,%ecx\nmov    %r13d,%edx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r12d,%ecx\nmov    %r14d,%edx\nmov    %r13d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r13d,%ecx\nmov    %r12d,%edx\nmov    %r14d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r14d,%ecx\nmov    %r13d,%edx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r12d,%ecx\nmov    %r14d,%edx\nmov    %r13d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r13d,%ecx\nmov    %r12d,%edx\nmov    %r14d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r14d,%ecx\nmov    %r13d,%edx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r12d,%ecx\nmov    %r14d,%edx\nmov    %r13d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r13d,%ecx\nmov    %r12d,%edx\nmov    %r14d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r14d,%ecx\nmov    %r13d,%edx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r12d,%ecx\nmov    %r14d,%edx\nmov    %r13d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r13d,%ecx\nmov    %r12d,%edx\nmov    %r14d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r14d,%ecx\nmov    %r13d,%edx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r12d,%ecx\nmov    %r14d,%edx\nmov    %r13d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r13d,%ecx\nmov    %r12d,%edx\nmov    %r14d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r14d,%ecx\nmov    %r13d,%edx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r12d,%ecx\nmov    %r14d,%edx\nmov    %r13d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r13d,%ecx\nmov    %r12d,%edx\nmov    %r14d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nmov    %r14d,%ecx\nmov    %r13d,%edx\nmov    %r12d,%esi\nmov    %ebp,%edi\ncall   1d70 <towers>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "graph-tests/graph-tests.c", "function_name": "towers_test", "content": "void\ntowers_test(void)\n{\n    towers(5, 'A', 'C', 'B');\n}\n"}, "pseudo": {"path": "graph-tests/graph-tests.host.O2.pseudo", "function_name": "towers_test", "address": "0x1fd0", "label": "towers_test", "content": "void __cdecl towers_test()\n{\n  towers(1, 65, 67, 66);\n  towers(1, 67, 66, 65);\n  towers(1, 65, 67, 66);\n  towers(1, 67, 66, 65);\n  towers(1, 65, 67, 66);\n  towers(1, 65, 67, 66);\n  towers(1, 65, 67, 66);\n}\n"}, "pseudo_normalize": "void towers_test() {\n  towers(1, 65, 67, 66);\n  towers(1, 67, 66, 65);\n  towers(1, 65, 67, 66);\n  towers(1, 67, 66, 65);\n  towers(1, 65, 67, 66);\n  towers(1, 65, 67, 66);\n  towers(1, 65, 67, 66);\n}", "binary": "graph-tests/graph-tests.host.O2", "assembly": "<towers_test>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x42,%ecx\nmov    $0x43,%edx\nmov    $0x41,%esi\nmov    $0x1,%edi\ncall   1d70 <towers>\nmov    $0x41,%ecx\nmov    $0x42,%edx\nmov    $0x43,%esi\nmov    $0x1,%edi\ncall   1d70 <towers>\nmov    $0x42,%ecx\nmov    $0x43,%edx\nmov    $0x41,%esi\nmov    $0x1,%edi\ncall   1d70 <towers>\nmov    $0x41,%ecx\nmov    $0x42,%edx\nmov    $0x43,%esi\nmov    $0x1,%edi\ncall   1d70 <towers>\nmov    $0x42,%ecx\nmov    $0x43,%edx\nmov    $0x41,%esi\nmov    $0x1,%edi\ncall   1d70 <towers>\nmov    $0x42,%ecx\nmov    $0x43,%edx\nmov    $0x41,%esi\nmov    $0x1,%edi\ncall   1d70 <towers>\nmov    $0x42,%ecx\nmov    $0x43,%edx\nmov    $0x41,%esi\nmov    $0x1,%edi\nadd    $0x8,%rsp\njmp    1d70 <towers>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "hanoi/hanoi.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int disk, Loops = 0;\n\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\");\n  libmin_printf(\"Disks     Moves\\n\");\n\n  disk = 0;\n\n  while (1)\n    {\n      disk++;\n      num[0] = 0;\n      num[1] = disk;\n      num[2] = 0;\n      num[3] = 0;\n      count  = 0;\n\n      mov(disk,1,3);\n\n      Loops = Loops + 1;\n      libmin_printf(\"%3d  %10ld\\n\",disk,count);\n\n      if (disk == 10) break;\n    }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "hanoi/hanoi.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n\n  v3 = 0;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  do\n  {\n    ++v3;\n    num[0] = 0;\n    num[1] = v3;\n    *(_QWORD *)&num[2] = 0LL;\n    count = 0LL;\n    mov(v3, 1, 3);\n    libmin_printf(\"%3d  %10ld\\n\", v3, count);\n  }\n  while ( v3 != 10 );\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  v3 = 0;\n  libmin_printf(\"Towers of Hanoi Puzzle Test Program\\n\", argv, envp);\n  libmin_printf(\"Disks     Moves\\n\");\n  do {\n    ++v3;\n    num[0] = 0;\n    num[1] = v3;\n    *(uint64_t *)&num[2] = 0LL;\n    count = 0LL;\n    mov(v3, 1, 3);\n    libmin_printf(\"%3d  %10ld\\n\", v3, count);\n  } while (v3 != 10);\n  libmin_success();\n}", "binary": "hanoi/hanoi.host.O2", "assembly": "<main>:\nendbr64\npush   %rbp\nlea    0x1efc(%rip),%rdi\nxor    %eax,%eax\nlea    0x1f29(%rip),%rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x8,%rsp\ncall   2cf0 <libmin_printf>\nlea    0x1f05(%rip),%rdi\nxor    %eax,%eax\ncall   2cf0 <libmin_printf>\nnop\nadd    $0x1,%ebx\nmov    $0x3,%edx\nmov    $0x1,%esi\nmovl   $0x0,0x4139(%rip)\nmov    %ebx,%edi\nmov    %ebx,0x4135(%rip)\nmovq   $0x0,0x412e(%rip)\nmovq   $0x0,0x410b(%rip)\ncall   1280 <mov.isra.0>\nmov    0x40ff(%rip),%rdx\nxor    %eax,%eax\nmov    %ebx,%esi\nmov    %rbp,%rdi\ncall   2cf0 <libmin_printf>\ncmp    $0xa,%ebx\njne    1130 <main+0x30>\ncall   2f30 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nret\n"}
{"source": {"path": "heapsort/heapsort.c", "function_name": "HSORT", "content": "/*************************/\n/*  Heap Sort Program    */\n/*************************/\n\nint\nHSORT(int64_t m, int64_t p)\n{\n  int64_t i,j,k,l;\n  int64_t size;\n\n  int64_t  msize, iran, ia, ic, im, ih, ir;\n  int64_t  count, ca;\n\n  msize = m * bplong;\n  size  = m - 1;\n\n  if (m >= 2048)\n    {\n      libmin_printf(\"base buffer overflow!\\n\");\n      libmin_fail(1);\n    }\n\n  ia = 106;\n  ic = 1283;\n  im = 6075;\n  ih = 1001;\n\n  count = 0;\n\n  iran = 47;                        /* Fill with 'random' numbers */\n  for(i=1 ; i<=size ; i++)\n    {\n      iran = (iran * ia + ic) % im;\n      *(base+i) = 1 + (ih * iran) / im;\n    }\n\n  k = (size >> 1) + 1;              /* Heap sort the array */\n  l = size;\n  ca = 0;\n\n  for (;;)\n    {\n      if (k > 1)\n\t{\n\t  ir = *(base+(--k));\n\t}\n      else\n\t{\n\t  ir = *(base+l);\n\t  *(base+l) = *(base+1);\n\t  if (--l == 1)\n\t    {\n\t      *(base+1) = ir;\n\t      goto Done;\n\t    }\n\t}\n\n      i = k;\n      j = k << 1;\n\n      while (j <= l)\n\t{\n\t  if ( (j < l) && (*(base+j) < *(base+j+1)) ) ++j;\n\t  if (ir < *(base+j))\n\t    {\n\t      *(base+i) = *(base+j);\n\t      j += (i=j);\n\t    }\n\t  else\n\t    {\n\t      j = l + 1;\n\t    }\n\t}\n      *(base+i) = ir;\n    }\n Done:\n  count = count + ca;\n\n  /* Scale runtime per iteration */\n  ir = count;\n  ir = (ir + ca) / 2;\n\n  if ( p != 0L )\n    libmin_printf(\"   %10ld\\n\", (int)msize);\n\n  /* check the array */\n  for(i = 0; i < size-1; i++)\n    {\n      if (base[i] > base[i+1])\n      {\n        libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n        libmin_fail(1);\n      }\n    }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n\n  return 0;\n}\n"}, "pseudo": {"path": "heapsort/heapsort.host.O2.pseudo", "function_name": "HSORT", "address": "0x1250", "label": "HSORT", "content": "int __fastcall HSORT(int64_t m, int64_t p)\n{\n  int v2; // r14d\n  int64_t v5; // rbx\n  int64_t *v6; // rsi\n  __int64 v7; // rcx\n  int64_t *v8; // rbp\n  __int64 v9; // r10\n  int64_t *v10; // rcx\n  int64_t v11; // r8\n  __int64 v12; // rax\n  __int64 v13; // rdi\n  int64_t v14; // rdx\n  int64_t *v15; // rsi\n  int64_t *v16; // rsi\n  int64_t *v17; // rax\n  int64_t v18; // r12\n  __int64 v19; // rbx\n  int64_t v20; // rax\n\n  v2 = bplong;\n  v5 = m - 1;\n  if ( m > 2047 )\n  {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  if ( v5 <= 0 )\n  {\n    v8 = base;\n  }\n  else\n  {\n    v6 = &base[1];\n    v7 = 47LL;\n    v8 = base;\n    do\n    {\n      ++v6;\n      v7 = (106 * v7 + 1283) % 6075;\n      *(v6 - 1) = 1001 * v7 / 6075 + 1;\n    }\n    while ( &base[m - 7] != v6 );\n  }\n  v9 = (v5 >> 1) + 1;\n  if ( v9 <= 1 )\n    goto LABEL_16;\nLABEL_6:\n  v10 = &v8[--v9];\n  v11 = *v10;\n  while ( 1 )\n  {\n    v12 = 2 * v9;\n    if ( v5 >= 2 * v9 )\n    {\n      v13 = v9;\n      do\n      {\n        while ( 1 )\n        {\n          v10 = &v8[v12];\n          v14 = *v10;\n          if ( v5 > v12 )\n          {\n            v15 = &v8[v12 + 1];\n            if ( *v15 > v14 )\n            {\n              ++v12;\n              v14 = *v15;\n              v10 = v15;\n            }\n          }\n          v16 = &v8[v13];\n          if ( v11 >= v14 )\n            break;\n          v13 = v12;\n          v12 *= 2LL;\n          *v16 = v14;\n          if ( v12 > v5 )\n            goto LABEL_15;\n        }\n        v12 = v5 + 1;\n        v10 = &v8[v13];\n      }\n      while ( v5 + 1 <= v5 );\n    }\nLABEL_15:\n    *v10 = v11;\n    if ( v9 > 1 )\n      goto LABEL_6;\nLABEL_16:\n    v17 = &v8[v5--];\n    v11 = *v17;\n    *v17 = base[1];\n    if ( v5 == 1 )\n      break;\n    v10 = &v8[v9];\n  }\n  base[1] = v11;\n  if ( p )\n    libmin_printf(\"   %10ld\\n\", (unsigned int)(m * v2));\n  v18 = m - 2;\n  v19 = 0LL;\n  if ( v18 > 0 )\n  {\n    do\n    {\n      v20 = v8[v19++];\n      if ( v20 > v8[v19] )\n      {\n        libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n        libmin_fail(1);\n      }\n    }\n    while ( v19 != v18 );\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  return 0;\n}\n"}, "pseudo_normalize": "int HSORT(int64_t m, int64_t p) {\n  int v2;\n  int64_t v5;\n  int64_t *v6;\n  long long v7;\n  int64_t *v8;\n  long long v9;\n  int64_t *v10;\n  int64_t v11;\n  long long v12;\n  long long v13;\n  int64_t v14;\n  int64_t *v15;\n  int64_t *v16;\n  int64_t *v17;\n  int64_t v18;\n  long long v19;\n  int64_t v20;\n  v2 = bplong;\n  v5 = m - 1;\n  if (m > 2047) {\n    libmin_printf(\"base buffer overflow!\\n\");\n    libmin_fail(1);\n  }\n  if (v5 <= 0) {\n    v8 = base;\n  } else {\n    v6 = &base[1];\n    v7 = 47LL;\n    v8 = base;\n    do {\n      ++v6;\n      v7 = (106 * v7 + 1283) % 6075;\n      *(v6 - 1) = 1001 * v7 / 6075 + 1;\n    } while (&base[m - 7] != v6);\n  }\n  v9 = (v5 >> 1) + 1;\n  if (v9 <= 1) goto LABEL_16;\nLABEL_6:\n  v10 = &v8[--v9];\n  v11 = *v10;\n  while (1) {\n    v12 = 2 * v9;\n    if (v5 >= 2 * v9) {\n      v13 = v9;\n      do {\n        while (1) {\n          v10 = &v8[v12];\n          v14 = *v10;\n          if (v5 > v12) {\n            v15 = &v8[v12 + 1];\n            if (*v15 > v14) {\n              ++v12;\n              v14 = *v15;\n              v10 = v15;\n            }\n          }\n          v16 = &v8[v13];\n          if (v11 >= v14) break;\n          v13 = v12;\n          v12 *= 2LL;\n          *v16 = v14;\n          if (v12 > v5) goto LABEL_15;\n        }\n        v12 = v5 + 1;\n        v10 = &v8[v13];\n      } while (v5 + 1 <= v5);\n    }\n  LABEL_15:\n    *v10 = v11;\n    if (v9 > 1) goto LABEL_6;\n  LABEL_16:\n    v17 = &v8[v5--];\n    v11 = *v17;\n    *v17 = base[1];\n    if (v5 == 1) break;\n    v10 = &v8[v9];\n  }\n  base[1] = v11;\n  if (p) libmin_printf(\"   %10ld\\n\", (unsigned int)(m * v2));\n  v18 = m - 2;\n  v19 = 0LL;\n  if (v18 > 0) {\n    do {\n      v20 = v8[v19++];\n      if (v20 > v8[v19]) {\n        libmin_printf(\"ERROR: base array is not properly sorted!\\n\");\n        libmin_fail(1);\n      }\n    } while (v19 != v18);\n  }\n  libmin_printf(\"INFO: base array is properly sorted!\\n\");\n  return 0;\n}", "binary": "heapsort/heapsort.host.O2", "assembly": "<HSORT>:\nendbr64\npush   %r14\nmov    0x8023(%rip),%r14\npush   %r13\nmov    %rsi,%r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nlea    -0x1(%rdi),%rbx\ncmp    $0x7ff,%rdi\njg     141f <HSORT+0x1cf>\ntest   %rbx,%rbx\njle    1440 <HSORT+0x1f0>\nlea    0x3ffe(%rip),%rsi\nmov    $0x2f,%ecx\nmovabs $0x564d7402dd925a19,%rdi\nlea    -0x8(%rsi),%rbp\nlea    0x0(%rbp,%r12,8),%r8\nnopw   0x0(%rax,%rax,1)\nimul   $0x6a,%rcx,%r9\nadd    $0x8,%rsi\nadd    $0x503,%r9\nmov    %r9,%rax\nimul   %rdi\nmov    %r9,%rax\nsar    $0x3f,%rax\nsar    $0xb,%rdx\nmov    %rdx,%rcx\nsub    %rax,%rcx\nimul   $0x17bb,%rcx,%rax\nmov    %r9,%rcx\nsub    %rax,%rcx\nimul   $0x3e9,%rcx,%r9\nmov    %r9,%rax\nsar    $0x3f,%r9\nimul   %rdi\nsar    $0xb,%rdx\nsub    %r9,%rdx\nlea    0x1(%rdx),%rax\nmov    %rax,-0x8(%rsi)\ncmp    %rsi,%r8\njne    12a8 <HSORT+0x58>\nmov    %rbx,%r10\nsar    %r10\nadd    $0x1,%r10\ncmp    $0x1,%r10\njle    1389 <HSORT+0x139>\nsub    $0x1,%r10\nlea    0x0(%rbp,%r10,8),%rcx\nmov    (%rcx),%r8\nlea    (%r10,%r10,1),%rax\ncmp    %rax,%rbx\njl     1380 <HSORT+0x130>\nmov    %r10,%rdi\njmp    133e <HSORT+0xee>\nnopw   0x0(%rax,%rax,1)\nmov    %rax,%rdi\nadd    %rax,%rax\nmov    %rdx,(%rsi)\ncmp    %rbx,%rax\njg     1380 <HSORT+0x130>\nlea    0x0(,%rax,8),%rsi\nlea    0x0(%rbp,%rsi,1),%rcx\nmov    (%rcx),%rdx\ncmp    %rax,%rbx\njle    136a <HSORT+0x11a>\nlea    0x8(%rbp,%rsi,1),%rsi\nmov    (%rsi),%r9\ncmp    %rdx,%r9\njle    136a <HSORT+0x11a>\nadd    $0x1,%rax\nmov    %r9,%rdx\nmov    %rsi,%rcx\nlea    0x0(%rbp,%rdi,8),%rsi\ncmp    %rdx,%r8\njl     1330 <HSORT+0xe0>\nlea    0x1(%rbx),%rax\nmov    %rsi,%rcx\ncmp    %rbx,%rax\njle    133e <HSORT+0xee>\nmov    %r8,(%rcx)\ncmp    $0x1,%r10\njg     1310 <HSORT+0xc0>\nmov    0x3ef8(%rip),%rdx\nlea    0x0(%rbp,%rbx,8),%rax\nsub    $0x1,%rbx\nmov    (%rax),%r8\nmov    %rdx,(%rax)\ncmp    $0x1,%rbx\nje     13af <HSORT+0x15f>\nlea    0x0(%rbp,%r10,8),%rcx\njmp    131c <HSORT+0xcc>\nmov    %r8,0x3ed2(%rip)\ntest   %r13,%r13\njne    144c <HSORT+0x1fc>\nsub    $0x2,%r12\nxor    %ebx,%ebx\nlea    0x1cb4(%rip),%r13\ntest   %r12,%r12\njg     13dd <HSORT+0x18d>\njmp    1406 <HSORT+0x1b6>\nnopl   0x0(%rax,%rax,1)\ncmp    %r12,%rbx\nje     1406 <HSORT+0x1b6>\nmov    0x0(%rbp,%rbx,8),%rax\nadd    $0x1,%rbx\ncmp    0x0(%rbp,%rbx,8),%rax\njle    13d8 <HSORT+0x188>\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   29d0 <libmin_printf>\nmov    $0x1,%edi\ncall   1650 <libmin_fail>\ncmp    %r12,%rbx\njne    13dd <HSORT+0x18d>\nlea    0x1c4b(%rip),%rdi\nxor    %eax,%eax\ncall   29d0 <libmin_printf>\npop    %rbx\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nlea    0x1bde(%rip),%rdi\nxor    %eax,%eax\ncall   29d0 <libmin_printf>\nmov    $0x1,%edi\ncall   1650 <libmin_fail>\ntest   %rbx,%rbx\njg     1283 <HSORT+0x33>\nlea    0x3e39(%rip),%rbp\njmp    1300 <HSORT+0xb0>\nmov    %r14d,%esi\nlea    0x1bc5(%rip),%rdi\nxor    %eax,%eax\nimul   %r12d,%esi\ncall   29d0 <libmin_printf>\njmp    13bf <HSORT+0x16f>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "heapsort/heapsort.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int64_t  j, p;\n\n  bplong = sizeof(int64_t);\n\n  libmin_printf(\"\\n   Heap Sort C Program\\n\");\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", (long)bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n\n\t\t\t\t   /* Predetermine runtime (sec) for  */\n\t\t\t\t   /* memory size 2000 * sizeof(long),*/\n\t\t\t\t   /* and 256 iterations. p = 0 means */\n\t\t\t\t   /* don't print the result.         */\n  j = 1024;\n  p = 1;\n  HSORT(j,p);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "heapsort/heapsort.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  bplong = 8LL;\n  libmin_printf(\"\\n   Heap Sort C Program\\n\", argv, envp);\n  libmin_printf(\"   Size of long (bytes): %ld\\n\\n\", bplong);\n  libmin_printf(\"   Array Size (bytes)\\n\");\n  HSORT(1024LL, 1LL);\n  libmin_success();\n}", "binary": "heapsort/heapsort.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nlea    0x1f16(%rip),%rdi\nxor    %eax,%eax\nmovq   $0x8,0x8164(%rip)\ncall   29d0 <libmin_printf>\nmov    0x8158(%rip),%rsi\nlea    0x1f81(%rip),%rdi\nxor    %eax,%eax\ncall   29d0 <libmin_printf>\nlea    0x1f01(%rip),%rdi\nxor    %eax,%eax\ncall   29d0 <libmin_printf>\nmov    $0x1,%esi\nmov    $0x400,%edi\ncall   1250 <HSORT>\ncall   2c10 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\nnop\n"}
{"source": {"path": "heat-calc/heat-calc.c", "function_name": "main", "content": "#include \"libmin.h\"\n\n#define N      100    // Number of grid points along the rod.\n#define STEPS  500   // Number of time steps for the simulation.\n#define ALPHA  1.0    // Thermal diffusivity constant.\n#define DX     1.0    // Spatial step (distance between grid points).\n#define DT     0.1    // Time step (should be small enough for stability).\n\nint main() {\n    double u[N];      // Temperature distribution at current time.\n    double u_new[N];  // Temperature distribution for the next time step.\n    int i, step;\n\n    // Initialize the rod:\n    // Set an initial temperature distribution with a single \"hot spot\" at the center.\n    // Boundary conditions: fixed at 0.0 at both ends.\n    for (i = 0; i < N; i++) {\n        if (i == N / 2)\n            u[i] = 100.0;\n        else\n            u[i] = 0.0;\n    }\n\n    // Main time-stepping loop: simulate STEPS time steps.\n    for (step = 0; step < STEPS; step++) {\n        // Update interior points using the explicit finite difference scheme:\n        // u_new[i] = u[i] + DT * ALPHA * (u[i-1] - 2*u[i] + u[i+1]) / (DX*DX)\n        for (i = 1; i < N - 1; i++) {\n            u_new[i] = u[i] + DT * ALPHA * (u[i - 1] - 2 * u[i] + u[i + 1]) / (DX * DX);\n        }\n        \n        // Copy boundary values (Dirichlet boundary conditions; they remain constant).\n        u_new[0] = u[0];\n        u_new[N - 1] = u[N - 1];\n        \n        // Update the current temperature distribution from the newly computed values.\n        for (i = 0; i < N; i++) {\n            u[i] = u_new[i];\n        }\n    }\n\n    // Output the final temperature distribution.\n    libmin_printf(\"Final temperature distribution along the rod:\\n\");\n    for (i = 0; i < N; i++) {\n        libmin_printf(\"u[%d] = %.2f\\n\", i, u[i]);\n    }\n\n    // Compute a simple checksum (sum of all temperatures) for validation.\n    double checksum = 0.0;\n    for (i = 0; i < N; i++) {\n        checksum += u[i];\n    }\n    libmin_printf(\"Checksum: %.2f\\n\", checksum);\n\n    libtarg_success();\n    return 0;\n}\n"}, "pseudo": {"path": "heat-calc/heat-calc.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rax\n  double *v4; // rbx\n  __int64 v5; // rsi\n  double v6; // xmm1_8\n  double *v7; // rdx\n  double *v8; // rax\n  double v9; // xmm0_8\n  double v10; // xmm0_8\n  double v11; // xmm2_8\n  double v12; // xmm0_8\n  __int64 v13; // rax\n  __int64 v14; // r12\n  double v15; // xmm0_8\n  int v16; // esi\n  double v17; // xmm0_8\n  double u[100]; // [rsp+0h] [rbp-678h] BYREF\n  double u_new[107]; // [rsp+320h] [rbp-358h] BYREF\n\n  *(_QWORD *)&u_new[101] = __readfsqword(0x28u);\n  v3 = 0LL;\n  v4 = u;\n  while ( 1 )\n  {\n    if ( v3 == 50 )\n    {\n      u[50] = 100.0;\n    }\n    else\n    {\n      u[v3] = 0.0;\n      if ( v3 == 99 )\n      {\n        LODWORD(v5) = 500;\n        do\n        {\n          v6 = u[1];\n          v7 = &u_new[1];\n          v8 = &u[2];\n          do\n          {\n            v9 = *(v8 - 2);\n            ++v7;\n            ++v8;\n            v10 = v9 - (v6 + v6);\n            v11 = v6;\n            v6 = *(v8 - 1);\n            *(v7 - 1) = (v10 + v6) * 0.1 + v11;\n          }\n          while ( &u_new[99] != v7 );\n          v12 = u[0];\n          v13 = 0LL;\n          u_new[99] = u[99];\n          while ( 1 )\n          {\n            u[v13++] = v12;\n            if ( v13 == 100 )\n              break;\n            v12 = u_new[v13];\n          }\n          v5 = (unsigned int)(v5 - 1);\n        }\n        while ( (_DWORD)v5 );\n        v14 = 0LL;\n        libmin_printf(\"Final temperature distribution along the rod:\\n\", v5, v7, &u_new[99], &u_new[1]);\n        do\n        {\n          v15 = u[v14];\n          v16 = v14++;\n          libmin_printf(\"u[%d] = %.2f\\n\", v16, v15);\n        }\n        while ( v14 != 100 );\n        v17 = 0.0;\n        do\n          v17 = v17 + *v4++;\n        while ( u_new != v4 );\n        libmin_printf(\"Checksum: %.2f\\n\", v17);\n        libtarg_success();\n      }\n    }\n    ++v3;\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  double *v4;\n  long long v5;\n  double v6;\n  double *v7;\n  double *v8;\n  double v9;\n  double v10;\n  double v11;\n  double v12;\n  long long v13;\n  long long v14;\n  double v15;\n  int v16;\n  double v17;\n  double u[100];\n  double u_new[107];\n  *(uint64_t *)&u_new[101] = __readfsqword(40u);\n  v3 = 0LL;\n  v4 = u;\n  while (1) {\n    if (v3 == 50) {\n      u[50] = 100.0;\n    } else {\n      u[v3] = 0.0;\n      if (v3 == 99) {\n        LODWORD(v5) = 500;\n        do {\n          v6 = u[1];\n          v7 = &u_new[1];\n          v8 = &u[2];\n          do {\n            v9 = *(v8 - 2);\n            ++v7;\n            ++v8;\n            v10 = v9 - (v6 + v6);\n            v11 = v6;\n            v6 = *(v8 - 1);\n            *(v7 - 1) = (v10 + v6) * 0.1 + v11;\n          } while (&u_new[99] != v7);\n          v12 = u[0];\n          v13 = 0LL;\n          u_new[99] = u[99];\n          while (1) {\n            u[v13++] = v12;\n            if (v13 == 100) break;\n            v12 = u_new[v13];\n          }\n          v5 = (unsigned int)(v5 - 1);\n        } while ((uint32_t)v5);\n        v14 = 0LL;\n        libmin_printf(\"Final temperature distribution along the rod:\\n\", v5, v7,\n                      &u_new[99], &u_new[1]);\n        do {\n          v15 = u[v14];\n          v16 = v14++;\n          libmin_printf(\"u[%d] = %.2f\\n\", v16, v15);\n        } while (v14 != 100);\n        v17 = 0.0;\n        do v17 = v17 + *v4++;\n        while (u_new != v4);\n        libmin_printf(\"Checksum: %.2f\\n\", v17);\n        libtarg_success();\n      }\n    }\n    ++v3;\n  }\n}", "binary": "heat-calc/heat-calc.host.O2", "assembly": "<main>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x658,%rsp\nmovsd  0x1f3f(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x648(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbx\njmp    1143 <main+0x43>\nmovq   $0x0,(%rbx,%rax,8)\ncmp    $0x63,%rax\nje     1154 <main+0x54>\nadd    $0x1,%rax\ncmp    $0x32,%rax\njne    1131 <main+0x31>\nmovsd  %xmm0,0x190(%rsp)\njmp    113f <main+0x3f>\nmovsd  0x1f04(%rip),%xmm3\nmov    $0x1f4,%esi\nlea    0x320(%rsp),%rbp\nlea    0x328(%rsp),%r8\nlea    0x10(%rsp),%rdi\nlea    0x638(%rsp),%rcx\nmovsd  0x8(%rsp),%xmm1\nmov    %r8,%rdx\nmov    %rdi,%rax\nnopw   0x0(%rax,%rax,1)\nmovapd %xmm1,%xmm2\nmovsd  -0x10(%rax),%xmm0\nadd    $0x8,%rdx\nadd    $0x8,%rax\naddsd  %xmm1,%xmm2\nsubsd  %xmm2,%xmm0\nmovapd %xmm1,%xmm2\nmovsd  -0x8(%rax),%xmm1\naddsd  %xmm1,%xmm0\nmulsd  %xmm3,%xmm0\naddsd  %xmm2,%xmm0\nmovsd  %xmm0,-0x8(%rdx)\ncmp    %rdx,%rcx\njne    1190 <main+0x90>\nmovsd  0x318(%rsp),%xmm1\nmovsd  (%rsp),%xmm0\nxor    %eax,%eax\nmovsd  %xmm1,0x638(%rsp)\njmp    11ed <main+0xed>\nnopl   0x0(%rax,%rax,1)\nmovsd  (%rax,%rbp,1),%xmm0\nmovsd  %xmm0,(%rbx,%rax,1)\nadd    $0x8,%rax\ncmp    $0x320,%rax\njne    11e8 <main+0xe8>\nsub    $0x1,%esi\njne    117e <main+0x7e>\nlea    0x1dfa(%rip),%rdi\nxor    %eax,%eax\nxor    %r12d,%r12d\ncall   28a0 <libmin_printf>\nlea    0x1e18(%rip),%r13\nmovsd  (%rbx,%r12,8),%xmm0\nmov    %r12d,%esi\nmov    %r13,%rdi\nmov    $0x1,%eax\nadd    $0x1,%r12\ncall   28a0 <libmin_printf>\ncmp    $0x64,%r12\njne    121f <main+0x11f>\npxor   %xmm0,%xmm0\naddsd  (%rbx),%xmm0\nadd    $0x8,%rbx\ncmp    %rbx,%rbp\njne    1243 <main+0x143>\nlea    0x1dee(%rip),%rdi\nmov    $0x1,%eax\ncall   28a0 <libmin_printf>\ncall   1360 <libtarg_success>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "buildHuffmanTree", "content": "// Build Huffman Tree and return its root\nHuffmanNode* buildHuffmanTree(char data[], int freq[], int size) {\n    HuffmanNode *left, *right, *top;\n    MinHeap* minHeap = createAndBuildMinHeap(data, freq, size);\n    \n    while (!isSizeOne(minHeap)) {\n        left = extractMin(minHeap);\n        right = extractMin(minHeap);\n        \n        top = createNode('$', left->freq + right->freq);\n        top->left = left;\n        top->right = right;\n        \n        insertMinHeap(minHeap, top);\n    }\n    return extractMin(minHeap);\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "buildHuffmanTree", "address": "0x1860", "label": "buildHuffmanTree", "content": "HuffmanNode *__fastcall buildHuffmanTree(char *data, int *freq, int size)\n{\n  MinHeap *v3; // rax\n  int v4; // ebx\n  MinHeap *i; // rbp\n  HuffmanNode **array; // r13\n  HuffmanNode *v7; // r12\n  HuffmanNode *v8; // r15\n  int v9; // ebx\n  HuffmanNode *v10; // rax\n  HuffmanNode *v11; // r12\n\n  v3 = createAndBuildMinHeap(data, freq, size);\n  v4 = v3->size;\n  for ( i = v3; i->size != 1; v4 = i->size )\n  {\n    array = i->array;\n    v7 = *array;\n    *array = array[v4 - 1];\n    i->size = v4 - 1;\n    minHeapify(i, 0);\n    v8 = *array;\n    *array = array[v4 - 2];\n    i->size = v4 - 2;\n    minHeapify(i, 0);\n    v9 = v7->freq + v8->freq;\n    v10 = (HuffmanNode *)libmin_malloc(0x18uLL);\n    v10->freq = v9;\n    v10->data = 36;\n    v10->left = v7;\n    v10->right = v8;\n    insertMinHeap(i, v10);\n  }\n  v11 = *i->array;\n  i->size = 0;\n  minHeapify(i, 0);\n  return v11;\n}\n"}, "pseudo_normalize": "HuffmanNode *buildHuffmanTree(char *data, int *freq, int size) {\n  MinHeap *v3;\n  int v4;\n  MinHeap *i;\n  HuffmanNode **array;\n  HuffmanNode *v7;\n  HuffmanNode *v8;\n  int v9;\n  HuffmanNode *v10;\n  HuffmanNode *v11;\n  v3 = createAndBuildMinHeap(data, freq, size);\n  v4 = v3->size;\n  for (i = v3; i->size != 1; v4 = i->size) {\n    array = i->array;\n    v7 = *array;\n    *array = array[v4 - 1];\n    i->size = v4 - 1;\n    minHeapify(i, 0);\n    v8 = *array;\n    *array = array[v4 - 2];\n    i->size = v4 - 2;\n    minHeapify(i, 0);\n    v9 = v7->freq + v8->freq;\n    v10 = (HuffmanNode *)libmin_malloc(24uLL);\n    v10->freq = v9;\n    v10->data = 36;\n    v10->left = v7;\n    v10->right = v8;\n    insertMinHeap(i, v10);\n  }\n  v11 = *i->array;\n  i->size = 0;\n  minHeapify(i, 0);\n  return v11;\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<buildHuffmanTree>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   1760 <createAndBuildMinHeap>\nmov    (%rax),%ebx\nmov    %rax,%rbp\ncmp    $0x1,%ebx\nje     1902 <buildHuffmanTree+0xa2>\nnopl   (%rax)\nmov    0x8(%rbp),%r13\nmovslq %ebx,%rax\nlea    -0x1(%rbx),%r14d\nxor    %esi,%esi\nmov    %rbp,%rdi\nsub    $0x2,%ebx\nmov    -0x8(%r13,%rax,8),%rax\nmov    0x0(%r13),%r12\nmov    %rax,0x0(%r13)\nmov    %r14d,0x0(%rbp)\nmovslq %r14d,%r14\ncall   1600 <minHeapify>\nmov    -0x8(%r13,%r14,8),%rax\nmov    0x0(%r13),%r15\nxor    %esi,%esi\nmov    %rbp,%rdi\nmov    %rax,0x0(%r13)\nmov    %ebx,0x0(%rbp)\ncall   1600 <minHeapify>\nmov    $0x18,%edi\nmov    0x4(%r15),%ebx\nadd    0x4(%r12),%ebx\ncall   1d20 <libmin_malloc>\nmov    %rbp,%rdi\nmov    %ebx,0x4(%rax)\nmov    %rax,%rsi\nmovb   $0x24,(%rax)\nmov    %r12,0x8(%rax)\nmov    %r15,0x10(%rax)\ncall   16d0 <insertMinHeap>\nmov    0x0(%rbp),%ebx\ncmp    $0x1,%ebx\njne    1888 <buildHuffmanTree+0x28>\nmov    0x8(%rbp),%rax\nmov    %rbp,%rdi\nxor    %esi,%esi\nmov    (%rax),%r12\nmovl   $0x0,0x0(%rbp)\ncall   1600 <minHeapify>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "buildMinHeap", "content": "// Build the min-heap\nvoid buildMinHeap(MinHeap* minHeap) {\n    int n = minHeap->size;\n    for (int i = (n - 1) / 2; i >= 0; i--)\n        minHeapify(minHeap, i);\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "buildMinHeap", "address": "0x1720", "label": "buildMinHeap", "content": "void __fastcall buildMinHeap(MinHeap *minHeap)\n{\n  int v1; // ebx\n\n  v1 = (minHeap->size - 1) / 2;\n  if ( minHeap->size >= 0 )\n  {\n    do\n      minHeapify(minHeap, v1);\n    while ( v1-- != 0 );\n  }\n}\n"}, "pseudo_normalize": "void buildMinHeap(MinHeap *minHeap) {\n  int v1;\n  v1 = (minHeap->size - 1) / 2;\n  if (minHeap->size >= 0) {\n    do minHeapify(minHeap, v1);\n    while (v1-- != 0);\n  }\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<buildMinHeap>:\nendbr64\npush   %rbp\npush   %rbx\nmov    (%rdi),%eax\nlea    -0x1(%rax),%edx\nmov    %edx,%ebx\nshr    $0x1f,%ebx\nadd    %edx,%ebx\nsar    %ebx\ntest   %eax,%eax\njs     174f <buildMinHeap+0x2f>\nmov    %rdi,%rbp\nnopl   0x0(%rax,%rax,1)\nmov    %ebx,%esi\nmov    %rbp,%rdi\ncall   1600 <minHeapify>\nsub    $0x1,%ebx\njae    1740 <buildMinHeap+0x20>\npop    %rbx\npop    %rbp\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "createAndBuildMinHeap", "content": "// Create and build min-heap from given characters and their frequencies\nMinHeap* createAndBuildMinHeap(char data[], int freq[], int size) {\n    MinHeap* minHeap = createMinHeap(size);\n    for (int i = 0; i < size; i++) {\n        minHeap->array[i] = createNode(data[i], freq[i]);\n    }\n    minHeap->size = size;\n    buildMinHeap(minHeap);\n    return minHeap;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "createAndBuildMinHeap", "address": "0x1760", "label": "createAndBuildMinHeap", "content": "MinHeap *__fastcall createAndBuildMinHeap(char *data, int *freq, int size)\n{\n  MinHeap *v4; // rax\n  MinHeap *v5; // r12\n  HuffmanNode **array; // rax\n  int v7; // r14d\n  __int64 v8; // r15\n  HuffmanNode **v9; // r13\n  int v10; // ebx\n  char v11; // bp\n  _DWORD *v12; // rax\n  __int64 v15; // [rsp+10h] [rbp-48h]\n\n  v4 = (MinHeap *)libmin_malloc(0x10uLL);\n  v4->size = 0;\n  v5 = v4;\n  v4->capacity = size;\n  v15 = size;\n  array = (HuffmanNode **)libmin_malloc(8LL * size);\n  v5->array = array;\n  v7 = (size - 1) / 2;\n  if ( size <= 0 )\n  {\n    v5->size = size;\n    if ( size )\n      return v5;\n  }\n  else\n  {\n    v8 = 0LL;\n    while ( 1 )\n    {\n      v9 = &array[v8];\n      v10 = freq[v8];\n      v11 = data[v8++];\n      v12 = libmin_malloc(0x18uLL);\n      *(_BYTE *)v12 = v11;\n      v12[1] = v10;\n      *((_QWORD *)v12 + 2) = 0LL;\n      *((_QWORD *)v12 + 1) = 0LL;\n      *v9 = (HuffmanNode *)v12;\n      if ( v15 == v8 )\n        break;\n      array = v5->array;\n    }\n    v5->size = size;\n  }\n  do\n    minHeapify(v5, v7);\n  while ( v7-- != 0 );\n  return v5;\n}\n"}, "pseudo_normalize": "MinHeap *createAndBuildMinHeap(char *data, int *freq, int size) {\n  MinHeap *v4;\n  MinHeap *v5;\n  HuffmanNode **array;\n  int v7;\n  long long v8;\n  HuffmanNode **v9;\n  int v10;\n  char v11;\n  uint32_t *v12;\n  long long v15;\n  v4 = (MinHeap *)libmin_malloc(16uLL);\n  v4->size = 0;\n  v5 = v4;\n  v4->capacity = size;\n  v15 = size;\n  array = (HuffmanNode **)libmin_malloc(8LL * size);\n  v5->array = array;\n  v7 = (size - 1) / 2;\n  if (size <= 0) {\n    v5->size = size;\n    if (size) return v5;\n  } else {\n    v8 = 0LL;\n    while (1) {\n      v9 = &array[v8];\n      v10 = freq[v8];\n      v11 = data[v8++];\n      v12 = libmin_malloc(24uLL);\n      *(uint8_t *)v12 = v11;\n      v12[1] = v10;\n      *((uint64_t *)v12 + 2) = 0LL;\n      *((uint64_t *)v12 + 1) = 0LL;\n      *v9 = (HuffmanNode *)v12;\n      if (v15 == v8) break;\n      array = v5->array;\n    }\n    v5->size = size;\n  }\n  do minHeapify(v5, v7);\n  while (v7-- != 0);\n  return v5;\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<createAndBuildMinHeap>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edx,%ebx\nsub    $0x28,%rsp\nmov    %rdi,(%rsp)\nmov    $0x10,%edi\nmov    %edx,0x1c(%rsp)\nmov    %rsi,0x8(%rsp)\ncall   1d20 <libmin_malloc>\nmovl   $0x0,(%rax)\nmov    %rax,%r12\nmov    %ebx,0x4(%rax)\nmovslq %ebx,%rax\nlea    0x0(,%rax,8),%rdi\nmov    %rax,0x10(%rsp)\ncall   1d20 <libmin_malloc>\nlea    -0x1(%rbx),%ecx\nmov    %ecx,%edx\nmov    %rax,0x8(%r12)\nshr    $0x1f,%edx\nadd    %ecx,%edx\nsar    %edx\nmov    %edx,%r14d\ntest   %ebx,%ebx\njle    1850 <createAndBuildMinHeap+0xf0>\nxor    %r15d,%r15d\njmp    17d5 <createAndBuildMinHeap+0x75>\nnopl   (%rax)\nmov    0x8(%r12),%rax\nmov    0x8(%rsp),%rcx\nmov    (%rsp),%rdx\nmov    $0x18,%edi\nlea    (%rax,%r15,8),%r13\nmov    (%rcx,%r15,4),%ebx\nmovzbl (%rdx,%r15,1),%ebp\nadd    $0x1,%r15\ncall   1d20 <libmin_malloc>\nmov    %bpl,(%rax)\nmov    %ebx,0x4(%rax)\nmovq   $0x0,0x10(%rax)\nmovq   $0x0,0x8(%rax)\nmov    %rax,0x0(%r13)\ncmp    %r15,0x10(%rsp)\njne    17d0 <createAndBuildMinHeap+0x70>\nmov    0x1c(%rsp),%eax\nmov    %eax,(%r12)\nnopw   0x0(%rax,%rax,1)\nmov    %r14d,%esi\nmov    %r12,%rdi\ncall   1600 <minHeapify>\nsub    $0x1,%r14d\njae    1828 <createAndBuildMinHeap+0xc8>\nadd    $0x28,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmov    0x1c(%rsp),%eax\nmov    %eax,(%r12)\njne    1839 <createAndBuildMinHeap+0xd9>\njmp    1828 <createAndBuildMinHeap+0xc8>\nnopl   0x0(%rax)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "createMinHeap", "content": "// Function to create a min-heap of given capacity\nMinHeap* createMinHeap(int capacity) {\n    MinHeap* minHeap = (MinHeap*)libmin_malloc(sizeof(MinHeap));\n    minHeap->size = 0;\n    minHeap->capacity = capacity;\n    minHeap->array = (HuffmanNode**)libmin_malloc(capacity * sizeof(HuffmanNode*));\n    return minHeap;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "createMinHeap", "address": "0x15a0", "label": "createMinHeap", "content": "MinHeap *__fastcall createMinHeap(int capacity)\n{\n  MinHeap *v1; // rax\n  MinHeap *v2; // r12\n\n  v1 = (MinHeap *)libmin_malloc(0x10uLL);\n  v1->capacity = capacity;\n  v2 = v1;\n  v1->size = 0;\n  v1->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return v2;\n}\n"}, "pseudo_normalize": "MinHeap *createMinHeap(int capacity) {\n  MinHeap *v1;\n  MinHeap *v2;\n  v1 = (MinHeap *)libmin_malloc(16uLL);\n  v1->capacity = capacity;\n  v2 = v1;\n  v1->size = 0;\n  v1->array = (HuffmanNode **)libmin_malloc(8LL * capacity);\n  return v2;\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<createMinHeap>:\nendbr64\npush   %r12\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\nsub    $0x8,%rsp\ncall   1d20 <libmin_malloc>\nmovslq %ebx,%rdi\nmov    %ebx,0x4(%rax)\nshl    $0x3,%rdi\nmov    %rax,%r12\nmovl   $0x0,(%rax)\ncall   1d20 <libmin_malloc>\nmov    %rax,0x8(%r12)\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %r12\nret\nnop\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "createNode", "content": "// Function to create a new Huffman node\nHuffmanNode* createNode(char data, int freq) {\n    HuffmanNode* node = (HuffmanNode*)libmin_malloc(sizeof(HuffmanNode));\n    node->data = data;\n    node->freq = freq;\n    node->left = node->right = NULL;\n    return node;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "createNode", "address": "0x1560", "label": "createNode", "content": "HuffmanNode *__fastcall createNode(char data, int freq)\n{\n  HuffmanNode *result; // rax\n\n  result = (HuffmanNode *)libmin_malloc(0x18uLL);\n  result->data = data;\n  result->freq = freq;\n  result->right = 0LL;\n  result->left = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "HuffmanNode *createNode(char data, int freq) {\n  HuffmanNode *result;\n  result = (HuffmanNode *)libmin_malloc(24uLL);\n  result->data = data;\n  result->freq = freq;\n  result->right = 0LL;\n  result->left = 0LL;\n  return result;\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<createNode>:\nendbr64\npush   %rbp\nmov    %edi,%ebp\nmov    $0x18,%edi\npush   %rbx\nmov    %esi,%ebx\nsub    $0x8,%rsp\ncall   1d20 <libmin_malloc>\nmov    %bpl,(%rax)\nmov    %ebx,0x4(%rax)\nmovq   $0x0,0x10(%rax)\nmovq   $0x0,0x8(%rax)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "decodeString", "content": "// Decode the encoded bit string using the Huffman tree\nvoid decodeString(HuffmanNode* root, const char* encoded, char* decoded) {\n    int idx = 0, out_idx = 0;\n    HuffmanNode* curr = root;\n    while (encoded[idx]) {\n        if (encoded[idx] == '0')\n            curr = curr->left;\n        else\n            curr = curr->right;\n        \n        // If leaf node, record the character and restart from tree root\n        if (!curr->left && !curr->right) {\n            decoded[out_idx++] = curr->data;\n            curr = root;\n        }\n        idx++;\n    }\n    decoded[out_idx] = '\\0';\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "decodeString", "address": "0x1a30", "label": "decodeString", "content": "void __fastcall decodeString(HuffmanNode *root, const char *encoded, char *decoded)\n{\n  char v3; // cl\n  const char *v4; // rsi\n  HuffmanNode *v5; // rax\n  int v6; // r9d\n  HuffmanNode *left; // r8\n  __int64 v8; // rax\n\n  v3 = *encoded;\n  if ( *encoded )\n  {\n    v4 = encoded + 1;\n    v5 = root;\n    v6 = 0;\n    do\n    {\n      while ( 1 )\n      {\n        left = v5->left;\n        if ( v3 != 48 )\n          left = v5->right;\n        v5 = left;\n        if ( !left->left && !left->right )\n          break;\n        v3 = *v4++;\n        if ( !v3 )\n          goto LABEL_9;\n      }\n      v8 = v6;\n      ++v4;\n      ++v6;\n      decoded[v8] = left->data;\n      v3 = *(v4 - 1);\n      v5 = root;\n    }\n    while ( v3 );\nLABEL_9:\n    decoded += v6;\n  }\n  *decoded = 0;\n}\n"}, "pseudo_normalize": "void decodeString(HuffmanNode *root, const char *encoded, char *decoded) {\n  char v3;\n  const char *v4;\n  HuffmanNode *v5;\n  int v6;\n  HuffmanNode *left;\n  long long v8;\n  v3 = *encoded;\n  if (*encoded) {\n    v4 = encoded + 1;\n    v5 = root;\n    v6 = 0;\n    do {\n      while (1) {\n        left = v5->left;\n        if (v3 != 48) left = v5->right;\n        v5 = left;\n        if (!left->left && !left->right) break;\n        v3 = *v4++;\n        if (!v3) goto LABEL_9;\n      }\n      v8 = v6;\n      ++v4;\n      ++v6;\n      decoded[v8] = left->data;\n      v3 = *(v4 - 1);\n      v5 = root;\n    } while (v3);\n  LABEL_9:\n    decoded += v6;\n  }\n  *decoded = 0;\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<decodeString>:\nendbr64\nmovzbl (%rsi),%ecx\ntest   %cl,%cl\nje     1a9e <decodeString+0x6e>\nadd    $0x1,%rsi\nmov    %rdi,%rax\nxor    %r9d,%r9d\njmp    1a5b <decodeString+0x2b>\nnopw   0x0(%rax,%rax,1)\nmovzbl (%rsi),%ecx\nadd    $0x1,%rsi\ntest   %cl,%cl\nje     1a98 <decodeString+0x68>\nmov    0x8(%rax),%r8\ncmp    $0x30,%cl\ncmovne 0x10(%rax),%r8\ncmpq   $0x0,0x8(%r8)\nmov    %r8,%rax\njne    1a50 <decodeString+0x20>\ncmpq   $0x0,0x10(%r8)\njne    1a50 <decodeString+0x20>\nmovzbl (%r8),%ecx\nmovslq %r9d,%rax\nadd    $0x1,%rsi\nadd    $0x1,%r9d\nmov    %cl,(%rdx,%rax,1)\nmovzbl -0x1(%rsi),%ecx\nmov    %rdi,%rax\ntest   %cl,%cl\njne    1a5b <decodeString+0x2b>\nnopl   (%rax)\nmovslq %r9d,%r9\nadd    %r9,%rdx\nmovb   $0x0,(%rdx)\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "encodeString", "content": "// Encode the input string using the generated Huffman codes\nvoid encodeString(const char* input, char codes[][MAX_TREE_HT], char* encoded) {\n    encoded[0] = '\\0';\n    for (int i = 0; input[i]; i++) {\n        libmin_strcat(encoded, codes[(unsigned char)input[i]]);\n    }\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "encodeString", "address": "0x19e0", "label": "encodeString", "content": "void __fastcall encodeString(const char *input, char (*codes)[256], char *encoded)\n{\n  __int64 v4; // rsi\n  const char *v6; // r12\n\n  *encoded = 0;\n  v4 = *(unsigned __int8 *)input;\n  if ( (_BYTE)v4 )\n  {\n    v6 = input + 1;\n    do\n    {\n      ++v6;\n      libmin_strcat(encoded, &(*codes)[256 * v4]);\n      v4 = *((unsigned __int8 *)v6 - 1);\n    }\n    while ( (_BYTE)v4 );\n  }\n}\n"}, "pseudo_normalize": "void encodeString(const char *input, char (*codes)[256], char *encoded) {\n  long long v4;\n  const char *v6;\n  *encoded = 0;\n  v4 = *(unsigned char *)input;\n  if ((uint8_t)v4) {\n    v6 = input + 1;\n    do {\n      ++v6;\n      libmin_strcat(encoded, &(*codes)[256 * v4]);\n      v4 = *((unsigned char *)v6 - 1);\n    } while ((uint8_t)v4);\n  }\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<encodeString>:\nendbr64\npush   %r12\nmovb   $0x0,(%rdx)\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nmovzbl (%rdi),%esi\ntest   %sil,%sil\nje     1a1e <encodeString+0x3e>\nmov    %rdx,%rbx\nlea    0x1(%rdi),%r12\nnopl   (%rax)\nshl    $0x8,%rsi\nmov    %rbx,%rdi\nadd    $0x1,%r12\nadd    %rbp,%rsi\ncall   34d0 <libmin_strcat>\nmovzbl -0x1(%r12),%esi\ntest   %sil,%sil\njne    1a00 <encodeString+0x20>\npop    %rbx\npop    %rbp\npop    %r12\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "extractMin", "content": "// Extract minimum node from heap\nHuffmanNode* extractMin(MinHeap* minHeap) {\n    HuffmanNode* temp = minHeap->array[0];\n    minHeap->array[0] = minHeap->array[minHeap->size - 1];\n    minHeap->size--;\n    minHeapify(minHeap, 0);\n    return temp;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "extractMin", "address": "0x16a0", "label": "extractMin", "content": "HuffmanNode *__fastcall extractMin(MinHeap *minHeap)\n{\n  HuffmanNode **array; // rdx\n  HuffmanNode *v2; // r12\n  int v3; // eax\n\n  array = minHeap->array;\n  v2 = *array;\n  v3 = minHeap->size - 1;\n  *array = array[minHeap->size - 1];\n  minHeap->size = v3;\n  minHeapify(minHeap, 0);\n  return v2;\n}\n"}, "pseudo_normalize": "HuffmanNode *extractMin(MinHeap *minHeap) {\n  HuffmanNode **array;\n  HuffmanNode *v2;\n  int v3;\n  array = minHeap->array;\n  v2 = *array;\n  v3 = minHeap->size - 1;\n  *array = array[minHeap->size - 1];\n  minHeap->size = v3;\n  minHeapify(minHeap, 0);\n  return v2;\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<extractMin>:\nendbr64\nmovslq (%rdi),%rcx\nmov    0x8(%rdi),%rdx\npush   %r12\nxor    %esi,%esi\nmov    %rcx,%rax\nmov    -0x8(%rdx,%rcx,8),%rcx\nmov    (%rdx),%r12\nsub    $0x1,%eax\nmov    %rcx,(%rdx)\nmov    %eax,(%rdi)\ncall   1600 <minHeapify>\nmov    %r12,%rax\npop    %r12\nret\nnopl   (%rax)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "generateCodes", "content": "// Recursively generate Huffman codes and store them in codes array\n// codes[c] will store the Huffman code (a string of '0's and '1's) for character c.\nvoid generateCodes(HuffmanNode* root, char arr[], int top, char codes[][MAX_TREE_HT]) {\n    if (root->left) {\n        arr[top] = '0';\n        generateCodes(root->left, arr, top + 1, codes);\n    }\n    if (root->right) {\n        arr[top] = '1';\n        generateCodes(root->right, arr, top + 1, codes);\n    }\n    // If node is a leaf, store the code\n    if (!root->left && !root->right) {\n        arr[top] = '\\0';\n        libmin_strcpy(codes[(unsigned char)root->data], arr);\n    }\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "generateCodes", "address": "0x1930", "label": "generateCodes", "content": "void __fastcall generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256])\n{\n  __int64 v4; // r14\n  int v6; // r12d\n\n  v4 = top;\n  if ( root->left )\n  {\n    arr[top] = 48;\n    v6 = top + 1;\n    generateCodes(root->left, arr, top + 1, codes);\n    if ( !root->right )\n    {\n      if ( root->left )\n        return;\nLABEL_7:\n      arr[v4] = 0;\n      libmin_strcpy(&(*codes)[256 * (unsigned __int64)(unsigned __int8)root->data], arr);\n      return;\n    }\n  }\n  else\n  {\n    v6 = top + 1;\n    if ( !root->right )\n      goto LABEL_7;\n  }\n  arr[v4] = 49;\n  generateCodes(root->right, arr, v6, codes);\n  if ( *(_OWORD *)&root->left == 0LL )\n    goto LABEL_7;\n}\n"}, "pseudo_normalize": "void generateCodes(HuffmanNode *root, char *arr, int top, char (*codes)[256]) {\n  long long v4;\n  int v6;\n  v4 = top;\n  if (root->left) {\n    arr[top] = 48;\n    v6 = top + 1;\n    generateCodes(root->left, arr, top + 1, codes);\n    if (!root->right) {\n      if (root->left) return;\n    LABEL_7:\n      arr[v4] = 0;\n      libmin_strcpy(\n          &(*codes)[256 * (unsigned long long)(unsigned char)root->data], arr);\n      return;\n    }\n  } else {\n    v6 = top + 1;\n    if (!root->right) goto LABEL_7;\n  }\n  arr[v4] = 49;\n  generateCodes(root->right, arr, v6, codes);\n  if (*(long double *)&root->left == 0LL) goto LABEL_7;\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<generateCodes>:\nendbr64\npush   %r14\nmovslq %edx,%r14\npush   %r13\nmov    %rcx,%r13\npush   %r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\ncmpq   $0x0,0x8(%rdi)\nmov    %rdi,%rbx\nje     1980 <generateCodes+0x50>\nmovb   $0x30,(%rsi,%r14,1)\nlea    0x1(%rdx),%r12d\nmov    0x8(%rdi),%rdi\nmov    %r12d,%edx\ncall   1930 <generateCodes>\ncmpq   $0x0,0x10(%rbx)\njne    198b <generateCodes+0x5b>\ncmpq   $0x0,0x8(%rbx)\nje     19b1 <generateCodes+0x81>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\ncmpq   $0x0,0x10(%rdi)\nlea    0x1(%rdx),%r12d\nje     19b1 <generateCodes+0x81>\nmovb   $0x31,0x0(%rbp,%r14,1)\nmov    0x10(%rbx),%rdi\nmov    %r13,%rcx\nmov    %r12d,%edx\nmov    %rbp,%rsi\ncall   1930 <generateCodes>\ncmpq   $0x0,0x8(%rbx)\njne    1972 <generateCodes+0x42>\ncmpq   $0x0,0x10(%rbx)\njne    1972 <generateCodes+0x42>\nmovb   $0x0,0x0(%rbp,%r14,1)\nmovzbl (%rbx),%eax\nmov    %rbp,%rsi\npop    %rbx\npop    %rbp\nshl    $0x8,%rax\npop    %r12\nlea    0x0(%r13,%rax,1),%rdi\npop    %r13\npop    %r14\njmp    3560 <libmin_strcpy>\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "insertMinHeap", "content": "// Insert a node into the min-heap\nvoid insertMinHeap(MinHeap* minHeap, HuffmanNode* node) {\n    ++minHeap->size;\n    int i = minHeap->size - 1;\n    while (i && node->freq < minHeap->array[(i - 1) / 2]->freq) {\n        minHeap->array[i] = minHeap->array[(i - 1) / 2];\n        i = (i - 1) / 2;\n    }\n    minHeap->array[i] = node;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "insertMinHeap", "address": "0x16d0", "label": "insertMinHeap", "content": "void __fastcall insertMinHeap(MinHeap *minHeap, HuffmanNode *node)\n{\n  int v2; // eax\n  HuffmanNode **array; // rdi\n  int freq; // r8d\n  HuffmanNode **v5; // rdx\n  HuffmanNode *v6; // rcx\n\n  v2 = minHeap->size++;\n  array = minHeap->array;\n  if ( v2 )\n  {\n    freq = node->freq;\n    while ( 1 )\n    {\n      v5 = &array[v2];\n      v2 = (v2 - 1) / 2;\n      v6 = array[v2];\n      if ( freq >= v6->freq )\n        break;\n      *v5 = v6;\n      if ( !v2 )\n        goto LABEL_6;\n    }\n    array = v5;\n  }\nLABEL_6:\n  *array = node;\n}\n"}, "pseudo_normalize": "void insertMinHeap(MinHeap *minHeap, HuffmanNode *node) {\n  int v2;\n  HuffmanNode **array;\n  int freq;\n  HuffmanNode **v5;\n  HuffmanNode *v6;\n  v2 = minHeap->size++;\n  array = minHeap->array;\n  if (v2) {\n    freq = node->freq;\n    while (1) {\n      v5 = &array[v2];\n      v2 = (v2 - 1) / 2;\n      v6 = array[v2];\n      if (freq >= v6->freq) break;\n      *v5 = v6;\n      if (!v2) goto LABEL_6;\n    }\n    array = v5;\n  }\nLABEL_6:\n  *array = node;\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<insertMinHeap>:\nendbr64\nmov    (%rdi),%eax\nlea    0x1(%rax),%edx\nmov    %edx,(%rdi)\nmov    0x8(%rdi),%rdi\ntest   %eax,%eax\nje     171a <insertMinHeap+0x4a>\nmov    0x4(%rsi),%r8d\njmp    16f7 <insertMinHeap+0x27>\nnopl   0x0(%rax)\nmov    %rcx,(%rdx)\ntest   %eax,%eax\nje     171a <insertMinHeap+0x4a>\nmovslq %eax,%rdx\nlea    -0x1(%rdx),%ecx\nlea    (%rdi,%rdx,8),%rdx\nmov    %ecx,%eax\nshr    $0x1f,%eax\nadd    %ecx,%eax\nsar    %eax\nmovslq %eax,%rcx\nmov    (%rdi,%rcx,8),%rcx\ncmp    0x4(%rcx),%r8d\njl     16f0 <insertMinHeap+0x20>\nmov    %rdx,%rdi\nmov    %rsi,(%rdi)\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "isSizeOne", "content": "// Check if heap size is one\nint isSizeOne(MinHeap* minHeap) {\n    return (minHeap->size == 1);\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "isSizeOne", "address": "0x1690", "label": "isSizeOne", "content": "int __fastcall isSizeOne(MinHeap *minHeap)\n{\n  return minHeap->size == 1;\n}\n"}, "pseudo_normalize": "", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<isSizeOne>:\nendbr64\nxor    %eax,%eax\ncmpl   $0x1,(%rdi)\nsete   %al\nret\nnopl   (%rax)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "main", "content": "int main() {\n    // Example input string to compress\n    char input[] = \"this is an example for huffman encoding\";\n    \n    // Count frequency of each character in input\n    int freq[256] = {0};\n    for (int i = 0; input[i]; i++) {\n        freq[(unsigned char)input[i]]++;\n    }\n    \n    // Create arrays for characters and their frequencies (for non-zero frequencies)\n    int unique = 0;\n    for (int i = 0; i < 256; i++)\n        if (freq[i])\n            unique++;\n    \n    char* characters = (char*)libmin_malloc(unique * sizeof(char));\n    int* frequencies = (int*)libmin_malloc(unique * sizeof(int));\n    \n    int index = 0;\n    for (int i = 0; i < 256; i++) {\n        if (freq[i]) {\n            characters[index] = (char)i;\n            frequencies[index] = freq[i];\n            index++;\n        }\n    }\n    \n    // Build Huffman Tree\n    HuffmanNode* root = buildHuffmanTree(characters, frequencies, unique);\n    \n    // Generate Huffman codes for characters\n    char codes[256][MAX_TREE_HT] = {{0}};\n    char arr[MAX_TREE_HT];\n    generateCodes(root, arr, 0, codes);\n    \n    // Print generated Huffman codes\n    libmin_printf(\"Huffman Codes:\\n\");\n    for (int i = 0; i < 256; i++) {\n        if (freq[i]) {\n            libmin_printf(\"'%c': %s\\n\", i, codes[i]);\n        }\n    }\n    \n    // Encode input string\n    char encoded[1024] = {0};\n    encodeString(input, codes, encoded);\n    libmin_printf(\"\\nEncoded string:\\n%s\\n\", encoded);\n    \n    // Report compression metrics:\n    int inputBits = libmin_strlen(input) * 8;         // Assuming 8 bits per char originally\n    int encodedBits = libmin_strlen(encoded);         // One character per bit in encoded string representation\n    libmin_printf(\"\\nCompression Metrics:\\n\");\n    libmin_printf(\"Original size: %d bits\\n\", inputBits);\n    libmin_printf(\"Encoded size: %d bits\\n\", encodedBits);\n    libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)encodedBits / inputBits * 100);\n    \n    // Decode the encoded string\n    char decoded[1024] = {0};\n    decodeString(root, encoded, decoded);\n    libmin_printf(\"\\nDecoded string:\\n%s\\n\", decoded);\n    \n    // Check that the decompressed string matches the original input\n    if (libmin_strcmp(input, decoded) == 0)\n        libmin_printf(\"\\nDecompression verified: decoded string matches the original input.\\n\");\n    else\n        libmin_printf(\"\\nError: decoded string does not match the original input.\\n\");\n    \n    // Free allocated memory for characters and frequencies\n    libmin_free(characters);\n    libmin_free(frequencies);\n    \n    // Note: In a complete implementation you should also free the Huffman tree nodes.\n\n    libmin_success();    \n    return 0;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "// positive sp value has been detected, the output may be wrong!\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // edx\n  char *v4; // rsi\n  unsigned __int8 v5; // cl\n  __int64 v6; // rax\n  unsigned __int8 v7; // di\n  char *v8; // rax\n  int v9; // r14d\n  int v10; // edx\n  char *v11; // r13\n  int *v12; // rax\n  int v13; // ecx\n  int *v14; // r12\n  __int64 v15; // rax\n  int v16; // edx\n  __int64 v17; // rsi\n  __int64 v18; // rbx\n  int i; // eax\n  __int64 v20; // rsi\n  __int64 v21; // rdx\n  int v22; // ebx\n  HuffmanNode *v23; // [rsp-1D98h] [rbp-12B28h]\n  int v24; // [rsp-1D8Ch] [rbp-12B1Ch]\n  _DWORD v25[256]; // [rsp-1D80h] [rbp-12B10h] BYREF\n  char v26[2376]; // [rsp-1980h] [rbp-12710h] BYREF\n  __int64 v27; // [rsp-1038h] [rbp-11DC8h] BYREF\n  __int64 v28; // [rsp-38h] [rbp-10DC8h] BYREF\n  char codes[256][256]; // [rsp+418h] [rbp-10978h] BYREF\n\n  while ( &v27 != &v28 - 0x2000 )\n    ;\n  v3 = 0;\n  *(_QWORD *)&codes[235][160] = __readfsqword(0x28u);\n  *(__m128i *)&codes[226][104] = _mm_load_si128((const __m128i *)&xmmword_4140);\n  strcpy(&codes[226][136], \"ncoding\");\n  memset(v25, 0, sizeof(v25));\n  v4 = &codes[226][106];\n  v5 = 104;\n  v6 = 116LL;\n  *(__m128i *)&codes[226][120] = _mm_load_si128((const __m128i *)&xmmword_4150);\n  while ( 1 )\n  {\n    v25[v6] = v3 + 1;\n    if ( !v5 )\n      break;\n    v7 = *v4++;\n    v3 = v25[v5];\n    v6 = v5;\n    v5 = v7;\n  }\n  v8 = (char *)&v25[1];\n  v9 = 0;\n  while ( v8 != v26 )\n  {\n    v10 = *(_DWORD *)v8;\n    v8 += 4;\n    v9 -= (v10 == 0) - 1;\n  }\n  v11 = (char *)libmin_malloc(v9);\n  v12 = (int *)libmin_malloc(4LL * v9);\n  v13 = 0;\n  v14 = v12;\n  v15 = 0LL;\n  while ( ++v15 != 256 )\n  {\n    while ( 1 )\n    {\n      v16 = v25[v15];\n      if ( !v16 )\n        break;\n      v17 = v13++;\n      v11[v17] = v15++;\n      v14[v17] = v16;\n      if ( v15 == 256 )\n        goto LABEL_12;\n    }\n  }\nLABEL_12:\n  v23 = buildHuffmanTree(v11, v14, v9);\n  memset(v26, 0, 0x10000uLL);\n  v18 = 0LL;\n  generateCodes(v23, &codes[226][152], 0, (char (*)[256])v26);\n  libmin_printf(\"Huffman Codes:\\n\");\n  for ( i = 0; ; i = v25[v18] )\n  {\n    v20 = (unsigned int)v18;\n    if ( i )\n    {\n      v21 = v18++;\n      libmin_printf(\"'%c': %s\\n\", v20, &v26[256 * v21]);\n      if ( v18 == 256 )\n      {\nLABEL_17:\n        *(_OWORD *)&codes[227][152] = 0LL;\n        memset(&codes[227][168], 0, 0x3F0uLL);\n        encodeString(&codes[226][104], (char (*)[256])v26, &codes[227][152]);\n        libmin_printf(\"\\nEncoded string:\\n%s\\n\", &codes[227][152]);\n        v22 = 8 * libmin_strlen(&codes[226][104]);\n        v24 = libmin_strlen(&codes[227][152]);\n        libmin_printf(\"\\nCompression Metrics:\\n\");\n        libmin_printf(\"Original size: %d bits\\n\", v22);\n        libmin_printf(\"Encoded size: %d bits\\n\", v24);\n        libmin_printf(\"Compression ratio: %.2f%%\\n\", (double)v24 / (double)v22 * 100.0);\n        *(_OWORD *)&codes[231][152] = 0LL;\n        memset(&codes[231][168], 0, 0x3F0uLL);\n        decodeString(v23, &codes[227][152], &codes[231][152]);\n        libmin_printf(\"\\nDecoded string:\\n%s\\n\", &codes[231][152]);\n        if ( libmin_strcmp(&codes[226][104], &codes[231][152]) )\n          libmin_printf(\"\\nError: decoded string does not match the original input.\\n\");\n        else\n          libmin_printf(\"\\nDecompression verified: decoded string matches the original input.\\n\");\n        libmin_free(v11);\n        libmin_free(v14);\n        libmin_success();\n      }\n    }\n    else if ( ++v18 == 256 )\n    {\n      goto LABEL_17;\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  char *v4;\n  unsigned char v5;\n  long long v6;\n  unsigned char v7;\n  char *v8;\n  int v9;\n  int v10;\n  char *v11;\n  int *v12;\n  int v13;\n  int *v14;\n  long long v15;\n  int v16;\n  long long v17;\n  long long v18;\n  int i;\n  long long v20;\n  long long v21;\n  int v22;\n  HuffmanNode *v23;\n  int v24;\n  uint32_t v25[256];\n  char v26[2376];\n  long long v27;\n  long long v28;\n  char codes[256][256];\n  while (&v27 != &v28 - 8192)\n    ;\n  v3 = 0;\n  *(uint64_t *)&codes[235][160] = __readfsqword(40u);\n  *(__m128i *)&codes[226][104] = _mm_load_si128((const __m128i *)&xmmword_4140);\n  strcpy(&codes[226][136], \"ncoding\");\n  memset(v25, 0, sizeof(v25));\n  v4 = &codes[226][106];\n  v5 = 104;\n  v6 = 116LL;\n  *(__m128i *)&codes[226][120] = _mm_load_si128((const __m128i *)&xmmword_4150);\n  while (1) {\n    v25[v6] = v3 + 1;\n    if (!v5) break;\n    v7 = *v4++;\n    v3 = v25[v5];\n    v6 = v5;\n    v5 = v7;\n  }\n  v8 = (char *)&v25[1];\n  v9 = 0;\n  while (v8 != v26) {\n    v10 = *(uint32_t *)v8;\n    v8 += 4;\n    v9 -= (v10 == 0) - 1;\n  }\n  v11 = (char *)libmin_malloc(v9);\n  v12 = (int *)libmin_malloc(4LL * v9);\n  v13 = 0;\n  v14 = v12;\n  v15 = 0LL;\n  while (++v15 != 256) {\n    while (1) {\n      v16 = v25[v15];\n      if (!v16) break;\n      v17 = v13++;\n      v11[v17] = v15++;\n      v14[v17] = v16;\n      if (v15 == 256) goto LABEL_12;\n    }\n  }\nLABEL_12:\n  v23 = buildHuffmanTree(v11, v14, v9);\n  memset(v26, 0, 65536uLL);\n  v18 = 0LL;\n  generateCodes(v23, &codes[226][152], 0, (char(*)[256])v26);\n  libmin_printf(\"Huffman Codes:\\n\");\n  for (i = 0;; i = v25[v18]) {\n    v20 = (unsigned int)v18;\n    if (i) {\n      v21 = v18++;\n      libmin_printf(\"'%c': %s\\n\", v20, &v26[256 * v21]);\n      if (v18 == 256) {\n      LABEL_17:\n        *(long double *)&codes[227][152] = 0LL;\n        memset(&codes[227][168], 0, 1008uLL);\n        encodeString(&codes[226][104], (char(*)[256])v26, &codes[227][152]);\n        libmin_printf(\"\\nEncoded string:\\n%s\\n\", &codes[227][152]);\n        v22 = 8 * libmin_strlen(&codes[226][104]);\n        v24 = libmin_strlen(&codes[227][152]);\n        libmin_printf(\"\\nCompression Metrics:\\n\");\n        libmin_printf(\"Original size: %d bits\\n\", v22);\n        libmin_printf(\"Encoded size: %d bits\\n\", v24);\n        libmin_printf(\"Compression ratio: %.2f%%\\n\",\n                      (double)v24 / (double)v22 * 100.0);\n        *(long double *)&codes[231][152] = 0LL;\n        memset(&codes[231][168], 0, 1008uLL);\n        decodeString(v23, &codes[227][152], &codes[231][152]);\n        libmin_printf(\"\\nDecoded string:\\n%s\\n\", &codes[231][152]);\n        if (libmin_strcmp(&codes[226][104], &codes[231][152]))\n          libmin_printf(\n              \"\\nError: decoded string does not match the original input.\\n\");\n        else\n          libmin_printf(\n              \"\\nDecompression verified: decoded string matches the original \"\n              \"input.\\n\");\n        libmin_free(v11);\n        libmin_free(v14);\n        libmin_success();\n      }\n    } else if (++v18 == 256) {\n      goto LABEL_17;\n    }\n  }\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    -0x10000(%rsp),%r11\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\ncmp    %r11,%rsp\njne    1136 <main+0x16>\nsub    $0xd68,%rsp\nmovdqa 0x2fea(%rip),%xmm0\nmov    $0x80,%ecx\nxor    %edx,%edx\nmov    %fs:0x28,%rax\nmov    %rax,0x10d58(%rsp)\nxor    %eax,%eax\nlea    0x20(%rsp),%rbp\nmovabs $0x676e69646f636e,%rax\nmovaps %xmm0,0x10420(%rsp)\nmovdqa 0x2fc1(%rip),%xmm0\nmov    %rax,0x10440(%rsp)\nmov    %rbp,%rdi\nxor    %eax,%eax\nrep stos %rax,%es:(%rdi)\nlea    0x10422(%rsp),%rsi\nmov    $0x68,%ecx\nmov    $0x74,%eax\nmovaps %xmm0,0x10430(%rsp)\njmp    11d3 <main+0xb3>\nnopl   0x0(%rax,%rax,1)\nmovzbl (%rsi),%edi\nmovzbl %cl,%eax\nadd    $0x1,%rsi\nmov    0x20(%rsp,%rax,4),%edx\nmovzbl %cl,%eax\nmov    %edi,%ecx\nadd    $0x1,%edx\nmov    %edx,0x20(%rsp,%rax,4)\ntest   %cl,%cl\njne    11c0 <main+0xa0>\nlea    0x24(%rsp),%rax\nlea    0x420(%rsp),%r15\nxor    %r14d,%r14d\njmp    11fd <main+0xdd>\nmov    (%rax),%edx\nadd    $0x4,%rax\ncmp    $0x1,%edx\nsbb    $0xffffffff,%r14d\ncmp    %r15,%rax\njne    11f0 <main+0xd0>\nmovslq %r14d,%rbx\nmov    %rbx,%rdi\ncall   1d20 <libmin_malloc>\nlea    0x0(,%rbx,4),%rdi\nmov    %rax,%r13\ncall   1d20 <libmin_malloc>\nxor    %ecx,%ecx\nmov    %rax,%r12\nxor    %eax,%eax\nnopl   0x0(%rax)\nadd    $0x1,%rax\ncmp    $0x100,%rax\nje     1257 <main+0x137>\nmov    0x0(%rbp,%rax,4),%edx\ntest   %edx,%edx\nje     1228 <main+0x108>\nmovslq %ecx,%rsi\nadd    $0x1,%ecx\nmov    %al,0x0(%r13,%rsi,1)\nadd    $0x1,%rax\nmov    %edx,(%r12,%rsi,4)\ncmp    $0x100,%rax\njne    1234 <main+0x114>\nmov    %r14d,%edx\nmov    %r12,%rsi\nlea    0x2db0(%rip),%r14\nmov    %r13,%rdi\ncall   1860 <buildHuffmanTree>\nmov    $0x10000,%edx\nxor    %esi,%esi\nmov    %r15,%rdi\nmov    %rax,%rbx\nmov    %rax,0x8(%rsp)\ncall   10d0 <memset@plt>\nmov    %rbx,%rdi\nmov    %r15,%rcx\nxor    %edx,%edx\nlea    0x10450(%rsp),%rsi\nxor    %ebx,%ebx\ncall   1930 <generateCodes>\nlea    0x2d63(%rip),%rdi\nxor    %eax,%eax\ncall   32c0 <libmin_printf>\nxor    %eax,%eax\njmp    12c1 <main+0x1a1>\nnopl   0x0(%rax)\nadd    $0x1,%rbx\ncmp    $0x100,%rbx\nje     12e8 <main+0x1c8>\nmov    0x0(%rbp,%rbx,4),%eax\nmov    %ebx,%esi\ntest   %eax,%eax\nje     12b0 <main+0x190>\nmov    %rbx,%rdx\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\nshl    $0x8,%rdx\nadd    %r15,%rdx\ncall   32c0 <libmin_printf>\ncmp    $0x100,%rbx\njne    12bd <main+0x19d>\nxor    %r9d,%r9d\nmov    $0x7e,%ecx\npxor   %xmm1,%xmm1\nmov    %r15,%rsi\nmov    %r9,%rax\nlea    0x10550(%rsp),%rbp\nlea    0x10420(%rsp),%r14\nmovaps %xmm1,0x10550(%rsp)\nlea    0x10560(%rsp),%rdi\nmov    %rbp,%rdx\nrep stos %rax,%es:(%rdi)\nmov    %r14,%rdi\ncall   19e0 <encodeString>\nmov    %rbp,%rsi\nlea    0x2cec(%rip),%rdi\nxor    %eax,%eax\ncall   32c0 <libmin_printf>\nmov    %r14,%rdi\ncall   3580 <libmin_strlen>\nmov    %rbp,%rdi\nlea    0x0(,%rax,8),%ebx\ncall   3580 <libmin_strlen>\nlea    0x2cdc(%rip),%rdi\nmov    %rax,0x18(%rsp)\nmov    %eax,0x14(%rsp)\nxor    %eax,%eax\ncall   32c0 <libmin_printf>\nmov    %ebx,%esi\nlea    0x2cda(%rip),%rdi\nxor    %eax,%eax\ncall   32c0 <libmin_printf>\nmov    0x14(%rsp),%esi\nlea    0x2ce0(%rip),%rdi\nxor    %eax,%eax\ncall   32c0 <libmin_printf>\nmov    0x18(%rsp),%rdx\npxor   %xmm0,%xmm0\npxor   %xmm2,%xmm2\ncvtsi2sd %ebx,%xmm2\nlea    0x2cd8(%rip),%rdi\nmov    $0x1,%eax\ncvtsi2sd %edx,%xmm0\nlea    0x10950(%rsp),%rbx\ndivsd  %xmm2,%xmm0\nmulsd  0x2d7a(%rip),%xmm0\ncall   32c0 <libmin_printf>\nxor    %eax,%eax\nmov    $0x7e,%ecx\npxor   %xmm1,%xmm1\nlea    0x10960(%rsp),%rdi\nmov    %rbx,%rdx\nmov    %rbp,%rsi\nmovaps %xmm1,0x10950(%rsp)\nrep stos %rax,%es:(%rdi)\nmov    0x8(%rsp),%rdi\ncall   1a30 <decodeString>\nmov    %rbx,%rsi\nlea    0x2c99(%rip),%rdi\nxor    %eax,%eax\ncall   32c0 <libmin_printf>\nmov    %rbx,%rsi\nmov    %r14,%rdi\ncall   3500 <libmin_strcmp>\ntest   %eax,%eax\njne    1459 <main+0x339>\nlea    0x2c98(%rip),%rdi\ncall   32c0 <libmin_printf>\nmov    %r13,%rdi\ncall   1dd0 <libmin_free>\nmov    %r12,%rdi\ncall   1dd0 <libmin_free>\ncall   35b0 <libmin_success>\nmov    0x10d58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1469 <main+0x349>\nadd    $0x10d68,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x2c98(%rip),%rdi\nxor    %eax,%eax\ncall   32c0 <libmin_printf>\njmp    141d <main+0x2fd>\ncall   10c0 <__stack_chk_fail@plt>\nxchg   %ax,%ax\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "minHeapify", "content": "// Heapify at given index (min-heap)\nvoid minHeapify(MinHeap* minHeap, int idx) {\n    int smallest = idx;\n    int left = 2 * idx + 1;\n    int right = 2 * idx + 2;\n    \n    if (left < minHeap->size && minHeap->array[left]->freq < minHeap->array[smallest]->freq)\n        smallest = left;\n    if (right < minHeap->size && minHeap->array[right]->freq < minHeap->array[smallest]->freq)\n        smallest = right;\n    if (smallest != idx) {\n        swapNodes(&minHeap->array[smallest], &minHeap->array[idx]);\n        minHeapify(minHeap, smallest);\n    }\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "minHeapify", "address": "0x1600", "label": "minHeapify", "content": "void __fastcall minHeapify(MinHeap *minHeap, int idx)\n{\n  int size; // r8d\n  HuffmanNode **array; // rcx\n  __int64 v5; // rdi\n  HuffmanNode **v6; // rdx\n  HuffmanNode **v7; // rcx\n  HuffmanNode *v8; // rsi\n  int v9; // eax\n  int v10; // edx\n\n  size = minHeap->size;\n  while ( 1 )\n  {\n    v9 = 2 * idx + 1;\n    v10 = 2 * idx + 2;\n    if ( size > v9 )\n    {\n      array = minHeap->array;\n      v5 = v9;\n      if ( array[v9]->freq < array[idx]->freq )\n      {\n        if ( size <= v10 )\n          goto LABEL_4;\n        goto LABEL_9;\n      }\n    }\n    if ( size <= v10 )\n      break;\n    array = minHeap->array;\n    v9 = idx;\n    v5 = idx;\nLABEL_9:\n    if ( array[v10]->freq < array[v5]->freq )\n      v9 = 2 * idx + 2;\nLABEL_4:\n    if ( v9 == idx )\n      return;\n    v6 = &array[idx];\n    v7 = &array[v9];\n    v8 = *v7;\n    *v7 = *v6;\n    *v6 = v8;\n    idx = v9;\n  }\n}\n"}, "pseudo_normalize": "void minHeapify(MinHeap *minHeap, int idx) {\n  int size;\n  HuffmanNode **array;\n  long long v5;\n  HuffmanNode **v6;\n  HuffmanNode **v7;\n  HuffmanNode *v8;\n  int v9;\n  int v10;\n  size = minHeap->size;\n  while (1) {\n    v9 = 2 * idx + 1;\n    v10 = 2 * idx + 2;\n    if (size > v9) {\n      array = minHeap->array;\n      v5 = v9;\n      if (array[v9]->freq < array[idx]->freq) {\n        if (size <= v10) goto LABEL_4;\n        goto LABEL_9;\n      }\n    }\n    if (size <= v10) break;\n    array = minHeap->array;\n    v9 = idx;\n    v5 = idx;\n  LABEL_9:\n    if (array[v10]->freq < array[v5]->freq) v9 = 2 * idx + 2;\n  LABEL_4:\n    if (v9 == idx) return;\n    v6 = &array[idx];\n    v7 = &array[v9];\n    v8 = *v7;\n    *v7 = *v6;\n    *v6 = v8;\n    idx = v9;\n  }\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<minHeapify>:\nendbr64\nmov    (%rdi),%r8d\nmov    %rdi,%r9\njmp    1651 <minHeapify+0x51>\nnopl   0x0(%rax)\nmov    0x8(%r9),%rcx\nmovslq %eax,%rdi\nmovslq %esi,%r10\nmov    (%rcx,%r10,8),%r10\nmov    (%rcx,%rdi,8),%r11\nmov    0x4(%r10),%r10d\ncmp    %r10d,0x4(%r11)\njge    165f <minHeapify+0x5f>\ncmp    %edx,%r8d\njg     166d <minHeapify+0x6d>\ncmp    %esi,%eax\nje     1688 <minHeapify+0x88>\nmovslq %esi,%rsi\nlea    (%rcx,%rsi,8),%rdx\nmovslq %eax,%rsi\nlea    (%rcx,%rsi,8),%rcx\nmov    (%rdx),%rdi\nmov    (%rcx),%rsi\nmov    %rdi,(%rcx)\nmov    %rsi,(%rdx)\nmov    %eax,%esi\nlea    (%rsi,%rsi,1),%edx\nlea    0x1(%rdx),%eax\nadd    $0x2,%edx\ncmp    %eax,%r8d\njg     1610 <minHeapify+0x10>\ncmp    %edx,%r8d\njle    1688 <minHeapify+0x88>\nmov    0x8(%r9),%rcx\nmov    %esi,%eax\nmovslq %esi,%rdi\nmovslq %edx,%r10\nmov    (%rcx,%rdi,8),%rdi\nmov    (%rcx,%r10,8),%r10\nmov    0x4(%rdi),%edi\ncmp    %edi,0x4(%r10)\ncmovl  %edx,%eax\njmp    1631 <minHeapify+0x31>\nnopl   0x0(%rax)\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "huff-encode/huff-encode.c", "function_name": "swapNodes", "content": "// Swap two Huffman nodes\nvoid swapNodes(HuffmanNode** a, HuffmanNode** b) {\n    HuffmanNode* temp = *a;\n    *a = *b;\n    *b = temp;\n}\n"}, "pseudo": {"path": "huff-encode/huff-encode.host.O2.pseudo", "function_name": "swapNodes", "address": "0x15e0", "label": "swapNodes", "content": "void __fastcall swapNodes(HuffmanNode **a, HuffmanNode **b)\n{\n  HuffmanNode *v2; // rax\n\n  v2 = *a;\n  *a = *b;\n  *b = v2;\n}\n"}, "pseudo_normalize": "void swapNodes(HuffmanNode **a, HuffmanNode **b) {\n  HuffmanNode *v2;\n  v2 = *a;\n  *a = *b;\n  *b = v2;\n}", "binary": "huff-encode/huff-encode.host.O2", "assembly": "<swapNodes>:\nendbr64\nmov    (%rdi),%rax\nmov    (%rsi),%rdx\nmov    %rdx,(%rdi)\nmov    %rax,(%rsi)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "idct-alg/idct-alg.c", "function_name": "C", "content": "#include \"libmin.h\"\n\n#define N 8\n#define PI 3.14159265358979323846\n\ndouble C(int u) {\n    return (u == 0) ? libmin_sqrt(1.0 / N) : libmin_sqrt(2.0 / N);\n}\n"}, "pseudo": {"path": "idct-alg/idct-alg.host.O2.pseudo", "function_name": "C", "address": "0x12c0", "label": "C", "content": "double __fastcall C(int u)\n{\n  double v1; // xmm1_8\n\n  return libmin_sqrt(v1);\n}\n"}, "pseudo_normalize": "", "binary": "idct-alg/idct-alg.host.O2", "assembly": "<C>:\nendbr64\ntest   %edi,%edi\njne    12d8 <C+0x18>\nmovsd  0x3d50(%rip),%xmm0\njmp    3110 <libmin_sqrt>\nnopl   (%rax)\nmovsd  0x3d48(%rip),%xmm0\njmp    3110 <libmin_sqrt>\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "idct-alg/idct-alg.c", "function_name": "idct_2d", "content": "void idct_2d(double input[N][N], double output[N][N]) {\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n            double sum = 0.0;\n            for (int u = 0; u < N; u++) {\n                for (int v = 0; v < N; v++) {\n                    sum += C(u) * C(v) * input[u][v] *\n                        libmin_cos(((2 * x + 1) * u * PI) / (2 * N)) *\n                        libmin_cos(((2 * y + 1) * v * PI) / (2 * N));\n                }\n            }\n            output[x][y] = sum;\n        }\n    }\n}\n"}, "pseudo": {"path": "idct-alg/idct-alg.host.O2.pseudo", "function_name": "idct_2d", "address": "0x12f0", "label": "idct_2d", "content": "void __fastcall idct_2d(double (*input)[8], double (*output)[8])\n{\n  double v2; // xmm1_8\n  int v3; // r14d\n  double *v4; // r13\n  int v5; // r15d\n  int j; // r12d\n  int v7; // ebp\n  __int64 v8; // rbx\n  double v9; // xmm0_8\n  double sum; // [rsp+8h] [rbp-70h]\n  double v11; // [rsp+10h] [rbp-68h]\n  double v12; // [rsp+10h] [rbp-68h]\n  int i; // [rsp+24h] [rbp-54h]\n  double *v14; // [rsp+28h] [rbp-50h]\n\n  for ( i = 1; i != 17; i += 2 )\n  {\n    v3 = 1;\n    v14 = (double *)output;\n    do\n    {\n      sum = 0.0;\n      v4 = (double *)input;\n      v5 = 0;\n      for ( j = 0; j != 8; ++j )\n      {\n        v7 = 0;\n        v8 = 0LL;\n        do\n        {\n          v11 = libmin_sqrt(v2);\n          v9 = libmin_sqrt(v2) * v11 * v4[v8++];\n          v7 += v3;\n          v12 = v9 * libmin_cos(v2);\n          sum = libmin_cos(v2) * v12 + sum;\n        }\n        while ( v8 != 8 );\n        v4 += 8;\n        v5 += i;\n      }\n      v3 += 2;\n      *v14++ = sum;\n    }\n    while ( v3 != 17 );\n    ++output;\n  }\n}\n"}, "pseudo_normalize": "void idct_2d(double (*input)[8], double (*output)[8]) {\n  double v2;\n  int v3;\n  double *v4;\n  int v5;\n  int j;\n  int v7;\n  long long v8;\n  double v9;\n  double sum;\n  double v11;\n  double v12;\n  int i;\n  double *v14;\n  for (i = 1; i != 17; i += 2) {\n    v3 = 1;\n    v14 = (double *)output;\n    do {\n      sum = 0.0;\n      v4 = (double *)input;\n      v5 = 0;\n      for (j = 0; j != 8; ++j) {\n        v7 = 0;\n        v8 = 0LL;\n        do {\n          v11 = libmin_sqrt(v2);\n          v9 = libmin_sqrt(v2) * v11 * v4[v8++];\n          v7 += v3;\n          v12 = v9 * libmin_cos(v2);\n          sum = libmin_cos(v2) * v12 + sum;\n        } while (v8 != 8);\n        v4 += 8;\n        v5 += i;\n      }\n      v3 += 2;\n      *v14++ = sum;\n    } while (v3 != 17);\n    ++output;\n  }\n}", "binary": "idct-alg/idct-alg.host.O2", "assembly": "<idct_2d>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    %rdi,0x30(%rsp)\nmov    %rsi,0x38(%rsp)\nmovl   $0x1,0x24(%rsp)\nmov    0x38(%rsp),%rax\nmov    $0x1,%r14d\nmov    %rax,0x28(%rsp)\nnopl   0x0(%rax)\nmovq   $0x0,0x8(%rsp)\nmov    0x30(%rsp),%r13\nxor    %r15d,%r15d\nxor    %r12d,%r12d\nnopl   0x0(%rax)\npxor   %xmm7,%xmm7\nxor    %ebp,%ebp\nxor    %ebx,%ebx\ncvtsi2sd %r15d,%xmm7\nmovsd  %xmm7,0x18(%rsp)\njmp    140f <idct_2d+0x11f>\nnopl   0x0(%rax,%rax,1)\nmov    0x3cb9(%rip),%rax\nmovq   %rax,%xmm0\ncall   3110 <libmin_sqrt>\nmovsd  %xmm0,0x10(%rsp)\ntest   %rbx,%rbx\njne    1438 <idct_2d+0x148>\nmov    0x3c99(%rip),%rax\nmovq   %rax,%xmm0\ncall   3110 <libmin_sqrt>\nmulsd  0x10(%rsp),%xmm0\nmovsd  0x3c91(%rip),%xmm2\nmulsd  0x0(%r13,%rbx,8),%xmm0\nadd    $0x1,%rbx\nmulsd  0x18(%rsp),%xmm2\nmovsd  %xmm0,0x10(%rsp)\nmovsd  0x3c7a(%rip),%xmm0\nmulsd  %xmm2,%xmm0\ncall   2e00 <libmin_cos>\nmovsd  0x10(%rsp),%xmm3\nmulsd  %xmm0,%xmm3\npxor   %xmm0,%xmm0\ncvtsi2sd %ebp,%xmm0\nmulsd  0x3c4f(%rip),%xmm0\nadd    %r14d,%ebp\nmulsd  0x3c4c(%rip),%xmm0\nmovsd  %xmm3,0x10(%rsp)\ncall   2e00 <libmin_cos>\nmulsd  0x10(%rsp),%xmm0\naddsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncmp    $0x8,%rbx\nje     1450 <idct_2d+0x160>\ntest   %r12d,%r12d\nje     1360 <idct_2d+0x70>\nmov    0x3c09(%rip),%rax\nmovq   %rax,%xmm0\ncall   3110 <libmin_sqrt>\nmovsd  %xmm0,0x10(%rsp)\ntest   %rbx,%rbx\nje     1380 <idct_2d+0x90>\nmov    0x3be9(%rip),%rax\nmovq   %rax,%xmm0\ncall   3110 <libmin_sqrt>\njmp    1391 <idct_2d+0xa1>\nxchg   %ax,%ax\nadd    $0x1,%r12d\nadd    $0x40,%r13\nadd    0x24(%rsp),%r15d\ncmp    $0x8,%r12d\njne    1340 <idct_2d+0x50>\nmov    0x28(%rsp),%rax\nmovsd  0x8(%rsp),%xmm7\nadd    $0x2,%r14d\nmovsd  %xmm7,(%rax)\nadd    $0x8,%rax\nmov    %rax,0x28(%rsp)\ncmp    $0x11,%r14d\njne    1328 <idct_2d+0x38>\naddl   $0x2,0x24(%rsp)\nmov    0x24(%rsp),%eax\naddq   $0x40,0x38(%rsp)\ncmp    $0x11,%eax\njne    1314 <idct_2d+0x24>\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "idct-alg/idct-alg.c", "function_name": "main", "content": "int main() {\n    // Example: DCT domain input (can be real JPEG coefficients)\n    double input[N][N] = {\n        {52, 0, 0, 0, 0, 0, 0, 0},\n        {30, 0, 0, 0, 0, 0, 0, 0},\n        {20, 0, 0, 0, 0, 0, 0, 0},\n        {10, 0, 0, 0, 0, 0, 0, 0},\n        { 5, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n        { 0, 0, 0, 0, 0, 0, 0, 0},\n    };\n\n    double output[N][N] = {0};\n\n    idct_2d(input, output);\n    print_matrix(output, \"IDCT Output\");\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "idct-alg/idct-alg.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double input[8][8]; // [rsp+0h] [rbp-418h] BYREF\n  double output[8][8]; // [rsp+200h] [rbp-218h] BYREF\n  unsigned __int64 v5; // [rsp+408h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[4][0] = 5.0;\n  input[3][0] = 10.0;\n  memset(output, 0, sizeof(output));\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double input[8][8];\n  double output[8][8];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  memset(input, 0, sizeof(input));\n  input[0][0] = 52.0;\n  input[4][0] = 5.0;\n  input[3][0] = 10.0;\n  memset(output, 0, sizeof(output));\n  input[1][0] = 30.0;\n  input[2][0] = 20.0;\n  idct_2d(input, output);\n  print_matrix(output, \"IDCT Output\");\n  libmin_success();\n}", "binary": "idct-alg/idct-alg.host.O2", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    $0x40,%ecx\nsub    $0x410,%rsp\nmov    0x3f28(%rip),%rdx\nmov    0x3f41(%rip),%rsi\nmov    %fs:0x28,%rax\nmov    %rax,0x408(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdi\nlea    0x200(%rsp),%rbp\nrep stos %rax,%es:(%rdi)\nmov    0x3f11(%rip),%rcx\nmov    %rdx,(%rsp)\nlea    0x200(%rsp),%rdi\nmov    0x3eee(%rip),%rdx\nmov    %rsi,0x100(%rsp)\nmov    %rbp,%rsi\nmov    %rcx,0xc0(%rsp)\nmov    $0x40,%ecx\nrep stos %rax,%es:(%rdi)\nmov    %rdx,0x40(%rsp)\nmov    0x3ecf(%rip),%rdx\nmov    %rsp,%rdi\nmov    %rdx,0x80(%rsp)\ncall   12f0 <idct_2d>\nlea    0x3e78(%rip),%rsi\nmov    %rbp,%rdi\ncall   14c0 <print_matrix>\ncall   3350 <libmin_success>\nmov    0x408(%rsp),%rax\nsub    %fs:0x28,%rax\njne    11c3 <main+0xc3>\nadd    $0x410,%rsp\nxor    %eax,%eax\npop    %rbp\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "idct-alg/idct-alg.c", "function_name": "print_matrix", "content": "void print_matrix(double mat[N][N], const char* label) {\n    libmin_printf(\"%s:\\n\", label);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++)\n            libmin_printf(\"%8.2f \", mat[i][j]);\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "idct-alg/idct-alg.host.O2.pseudo", "function_name": "print_matrix", "address": "0x14c0", "label": "print_matrix", "content": "void __fastcall print_matrix(double (*mat)[8], const char *label)\n{\n  double *v2; // rbp\n  double *v3; // rbx\n  double v4; // xmm0_8\n\n  v2 = &(*mat)[8];\n  libmin_printf(\"%s:\\n\", label);\n  do\n  {\n    v3 = v2 - 8;\n    do\n    {\n      v4 = *v3++;\n      libmin_printf(\"%8.2f \", v4);\n    }\n    while ( v3 != v2 );\n    v2 = v3 + 8;\n    libmin_printf((char *)\"\\n\");\n  }\n  while ( v3 + 8 != &(*mat)[72] );\n  libmin_printf((char *)\"\\n\");\n}\n"}, "pseudo_normalize": "void print_matrix(double (*mat)[8], const char *label) {\n  double *v2;\n  double *v3;\n  double v4;\n  v2 = &(*mat)[8];\n  libmin_printf(\"%s:\\n\", label);\n  do {\n    v3 = v2 - 8;\n    do {\n      v4 = *v3++;\n      libmin_printf(\"%8.2f \", v4);\n    } while (v3 != v2);\n    v2 = v3 + 8;\n    libmin_printf((char *)\"\\n\");\n  } while (v3 + 8 != &(*mat)[72]);\n  libmin_printf((char *)\"\\n\");\n}", "binary": "idct-alg/idct-alg.host.O2", "assembly": "<print_matrix>:\nendbr64\npush   %r14\nxor    %eax,%eax\nlea    0x3b38(%rip),%r14\npush   %r13\nmov    %rdi,%r13\nlea    0x3b29(%rip),%rdi\npush   %r12\nlea    0x3b25(%rip),%r12\npush   %rbp\nlea    0x40(%r13),%rbp\nadd    $0x240,%r13\npush   %rbx\ncall   2a90 <libmin_printf>\ncs nopw 0x0(%rax,%rax,1)\nlea    -0x40(%rbp),%rbx\nnopl   0x0(%rax)\nmovsd  (%rbx),%xmm0\nmov    %r12,%rdi\nmov    $0x1,%eax\nadd    $0x8,%rbx\ncall   2a90 <libmin_printf>\ncmp    %rbp,%rbx\njne    1508 <print_matrix+0x48>\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    0x40(%rbx),%rbp\ncall   2a90 <libmin_printf>\ncmp    %r13,%rbp\njne    1500 <print_matrix+0x40>\npop    %rbx\nmov    %r14,%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %r14\njmp    2a90 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "indirect-test/indirect-test.c", "function_name": "bar", "content": "void\nbar(int (*pfoo)(int x))\n{\n  // call a function through a pointer\n  aglobal = (*pfoo)(aglobal);\n\n  // and implement a switch statement\n  switch (aglobal & 0x7)\n  {\n  case 0:\n    aglobal++;\n    break;\n\n  case 1:\n    aglobal--;\n    break;\n\n  case 2:\n    aglobal *= 2;\n    break;\n\n  case 3:\n    aglobal /= 2;\n    break;\n\n  case 4:\n    aglobal %= 2;\n    break;\n\n  default:\n    aglobal = -aglobal;\n    break;\n  }\n}\n"}, "pseudo": {"path": "indirect-test/indirect-test.host.O2.pseudo", "function_name": "bar", "address": "0x1250", "label": "bar", "content": "void __fastcall bar(int (*pfoo)(int))\n{\n  int v1; // eax\n\n  v1 = pfoo(aglobal);\n  switch ( v1 & 7 )\n  {\n    case 0:\n      aglobal = v1 + 1;\n      break;\n    case 1:\n      aglobal = v1 - 1;\n      break;\n    case 2:\n      aglobal = 2 * v1;\n      break;\n    case 3:\n      aglobal = v1 / 2;\n      break;\n    case 4:\n      aglobal = v1 % 2;\n      break;\n    default:\n      aglobal = -v1;\n      break;\n  }\n}\n"}, "pseudo_normalize": "void bar(int (*pfoo)(int)) {\n  int v1;\n  v1 = pfoo(aglobal);\n  switch (v1 & 7) {\n    case 0:\n      aglobal = v1 + 1;\n      break;\n    case 1:\n      aglobal = v1 - 1;\n      break;\n    case 2:\n      aglobal = 2 * v1;\n      break;\n    case 3:\n      aglobal = v1 / 2;\n      break;\n    case 4:\n      aglobal = v1 % 2;\n      break;\n    default:\n      aglobal = -v1;\n      break;\n  }\n}", "binary": "indirect-test/indirect-test.host.O2", "assembly": "<bar>:\nendbr64\nsub    $0x8,%rsp\nmov    %rdi,%r8\nmov    0x3daf(%rip),%edi\ncall   *%r8\nmov    %eax,%edx\nand    $0x7,%edx\ncmp    $0x4,%edx\nja     12dd <bar+0x8d>\nlea    0x1d8f(%rip),%rcx\nmovslq (%rcx,%rdx,4),%rdx\nadd    %rcx,%rdx\nnotrack jmp *%rdx\nnop\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nsar    %eax\nmov    %eax,0x3d81(%rip)\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\nmov    %eax,%edx\nshr    $0x1f,%edx\nadd    %edx,%eax\nand    $0x1,%eax\nsub    %edx,%eax\nmov    %eax,0x3d66(%rip)\nadd    $0x8,%rsp\nret\nnop\nadd    $0x1,%eax\nmov    %eax,0x3d57(%rip)\nadd    $0x8,%rsp\nret\nxchg   %ax,%ax\nsub    $0x1,%eax\nmov    %eax,0x3d47(%rip)\nadd    $0x8,%rsp\nret\nxchg   %ax,%ax\nadd    %eax,%eax\nmov    %eax,0x3d38(%rip)\nadd    $0x8,%rsp\nret\nneg    %eax\nmov    %eax,0x3d2b(%rip)\nadd    $0x8,%rsp\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "indirect-test/indirect-test.c", "function_name": "foo", "content": "int\nfoo(int x)\n{\n  return x*x;\n}\n"}, "pseudo": {"path": "indirect-test/indirect-test.host.O2.pseudo", "function_name": "foo", "address": "0x1240", "label": "foo", "content": "int __fastcall foo(int x)\n{\n  return x * x;\n}\n"}, "pseudo_normalize": "", "binary": "indirect-test/indirect-test.host.O2", "assembly": "<foo>:\nendbr64\nmov    %edi,%eax\nimul   %edi,%eax\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "indirect-test/indirect-test.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int (*pfoo)(int) = &foo;\n  (*pbar)(pfoo);\n  (*pbar)(pfoo);\n  (*pbar)(pfoo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "indirect-test/indirect-test.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  pbar(foo);\n  pbar(foo);\n  pbar(foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  pbar(foo);\n  pbar(foo);\n  pbar(foo);\n  libmin_printf(\"aglobal = %d\\n\", aglobal);\n  libmin_success();\n}", "binary": "indirect-test/indirect-test.host.O2", "assembly": "<main>:\nendbr64\npush   %rbp\nlea    0x134(%rip),%rbp\nmov    %rbp,%rdi\ncall   *0x3f03(%rip)\nmov    %rbp,%rdi\ncall   *0x3efa(%rip)\nmov    %rbp,%rdi\ncall   *0x3ef1(%rip)\nmov    0x3ee3(%rip),%esi\nlea    0x1ee4(%rip),%rdi\nxor    %eax,%eax\ncall   2830 <libmin_printf>\ncall   2a70 <libmin_success>\nxor    %eax,%eax\npop    %rbp\nret\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "calculateCentroid", "content": "/*!\n * Calculate centoid and assign it to the cluster variable\n *\n * @param observations  an array of observations whose centroid is calculated\n * @param size  size of the observations array\n * @param centroid  a reference to cluster object to store information of\n * centroid\n */\nvoid calculateCentroid(observation observations[], size_t size,\n                       cluster* centroid)\n{\n    size_t i = 0;\n    centroid->x = 0;\n    centroid->y = 0;\n    centroid->count = size;\n    for (; i < size; i++)\n    {\n        centroid->x += observations[i].x;\n        centroid->y += observations[i].y;\n        observations[i].group = 0;\n    }\n    centroid->x /= centroid->count;\n    centroid->y /= centroid->count;\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O2.pseudo", "function_name": "calculateCentroid", "address": "0x1390", "label": "calculateCentroid", "content": "void __fastcall calculateCentroid(observation *observations, size_t size, cluster *centroid)\n{\n  double v3; // xmm0_8\n  observation *v4; // rax\n  double v5; // xmm1_8\n\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->count = size;\n  if ( size )\n  {\n    v3 = 0.0;\n    v4 = observations;\n    v5 = 0.0;\n    do\n    {\n      v5 = v5 + v4->x;\n      v3 = v3 + v4->y;\n      v4->group = 0;\n      ++v4;\n    }\n    while ( &observations[size] != v4 );\n    observations[size - 1].group = 0;\n  }\n  else\n  {\n    v3 = 0.0;\n    v5 = 0.0;\n  }\n  centroid->x = v5 / (double)(int)size;\n  centroid->y = v3 / (double)(int)size;\n}\n"}, "pseudo_normalize": "void calculateCentroid(observation *observations, unsigned int size,\n                       cluster *centroid) {\n  double v3;\n  observation *v4;\n  double v5;\n  centroid->x = 0.0;\n  centroid->y = 0.0;\n  centroid->count = size;\n  if (size) {\n    v3 = 0.0;\n    v4 = observations;\n    v5 = 0.0;\n    do {\n      v5 = v5 + v4->x;\n      v3 = v3 + v4->y;\n      v4->group = 0;\n      ++v4;\n    } while (&observations[size] != v4);\n    observations[size - 1].group = 0;\n  } else {\n    v3 = 0.0;\n    v5 = 0.0;\n  }\n  centroid->x = v5 / (double)(int)size;\n  centroid->y = v3 / (double)(int)size;\n}", "binary": "k-means/k-means.host.O2", "assembly": "<calculateCentroid>:\nendbr64\nmovq   $0x0,(%rdx)\nmovq   $0x0,0x8(%rdx)\nmov    %rsi,0x10(%rdx)\ntest   %rsi,%rsi\nje     1408 <calculateCentroid+0x78>\nlea    (%rsi,%rsi,2),%r8\npxor   %xmm0,%xmm0\nmov    %rdi,%rax\nshl    $0x3,%r8\nmovapd %xmm0,%xmm1\nlea    (%rdi,%r8,1),%rcx\nnopl   0x0(%rax,%rax,1)\naddsd  (%rax),%xmm1\naddsd  0x8(%rax),%xmm0\nmovl   $0x0,0x10(%rax)\nadd    $0x18,%rax\ncmp    %rax,%rcx\njne    13c8 <calculateCentroid+0x38>\nmovl   $0x0,-0x8(%rdi,%r8,1)\npxor   %xmm2,%xmm2\ncvtsi2sd %rsi,%xmm2\ndivsd  %xmm2,%xmm1\ndivsd  %xmm2,%xmm0\nmovsd  %xmm1,(%rdx)\nmovsd  %xmm0,0x8(%rdx)\nret\nnopl   (%rax)\npxor   %xmm0,%xmm0\nmovapd %xmm0,%xmm1\njmp    13ea <calculateCentroid+0x5a>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "calculateNearst", "content": "/*!\n * Returns the index of centroid nearest to\n * given observation\n *\n * @param o  observation\n * @param clusters  array of cluster having centroids coordinates\n * @param k  size of clusters array\n *\n * @returns the index of nearest centroid for given observation\n */\nint calculateNearst(observation* o, cluster clusters[], int k)\n{\n    double minD = DBL_MAX;\n    double dist = 0;\n    int index = -1;\n    int i = 0;\n    for (; i < k; i++)\n    {\n        /* Calculate Squared Distance*/\n        dist = (clusters[i].x - o->x) * (clusters[i].x - o->x) +\n               (clusters[i].y - o->y) * (clusters[i].y - o->y);\n        if (dist < minD)\n        {\n            minD = dist;\n            index = i;\n        }\n    }\n    return index;\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O2.pseudo", "function_name": "calculateNearst", "address": "0x1310", "label": "calculateNearst", "content": "int __fastcall calculateNearst(observation *o, cluster *clusters, int k)\n{\n  int v3; // eax\n  int v4; // r8d\n  double v5; // xmm2_8\n  double v6; // xmm0_8\n  bool v7; // cc\n  double v8; // xmm0_8\n\n  if ( k <= 0 )\n    return -1;\n  v3 = 0;\n  v4 = -1;\n  v5 = 1.797693134862316e308;\n  do\n  {\n    v6 = (clusters->x - o->x) * (clusters->x - o->x) + (clusters->y - o->y) * (clusters->y - o->y);\n    v7 = v5 <= v6;\n    v8 = fmin(v6, v5);\n    if ( !v7 )\n      v4 = v3;\n    ++v3;\n    v5 = v8;\n    ++clusters;\n  }\n  while ( k != v3 );\n  return v4;\n}\n"}, "pseudo_normalize": "int calculateNearst(observation *o, cluster *clusters, int k) {\n  int v3;\n  int v4;\n  double v5;\n  double v6;\n  bool v7;\n  double v8;\n  if (k <= 0) return -1;\n  v3 = 0;\n  v4 = -1;\n  v5 = 1.797693134862316e308;\n  do {\n    v6 = (clusters->x - o->x) * (clusters->x - o->x) +\n         (clusters->y - o->y) * (clusters->y - o->y);\n    v7 = v5 <= v6;\n    v8 = fmin(v6, v5);\n    if (!v7) v4 = v3;\n    ++v3;\n    v5 = v8;\n    ++clusters;\n  } while (k != v3);\n  return v4;\n}", "binary": "k-means/k-means.host.O2", "assembly": "<calculateNearst>:\nendbr64\ntest   %edx,%edx\njle    1378 <calculateNearst+0x68>\nmovsd  (%rdi),%xmm4\nmovsd  0x8(%rdi),%xmm3\nxor    %eax,%eax\nmov    $0xffffffff,%r8d\nmovsd  0x3e47(%rip),%xmm2\nnopl   0x0(%rax)\nmovsd  (%rsi),%xmm0\nmovsd  0x8(%rsi),%xmm1\nsubsd  %xmm4,%xmm0\nsubsd  %xmm3,%xmm1\nmulsd  %xmm0,%xmm0\nmulsd  %xmm1,%xmm1\naddsd  %xmm1,%xmm0\ncomisd %xmm0,%xmm2\nminsd  %xmm2,%xmm0\ncmova  %eax,%r8d\nadd    $0x1,%eax\nmovapd %xmm0,%xmm2\nadd    $0x18,%rsi\ncmp    %eax,%edx\njne    1338 <calculateNearst+0x28>\nmov    %r8d,%eax\nret\nnopl   0x0(%rax)\nmov    $0xffffffff,%r8d\nmov    %r8d,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "kMeans", "content": "/*!\n *    --K Means Algorithm--\n * 1. Assign each observation to one of k groups\n *    creating a random initial clustering\n * 2. Find the centroid of observations for each\n *    cluster to form new centroids\n * 3. Find the centroid which is nearest for each\n *    observation among the calculated centroids\n * 4. Assign the observation to its nearest centroid\n *    to create a new clustering.\n * 5. Repeat step 2,3,4 until there is no change\n *    the current clustering and is same as last\n *    clustering.\n *\n * @param observations  an array of observations to cluster\n * @param size  size of observations array\n * @param k  no of clusters to be made\n *\n * @returns pointer to cluster object\n */\ncluster* kMeans(observation observations[], size_t size, int k)\n{\n    cluster* clusters = NULL;\n    if (k <= 1)\n    {\n        /*\n        If we have to cluster them only in one group\n        then calculate centroid of observations and\n        that will be a ingle cluster\n        */\n        clusters = (cluster*)libmin_malloc(sizeof(cluster));\n        libmin_memset(clusters, 0, sizeof(cluster));\n        calculateCentroid(observations, size, clusters);\n    }\n    else if (k < size)\n    {\n        clusters = libmin_malloc(sizeof(cluster) * k);\n        libmin_memset(clusters, 0, k * sizeof(cluster));\n        /* STEP 1 */\n        for (size_t j = 0; j < size; j++)\n        {\n            observations[j].group = libmin_rand() % k;\n        }\n        size_t changed = 0;\n        size_t minAcceptedError =\n            size /\n            10000;  // Do until 99.99 percent points are in correct cluster\n        int t = 0;\n        do\n        {\n            /* Initialize clusters */\n            for (int i = 0; i < k; i++)\n            {\n                clusters[i].x = 0;\n                clusters[i].y = 0;\n                clusters[i].count = 0;\n            }\n            /* STEP 2*/\n            for (size_t j = 0; j < size; j++)\n            {\n                t = observations[j].group;\n                clusters[t].x += observations[j].x;\n                clusters[t].y += observations[j].y;\n                clusters[t].count++;\n            }\n            for (int i = 0; i < k; i++)\n            {\n                clusters[i].x /= clusters[i].count;\n                clusters[i].y /= clusters[i].count;\n            }\n            /* STEP 3 and 4 */\n            changed = 0;  // this variable stores change in clustering\n            for (size_t j = 0; j < size; j++)\n            {\n                t = calculateNearst(observations + j, clusters, k);\n                if (t != observations[j].group)\n                {\n                    changed++;\n                    observations[j].group = t;\n                }\n            }\n        } while (changed > minAcceptedError);  // Keep on grouping until we have\n                                               // got almost best clustering\n    }\n    else\n    {\n        /* If no of clusters is more than observations\n           each observation can be its own cluster\n        */\n        clusters = (cluster*)libmin_malloc(sizeof(cluster) * k);\n        libmin_memset(clusters, 0, k * sizeof(cluster));\n        for (int j = 0; j < size; j++)\n        {\n            clusters[j].x = observations[j].x;\n            clusters[j].y = observations[j].y;\n            clusters[j].count = 1;\n            observations[j].group = j;\n        }\n    }\n    return clusters;\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O2.pseudo", "function_name": "kMeans", "address": "0x1420", "label": "kMeans", "content": "cluster *__fastcall kMeans(observation *observations, size_t size, int k)\n{\n  observation *v4; // rbp\n  size_t v6; // r14\n  cluster *v7; // r12\n  cluster *v8; // rax\n  int v9; // edx\n  double v10; // xmm0_8\n  double y; // xmm0_8\n  cluster *v13; // rax\n  size_t v14; // rdx\n  int *p_group; // r15\n  __int64 v16; // r14\n  cluster *v17; // r8\n  observation *v18; // rdi\n  cluster *v19; // rax\n  observation *v20; // rdx\n  __int64 group; // rax\n  cluster *v22; // rax\n  double v23; // xmm0_8\n  cluster *v24; // rax\n  double v25; // xmm0_8\n  double x; // xmm1_8\n  __int64 count; // rdx\n  __int64 v28; // rcx\n  observation *v29; // rsi\n  size_t v30; // r10\n  double *p_x; // rdx\n  double v32; // xmm2_8\n  int v33; // ecx\n  int v34; // eax\n  double v35; // xmm0_8\n  bool v36; // cc\n  double v37; // xmm0_8\n\n  v4 = observations;\n  if ( k <= 1 )\n  {\n    v7 = (cluster *)libmin_malloc(0x18uLL);\n    libmin_memset(v7, 0, 0x18uLL);\n    calculateCentroid(observations, size, v7);\n  }\n  else\n  {\n    v6 = 24LL * k;\n    if ( k < size )\n    {\n      v13 = (cluster *)libmin_malloc(v6);\n      v14 = v6;\n      p_group = &observations->group;\n      v7 = v13;\n      v16 = 0LL;\n      libmin_memset(v13, 0, v14);\n      do\n      {\n        ++v16;\n        p_group += 6;\n        *(p_group - 6) = libmin_rand() % k;\n      }\n      while ( size != v16 );\n      v17 = &v7[k];\n      v18 = &observations[size];\n      do\n      {\n        v19 = v7;\n        do\n        {\n          v19->x = 0.0;\n          ++v19;\n          v19[-1].y = 0.0;\n          v19[-1].count = 0LL;\n        }\n        while ( v17 != v19 );\n        v20 = v4;\n        do\n        {\n          group = v20->group;\n          ++v20;\n          v22 = &v7[group];\n          v22->x = v22->x + v20[-1].x;\n          v23 = v22->y + v20[-1].y;\n          ++v22->count;\n          v22->y = v23;\n        }\n        while ( v18 != v20 );\n        v24 = v7;\n        do\n        {\n          count = v24->count;\n          if ( count >= 0 )\n          {\n            v25 = (double)(int)count;\n          }\n          else\n          {\n            v28 = v24->count & 1 | (v24->count >> 1);\n            v25 = (double)(int)v28 + (double)(int)v28;\n          }\n          x = v24->x;\n          ++v24;\n          v24[-1].x = x / v25;\n          v24[-1].y = v24[-1].y / v25;\n        }\n        while ( v17 != v24 );\n        v29 = v4;\n        v30 = 0LL;\n        do\n        {\n          p_x = &v7->x;\n          v32 = 1.797693134862316e308;\n          v33 = -1;\n          v34 = 0;\n          do\n          {\n            v35 = (*p_x - v29->x) * (*p_x - v29->x) + (p_x[1] - v29->y) * (p_x[1] - v29->y);\n            v36 = v32 <= v35;\n            v37 = fmin(v35, v32);\n            if ( !v36 )\n              v33 = v34;\n            ++v34;\n            v32 = v37;\n            p_x += 3;\n          }\n          while ( k != v34 );\n          if ( v29->group != v33 )\n          {\n            v29->group = v33;\n            ++v30;\n          }\n          ++v29;\n        }\n        while ( v18 != v29 );\n      }\n      while ( v30 > size / 0x2710 );\n    }\n    else\n    {\n      v7 = (cluster *)libmin_malloc(v6);\n      libmin_memset(v7, 0, v6);\n      if ( size )\n      {\n        v8 = v7;\n        v9 = 0;\n        do\n        {\n          v10 = v4->x;\n          ++v8;\n          ++v4;\n          v8[-1].x = v10;\n          y = v4[-1].y;\n          v8[-1].count = 1LL;\n          v8[-1].y = y;\n          v4[-1].group = v9++;\n        }\n        while ( (_DWORD)size != v9 );\n      }\n    }\n  }\n  return v7;\n}\n"}, "pseudo_normalize": "cluster *kMeans(observation *observations, unsigned int size, int k) {\n  observation *v4;\n  unsigned int v6;\n  cluster *v7;\n  cluster *v8;\n  int v9;\n  double v10;\n  double y;\n  cluster *v13;\n  unsigned int v14;\n  int *p_group;\n  long long v16;\n  cluster *v17;\n  observation *v18;\n  cluster *v19;\n  observation *v20;\n  long long group;\n  cluster *v22;\n  double v23;\n  cluster *v24;\n  double v25;\n  double x;\n  long long count;\n  long long v28;\n  observation *v29;\n  unsigned int v30;\n  double *p_x;\n  double v32;\n  int v33;\n  int v34;\n  double v35;\n  bool v36;\n  double v37;\n  v4 = observations;\n  if (k <= 1) {\n    v7 = (cluster *)libmin_malloc(24uLL);\n    libmin_memset(v7, 0, 24uLL);\n    calculateCentroid(observations, size, v7);\n  } else {\n    v6 = 24LL * k;\n    if (k < size) {\n      v13 = (cluster *)libmin_malloc(v6);\n      v14 = v6;\n      p_group = &observations->group;\n      v7 = v13;\n      v16 = 0LL;\n      libmin_memset(v13, 0, v14);\n      do {\n        ++v16;\n        p_group += 6;\n        *(p_group - 6) = libmin_rand() % k;\n      } while (size != v16);\n      v17 = &v7[k];\n      v18 = &observations[size];\n      do {\n        v19 = v7;\n        do {\n          v19->x = 0.0;\n          ++v19;\n          v19[-1].y = 0.0;\n          v19[-1].count = 0LL;\n        } while (v17 != v19);\n        v20 = v4;\n        do {\n          group = v20->group;\n          ++v20;\n          v22 = &v7[group];\n          v22->x = v22->x + v20[-1].x;\n          v23 = v22->y + v20[-1].y;\n          ++v22->count;\n          v22->y = v23;\n        } while (v18 != v20);\n        v24 = v7;\n        do {\n          count = v24->count;\n          if (count >= 0) {\n            v25 = (double)(int)count;\n          } else {\n            v28 = v24->count & 1 | (v24->count >> 1);\n            v25 = (double)(int)v28 + (double)(int)v28;\n          }\n          x = v24->x;\n          ++v24;\n          v24[-1].x = x / v25;\n          v24[-1].y = v24[-1].y / v25;\n        } while (v17 != v24);\n        v29 = v4;\n        v30 = 0LL;\n        do {\n          p_x = &v7->x;\n          v32 = 1.797693134862316e308;\n          v33 = -1;\n          v34 = 0;\n          do {\n            v35 = (*p_x - v29->x) * (*p_x - v29->x) +\n                  (p_x[1] - v29->y) * (p_x[1] - v29->y);\n            v36 = v32 <= v35;\n            v37 = fmin(v35, v32);\n            if (!v36) v33 = v34;\n            ++v34;\n            v32 = v37;\n            p_x += 3;\n          } while (k != v34);\n          if (v29->group != v33) {\n            v29->group = v33;\n            ++v30;\n          }\n          ++v29;\n        } while (v18 != v29);\n      } while (v30 > size / 10000);\n    } else {\n      v7 = (cluster *)libmin_malloc(v6);\n      libmin_memset(v7, 0, v6);\n      if (size) {\n        v8 = v7;\n        v9 = 0;\n        do {\n          v10 = v4->x;\n          ++v8;\n          ++v4;\n          v8[-1].x = v10;\n          y = v4[-1].y;\n          v8[-1].count = 1LL;\n          v8[-1].y = y;\n          v4[-1].group = v9++;\n        } while ((uint32_t)size != v9);\n      }\n    }\n  }\n  return v7;\n}", "binary": "k-means/k-means.host.O2", "assembly": "<kMeans>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x8,%rsp\ncmp    $0x1,%edx\njle    167a <kMeans+0x25a>\nmovslq %edx,%rax\nmov    %edx,%ebx\nlea    (%rax,%rax,2),%r14\nshl    $0x3,%r14\nmov    %r14,%rdi\ncmp    %rsi,%rax\njb     14b9 <kMeans+0x99>\ncall   1d60 <libmin_malloc>\nxor    %esi,%esi\nmov    %r14,%rdx\nmov    %rax,%rdi\nmov    %rax,%r12\ncall   1f30 <libmin_memset>\ntest   %r13,%r13\nje     14a7 <kMeans+0x87>\nmov    %r12,%rax\nxor    %edx,%edx\nnopl   (%rax)\nmovsd  0x0(%rbp),%xmm0\nadd    $0x18,%rax\nadd    $0x18,%rbp\nmovsd  %xmm0,-0x18(%rax)\nmovsd  -0x10(%rbp),%xmm0\nmovq   $0x1,-0x8(%rax)\nmovsd  %xmm0,-0x10(%rax)\nmov    %edx,-0x8(%rbp)\nadd    $0x1,%edx\ncmp    %edx,%r13d\njne    1478 <kMeans+0x58>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   1d60 <libmin_malloc>\nmov    %r14,%rdx\nxor    %esi,%esi\nlea    0x10(%rbp),%r15\nmov    %rax,%rdi\nmov    %rax,%r12\nxor    %r14d,%r14d\ncall   1f30 <libmin_memset>\nnopl   (%rax)\ncall   3570 <libmin_rand>\nxor    %edx,%edx\nadd    $0x1,%r14\nadd    $0x18,%r15\ndiv    %ebx\nmov    %edx,-0x18(%r15)\ncmp    %r14,%r13\njne    14d8 <kMeans+0xb8>\nmov    %r13,%rax\nmovsd  0x3c7b(%rip),%xmm5\nmovabs $0x346dc5d63886594b,%rdx\nmul    %rdx\nmov    %ebx,%eax\nlea    (%rax,%rax,2),%rax\nlea    (%r12,%rax,8),%r8\nlea    0x0(%r13,%r13,2),%rax\nshr    $0xb,%rdx\nlea    0x0(%rbp,%rax,8),%rdi\nmov    %rdx,%r9\nnopl   (%rax)\nmov    %r12,%rax\nnopl   0x0(%rax,%rax,1)\nmovq   $0x0,(%rax)\nadd    $0x18,%rax\nmovq   $0x0,-0x10(%rax)\nmovq   $0x0,-0x8(%rax)\ncmp    %rax,%r8\njne    1530 <kMeans+0x110>\nmov    %rbp,%rdx\nnopl   0x0(%rax,%rax,1)\nmovslq 0x10(%rdx),%rax\nadd    $0x18,%rdx\nlea    (%rax,%rax,2),%rax\nlea    (%r12,%rax,8),%rax\nmovsd  (%rax),%xmm0\naddsd  -0x18(%rdx),%xmm0\nmovsd  %xmm0,(%rax)\nmovsd  0x8(%rax),%xmm0\naddsd  -0x10(%rdx),%xmm0\naddq   $0x1,0x10(%rax)\nmovsd  %xmm0,0x8(%rax)\ncmp    %rdx,%rdi\njne    1558 <kMeans+0x138>\nmov    %r12,%rax\njmp    15c5 <kMeans+0x1a5>\nnopl   0x0(%rax,%rax,1)\npxor   %xmm0,%xmm0\ncvtsi2sd %rdx,%xmm0\nmovsd  (%rax),%xmm1\nadd    $0x18,%rax\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,-0x18(%rax)\nmovsd  -0x10(%rax),%xmm1\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,-0x10(%rax)\ncmp    %rax,%r8\nje     15f0 <kMeans+0x1d0>\nmov    0x10(%rax),%rdx\ntest   %rdx,%rdx\njns    1598 <kMeans+0x178>\nmov    %rdx,%rcx\nand    $0x1,%edx\npxor   %xmm0,%xmm0\nshr    %rcx\nor     %rdx,%rcx\ncvtsi2sd %rcx,%xmm0\naddsd  %xmm0,%xmm0\njmp    15a1 <kMeans+0x181>\nnopl   0x0(%rax)\nmov    %rbp,%rsi\nxor    %r10d,%r10d\ncs nopw 0x0(%rax,%rax,1)\nmovsd  (%rsi),%xmm4\nmovsd  0x8(%rsi),%xmm3\nmov    %r12,%rdx\nmovapd %xmm5,%xmm2\nmov    $0xffffffff,%ecx\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmovsd  (%rdx),%xmm0\nmovsd  0x8(%rdx),%xmm1\nsubsd  %xmm4,%xmm0\nsubsd  %xmm3,%xmm1\nmulsd  %xmm0,%xmm0\nmulsd  %xmm1,%xmm1\naddsd  %xmm1,%xmm0\ncomisd %xmm0,%xmm2\nminsd  %xmm2,%xmm0\ncmova  %eax,%ecx\nadd    $0x1,%eax\nmovapd %xmm0,%xmm2\nadd    $0x18,%rdx\ncmp    %eax,%ebx\njne    1620 <kMeans+0x200>\ncmp    %ecx,0x10(%rsi)\nje     1663 <kMeans+0x243>\nmov    %ecx,0x10(%rsi)\nadd    $0x1,%r10\nadd    $0x18,%rsi\ncmp    %rsi,%rdi\njne    1600 <kMeans+0x1e0>\ncmp    %r9,%r10\nja     1528 <kMeans+0x108>\njmp    14a7 <kMeans+0x87>\nmov    $0x18,%edi\ncall   1d60 <libmin_malloc>\nxor    %esi,%esi\nmov    $0x18,%edx\nmov    %rax,%r12\nmov    %rax,%rdi\ncall   1f30 <libmin_memset>\nmov    %r12,%rdx\nmov    %r13,%rsi\nmov    %rbp,%rdi\ncall   1390 <calculateCentroid>\njmp    14a7 <kMeans+0x87>\nnopl   0x0(%rax)\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "main", "content": "/*!\n * This function calls the test\n * function\n */\nint main()\n{\n    libmin_srand(42);\n    test();\n    /* test2(); */\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  observation *v3; // r12\n  observation *v4; // rbx\n  cluster *v5; // rbp\n  double v6; // [rsp+0h] [rbp-28h]\n  double x; // [rsp+8h] [rbp-20h]\n\n  libmin_srand(0x2Au);\n  v3 = (observation *)libmin_malloc(0x12C0uLL);\n  v4 = v3;\n  do\n  {\n    ++v4;\n    v6 = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    x = (double)(int)libmin_rand() / 2147483647.0 * 6.283185307179586;\n    v4[-1].x = libmin_cos(x) * v6;\n    v4[-1].y = libmin_sin(x) * v6;\n  }\n  while ( v4 != &v3[200] );\n  v5 = kMeans(v3, 0xC8uLL, 5);\n  printEPS(v3, 0xC8uLL, v5, 5);\n  libmin_free(v3);\n  libmin_free(v5);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  observation *v3;\n  observation *v4;\n  cluster *v5;\n  double v6;\n  double x;\n  libmin_srand(42u);\n  v3 = (observation *)libmin_malloc(4800uLL);\n  v4 = v3;\n  do {\n    ++v4;\n    v6 = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    x = (double)(int)libmin_rand() / 2147483647.0 * 6.283185307179586;\n    v4[-1].x = libmin_cos(x) * v6;\n    v4[-1].y = libmin_sin(x) * v6;\n  } while (v4 != &v3[200]);\n  v5 = kMeans(v3, 200uLL, 5);\n  printEPS(v3, 200uLL, v5, 5);\n  libmin_free(v3);\n  libmin_free(v5);\n  libmin_success();\n}", "binary": "k-means/k-means.host.O2", "assembly": "<main>:\nendbr64\npush   %r12\nmov    $0x2a,%edi\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\ncall   3510 <libmin_srand>\nmov    $0x12c0,%edi\ncall   1d60 <libmin_malloc>\nmov    %rax,%r12\nmov    %rax,%rbx\nlea    0x12c0(%rax),%rbp\nnopl   (%rax)\ncall   3570 <libmin_rand>\npxor   %xmm0,%xmm0\nadd    $0x18,%rbx\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x4044(%rip),%xmm0\nmulsd  0x4044(%rip),%xmm0\nmovsd  %xmm0,(%rsp)\ncall   3570 <libmin_rand>\npxor   %xmm1,%xmm1\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm1\ndivsd  0x401f(%rip),%xmm1\nmulsd  0x4027(%rip),%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm1,0x8(%rsp)\ncall   3880 <libmin_cos>\nmulsd  (%rsp),%xmm0\nmovsd  0x8(%rsp),%xmm1\nmovsd  %xmm0,-0x18(%rbx)\nmovapd %xmm1,%xmm0\ncall   39e0 <libmin_sin>\nmulsd  (%rsp),%xmm0\nmovsd  %xmm0,-0x10(%rbx)\ncmp    %rbp,%rbx\njne    1150 <main+0x30>\nmov    %r12,%rdi\nmov    $0x5,%edx\nmov    $0xc8,%esi\ncall   1420 <kMeans>\nmov    $0x5,%ecx\nmov    $0xc8,%esi\nmov    %r12,%rdi\nmov    %rax,%rdx\nmov    %rax,%rbp\ncall   16b0 <printEPS>\nmov    %r12,%rdi\ncall   1e10 <libmin_free>\nmov    %rbp,%rdi\ncall   1e10 <libmin_free>\ncall   3bc0 <libmin_success>\nadd    $0x10,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "printEPS", "content": "/**\n * @}\n * @}\n */\n\n/*!\n * A function to print observations and clusters\n * The code is taken from\n * http://rosettacode.org/wiki/K-means%2B%2B_clustering.\n * Even the K Means code is also inspired from it\n *\n * @note To print in a file use pipeline operator\n * ```sh\n * ./k_means_clustering > image.eps\n * ```\n *\n * @param observations  observations array\n * @param len  size of observation array\n * @param cent  clusters centroid's array\n * @param k  size of cent array\n */\nvoid printEPS(observation pts[], size_t len, cluster cent[], int k)\n{\n    int W = 400, H = 400;\n    double min_x = DBL_MAX, max_x = DBL_MIN, min_y = DBL_MAX, max_y = DBL_MIN;\n    double scale = 0, cx = 0, cy = 0;\n    double* colors = (double*)libmin_malloc(sizeof(double) * (k * 3));\n    int i;\n    size_t j;\n    double kd = k * 1.0;\n    for (i = 0; i < k; i++)\n    {\n        *(colors + 3 * i) = (3 * (i + 1) % k) / kd;\n        *(colors + 3 * i + 1) = (7 * i % k) / kd;\n        *(colors + 3 * i + 2) = (9 * i % k) / kd;\n    }\n\n    for (j = 0; j < len; j++)\n    {\n        if (max_x < pts[j].x)\n        {\n            max_x = pts[j].x;\n        }\n        if (min_x > pts[j].x)\n        {\n            min_x = pts[j].x;\n        }\n        if (max_y < pts[j].y)\n        {\n            max_y = pts[j].y;\n        }\n        if (min_y > pts[j].y)\n        {\n            min_y = pts[j].y;\n        }\n    }\n    scale = W / (max_x - min_x);\n    if (scale > (H / (max_y - min_y)))\n    {\n        scale = H / (max_y - min_y);\n    };\n    cx = (max_x + min_x) / 2;\n    cy = (max_y + min_y) / 2;\n\n    libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", W + 10,\n           H + 10);\n    libmin_printf(\n        \"/l {rlineto} def /m {rmoveto} def\\n\"\n        \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n        \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \"\n        \"\tgsave 1 setgray fill grestore gsave 3 setlinewidth\"\n        \" 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n    for (int i = 0; i < k; i++)\n    {\n        libmin_printf(\"%f %f %f setrgbcolor\\n\", *(colors + 3 * i),\n               *(colors + 3 * i + 1), *(colors + 3 * i + 2));\n        for (j = 0; j < len; j++)\n        {\n            if (pts[j].group != i)\n            {\n                continue;\n            }\n            libmin_printf(\"%.3f %.3f c\\n\", (pts[j].x - cx) * scale + W / 2,\n                   (pts[j].y - cy) * scale + H / 2);\n        }\n        libmin_printf(\"\\n0 setgray %f %f s\\n\", (cent[i].x - cx) * scale + W / 2,\n               (cent[i].y - cy) * scale + H / 2);\n    }\n    libmin_printf(\"\\n%%%%EOF\\n\");\n\n    // free accquired memory\n    libmin_free(colors);\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O2.pseudo", "function_name": "printEPS", "address": "0x16b0", "label": "printEPS", "content": "void __fastcall printEPS(observation *pts, size_t len, cluster *cent, int k)\n{\n  double *v7; // rax\n  double *v8; // rsi\n  int v9; // r8d\n  double v10; // xmm1_8\n  int v11; // edi\n  int v12; // ecx\n  int v13; // eax\n  int v14; // edx\n  int v15; // eax\n  double v16; // xmm0_8\n  int v17; // edx\n  int v18; // eax\n  double v19; // xmm3_8\n  double v20; // xmm1_8\n  observation *v21; // rax\n  double v22; // xmm4_8\n  double v23; // xmm2_8\n  double x; // xmm0_8\n  double v25; // xmm7_8\n  double y; // xmm5_8\n  __int64 v27; // rdx\n  __int64 v28; // rcx\n  __int64 v29; // r8\n  __int64 v30; // r9\n  double *v31; // r12\n  int v32; // r15d\n  __int64 v33; // rbp\n  observation *v34; // r14\n  double v35; // xmm1_8\n  double v36; // xmm0_8\n  double v37; // [rsp+0h] [rbp-68h]\n  double scale; // [rsp+8h] [rbp-60h]\n  double v39; // [rsp+10h] [rbp-58h]\n  double *colors; // [rsp+28h] [rbp-40h]\n\n  v7 = (double *)libmin_malloc(24LL * k);\n  colors = v7;\n  if ( k <= 0 )\n  {\n    if ( !len )\n    {\n      libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410, 410);\n      libmin_printf(\"/l {rlineto} def /m {rmoveto} def\\n\"\n                    \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n                    \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray fill grestore gsave 3 setlinewid\"\n                    \"th 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n      goto LABEL_14;\n    }\nLABEL_5:\n    v19 = 2.225073858507201e-308;\n    v20 = 1.797693134862316e308;\n    v21 = pts;\n    v22 = 2.225073858507201e-308;\n    v23 = 1.797693134862316e308;\n    do\n    {\n      x = v21->x;\n      ++v21;\n      v25 = fmax(x, v22);\n      v23 = fmin(x, v23);\n      v22 = v25;\n      y = v21[-1].y;\n      v20 = fmin(y, v20);\n      v19 = fmax(y, v19);\n    }\n    while ( &pts[len] != v21 );\n    v39 = (v23 + v25) * 0.5;\n    v37 = (v20 + v19) * 0.5;\n    scale = fmin(400.0 / (v19 - v20), 400.0 / (v25 - v23));\n    libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410, 410);\n    libmin_printf(\"/l {rlineto} def /m {rmoveto} def\\n\"\n                  \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n                  \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray fill grestore gsave 3 setlinewidth\"\n                  \" 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n    if ( k <= 0 )\n      goto LABEL_14;\n    goto LABEL_8;\n  }\n  v8 = v7;\n  v9 = 0;\n  v10 = (double)k;\n  v11 = 0;\n  v12 = 3;\n  do\n  {\n    v13 = v12;\n    v12 += 3;\n    v8 += 3;\n    v14 = v13 % k;\n    v15 = v11;\n    v11 += 7;\n    v16 = (double)v14;\n    v17 = v15 % k;\n    v18 = v9;\n    v9 += 9;\n    *(v8 - 3) = v16 / v10;\n    *(v8 - 2) = (double)v17 / v10;\n    *(v8 - 1) = (double)(v18 % k) / v10;\n  }\n  while ( 3 * k + 3 != v12 );\n  if ( len )\n    goto LABEL_5;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410, 410);\n  libmin_printf(\"/l {rlineto} def /m {rmoveto} def\\n\"\n                \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n                \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray fill grestore gsave 3 setlinewidth 1\"\n                \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  v37 = 8.988465674311579e307;\n  v39 = 8.988465674311579e307;\n  scale = -2.225073858507202e-306;\nLABEL_8:\n  v31 = colors;\n  v32 = 0;\n  do\n  {\n    v33 = 0LL;\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", *v31, v31[1], v31[2]);\n    v34 = pts;\n    if ( len )\n    {\n      do\n      {\n        if ( v34->group == v32 )\n          libmin_printf(\"%.3f %.3f c\\n\", (v34->x - v39) * scale + 200.0, (v34->y - v37) * scale + 200.0);\n        ++v33;\n        ++v34;\n      }\n      while ( len != v33 );\n    }\n    v35 = cent->y;\n    v36 = cent->x;\n    ++v32;\n    v31 += 3;\n    ++cent;\n    libmin_printf(\"\\n0 setgray %f %f s\\n\", (v36 - v39) * scale + 200.0, (v35 - v37) * scale + 200.0);\n  }\n  while ( k != v32 );\nLABEL_14:\n  libmin_printf(\"\\n%%%%EOF\\n\", 410LL, v27, v28, v29, v30, *(_QWORD *)&v37, *(_QWORD *)&scale, *(_QWORD *)&v39);\n  libmin_free(colors);\n}\n"}, "pseudo_normalize": "void printEPS(observation *pts, unsigned int len, cluster *cent, int k) {\n  double *v7;\n  double *v8;\n  int v9;\n  double v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  int v15;\n  double v16;\n  int v17;\n  int v18;\n  double v19;\n  double v20;\n  observation *v21;\n  double v22;\n  double v23;\n  double x;\n  double v25;\n  double y;\n  long long v27;\n  long long v28;\n  long long v29;\n  long long v30;\n  double *v31;\n  int v32;\n  long long v33;\n  observation *v34;\n  double v35;\n  double v36;\n  double v37;\n  double scale;\n  double v39;\n  double *colors;\n  v7 = (double *)libmin_malloc(24LL * k);\n  colors = v7;\n  if (k <= 0) {\n    if (!len) {\n      libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\",\n                    410, 410);\n      libmin_printf(\n          \"/l {rlineto} def /m {rmoveto} def\\n\"\n          \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n          \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n          \"fill grestore gsave 3 setlinewid\"\n          \"th 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n      goto LABEL_14;\n    }\n  LABEL_5:\n    v19 = 2.225073858507201e-308;\n    v20 = 1.797693134862316e308;\n    v21 = pts;\n    v22 = 2.225073858507201e-308;\n    v23 = 1.797693134862316e308;\n    do {\n      x = v21->x;\n      ++v21;\n      v25 = fmax(x, v22);\n      v23 = fmin(x, v23);\n      v22 = v25;\n      y = v21[-1].y;\n      v20 = fmin(y, v20);\n      v19 = fmax(y, v19);\n    } while (&pts[len] != v21);\n    v39 = (v23 + v25) * 0.5;\n    v37 = (v20 + v19) * 0.5;\n    scale = fmin(400.0 / (v19 - v20), 400.0 / (v25 - v23));\n    libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\",\n                  410, 410);\n    libmin_printf(\n        \"/l {rlineto} def /m {rmoveto} def\\n\"\n        \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n        \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n        \"fill grestore gsave 3 setlinewidth\"\n        \" 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n    if (k <= 0) goto LABEL_14;\n    goto LABEL_8;\n  }\n  v8 = v7;\n  v9 = 0;\n  v10 = (double)k;\n  v11 = 0;\n  v12 = 3;\n  do {\n    v13 = v12;\n    v12 += 3;\n    v8 += 3;\n    v14 = v13 % k;\n    v15 = v11;\n    v11 += 7;\n    v16 = (double)v14;\n    v17 = v15 % k;\n    v18 = v9;\n    v9 += 9;\n    *(v8 - 3) = v16 / v10;\n    *(v8 - 2) = (double)v17 / v10;\n    *(v8 - 1) = (double)(v18 % k) / v10;\n  } while (3 * k + 3 != v12);\n  if (len) goto LABEL_5;\n  libmin_printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", 410,\n                410);\n  libmin_printf(\n      \"/l {rlineto} def /m {rmoveto} def\\n\"\n      \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n      \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \\tgsave 1 setgray \"\n      \"fill grestore gsave 3 setlinewidth 1\"\n      \" setgray stroke grestore 0 setgray stroke }def\\n\");\n  v37 = 8.988465674311579e307;\n  v39 = 8.988465674311579e307;\n  scale = -2.225073858507202e-306;\nLABEL_8:\n  v31 = colors;\n  v32 = 0;\n  do {\n    v33 = 0LL;\n    libmin_printf(\"%f %f %f setrgbcolor\\n\", *v31, v31[1], v31[2]);\n    v34 = pts;\n    if (len) {\n      do {\n        if (v34->group == v32)\n          libmin_printf(\"%.3f %.3f c\\n\", (v34->x - v39) * scale + 200.0,\n                        (v34->y - v37) * scale + 200.0);\n        ++v33;\n        ++v34;\n      } while (len != v33);\n    }\n    v35 = cent->y;\n    v36 = cent->x;\n    ++v32;\n    v31 += 3;\n    ++cent;\n    libmin_printf(\"\\n0 setgray %f %f s\\n\", (v36 - v39) * scale + 200.0,\n                  (v35 - v37) * scale + 200.0);\n  } while (k != v32);\nLABEL_14:\n  libmin_printf(\"\\n%%%%EOF\\n\", 410LL, v27, v28, v29, v30, *(uint64_t *)&v37,\n                *(uint64_t *)&scale, *(uint64_t *)&v39);\n  libmin_free(colors);\n}", "binary": "k-means/k-means.host.O2", "assembly": "<printEPS>:\nendbr64\npush   %r15\nmov    %ecx,%r15d\npush   %r14\npush   %r13\nmov    %rdx,%r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x38,%rsp\nmov    %rdi,0x20(%rsp)\nlea    (%rcx,%rcx,2),%edi\nmovslq %edi,%rdi\nmov    %ecx,0x1c(%rsp)\nshl    $0x3,%rdi\ncall   1d60 <libmin_malloc>\nmov    %rax,0x28(%rsp)\ntest   %r15d,%r15d\njle    197b <printEPS+0x2cb>\npxor   %xmm1,%xmm1\nmov    %rax,%rsi\nlea    0x3(%r15,%r15,2),%r9d\nxor    %r8d,%r8d\ncvtsi2sd %r15d,%xmm1\nxor    %edi,%edi\nmov    $0x3,%ecx\nnopl   0x0(%rax)\nmov    0x1c(%rsp),%r10d\nmov    %ecx,%eax\npxor   %xmm0,%xmm0\nadd    $0x3,%ecx\ncltd\nadd    $0x18,%rsi\nidiv   %r10d\nmov    %edi,%eax\nadd    $0x7,%edi\ncvtsi2sd %edx,%xmm0\ncltd\nidiv   %r10d\ndivsd  %xmm1,%xmm0\nmov    %r8d,%eax\nadd    $0x9,%r8d\nmovsd  %xmm0,-0x18(%rsi)\npxor   %xmm0,%xmm0\ncvtsi2sd %edx,%xmm0\ncltd\nidiv   %r10d\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%rsi)\npxor   %xmm0,%xmm0\ncvtsi2sd %edx,%xmm0\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x8(%rsi)\ncmp    %ecx,%r9d\njne    1710 <printEPS+0x60>\ntest   %rbx,%rbx\nje     19ac <printEPS+0x2fc>\nmov    0x20(%rsp),%rcx\nmovsd  0x39fc(%rip),%xmm3\nlea    (%rbx,%rbx,2),%rdx\nmovsd  0x39e8(%rip),%xmm1\nmov    %rcx,%rax\nlea    (%rcx,%rdx,8),%rdx\nmovapd %xmm3,%xmm4\nmovapd %xmm1,%xmm2\nnop\nmovsd  (%rax),%xmm0\nadd    $0x18,%rax\nmovapd %xmm0,%xmm7\nminsd  %xmm2,%xmm0\nmaxsd  %xmm4,%xmm7\nmovapd %xmm0,%xmm2\nmovsd  -0x10(%rax),%xmm0\nmovapd %xmm7,%xmm4\nmovapd %xmm0,%xmm5\nminsd  %xmm1,%xmm0\nmaxsd  %xmm3,%xmm5\nmovapd %xmm0,%xmm1\nmovapd %xmm5,%xmm3\ncmp    %rax,%rdx\njne    17a0 <printEPS+0xf0>\nmovapd %xmm7,%xmm5\nmov    $0x19a,%edx\nmov    $0x19a,%esi\nxor    %eax,%eax\nsubsd  %xmm2,%xmm5\nmovsd  0x39a2(%rip),%xmm0\naddsd  %xmm4,%xmm2\nmovsd  0x399e(%rip),%xmm4\nlea    0x37ff(%rip),%rdi\nmovapd %xmm0,%xmm7\ndivsd  %xmm5,%xmm7\nmovapd %xmm3,%xmm5\nsubsd  %xmm1,%xmm5\naddsd  %xmm3,%xmm1\nmulsd  %xmm4,%xmm2\nmulsd  %xmm4,%xmm1\nmovsd  %xmm2,0x10(%rsp)\nmovsd  %xmm1,(%rsp)\ndivsd  %xmm5,%xmm0\nminsd  %xmm7,%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncall   3300 <libmin_printf>\nlea    0x37f6(%rip),%rdi\nxor    %eax,%eax\ncall   3300 <libmin_printf>\nmov    0x1c(%rsp),%eax\ntest   %eax,%eax\njle    1955 <printEPS+0x2a5>\nmov    0x28(%rsp),%r12\nxor    %r15d,%r15d\nnopl   (%rax)\nmovsd  0x10(%r12),%xmm2\nmovsd  0x8(%r12),%xmm1\nxor    %ebp,%ebp\nlea    0x38bb(%rip),%rdi\nmovsd  (%r12),%xmm0\nmov    $0x3,%eax\ncall   3300 <libmin_printf>\nmov    0x20(%rsp),%r14\ntest   %rbx,%rbx\nje     18f8 <printEPS+0x248>\nnopl   0x0(%rax)\ncmp    %r15d,0x10(%r14)\njne    18eb <printEPS+0x23b>\nmovsd  0x8(%r14),%xmm1\nmovsd  (%r14),%xmm0\nlea    0x38ac(%rip),%rdi\nmov    $0x2,%eax\nsubsd  (%rsp),%xmm1\nsubsd  0x10(%rsp),%xmm0\nmovsd  0x8(%rsp),%xmm6\nmulsd  %xmm6,%xmm1\nmulsd  %xmm6,%xmm0\naddsd  0x38ca(%rip),%xmm1\naddsd  0x38c2(%rip),%xmm0\ncall   3300 <libmin_printf>\nadd    $0x1,%rbp\nadd    $0x18,%r14\ncmp    %rbp,%rbx\njne    18a0 <printEPS+0x1f0>\nmovsd  0x8(%r13),%xmm1\nsubsd  (%rsp),%xmm1\nlea    0x3846(%rip),%rdi\nmov    $0x2,%eax\nmovsd  0x0(%r13),%xmm0\nadd    $0x1,%r15d\nadd    $0x18,%r12\nadd    $0x18,%r13\nsubsd  0x10(%rsp),%xmm0\nmovsd  0x8(%rsp),%xmm3\nmulsd  %xmm3,%xmm1\nmulsd  %xmm3,%xmm0\naddsd  0x386b(%rip),%xmm1\naddsd  0x3863(%rip),%xmm0\ncall   3300 <libmin_printf>\ncmp    %r15d,0x1c(%rsp)\njne    1868 <printEPS+0x1b8>\nlea    0x37d4(%rip),%rdi\nxor    %eax,%eax\ncall   3300 <libmin_printf>\nmov    0x28(%rsp),%rdi\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    1e10 <libmin_free>\ntest   %rbx,%rbx\njne    1777 <printEPS+0xc7>\nmov    $0x19a,%edx\nmov    $0x19a,%esi\nlea    0x3673(%rip),%rdi\nxor    %eax,%eax\ncall   3300 <libmin_printf>\nlea    0x369d(%rip),%rdi\nxor    %eax,%eax\ncall   3300 <libmin_printf>\njmp    1955 <printEPS+0x2a5>\nmov    $0x19a,%edx\nmov    $0x19a,%esi\nlea    0x364b(%rip),%rdi\nxor    %eax,%eax\ncall   3300 <libmin_printf>\nlea    0x3675(%rip),%rdi\nxor    %eax,%eax\ncall   3300 <libmin_printf>\nmovsd  0x37ae(%rip),%xmm4\nmovsd  %xmm4,(%rsp)\nmovsd  %xmm4,0x10(%rsp)\nmovsd  0x37a3(%rip),%xmm4\nmovsd  %xmm4,0x8(%rsp)\njmp    185d <printEPS+0x1ad>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "k-means/k-means.c", "function_name": "test2", "content": "/*!\n * A function to test the kMeans function\n * Generates 1000000 points in a circle of\n * radius 20.0 with center at (0,0)\n * and cluster them into 11 clusters\n *\n * <img alt=\"Output for 1000000 points divided in 11 clusters\" src=\n * \"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest2.png\"\n * width=\"400px\" heiggt=\"400px\">\n * @returns None\n */\nvoid test2()\n{\n    size_t size = 1000000L;\n    observation* observations =\n        (observation*)libmin_malloc(sizeof(observation) * size);\n    double maxRadius = 20.00;\n    double radius = 0;\n    double ang = 0;\n    size_t i = 0;\n    for (; i < size; i++)\n    {\n        radius = maxRadius * ((double)libmin_rand() / RAND_MAX);\n        ang = 2 * M_PI * ((double)libmin_rand() / RAND_MAX);\n        observations[i].x = radius * libmin_cos(ang);\n        observations[i].y = radius * libmin_sin(ang);\n    }\n    int k = 11;  // No of clusters\n    cluster* clusters = kMeans(observations, size, k);\n    printEPS(observations, size, clusters, k);\n    // Free the accquired memory\n    libmin_free(observations);\n    libmin_free(clusters);\n}\n"}, "pseudo": {"path": "k-means/k-means.host.O2.pseudo", "function_name": "test2", "address": "0x1a00", "label": "test2", "content": "void __cdecl test2()\n{\n  observation *v0; // r12\n  observation *v1; // rbx\n  cluster *v2; // rbp\n  double radius; // [rsp+0h] [rbp-28h]\n  double ang; // [rsp+8h] [rbp-20h]\n\n  v0 = (observation *)libmin_malloc(0x16E3600uLL);\n  v1 = v0;\n  do\n  {\n    ++v1;\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = (double)(int)libmin_rand() / 2147483647.0 * 6.283185307179586;\n    v1[-1].x = libmin_cos(ang) * radius;\n    v1[-1].y = libmin_sin(ang) * radius;\n  }\n  while ( v1 != &v0[1000000] );\n  v2 = kMeans(v0, 0xF4240uLL, 11);\n  printEPS(v0, 0xF4240uLL, v2, 11);\n  libmin_free(v0);\n  libmin_free(v2);\n}\n"}, "pseudo_normalize": "void test2() {\n  observation *v0;\n  observation *v1;\n  cluster *v2;\n  double radius;\n  double ang;\n  v0 = (observation *)libmin_malloc(24000000uLL);\n  v1 = v0;\n  do {\n    ++v1;\n    radius = (double)(int)libmin_rand() / 2147483647.0 * 20.0;\n    ang = (double)(int)libmin_rand() / 2147483647.0 * 6.283185307179586;\n    v1[-1].x = libmin_cos(ang) * radius;\n    v1[-1].y = libmin_sin(ang) * radius;\n  } while (v1 != &v0[1000000]);\n  v2 = kMeans(v0, 1000000uLL, 11);\n  printEPS(v0, 1000000uLL, v2, 11);\n  libmin_free(v0);\n  libmin_free(v2);\n}", "binary": "k-means/k-means.host.O2", "assembly": "<test2>:\nendbr64\npush   %r12\nmov    $0x16e3600,%edi\npush   %rbp\npush   %rbx\nsub    $0x10,%rsp\ncall   1d60 <libmin_malloc>\nmov    %rax,%r12\nmov    %rax,%rbx\nlea    0x16e3600(%rax),%rbp\nnopl   0x0(%rax,%rax,1)\ncall   3570 <libmin_rand>\npxor   %xmm0,%xmm0\nadd    $0x18,%rbx\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x376c(%rip),%xmm0\nmulsd  0x376c(%rip),%xmm0\nmovsd  %xmm0,(%rsp)\ncall   3570 <libmin_rand>\npxor   %xmm1,%xmm1\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm1\ndivsd  0x3747(%rip),%xmm1\nmulsd  0x374f(%rip),%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm1,0x8(%rsp)\ncall   3880 <libmin_cos>\nmulsd  (%rsp),%xmm0\nmovsd  0x8(%rsp),%xmm1\nmovsd  %xmm0,-0x18(%rbx)\nmovapd %xmm1,%xmm0\ncall   39e0 <libmin_sin>\nmulsd  (%rsp),%xmm0\nmovsd  %xmm0,-0x10(%rbx)\ncmp    %rbp,%rbx\njne    1a28 <test2+0x28>\nmov    %r12,%rdi\nmov    $0xb,%edx\nmov    $0xf4240,%esi\ncall   1420 <kMeans>\nmov    %r12,%rdi\nmov    $0xb,%ecx\nmov    $0xf4240,%esi\nmov    %rax,%rdx\nmov    %rax,%rbp\ncall   16b0 <printEPS>\nmov    %r12,%rdi\ncall   1e10 <libmin_free>\nadd    $0x10,%rsp\nmov    %rbp,%rdi\npop    %rbx\npop    %rbp\npop    %r12\njmp    1e10 <libmin_free>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "kadane/kadane.c", "function_name": "kadane", "content": "#include \"libmin.h\"\n \n// Function to find the maximum sum of a contiguous subarray\n// in a given integer array\nint\nkadane(int arr[], int n, int *ends_at)\n{\n  // stores the maximum sum subarray found so far\n  int max_so_far = 0;\n  *ends_at = -1;\n \n  // stores the maximum sum of subarray ending at the current position\n  int max_ending_here = 0;\n \n  // traverse the given array\n  for (int i = 0; i < n; i++)\n  {\n    // update the maximum sum of subarray \"ending\" at index `i` (by adding the\n    // current element to maximum sum ending at previous index `i-1`)\n    max_ending_here = max_ending_here + arr[i];\n \n    // if the maximum sum is negative, set it to 0 (which represents\n    // an empty subarray)\n    max_ending_here = MAX(max_ending_here, 0);\n\n    // update the result if the current subarray sum is found to be greater\n    if (max_so_far < max_ending_here)\n      *ends_at = i;\n    max_so_far = MAX(max_so_far, max_ending_here);\n  }\n  return max_so_far;\n}\n"}, "pseudo": {"path": "kadane/kadane.host.O2.pseudo", "function_name": "kadane", "address": "0x1290", "label": "kadane", "content": "int __fastcall kadane(int *arr, int n, int *ends_at)\n{\n  __int64 v3; // rcx\n  int v4; // eax\n  int v5; // r8d\n\n  *ends_at = -1;\n  if ( n <= 0 )\n    return 0;\n  v3 = 0LL;\n  v4 = 0;\n  v5 = 0;\n  do\n  {\n    v4 += arr[v3];\n    if ( v4 < 0 )\n      v4 = 0;\n    if ( v4 > v5 )\n    {\n      *ends_at = v3;\n      v5 = v4;\n    }\n    ++v3;\n  }\n  while ( n != v3 );\n  return v5;\n}\n"}, "pseudo_normalize": "int kadane(int *arr, int n, int *ends_at) {\n  long long v3;\n  int v4;\n  int v5;\n  *ends_at = -1;\n  if (n <= 0) return 0;\n  v3 = 0LL;\n  v4 = 0;\n  v5 = 0;\n  do {\n    v4 += arr[v3];\n    if (v4 < 0) v4 = 0;\n    if (v4 > v5) {\n      *ends_at = v3;\n      v5 = v4;\n    }\n    ++v3;\n  } while (n != v3);\n  return v5;\n}", "binary": "kadane/kadane.host.O2", "assembly": "<kadane>:\nendbr64\nmovl   $0xffffffff,(%rdx)\ntest   %esi,%esi\njle    12e0 <kadane+0x50>\nmovslq %esi,%rsi\nxor    %ecx,%ecx\nxor    %eax,%eax\nxor    %r8d,%r8d\nnopl   0x0(%rax,%rax,1)\nadd    (%rdi,%rcx,4),%eax\nmov    $0x0,%r9d\ncmovs  %r9d,%eax\ncmp    %r8d,%eax\njle    12c4 <kadane+0x34>\nmov    %ecx,(%rdx)\ncmp    %eax,%r8d\ncmovl  %eax,%r8d\nadd    $0x1,%rcx\ncmp    %rcx,%rsi\njne    12b0 <kadane+0x20>\nmov    %r8d,%eax\nret\nnopl   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "kadane/kadane.c", "function_name": "main", "content": " \nint\nmain(void)\n{\n  int arr[] = {\n    8155, 17168, 11554, -14406, 13854, 20973, -26471, -11245, 25508, -24548, -2094, -16932, -23080,\n    29777, -27647, -5927, 20197, -16505, -28944, 2518, 22405, 15304, -19199, 5439, 4971, 24179, 1119,\n    16764, -24526, -973, -9585, 15066, 12069, -21990, -19708, -16603, 24065, 15869, -6208, 22922,\n    2901, 24070, -16253, 15350, -27951, -817, -10363, -4185, -17835, -21493, -25281, -4842, -1425,\n    6710, -7297, -17119, -10408, 18129, -28213, -12161, 13068, -4347, 27196, -9652, -19423, 6057,\n    -22147, -10601, -17130, -13839, 4925, 27786, -9734, -25871, -2776, 16462, 13778, 11363, -6662,\n    -24896, 19904, 29515, 9625, 18193, -17274, -3246, 27168, 508, -81, 15064, 19885, 18619, -5470,\n    23422, -10780, -21517, 26606, -20833, -27943, -11223, -10137, -29356, 2701, -10774, 13286, -15863,\n    24259, -3434, -16362, -4444, -20182, 7785, 23559, -16482, -23146, 7477, 25038, -19306, -26506,\n    29314, 2174, 7862, -29266, -1236, -28187, 27877, -7969, 10314, -5142, 5466, 28920, 29191, -27061,\n    27601, 7428, 12574, -5776, 27915, -13399, -11340, 3307, 7043, -6927, 16463, -6535, 26316, -10710,\n    16103, -5578, 26102, -22493, 23027, 12203, 3251, 5281, -17123, -9919, 18986, -9330, -192, 16263,\n    -19289, -22665, -2993, 27926, -3020, -10050, -4092, 17416, 26503, -16237, -25905, -19723, -5055,\n    2901, 24070, -16253, 15350, -27951, -817, -10363, -4185, -17835, -21493, -25281, -4842, -1425,\n    27601, 7428, 12574, -5776, 27915, -13399, -11340, 3307, 7043, -6927, 16463, -6535, 26316, -10710,\n    29777, -27647, -5927, 20197, -16505, -28944, 2518, 22405, 15304, -19199, 5439, 4971, 24179, 1119,\n    8155, 17168, 11554, -14406, 13854, 20973, -26471, -11245, 25508, -24548, -2094, -16932, -23080,\n    -25496, -27164, -9845, 25985, 21965, 26979, -28295, -4574, -27464, -26163, 11498, -6302,\n    29123, -4712, -24339, -27645, 23484, 12151, 14797, -5334, -15853, 9431, 7116, 27195, -1075,\n    17134, 21955, -3745, -4717, 11285, -9264, -20400, 15249, -18604, 390, 25377, -7495,\n    -24694, 25767, 17461, -21795, 1815, -5557, 22489, 11085, -6132, -2513, 131, 18955,\n    -28518, -14482, 15781, 21178, 5485, -12187, -24004, 12344, 20129, -26045, -28136, -26435, 23729,\n    -12384, 3157, 3121, -18724, -17193, 22853, -29225, 29921, -19534, -28048, -9185, -29704, -29260, -2534,\n    21587, 4770, 4880, -9269, 9197, 25075, -3083, -4795, -28614, -8794, 20376, -12507, -14627, 8109,\n    28004, -29128, -10195, 16767, -6852, -21305, 28599, -23297, -16460, 18601, 5359, -7017, -24250, -23556,\n    16491, -23856, -16880, 19593, 6171, 12602, -29905, -27567, 18969, -12582, 18015, 7774, 23534, -26819,\n    -8535, 13345, 9279, -20758, -1612, 13739, -29764, 6005, 2037, 14339, -23422, -11, -16605, -11701\n  };\n  int n = sizeof(arr)/sizeof(arr[0]);\n  int max_sum, ends_at;\n \n  libmin_printf(\"Array size= %d\\n\", n);\n\n  max_sum = kadane(arr, n, &ends_at);\n\n  libmin_printf(\"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\", max_sum, ends_at);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "kadane/kadane.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int ends_at; // [rsp+Ch] [rbp-5BCh] BYREF\n  int arr[362]; // [rsp+10h] [rbp-5B8h] BYREF\n  unsigned __int64 v6; // [rsp+5B8h] [rbp-10h]\n\n  v6 = __readfsqword(0x28u);\n  qmemcpy(arr, &unk_3060, 0x5A0uLL);\n  libmin_printf(\"Array size= %d\\n\", 360);\n  v3 = kadane(arr, 360, &ends_at);\n  libmin_printf(\"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\", v3, ends_at);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int ends_at;\n  int arr[362];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  qmemcpy(arr, &unk_3060, 1440uLL);\n  libmin_printf(\"Array size= %d\\n\", 360);\n  v3 = kadane(arr, 360, &ends_at);\n  libmin_printf(\n      \"The maximum sum of a contiguous subarray is %d (ending at index %d)\\n\",\n      v3, ends_at);\n  libmin_success();\n}", "binary": "kadane/kadane.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x5c8,%rsp\nlea    0x1f4e(%rip),%rsi\nmov    $0xb4,%ecx\nmov    %fs:0x28,%rax\nmov    %rax,0x5b8(%rsp)\nxor    %eax,%eax\nlea    0x10(%rsp),%rdi\nrep movsq %ds:(%rsi),%es:(%rdi)\nmov    $0x168,%esi\nlea    0x1ec6(%rip),%rdi\ncall   2830 <libmin_printf>\nlea    0xc(%rsp),%rdx\nlea    0x10(%rsp),%rdi\nmov    $0x168,%esi\ncall   1290 <kadane>\nmov    0xc(%rsp),%edx\nlea    0x1eb6(%rip),%rdi\nmov    %eax,%esi\nxor    %eax,%eax\ncall   2830 <libmin_printf>\ncall   2a70 <libmin_success>\nmov    0x5b8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    118d <main+0x8d>\nxor    %eax,%eax\nadd    $0x5c8,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "J", "content": "/* The following routine calculates the Bessel function of the first kind \n   for an integer index. We just sum the series representation given by\n\n\n                      __                     2j\n\t              \\        j        (x/2)\nJ (x) = 1/n! (x/2)^n       (-1)   __________________\n n\t              /__          j!(n+1)...(n+j)\n\t\t      j=0\n\n   \nSee Special functions and their applications, N.N. Lebedev, Dover, 1972,\npp 95-142 for an introduction to Bessel functions and related cylinder\nfunctions.\n\n*/\n\ndouble J(int n, double x)\n{\n\tdouble dsum=0.0,dterm,s_j,d_n,d_j,cfact=1.0;\n\tint j,nn;\n\n\tnn = n >= 0 ? n : -n;  /* Absolute value of n. Use the relation\n                                  J  (x) = (-1)^n J  (x) for negative n \n\t\t\t\t    -n              n    */\n\n\td_n = (double) nn;\n\t\n\t/* Calculate the common factor (x/2)^n/n! so it only has to be\n           done once. */\n\n\tfor(j=1;j<=nn;j++){\n\t\td_j = (double)j;\n\t\tcfact *= x/(2.0*d_j);\n\t}\n\n\t/* j = 0 term: */\n\tdsum = dterm = cfact;\n\n\tj = 1;\n\n\tdo {\n\t\td_j = (double)j;\n\t\ts_j = j%2 ? -1.0: 1.0;\n\t\tdterm *= x*x/(d_j*4.0*(d_n + d_j));\n\t\tdsum += s_j*dterm;\n\t\tj++;\n\t} while( dterm > DBL_EPSILON );\n\t\t\n\ts_j = nn%2 ? -1.0 : 1.0;\n\treturn  n >= 0 ? dsum : s_j*dsum;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O2.pseudo", "function_name": "J", "address": "0x1920", "label": "J", "content": "double __fastcall J(int n, double a2, double x)\n{\n  int v3; // ecx\n  int v4; // eax\n  double v5; // xmm1_8\n  double v6; // xmm2_8\n  double v7; // xmm0_8\n  double v8; // xmm5_8\n  int v9; // eax\n  double v10; // xmm3_8\n  double v11; // xmm2_8\n  double v12; // xmm0_8\n\n  v3 = -n;\n  if ( n > 0 )\n    v3 = n;\n  if ( n )\n  {\n    v4 = 1;\n    v5 = 1.0;\n    do\n    {\n      v6 = (double)v4++;\n      v5 = v5 * (a2 / (v6 + v6));\n    }\n    while ( v4 != v3 + 1 );\n  }\n  else\n  {\n    v5 = 1.0;\n  }\n  v7 = a2 * a2;\n  v8 = v5;\n  v9 = 1;\n  do\n  {\n    v10 = -1.0;\n    v11 = (double)v9;\n    if ( (v9 & 1) == 0 )\n      v10 = 1.0;\n    ++v9;\n    v5 = v5 * (v7 / ((v11 + (double)v3) * (v11 * 4.0)));\n    v8 = v8 + v10 * v5;\n  }\n  while ( v5 > 2.220446049250313e-16 );\n  v12 = -1.0;\n  if ( (v3 & 1) == 0 )\n    v12 = 1.0;\n  if ( n < 0 )\n    return v8 * v12;\n  return v8;\n}\n"}, "pseudo_normalize": "double J(int n, double a2, double x) {\n  int v3;\n  int v4;\n  double v5;\n  double v6;\n  double v7;\n  double v8;\n  int v9;\n  double v10;\n  double v11;\n  double v12;\n  v3 = -n;\n  if (n > 0) v3 = n;\n  if (n) {\n    v4 = 1;\n    v5 = 1.0;\n    do {\n      v6 = (double)v4++;\n      v5 = v5 * (a2 / (v6 + v6));\n    } while (v4 != v3 + 1);\n  } else {\n    v5 = 1.0;\n  }\n  v7 = a2 * a2;\n  v8 = v5;\n  v9 = 1;\n  do {\n    v10 = -1.0;\n    v11 = (double)v9;\n    if ((v9 & 1) == 0) v10 = 1.0;\n    ++v9;\n    v5 = v5 * (v7 / ((v11 + (double)v3) * (v11 * 4.0)));\n    v8 = v8 + v10 * v5;\n  } while (v5 > 2.220446049250313e-16);\n  v12 = -1.0;\n  if ((v3 & 1) == 0) v12 = 1.0;\n  if (n < 0) return v8 * v12;\n  return v8;\n}", "binary": "kepler/kepler.host.O2", "assembly": "<J>:\nendbr64\nmov    %edi,%ecx\npxor   %xmm7,%xmm7\nneg    %ecx\ncmovs  %edi,%ecx\ncvtsi2sd %ecx,%xmm7\ntest   %edi,%edi\nje     1a08 <J+0xe8>\nmovsd  0x4974(%rip),%xmm10\nlea    0x1(%rcx),%edx\nmov    $0x1,%eax\nmovapd %xmm10,%xmm1\nnopl   0x0(%rax)\npxor   %xmm2,%xmm2\nmovapd %xmm0,%xmm3\ncvtsi2sd %eax,%xmm2\nadd    $0x1,%eax\naddsd  %xmm2,%xmm2\ndivsd  %xmm2,%xmm3\nmulsd  %xmm3,%xmm1\ncmp    %edx,%eax\njne    1958 <J+0x38>\nmulsd  %xmm0,%xmm0\nmovsd  0x494d(%rip),%xmm6\nmovsd  0x4974(%rip),%xmm9\nmovapd %xmm1,%xmm5\nmovsd  0x4947(%rip),%xmm8\nmov    $0x1,%eax\nxchg   %ax,%ax\npxor   %xmm2,%xmm2\nmovapd %xmm6,%xmm3\ncvtsi2sd %eax,%xmm2\ntest   $0x1,%al\njne    19b5 <J+0x95>\nmovapd %xmm10,%xmm3\nmovapd %xmm2,%xmm4\naddsd  %xmm7,%xmm2\nadd    $0x1,%eax\nmulsd  %xmm9,%xmm4\nmulsd  %xmm4,%xmm2\nmovapd %xmm0,%xmm4\ndivsd  %xmm2,%xmm4\nmulsd  %xmm4,%xmm1\nmulsd  %xmm1,%xmm3\ncomisd %xmm8,%xmm1\naddsd  %xmm3,%xmm5\nja     19a0 <J+0x80>\nand    $0x1,%ecx\nmovsd  0x48e1(%rip),%xmm0\njne    19f6 <J+0xd6>\nmovapd %xmm10,%xmm0\ntest   %edi,%edi\njns    19fe <J+0xde>\nmulsd  %xmm0,%xmm5\nmovapd %xmm5,%xmm0\nret\nnopl   0x0(%rax,%rax,1)\nmovsd  0x48a7(%rip),%xmm10\nmovapd %xmm10,%xmm1\njmp    1977 <J+0x57>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "bin_fact", "content": "#endif /* NO_MAIN */\n\n/* The bin_fact routine calculates C(n,k)(n-2k)^(n-1)/n!2^(n-1). This\n   routine assumes 2k <  n, and tries to keep the intermediate products\n   small to prevent overflow.  */\n\ndouble \nbin_fact(int n, int k)\n{\n\t\tint j;\n\t\tdouble cum_prod = 1.0;\n\t\tdouble num_fact,den_fact,dj,dk,x;\n\n\t\tx = ((double) n)/2.0 - (double)k;\n\n\t\tfor(j=n-k;j>1;j--){\n\t\t\tdj = (double)j;\n\t\t\tdk = (double) n -(double)k - dj + 1.0;\n\t\t\tden_fact = n - k - j + 1 <= k ? dk*dj : dj;  \n\t\t\tnum_fact = n - k - j + 1 <= k ? x*x : x; \n\t\t\tcum_prod *= (num_fact/den_fact);\n\t\t}\n\t\treturn cum_prod;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O2.pseudo", "function_name": "bin_fact", "address": "0x1740", "label": "bin_fact", "content": "double __fastcall bin_fact(int n, int k)\n{\n  double v2; // xmm4_8\n  int v3; // edi\n  double v4; // xmm2_8\n  double v5; // xmm4_8\n  int v6; // eax\n  double v7; // xmm3_8\n  double v8; // xmm0_8\n  double v9; // xmm1_8\n\n  v2 = (double)n;\n  v3 = n - k;\n  v4 = 0.5 * v2 - (double)k;\n  if ( v3 <= 1 )\n    return 1.0;\n  v5 = v2 - (double)k;\n  v6 = v3;\n  v7 = 1.0;\n  do\n  {\n    v8 = v4;\n    v9 = (double)v6;\n    if ( v3 - v6 < k )\n    {\n      v9 = v9 * (v5 - v9 + 1.0);\n      v8 = v4 * v4;\n    }\n    --v6;\n    v7 = v7 * (v8 / v9);\n  }\n  while ( v6 != 1 );\n  return v7;\n}\n"}, "pseudo_normalize": "double bin_fact(int n, int k) {\n  double v2;\n  int v3;\n  double v4;\n  double v5;\n  int v6;\n  double v7;\n  double v8;\n  double v9;\n  v2 = (double)n;\n  v3 = n - k;\n  v4 = 0.5 * v2 - (double)k;\n  if (v3 <= 1) return 1.0;\n  v5 = v2 - (double)k;\n  v6 = v3;\n  v7 = 1.0;\n  do {\n    v8 = v4;\n    v9 = (double)v6;\n    if (v3 - v6 < k) {\n      v9 = v9 * (v5 - v9 + 1.0);\n      v8 = v4 * v4;\n    }\n    --v6;\n    v7 = v7 * (v8 / v9);\n  } while (v6 != 1);\n  return v7;\n}", "binary": "kepler/kepler.host.O2", "assembly": "<bin_fact>:\nendbr64\npxor   %xmm4,%xmm4\nmovsd  0x4b78(%rip),%xmm2\npxor   %xmm0,%xmm0\ncvtsi2sd %edi,%xmm4\nsub    %esi,%edi\ncvtsi2sd %esi,%xmm0\nmulsd  %xmm4,%xmm2\nsubsd  %xmm0,%xmm2\ncmp    $0x1,%edi\njle    17c8 <bin_fact+0x88>\nmovsd  0x4b45(%rip),%xmm5\nsubsd  %xmm0,%xmm4\nmov    %edi,%eax\nmovapd %xmm5,%xmm3\nnopl   (%rax)\nmov    %edi,%edx\npxor   %xmm1,%xmm1\nmovapd %xmm2,%xmm0\nsub    %eax,%edx\ncvtsi2sd %eax,%xmm1\ncmp    %esi,%edx\njge    17ac <bin_fact+0x6c>\nmovapd %xmm4,%xmm0\nsubsd  %xmm1,%xmm0\naddsd  %xmm5,%xmm0\nmulsd  %xmm0,%xmm1\nmovapd %xmm2,%xmm0\nmulsd  %xmm2,%xmm0\ndivsd  %xmm1,%xmm0\nsub    $0x1,%eax\nmulsd  %xmm0,%xmm3\ncmp    $0x1,%eax\njne    1780 <bin_fact+0x40>\nmovapd %xmm3,%xmm0\nret\nnopl   0x0(%rax)\nmovsd  0x4ae8(%rip),%xmm3\nmovapd %xmm3,%xmm0\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "binary", "content": "/* The following routine implements the binary search algorithm due\n   to Roger Sinnott, Sky and Telescope, Vol 70, page 159 (August 1985.)\n   It is not the fastest algorithm, but it is completely reliable. \n*/\n\ndouble binary(double E, double e, double M, int reset)\n{\n\tstatic double scale = .7853981633975;   /* PI/4 */\n\tdouble R;\n\tdouble X;\n\n\tif(reset) {\n\t\tscale = PI/4.0;\n\t\treturn 0.0;\n\t}\n\n\tR = E - e*libmin_sin(E);\n\tX = M > R ? E + scale : E - scale;\n\tscale = scale/2.0;\n\treturn X;\n\t\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O2.pseudo", "function_name": "binary", "address": "0x16a0", "label": "binary", "content": "double __fastcall binary(double a1, double E, double e, double M, int reset)\n{\n  double result; // xmm0_8\n  double v7; // xmm3_8\n\n  if ( reset )\n  {\n    result = 0.0;\n    scale_2 = 0x3FE921FB54442EEALL;\n  }\n  else\n  {\n    if ( e <= a1 - E * libmin_sin(E) )\n      v7 = a1 - *(double *)&scale_2;\n    else\n      v7 = a1 + *(double *)&scale_2;\n    result = v7;\n    *(double *)&scale_2 = *(double *)&scale_2 * 0.5;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "double binary(double a1, double E, double e, double M, int reset) {\n  double result;\n  double v7;\n  if (reset) {\n    result = 0.0;\n    scale_2 = 4605249457297305322LL;\n  } else {\n    if (e <= a1 - E * libmin_sin(E))\n      v7 = a1 - *(double *)&scale_2;\n    else\n      v7 = a1 + *(double *)&scale_2;\n    result = v7;\n    *(double *)&scale_2 = *(double *)&scale_2 * 0.5;\n  }\n  return result;\n}", "binary": "kepler/kepler.host.O2", "assembly": "<binary>:\nendbr64\nsub    $0x28,%rsp\nmovsd  %xmm1,0x10(%rsp)\nmovsd  %xmm2,0x8(%rsp)\ntest   %edi,%edi\nje     16d8 <binary+0x38>\nmovsd  0x4c00(%rip),%xmm1\npxor   %xmm0,%xmm0\nmovsd  %xmm1,0x7944(%rip)\nadd    $0x28,%rsp\nret\nnopl   0x0(%rax)\nmovsd  %xmm0,0x18(%rsp)\ncall   4470 <libmin_sin>\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x18(%rsp),%xmm3\nmovsd  0x8(%rsp),%xmm2\nmulsd  %xmm0,%xmm1\nmovapd %xmm3,%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  0x7907(%rip),%xmm1\ncomisd %xmm0,%xmm2\njbe    1730 <binary+0x90>\naddsd  %xmm1,%xmm3\nmovapd %xmm3,%xmm0\nmulsd  0x4ba9(%rip),%xmm1\nmovsd  %xmm1,0x78e9(%rip)\nadd    $0x28,%rsp\nret\nnopl   0x0(%rax)\nsubsd  %xmm1,%xmm3\nmovapd %xmm3,%xmm0\njmp    1717 <binary+0x77>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "e_series", "content": "/* The following infinite series expansion for E in powers of e is known:\n\n                 __\n\t        \\       n\n\tE = M +      A e\n\t\t/__   n\n\t\tn=1\n\nwhere              __ \n       \t     n-1  \\          k            (n-1)\nA =      (1/2 n!)        (-1) C(n,k)(n-2k)   sin((n-2k)M),\n n                /__\n                 0<= k <= [n/2]\n\nwhich converges for e < LAPLACE_LIMIT (defined above). This is based upon\nthe Laplace inversion formula -- see the discussion of Burmann's theorem\nand following material in Whittaker and Watson.\n\nThe bin_fact helper routine calculates C(n,k)(n-2k)^(n-1)/n!2^(n-1) */\n\n\ndouble e_series(double E, double e, double M, int reset)\n{\n\tstatic int n;\n\tint k;\n\tdouble n_2k,a_n=0.0,s_k;\n\n\tif(reset){\n\t\tn = 0;\n\t\treturn 0.0;\n\t}\n\n\tif(n==0){\n\t\tn++;\n\t\treturn M;\n\t}\n\n\n\tfor(k=0;2*k<=n;k++){\n\t\tn_2k = (double)n - 2.0 * ((double)k);\n\t\ts_k = k%2 ? -1.0 : 1.0;   /*   (-1)^k */\n\t\ta_n += s_k*bin_fact(n,k)*libmin_sin(n_2k*M);\n\t}\n\tn++;\n\treturn E + libmin_pow(e,n-1)*a_n;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O2.pseudo", "function_name": "e_series", "address": "0x17e0", "label": "e_series", "content": "double __fastcall e_series(double a1, double E, double e, double M, int reset)\n{\n  int v5; // ebx\n  int v6; // edi\n  double v7; // xmm1_8\n  double v8; // xmm7_8\n  int v9; // esi\n  double v10; // xmm0_8\n  double v12; // [rsp+0h] [rbp-38h]\n  double v13; // [rsp+8h] [rbp-30h]\n\n  if ( reset )\n  {\n    n_1 = 0;\n    return 0.0;\n  }\n  else\n  {\n    v5 = 0;\n    v6 = n_1;\n    if ( n_1 )\n    {\n      v7 = (double)n_1;\n      v12 = 0.0;\n      if ( n_1 >= 0 )\n      {\nLABEL_4:\n        v8 = 1.0;\n        while ( 1 )\n        {\n          v9 = v5++;\n          v13 = bin_fact(v6, v9) * v8;\n          v10 = libmin_sin(v7);\n          v6 = n_1;\n          v12 = v10 * v13 + v12;\n          if ( n_1 < 2 * v5 )\n            break;\n          v8 = -1.0;\n          if ( (v5 & 1) == 0 )\n            goto LABEL_4;\n        }\n        v7 = (double)n_1;\n      }\n      n_1 = v6 + 1;\n      return libmin_pow(v7, 0.0) * v12 + a1;\n    }\n    else\n    {\n      n_1 = 1;\n      return e;\n    }\n  }\n}\n"}, "pseudo_normalize": "double e_series(double a1, double E, double e, double M, int reset) {\n  int v5;\n  int v6;\n  double v7;\n  double v8;\n  int v9;\n  double v10;\n  double v12;\n  double v13;\n  if (reset) {\n    n_1 = 0;\n    return 0.0;\n  } else {\n    v5 = 0;\n    v6 = n_1;\n    if (n_1) {\n      v7 = (double)n_1;\n      v12 = 0.0;\n      if (n_1 >= 0) {\n      LABEL_4:\n        v8 = 1.0;\n        while (1) {\n          v9 = v5++;\n          v13 = bin_fact(v6, v9) * v8;\n          v10 = libmin_sin(v7);\n          v6 = n_1;\n          v12 = v10 * v13 + v12;\n          if (n_1 < 2 * v5) break;\n          v8 = -1.0;\n          if ((v5 & 1) == 0) goto LABEL_4;\n        }\n        v7 = (double)n_1;\n      }\n      n_1 = v6 + 1;\n      return libmin_pow(v7, 0.0) * v12 + a1;\n    } else {\n      n_1 = 1;\n      return e;\n    }\n  }\n}", "binary": "kepler/kepler.host.O2", "assembly": "<e_series>:\nendbr64\npush   %r14\npush   %rbx\nsub    $0x28,%rsp\nmovsd  %xmm0,0x18(%rsp)\nmovsd  %xmm2,0x10(%rsp)\ntest   %edi,%edi\njne    1900 <e_series+0x120>\nmov    %edi,%ebx\nmov    0x7ac9(%rip),%edi\ntest   %edi,%edi\nje     18b0 <e_series+0xd0>\nmovq   %xmm1,%r14\npxor   %xmm1,%xmm1\npxor   %xmm2,%xmm2\ncvtsi2sd %edi,%xmm1\nmovsd  %xmm2,(%rsp)\nmovapd %xmm1,%xmm6\njs     18d8 <e_series+0xf8>\nmov    0x4a82(%rip),%rax\nmovq   %rax,%xmm7\nmov    %ebx,%esi\nadd    $0x1,%ebx\ncall   1740 <bin_fact>\nmulsd  0x10(%rsp),%xmm6\nmulsd  %xmm7,%xmm0\nmovsd  %xmm0,0x8(%rsp)\nmovapd %xmm6,%xmm0\ncall   4470 <libmin_sin>\nmulsd  0x8(%rsp),%xmm0\nmov    0x7a66(%rip),%edi\nlea    (%rbx,%rbx,1),%eax\naddsd  (%rsp),%xmm0\nmovsd  %xmm0,(%rsp)\ncmp    %eax,%edi\njl     18d0 <e_series+0xf0>\npxor   %xmm0,%xmm0\npxor   %xmm6,%xmm6\nmov    0x4a46(%rip),%rax\ncvtsi2sd %ebx,%xmm0\ncvtsi2sd %edi,%xmm6\nmovq   %rax,%xmm7\naddsd  %xmm0,%xmm0\nsubsd  %xmm0,%xmm6\ntest   $0x1,%bl\njne    183b <e_series+0x5b>\njmp    182f <e_series+0x4f>\ncs nopw 0x0(%rax,%rax,1)\nmovl   $0x1,0x7a16(%rip)\nmovsd  0x10(%rsp),%xmm0\nadd    $0x28,%rsp\npop    %rbx\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\npxor   %xmm1,%xmm1\ncvtsi2sd %edi,%xmm1\nadd    $0x1,%edi\nmovq   %r14,%xmm0\nmov    %edi,0x79ea(%rip)\ncall   21f0 <libmin_pow>\nmulsd  (%rsp),%xmm0\naddsd  0x18(%rsp),%xmm0\nadd    $0x28,%rsp\npop    %rbx\npop    %r14\nret\nxchg   %ax,%ax\nmovl   $0x0,0x79c6(%rip)\nadd    $0x28,%rsp\npxor   %xmm0,%xmm0\npop    %rbx\npop    %r14\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "j_series", "content": "\t\n/* The eccentric anomaly is an odd periodic function in the Mean Anomoly\n   and so can be developed in a Fourier sine series. This turns out to\n   be \n                 __\n\t        \\  \n\tE = M +      (2/n)J (ne)sin(nM)\n\t\t/__        n \n\t\tn=1\n\n  where J_n is the Bessel function of the first kind. See, e.g, A Mathematical\n  Introdution to Celestial Mechanics, Harry Pollard, Prentice Hall, 1966,\n  pp 22-23. The following routine is used to sum this series.\n*/\n\n\ndouble j_series(double E, double e, double M, int reset)\n{\n\tstatic int n;\n\tdouble dn, term;\n\n\tif(reset){\n\t\tn = 0;\n\t\treturn 0.0;\n\t}\n\n\tif(n==0){\n\t\tn++;\n\t\treturn M;\n\t}\n\tdn = (double)n;\n\tterm = (2.0/(double)n)*J(n,dn*e)*libmin_sin(dn*M);\n\tn++;\n\treturn E + term;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O2.pseudo", "function_name": "j_series", "address": "0x1a20", "label": "j_series", "content": "double __fastcall j_series(double a1, double E, double e, double M, int reset)\n{\n  double result; // xmm0_8\n  double v6; // xmm12_8\n  double v7; // xmm0_8\n  double v8; // xmm0_8\n  double v10; // [rsp+8h] [rbp-10h]\n\n  if ( reset )\n  {\n    result = 0.0;\n    n_0 = 0;\n  }\n  else if ( n_0 )\n  {\n    v6 = (double)n_0;\n    v7 = J(n_0, E * (double)n_0, E * (double)n_0);\n    v10 = 2.0 / v6 * v7;\n    v8 = libmin_sin(v7);\n    ++n_0;\n    return v8 * v10 + a1;\n  }\n  else\n  {\n    result = e;\n    n_0 = 1;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "double j_series(double a1, double E, double e, double M, int reset) {\n  double result;\n  double v6;\n  double v7;\n  double v8;\n  double v10;\n  if (reset) {\n    result = 0.0;\n    n_0 = 0;\n  } else if (n_0) {\n    v6 = (double)n_0;\n    v7 = J(n_0, E * (double)n_0, E * (double)n_0);\n    v10 = 2.0 / v6 * v7;\n    v8 = libmin_sin(v7);\n    ++n_0;\n    return v8 * v10 + a1;\n  } else {\n    result = e;\n    n_0 = 1;\n  }\n  return result;\n}", "binary": "kepler/kepler.host.O2", "assembly": "<j_series>:\nendbr64\nsub    $0x18,%rsp\nmovsd  %xmm0,(%rsp)\ntest   %edi,%edi\njne    1ac8 <j_series+0xa8>\nmov    0x7891(%rip),%edi\nmovapd %xmm2,%xmm11\ntest   %edi,%edi\njne    1a60 <j_series+0x40>\nmov    $0x1,%eax\nmovapd %xmm2,%xmm0\nmov    %eax,0x7879(%rip)\nadd    $0x18,%rsp\nret\nnopl   0x0(%rax,%rax,1)\npxor   %xmm12,%xmm12\ncvtsi2sd %edi,%xmm12\nmulsd  %xmm12,%xmm1\nmulsd  %xmm12,%xmm11\nmovapd %xmm1,%xmm0\ncall   1920 <J>\nmovapd %xmm0,%xmm1\nmovsd  0x487f(%rip),%xmm0\ndivsd  %xmm12,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,0x8(%rsp)\nmovapd %xmm11,%xmm0\ncall   4470 <libmin_sin>\nmulsd  0x8(%rsp),%xmm0\nmov    0x781e(%rip),%eax\nmovsd  (%rsp),%xmm3\nadd    $0x1,%eax\nmov    %eax,0x7810(%rip)\nadd    $0x18,%rsp\naddsd  %xmm3,%xmm0\nret\nnopl   (%rax)\nxor    %eax,%eax\npxor   %xmm0,%xmm0\nmov    %eax,0x77f8(%rip)\nadd    $0x18,%rsp\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "kepler", "content": "int\nkepler(double *E, double M, double e, double my_derror, int m)\n{\n\tint count = 0;\n\tdouble sign = 1.0;\n\tdouble  E_old=PI/2;\n\tdouble (*method)(double,double, double,int);\n\t\n\tif((m<0) || (m>=NMETHODS))return -1;\n\n\tmethod = (double(*)(double,double,double,int))methods[m];\n\n\tif((m==3)&&(e > LAPLACE_LIMIT))\n\t\treturn -1;\n\n\tif((e<0)||(e>=1.0))\n\t\treturn -1;\n\n\t/* Normalize M to lie between 0 and PI */\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M)/(2*PI);\n\tM = (M - libmin_floor(M))*2*PI*sign;\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M);\n\tif(M > PI){\n\t\tM = 2*PI - M;\n\t\tsign = -1.0;\n\t}\n\t\n\t/* Do selected calculation, and quit when accuracy is bettered. */\n\twhile(libmin_fabs(E_old - (*E = method(E_old,e,M,0))) >= my_derror){\n\t\tE_old = *E;\n\t\tcount++;\n\t}\n\t*E = sign*(*E);\n\tmethod(0.0,0.0,0.0,1);  /* reset */\n\n\treturn count;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O2.pseudo", "function_name": "kepler", "address": "0x1ae0", "label": "kepler", "content": "__int64 __fastcall kepler(double *E, double a2, double M, double e, double my_derror, unsigned int m)\n{\n  double (__fastcall *v6)(double, double, double, double, int); // rbp\n  double v7; // xmm2_8\n  double v8; // xmm1_8\n  double v9; // r14\n  double v10; // xmm0_8\n  double v11; // xmm2_8\n  double v12; // xmm3_8\n  unsigned int i; // r12d\n  double v14; // xmm0_8\n  double v15; // xmm3_8\n  double E_old; // [rsp+0h] [rbp-48h]\n\n  if ( m > 4 )\n    return (unsigned int)-1;\n  v6 = (double (__fastcall *)(double, double, double, double, int))methods[m];\n  if ( m == 3 && M > 0.6627434193 )\n    return (unsigned int)-1;\n  if ( M < 0.0 || M >= 1.0 )\n  {\n    return (unsigned int)-1;\n  }\n  else\n  {\n    v7 = 1.0;\n    if ( a2 <= 0.0 )\n      v7 = -1.0;\n    E_old = libmin_fabs(M) / 6.28318530718;\n    v8 = E_old - libmin_floor(E_old);\n    v9 = 1.0;\n    if ( (v8 + v8) * 3.14159265359 * v7 <= 0.0 )\n      v9 = -1.0;\n    v10 = libmin_fabs(v8);\n    v11 = v10;\n    if ( v10 > 3.14159265359 )\n    {\n      v11 = 6.28318530718 - v10;\n      v9 = -1.0;\n    }\n    v12 = 1.570796326795;\n    for ( i = 0; ; ++i )\n    {\n      v14 = v6(v12, M, v11, v12, 0);\n      *E = v14;\n      v15 = v12 - v14;\n      if ( libmin_fabs(M) < e )\n        break;\n      v12 = *E;\n    }\n    *E = v9 * *E;\n    v6(0.0, 0.0, 0.0, v15, 1);\n  }\n  return i;\n}\n"}, "pseudo_normalize": "long long kepler(double *E, double a2, double M, double e, double my_derror,\n                 unsigned int m) {\n  double (*v6)(double, double, double, double, int);\n  double v7;\n  double v8;\n  double v9;\n  double v10;\n  double v11;\n  double v12;\n  unsigned int i;\n  double v14;\n  double v15;\n  double E_old;\n  if (m > 4) return (unsigned int)-1;\n  v6 = (double (*)(double, double, double, double, int))methods[m];\n  if (m == 3 && M > 0.6627434193) return (unsigned int)-1;\n  if (M < 0.0 || M >= 1.0) {\n    return (unsigned int)-1;\n  } else {\n    v7 = 1.0;\n    if (a2 <= 0.0) v7 = -1.0;\n    E_old = libmin_fabs(M) / 6.28318530718;\n    v8 = E_old - libmin_floor(E_old);\n    v9 = 1.0;\n    if ((v8 + v8) * 3.14159265359 * v7 <= 0.0) v9 = -1.0;\n    v10 = libmin_fabs(v8);\n    v11 = v10;\n    if (v10 > 3.14159265359) {\n      v11 = 6.28318530718 - v10;\n      v9 = -1.0;\n    }\n    v12 = 1.570796326795;\n    for (i = 0;; ++i) {\n      v14 = v6(v12, M, v11, v12, 0);\n      *E = v14;\n      v15 = v12 - v14;\n      if (libmin_fabs(M) < e) break;\n      v12 = *E;\n    }\n    *E = v9 * *E;\n    v6(0.0, 0.0, 0.0, v15, 1);\n  }\n  return i;\n}", "binary": "kepler/kepler.host.O2", "assembly": "<kepler>:\nendbr64\npush   %r14\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovsd  %xmm1,0x10(%rsp)\nmovsd  %xmm2,0x18(%rsp)\ncmp    $0x4,%esi\nja     1c9e <kepler+0x1be>\nmovslq %esi,%rdx\nlea    0x7253(%rip),%rax\nmov    %rdi,%rbx\nmov    (%rax,%rdx,8),%rbp\ncmp    $0x3,%esi\nje     1c90 <kepler+0x1b0>\nmovsd  0x10(%rsp),%xmm5\npxor   %xmm6,%xmm6\ncomisd %xmm5,%xmm6\nja     1c9e <kepler+0x1be>\ncomisd 0x477f(%rip),%xmm5\njae    1c9e <kepler+0x1be>\ncomisd %xmm6,%xmm0\nmov    0x476e(%rip),%rax\nmovq   %rax,%xmm2\nja     1b59 <kepler+0x79>\nmovsd  0x4777(%rip),%xmm2\nmovsd  %xmm2,0x8(%rsp)\ncall   20f0 <libmin_fabs>\nmovapd %xmm0,%xmm1\ndivsd  0x4780(%rip),%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm1,(%rsp)\ncall   2130 <libmin_floor>\nmovsd  (%rsp),%xmm1\npxor   %xmm7,%xmm7\nmovsd  0x8(%rsp),%xmm2\nmov    0x4724(%rip),%rax\nsubsd  %xmm0,%xmm1\nmov    %rax,%r14\nmovapd %xmm1,%xmm0\naddsd  %xmm1,%xmm0\nmulsd  0x474d(%rip),%xmm0\nmulsd  %xmm2,%xmm0\ncomisd %xmm7,%xmm0\nja     1bc2 <kepler+0xe2>\nmovsd  0x4713(%rip),%xmm7\nmovq   %xmm7,%r14\ncall   20f0 <libmin_fabs>\ncomisd 0x4729(%rip),%xmm0\nmovapd %xmm0,%xmm2\nja     1c68 <kepler+0x188>\nmovsd  0x46f7(%rip),%xmm3\nxor    %r12d,%r12d\njmp    1bf8 <kepler+0x118>\ncs nopw 0x0(%rax,%rax,1)\nmovsd  (%rbx),%xmm3\nadd    $0x1,%r12d\nxor    %edi,%edi\nmovsd  %xmm2,0x8(%rsp)\nmovsd  0x10(%rsp),%xmm1\nmovapd %xmm3,%xmm0\nmovsd  %xmm3,(%rsp)\ncall   *%rbp\nmovsd  (%rsp),%xmm3\nmovsd  %xmm0,(%rbx)\nsubsd  %xmm0,%xmm3\nmovapd %xmm3,%xmm0\ncall   20f0 <libmin_fabs>\ncomisd 0x18(%rsp),%xmm0\nmovsd  0x8(%rsp),%xmm2\njae    1bf0 <kepler+0x110>\nmovq   %r14,%xmm0\npxor   %xmm2,%xmm2\nmov    $0x1,%edi\nmulsd  (%rbx),%xmm0\nmovapd %xmm2,%xmm1\nmovsd  %xmm0,(%rbx)\npxor   %xmm0,%xmm0\ncall   *%rbp\nadd    $0x28,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nmovsd  0x4680(%rip),%xmm6\nsubsd  %xmm0,%xmm6\nmovapd %xmm6,%xmm2\nmovsd  0x4650(%rip),%xmm6\nmovq   %xmm6,%r14\njmp    1bd9 <kepler+0xf9>\nnopw   0x0(%rax,%rax,1)\ncomisd 0x4650(%rip),%xmm1\njbe    1b1d <kepler+0x3d>\nmov    $0xffffffff,%r12d\njmp    1c55 <kepler+0x175>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tint n = 1,i=1;\n\tint m=1;\n\tdouble sign = 1.0;\n\tdouble M = 0.0, e = -0.1, E_old=PI/2 ,E;\n\tdouble (*method)(double,double, double,int);\n\n\n\t/* Process command line options */\n\n\twhile(argv[i][0] == '-'){\n\t\t  if(libmin_strcmp(argv[i],\"-h\")==0){\n\t\t\tlibmin_printf(\"%s\\n\", HELP);\n\t\t\tlibmin_success();\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-v\")==0){\n\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\tlibmin_success();\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-a\")==0){\n\t\t\tderror = libmin_atof(argv[i+1]);\n\t\t\tif(derror <= DBL_EPSILON)\n\t\t\t        libmin_printf(\"Warning: requested precision may exceed implementation limit.\\n\");\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t  }\n\t\t  if(libmin_strcmp(argv[i],\"-m\")==0){\n\t\t\tm = libmin_atoi(argv[i+1]);\n\t\t\tif((m<=0) || (m>NMETHODS)){\n\t\t\t\tlibmin_printf(\"Bad method number %d\\n\",m);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t  }\n\t\t  libmin_printf(\"kepler: Unknown option %s\\n\", argv[i]);\n\t\t  libmin_printf(\"%s\\n\",USAGE);\n\t\t  return 1;\n\t\t}\n\tif(i + 2 > argc){\n\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\treturn 1;\n\t}\n\tM = libmin_atof(argv[i++]);\n\te = libmin_atof(argv[i]);\n\tmethod = (double(*)(double,double,double,int))methods[m-1];\n\n\tif((m==4)&&(e > LAPLACE_LIMIT)){\n\t\tlibmin_printf(\"e cannot exceed %f for this method.\\n\",\n\t\t\t\tLAPLACE_LIMIT);\n\t\treturn 1;\n\t}\n\n\tif((e<0)||(e>=1.0)){\n\t\tlibmin_printf(\"Eccentricity %f out of range.\\n\",e);\n\t\treturn 1;\n\t}\n\n\t/* Normalize M to lie between 0 and PI */\n\tsign = M > 0 ? 1.0 : -1.0;\n\tM = libmin_fabs(M)/(2*PI);\n\tM = (M - libmin_floor(M))*2*PI*sign;\n\tsign = 1.0;\n\tif(M > PI){\n\t\tM = 2*PI - M;\n\t\tsign = -1.0;\n\t}\n\t\n\t/* Do selected calculation, and quit when accuracy is bettered. */\n\twhile(libmin_fabs(E_old - (E = method(E_old,e,M,0))) >= derror){\n\t\tE_old = E;\n\t\tlibmin_printf(\"n = %d\\tE = %f\\n\",n++,sign*E);\n\t}\n\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  const char *v3; // rdi\n  char **v4; // rbx\n  int v5; // ebp\n  int v6; // r12d\n  __int64 v7; // rax\n  double v8; // xmm0_8\n  double v9; // xmm1_8\n  double (__usercall *v10)@<xmm0>(double@<xmm1>, double@<xmm2>, double@<xmm3>, int@<edi>); // rbx\n  double v11; // xmm2_8\n  double v12; // xmm0_8\n  double v13; // xmm0_8\n  double v14; // xmm3_8\n  int i; // ebp\n  int v16; // esi\n  double Ea; // [rsp+8h] [rbp-60h]\n  double Eb; // [rsp+8h] [rbp-60h]\n  double E; // [rsp+8h] [rbp-60h]\n  double e; // [rsp+18h] [rbp-50h]\n  double v22; // [rsp+20h] [rbp-48h]\n  double v23; // [rsp+28h] [rbp-40h]\n\n  v3 = ::argv[1];\n  if ( *::argv[1] == 45 )\n  {\n    v4 = ::argv;\n    v5 = 3;\n    v6 = 1;\n    do\n    {\n      if ( !libmin_strcmp(v3, \"-h\") )\n      {\n        libmin_printf(\n          (char *)\"%s\\n\",\n          \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n          \"-h: print this helpful message\\n\"\n          \"-v: print version number and exit\\n\"\n          \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n          \"-m: use selected calculation method k, where\\n\"\n          \"\\tk = 1: Simple iteration.\\n\"\n          \"\\tk = 2: Newton's method.\\n\"\n          \"\\tk = 3: Binary search.\\n\"\n          \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n          \"\\tk = 5: Fourier Bessel series.\\n\"\n          \"M = mean anomaly (radians)\\n\"\n          \"e = orbit eccentricty.\");\n        libmin_success();\n      }\n      if ( !libmin_strcmp(v4[1], \"-v\") )\n      {\n        libmin_printf((char *)\"%s\\n\", \"1.11\");\n        libmin_success();\n      }\n      if ( libmin_strcmp(v4[1], \"-a\") )\n      {\n        if ( libmin_strcmp(v4[1], \"-m\") )\n        {\n          libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[v5 - 2]);\n          goto LABEL_27;\n        }\n        v6 = libmin_atoi(v4[2]);\n        if ( (unsigned int)(v6 - 1) > 4 )\n        {\n          libmin_printf(\"Bad method number %d\\n\", v6);\n          return 1;\n        }\n      }\n      else\n      {\n        derror = libmin_atof(v4[2]);\n        if ( derror <= 2.220446049250313e-16 )\n          libmin_printf(\"Warning: requested precision may exceed implementation limit.\\n\");\n      }\n      v7 = v5;\n      v5 += 2;\n      v4 += 2;\n      v3 = ::argv[v7];\n    }\n    while ( *v3 == 45 );\n    if ( ::argc <= 4 )\n      goto LABEL_27;\n    Ea = libmin_atof(v3);\n    v8 = libmin_atof(::argv[4]);\n    v9 = Ea;\n    e = v8;\n    v10 = (double (__usercall *)@<xmm0>(double@<xmm1>, double@<xmm2>, double@<xmm3>, int@<edi>))methods[v6 - 1];\n    if ( v6 == 4 && v8 > 0.6627434193 )\n    {\n      libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n      return 1;\n    }\n  }\n  else\n  {\n    if ( ::argc <= 2 )\n    {\nLABEL_27:\n      libmin_printf((char *)\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n      return 1;\n    }\n    v10 = strict_iteration;\n    v9 = libmin_atof(::argv[1]);\n    e = libmin_atof(::argv[2]);\n  }\n  if ( e >= 0.0 && e < 1.0 )\n  {\n    v11 = 1.0;\n    if ( v9 <= 0.0 )\n      v11 = -1.0;\n    Eb = libmin_fabs(v9) / 6.28318530718;\n    v12 = libmin_floor(Eb);\n    v13 = (Eb - v12 + Eb - v12) * 3.14159265359 * v11;\n    v22 = v13;\n    if ( v13 <= 3.14159265359 )\n    {\n      v23 = 1.0;\n    }\n    else\n    {\n      v23 = -1.0;\n      v22 = 6.28318530718 - v13;\n    }\n    v14 = 1.570796326795;\n    for ( i = 1; ; ++i )\n    {\n      E = v10(e, v22, v14, 0);\n      if ( libmin_fabs(e) < derror )\n        break;\n      v16 = i;\n      libmin_printf(\"n = %d\\tE = %f\\n\", v16, E * v23);\n      v14 = E;\n    }\n    libmin_success();\n  }\n  libmin_printf(\"Eccentricity %f out of range.\\n\", e);\n  return 1;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  const char *v3;\n  char **v4;\n  int v5;\n  int v6;\n  long long v7;\n  double v8;\n  double v9;\n  double(__usercall * v10)\n      @<xmm0>(double @<xmm1>, double @<xmm2>, double @<xmm3>, int @<edi>);\n  double v11;\n  double v12;\n  double v13;\n  double v14;\n  int i;\n  int v16;\n  double Ea;\n  double Eb;\n  double E;\n  double e;\n  double v22;\n  double v23;\n  v3 = ::argv[1];\n  if (*::argv[1] == 45) {\n    v4 = ::argv;\n    v5 = 3;\n    v6 = 1;\n    do {\n      if (!libmin_strcmp(v3, \"-h\")) {\n        libmin_printf(\n            (char *)\"%s\\n\",\n            \"kepler [-h -v -a <.nnnn...> -m <k>] M e\\n\"\n            \"-h: print this helpful message\\n\"\n            \"-v: print version number and exit\\n\"\n            \"-a: obtain solution to accuracy of  < .nnnn (default .0000001)\\n\"\n            \"-m: use selected calculation method k, where\\n\"\n            \"\\tk = 1: Simple iteration.\\n\"\n            \"\\tk = 2: Newton's method.\\n\"\n            \"\\tk = 3: Binary search.\\n\"\n            \"\\tk = 4: Series in powers of e. (e<.6627434193.)\\n\"\n            \"\\tk = 5: Fourier Bessel series.\\n\"\n            \"M = mean anomaly (radians)\\n\"\n            \"e = orbit eccentricty.\");\n        libmin_success();\n      }\n      if (!libmin_strcmp(v4[1], \"-v\")) {\n        libmin_printf((char *)\"%s\\n\", \"1.11\");\n        libmin_success();\n      }\n      if (libmin_strcmp(v4[1], \"-a\")) {\n        if (libmin_strcmp(v4[1], \"-m\")) {\n          libmin_printf(\"kepler: Unknown option %s\\n\", ::argv[v5 - 2]);\n          goto LABEL_27;\n        }\n        v6 = libmin_atoi(v4[2]);\n        if ((unsigned int)(v6 - 1) > 4) {\n          libmin_printf(\"Bad method number %d\\n\", v6);\n          return 1;\n        }\n      } else {\n        derror = libmin_atof(v4[2]);\n        if (derror <= 2.220446049250313e-16)\n          libmin_printf(\n              \"Warning: requested precision may exceed implementation \"\n              \"limit.\\n\");\n      }\n      v7 = v5;\n      v5 += 2;\n      v4 += 2;\n      v3 = ::argv[v7];\n    } while (*v3 == 45);\n    if (::argc <= 4) goto LABEL_27;\n    Ea = libmin_atof(v3);\n    v8 = libmin_atof(::argv[4]);\n    v9 = Ea;\n    e = v8;\n    v10 = (double(__usercall *)\n               @<xmm0>(double @<xmm1>, double @<xmm2>, double @<xmm3>,\n                       int @<edi>))methods[v6 - 1];\n    if (v6 == 4 && v8 > 0.6627434193) {\n      libmin_printf(\"e cannot exceed %f for this method.\\n\", 0.6627434193);\n      return 1;\n    }\n  } else {\n    if (::argc <= 2) {\n    LABEL_27:\n      libmin_printf((char *)\"%s\\n\", \"kepler [-h -v -a <.nnnn...> -m <k>] M e\");\n      return 1;\n    }\n    v10 = strict_iteration;\n    v9 = libmin_atof(::argv[1]);\n    e = libmin_atof(::argv[2]);\n  }\n  if (e >= 0.0 && e < 1.0) {\n    v11 = 1.0;\n    if (v9 <= 0.0) v11 = -1.0;\n    Eb = libmin_fabs(v9) / 6.28318530718;\n    v12 = libmin_floor(Eb);\n    v13 = (Eb - v12 + Eb - v12) * 3.14159265359 * v11;\n    v22 = v13;\n    if (v13 <= 3.14159265359) {\n      v23 = 1.0;\n    } else {\n      v23 = -1.0;\n      v22 = 6.28318530718 - v13;\n    }\n    v14 = 1.570796326795;\n    for (i = 1;; ++i) {\n      E = v10(e, v22, v14, 0);\n      if (libmin_fabs(e) < derror) break;\n      v16 = i;\n      libmin_printf(\"n = %d\\tE = %f\\n\", v16, E * v23);\n      v14 = E;\n    }\n    libmin_success();\n  }\n  libmin_printf(\"Eccentricity %f out of range.\\n\", e);\n  return 1;\n}", "binary": "kepler/kepler.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    0x7f2f(%rip),%rdi\ncmpb   $0x2d,(%rdi)\njne    14b2 <main+0x3b2>\nlea    0x7f17(%rip),%rbx\nmov    $0x3,%ebp\nmov    $0x1,%r12d\nlea    0x4ec9(%rip),%r15\nlea    0x4ec5(%rip),%r14\nlea    0x4ec6(%rip),%r13\nlea    -0x2(%rbp),%eax\nmov    %r15,%rsi\nmov    %eax,0x8(%rsp)\ncall   4830 <libmin_strcmp>\ntest   %eax,%eax\nje     1370 <main+0x270>\nmov    0x8(%rbx),%rdi\nmov    %r14,%rsi\ncall   4830 <libmin_strcmp>\ntest   %eax,%eax\nje     139c <main+0x29c>\nmov    0x8(%rbx),%rdi\nmov    %r13,%rsi\ncall   4830 <libmin_strcmp>\ntest   %eax,%eax\nje     13c8 <main+0x2c8>\nmov    0x8(%rbx),%rdi\nlea    0x4e7f(%rip),%rsi\ncall   4830 <libmin_strcmp>\ntest   %eax,%eax\njne    1425 <main+0x325>\nmov    0x10(%rbx),%rdi\ncall   2030 <libmin_atoi>\nmov    %eax,%r12d\nlea    -0x1(%rax),%eax\ncmp    $0x4,%eax\nja     1400 <main+0x300>\nmovslq %ebp,%rax\nlea    0x7e7e(%rip),%rcx\nadd    $0x2,%ebp\nadd    $0x10,%rbx\nmov    (%rcx,%rax,8),%rdi\ncmpb   $0x2d,(%rdi)\nje     1149 <main+0x49>\ncmpl   $0x4,0x7e3b(%rip)\njle    1443 <main+0x343>\ncall   1e90 <libmin_atof>\nmov    0x7e71(%rip),%rdi\nmovsd  %xmm0,0x8(%rsp)\ncall   1e90 <libmin_atof>\nlea    -0x1(%r12),%eax\ncmp    $0x4,%r12d\nlea    0x7b56(%rip),%rdx\ncltq\nmovsd  0x8(%rsp),%xmm1\nmovsd  %xmm0,0x18(%rsp)\nmov    (%rdx,%rax,8),%rbx\nje     145f <main+0x35f>\nmovsd  0x18(%rsp),%xmm5\npxor   %xmm0,%xmm0\ncomisd %xmm5,%xmm0\nja     1491 <main+0x391>\ncomisd 0x507a(%rip),%xmm5\njae    1491 <main+0x391>\ncomisd %xmm0,%xmm1\nmov    0x5069(%rip),%rax\nmovq   %rax,%xmm2\nja     125e <main+0x15e>\nmovsd  0x5072(%rip),%xmm2\nmovapd %xmm1,%xmm0\nmovsd  %xmm2,0x10(%rsp)\ncall   20f0 <libmin_fabs>\nmovapd %xmm0,%xmm1\ndivsd  0x5077(%rip),%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm1,0x8(%rsp)\ncall   2130 <libmin_floor>\nmovsd  0x8(%rsp),%xmm1\nmovsd  0x10(%rsp),%xmm2\nsubsd  %xmm0,%xmm1\nmovapd %xmm1,%xmm0\naddsd  %xmm1,%xmm0\nmovsd  0x5050(%rip),%xmm1\nmulsd  %xmm1,%xmm0\nmulsd  %xmm2,%xmm0\ncomisd %xmm1,%xmm0\nmovsd  %xmm0,0x20(%rsp)\njbe    14ea <main+0x3ea>\nmovsd  0x5028(%rip),%xmm6\nmovsd  0x5000(%rip),%xmm7\nsubsd  %xmm0,%xmm6\nmovsd  %xmm7,0x28(%rsp)\nmovsd  %xmm6,0x20(%rsp)\nmovsd  0x4ff0(%rip),%xmm3\nmov    $0x1,%ebp\nlea    0x4d52(%rip),%r12\njmp    131e <main+0x21e>\nmovsd  0x8(%rsp),%xmm0\nmov    %ebp,%esi\nmov    %r12,%rdi\nmov    $0x1,%eax\nmulsd  0x28(%rsp),%xmm0\nlea    0x1(%rbp),%r13d\nmov    %r13d,%ebp\ncall   3ee0 <libmin_printf>\nmovsd  0x8(%rsp),%xmm3\nxor    %edi,%edi\nmovsd  0x20(%rsp),%xmm2\nmovsd  0x18(%rsp),%xmm1\nmovapd %xmm3,%xmm0\nmovsd  %xmm3,0x10(%rsp)\ncall   *%rbx\nmovsd  0x10(%rsp),%xmm3\nmovsd  %xmm0,0x8(%rsp)\nsubsd  %xmm0,%xmm3\nmovapd %xmm3,%xmm0\ncall   20f0 <libmin_fabs>\ncomisd 0x7cc7(%rip),%xmm0\njae    12f6 <main+0x1f6>\ncall   48c0 <libmin_success>\nxor    %eax,%eax\njmp    1416 <main+0x316>\nnopw   0x0(%rax,%rax,1)\nlea    0x4cf1(%rip),%rsi\nlea    0x4cc4(%rip),%rdi\ncall   3ee0 <libmin_printf>\ncall   48c0 <libmin_success>\nmov    0x8(%rbx),%rdi\nmov    %r14,%rsi\ncall   4830 <libmin_strcmp>\ntest   %eax,%eax\njne    1174 <main+0x74>\nlea    0x4c67(%rip),%rsi\nlea    0x4c98(%rip),%rdi\ncall   3ee0 <libmin_printf>\ncall   48c0 <libmin_success>\nmov    0x8(%rbx),%rdi\nmov    %r13,%rsi\ncall   4830 <libmin_strcmp>\ntest   %eax,%eax\njne    1188 <main+0x88>\nmov    0x10(%rbx),%rdi\ncall   1e90 <libmin_atof>\nmovsd  0x4f07(%rip),%xmm1\nmovsd  %xmm0,0x7c3f(%rip)\ncomisd %xmm0,%xmm1\njb     11b8 <main+0xb8>\nlea    0x4e16(%rip),%rdi\nxor    %eax,%eax\ncall   3ee0 <libmin_printf>\njmp    11b8 <main+0xb8>\nxchg   %ax,%ax\nmov    %r12d,%esi\nlea    0x4c0b(%rip),%rdi\nxor    %eax,%eax\ncall   3ee0 <libmin_printf>\nmov    $0x1,%eax\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovslq 0x8(%rsp),%rax\nlea    0x7c0f(%rip),%rdx\nlea    0x4bf3(%rip),%rdi\nmov    (%rdx,%rax,8),%rsi\nxor    %eax,%eax\ncall   3ee0 <libmin_printf>\nlea    0x4dfe(%rip),%rsi\nlea    0x4bf1(%rip),%rdi\nxor    %eax,%eax\ncall   3ee0 <libmin_printf>\nmov    $0x1,%eax\njmp    1416 <main+0x316>\ncomisd 0x4e81(%rip),%xmm0\njbe    1222 <main+0x122>\nmov    0x4e74(%rip),%rax\nlea    0x4df5(%rip),%rdi\nmovq   %rax,%xmm0\nmov    $0x1,%eax\ncall   3ee0 <libmin_printf>\nmov    $0x1,%eax\njmp    1416 <main+0x316>\nmovsd  0x18(%rsp),%xmm0\nlea    0x4dfa(%rip),%rdi\nmov    $0x1,%eax\ncall   3ee0 <libmin_printf>\nmov    $0x1,%eax\njmp    1416 <main+0x316>\ncmpl   $0x2,0x7b5f(%rip)\njle    1443 <main+0x343>\ncall   1e90 <libmin_atof>\nmov    0x7b89(%rip),%rdi\nlea    0x122(%rip),%rbx\nmovsd  %xmm0,0x8(%rsp)\ncall   1e90 <libmin_atof>\nmovsd  0x8(%rsp),%xmm1\nmovsd  %xmm0,0x18(%rsp)\njmp    1222 <main+0x122>\nmov    0x4dc7(%rip),%rax\nmov    %rax,0x28(%rsp)\njmp    12e0 <main+0x1e0>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "newton", "content": "/* The following routine is used to solve kepler's equation using\n   Newton's method. It is very fast and reliable for small values of\n   e, but can be wildly erratic for e close to 1. See, e.g, the discussion\n   in Jean Meeus, Astronomical Algorithms, Willmann-Bell, 1991, 181-193.\n*/\n\ndouble newton(double E, double e, double M, int reset)\n{\n\t/* reset is not used in this routine. It may generate a compiler\n           warning */\n\treturn E + (M + e*libmin_sin(E) - E)/(1 - e*libmin_cos(E));\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O2.pseudo", "function_name": "newton", "address": "0x1620", "label": "newton", "content": "double __fastcall newton(double a1, double E, double e, double M, int reset)\n{\n  double Ea; // [rsp+18h] [rbp-10h]\n\n  Ea = e + libmin_sin(E) * E - a1;\n  return Ea / (1.0 - libmin_cos(Ea) * E) + a1;\n}\n"}, "pseudo_normalize": "", "binary": "kepler/kepler.host.O2", "assembly": "<newton>:\nendbr64\nsub    $0x28,%rsp\nmovsd  %xmm2,0x10(%rsp)\nmovsd  %xmm1,0x8(%rsp)\nmovsd  %xmm0,0x18(%rsp)\ncall   4470 <libmin_sin>\nmulsd  0x8(%rsp),%xmm0\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x18(%rsp),%xmm3\nmovsd  %xmm3,0x10(%rsp)\naddsd  %xmm0,%xmm1\nmovapd %xmm3,%xmm0\nsubsd  %xmm3,%xmm1\nmovsd  %xmm1,0x18(%rsp)\ncall   4310 <libmin_cos>\nmulsd  0x8(%rsp),%xmm0\nmovsd  0x4c3c(%rip),%xmm2\nmovsd  0x18(%rsp),%xmm1\nmovsd  0x10(%rsp),%xmm3\nadd    $0x28,%rsp\nsubsd  %xmm0,%xmm2\ndivsd  %xmm2,%xmm1\nmovapd %xmm1,%xmm0\naddsd  %xmm3,%xmm0\nret\nnopl   (%rax)\n"}
{"source": {"path": "kepler/kepler.c", "function_name": "strict_iteration", "content": "/* All the algorithms for solving kepler's equation are implemented in\n   the following subroutines. A subroutine is called iteratively from\n   main, until the previous value of E differs from the current one by\n   less than derror.\n\n   To add a new method, add its implementation as a subroutine \n   with signature\n\n\tdouble foo(double E, double e, double M, int reset);\n\n   It should return a better approximation to the true E\n   given the current E and the values of e and M. When passed a \n   nonzero value for the reset parameter it should reinitialize any\n   static information it retains and return.\n   Then add the address of\n   the new subroutine to the methods array defined below.\n*/ \n\n/* CURRENTLY IMPLEMENTED METHODS: */\n\n/* Used to solve kepler's equation by simple iteration */\n\ndouble strict_iteration(double E, double e, double M, int reset)\n{\n\n\t/* reset is not used in this routine. It may generate a compiler\n           warning */\n\treturn M + e*libmin_sin(E);\n}\n"}, "pseudo": {"path": "kepler/kepler.host.O2.pseudo", "function_name": "strict_iteration", "address": "0x15f0", "label": "strict_iteration", "content": "double __fastcall strict_iteration(double a1, double E, double e, double M, int reset)\n{\n  return libmin_sin(E) * E + e;\n}\n"}, "pseudo_normalize": "", "binary": "kepler/kepler.host.O2", "assembly": "<strict_iteration>:\nendbr64\nsub    $0x18,%rsp\nmovsd  %xmm1,(%rsp)\nmovsd  %xmm2,0x8(%rsp)\ncall   4470 <libmin_sin>\nmulsd  (%rsp),%xmm0\naddsd  0x8(%rsp),%xmm0\nadd    $0x18,%rsp\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "knapsack/knapsack.c", "function_name": "knapSack", "content": "// Returns the maximum value that can be put in a knapsack of capacity W\nvoid\nknapSack(int wt[], int val[], int K[N+1][W+1])\n{\n  int i, w;\n\n  // Build table K[][] in bottom up manner\n  for (i = 0; i <= N; i++)\n  {\n    for (w = 0; w <= W; w++)\n    {\n      if (i==0 || w==0)\n        K[i][w] = 0;\n      else\n      {\n        if (wt[i-1] <= w)\n          K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]);\n        else\n          K[i][w] = K[i-1][w];\n      }\n    }\n  }\n}\n"}, "pseudo": {"path": "knapsack/knapsack.host.O2.pseudo", "function_name": "knapSack", "address": "0x1320", "label": "knapSack", "content": "void __fastcall knapSack(int *wt, int *val, int (*K)[251])\n{\n  int *v5; // r11\n  int *v6; // r10\n  int v7; // ebx\n  int *v8; // r9\n  __int64 i; // rax\n  int v10; // edx\n\n  v5 = val - 1;\n  v6 = wt - 1;\n  v7 = 0;\n  do\n  {\n    v8 = &(*K)[-251];\n    for ( i = 0LL; i != 251; ++i )\n    {\n      while ( !(_DWORD)i || !v7 )\n      {\n        (*K)[i++] = 0;\n        if ( i == 251 )\n          goto LABEL_10;\n      }\n      v10 = v8[i];\n      if ( *v6 <= (int)i && v10 < v8[(int)i - *v6] + *v5 )\n        v10 = v8[(int)i - *v6] + *v5;\n      (*K)[i] = v10;\n    }\nLABEL_10:\n    ++v7;\n    ++K;\n    ++v5;\n    ++v6;\n  }\n  while ( v7 != 51 );\n}\n"}, "pseudo_normalize": "void knapSack(int *wt, int *val, int (*K)[251]) {\n  int *v5;\n  int *v6;\n  int v7;\n  int *v8;\n  long long i;\n  int v10;\n  v5 = val - 1;\n  v6 = wt - 1;\n  v7 = 0;\n  do {\n    v8 = &(*K)[-251];\n    for (i = 0LL; i != 251; ++i) {\n      while (!(uint32_t)i || !v7) {\n        (*K)[i++] = 0;\n        if (i == 251) goto LABEL_10;\n      }\n      v10 = v8[i];\n      if (*v6 <= (int)i && v10 < v8[(int)i - *v6] + *v5)\n        v10 = v8[(int)i - *v6] + *v5;\n      (*K)[i] = v10;\n    }\n  LABEL_10:\n    ++v7;\n    ++K;\n    ++v5;\n    ++v6;\n  } while (v7 != 51);\n}", "binary": "knapsack/knapsack.host.O2", "assembly": "<knapSack>:\nendbr64\nmov    %rdi,%r10\npush   %rbx\nmov    %rdx,%rdi\nlea    -0x4(%rsi),%r11\nsub    $0x4,%r10\nxor    %ebx,%ebx\ntest   %ebx,%ebx\nlea    -0x3ec(%rdi),%r9\nsete   %r8b\nxor    %eax,%eax\njmp    137b <knapSack+0x5b>\ncs nopw 0x0(%rax,%rax,1)\nmov    (%r10),%esi\nmov    (%r9,%rax,4),%edx\ncmp    %eax,%esi\njg     136c <knapSack+0x4c>\nsub    %esi,%ecx\nmov    (%r11),%esi\nmovslq %ecx,%rcx\nadd    (%r9,%rcx,4),%esi\ncmp    %esi,%edx\ncmovl  %esi,%edx\nmov    %edx,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    $0xfb,%rax\nje     1397 <knapSack+0x77>\nmov    %eax,%ecx\ntest   %eax,%eax\nje     1386 <knapSack+0x66>\ntest   %r8b,%r8b\nje     1350 <knapSack+0x30>\nxor    %edx,%edx\nmov    %edx,(%rdi,%rax,4)\nadd    $0x1,%rax\ncmp    $0xfb,%rax\njne    137b <knapSack+0x5b>\nadd    $0x1,%ebx\nadd    $0x3ec,%rdi\nadd    $0x4,%r11\nadd    $0x4,%r10\ncmp    $0x33,%ebx\njne    1335 <knapSack+0x15>\npop    %rbx\nret\n"}
{"source": {"path": "knapsack/knapsack.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int n = N;\n  int w = W;\n  int K[N+1][W+1];\n\n\n  knapSack(wt, val, K);\n\n\tlibmin_printf(\"Max value: %d\\n\", K[n][W]);\n\t\n  libmin_printf(\"Selected packs:\\n\");\n  while (n != 0)\n  {\n    if (K[n][w] != K[n - 1][w]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", n, wt[n - 1], val[n - 1]);\n      w = w - wt[n-1];\n    }\n    n--;\n  }\n  libmin_printf(\"Total weight: %d\\n\", W - w);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "knapsack/knapsack.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "// positive sp value has been detected, the output may be wrong!\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rbx\n  int v4; // r12d\n  int v6[516]; // [rsp-1838h] [rbp-E070h] BYREF\n  __int64 v7; // [rsp-1028h] [rbp-D860h] BYREF\n  __int64 v8; // [rsp-28h] [rbp-C860h] BYREF\n  int K[51][251]; // [rsp+0h] [rbp-C838h]\n\n  while ( &v7 != &v8 - 6144 )\n    ;\n  v3 = 49LL;\n  v4 = 250;\n  *(_QWORD *)&K[44][208] = __readfsqword(0x28u);\n  knapSack(wt, val, (int (*)[251])v6);\n  libmin_printf(\"Max value: %d\\n\", K[44][206]);\n  libmin_printf(\"Selected packs:\\n\");\n  while ( 1 )\n  {\n    if ( v6[251 * (int)v3 + 251 + v4] != v6[251 * (int)v3 + v4] )\n    {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", v3 + 1, wt[v3], val[v3]);\n      v4 -= wt[v3];\n    }\n    if ( v3-- == 0 )\n    {\n      libmin_printf(\"Total weight: %d\\n\", 250 - v4);\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  int v6[516];\n  long long v7;\n  long long v8;\n  int K[51][251];\n  while (&v7 != &v8 - 6144)\n    ;\n  v3 = 49LL;\n  v4 = 250;\n  *(uint64_t *)&K[44][208] = __readfsqword(40u);\n  knapSack(wt, val, (int(*)[251])v6);\n  libmin_printf(\"Max value: %d\\n\", K[44][206]);\n  libmin_printf(\"Selected packs:\\n\");\n  while (1) {\n    if (v6[251 * (int)v3 + 251 + v4] != v6[251 * (int)v3 + v4]) {\n      libmin_printf(\"  Package %d with wt=%d and val=%d\\n\", v3 + 1, wt[v3],\n                    val[v3]);\n      v4 -= wt[v3];\n    }\n    if (v3-- == 0) {\n      libmin_printf(\"Total weight: %d\\n\", 250 - v4);\n      libmin_success();\n    }\n  }\n}", "binary": "knapsack/knapsack.host.O2", "assembly": "<main>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    -0xc000(%rsp),%r11\nsub    $0x1000,%rsp\norq    $0x0,(%rsp)\ncmp    %r11,%rsp\njne    1114 <main+0x14>\nsub    $0x810,%rsp\nlea    0x3fcd(%rip),%r14\nlea    0x3ee6(%rip),%r13\nmov    $0x31,%ebx\nmov    %r14,%rsi\nmov    %r13,%rdi\nmov    $0xfa,%r12d\nlea    0x1ee6(%rip),%rbp\nmov    %fs:0x28,%rax\nmov    %rax,0xc808(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rdx\ncall   1320 <knapSack>\nmov    0xc800(%rsp),%esi\nlea    0x1e89(%rip),%rdi\nxor    %eax,%eax\ncall   28f0 <libmin_printf>\nlea    0x1e8a(%rip),%rdi\nxor    %eax,%eax\ncall   28f0 <libmin_printf>\nlea    0x1(%rbx),%esi\nmovslq %ebx,%rax\nmovslq %r12d,%rcx\nmovslq %esi,%rdx\nimul   $0xfb,%rax,%rax\nimul   $0xfb,%rdx,%rdx\nadd    %rcx,%rax\nadd    %rcx,%rdx\nmov    (%rsp,%rax,4),%eax\ncmp    %eax,(%rsp,%rdx,4)\nje     11d0 <main+0xd0>\nmov    (%r14,%rbx,4),%ecx\nmov    0x0(%r13,%rbx,4),%edx\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   28f0 <libmin_printf>\nsub    0x0(%r13,%rbx,4),%r12d\nsub    $0x1,%rbx\njae    1190 <main+0x90>\nmov    $0xfa,%esi\nlea    0x1e42(%rip),%rdi\nxor    %eax,%eax\nsub    %r12d,%esi\ncall   28f0 <libmin_printf>\ncall   2b30 <libmin_success>\nmov    0xc808(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1216 <main+0x116>\nadd    $0xc810,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "knapsack/knapsack.c", "function_name": "max", "content": "#endif /* !PROBLEM_TINY */\n\n// A utility function that returns maximum of two integers\nint\nmax(int a, int b)\n{\n  if (a > b)\n    return a;\n  else\n    return b;\n}\n"}, "pseudo": {"path": "knapsack/knapsack.host.O2.pseudo", "function_name": "max", "address": "0x1310", "label": "max", "content": "int __fastcall max(int a, int b)\n{\n  int result; // eax\n\n  result = b;\n  if ( a >= b )\n    return a;\n  return result;\n}\n"}, "pseudo_normalize": "int max(int a, int b) {\n  int result;\n  result = b;\n  if (a >= b) return a;\n  return result;\n}", "binary": "knapsack/knapsack.host.O2", "assembly": "<max>:\nendbr64\ncmp    %esi,%edi\nmov    %esi,%eax\ncmovge %edi,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "isSafe", "content": "/* A utility function to check if i,j are valid indexes\n   for N*N chessboard */\nint\nisSafe(int x, int y, int sol[N][N])\n{\n    return ( x >= 0 && x < N && y >= 0 && y < N && sol[x][y] == -1);\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O2.pseudo", "function_name": "isSafe", "address": "0x12f0", "label": "isSafe", "content": "int __fastcall isSafe(int x, int y, int (*sol)[5])\n{\n  return (unsigned int)x <= 4 && (unsigned int)y <= 4 && (*sol)[5 * x + y] == -1;\n}\n"}, "pseudo_normalize": "", "binary": "knights-tour/knights-tour.host.O2", "assembly": "<isSafe>:\nendbr64\ncmp    $0x4,%edi\nja     12fe <isSafe+0xe>\ncmp    $0x4,%esi\njbe    1308 <isSafe+0x18>\nxor    %eax,%eax\nret\nnopl   0x0(%rax)\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nlea    (%rdi,%rdi,4),%rax\nlea    (%rdx,%rax,4),%rax\ncmpl   $0xffffffff,(%rax,%rsi,4)\nsete   %al\nmovzbl %al,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "main", "content": "/* Driver program to test above functions */\nint\nmain(void)\n{\n    solveKT();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  solveKT();\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "knights-tour/knights-tour.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\ncall   1390 <solveKT>\ncall   2c90 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "printSolution", "content": "/* A utility function to print solution matrix sol[N][N] */\nvoid\nprintSolution(int sol[N][N])\n{\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++)\n            libmin_printf(\" %2d \", sol[x][y]);\n        libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O2.pseudo", "function_name": "printSolution", "address": "0x1330", "label": "printSolution", "content": "void __fastcall printSolution(int (*sol)[5])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n  int v3; // esi\n\n  v1 = &(*sol)[5];\n  do\n  {\n    v2 = v1 - 5;\n    do\n    {\n      v3 = *v2++;\n      libmin_printf(\" %2d \", v3);\n    }\n    while ( v2 != v1 );\n    v1 = v2 + 5;\n    libmin_printf(\"\\n\");\n  }\n  while ( v2 + 5 != &(*sol)[30] );\n}\n"}, "pseudo_normalize": "void printSolution(int (*sol)[5]) {\n  int *v1;\n  int *v2;\n  int v3;\n  v1 = &(*sol)[5];\n  do {\n    v2 = v1 - 5;\n    do {\n      v3 = *v2++;\n      libmin_printf(\" %2d \", v3);\n    } while (v2 != v1);\n    v1 = v2 + 5;\n    libmin_printf(\"\\n\");\n  } while (v2 + 5 != &(*sol)[30]);\n}", "binary": "knights-tour/knights-tour.host.O2", "assembly": "<printSolution>:\nendbr64\npush   %r14\nlea    0x1ccd(%rip),%r14\npush   %r13\nlea    0x78(%rdi),%r13\npush   %r12\nlea    0x1cb8(%rip),%r12\npush   %rbp\nlea    0x14(%rdi),%rbp\npush   %rbx\nlea    -0x14(%rbp),%rbx\nmov    (%rbx),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   2a50 <libmin_printf>\ncmp    %rbp,%rbx\njne    1356 <printSolution+0x26>\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    0x14(%rbx),%rbp\ncall   2a50 <libmin_printf>\ncmp    %r13,%rbp\njne    1352 <printSolution+0x22>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "solveKT", "content": "/* This function solves the Knight Tour problem using\n   Backtracking.  This function mainly uses solveKTUtil()\n   to solve the problem. It returns false if no complete\n   tour is possible, otherwise return true and prints the\n   tour.\n*/\nint\nsolveKT(void)\n{\n    int sol[N][N];\n\n    /* Initialization of solution matrix */\n    for (int x = 0; x < N; x++)\n        for (int y = 0; y < N; y++)\n            sol[x][y] = -1;\n\n    /* xMove[] and yMove[] define next move of Knight.\n       xMove[] is for next value of x coordinate\n       yMove[] is for next value of y coordinate */\n    int xMove[8] = {  2, 1, -1, -2, -2, -1,  1,  2 };\n    int yMove[8] = {  1, 2,  2,  1, -1, -2, -2, -1 };\n\n    // Since the Knight is initially at the first block\n    sol[0][0]  = 0;\n\n    /* Start from 0,0 and explore all tours using\n       solveKTUtil() */\n    if (solveKTUtil(0, 0, 1, sol, xMove, yMove) == 0) {\n        libmin_printf(\"Solution does not exist\");\n        return 0;\n    }\n    else\n        printSolution(sol);\n\n    return 1;\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O2.pseudo", "function_name": "solveKT", "address": "0x1390", "label": "solveKT", "content": "int __cdecl solveKT()\n{\n  int *v0; // rax\n  int v1; // r12d\n  int *v2; // rbp\n  int *v3; // rbx\n  int v4; // esi\n  int xMove[8]; // [rsp+0h] [rbp-D8h] BYREF\n  int yMove[8]; // [rsp+20h] [rbp-B8h] BYREF\n  int sol[5][5]; // [rsp+40h] [rbp-98h] BYREF\n  char v9; // [rsp+A4h] [rbp-34h] BYREF\n  unsigned __int64 v10; // [rsp+A8h] [rbp-30h]\n  __int64 v11; // [rsp+B8h] [rbp-20h] BYREF\n\n  v10 = __readfsqword(0x28u);\n  v0 = sol[0];\n  do\n  {\n    *v0 = -1;\n    v0 += 5;\n    *(v0 - 4) = -1;\n    *(v0 - 3) = -1;\n    *(v0 - 2) = -1;\n    *(v0 - 1) = -1;\n  }\n  while ( v0 != (int *)&v9 );\n  *(_QWORD *)&xMove[4] = -2LL;\n  *(_QWORD *)xMove = 0x100000002LL;\n  *(_QWORD *)&xMove[6] = 0x200000001LL;\n  *(_QWORD *)yMove = 0x200000001LL;\n  *(_QWORD *)&yMove[2] = 0x100000002LL;\n  *(_QWORD *)&xMove[2] = 0xFFFFFFFEFFFFFFFFLL;\n  *(_QWORD *)&yMove[4] = 0xFFFFFFFEFFFFFFFFLL;\n  *(_QWORD *)&yMove[6] = -2LL;\n  sol[0][0] = 0;\n  v1 = solveKTUtil_0(0, 0, 1, sol, xMove, yMove);\n  if ( v1 )\n  {\n    v2 = sol[1];\n    do\n    {\n      v3 = v2 - 5;\n      do\n      {\n        v4 = *v3++;\n        libmin_printf(\" %2d \", v4);\n      }\n      while ( v2 != v3 );\n      v2 += 5;\n      libmin_printf(\"\\n\");\n    }\n    while ( v2 != (int *)&v11 );\n    return 1;\n  }\n  else\n  {\n    libmin_printf(\"Solution does not exist\");\n  }\n  return v1;\n}\n"}, "pseudo_normalize": "int solveKT() {\n  int *v0;\n  int v1;\n  int *v2;\n  int *v3;\n  int v4;\n  int xMove[8];\n  int yMove[8];\n  int sol[5][5];\n  char v9;\n  unsigned long long v10;\n  long long v11;\n  v10 = __readfsqword(40u);\n  v0 = sol[0];\n  do {\n    *v0 = -1;\n    v0 += 5;\n    *(v0 - 4) = -1;\n    *(v0 - 3) = -1;\n    *(v0 - 2) = -1;\n    *(v0 - 1) = -1;\n  } while (v0 != (int *)&v9);\n  *(uint64_t *)&xMove[4] = -2LL;\n  *(uint64_t *)xMove = 4294967298LL;\n  *(uint64_t *)&xMove[6] = 8589934593LL;\n  *(uint64_t *)yMove = 8589934593LL;\n  *(uint64_t *)&yMove[2] = 4294967298LL;\n  *(uint64_t *)&xMove[2] = 18446744069414584319LL;\n  *(uint64_t *)&yMove[4] = 18446744069414584319LL;\n  *(uint64_t *)&yMove[6] = -2LL;\n  sol[0][0] = 0;\n  v1 = solveKTUtil_0(0, 0, 1, sol, xMove, yMove);\n  if (v1) {\n    v2 = sol[1];\n    do {\n      v3 = v2 - 5;\n      do {\n        v4 = *v3++;\n        libmin_printf(\" %2d \", v4);\n      } while (v2 != v3);\n      v2 += 5;\n      libmin_printf(\"\\n\");\n    } while (v2 != (int *)&v11);\n    return 1;\n  } else {\n    libmin_printf(\"Solution does not exist\");\n  }\n  return v1;\n}", "binary": "knights-tour/knights-tour.host.O2", "assembly": "<solveKT>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0xb0,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0xa8(%rsp)\nxor    %eax,%eax\nlea    0x40(%rsp),%r13\nlea    0xa4(%rsp),%rdx\nmov    %r13,%rax\nmovl   $0xffffffff,(%rax)\nadd    $0x14,%rax\nmovl   $0xffffffff,-0x10(%rax)\nmovl   $0xffffffff,-0xc(%rax)\nmovl   $0xffffffff,-0x8(%rax)\nmovl   $0xffffffff,-0x4(%rax)\ncmp    %rdx,%rax\njne    13c6 <solveKT+0x36>\nlea    0x20(%rsp),%r9\nmov    %rsp,%r8\nxor    %esi,%esi\nxor    %edi,%edi\nmovabs $0x100000002,%rdx\nmovabs $0x200000001,%rcx\nmovabs $0xfffffffeffffffff,%rax\nmovq   $0xfffffffffffffffe,0x10(%rsp)\nmov    %rdx,(%rsp)\nmov    %rcx,0x18(%rsp)\nmov    %rcx,0x20(%rsp)\nmov    %r13,%rcx\nmov    %rdx,0x28(%rsp)\nmov    $0x1,%edx\nmov    %rax,0x8(%rsp)\nmov    %rax,0x30(%rsp)\nmovq   $0xfffffffffffffffe,0x38(%rsp)\nmovl   $0x0,0x40(%rsp)\ncall   1210 <solveKTUtil.part.0>\nmov    %eax,%r12d\ntest   %eax,%eax\nje     14d8 <solveKT+0x148>\nlea    0x14(%r13),%rbp\nlea    0x1b93(%rip),%r12\nadd    $0x78,%r13\nlea    0x1b8e(%rip),%r14\nlea    -0x14(%rbp),%rbx\nmov    (%rbx),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   2a50 <libmin_printf>\ncmp    %rbx,%rbp\njne    1480 <solveKT+0xf0>\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x14,%rbp\ncall   2a50 <libmin_printf>\ncmp    %r13,%rbp\njne    147c <solveKT+0xec>\nmov    $0x1,%r12d\nmov    0xa8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    14e8 <solveKT+0x158>\nadd    $0xb0,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\nlea    0x1b2d(%rip),%rdi\nxor    %eax,%eax\ncall   2a50 <libmin_printf>\njmp    14ae <solveKT+0x11e>\ncall   10b0 <__stack_chk_fail@plt>\nnopl   (%rax)\n"}
{"source": {"path": "knights-tour/knights-tour.c", "function_name": "solveKTUtil", "content": "/* A recursive utility function to solve Knight Tour\n   problem */\nint\nsolveKTUtil(int x, int y, int movei, int sol[N][N], int xMove[N], int yMove[N])\n{\n   int k, next_x, next_y;\n   if (movei == N*N)\n       return 1;\n\n   /* Try all next moves from the current coordinate x, y */\n   for (k = 0; k < 8; k++) {\n       next_x = x + xMove[k];\n       next_y = y + yMove[k];\n       if (isSafe(next_x, next_y, sol)) {\n         sol[next_x][next_y] = movei;\n         if (solveKTUtil(next_x, next_y, movei+1, sol, xMove, yMove) == 1)\n             return 1;\n         else\n             sol[next_x][next_y] = -1;// backtracking\n       }\n   }\n\n   return 0;\n}\n"}, "pseudo": {"path": "knights-tour/knights-tour.host.O2.pseudo", "function_name": "solveKTUtil", "address": "0x14f0", "label": "solveKTUtil", "content": "int __fastcall solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove, int *yMove)\n{\n  if ( movei == 25 )\n    return 1;\n  else\n    return solveKTUtil_0(x, y, movei, sol, xMove, yMove);\n}\n"}, "pseudo_normalize": "int solveKTUtil(int x, int y, int movei, int (*sol)[5], int *xMove,\n                int *yMove) {\n  if (movei == 25)\n    return 1;\n  else\n    return solveKTUtil_0(x, y, movei, sol, xMove, yMove);\n}", "binary": "knights-tour/knights-tour.host.O2", "assembly": "<solveKTUtil>:\nendbr64\ncmp    $0x19,%edx\nje     1500 <solveKTUtil+0x10>\njmp    1210 <solveKTUtil.part.0>\nxchg   %ax,%ax\nmov    $0x1,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "draw", "content": "void\ndraw(void)\n{\n  // go to home position on screen\n  libmin_printf(\"\\x1b[H\");\n\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", evolution++);\n  for (int y = 0; y < GRID_HEIGHT; ++y)\n    {\n      for (int x = 0; x < GRID_WIDTH; ++x)\n        libmin_printf(\"%c\", grid[x][y]);\n      libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "draw", "address": "0x12f0", "label": "draw", "content": "void __cdecl draw()\n{\n  __int64 v0; // rbp\n  unsigned int v1; // esi\n  __int64 i; // rbx\n  char *v3; // rax\n\n  v0 = 0LL;\n  libmin_printf(\"\\x1B[H\");\n  v1 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v1);\n  do\n  {\n    for ( i = 0LL; i != 70; ++i )\n    {\n      v3 = grid[i];\n      libmin_printf(\"%c\", (unsigned int)v3[v0]);\n    }\n    ++v0;\n    libmin_printf(\"\\n\");\n  }\n  while ( v0 != 22 );\n}\n"}, "pseudo_normalize": "void draw() {\n  long long v0;\n  unsigned int v1;\n  long long i;\n  char *v3;\n  v0 = 0LL;\n  libmin_printf(\"\\x1B[H\");\n  v1 = evolution++;\n  libmin_printf(\"CONWAY'S Game of Life\\n\\nEvolution #%d\\n\\n\", v1);\n  do {\n    for (i = 0LL; i != 70; ++i) {\n      v3 = grid[i];\n      libmin_printf(\"%c\", (unsigned int)v3[v0]);\n    }\n    ++v0;\n    libmin_printf(\"\\n\");\n  } while (v0 != 22);\n}", "binary": "life/life.host.O2", "assembly": "<draw>:\nendbr64\npush   %r13\nlea    0x2d0c(%rip),%rdi\nxor    %eax,%eax\nlea    0x2d0a(%rip),%r13\npush   %r12\nlea    0x2cfe(%rip),%r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nsub    $0x8,%rsp\ncall   2d60 <libmin_printf>\nmov    0x4cee(%rip),%esi\nlea    0x2cef(%rip),%rdi\nlea    0x1(%rsi),%eax\nmov    %eax,0x4cde(%rip)\nxor    %eax,%eax\ncall   2d60 <libmin_printf>\nnopl   0x0(%rax)\nxor    %ebx,%ebx\nnopw   0x0(%rax,%rax,1)\nmov    0x4cd9(%rip),%rax\nmov    %r12,%rdi\nmov    (%rax,%rbx,1),%rax\nadd    $0x8,%rbx\nmovsbl (%rax,%rbp,1),%esi\nxor    %eax,%eax\ncall   2d60 <libmin_printf>\ncmp    $0x230,%rbx\njne    1348 <draw+0x58>\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbp\ncall   2d60 <libmin_printf>\ncmp    $0x16,%rbp\njne    1340 <draw+0x50>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   (%rax)\n"}
{"source": {"path": "life/life.c", "function_name": "flip", "content": "void\nflip(void)\n{\n  char **tmp = grid;\n  grid = gridTmp;\n  gridTmp = tmp;\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "flip", "address": "0x1620", "label": "flip", "content": "void __cdecl flip()\n{\n  char **v0; // rdx\n\n  v0 = gridTmp;\n  gridTmp = grid;\n  grid = v0;\n}\n"}, "pseudo_normalize": "void flip() {\n  char **v0;\n  v0 = gridTmp;\n  gridTmp = grid;\n  grid = v0;\n}", "binary": "life/life.host.O2", "assembly": "<flip>:\nendbr64\nmov    0x49fd(%rip),%rax\nmov    0x49ee(%rip),%rdx\nmov    %rax,0x49e7(%rip)\nmov    %rdx,0x49e8(%rip)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "life/life.c", "function_name": "getDown", "content": "char\ngetDown(int x, int y)\n{\n  if (y == GRID_HEIGHT - 1)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x][y + 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "getDown", "address": "0x16e0", "label": "getDown", "content": "char __fastcall getDown(int x, int y)\n{\n  if ( y == 21 )\n    return DEAD[0];\n  else\n    return grid[x][y + 1];\n}\n"}, "pseudo_normalize": "char getDown(int x, int y) {\n  if (y == 21)\n    return DEAD[0];\n  else\n    return grid[x][y + 1];\n}", "binary": "life/life.host.O2", "assembly": "<getDown>:\nendbr64\ncmp    $0x15,%esi\nje     1700 <getDown+0x20>\nmov    0x4938(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    (%rax,%rdi,8),%rax\nmovzbl 0x1(%rax,%rsi,1),%eax\nret\nmovzbl 0x490f(%rip),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "getDownLeft", "content": "char\ngetDownLeft(int x, int y)\n {\n  if (y == GRID_HEIGHT - 1 || x == 0)\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x - 1][y + 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "getDownLeft", "address": "0x1770", "label": "getDownLeft", "content": "char __fastcall getDownLeft(int x, int y)\n{\n  if ( y == 21 || !x )\n    return DEAD[0];\n  else\n    return grid[x - 1][y + 1];\n}\n"}, "pseudo_normalize": "char getDownLeft(int x, int y) {\n  if (y == 21 || !x)\n    return DEAD[0];\n  else\n    return grid[x - 1][y + 1];\n}", "binary": "life/life.host.O2", "assembly": "<getDownLeft>:\nendbr64\ncmp    $0x15,%esi\nje     1798 <getDownLeft+0x28>\ntest   %edi,%edi\nje     1798 <getDownLeft+0x28>\nmov    0x48a4(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    -0x8(%rax,%rdi,8),%rax\nmovzbl 0x1(%rax,%rsi,1),%eax\nret\nnopl   (%rax)\nmovzbl 0x4877(%rip),%eax\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getDownRight", "content": "char\ngetDownRight(int x, int y)\n{\n  if (y == GRID_HEIGHT - 1 || x == GRID_WIDTH - 1 )\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x + 1][y + 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "getDownRight", "address": "0x17a0", "label": "getDownRight", "content": "char __fastcall getDownRight(int x, int y)\n{\n  if ( y == 21 || x == 69 )\n    return DEAD[0];\n  else\n    return grid[x + 1][y + 1];\n}\n"}, "pseudo_normalize": "char getDownRight(int x, int y) {\n  if (y == 21 || x == 69)\n    return DEAD[0];\n  else\n    return grid[x + 1][y + 1];\n}", "binary": "life/life.host.O2", "assembly": "<getDownRight>:\nendbr64\ncmp    $0x15,%esi\nje     17d0 <getDownRight+0x30>\ncmp    $0x45,%edi\nje     17d0 <getDownRight+0x30>\nmov    0x4873(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x8(%rax,%rdi,8),%rax\nmovzbl 0x1(%rax,%rsi,1),%eax\nret\ncs nopw 0x0(%rax,%rax,1)\nmovzbl 0x483f(%rip),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "getLeft", "content": "char\ngetLeft(int x, int y)\n{\n  if (x == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x - 1][y];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "getLeft", "address": "0x1650", "label": "getLeft", "content": "char __fastcall getLeft(int x, int y)\n{\n  if ( x )\n    return grid[x - 1][y];\n  else\n    return DEAD[0];\n}\n"}, "pseudo_normalize": "char getLeft(int x, int y) {\n  if (x)\n    return grid[x - 1][y];\n  else\n    return DEAD[0];\n}", "binary": "life/life.host.O2", "assembly": "<getLeft>:\nendbr64\ntest   %edi,%edi\nje     1670 <getLeft+0x20>\nmov    0x49c9(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    -0x8(%rax,%rdi,8),%rax\nmovzbl (%rax,%rsi,1),%eax\nret\nnop\nmovzbl 0x499f(%rip),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "getNumNeigbors", "content": "int\ngetNumNeigbors(int x, int y)\n{\n  int i = 0;\n\n  if (getLeft(x, y) == LIVE)\n    i++;\n  if (getRight(x, y) == LIVE)\n    i++;\n  if (getUp(x, y) == LIVE)\n    i++;\n  if (getDown(x, y) == LIVE)\n    i++;\n  if (getUpLeft(x, y) == LIVE)\n    i++;\n  if (getUpRight(x, y) == LIVE)\n    i++;\n  if (getDownLeft(x, y) == LIVE)\n    i++;\n  if (getDownRight(x, y) == LIVE)\n    i++;\n\n  return i;\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "getNumNeigbors", "address": "0x1390", "label": "getNumNeigbors", "content": "int __fastcall getNumNeigbors(int x, int y)\n{\n  __int64 v2; // r9\n  char v3; // r10\n  _BOOL4 v4; // eax\n  int v5; // eax\n  char v6; // r10\n  int v7; // eax\n  bool v8; // r10\n  char v9; // bl\n  int v10; // eax\n  bool v11; // di\n  char v12; // r11\n  int v13; // eax\n  char v14; // r10\n  int v15; // eax\n\n  v2 = x;\n  if ( x )\n  {\n    v3 = DEAD[0];\n    v4 = grid[x - 1][y] == LIVE[0];\n    if ( x == 69 )\n      goto LABEL_4;\n  }\n  else\n  {\n    v4 = DEAD[0] == LIVE[0];\n  }\n  v3 = grid[x + 1][y];\nLABEL_4:\n  v5 = (v3 == LIVE[0]) + v4;\n  if ( y )\n  {\n    if ( grid[x][y - 1] != LIVE[0] )\n      goto LABEL_6;\n  }\n  else if ( DEAD[0] != LIVE[0] )\n  {\n    goto LABEL_7;\n  }\n  ++v5;\nLABEL_6:\n  v6 = DEAD[0];\n  if ( y != 21 )\nLABEL_7:\n    v6 = grid[x][y + 1];\n  v7 = (v6 == LIVE[0]) + v5;\n  v8 = x == 0;\n  if ( x && y )\n    v9 = grid[x - 1][y - 1];\n  else\n    v9 = DEAD[0];\n  v10 = (v9 == LIVE[0]) + v7;\n  v11 = x == 69;\n  if ( !y || v11 )\n    v12 = DEAD[0];\n  else\n    v12 = grid[v2 + 1][y - 1];\n  v13 = (v12 == LIVE[0]) + v10;\n  if ( v8 || y == 21 )\n    v14 = DEAD[0];\n  else\n    v14 = grid[v2 - 1][y + 1];\n  v15 = (v14 == LIVE[0]) + v13;\n  if ( v11 || y == 21 )\n    return (DEAD[0] == LIVE[0]) + v15;\n  else\n    return (grid[v2 + 1][y + 1] == LIVE[0]) + v15;\n}\n"}, "pseudo_normalize": "int getNumNeigbors(int x, int y) {\n  long long v2;\n  char v3;\n  int v4;\n  int v5;\n  char v6;\n  int v7;\n  bool v8;\n  char v9;\n  int v10;\n  bool v11;\n  char v12;\n  int v13;\n  char v14;\n  int v15;\n  v2 = x;\n  if (x) {\n    v3 = DEAD[0];\n    v4 = grid[x - 1][y] == LIVE[0];\n    if (x == 69) goto LABEL_4;\n  } else {\n    v4 = DEAD[0] == LIVE[0];\n  }\n  v3 = grid[x + 1][y];\nLABEL_4:\n  v5 = (v3 == LIVE[0]) + v4;\n  if (y) {\n    if (grid[x][y - 1] != LIVE[0]) goto LABEL_6;\n  } else if (DEAD[0] != LIVE[0]) {\n    goto LABEL_7;\n  }\n  ++v5;\nLABEL_6:\n  v6 = DEAD[0];\n  if (y != 21)\n  LABEL_7:\n    v6 = grid[x][y + 1];\n  v7 = (v6 == LIVE[0]) + v5;\n  v8 = x == 0;\n  if (x && y)\n    v9 = grid[x - 1][y - 1];\n  else\n    v9 = DEAD[0];\n  v10 = (v9 == LIVE[0]) + v7;\n  v11 = x == 69;\n  if (!y || v11)\n    v12 = DEAD[0];\n  else\n    v12 = grid[v2 + 1][y - 1];\n  v13 = (v12 == LIVE[0]) + v10;\n  if (v8 || y == 21)\n    v14 = DEAD[0];\n  else\n    v14 = grid[v2 - 1][y + 1];\n  v15 = (v14 == LIVE[0]) + v13;\n  if (v11 || y == 21)\n    return (DEAD[0] == LIVE[0]) + v15;\n  else\n    return (grid[v2 + 1][y + 1] == LIVE[0]) + v15;\n}", "binary": "life/life.host.O2", "assembly": "<getNumNeigbors>:\nendbr64\nmovslq %esi,%rsi\npush   %rbx\nmovzbl 0x4c78(%rip),%edx\nmovslq %edi,%r9\nmov    0x4c7f(%rip),%r8\nmov    %rsi,%rcx\ntest   %edi,%edi\nje     14f0 <getNumNeigbors+0x160>\nmov    -0x8(%r8,%r9,8),%rax\nmovzbl 0x4c55(%rip),%r10d\ncmp    %dl,(%rax,%rsi,1)\nsete   %al\nmovzbl %al,%eax\ncmp    $0x45,%edi\nje     13d9 <getNumNeigbors+0x49>\nmov    0x8(%r8,%r9,8),%r10\nmovzbl (%r10,%rsi,1),%r10d\ncmp    %dl,%r10b\nsete   %r10b\nmovzbl %r10b,%r10d\nadd    %r10d,%eax\ntest   %ecx,%ecx\nje     14d8 <getNumNeigbors+0x148>\nmov    (%r8,%r9,8),%r10\ncmp    %dl,-0x1(%r10,%rsi,1)\nje     14e4 <getNumNeigbors+0x154>\nmovzbl 0x4c10(%rip),%r10d\ncmp    $0x15,%ecx\nje     1415 <getNumNeigbors+0x85>\nmov    (%r8,%r9,8),%r10\nmovzbl 0x1(%r10,%rsi,1),%r10d\ncmp    %dl,%r10b\nsete   %r10b\nmovzbl %r10b,%r10d\nadd    %r10d,%eax\ntest   %edi,%edi\nsete   %r10b\ntest   %ecx,%ecx\nsete   %r11b\ntest   %r10b,%r10b\njne    1538 <getNumNeigbors+0x1a8>\ntest   %r11b,%r11b\njne    1538 <getNumNeigbors+0x1a8>\nmov    -0x8(%r8,%r9,8),%rbx\nmovzbl -0x1(%rbx,%rsi,1),%ebx\ncmp    %dl,%bl\nsete   %bl\nmovzbl %bl,%ebx\nadd    %ebx,%eax\ncmp    $0x45,%edi\nsete   %dil\ntest   %r11b,%r11b\njne    1528 <getNumNeigbors+0x198>\ntest   %dil,%dil\njne    1528 <getNumNeigbors+0x198>\nmov    0x8(%r8,%r9,8),%r11\nmovzbl -0x1(%r11,%rsi,1),%r11d\ncmp    %dl,%r11b\nsete   %r11b\nmovzbl %r11b,%r11d\nadd    %r11d,%eax\ncmp    $0x15,%ecx\nsete   %cl\ntest   %r10b,%r10b\njne    1518 <getNumNeigbors+0x188>\ntest   %cl,%cl\njne    1518 <getNumNeigbors+0x188>\nmov    -0x8(%r8,%r9,8),%r10\nmovzbl 0x1(%r10,%rsi,1),%r10d\ncmp    %dl,%r10b\nsete   %r10b\nmovzbl %r10b,%r10d\nadd    %r10d,%eax\ntest   %dil,%dil\njne    1500 <getNumNeigbors+0x170>\ntest   %cl,%cl\njne    1500 <getNumNeigbors+0x170>\nmov    0x8(%r8,%r9,8),%rcx\npop    %rbx\nmovzbl 0x1(%rcx,%rsi,1),%ecx\ncmp    %dl,%cl\nsete   %dl\nmovzbl %dl,%edx\nadd    %edx,%eax\nret\nnopw   0x0(%rax,%rax,1)\ncmp    %dl,0x4b38(%rip)\njne    140b <getNumNeigbors+0x7b>\nadd    $0x1,%eax\njmp    13fe <getNumNeigbors+0x6e>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncmp    %dl,0x4b1e(%rip)\nsete   %al\njmp    13cf <getNumNeigbors+0x3f>\nmovzbl 0x4b0f(%rip),%ecx\npop    %rbx\ncmp    %dl,%cl\nsete   %dl\nmovzbl %dl,%edx\nadd    %edx,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmovzbl 0x4af6(%rip),%r10d\njmp    14a5 <getNumNeigbors+0x115>\nnopl   (%rax)\nmovzbl 0x4ae6(%rip),%r11d\njmp    1479 <getNumNeigbors+0xe9>\nnopl   (%rax)\nmovzbl 0x4ad7(%rip),%ebx\njmp    144b <getNumNeigbors+0xbb>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "life/life.c", "function_name": "getRight", "content": "char\ngetRight(int x, int y)\n{\n  if (x == GRID_WIDTH - 1)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x + 1][y];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "getRight", "address": "0x1680", "label": "getRight", "content": "char __fastcall getRight(int x, int y)\n{\n  if ( x == 69 )\n    return DEAD[0];\n  else\n    return grid[x + 1][y];\n}\n"}, "pseudo_normalize": "char getRight(int x, int y) {\n  if (x == 69)\n    return DEAD[0];\n  else\n    return grid[x + 1][y];\n}", "binary": "life/life.host.O2", "assembly": "<getRight>:\nendbr64\ncmp    $0x45,%edi\nje     16a0 <getRight+0x20>\nmov    0x4998(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x8(%rax,%rdi,8),%rax\nmovzbl (%rax,%rsi,1),%eax\nret\nmovzbl 0x496f(%rip),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "getUp", "content": "char\ngetUp(int x, int y)\n{\n  if (y == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x][y - 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "getUp", "address": "0x16b0", "label": "getUp", "content": "char __fastcall getUp(int x, int y)\n{\n  if ( y )\n    return grid[x][y - 1];\n  else\n    return DEAD[0];\n}\n"}, "pseudo_normalize": "char getUp(int x, int y) {\n  if (y)\n    return grid[x][y - 1];\n  else\n    return DEAD[0];\n}", "binary": "life/life.host.O2", "assembly": "<getUp>:\nendbr64\ntest   %esi,%esi\nje     16d0 <getUp+0x20>\nmov    0x4969(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    (%rax,%rdi,8),%rax\nmovzbl -0x1(%rax,%rsi,1),%eax\nret\nnop\nmovzbl 0x493f(%rip),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "getUpLeft", "content": "char\ngetUpLeft(int x, int y)\n{\n  if (x == 0 || y == 0)\n  {\n    return DEAD;\n  }\n\n  char retval = grid[x - 1][y - 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "getUpLeft", "address": "0x1710", "label": "getUpLeft", "content": "char __fastcall getUpLeft(int x, int y)\n{\n  if ( x && y )\n    return grid[x - 1][y - 1];\n  else\n    return DEAD[0];\n}\n"}, "pseudo_normalize": "char getUpLeft(int x, int y) {\n  if (x && y)\n    return grid[x - 1][y - 1];\n  else\n    return DEAD[0];\n}", "binary": "life/life.host.O2", "assembly": "<getUpLeft>:\nendbr64\ntest   %edi,%edi\nje     1738 <getUpLeft+0x28>\ntest   %esi,%esi\nje     1738 <getUpLeft+0x28>\nmov    0x4905(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    -0x8(%rax,%rdi,8),%rax\nmovzbl -0x1(%rax,%rsi,1),%eax\nret\nnopl   0x0(%rax)\nmovzbl 0x48d7(%rip),%eax\nret\n"}
{"source": {"path": "life/life.c", "function_name": "getUpRight", "content": "char\ngetUpRight(int x, int y)\n{\n  if (x == GRID_WIDTH - 1 || y == 0)\n  {\n    return DEAD;\n  }\n \n  char retval = grid[x + 1][y - 1];\n\n  return retval;\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "getUpRight", "address": "0x1740", "label": "getUpRight", "content": "char __fastcall getUpRight(int x, int y)\n{\n  if ( x == 69 || !y )\n    return DEAD[0];\n  else\n    return grid[x + 1][y - 1];\n}\n"}, "pseudo_normalize": "char getUpRight(int x, int y) {\n  if (x == 69 || !y)\n    return DEAD[0];\n  else\n    return grid[x + 1][y - 1];\n}", "binary": "life/life.host.O2", "assembly": "<getUpRight>:\nendbr64\ncmp    $0x45,%edi\nje     1768 <getUpRight+0x28>\ntest   %esi,%esi\nje     1768 <getUpRight+0x28>\nmov    0x48d4(%rip),%rax\nmovslq %edi,%rdi\nmovslq %esi,%rsi\nmov    0x8(%rax,%rdi,8),%rax\nmovzbl -0x1(%rax,%rsi,1),%eax\nret\nnopl   (%rax)\nmovzbl 0x48a7(%rip),%eax\nret\n"}
{"source": {"path": "life/life.c", "function_name": "init", "content": "void\ninit(void)\n{ \n  libmin_srand(1001);\n  for (int x = 0; x < GRID_WIDTH; ++x)\n    {\n      grid[x] = gridVals[x];\n      gridTmp[x] = gridTmpVals[x];\n      for (int y = 0; y < GRID_HEIGHT; ++y)\n        {\n          grid[x][y] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n          gridTmp[x][y] = ' ';\n        }\n    }\n\n  // clear the screen\n  libmin_printf(\"\\x1b[2J\");\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "init", "address": "0x1220", "label": "init", "content": "void __cdecl init()\n{\n  __int64 v0; // r15\n  __int64 v1; // r12\n  __int64 v2; // rbx\n\n  v0 = 0LL;\n  v1 = 0LL;\n  libmin_srand(0x3E9u);\n  do\n  {\n    v2 = 0LL;\n    grid[v0] = &gridVals[v1];\n    gridTmp[v0] = &gridTmpVals[v1];\n    do\n    {\n      grid[v0][v2] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[v0][v2++] = 32;\n    }\n    while ( v2 != 22 );\n    v1 += 22LL;\n    ++v0;\n  }\n  while ( v1 != 1540 );\n  libmin_printf(\"\\x1B[2J\");\n}\n"}, "pseudo_normalize": "void init() {\n  long long v0;\n  long long v1;\n  long long v2;\n  v0 = 0LL;\n  v1 = 0LL;\n  libmin_srand(1001u);\n  do {\n    v2 = 0LL;\n    grid[v0] = &gridVals[v1];\n    gridTmp[v0] = &gridTmpVals[v1];\n    do {\n      grid[v0][v2] = BLOCKS[libmin_rand() % NUM_BLOCKS];\n      gridTmp[v0][v2++] = 32;\n    } while (v2 != 22);\n    v1 += 22LL;\n    ++v0;\n  } while (v1 != 1540);\n  libmin_printf(\"\\x1B[2J\");\n}", "binary": "life/life.host.O2", "assembly": "<init>:\nendbr64\npush   %r15\nmov    $0x3e9,%edi\nxor    %r15d,%r15d\npush   %r14\nlea    0x56a9(%rip),%r14\npush   %r13\nlea    0x5080(%rip),%r13\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nlea    0x4dc7(%rip),%rbp\npush   %rbx\nsub    $0x8,%rsp\ncall   2f70 <libmin_srand>\nnopw   0x0(%rax,%rax,1)\nmov    0x4dc1(%rip),%rax\nlea    (%r14,%r12,1),%rdx\nxor    %ebx,%ebx\nmov    %rdx,(%rax,%r15,1)\nmov    0x4da8(%rip),%rax\nlea    0x0(%r13,%r12,1),%rdx\nmov    %rdx,(%rax,%r15,1)\nnopl   0x0(%rax)\ncall   2fd0 <libmin_rand>\nxor    %edx,%edx\ndivl   0x4d83(%rip)\nmov    0x4d8c(%rip),%rax\nmov    (%rax,%r15,1),%rax\nmovzbl 0x0(%rbp,%rdx,1),%edx\nmov    %dl,(%rax,%rbx,1)\nmov    0x4d71(%rip),%rax\nmov    (%rax,%r15,1),%rax\nmovb   $0x20,(%rax,%rbx,1)\nadd    $0x1,%rbx\ncmp    $0x16,%rbx\njne    1288 <init+0x68>\nadd    $0x16,%r12\nadd    $0x8,%r15\ncmp    $0x604,%r12\njne    1260 <init+0x40>\nadd    $0x8,%rsp\nlea    0x2d27(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    2d60 <libmin_printf>\nxchg   %ax,%ax\n"}
{"source": {"path": "life/life.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int iters = 0;\n\n  init();\n  int running = TRUE;\n  while (running) {\n    draw();\n    //sleep(500);\n    process();\n    iters++;\n    if (iters == 80)\n      running = FALSE;\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n\n  v3 = 80;\n  init();\n  do\n  {\n    draw();\n    process();\n    --v3;\n  }\n  while ( v3 );\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  v3 = 80;\n  init();\n  do {\n    draw();\n    process();\n    --v3;\n  } while (v3);\n  libmin_success();\n}", "binary": "life/life.host.O2", "assembly": "<main>:\nendbr64\npush   %rbx\nmov    $0x50,%ebx\ncall   1220 <init>\nnop\ncall   12f0 <draw>\ncall   1550 <process>\nsub    $0x1,%ebx\njne    1110 <main+0x10>\ncall   31b0 <libmin_success>\nxor    %eax,%eax\npop    %rbx\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "life/life.c", "function_name": "process", "content": "void\nprocess(void)\n{\n  for (int y = 0; y < GRID_HEIGHT; ++y)\n    {\n      for (int x = 0; x < GRID_WIDTH; ++x)\n        {\n          int neighbors = getNumNeigbors(x, y);\n          if (grid[x][y] == LIVE)\n            {\n              //1. Any live cell with fewer than two live neighbors dies, as if caused by underpopulation.\n              //2. Any live cell with more than three live neighbors dies, as if by overcrowding.\n              if (neighbors < 2 || neighbors > 3)\n                gridTmp[x][y] = DEAD;\n              else\n                gridTmp[x][y] = LIVE;\n              //3. Any live cell with two or three live neighbors lives on to the next generation.\n            }\n          else\n            {\n              //4. Any dead cell with exactly three live neighbors becomes a live cell.\n              if (neighbors == 3)\n                gridTmp[x][y] = LIVE;\n              else\n                gridTmp[x][y] = DEAD;\n            }\n          processMutate(x, y);\n        }\n    }\n    flip();\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "process", "address": "0x1550", "label": "process", "content": "void __cdecl process()\n{\n  __int64 i; // rbp\n  __int64 j; // rbx\n  char *v2; // rcx\n  int NumNeigbors; // eax\n  char **v4; // rcx\n  char **v5; // rax\n\n  for ( i = 0LL; i != 22; ++i )\n  {\n    for ( j = 0LL; j != 70; ++j )\n    {\n      while ( 1 )\n      {\n        NumNeigbors = getNumNeigbors(j, i);\n        v4 = &gridTmp[j];\n        if ( grid[j][i] == LIVE[0] )\n          break;\n        v2 = &(*v4)[i];\n        if ( NumNeigbors == 3 )\n          goto LABEL_7;\nLABEL_4:\n        ++j;\n        *v2 = DEAD[0];\n        libmin_rand();\n        if ( j == 70 )\n          goto LABEL_8;\n      }\n      v2 = &(*v4)[i];\n      if ( (unsigned int)(NumNeigbors - 2) > 1 )\n        goto LABEL_4;\nLABEL_7:\n      *v2 = LIVE[0];\n      libmin_rand();\n    }\nLABEL_8:\n    ;\n  }\n  v5 = grid;\n  grid = gridTmp;\n  gridTmp = v5;\n}\n"}, "pseudo_normalize": "void process() {\n  long long i;\n  long long j;\n  char *v2;\n  int NumNeigbors;\n  char **v4;\n  char **v5;\n  for (i = 0LL; i != 22; ++i) {\n    for (j = 0LL; j != 70; ++j) {\n      while (1) {\n        NumNeigbors = getNumNeigbors(j, i);\n        v4 = &gridTmp[j];\n        if (grid[j][i] == LIVE[0]) break;\n        v2 = &(*v4)[i];\n        if (NumNeigbors == 3) goto LABEL_7;\n      LABEL_4:\n        ++j;\n        *v2 = DEAD[0];\n        libmin_rand();\n        if (j == 70) goto LABEL_8;\n      }\n      v2 = &(*v4)[i];\n      if ((unsigned int)(NumNeigbors - 2) > 1) goto LABEL_4;\n    LABEL_7:\n      *v2 = LIVE[0];\n      libmin_rand();\n    }\n  LABEL_8:;\n  }\n  v5 = grid;\n  grid = gridTmp;\n  gridTmp = v5;\n}", "binary": "life/life.host.O2", "assembly": "<process>:\nendbr64\npush   %r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nnopw   0x0(%rax,%rax,1)\nmov    %ebp,%r12d\nxor    %ebx,%ebx\njmp    1593 <process+0x43>\nnopw   0x0(%rax,%rax,1)\nadd    (%rcx),%rdi\nmov    %rdi,%rcx\ncmp    $0x3,%eax\nje     15d0 <process+0x80>\nmovzbl 0x4a94(%rip),%eax\nadd    $0x1,%rbx\nmov    %al,(%rcx)\ncall   2fd0 <libmin_rand>\ncmp    $0x46,%rbx\nje     15e1 <process+0x91>\nmov    %r12d,%esi\nmov    %ebx,%edi\ncall   1390 <getNumNeigbors>\nmov    0x4a84(%rip),%rsi\nmov    0x4a75(%rip),%rcx\nmov    %rbp,%rdi\nmovzbl 0x4a62(%rip),%edx\nmov    (%rsi,%rbx,8),%rsi\nlea    (%rcx,%rbx,8),%rcx\ncmp    %dl,(%rsi,%rbp,1)\njne    1570 <process+0x20>\nadd    (%rcx),%rdi\nsub    $0x2,%eax\nmov    %rdi,%rcx\ncmp    $0x1,%eax\nja     157b <process+0x2b>\nmov    %dl,(%rcx)\nadd    $0x1,%rbx\ncall   2fd0 <libmin_rand>\ncmp    $0x46,%rbx\njne    1593 <process+0x43>\nadd    $0x1,%rbp\ncmp    $0x16,%rbp\njne    1560 <process+0x10>\nmov    0x4a32(%rip),%rax\nmov    0x4a23(%rip),%rdx\npop    %rbx\npop    %rbp\nmov    %rdx,0x4a22(%rip)\npop    %r12\nmov    %rax,0x4a11(%rip)\nret\n"}
{"source": {"path": "life/life.c", "function_name": "processMutate", "content": "void\nprocessMutate(int x, int y)\n{\n  if (libmin_rand() % 3000 > 2927)\n    {\n      if (gridTmp[x][y] == DEAD)\n        ; // gridTmp[x][y] = LIVE;\n    }\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "processMutate", "address": "0x1610", "label": "processMutate", "content": "void __fastcall processMutate(int x, int y)\n{\n  libmin_rand();\n}\n"}, "pseudo_normalize": "", "binary": "life/life.host.O2", "assembly": "<processMutate>:\nendbr64\njmp    2fd0 <libmin_rand>\nnopl   0x0(%rax)\n"}
{"source": {"path": "life/life.c", "function_name": "sleep", "content": "void\nsleep(unsigned int mseconds)\n{\n  x = 0;\n  while (x < MS_DELAY)\n    x++;\n}\n"}, "pseudo": {"path": "life/life.host.O2.pseudo", "function_name": "sleep", "address": "0x17e0", "label": "sleep", "content": "void __fastcall sleep(unsigned int mseconds)\n{\n  x = 0;\n  do\n    ++x;\n  while ( x <= 0 );\n}\n"}, "pseudo_normalize": "", "binary": "life/life.host.O2", "assembly": "<sleep>:\nendbr64\nmovl   $0x0,0x4ab2(%rip)\nmov    0x4aac(%rip),%eax\ntest   %eax,%eax\njg     1819 <sleep+0x39>\nnopl   0x0(%rax,%rax,1)\nmov    0x4a9a(%rip),%eax\nadd    $0x1,%eax\nmov    %eax,0x4a91(%rip)\nmov    0x4a8b(%rip),%eax\ntest   %eax,%eax\njle    1800 <sleep+0x20>\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "cut_off", "content": "/* Creates a new string by cutting the given number of characters off\n   the front of source */\n\nchar *\ncut_off(char *source, int n)\n{\n\tint k;\n\tchar *res;\n\n\tif((n <= 0)||(source == NULL))return NULL;\n\tk = libmin_strlen(source);\n\tk = ( n > k ? k : n );\n\tres = (char *)libmin_calloc(sizeof(char),(k+1));\n\tif(res == NULL){\n\t\tlibmin_printf(\"cut_off: Unable to malloc\\n\");\n\t\treturn NULL;\n\t}\n\tlibmin_strncpy(res,source,k);\n\treturn res;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O2.pseudo", "function_name": "cut_off", "address": "0x1de0", "label": "cut_off", "content": "char *__fastcall cut_off(char *source, int n)\n{\n  int v2; // ebx\n  int v3; // eax\n  char *v4; // rax\n  char *v5; // r12\n\n  if ( n <= 0 || !source )\n    return 0LL;\n  v2 = n;\n  v3 = libmin_strlen(source);\n  if ( n > v3 )\n    v2 = v3;\n  v4 = (char *)libmin_calloc(1uLL, v2 + 1);\n  v5 = v4;\n  if ( v4 )\n    libmin_strncpy(v4, source, v2);\n  else\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n  return v5;\n}\n"}, "pseudo_normalize": "char *cut_off(char *source, int n) {\n  int v2;\n  int v3;\n  char *v4;\n  char *v5;\n  if (n <= 0 || !source) return 0LL;\n  v2 = n;\n  v3 = libmin_strlen(source);\n  if (n > v3) v2 = v3;\n  v4 = (char *)libmin_calloc(1uLL, v2 + 1);\n  v5 = v4;\n  if (v4)\n    libmin_strncpy(v4, source, v2);\n  else\n    libmin_printf(\"cut_off: Unable to malloc\\n\");\n  return v5;\n}", "binary": "longdiv/longdiv.host.O2", "assembly": "<cut_off>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\ntest   %esi,%esi\njle    1e30 <cut_off+0x50>\nmov    %rdi,%rbp\ntest   %rdi,%rdi\nje     1e30 <cut_off+0x50>\nmov    %esi,%ebx\ncall   3920 <libmin_strlen>\nmov    $0x1,%edi\ncmp    %eax,%ebx\ncmovg  %eax,%ebx\nlea    0x1(%rbx),%esi\nmovslq %esi,%rsi\ncall   21e0 <libmin_calloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1e40 <cut_off+0x60>\nmovslq %ebx,%rdx\nmov    %rbp,%rsi\nmov    %rax,%rdi\ncall   3950 <libmin_strncpy>\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\nret\nxchg   %ax,%ax\nxor    %r12d,%r12d\npop    %rbx\npop    %rbp\nmov    %r12,%rax\npop    %r12\nret\nnopl   0x0(%rax,%rax,1)\nlea    0x21f8(%rip),%rdi\nxor    %eax,%eax\ncall   36b0 <libmin_printf>\njmp    1e26 <cut_off+0x46>\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "isgte", "content": "/* Isgte: returns TRUE if first digit string is >=  the second */\n\nint\nisgte( char *A, char *B)\n{\n\tint a,b,i;\n\tchar *AA, *BB;\n\n\tif(B==NULL) return TRUE;\n\tif(A==NULL) return FALSE;\n\n/* Normalize by stripping off leading zeros */\n\n\tAA = libmin_strpbrk(A,DIGITS);\n\tBB = libmin_strpbrk(B,DIGITS);\n\n\tif(BB == NULL) return TRUE;\n\tif(AA == NULL) return FALSE;  \n\n\tif((b=libmin_strlen(BB ))>(a=libmin_strlen(AA)))return FALSE;\n\tif(a > b) return TRUE;\n\t\n\tfor(i=0;i<b;i++){\n\t\tif(AA[i]>BB[i]) return TRUE;\n\t\tif(AA[i]<BB[i]) return FALSE;\n\t}\n\treturn TRUE;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O2.pseudo", "function_name": "isgte", "address": "0x19f0", "label": "isgte", "content": "int __fastcall isgte(char *A, char *B)\n{\n  if ( !B )\n    return 1;\n  if ( A )\n    return isgte_0(A, B);\n  return 0;\n}\n"}, "pseudo_normalize": "", "binary": "longdiv/longdiv.host.O2", "assembly": "<isgte>:\nendbr64\ntest   %rsi,%rsi\nje     1a10 <isgte+0x20>\ntest   %rdi,%rdi\nje     1a08 <isgte+0x18>\njmp    1920 <isgte.part.0>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "main", "content": "int \nmain(void)\n{\n\tint dsr_len,ddnd_len;\n\tint dgts_fwd;   /* digits carried forward from previous step */\n\tint i,j,k;\n\tint step = 0;\n\tchar *quotient;\n\tchar *dsr;             /* Divisor */\n\tchar *ddnds[128];   /* Successive dividends */\n\tchar *shends[128]; /* Successive subtrahends */\n\tchar *mend;  /* Current minuend: see example below */\n\tchar *pend;  /* Points to 1st char beyond current minuend */\n\tchar *ptr;\n\n\t/* Do sanity checks on args */\n\n\tfor(i=0; i<libmin_strlen(argv[1]); i++)\n\t\tif(!isdigit(argv[1][i])){\n\t\t\tlibmin_printf(\"%s\\n%s\\n\",\"longdiv: syntax error\",\n\t\t\t\targv[1]);\n\t\t\tfor(j=0;j<i;j++)libmin_putc(' ');\n\t\t\tlibmin_putc('^');\n\t\t\tlibmin_putc('\\n');\n\t\t\treturn FALSE;\n\t\t}\n\n\tfor(i=0; i<libmin_strlen(argv[2]); i++)\n\t\tif(!isdigit(argv[2][i])){\n\t\t\tlibmin_printf(\"%s\\n%s\\n\",\"longdiv: syntax error\",\n\t\t\t\targv[2]);\n\t\t\tfor(j=0;j<i;j++)libmin_putc(' ');\n\t\t\tlibmin_putc('^');\n\t\t\tlibmin_putc('\\n');\n\t\t\treturn FALSE;\n\t\t}\n\n\t/* Make sure we're not dividing by 0 */\n\n\tj = TRUE; /* Guilty, till proven innocent */\n\tfor(i=0;i<libmin_strlen(argv[2]);i++)\n\t\tif(argv[2][i] != '0'){j = FALSE; break; }\n\tif(j){\n\t\tlibmin_printf(\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n\t\treturn FALSE;\n\t}\n\n\t/* OK, lookin' good */\n\t/* Save divisor and dividend */\n\n\tif((ptr = libmin_strpbrk(argv[1],DIGITS))==NULL)\n\t\t ddnd_len = 1;\n\telse \n\t   ddnd_len = libmin_strlen(ptr);\n\tddnds[0] = (char *)libmin_malloc((ddnd_len+1)*sizeof(char));\n\tif(ptr == NULL)\n\t\tlibmin_strcpy(ddnds[0],\"0\");\n\telse\n\t        libmin_strcpy(ddnds[0],ptr);\n\tptr = libmin_strpbrk(argv[2],DIGITS);\n\tdsr_len = libmin_strlen(ptr);\n\tdsr = (char *)libmin_malloc((dsr_len+1)*sizeof(char));\n\tlibmin_strcpy(dsr,ptr);\n\n\tdgts_fwd = dsr_len-1; /* Turns out to be the right initialization */\n\n\t/* Reserve space for, and properly terminate, quotient */\n\n\tquotient = (char *)libmin_calloc(sizeof(char),ddnd_len+1);\n\n\t/* stick an appropriate number of leading zeros on quotient */\n\t/* These will be stripped in the printout */\n\n\tfor(j=0;j<dsr_len-1;j++)quotient[j]='0';\n\n\t/* The algorithm breaks into steps, each of which involves a\n\t   set of trial multiplications and a subtraction. \n\t   As a try at the first minuend, we take the first n digits of\n\t   the first dividend, where n is length of the divisor. To\n\t   clarify the terminology, consider the problem:\n\n\t\t9\n          _______________________\n   3213   ) 29946712\n\t    28917\n\t    -------\n\t       29\n\t\n\tHere, the first minuend is 29546, the first subtrahend is\n\t28917, and dgts_fwd is 2.  This was step = 0.  \n        The next dividend will be 29712, and the next minuend will be gotten\n        by taking the appropriate initial string from it. \n\t*/\n\t\n        while(isgte(ddnds[step],dsr)){  /* loop until dividend shorter than\n                                             divisor. When we exit the loop,\n                                             the last dividend is the remainder\n\t\t\t\t\t*/\n\n\t  /* Determine the next minuend */\n\t  mend = cut_off(ddnds[step],++dgts_fwd);\t\n\t  while(!isgte(mend,dsr)){\n\t\tlibmin_strcat(quotient,\"0\");\n\t\tlibmin_free(mend);\n\t\tmend = cut_off(ddnds[step],++dgts_fwd);\n\t  } \n\n\t  pend = ddnds[step]+libmin_strlen(mend); /* Set pointer to rest of dividend that\n\t\t\t\t\t will be spliced on to form the\n                                         next dividend. (points to 7 in example\n\t\t\t\t\t above. */\n\n\t/* Now we do some \"trial multiplications\" to determine the next\n           digit of the quotient. */\n\n\t  for(i='9';i>='1';i--){\n\t\tshends[step] = times_digit(dsr,i);\n\t\tif(isgte(mend,shends[step]))break;\n\t\tlibmin_free(shends[step]);\n\t  }\n\n\t/* \n\t  Insert the new digit in the quotient.  \n\t*/\n\n\t  quotient[libmin_strlen(quotient)]=i;\n\n\t/* Now, subtract the current subtrahend from the current minuend,\n\t   and splice the result with pend to form the next dividend */\n\n\t  ptr = sbc(mend,shends[step]);\n\t  if(libmin_strpbrk(ptr,DIGITS)==NULL)dgts_fwd = 0;\n\t  else\n\t  \tdgts_fwd = libmin_strlen(libmin_strpbrk(ptr,DIGITS));\n\n\t/* A special situation arises here if dgts_fwd = 0 and pend\n           points to a zero: since we strip off leading zeros when defining\n           the new dividend, we would miss the need to append zero digits\n           to the quotient.\n\t*/\n\t if(dgts_fwd == 0)\n\t\twhile ((*pend == '0') && (*pend != '\\0')){\n\t\t\tlibmin_strcat(quotient,\"0\");\n\t\t\tpend++;\n\t\t} \n\t  ddnds[step+1] = libmin_strpbrk(splice(ptr,pend),\n\t\t\t\tDIGITS); \n\t  if(ddnds[step+1]==NULL){\n\t\tddnds[step+1]= libmin_malloc(2*sizeof(char));\n\t\tlibmin_strcpy(ddnds[step+1],\"0\");\n\t  }\n\t  libmin_free(mend);\n\t  step++;\n\n\t}  /* repeat with new dividend */\n\n\t/* Add any necessary trailing zeros to quotient */\n\tj = libmin_strlen(quotient);\n\tfor(i=0;i<ddnd_len - j;i++)libmin_strcat(quotient,\"0\");\n\n\t/* Calculation done. Print everything out */\n\n\t/* Print out the quotient */\n\tfor(i=0;i<dsr_len+2;i++)libmin_putc(' ');\n\tfor(;*quotient == '0';quotient++)libmin_putc(' ');\n\tlibmin_printf(\"%s\\n\",quotient);\n\n\t/* Print out the top bar */\n\t\n\tfor(i=0;i<dsr_len+2;i++)libmin_putc(' ');   /* space over */\n\tfor(i=0;i<ddnd_len;i++)libmin_putc('_');\n\n\t/* Print out divisor and dividend */\n\tlibmin_printf(\"\\n %s)%s\\n\",dsr,ddnds[0]);\n\n\tfor(i=0;i<step;i++){\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tlibmin_printf(\"%s\\n\",shends[i]);\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tfor(k=0;k<libmin_strlen(shends[i]);k++)libmin_putc('-');\n\t\tlibmin_putc('\\n');\n\t\tfor(j=0;j<dsr_len+2+ddnd_len - libmin_strlen(ddnds[i+1]);j++)\n\t\t\tlibmin_putc(' ');\t\n\t\tlibmin_printf(\"%s\\n\",ddnds[i+1]);\n\t}\t\n\t\t\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  size_t v3; // rbx\n  const char *v4; // rdi\n  __int64 v5; // rdx\n  int v6; // ebp\n  const char *v7; // rdi\n  size_t v8; // rbx\n  __int64 v9; // rdx\n  size_t v10; // rax\n  int v11; // ebp\n  size_t v12; // rbx\n  char v13; // al\n  int v14; // ebx\n  int i; // ebx\n  char *v17; // rax\n  const char *v18; // r12\n  size_t v19; // rbp\n  char *v20; // r12\n  char *v21; // r14\n  _BYTE *v22; // r13\n  char *v23; // r15\n  int v24; // r12d\n  char *v25; // rax\n  char *v26; // rbp\n  int v27; // r12d\n  char *v28; // rax\n  char *v29; // r13\n  char *v30; // r15\n  char *v31; // r12\n  char *v32; // rax\n  char *v33; // rax\n  char *v34; // rax\n  char *v35; // r15\n  int v36; // r12d\n  int v37; // ebx\n  int v38; // ebx\n  int v39; // eax\n  int v40; // ebx\n  int v41; // eax\n  int v42; // ebx\n  __int64 v43; // r15\n  const char *v44; // rbx\n  __int64 v45; // rbp\n  size_t k; // r12\n  size_t v47; // r12\n  const char *v48; // r14\n  size_t m; // rbx\n  size_t v50; // r12\n  char *v51; // rdi\n  __int64 step; // [rsp+0h] [rbp-898h]\n  char *pend; // [rsp+10h] [rbp-888h]\n  int dgts_fwd; // [rsp+18h] [rbp-880h]\n  const char *dgts_fwda; // [rsp+18h] [rbp-880h]\n  char **j; // [rsp+20h] [rbp-878h]\n  int ddnd_len; // [rsp+34h] [rbp-864h]\n  int v58; // [rsp+38h] [rbp-860h]\n  int v59; // [rsp+40h] [rbp-858h]\n  char *v60; // [rsp+48h] [rbp-850h]\n  char *ddnds[128]; // [rsp+50h] [rbp-848h] BYREF\n  char *shends[128]; // [rsp+450h] [rbp-448h] BYREF\n  unsigned __int64 v63; // [rsp+858h] [rbp-40h]\n\n  v3 = 0LL;\n  v4 = ::argv[1];\n  v63 = __readfsqword(0x28u);\n  do\n  {\n    v6 = v3;\n    if ( libmin_strlen(v4) <= v3 )\n    {\n      v7 = ::argv[2];\n      v8 = 0LL;\n      while ( 1 )\n      {\n        v10 = libmin_strlen(v7);\n        v11 = v8;\n        v7 = ::argv[2];\n        if ( v10 <= v8 )\n          break;\n        v9 = ::argv[2][v8++];\n        if ( (pctype[v9] & 4) == 0 )\n        {\n          libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n          if ( v11 )\n          {\n            for ( i = 0; i != v11; ++i )\n              libmin_putc(32);\n          }\n          goto LABEL_13;\n        }\n      }\n      v12 = 0LL;\n      while ( libmin_strlen(v7) > v12 )\n      {\n        v7 = ::argv[2];\n        v13 = ::argv[2][v12++];\n        if ( v13 != 48 )\n        {\n          v17 = libmin_strpbrk(::argv[1], \"123456789\");\n          v18 = v17;\n          if ( v17 )\n          {\n            ddnd_len = libmin_strlen(v17);\n            v19 = ddnd_len + 1;\n            v60 = (char *)libmin_malloc(v19);\n            ddnds[0] = v60;\n            libmin_strcpy(v60, v18);\n          }\n          else\n          {\n            v19 = 2LL;\n            v60 = (char *)libmin_malloc(2uLL);\n            ddnds[0] = v60;\n            libmin_strcpy(v60, \"0\");\n            ddnd_len = 1;\n          }\n          v20 = libmin_strpbrk(::argv[2], \"123456789\");\n          v58 = libmin_strlen(v20);\n          v59 = v58 + 1;\n          v21 = (char *)libmin_malloc(v58 + 1);\n          libmin_strcpy(v21, v20);\n          dgts_fwd = v58 - 1;\n          v22 = libmin_calloc(1uLL, v19);\n          if ( v58 - 1 > 0 )\n            memset(v22, 48, (unsigned int)(v58 - 2) + 1LL);\n          step = 0LL;\n          for ( j = shends; ; ++j )\n          {\n            v23 = ddnds[step];\n            if ( v21 )\n            {\n              if ( !v23 || !isgte_0(ddnds[step], v21) )\n              {\n                v36 = 0;\n                v37 = ddnd_len - libmin_strlen(v22);\n                if ( v37 > 0 )\n                {\n                  do\n                  {\n                    ++v36;\n                    libmin_strcat(v22, \"0\");\n                  }\n                  while ( v36 != v37 );\n                }\n                v38 = 0;\n                if ( v59 < 0 )\n                {\n                  if ( *v22 == 48 )\n                    goto LABEL_50;\n                  libmin_printf((char *)\"%s\\n\", v22);\n                }\n                else\n                {\n                  do\n                  {\n                    libmin_putc(32);\n                    v39 = v38++;\n                  }\n                  while ( v58 >= v39 );\n                  if ( *v22 != 48 )\n                  {\n                    libmin_printf((char *)\"%s\\n\", v22);\n                    goto LABEL_52;\n                  }\n                  do\n                  {\nLABEL_50:\n                    ++v22;\n                    libmin_putc(32);\n                  }\n                  while ( *v22 == 48 );\n                  libmin_printf((char *)\"%s\\n\", v22);\n                  if ( v59 >= 0 )\n                  {\nLABEL_52:\n                    v40 = 0;\n                    do\n                    {\n                      libmin_putc(32);\n                      v41 = v40++;\n                    }\n                    while ( v58 >= v41 );\n                  }\n                }\n                v42 = 0;\n                if ( ddnd_len > 0 )\n                {\n                  do\n                  {\n                    ++v42;\n                    libmin_putc(95);\n                  }\n                  while ( v42 != ddnd_len );\n                }\n                libmin_printf(\"\\n %s)%s\\n\", v21, v60);\n                if ( (_DWORD)step )\n                {\n                  v43 = 0LL;\n                  v44 = ddnds[0];\n                  v45 = ddnd_len + v58 + 2;\n                  do\n                  {\n                    for ( k = 0LL; k < v45 - libmin_strlen(v44); ++k )\n                      libmin_putc(32);\n                    v47 = 0LL;\n                    v48 = shends[v43];\n                    libmin_printf((char *)\"%s\\n\", v48);\n                    while ( v45 - libmin_strlen(v44) > v47 )\n                    {\n                      ++v47;\n                      libmin_putc(32);\n                    }\n                    for ( m = 0LL; m < libmin_strlen(v48); ++m )\n                      libmin_putc(45);\n                    v50 = 0LL;\n                    libmin_putc(10);\n                    v44 = ddnds[v43 + 1];\n                    while ( v45 - libmin_strlen(v44) > v50 )\n                    {\n                      ++v50;\n                      libmin_putc(32);\n                    }\n                    ++v43;\n                    libmin_printf((char *)\"%s\\n\", v44);\n                  }\n                  while ( v43 != step );\n                }\n                libmin_success();\n              }\n              v24 = dgts_fwd;\n              while ( 1 )\n              {\n                v25 = cut_off(v23, ++v24);\n                v26 = v25;\n                if ( v25 )\n                {\n                  if ( isgte_0(v25, v21) )\n                    break;\n                }\n                libmin_strcat(v22, \"0\");\n                libmin_free(v26);\n              }\n            }\n            else\n            {\n              v26 = cut_off(ddnds[step], dgts_fwd + 1);\n            }\n            v27 = 57;\n            dgts_fwda = v22;\n            pend = &v23[libmin_strlen(v26)];\n            do\n            {\n              v28 = times_digit(v21, v27);\n              *j = v28;\n              v29 = v28;\n              if ( !v28 || v26 && isgte_0(v26, v28) )\n                break;\n              --v27;\n              libmin_free(v29);\n            }\n            while ( v27 != 48 );\n            v30 = v29;\n            v22 = dgts_fwda;\n            dgts_fwda[libmin_strlen(dgts_fwda)] = v27;\n            v31 = sbc(v26, v30);\n            if ( !libmin_strpbrk(v31, \"123456789\")\n              || (v32 = libmin_strpbrk(v31, \"123456789\"), (dgts_fwd = libmin_strlen(v32)) == 0) )\n            {\n              v35 = pend;\n              if ( *pend == 48 )\n              {\n                do\n                {\n                  ++v35;\n                  libmin_strcat(v22, \"0\");\n                }\n                while ( *v35 == 48 );\n                pend = v35;\n              }\n              dgts_fwd = 0;\n            }\n            v33 = splice(v31, pend);\n            v34 = libmin_strpbrk(v33, \"123456789\");\n            ddnds[step + 1] = v34;\n            if ( !v34 )\n            {\n              v51 = (char *)libmin_malloc(2uLL);\n              ddnds[step + 1] = v51;\n              libmin_strcpy(v51, \"0\");\n            }\n            libmin_free(v26);\n            ++step;\n          }\n        }\n      }\n      libmin_printf((char *)\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n      return 0;\n    }\n    v4 = ::argv[1];\n    v5 = ::argv[1][v3++];\n  }\n  while ( (pctype[v5] & 4) != 0 );\n  v14 = 0;\n  libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n  if ( v6 )\n  {\n    do\n    {\n      ++v14;\n      libmin_putc(32);\n    }\n    while ( v6 != v14 );\n  }\nLABEL_13:\n  libmin_putc(94);\n  libmin_putc(10);\n  return 0;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  unsigned int v3;\n  const char *v4;\n  long long v5;\n  int v6;\n  const char *v7;\n  unsigned int v8;\n  long long v9;\n  unsigned int v10;\n  int v11;\n  unsigned int v12;\n  char v13;\n  int v14;\n  int i;\n  char *v17;\n  const char *v18;\n  unsigned int v19;\n  char *v20;\n  char *v21;\n  uint8_t *v22;\n  char *v23;\n  int v24;\n  char *v25;\n  char *v26;\n  int v27;\n  char *v28;\n  char *v29;\n  char *v30;\n  char *v31;\n  char *v32;\n  char *v33;\n  char *v34;\n  char *v35;\n  int v36;\n  int v37;\n  int v38;\n  int v39;\n  int v40;\n  int v41;\n  int v42;\n  long long v43;\n  const char *v44;\n  long long v45;\n  unsigned int k;\n  unsigned int v47;\n  const char *v48;\n  unsigned int m;\n  unsigned int v50;\n  char *v51;\n  long long step;\n  char *pend;\n  int dgts_fwd;\n  const char *dgts_fwda;\n  char **j;\n  int ddnd_len;\n  int v58;\n  int v59;\n  char *v60;\n  char *ddnds[128];\n  char *shends[128];\n  unsigned long long v63;\n  v3 = 0LL;\n  v4 = ::argv[1];\n  v63 = __readfsqword(40u);\n  do {\n    v6 = v3;\n    if (libmin_strlen(v4) <= v3) {\n      v7 = ::argv[2];\n      v8 = 0LL;\n      while (1) {\n        v10 = libmin_strlen(v7);\n        v11 = v8;\n        v7 = ::argv[2];\n        if (v10 <= v8) break;\n        v9 = ::argv[2][v8++];\n        if ((pctype[v9] & 4) == 0) {\n          libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[2]);\n          if (v11) {\n            for (i = 0; i != v11; ++i) libmin_putc(32);\n          }\n          goto LABEL_13;\n        }\n      }\n      v12 = 0LL;\n      while (libmin_strlen(v7) > v12) {\n        v7 = ::argv[2];\n        v13 = ::argv[2][v12++];\n        if (v13 != 48) {\n          v17 = libmin_strpbrk(::argv[1], \"123456789\");\n          v18 = v17;\n          if (v17) {\n            ddnd_len = libmin_strlen(v17);\n            v19 = ddnd_len + 1;\n            v60 = (char *)libmin_malloc(v19);\n            ddnds[0] = v60;\n            libmin_strcpy(v60, v18);\n          } else {\n            v19 = 2LL;\n            v60 = (char *)libmin_malloc(2uLL);\n            ddnds[0] = v60;\n            libmin_strcpy(v60, \"0\");\n            ddnd_len = 1;\n          }\n          v20 = libmin_strpbrk(::argv[2], \"123456789\");\n          v58 = libmin_strlen(v20);\n          v59 = v58 + 1;\n          v21 = (char *)libmin_malloc(v58 + 1);\n          libmin_strcpy(v21, v20);\n          dgts_fwd = v58 - 1;\n          v22 = libmin_calloc(1uLL, v19);\n          if (v58 - 1 > 0) memset(v22, 48, (unsigned int)(v58 - 2) + 1LL);\n          step = 0LL;\n          for (j = shends;; ++j) {\n            v23 = ddnds[step];\n            if (v21) {\n              if (!v23 || !isgte_0(ddnds[step], v21)) {\n                v36 = 0;\n                v37 = ddnd_len - libmin_strlen(v22);\n                if (v37 > 0) {\n                  do {\n                    ++v36;\n                    libmin_strcat(v22, \"0\");\n                  } while (v36 != v37);\n                }\n                v38 = 0;\n                if (v59 < 0) {\n                  if (*v22 == 48) goto LABEL_50;\n                  libmin_printf((char *)\"%s\\n\", v22);\n                } else {\n                  do {\n                    libmin_putc(32);\n                    v39 = v38++;\n                  } while (v58 >= v39);\n                  if (*v22 != 48) {\n                    libmin_printf((char *)\"%s\\n\", v22);\n                    goto LABEL_52;\n                  }\n                  do {\n                  LABEL_50:\n                    ++v22;\n                    libmin_putc(32);\n                  } while (*v22 == 48);\n                  libmin_printf((char *)\"%s\\n\", v22);\n                  if (v59 >= 0) {\n                  LABEL_52:\n                    v40 = 0;\n                    do {\n                      libmin_putc(32);\n                      v41 = v40++;\n                    } while (v58 >= v41);\n                  }\n                }\n                v42 = 0;\n                if (ddnd_len > 0) {\n                  do {\n                    ++v42;\n                    libmin_putc(95);\n                  } while (v42 != ddnd_len);\n                }\n                libmin_printf(\"\\n %s)%s\\n\", v21, v60);\n                if ((uint32_t)step) {\n                  v43 = 0LL;\n                  v44 = ddnds[0];\n                  v45 = ddnd_len + v58 + 2;\n                  do {\n                    for (k = 0LL; k < v45 - libmin_strlen(v44); ++k)\n                      libmin_putc(32);\n                    v47 = 0LL;\n                    v48 = shends[v43];\n                    libmin_printf((char *)\"%s\\n\", v48);\n                    while (v45 - libmin_strlen(v44) > v47) {\n                      ++v47;\n                      libmin_putc(32);\n                    }\n                    for (m = 0LL; m < libmin_strlen(v48); ++m) libmin_putc(45);\n                    v50 = 0LL;\n                    libmin_putc(10);\n                    v44 = ddnds[v43 + 1];\n                    while (v45 - libmin_strlen(v44) > v50) {\n                      ++v50;\n                      libmin_putc(32);\n                    }\n                    ++v43;\n                    libmin_printf((char *)\"%s\\n\", v44);\n                  } while (v43 != step);\n                }\n                libmin_success();\n              }\n              v24 = dgts_fwd;\n              while (1) {\n                v25 = cut_off(v23, ++v24);\n                v26 = v25;\n                if (v25) {\n                  if (isgte_0(v25, v21)) break;\n                }\n                libmin_strcat(v22, \"0\");\n                libmin_free(v26);\n              }\n            } else {\n              v26 = cut_off(ddnds[step], dgts_fwd + 1);\n            }\n            v27 = 57;\n            dgts_fwda = v22;\n            pend = &v23[libmin_strlen(v26)];\n            do {\n              v28 = times_digit(v21, v27);\n              *j = v28;\n              v29 = v28;\n              if (!v28 || v26 && isgte_0(v26, v28)) break;\n              --v27;\n              libmin_free(v29);\n            } while (v27 != 48);\n            v30 = v29;\n            v22 = dgts_fwda;\n            dgts_fwda[libmin_strlen(dgts_fwda)] = v27;\n            v31 = sbc(v26, v30);\n            if (!libmin_strpbrk(v31, \"123456789\") ||\n                (v32 = libmin_strpbrk(v31, \"123456789\"),\n                 (dgts_fwd = libmin_strlen(v32)) == 0)) {\n              v35 = pend;\n              if (*pend == 48) {\n                do {\n                  ++v35;\n                  libmin_strcat(v22, \"0\");\n                } while (*v35 == 48);\n                pend = v35;\n              }\n              dgts_fwd = 0;\n            }\n            v33 = splice(v31, pend);\n            v34 = libmin_strpbrk(v33, \"123456789\");\n            ddnds[step + 1] = v34;\n            if (!v34) {\n              v51 = (char *)libmin_malloc(2uLL);\n              ddnds[step + 1] = v51;\n              libmin_strcpy(v51, \"0\");\n            }\n            libmin_free(v26);\n            ++step;\n          }\n        }\n      }\n      libmin_printf((char *)\"%s\\n\", \"longdiv: Cannot divide by 0.\\n\");\n      return 0;\n    }\n    v4 = ::argv[1];\n    v5 = ::argv[1][v3++];\n  } while ((pctype[v5] & 4) != 0);\n  v14 = 0;\n  libmin_printf(\"%s\\n%s\\n\", \"longdiv: syntax error\", ::argv[1]);\n  if (v6) {\n    do {\n      ++v14;\n      libmin_putc(32);\n    } while (v6 != v14);\n  }\nLABEL_13:\n  libmin_putc(94);\n  libmin_putc(10);\n  return 0;\n}", "binary": "longdiv/longdiv.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x868,%rsp\nmov    0x5eea(%rip),%rdi\nmov    %fs:0x28,%rax\nmov    %rax,0x858(%rsp)\nxor    %eax,%eax\njmp    1179 <main+0x59>\nnopl   0x0(%rax,%rax,1)\nmov    0x5ec9(%rip),%rdi\nmov    0x60e2(%rip),%rax\nmovsbq (%rdi,%rbx,1),%rdx\nadd    $0x1,%rbx\ntestb  $0x4,(%rax,%rdx,2)\nje     1200 <main+0xe0>\nmov    %ebx,%ebp\ncall   3920 <libmin_strlen>\ncmp    %rbx,%rax\nja     1158 <main+0x38>\nmov    0x5ea4(%rip),%rdi\nxor    %ebx,%ebx\njmp    11aa <main+0x8a>\nmovsbq (%rdi,%rbx,1),%rdx\nmov    0x60ac(%rip),%rax\nadd    $0x1,%rbx\ntestb  $0x4,(%rax,%rdx,2)\nje     1270 <main+0x150>\ncall   3920 <libmin_strlen>\nmov    %ebx,%ebp\nmov    0x5e78(%rip),%rdi\ncmp    %rbx,%rax\nja     1190 <main+0x70>\nxor    %ebx,%ebx\njmp    11df <main+0xbf>\nnopl   0x0(%rax)\nmov    0x5e61(%rip),%rdi\nmovzbl (%rdi,%rbx,1),%eax\nadd    $0x1,%rbx\ncmp    $0x30,%al\njne    12a3 <main+0x183>\ncall   3920 <libmin_strlen>\ncmp    %rbx,%rax\nja     11c8 <main+0xa8>\nlea    0x2e92(%rip),%rsi\nlea    0x2e7c(%rip),%rdi\nxor    %eax,%eax\ncall   36b0 <libmin_printf>\njmp    1245 <main+0x125>\nmov    %rdi,%rdx\nlea    0x2e50(%rip),%rsi\nxor    %eax,%eax\nxor    %ebx,%ebx\nlea    0x2e5b(%rip),%rdi\ncall   36b0 <libmin_printf>\ntest   %ebp,%ebp\nje     1231 <main+0x111>\nxchg   %ax,%ax\nmov    $0x20,%edi\nadd    $0x1,%ebx\ncall   38c0 <libmin_putc>\ncmp    %ebx,%ebp\njne    1220 <main+0x100>\nmov    $0x5e,%edi\ncall   38c0 <libmin_putc>\nmov    $0xa,%edi\ncall   38c0 <libmin_putc>\nmov    0x858(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1825 <main+0x705>\nadd    $0x868,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %rdi,%rdx\nxor    %eax,%eax\nlea    0x2dde(%rip),%rsi\nlea    0x2ded(%rip),%rdi\ncall   36b0 <libmin_printf>\ntest   %ebp,%ebp\nje     1231 <main+0x111>\nxor    %ebx,%ebx\nxchg   %ax,%ax\nmov    $0x20,%edi\nadd    $0x1,%ebx\ncall   38c0 <libmin_putc>\ncmp    %ebx,%ebp\njne    1290 <main+0x170>\njmp    1231 <main+0x111>\nmov    0x5d7e(%rip),%rdi\nlea    0x2d53(%rip),%rsi\ncall   39a0 <libmin_strpbrk>\nmov    %rax,%r12\ntest   %rax,%rax\nje     17b0 <main+0x690>\nmov    %r12,%rdi\ncall   3920 <libmin_strlen>\nmov    %eax,0x34(%rsp)\nadd    $0x1,%eax\nmovslq %eax,%rbp\nmov    %rbp,%rdi\ncall   2110 <libmin_malloc>\nmov    %r12,%rsi\nmov    %rax,%rdi\nmov    %rax,0x48(%rsp)\nmov    %rax,0x50(%rsp)\ncall   3900 <libmin_strcpy>\nmov    0x5d38(%rip),%rdi\nlea    0x2d05(%rip),%rsi\ncall   39a0 <libmin_strpbrk>\nmov    %rax,%rdi\nmov    %rax,%r12\ncall   3920 <libmin_strlen>\nmov    %rax,0x38(%rsp)\nmov    %rax,%rbx\nmov    %eax,0x44(%rsp)\nadd    $0x1,%eax\nlea    -0x1(%rbx),%ebx\nmovslq %eax,%rdi\nmov    %eax,0x40(%rsp)\ncall   2110 <libmin_malloc>\nmov    %r12,%rsi\nmov    %rax,%rdi\nmov    %rax,%r14\ncall   3900 <libmin_strcpy>\nmov    %rbp,%rsi\nmov    $0x1,%edi\nmov    %ebx,0x18(%rsp)\ncall   21e0 <libmin_calloc>\nmov    %rax,%r13\ntest   %ebx,%ebx\njle    136c <main+0x24c>\nmov    0x38(%rsp),%rax\nmov    $0x30,%esi\nmov    %r13,%rdi\nlea    -0x2(%rax),%edx\nadd    $0x1,%rdx\ncall   10d0 <memset@plt>\nlea    0x450(%rsp),%rax\nmovq   $0x0,(%rsp)\nlea    0x2cf4(%rip),%rbx\nmov    %rax,0x28(%rsp)\nmov    %rax,0x20(%rsp)\nlea    0x50(%rsp),%rax\nmov    %rax,0x8(%rsp)\nnopw   0x0(%rax,%rax,1)\nmov    (%rsp),%rax\nmov    0x8(%rsp),%rcx\nmov    %eax,%ebp\nmov    (%rcx,%rax,8),%r15\ntest   %r14,%r14\nje     1771 <main+0x651>\ntest   %r15,%r15\nje     1557 <main+0x437>\nmov    %r14,%rsi\nmov    %r15,%rdi\ncall   1920 <isgte.part.0>\ntest   %eax,%eax\nje     1557 <main+0x437>\nmov    0x18(%rsp),%r12d\njmp    13f3 <main+0x2d3>\nnopl   0x0(%rax,%rax,1)\nmov    %r13,%rdi\nmov    %rbx,%rsi\ncall   38d0 <libmin_strcat>\nmov    %rbp,%rdi\ncall   21c0 <libmin_free>\nadd    $0x1,%r12d\nmov    %r15,%rdi\nmov    %r12d,%esi\ncall   1de0 <cut_off>\nmov    %rax,%rbp\ntest   %rax,%rax\nje     13e0 <main+0x2c0>\nmov    %r14,%rsi\nmov    %rax,%rdi\ncall   1920 <isgte.part.0>\ntest   %eax,%eax\nje     13e0 <main+0x2c0>\nmov    %rbp,%rdi\nmov    $0x39,%r12d\ncall   3920 <libmin_strlen>\nmov    %r13,0x18(%rsp)\nadd    %r15,%rax\nmov    0x20(%rsp),%r15\nmov    %rax,0x10(%rsp)\njmp    1466 <main+0x346>\nnopl   0x0(%rax,%rax,1)\ntest   %rbp,%rbp\nje     1454 <main+0x334>\nmov    %rax,%rsi\nmov    %rbp,%rdi\ncall   1920 <isgte.part.0>\ntest   %eax,%eax\njne    147c <main+0x35c>\nmov    %r13,%rdi\nsub    $0x1,%r12d\ncall   21c0 <libmin_free>\ncmp    $0x30,%r12d\nje     147c <main+0x35c>\nmov    %r12d,%esi\nmov    %r14,%rdi\ncall   1c10 <times_digit>\nmov    %rax,(%r15)\nmov    %rax,%r13\ntest   %rax,%rax\njne    1440 <main+0x320>\nmov    %r13,%r15\nmov    0x18(%rsp),%r13\nmov    %r13,%rdi\ncall   3920 <libmin_strlen>\nmov    %r15,%rsi\nmov    %rbp,%rdi\nmov    %r12b,0x0(%r13,%rax,1)\ncall   1a20 <sbc>\nlea    0x2b61(%rip),%rsi\nmov    %rax,%rdi\nmov    %rax,%r12\ncall   39a0 <libmin_strpbrk>\ntest   %rax,%rax\nje     151d <main+0x3fd>\nlea    0x2b4a(%rip),%rsi\nmov    %r12,%rdi\ncall   39a0 <libmin_strpbrk>\nmov    %rax,%rdi\ncall   3920 <libmin_strlen>\nmov    %eax,0x18(%rsp)\ntest   %eax,%eax\nje     151d <main+0x3fd>\nmov    0x10(%rsp),%rsi\nmov    %r12,%rdi\ncall   1d60 <splice>\nlea    0x2b1e(%rip),%rsi\nmov    %rax,%rdi\ncall   39a0 <libmin_strpbrk>\nmov    0x8(%rsp),%rcx\nmov    (%rsp),%rdx\nmov    %rax,0x8(%rcx,%rdx,8)\ntest   %rax,%rax\nje     1788 <main+0x668>\nmov    %rbp,%rdi\ncall   21c0 <libmin_free>\naddq   $0x1,(%rsp)\naddq   $0x8,0x20(%rsp)\njmp    13a0 <main+0x280>\nmov    0x10(%rsp),%rax\nmov    0x10(%rsp),%r15\ncmpb   $0x30,(%rax)\njne    154a <main+0x42a>\nnopl   0x0(%rax)\nmov    %rbx,%rsi\nmov    %r13,%rdi\nadd    $0x1,%r15\ncall   38d0 <libmin_strcat>\ncmpb   $0x30,(%r15)\nje     1530 <main+0x410>\nmov    %r15,0x10(%rsp)\nmovl   $0x0,0x18(%rsp)\njmp    14d2 <main+0x3b2>\nmov    %r13,%rdi\nxor    %r12d,%r12d\nlea    0x2b13(%rip),%r15\ncall   3920 <libmin_strlen>\nmov    0x34(%rsp),%ebx\nsub    %eax,%ebx\ntest   %ebx,%ebx\njle    1587 <main+0x467>\nmov    %r15,%rsi\nmov    %r13,%rdi\nadd    $0x1,%r12d\ncall   38d0 <libmin_strcat>\ncmp    %ebx,%r12d\njne    1573 <main+0x453>\nxor    %ebx,%ebx\ncmpl   $0x0,0x40(%rsp)\nmov    0x44(%rsp),%r12d\njs     17e8 <main+0x6c8>\nnopl   0x0(%rax)\nmov    $0x20,%edi\ncall   38c0 <libmin_putc>\nmov    %ebx,%eax\nadd    $0x1,%ebx\ncmp    %eax,%r12d\njge    15a0 <main+0x480>\ncmpb   $0x30,0x0(%r13)\njne    180c <main+0x6ec>\nnop\nmov    $0x20,%edi\nadd    $0x1,%r13\ncall   38c0 <libmin_putc>\ncmpb   $0x30,0x0(%r13)\nje     15c0 <main+0x4a0>\nmov    %r13,%rsi\nlea    0x2a94(%rip),%r13\nxor    %eax,%eax\nmov    %r13,%rdi\ncall   36b0 <libmin_printf>\ncmpl   $0x0,0x40(%rsp)\njs     1614 <main+0x4f4>\nmov    0x44(%rsp),%r12d\nxor    %ebx,%ebx\nnopw   0x0(%rax,%rax,1)\nmov    $0x20,%edi\ncall   38c0 <libmin_putc>\nmov    %ebx,%eax\nadd    $0x1,%ebx\ncmp    %eax,%r12d\njge    1600 <main+0x4e0>\nxor    %ebx,%ebx\ncmpl   $0x0,0x34(%rsp)\nmov    0x34(%rsp),%r12d\njle    163a <main+0x51a>\nnopw   0x0(%rax,%rax,1)\nmov    $0x5f,%edi\nadd    $0x1,%ebx\ncall   38c0 <libmin_putc>\ncmp    %r12d,%ebx\njne    1628 <main+0x508>\nmov    0x48(%rsp),%rdx\nxor    %eax,%eax\nmov    %r14,%rsi\nlea    0x2a2e(%rip),%rdi\ncall   36b0 <libmin_printf>\ntest   %ebp,%ebp\nje     1767 <main+0x647>\nmov    0x34(%rsp),%eax\nmov    0x38(%rsp),%rcx\nxor    %r15d,%r15d\nmov    0x50(%rsp),%rbx\nlea    0x2(%rax,%rcx,1),%ebp\nmovslq %ebp,%rbp\nxor    %r12d,%r12d\njmp    1686 <main+0x566>\nnopl   (%rax)\nmov    $0x20,%edi\nadd    $0x1,%r12\ncall   38c0 <libmin_putc>\nmov    %rbx,%rdi\ncall   3920 <libmin_strlen>\nmov    %rax,%r8\nmov    %rbp,%rax\nsub    %r8,%rax\ncmp    %rax,%r12\njb     1678 <main+0x558>\nmov    0x28(%rsp),%rax\nmov    %r13,%rdi\nxor    %r12d,%r12d\nmov    (%rax,%r15,8),%r14\nxor    %eax,%eax\nmov    %r14,%rsi\ncall   36b0 <libmin_printf>\njmp    16ce <main+0x5ae>\nnopw   0x0(%rax,%rax,1)\nmov    $0x20,%edi\nadd    $0x1,%r12\ncall   38c0 <libmin_putc>\nmov    %rbx,%rdi\ncall   3920 <libmin_strlen>\nmov    %rax,%r8\nmov    %rbp,%rax\nsub    %r8,%rax\ncmp    %r12,%rax\nja     16c0 <main+0x5a0>\nxor    %ebx,%ebx\njmp    16fe <main+0x5de>\nnopl   0x0(%rax,%rax,1)\nmov    $0x2d,%edi\nadd    $0x1,%rbx\ncall   38c0 <libmin_putc>\nmov    %r14,%rdi\ncall   3920 <libmin_strlen>\ncmp    %rax,%rbx\njb     16f0 <main+0x5d0>\nmov    $0xa,%edi\nxor    %r12d,%r12d\ncall   38c0 <libmin_putc>\nmov    0x8(%rsp),%rax\nmov    0x8(%rax,%r15,8),%rbx\njmp    1736 <main+0x616>\nnopl   0x0(%rax)\nmov    $0x20,%edi\nadd    $0x1,%r12\ncall   38c0 <libmin_putc>\nmov    %rbx,%rdi\ncall   3920 <libmin_strlen>\nmov    %rax,%r8\nmov    %rbp,%rax\nsub    %r8,%rax\ncmp    %r12,%rax\nja     1728 <main+0x608>\nmov    %rbx,%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%r15\ncall   36b0 <libmin_printf>\ncmp    (%rsp),%r15\njne    1670 <main+0x550>\ncall   39c0 <libmin_success>\njmp    1245 <main+0x125>\nmov    0x18(%rsp),%esi\nmov    %r15,%rdi\nadd    $0x1,%esi\ncall   1de0 <cut_off>\nmov    %rax,%rbp\njmp    1419 <main+0x2f9>\nmov    $0x2,%edi\ncall   2110 <libmin_malloc>\nmov    (%rsp),%rcx\nmov    %rbx,%rsi\nmov    %rax,%rdi\nmov    0x8(%rsp),%rax\nmov    %rdi,0x8(%rax,%rcx,8)\ncall   3900 <libmin_strcpy>\njmp    1505 <main+0x3e5>\nmov    $0x2,%edi\nlea    0x28bb(%rip),%r15\nmov    $0x2,%ebp\ncall   2110 <libmin_malloc>\nmov    %r15,%rsi\nmov    %rax,%rdi\nmov    %rax,0x48(%rsp)\nmov    %rax,0x50(%rsp)\ncall   3900 <libmin_strcpy>\nmovl   $0x1,0x34(%rsp)\njmp    12f1 <main+0x1d1>\ncmpb   $0x30,0x0(%r13)\nje     15c0 <main+0x4a0>\nmov    %r13,%rsi\nlea    0x2876(%rip),%r13\nxor    %eax,%eax\nmov    %r13,%rdi\ncall   36b0 <libmin_printf>\njmp    1614 <main+0x4f4>\nmov    %r13,%rsi\nlea    0x285d(%rip),%r13\nxor    %eax,%eax\nmov    %r13,%rdi\ncall   36b0 <libmin_printf>\njmp    15f0 <main+0x4d0>\ncall   10c0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "sbc", "content": "\t\n\t\t \n\t\n\n/* Given character strings of digits with mend >= shend, this returns a pointer\nto the string corresponding to minuend - subtrahend. Returns NULL if\nminuend < subtrahend. Result array is padded with leading zeros.  \n*/\n\nchar *sbc(char *mend, char *shend)\n{\n\tint need_borrow = FALSE;\n\tint lm,ls,i;\n\tchar *res;\n\tchar *mnd,*p;\n\n\tif(!isgte(mend,shend))return NULL;\n\n\tlm = libmin_strlen(mend);\n\tls = libmin_strlen(shend);\n\tres = (char *)libmin_malloc(libmin_strlen(mend)+1);\n\tif(res == NULL){\n\t\tlibmin_printf(\"sbc: Unable to malloc space for result\\n\");\n\t\tlibmin_fail(1);\n\t}\n\tp = mnd = (char *)libmin_malloc(libmin_strlen(mend)+1);\n\tif(mnd == NULL){\n\t\tlibmin_printf(\"sbc: Unable to malloc\\n\");\n\t\tlibmin_fail(1);\n\t}\n\tlibmin_strcpy(mnd,mend);\n\n\t/* Fill result array with digit zero */\n\n\tfor(i=0;i<lm;i++)res[i]='0';\n\tres[lm] = '\\0';\n\n\n\tfor(i = 0; i<lm; i++){\n\t\tif (need_borrow)\n    {\n\t\t\tif(mnd[lm-i-1] == '0')\n\t\t\t\tmnd[lm-i-1] = '9'; /* need_borrow stays TRUE */\n\t\t\telse {\n\t\t\t\t--mnd[lm-i-1];\n\t\t\t\tneed_borrow = FALSE;\n\t\t\t}\n    }\n\t\tif( i < ls )\n\t\t need_borrow |= sub(mnd[lm-i-1],shend[ls-i-1],res+lm-i-1);\n\t\telse\n\t\t need_borrow |= sub(mnd[lm-i-1],'0',res+lm-i-1);\n\t}\n\t\t\n\tlibmin_free(p);\n\treturn res;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O2.pseudo", "function_name": "sbc", "address": "0x1a20", "label": "sbc", "content": "char *__fastcall sbc(char *mend, char *shend)\n{\n  int v3; // r14d\n  size_t v4; // rax\n  _BYTE *v5; // r13\n  size_t v6; // rax\n  char *v7; // rax\n  char *v8; // r8\n  int v9; // edi\n  int v10; // ecx\n  char *v11; // rsi\n  char *v12; // rdx\n  char v13; // r9\n  char v14; // al\n  char v15; // al\n  char v16; // al\n  int lm; // [rsp+8h] [rbp-50h]\n  char *p; // [rsp+10h] [rbp-48h]\n\n  if ( shend && (!mend || !isgte_0(mend, shend)) )\n    return 0LL;\n  lm = libmin_strlen(mend);\n  v3 = libmin_strlen(shend);\n  v4 = libmin_strlen(mend);\n  v5 = libmin_malloc(v4 + 1);\n  if ( !v5 )\n  {\n    libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n    libmin_fail(1);\n  }\n  v6 = libmin_strlen(mend);\n  v7 = (char *)libmin_malloc(v6 + 1);\n  if ( !v7 )\n  {\n    libmin_printf(\"sbc: Unable to malloc\\n\");\n    libmin_fail(1);\n  }\n  p = v7;\n  libmin_strcpy(v7, mend);\n  v8 = p;\n  if ( lm <= 0 )\n  {\n    v5[lm] = 0;\n  }\n  else\n  {\n    memset(v5, 48, (unsigned int)(lm - 1) + 1LL);\n    v9 = 0;\n    v8 = p;\n    v5[lm] = 0;\n    v10 = 0;\n    v11 = &v5[lm - 1];\n    v12 = &p[lm - 1];\nLABEL_8:\n    if ( v10 < v3 )\n    {\nLABEL_9:\n      v13 = shend[v3 - v10 - 1];\n      v14 = *v12;\n      if ( v13 <= *v12 )\n      {\n        v15 = v14 + 48;\n      }\n      else\n      {\n        v15 = v14 + 58;\n        v9 = 1;\n      }\n      v16 = v15 - v13;\n      goto LABEL_12;\n    }\n    while ( 1 )\n    {\n      v16 = *v12;\n      if ( *v12 <= 47 )\n      {\n        v16 += 10;\n        v9 = 1;\n      }\nLABEL_12:\n      ++v10;\n      *v11 = v16;\n      --v12;\n      --v11;\n      if ( lm == v10 )\n        break;\n      if ( !v9 )\n        goto LABEL_8;\n      if ( *v12 == 48 )\n      {\n        *v12 = 57;\n        goto LABEL_8;\n      }\n      v9 = 0;\n      --*v12;\n      if ( v10 < v3 )\n        goto LABEL_9;\n    }\n  }\n  libmin_free(v8);\n  return v5;\n}\n"}, "pseudo_normalize": "char *sbc(char *mend, char *shend) {\n  int v3;\n  unsigned int v4;\n  uint8_t *v5;\n  unsigned int v6;\n  char *v7;\n  char *v8;\n  int v9;\n  int v10;\n  char *v11;\n  char *v12;\n  char v13;\n  char v14;\n  char v15;\n  char v16;\n  int lm;\n  char *p;\n  if (shend && (!mend || !isgte_0(mend, shend))) return 0LL;\n  lm = libmin_strlen(mend);\n  v3 = libmin_strlen(shend);\n  v4 = libmin_strlen(mend);\n  v5 = libmin_malloc(v4 + 1);\n  if (!v5) {\n    libmin_printf(\"sbc: Unable to malloc space for result\\n\");\n    libmin_fail(1);\n  }\n  v6 = libmin_strlen(mend);\n  v7 = (char *)libmin_malloc(v6 + 1);\n  if (!v7) {\n    libmin_printf(\"sbc: Unable to malloc\\n\");\n    libmin_fail(1);\n  }\n  p = v7;\n  libmin_strcpy(v7, mend);\n  v8 = p;\n  if (lm <= 0) {\n    v5[lm] = 0;\n  } else {\n    memset(v5, 48, (unsigned int)(lm - 1) + 1LL);\n    v9 = 0;\n    v8 = p;\n    v5[lm] = 0;\n    v10 = 0;\n    v11 = &v5[lm - 1];\n    v12 = &p[lm - 1];\n  LABEL_8:\n    if (v10 < v3) {\n    LABEL_9:\n      v13 = shend[v3 - v10 - 1];\n      v14 = *v12;\n      if (v13 <= *v12) {\n        v15 = v14 + 48;\n      } else {\n        v15 = v14 + 58;\n        v9 = 1;\n      }\n      v16 = v15 - v13;\n      goto LABEL_12;\n    }\n    while (1) {\n      v16 = *v12;\n      if (*v12 <= 47) {\n        v16 += 10;\n        v9 = 1;\n      }\n    LABEL_12:\n      ++v10;\n      *v11 = v16;\n      --v12;\n      --v11;\n      if (lm == v10) break;\n      if (!v9) goto LABEL_8;\n      if (*v12 == 48) {\n        *v12 = 57;\n        goto LABEL_8;\n      }\n      v9 = 0;\n      --*v12;\n      if (v10 < v3) goto LABEL_9;\n    }\n  }\n  libmin_free(v8);\n  return v5;\n}", "binary": "longdiv/longdiv.host.O2", "assembly": "<sbc>:\nendbr64\npush   %r15\nmov    %rdi,%r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x28,%rsp\ntest   %rsi,%rsi\nje     1a53 <sbc+0x33>\ntest   %rdi,%rdi\nje     1bb8 <sbc+0x198>\ncall   1920 <isgte.part.0>\ntest   %eax,%eax\nje     1bb8 <sbc+0x198>\nmov    %r15,%rdi\ncall   3920 <libmin_strlen>\nmov    %rbx,%rdi\nmov    %rax,0x8(%rsp)\nmov    %eax,%ebp\ncall   3920 <libmin_strlen>\nmov    %r15,%rdi\nmov    %rax,%r14\nmov    %eax,%r12d\ncall   3920 <libmin_strlen>\nlea    0x1(%rax),%rdi\ncall   2110 <libmin_malloc>\nmov    %rax,%r13\ntest   %rax,%rax\nje     1bf0 <sbc+0x1d0>\nmov    %r15,%rdi\ncall   3920 <libmin_strlen>\nlea    0x1(%rax),%rdi\ncall   2110 <libmin_malloc>\nmov    %rax,%r8\ntest   %rax,%rax\nje     1bc0 <sbc+0x1a0>\nmov    %r8,%rdi\nmov    %r15,%rsi\nmov    %r8,0x10(%rsp)\ncall   3900 <libmin_strcpy>\nmov    0x8(%rsp),%rax\nmov    0x10(%rsp),%r8\nmovslq %eax,%rcx\ntest   %eax,%eax\nmov    %rcx,0x8(%rsp)\nlea    0x0(%r13,%rcx,1),%r9\njle    1b90 <sbc+0x170>\nlea    -0x1(%rax),%edx\nmov    $0x30,%esi\nmov    %r13,%rdi\nmov    %r9,0x18(%rsp)\nadd    $0x1,%rdx\ncall   10d0 <memset@plt>\nmov    0x18(%rsp),%r9\nmov    0x8(%rsp),%rcx\nxor    %edi,%edi\nmov    0x10(%rsp),%r8\nmovb   $0x0,(%r9)\nlea    -0x1(%rcx),%rdx\nxor    %ecx,%ecx\nlea    0x0(%r13,%rdx,1),%rsi\nadd    %r8,%rdx\nnopl   (%rax)\ncmp    %r12d,%ecx\njge    1b65 <sbc+0x145>\nmov    %r14d,%eax\nsub    %ecx,%eax\ncltq\nmovzbl -0x1(%rbx,%rax,1),%r9d\nmovzbl (%rdx),%eax\ncmp    %al,%r9b\njle    1b88 <sbc+0x168>\nadd    $0x3a,%eax\nmov    $0x1,%edi\nsub    %r9d,%eax\nadd    $0x1,%ecx\nmov    %al,(%rsi)\nsub    $0x1,%rdx\nsub    $0x1,%rsi\ncmp    %ecx,%ebp\nje     1b98 <sbc+0x178>\ntest   %edi,%edi\nje     1b18 <sbc+0xf8>\nmovzbl (%rdx),%eax\ncmp    $0x30,%al\nje     1b80 <sbc+0x160>\nsub    $0x1,%eax\nxor    %edi,%edi\nmov    %al,(%rdx)\ncmp    %r12d,%ecx\njl     1b1d <sbc+0xfd>\nmovzbl (%rdx),%eax\ncmp    $0x2f,%al\njg     1b3d <sbc+0x11d>\nadd    $0xa,%eax\nmov    $0x1,%edi\njmp    1b3d <sbc+0x11d>\ncs nopw 0x0(%rax,%rax,1)\nmovb   $0x39,(%rdx)\njmp    1b18 <sbc+0xf8>\nnopl   (%rax)\nadd    $0x30,%eax\nsub    %r9d,%eax\njmp    1b3d <sbc+0x11d>\nmovb   $0x0,(%r9)\nnopl   0x0(%rax)\nmov    %r8,%rdi\ncall   21c0 <libmin_free>\nadd    $0x28,%rsp\nmov    %r13,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nxor    %r13d,%r13d\njmp    1ba0 <sbc+0x180>\nnopl   (%rax)\nmov    %rax,0x10(%rsp)\nlea    0x2442(%rip),%rdi\nxor    %eax,%eax\ncall   36b0 <libmin_printf>\nmov    $0x1,%edi\ncall   2060 <libmin_fail>\nmov    0x10(%rsp),%r8\njmp    1aaa <sbc+0x8a>\nnopw   0x0(%rax,%rax,1)\nlea    0x24c1(%rip),%rdi\nxor    %eax,%eax\ncall   36b0 <libmin_printf>\nmov    $0x1,%edi\ncall   2060 <libmin_fail>\njmp    1a8d <sbc+0x6d>\nnopl   (%rax)\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "splice", "content": "/* Allocates a new string consisting of front and back glued together */\n\nchar *\nsplice(char *front, char *back)\n{\n\n\tchar *res;\n\tint len;\n\n\tif(front == NULL)return back;\n\tif(back == NULL) return front;  \n\tlen = libmin_strlen(front)+libmin_strlen(back);\n\n\tres = (char *)libmin_malloc((len+1)*sizeof(char));\n\tif(res == NULL) {\n\t\tlibmin_printf(\"splice: unable to malloc\\n\");\n\t\treturn NULL;\n\t}\n\tlibmin_strcpy(res,front);\n\tlibmin_strcat(res,back);\n\treturn res;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O2.pseudo", "function_name": "splice", "address": "0x1d60", "label": "splice", "content": "char *__fastcall splice(char *front, char *back)\n{\n  char *v2; // r12\n  int v3; // r12d\n  int v4; // eax\n  char *v5; // rax\n\n  if ( !front )\n    return back;\n  v2 = front;\n  if ( back )\n  {\n    v3 = libmin_strlen(front);\n    v4 = libmin_strlen(back);\n    v5 = (char *)libmin_malloc(v3 + v4 + 1);\n    v2 = v5;\n    if ( v5 )\n    {\n      libmin_strcpy(v5, front);\n      libmin_strcat(v2, back);\n    }\n    else\n    {\n      libmin_printf(\"splice: unable to malloc\\n\");\n    }\n  }\n  return v2;\n}\n"}, "pseudo_normalize": "char *splice(char *front, char *back) {\n  char *v2;\n  int v3;\n  int v4;\n  char *v5;\n  if (!front) return back;\n  v2 = front;\n  if (back) {\n    v3 = libmin_strlen(front);\n    v4 = libmin_strlen(back);\n    v5 = (char *)libmin_malloc(v3 + v4 + 1);\n    v2 = v5;\n    if (v5) {\n      libmin_strcpy(v5, front);\n      libmin_strcat(v2, back);\n    } else {\n      libmin_printf(\"splice: unable to malloc\\n\");\n    }\n  }\n  return v2;\n}", "binary": "longdiv/longdiv.host.O2", "assembly": "<splice>:\nendbr64\npush   %r13\nmov    %rsi,%r13\npush   %r12\npush   %rbp\ntest   %rdi,%rdi\nje     1dc0 <splice+0x60>\nmov    %rdi,%rbp\nmov    %rdi,%r12\ntest   %rsi,%rsi\nje     1db7 <splice+0x57>\ncall   3920 <libmin_strlen>\nmov    %r13,%rdi\nmov    %rax,%r12\ncall   3920 <libmin_strlen>\nlea    0x1(%r12,%rax,1),%edi\nmovslq %edi,%rdi\ncall   2110 <libmin_malloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1dd0 <splice+0x70>\nmov    %rbp,%rsi\nmov    %rax,%rdi\ncall   3900 <libmin_strcpy>\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   38d0 <libmin_strcat>\nmov    %r12,%rax\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    %rsi,%r12\npop    %rbp\nmov    %r12,%rax\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nlea    0x224e(%rip),%rdi\nxor    %eax,%eax\ncall   36b0 <libmin_printf>\njmp    1db7 <splice+0x57>\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "sub", "content": "/* longdiv.c: program to print out examples of \"long-division\" problems.\n*  (Sure wish I had one of these in grade school.)\n*\n* By Terry R. McConnell 12/97\n*\n* Usage: longdiv <dividend> <divisor>\n* Here both dividend and divisor must be positive integers. At some point\n* we should improve the program to handle decimal points, negative\n* numbers, and other bases,\n* but this should be sufficient to establish the concept.\n*\n* Dividend and divisor can be arbitrarily long, subject only to the size of\n* ARG_MAX on your system. POSIX.1 ensures that this is at least 4096 bytes.\n* I.e, this can handle REALLY LARGE division problems!\n*\n* A bit of useful terminology: \n*   dividend = that which is divided into ( = numerator ).\n*   divisor  = that which is divided by ( = denominator ).\n*   subtrahend = that which is subtracted.\n*   minuend  = that which is subtracted from.\n*/\n\n\n#define _POSIX_SOURCE\n#define USAGE \"Usage: longdiv <dividend> <divisor>\"\n#define DIGITS \"123456789\"\n\n#include \"libmin.h\"\n\n#define RADIX 10 /* Actually, base 10 is assumed at many points in the pgm,\n                    so porting this to handle other bases will involve more\n                    than just changing this define. */\n\n#define BORROW 1\n#define NO_BORROW 0\n\n\n/* The main routine is at the bottom, following a number of auxiliary\n   routines.\n*/\n\n/* Subtracts digits and stores result in res. Returns indicator of whether\n   or not borrow is needed.\n*/\n\nint\nsub( char x, char y, char *res)\n{\n\tif( x >= y){\n\t\t *res = '0' + x - y;\n\t\t return FALSE;\n\t}\n\t*res = '0' + x - y + 10;\n\treturn TRUE;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O2.pseudo", "function_name": "sub", "address": "0x19c0", "label": "sub", "content": "int __fastcall sub(char x, char y, char *res)\n{\n  int result; // eax\n  char v4; // cl\n\n  result = 1;\n  v4 = x - y + 58;\n  if ( x >= y )\n  {\n    v4 = x - y + 48;\n    result = 0;\n  }\n  *res = v4;\n  return result;\n}\n"}, "pseudo_normalize": "int sub(char x, char y, char *res) {\n  int result;\n  char v4;\n  result = 1;\n  v4 = x - y + 58;\n  if (x >= y) {\n    v4 = x - y + 48;\n    result = 0;\n  }\n  *res = v4;\n  return result;\n}", "binary": "longdiv/longdiv.host.O2", "assembly": "<sub>:\nendbr64\nmov    %edi,%r8d\nmov    $0x1,%eax\nsub    %esi,%r8d\nlea    0x3a(%r8),%ecx\ncmp    %sil,%dil\njl     19de <sub+0x1e>\nlea    0x30(%r8),%ecx\nxor    %eax,%eax\nmov    %cl,(%rdx)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "longdiv/longdiv.c", "function_name": "times_digit", "content": "/* Multiplies digit string by digit character. Returns string pointing\n   to answer. Leading zeros are removed.\n*/\n\nchar *\ntimes_digit(char *mcand, char dgt)\n{\n\n\tint i,len;\n\tint carry=0,idgt,curdgt,prod;\n\tchar *res,*tmp;\n\n\tif(mcand == NULL) return NULL;\n\n\tidgt = dgt - '0';\n\tlen = libmin_strlen(mcand);\n\ttmp = (char *)libmin_malloc(len+2);\n\tif(tmp==NULL){\n\t\tlibmin_printf(\"Unable to malloc partial product array\\n\");\n\t\tlibmin_fail(1);\n\t}\n\t\n\ttmp[len+1]='\\0';\n\n\tfor(i=0;i<len;i++){\n\t\tcurdgt = mcand[len-i-1] - '0';\n\t\tprod = curdgt*idgt + carry;\n\t\ttmp[len-i] = '0' + (prod % RADIX);\t\n\t\tcarry = prod/RADIX;\n\t}\n\ttmp[0] = '0' + carry;\n\tif(tmp[0]=='0'){\n\t\tres = (char *)libmin_malloc(len+1);\n\t\tif(res == NULL){\n\t\t\tlibmin_printf(\"Unable to malloc partial product array\\n\");\n\t\t\tlibmin_fail(1);\n\t\t}\n\t\tres[len]='\\0';\n\t\tlibmin_strcpy(res,tmp+1);\n\t\tlibmin_free(tmp);\n\t}\n\telse res = tmp;\n\treturn res;\n}\n"}, "pseudo": {"path": "longdiv/longdiv.host.O2.pseudo", "function_name": "times_digit", "address": "0x1c10", "label": "times_digit", "content": "char *__fastcall times_digit(char *mcand, char dgt)\n{\n  int v2; // r14d\n  _BYTE *v3; // rax\n  _BYTE *v4; // r12\n  __int64 v5; // rcx\n  int v6; // edx\n  int v7; // eax\n  char v8; // dl\n  char *v10; // rax\n  char *v11; // rbx\n\n  if ( !mcand )\n    return 0LL;\n  v2 = libmin_strlen(mcand);\n  v3 = libmin_malloc(v2 + 2);\n  v4 = v3;\n  if ( !v3 )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v3[v2 + 1] = 0;\n  if ( v2 <= 0 )\n  {\n    *v3 = 48;\n  }\n  else\n  {\n    v5 = v2;\n    v6 = 0;\n    do\n    {\n      v7 = v6 + (dgt - 48) * (mcand[v5 - 1] - 48);\n      v6 = v7 / 10;\n      v4[v5--] = v7 % 10 + 48;\n    }\n    while ( v2 - 1LL - (unsigned int)(v2 - 1) != v5 );\n    v8 = v6 + 48;\n    *v4 = v8;\n    if ( v8 != 48 )\n      return v4;\n  }\n  v10 = (char *)libmin_malloc(v2 + 1LL);\n  v11 = v10;\n  if ( !v10 )\n  {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v10[v2] = 0;\n  libmin_strcpy(v10, v4 + 1);\n  libmin_free(v4);\n  return v11;\n}\n"}, "pseudo_normalize": "char *times_digit(char *mcand, char dgt) {\n  int v2;\n  uint8_t *v3;\n  uint8_t *v4;\n  long long v5;\n  int v6;\n  int v7;\n  char v8;\n  char *v10;\n  char *v11;\n  if (!mcand) return 0LL;\n  v2 = libmin_strlen(mcand);\n  v3 = libmin_malloc(v2 + 2);\n  v4 = v3;\n  if (!v3) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v3[v2 + 1] = 0;\n  if (v2 <= 0) {\n    *v3 = 48;\n  } else {\n    v5 = v2;\n    v6 = 0;\n    do {\n      v7 = v6 + (dgt - 48) * (mcand[v5 - 1] - 48);\n      v6 = v7 / 10;\n      v4[v5--] = v7 % 10 + 48;\n    } while (v2 - 1LL - (unsigned int)(v2 - 1) != v5);\n    v8 = v6 + 48;\n    *v4 = v8;\n    if (v8 != 48) return v4;\n  }\n  v10 = (char *)libmin_malloc(v2 + 1LL);\n  v11 = v10;\n  if (!v10) {\n    libmin_printf(\"Unable to malloc partial product array\\n\");\n    libmin_fail(1);\n  }\n  v10[v2] = 0;\n  libmin_strcpy(v10, v4 + 1);\n  libmin_free(v4);\n  return v11;\n}", "binary": "longdiv/longdiv.host.O2", "assembly": "<times_digit>:\nendbr64\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\ntest   %rdi,%rdi\nje     1d10 <times_digit+0x100>\nmovsbl %sil,%esi\nmov    %rdi,%rbp\nlea    -0x30(%rsi),%ebx\ncall   3920 <libmin_strlen>\nlea    0x2(%rax),%edi\nmov    %rax,%r14\nmovslq %edi,%rdi\ncall   2110 <libmin_malloc>\nmov    %rax,%r12\ntest   %rax,%rax\nje     1d20 <times_digit+0x110>\nmovslq %r14d,%r13\nmovb   $0x0,0x1(%r12,%r13,1)\nlea    0x1(%r13),%rdi\ntest   %r14d,%r14d\njle    1cd0 <times_digit+0xc0>\nlea    -0x1(%r13),%rsi\nlea    -0x1(%r14),%eax\nmov    %r13,%rcx\nxor    %edx,%edx\nsub    %rax,%rsi\nmovsbl -0x1(%rbp,%rcx,1),%eax\nsub    $0x30,%eax\nimul   %ebx,%eax\nadd    %edx,%eax\nmovslq %eax,%rdx\nmov    %eax,%r8d\nimul   $0x66666667,%rdx,%rdx\nsar    $0x1f,%r8d\nsar    $0x22,%rdx\nsub    %r8d,%edx\nlea    (%rdx,%rdx,4),%r8d\nadd    %r8d,%r8d\nsub    %r8d,%eax\nadd    $0x30,%eax\nmov    %al,(%r12,%rcx,1)\nsub    $0x1,%rcx\ncmp    %rcx,%rsi\njne    1c70 <times_digit+0x60>\nadd    $0x30,%edx\nmov    %dl,(%r12)\ncmp    $0x30,%dl\nje     1cd5 <times_digit+0xc5>\npop    %rbx\nmov    %r12,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopw   0x0(%rax,%rax,1)\nmovb   $0x30,(%r12)\ncall   2110 <libmin_malloc>\nmov    %rax,%rbx\ntest   %rax,%rax\nje     1d3d <times_digit+0x12d>\nmovb   $0x0,(%rbx,%r13,1)\nlea    0x1(%r12),%rsi\nmov    %rbx,%rdi\ncall   3900 <libmin_strcpy>\nmov    %r12,%rdi\nmov    %rbx,%r12\ncall   21c0 <libmin_free>\npop    %rbx\nmov    %r12,%rax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nxor    %r12d,%r12d\npop    %rbx\npop    %rbp\nmov    %r12,%rax\npop    %r12\npop    %r13\npop    %r14\nret\nnop\nlea    0x23b9(%rip),%rdi\nxor    %eax,%eax\ncall   36b0 <libmin_printf>\nmov    $0x1,%edi\ncall   2060 <libmin_fail>\njmp    1c4e <times_digit+0x3e>\nlea    0x239c(%rip),%rdi\nxor    %eax,%eax\ncall   36b0 <libmin_printf>\nmov    $0x1,%edi\ncall   2060 <libmin_fail>\njmp    1ce2 <times_digit+0xd2>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "lu-decomp/lu-decomp.c", "function_name": "lu_decomposition", "content": "void lu_decomposition(double A[N][N], double L[N][N], double U[N][N]) {\n    for (int i = 0; i < N; i++) {\n        // Compute U row\n        for (int k = i; k < N; k++) {\n            double sum = 0;\n            for (int j = 0; j < i; j++)\n                sum += L[i][j] * U[j][k];\n            U[i][k] = A[i][k] - sum;\n        }\n\n        // Compute L column\n        for (int k = i; k < N; k++) {\n            if (i == k)\n                L[i][i] = 1.0;\n            else {\n                double sum = 0;\n                for (int j = 0; j < i; j++)\n                    sum += L[k][j] * U[j][i];\n                L[k][i] = (A[k][i] - sum) / U[i][i];\n            }\n        }\n    }\n}\n"}, "pseudo": {"path": "lu-decomp/lu-decomp.host.O2.pseudo", "function_name": "lu_decomposition", "address": "0x1420", "label": "lu_decomposition", "content": "void __fastcall lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5])\n{\n  __int64 v4; // r15\n  __int64 v5; // r10\n  __int64 v6; // rbp\n  int v8; // r8d\n  __int64 v9; // r11\n  __int64 v10; // rsi\n  int v11; // ecx\n  double v12; // xmm1_8\n  double *v13; // rdx\n  __int64 v14; // rax\n  double v15; // xmm0_8\n  __int64 v16; // rsi\n  double v17; // xmm1_8\n  double *v18; // rdx\n  __int64 v19; // rax\n  double v20; // xmm0_8\n  double *v21; // [rsp+0h] [rbp-40h]\n  double *v22; // [rsp+8h] [rbp-38h]\n\n  v4 = 0LL;\n  v5 = 0LL;\n  v6 = 0LL;\n  v22 = (double *)L;\n  v21 = (double *)U;\n  do\n  {\n    v8 = v6;\n    v9 = v6;\n    v10 = v6++;\n    v11 = v8;\n    do\n    {\n      v12 = 0.0;\n      if ( v9 )\n      {\n        v13 = &(*U)[v10];\n        v14 = 0LL;\n        v12 = 0.0;\n        do\n        {\n          v15 = (*L)[v4 + v14++] * *v13;\n          v13 += 5;\n          v12 = v12 + v15;\n        }\n        while ( v8 > (int)v14 );\n      }\n      (*U)[v4 + v10] = (*A)[v4 + v10] - v12;\n      ++v10;\n    }\n    while ( v10 != 5 );\n    v16 = v5 * 8;\n    do\n    {\n      if ( v8 == v11 )\n      {\n        (*L)[v5] = 1.0;\n      }\n      else\n      {\n        v17 = 0.0;\n        if ( v11 > 0 )\n        {\n          v18 = v21;\n          v19 = 0LL;\n          do\n          {\n            v20 = *(double *)((char *)&v22[v19++] + v16) * *v18;\n            v18 += 5;\n            v17 = v17 + v20;\n          }\n          while ( v11 > (int)v19 );\n        }\n        *(double *)((char *)*L + v16) = (*(double *)((char *)*A + v16) - v17) / (*U)[v5];\n      }\n      ++v8;\n      v16 += 40LL;\n    }\n    while ( v8 != 5 );\n    ++v21;\n    v5 += 6LL;\n    v4 += 5LL;\n    --v22;\n  }\n  while ( v6 != 5 );\n}\n"}, "pseudo_normalize": "void lu_decomposition(double (*A)[5], double (*L)[5], double (*U)[5]) {\n  long long v4;\n  long long v5;\n  long long v6;\n  int v8;\n  long long v9;\n  long long v10;\n  int v11;\n  double v12;\n  double *v13;\n  long long v14;\n  double v15;\n  long long v16;\n  double v17;\n  double *v18;\n  long long v19;\n  double v20;\n  double *v21;\n  double *v22;\n  v4 = 0LL;\n  v5 = 0LL;\n  v6 = 0LL;\n  v22 = (double *)L;\n  v21 = (double *)U;\n  do {\n    v8 = v6;\n    v9 = v6;\n    v10 = v6++;\n    v11 = v8;\n    do {\n      v12 = 0.0;\n      if (v9) {\n        v13 = &(*U)[v10];\n        v14 = 0LL;\n        v12 = 0.0;\n        do {\n          v15 = (*L)[v4 + v14++] * *v13;\n          v13 += 5;\n          v12 = v12 + v15;\n        } while (v8 > (int)v14);\n      }\n      (*U)[v4 + v10] = (*A)[v4 + v10] - v12;\n      ++v10;\n    } while (v10 != 5);\n    v16 = v5 * 8;\n    do {\n      if (v8 == v11) {\n        (*L)[v5] = 1.0;\n      } else {\n        v17 = 0.0;\n        if (v11 > 0) {\n          v18 = v21;\n          v19 = 0LL;\n          do {\n            v20 = *(double *)((char *)&v22[v19++] + v16) * *v18;\n            v18 += 5;\n            v17 = v17 + v20;\n          } while (v11 > (int)v19);\n        }\n        *(double *)((char *)*L + v16) =\n            (*(double *)((char *)*A + v16) - v17) / (*U)[v5];\n      }\n      ++v8;\n      v16 += 40LL;\n    } while (v8 != 5);\n    ++v21;\n    v5 += 6LL;\n    v4 += 5LL;\n    --v22;\n  } while (v6 != 5);\n}", "binary": "lu-decomp/lu-decomp.host.O2", "assembly": "<lu_decomposition>:\nendbr64\npush   %r15\nmovsd  0x1bea(%rip),%xmm3\nmov    %rdx,%r9\nxor    %r15d,%r15d\npush   %r14\nxor    %r10d,%r10d\npxor   %xmm2,%xmm2\npush   %r13\nmov    %rdi,%r13\npush   %r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nmov    %rsi,%rbx\nmov    %rsi,-0x8(%rsp)\nmov    %rdx,-0x10(%rsp)\nmov    %ebp,%r8d\nlea    (%rbx,%r15,1),%rdi\nlea    0x0(%r13,%r15,1),%r14\nmov    %rbp,%r11\nlea    0x0(,%rbp,8),%rsi\nlea    (%r9,%r15,1),%r12\nadd    $0x1,%rbp\nmov    %r8d,%ecx\nmovapd %xmm2,%xmm1\ntest   %r11,%r11\nje     14a3 <lu_decomposition+0x83>\nlea    (%r9,%rsi,1),%rdx\nxor    %eax,%eax\nmovapd %xmm2,%xmm1\nmovsd  (%rdi,%rax,8),%xmm0\nmulsd  (%rdx),%xmm0\nadd    $0x1,%rax\nadd    $0x28,%rdx\naddsd  %xmm0,%xmm1\ncmp    %eax,%ecx\njg     148a <lu_decomposition+0x6a>\nmovsd  (%r14,%rsi,1),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%r12,%rsi,1)\nadd    $0x8,%rsi\ncmp    $0x28,%rsi\njne    1477 <lu_decomposition+0x57>\nmov    -0x8(%rsp),%r11\nmov    %r10,%rsi\ncmp    %ecx,%r8d\nje     1548 <lu_decomposition+0x128>\nmovapd %xmm2,%xmm1\ntest   %ecx,%ecx\njle    14f6 <lu_decomposition+0xd6>\nmov    -0x10(%rsp),%rdx\nlea    (%rsi,%r11,1),%rdi\nxor    %eax,%eax\nmovsd  (%rdi,%rax,8),%xmm0\nmulsd  (%rdx),%xmm0\nadd    $0x1,%rax\nadd    $0x28,%rdx\naddsd  %xmm0,%xmm1\ncmp    %eax,%ecx\njg     14dd <lu_decomposition+0xbd>\nmovsd  0x0(%r13,%rsi,1),%xmm0\nsubsd  %xmm1,%xmm0\ndivsd  (%r9,%r10,1),%xmm0\nmovsd  %xmm0,(%rbx,%rsi,1)\nadd    $0x1,%r8d\nadd    $0x28,%rsi\ncmp    $0x5,%r8d\njne    14c5 <lu_decomposition+0xa5>\naddq   $0x8,-0x10(%rsp)\nadd    $0x30,%r10\nadd    $0x28,%r15\nsubq   $0x8,-0x8(%rsp)\ncmp    $0x5,%rbp\njne    1455 <lu_decomposition+0x35>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nmovsd  %xmm3,(%rbx,%r10,1)\njmp    150c <lu_decomposition+0xec>\n"}
{"source": {"path": "lu-decomp/lu-decomp.c", "function_name": "main", "content": "int main() {\n    double A[N][N] = {\n        {  2.0,  -1.0,   0.0,   0.0,   0.0 },\n        { -1.0,   2.0,  -1.0,   0.0,   0.0 },\n        {  0.0,  -1.0,   2.0,  -1.0,   0.0 },\n        {  0.0,   0.0,  -1.0,   2.0,  -1.0 },\n        {  0.0,   0.0,   0.0,  -1.0,   2.0 }\n    }; // A tridiagonal symmetric positive definite matrix\n\n#if 0\n    double A[N][N] = {\n        {2.0, -1.0, -2.0},\n        {-4.0, 6.0, 3.0},\n        {-4.0, -2.0, 8.0}\n    };\n#endif\n    double L[N][N] = {0};\n    double U[N][N] = {0};\n\n    lu_decomposition(A, L, U);\n\n    print_matrix(\"A\", A);\n    print_matrix(\"L\", L);\n    print_matrix(\"U\", U);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "lu-decomp/lu-decomp.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double A[5][5]; // [rsp+0h] [rbp-288h] BYREF\n  double L[5][5]; // [rsp+D0h] [rbp-1B8h] BYREF\n  double U[5][5]; // [rsp+1A0h] [rbp-E8h] BYREF\n  unsigned __int64 v6; // [rsp+268h] [rbp-20h]\n\n  v6 = __readfsqword(0x28u);\n  A[0][0] = 2.0;\n  *(_OWORD *)&A[0][1] = 0xBFF0000000000000LL;\n  A[1][0] = -1.0;\n  A[1][1] = 2.0;\n  *(_OWORD *)&A[1][2] = 0xBFF0000000000000LL;\n  A[2][1] = -1.0;\n  A[2][2] = 2.0;\n  *(_OWORD *)&A[2][3] = 0xBFF0000000000000LL;\n  A[3][2] = -1.0;\n  A[3][3] = 2.0;\n  A[3][4] = -1.0;\n  A[4][3] = -1.0;\n  *(_OWORD *)&A[0][3] = 0uLL;\n  A[1][4] = 0.0;\n  A[2][0] = 0.0;\n  *(_OWORD *)&A[3][0] = 0uLL;\n  memset(A[4], 0, 24);\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double A[5][5];\n  double L[5][5];\n  double U[5][5];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  A[0][0] = 2.0;\n  *(long double *)&A[0][1] = 13830554455654793216LL;\n  A[1][0] = -1.0;\n  A[1][1] = 2.0;\n  *(long double *)&A[1][2] = 13830554455654793216LL;\n  A[2][1] = -1.0;\n  A[2][2] = 2.0;\n  *(long double *)&A[2][3] = 13830554455654793216LL;\n  A[3][2] = -1.0;\n  A[3][3] = 2.0;\n  A[3][4] = -1.0;\n  A[4][3] = -1.0;\n  *(long double *)&A[0][3] = 0uLL;\n  A[1][4] = 0.0;\n  A[2][0] = 0.0;\n  *(long double *)&A[3][0] = 0uLL;\n  memset(A[4], 0, 24);\n  A[4][4] = 2.0;\n  memset(L, 0, sizeof(L));\n  memset(U, 0, sizeof(U));\n  lu_decomposition(A, L, U);\n  print_matrix(\"A\", A);\n  print_matrix(\"L\", L);\n  print_matrix(\"U\", U);\n  libmin_success();\n}", "binary": "lu-decomp/lu-decomp.host.O2", "assembly": "<main>:\nendbr64\npush   %r13\nmov    $0x19,%ecx\npush   %r12\npush   %rbp\nsub    $0x270,%rsp\nmovsd  0x1f0b(%rip),%xmm0\nmovsd  0x1efb(%rip),%xmm1\nmov    %fs:0x28,%rax\nmov    %rax,0x268(%rsp)\nxor    %eax,%eax\nlea    0xd0(%rsp),%rdi\nmov    %rsp,%r13\nlea    0x1a0(%rsp),%rbp\nmovsd  %xmm1,(%rsp)\nlea    0xd0(%rsp),%r12\nmov    %rbp,%rdx\nmovsd  %xmm0,0x8(%rsp)\nmov    %r12,%rsi\nmovsd  %xmm0,0x28(%rsp)\nmovsd  %xmm1,0x30(%rsp)\nmovsd  %xmm0,0x38(%rsp)\nmovsd  %xmm0,0x58(%rsp)\nmovsd  %xmm1,0x60(%rsp)\nmovsd  %xmm0,0x68(%rsp)\nmovsd  %xmm0,0x88(%rsp)\nmovsd  %xmm1,0x90(%rsp)\nmovsd  %xmm0,0x98(%rsp)\nmovsd  %xmm0,0xb8(%rsp)\nmovq   $0x0,0x10(%rsp)\nmovq   $0x0,0x18(%rsp)\nmovq   $0x0,0x20(%rsp)\nmovq   $0x0,0x40(%rsp)\nmovq   $0x0,0x48(%rsp)\nmovq   $0x0,0x50(%rsp)\nmovq   $0x0,0x70(%rsp)\nmovq   $0x0,0x78(%rsp)\nmovq   $0x0,0x80(%rsp)\nmovq   $0x0,0xa0(%rsp)\nmovq   $0x0,0xa8(%rsp)\nmovq   $0x0,0xb0(%rsp)\nmovsd  %xmm1,0xc0(%rsp)\nrep stos %rax,%es:(%rdi)\nlea    0x1a0(%rsp),%rdi\nmov    $0x19,%ecx\nrep stos %rax,%es:(%rdi)\nmov    %r13,%rdi\ncall   1420 <lu_decomposition>\nmov    %r13,%rsi\nlea    0x1dbf(%rip),%rdi\ncall   13a0 <print_matrix>\nmov    %r12,%rsi\nlea    0x1db2(%rip),%rdi\ncall   13a0 <print_matrix>\nmov    %rbp,%rsi\nlea    0x1da5(%rip),%rdi\ncall   13a0 <print_matrix>\ncall   2cd0 <libmin_success>\nmov    0x268(%rsp),%rax\nsub    %fs:0x28,%rax\njne    129c <main+0x19c>\nadd    $0x270,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "lu-decomp/lu-decomp.c", "function_name": "print_matrix", "content": "#include \"libmin.h\"\n\n#define N 5  // Matrix size\n// #define N 3  // Matrix size\n\nvoid print_matrix(const char* name, double mat[N][N]) {\n    libmin_printf(\"%s =\\n\", name);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            libmin_printf(\"%8.4f \", mat[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "lu-decomp/lu-decomp.host.O2.pseudo", "function_name": "print_matrix", "address": "0x13a0", "label": "print_matrix", "content": "void __fastcall print_matrix(const char *name, double (*mat)[5])\n{\n  double *v2; // rbp\n  double *v3; // rbx\n  double v4; // xmm0_8\n\n  v2 = &(*mat)[5];\n  libmin_printf(\"%s =\\n\", name);\n  do\n  {\n    v3 = v2 - 5;\n    do\n    {\n      v4 = *v3++;\n      libmin_printf(\"%8.4f \", v4);\n    }\n    while ( v3 != v2 );\n    v2 = v3 + 5;\n    libmin_printf((char *)\"\\n\");\n  }\n  while ( v3 + 5 != &(*mat)[30] );\n  libmin_printf((char *)\"\\n\");\n}\n"}, "pseudo_normalize": "void print_matrix(const char *name, double (*mat)[5]) {\n  double *v2;\n  double *v3;\n  double v4;\n  v2 = &(*mat)[5];\n  libmin_printf(\"%s =\\n\", name);\n  do {\n    v3 = v2 - 5;\n    do {\n      v4 = *v3++;\n      libmin_printf(\"%8.4f \", v4);\n    } while (v3 != v2);\n    v2 = v3 + 5;\n    libmin_printf((char *)\"\\n\");\n  } while (v3 + 5 != &(*mat)[30]);\n  libmin_printf((char *)\"\\n\");\n}", "binary": "lu-decomp/lu-decomp.host.O2", "assembly": "<print_matrix>:\nendbr64\npush   %r14\nxor    %eax,%eax\nlea    0x1c59(%rip),%r14\npush   %r13\nmov    %rsi,%r13\nmov    %rdi,%rsi\nlea    0x1c46(%rip),%rdi\npush   %r12\nlea    0x1c43(%rip),%r12\npush   %rbp\nlea    0x28(%r13),%rbp\nadd    $0xf0,%r13\npush   %rbx\ncall   2a90 <libmin_printf>\nlea    -0x28(%rbp),%rbx\nmovsd  (%rbx),%xmm0\nmov    %r12,%rdi\nmov    $0x1,%eax\nadd    $0x8,%rbx\ncall   2a90 <libmin_printf>\ncmp    %rbp,%rbx\njne    13dd <print_matrix+0x3d>\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    0x28(%rbx),%rbp\ncall   2a90 <libmin_printf>\ncmp    %r13,%rbp\njne    13d9 <print_matrix+0x39>\npop    %rbx\nmov    %r14,%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %r14\njmp    2a90 <libmin_printf>\nnopl   0x0(%rax)\n"}
{"source": {"path": "lz-compress/lz-compress.c", "function_name": "lz77_decompress", "content": "uint32_t lz77_decompress (uint8_t *compressed_text, uint8_t *uncompressed_text)\n{\n    uint8_t pointer_length_width;\n    uint16_t input_pointer, pointer_length, pointer_pos, pointer_length_mask;\n    uint32_t compressed_pointer, coding_pos, pointer_offset, uncompressed_size;\n\n    uncompressed_size = *((uint32_t *) compressed_text);\n    pointer_length_width = *(compressed_text + 4);\n    compressed_pointer = 5;\n\n    pointer_length_mask = (1 << pointer_length_width)- 1;\n\n\n    for(coding_pos = 0; coding_pos < uncompressed_size; ++coding_pos)\n    {\n        input_pointer = *((uint16_t *) (compressed_text + compressed_pointer));\n        compressed_pointer += 2;\n        pointer_pos = input_pointer >> pointer_length_width;\n        pointer_length = pointer_pos ? ((input_pointer & pointer_length_mask) + 1) : 0;\n        if(pointer_pos)\n            for(pointer_offset = coding_pos - pointer_pos; pointer_length > 0; --pointer_length)\n                uncompressed_text[coding_pos++] = uncompressed_text[pointer_offset++];\n        *(uncompressed_text + coding_pos) = *(compressed_text + compressed_pointer++);\n    }\n\n    return coding_pos;\n}\n"}, "pseudo": {"path": "lz-compress/lz-compress.host.O2.pseudo", "function_name": "lz77_decompress", "address": "0x1560", "label": "lz77_decompress", "content": "uint32_t __fastcall lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text)\n{\n  uint8_t v2; // cl\n  uint32_t v3; // r13d\n  uint32_t v6; // r9d\n  int v7; // r11d\n  int v8; // edi\n  unsigned __int16 v9; // r10\n  uint32_t v10; // eax\n  int v11; // ebp\n  __int64 v12; // rsi\n  __int64 v13; // rdx\n  uint8_t v14; // dl\n  __int64 v15; // rax\n\n  v2 = compressed_text[4];\n  v3 = *(_DWORD *)compressed_text;\n  if ( !*(_DWORD *)compressed_text )\n    return 0;\n  v6 = 0;\n  v7 = 5;\n  do\n  {\n    v8 = (int)*(unsigned __int16 *)&compressed_text[v7] >> v2;\n    if ( v8 )\n    {\n      v9 = ((1 << v2) - 1) & *(_WORD *)&compressed_text[v7];\n      v10 = v6 - v8;\n      if ( v9 != 0xFFFF )\n      {\n        v11 = v10 + v9 + 1;\n        do\n        {\n          v12 = v10;\n          v13 = v8 + v10++;\n          uncompressed_text[v13] = uncompressed_text[v12];\n        }\n        while ( v10 != v11 );\n        v6 += v9 + 1;\n      }\n    }\n    v14 = compressed_text[v7 + 2];\n    v15 = v6++;\n    v7 += 3;\n    uncompressed_text[v15] = v14;\n  }\n  while ( v3 > v6 );\n  return v6;\n}\n"}, "pseudo_normalize": "uint32_t lz77_decompress(uint8_t *compressed_text, uint8_t *uncompressed_text) {\n  uint8_t v2;\n  uint32_t v3;\n  uint32_t v6;\n  int v7;\n  int v8;\n  unsigned short v9;\n  uint32_t v10;\n  int v11;\n  long long v12;\n  long long v13;\n  uint8_t v14;\n  long long v15;\n  v2 = compressed_text[4];\n  v3 = *(uint32_t *)compressed_text;\n  if (!*(uint32_t *)compressed_text) return 0;\n  v6 = 0;\n  v7 = 5;\n  do {\n    v8 = (int)*(unsigned short *)&compressed_text[v7] >> v2;\n    if (v8) {\n      v9 = ((1 << v2) - 1) & *(unsigned short *)&compressed_text[v7];\n      v10 = v6 - v8;\n      if (v9 != 65535) {\n        v11 = v10 + v9 + 1;\n        do {\n          v12 = v10;\n          v13 = v8 + v10++;\n          uncompressed_text[v13] = uncompressed_text[v12];\n        } while (v10 != v11);\n        v6 += v9 + 1;\n      }\n    }\n    v14 = compressed_text[v7 + 2];\n    v15 = v6++;\n    v7 += 3;\n    uncompressed_text[v15] = v14;\n  } while (v3 > v6);\n  return v6;\n}", "binary": "lz-compress/lz-compress.host.O2", "assembly": "<lz77_decompress>:\nendbr64\npush   %r14\nmov    $0x1,%r14d\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmovzbl 0x4(%rdi),%ecx\nmov    (%rdi),%r13d\nshl    %cl,%r14d\nsub    $0x1,%r14d\ntest   %r13d,%r13d\nje     160f <lz77_decompress+0xaf>\nmov    %rdi,%r12\nmov    %rsi,%r8\nxor    %r9d,%r9d\nmov    $0x5,%r11d\nnopl   0x0(%rax,%rax,1)\nmov    %r11d,%eax\nlea    0x2(%r11),%ebx\nmovzwl (%r12,%rax,1),%edi\nmov    %edi,%r10d\nsar    %cl,%edi\ntest   %edi,%edi\nje     15ea <lz77_decompress+0x8a>\nmov    %r9d,%eax\nand    %r14d,%r10d\nsub    %edi,%eax\ncmp    $0xffff,%r10w\nje     15ea <lz77_decompress+0x8a>\nmovzwl %r10w,%r10d\nlea    0x1(%rax,%r10,1),%ebp\nnopl   (%rax)\nmov    %eax,%esi\nlea    (%rdi,%rax,1),%edx\nadd    $0x1,%eax\nmovzbl (%r8,%rsi,1),%esi\nmov    %sil,(%r8,%rdx,1)\ncmp    %ebp,%eax\njne    15d0 <lz77_decompress+0x70>\nlea    0x1(%r10,%r9,1),%r9d\nmovzbl (%r12,%rbx,1),%edx\nmov    %r9d,%eax\nadd    $0x1,%r9d\nadd    $0x3,%r11d\nmov    %dl,(%r8,%rax,1)\ncmp    %r9d,%r13d\nja     15a0 <lz77_decompress+0x40>\npop    %rbx\nmov    %r9d,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nxor    %r9d,%r9d\npop    %rbx\npop    %rbp\nmov    %r9d,%eax\npop    %r12\npop    %r13\npop    %r14\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "lz-compress/lz-compress.c", "function_name": "main", "content": "int main (int argc, char const *argv[])\n{\n    uint32_t compressed_size, uncompressed_size, orig_size;\n    uint8_t *compressed_text, *uncompressed_text;\n\n    libmin_mopen(infile, \"r\");\n    uncompressed_size = libmin_msize(infile);\n    libmin_printf(\"Original size: %ld\\n\", uncompressed_size);\n    uncompressed_text = libmin_malloc(uncompressed_size);\n    if((uncompressed_size != libmin_mread(uncompressed_text, uncompressed_size, infile)))\n        return 0;\n    libmin_mclose(infile);\n\n    compressed_text = libmin_malloc(MALLOC_SIZE);\n\n    for (unsigned i = 1; i < 16; ++i)\n    {\n      compressed_size = lz77_compress(uncompressed_text, uncompressed_size, compressed_text, i);\n      libmin_assert(compressed_size < MALLOC_SIZE);\n\n      orig_size = lz77_decompress(compressed_text, uncompressed_text);\n      libmin_assert(orig_size == uncompressed_size);\n\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", i, compressed_size, uncompressed_size);\n    }\n\n    // output the final decompressed data\n    for (unsigned cnt=0; cnt < uncompressed_size; cnt++)\n      libmin_putc(uncompressed_text[cnt]);\n\n    libmin_success();\n}\n"}, "pseudo": {"path": "lz-compress/lz-compress.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  char *v3; // rbx\n  int v5; // ebp\n  uint8_t *v6; // r13\n  int v7; // esi\n  uint32_t v8; // r14d\n  __int64 v9; // rbp\n  char v10; // di\n  uint32_t v11; // [rsp+8h] [rbp-40h]\n\n  libmin_mopen(infile, \"r\");\n  v11 = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", v11);\n  v3 = (char *)libmin_malloc(v11);\n  if ( libmin_mread(v3, v11, infile) == v11 )\n  {\n    v5 = 1;\n    libmin_mclose(infile);\n    v6 = (uint8_t *)libmin_malloc(0x40000uLL);\n    while ( 1 )\n    {\n      v8 = lz77_compress((uint8_t *)v3, v11, v6, v5);\n      if ( v8 > 0x3FFFF )\n        break;\n      if ( v11 != lz77_decompress(v6, (uint8_t *)v3) )\n        libmin_fail(1);\n      v7 = v5++;\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", v7, v8, v11);\n      if ( v5 == 16 )\n      {\n        if ( v11 )\n        {\n          v9 = (__int64)&v3[v11];\n          do\n          {\n            v10 = *v3++;\n            libmin_putc(v10);\n          }\n          while ( v3 != (char *)v9 );\n        }\n        libmin_success();\n      }\n    }\n    libmin_fail(1);\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  char *v3;\n  int v5;\n  uint8_t *v6;\n  int v7;\n  uint32_t v8;\n  long long v9;\n  char v10;\n  uint32_t v11;\n  libmin_mopen(infile, \"r\");\n  v11 = libmin_msize(infile);\n  libmin_printf(\"Original size: %ld\\n\", v11);\n  v3 = (char *)libmin_malloc(v11);\n  if (libmin_mread(v3, v11, infile) == v11) {\n    v5 = 1;\n    libmin_mclose(infile);\n    v6 = (uint8_t *)libmin_malloc(262144uLL);\n    while (1) {\n      v8 = lz77_compress((uint8_t *)v3, v11, v6, v5);\n      if (v8 > 262143) break;\n      if (v11 != lz77_decompress(v6, (uint8_t *)v3)) libmin_fail(1);\n      v7 = v5++;\n      libmin_printf(\"Compressed (%i): %u, decompressed: (%u)\\n\", v7, v8, v11);\n      if (v5 == 16) {\n        if (v11) {\n          v9 = (long long)&v3[v11];\n          do {\n            v10 = *v3++;\n            libmin_putc(v10);\n          } while (v3 != (char *)v9);\n        }\n        libmin_success();\n      }\n    }\n    libmin_fail(1);\n  }\n  return 0;\n}", "binary": "lz-compress/lz-compress.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nlea    0x2ed7(%rip),%rsi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    0x12ee0(%rip),%rdi\ncall   1b00 <libmin_mopen>\nmov    0x12ed4(%rip),%rdi\ncall   1be0 <libmin_msize>\nlea    0x2eae(%rip),%rdi\nmov    %rax,%rbx\nmov    %eax,%esi\nmov    %rax,0x8(%rsp)\nmov    %eax,%r12d\nmov    %ebx,%ebp\nxor    %eax,%eax\ncall   2f50 <libmin_printf>\nmov    %rbp,%rdi\ncall   18b0 <libmin_malloc>\nmov    0x12ea3(%rip),%rdx\nmov    %rbp,%rsi\nmov    %rax,%rdi\nmov    %rax,%rbx\ncall   1b50 <libmin_mread>\ncmp    %rbp,%rax\nje     11a1 <main+0x81>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    0x12e78(%rip),%rdi\nmov    $0x1,%ebp\nlea    0x2e74(%rip),%r15\ncall   1a50 <libmin_mclose>\nmov    $0x40000,%edi\ncall   18b0 <libmin_malloc>\nmov    %rax,%r13\njmp    1204 <main+0xe4>\nnopl   0x0(%rax,%rax,1)\nmov    %rbx,%rsi\nmov    %r13,%rdi\ncall   1560 <lz77_decompress>\ncmp    %eax,%r12d\nje     11ea <main+0xca>\nmov    $0x1,%edi\ncall   1800 <libmin_fail>\nmov    %ebp,%esi\nmov    %r12d,%ecx\nmov    %r14d,%edx\nmov    %r15,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebp\ncall   2f50 <libmin_printf>\ncmp    $0x10,%ebp\nje     122a <main+0x10a>\nmov    %ebp,%ecx\nmov    %r13,%rdx\nmov    %r12d,%esi\nmov    %rbx,%rdi\ncall   1350 <lz77_compress>\nmov    %eax,%r14d\ncmp    $0x3ffff,%eax\njbe    11d0 <main+0xb0>\nmov    $0x1,%edi\ncall   1800 <libmin_fail>\njmp    11d0 <main+0xb0>\nmov    0x8(%rsp),%rax\ntest   %eax,%eax\nje     1251 <main+0x131>\nsub    $0x1,%eax\nlea    0x1(%rbx,%rax,1),%rbp\nnopl   0x0(%rax,%rax,1)\nmovsbl (%rbx),%edi\nadd    $0x1,%rbx\ncall   3160 <libmin_putc>\ncmp    %rbp,%rbx\njne    1240 <main+0x120>\ncall   3200 <libmin_success>\njmp    1190 <main+0x70>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "mandelbrot/mandelbrot.c", "function_name": "color", "content": "/**  mandel.c   by Eric R. Weeks   written 9-28-96\n **  weeks@dept.physics.upenn.edu\n **  http://dept.physics.upenn.edu/~weeks/\n **  \n **  This program is public domain, but this header must be left intact\n **  and unchanged.\n **  \n **  to compile:  cc -o mand mandel.c\n ** \n **/\n\n#include \"libmin.h\"\n\nvoid\ncolor(int red, int green, int blue)\n{\n  libmin_printf(\"<%d,%d,%d>\\n\", red, green, blue);\n}\n"}, "pseudo": {"path": "mandelbrot/mandelbrot.host.O2.pseudo", "function_name": "color", "address": "0x13b0", "label": "color", "content": "void __fastcall color(int red, int green, int blue)\n{\n  libmin_printf(\"<%d,%d,%d>\\n\", red, green, blue);\n}\n"}, "pseudo_normalize": "", "binary": "mandelbrot/mandelbrot.host.O2", "assembly": "<color>:\nendbr64\nmov    %edx,%ecx\nxor    %eax,%eax\nmov    %esi,%edx\nmov    %edi,%esi\nlea    0x1c41(%rip),%rdi\njmp    2910 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "mandelbrot/mandelbrot.c", "function_name": "main", "content": "int\nmain(void)\n{\n  double x, xx, y, cx, cy;\n  int iteration, hx, hy;\n  int itermax = 100;\t\t/* how many iterations to do\t*/\n  double magnify = 1.0;\t\t/* no magnification\t\t*/\n  int hxres = 78;\t\t/* horizonal resolution\t\t*/\n  int hyres = 48;\t\t/* vertical resolution\t\t*/\n\n  /* header for PPM output */\n  libmin_printf(\"** Mandelbrot ASCII image\\n\");\n  libmin_printf(\"** xres: %d, yres: %d\\n\", hxres, hyres);\n\n  for (hy=1; hy <= hyres; hy++)\n    {\n      for (hx=1; hx <= hxres; hx++)\n\t{\n\t  cx = (((float)hx)/((float)hxres)-0.5)/magnify*3.0-0.7;\n\t  cy = (((float)hy)/((float)hyres)-0.5)/magnify*3.0;\n\t  x = 0.0; y = 0.0;\n\n\t  for (iteration=1; iteration < itermax; iteration++)\n\t    {\n\t      xx = x*x-y*y+cx;\n\t      y = 2.0*x*y+cy;\n\t      x = xx;\n\t      if (x*x+y*y > 100.0)\n\t\titeration = 999999;\n\t    }\n\t  if (iteration < 99999)\n\t    libmin_printf(\" \");\n\t  else\n\t    libmin_printf(\"0\");\n\t}\n      libmin_printf(\"\\n\");\n    }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "mandelbrot/mandelbrot.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r12d\n  __int128 v4; // xmm7\n  int v5; // r14d\n  double v6; // xmm5_8\n  int v7; // eax\n  double v8; // xmm2_8\n  __int128 v9; // xmm1\n  double v10; // xmm3_8\n  __int128 v11; // xmm0\n  double v12; // [rsp+8h] [rbp-30h]\n  double v13; // [rsp+8h] [rbp-30h]\n\n  v3 = 1;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  v4 = 0LL;\nLABEL_2:\n  v5 = 1;\n  v6 = ((float)((float)v3 / 48.0) - 0.5) * 3.0;\n  while ( 1 )\n  {\nLABEL_4:\n    v7 = 1;\n    v8 = *(double *)&v4;\n    v9 = v4;\n    v10 = *(double *)&v4;\n    while ( 1 )\n    {\n      *((_QWORD *)&v11 + 1) = *((_QWORD *)&v9 + 1);\n      v8 = v8 * (*(double *)&v9 + *(double *)&v9) + v6;\n      *(double *)&v11 = *(double *)&v9 * *(double *)&v9 - v10 + ((float)((float)v5 / 78.0) - 0.5) * 3.0 - 0.7;\n      v10 = v8 * v8;\n      if ( *(double *)&v11 * *(double *)&v11 + v8 * v8 > 100.0 )\n        break;\n      if ( ++v7 == 100 )\n      {\n        v13 = v6;\n        ++v5;\n        libmin_printf(\" \");\n        v6 = v13;\n        v4 = 0LL;\n        if ( v5 == 79 )\n          goto LABEL_9;\n        goto LABEL_4;\n      }\n      v9 = v11;\n    }\n    v12 = v6;\n    ++v5;\n    libmin_printf(\"0\");\n    v6 = v12;\n    v4 = 0LL;\n    if ( v5 == 79 )\n    {\nLABEL_9:\n      ++v3;\n      libmin_printf((char *)\"\\n\");\n      v4 = 0LL;\n      if ( v3 == 49 )\n        libmin_success();\n      goto LABEL_2;\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  __int128 v4;\n  int v5;\n  double v6;\n  int v7;\n  double v8;\n  __int128 v9;\n  double v10;\n  __int128 v11;\n  double v12;\n  double v13;\n  v3 = 1;\n  libmin_printf(\"** Mandelbrot ASCII image\\n\", argv, envp);\n  libmin_printf(\"** xres: %d, yres: %d\\n\", 78, 48);\n  v4 = 0LL;\nLABEL_2:\n  v5 = 1;\n  v6 = ((float)((float)v3 / 48.0) - 0.5) * 3.0;\n  while (1) {\n  LABEL_4:\n    v7 = 1;\n    v8 = *(double *)&v4;\n    v9 = v4;\n    v10 = *(double *)&v4;\n    while (1) {\n      *((uint64_t *)&v11 + 1) = *((uint64_t *)&v9 + 1);\n      v8 = v8 * (*(double *)&v9 + *(double *)&v9) + v6;\n      *(double *)&v11 = *(double *)&v9 * *(double *)&v9 - v10 +\n                        ((float)((float)v5 / 78.0) - 0.5) * 3.0 - 0.7;\n      v10 = v8 * v8;\n      if (*(double *)&v11 * *(double *)&v11 + v8 * v8 > 100.0) break;\n      if (++v7 == 100) {\n        v13 = v6;\n        ++v5;\n        libmin_printf(\" \");\n        v6 = v13;\n        v4 = 0LL;\n        if (v5 == 79) goto LABEL_9;\n        goto LABEL_4;\n      }\n      v9 = v11;\n    }\n    v12 = v6;\n    ++v5;\n    libmin_printf(\"0\");\n    v6 = v12;\n    v4 = 0LL;\n    if (v5 == 79) {\n    LABEL_9:\n      ++v3;\n      libmin_printf((char *)\"\\n\");\n      v4 = 0LL;\n      if (v3 == 49) libmin_success();\n      goto LABEL_2;\n    }\n  }\n}", "binary": "mandelbrot/mandelbrot.host.O2", "assembly": "<main>:\nendbr64\npush   %r14\nlea    0x1f03(%rip),%rdi\nxor    %eax,%eax\npush   %r13\nlea    0x1ef6(%rip),%r13\npush   %r12\nmov    $0x1,%r12d\npush   %rbp\npush   %rbx\nlea    0x1f1b(%rip),%rbx\nsub    $0x10,%rsp\ncall   2910 <libmin_printf>\nmov    $0x30,%edx\nmov    $0x4e,%esi\nxor    %eax,%eax\nlea    0x1ee6(%rip),%rdi\ncall   2910 <libmin_printf>\nmovsd  0x1f16(%rip),%xmm6\npxor   %xmm7,%xmm7\npxor   %xmm5,%xmm5\nmov    $0x1,%r14d\nlea    0x1edb(%rip),%rbp\ncvtsi2ss %r12d,%xmm5\ndivss  0x1ed8(%rip),%xmm5\ncvtss2sd %xmm5,%xmm5\nsubsd  0x1ed0(%rip),%xmm5\nmulsd  0x1ed0(%rip),%xmm5\njmp    11c4 <main+0xc4>\nnopw   0x0(%rax,%rax,1)\nmov    %rbx,%rdi\nxor    %eax,%eax\nmovsd  %xmm5,0x8(%rsp)\nadd    $0x1,%r14d\ncall   2910 <libmin_printf>\nmov    0x1ebd(%rip),%rax\nmovsd  0x8(%rsp),%xmm5\npxor   %xmm7,%xmm7\nmovq   %rax,%xmm6\ncmp    $0x4f,%r14d\nje     1284 <main+0x184>\npxor   %xmm4,%xmm4\nmov    $0x1,%eax\nmovapd %xmm7,%xmm2\ncvtsi2ss %r14d,%xmm4\nmovapd %xmm7,%xmm1\nmovapd %xmm7,%xmm3\ndivss  0x1e62(%rip),%xmm4\ncvtss2sd %xmm4,%xmm4\nsubsd  0x1e5e(%rip),%xmm4\nmulsd  0x1e5e(%rip),%xmm4\nsubsd  0x1e5e(%rip),%xmm4\nmovapd %xmm1,%xmm0\nmulsd  %xmm1,%xmm0\naddsd  %xmm1,%xmm1\nmulsd  %xmm1,%xmm2\nsubsd  %xmm3,%xmm0\naddsd  %xmm5,%xmm2\naddsd  %xmm4,%xmm0\nmovapd %xmm2,%xmm3\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmulsd  %xmm2,%xmm3\naddsd  %xmm3,%xmm1\ncomisd %xmm6,%xmm1\nja     1190 <main+0x90>\nadd    $0x1,%eax\ncmp    $0x64,%eax\nje     1250 <main+0x150>\nmovapd %xmm0,%xmm1\njmp    1202 <main+0x102>\nnopw   0x0(%rax,%rax,1)\nmov    %rbp,%rdi\nxor    %eax,%eax\nmovsd  %xmm5,0x8(%rsp)\nadd    $0x1,%r14d\ncall   2910 <libmin_printf>\nmov    0x1dfd(%rip),%rax\nmovsd  0x8(%rsp),%xmm5\npxor   %xmm7,%xmm7\nmovq   %rax,%xmm6\ncmp    $0x4f,%r14d\njne    11c4 <main+0xc4>\nxor    %eax,%eax\nmov    %r13,%rdi\nadd    $0x1,%r12d\ncall   2910 <libmin_printf>\nmov    0x1dcf(%rip),%rax\ncmp    $0x31,%r12d\npxor   %xmm7,%xmm7\nmovq   %rax,%xmm6\njne    1156 <main+0x56>\ncall   2b50 <libmin_success>\nadd    $0x10,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\n"}
{"source": {"path": "matmult/matmult.c", "function_name": "main", "content": "   // Reference result using an alternative loop order (order: i, k, j)\n\nint main() {\n    // Initialize random seed\n    libmin_srand(12345);\n\n    // Initialize matrices A and B with random data; zero out C and refC\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            // Use modulo to restrict the range of random numbers (0..99)\n            A[i][j] = libmin_rand() % 1000;\n            B[i][j] = libmin_rand() % 1000;\n            C[i][j] = 0;\n            refC[i][j] = 0;\n        }\n    }\n\n    // --- First Multiplication: Loop order (i, j, k) ---\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    // --- Second Multiplication (Reference): Loop order (i, k, j) ---\n    for (int i = 0; i < N; i++) {\n        for (int k = 0; k < N; k++) {\n            for (int j = 0; j < N; j++) {\n                refC[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n\n    // --- Verification: Compare C and refC ---\n    int error = 0;\n    for (int i = 0; i < N && !error; i++) {\n        for (int j = 0; j < N && !error; j++) {\n            if (C[i][j] != refC[i][j]) {\n                libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", \n                                i, j, C[i][j], refC[i][j]);\n                error = 1;\n            }\n        }\n    }\n\n    // --- Final Reporting ---\n    if (error) {\n        // If an error is detected, print a failure message.\n        libtarg_fail(1);\n    } else {\n        // Compute a checksum of the result matrix for quick verification.\n        int checksum = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                checksum = (checksum + C[i][j]) % 100000;\n            }\n        }\n        libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", checksum);\n        \n        // Print the computed result matrix.\n        libmin_printf(\"Result Matrix C:\\n\");\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                libmin_printf(\"%d \", C[i][j]);\n            }\n            libmin_printf(\"\\n\");\n        }\n        \n        libtarg_success();\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "matmult/matmult.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // r14\n  int *v4; // r13\n  int *v5; // r12\n  int *v6; // rbp\n  __int64 *v7; // rbx\n  __int64 i; // r15\n  unsigned int v9; // eax\n  __int64 j; // rbx\n  int *v11; // rdi\n  int *v12; // r9\n  int v13; // esi\n  int *v14; // rcx\n  int *v15; // rax\n  int v16; // edx\n  int *v17; // rdi\n  int *v18; // r9\n  int *v19; // r10\n  int v20; // esi\n  int *v21; // rax\n  int *v22; // rdx\n  int v23; // ecx\n  int *v24; // rcx\n  __int64 k; // rdx\n  __int64 m; // rax\n  int v27; // r9d\n  int v28; // r8d\n  int v29; // eax\n  int *v30; // rbx\n  int v31; // esi\n  int *v32; // rbp\n  int *v33; // rdi\n  int *v34; // rax\n  int v35; // esi\n  int *v36; // r12\n  int v37; // esi\n\n  v3 = A[0];\n  v4 = refC[0];\n  v5 = C[0];\n  v6 = B[0];\n  v7 = (__int64 *)A[0];\n  libmin_srand(0x3039u);\n  do\n  {\n    for ( i = 0LL; i != 64; ++i )\n    {\n      *(_DWORD *)((char *)v7 + i * 4) = libmin_rand() % 0x3E8;\n      v9 = libmin_rand();\n      v5[i] = 0;\n      v4[i] = 0;\n      v6[i] = v9 % 0x3E8;\n    }\n    v7 += 32;\n    v6 += 64;\n    v5 += 64;\n    v4 += 64;\n  }\n  while ( v7 != &_start_time );\n  for ( j = 0LL; j != 64; ++j )\n  {\n    v11 = B[64];\n    v12 = C[j];\n    do\n    {\n      v13 = *v12;\n      v14 = A[j];\n      v15 = v11 - 4096;\n      do\n      {\n        v16 = *v15 * *v14;\n        v15 += 64;\n        ++v14;\n        v13 += v16;\n      }\n      while ( v15 != v11 );\n      v11 = v15 + 1;\n      *v12++ = v13;\n    }\n    while ( v15 + 1 != B[65] );\n  }\n  v17 = refC[1];\n  do\n  {\n    v18 = B[0];\n    v19 = v3;\n    do\n    {\n      v20 = *v19;\n      v21 = v17 - 64;\n      v22 = v18;\n      do\n      {\n        v23 = *v22++;\n        *v21++ += v20 * v23;\n      }\n      while ( v21 != v17 );\n      v18 += 64;\n      ++v19;\n    }\n    while ( v18 != B[64] );\n    v17 = v21 + 64;\n    v3 += 64;\n  }\n  while ( v21 + 64 != refC[65] );\n  v24 = C[0];\n  for ( k = 0LL; ; ++k )\n  {\n    for ( m = 0LL; m != 64; ++m )\n    {\n      v27 = v24[m];\n      v28 = refC[k][m];\n      if ( v27 != v28 )\n      {\n        libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", k, m, v27, v28);\n        libtarg_fail(1);\n      }\n    }\n    v29 = k;\n    v24 += 64;\n    if ( v29 > 62 )\n    {\n      v30 = C[1];\n      v31 = 0;\n      v32 = C[65];\n      v33 = C[1];\n      do\n      {\n        v34 = v33 - 64;\n        do\n        {\n          v35 = *v34++ + v31;\n          v31 = v35 % 100000;\n        }\n        while ( v34 != v33 );\n        v33 = v34 + 64;\n      }\n      while ( v34 + 64 != v32 );\n      libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", v31);\n      libmin_printf(\"Result Matrix C:\\n\");\n      while ( 1 )\n      {\n        v36 = v30 - 64;\n        do\n        {\n          v37 = *v36++;\n          libmin_printf(\"%d \", v37);\n        }\n        while ( v30 != v36 );\n        v30 += 64;\n        libmin_printf((char *)\"\\n\");\n        if ( v30 == v32 )\n          libtarg_success();\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  int *v4;\n  int *v5;\n  int *v6;\n  long long *v7;\n  long long i;\n  unsigned int v9;\n  long long j;\n  int *v11;\n  int *v12;\n  int v13;\n  int *v14;\n  int *v15;\n  int v16;\n  int *v17;\n  int *v18;\n  int *v19;\n  int v20;\n  int *v21;\n  int *v22;\n  int v23;\n  int *v24;\n  long long k;\n  long long m;\n  int v27;\n  int v28;\n  int v29;\n  int *v30;\n  int v31;\n  int *v32;\n  int *v33;\n  int *v34;\n  int v35;\n  int *v36;\n  int v37;\n  v3 = A[0];\n  v4 = refC[0];\n  v5 = C[0];\n  v6 = B[0];\n  v7 = (long long *)A[0];\n  libmin_srand(12345u);\n  do {\n    for (i = 0LL; i != 64; ++i) {\n      *(uint32_t *)((char *)v7 + i * 4) = libmin_rand() % 1000;\n      v9 = libmin_rand();\n      v5[i] = 0;\n      v4[i] = 0;\n      v6[i] = v9 % 1000;\n    }\n    v7 += 32;\n    v6 += 64;\n    v5 += 64;\n    v4 += 64;\n  } while (v7 != &_start_time);\n  for (j = 0LL; j != 64; ++j) {\n    v11 = B[64];\n    v12 = C[j];\n    do {\n      v13 = *v12;\n      v14 = A[j];\n      v15 = v11 - 4096;\n      do {\n        v16 = *v15 * *v14;\n        v15 += 64;\n        ++v14;\n        v13 += v16;\n      } while (v15 != v11);\n      v11 = v15 + 1;\n      *v12++ = v13;\n    } while (v15 + 1 != B[65]);\n  }\n  v17 = refC[1];\n  do {\n    v18 = B[0];\n    v19 = v3;\n    do {\n      v20 = *v19;\n      v21 = v17 - 64;\n      v22 = v18;\n      do {\n        v23 = *v22++;\n        *v21++ += v20 * v23;\n      } while (v21 != v17);\n      v18 += 64;\n      ++v19;\n    } while (v18 != B[64]);\n    v17 = v21 + 64;\n    v3 += 64;\n  } while (v21 + 64 != refC[65]);\n  v24 = C[0];\n  for (k = 0LL;; ++k) {\n    for (m = 0LL; m != 64; ++m) {\n      v27 = v24[m];\n      v28 = refC[k][m];\n      if (v27 != v28) {\n        libmin_printf(\"Mismatch at (%d, %d): computed %d, expected %d\\n\", k, m,\n                      v27, v28);\n        libtarg_fail(1);\n      }\n    }\n    v29 = k;\n    v24 += 64;\n    if (v29 > 62) {\n      v30 = C[1];\n      v31 = 0;\n      v32 = C[65];\n      v33 = C[1];\n      do {\n        v34 = v33 - 64;\n        do {\n          v35 = *v34++ + v31;\n          v31 = v35 % 100000;\n        } while (v34 != v33);\n        v33 = v34 + 64;\n      } while (v34 + 64 != v32);\n      libmin_printf(\"Matrix multiplication successful. Checksum: %d\\n\", v31);\n      libmin_printf(\"Result Matrix C:\\n\");\n      while (1) {\n        v36 = v30 - 64;\n        do {\n          v37 = *v36++;\n          libmin_printf(\"%d \", v37);\n        } while (v30 != v36);\n        v30 += 64;\n        libmin_printf((char *)\"\\n\");\n        if (v30 == v32) libtarg_success();\n      }\n    }\n  }\n}", "binary": "matmult/matmult.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x3039,%edi\npush   %r14\nlea    0x1016c(%rip),%r14\npush   %r13\nlea    0x4163(%rip),%r13\npush   %r12\nlea    0x815a(%rip),%r12\npush   %rbp\nlea    0xc152(%rip),%rbp\npush   %rbx\nmov    %r14,%rbx\nsub    $0x8,%rsp\ncall   2c10 <libmin_srand>\nxor    %r15d,%r15d\nxchg   %ax,%ax\ncall   2c70 <libmin_rand>\nmov    %eax,%edx\nimul   $0x10624dd3,%rdx,%rdx\nshr    $0x26,%rdx\nimul   $0x3e8,%edx,%edx\nsub    %edx,%eax\nmov    %eax,(%rbx,%r15,1)\ncall   2c70 <libmin_rand>\nmovl   $0x0,(%r12,%r15,1)\nmovl   $0x0,0x0(%r13,%r15,1)\nmov    %eax,%edx\nimul   $0x10624dd3,%rdx,%rdx\nshr    $0x26,%rdx\nimul   $0x3e8,%edx,%edx\nsub    %edx,%eax\nmov    %eax,0x0(%rbp,%r15,1)\nadd    $0x4,%r15\ncmp    $0x100,%r15\njne    1140 <main+0x40>\nadd    $0x100,%rbx\nlea    0x140d7(%rip),%rax\nadd    $0x100,%rbp\nadd    $0x100,%r12\nadd    $0x100,%r13\ncmp    %rax,%rbx\njne    113b <main+0x3b>\nlea    0xc0b2(%rip),%rax\nxor    %ebx,%ebx\nlea    0x4000(%rax),%r8\nlea    0x4100(%rax),%r10\nlea    0x809b(%rip),%rax\nmov    %r8,%rdi\nlea    (%rbx,%r14,1),%r11\nlea    (%rbx,%rax,1),%r9\nmov    (%r9),%esi\nmov    %r11,%rcx\nlea    -0x4000(%rdi),%rax\nnopl   (%rax)\nmov    (%rcx),%edx\nimul   (%rax),%edx\nadd    $0x100,%rax\nadd    $0x4,%rcx\nadd    %edx,%esi\ncmp    %rdi,%rax\njne    1200 <main+0x100>\nlea    0x4(%rax),%rdi\nmov    %esi,(%r9)\nadd    $0x4,%r9\ncmp    %r10,%rdi\njne    11f0 <main+0xf0>\nadd    $0x100,%rbx\ncmp    $0x4000,%rbx\njne    11de <main+0xde>\nlea    0x4143(%rip),%rdi\nlea    0x4000(%rdi),%rbx\nlea    0xc035(%rip),%r9\nmov    %r14,%r10\nlea    -0x100(%rdi),%r11\nnopl   (%rax)\nmov    (%r10),%esi\nmov    %r11,%rax\nmov    %r9,%rdx\nnopl   0x0(%rax)\nmov    (%rdx),%ecx\nadd    $0x4,%rdx\nimul   %esi,%ecx\nadd    %ecx,(%rax)\nadd    $0x4,%rax\ncmp    %rdi,%rax\njne    1268 <main+0x168>\nadd    $0x100,%r9\nadd    $0x4,%r10\ncmp    %r8,%r9\njne    1258 <main+0x158>\nlea    0x100(%rax),%rdi\nadd    $0x100,%r14\ncmp    %rbx,%rdi\njne    1244 <main+0x144>\nlea    0x7fda(%rip),%rcx\nxor    %edx,%edx\nmov    %rdx,%rsi\nlea    0x3fce(%rip),%rax\nmov    %edx,%r10d\nshl    $0x8,%rsi\nadd    %rax,%rsi\nxor    %eax,%eax\nmov    (%rcx,%rax,4),%r9d\nmov    (%rsi,%rax,4),%r8d\ncmp    %r8d,%r9d\nje     12eb <main+0x1eb>\nmov    %eax,%edx\nlea    0x1d34(%rip),%rdi\nmov    %r9d,%ecx\nmov    %r10d,%esi\nxor    %eax,%eax\ncall   2a00 <libmin_printf>\nmov    $0x1,%edi\ncall   14e0 <libtarg_fail>\nadd    $0x1,%rax\ncmp    $0x40,%rax\njne    12be <main+0x1be>\nmov    %edx,%eax\nadd    $0x100,%rcx\nadd    $0x1,%rdx\ncmp    $0x3e,%eax\njle    12a8 <main+0x1a8>\nlea    0x8072(%rip),%rbx\nxor    %esi,%esi\nlea    0x4000(%rbx),%rbp\nmov    %rbx,%rdi\nlea    -0x100(%rdi),%rax\nnopl   0x0(%rax)\nadd    (%rax),%esi\nadd    $0x4,%rax\nmov    %esi,%edx\nmovslq %esi,%rsi\nimul   $0x14f8b589,%rsi,%rsi\nmov    %edx,%ecx\nsar    $0x1f,%ecx\nsar    $0x2d,%rsi\nsub    %ecx,%esi\nimul   $0x186a0,%esi,%ecx\nmov    %edx,%esi\nsub    %ecx,%esi\ncmp    %rdi,%rax\njne    1328 <main+0x228>\nlea    0x100(%rax),%rdi\ncmp    %rbp,%rdi\njne    131a <main+0x21a>\nlea    0x1cd1(%rip),%rdi\nxor    %eax,%eax\nlea    0x1d0a(%rip),%r13\ncall   2a00 <libmin_printf>\nlea    0x1cec(%rip),%rdi\nxor    %eax,%eax\nlea    0x1cf3(%rip),%r14\ncall   2a00 <libmin_printf>\nlea    -0x100(%rbx),%r12\nnopl   0x0(%rax)\nmov    (%r12),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%r12\ncall   2a00 <libmin_printf>\ncmp    %r12,%rbx\njne    1398 <main+0x298>\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x100,%rbx\ncall   2a00 <libmin_printf>\ncmp    %rbp,%rbx\njne    138a <main+0x28a>\ncall   14c0 <libtarg_success>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "max-subseq/max-subseq.c", "function_name": "lcsAlgo", "content": "void lcsAlgo() {\n  // Filling 0's in the matrix\n  for (i = 0; i <= m; i++)\n    LCS_table[i][0] = 0;\n  for (i = 0; i <= n; i++)\n    LCS_table[0][i] = 0;\n\n  // Building the mtrix in bottom-up way\n  for (i = 1; i <= m; i++)\n    for (j = 1; j <= n; j++) {\n      if (S1[i - 1] == S2[j - 1]) {\n        LCS_table[i][j] = LCS_table[i - 1][j - 1] + 1;\n      } else if (LCS_table[i - 1][j] >= LCS_table[i][j - 1]) {\n        LCS_table[i][j] = LCS_table[i - 1][j];\n      } else {\n        LCS_table[i][j] = LCS_table[i][j - 1];\n      }\n    }\n\n  int index = LCS_table[m][n];\n  char lcsAlgo[index + 1];\n  lcsAlgo[index] = '\\0';\n\n  int i = m, j = n;\n  while (i > 0 && j > 0) {\n    if (S1[i - 1] == S2[j - 1]) {\n      lcsAlgo[index - 1] = S1[i - 1];\n      i--;\n      j--;\n      index--;\n    }\n\n    else if (LCS_table[i - 1][j] > LCS_table[i][j - 1])\n      i--;\n    else\n      j--;\n  }\n\n  // Printing the sub sequences\n  libmin_printf(\"LCS: %s\", lcsAlgo);\n}\n"}, "pseudo": {"path": "max-subseq/max-subseq.host.O2.pseudo", "function_name": "lcsAlgo", "address": "0x1290", "label": "lcsAlgo", "content": "void __cdecl lcsAlgo()\n{\n  int *v0; // r11\n  int v1; // r12d\n  int *v2; // rax\n  int v3; // ebx\n  __int64 v4; // r13\n  char *v5; // r10\n  int v6; // eax\n  int *v7; // rsi\n  int *v8; // r12\n  char v9; // r8\n  char *v10; // rdx\n  int *v11; // rcx\n  int v12; // eax\n  int v13; // r12d\n  int v14; // edi\n  char *v15; // rcx\n  signed __int64 v16; // rdx\n  void *v17; // rsp\n  char v18; // si\n  __int64 v19; // rcx\n  char *v20; // rsi\n  signed __int64 v21; // rax\n  void *v22; // rsp\n  char v24[4088]; // [rsp+8h] [rbp-1060h] BYREF\n  __int64 v25; // [rsp+1008h] [rbp-60h] BYREF\n  int v26; // [rsp+1010h] [rbp-58h]\n  int v27; // [rsp+1014h] [rbp-54h]\n  __int64 v28; // [rsp+1018h] [rbp-50h]\n  __int64 v29; // [rsp+1020h] [rbp-48h]\n  unsigned __int64 v30; // [rsp+1030h] [rbp-38h]\n\n  v0 = LCS_table[0];\n  v1 = m;\n  v30 = __readfsqword(0x28u);\n  if ( m < 0 )\n  {\n    v28 = m;\n  }\n  else\n  {\n    v2 = LCS_table[0];\n    v28 = m;\n    do\n    {\n      *v2 = 0;\n      v2 += 40;\n    }\n    while ( v2 != LCS_table[v1 + 1] );\n  }\n  v3 = n;\n  v29 = n;\n  if ( n >= 0 )\n    v0 = (int *)memset(LCS_table, 0, 4LL * n + 4);\n  i = 1;\n  if ( v1 <= 0 )\n  {\n    v19 = v0[40 * v28 + v29];\n    v20 = (char *)&v25 - (((int)v19 + 1 + 15LL) & 0xFFFFFFFFFFFFF000LL);\n    if ( &v25 != (__int64 *)v20 )\n    {\n      while ( v24 != v20 )\n        ;\n    }\n    v21 = ((_WORD)v19 + 16) & 0xFF0;\n    v22 = alloca(v21);\n    if ( (((_WORD)v19 + 16) & 0xFF0) != 0 )\n      *(_QWORD *)&v24[v21 - 8] = *(_QWORD *)&v24[v21 - 8];\n    v24[v19] = 0;\n  }\n  else\n  {\n    v26 = v1;\n    v4 = (unsigned int)(v1 - 1);\n    v5 = S1;\n    v6 = 1;\n    if ( v3 > 0 )\n      v6 = v3 + 1;\n    v7 = LCS_table[0];\n    v27 = v6;\n    do\n    {\n      v8 = v7 + 40;\n      if ( v3 > 0 )\n      {\n        v8 = v7 + 40;\n        v9 = *v5;\n        v10 = S2;\n        v11 = v7 + 40;\n        do\n        {\n          if ( v9 == *v10 )\n          {\n            v12 = *v7 + 1;\n          }\n          else\n          {\n            v12 = v7[1];\n            if ( v12 < *v11 )\n              v12 = *v11;\n          }\n          ++v10;\n          v11[1] = v12;\n          ++v7;\n          ++v11;\n        }\n        while ( &S2[v3 - 1 + 1] != v10 );\n      }\n      ++v5;\n      v7 = v8;\n    }\n    while ( v5 != &S1[v4 + 1] );\n    v13 = v26;\n    j = v27;\n    i = v26 + 1;\n    v14 = v0[40 * v28 + v29];\n    v15 = (char *)&v25 - ((v14 + 1 + 15LL) & 0xFFFFFFFFFFFFF000LL);\n    if ( &v25 != (__int64 *)v15 )\n    {\n      while ( v24 != v15 )\n        ;\n    }\n    v16 = ((_WORD)v14 + 16) & 0xFF0;\n    v17 = alloca(v16);\n    if ( (((_WORD)v14 + 16) & 0xFF0) != 0 )\n      *(_QWORD *)&v24[v16 - 8] = *(_QWORD *)&v24[v16 - 8];\n    v24[v14] = 0;\n    if ( v3 > 0 )\n    {\n      while ( 1 )\n      {\n        v18 = S1[(int)v4];\n        if ( v18 == S2[v3 - 1] )\n        {\n          --v14;\n          v13 = v4;\n          --v3;\n          v24[v14] = v18;\n          if ( (int)v4 <= 0 )\n            break;\n        }\n        else\n        {\n          if ( v0[40 * (int)v4 + v3] <= v0[40 * v13 - 1 + v3] )\n            --v3;\n          else\n            v13 = v4;\n          if ( v13 <= 0 )\n            break;\n        }\n        if ( v3 <= 0 )\n          break;\n        LODWORD(v4) = v13 - 1;\n      }\n    }\n  }\n  libmin_printf(\"LCS: %s\", v24);\n}\n"}, "pseudo_normalize": "void lcsAlgo() {\n  int *v0;\n  int v1;\n  int *v2;\n  int v3;\n  long long v4;\n  char *v5;\n  int v6;\n  int *v7;\n  int *v8;\n  char v9;\n  char *v10;\n  int *v11;\n  int v12;\n  int v13;\n  int v14;\n  char *v15;\n  signed long long v16;\n  void *v17;\n  char v18;\n  long long v19;\n  char *v20;\n  signed long long v21;\n  void *v22;\n  char v24[4088];\n  long long v25;\n  int v26;\n  int v27;\n  long long v28;\n  long long v29;\n  unsigned long long v30;\n  v0 = LCS_table[0];\n  v1 = m;\n  v30 = __readfsqword(40u);\n  if (m < 0) {\n    v28 = m;\n  } else {\n    v2 = LCS_table[0];\n    v28 = m;\n    do {\n      *v2 = 0;\n      v2 += 40;\n    } while (v2 != LCS_table[v1 + 1]);\n  }\n  v3 = n;\n  v29 = n;\n  if (n >= 0) v0 = (int *)memset(LCS_table, 0, 4LL * n + 4);\n  i = 1;\n  if (v1 <= 0) {\n    v19 = v0[40 * v28 + v29];\n    v20 = (char *)&v25 - (((int)v19 + 1 + 15LL) & 18446744073709547520LL);\n    if (&v25 != (long long *)v20) {\n      while (v24 != v20)\n        ;\n    }\n    v21 = ((unsigned short)v19 + 16) & 4080;\n    v22 = alloca(v21);\n    if ((((unsigned short)v19 + 16) & 4080) != 0)\n      *(uint64_t *)&v24[v21 - 8] = *(uint64_t *)&v24[v21 - 8];\n    v24[v19] = 0;\n  } else {\n    v26 = v1;\n    v4 = (unsigned int)(v1 - 1);\n    v5 = S1;\n    v6 = 1;\n    if (v3 > 0) v6 = v3 + 1;\n    v7 = LCS_table[0];\n    v27 = v6;\n    do {\n      v8 = v7 + 40;\n      if (v3 > 0) {\n        v8 = v7 + 40;\n        v9 = *v5;\n        v10 = S2;\n        v11 = v7 + 40;\n        do {\n          if (v9 == *v10) {\n            v12 = *v7 + 1;\n          } else {\n            v12 = v7[1];\n            if (v12 < *v11) v12 = *v11;\n          }\n          ++v10;\n          v11[1] = v12;\n          ++v7;\n          ++v11;\n        } while (&S2[v3 - 1 + 1] != v10);\n      }\n      ++v5;\n      v7 = v8;\n    } while (v5 != &S1[v4 + 1]);\n    v13 = v26;\n    j = v27;\n    i = v26 + 1;\n    v14 = v0[40 * v28 + v29];\n    v15 = (char *)&v25 - ((v14 + 1 + 15LL) & 18446744073709547520LL);\n    if (&v25 != (long long *)v15) {\n      while (v24 != v15)\n        ;\n    }\n    v16 = ((unsigned short)v14 + 16) & 4080;\n    v17 = alloca(v16);\n    if ((((unsigned short)v14 + 16) & 4080) != 0)\n      *(uint64_t *)&v24[v16 - 8] = *(uint64_t *)&v24[v16 - 8];\n    v24[v14] = 0;\n    if (v3 > 0) {\n      while (1) {\n        v18 = S1[(int)v4];\n        if (v18 == S2[v3 - 1]) {\n          --v14;\n          v13 = v4;\n          --v3;\n          v24[v14] = v18;\n          if ((int)v4 <= 0) break;\n        } else {\n          if (v0[40 * (int)v4 + v3] <= v0[40 * v13 - 1 + v3])\n            --v3;\n          else\n            v13 = v4;\n          if (v13 <= 0) break;\n        }\n        if (v3 <= 0) break;\n        LODWORD(v4) = v13 - 1;\n      }\n    }\n  }\n  libmin_printf(\"LCS: %s\", v24);\n}", "binary": "max-subseq/max-subseq.host.O2", "assembly": "<lcsAlgo>:\nendbr64\npush   %rbp\nlea    0x4664(%rip),%r11\nmov    %rsp,%rbp\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbx\nsub    $0x38,%rsp\nmov    0x5f51(%rip),%r12d\nmov    %fs:0x28,%rax\nmov    %rax,-0x38(%rbp)\nxor    %eax,%eax\ntest   %r12d,%r12d\njs     150e <lcsAlgo+0x27e>\nmovslq %r12d,%rbx\nlea    0xa0(%r11),%rcx\nmov    %r11,%rax\nlea    (%rbx,%rbx,4),%rdx\nmov    %rbx,-0x50(%rbp)\nshl    $0x5,%rdx\nadd    %rcx,%rdx\nnopw   0x0(%rax,%rax,1)\nmovl   $0x0,(%rax)\nadd    $0xa0,%rax\ncmp    %rdx,%rax\njne    12f0 <lcsAlgo+0x60>\nmov    0x5ef9(%rip),%ebx\nmovslq %ebx,%rax\nmov    %rax,-0x48(%rbp)\ntest   %ebx,%ebx\njs     1327 <lcsAlgo+0x97>\nmov    %r11,%rdi\nlea    0x4(,%rax,4),%rdx\nxor    %esi,%esi\ncall   10d0 <memset@plt>\nmov    %rax,%r11\nmovl   $0x1,0x5edb(%rip)\ntest   %r12d,%r12d\njle    151a <lcsAlgo+0x28a>\nlea    0x3cef(%rip),%r15\nlea    -0x1(%r12),%edx\ntest   %ebx,%ebx\nmov    %r12d,-0x58(%rbp)\nlea    0x1(%r15),%rax\nmov    %rdx,%r13\nmov    %r15,%r10\nlea    (%rdx,%rax,1),%r14\nlea    0x1(%rbx),%edx\nmov    $0x1,%eax\ncmovg  %edx,%eax\nlea    0x3ca5(%rip),%r9\nlea    0x458d(%rip),%rsi\nmov    %eax,-0x54(%rbp)\nlea    -0x1(%rbx),%eax\nadd    %rax,%r9\nnopl   0x0(%rax)\nlea    0xa0(%rsi),%r12\ntest   %ebx,%ebx\njle    13d8 <lcsAlgo+0x148>\nlea    0xa0(%rsi),%r12\nmovzbl (%r10),%r8d\nlea    0x3c73(%rip),%rdx\nmov    %r12,%rcx\njmp    13c6 <lcsAlgo+0x136>\nnopw   0x0(%rax,%rax,1)\nmov    0x4(%rsi),%eax\nmov    (%rcx),%edi\ncmp    %edi,%eax\ncmovl  %edi,%eax\nadd    $0x1,%rdx\nmov    %eax,0x4(%rcx)\nadd    $0x4,%rsi\nadd    $0x4,%rcx\ncmp    %rdx,%r9\nje     13d8 <lcsAlgo+0x148>\ncmp    (%rdx),%r8b\njne    13a8 <lcsAlgo+0x118>\nmov    (%rsi),%eax\nadd    $0x1,%eax\njmp    13b2 <lcsAlgo+0x122>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%r10\nmov    %r12,%rsi\ncmp    %r14,%r10\njne    1380 <lcsAlgo+0xf0>\nmov    -0x54(%rbp),%eax\nmov    -0x58(%rbp),%r12d\nmov    %rsp,%rcx\nmov    -0x48(%rbp),%rdi\nmov    %eax,0x5e10(%rip)\nlea    0x1(%r12),%eax\nmov    %eax,0x5e09(%rip)\nmov    -0x50(%rbp),%rax\nlea    (%rax,%rax,4),%rax\nlea    (%rdi,%rax,8),%rax\nmov    (%r11,%rax,4),%edi\nlea    0x1(%rdi),%eax\ncltq\nadd    $0xf,%rax\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nsub    %rax,%rcx\nand    $0xfffffffffffffff0,%rdx\ncmp    %rcx,%rsp\nje     1446 <lcsAlgo+0x1b6>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\ncmp    %rcx,%rsp\njne    1431 <lcsAlgo+0x1a1>\nand    $0xfff,%edx\nsub    %rdx,%rsp\ntest   %rdx,%rdx\njne    1503 <lcsAlgo+0x273>\nmovslq %edi,%rax\nmov    %rsp,%r9\nmovb   $0x0,(%rsp,%rax,1)\ntest   %ebx,%ebx\njle    14d0 <lcsAlgo+0x240>\nlea    0x3ba3(%rip),%r8\njmp    14a3 <lcsAlgo+0x213>\nnop\nmovslq %ebx,%rsi\nlea    (%rax,%rax,4),%rax\nlea    (%rsi,%rax,8),%rsi\nmovslq %r12d,%rax\nlea    (%rax,%rax,4),%rax\nlea    (%rcx,%rax,8),%rax\nmov    (%r11,%rax,4),%eax\ncmp    %eax,(%r11,%rsi,4)\ncmovg  %r13d,%r12d\ncmovle %edx,%ebx\ntest   %r12d,%r12d\njle    14d0 <lcsAlgo+0x240>\ntest   %ebx,%ebx\njle    14d0 <lcsAlgo+0x240>\nlea    -0x1(%r12),%r13d\nlea    -0x1(%rbx),%edx\nmovslq %r13d,%rax\nmovslq %edx,%rcx\nmovzbl (%r15,%rax,1),%esi\ncmp    (%r8,%rcx,1),%sil\njne    1470 <lcsAlgo+0x1e0>\nsub    $0x1,%edi\nmov    %r13d,%r12d\nmov    %edx,%ebx\nmovslq %edi,%rax\nmov    %sil,(%r9,%rax,1)\ntest   %r12d,%r12d\njg     149a <lcsAlgo+0x20a>\nnopl   0x0(%rax,%rax,1)\nxor    %eax,%eax\nmov    %r9,%rsi\nlea    0x1b28(%rip),%rdi\ncall   2ad0 <libmin_printf>\nmov    -0x38(%rbp),%rax\nsub    %fs:0x28,%rax\njne    1586 <lcsAlgo+0x2f6>\nlea    -0x28(%rbp),%rsp\npop    %rbx\npop    %r12\npop    %r13\npop    %r14\npop    %r15\npop    %rbp\nret\norq    $0x0,-0x8(%rsp,%rdx,1)\njmp    1458 <lcsAlgo+0x1c8>\nmovslq %r12d,%rax\nmov    %rax,-0x50(%rbp)\njmp    1301 <lcsAlgo+0x71>\nmov    -0x50(%rbp),%rax\nmov    -0x48(%rbp),%rbx\nmov    %rsp,%rsi\nlea    (%rax,%rax,4),%rax\nlea    (%rbx,%rax,8),%rax\nmovslq (%r11,%rax,4),%rcx\nlea    0x1(%rcx),%eax\ncltq\nadd    $0xf,%rax\nmov    %rax,%rdx\nand    $0xfffffffffffff000,%rax\nsub    %rax,%rsi\nand    $0xfffffffffffffff0,%rdx\ncmp    %rsi,%rsp\nje     1564 <lcsAlgo+0x2d4>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\ncmp    %rsi,%rsp\njne    154f <lcsAlgo+0x2bf>\nmov    %rdx,%rax\nand    $0xfff,%eax\nsub    %rax,%rsp\ntest   %rax,%rax\nje     157a <lcsAlgo+0x2ea>\norq    $0x0,-0x8(%rsp,%rax,1)\nmovb   $0x0,(%rsp,%rcx,1)\nmov    %rsp,%r9\njmp    14d0 <lcsAlgo+0x240>\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "max-subseq/max-subseq.c", "function_name": "main", "content": "int\nmain(void)\n{\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "max-subseq/max-subseq.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  m = libmin_strlen(S1);\n  n = libmin_strlen(S2);\n  libmin_printf(\"S1 : %s (%d) \\nS2 : %s  (%d)\\n\", S1, m, S2, n);\n  lcsAlgo();\n  libmin_printf((char *)\"\\n\");\n  libmin_success();\n}", "binary": "max-subseq/max-subseq.host.O2", "assembly": "<main>:\nendbr64\npush   %r12\nlea    0x3ee3(%rip),%r12\npush   %rbp\nlea    0x3efb(%rip),%rbp\nmov    %rbp,%rdi\nsub    $0x8,%rsp\ncall   2ce0 <libmin_strlen>\nmov    %r12,%rdi\nmov    %eax,0x60ba(%rip)\ncall   2ce0 <libmin_strlen>\nmov    0x60af(%rip),%edx\nmov    %r12,%rcx\nmov    %rbp,%rsi\nmov    %rax,%r8\nlea    0x1ea7(%rip),%rdi\nmov    %eax,0x6095(%rip)\nxor    %eax,%eax\ncall   2ad0 <libmin_printf>\nxor    %eax,%eax\ncall   1290 <lcsAlgo>\nlea    0x1ea7(%rip),%rdi\nxor    %eax,%eax\ncall   2ad0 <libmin_printf>\ncall   2d10 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "mersenne/mersenne.c", "function_name": "genrand", "content": "unsigned int \ngenrand(void)\n{\n  unsigned int y;\n  static unsigned int mag01[2]={0x0, MATRIX_A};\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (mti >= N) { /* generate N words at one time */\n    int kk;\n\n    if (mti == N+1)   /* if sgenrand() has not been called, */\n      sgenrand(4357); /* a default initial seed is used   */\n\n    for (kk=0;kk<N-M;kk++)\n      {\n\ty = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n\tmt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];\n      }\n    for (;kk<N-1;kk++)\n      {\n\ty = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n\tmt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];\n      }\n    y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);\n    mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];\n\n    mti = 0;\n  }\n  \n  y = mt[mti++];\n  y ^= TEMPERING_SHIFT_U(y);\n  y ^= TEMPERING_SHIFT_S(y) & TEMPERING_MASK_B;\n  y ^= TEMPERING_SHIFT_T(y) & TEMPERING_MASK_C;\n  y ^= TEMPERING_SHIFT_L(y);\n\n  return y; \n}\n"}, "pseudo": {"path": "mersenne/mersenne.host.O2.pseudo", "function_name": "genrand", "address": "0x1310", "label": "genrand", "content": "unsigned int __cdecl genrand()\n{\n  int v0; // edx\n  unsigned int v1; // ecx\n  unsigned int *v3; // rdx\n  unsigned int *v4; // rcx\n  unsigned int v5; // eax\n  unsigned int v6; // esi\n  unsigned int v7; // eax\n  unsigned int v8; // ecx\n  unsigned int *v9; // rcx\n  int v10; // eax\n  int v11; // edx\n\n  if ( mti > 623 )\n  {\n    if ( mti == 625 )\n    {\n      v9 = mt;\n      v10 = 4357;\n      do\n      {\n        v11 = 69069 * v10;\n        LOWORD(v10) = 0;\n        *v9++ = ((unsigned int)(v11 + 1) >> 16) | v10;\n        v10 = 69069 * (v11 + 1) + 1;\n      }\n      while ( &mt[624] != v9 );\n    }\n    v3 = mt;\n    v4 = mt;\n    do\n    {\n      v5 = *v4;\n      v6 = v4[1];\n      ++v4;\n      *(v4 - 1) = mag01_0[v6 & 1] ^ v4[396] ^ ((v6 & 0x7FFFFFFF | v5 & 0x80000000) >> 1);\n    }\n    while ( &mt[227] != v4 );\n    do\n    {\n      v7 = v3[227];\n      v8 = v3[228];\n      ++v3;\n      v3[226] = mag01_0[v8 & 1] ^ *(v3 - 1) ^ ((v8 & 0x7FFFFFFF | v7 & 0x80000000) >> 1);\n    }\n    while ( &mt[396] != v3 );\n    v1 = mt[0];\n    mt[623] = mag01_0[mt[0] & 1] ^ mt[396] ^ ((mt[0] & 0x7FFFFFFF | mt[623] & 0x80000000) >> 1);\n    v0 = 1;\n  }\n  else\n  {\n    v0 = mti + 1;\n    v1 = mt[mti];\n  }\n  mti = v0;\n  return v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 0x9D2C5680 ^ ((v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 0x9D2C5680) << 15) & 0xEFC60000 ^ ((v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 0x9D2C5680 ^ ((v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 0x9D2C5680) << 15) & 0xEFC60000) >> 18);\n}\n"}, "pseudo_normalize": "unsigned int genrand() {\n  int v0;\n  unsigned int v1;\n  unsigned int *v3;\n  unsigned int *v4;\n  unsigned int v5;\n  unsigned int v6;\n  unsigned int v7;\n  unsigned int v8;\n  unsigned int *v9;\n  int v10;\n  int v11;\n  if (mti > 623) {\n    if (mti == 625) {\n      v9 = mt;\n      v10 = 4357;\n      do {\n        v11 = 69069 * v10;\n        LOWORD(v10) = 0;\n        *v9++ = ((unsigned int)(v11 + 1) >> 16) | v10;\n        v10 = 69069 * (v11 + 1) + 1;\n      } while (&mt[624] != v9);\n    }\n    v3 = mt;\n    v4 = mt;\n    do {\n      v5 = *v4;\n      v6 = v4[1];\n      ++v4;\n      *(v4 - 1) = mag01_0[v6 & 1] ^ v4[396] ^\n                  ((v6 & 2147483647 | v5 & 2147483648) >> 1);\n    } while (&mt[227] != v4);\n    do {\n      v7 = v3[227];\n      v8 = v3[228];\n      ++v3;\n      v3[226] = mag01_0[v8 & 1] ^ *(v3 - 1) ^\n                ((v8 & 2147483647 | v7 & 2147483648) >> 1);\n    } while (&mt[396] != v3);\n    v1 = mt[0];\n    mt[623] = mag01_0[mt[0] & 1] ^ mt[396] ^\n              ((mt[0] & 2147483647 | mt[623] & 2147483648) >> 1);\n    v0 = 1;\n  } else {\n    v0 = mti + 1;\n    v1 = mt[mti];\n  }\n  mti = v0;\n  return v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 2636928640 ^\n         ((v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 2636928640) << 15) &\n             4022730752 ^\n         ((v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 2636928640 ^\n           ((v1 ^ (v1 >> 11) ^ ((v1 ^ (v1 >> 11)) << 7) & 2636928640) << 15) &\n               4022730752) >>\n          18);\n}", "binary": "mersenne/mersenne.host.O2", "assembly": "<genrand>:\nendbr64\nmovslq 0x3cf5(%rip),%rax\ncmp    $0x26f,%eax\njg     135d <genrand+0x4d>\nlea    0x3f57(%rip),%rcx\nlea    0x1(%rax),%edx\nmov    (%rcx,%rax,4),%ecx\nmov    %edx,0x3cdb(%rip)\nmov    %ecx,%edx\nshr    $0xb,%edx\nxor    %ecx,%edx\nmov    %edx,%eax\nshl    $0x7,%eax\nand    $0x9d2c5680,%eax\nxor    %edx,%eax\nmov    %eax,%edx\nshl    $0xf,%edx\nand    $0xefc60000,%edx\nxor    %eax,%edx\nmov    %edx,%eax\nshr    $0x12,%eax\nxor    %edx,%eax\nret\ncmp    $0x271,%eax\nje     1428 <genrand+0x118>\nlea    0x3f11(%rip),%rdx\nlea    0x1c9a(%rip),%rdi\nlea    0x38c(%rdx),%r8\nmov    %rdx,%rcx\nmov    (%rcx),%eax\nmov    0x4(%rcx),%esi\nadd    $0x4,%rcx\nand    $0x7fffffff,%esi\nand    $0x80000000,%eax\nor     %esi,%eax\nmov    %eax,%esi\nand    $0x1,%eax\nshr    %esi\nxor    0x630(%rcx),%esi\nxor    (%rdi,%rax,4),%esi\nmov    %esi,-0x4(%rcx)\ncmp    %rcx,%r8\njne    1380 <genrand+0x70>\nlea    0x44fb(%rip),%rsi\nnopl   (%rax)\nmov    0x38c(%rdx),%eax\nmov    0x390(%rdx),%ecx\nadd    $0x4,%rdx\nand    $0x7fffffff,%ecx\nand    $0x80000000,%eax\nor     %ecx,%eax\nmov    %eax,%ecx\nand    $0x1,%eax\nshr    %ecx\nxor    -0x4(%rdx),%ecx\nxor    (%rdi,%rax,4),%ecx\nmov    %ecx,0x388(%rdx)\ncmp    %rdx,%rsi\njne    13b8 <genrand+0xa8>\nmov    0x3e8d(%rip),%ecx\nmov    0x4843(%rip),%eax\nmov    %ecx,%edx\nand    $0x80000000,%eax\nand    $0x7fffffff,%edx\nor     %edx,%eax\nmov    %eax,%edx\nand    $0x1,%eax\nshr    %edx\nxor    0x449b(%rip),%edx\nxor    (%rdi,%rax,4),%edx\nmov    %edx,0x481e(%rip)\nmov    $0x1,%edx\njmp    132f <genrand+0x1f>\nlea    0x3e51(%rip),%rcx\nmov    $0x1105,%eax\nlea    0x9c0(%rcx),%rdi\nnopl   0x0(%rax,%rax,1)\nimul   $0x10dcd,%eax,%edx\nxor    %ax,%ax\nadd    $0x4,%rcx\nadd    $0x1,%edx\nmov    %edx,%esi\nimul   $0x10dcd,%edx,%edx\nshr    $0x10,%esi\nor     %esi,%eax\nmov    %eax,-0x4(%rcx)\nlea    0x1(%rdx),%eax\ncmp    %rcx,%rdi\njne    1440 <genrand+0x130>\njmp    1368 <genrand+0x58>\nnopl   (%rax)\n"}
{"source": {"path": "mersenne/mersenne.c", "function_name": "lsgenrand", "content": "/* Initialization by \"sgenrand()\" is an example. Theoretically,      */\n/* there are 2^19937-1 possible states as an intial state.           */\n/* This function allows to choose any of 2^19937-1 ones.             */\n/* Essential bits in \"seed_array[]\" is following 19937 bits:         */\n/* (seed_array[0]&UPPER_MASK), seed_array[1], ..., seed_array[N-1]. */\n/* (seed_array[0]&LOWER_MASK) is discarded.                          */ \n/* Theoretically,                                                    */\n/* (seed_array[0]&UPPER_MASK), seed_array[1], ..., seed_array[N-1]  */\n/* can take any values except all zeros.                             */\nvoid\nlsgenrand(unsigned int seed_array[])\n     /* the length of seed_array[] must be at least N */\n{\n  int i;\n\n  for (i=0;i<N;i++) \n    mt[i] = seed_array[i];\n  mti=N;\n}\n"}, "pseudo": {"path": "mersenne/mersenne.host.O2.pseudo", "function_name": "lsgenrand", "address": "0x12e0", "label": "lsgenrand", "content": "void __fastcall lsgenrand(unsigned int *seed_array)\n{\n  __int64 i; // rax\n\n  for ( i = 0LL; i != 624; ++i )\n    mt[i] = seed_array[i];\n  mti = 624;\n}\n"}, "pseudo_normalize": "", "binary": "mersenne/mersenne.host.O2", "assembly": "<lsgenrand>:\nendbr64\nxor    %eax,%eax\nlea    0x3f93(%rip),%rcx\nnopl   (%rax)\nmov    (%rdi,%rax,1),%edx\nmov    %edx,(%rcx,%rax,1)\nadd    $0x4,%rax\ncmp    $0x9c0,%rax\njne    12f0 <lsgenrand+0x10>\nmovl   $0x270,0x3d04(%rip)\nret\nnopl   (%rax)\n"}
{"source": {"path": "mersenne/mersenne.c", "function_name": "main", "content": "/* This main() outputs first 1000 generated numbers.  */\nint\nmain(void)\n{ \n  int steps = 10000;\n  int i, j;\n    \n  sgenrand(4357);\n  for (i=0,j=0; i<steps; i++)\n    {\n      if ((i % 100) == 0)\n\t{\n\t  libmin_printf(\"%10u \", genrand());\n\t  if (++j%5==0)\n\t    libmin_printf(\"\\n\");\n\t}\n    }\n  libmin_printf(\"\\n\");\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "mersenne/mersenne.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // ebx\n  unsigned int v5; // eax\n\n  v3 = 0;\n  v4 = 0;\n  sgenrand(0x1105u);\n  while ( 1 )\n  {\n    if ( __ROR4__(-1030792151 * v4, 2) > 0x28F5C28u\n      || (v5 = genrand(),\n          ++v3,\n          argv = (const char **)v5,\n          libmin_printf(\"%10u \", v5),\n          (unsigned int)(-858993459 * v3) > 0x33333333) )\n    {\n      if ( ++v4 == 10000 )\n        goto LABEL_6;\n    }\n    else\n    {\n      ++v4;\n      libmin_printf(\"\\n\");\n      if ( v4 == 10000 )\n      {\nLABEL_6:\n        libmin_printf(\"\\n\", argv);\n        libmin_success();\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  unsigned int v5;\n  v3 = 0;\n  v4 = 0;\n  sgenrand(4357u);\n  while (1) {\n    if (__ROR4__(-1030792151 * v4, 2) > 42949672u ||\n        (v5 = genrand(), ++v3, argv = (const char **)v5,\n         libmin_printf(\"%10u \", v5),\n         (unsigned int)(-858993459 * v3) > 858993459)) {\n      if (++v4 == 10000) goto LABEL_6;\n    } else {\n      ++v4;\n      libmin_printf(\"\\n\");\n      if (v4 == 10000) {\n      LABEL_6:\n        libmin_printf(\"\\n\", argv);\n        libmin_success();\n      }\n    }\n  }\n}", "binary": "mersenne/mersenne.host.O2", "assembly": "<main>:\nendbr64\npush   %r13\nmov    $0x1105,%edi\nlea    0x1ef8(%rip),%r13\npush   %r12\nlea    0x1ee9(%rip),%r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x8,%rsp\ncall   1290 <sgenrand>\njmp    113b <main+0x3b>\nnopl   0x0(%rax)\nadd    $0x1,%ebx\ncmp    $0x2710,%ebx\nje     1181 <main+0x81>\nimul   $0xc28f5c29,%ebx,%eax\nror    $0x2,%eax\ncmp    $0x28f5c28,%eax\nja     1130 <main+0x30>\ncall   1310 <genrand>\nadd    $0x1,%ebp\nmov    %r12,%rdi\nmov    %eax,%esi\nxor    %eax,%eax\ncall   29b0 <libmin_printf>\nimul   $0xcccccccd,%ebp,%eax\ncmp    $0x33333333,%eax\nja     1130 <main+0x30>\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   29b0 <libmin_printf>\ncmp    $0x2710,%ebx\njne    113b <main+0x3b>\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   29b0 <libmin_printf>\ncall   2bf0 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   (%rax)\n"}
{"source": {"path": "mersenne/mersenne.c", "function_name": "sgenrand", "content": " /* mti==N+1 means mt[N] is not initialized */\n\n/* Initializing the array with a seed */\nvoid\nsgenrand(unsigned int seed)\n{\n  int i;\n\n  for (i=0;i<N;i++)\n    {\n      mt[i] = seed & 0xffff0000;\n      seed = 69069 * seed + 1;\n      mt[i] |= (seed & 0xffff0000) >> 16;\n      seed = 69069 * seed + 1;\n    }\n  mti = N;\n}\n"}, "pseudo": {"path": "mersenne/mersenne.host.O2.pseudo", "function_name": "sgenrand", "address": "0x1290", "label": "sgenrand", "content": "void __fastcall sgenrand(unsigned int seed)\n{\n  unsigned int *v1; // rdx\n  unsigned int v2; // eax\n\n  v1 = mt;\n  do\n  {\n    v2 = 69069 * seed;\n    LOWORD(seed) = 0;\n    *v1++ = ((v2 + 1) >> 16) | seed;\n    seed = 69069 * (v2 + 1) + 1;\n  }\n  while ( &mt[624] != v1 );\n  mti = 624;\n}\n"}, "pseudo_normalize": "void sgenrand(unsigned int seed) {\n  unsigned int *v1;\n  unsigned int v2;\n  v1 = mt;\n  do {\n    v2 = 69069 * seed;\n    LOWORD(seed) = 0;\n    *v1++ = ((v2 + 1) >> 16) | seed;\n    seed = 69069 * (v2 + 1) + 1;\n  } while (&mt[624] != v1);\n  mti = 624;\n}", "binary": "mersenne/mersenne.host.O2", "assembly": "<sgenrand>:\nendbr64\nlea    0x3fe5(%rip),%rdx\nlea    0x9c0(%rdx),%rsi\nnopw   0x0(%rax,%rax,1)\nimul   $0x10dcd,%edi,%eax\nxor    %di,%di\nadd    $0x4,%rdx\nadd    $0x1,%eax\nmov    %eax,%ecx\nimul   $0x10dcd,%eax,%eax\nshr    $0x10,%ecx\nor     %ecx,%edi\nmov    %edi,-0x4(%rdx)\nlea    0x1(%rax),%edi\ncmp    %rdx,%rsi\njne    12a8 <sgenrand+0x18>\nmovl   $0x270,0x3d36(%rip)\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "displayGraph", "content": "void\ndisplayGraph(int32_t graph[V][V])\n{\n\tint index = 0;\n\tfor (int i=-1;i<V;i++)\n  {\n\t\tfor (int j=-1;j<V;j++)\n    {\n\t\t\tif (i==-1)\n      {\n\t\t\t\tif (j==-1)\n          libmin_printf(\"       \");\n\t\t\t\telse\n          libmin_printf(\"%8s\", vertName[j]);\n\t\t\t}\n      else\n      {\n\t\t\t\tif(j==-1)\n        {\n          libmin_printf(\"%8s\", vertName[index]);\n\t\t\t\t\tindex++;\n\t\t\t\t}\n        else\n          libmin_printf(\"%8d\", graph[i][j]);\n\t\t\t}\n\t\t}\n    libmin_printf(\"\\n\");\n\t}\n  libmin_printf(\"\\n\\n\");\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O2.pseudo", "function_name": "displayGraph", "address": "0x14f0", "label": "displayGraph", "content": "void __fastcall displayGraph(int32_t (*graph)[1])\n{\n  int v1; // r13d\n  int32_t *v2; // rbp\n  int i; // ebx\n  __int64 v4; // r15\n  __int64 v5; // rax\n\n  v1 = 0;\n  v2 = &(*graph)[-10];\n  for ( i = -1; i != 10; ++i )\n  {\n    v4 = 0LL;\n    while ( i != -1 )\n    {\n      if ( v4 )\n      {\n        libmin_printf(\"%8d\", v2[v4 - 1]);\n        if ( v4 == 10 )\n          goto LABEL_9;\n      }\n      else\n      {\n        v5 = v1++;\n        libmin_printf(\"%8s\", vertName[v5]);\n      }\nLABEL_5:\n      ++v4;\n    }\n    if ( !v4 )\n    {\n      libmin_printf(\"       \");\n      goto LABEL_5;\n    }\n    libmin_printf(\"%8s\", *((const char **)&unk_6018 + v4));\n    if ( v4 != 10 )\n      goto LABEL_5;\nLABEL_9:\n    v2 += 10;\n    libmin_printf((char *)\"\\n\");\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}\n"}, "pseudo_normalize": "void displayGraph(int32_t (*graph)[1]) {\n  int v1;\n  int32_t *v2;\n  int i;\n  long long v4;\n  long long v5;\n  v1 = 0;\n  v2 = &(*graph)[-10];\n  for (i = -1; i != 10; ++i) {\n    v4 = 0LL;\n    while (i != -1) {\n      if (v4) {\n        libmin_printf(\"%8d\", v2[v4 - 1]);\n        if (v4 == 10) goto LABEL_9;\n      } else {\n        v5 = v1++;\n        libmin_printf(\"%8s\", vertName[v5]);\n      }\n    LABEL_5:\n      ++v4;\n    }\n    if (!v4) {\n      libmin_printf(\"       \");\n      goto LABEL_5;\n    }\n    libmin_printf(\"%8s\", *((const char **)&unk_6018 + v4));\n    if (v4 != 10) goto LABEL_5;\n  LABEL_9:\n    v2 += 10;\n    libmin_printf((char *)\"\\n\");\n  }\n  libmin_printf((char *)\"\\n\\n\");\n}", "binary": "minspan/minspan.host.O2", "assembly": "<displayGraph>:\nendbr64\npush   %r15\npush   %r14\nlea    0x2b0d(%rip),%r14\npush   %r13\nxor    %r13d,%r13d\npush   %r12\nlea    0x2b03(%rip),%r12\npush   %rbp\nlea    -0x28(%rdi),%rbp\npush   %rbx\nmov    $0xffffffff,%ebx\nsub    $0x8,%rsp\nnopl   0x0(%rax)\nxor    %r15d,%r15d\njmp    1546 <displayGraph+0x56>\nnopl   (%rax)\ntest   %r15,%r15\nje     15a8 <displayGraph+0xb8>\nmov    -0x4(%rbp,%r15,4),%esi\nxor    %eax,%eax\nmov    %r12,%rdi\ncall   2d80 <libmin_printf>\ncmp    $0xa,%r15\nje     156f <displayGraph+0x7f>\nadd    $0x1,%r15\ncmp    $0xffffffff,%ebx\njne    1528 <displayGraph+0x38>\ntest   %r15,%r15\nje     15d0 <displayGraph+0xe0>\nlea    0x4abd(%rip),%rax\nmov    %r14,%rdi\nmov    (%rax,%r15,8),%rsi\nxor    %eax,%eax\ncall   2d80 <libmin_printf>\ncmp    $0xa,%r15\njne    1542 <displayGraph+0x52>\nlea    0x2ac3(%rip),%rdi\nxor    %eax,%eax\nadd    $0x1,%ebx\nadd    $0x28,%rbp\ncall   2d80 <libmin_printf>\ncmp    $0xa,%ebx\njne    1520 <displayGraph+0x30>\nadd    $0x8,%rsp\nlea    0x2aa4(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    2d80 <libmin_printf>\nnopl   (%rax)\nmovslq %r13d,%rax\nlea    0x4a6e(%rip),%rdx\nmov    %r14,%rdi\nadd    $0x1,%r13d\nmov    (%rdx,%rax,8),%rsi\nxor    %eax,%eax\ncall   2d80 <libmin_printf>\njmp    1542 <displayGraph+0x52>\nnopl   0x0(%rax)\nlea    0x2a2d(%rip),%rdi\nxor    %eax,%eax\ncall   2d80 <libmin_printf>\njmp    1542 <displayGraph+0x52>\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "displayGraph1", "content": "void\ndisplayGraph1(int32_t graph[V][V], int32_t path[V])\n{\n\tint index = 0;\n\tfor (int i=-1;i<V;i++)\n  {\n\t\tfor (int j=-1;j<V;j++)\n    {\n\t\t\tif (i==-1)\n      {\n\t\t\t\tif (j==-1)\n          libmin_printf(\"       \");\n\t\t\t\telse\n          libmin_printf(\"%8s\", vertName[j]);\n\t\t\t}\n      else\n      {\n\t\t\t\tif(j==-1)\n        {\n          libmin_printf(\"%8s\", vertName[index]);\n\t\t\t\t\tindex++;\n\t\t\t\t}\n        else\n          libmin_printf(\"%8d / %d\", graph[i][j], path[i]);\n\t\t\t}\n\t\t}\n    libmin_printf(\"\\n\");\n\t}\n  libmin_printf(\"\\n\\n\");\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O2.pseudo", "function_name": "displayGraph1", "address": "0x15f0", "label": "displayGraph1", "content": "void __fastcall displayGraph1(int32_t (*graph)[1], int32_t *path)\n{\n  int32_t *v2; // r12\n  int32_t *v3; // rbp\n  int v4; // ebx\n  __int64 v5; // r14\n  int index; // [rsp+Ch] [rbp-3Ch]\n\n  v2 = path - 1;\n  v3 = &(*graph)[-10];\n  v4 = -1;\n  index = 0;\n  do\n  {\n    v5 = 0LL;\n    while ( v4 != -1 )\n    {\n      if ( v5 )\n      {\n        libmin_printf(\"%8d / %d\", v3[v5 - 1], *v2);\n        if ( v5 == 10 )\n          goto LABEL_9;\n      }\n      else\n      {\n        libmin_printf(\"%8s\", vertName[index++]);\n      }\nLABEL_5:\n      ++v5;\n    }\n    if ( !v5 )\n    {\n      libmin_printf(\"       \");\n      goto LABEL_5;\n    }\n    libmin_printf(\"%8s\", *((const char **)&unk_6018 + v5));\n    if ( v5 != 10 )\n      goto LABEL_5;\nLABEL_9:\n    ++v4;\n    ++v2;\n    libmin_printf((char *)\"\\n\");\n    v3 += 10;\n  }\n  while ( v4 != 10 );\n  libmin_printf((char *)\"\\n\\n\");\n}\n"}, "pseudo_normalize": "void displayGraph1(int32_t (*graph)[1], int32_t *path) {\n  int32_t *v2;\n  int32_t *v3;\n  int v4;\n  long long v5;\n  int index;\n  v2 = path - 1;\n  v3 = &(*graph)[-10];\n  v4 = -1;\n  index = 0;\n  do {\n    v5 = 0LL;\n    while (v4 != -1) {\n      if (v5) {\n        libmin_printf(\"%8d / %d\", v3[v5 - 1], *v2);\n        if (v5 == 10) goto LABEL_9;\n      } else {\n        libmin_printf(\"%8s\", vertName[index++]);\n      }\n    LABEL_5:\n      ++v5;\n    }\n    if (!v5) {\n      libmin_printf(\"       \");\n      goto LABEL_5;\n    }\n    libmin_printf(\"%8s\", *((const char **)&unk_6018 + v5));\n    if (v5 != 10) goto LABEL_5;\n  LABEL_9:\n    ++v4;\n    ++v2;\n    libmin_printf((char *)\"\\n\");\n    v3 += 10;\n  } while (v4 != 10);\n  libmin_printf((char *)\"\\n\\n\");\n}", "binary": "minspan/minspan.host.O2", "assembly": "<displayGraph1>:\nendbr64\npush   %r15\nlea    0x2a0f(%rip),%r15\npush   %r14\npush   %r13\nlea    0x2a0c(%rip),%r13\npush   %r12\nlea    -0x4(%rsi),%r12\npush   %rbp\nlea    -0x28(%rdi),%rbp\npush   %rbx\nmov    $0xffffffff,%ebx\nsub    $0x18,%rsp\nmovl   $0x0,0xc(%rsp)\nnopl   (%rax)\nxor    %r14d,%r14d\njmp    1656 <displayGraph1+0x66>\nnopl   (%rax)\ntest   %r14,%r14\nje     16c0 <displayGraph1+0xd0>\nmov    -0x4(%rbp,%r14,4),%esi\nmov    (%r12),%edx\nxor    %eax,%eax\nmov    %r13,%rdi\ncall   2d80 <libmin_printf>\ncmp    $0xa,%r14\nje     167f <displayGraph1+0x8f>\nadd    $0x1,%r14\ncmp    $0xffffffff,%ebx\njne    1630 <displayGraph1+0x40>\ntest   %r14,%r14\nje     16e8 <displayGraph1+0xf8>\nlea    0x49ad(%rip),%rax\nmov    %r15,%rdi\nmov    (%rax,%r14,8),%rsi\nxor    %eax,%eax\ncall   2d80 <libmin_printf>\ncmp    $0xa,%r14\njne    1652 <displayGraph1+0x62>\nlea    0x29b3(%rip),%rdi\nxor    %eax,%eax\nadd    $0x1,%ebx\nadd    $0x4,%r12\ncall   2d80 <libmin_printf>\nadd    $0x28,%rbp\ncmp    $0xa,%ebx\njne    1628 <displayGraph1+0x38>\nadd    $0x18,%rsp\nlea    0x2990(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    2d80 <libmin_printf>\nnopl   0x0(%rax)\nmovslq 0xc(%rsp),%rax\nlea    0x4954(%rip),%rcx\nmov    %r15,%rdi\nmov    (%rcx,%rax,8),%rsi\nxor    %eax,%eax\ncall   2d80 <libmin_printf>\naddl   $0x1,0xc(%rsp)\njmp    1652 <displayGraph1+0x62>\nnopl   0x0(%rax)\nlea    0x2915(%rip),%rdi\nxor    %eax,%eax\ncall   2d80 <libmin_printf>\njmp    1652 <displayGraph1+0x62>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "displayPath", "content": "//Displays the path from source to destination\nvoid\ndisplayPath(int32_t source, int32_t dest, int32_t path[V])\n{\n\tstatic int count = 0;\n\t\n\tint currPath = dest;\n\t\n\tif (count == 0)\n  {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source], vertName[currPath]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n\t\tcount++;\n\t}\t\n\tif (path[currPath] != source)\n  {\n\t\tdisplayPath(source,path[currPath],path);\n\t}\n  libmin_printf(\"-> %s\", vertName[currPath]);\n\tif (currPath == dest)\n  {\n    libmin_printf(\"\\n\");\n\t}\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O2.pseudo", "function_name": "displayPath", "address": "0x1700", "label": "displayPath", "content": "void __fastcall displayPath(int32_t source, int32_t dest, int32_t *path)\n{\n  __int64 v4; // rbx\n  int32_t v5; // esi\n\n  v4 = dest;\n  if ( !count_0 )\n  {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source], vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  v5 = path[dest];\n  if ( v5 != source )\n    displayPath(source, v5, path);\n  libmin_printf(\"-> %s\", vertName[v4]);\n  libmin_printf((char *)\"\\n\");\n}\n"}, "pseudo_normalize": "void displayPath(int32_t source, int32_t dest, int32_t *path) {\n  long long v4;\n  int32_t v5;\n  v4 = dest;\n  if (!count_0) {\n    libmin_printf(\"\\nSource: %s\\tDestination: %s\\n\\n\", vertName[source],\n                  vertName[dest]);\n    libmin_printf(\"Path: %s\", vertName[source]);\n    ++count_0;\n  }\n  v5 = path[dest];\n  if (v5 != source) displayPath(source, v5, path);\n  libmin_printf(\"-> %s\", vertName[v4]);\n  libmin_printf((char *)\"\\n\");\n}", "binary": "minspan/minspan.host.O2", "assembly": "<displayPath>:\nendbr64\nmov    0x4bc2(%rip),%eax\npush   %r14\npush   %r13\nlea    0x490b(%rip),%r13\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %edi,%ebp\npush   %rbx\nmovslq %esi,%rbx\ntest   %eax,%eax\nje     1760 <displayPath+0x60>\nmov    (%r12,%rbx,4),%esi\ncmp    %ebp,%esi\nje     1737 <displayPath+0x37>\nmov    %r12,%rdx\nmov    %ebp,%edi\ncall   1700 <displayPath>\nmov    0x0(%r13,%rbx,8),%rsi\nlea    0x2901(%rip),%rdi\nxor    %eax,%eax\ncall   2d80 <libmin_printf>\npop    %rbx\nlea    0x28e7(%rip),%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %r14\njmp    2d80 <libmin_printf>\nmovslq %edi,%r14\nmov    0x0(%r13,%rbx,8),%rdx\nxor    %eax,%eax\nlea    0x28ac(%rip),%rdi\nmov    0x0(%r13,%r14,8),%rsi\ncall   2d80 <libmin_printf>\nmov    0x0(%r13,%r14,8),%rsi\nlea    0x28b4(%rip),%rdi\nxor    %eax,%eax\ncall   2d80 <libmin_printf>\naddl   $0x1,0x4b37(%rip)\njmp    1725 <displayPath+0x25>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "displayTree", "content": "// display the minimum spanning tree\nvoid\ndisplayTree(int32_t graph[V][V], int32_t path[V])\n{\n  int cost = 0;\n  libmin_printf(\"minimum spanning tree:\\n\");\n  for (int i=1; i < V; i++)\n  {\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", vertName[i], graph[i][path[i]], vertName[path[i]]);\n    cost += graph[i][path[i]];\n  }\n  libmin_printf(\"total cost = %d\\n\", cost);\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O2.pseudo", "function_name": "displayTree", "address": "0x17a0", "label": "displayTree", "content": "void __fastcall displayTree(int32_t (*graph)[1], int32_t *path)\n{\n  int v2; // r15d\n  int *v3; // r12\n  int32_t *v4; // rbp\n  int32_t *v5; // rbx\n  __int64 v6; // rax\n  const char *v7; // rsi\n\n  v2 = 0;\n  v3 = (int *)&vertName[1];\n  v4 = path + 1;\n  v5 = &(*graph)[10];\n  libmin_printf(\"minimum spanning tree:\\n\");\n  do\n  {\n    v6 = *v4;\n    v7 = *(const char **)v3;\n    v3 += 2;\n    ++v4;\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", v7, v5[v6], vertName[v6 - 7]);\n    v2 += v5[*(v4 - 1)];\n    v5 += 10;\n  }\n  while ( v3 != &mti );\n  libmin_printf(\"total cost = %d\\n\", v2);\n}\n"}, "pseudo_normalize": "void displayTree(int32_t (*graph)[1], int32_t *path) {\n  int v2;\n  int *v3;\n  int32_t *v4;\n  int32_t *v5;\n  long long v6;\n  const char *v7;\n  v2 = 0;\n  v3 = (int *)&vertName[1];\n  v4 = path + 1;\n  v5 = &(*graph)[10];\n  libmin_printf(\"minimum spanning tree:\\n\");\n  do {\n    v6 = *v4;\n    v7 = *(const char **)v3;\n    v3 += 2;\n    ++v4;\n    libmin_printf(\"  %8s <-%d-> %8s\\n\", v7, v5[v6], vertName[v6 - 7]);\n    v2 += v5[*(v4 - 1)];\n    v5 += 10;\n  } while (v3 != &mti);\n  libmin_printf(\"total cost = %d\\n\", v2);\n}", "binary": "minspan/minspan.host.O2", "assembly": "<displayTree>:\nendbr64\npush   %r15\nxor    %eax,%eax\nxor    %r15d,%r15d\npush   %r14\npush   %r13\nlea    0x28ac(%rip),%r13\npush   %r12\nlea    0x4869(%rip),%r12\npush   %rbp\nmov    %rsi,%rbp\nlea    -0x8(%r12),%r14\npush   %rbx\nmov    %rdi,%rbx\nlea    0x2877(%rip),%rdi\nadd    $0x4,%rbp\nadd    $0x28,%rbx\nsub    $0x8,%rsp\ncall   2d80 <libmin_printf>\nnopl   0x0(%rax)\nmovslq 0x0(%rbp),%rax\nmov    (%r12),%rsi\nmov    %r13,%rdi\nadd    $0x8,%r12\nadd    $0x4,%rbp\nmov    (%rbx,%rax,4),%edx\nmov    (%r14,%rax,8),%rcx\nxor    %eax,%eax\ncall   2d80 <libmin_printf>\nmovslq -0x4(%rbp),%rax\nadd    (%rbx,%rax,4),%r15d\nlea    0x4858(%rip),%rax\nadd    $0x28,%rbx\ncmp    %rax,%r12\njne    17e8 <displayTree+0x48>\nadd    $0x8,%rsp\nmov    %r15d,%esi\nlea    0x2845(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    2d80 <libmin_printf>\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "initializeData", "content": "//Used to initialize the graph\nvoid\ninitializeData(int32_t graph[V][V])\n{\n\tlibmin_srand(10);\n\tfor (int i=0; i < V; i++)\n  {\n\t\tfor (int j=0;j<V;j++)\n    {\n\t\t\tif (i>j)\n\t\t\t\tgraph[i][j] = graph[j][i];\n\t\t\telse if (i==j)\n\t\t\t\tgraph[i][j] = 0;\n\t\t\telse\n      {\n\t\t\t\tif (libmin_rand() % 5 == libmin_rand() % 5)\n\t\t\t\t\tgraph[i][j] = 0;\t\n\t\t\t\telse\n\t\t\t\t\tgraph[i][j] = libmin_rand() % 10;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O2.pseudo", "function_name": "initializeData", "address": "0x1400", "label": "initializeData", "content": "void __fastcall initializeData(int32_t (*graph)[1])\n{\n  __int64 v1; // r14\n  __int64 v2; // rbx\n  int32_t *v3; // r12\n  unsigned int v4; // ebp\n  unsigned int v5; // r15d\n\n  v1 = 0LL;\n  libmin_srand(0xAu);\n  do\n  {\n    v2 = 0LL;\n    v3 = &(*graph)[v1];\n    do\n    {\n      if ( (int)v2 < (int)v1 )\n      {\n        v4 = *v3;\n      }\n      else\n      {\n        v4 = 0;\n        if ( (_DWORD)v2 != (_DWORD)v1 )\n        {\n          v5 = libmin_rand();\n          if ( v5 % 5 != libmin_rand() % 5 )\n            v4 = libmin_rand() % 0xA;\n        }\n      }\n      (*graph)[10 * v1 + v2++] = v4;\n      v3 += 10;\n    }\n    while ( v2 != 10 );\n    ++v1;\n  }\n  while ( v1 != 10 );\n}\n"}, "pseudo_normalize": "void initializeData(int32_t (*graph)[1]) {\n  long long v1;\n  long long v2;\n  int32_t *v3;\n  unsigned int v4;\n  unsigned int v5;\n  v1 = 0LL;\n  libmin_srand(10u);\n  do {\n    v2 = 0LL;\n    v3 = &(*graph)[v1];\n    do {\n      if ((int)v2 < (int)v1) {\n        v4 = *v3;\n      } else {\n        v4 = 0;\n        if ((uint32_t)v2 != (uint32_t)v1) {\n          v5 = libmin_rand();\n          if (v5 % 5 != libmin_rand() % 5) v4 = libmin_rand() % 10;\n        }\n      }\n      (*graph)[10 * v1 + v2++] = v4;\n      v3 += 10;\n    } while (v2 != 10);\n    ++v1;\n  } while (v1 != 10);\n}", "binary": "minspan/minspan.host.O2", "assembly": "<initializeData>:\nendbr64\npush   %r15\npush   %r14\nxor    %r14d,%r14d\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rdi,0x8(%rsp)\nmov    $0xa,%edi\ncall   2f90 <libmin_srand>\nnopl   0x0(%rax)\nmov    0x8(%rsp),%rsi\nlea    0x0(,%r14,4),%r12\nxor    %ebx,%ebx\nlea    (%r12,%r14,1),%rax\nlea    (%rsi,%rax,8),%r13\nadd    %rsi,%r12\njmp    145f <initializeData+0x5f>\nnopl   0x0(%rax)\nmov    (%r12),%ebp\nmov    %ebp,0x0(%r13,%rbx,4)\nadd    $0x1,%rbx\nadd    $0x28,%r12\ncmp    $0xa,%rbx\nje     14c8 <initializeData+0xc8>\ncmp    %r14d,%ebx\njl     1448 <initializeData+0x48>\nmov    $0x0,%ebp\nje     144c <initializeData+0x4c>\ncall   2ff0 <libmin_rand>\nmov    %eax,%r15d\ncall   2ff0 <libmin_rand>\nmov    $0xcccccccd,%ecx\nmov    %eax,%edx\nmov    %r15d,%eax\nimul   %rcx,%rax\nshr    $0x22,%rax\nlea    (%rax,%rax,4),%eax\nsub    %eax,%r15d\nmov    %edx,%eax\nimul   %rcx,%rax\nshr    $0x22,%rax\nlea    (%rax,%rax,4),%eax\nsub    %eax,%edx\ncmp    %edx,%r15d\nje     144c <initializeData+0x4c>\ncall   2ff0 <libmin_rand>\nmov    $0xcccccccd,%ecx\nmov    %eax,%ebp\nimul   %rcx,%rbp\nshr    $0x23,%rbp\nlea    0x0(%rbp,%rbp,4),%edx\nadd    %edx,%edx\nsub    %edx,%eax\nmov    %eax,%ebp\njmp    144c <initializeData+0x4c>\nnopl   0x0(%rax)\nadd    $0x1,%r14\ncmp    $0xa,%r14\njne    1428 <initializeData+0x28>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "main", "content": "int\nmain()\n{\n\t// int32_t source = 0;\n\t// int32_t destination = 1;\n\tint32_t graph[V][V];\n\tint32_t path[V];\t\n\tfor(int i=0;i<V;i++){\n\t\tpath[i]=-1;\n\t}\n\tinitializeData(graph);\t\n\tdisplayGraph(graph);\n  minSpanTree(graph,path);\n\n\t// displayPath(source,destination,path);\n\t// displayGraph1(graph, path);\n\tdisplayTree(graph, path);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "// local variable allocation has failed, the output may be wrong!\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int32_t v3[98]; // [rsp-188h] [rbp-11D0h] BYREF\n  _BYTE path[32]; // [rsp+1008h] [rbp-40h] OVERLAPPED BYREF\n  __int64 v5; // [rsp+1028h] [rbp-20h]\n  unsigned __int64 v6; // [rsp+1030h] [rbp-18h]\n\n  v6 = __readfsqword(0x28u);\n  memset(path, 255, sizeof(path));\n  v5 = -1LL;\n  initializeData((int32_t (*)[1])v3);\n  displayGraph((int32_t (*)[1])v3);\n  minSpanTree((int32_t (*)[1])v3, (int32_t *)path);\n  displayTree((int32_t (*)[1])v3, (int32_t *)path);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int32_t v3[98];\n  uint8_t path[32];\n  long long v5;\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  memset(path, 255, sizeof(path));\n  v5 = -1LL;\n  initializeData((int32_t(*)[1])v3);\n  displayGraph((int32_t(*)[1])v3);\n  minSpanTree((int32_t(*)[1])v3, (int32_t *)path);\n  displayTree((int32_t(*)[1])v3, (int32_t *)path);\n  libmin_success();\n}", "binary": "minspan/minspan.host.O2", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    %rsp,%rbp\npush   %r13\npush   %r12\nsub    $0x30,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,-0x18(%rbp)\nmov    %rsp,%rax\ncmp    %rax,%rsp\nje     113a <main+0x3a>\nsub    $0x1000,%rsp\norq    $0x0,0xff8(%rsp)\ncmp    %rax,%rsp\njne    1125 <main+0x25>\nsub    $0x190,%rsp\norq    $0x0,0x188(%rsp)\npcmpeqd %xmm0,%xmm0\nmov    %rsp,%r12\nmovups %xmm0,-0x40(%rbp)\nlea    -0x40(%rbp),%r13\nmov    %r12,%rdi\nmovups %xmm0,-0x30(%rbp)\nmovq   $0xffffffffffffffff,-0x20(%rbp)\ncall   1400 <initializeData>\nmov    %r12,%rdi\ncall   14f0 <displayGraph>\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   12f0 <minSpanTree>\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   17a0 <displayTree>\ncall   31d0 <libmin_success>\nmov    -0x18(%rbp),%rax\nsub    %fs:0x28,%rax\njne    11ab <main+0xab>\nlea    -0x10(%rbp),%rsp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %rbp\nret\ncall   10b0 <__stack_chk_fail@plt>\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "minSpanTree", "content": "// find the shortest path from the source to all other vertexes\nvoid\nminSpanTree(int32_t graph[V][V], int32_t path[V])\n{\n\tint32_t dist[V];\n\n  // KNOWN[I] set to true when the algorithm has linked node I into the minimal spanning tree being built\n\tint known[V];\n\tint32_t min = 0;\n\t\n\tfor (int i=0; i<V; i++)\n  {\n\t\tif (min == i)\n    {\n\t\t\tdist[i] = 0;\n\t\t\tknown[i] = TRUE;\n\t\t}\n    else\n    {\n\t\t\tdist[i] = INT_MAX;\n\t\t\tknown[i] = FALSE;\n\t\t}\n\t}\n\t\t\n\tfor (int i=0;i<V;i++)\n  {\n\t\tfor (int j = 0;j<V;j++)\n    {\n\t\t\tif (!known[j] && (graph[min][j] != 0) && (graph[min][j] < dist[j]))\n      {\n\t\t\t\tdist[j] = graph[min][j];\n\t\t\t\tpath[j] = min;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tmin = minVal(dist, known);\n\t}\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O2.pseudo", "function_name": "minSpanTree", "address": "0x12f0", "label": "minSpanTree", "content": "void __fastcall minSpanTree(int32_t (*graph)[1], int32_t *path)\n{\n  __int64 i; // rax\n  int v4; // r9d\n  int32_t v5; // edi\n  __int64 j; // rax\n  int32_t v7; // edx\n  __int64 v8; // rax\n  int32_t v9; // ecx\n  int32_t dist[12]; // [rsp+0h] [rbp-68h]\n  int known[10]; // [rsp+30h] [rbp-38h]\n  unsigned __int64 v12; // [rsp+58h] [rbp-10h]\n\n  v12 = __readfsqword(0x28u);\n  for ( i = 0LL; !i; ++i )\n  {\n    dist[0] = 0;\n    known[0] = 1;\nLABEL_3:\n    ;\n  }\n  dist[i] = 0x7FFFFFFF;\n  known[i] = 0;\n  if ( i != 9 )\n    goto LABEL_3;\n  v4 = 10;\n  v5 = 0;\n  do\n  {\n    for ( j = 0LL; j != 10; ++j )\n    {\n      if ( !known[j] )\n      {\n        v7 = (*graph)[10 * v5 + j];\n        if ( v7 )\n        {\n          if ( v7 < dist[j] )\n          {\n            dist[j] = v7;\n            path[j] = v5;\n          }\n        }\n      }\n    }\n    v8 = 0LL;\n    v5 = -1;\n    v9 = 0x7FFFFFFF;\n    do\n    {\n      if ( dist[v8] < v9 && !known[v8] )\n      {\n        v9 = dist[v8];\n        v5 = v8;\n      }\n      ++v8;\n    }\n    while ( v8 != 10 );\n    if ( v5 != -1 )\n      known[v5] = 1;\n    --v4;\n  }\n  while ( v4 );\n}\n"}, "pseudo_normalize": "void minSpanTree(int32_t (*graph)[1], int32_t *path) {\n  long long i;\n  int v4;\n  int32_t v5;\n  long long j;\n  int32_t v7;\n  long long v8;\n  int32_t v9;\n  int32_t dist[12];\n  int known[10];\n  unsigned long long v12;\n  v12 = __readfsqword(40u);\n  for (i = 0LL; !i; ++i) {\n    dist[0] = 0;\n    known[0] = 1;\n  LABEL_3:;\n  }\n  dist[i] = 2147483647;\n  known[i] = 0;\n  if (i != 9) goto LABEL_3;\n  v4 = 10;\n  v5 = 0;\n  do {\n    for (j = 0LL; j != 10; ++j) {\n      if (!known[j]) {\n        v7 = (*graph)[10 * v5 + j];\n        if (v7) {\n          if (v7 < dist[j]) {\n            dist[j] = v7;\n            path[j] = v5;\n          }\n        }\n      }\n    }\n    v8 = 0LL;\n    v5 = -1;\n    v9 = 2147483647;\n    do {\n      if (dist[v8] < v9 && !known[v8]) {\n        v9 = dist[v8];\n        v5 = v8;\n      }\n      ++v8;\n    } while (v8 != 10);\n    if (v5 != -1) known[v5] = 1;\n    --v4;\n  } while (v4);\n}", "binary": "minspan/minspan.host.O2", "assembly": "<minSpanTree>:\nendbr64\nsub    $0x68,%rsp\nmov    %rsi,%r11\nmov    %rdi,%r10\nmov    %fs:0x28,%rax\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r8\nlea    0x30(%rsp),%rsi\njmp    1339 <minSpanTree+0x49>\nnopl   0x0(%rax,%rax,1)\nmovl   $0x7fffffff,(%r8,%rax,4)\nmovl   $0x0,(%rsi,%rax,4)\ncmp    $0x9,%rax\nje     134f <minSpanTree+0x5f>\nadd    $0x1,%rax\ntest   %rax,%rax\njne    1320 <minSpanTree+0x30>\nmovl   $0x0,(%rsp)\nmovl   $0x1,0x30(%rsp)\njmp    1335 <minSpanTree+0x45>\nmov    $0xa,%r9d\nxor    %edi,%edi\nnopw   0x0(%rax,%rax,1)\nmovslq %edi,%rax\nlea    (%rax,%rax,4),%rax\nlea    (%r10,%rax,8),%rcx\nxor    %eax,%eax\nnopl   (%rax)\nmov    (%rsi,%rax,1),%edx\ntest   %edx,%edx\njne    1390 <minSpanTree+0xa0>\nmov    (%rcx,%rax,1),%edx\ntest   %edx,%edx\nje     1390 <minSpanTree+0xa0>\ncmp    (%r8,%rax,1),%edx\njge    1390 <minSpanTree+0xa0>\nmov    %edx,(%r8,%rax,1)\nmov    %edi,(%r11,%rax,1)\nnopl   0x0(%rax)\nadd    $0x4,%rax\ncmp    $0x28,%rax\njne    1370 <minSpanTree+0x80>\nxor    %eax,%eax\nmov    $0xffffffff,%edi\nmov    $0x7fffffff,%ecx\ncs nopw 0x0(%rax,%rax,1)\nmov    (%r8,%rax,4),%edx\ncmp    %ecx,%edx\njge    13c2 <minSpanTree+0xd2>\ncmpl   $0x0,(%rsi,%rax,4)\ncmove  %edx,%ecx\ncmove  %eax,%edi\nadd    $0x1,%rax\ncmp    $0xa,%rax\njne    13b0 <minSpanTree+0xc0>\ncmp    $0xffffffff,%edi\nje     13dc <minSpanTree+0xec>\nmovslq %edi,%rax\nmovl   $0x1,0x30(%rsp,%rax,4)\nsub    $0x1,%r9d\njne    1360 <minSpanTree+0x70>\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    13fb <minSpanTree+0x10b>\nadd    $0x68,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\n"}
{"source": {"path": "minspan/minspan.c", "function_name": "minVal", "content": "// find the vertex with min distance from the unknown vertexes\nint32_t\nminVal(int32_t *dist, int *known)\n{\n\tint32_t min = -1;\n\tint32_t distVal = INT_MAX;\n\t\t\t\n\tfor (int i=0; i<V; i++)\n  {\n\t\tif (distVal>dist[i] && !known[i])\n    {\n\t\t\tdistVal = dist[i];\n\t\t\tmin = i;\n\t\t}\t\t\t\t\t\n\t}\n\t\t\t\t\n  if (min != -1)\n    known[min] = TRUE;\n  return min;\n}\n"}, "pseudo": {"path": "minspan/minspan.host.O2.pseudo", "function_name": "minVal", "address": "0x12a0", "label": "minVal", "content": "int32_t __fastcall minVal(int32_t *dist, int *known)\n{\n  __int64 v2; // rax\n  int32_t v3; // ecx\n  int32_t v4; // r8d\n\n  v2 = 0LL;\n  v3 = 0x7FFFFFFF;\n  v4 = -1;\n  do\n  {\n    if ( dist[v2] < v3 && !known[v2] )\n    {\n      v3 = dist[v2];\n      v4 = v2;\n    }\n    ++v2;\n  }\n  while ( v2 != 10 );\n  if ( v4 != -1 )\n    known[v4] = 1;\n  return v4;\n}\n"}, "pseudo_normalize": "int32_t minVal(int32_t *dist, int *known) {\n  long long v2;\n  int32_t v3;\n  int32_t v4;\n  v2 = 0LL;\n  v3 = 2147483647;\n  v4 = -1;\n  do {\n    if (dist[v2] < v3 && !known[v2]) {\n      v3 = dist[v2];\n      v4 = v2;\n    }\n    ++v2;\n  } while (v2 != 10);\n  if (v4 != -1) known[v4] = 1;\n  return v4;\n}", "binary": "minspan/minspan.host.O2", "assembly": "<minVal>:\nendbr64\nxor    %eax,%eax\nmov    $0x7fffffff,%ecx\nmov    $0xffffffff,%r8d\nnopl   0x0(%rax)\nmov    (%rdi,%rax,4),%edx\ncmp    %ecx,%edx\njge    12cd <minVal+0x2d>\nmov    (%rsi,%rax,4),%r9d\ntest   %r9d,%r9d\ncmove  %edx,%ecx\ncmove  %eax,%r8d\nadd    $0x1,%rax\ncmp    $0xa,%rax\njne    12b8 <minVal+0x18>\ncmp    $0xffffffff,%r8d\nje     12e7 <minVal+0x47>\nmovslq %r8d,%rax\nmovl   $0x1,(%rsi,%rax,4)\nmov    %r8d,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "monte-carlo/monte-carlo.c", "function_name": "main", "content": "#include \"libmin.h\"\n\n#define NUM_SAMPLES 25000  // samples\n\nint\nmain(void)\n{\n  int count_inside_circle = 0;\n  double x, y;\n\n  // Seed the random number generator\n  libmin_srand(42);\n\n  for (int i = 0; i < NUM_SAMPLES; ++i)\n  {\n    // Generate random (x, y) point in [0, 1]  [0, 1]\n    x = (double)libmin_rand() / RAND_MAX;\n    y = (double)libmin_rand() / RAND_MAX;\n\n    // Check if the point is inside the unit circle\n    if (x*x + y*y <= 1.0)\n      count_inside_circle++;\n  }\n\n  // Estimate Pi\n  double pi_estimate = 4.0 * count_inside_circle / NUM_SAMPLES;\n\n  // Output result\n  libmin_printf(\"Estimated Pi = %.8f\\n\", pi_estimate);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "monte-carlo/monte-carlo.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebp\n  int v4; // ebx\n  signed int v5; // eax\n  double x; // [rsp+8h] [rbp-20h]\n\n  v3 = 0;\n  v4 = 25000;\n  libmin_srand(0x2Au);\n  do\n  {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    v5 = libmin_rand();\n    v3 -= (x * x + (double)v5 / 2147483647.0 * ((double)v5 / 2147483647.0) > 1.0) - 1;\n    --v4;\n  }\n  while ( v4 );\n  libmin_printf(\"Estimated Pi = %.8f\\n\", (double)v3 * 4.0 / 25000.0);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  signed int v5;\n  double x;\n  v3 = 0;\n  v4 = 25000;\n  libmin_srand(42u);\n  do {\n    x = (double)(int)libmin_rand() / 2147483647.0;\n    v5 = libmin_rand();\n    v3 -= (x * x + (double)v5 / 2147483647.0 * ((double)v5 / 2147483647.0) >\n           1.0) -\n          1;\n    --v4;\n  } while (v4);\n  libmin_printf(\"Estimated Pi = %.8f\\n\", (double)v3 * 4.0 / 25000.0);\n  libmin_success();\n}", "binary": "monte-carlo/monte-carlo.host.O2", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    $0x2a,%edi\nxor    %ebp,%ebp\npush   %rbx\nmov    $0x61a8,%ebx\nsub    $0x18,%rsp\ncall   2a00 <libmin_srand>\nnopl   0x0(%rax,%rax,1)\ncall   2a60 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x1ee8(%rip),%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncall   2a60 <libmin_rand>\nmovsd  0x8(%rsp),%xmm0\npxor   %xmm1,%xmm1\nmovsd  0x1ed3(%rip),%xmm2\nmov    %eax,%eax\nmulsd  %xmm0,%xmm0\ncvtsi2sd %rax,%xmm1\ndivsd  0x1eb8(%rip),%xmm1\nmulsd  %xmm1,%xmm1\naddsd  %xmm1,%xmm0\ncomisd %xmm0,%xmm2\nsbb    $0xffffffff,%ebp\nsub    $0x1,%ebx\njne    1120 <main+0x20>\npxor   %xmm0,%xmm0\nlea    0x1e7d(%rip),%rdi\nmov    $0x1,%eax\ncvtsi2sd %ebp,%xmm0\nmulsd  0x1e98(%rip),%xmm0\ndivsd  0x1e98(%rip),%xmm0\ncall   27f0 <libmin_printf>\ncall   2c40 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "murmur-hash/murmur-hash.c", "function_name": "main", "content": "int\nmain(void)\n{\n    uint32_t seed = 0;\n\n    {\n      const char *key = \"kinkajou\"; // 0xb6d99cf8\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    {\n      const char *key = \"The bringup-bench benchmark MURMUR made this.\";\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    {\n      const char *key = \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\";\n      uint32_t hash = murmurhash(key, (uint32_t)libmin_strlen(key), seed);\n      libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", key, hash);\n    }\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "murmur-hash/murmur-hash.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  uint32_t v3; // eax\n  uint32_t v4; // eax\n  uint32_t v5; // eax\n  uint32_t v6; // eax\n  uint32_t v7; // eax\n  uint32_t v8; // eax\n\n  v3 = libmin_strlen(\"kinkajou\");\n  v4 = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", v4);\n  v5 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  v6 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v5, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"The bringup-bench benchmark MURMUR made this.\", v6);\n  v7 = libmin_strlen(\"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\");\n  v8 = murmurhash(\n         \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n         v7,\n         0);\n  libmin_printf(\n    \"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n    \"It has to start somewhere, it has to start sometime, what better place than here? What better time than now?\",\n    v8);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  uint32_t v3;\n  uint32_t v4;\n  uint32_t v5;\n  uint32_t v6;\n  uint32_t v7;\n  uint32_t v8;\n  v3 = libmin_strlen(\"kinkajou\");\n  v4 = murmurhash(\"kinkajou\", v3, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\", \"kinkajou\", v4);\n  v5 = libmin_strlen(\"The bringup-bench benchmark MURMUR made this.\");\n  v6 = murmurhash(\"The bringup-bench benchmark MURMUR made this.\", v5, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"The bringup-bench benchmark MURMUR made this.\", v6);\n  v7 = libmin_strlen(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\");\n  v8 = murmurhash(\n      \"It has to start somewhere, it has to start sometime, what better place \"\n      \"than here? What better time than now?\",\n      v7, 0);\n  libmin_printf(\"murmurhash(\\\"%s\\\") = 0x%x\\n\",\n                \"It has to start somewhere, it has to start sometime, what \"\n                \"better place than here? What better time than now?\",\n                v8);\n  libmin_success();\n}", "binary": "murmur-hash/murmur-hash.host.O2", "assembly": "<main>:\nendbr64\npush   %r12\nlea    0x1f1b(%rip),%r12\npush   %rbp\nlea    0x1eef(%rip),%rbp\nmov    %rbp,%rdi\nsub    $0x8,%rsp\ncall   2ab0 <libmin_strlen>\nmov    %rbp,%rdi\nxor    %edx,%edx\nmov    %eax,%esi\ncall   1290 <murmurhash>\nmov    %rbp,%rsi\nlea    0x1ed6(%rip),%rbp\nmov    %eax,%edx\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   28a0 <libmin_printf>\nmov    %r12,%rdi\ncall   2ab0 <libmin_strlen>\nmov    %r12,%rdi\nxor    %edx,%edx\nmov    %eax,%esi\ncall   1290 <murmurhash>\nmov    %r12,%rsi\nmov    %rbp,%rdi\nlea    0x1ef4(%rip),%r12\nmov    %eax,%edx\nxor    %eax,%eax\ncall   28a0 <libmin_printf>\nmov    %r12,%rdi\ncall   2ab0 <libmin_strlen>\nmov    %r12,%rdi\nxor    %edx,%edx\nmov    %eax,%esi\ncall   1290 <murmurhash>\nmov    %r12,%rsi\nmov    %rbp,%rdi\nmov    %eax,%edx\nxor    %eax,%eax\ncall   28a0 <libmin_printf>\ncall   2ae0 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\nnop\n"}
{"source": {"path": "murmur-hash/murmur-hash.c", "function_name": "murmurhash", "content": "/**\n * `murmurhash.h' - murmurhash\n *\n * copyright (c) 2014-2022 joseph werle <joseph.werle@gmail.com>\n */\n\nuint32_t\nmurmurhash (const char *key, uint32_t len, uint32_t seed)\n{\n  uint32_t c1 = 0xcc9e2d51;\n  uint32_t c2 = 0x1b873593;\n  uint32_t r1 = 15;\n  uint32_t r2 = 13;\n  uint32_t m = 5;\n  uint32_t n = 0xe6546b64;\n  uint32_t h = 0;\n  uint32_t k = 0;\n  uint8_t *d = (uint8_t *) key; // 32 bit extract from `key'\n  const uint32_t *chunks = NULL;\n  const uint8_t *tail = NULL; // tail - last 8 bytes\n  int i = 0;\n  int l = len / 4; // chunk length\n\n  h = seed;\n\n  chunks = (const uint32_t *) (d + l * 4); // body\n  tail = (const uint8_t *) (d + l * 4); // last 8 byte chunk of `key'\n\n  // for each 4 byte chunk of `key'\n  for (i = -l; i != 0; ++i) {\n    // next 4 byte chunk of `key'\n    k = chunks[i];\n\n    // encode next 4 byte chunk of `key'\n    k *= c1;\n    k = (k << r1) | (k >> (32 - r1));\n    k *= c2;\n\n    // append to hash\n    h ^= k;\n    h = (h << r2) | (h >> (32 - r2));\n    h = h * m + n;\n  }\n\n  k = 0;\n\n  // remainder\n  switch (len & 3) { // `len % 4'\n    case 3: k ^= (tail[2] << 16);\n    case 2: k ^= (tail[1] << 8);\n\n    case 1:\n      k ^= tail[0];\n      k *= c1;\n      k = (k << r1) | (k >> (32 - r1));\n      k *= c2;\n      h ^= k;\n  }\n\n  h ^= len;\n\n  h ^= (h >> 16);\n  h *= 0x85ebca6b;\n  h ^= (h >> 13);\n  h *= 0xc2b2ae35;\n  h ^= (h >> 16);\n\n  return h;\n}\n"}, "pseudo": {"path": "murmur-hash/murmur-hash.host.O2.pseudo", "function_name": "murmurhash", "address": "0x1290", "label": "murmurhash", "content": "uint32_t __fastcall murmurhash(const char *key, uint32_t len, uint32_t seed)\n{\n  uint32_t v5; // r8d\n  uint32_t v7; // edx\n  const char *v8; // rsi\n  __int64 v9; // rdx\n  int v10; // eax\n  uint32_t v11; // eax\n  uint32_t v12; // edx\n  int v14; // edx\n  int v15; // eax\n\n  v5 = len >> 2;\n  v7 = len >> 2;\n  v8 = &key[len & 0xFFFFFFFC];\n  LODWORD(v9) = -v7;\n  if ( v5 )\n  {\n    v9 = (int)v9;\n    do\n    {\n      v10 = -862048943 * *(_DWORD *)&v8[4 * v9++];\n      seed = 5 * __ROL4__(seed ^ (461845907 * __ROL4__(v10, 15)), 13) - 430675100;\n    }\n    while ( (_DWORD)v9 );\n  }\n  v11 = len & 3;\n  switch ( v11 )\n  {\n    case 2u:\n      v15 = 0;\n      goto LABEL_11;\n    case 3u:\n      v15 = *((unsigned __int8 *)v8 + 2) << 16;\nLABEL_11:\n      v14 = v15 ^ (*((unsigned __int8 *)v8 + 1) << 8);\n      goto LABEL_9;\n    case 1u:\n      v14 = 0;\nLABEL_9:\n      seed ^= 461845907 * __ROL4__(-862048943 * (v14 ^ *(unsigned __int8 *)v8), 15);\n      break;\n  }\n  v12 = -1028477387\n      * ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) ^ ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) >> 13));\n  return v12 ^ HIWORD(v12);\n}\n"}, "pseudo_normalize": "uint32_t murmurhash(const char *key, uint32_t len, uint32_t seed) {\n  uint32_t v5;\n  uint32_t v7;\n  const char *v8;\n  long long v9;\n  int v10;\n  uint32_t v11;\n  uint32_t v12;\n  int v14;\n  int v15;\n  v5 = len >> 2;\n  v7 = len >> 2;\n  v8 = &key[len & 4294967292];\n  LODWORD(v9) = -v7;\n  if (v5) {\n    v9 = (int)v9;\n    do {\n      v10 = -862048943 * *(uint32_t *)&v8[4 * v9++];\n      seed =\n          5 * __ROL4__(seed ^ (461845907 * __ROL4__(v10, 15)), 13) - 430675100;\n    } while ((uint32_t)v9);\n  }\n  v11 = len & 3;\n  switch (v11) {\n    case 2u:\n      v15 = 0;\n      goto LABEL_11;\n    case 3u:\n      v15 = *((unsigned char *)v8 + 2) << 16;\n    LABEL_11:\n      v14 = v15 ^ (*((unsigned char *)v8 + 1) << 8);\n      goto LABEL_9;\n    case 1u:\n      v14 = 0;\n    LABEL_9:\n      seed ^=\n          461845907 * __ROL4__(-862048943 * (v14 ^ *(unsigned char *)v8), 15);\n      break;\n  }\n  v12 = -1028477387 *\n        ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) ^\n         ((-2048144789 * (len ^ seed ^ ((len ^ seed) >> 16))) >> 13));\n  return v12 ^ HIWORD(v12);\n}", "binary": "murmur-hash/murmur-hash.host.O2", "assembly": "<murmurhash>:\nendbr64\nmov    %esi,%r8d\nmov    %esi,%eax\nmov    %rdi,%r9\nmov    %edx,%ecx\nshr    $0x2,%r8d\nand    $0xfffffffc,%eax\nmov    %esi,%edi\ncltq\nmov    %r8d,%edx\nlea    (%r9,%rax,1),%rsi\nneg    %edx\ntest   %r8d,%r8d\nje     12e4 <murmurhash+0x54>\nmovslq %edx,%rdx\nnopw   0x0(%rax,%rax,1)\nimul   $0xcc9e2d51,(%rsi,%rdx,4),%eax\nadd    $0x1,%rdx\nrol    $0xf,%eax\nimul   $0x1b873593,%eax,%eax\nxor    %ecx,%eax\nrol    $0xd,%eax\nlea    -0x19ab949c(%rax,%rax,4),%ecx\ntest   %edx,%edx\njne    12c0 <murmurhash+0x30>\nmov    %edi,%eax\nand    $0x3,%eax\ncmp    $0x2,%eax\nje     1358 <murmurhash+0xc8>\ncmp    $0x3,%eax\nje     1340 <murmurhash+0xb0>\ncmp    $0x1,%eax\nje     1320 <murmurhash+0x90>\nxor    %edi,%ecx\nmov    %ecx,%eax\nshr    $0x10,%eax\nxor    %ecx,%eax\nimul   $0x85ebca6b,%eax,%eax\nmov    %eax,%edx\nshr    $0xd,%edx\nxor    %eax,%edx\nimul   $0xc2b2ae35,%edx,%edx\nmov    %edx,%eax\nshr    $0x10,%eax\nxor    %edx,%eax\nret\nnopl   0x0(%rax)\nxor    %edx,%edx\nmovzbl (%rsi),%eax\nxor    %edx,%eax\nimul   $0xcc9e2d51,%eax,%eax\nrol    $0xf,%eax\nimul   $0x1b873593,%eax,%eax\nxor    %eax,%ecx\njmp    12f8 <murmurhash+0x68>\nnopw   0x0(%rax,%rax,1)\nmovzbl 0x2(%rsi),%eax\nshl    $0x10,%eax\nmovzbl 0x1(%rsi),%edx\nshl    $0x8,%edx\nxor    %eax,%edx\njmp    1322 <murmurhash+0x92>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\njmp    1347 <murmurhash+0xb7>\nnopl   0x0(%rax)\n"}
{"source": {"path": "n-queens/n-queens.c", "function_name": "is_safe", "content": "// Check if placing a queen at (row, col) is safe\nint\nis_safe(int queens[], int row, int col)\n{\n  for (int i = 0; i < row; i++)\n  {\n    int q_col = queens[i];\n    if (q_col == col || libmin_abs(q_col - col) == libmin_abs(i - row))\n      return FALSE;\n  }\n  return TRUE;\n}\n"}, "pseudo": {"path": "n-queens/n-queens.host.O2.pseudo", "function_name": "is_safe", "address": "0x1260", "label": "is_safe", "content": "int __fastcall is_safe(int *queens, int row, int col)\n{\n  int v5; // ebx\n  int v6; // ebp\n\n  if ( row <= 0 )\n    return 1;\n  v5 = -row;\n  do\n  {\n    if ( *queens == col )\n      return 0;\n    v6 = libmin_abs(*queens - col);\n    if ( v6 == libmin_abs(v5) )\n      return 0;\n    ++queens;\n    ++v5;\n  }\n  while ( v5 );\n  return 1;\n}\n"}, "pseudo_normalize": "int is_safe(int *queens, int row, int col) {\n  int v5;\n  int v6;\n  if (row <= 0) return 1;\n  v5 = -row;\n  do {\n    if (*queens == col) return 0;\n    v6 = libmin_abs(*queens - col);\n    if (v6 == libmin_abs(v5)) return 0;\n    ++queens;\n    ++v5;\n  } while (v5);\n  return 1;\n}", "binary": "n-queens/n-queens.host.O2", "assembly": "<is_safe>:\nendbr64\ntest   %esi,%esi\njle    12c8 <is_safe+0x68>\npush   %r13\nmov    %rdi,%r13\npush   %r12\nmov    %edx,%r12d\npush   %rbp\npush   %rbx\nmov    %esi,%ebx\nneg    %ebx\nsub    $0x8,%rsp\njmp    129e <is_safe+0x3e>\nxchg   %ax,%ax\nsub    %r12d,%edi\ncall   1570 <libmin_abs>\nmov    %ebx,%edi\nmov    %eax,%ebp\ncall   1570 <libmin_abs>\ncmp    %eax,%ebp\nje     12a7 <is_safe+0x47>\nadd    $0x4,%r13\nadd    $0x1,%ebx\nje     12b8 <is_safe+0x58>\nmov    0x0(%r13),%edi\ncmp    %r12d,%edi\njne    1280 <is_safe+0x20>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nmov    $0x1,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nmov    $0x1,%eax\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "n-queens/n-queens.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int *queens = (int *)libmin_malloc(BOARD_SIZE * sizeof(int));\n\n  solve(queens, 0);\n\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", BOARD_SIZE, solution_count);\n\n  libmin_free(queens);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "n-queens/n-queens.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // rbp\n\n  v3 = (int *)libmin_malloc(0x28uLL);\n  solve(v3, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(v3);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  v3 = (int *)libmin_malloc(40uLL);\n  solve(v3, 0);\n  libmin_printf(\"Total solutions for %d-Queens: %d\\n\", 10, solution_count);\n  libmin_free(v3);\n  libmin_success();\n}", "binary": "n-queens/n-queens.host.O2", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    $0x28,%edi\ncall   1610 <libmin_malloc>\nxor    %esi,%esi\nmov    %rax,%rdi\nmov    %rax,%rbp\ncall   12d0 <solve>\nmov    0x412a(%rip),%edx\nmov    $0xa,%esi\nxor    %eax,%eax\nlea    0x1eb8(%rip),%rdi\ncall   2bb0 <libmin_printf>\nmov    %rbp,%rdi\ncall   16c0 <libmin_free>\ncall   2df0 <libmin_success>\nxor    %eax,%eax\npop    %rbp\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "n-queens/n-queens.c", "function_name": "solve", "content": "// Recursive backtracking solver\nvoid\nsolve(int queens[], int row)\n{\n  if (row == BOARD_SIZE)\n  {\n    solution_count++;\n    return;\n  }\n  for (int col = 0; col < BOARD_SIZE; col++)\n  {\n    if (is_safe(queens, row, col))\n    {\n      queens[row] = col;\n      solve(queens, row + 1);\n    }\n  }\n}\n"}, "pseudo": {"path": "n-queens/n-queens.host.O2.pseudo", "function_name": "solve", "address": "0x12d0", "label": "solve", "content": "void __fastcall solve(int *queens, int row)\n{\n  int i; // r14d\n  int *v3; // r13\n  int v4; // ebx\n  int v5; // r15d\n\n  if ( row == 10 )\n  {\n    ++solution_count;\n  }\n  else\n  {\n    for ( i = 0; i != 10; ++i )\n    {\n      while ( 1 )\n      {\n        v3 = queens;\n        v4 = -row;\n        if ( row > 0 )\n          break;\nLABEL_10:\n        queens[row] = i++;\n        solve(queens, row + 1);\n        if ( i == 10 )\n          return;\n      }\n      while ( *v3 != i )\n      {\n        v5 = libmin_abs(*v3 - i);\n        if ( v5 == libmin_abs(v4) )\n          break;\n        ++v3;\n        if ( !++v4 )\n          goto LABEL_10;\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "void solve(int *queens, int row) {\n  int i;\n  int *v3;\n  int v4;\n  int v5;\n  if (row == 10) {\n    ++solution_count;\n  } else {\n    for (i = 0; i != 10; ++i) {\n      while (1) {\n        v3 = queens;\n        v4 = -row;\n        if (row > 0) break;\n      LABEL_10:\n        queens[row] = i++;\n        solve(queens, row + 1);\n        if (i == 10) return;\n      }\n      while (*v3 != i) {\n        v5 = libmin_abs(*v3 - i);\n        if (v5 == libmin_abs(v4)) break;\n        ++v3;\n        if (!++v4) goto LABEL_10;\n      }\n    }\n  }\n}", "binary": "n-queens/n-queens.host.O2", "assembly": "<solve>:\nendbr64\ncmp    $0xa,%esi\nje     137f <solve+0xaf>\npush   %r15\nmovslq %esi,%rax\npush   %r14\nlea    (%rdi,%rax,4),%rax\nxor    %r14d,%r14d\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %esi,%ebp\npush   %rbx\nsub    $0x18,%rsp\nmov    %rax,(%rsp)\nlea    0x1(%rsi),%eax\nmov    %eax,0xc(%rsp)\nnopl   (%rax)\nmov    %ebp,%ebx\nmov    %r12,%r13\nneg    %ebx\ntest   %ebp,%ebp\njg     1338 <solve+0x68>\njmp    1360 <solve+0x90>\nnopl   (%rax)\nsub    %r14d,%edi\ncall   1570 <libmin_abs>\nmov    %ebx,%edi\nmov    %eax,%r15d\ncall   1570 <libmin_abs>\ncmp    %eax,%r15d\nje     1341 <solve+0x71>\nadd    $0x4,%r13\nadd    $0x1,%ebx\nje     1360 <solve+0x90>\nmov    0x0(%r13),%edi\ncmp    %r14d,%edi\njne    1318 <solve+0x48>\nadd    $0x1,%r14d\ncmp    $0xa,%r14d\njne    1308 <solve+0x38>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    (%rsp),%rax\nmov    0xc(%rsp),%esi\nmov    %r12,%rdi\nmov    %r14d,(%rax)\nadd    $0x1,%r14d\ncall   12d0 <solve>\ncmp    $0xa,%r14d\njne    1308 <solve+0x38>\njmp    134b <solve+0x7b>\naddl   $0x1,0x3ee6(%rip)\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "natlog/natlog.c", "function_name": "main", "content": "#include \"libmin.h\"\n\n/* calculate e=2.718..., using an interative approximation */\n\nint\nmain(void)\n{\n  /* STEPS is usually a very large number eg 10000000 */\n  int steps = 100000;\n  double x, y;\n\n  y = 1.0 + 1.0/steps;\n  x = 1.0;\n\n  for(; steps > 0; steps--)\n    x *= y;\n\n  libmin_printf(\"natlog: e=%f\\n\", x);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "natlog/natlog.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm0_8\n  int v4; // eax\n\n  v3 = 1.0;\n  v4 = 100000;\n  do\n  {\n    v3 = v3 * 1.00001;\n    --v4;\n  }\n  while ( v4 );\n  libmin_printf(\"natlog: e=%f\\n\", v3);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  int v4;\n  v3 = 1.0;\n  v4 = 100000;\n  do {\n    v3 = v3 * 1.00001;\n    --v4;\n  } while (v4);\n  libmin_printf(\"natlog: e=%f\\n\", v3);\n  libmin_success();\n}", "binary": "natlog/natlog.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nmovsd  0x1f08(%rip),%xmm0\nmov    $0x186a0,%eax\nmovsd  0x1f03(%rip),%xmm1\nnopl   (%rax)\nmulsd  %xmm1,%xmm0\nsub    $0x1,%eax\njne    1120 <main+0x20>\nlea    0x1ed4(%rip),%rdi\nmov    $0x1,%eax\ncall   2780 <libmin_printf>\ncall   29c0 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "nbody-sim/nbody-sim.c", "function_name": "main", "content": "int main(void) {\n    // Initialize three particles with arbitrary masses, positions (in meters), and velocities (in m/s)\n    Particle bodies[N_BODIES] = {\n        {1e24, {0.0,    0.0,    0.0},    {0.0,    0.0, 0.0}},      // Body 0\n        {1e24, {1e8,    0.0,    0.0},    {0.0,  1e3, 0.0}},      // Body 1\n        {1e24, {0.0,    1e8,    0.0},    {-1e3,   0.0, 0.0}}       // Body 2\n    };\n\n    // Time integration loop using Euler integration\n    for (int step = 0; step < NUM_STEPS; step++) {\n        // Array to store computed accelerations for each particle\n        double acc[N_BODIES][3] = { {0.0} };\n        \n        // Compute gravitational acceleration for each particle\n        for (int i = 0; i < N_BODIES; i++) {\n            for (int j = 0; j < N_BODIES; j++) {\n                if (i == j) \n                    continue; // Skip self-interaction\n                \n                // Compute difference vector between particle j and i\n                double dx = bodies[j].pos[0] - bodies[i].pos[0];\n                double dy = bodies[j].pos[1] - bodies[i].pos[1];\n                double dz = bodies[j].pos[2] - bodies[i].pos[2];\n                \n                // Compute squared distance (with softening factor to avoid division by zero)\n                double r2 = dx * dx + dy * dy + dz * dz + EPS;\n                double r = libmin_sqrt(r2);\n                \n                // Compute acceleration magnitude: a = G * m_j / r^2\n                // Multiply by (dx, dy, dz)/r to get the vector\n                double a = G * bodies[j].mass / r2;\n                acc[i][0] += a * (dx / r);\n                acc[i][1] += a * (dy / r);\n                acc[i][2] += a * (dz / r);\n            }\n        }\n        \n        // Update velocities and positions of each particle using the computed accelerations\n        for (int i = 0; i < N_BODIES; i++) {\n            bodies[i].vel[0] += acc[i][0] * DT;\n            bodies[i].vel[1] += acc[i][1] * DT;\n            bodies[i].vel[2] += acc[i][2] * DT;\n            \n            bodies[i].pos[0] += bodies[i].vel[0] * DT;\n            bodies[i].pos[1] += bodies[i].vel[1] * DT;\n            bodies[i].pos[2] += bodies[i].vel[2] * DT;\n        }\n    }\n\n    // Print final positions and velocities after the simulation\n    libmin_printf(\"Final state after %d steps:\\n\", NUM_STEPS);\n    for (int i = 0; i < N_BODIES; i++) {\n        libmin_printf(\"Body %d:\\n\", i);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", \n               bodies[i].pos[0], bodies[i].pos[1], bodies[i].pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", \n               bodies[i].vel[0], bodies[i].vel[1], bodies[i].vel[2]);\n    }\n    \n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "nbody-sim/nbody-sim.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Particle *v3; // r12\n  double *v4; // r15\n  int v5; // ebp\n  double *v6; // r13\n  Particle *v7; // r14\n  int j; // ebx\n  double v9; // xmm0_8\n  double v10; // xmm6_8\n  Particle *k; // rax\n  double v12; // xmm2_8\n  double v13; // xmm1_8\n  double v14; // xmm2_8\n  double v15; // xmm1_8\n  double v16; // xmm0_8\n  double v17; // xmm2_8\n  double v18; // xmm1_8\n  double v19; // xmm0_8\n  int v20; // ebx\n  int v21; // esi\n  double dz; // [rsp+8h] [rbp-178h]\n  double dy; // [rsp+10h] [rbp-170h]\n  double dx_0; // [rsp+18h] [rbp-168h]\n  double i; // [rsp+20h] [rbp-160h]\n  Particle *v26; // [rsp+30h] [rbp-150h]\n  int v27; // [rsp+3Ch] [rbp-144h]\n  double acc[3][3]; // [rsp+48h] [rbp-138h] BYREF\n  Particle bodies[3]; // [rsp+98h] [rbp-E8h] BYREF\n  unsigned __int64 v30; // [rsp+140h] [rbp-40h] BYREF\n\n  v30 = __readfsqword(0x28u);\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[1].vel[1] = 1000.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[2].vel[0] = -1000.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[2] = 0.0;\n  bodies[0].mass = 1.0e24;\n  bodies[1].mass = 1.0e24;\n  bodies[1].pos[0] = 100000000.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[1] = 100000000.0;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  v27 = 1000;\n  for ( i = 0.0; ; i = bodies[0].vel[0] )\n  {\n    v3 = bodies;\n    v4 = acc[0];\n    v5 = 0;\n    v26 = bodies;\n    v6 = acc[0];\n    memset(acc, 0, sizeof(acc));\n    do\n    {\n      v7 = bodies;\n      for ( j = 0; j != 3; ++j )\n      {\n        if ( v5 != j )\n        {\n          dx_0 = v7->pos[0] - v3->pos[0];\n          dy = v7->pos[1] - v3->pos[1];\n          dz = v7->pos[2] - v3->pos[2];\n          v9 = libmin_sqrt(dz);\n          v10 = 6.674299999999999e-11 * v7->mass / (dx_0 * dx_0 + dy * dy + dz * dz + 2.220446049250313e-16);\n          *v4 = dx_0 / v9 * v10 + *v4;\n          v4[1] = dy / v9 * v10 + v4[1];\n          v4[2] = dz / v9 * v10 + v4[2];\n        }\n        ++v7;\n      }\n      ++v5;\n      ++v3;\n      v4 += 3;\n    }\n    while ( v5 != 3 );\n    for ( k = bodies; ; i = k->vel[0] )\n    {\n      v12 = *v6;\n      v13 = v6[1];\n      ++k;\n      v6 += 3;\n      v14 = v12 * 0.01 + i;\n      v15 = v13 * 0.01 + k[-1].vel[1];\n      v16 = *(v6 - 1) * 0.01 + k[-1].vel[2];\n      k[-1].vel[0] = v14;\n      k[-1].vel[1] = v15;\n      v17 = v14 * 0.01 + k[-1].pos[0];\n      k[-1].vel[2] = v16;\n      v18 = v15 * 0.01 + k[-1].pos[1];\n      v19 = v16 * 0.01 + k[-1].pos[2];\n      k[-1].pos[0] = v17;\n      k[-1].pos[1] = v18;\n      k[-1].pos[2] = v19;\n      if ( k == (Particle *)&v30 )\n        break;\n    }\n    if ( !--v27 )\n    {\n      v20 = 0;\n      libmin_printf(\"Final state after %d steps:\\n\", 1000);\n      do\n      {\n        v21 = v20++;\n        libmin_printf(\"Body %d:\\n\", v21);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", v26->pos[0], v26->pos[1], v26->pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", v26->vel[0], v26->vel[1], v26->vel[2]);\n        ++v26;\n      }\n      while ( v20 != 3 );\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  Particle *v3;\n  double *v4;\n  int v5;\n  double *v6;\n  Particle *v7;\n  int j;\n  double v9;\n  double v10;\n  Particle *k;\n  double v12;\n  double v13;\n  double v14;\n  double v15;\n  double v16;\n  double v17;\n  double v18;\n  double v19;\n  int v20;\n  int v21;\n  double dz;\n  double dy;\n  double dx_0;\n  double i;\n  Particle *v26;\n  int v27;\n  double acc[3][3];\n  Particle bodies[3];\n  unsigned long long v30;\n  v30 = __readfsqword(40u);\n  bodies[0].pos[0] = 0.0;\n  bodies[0].pos[1] = 0.0;\n  bodies[1].vel[1] = 1000.0;\n  bodies[0].pos[2] = 0.0;\n  bodies[2].vel[0] = -1000.0;\n  bodies[0].vel[0] = 0.0;\n  bodies[0].vel[1] = 0.0;\n  bodies[0].vel[2] = 0.0;\n  bodies[1].pos[1] = 0.0;\n  bodies[1].pos[2] = 0.0;\n  bodies[1].vel[0] = 0.0;\n  bodies[1].vel[2] = 0.0;\n  bodies[2].pos[0] = 0.0;\n  bodies[2].pos[2] = 0.0;\n  bodies[0].mass = 1.0e24;\n  bodies[1].mass = 1.0e24;\n  bodies[1].pos[0] = 100000000.0;\n  bodies[2].mass = 1.0e24;\n  bodies[2].pos[1] = 100000000.0;\n  bodies[2].vel[1] = 0.0;\n  bodies[2].vel[2] = 0.0;\n  v27 = 1000;\n  for (i = 0.0;; i = bodies[0].vel[0]) {\n    v3 = bodies;\n    v4 = acc[0];\n    v5 = 0;\n    v26 = bodies;\n    v6 = acc[0];\n    memset(acc, 0, sizeof(acc));\n    do {\n      v7 = bodies;\n      for (j = 0; j != 3; ++j) {\n        if (v5 != j) {\n          dx_0 = v7->pos[0] - v3->pos[0];\n          dy = v7->pos[1] - v3->pos[1];\n          dz = v7->pos[2] - v3->pos[2];\n          v9 = libmin_sqrt(dz);\n          v10 = 6.674299999999999e-11 * v7->mass /\n                (dx_0 * dx_0 + dy * dy + dz * dz + 2.220446049250313e-16);\n          *v4 = dx_0 / v9 * v10 + *v4;\n          v4[1] = dy / v9 * v10 + v4[1];\n          v4[2] = dz / v9 * v10 + v4[2];\n        }\n        ++v7;\n      }\n      ++v5;\n      ++v3;\n      v4 += 3;\n    } while (v5 != 3);\n    for (k = bodies;; i = k->vel[0]) {\n      v12 = *v6;\n      v13 = v6[1];\n      ++k;\n      v6 += 3;\n      v14 = v12 * 0.01 + i;\n      v15 = v13 * 0.01 + k[-1].vel[1];\n      v16 = *(v6 - 1) * 0.01 + k[-1].vel[2];\n      k[-1].vel[0] = v14;\n      k[-1].vel[1] = v15;\n      v17 = v14 * 0.01 + k[-1].pos[0];\n      k[-1].vel[2] = v16;\n      v18 = v15 * 0.01 + k[-1].pos[1];\n      v19 = v16 * 0.01 + k[-1].pos[2];\n      k[-1].pos[0] = v17;\n      k[-1].pos[1] = v18;\n      k[-1].pos[2] = v19;\n      if (k == (Particle *)&v30) break;\n    }\n    if (!--v27) {\n      v20 = 0;\n      libmin_printf(\"Final state after %d steps:\\n\", 1000);\n      do {\n        v21 = v20++;\n        libmin_printf(\"Body %d:\\n\", v21);\n        libmin_printf(\"  Position = (%f, %f, %f) m\\n\", v26->pos[0], v26->pos[1],\n                      v26->pos[2]);\n        libmin_printf(\"  Velocity = (%f, %f, %f) m/s\\n\\n\", v26->vel[0],\n                      v26->vel[1], v26->vel[2]);\n        ++v26;\n      } while (v20 != 3);\n      libmin_success();\n    }\n  }\n}", "binary": "nbody-sim/nbody-sim.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\npxor   %xmm7,%xmm7\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x158,%rsp\nmovsd  0x1f47(%rip),%xmm0\nmovsd  0x1f47(%rip),%xmm1\nmov    %fs:0x28,%rax\nmov    %rax,0x148(%rsp)\nxor    %eax,%eax\nmov    0x1f35(%rip),%rax\nmovq   $0x0,0xa8(%rsp)\nmovq   $0x0,0xb0(%rsp)\nmov    %rax,0x100(%rsp)\nmov    0x1f16(%rip),%rax\nmovq   $0x0,0xb8(%rsp)\nmov    %rax,0x130(%rsp)\nlea    0xa0(%rsp),%rax\nmovq   $0x0,0xc0(%rsp)\nmovq   $0x0,0xc8(%rsp)\nmovq   $0x0,0xd0(%rsp)\nmovq   $0x0,0xe8(%rsp)\nmovq   $0x0,0xf0(%rsp)\nmovq   $0x0,0xf8(%rsp)\nmovq   $0x0,0x108(%rsp)\nmovq   $0x0,0x118(%rsp)\nmovq   $0x0,0x128(%rsp)\nmovsd  %xmm0,0xa0(%rsp)\nmovsd  %xmm0,0xd8(%rsp)\nmovsd  %xmm1,0xe0(%rsp)\nmovsd  %xmm0,0x110(%rsp)\nmovsd  %xmm1,0x120(%rsp)\nmovq   $0x0,0x138(%rsp)\nmovsd  0x1e65(%rip),%xmm5\nmov    %rax,0x30(%rsp)\nlea    0x50(%rsp),%rax\nmovq   $0x0,0x140(%rsp)\nmovl   $0x3e8,0x44(%rsp)\nmov    %rax,0x48(%rsp)\nmovsd  %xmm7,0x28(%rsp)\nnopl   0x0(%rax)\nmov    0x30(%rsp),%r12\nmov    0x48(%rsp),%r15\npxor   %xmm0,%xmm0\nxor    %ebp,%ebp\nmovq   $0x0,0x90(%rsp)\nmov    %r12,0x38(%rsp)\nmov    %r15,%r13\nmovaps %xmm0,0x50(%rsp)\nmovaps %xmm0,0x60(%rsp)\nmovaps %xmm0,0x70(%rsp)\nmovaps %xmm0,0x80(%rsp)\nmov    0x30(%rsp),%r14\nxor    %ebx,%ebx\ncmp    %ebx,%ebp\nje     1389 <main+0x289>\nmovsd  0x8(%r14),%xmm3\nmovsd  0x10(%r14),%xmm2\nsubsd  0x8(%r12),%xmm3\nsubsd  0x10(%r12),%xmm2\nmovsd  0x18(%r14),%xmm1\nsubsd  0x18(%r12),%xmm1\nmovapd %xmm3,%xmm4\nmovapd %xmm2,%xmm0\nmovsd  %xmm3,0x20(%rsp)\nmulsd  %xmm2,%xmm0\nmovsd  %xmm2,0x18(%rsp)\nmulsd  %xmm3,%xmm4\nmovsd  %xmm1,0x10(%rsp)\naddsd  %xmm0,%xmm4\nmovapd %xmm1,%xmm0\nmulsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm4\naddsd  0x1d7d(%rip),%xmm4\nmovapd %xmm4,%xmm0\nmovsd  %xmm4,0x8(%rsp)\ncall   2d60 <libmin_sqrt>\nmovsd  0x1d6e(%rip),%xmm6\nmulsd  (%r14),%xmm6\nmovsd  0x8(%rsp),%xmm4\nmovsd  0x20(%rsp),%xmm3\nmovsd  0x18(%rsp),%xmm2\nmovsd  0x10(%rsp),%xmm1\ndivsd  %xmm0,%xmm3\nmov    0x1d4e(%rip),%rax\nmovq   %rax,%xmm5\ndivsd  %xmm4,%xmm6\ndivsd  %xmm0,%xmm2\nmulsd  %xmm6,%xmm3\naddsd  (%r15),%xmm3\nmovsd  %xmm3,(%r15)\ndivsd  %xmm0,%xmm1\nmulsd  %xmm6,%xmm2\naddsd  0x8(%r15),%xmm2\nmovsd  %xmm2,0x8(%r15)\nmulsd  %xmm6,%xmm1\naddsd  0x10(%r15),%xmm1\nmovsd  %xmm1,0x10(%r15)\nadd    $0x1,%ebx\nadd    $0x38,%r14\ncmp    $0x3,%ebx\njne    12a2 <main+0x1a2>\nadd    $0x1,%ebp\nadd    $0x38,%r12\nadd    $0x18,%r15\ncmp    $0x3,%ebp\njne    129b <main+0x19b>\nmov    0x30(%rsp),%rax\nlea    0xa8(%rax),%rdx\nmovsd  0x0(%r13),%xmm2\nmovsd  0x8(%r13),%xmm1\nadd    $0x38,%rax\nadd    $0x18,%r13\nmovsd  -0x8(%r13),%xmm0\nmulsd  %xmm5,%xmm2\nmulsd  %xmm5,%xmm1\naddsd  0x28(%rsp),%xmm2\nmulsd  %xmm5,%xmm0\naddsd  -0x10(%rax),%xmm1\naddsd  -0x8(%rax),%xmm0\nmovsd  %xmm2,-0x18(%rax)\nmulsd  %xmm5,%xmm2\nmovsd  %xmm1,-0x10(%rax)\nmulsd  %xmm5,%xmm1\naddsd  -0x30(%rax),%xmm2\nmovsd  %xmm0,-0x8(%rax)\nmulsd  %xmm5,%xmm0\naddsd  -0x28(%rax),%xmm1\naddsd  -0x20(%rax),%xmm0\nmovsd  %xmm2,-0x30(%rax)\nmovsd  %xmm1,-0x28(%rax)\nmovsd  %xmm0,-0x20(%rax)\ncmp    %rdx,%rax\nje     1440 <main+0x340>\nmovsd  0x20(%rax),%xmm7\nmovsd  %xmm7,0x28(%rsp)\njmp    13b9 <main+0x2b9>\nnopl   (%rax)\nsubl   $0x1,0x44(%rsp)\nje     145b <main+0x35b>\nmovsd  0xc0(%rsp),%xmm7\nmovsd  %xmm7,0x28(%rsp)\njmp    1260 <main+0x160>\nmov    $0x3e8,%esi\nlea    0x1b9d(%rip),%rdi\nxor    %eax,%eax\nxor    %ebx,%ebx\ncall   2b50 <libmin_printf>\nlea    0x1baa(%rip),%r14\nlea    0x1bad(%rip),%r12\nlea    0x1bc3(%rip),%rbp\nmov    %ebx,%esi\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   2b50 <libmin_printf>\nmov    0x38(%rsp),%r15\nmov    %r12,%rdi\nmov    $0x3,%eax\nmovsd  0x8(%r15),%xmm0\nmovsd  0x18(%r15),%xmm2\nmovsd  0x10(%r15),%xmm1\ncall   2b50 <libmin_printf>\nmovsd  0x20(%r15),%xmm0\nmov    %rbp,%rdi\nmov    $0x3,%eax\nmovsd  0x30(%r15),%xmm2\nmovsd  0x28(%r15),%xmm1\ncall   2b50 <libmin_printf>\nmov    %r15,%rax\nadd    $0x38,%rax\nmov    %rax,0x38(%rsp)\ncmp    $0x3,%ebx\njne    1485 <main+0x385>\ncall   2fa0 <libmin_success>\nmov    0x148(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1514 <main+0x414>\nadd    $0x158,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10b0 <__stack_chk_fail@plt>\nnopl   0x0(%rax)\n"}
{"source": {"path": "nr-solver/nr-solver.c", "function_name": "f", "content": "#define FN_SQRT\n\n#ifdef FN_SQRT\ndouble\nf(double x)\n{\n  return x*x - sqrt_value;\n}\n"}, "pseudo": {"path": "nr-solver/nr-solver.host.O2.pseudo", "function_name": "f", "address": "0x12f0", "label": "f", "content": "double __fastcall f(double a1, double x)\n{\n  return a1 * a1 - sqrt_value;\n}\n"}, "pseudo_normalize": "", "binary": "nr-solver/nr-solver.host.O2", "assembly": "<f>:\nendbr64\nmulsd  %xmm0,%xmm0\nsubsd  0x4110(%rip),%xmm0\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "nr-solver/nr-solver.c", "function_name": "myfabs", "content": "#endif\n\n// get absolute value of the number given by user\ndouble myfabs(double num)\n{\n  if (num < 0.0)\n    return -num;\n  else\n    return num;\n}\n"}, "pseudo": {"path": "nr-solver/nr-solver.host.O2.pseudo", "function_name": "myfabs", "address": "0x1320", "label": "myfabs", "content": "double __fastcall myfabs(double result, double num)\n{\n  if ( result < 0.0 )\n    return -result;\n  return result;\n}\n"}, "pseudo_normalize": "", "binary": "nr-solver/nr-solver.host.O2", "assembly": "<myfabs>:\nendbr64\npxor   %xmm1,%xmm1\ncomisd %xmm0,%xmm1\nja     1330 <myfabs+0x10>\nret\nnop\nxorpd  0x1cf8(%rip),%xmm0\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "nr-solver/nr-solver.c", "function_name": "rn_solver", "content": "// calculate function value using Newton-Raphson method\ndouble rn_solver(int *converged, double maxerr, unsigned maxiter, fn_type f, fn_type df)\n{\n  unsigned iter;\n  double guess = 1.0;\n\n  *converged = FALSE;\n  for (iter = 0; iter < maxiter; iter++)\n  {\n      *converged = myfabs(f(guess)) <= maxerr;\n      if (*converged)\n        break;\n      guess = guess - f(guess)/df(guess);\n  }\n  // libmin_printf(\"niter == %u\\n\", iter);\n  return guess;\n}\n"}, "pseudo": {"path": "nr-solver/nr-solver.host.O2.pseudo", "function_name": "rn_solver", "address": "0x1340", "label": "rn_solver", "content": "double __fastcall rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f, fn_type df_0)\n{\n  int v8; // ebx\n  double v9; // xmm2_8\n  double v10; // xmm0_8\n  double v12; // [rsp+8h] [rbp-40h]\n\n  *converged = 0;\n  if ( !maxiter )\n    return 1.0;\n  v8 = 0;\n  v9 = 1.0;\n  do\n  {\n    v10 = f(v9);\n    if ( v10 < 0.0 )\n      v10 = -v10;\n    *converged = maxerr >= v10;\n    if ( maxerr >= v10 )\n      break;\n    ++v8;\n    v12 = f(v9);\n    v9 = v9 - v12 / df_0(v9);\n  }\n  while ( maxiter != v8 );\n  return v9;\n}\n"}, "pseudo_normalize": "double rn_solver(int *converged, double maxerr, unsigned int maxiter, fn_type f,\n                 fn_type df_0) {\n  int v8;\n  double v9;\n  double v10;\n  double v12;\n  *converged = 0;\n  if (!maxiter) return 1.0;\n  v8 = 0;\n  v9 = 1.0;\n  do {\n    v10 = f(v9);\n    if (v10 < 0.0) v10 = -v10;\n    *converged = maxerr >= v10;\n    if (maxerr >= v10) break;\n    ++v8;\n    v12 = f(v9);\n    v9 = v9 - v12 / df_0(v9);\n  } while (maxiter != v8);\n  return v9;\n}", "binary": "nr-solver/nr-solver.host.O2", "assembly": "<rn_solver>:\nendbr64\nmovl   $0x0,(%rdi)\ntest   %esi,%esi\nje     1401 <rn_solver+0xc1>\npush   %r15\nmovq   %xmm0,%r15\npush   %r14\nmov    %rcx,%r14\npush   %r13\nmov    %esi,%r13d\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %rdx,%rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x18,%rsp\nmovsd  0x1cc5(%rip),%xmm2\njmp    13b8 <rn_solver+0x78>\nnopl   (%rax)\nmovapd %xmm2,%xmm0\nmovsd  %xmm2,(%rsp)\nadd    $0x1,%ebx\ncall   *%rbp\nmovsd  (%rsp),%xmm2\nmovsd  %xmm0,0x8(%rsp)\nmovapd %xmm2,%xmm0\ncall   *%r14\nmovsd  0x8(%rsp),%xmm1\nmovsd  (%rsp),%xmm2\ndivsd  %xmm0,%xmm1\nsubsd  %xmm1,%xmm2\ncmp    %ebx,%r13d\nje     13ee <rn_solver+0xae>\nmovapd %xmm2,%xmm0\nmovsd  %xmm2,(%rsp)\ncall   *%rbp\npxor   %xmm4,%xmm4\nmovsd  (%rsp),%xmm2\ncomisd %xmm0,%xmm4\njbe    13da <rn_solver+0x9a>\nxorpd  0x1c56(%rip),%xmm0\nmovq   %r15,%xmm5\nxor    %eax,%eax\ncomisd %xmm0,%xmm5\nsetae  %al\nmov    %eax,(%r12)\njb     1380 <rn_solver+0x40>\nadd    $0x18,%rsp\nmovapd %xmm2,%xmm0\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmovsd  0x1c37(%rip),%xmm2\nmovapd %xmm2,%xmm0\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "check_packet_filter", "content": "// Check if the packet matches the filter criteria:\n// The packet should be using TCP and have a destination IP in the range 192.168.0.0/16.\nint check_packet_filter(Packet pkt) {\n    if (pkt.protocol != TCP_PROTOCOL) {\n        return FALSE;\n    }\n    // Extract the first two octets of the destination IP.\n    unsigned int first_octet = (pkt.dest_ip >> 24) & 0xFF;\n    unsigned int second_octet = (pkt.dest_ip >> 16) & 0xFF;\n    return (first_octet == FIXED_IP_FIRST && second_octet == FIXED_IP_SECOND);\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O2.pseudo", "function_name": "check_packet_filter", "address": "0x1430", "label": "check_packet_filter", "content": "__int64 __fastcall check_packet_filter(Packet pkt)\n{\n  __int64 result; // rax\n\n  result = 0LL;\n  if ( pkt.protocol == 6 )\n    return (BYTE2(pkt.dest_ip) == 0xA8) & (unsigned __int8)(HIBYTE(pkt.dest_ip) == 192);\n  return result;\n}\n"}, "pseudo_normalize": "long long check_packet_filter(Packet pkt) {\n  long long result;\n  result = 0LL;\n  if (pkt.protocol == 6)\n    return (BYTE2(pkt.dest_ip) == 168) &\n           (unsigned char)(HIBYTE(pkt.dest_ip) == 192);\n  return result;\n}", "binary": "packet-filter/packet-filter.host.O2", "assembly": "<check_packet_filter>:\nendbr64\nxor    %eax,%eax\ncmpb   $0x6,0x14(%rsp)\njne    145c <check_packet_filter+0x2c>\nmov    0xc(%rsp),%eax\nmov    %eax,%edx\nshr    $0x10,%edx\ncmp    $0xa8,%dl\nsete   %dl\nshr    $0x18,%eax\ncmp    $0xc0,%eax\nsete   %al\nmovzbl %al,%eax\nand    %edx,%eax\nret\nnopl   (%rax)\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "generate_packet", "content": "// Generate a random packet.\n// With ~5% probability, the packet will have the TCP protocol \n// and a destination IP within the range 192.168.0.0 - 192.168.255.255.\nPacket generate_packet() {\n    Packet pkt;\n    \n    if (libmin_rand() % 20 == 0) {\n        // Force matching criteria: destination IP in 192.168.x.x and TCP protocol.\n        pkt.dest_ip = ((unsigned int)FIXED_IP_FIRST << 24) |\n                      ((unsigned int)FIXED_IP_SECOND << 16) |\n                      (((unsigned int)libmin_rand() % 256) << 8) |\n                      ((unsigned int)libmin_rand() % 256);\n        pkt.protocol = TCP_PROTOCOL;\n    } else {\n        // Generate a random destination IP and a random protocol.\n        pkt.dest_ip = (unsigned int)libmin_rand();\n        pkt.protocol = (unsigned char)(libmin_rand() % 256);\n    }\n    \n    // Generate a random source IP.\n    pkt.src_ip = (unsigned int)libmin_rand();\n    \n    // Generate random source and destination ports.\n    pkt.src_port = (unsigned short)(libmin_rand() % 65536);\n    pkt.dest_port = (unsigned short)(libmin_rand() % 65536);\n    \n    // Fill the payload with 63 random uppercase characters and null-terminate.\n    for (int i = 0; i < 63; i++) {\n        pkt.payload[i] = 'A' + (libmin_rand() % 26);\n    }\n    pkt.payload[63] = '\\0';\n    \n    return pkt;\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O2.pseudo", "function_name": "generate_packet", "address": "0x12d0", "label": "generate_packet", "content": "Packet *__cdecl generate_packet(Packet *__return_ptr retstr)\n{\n  __int16 v1; // bx\n  char *v2; // r15\n  unsigned int v3; // r14d\n  __int16 v4; // r13\n  __int16 v5; // bp\n  __m128i si128; // xmm1\n  __m128i v7; // xmm2\n  __m128i v8; // xmm3\n  __m128i v9; // xmm4\n  __m128i v10; // xmm0\n  Packet pkt; // [rsp+8h] [rbp-A0h] BYREF\n  char v13; // [rsp+5Ch] [rbp-4Ch] BYREF\n  unsigned __int64 v14; // [rsp+68h] [rbp-40h]\n\n  v14 = __readfsqword(0x28u);\n  if ( __ROR4__(-858993459 * libmin_rand(), 2) > 0xCCCCCCCu )\n  {\n    pkt.src_ip = libmin_rand();\n    HIBYTE(pkt.dest_ip) = libmin_rand();\n  }\n  else\n  {\n    v1 = libmin_rand();\n    HIBYTE(pkt.dest_ip) = 6;\n    pkt.src_ip = (unsigned __int8)libmin_rand() | (unsigned __int16)(v1 << 8) | 0xC0A80000;\n  }\n  v2 = &pkt.payload[8];\n  v3 = libmin_rand();\n  v4 = libmin_rand();\n  v5 = libmin_rand();\n  do\n    *v2++ = libmin_rand() % 0x1A + 65;\n  while ( &v13 != v2 );\n  v13 = 0;\n  *(_DWORD *)&pkt.src_port = v3;\n  si128 = _mm_load_si128((const __m128i *)&pkt.payload[11]);\n  v7 = _mm_load_si128((const __m128i *)&pkt.payload[27]);\n  v8 = _mm_load_si128((const __m128i *)&pkt.payload[43]);\n  *(_DWORD *)&pkt.protocol = pkt.src_ip;\n  *(_WORD *)&pkt.payload[3] = v4;\n  *(_WORD *)&pkt.payload[5] = v5;\n  v9 = _mm_load_si128((const __m128i *)&pkt.payload[59]);\n  pkt.payload[7] = HIBYTE(pkt.dest_ip);\n  v10 = _mm_load_si128((const __m128i *)&pkt.src_port);\n  *(__m128i *)&retstr->payload[3] = si128;\n  *(__m128i *)&retstr->src_ip = v10;\n  *(__m128i *)&retstr->payload[19] = v7;\n  *(__m128i *)&retstr->payload[35] = v8;\n  *(__m128i *)&retstr->payload[51] = v9;\n  return retstr;\n}\n"}, "pseudo_normalize": "Packet *generate_packet(Packet *__return_ptr retstr) {\n  short v1;\n  char *v2;\n  unsigned int v3;\n  short v4;\n  short v5;\n  __m128i si128;\n  __m128i v7;\n  __m128i v8;\n  __m128i v9;\n  __m128i v10;\n  Packet pkt;\n  char v13;\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  if (__ROR4__(-858993459 * libmin_rand(), 2) > 214748364u) {\n    pkt.src_ip = libmin_rand();\n    HIBYTE(pkt.dest_ip) = libmin_rand();\n  } else {\n    v1 = libmin_rand();\n    HIBYTE(pkt.dest_ip) = 6;\n    pkt.src_ip =\n        (unsigned char)libmin_rand() | (unsigned short)(v1 << 8) | 3232235520;\n  }\n  v2 = &pkt.payload[8];\n  v3 = libmin_rand();\n  v4 = libmin_rand();\n  v5 = libmin_rand();\n  do *v2++ = libmin_rand() % 26 + 65;\n  while (&v13 != v2);\n  v13 = 0;\n  *(uint32_t *)&pkt.src_port = v3;\n  si128 = _mm_load_si128((const __m128i *)&pkt.payload[11]);\n  v7 = _mm_load_si128((const __m128i *)&pkt.payload[27]);\n  v8 = _mm_load_si128((const __m128i *)&pkt.payload[43]);\n  *(uint32_t *)&pkt.protocol = pkt.src_ip;\n  *(unsigned short *)&pkt.payload[3] = v4;\n  *(unsigned short *)&pkt.payload[5] = v5;\n  v9 = _mm_load_si128((const __m128i *)&pkt.payload[59]);\n  pkt.payload[7] = HIBYTE(pkt.dest_ip);\n  v10 = _mm_load_si128((const __m128i *)&pkt.src_port);\n  *(__m128i *)&retstr->payload[3] = si128;\n  *(__m128i *)&retstr->src_ip = v10;\n  *(__m128i *)&retstr->payload[19] = v7;\n  *(__m128i *)&retstr->payload[35] = v8;\n  *(__m128i *)&retstr->payload[51] = v9;\n  return retstr;\n}", "binary": "packet-filter/packet-filter.host.O2", "assembly": "<generate_packet>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\npush   %rbx\nsub    $0x78,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\ncall   2d20 <libmin_rand>\nimul   $0xcccccccd,%eax,%eax\nror    $0x2,%eax\ncmp    $0xccccccc,%eax\nja     140a <generate_packet+0x13a>\ncall   2d20 <libmin_rand>\nmov    %eax,%ebx\ncall   2d20 <libmin_rand>\nshl    $0x8,%ebx\nmovb   $0x6,0xf(%rsp)\nmov    %eax,%r8d\nmovzwl %bx,%eax\nmovzbl %r8b,%edx\nor     %edx,%eax\nor     $0xc0a80000,%eax\nmov    %eax,0x8(%rsp)\ncall   2d20 <libmin_rand>\nlea    0x1d(%rsp),%r15\nlea    0x5c(%rsp),%rbx\nmov    %eax,%r14d\ncall   2d20 <libmin_rand>\nmov    %eax,%r13d\ncall   2d20 <libmin_rand>\nmov    %eax,%ebp\nnopl   0x0(%rax,%rax,1)\ncall   2d20 <libmin_rand>\nadd    $0x1,%r15\nmov    %eax,%edx\nimul   $0x4ec4ec4f,%rdx,%rdx\nshr    $0x23,%rdx\nimul   $0x1a,%edx,%edx\nsub    %edx,%eax\nadd    $0x41,%eax\nmov    %al,-0x1(%r15)\ncmp    %r15,%rbx\njne    1360 <generate_packet+0x90>\nmov    0x8(%rsp),%eax\nmovb   $0x0,0x5c(%rsp)\nmov    %r14d,0x10(%rsp)\nmovdqa 0x20(%rsp),%xmm1\nmovdqa 0x30(%rsp),%xmm2\nmovdqa 0x40(%rsp),%xmm3\nmov    %eax,0x14(%rsp)\nmovzbl 0xf(%rsp),%eax\nmov    %r13w,0x18(%rsp)\nmov    %bp,0x1a(%rsp)\nmovdqa 0x50(%rsp),%xmm4\nmov    %al,0x1c(%rsp)\nmovdqa 0x10(%rsp),%xmm0\nmovups %xmm1,0x10(%r12)\nmovups %xmm0,(%r12)\nmovups %xmm2,0x20(%r12)\nmovups %xmm3,0x30(%r12)\nmovups %xmm4,0x40(%r12)\nmov    0x68(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1421 <generate_packet+0x151>\nadd    $0x78,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   2d20 <libmin_rand>\nmov    %eax,0x8(%rsp)\ncall   2d20 <libmin_rand>\nmov    %al,0xf(%rsp)\njmp    1337 <generate_packet+0x67>\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "main", "content": "int main() {\n    // Seed the random number generator.\n    libmin_srand(42);\n    \n    int packetCounter = 0;\n    \n    // Simulate packet processing.\n    while (packetCounter < PACKET_COUNT) {\n        Packet pkt = generate_packet();\n        packetCounter++;\n        \n        // Use the updated filter: check for TCP and IP range.\n        if (check_packet_filter(pkt)) {\n            libmin_printf(\"Matched Packet #%d:\\n\", packetCounter);\n            print_packet(pkt);\n        }\n    }\n    \n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n  Packet pkt; // [rsp+0h] [rbp+0h] BYREF\n  unsigned __int64 vars58; // [rsp+58h] [rbp+58h]\n\n  v3 = 0;\n  vars58 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  while ( 1 )\n  {\n    ++v3;\n    generate_packet(&pkt);\n    if ( pkt.protocol == 6 && BYTE2(pkt.dest_ip) == 0xA8 && HIBYTE(pkt.dest_ip) == 192 )\n    {\n      libmin_printf(\"Matched Packet #%d:\\n\", v3);\n      print_packet(pkt);\n    }\n    if ( v3 == 100 )\n      libmin_success();\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  Packet pkt;\n  unsigned long long vars58;\n  v3 = 0;\n  vars58 = __readfsqword(40u);\n  libmin_srand(42u);\n  while (1) {\n    ++v3;\n    generate_packet(&pkt);\n    if (pkt.protocol == 6 && BYTE2(pkt.dest_ip) == 168 &&\n        HIBYTE(pkt.dest_ip) == 192) {\n      libmin_printf(\"Matched Packet #%d:\\n\", v3);\n      print_packet(pkt);\n    }\n    if (v3 == 100) libmin_success();\n  }\n}", "binary": "packet-filter/packet-filter.host.O2", "assembly": "<main>:\nendbr64\npush   %r12\nmov    $0x2a,%edi\nlea    0x1f7c(%rip),%r12\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x60,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x58(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbp\ncall   2cc0 <libmin_srand>\nnopw   0x0(%rax,%rax,1)\nxor    %eax,%eax\nmov    %rbp,%rdi\nadd    $0x1,%ebx\ncall   12d0 <generate_packet>\ncmpb   $0x6,0xc(%rsp)\njne    11a8 <main+0xa8>\nmov    0x4(%rsp),%eax\nmov    %eax,%edx\nshr    $0x10,%edx\ncmp    $0xa8,%dl\njne    11a8 <main+0xa8>\nshr    $0x18,%eax\ncmp    $0xc0,%eax\njne    11a8 <main+0xa8>\nmov    %ebx,%esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2ab0 <libmin_printf>\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\npush   0x48(%rsp)\ncall   1490 <print_packet>\nadd    $0x50,%rsp\nnopl   0x0(%rax)\ncmp    $0x64,%ebx\njne    1138 <main+0x38>\ncall   2f00 <libmin_success>\nmov    0x58(%rsp),%rax\nsub    %fs:0x28,%rax\njne    11cd <main+0xcd>\nadd    $0x60,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "print_ip", "content": "// Helper function to print an IP address in dotted notation.\nvoid print_ip(unsigned int ip) {\n    libmin_printf(\"%u.%u.%u.%u\", \n           (ip >> 24) & 0xFF, \n           (ip >> 16) & 0xFF, \n           (ip >> 8) & 0xFF, \n           ip & 0xFF);\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O2.pseudo", "function_name": "print_ip", "address": "0x1460", "label": "print_ip", "content": "void __fastcall print_ip(unsigned int ip)\n{\n  libmin_printf(\"%u.%u.%u.%u\", HIBYTE(ip), BYTE2(ip), BYTE1(ip), (unsigned __int8)ip);\n}\n"}, "pseudo_normalize": "", "binary": "packet-filter/packet-filter.host.O2", "assembly": "<print_ip>:\nendbr64\nmov    %edi,%edx\nmov    %edi,%eax\nmov    %edi,%esi\nmovzbl %dil,%r8d\nshr    $0x10,%edx\nmovzbl %ah,%ecx\nshr    $0x18,%esi\nlea    0x1b86(%rip),%rdi\nmovzbl %dl,%edx\nxor    %eax,%eax\njmp    2ab0 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "packet-filter/packet-filter.c", "function_name": "print_packet", "content": "// Print the details of a packet.\nvoid print_packet(Packet pkt) {\n    libmin_printf(\"Packet Details:\\n\");\n    libmin_printf(\"  Source IP: \");\n    print_ip(pkt.src_ip);\n    libmin_printf(\"\\n  Destination IP: \");\n    print_ip(pkt.dest_ip);\n    libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n    libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n    libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n    libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n    libmin_printf(\"------------------------------\\n\");\n}\n"}, "pseudo": {"path": "packet-filter/packet-filter.host.O2.pseudo", "function_name": "print_packet", "address": "0x1490", "label": "print_packet", "content": "void __cdecl print_packet(Packet pkt)\n{\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  libmin_printf(\"%u.%u.%u.%u\", HIBYTE(pkt.src_ip), BYTE2(pkt.src_ip), BYTE1(pkt.src_ip), LOBYTE(pkt.src_ip));\n  libmin_printf(\"\\n  Destination IP: \");\n  libmin_printf(\"%u.%u.%u.%u\", HIBYTE(pkt.dest_ip), BYTE2(pkt.dest_ip), BYTE1(pkt.dest_ip), LOBYTE(pkt.dest_ip));\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}\n"}, "pseudo_normalize": "void print_packet(Packet pkt) {\n  libmin_printf(\"Packet Details:\\n\");\n  libmin_printf(\"  Source IP: \");\n  libmin_printf(\"%u.%u.%u.%u\", HIBYTE(pkt.src_ip), BYTE2(pkt.src_ip),\n                BYTE1(pkt.src_ip), LOBYTE(pkt.src_ip));\n  libmin_printf(\"\\n  Destination IP: \");\n  libmin_printf(\"%u.%u.%u.%u\", HIBYTE(pkt.dest_ip), BYTE2(pkt.dest_ip),\n                BYTE1(pkt.dest_ip), LOBYTE(pkt.dest_ip));\n  libmin_printf(\"\\n  Source Port: %u\\n\", pkt.src_port);\n  libmin_printf(\"  Destination Port: %u\\n\", pkt.dest_port);\n  libmin_printf(\"  Protocol: %u\\n\", pkt.protocol);\n  libmin_printf(\"  Payload: %s\\n\", pkt.payload);\n  libmin_printf(\"------------------------------\\n\");\n}", "binary": "packet-filter/packet-filter.host.O2", "assembly": "<print_packet>:\nendbr64\npush   %rbp\nlea    0x1b74(%rip),%rdi\nxor    %eax,%eax\nlea    0x1b5f(%rip),%rbp\ncall   2ab0 <libmin_printf>\nlea    0x1b70(%rip),%rdi\nxor    %eax,%eax\ncall   2ab0 <libmin_printf>\nmov    0x10(%rsp),%eax\nmov    %rbp,%rdi\nmov    %eax,%edx\nmov    %eax,%esi\nmovzbl %ah,%ecx\nmovzbl %al,%r8d\nshr    $0x10,%edx\nshr    $0x18,%esi\nxor    %eax,%eax\nmovzbl %dl,%edx\ncall   2ab0 <libmin_printf>\nlea    0x1b4e(%rip),%rdi\nxor    %eax,%eax\ncall   2ab0 <libmin_printf>\nmov    0x14(%rsp),%eax\nmov    %rbp,%rdi\nmov    %eax,%edx\nmov    %eax,%esi\nmovzbl %ah,%ecx\nmovzbl %al,%r8d\nshr    $0x10,%edx\nshr    $0x18,%esi\nxor    %eax,%eax\nmovzbl %dl,%edx\ncall   2ab0 <libmin_printf>\nmovzwl 0x18(%rsp),%esi\nlea    0x1b2d(%rip),%rdi\nxor    %eax,%eax\ncall   2ab0 <libmin_printf>\nmovzwl 0x1a(%rsp),%esi\nlea    0x1b2e(%rip),%rdi\nxor    %eax,%eax\ncall   2ab0 <libmin_printf>\nmovzbl 0x1c(%rsp),%esi\nlea    0x1b33(%rip),%rdi\nxor    %eax,%eax\ncall   2ab0 <libmin_printf>\nlea    0x1d(%rsp),%rsi\nlea    0x1b30(%rip),%rdi\nxor    %eax,%eax\ncall   2ab0 <libmin_printf>\nlea    0x1b4b(%rip),%rdi\nxor    %eax,%eax\ncall   2ab0 <libmin_printf>\npop    %rbp\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "parrondo/parrondo.c", "function_name": "cointoss", "content": "/* parrando.c: simulation of J. Parrando's probability paradox */\n\n\n/* Parrondo's game is based upon two simple games of chance.\n\n        The gambler's fortune starts at 0.\n\n\tThe simple game: Toss a biased coin and win +1 with probability\n\t\tS_WIN_PROB (defined below). Otherwise win -1; \n\n\tThe complex game: If the player's fortune is divisible by 3, toss\n\t\tthe \"bad coin\" having win probability BAD_WIN_PROB.\n\t\tIf the player's fortune is not divisible by 3 toss the\n                \"good coin\" having win probability GOOD_WIN_PROB.\n\n\tA game ends when the accumlated fortune exceeds MAX_FORTUNE ( a \"win\" )\n\tor dips below -MAX_FORTUNE ( a \"loss .)  \n\n\tThe numbers are chosen so that each game is quite unfavorable.\n        Remarkably, when the games are alternated at random, the resulting\n        game is quite favorable.\n\n\tThis program simulates many trials of a Parrondo game and reports\n        statistics on their outcomes. (It can also simulate the simple and\n        complex games individually.) The number of trials, fortune limits,\n        and a seed for the random number can be supplied on the command line.\n        The -h option prints detailed help. \n\n\tFor more information on Parrondo games and related phenomena see\n        J. Parrondo's website, http://seneca.fis.ucm.es/parr/,  or the\n        announcement in Nature magazine, 23/30, December 1999.\n*/\n\n/* compile: cc -o parrondo parrondo.c \n\n      Use -D_NO_RANDOM if your library doesn't have random/srandom. Most do,\n       \tbut the only truly portable RNG is rand/srand. Unfortunately it has\n        very poor performance, so you should use random if possible.\n\n      Use -D_MAX_RAND=  to set the size of the maximum value returned by\n         random(). The portable RNG rand() always returns a maximum of \n         RAND_MAX (defined in stdlib.h), but some implementations of random\n         do not use this value. Read the man page for random to be sure. A\n\t common value is 2^31-1 = 2147483647. In so, and this is not the\n         value of RAND_MAX on your system, you would compile with\n         -D_MAX_RAND=214748367.\n\n      Use -D_SHORT_STRINGS if your compiler does not support multiline\n          string constants.\n*/\n\n\n#include \"libmin.h\"\n\n#define VERSION \"1.1\"\n#define USAGE \"parrondo [ -s number -t number -m number -1 -2 -h -v]\"\n#ifndef _SHORT_STRINGS\n#define HELP \"parrondo [ -s number -t number -m number -1 -2 ]\\n\\n\\\nPrint information on simulations of Parrondo's paradoxical game.\\n\\n\\\n-s: Use next argument as RNG seed. (otherwise use system time as seed.)\\n\\\n-t: Use next argument as number of trials. Default 10000.\\n\\\n-m: Use number as max fortune (win), -number as min fortune(loss). Default 50. \\n\\\n-v: Print version number and exit. \\n\\\n-h: Print this helpful information. \\n\\\n-1: Simulate simple game alone.\\n\\\n-2: Simulate complex game alone.\\n\\n\"\n#else\n#define HELP USAGE\n#endif\n\n/* Default values */\n#define MAX_FORTUNE 50\n#define MAX_ITERATIONS 1000000L\n#define TRIALS 1000\n#define INITIAL_SEED 3445\n#ifndef _MAX_RAND\n#define _MAX_RAND RAND_MAX\n#endif\n\n/* See above for meaning of these */\n#define S_WIN_PROB .495\n#define BAD_WIN_PROB .095\n#define GOOD_WIN_PROB .745\n\n\n/* return -1 or +1 according as a simulated coin toss is heads (+1) or\n   tails (-1). Take p as probability of heads.\n*/\n\nint\ncointoss(double p)\n{\n\n\tdouble U;   /* U(0,1) random variable */\n\n\tU = ((double)libmin_rand())/((double)_MAX_RAND);\n\treturn U >= p ? -1 : 1;\n}\n"}, "pseudo": {"path": "parrondo/parrondo.host.O2.pseudo", "function_name": "cointoss", "address": "0x17a0", "label": "cointoss", "content": "__int64 __fastcall cointoss(double a1, double p)\n{\n  return (double)(int)libmin_rand() / 2147483647.0 < a1 ? 1 : -1;\n}\n"}, "pseudo_normalize": "", "binary": "parrondo/parrondo.host.O2", "assembly": "<cointoss>:\nendbr64\nsub    $0x18,%rsp\nmovsd  %xmm0,0x8(%rsp)\ncall   31c0 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2c82(%rip),%xmm0\ncomisd 0x8(%rsp),%xmm0\nsbb    %eax,%eax\nadd    $0x18,%rsp\nand    $0x2,%eax\nsub    $0x1,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "parrondo/parrondo.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tlong n=0L;\n\tdouble n_bar,n_tot=0.0;\n\tint trials = TRIALS;\n\tint i=0,j=0,m;\n\tint win_count = 0;\n\tint loss_count = 0;\n\tlong site_visits[3];  /* counts visits to numbers mod 3 */\n\tint fortune = 0;\n\tint max_fortune = MAX_FORTUNE;\n\tdouble game_select = 0.5;  /* Governs a coin toss below which selects\n                                      between games. Setting this to 1.0 chooses\n\t\t\t\t      complex game only. Setting to 0.0 chooses\n                                      simple game only. \n\t\t\t\t   */\n                                      \n\tlong seed=0;\n\n\t/* Process command line */\n\twhile(++j < argc){\n\t\tif(argv[j][0] == '-')\n\t\t\tswitch(argv[j][1]){ \n\t\t\t\tcase 's':\n\t\t\t\tcase 'S':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\tseed = libmin_atol(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 't':\n\t\t\t\tcase 'T':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\ttrials = libmin_atoi(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\t\n\t\t\t\tcase 'm':\n\t\t\t\tcase 'M':\n\t\t\t\t\tif(j+1 >= argc){\n\t\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\t\tlibmin_fail(1);\n\t\t\t\t\t}\n\t\t\t\t\tmax_fortune = libmin_atoi(argv[j+1]);\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase 'v':\n\t\t\t\tcase 'V':\n\t\t\t\t\tlibmin_printf(\"%s\\n\", VERSION);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '?':\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'H':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",HELP);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '1':\n\t\t\t\t\tgame_select = 0.0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tgame_select = 1.0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tlibmin_printf(\"parrondo: unkown option %s\\n\",\n\t\t\t\t\t\targv[j]);\n\t\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\telse {\n\t\t\tlibmin_printf(\"%s\\n\", USAGE);\n\t\t\tlibmin_fail(1);\n\t\t}\n\t}\n \n\t/* If no seed is supplied, then use current system time */\n\t\n\tif(!seed)\n  {\n\t\t\tseed = INITIAL_SEED; /* if all else fails */\n\t\t\tlibmin_printf(\"Using seed = %d\\n\",INITIAL_SEED);\n  }\n\t\t\n\tlibmin_srand((int)seed);\n\tfor(i=0;i<3;i++)site_visits[i] = 0L;  /* initialize counters */\n\ti=0;\n\tlibmin_printf(\"Simulating %d trials ...\\n\",trials);\n\twhile(i<trials){   /* Loop over trials */\n\n\t\t/* reseed */\n\t\tseed = libmin_rand();\n\t\tlibmin_srand((int)seed);\n\n\t\t/* Each trial: loop until fortune goes out of range */\n\t\tfortune = 0;\n\t\twhile(n++<MAX_ITERATIONS){\n\t\t\tif(cointoss(game_select) == 1)\n\t\t\t\tfortune += play_c(fortune);\n\t\t\telse\n\t\t\t\tfortune += play_s();\n\t\t\tif((fortune >= max_fortune)||(fortune <= -max_fortune))\n\t\t\t\tbreak;\n\n\t\t\tm = fortune > 0 ? fortune : -fortune;\n\t\t\tsite_visits[m%3]++;\t\n\t\t}\n\n\t\tif(fortune == max_fortune)\n\t\t\twin_count++;\n\t\telse if(fortune == -max_fortune)\n\t\t\tloss_count++;\n\n\t\ti++;\n\t\tn_tot += (double)n;\n\t\tn = 0L;\n\t\t\n\t}\n\n\tn_bar = n_tot/((double)i);\n\n\t/* Print stuff out */\n\n\tlibmin_printf(\"%d wins, %d losses, %d draws\\n\",win_count,\n\t\t\tloss_count, i-(win_count+loss_count));\n\tlibmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\",\n\t\t\tmax_fortune,max_fortune,MAX_ITERATIONS);\n\tlibmin_printf(\"Average trial length = %lf\\n\",n_bar);\n\tlibmin_printf(\"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n\t\t100.0*((double)site_visits[0])/n_tot,\n\t\t100.0*((double)site_visits[1])/n_tot,\n\t\t100.0*((double)site_visits[2])/n_tot\n\t);\n\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "parrondo/parrondo.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ecx\n  int v4; // r13d\n  int v5; // ebp\n  int v6; // r8d\n  int v7; // r14d\n  char *v8; // rsi\n  int v9; // r13d\n  unsigned int v10; // eax\n  __int64 v11; // rbx\n  int v12; // r15d\n  bool v13; // zf\n  int v14; // eax\n  unsigned int v15; // ecx\n  int v16; // eax\n  double v17; // xmm0_8\n  int v18; // r8d\n  int v19; // eax\n  int v20; // r8d\n  int v21; // eax\n  int v22; // r8d\n  __int64 v23; // rax\n  double game_select; // [rsp+0h] [rbp-78h]\n  __int64 seed; // [rsp+8h] [rbp-70h]\n  double seeda; // [rsp+8h] [rbp-70h]\n  int loss_count; // [rsp+10h] [rbp-68h]\n  int loss_counta; // [rsp+10h] [rbp-68h]\n  int loss_countb; // [rsp+10h] [rbp-68h]\n  int loss_countc; // [rsp+10h] [rbp-68h]\n  int win_count; // [rsp+14h] [rbp-64h]\n  __int64 site_visits[3]; // [rsp+20h] [rbp-58h] BYREF\n  unsigned __int64 v34; // [rsp+38h] [rbp-40h]\n\n  v3 = ::argc;\n  v34 = __readfsqword(0x28u);\n  if ( ::argc <= 1 )\n  {\n    v5 = 50;\n    v7 = 1000;\n    game_select = 0.5;\nLABEL_43:\n    libmin_printf(\"Using seed = %d\\n\", 3445);\n    libmin_srand(0xD75u);\n  }\n  else\n  {\n    v4 = 1;\n    v5 = 50;\n    seed = 0LL;\n    v6 = 0;\n    v7 = 1000;\n    game_select = 0.5;\n    while ( 2 )\n    {\n      v8 = ::argv[v4];\n      if ( *v8 != 45 )\n      {\n        libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\nLABEL_6:\n        libmin_fail(1);\n      }\n      switch ( v8[1] )\n      {\n        case '1':\n          v6 = v4;\n          game_select = 0.0;\n          goto LABEL_7;\n        case '2':\n          v6 = v4;\n          game_select = 1.0;\n          goto LABEL_7;\n        case '?':\n        case 'H':\n        case 'h':\n          libmin_printf(\n            (char *)\"%s\\n\",\n            \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n            \"\\n\"\n            \"Print information on simulations of Parrondo's paradoxical game.\\n\"\n            \"\\n\"\n            \"-s: Use next argument as RNG seed. (otherwise use system time as seed.)\\n\"\n            \"-t: Use next argument as number of trials. Default 10000.\\n\"\n            \"-m: Use number as max fortune (win), -number as min fortune(loss). Default 50. \\n\"\n            \"-v: Print version number and exit. \\n\"\n            \"-h: Print this helpful information. \\n\"\n            \"-1: Simulate simple game alone.\\n\"\n            \"-2: Simulate complex game alone.\\n\"\n            \"\\n\");\n          libmin_success();\n        case 'M':\n        case 'm':\n          v18 = v6 + 2;\n          if ( v18 >= v3 )\n          {\n            libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          loss_counta = v18;\n          v19 = libmin_atoi(::argv[v18]);\n          v3 = ::argc;\n          v6 = loss_counta;\n          v5 = v19;\n          goto LABEL_7;\n        case 'S':\n        case 's':\n          v22 = v6 + 2;\n          if ( v22 >= v3 )\n          {\n            libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          loss_countc = v22;\n          v23 = libmin_atol(::argv[v22]);\n          v3 = ::argc;\n          v6 = loss_countc;\n          seed = v23;\n          goto LABEL_7;\n        case 'T':\n        case 't':\n          v20 = v6 + 2;\n          if ( v20 >= v3 )\n          {\n            libmin_printf((char *)\"%s\\n\", \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          loss_countb = v20;\n          v21 = libmin_atoi(::argv[v20]);\n          v3 = ::argc;\n          v6 = loss_countb;\n          v7 = v21;\nLABEL_7:\n          v4 = v6 + 1;\n          if ( v3 > v6 + 1 )\n            continue;\n          if ( !seed )\n            goto LABEL_43;\n          libmin_srand(seed);\n          break;\n        case 'V':\n        case 'v':\n          libmin_printf((char *)\"%s\\n\", \"1.1\");\n          libmin_success();\n        default:\n          libmin_printf(\"parrondo: unkown option %s\\n\", v8);\n          goto LABEL_6;\n      }\n      break;\n    }\n  }\n  memset(site_visits, 0, sizeof(site_visits));\n  libmin_printf(\"Simulating %d trials ...\\n\", v7);\n  loss_count = 0;\n  win_count = 0;\n  if ( v7 <= 0 )\n  {\n    v7 = 0;\n    seeda = 0.0;\n    goto LABEL_26;\n  }\n  v9 = 0;\n  seeda = 0.0;\nLABEL_12:\n  v10 = libmin_rand();\n  v11 = 1LL;\n  v12 = 0;\n  libmin_srand(v10);\n  while ( 1 )\n  {\n    if ( (double)(int)libmin_rand() / 2147483647.0 >= game_select )\n    {\n      v12 = v12 + ((double)(int)libmin_rand() / 2147483647.0 < 0.495 ? 2 : 0) - 1;\n      v13 = v12 == v5;\n      if ( v12 >= v5 )\n        goto LABEL_23;\n      goto LABEL_14;\n    }\n    if ( (unsigned int)(-1431655765 * v12 + 715827882) > 0x55555554 )\n    {\n      if ( (double)(int)libmin_rand() / 2147483647.0 >= 0.745 )\n      {\nLABEL_21:\n        v16 = -1;\n        goto LABEL_22;\n      }\n    }\n    else if ( (double)(int)libmin_rand() / 2147483647.0 >= 0.095 )\n    {\n      goto LABEL_21;\n    }\n    v16 = 1;\nLABEL_22:\n    v12 += v16;\n    v13 = v12 == v5;\n    if ( v12 >= v5 )\n    {\nLABEL_23:\n      v17 = (double)(int)v11;\n      if ( v13 )\n      {\n        ++win_count;\n        goto LABEL_25;\n      }\n      v14 = -v5;\n      goto LABEL_39;\n    }\nLABEL_14:\n    v14 = -v5;\n    if ( -v5 >= v12 )\n    {\n      v17 = (double)(int)v11;\nLABEL_39:\n      loss_count += v14 == v12;\n      goto LABEL_25;\n    }\n    v15 = -v12;\n    if ( v12 > 0 )\n      v15 = v12;\n    ++v11;\n    ++site_visits[v15 % 3];\n    if ( v11 == 1000001 )\n    {\n      v17 = 1000001.0;\nLABEL_25:\n      ++v9;\n      seeda = v17 + seeda;\n      if ( v7 == v9 )\n      {\nLABEL_26:\n        libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count, v7 - (loss_count + win_count));\n        libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\", v5, v5, 1000000LL);\n        libmin_printf(\"Average trial length = %lf\\n\", seeda / (double)v7);\n        libmin_printf(\n          \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n          (double)SLODWORD(site_visits[0]) * 100.0 / seeda,\n          (double)SLODWORD(site_visits[1]) * 100.0 / seeda,\n          (double)SLODWORD(site_visits[2]) * 100.0 / seeda);\n        libmin_success();\n      }\n      goto LABEL_12;\n    }\n  }\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  char *v8;\n  int v9;\n  unsigned int v10;\n  long long v11;\n  int v12;\n  bool v13;\n  int v14;\n  unsigned int v15;\n  int v16;\n  double v17;\n  int v18;\n  int v19;\n  int v20;\n  int v21;\n  int v22;\n  long long v23;\n  double game_select;\n  long long seed;\n  double seeda;\n  int loss_count;\n  int loss_counta;\n  int loss_countb;\n  int loss_countc;\n  int win_count;\n  long long site_visits[3];\n  unsigned long long v34;\n  v3 = ::argc;\n  v34 = __readfsqword(40u);\n  if (::argc <= 1) {\n    v5 = 50;\n    v7 = 1000;\n    game_select = 0.5;\n  LABEL_43:\n    libmin_printf(\"Using seed = %d\\n\", 3445);\n    libmin_srand(3445u);\n  } else {\n    v4 = 1;\n    v5 = 50;\n    seed = 0LL;\n    v6 = 0;\n    v7 = 1000;\n    game_select = 0.5;\n    while (2) {\n      v8 = ::argv[v4];\n      if (*v8 != 45) {\n        libmin_printf((char *)\"%s\\n\",\n                      \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n      LABEL_6:\n        libmin_fail(1);\n      }\n      switch (v8[1]) {\n        case '1':\n          v6 = v4;\n          game_select = 0.0;\n          goto LABEL_7;\n        case '2':\n          v6 = v4;\n          game_select = 1.0;\n          goto LABEL_7;\n        case '?':\n        case 'H':\n        case 'h':\n          libmin_printf(\n              (char *)\"%s\\n\",\n              \"parrondo [ -s number -t number -m number -1 -2 ]\\n\"\n              \"\\n\"\n              \"Print information on simulations of Parrondo's paradoxical \"\n              \"game.\\n\"\n              \"\\n\"\n              \"-s: Use next argument as RNG seed. (otherwise use system time \"\n              \"as seed.)\\n\"\n              \"-t: Use next argument as number of trials. Default 10000.\\n\"\n              \"-m: Use number as max fortune (win), -number as min \"\n              \"fortune(loss). Default 50. \\n\"\n              \"-v: Print version number and exit. \\n\"\n              \"-h: Print this helpful information. \\n\"\n              \"-1: Simulate simple game alone.\\n\"\n              \"-2: Simulate complex game alone.\\n\"\n              \"\\n\");\n          libmin_success();\n        case 'M':\n        case 'm':\n          v18 = v6 + 2;\n          if (v18 >= v3) {\n            libmin_printf(\n                (char *)\"%s\\n\",\n                \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          loss_counta = v18;\n          v19 = libmin_atoi(::argv[v18]);\n          v3 = ::argc;\n          v6 = loss_counta;\n          v5 = v19;\n          goto LABEL_7;\n        case 'S':\n        case 's':\n          v22 = v6 + 2;\n          if (v22 >= v3) {\n            libmin_printf(\n                (char *)\"%s\\n\",\n                \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          loss_countc = v22;\n          v23 = libmin_atol(::argv[v22]);\n          v3 = ::argc;\n          v6 = loss_countc;\n          seed = v23;\n          goto LABEL_7;\n        case 'T':\n        case 't':\n          v20 = v6 + 2;\n          if (v20 >= v3) {\n            libmin_printf(\n                (char *)\"%s\\n\",\n                \"parrondo [ -s number -t number -m number -1 -2 -h -v]\");\n            libmin_fail(1);\n          }\n          loss_countb = v20;\n          v21 = libmin_atoi(::argv[v20]);\n          v3 = ::argc;\n          v6 = loss_countb;\n          v7 = v21;\n        LABEL_7:\n          v4 = v6 + 1;\n          if (v3 > v6 + 1) continue;\n          if (!seed) goto LABEL_43;\n          libmin_srand(seed);\n          break;\n        case 'V':\n        case 'v':\n          libmin_printf((char *)\"%s\\n\", \"1.1\");\n          libmin_success();\n        default:\n          libmin_printf(\"parrondo: unkown option %s\\n\", v8);\n          goto LABEL_6;\n      }\n      break;\n    }\n  }\n  memset(site_visits, 0, sizeof(site_visits));\n  libmin_printf(\"Simulating %d trials ...\\n\", v7);\n  loss_count = 0;\n  win_count = 0;\n  if (v7 <= 0) {\n    v7 = 0;\n    seeda = 0.0;\n    goto LABEL_26;\n  }\n  v9 = 0;\n  seeda = 0.0;\nLABEL_12:\n  v10 = libmin_rand();\n  v11 = 1LL;\n  v12 = 0;\n  libmin_srand(v10);\n  while (1) {\n    if ((double)(int)libmin_rand() / 2147483647.0 >= game_select) {\n      v12 =\n          v12 + ((double)(int)libmin_rand() / 2147483647.0 < 0.495 ? 2 : 0) - 1;\n      v13 = v12 == v5;\n      if (v12 >= v5) goto LABEL_23;\n      goto LABEL_14;\n    }\n    if ((unsigned int)(-1431655765 * v12 + 715827882) > 1431655764) {\n      if ((double)(int)libmin_rand() / 2147483647.0 >= 0.745) {\n      LABEL_21:\n        v16 = -1;\n        goto LABEL_22;\n      }\n    } else if ((double)(int)libmin_rand() / 2147483647.0 >= 0.095) {\n      goto LABEL_21;\n    }\n    v16 = 1;\n  LABEL_22:\n    v12 += v16;\n    v13 = v12 == v5;\n    if (v12 >= v5) {\n    LABEL_23:\n      v17 = (double)(int)v11;\n      if (v13) {\n        ++win_count;\n        goto LABEL_25;\n      }\n      v14 = -v5;\n      goto LABEL_39;\n    }\n  LABEL_14:\n    v14 = -v5;\n    if (-v5 >= v12) {\n      v17 = (double)(int)v11;\n    LABEL_39:\n      loss_count += v14 == v12;\n      goto LABEL_25;\n    }\n    v15 = -v12;\n    if (v12 > 0) v15 = v12;\n    ++v11;\n    ++site_visits[v15 % 3];\n    if (v11 == 1000001) {\n      v17 = 1000001.0;\n    LABEL_25:\n      ++v9;\n      seeda = v17 + seeda;\n      if (v7 == v9) {\n      LABEL_26:\n        libmin_printf(\"%d wins, %d losses, %d draws\\n\", win_count, loss_count,\n                      v7 - (loss_count + win_count));\n        libmin_printf(\"(Win/loss = %d/-%d, draw = no win/loss in %ld plays.)\\n\",\n                      v5, v5, 1000000LL);\n        libmin_printf(\"Average trial length = %lf\\n\", seeda / (double)v7);\n        libmin_printf(\n            \"Site occupancy: 0 mod 3: %lf%%, 1 mod 3: %lf%%, 2 mod 3: %lf%%\\n\",\n            (double)SLODWORD(site_visits[0]) * 100.0 / seeda,\n            (double)SLODWORD(site_visits[1]) * 100.0 / seeda,\n            (double)SLODWORD(site_visits[2]) * 100.0 / seeda);\n        libmin_success();\n      }\n      goto LABEL_12;\n    }\n  }\n}", "binary": "parrondo/parrondo.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x48,%rsp\nmov    0x5ef8(%rip),%ecx\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nxor    %eax,%eax\ncmp    $0x1,%ecx\njle    15ae <main+0x4ae>\nmovsd  0x332f(%rip),%xmm7\nmov    $0x1,%r13d\nmov    $0x32,%ebp\nmovq   $0x0,0x8(%rsp)\nxor    %r8d,%r8d\nmov    $0x3e8,%r14d\nlea    0x5ec3(%rip),%rbx\nmovsd  %xmm7,(%rsp)\npxor   %xmm7,%xmm7\nlea    0x2e9b(%rip),%r15\nlea    0x3138(%rip),%r12\nmovsd  %xmm7,0x18(%rsp)\nnopw   0x0(%rax,%rax,1)\nmovslq %r13d,%rax\nmov    (%rbx,%rax,8),%rsi\ncmpb   $0x2d,(%rsi)\njne    1570 <main+0x470>\nmovzbl 0x1(%rsi),%eax\nsub    $0x31,%eax\ncmp    $0x45,%al\nja     11af <main+0xaf>\nlea    0x318a(%rip),%rdx\nmovzbl %al,%eax\nmovslq (%rdx,%rax,4),%rax\nadd    %rdx,%rax\nnotrack jmp *%rax\nlea    0x30de(%rip),%rdi\ncs nopw 0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   2f50 <libmin_printf>\nmov    $0x1,%edi\ncall   1bd0 <libmin_fail>\nmov    0x5e39(%rip),%ecx\nmov    %r13d,%r8d\nlea    0x1(%r8),%r13d\ncmp    %r13d,%ecx\njg     1180 <main+0x80>\ncmpq   $0x0,0x8(%rsp)\nje     15d0 <main+0x4d0>\nmov    0x8(%rsp),%edi\ncall   3160 <libmin_srand>\nmov    %r14d,%esi\nlea    0x30bf(%rip),%rdi\nxor    %eax,%eax\nmovq   $0x0,0x20(%rsp)\nmovq   $0x0,0x28(%rsp)\nmovq   $0x0,0x30(%rsp)\ncall   2f50 <libmin_printf>\nmovl   $0x0,0x10(%rsp)\nmovl   $0x0,0x14(%rsp)\ntest   %r14d,%r14d\njle    168b <main+0x58b>\nmovsd  0x18(%rsp),%xmm3\nxor    %r13d,%r13d\nmovsd  %xmm3,0x8(%rsp)\nnopl   0x0(%rax)\ncall   31c0 <libmin_rand>\nmov    $0x1,%ebx\nxor    %r15d,%r15d\nmov    $0xaaaaaaab,%r12d\nmov    %eax,%edi\ncall   3160 <libmin_srand>\njmp    12e3 <main+0x1e3>\nnopl   0x0(%rax)\ncall   31c0 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x31c0(%rip),%xmm0\ncomisd 0x31c0(%rip),%xmm0\nsbb    %eax,%eax\nand    $0x2,%eax\nlea    -0x1(%r15,%rax,1),%r15d\ncmp    %ebp,%r15d\njge    1354 <main+0x254>\nmov    %ebp,%eax\nneg    %eax\ncmp    %r15d,%eax\njge    1580 <main+0x480>\nmov    %r15d,%ecx\nneg    %ecx\ncmovs  %r15d,%ecx\nadd    $0x1,%rbx\nmov    %ecx,%eax\nimul   %r12,%rax\nshr    $0x21,%rax\nlea    (%rax,%rax,2),%esi\nmov    %ecx,%eax\nsub    %esi,%eax\ncltq\naddq   $0x1,0x20(%rsp,%rax,8)\ncmp    $0xf4241,%rbx\nje     15a1 <main+0x4a1>\ncall   31c0 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x314d(%rip),%xmm0\ncomisd (%rsp),%xmm0\njae    1270 <main+0x170>\nimul   $0xaaaaaaab,%r15d,%eax\nadd    $0x2aaaaaaa,%eax\ncmp    $0x55555554,%eax\nja     1540 <main+0x440>\ncall   31c0 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x3113(%rip),%xmm0\ncomisd 0x3123(%rip),%xmm0\njb     1566 <main+0x466>\nmov    $0xffffffff,%eax\nadd    %eax,%r15d\ncmp    %ebp,%r15d\njl     12a3 <main+0x1a3>\npxor   %xmm0,%xmm0\ncvtsi2sd %rbx,%xmm0\njne    159b <main+0x49b>\naddl   $0x1,0x14(%rsp)\naddsd  0x8(%rsp),%xmm0\nadd    $0x1,%r13d\nmovsd  %xmm0,0x8(%rsp)\ncmp    %r13d,%r14d\njne    1250 <main+0x150>\npxor   %xmm1,%xmm1\nmov    0x14(%rsp),%esi\nmov    0x10(%rsp),%edx\nmov    %r14d,%ecx\ncvtsi2sd %r14d,%xmm1\nmovsd  0x8(%rsp),%xmm0\nlea    0x2f39(%rip),%rdi\nmov    %esi,%eax\nadd    %edx,%eax\nsub    %eax,%ecx\nxor    %eax,%eax\ndivsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rsp)\ncall   2f50 <libmin_printf>\nmov    $0xf4240,%ecx\nmov    %ebp,%edx\nmov    %ebp,%esi\nlea    0x2e50(%rip),%rdi\nxor    %eax,%eax\ncall   2f50 <libmin_printf>\nmovsd  (%rsp),%xmm0\nmov    $0x1,%eax\nlea    0x2f19(%rip),%rdi\ncall   2f50 <libmin_printf>\npxor   %xmm2,%xmm2\npxor   %xmm1,%xmm1\npxor   %xmm0,%xmm0\ncvtsi2sdq 0x30(%rsp),%xmm2\nmovsd  0x3080(%rip),%xmm3\nmovsd  0x8(%rsp),%xmm6\nlea    0x2e43(%rip),%rdi\ncvtsi2sdq 0x28(%rsp),%xmm1\nmov    $0x3,%eax\ncvtsi2sdq 0x20(%rsp),%xmm0\nmulsd  %xmm3,%xmm2\nmulsd  %xmm3,%xmm1\nmulsd  %xmm3,%xmm0\ndivsd  %xmm6,%xmm2\ndivsd  %xmm6,%xmm0\ndivsd  %xmm6,%xmm1\ncall   2f50 <libmin_printf>\ncall   33a0 <libmin_success>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    169f <main+0x59f>\nadd    $0x48,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x2e22(%rip),%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f50 <libmin_printf>\ncall   33a0 <libmin_success>\nlea    0x2bbc(%rip),%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2f50 <libmin_printf>\ncall   33a0 <libmin_success>\nmovsd  0x18(%rsp),%xmm7\nmov    0x5b71(%rip),%ecx\nmov    %r13d,%r8d\nmovsd  %xmm7,(%rsp)\njmp    11da <main+0xda>\nadd    $0x2,%r8d\ncmp    %ecx,%r8d\njge    1617 <main+0x517>\nmovslq %r8d,%rax\nmov    %r8d,0x10(%rsp)\nmov    (%rbx,%rax,8),%rdi\ncall   1a80 <libmin_atoi>\nmov    0x5b40(%rip),%ecx\nmov    0x10(%rsp),%r8d\nmov    %eax,%ebp\njmp    11da <main+0xda>\nadd    $0x2,%r8d\ncmp    %ecx,%r8d\njge    163d <main+0x53d>\nmovslq %r8d,%rax\nmov    %r8d,0x10(%rsp)\nmov    (%rbx,%rax,8),%rdi\ncall   1a80 <libmin_atoi>\nmov    0x5b10(%rip),%ecx\nmov    0x10(%rsp),%r8d\nmov    %eax,%r14d\njmp    11da <main+0xda>\nadd    $0x2,%r8d\ncmp    %ecx,%r8d\njge    15f1 <main+0x4f1>\nmovslq %r8d,%rax\nmov    %r8d,0x10(%rsp)\nmov    (%rbx,%rax,8),%rdi\ncall   1b10 <libmin_atol>\nmov    0x5adf(%rip),%ecx\nmov    0x10(%rsp),%r8d\nmov    %rax,0x8(%rsp)\njmp    11da <main+0xda>\ncall   31c0 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2ef0(%rip),%xmm0\ncomisd 0x2ef8(%rip),%xmm0\njae    1343 <main+0x243>\nmov    $0x1,%eax\njmp    1348 <main+0x248>\nmov    %r15,%rsi\nmov    %r12,%rdi\njmp    11c0 <main+0xc0>\nnopl   0x0(%rax,%rax,1)\npxor   %xmm0,%xmm0\ncvtsi2sd %rbx,%xmm0\ncmp    %r15d,%eax\nsete   %al\nmovzbl %al,%eax\nadd    %eax,0x10(%rsp)\njmp    1368 <main+0x268>\nmov    %ebp,%eax\nneg    %eax\njmp    1589 <main+0x489>\nmovsd  0x2ecf(%rip),%xmm0\njmp    1368 <main+0x268>\npxor   %xmm2,%xmm2\nmovsd  0x2eae(%rip),%xmm7\nmov    $0x32,%ebp\nmov    $0x3e8,%r14d\nmovsd  %xmm2,0x18(%rsp)\nmovsd  %xmm7,(%rsp)\nmov    $0xd75,%esi\nlea    0x2cd4(%rip),%rdi\nxor    %eax,%eax\ncall   2f50 <libmin_printf>\nmovq   $0xd75,0x8(%rsp)\njmp    11ef <main+0xef>\nmov    %r15,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\nmov    %r8d,0x8(%rsp)\ncall   2f50 <libmin_printf>\nmov    $0x1,%edi\ncall   1bd0 <libmin_fail>\nmov    0x8(%rsp),%r8d\njmp    151a <main+0x41a>\nmov    %r15,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\nmov    %r8d,0x10(%rsp)\ncall   2f50 <libmin_printf>\nmov    $0x1,%edi\ncall   1bd0 <libmin_fail>\nmov    0x10(%rsp),%r8d\njmp    14b9 <main+0x3b9>\nmov    %r15,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\nmov    %r8d,0x10(%rsp)\ncall   2f50 <libmin_printf>\nmov    $0x1,%edi\ncall   1bd0 <libmin_fail>\nmov    0x10(%rsp),%r8d\njmp    14e9 <main+0x3e9>\nmovsd  0x2e05(%rip),%xmm2\nmov    %r13d,%r8d\nmovsd  %xmm2,(%rsp)\njmp    11da <main+0xda>\nmovsd  0x18(%rsp),%xmm2\nmov    %r13d,%r8d\nmovsd  %xmm2,(%rsp)\njmp    11da <main+0xda>\nmovsd  0x18(%rsp),%xmm7\nxor    %r14d,%r14d\nmovsd  %xmm7,0x8(%rsp)\njmp    1381 <main+0x281>\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "parrondo/parrondo.c", "function_name": "play_c", "content": "/* One play of the complicated game: +1 if win, -1 if loss. */\n\nint play_c(int fortune)\n{\n\n\tif( fortune % 3 )\n\t\treturn cointoss(GOOD_WIN_PROB);\n\treturn cointoss(BAD_WIN_PROB);\n}\n"}, "pseudo": {"path": "parrondo/parrondo.host.O2.pseudo", "function_name": "play_c", "address": "0x1820", "label": "play_c", "content": "int __fastcall play_c(int fortune)\n{\n  if ( (unsigned int)(-1431655765 * fortune + 715827882) > 0x55555554 )\n  {\n    if ( (double)(int)libmin_rand() / 2147483647.0 < 0.745 )\n      return 1;\n  }\n  else if ( (double)(int)libmin_rand() / 2147483647.0 < 0.095 )\n  {\n    return 1;\n  }\n  return -1;\n}\n"}, "pseudo_normalize": "int play_c(int fortune) {\n  if ((unsigned int)(-1431655765 * fortune + 715827882) > 1431655764) {\n    if ((double)(int)libmin_rand() / 2147483647.0 < 0.745) return 1;\n  } else if ((double)(int)libmin_rand() / 2147483647.0 < 0.095) {\n    return 1;\n  }\n  return -1;\n}", "binary": "parrondo/parrondo.host.O2", "assembly": "<play_c>:\nendbr64\nimul   $0xaaaaaaab,%edi,%edi\nsub    $0x8,%rsp\nadd    $0x2aaaaaaa,%edi\ncmp    $0x55555554,%edi\nja     1870 <play_c+0x50>\ncall   31c0 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2bf4(%rip),%xmm0\ncomisd 0x2c04(%rip),%xmm0\njae    1892 <play_c+0x72>\nmov    $0x1,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax,%rax,1)\ncall   31c0 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2bc0(%rip),%xmm0\ncomisd 0x2bc8(%rip),%xmm0\njb     185e <play_c+0x3e>\nmov    $0xffffffff,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "parrondo/parrondo.c", "function_name": "play_s", "content": " \n\n/* One play of the simple game: +1 if win, -1 if loss. */\n\nint play_s(void)\n{\n\treturn cointoss(S_WIN_PROB);\n\t\t\n}\n"}, "pseudo": {"path": "parrondo/parrondo.host.O2.pseudo", "function_name": "play_s", "address": "0x17e0", "label": "play_s", "content": "int __cdecl play_s()\n{\n  return (double)(int)libmin_rand() / 2147483647.0 < 0.495 ? 1 : -1;\n}\n"}, "pseudo_normalize": "", "binary": "parrondo/parrondo.host.O2", "assembly": "<play_s>:\nendbr64\nsub    $0x8,%rsp\ncall   31c0 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2c48(%rip),%xmm0\ncomisd 0x2c48(%rip),%xmm0\nsbb    %eax,%eax\nadd    $0x8,%rsp\nand    $0x2,%eax\nsub    $0x1,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "pascal/pascal.c", "function_name": "main", "content": "int main(void)\n{\n\tint argc=1; char **argv=NULL;\n\tint i=1,j;\n\tint cols_option = FALSE;\n\tint nrows;\n\tint max_width;\n\tint row_offset;\n\n\t/* Process command line */\n\t\n\twhile(((i+1)<=argc)&&(argv[i][0] == '-')){\n\t\tif(argv[i][1] == 'h'){\n\t\t\tlibmin_printf(HELP);\n\t\t\treturn 0;\n\t\t}\n\t\tif(argv[i][1] == 'v'){\n\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\treturn 0;\n\t\t}\n\t\tif(argv[i][1]=='c'){\n\t\t\t/* make sure there is an arg */\n\t\t\tif((i+1) >= argc){\n\t\t\t\tlibmin_printf(USAGE);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcols_option = TRUE;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Unknown option if we got to here */\n\t\tlibmin_printf(USAGE);\n\t\treturn 1;\n\t}\n\n\t/* Make sure there is one arg left */\n\n\tif((i+1) != argc){ \n\t  nrows = 20;\n\t}\n\telse\n\t  nrows = libmin_atoi(argv[i]);\n\n\t/* Sanity checks */\n\tif(nrows == 0){ \n\t\tif(cols_option)\n\t\t  libmin_printf(\"0\\n\");\n\t\tlibmin_success(); /* nothing to do */\n\t}\n\tif(nrows < 0){\n\t\tlibmin_printf(\"%s: %d is an invalid number of rows\\n\", PROGRAM_NAME,nrows);\n\t\tlibmin_fail(1);\n\t}\n\tif(nrows > MAX_ROWS){\n\t\tlibmin_printf(\"%s: %d > %d rows maximum\\n\",PROGRAM_NAME,nrows, MAX_ROWS);\n\t\tlibmin_fail(1);\n\t}\n\n\t/* build the triangle */\n\t\n\ttriangle[0][0] = 1;\n\tfor(i=1;i<nrows;i++){\n\t\ttriangle[i][0] = 1;\n\t\tfor(j=1;j<i;j++)\n\t\t\ttriangle[i][j] = triangle[i-1][j-1]\n\t\t\t\t+ triangle[i-1][j];\n\t\ttriangle[i][i] = 1;\n\t}\n\n\t/* Find the widest number in table. It's the middle one in\n           the bottom row */\n\n\tmax_width = num_digits(triangle[nrows-1][nrows/2]);\n\n\t/* make sure this value is even */\n\tif(max_width % 2) max_width++;\n\n\t/* Since each number is printed in a field max_width+2 wide\n\t   and there are nrows numbers in the longest (bottom) row\n           the number of columns needed for the display is\n           (max_width+2)*nrows */\n\n\tif(cols_option){\n\t\t\tlibmin_printf(\"%d\\n\",(max_width + 2)*nrows);\n\t\t\tlibmin_success();\n\t}\n\t   \n\t/* Now print everything out */ \n\n\tfor(i=0;i<nrows;i++){\n\n\t\t/* This is the only tricky part. Think of each number as\n                   being printed in the center of a brick. Each brick has\n                   width max_width/2 + 1. Going down one row, the bricks\n                   move over one half width */\n\n\t\trow_offset = (nrows-i-1)*(max_width/2+1);\n\n\t\t/* Move first row in deepest, etc., by printing the approp.\n                   number of leading blanks */\n\n\t\tfor(j=0;j<row_offset;j++)\n\t\t  libmin_printf(\" \");\n\n\t\t/* Print ith row of numbers */\n\n\t\tfor(j=0;j<i+1;j++)\n\t\t\tif( print_centered(triangle[i][j],max_width+2)){\n\t\t\t\tlibmin_printf(\"%s: error printing element %d,%d\\n\",PROGRAM_NAME,i,j);\n\t\t\t\tlibmin_fail(1);\n\t\t}\n\t\tlibmin_printf(\"\\n\");\n\t}\n\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "pascal/pascal.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int *v3; // rsi\n  __int64 v4; // r8\n  int v5; // r10d\n  int *v6; // r9\n  __int64 v7; // rdi\n  int *v8; // rax\n  unsigned __int64 v9; // rcx\n  int v10; // edx\n  int v11; // r13d\n  __int64 v12; // rdx\n  int v13; // eax\n  int v14; // eax\n  int *v15; // rbp\n  unsigned int v16; // r13d\n  __int64 v17; // rbx\n  int v18; // r15d\n  __int64 v19; // r12\n  int row_offset; // [rsp+8h] [rbp-40h]\n  unsigned int v21; // [rsp+Ch] [rbp-3Ch]\n\n  v3 = &triangle[1][1];\n  v4 = 240LL;\n  v5 = 2;\n  v6 = triangle[1];\n  v7 = 0x3FFFFFFFFFFFFFE2LL;\n  triangle[0][0] = 1;\n  *(_QWORD *)&triangle[1][0] = 0x100000001LL;\n  do\n  {\n    v6[30] = 1;\n    v8 = v6;\n    do\n    {\n      v9 = (unsigned __int64)&v8[v7];\n      v10 = *v8 + v8[1];\n      ++v8;\n      *(_DWORD *)(v9 + v4 + 4) = v10;\n    }\n    while ( v8 != v3 );\n    ++v5;\n    v3 += 31;\n    v6 += 30;\n    v7 -= 30LL;\n    v4 += 120LL;\n    *v3 = 1;\n  }\n  while ( v5 != 20 );\n  v11 = 1;\n  v12 = (unsigned int)(triangle[19][10] / 10);\n  if ( !(_DWORD)v12 )\n    goto LABEL_17;\n  do\n  {\n    ++v11;\n    v9 = (unsigned int)((int)v12 >> 31);\n    v13 = (int)v12 / 10;\n    v12 = (unsigned int)((int)v12 / 10);\n  }\n  while ( v13 );\n  if ( (v11 & 1) != 0 )\nLABEL_17:\n    ++v11;\n  v14 = v11;\n  v15 = triangle[0];\n  v16 = v11 + 2;\n  v21 = (v14 >> 1) + 1;\n  v17 = 1LL;\n  row_offset = 19 * v21;\n  while ( 1 )\n  {\n    v18 = 0;\n    if ( row_offset > 0 )\n    {\n      do\n      {\n        ++v18;\n        libmin_printf(\" \", v3, v12, v9, v4, v6);\n      }\n      while ( v18 != row_offset );\n    }\n    v19 = 0LL;\n    do\n    {\n      v3 = (int *)v16;\n      if ( print_centered(v15[v19], v16) )\n      {\n        libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", v17 - 1, v19);\n        libmin_fail(1);\n      }\n      ++v19;\n    }\n    while ( v17 != v19 );\n    ++v17;\n    v15 += 30;\n    libmin_printf(\"\\n\");\n    v9 = v21;\n    row_offset -= v21;\n    if ( v17 == 21 )\n      libmin_success();\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int *v3;\n  long long v4;\n  int v5;\n  int *v6;\n  long long v7;\n  int *v8;\n  unsigned long long v9;\n  int v10;\n  int v11;\n  long long v12;\n  int v13;\n  int v14;\n  int *v15;\n  unsigned int v16;\n  long long v17;\n  int v18;\n  long long v19;\n  int row_offset;\n  unsigned int v21;\n  v3 = &triangle[1][1];\n  v4 = 240LL;\n  v5 = 2;\n  v6 = triangle[1];\n  v7 = 4611686018427387874LL;\n  triangle[0][0] = 1;\n  *(uint64_t *)&triangle[1][0] = 4294967297LL;\n  do {\n    v6[30] = 1;\n    v8 = v6;\n    do {\n      v9 = (unsigned long long)&v8[v7];\n      v10 = *v8 + v8[1];\n      ++v8;\n      *(uint32_t *)(v9 + v4 + 4) = v10;\n    } while (v8 != v3);\n    ++v5;\n    v3 += 31;\n    v6 += 30;\n    v7 -= 30LL;\n    v4 += 120LL;\n    *v3 = 1;\n  } while (v5 != 20);\n  v11 = 1;\n  v12 = (unsigned int)(triangle[19][10] / 10);\n  if (!(uint32_t)v12) goto LABEL_17;\n  do {\n    ++v11;\n    v9 = (unsigned int)((int)v12 >> 31);\n    v13 = (int)v12 / 10;\n    v12 = (unsigned int)((int)v12 / 10);\n  } while (v13);\n  if ((v11 & 1) != 0)\n  LABEL_17:\n    ++v11;\n  v14 = v11;\n  v15 = triangle[0];\n  v16 = v11 + 2;\n  v21 = (v14 >> 1) + 1;\n  v17 = 1LL;\n  row_offset = 19 * v21;\n  while (1) {\n    v18 = 0;\n    if (row_offset > 0) {\n      do {\n        ++v18;\n        libmin_printf(\" \", v3, v12, v9, v4, v6);\n      } while (v18 != row_offset);\n    }\n    v19 = 0LL;\n    do {\n      v3 = (int *)v16;\n      if (print_centered(v15[v19], v16)) {\n        libmin_printf(\"%s: error printing element %d,%d\\n\", \"pascal\", v17 - 1,\n                      v19);\n        libmin_fail(1);\n      }\n      ++v19;\n    } while (v17 != v19);\n    ++v17;\n    v15 += 30;\n    libmin_printf(\"\\n\");\n    v9 = v21;\n    row_offset -= v21;\n    if (v17 == 21) libmin_success();\n  }\n}", "binary": "pascal/pascal.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x1,%r10d\nlea    0x41e9(%rip),%rsi\nmov    $0xf0,%r8d\npush   %r14\nadd    $0x1,%r10d\nlea    -0x4(%rsi),%r9\nmov    $0xffffffffffffff88,%rdi\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmovl   $0x1,0x4142(%rip)\nmovl   $0x1,0x41b0(%rip)\nmovl   $0x1,(%rsi)\ncmp    $0x14,%r10d\nje     119f <main+0x9f>\nnopl   0x0(%rax)\nmovl   $0x1,0x78(%r9)\nmov    %r9,%rax\nnopl   0x0(%rax,%rax,1)\nmov    0x4(%rax),%edx\nlea    (%rax,%rdi,1),%rcx\nadd    (%rax),%edx\nadd    $0x4,%rax\nmov    %edx,0x4(%rcx,%r8,1)\ncmp    %rsi,%rax\njne    1168 <main+0x68>\nadd    $0x1,%r10d\nadd    $0x7c,%rsi\nadd    $0x78,%r9\nsub    $0x78,%rdi\nadd    $0x78,%r8\nmovl   $0x1,(%rsi)\ncmp    $0x14,%r10d\njne    1158 <main+0x58>\nmovslq 0x49ea(%rip),%rdx\nmov    $0x1,%r13d\nmov    %rdx,%rax\nimul   $0x66666667,%rdx,%rdx\nsar    $0x1f,%eax\nsar    $0x22,%rdx\nsub    %eax,%edx\nje     12e7 <main+0x1e7>\nnopl   (%rax)\nmovslq %edx,%rax\nmov    %edx,%ecx\nadd    $0x1,%r13d\nimul   $0x66666667,%rax,%rax\nsar    $0x1f,%ecx\nsar    $0x22,%rax\nsub    %ecx,%eax\nmov    %eax,%edx\njne    11c8 <main+0xc8>\ntest   $0x1,%r13b\njne    12e7 <main+0x1e7>\nmov    %r13d,%eax\nlea    0x4087(%rip),%rbp\nadd    $0x2,%r13d\nsar    %eax\nlea    0x1dfe(%rip),%r14\nlea    0x1(%rax),%ebx\nlea    (%rbx,%rbx,8),%eax\nmov    %ebx,0xc(%rsp)\nlea    (%rbx,%rax,2),%eax\nmov    $0x1,%ebx\nmov    %eax,0x8(%rsp)\nnopl   0x0(%rax)\nlea    -0x1(%rbx),%eax\nmov    0x8(%rsp),%r12d\nxor    %r15d,%r15d\nmov    %eax,0x4(%rsp)\nmov    0x8(%rsp),%eax\ntest   %eax,%eax\njle    1253 <main+0x153>\nnopw   0x0(%rax,%rax,1)\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x1,%r15d\ncall   2a60 <libmin_printf>\ncmp    %r12d,%r15d\njne    1240 <main+0x140>\nxor    %r12d,%r12d\njmp    1269 <main+0x169>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%r12\ncmp    %r12,%rbx\nje     12a9 <main+0x1a9>\nmov    0x0(%rbp,%r12,4),%edi\nmov    %r13d,%esi\ncall   1430 <print_centered>\ntest   %eax,%eax\nje     1260 <main+0x160>\nmov    0x4(%rsp),%edx\nmov    %r12d,%ecx\nlea    0x1d81(%rip),%rsi\nxor    %eax,%eax\nlea    0x1d87(%rip),%rdi\nadd    $0x1,%r12\ncall   2a60 <libmin_printf>\nmov    $0x1,%edi\ncall   16e0 <libmin_fail>\ncmp    %r12,%rbx\njne    1269 <main+0x169>\nlea    0x1d60(%rip),%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\nadd    $0x78,%rbp\ncall   2a60 <libmin_printf>\nmov    0xc(%rsp),%ecx\nsub    %ecx,0x8(%rsp)\ncmp    $0x15,%rbx\njne    1220 <main+0x120>\ncall   2ca0 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nadd    $0x1,%r13d\njmp    11ef <main+0xef>\n"}
{"source": {"path": "pascal/pascal.c", "function_name": "num_digits", "content": "/* num_digits: count how man digits the argument has and return that number */\n\nint num_digits(int n) {\n\n\tint d = 1;\n\n\t\n\twhile((n=n/10) != 0)\n    d++;\n\treturn d;\n}\n"}, "pseudo": {"path": "pascal/pascal.host.O2.pseudo", "function_name": "num_digits", "address": "0x13e0", "label": "num_digits", "content": "int __fastcall num_digits(int n)\n{\n  int v1; // r8d\n  int i; // edx\n\n  v1 = 1;\n  for ( i = n / 10; i; i /= 10 )\n    ++v1;\n  return v1;\n}\n"}, "pseudo_normalize": "int num_digits(int n) {\n  int v1;\n  int i;\n  v1 = 1;\n  for (i = n / 10; i; i /= 10) ++v1;\n  return v1;\n}", "binary": "pascal/pascal.host.O2", "assembly": "<num_digits>:\nendbr64\nmovslq %edi,%rdx\nsar    $0x1f,%edi\nmov    $0x1,%r8d\nimul   $0x66666667,%rdx,%rdx\nsar    $0x22,%rdx\nsub    %edi,%edx\nje     141d <num_digits+0x3d>\nnop\nmovslq %edx,%rax\nmov    %edx,%ecx\nadd    $0x1,%r8d\nimul   $0x66666667,%rax,%rax\nsar    $0x1f,%ecx\nsar    $0x22,%rax\nsub    %ecx,%eax\nmov    %eax,%edx\njne    1400 <num_digits+0x20>\nmov    %r8d,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "pascal/pascal.c", "function_name": "print_centered", "content": "/* print_centered: print the first argument centered in a field of \n\twidth given by the second argument, to the extent possible.\n\t(The width is always the second argument, but the number may not\n        be quite centered, depending on parity.) \n\tReturn 0 if successful and 1 if not.\n*/\n\nint print_centered(int n, int width)\n{\n\tint nw;\n\tint pad_space;\n\tint i;\n\n\tnw = num_digits(n);\n\tif(width < nw) return 1;  /* no can do */\n\n\tpad_space = (width - nw)/2;\n\n\tfor(i=0;i<pad_space;i++)\n\t  libmin_printf(\" \");\n\tlibmin_printf(\"%d\",n);\n\tfor(i=0;i<width - nw - pad_space;i++)\n\t  libmin_printf(\" \");\n\treturn 0;\n}\n"}, "pseudo": {"path": "pascal/pascal.host.O2.pseudo", "function_name": "print_centered", "address": "0x1430", "label": "print_centered", "content": "int __fastcall print_centered(int n, int width)\n{\n  int v3; // edi\n  int v4; // ebp\n  __int64 v5; // rdx\n  int v6; // eax\n  int result; // eax\n  __int64 v8; // rsi\n  int v9; // r12d\n  int v10; // ebx\n  int v11; // ebp\n\n  v3 = 1;\n  v4 = n;\n  v5 = (unsigned int)(n / 10);\n  if ( (_DWORD)v5 )\n  {\n    do\n    {\n      ++v3;\n      v6 = (int)v5 / 10;\n      v5 = (unsigned int)((int)v5 / 10);\n    }\n    while ( v6 );\n  }\n  result = 1;\n  if ( width >= v3 )\n  {\n    v8 = (unsigned int)(width - v3);\n    v9 = (int)v8 >> 1;\n    if ( (int)v8 >> 1 )\n    {\n      v10 = 0;\n      do\n      {\n        ++v10;\n        libmin_printf(\" \", v8, v5);\n      }\n      while ( v9 != v10 );\n    }\n    libmin_printf(\"%d\", v4);\n    v11 = 0;\n    if ( (int)v8 - v9 > 0 )\n    {\n      do\n      {\n        ++v11;\n        libmin_printf(\" \");\n      }\n      while ( v11 != (_DWORD)v8 - v9 );\n    }\n    return 0;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int print_centered(int n, int width) {\n  int v3;\n  int v4;\n  long long v5;\n  int v6;\n  int result;\n  long long v8;\n  int v9;\n  int v10;\n  int v11;\n  v3 = 1;\n  v4 = n;\n  v5 = (unsigned int)(n / 10);\n  if ((uint32_t)v5) {\n    do {\n      ++v3;\n      v6 = (int)v5 / 10;\n      v5 = (unsigned int)((int)v5 / 10);\n    } while (v6);\n  }\n  result = 1;\n  if (width >= v3) {\n    v8 = (unsigned int)(width - v3);\n    v9 = (int)v8 >> 1;\n    if ((int)v8 >> 1) {\n      v10 = 0;\n      do {\n        ++v10;\n        libmin_printf(\" \", v8, v5);\n      } while (v9 != v10);\n    }\n    libmin_printf(\"%d\", v4);\n    v11 = 0;\n    if ((int)v8 - v9 > 0) {\n      do {\n        ++v11;\n        libmin_printf(\" \");\n      } while (v11 != (uint32_t)v8 - v9);\n    }\n    return 0;\n  }\n  return result;\n}", "binary": "pascal/pascal.host.O2", "assembly": "<print_centered>:\nendbr64\nmovslq %edi,%rdx\npush   %r14\nmov    $0x1,%edi\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdx,%rbp\nimul   $0x66666667,%rdx,%rdx\nmov    %ebp,%eax\npush   %rbx\nsar    $0x1f,%eax\nsar    $0x22,%rdx\nsub    %eax,%edx\nje     147c <print_centered+0x4c>\nnopl   0x0(%rax,%rax,1)\nmovslq %edx,%rax\nmov    %edx,%ecx\nadd    $0x1,%edi\nimul   $0x66666667,%rax,%rax\nsar    $0x1f,%ecx\nsar    $0x22,%rax\nsub    %ecx,%eax\nmov    %eax,%edx\njne    1460 <print_centered+0x30>\nmov    $0x1,%eax\ncmp    %edi,%esi\njl     14ec <print_centered+0xbc>\nsub    %edi,%esi\nmov    %esi,%r12d\nmov    %esi,%r14d\nsar    %r12d\nje     14b2 <print_centered+0x82>\nxor    %ebx,%ebx\nlea    0x1b69(%rip),%r13\nnopl   0x0(%rax,%rax,1)\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebx\ncall   2a60 <libmin_printf>\ncmp    %ebx,%r12d\njne    14a0 <print_centered+0x70>\nmov    %ebp,%esi\nlea    0x1b4b(%rip),%rdi\nxor    %eax,%eax\nsub    %r12d,%r14d\ncall   2a60 <libmin_printf>\nxor    %ebp,%ebp\nlea    0x1b36(%rip),%r13\ntest   %r14d,%r14d\njle    14ea <print_centered+0xba>\nnopl   0x0(%rax,%rax,1)\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%ebp\ncall   2a60 <libmin_printf>\ncmp    %r14d,%ebp\njne    14d8 <print_centered+0xa8>\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "pi-calc/pi-calc.c", "function_name": "main", "content": "int main(void){for(;(b=c-=14);h=libmin_printf(\"%04d\",e+d/f))for(e=d%=f;(g=--b*2);d/=g)d=d*b+f*(h?a[b]:f/5),a[b]=d%--g;libmin_success(); return 0;}\n"}, "pseudo": {"path": "pi-calc/pi-calc.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r11d\n  int v4; // r8d\n  int v5; // r12d\n  int v6; // edx\n  int v7; // esi\n  int v8; // r10d\n  __int64 v9; // rcx\n  int v10; // edi\n  int v11; // eax\n  int v12; // eax\n  int v13; // edx\n  int v14; // kr00_4\n  __int64 v15; // rt2\n\n  v3 = c - 14;\n  c = v3;\n  for ( b = v3; v3; b = v3 )\n  {\n    v4 = f;\n    v5 = v3 - 1;\n    b = v3 - 1;\n    g = 2 * (v3 - 1);\n    v6 = d % f;\n    d = v6;\n    v7 = v6;\n    e = v6;\n    if ( v3 == 1 )\n    {\n      v11 = v6;\n    }\n    else\n    {\n      v8 = h;\n      v9 = v5;\n      v10 = 2 * v5 - 1;\n      v11 = v6;\n      do\n      {\n        v12 = v9 * v11;\n        v13 = v4 / 5;\n        if ( v8 )\n          v13 = a[v9];\n        v14 = v4 * v13 + v12;\n        v15 = v14 % (__int64)v10;\n        v11 = v14 / v10;\n        v10 -= 2;\n        a[v9--] = v15;\n      }\n      while ( (_DWORD)v9 );\n      d = v11;\n      b = 0;\n      g = 0;\n    }\n    h = libmin_printf(\"%04d\", v11 / v4 + v7);\n    v3 = c - 14;\n    c = v3;\n  }\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v8;\n  long long v9;\n  int v10;\n  int v11;\n  int v12;\n  int v13;\n  int v14;\n  long long v15;\n  v3 = c - 14;\n  c = v3;\n  for (b = v3; v3; b = v3) {\n    v4 = f;\n    v5 = v3 - 1;\n    b = v3 - 1;\n    g = 2 * (v3 - 1);\n    v6 = d % f;\n    d = v6;\n    v7 = v6;\n    e = v6;\n    if (v3 == 1) {\n      v11 = v6;\n    } else {\n      v8 = h;\n      v9 = v5;\n      v10 = 2 * v5 - 1;\n      v11 = v6;\n      do {\n        v12 = v9 * v11;\n        v13 = v4 / 5;\n        if (v8) v13 = a[v9];\n        v14 = v4 * v13 + v12;\n        v15 = v14 % (long long)v10;\n        v11 = v14 / v10;\n        v10 -= 2;\n        a[v9--] = v15;\n      } while ((uint32_t)v9);\n      d = v11;\n      b = 0;\n      g = 0;\n    }\n    h = libmin_printf(\"%04d\", v11 / v4 + v7);\n    v3 = c - 14;\n    c = v3;\n  }\n  libmin_success();\n}", "binary": "pi-calc/pi-calc.host.O2", "assembly": "<main>:\nendbr64\nmov    0x3f0a(%rip),%eax\npush   %r12\npush   %rbp\nlea    -0xe(%rax),%r11d\npush   %rbx\nmov    %r11d,0x3efb(%rip)\nmov    %r11d,0x4170(%rip)\ntest   %r11d,%r11d\nje     1224 <main+0x124>\nlea    0x1ed4(%rip),%rbx\nlea    0x4169(%rip),%rbp\nnopw   0x0(%rax,%rax,1)\nmov    0x4146(%rip),%eax\nmov    0x3ec3(%rip),%r8d\nlea    -0x1(%r11),%r12d\nlea    (%r12,%r12,1),%edi\nmov    %r12d,0x4134(%rip)\ncltd\nmov    %edi,0x4121(%rip)\nidiv   %r8d\nmov    %edx,0x4120(%rip)\nmov    %edx,%esi\nmov    %edx,0x4114(%rip)\ntest   %r12d,%r12d\nje     1230 <main+0x130>\nmovslq %r8d,%r9\nmov    %r8d,%eax\nmov    0x40f6(%rip),%r10d\nmovslq %r12d,%rcx\nimul   $0x66666667,%r9,%r9\nsar    $0x1f,%eax\nsub    $0x1,%edi\nsar    $0x21,%r9\nsub    %eax,%r9d\nmov    %edx,%eax\nnopl   0x0(%rax,%rax,1)\nimul   %ecx,%eax\nmov    %r9d,%edx\ntest   %r10d,%r10d\nje     11b7 <main+0xb7>\nmov    0x0(%rbp,%rcx,4),%edx\nimul   %r8d,%edx\nadd    %edx,%eax\ncltd\nidiv   %edi\nsub    $0x2,%edi\nmov    %edx,0x0(%rbp,%rcx,4)\nsub    $0x1,%rcx\ntest   %ecx,%ecx\njne    11a8 <main+0xa8>\nsub    %r11d,%r12d\nmov    %eax,0x40b4(%rip)\nmovl   $0x0,0x40ae(%rip)\nlea    0x2(%r12,%r12,1),%edx\nmov    %edx,0x4097(%rip)\ncltd\nmov    %rbx,%rdi\nidiv   %r8d\nadd    %eax,%esi\nxor    %eax,%eax\ncall   2870 <libmin_printf>\nmov    %eax,0x407d(%rip)\nmov    0x3e0b(%rip),%eax\nlea    -0xe(%rax),%r11d\nmov    %r11d,0x3e00(%rip)\nmov    %r11d,0x4075(%rip)\ntest   %r11d,%r11d\njne    1140 <main+0x40>\ncall   2ab0 <libmin_success>\npop    %rbx\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\nmov    %edx,%eax\njmp    11ed <main+0xed>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "get_random_int", "content": "/*\n * This function generates a random integer between in the interval\n * [low, high].  As we divide by (high - low + 1) in the process, we need\n * low < high.\n */\nuint64_t get_random_int(uint64_t low, uint64_t high)\n{\n\treturn (uint64_t)libmin_rand() % (high - low + 1) + low;\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O2.pseudo", "function_name": "get_random_int", "address": "0x14a0", "label": "get_random_int", "content": "uint64_t __fastcall get_random_int(uint64_t low, uint64_t high)\n{\n  return libmin_rand() % (high - low + 1) + low;\n}\n"}, "pseudo_normalize": "", "binary": "primal-test/primal-test.host.O2", "assembly": "<get_random_int>:\nendbr64\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    %rbp,%rbx\nsub    $0x8,%rsp\ncall   3690 <libmin_rand>\nlea    0x1(%rbx),%rsi\nxor    %edx,%edx\nadd    $0x8,%rsp\nmov    %eax,%eax\npop    %rbx\ndiv    %rsi\nlea    (%rdx,%rbp,1),%rax\npop    %rbp\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "main", "content": "int\nmain(void)\n{\n  // initialize the RNG\n  libmin_srand(42);\n\n  // locate primes in a stream of random numbers\n  {\n    uint32_t val = 3;\n    for (int i=0; i < 200; i++)\n    {\n      int32_t prim = miller_rabin_int(val, K);\n      int _pred = (prim != PT_COMPOSITE);\n      if (_pred)\n      {\n        q[q_head].val = val;\n        q[q_head].prim = prim;\n        if (q_head+1 < Q_SIZE)\n          q_head++;\n      }\n      val = libmin_rand();\n    } \n  }\n\n  // print out the primes that were found\n  libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n  for (int i=0; i < q_head; i++)\n  {\n    if (q[i].prim == PT_PRIME)\n      libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\", q[i].val);\n    else if (q[i].prim == PT_PRIME_LIKELY)\n      libmin_printf(\"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\", q[i].val, libmin_pow(4.0, K));\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm2_8\n  int v4; // ebp\n  uint32_t v5; // ebx\n  int32_t v6; // eax\n  __int64 v7; // rcx\n  struct {uint32_t val;int32_t prim;} *v8; // rbx\n  int v9; // ebp\n  int32_t prim; // eax\n  uint32_t val; // esi\n  double v12; // xmm0_8\n\n  v4 = 200;\n  v5 = 3;\n  libmin_srand(0x2Au);\n  while ( 1 )\n  {\n    while ( (v5 & 1) == 0 )\n    {\n      v6 = 1;\n      if ( v5 == 2 )\n        goto LABEL_5;\n      v5 = libmin_rand();\n      if ( !--v4 )\n      {\nLABEL_11:\n        libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n        if ( q_head > 0 )\n        {\n          v8 = q;\n          v9 = 0;\n          do\n          {\n            while ( 1 )\n            {\n              prim = v8->prim;\n              if ( prim != 1 )\n                break;\n              val = v8->val;\n              ++v9;\n              ++v8;\n              libmin_printf(\"Value %u is `prime' with failure probability (0)\\n\", val);\n              if ( q_head <= v9 )\n                goto LABEL_18;\n            }\n            if ( prim == 2 )\n            {\n              v12 = libmin_pow(16.0, v3);\n              libmin_printf(\"Value %u is `likely prime' with failure probability (1 in %.0lf)\\n\", v8->val, v12);\n            }\n            ++v9;\n            ++v8;\n          }\n          while ( q_head > v9 );\n        }\nLABEL_18:\n        libmin_success();\n      }\n    }\n    if ( v5 == 3 )\n      break;\n    if ( v5 > 2 )\n    {\n      v6 = miller_rabin_int_0(v5, 0x10u);\n      if ( v6 )\n        goto LABEL_5;\n    }\nLABEL_7:\n    v5 = libmin_rand();\n    if ( !--v4 )\n      goto LABEL_11;\n  }\n  v6 = 1;\nLABEL_5:\n  v7 = q_head;\n  q[q_head].val = v5;\n  q[v7].prim = v6;\n  if ( (int)v7 <= 62 )\n    q_head = v7 + 1;\n  goto LABEL_7;\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  int v4;\n  uint32_t v5;\n  int32_t v6;\n  long long v7;\n  struct {\n    uint32_t val;\n    int32_t prim;\n  } * v8;\n  int v9;\n  int32_t prim;\n  uint32_t val;\n  double v12;\n  v4 = 200;\n  v5 = 3;\n  libmin_srand(42u);\n  while (1) {\n    while ((v5 & 1) == 0) {\n      v6 = 1;\n      if (v5 == 2) goto LABEL_5;\n      v5 = libmin_rand();\n      if (!--v4) {\n      LABEL_11:\n        libmin_printf(\"Primality tests found %d primes...\\n\", q_head);\n        if (q_head > 0) {\n          v8 = q;\n          v9 = 0;\n          do {\n            while (1) {\n              prim = v8->prim;\n              if (prim != 1) break;\n              val = v8->val;\n              ++v9;\n              ++v8;\n              libmin_printf(\n                  \"Value %u is `prime' with failure probability (0)\\n\", val);\n              if (q_head <= v9) goto LABEL_18;\n            }\n            if (prim == 2) {\n              v12 = libmin_pow(16.0, v3);\n              libmin_printf(\n                  \"Value %u is `likely prime' with failure probability (1 in \"\n                  \"%.0lf)\\n\",\n                  v8->val, v12);\n            }\n            ++v9;\n            ++v8;\n          } while (q_head > v9);\n        }\n      LABEL_18:\n        libmin_success();\n      }\n    }\n    if (v5 == 3) break;\n    if (v5 > 2) {\n      v6 = miller_rabin_int_0(v5, 16u);\n      if (v6) goto LABEL_5;\n    }\n  LABEL_7:\n    v5 = libmin_rand();\n    if (!--v4) goto LABEL_11;\n  }\n  v6 = 1;\nLABEL_5:\n  v7 = q_head;\n  q[q_head].val = v5;\n  q[v7].prim = v6;\n  if ((int)v7 <= 62) q_head = v7 + 1;\n  goto LABEL_7;\n}", "binary": "primal-test/primal-test.host.O2", "assembly": "<main>:\nendbr64\npush   %r13\nmov    $0x2a,%edi\npush   %r12\nlea    0x518c(%rip),%r12\npush   %rbp\nmov    $0xc8,%ebp\npush   %rbx\nmov    $0x3,%ebx\nsub    $0x8,%rsp\ncall   3630 <libmin_srand>\njmp    117b <main+0x7b>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x3,%ebx\nje     1220 <main+0x120>\ncmp    $0x2,%ebx\njbe    116f <main+0x6f>\nmov    $0x10,%esi\nmov    %ebx,%edi\ncall   1360 <miller_rabin_int.part.0>\ntest   %eax,%eax\nje     116f <main+0x6f>\nmovslq 0x512b(%rip),%rcx\nmov    %ebx,(%r12,%rcx,8)\nmov    %rcx,%rdx\nmov    %eax,0x4(%r12,%rcx,8)\ncmp    $0x3e,%ecx\njg     116f <main+0x6f>\nadd    $0x1,%edx\nmov    %edx,0x5111(%rip)\ncall   3690 <libmin_rand>\nmov    %eax,%ebx\nsub    $0x1,%ebp\nje     1196 <main+0x96>\ntest   $0x1,%bl\njne    1130 <main+0x30>\nmov    $0x1,%eax\ncmp    $0x2,%ebx\nje     114e <main+0x4e>\ncall   3690 <libmin_rand>\nmov    %eax,%ebx\nsub    $0x1,%ebp\njne    117b <main+0x7b>\nmov    0x50e4(%rip),%esi\nlea    0x2e65(%rip),%rdi\nxor    %eax,%eax\ncall   3420 <libmin_printf>\nmov    0x50d0(%rip),%eax\ntest   %eax,%eax\njle    1207 <main+0x107>\nlea    0x50e5(%rip),%rbx\nxor    %ebp,%ebp\nlea    0x2ea4(%rip),%r13\nlea    0x2e65(%rip),%r12\njmp    11e4 <main+0xe4>\nnopl   (%rax)\ncmp    $0x2,%eax\nje     1230 <main+0x130>\nadd    $0x1,%ebp\nadd    $0x8,%rbx\ncmp    %ebp,0x509e(%rip)\njle    1207 <main+0x107>\nmov    0x4(%rbx),%eax\ncmp    $0x1,%eax\njne    11d0 <main+0xd0>\nmov    (%rbx),%esi\nxor    %eax,%eax\nmov    %r12,%rdi\nadd    $0x1,%ebp\nadd    $0x8,%rbx\ncall   3420 <libmin_printf>\ncmp    %ebp,0x507b(%rip)\njg     11e4 <main+0xe4>\ncall   3b40 <libmin_success>\nadd    $0x8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nmov    $0x1,%eax\njmp    114e <main+0x4e>\nnopw   0x0(%rax,%rax,1)\nmov    0x2e79(%rip),%rax\nmovq   %rax,%xmm1\nmov    0x2e75(%rip),%rax\nmovq   %rax,%xmm0\ncall   1730 <libmin_pow>\nmov    (%rbx),%esi\nmov    %r13,%rdi\nmov    $0x1,%eax\ncall   3420 <libmin_printf>\njmp    11d5 <main+0xd5>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "miller_rabin_int", "content": "/*\n * This function checks whether a given number n is a prime or not, using the\n * Miller-Rabin primality test.  This is a probabilistic test which randomly\n * chooses an integer a as a base and checks whether n satisfies a certain\n * property (which depends on b).  If it does, n is a prime for at least three\n * out of four of the possible values of a, if it does not, it is certainly not\n * prime.\n *\n * The implementation is taken from the pseudo code found on\n * http://en.wikipedia.org/wiki/Miller-Rabin_primality_test.\n *\n * The function returns `probably_prime` if it found no evidence, that n might\n * be composite and `composite` if it did find a counter example.\n */\nint32_t\nmiller_rabin_int(uint32_t n, uint32_t k)\n{\n\tuint64_t s;\n\tuint64_t a = 0, d, x, nm1;\n\t/* We need an odd integer greater than 3 */\n\tif ((n & 1) == 0)\n\t\treturn n == 2 ? PT_PRIME : PT_COMPOSITE;\n\tif (n == 3)\n\t\treturn PT_PRIME;\n\telse if (n < 3)\n\t\treturn PT_COMPOSITE;\n\n\tnm1 = n - 1;\n\n\t/* compute s and d s.t. n-1=2^s*d */\n\tsplit_int(&s, &d, n);\n\n\t/* Repeat the test itself k times to increase the accuracy */\n\tfor (unsigned i = 0; i < k; i++) {\n\t\ta = get_random_int(2, n - 2);\n\n\t\t/* compute a^d mod n */\n\t\tx = powm(a, d, n);\n\n\t\tif (x == 1 || x == nm1)\n\t\t\tcontinue;\n\n\t\tfor (uint64_t r = 1; r <= s; r++) {\n\t\t\tx = (x * x) % n;\n\t\t\tif (x == 1)\n\t\t\t\treturn PT_COMPOSITE;\n\t\t\tif (x == nm1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (x != nm1)\n\t\t\treturn PT_COMPOSITE;\n\t}\n\n\treturn PT_PRIME_LIKELY;\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O2.pseudo", "function_name": "miller_rabin_int", "address": "0x1510", "label": "miller_rabin_int", "content": "int32_t __fastcall miller_rabin_int(uint32_t n, uint32_t k)\n{\n  if ( (n & 1) == 0 )\n    return n == 2;\n  if ( n == 3 )\n    return 1;\n  if ( n <= 2 )\n    return 0;\n  return miller_rabin_int_0(n, k);\n}\n"}, "pseudo_normalize": "int32_t miller_rabin_int(uint32_t n, uint32_t k) {\n  if ((n & 1) == 0) return n == 2;\n  if (n == 3) return 1;\n  if (n <= 2) return 0;\n  return miller_rabin_int_0(n, k);\n}", "binary": "primal-test/primal-test.host.O2", "assembly": "<miller_rabin_int>:\nendbr64\ntest   $0x1,%dil\nje     1530 <miller_rabin_int+0x20>\ncmp    $0x3,%edi\nje     1543 <miller_rabin_int+0x33>\ncmp    $0x2,%edi\njbe    1540 <miller_rabin_int+0x30>\njmp    1360 <miller_rabin_int.part.0>\nnopl   0x0(%rax)\nxor    %eax,%eax\ncmp    $0x2,%edi\nsete   %al\nret\nnopl   0x0(%rax)\nxor    %eax,%eax\nret\nmov    $0x1,%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "primal-test/primal-test.c", "function_name": "split_int", "content": "/*\n * Calculate s, d such that n-1=2^s*d where d is odd.\n */\nvoid split_int(uint64_t *s, uint64_t *d, uint64_t n)\n{\n\t*s = 0;\n\t*d = n - 1;\n\n\twhile ((*d & 1) == 0)\n  {\n\t\t(*s)++;\n\t\t*d /= 2;\n\t}\n}\n"}, "pseudo": {"path": "primal-test/primal-test.host.O2.pseudo", "function_name": "split_int", "address": "0x14d0", "label": "split_int", "content": "void __fastcall split_int(uint64_t *s, uint64_t *d, uint64_t n)\n{\n  uint64_t v3; // rdx\n  uint64_t v4; // rax\n\n  v3 = n - 1;\n  *s = 0LL;\n  *d = v3;\n  if ( (v3 & 1) == 0 )\n  {\n    do\n    {\n      ++*s;\n      v4 = *d >> 1;\n      *d = v4;\n    }\n    while ( (v4 & 1) == 0 );\n  }\n}\n"}, "pseudo_normalize": "void split_int(uint64_t *s, uint64_t *d, uint64_t n) {\n  uint64_t v3;\n  uint64_t v4;\n  v3 = n - 1;\n  *s = 0LL;\n  *d = v3;\n  if ((v3 & 1) == 0) {\n    do {\n      ++*s;\n      v4 = *d >> 1;\n      *d = v4;\n    } while ((v4 & 1) == 0);\n  }\n}", "binary": "primal-test/primal-test.host.O2", "assembly": "<split_int>:\nendbr64\nsub    $0x1,%rdx\nmovq   $0x0,(%rdi)\nmov    %rdx,(%rsi)\nand    $0x1,%edx\njne    1501 <split_int+0x31>\nnopw   0x0(%rax,%rax,1)\naddq   $0x1,(%rdi)\nmov    (%rsi),%rax\nshr    %rax\nmov    %rax,(%rsi)\ntest   $0x1,%al\nje     14f0 <split_int+0x20>\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "isEmpty", "content": "// Function to check is list is empty\nint isEmpty(Node** head)\n{\n    return (*head) == NULL;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O2.pseudo", "function_name": "isEmpty", "address": "0x1420", "label": "isEmpty", "content": "int __fastcall isEmpty(Node **head)\n{\n  return *head == 0LL;\n}\n"}, "pseudo_normalize": "", "binary": "priority-queue/priority-queue.host.O2", "assembly": "<isEmpty>:\nendbr64\nxor    %eax,%eax\ncmpq   $0x0,(%rdi)\nsete   %al\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "main", "content": "// Driver code\nint main()\n{\n    // Create a Priority Queue\n    // 7->4->5->6\n    Node* pq = newNode(4, 1);\n    push(&pq, 5, 2);\n    push(&pq, 6, 3);\n    push(&pq, 7, 0);\n    printPQ(&pq);\n\n    libmin_srand(42);\n    pq = newNode(4, 1);\n    for (int i=0; i < 250; i++)\n    {\n      int prio = libmin_rand() % 250;\n      int val = libmin_rand() % 250;\n      push(&pq, prio, val);\n    }\n    printPQ(&pq);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Node *v3; // rax\n  Node *v4; // rax\n  int v5; // ebx\n  unsigned int v6; // r12d\n  unsigned int v7; // eax\n  Node *pq[5]; // [rsp+0h] [rbp+0h] BYREF\n\n  pq[1] = (Node *)__readfsqword(0x28u);\n  v3 = (Node *)libmin_malloc(0x10uLL);\n  *(_QWORD *)&v3->data = 0x100000004LL;\n  v3->next = 0LL;\n  pq[0] = v3;\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(0x2Au);\n  v4 = (Node *)libmin_malloc(0x10uLL);\n  v4->next = 0LL;\n  pq[0] = v4;\n  *(_QWORD *)&v4->data = 0x100000004LL;\n  v5 = 250;\n  do\n  {\n    v6 = libmin_rand();\n    v7 = libmin_rand();\n    push(pq, v6 % 0xFA, v7 % 0xFA);\n    --v5;\n  }\n  while ( v5 );\n  printPQ(pq);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  Node *v3;\n  Node *v4;\n  int v5;\n  unsigned int v6;\n  unsigned int v7;\n  Node *pq[5];\n  pq[1] = (Node *)__readfsqword(40u);\n  v3 = (Node *)libmin_malloc(16uLL);\n  *(uint64_t *)&v3->data = 4294967300LL;\n  v3->next = 0LL;\n  pq[0] = v3;\n  push(pq, 5, 2);\n  push(pq, 6, 3);\n  push(pq, 7, 0);\n  printPQ(pq);\n  libmin_srand(42u);\n  v4 = (Node *)libmin_malloc(16uLL);\n  v4->next = 0LL;\n  pq[0] = v4;\n  *(uint64_t *)&v4->data = 4294967300LL;\n  v5 = 250;\n  do {\n    v6 = libmin_rand();\n    v7 = libmin_rand();\n    push(pq, v6 % 250, v7 % 250);\n    --v5;\n  } while (v5);\n  printPQ(pq);\n  libmin_success();\n}", "binary": "priority-queue/priority-queue.host.O2", "assembly": "<main>:\nendbr64\npush   %r12\nmov    $0x10,%edi\npush   %rbp\npush   %rbx\nmovabs $0x100000004,%rbx\nsub    $0x10,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbp\ncall   1710 <libmin_malloc>\nmov    $0x2,%edx\nmov    $0x5,%esi\nmov    %rbp,%rdi\nmov    %rbx,(%rax)\nmovq   $0x0,0x8(%rax)\nmov    %rax,(%rsp)\ncall   13a0 <push>\nmov    $0x3,%edx\nmov    $0x6,%esi\nmov    %rbp,%rdi\ncall   13a0 <push>\nxor    %edx,%edx\nmov    $0x7,%esi\nmov    %rbp,%rdi\ncall   13a0 <push>\nmov    %rbp,%rdi\ncall   1430 <printPQ>\nmov    $0x2a,%edi\ncall   2ec0 <libmin_srand>\nmov    $0x10,%edi\ncall   1710 <libmin_malloc>\nmovq   $0x0,0x8(%rax)\nmov    %rax,(%rsp)\nmov    %rbx,(%rax)\nmov    $0xfa,%ebx\nnopl   (%rax)\ncall   2f20 <libmin_rand>\nmov    %eax,%r12d\ncall   2f20 <libmin_rand>\nmov    %r12d,%esi\nmov    %rbp,%rdi\nmov    %eax,%ecx\nimul   $0x10624dd3,%rcx,%rcx\nshr    $0x24,%rcx\nimul   $0xfa,%ecx,%ecx\nsub    %ecx,%eax\nmov    %r12d,%ecx\nimul   $0x10624dd3,%rcx,%rcx\nmov    %eax,%edx\nshr    $0x24,%rcx\nimul   $0xfa,%ecx,%ecx\nsub    %ecx,%esi\ncall   13a0 <push>\nsub    $0x1,%ebx\njne    11c8 <main+0xa8>\nmov    %rbp,%rdi\ncall   1430 <printPQ>\ncall   3100 <libmin_success>\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    123a <main+0x11a>\nadd    $0x10,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   10c0 <__stack_chk_fail@plt>\nnop\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "newNode", "content": "// Function to Create A New Node\nNode* newNode(int d, int p)\n{\n    Node* temp = (Node*)libmin_malloc(sizeof(Node));\n    temp->data = d;\n    temp->priority = p;\n    temp->next = NULL;\n\n    return temp;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O2.pseudo", "function_name": "newNode", "address": "0x1330", "label": "newNode", "content": "Node *__fastcall newNode(int d, int p)\n{\n  Node *result; // rax\n\n  result = (Node *)libmin_malloc(0x10uLL);\n  result->data = d;\n  result->priority = p;\n  result->next = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "Node *newNode(int d, int p) {\n  Node *result;\n  result = (Node *)libmin_malloc(16uLL);\n  result->data = d;\n  result->priority = p;\n  result->next = 0LL;\n  return result;\n}", "binary": "priority-queue/priority-queue.host.O2", "assembly": "<newNode>:\nendbr64\npush   %rbp\nmov    %edi,%ebp\nmov    $0x10,%edi\npush   %rbx\nmov    %esi,%ebx\nsub    $0x8,%rsp\ncall   1710 <libmin_malloc>\nmov    %ebp,(%rax)\nmov    %ebx,0x4(%rax)\nmovq   $0x0,0x8(%rax)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "peek", "content": "// Return the value at head\nint peek(Node** head)\n{\n    return (*head)->data;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O2.pseudo", "function_name": "peek", "address": "0x1360", "label": "peek", "content": "int __fastcall peek(Node **head)\n{\n  return (*head)->data;\n}\n"}, "pseudo_normalize": "", "binary": "priority-queue/priority-queue.host.O2", "assembly": "<peek>:\nendbr64\nmov    (%rdi),%rax\nmov    (%rax),%eax\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "pop", "content": "// Removes the element with the\n// highest priority form the list\nvoid pop(Node** head)\n{\n    Node* temp = *head;\n    (*head) = (*head)->next;\n    libmin_free(temp);\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O2.pseudo", "function_name": "pop", "address": "0x1380", "label": "pop", "content": "void __fastcall pop(Node **head)\n{\n  Node *v1; // r8\n\n  v1 = *head;\n  *head = (*head)->next;\n  libmin_free(v1);\n}\n"}, "pseudo_normalize": "void pop(Node **head) {\n  Node *v1;\n  v1 = *head;\n  *head = (*head)->next;\n  libmin_free(v1);\n}", "binary": "priority-queue/priority-queue.host.O2", "assembly": "<pop>:\nendbr64\nmov    (%rdi),%r8\nmov    0x8(%r8),%rax\nmov    %rax,(%rdi)\nmov    %r8,%rdi\njmp    17c0 <libmin_free>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "printPQ", "content": "void\nprintPQ(Node** pq)\n{\n  libmin_printf(\"priorityQ: \");\n  while (!isEmpty(pq)) {\n      libmin_printf(\"<prio:%d, val:%d> \", priopeek(pq), peek(pq));\n      pop(pq);\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O2.pseudo", "function_name": "printPQ", "address": "0x1430", "label": "printPQ", "content": "void __fastcall printPQ(Node **pq)\n{\n  Node *i; // rax\n  Node *v3; // rdi\n\n  libmin_printf(\"priorityQ: \");\n  for ( i = *pq; *pq; i = *pq )\n  {\n    libmin_printf(\"<prio:%d, val:%d> \", i->priority, i->data);\n    v3 = *pq;\n    *pq = (*pq)->next;\n    libmin_free(v3);\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void printPQ(Node **pq) {\n  Node *i;\n  Node *v3;\n  libmin_printf(\"priorityQ: \");\n  for (i = *pq; *pq; i = *pq) {\n    libmin_printf(\"<prio:%d, val:%d> \", i->priority, i->data);\n    v3 = *pq;\n    *pq = (*pq)->next;\n    libmin_free(v3);\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "priority-queue/priority-queue.host.O2", "assembly": "<printPQ>:\nendbr64\npush   %rbp\nxor    %eax,%eax\npush   %rbx\nmov    %rdi,%rbx\nlea    0x2bc2(%rip),%rdi\nsub    $0x8,%rsp\ncall   2cb0 <libmin_printf>\nmov    (%rbx),%rax\ntest   %rax,%rax\nje     1486 <printPQ+0x56>\nlea    0x2bb6(%rip),%rbp\nnopw   0x0(%rax,%rax,1)\nmov    0x4(%rax),%esi\nmov    (%rax),%edx\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   2cb0 <libmin_printf>\nmov    (%rbx),%rdi\nmov    0x8(%rdi),%rax\nmov    %rax,(%rbx)\ncall   17c0 <libmin_free>\nmov    (%rbx),%rax\ntest   %rax,%rax\njne    1460 <printPQ+0x30>\nadd    $0x8,%rsp\nlea    0x2b92(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\njmp    2cb0 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "priopeek", "content": "// Return the value at head\nint priopeek(Node** head)\n{\n    return (*head)->priority;\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O2.pseudo", "function_name": "priopeek", "address": "0x1370", "label": "priopeek", "content": "int __fastcall priopeek(Node **head)\n{\n  return (*head)->priority;\n}\n"}, "pseudo_normalize": "", "binary": "priority-queue/priority-queue.host.O2", "assembly": "<priopeek>:\nendbr64\nmov    (%rdi),%rax\nmov    0x4(%rax),%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "priority-queue/priority-queue.c", "function_name": "push", "content": "// Function to push according to priority\nvoid push(Node** head, int d, int p)\n{\n    Node* start = (*head);\n\n    // Create new Node\n    Node* temp = newNode(d, p);\n\n    // Special Case: The head of list has lesser\n    // priority than new node. So insert new\n    // node before head node and change head node.\n    if ((*head)->priority > p) {\n\n        // Insert New Node before head\n        temp->next = *head;\n        (*head) = temp;\n    }\n    else {\n\n        // Traverse the list and find a\n        // position to insert new node\n        while (start->next != NULL &&\n               start->next->priority < p) {\n            start = start->next;\n        }\n\n        // Either at the ends of the list\n        // or at required position\n        temp->next = start->next;\n        start->next = temp;\n    }\n}\n"}, "pseudo": {"path": "priority-queue/priority-queue.host.O2.pseudo", "function_name": "push", "address": "0x13a0", "label": "push", "content": "void __fastcall push(Node **head, int d, int p)\n{\n  Node *v4; // rbx\n  Node *v5; // rax\n  Node *v6; // rdx\n  Node *v7; // rdx\n\n  v4 = *head;\n  v5 = (Node *)libmin_malloc(0x10uLL);\n  v5->next = 0LL;\n  v6 = *head;\n  v5->data = d;\n  v5->priority = p;\n  if ( v6->priority <= p )\n  {\n    do\n    {\n      v7 = v4;\n      v4 = v4->next;\n    }\n    while ( v4 && v4->priority < p );\n    v5->next = v4;\n    v7->next = v5;\n  }\n  else\n  {\n    v5->next = v6;\n    *head = v5;\n  }\n}\n"}, "pseudo_normalize": "void push(Node **head, int d, int p) {\n  Node *v4;\n  Node *v5;\n  Node *v6;\n  Node *v7;\n  v4 = *head;\n  v5 = (Node *)libmin_malloc(16uLL);\n  v5->next = 0LL;\n  v6 = *head;\n  v5->data = d;\n  v5->priority = p;\n  if (v6->priority <= p) {\n    do {\n      v7 = v4;\n      v4 = v4->next;\n    } while (v4 && v4->priority < p);\n    v5->next = v4;\n    v7->next = v5;\n  } else {\n    v5->next = v6;\n    *head = v5;\n  }\n}", "binary": "priority-queue/priority-queue.host.O2", "assembly": "<push>:\nendbr64\npush   %r13\nmov    %esi,%r13d\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %edx,%ebp\npush   %rbx\nsub    $0x8,%rsp\nmov    (%rdi),%rbx\nmov    $0x10,%edi\ncall   1710 <libmin_malloc>\nmovq   $0x0,0x8(%rax)\nmov    (%r12),%rdx\nmov    %r13d,(%rax)\nmov    %ebp,0x4(%rax)\ncmp    %ebp,0x4(%rdx)\njle    13f5 <push+0x55>\nmov    %rdx,0x8(%rax)\nmov    %rax,(%r12)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   (%rax)\ncmp    %ebp,0x4(%rbx)\njge    1401 <push+0x61>\nmov    %rbx,%rdx\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\njne    13f0 <push+0x50>\nmov    %rbx,0x8(%rax)\nmov    %rax,0x8(%rdx)\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "cstring_cmp", "content": "/* qsort C-string comparison function */\nint\ncstring_cmp(const void *a, const void *b)\n{\n    const char **ia = (const char **)a;\n    const char **ib = (const char **)b;\n    return libmin_strcmp(*ia, *ib);\n    /* strcmp functions works exactly as expected from\n    comparison function */\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O2.pseudo", "function_name": "cstring_cmp", "address": "0x1280", "label": "cstring_cmp", "content": "int __fastcall cstring_cmp(const void *a, const void *b)\n{\n  return libmin_strcmp(*(const char **)a, *(const char **)b);\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O2", "assembly": "<cstring_cmp>:\nendbr64\nmov    (%rsi),%rsi\nmov    (%rdi),%rdi\njmp    3200 <libmin_strcmp>\nnop\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "int_cmp", "content": "#include \"libmin.h\"\n\n/* qsort int comparison function */\nint\nint_cmp(const void *a, const void *b)\n{\n    const int *ia = (const int *)a; // casting pointer types\n    const int *ib = (const int *)b;\n    return *ia  - *ib;\n    /* integer comparison: returns negative if a < b\n    and positive if a > b */\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O2.pseudo", "function_name": "int_cmp", "address": "0x1240", "label": "int_cmp", "content": "int __fastcall int_cmp(const void *a, const void *b)\n{\n  return *(_DWORD *)a - *(_DWORD *)b;\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O2", "assembly": "<int_cmp>:\nendbr64\nmov    (%rdi),%eax\nsub    (%rsi),%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "main", "content": "/* MAIN program (calls all other examples) */\nint\nmain(void)\n{\n    /* run all example functions */\n    sort_integers_example();\n    sort_cstrings_example();\n    sort_structs_example();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  sort_integers_example();\n  sort_cstrings_example();\n  sort_structs_example();\n  libmin_success();\n}", "binary": "qsort-demo/qsort-demo.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\ncall   1310 <sort_integers_example>\ncall   14a0 <sort_cstrings_example>\ncall   1640 <sort_structs_example>\ncall   3290 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "print_cstring_array", "content": "/* C-string array printing function */\nvoid\nprint_cstring_array(char **array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"%s | \", array[i]);\n\n    libmin_putc('\\n');\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O2.pseudo", "function_name": "print_cstring_array", "address": "0x1430", "label": "print_cstring_array", "content": "void __fastcall print_cstring_array(char **array, size_t len)\n{\n  __int64 i; // rbx\n  const char *v4; // rsi\n\n  if ( len )\n  {\n    for ( i = 0LL; i != len; ++i )\n    {\n      v4 = array[i];\n      libmin_printf(\"%s | \", v4);\n    }\n  }\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "void print_cstring_array(char **array, unsigned int len) {\n  long long i;\n  const char *v4;\n  if (len) {\n    for (i = 0LL; i != len; ++i) {\n      v4 = array[i];\n      libmin_printf(\"%s | \", v4);\n    }\n  }\n  libmin_putc(10);\n}", "binary": "qsort-demo/qsort-demo.host.O2", "assembly": "<print_cstring_array>:\nendbr64\ntest   %rsi,%rsi\nje     1488 <print_cstring_array+0x58>\npush   %r13\nlea    0x2bdf(%rip),%r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x8,%rsp\nnopw   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,8),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   2d60 <libmin_printf>\ncmp    %rbx,%rbp\njne    1458 <print_cstring_array+0x28>\nadd    $0x8,%rsp\nmov    $0xa,%edi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    2f70 <libmin_putc>\nnopl   0x0(%rax,%rax,1)\nmov    $0xa,%edi\njmp    2f70 <libmin_putc>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "print_int_array", "content": "/* integer array printing function */\nvoid\nprint_int_array(const int *array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"%d | \", array[i]);\n\n    libmin_putc('\\n');\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O2.pseudo", "function_name": "print_int_array", "address": "0x12a0", "label": "print_int_array", "content": "void __fastcall print_int_array(const int *array, size_t len)\n{\n  __int64 i; // rbx\n  int v4; // esi\n\n  if ( len )\n  {\n    for ( i = 0LL; i != len; ++i )\n    {\n      v4 = array[i];\n      libmin_printf(\"%d | \", v4);\n    }\n  }\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "void print_int_array(const int *array, unsigned int len) {\n  long long i;\n  int v4;\n  if (len) {\n    for (i = 0LL; i != len; ++i) {\n      v4 = array[i];\n      libmin_printf(\"%d | \", v4);\n    }\n  }\n  libmin_putc(10);\n}", "binary": "qsort-demo/qsort-demo.host.O2", "assembly": "<print_int_array>:\nendbr64\ntest   %rsi,%rsi\nje     12f8 <print_int_array+0x58>\npush   %r13\nlea    0x2d52(%rip),%r13\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x8,%rsp\nnopw   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,4),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   2d60 <libmin_printf>\ncmp    %rbx,%rbp\njne    12c8 <print_int_array+0x28>\nadd    $0x8,%rsp\nmov    $0xa,%edi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    2f70 <libmin_putc>\nnopl   0x0(%rax,%rax,1)\nmov    $0xa,%edi\njmp    2f70 <libmin_putc>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "print_struct_array", "content": "/* Example struct array printing function */\nvoid\nprint_struct_array(struct st_ex *array, size_t len)\n{\n    size_t i;\n\n    for(i=0; i<len; i++)\n        libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", array[i].product, array[i].price);\n\n    libmin_puts(\"--\");\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O2.pseudo", "function_name": "print_struct_array", "address": "0x15c0", "label": "print_struct_array", "content": "void __fastcall print_struct_array(st_ex *array, size_t len)\n{\n  __int64 v3; // rbp\n  st_ex *v5; // rsi\n  double price; // xmm0_8\n\n  if ( len )\n  {\n    v3 = 0LL;\n    do\n    {\n      v5 = array;\n      ++v3;\n      price = array->price;\n      ++array;\n      libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v5->product, price);\n    }\n    while ( len != v3 );\n  }\n  libmin_puts(\"--\");\n}\n"}, "pseudo_normalize": "void print_struct_array(st_ex *array, unsigned int len) {\n  long long v3;\n  st_ex *v5;\n  double price;\n  if (len) {\n    v3 = 0LL;\n    do {\n      v5 = array;\n      ++v3;\n      price = array->price;\n      ++array;\n      libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v5->product, price);\n    } while (len != v3);\n  }\n  libmin_puts(\"--\");\n}", "binary": "qsort-demo/qsort-demo.host.O2", "assembly": "<print_struct_array>:\nendbr64\ntest   %rsi,%rsi\nje     1628 <print_struct_array+0x68>\npush   %r13\nlea    0x2ab6(%rip),%r13\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nmov    %rdi,%rbx\nsub    $0x8,%rsp\nnopw   0x0(%rax,%rax,1)\nmov    %rbx,%rsi\npxor   %xmm0,%xmm0\nmov    %r13,%rdi\nmov    $0x1,%eax\nadd    $0x1,%rbp\ncvtss2sd 0x10(%rbx),%xmm0\nadd    $0x14,%rbx\ncall   2d60 <libmin_printf>\ncmp    %rbp,%r12\njne    15e8 <print_struct_array+0x28>\nadd    $0x8,%rsp\nlea    0x2a49(%rip),%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    2f80 <libmin_puts>\nnopl   0x0(%rax)\nlea    0x2a33(%rip),%rdi\njmp    2f80 <libmin_puts>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "sort_cstrings_example", "content": "/* sorting C-strings array using qsort() example */\nvoid\nsort_cstrings_example(void)\n{\n    char *strings[] = { \"Zorro\", \"Alex\", \"Celine\", \"Bill\", \"Forest\", \"Dexter\" };\n    size_t strings_len = sizeof(strings) / sizeof(char *);\n\n    /* STRING */\n    libmin_puts(\"*** String sorting...\");\n\n    /* print original string array */\n    print_cstring_array(strings, strings_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(strings, strings_len, sizeof(char *), cstring_cmp);\n\n    /* print sorted string array */\n    print_cstring_array(strings, strings_len);\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O2.pseudo", "function_name": "sort_cstrings_example", "address": "0x14a0", "label": "sort_cstrings_example", "content": "void __cdecl sort_cstrings_example()\n{\n  char **v0; // rbx\n  char **v1; // rbp\n  const char *v2; // rsi\n  const char *v3; // rsi\n  char *strings[6]; // [rsp+0h] [rbp-68h] BYREF\n  char v5; // [rsp+30h] [rbp-38h] BYREF\n  unsigned __int64 v6; // [rsp+38h] [rbp-30h]\n\n  v6 = __readfsqword(0x28u);\n  v0 = strings;\n  v1 = strings;\n  strings[0] = \"Zorro\";\n  strings[1] = \"Alex\";\n  strings[2] = \"Celine\";\n  strings[3] = \"Bill\";\n  strings[4] = \"Forest\";\n  strings[5] = \"Dexter\";\n  libmin_puts(\"*** String sorting...\");\n  do\n  {\n    v2 = *v1++;\n    libmin_printf(\"%s | \", v2);\n  }\n  while ( v1 != (char **)&v5 );\n  libmin_putc(10);\n  libmin_qsort(strings, 6uLL, 8uLL, cstring_cmp);\n  do\n  {\n    v3 = *v0++;\n    libmin_printf(\"%s | \", v3);\n  }\n  while ( v0 != (char **)&v5 );\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "void sort_cstrings_example() {\n  char **v0;\n  char **v1;\n  const char *v2;\n  const char *v3;\n  char *strings[6];\n  char v5;\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  v0 = strings;\n  v1 = strings;\n  strings[0] = \"Zorro\";\n  strings[1] = \"Alex\";\n  strings[2] = \"Celine\";\n  strings[3] = \"Bill\";\n  strings[4] = \"Forest\";\n  strings[5] = \"Dexter\";\n  libmin_puts(\"*** String sorting...\");\n  do {\n    v2 = *v1++;\n    libmin_printf(\"%s | \", v2);\n  } while (v1 != (char **)&v5);\n  libmin_putc(10);\n  libmin_qsort(strings, 6uLL, 8uLL, cstring_cmp);\n  do {\n    v3 = *v0++;\n    libmin_printf(\"%s | \", v3);\n  } while (v0 != (char **)&v5);\n  libmin_putc(10);\n}", "binary": "qsort-demo/qsort-demo.host.O2", "assembly": "<sort_cstrings_example>:\nendbr64\npush   %r14\nlea    0x2b9f(%rip),%rdi\npush   %r13\nlea    0x2b6b(%rip),%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nlea    0x2b54(%rip),%rax\nmov    %rsp,%r14\nlea    0x30(%rsp),%r12\nmov    %r14,%rbx\nmov    %r14,%rbp\nmov    %rax,(%rsp)\nlea    0x2b41(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x2b3a(%rip),%rax\nmov    %rax,0x10(%rsp)\nlea    0x2b35(%rip),%rax\nmov    %rax,0x18(%rsp)\nlea    0x2b2e(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0x2b29(%rip),%rax\nmov    %rax,0x28(%rsp)\ncall   2f80 <libmin_puts>\ncs nopw 0x0(%rax,%rax,1)\nmov    0x0(%rbp),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x8,%rbp\ncall   2d60 <libmin_printf>\ncmp    %r12,%rbp\njne    1530 <sort_cstrings_example+0x90>\nmov    $0xa,%edi\ncall   2f70 <libmin_putc>\nlea    -0x2d8(%rip),%rcx\nmov    $0x8,%edx\nmov    %r14,%rdi\nmov    $0x6,%esi\ncall   31d0 <libmin_qsort>\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x8,%rbx\ncall   2d60 <libmin_printf>\ncmp    %r12,%rbx\njne    1570 <sort_cstrings_example+0xd0>\nmov    $0xa,%edi\ncall   2f70 <libmin_putc>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    15ad <sort_cstrings_example+0x10d>\nadd    $0x40,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10c0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "sort_integers_example", "content": "/* sorting integers using qsort() example */\nvoid\nsort_integers_example(void)\n{\n    int numbers[] = { 7, 3, 4, 1, -1, 23, 12, 43, 2, -4, 5 };\n    size_t numbers_len = sizeof(numbers)/sizeof(int);\n\n    libmin_puts(\"*** Integer sorting...\");\n\n    /* print original integer array */\n    print_int_array(numbers, numbers_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(numbers, numbers_len, sizeof(int), int_cmp);\n\n    /* print sorted integer array */\n    print_int_array(numbers, numbers_len);\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O2.pseudo", "function_name": "sort_integers_example", "address": "0x1310", "label": "sort_integers_example", "content": "void __cdecl sort_integers_example()\n{\n  int *v0; // rbx\n  int *v1; // rbp\n  int v2; // esi\n  int v3; // esi\n  int numbers[11]; // [rsp+0h] [rbp-68h] BYREF\n  _BYTE v5[12]; // [rsp+2Ch] [rbp-3Ch] BYREF\n  unsigned __int64 v6; // [rsp+38h] [rbp-30h]\n\n  v6 = __readfsqword(0x28u);\n  numbers[10] = 5;\n  v0 = numbers;\n  v1 = numbers;\n  *(_QWORD *)numbers = 0x300000007LL;\n  *(_QWORD *)&numbers[2] = 0x100000004LL;\n  *(_QWORD *)&numbers[4] = 0x17FFFFFFFFLL;\n  *(_QWORD *)&numbers[6] = 0x2B0000000CLL;\n  *(_QWORD *)&numbers[8] = 0xFFFFFFFC00000002LL;\n  libmin_puts(\"*** Integer sorting...\");\n  do\n  {\n    v2 = *v1++;\n    libmin_printf(\"%d | \", v2);\n  }\n  while ( v1 != (int *)v5 );\n  libmin_putc(10);\n  libmin_qsort(numbers, 0xBuLL, 4uLL, int_cmp);\n  do\n  {\n    v3 = *v0++;\n    libmin_printf(\"%d | \", v3);\n  }\n  while ( v0 != (int *)v5 );\n  libmin_putc(10);\n}\n"}, "pseudo_normalize": "void sort_integers_example() {\n  int *v0;\n  int *v1;\n  int v2;\n  int v3;\n  int numbers[11];\n  uint8_t v5[12];\n  unsigned long long v6;\n  v6 = __readfsqword(40u);\n  numbers[10] = 5;\n  v0 = numbers;\n  v1 = numbers;\n  *(uint64_t *)numbers = 12884901895LL;\n  *(uint64_t *)&numbers[2] = 4294967300LL;\n  *(uint64_t *)&numbers[4] = 103079215103LL;\n  *(uint64_t *)&numbers[6] = 184683593740LL;\n  *(uint64_t *)&numbers[8] = 18446744056529682434LL;\n  libmin_puts(\"*** Integer sorting...\");\n  do {\n    v2 = *v1++;\n    libmin_printf(\"%d | \", v2);\n  } while (v1 != (int *)v5);\n  libmin_putc(10);\n  libmin_qsort(numbers, 11uLL, 4uLL, int_cmp);\n  do {\n    v3 = *v0++;\n    libmin_printf(\"%d | \", v3);\n  } while (v0 != (int *)v5);\n  libmin_putc(10);\n}", "binary": "qsort-demo/qsort-demo.host.O2", "assembly": "<sort_integers_example>:\nendbr64\npush   %r14\nlea    0x2ced(%rip),%rdi\npush   %r13\nlea    0x2cde(%rip),%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nmovabs $0x300000007,%rax\nmov    %rsp,%r14\nlea    0x2c(%rsp),%r12\nmovl   $0x5,0x28(%rsp)\nmov    %r14,%rbx\nmov    %r14,%rbp\nmov    %rax,(%rsp)\nmovabs $0x100000004,%rax\nmov    %rax,0x8(%rsp)\nmovabs $0x17ffffffff,%rax\nmov    %rax,0x10(%rsp)\nmovabs $0x2b0000000c,%rax\nmov    %rax,0x18(%rsp)\nmovabs $0xfffffffc00000002,%rax\nmov    %rax,0x20(%rsp)\ncall   2f80 <libmin_puts>\nnopl   0x0(%rax)\nmov    0x0(%rbp),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbp\ncall   2d60 <libmin_printf>\ncmp    %r12,%rbp\njne    13a8 <sort_integers_example+0x98>\nmov    $0xa,%edi\ncall   2f70 <libmin_putc>\nlea    -0x18f(%rip),%rcx\nmov    $0x4,%edx\nmov    %r14,%rdi\nmov    $0xb,%esi\ncall   31d0 <libmin_qsort>\nnopl   0x0(%rax)\nmov    (%rbx),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   2d60 <libmin_printf>\ncmp    %r12,%rbx\njne    13e8 <sort_integers_example+0xd8>\nmov    $0xa,%edi\ncall   2f70 <libmin_putc>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1424 <sort_integers_example+0x114>\nadd    $0x40,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "sort_structs_example", "content": "/* sorting structs using qsort() example */\nvoid\nsort_structs_example(void)\n{\n    struct st_ex structs[] = {{\"mp3 player\", 299.0f}, {\"plasma tv\", 2200.0f},\n                              {\"notebook\", 1300.0f}, {\"smartphone\", 499.99f},\n                              {\"dvd player\", 150.0f}, {\"matches\", 0.2f }};\n\n    size_t structs_len = sizeof(structs) / sizeof(struct st_ex);\n\n    libmin_puts(\"*** Struct sorting (price)...\");\n\n    /* print original struct array */\n    print_struct_array(structs, structs_len);\n\n    /* sort array using qsort functions */\n    libmin_qsort(structs, structs_len, sizeof(struct st_ex), struct_cmp_by_price);\n\n    /* print sorted struct array */\n    print_struct_array(structs, structs_len);\n\n    libmin_puts(\"*** Struct sorting (product)...\");\n\n    /* resort using other comparision function */\n    libmin_qsort(structs, structs_len, sizeof(struct st_ex), struct_cmp_by_product);\n\n    /* print sorted struct array */\n    print_struct_array(structs, structs_len);\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O2.pseudo", "function_name": "sort_structs_example", "address": "0x1640", "label": "sort_structs_example", "content": "void __cdecl sort_structs_example()\n{\n  st_ex *v0; // rbx\n  st_ex *v1; // rbp\n  st_ex *v2; // rbp\n  st_ex structs[6]; // [rsp+0h] [rbp-B8h] BYREF\n  _QWORD v4[8]; // [rsp+78h] [rbp-40h] BYREF\n\n  v4[0] = __readfsqword(0x28u);\n  structs[2].product[9] = 0;\n  *(_WORD *)&structs[2].product[10] = 0;\n  *(_DWORD *)&structs[2].product[12] = 0;\n  *(__m128i *)structs[0].product = _mm_load_si128((const __m128i *)&xmmword_40D0);\n  v0 = structs;\n  v1 = structs;\n  structs[0].price = 299.0;\n  strcpy(structs[2].product, \"notebook\");\n  *(__m128i *)structs[1].product = _mm_load_si128((const __m128i *)&xmmword_40E0);\n  structs[1].price = 2200.0;\n  *(__m128i *)structs[3].product = _mm_load_si128((const __m128i *)&xmmword_40F0);\n  structs[2].price = 1300.0;\n  structs[3].price = 499.98999;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(_QWORD *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  *(__m128i *)structs[4].product = _mm_load_si128((const __m128i *)&xmmword_4100);\n  libmin_puts(\"*** Struct sorting (price)...\");\n  do\n  {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v1->product, v1->price);\n    ++v1;\n  }\n  while ( v1 != (st_ex *)v4 );\n  v2 = structs;\n  libmin_puts(\"--\");\n  libmin_qsort(structs, 6uLL, 0x14uLL, struct_cmp_by_price);\n  do\n  {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v2->product, v2->price);\n    ++v2;\n  }\n  while ( v2 != (st_ex *)v4 );\n  libmin_puts(\"--\");\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 0x14uLL, struct_cmp_by_product);\n  do\n  {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v0->product, v0->price);\n    ++v0;\n  }\n  while ( v0 != (st_ex *)v4 );\n  libmin_puts(\"--\");\n}\n"}, "pseudo_normalize": "void sort_structs_example() {\n  st_ex *v0;\n  st_ex *v1;\n  st_ex *v2;\n  st_ex structs[6];\n  uint64_t v4[8];\n  v4[0] = __readfsqword(40u);\n  structs[2].product[9] = 0;\n  *(unsigned short *)&structs[2].product[10] = 0;\n  *(uint32_t *)&structs[2].product[12] = 0;\n  *(__m128i *)structs[0].product =\n      _mm_load_si128((const __m128i *)&xmmword_40D0);\n  v0 = structs;\n  v1 = structs;\n  structs[0].price = 299.0;\n  strcpy(structs[2].product, \"notebook\");\n  *(__m128i *)structs[1].product =\n      _mm_load_si128((const __m128i *)&xmmword_40E0);\n  structs[1].price = 2200.0;\n  *(__m128i *)structs[3].product =\n      _mm_load_si128((const __m128i *)&xmmword_40F0);\n  structs[2].price = 1300.0;\n  structs[3].price = 499.98999;\n  structs[4].price = 150.0;\n  strcpy(structs[5].product, \"matches\");\n  *(uint64_t *)&structs[5].product[8] = 0LL;\n  structs[5].price = 0.2;\n  *(__m128i *)structs[4].product =\n      _mm_load_si128((const __m128i *)&xmmword_4100);\n  libmin_puts(\"*** Struct sorting (price)...\");\n  do {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v1->product, v1->price);\n    ++v1;\n  } while (v1 != (st_ex *)v4);\n  v2 = structs;\n  libmin_puts(\"--\");\n  libmin_qsort(structs, 6uLL, 20uLL, struct_cmp_by_price);\n  do {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v2->product, v2->price);\n    ++v2;\n  } while (v2 != (st_ex *)v4);\n  libmin_puts(\"--\");\n  libmin_puts(\"*** Struct sorting (product)...\");\n  libmin_qsort(structs, 6uLL, 20uLL, struct_cmp_by_product);\n  do {\n    libmin_printf(\"[ product: %s \\t price: $%.2f ]\\n\", v0->product, v0->price);\n    ++v0;\n  } while (v0 != (st_ex *)v4);\n  libmin_puts(\"--\");\n}", "binary": "qsort-demo/qsort-demo.host.O2", "assembly": "<sort_structs_example>:\nendbr64\npush   %r15\nxor    %edx,%edx\nlea    0x2a16(%rip),%rdi\npush   %r14\npush   %r13\nlea    0x2a2e(%rip),%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x88,%rsp\nmovdqa 0x2a63(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x78(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r14\nmov    %rdx,0x30(%rsp)\nxor    %edx,%edx\nmovaps %xmm0,(%rsp)\nmov    %r14,%rbx\nlea    0x78(%rsp),%r12\nmov    %r14,%rbp\nmovdqa 0x2a42(%rip),%xmm0\nmovl   $0x43958000,0x10(%rsp)\nmovabs $0x6b6f6f6265746f6e,%rax\nmov    %rax,0x28(%rsp)\nmovabs $0x7365686374616d,%rax\nmovups %xmm0,0x14(%rsp)\nmovdqa 0x2a24(%rip),%xmm0\nmovl   $0x45098000,0x24(%rsp)\nmovups %xmm0,0x3c(%rsp)\nmovdqa 0x2a1f(%rip),%xmm0\nmovl   $0x44a28000,0x38(%rsp)\nmovl   $0x43f9feb8,0x4c(%rsp)\nmovl   $0x43160000,0x60(%rsp)\nmov    %rax,0x64(%rsp)\nmov    %rdx,0x6c(%rsp)\nmovl   $0x3e4ccccd,0x74(%rsp)\nmovaps %xmm0,0x50(%rsp)\ncall   2f80 <libmin_puts>\nnopl   (%rax)\npxor   %xmm0,%xmm0\nmov    %rbp,%rsi\nmov    %r13,%rdi\nmov    $0x1,%eax\ncvtss2sd 0x10(%rbp),%xmm0\ncall   2d60 <libmin_printf>\nadd    $0x14,%rbp\ncmp    %r12,%rbp\njne    1718 <sort_structs_example+0xd8>\nlea    0x2921(%rip),%r15\nmov    %r14,%rbp\nmov    %r15,%rdi\ncall   2f80 <libmin_puts>\nlea    -0x503(%rip),%rcx\nmov    $0x14,%edx\nmov    %r14,%rdi\nmov    $0x6,%esi\ncall   31d0 <libmin_qsort>\nnopl   (%rax)\npxor   %xmm0,%xmm0\nmov    %rbp,%rsi\nmov    %r13,%rdi\nmov    $0x1,%eax\ncvtss2sd 0x10(%rbp),%xmm0\ncall   2d60 <libmin_printf>\nadd    $0x14,%rbp\ncmp    %r12,%rbp\njne    1768 <sort_structs_example+0x128>\nmov    %r15,%rdi\ncall   2f80 <libmin_puts>\nlea    0x290f(%rip),%rdi\ncall   2f80 <libmin_puts>\nlea    -0x515(%rip),%rcx\nmov    $0x14,%edx\nmov    %r14,%rdi\nmov    $0x6,%esi\ncall   31d0 <libmin_qsort>\nnopw   0x0(%rax,%rax,1)\npxor   %xmm0,%xmm0\nmov    %rbx,%rsi\nmov    %r13,%rdi\nmov    $0x1,%eax\ncvtss2sd 0x10(%rbx),%xmm0\ncall   2d60 <libmin_printf>\nadd    $0x14,%rbx\ncmp    %r12,%rbx\njne    17c0 <sort_structs_example+0x180>\nmov    %r15,%rdi\ncall   2f80 <libmin_puts>\nmov    0x78(%rsp),%rax\nsub    %fs:0x28,%rax\njne    180c <sort_structs_example+0x1cc>\nadd    $0x88,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "struct_cmp_by_price", "content": "/* qsort struct comparision function (price float field) */\nint\nstruct_cmp_by_price(const void *a, const void *b)\n{\n    struct st_ex *ia = (struct st_ex *)a;\n    struct st_ex *ib = (struct st_ex *)b;\n    return (int)(100.f*ia->price - 100.f*ib->price);\n    /* float comparison: returns negative if b > a\n    and positive if a > b. We multiplied result by 100.0\n    to preserve decimal fraction */\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O2.pseudo", "function_name": "struct_cmp_by_price", "address": "0x1250", "label": "struct_cmp_by_price", "content": "int __fastcall struct_cmp_by_price(const void *a, const void *b)\n{\n  return (int)(float)((float)(*((float *)a + 4) * 100.0) - (float)(100.0 * *((float *)b + 4)));\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O2", "assembly": "<struct_cmp_by_price>:\nendbr64\nmovss  0x2e6c(%rip),%xmm0\nmovss  0x10(%rdi),%xmm1\nmulss  %xmm0,%xmm1\nmulss  0x10(%rsi),%xmm0\nsubss  %xmm0,%xmm1\ncvttss2si %xmm1,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "qsort-demo/qsort-demo.c", "function_name": "struct_cmp_by_product", "content": "/* qsort struct comparision function (product C-string field) */\nint\nstruct_cmp_by_product(const void *a, const void *b)\n{\n    struct st_ex *ia = (struct st_ex *)a;\n    struct st_ex *ib = (struct st_ex *)b;\n    return libmin_strcmp(ia->product, ib->product);\n    /* strcmp functions works exactly as expected from\n    comparison function */\n}\n"}, "pseudo": {"path": "qsort-demo/qsort-demo.host.O2.pseudo", "function_name": "struct_cmp_by_product", "address": "0x1290", "label": "struct_cmp_by_product", "content": "int __fastcall struct_cmp_by_product(const void *a, const void *b)\n{\n  return libmin_strcmp((const char *)a, (const char *)b);\n}\n"}, "pseudo_normalize": "", "binary": "qsort-demo/qsort-demo.host.O2", "assembly": "<struct_cmp_by_product>:\nendbr64\njmp    3200 <libmin_strcmp>\nnopl   0x0(%rax)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "int_compare", "content": "#include \"libmin.h\"\n\n/* Comparison function for integers. */\nint int_compare(const void *a, const void *b) {\n    const int *ia = (const int *) a;\n    const int *ib = (const int *) b;\n    return (*ia) - (*ib);\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O2.pseudo", "function_name": "int_compare", "address": "0x1930", "label": "int_compare", "content": "int __fastcall int_compare(const void *a, const void *b)\n{\n  return *(_DWORD *)a - *(_DWORD *)b;\n}\n"}, "pseudo_normalize": "", "binary": "qsort-test/qsort-test.host.O2", "assembly": "<int_compare>:\nendbr64\nmov    (%rdi),%eax\nsub    (%rsi),%eax\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "is_sorted", "content": "/* Utility function to check if an array of integers is sorted (non-decreasing order). */\nint is_sorted(const int arr[], size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        if (arr[i - 1] > arr[i])\n            return 0;\n    }\n    return 1;\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O2.pseudo", "function_name": "is_sorted", "address": "0x1950", "label": "is_sorted", "content": "int __fastcall is_sorted(const int *arr, size_t n)\n{\n  __int64 v2; // rax\n\n  if ( n <= 1 )\n    return 1;\n  v2 = 1LL;\n  while ( arr[v2 - 1] <= arr[v2] )\n  {\n    if ( n == ++v2 )\n      return 1;\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int is_sorted(const int *arr, unsigned int n) {\n  long long v2;\n  if (n <= 1) return 1;\n  v2 = 1LL;\n  while (arr[v2 - 1] <= arr[v2]) {\n    if (n == ++v2) return 1;\n  }\n  return 0;\n}", "binary": "qsort-test/qsort-test.host.O2", "assembly": "<is_sorted>:\nendbr64\ncmp    $0x1,%rsi\njbe    1980 <is_sorted+0x30>\nmov    $0x1,%eax\njmp    1971 <is_sorted+0x21>\nnopl   0x0(%rax)\nadd    $0x1,%rax\ncmp    %rax,%rsi\nje     1980 <is_sorted+0x30>\nmov    (%rdi,%rax,4),%edx\ncmp    %edx,-0x4(%rdi,%rax,4)\njle    1968 <is_sorted+0x18>\nxor    %eax,%eax\nret\nnopl   (%rax)\nmov    $0x1,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "is_sorted_string_array", "content": "/* Utility function to check if an array of strings is sorted lexicographically. */\nint is_sorted_string_array(const char *arr[], size_t n) {\n    for (size_t i = 1; i < n; i++) {\n        if (libmin_strcmp(arr[i - 1], arr[i]) > 0)\n            return 0;\n    }\n    return 1;\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O2.pseudo", "function_name": "is_sorted_string_array", "address": "0x19f0", "label": "is_sorted_string_array", "content": "int __fastcall is_sorted_string_array(const char **arr, size_t n)\n{\n  __int64 i; // rbx\n\n  if ( n <= 1 )\n    return 1;\n  for ( i = 1LL; i != n; ++i )\n  {\n    if ( libmin_strcmp(arr[i - 1], arr[i]) > 0 )\n      return 0;\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int is_sorted_string_array(const char **arr, unsigned int n) {\n  long long i;\n  if (n <= 1) return 1;\n  for (i = 1LL; i != n; ++i) {\n    if (libmin_strcmp(arr[i - 1], arr[i]) > 0) return 0;\n  }\n  return 1;\n}", "binary": "qsort-test/qsort-test.host.O2", "assembly": "<is_sorted_string_array>:\nendbr64\ncmp    $0x1,%rsi\njbe    1a42 <is_sorted_string_array+0x52>\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    $0x1,%ebx\njmp    1a19 <is_sorted_string_array+0x29>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rbx\ncmp    %rbx,%r12\nje     1a38 <is_sorted_string_array+0x48>\nmov    0x0(%rbp,%rbx,8),%rsi\nmov    -0x8(%rbp,%rbx,8),%rdi\ncall   3450 <libmin_strcmp>\ntest   %eax,%eax\njle    1a10 <is_sorted_string_array+0x20>\npop    %rbx\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\nnopl   0x0(%rax,%rax,1)\npop    %rbx\nmov    $0x1,%eax\npop    %rbp\npop    %r12\nret\nmov    $0x1,%eax\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "main", "content": "int main(void) {\n    /* ---------------------------\n     * Test 1: Random integer array (40 elements).\n     * These values are mostly unique with only few duplicates.\n     * ---------------------------\n     */\n    int test1[40] = {\n         5,  3, 12,  8,  1, 19,  7,  4,  0,  6,\n        10, 15,  2, 22, 11, 17, 13, 20,  9, 14,\n        16, 21, 23, 18, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39\n    };\n    size_t n1 = sizeof(test1) / sizeof(test1[0]);\n    libmin_qsort(test1, n1, sizeof(int), int_compare);\n    libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n    print_array(test1, n1);\n    if (is_sorted(test1, n1))\n        libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 2: Integer array with few duplicates (40 elements).\n     * Only one duplicate (the value '5' appears twice).\n     * ---------------------------\n     */\n    int test2[40] = {\n         2,  1,  3,  0,  4,  5,  5,  7,  8,  9,\n        10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,\n        30, 31, 32, 33, 34, 35, 36, 37, 38, 39\n    };\n    size_t n2 = sizeof(test2) / sizeof(test2[0]);\n    libmin_qsort(test2, n2, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n    print_array(test2, n2);\n    if (is_sorted(test2, n2))\n        libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 3: Already sorted integer array (40 elements).\n     * Generate 40 ascending integers (0, 1, 2, ... 39).\n     * ---------------------------\n     */\n    int test3[40];\n    for (int i = 0; i < 40; i++) {\n        test3[i] = i;\n    }\n    libmin_qsort(test3, 40, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n    print_array(test3, 40);\n    if (is_sorted(test3, 40))\n        libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n    else\n        libmin_printf(\"Test 3 failed: already sorted array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 4: Reverse sorted integer array (40 elements).\n     * Generate 40 descending integers (39, 38, ... 0).\n     * ---------------------------\n     */\n    int test4[40];\n    for (int i = 0; i < 40; i++) {\n        test4[i] = 39 - i;\n    }\n    libmin_qsort(test4, 40, sizeof(int), int_compare);\n    libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n    print_array(test4, 40);\n    if (is_sorted(test4, 40))\n        libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n\n    /* ---------------------------\n     * Test 5: String array (32 elements).\n     * These 32 strings are mostly distinct with one duplicate (\"apple\").\n     * ---------------------------\n     */\n    const char *test_strings[32] = {\n        \"banana\", \"apple\", \"orange\", \"kiwi\", \"grape\", \"mango\", \"strawberry\", \"pear\",\n        \"pineapple\", \"watermelon\", \"blueberry\", \"raspberry\", \"blackberry\", \"cherry\", \"peach\", \"apricot\",\n        \"plum\", \"nectarine\", \"cantaloupe\", \"honeydew\", \"papaya\", \"passionfruit\", \"guava\", \"lychee\",\n        \"pomegranate\", \"grapefruit\", \"lemon\", \"lime\", \"tangerine\", \"cranberry\", \"fig\", \"apple\"  // \"apple\" appears twice\n    };\n    size_t n_str = sizeof(test_strings) / sizeof(test_strings[0]);\n    libmin_qsort(test_strings, n_str, sizeof(char *), string_compare);\n    libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n    print_string_array(test_strings, n_str);\n    if (is_sorted_string_array(test_strings, n_str))\n        libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n    else\n        libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 i; // rax\n  int v4; // eax\n  int *v5; // rdx\n  int test1[40]; // [rsp+0h] [rbp+0h] BYREF\n  int test2[40]; // [rsp+A0h] [rbp+A0h] BYREF\n  int test4[40]; // [rsp+1E0h] [rbp+1E0h] BYREF\n  const char *test_strings[32]; // [rsp+280h] [rbp+280h] BYREF\n  unsigned __int64 vars388; // [rsp+388h] [rbp+388h]\n\n  vars388 = __readfsqword(0x28u);\n  *(_QWORD *)test1 = 0x300000005LL;\n  *(_QWORD *)&test1[2] = 0x80000000CLL;\n  *(_QWORD *)&test1[4] = 0x1300000001LL;\n  *(_QWORD *)&test1[6] = 0x400000007LL;\n  *(_QWORD *)&test1[8] = 0x600000000LL;\n  *(_QWORD *)&test1[10] = 0xF0000000ALL;\n  *(_QWORD *)&test1[12] = 0x1600000002LL;\n  *(_QWORD *)&test1[14] = 0x110000000BLL;\n  *(_QWORD *)&test1[16] = 0x140000000DLL;\n  *(_QWORD *)&test1[18] = 0xE00000009LL;\n  *(_QWORD *)&test1[20] = 0x1500000010LL;\n  *(_QWORD *)&test1[22] = 0x1200000017LL;\n  *(_QWORD *)&test1[24] = 0x1900000018LL;\n  *(_QWORD *)&test1[26] = 0x1B0000001ALL;\n  *(_QWORD *)&test1[28] = 0x1D0000001CLL;\n  *(_QWORD *)&test1[30] = 0x1F0000001ELL;\n  *(_QWORD *)&test1[32] = 0x2100000020LL;\n  *(_QWORD *)&test1[34] = 0x2300000022LL;\n  *(_QWORD *)&test1[36] = 0x2500000024LL;\n  *(_QWORD *)&test1[38] = 0x2700000026LL;\n  libmin_qsort(test1, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(test1, 0x28uLL);\n  if ( is_sorted(test1, 0x28uLL) )\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  *(_QWORD *)test2 = 0x100000002LL;\n  *(_QWORD *)&test2[4] = 0x500000004LL;\n  *(_QWORD *)&test2[6] = 0x700000005LL;\n  *(_QWORD *)&test2[8] = 0x900000008LL;\n  *(_QWORD *)&test2[10] = 0xB0000000ALL;\n  *(_QWORD *)&test2[12] = 0xD0000000CLL;\n  *(_QWORD *)&test2[14] = 0xF0000000ELL;\n  *(_QWORD *)&test2[16] = 0x1100000010LL;\n  *(_QWORD *)&test2[18] = 0x1300000012LL;\n  *(_QWORD *)&test2[20] = 0x1500000014LL;\n  *(_QWORD *)&test2[22] = 0x1700000016LL;\n  *(_QWORD *)&test2[24] = 0x1900000018LL;\n  *(_QWORD *)&test2[26] = 0x1B0000001ALL;\n  *(_QWORD *)&test2[28] = 0x1D0000001CLL;\n  *(_QWORD *)&test2[30] = 0x1F0000001ELL;\n  *(_QWORD *)&test2[32] = 0x2100000020LL;\n  *(_QWORD *)&test2[34] = 0x2300000022LL;\n  *(_QWORD *)&test2[36] = 0x2500000024LL;\n  *(_QWORD *)&test2[38] = 0x2700000026LL;\n  *(_QWORD *)&test2[2] = 3LL;\n  libmin_qsort(test2, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(test1, 0x28uLL);\n  if ( is_sorted(test1, 0x28uLL) )\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  for ( i = 0LL; i != 40; ++i )\n    test1[i] = i;\n  libmin_qsort(test1, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(test1, 0x28uLL);\n  if ( is_sorted(test1, 0x28uLL) )\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  else\n    libmin_printf(\"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  v4 = 39;\n  v5 = test4;\n  do\n    *v5++ = v4--;\n  while ( v4 != -1 );\n  libmin_qsort(test1, 0x28uLL, 4uLL, int_compare);\n  libmin_printf(\"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(test1, 0x28uLL);\n  if ( is_sorted(test1, 0x28uLL) )\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  test_strings[2] = \"orange\";\n  test_strings[3] = \"kiwi\";\n  test_strings[4] = \"grape\";\n  test_strings[5] = \"mango\";\n  test_strings[6] = \"strawberry\";\n  test_strings[7] = \"pear\";\n  test_strings[8] = \"pineapple\";\n  test_strings[9] = \"watermelon\";\n  test_strings[10] = \"blueberry\";\n  test_strings[11] = \"raspberry\";\n  test_strings[12] = \"blackberry\";\n  test_strings[13] = \"cherry\";\n  test_strings[14] = \"peach\";\n  test_strings[15] = \"apricot\";\n  test_strings[16] = \"plum\";\n  test_strings[17] = \"nectarine\";\n  test_strings[18] = \"cantaloupe\";\n  test_strings[19] = \"honeydew\";\n  test_strings[20] = \"papaya\";\n  test_strings[21] = \"passionfruit\";\n  test_strings[22] = \"guava\";\n  test_strings[23] = \"lychee\";\n  test_strings[24] = \"pomegranate\";\n  test_strings[25] = \"grapefruit\";\n  test_strings[26] = \"lemon\";\n  test_strings[27] = \"lime\";\n  test_strings[28] = \"tangerine\";\n  test_strings[0] = \"banana\";\n  test_strings[29] = \"cranberry\";\n  test_strings[30] = \"fig\";\n  test_strings[1] = \"apple\";\n  test_strings[31] = \"apple\";\n  libmin_qsort(test_strings, 0x20uLL, 8uLL, string_compare);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array((const char **)test1, 0x20uLL);\n  if ( is_sorted_string_array((const char **)test1, 0x20uLL) )\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long i;\n  int v4;\n  int *v5;\n  int test1[40];\n  int test2[40];\n  int test4[40];\n  const char *test_strings[32];\n  unsigned long long vars388;\n  vars388 = __readfsqword(40u);\n  *(uint64_t *)test1 = 12884901893LL;\n  *(uint64_t *)&test1[2] = 34359738380LL;\n  *(uint64_t *)&test1[4] = 81604378625LL;\n  *(uint64_t *)&test1[6] = 17179869191LL;\n  *(uint64_t *)&test1[8] = 25769803776LL;\n  *(uint64_t *)&test1[10] = 64424509450LL;\n  *(uint64_t *)&test1[12] = 94489280514LL;\n  *(uint64_t *)&test1[14] = 73014444043LL;\n  *(uint64_t *)&test1[16] = 85899345933LL;\n  *(uint64_t *)&test1[18] = 60129542153LL;\n  *(uint64_t *)&test1[20] = 90194313232LL;\n  *(uint64_t *)&test1[22] = 77309411351LL;\n  *(uint64_t *)&test1[24] = 107374182424LL;\n  *(uint64_t *)&test1[26] = 115964117018LL;\n  *(uint64_t *)&test1[28] = 124554051612LL;\n  *(uint64_t *)&test1[30] = 133143986206LL;\n  *(uint64_t *)&test1[32] = 141733920800LL;\n  *(uint64_t *)&test1[34] = 150323855394LL;\n  *(uint64_t *)&test1[36] = 158913789988LL;\n  *(uint64_t *)&test1[38] = 167503724582LL;\n  libmin_qsort(test1, 40uLL, 4uLL, int_compare);\n  libmin_printf(\"Test 1: Sorted Random Integer Array (40 elements):\\n\");\n  print_array(test1, 40uLL);\n  if (is_sorted(test1, 40uLL))\n    libmin_printf(\"Test 1 passed: array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 1 failed: array not sorted correctly.\\n\");\n  *(uint64_t *)test2 = 4294967298LL;\n  *(uint64_t *)&test2[4] = 21474836484LL;\n  *(uint64_t *)&test2[6] = 30064771077LL;\n  *(uint64_t *)&test2[8] = 38654705672LL;\n  *(uint64_t *)&test2[10] = 47244640266LL;\n  *(uint64_t *)&test2[12] = 55834574860LL;\n  *(uint64_t *)&test2[14] = 64424509454LL;\n  *(uint64_t *)&test2[16] = 73014444048LL;\n  *(uint64_t *)&test2[18] = 81604378642LL;\n  *(uint64_t *)&test2[20] = 90194313236LL;\n  *(uint64_t *)&test2[22] = 98784247830LL;\n  *(uint64_t *)&test2[24] = 107374182424LL;\n  *(uint64_t *)&test2[26] = 115964117018LL;\n  *(uint64_t *)&test2[28] = 124554051612LL;\n  *(uint64_t *)&test2[30] = 133143986206LL;\n  *(uint64_t *)&test2[32] = 141733920800LL;\n  *(uint64_t *)&test2[34] = 150323855394LL;\n  *(uint64_t *)&test2[36] = 158913789988LL;\n  *(uint64_t *)&test2[38] = 167503724582LL;\n  *(uint64_t *)&test2[2] = 3LL;\n  libmin_qsort(test2, 40uLL, 4uLL, int_compare);\n  libmin_printf(\n      \"\\nTest 2: Sorted Integer Array with Few Duplicates (40 elements):\\n\");\n  print_array(test1, 40uLL);\n  if (is_sorted(test1, 40uLL))\n    libmin_printf(\"Test 2 passed: duplicate elements sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 2 failed: duplicate elements not sorted correctly.\\n\");\n  for (i = 0LL; i != 40; ++i) test1[i] = i;\n  libmin_qsort(test1, 40uLL, 4uLL, int_compare);\n  libmin_printf(\"\\nTest 3: Already Sorted Integer Array (40 elements):\\n\");\n  print_array(test1, 40uLL);\n  if (is_sorted(test1, 40uLL))\n    libmin_printf(\"Test 3 passed: array remains sorted.\\n\");\n  else\n    libmin_printf(\n        \"Test 3 failed: already sorted array not sorted correctly.\\n\");\n  v4 = 39;\n  v5 = test4;\n  do *v5++ = v4--;\n  while (v4 != -1);\n  libmin_qsort(test1, 40uLL, 4uLL, int_compare);\n  libmin_printf(\n      \"\\nTest 4: Sorted Reverse Order Integer Array (40 elements):\\n\");\n  print_array(test1, 40uLL);\n  if (is_sorted(test1, 40uLL))\n    libmin_printf(\"Test 4 passed: reverse sorted array sorted correctly.\\n\");\n  else\n    libmin_printf(\n        \"Test 4 failed: reverse sorted array not sorted correctly.\\n\");\n  test_strings[2] = \"orange\";\n  test_strings[3] = \"kiwi\";\n  test_strings[4] = \"grape\";\n  test_strings[5] = \"mango\";\n  test_strings[6] = \"strawberry\";\n  test_strings[7] = \"pear\";\n  test_strings[8] = \"pineapple\";\n  test_strings[9] = \"watermelon\";\n  test_strings[10] = \"blueberry\";\n  test_strings[11] = \"raspberry\";\n  test_strings[12] = \"blackberry\";\n  test_strings[13] = \"cherry\";\n  test_strings[14] = \"peach\";\n  test_strings[15] = \"apricot\";\n  test_strings[16] = \"plum\";\n  test_strings[17] = \"nectarine\";\n  test_strings[18] = \"cantaloupe\";\n  test_strings[19] = \"honeydew\";\n  test_strings[20] = \"papaya\";\n  test_strings[21] = \"passionfruit\";\n  test_strings[22] = \"guava\";\n  test_strings[23] = \"lychee\";\n  test_strings[24] = \"pomegranate\";\n  test_strings[25] = \"grapefruit\";\n  test_strings[26] = \"lemon\";\n  test_strings[27] = \"lime\";\n  test_strings[28] = \"tangerine\";\n  test_strings[0] = \"banana\";\n  test_strings[29] = \"cranberry\";\n  test_strings[30] = \"fig\";\n  test_strings[1] = \"apple\";\n  test_strings[31] = \"apple\";\n  libmin_qsort(test_strings, 32uLL, 8uLL, string_compare);\n  libmin_printf(\"\\nTest 5: Sorted String Array (32 elements):\\n\");\n  print_string_array((const char **)test1, 32uLL);\n  if (is_sorted_string_array((const char **)test1, 32uLL))\n    libmin_printf(\"Test 5 passed: string array sorted correctly.\\n\");\n  else\n    libmin_printf(\"Test 5 failed: string array not sorted correctly.\\n\");\n  libmin_success();\n}", "binary": "qsort-test/qsort-test.host.O2", "assembly": "<main>:\nendbr64\npush   %r12\nlea    0x803(%rip),%r12\nmov    $0x4,%edx\nmov    $0x28,%esi\npush   %rbp\nmov    %r12,%rcx\nsub    $0x398,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x388(%rsp)\nmovabs $0x300000005,%rax\nmov    %rsp,%rbp\nmov    %rbp,%rdi\nmov    %rax,(%rsp)\nmovabs $0x80000000c,%rax\nmov    %rax,0x8(%rsp)\nmovabs $0x1300000001,%rax\nmov    %rax,0x10(%rsp)\nmovabs $0x400000007,%rax\nmov    %rax,0x18(%rsp)\nmovabs $0x600000000,%rax\nmov    %rax,0x20(%rsp)\nmovabs $0xf0000000a,%rax\nmov    %rax,0x28(%rsp)\nmovabs $0x1600000002,%rax\nmov    %rax,0x30(%rsp)\nmovabs $0x110000000b,%rax\nmov    %rax,0x38(%rsp)\nmovabs $0x140000000d,%rax\nmov    %rax,0x40(%rsp)\nmovabs $0xe00000009,%rax\nmov    %rax,0x48(%rsp)\nmovabs $0x1500000010,%rax\nmov    %rax,0x50(%rsp)\nmovabs $0x1200000017,%rax\nmov    %rax,0x58(%rsp)\nmovabs $0x1900000018,%rax\nmov    %rax,0x60(%rsp)\nmovabs $0x1b0000001a,%rax\nmov    %rax,0x68(%rsp)\nmovabs $0x1d0000001c,%rax\nmov    %rax,0x70(%rsp)\nmovabs $0x1f0000001e,%rax\nmov    %rax,0x78(%rsp)\nmovabs $0x2100000020,%rax\nmov    %rax,0x80(%rsp)\nmovabs $0x2300000022,%rax\nmov    %rax,0x88(%rsp)\nmovabs $0x2500000024,%rax\nmov    %rax,0x90(%rsp)\nmovabs $0x2700000026,%rax\nmov    %rax,0x98(%rsp)\ncall   3420 <libmin_qsort>\nlea    0x2e6c(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\nmov    $0x28,%esi\nmov    %rbp,%rdi\ncall   1990 <print_array>\nmov    $0x28,%esi\nmov    %rbp,%rdi\ncall   1950 <is_sorted>\ntest   %eax,%eax\nje     181b <main+0x6fb>\nlea    0x2e74(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\nlea    0xa0(%rsp),%rbp\nmov    %r12,%rcx\nmov    $0x4,%edx\nmovabs $0x100000002,%rax\nmov    %rax,0xa0(%rsp)\nmov    %rbp,%rdi\nmovabs $0x500000004,%rax\nmov    $0x28,%esi\nmov    %rax,0xb0(%rsp)\nmovabs $0x700000005,%rax\nmov    %rax,0xb8(%rsp)\nmovabs $0x900000008,%rax\nmov    %rax,0xc0(%rsp)\nmovabs $0xb0000000a,%rax\nmov    %rax,0xc8(%rsp)\nmovabs $0xd0000000c,%rax\nmov    %rax,0xd0(%rsp)\nmovabs $0xf0000000e,%rax\nmov    %rax,0xd8(%rsp)\nmovabs $0x1100000010,%rax\nmov    %rax,0xe0(%rsp)\nmovabs $0x1300000012,%rax\nmov    %rax,0xe8(%rsp)\nmovabs $0x1500000014,%rax\nmov    %rax,0xf0(%rsp)\nmovabs $0x1700000016,%rax\nmov    %rax,0xf8(%rsp)\nmovabs $0x1900000018,%rax\nmov    %rax,0x100(%rsp)\nmovabs $0x1b0000001a,%rax\nmov    %rax,0x108(%rsp)\nmovabs $0x1d0000001c,%rax\nmov    %rax,0x110(%rsp)\nmovabs $0x1f0000001e,%rax\nmov    %rax,0x118(%rsp)\nmovabs $0x2100000020,%rax\nmov    %rax,0x120(%rsp)\nmovabs $0x2300000022,%rax\nmov    %rax,0x128(%rsp)\nmovabs $0x2500000024,%rax\nmov    %rax,0x130(%rsp)\nmovabs $0x2700000026,%rax\nmov    %rax,0x138(%rsp)\nmovq   $0x3,0xa8(%rsp)\ncall   3420 <libmin_qsort>\nlea    0x2d3f(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\nmov    $0x28,%esi\nmov    %rbp,%rdi\ncall   1990 <print_array>\nmov    $0x28,%esi\nmov    %rbp,%rdi\ncall   1950 <is_sorted>\ntest   %eax,%eax\nje     1808 <main+0x6e8>\nlea    0x2d57(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\nxor    %eax,%eax\nlea    0x140(%rsp),%rbp\nnopw   0x0(%rax,%rax,1)\nmov    %eax,0x0(%rbp,%rax,4)\nadd    $0x1,%rax\ncmp    $0x28,%rax\njne    14a0 <main+0x380>\nmov    %r12,%rcx\nmov    $0x4,%edx\nmov    $0x28,%esi\nmov    %rbp,%rdi\ncall   3420 <libmin_qsort>\nlea    0x2d8e(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\nmov    $0x28,%esi\nmov    %rbp,%rdi\ncall   1990 <print_array>\nmov    $0x28,%esi\nmov    %rbp,%rdi\ncall   1950 <is_sorted>\ntest   %eax,%eax\nje     17d2 <main+0x6b2>\nlea    0x2d96(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\nlea    0x1e0(%rsp),%rbp\nmov    $0x27,%eax\nmov    %rbp,%rdx\nnopl   0x0(%rax)\nmov    %eax,(%rdx)\nsub    $0x1,%eax\nadd    $0x4,%rdx\ncmp    $0xffffffff,%eax\njne    1518 <main+0x3f8>\nmov    %r12,%rcx\nmov    $0x4,%edx\nmov    $0x28,%esi\nmov    %rbp,%rdi\ncall   3420 <libmin_qsort>\nlea    0x2db6(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\nmov    $0x28,%esi\nmov    %rbp,%rdi\ncall   1990 <print_array>\nmov    $0x28,%esi\nmov    %rbp,%rdi\ncall   1950 <is_sorted>\ntest   %eax,%eax\nje     17f5 <main+0x6d5>\nlea    0x2dc6(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\nlea    0x2a95(%rip),%rcx\nlea    0x2ab1(%rip),%rsi\nmov    $0x8,%edx\nmov    %rcx,0x290(%rsp)\nlea    0x2a81(%rip),%rcx\nlea    0x280(%rsp),%rbp\nmov    %rcx,0x298(%rsp)\nlea    0x2a6f(%rip),%rcx\nlea    0x2a55(%rip),%rax\nmov    %rbp,%rdi\nmov    %rcx,0x2a0(%rsp)\nlea    0x2a5c(%rip),%rcx\nmov    %rcx,0x2a8(%rsp)\nlea    0x2a53(%rip),%rcx\nmov    %rcx,0x2b0(%rsp)\nlea    0x2a54(%rip),%rcx\nmov    %rsi,0x2b8(%rsp)\nlea    0x2a4f(%rip),%rsi\nmov    %rcx,0x2c0(%rsp)\nlea    0x2a4b(%rip),%rcx\nmov    %rsi,0x2c8(%rsp)\nlea    0x2a46(%rip),%rsi\nmov    %rcx,0x2d0(%rsp)\nlea    0x2a41(%rip),%rcx\nmov    %rsi,0x2d8(%rsp)\nlea    0x2a3d(%rip),%rsi\nmov    %rcx,0x2e0(%rsp)\nlea    0x2a35(%rip),%rcx\nmov    %rsi,0x2e8(%rsp)\nlea    0x2a2c(%rip),%rsi\nmov    %rcx,0x2f0(%rsp)\nlea    0x2a25(%rip),%rcx\nmov    %rsi,0x2f8(%rsp)\nlea    0x2a1b(%rip),%rsi\nmov    %rcx,0x300(%rsp)\nlea    0x2a16(%rip),%rcx\nmov    %rsi,0x308(%rsp)\nlea    0x2a12(%rip),%rsi\nmov    %rcx,0x310(%rsp)\nlea    0x2a0c(%rip),%rcx\nmov    %rsi,0x318(%rsp)\nlea    0x2a04(%rip),%rsi\nmov    %rcx,0x320(%rsp)\nlea    0x2a02(%rip),%rcx\nmov    %rsi,0x328(%rsp)\nlea    0x29f9(%rip),%rsi\nmov    %rcx,0x330(%rsp)\nlea    0x29f1(%rip),%rcx\nmov    %rsi,0x338(%rsp)\nlea    0x29ee(%rip),%rsi\nmov    %rcx,0x340(%rsp)\nlea    0x29ea(%rip),%rcx\nmov    %rsi,0x348(%rsp)\nlea    0x29e1(%rip),%rsi\nmov    %rcx,0x350(%rsp)\nlea    0x29d7(%rip),%rcx\nmov    %rsi,0x358(%rsp)\nlea    0x29d2(%rip),%rsi\nmov    %rcx,0x360(%rsp)\nlea    0x29cd(%rip),%rcx\nmov    %rax,0x280(%rsp)\nlea    0x28ff(%rip),%rax\nmov    %rsi,0x368(%rsp)\nmov    $0x20,%esi\nmov    %rcx,0x370(%rsp)\nlea    0x1e2(%rip),%rcx\nmov    %rax,0x288(%rsp)\nmov    %rax,0x378(%rsp)\ncall   3420 <libmin_qsort>\nlea    0x2c36(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\nmov    $0x20,%esi\nmov    %rbp,%rdi\ncall   1a50 <print_string_array>\nmov    $0x20,%esi\nmov    %rbp,%rdi\ncall   19f0 <is_sorted_string_array>\ntest   %eax,%eax\nje     17e5 <main+0x6c5>\nlea    0x2c3a(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\ncall   34e0 <libmin_success>\nmov    0x388(%rsp),%rax\nsub    %fs:0x28,%rax\njne    182e <main+0x70e>\nadd    $0x398,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\nlea    0x2adf(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\njmp    1501 <main+0x3e1>\nlea    0x2c24(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\njmp    17ad <main+0x68d>\nlea    0x2b74(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\njmp    1579 <main+0x459>\nlea    0x2a09(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\njmp    1490 <main+0x370>\nlea    0x2946(%rip),%rdi\nxor    %eax,%eax\ncall   2ff0 <libmin_printf>\njmp    12d3 <main+0x1b3>\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "print_array", "content": "/* Function to print an array of integers. */\nvoid print_array(const int arr[], size_t n) {\n    for (size_t i = 0; i < n; i++)\n        libmin_printf(\"%d \", arr[i]);\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O2.pseudo", "function_name": "print_array", "address": "0x1990", "label": "print_array", "content": "void __fastcall print_array(const int *arr, size_t n)\n{\n  __int64 i; // rbx\n  int v4; // esi\n\n  if ( n )\n  {\n    for ( i = 0LL; i != n; ++i )\n    {\n      v4 = arr[i];\n      libmin_printf(\"%d \", v4);\n    }\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void print_array(const int *arr, unsigned int n) {\n  long long i;\n  int v4;\n  if (n) {\n    for (i = 0LL; i != n; ++i) {\n      v4 = arr[i];\n      libmin_printf(\"%d \", v4);\n    }\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "qsort-test/qsort-test.host.O2", "assembly": "<print_array>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %rsi,%rsi\nje     19cf <print_array+0x3f>\nmov    %rdi,%r12\nmov    %rsi,%rbp\nlea    0x2654(%rip),%r13\nxor    %ebx,%ebx\nnopw   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,4),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   2ff0 <libmin_printf>\ncmp    %rbx,%rbp\njne    19b8 <print_array+0x28>\nadd    $0x8,%rsp\nlea    0x262e(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    2ff0 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "print_string_array", "content": "/* Function to print an array of strings. */\nvoid print_string_array(const char *arr[], size_t n) {\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s \", arr[i]);\n    }\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O2.pseudo", "function_name": "print_string_array", "address": "0x1a50", "label": "print_string_array", "content": "void __fastcall print_string_array(const char **arr, size_t n)\n{\n  __int64 i; // rbx\n  const char *v4; // rsi\n\n  if ( n )\n  {\n    for ( i = 0LL; i != n; ++i )\n    {\n      v4 = arr[i];\n      libmin_printf(\"%s \", v4);\n    }\n  }\n  libmin_printf(\"\\n\");\n}\n"}, "pseudo_normalize": "void print_string_array(const char **arr, unsigned int n) {\n  long long i;\n  const char *v4;\n  if (n) {\n    for (i = 0LL; i != n; ++i) {\n      v4 = arr[i];\n      libmin_printf(\"%s \", v4);\n    }\n  }\n  libmin_printf(\"\\n\");\n}", "binary": "qsort-test/qsort-test.host.O2", "assembly": "<print_string_array>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\ntest   %rsi,%rsi\nje     1a8f <print_string_array+0x3f>\nmov    %rdi,%r12\nmov    %rsi,%rbp\nlea    0x259a(%rip),%r13\nxor    %ebx,%ebx\nnopw   0x0(%rax,%rax,1)\nmov    (%r12,%rbx,8),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   2ff0 <libmin_printf>\ncmp    %rbx,%rbp\njne    1a78 <print_string_array+0x28>\nadd    $0x8,%rsp\nlea    0x256e(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    2ff0 <libmin_printf>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "qsort-test/qsort-test.c", "function_name": "string_compare", "content": "/* Comparison function for strings using strcmp.\n * Note: Each element is a pointer to char.\n */\nint string_compare(const void *a, const void *b) {\n    const char * const *str1 = (const char * const *) a;\n    const char * const *str2 = (const char * const *) b;\n    return libmin_strcmp(*str1, *str2);\n}\n"}, "pseudo": {"path": "qsort-test/qsort-test.host.O2.pseudo", "function_name": "string_compare", "address": "0x1940", "label": "string_compare", "content": "int __fastcall string_compare(const void *a, const void *b)\n{\n  return libmin_strcmp(*(const char **)a, *(const char **)b);\n}\n"}, "pseudo_normalize": "", "binary": "qsort-test/qsort-test.host.O2", "assembly": "<string_compare>:\nendbr64\nmov    (%rsi),%rsi\nmov    (%rdi),%rdi\njmp    3450 <libmin_strcmp>\nnop\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "euler_from_quat", "content": "/**\n * Function to convert given quaternion to Euler angles.\n * \\f{eqnarray*}{\n * \\phi & = &\n * \\tan^{-1}\\left[\\frac{2\\left(q_0q_1+q_2q_3\\right)}{1-2\\left(q_1^2+q_2^2\\right)}\\right]\\\\\n * \\theta & =\n * &-\\sin^{-1}\\left[2\\left(q_0q_2-q_3q_1\\right)\\right]\\\\\n * \\psi & = &\n * \\tan^{-1}\\left[\\frac{2\\left(q_0q_3+q_1q_2\\right)}{1-2\\left(q_2^2+q_3^2\\right)}\\right]\\\\\n * \\f}\n *\n * @param [in] in_quat input quaternion instance\n * @returns converted euler angles\n */\neuler euler_from_quat(const quaternion *in_quat)\n{\n    euler out_euler = {{0.0}, {0.0}, {0.0}};\n    if (!in_quat)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_euler;\n    }\n\n    out_euler.roll = libmin_atan2(\n        2.0 * (in_quat->w * in_quat->q1 + in_quat->q2 * in_quat->q3),\n        1.0 - 2.0 * (in_quat->q1 * in_quat->q1 + in_quat->q2 * in_quat->q2));\n    out_euler.pitch =\n        libmin_asin(2.0 * (in_quat->w * in_quat->q2 + in_quat->q1 * in_quat->q3));\n    out_euler.yaw = libmin_atan2(\n        2.0 * (in_quat->w * in_quat->q3 + in_quat->q1 * in_quat->q2),\n        1.0 - 2.0 * (in_quat->q2 * in_quat->q2 + in_quat->q3 * in_quat->q3));\n\n    return out_euler;\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O2.pseudo", "function_name": "euler_from_quat", "address": "0x1580", "label": "euler_from_quat", "content": "euler *__fastcall euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat)\n{\n  double v2; // xmm1_8\n  double v3; // xmm2_8\n  double v4; // xmm2_8\n  double v5; // xmm0_8\n  double v6; // xmm4_8\n  double v7; // xmm5_8\n  euler *result; // rax\n  double v9; // [rsp+0h] [rbp-28h]\n  double v10; // [rsp+8h] [rbp-20h]\n\n  if ( in_quat )\n  {\n    v2 = in_quat->dual.x * in_quat->dual.x;\n    v10 = libmin_atan2(\n            1.0 - (v2 + in_quat->dual.y * in_quat->dual.y + v2 + in_quat->dual.y * in_quat->dual.y),\n            in_quat->dual.y * in_quat->dual.z);\n    v9 = libmin_asin(in_quat->dual.x * in_quat->dual.z);\n    v3 = in_quat->dual.y * in_quat->dual.y;\n    v4 = v3 + in_quat->dual.z * in_quat->dual.z + v3 + in_quat->dual.z * in_quat->dual.z;\n    v5 = libmin_atan2(1.0 - v4, v4);\n    v6 = v10;\n    v7 = v9;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    v6 = 0.0;\n    v7 = 0.0;\n    v5 = 0.0;\n  }\n  retstr->roll = v6;\n  result = retstr;\n  retstr->pitch = v7;\n  retstr->yaw = v5;\n  return result;\n}\n"}, "pseudo_normalize": "euler *euler_from_quat(euler *__return_ptr retstr, const quaternion *in_quat) {\n  double v2;\n  double v3;\n  double v4;\n  double v5;\n  double v6;\n  double v7;\n  euler *result;\n  double v9;\n  double v10;\n  if (in_quat) {\n    v2 = in_quat->dual.x * in_quat->dual.x;\n    v10 = libmin_atan2(1.0 - (v2 + in_quat->dual.y * in_quat->dual.y + v2 +\n                              in_quat->dual.y * in_quat->dual.y),\n                       in_quat->dual.y * in_quat->dual.z);\n    v9 = libmin_asin(in_quat->dual.x * in_quat->dual.z);\n    v3 = in_quat->dual.y * in_quat->dual.y;\n    v4 = v3 + in_quat->dual.z * in_quat->dual.z + v3 +\n         in_quat->dual.z * in_quat->dual.z;\n    v5 = libmin_atan2(1.0 - v4, v4);\n    v6 = v10;\n    v7 = v9;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"euler_from_quat\");\n    v6 = 0.0;\n    v7 = 0.0;\n    v5 = 0.0;\n  }\n  retstr->roll = v6;\n  result = retstr;\n  retstr->pitch = v7;\n  retstr->yaw = v5;\n  return result;\n}", "binary": "quaternions/quaternions.host.O2", "assembly": "<euler_from_quat>:\nendbr64\npush   %r12\nmov    %rdi,%r12\npush   %rbx\nsub    $0x18,%rsp\ntest   %rsi,%rsi\nje     1680 <euler_from_quat+0x100>\nmovsd  0x8(%rsi),%xmm0\nmovsd  0x10(%rsi),%xmm2\nmov    %rsi,%rbx\nmovsd  0x3b0c(%rip),%xmm6\nmovapd %xmm0,%xmm1\nmovapd %xmm2,%xmm3\nmulsd  %xmm2,%xmm3\nmulsd  %xmm0,%xmm1\nmulsd  0x18(%rsi),%xmm2\nmulsd  (%rsi),%xmm0\naddsd  %xmm3,%xmm1\naddsd  %xmm2,%xmm0\naddsd  %xmm1,%xmm1\naddsd  %xmm0,%xmm0\nsubsd  %xmm1,%xmm6\nmovapd %xmm6,%xmm1\ncall   1f50 <libmin_atan2>\nmovsd  0x8(%rbx),%xmm1\nmulsd  0x18(%rbx),%xmm1\nmovsd  %xmm0,0x8(%rsp)\nmovsd  (%rbx),%xmm0\nmulsd  0x10(%rbx),%xmm0\naddsd  %xmm1,%xmm0\naddsd  %xmm0,%xmm0\ncall   19e0 <libmin_asin>\nmovsd  0x10(%rbx),%xmm3\nmovsd  0x18(%rbx),%xmm1\nmovsd  %xmm0,(%rsp)\nmovapd %xmm3,%xmm2\nmovapd %xmm1,%xmm0\nmulsd  %xmm1,%xmm0\nmulsd  %xmm3,%xmm2\nmulsd  (%rbx),%xmm1\nmulsd  0x8(%rbx),%xmm3\naddsd  %xmm0,%xmm2\naddsd  %xmm3,%xmm1\naddsd  %xmm2,%xmm2\naddsd  %xmm1,%xmm1\nmovapd %xmm1,%xmm0\nmovsd  0x3a6c(%rip),%xmm1\nsubsd  %xmm2,%xmm1\ncall   1f50 <libmin_atan2>\nmovsd  0x8(%rsp),%xmm4\nmovsd  (%rsp),%xmm5\nmovsd  %xmm4,(%r12)\nmov    %r12,%rax\nmovsd  %xmm5,0x8(%r12)\nmovsd  %xmm0,0x10(%r12)\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\nret\nnop\nlea    0x3a09(%rip),%rsi\nlea    0x3976(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\npxor   %xmm4,%xmm4\nmovapd %xmm4,%xmm5\nmovapd %xmm4,%xmm0\njmp    1660 <euler_from_quat+0xe0>\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "main", "content": "int main()\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double x; // xmm1_8\n  double v4; // xmm1_8\n  __int128 v5; // [rsp+8h] [rbp-90h]\n  euler in_euler; // [rsp+20h] [rbp-78h] BYREF\n  quaternion in_quat; // [rsp+40h] [rbp-58h] BYREF\n  quaternion v8; // [rsp+60h] [rbp-38h] BYREF\n  unsigned __int64 v9; // [rsp+88h] [rbp-10h]\n\n  v9 = __readfsqword(0x28u);\n  in_quat.w = 0.7071;\n  *(_OWORD *)&in_quat.dual.x = 0x3FE6A0902DE00D1BuLL;\n  in_quat.dual.z = 0.0;\n  euler_from_quat(&in_euler, &in_quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", in_euler.pitch, in_euler.roll, in_euler.yaw);\n  quat_from_euler(&v8, &in_euler);\n  x = v8.dual.x;\n  v5 = *(_OWORD *)&v8.w;\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", v8.w, v8.dual.x, v8.dual.y, v8.dual.z);\n  if ( libmin_fabs(x) < 0.01 )\n  {\n    v4 = *((double *)&v5 + 1) - in_quat.dual.x;\n    if ( libmin_fabs(*((double *)&v5 + 1) - in_quat.dual.x) < 0.01 )\n    {\n      if ( libmin_fabs(v4) < 0.01 )\n      {\n        if ( libmin_fabs(v4) < 0.01 )\n        {\n          libmin_printf(\"All tests passed!\\n\");\n          libmin_success();\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double x;\n  double v4;\n  __int128 v5;\n  euler in_euler;\n  quaternion in_quat;\n  quaternion v8;\n  unsigned long long v9;\n  v9 = __readfsqword(40u);\n  in_quat.w = 0.7071;\n  *(long double *)&in_quat.dual.x = 4604544210138303771uLL;\n  in_quat.dual.z = 0.0;\n  euler_from_quat(&in_euler, &in_quat);\n  libmin_printf(\"Euler: %.4lf, %.4lf, %.4lf\\n\", in_euler.pitch, in_euler.roll,\n                in_euler.yaw);\n  quat_from_euler(&v8, &in_euler);\n  x = v8.dual.x;\n  v5 = *(long double *)&v8.w;\n  libmin_printf(\"Quaternion: %.4lf %+.4lf %+.4lf %+.4lf\\n\", v8.w, v8.dual.x,\n                v8.dual.y, v8.dual.z);\n  if (libmin_fabs(x) < 0.01) {\n    v4 = *((double *)&v5 + 1) - in_quat.dual.x;\n    if (libmin_fabs(*((double *)&v5 + 1) - in_quat.dual.x) < 0.01) {\n      if (libmin_fabs(v4) < 0.01) {\n        if (libmin_fabs(v4) < 0.01) {\n          libmin_printf(\"All tests passed!\\n\");\n          libmin_success();\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}", "binary": "quaternions/quaternions.host.O2", "assembly": "<main>:\nendbr64\npush   %rbp\nsub    $0x90,%rsp\nmovsd  0x3fac(%rip),%xmm0\nmov    %fs:0x28,%rax\nmov    %rax,0x88(%rsp)\nxor    %eax,%eax\nlea    0x20(%rsp),%rbp\nlea    0x40(%rsp),%rsi\nmovq   $0x0,0x50(%rsp)\nmov    %rbp,%rdi\nmovsd  %xmm0,0x40(%rsp)\nmovsd  %xmm0,0x48(%rsp)\nmovq   $0x0,0x58(%rsp)\ncall   1580 <euler_from_quat>\nmovsd  0x30(%rsp),%xmm2\nmovsd  0x20(%rsp),%xmm1\nlea    0x3ead(%rip),%rdi\nmovsd  0x28(%rsp),%xmm0\nmov    $0x3,%eax\ncall   35d0 <libmin_printf>\nmov    %rbp,%rsi\nlea    0x60(%rsp),%rdi\ncall   13f0 <quat_from_euler>\nmovsd  0x78(%rsp),%xmm4\nmov    $0x4,%eax\nmovsd  0x68(%rsp),%xmm1\nmovsd  0x70(%rsp),%xmm2\nmovsd  0x60(%rsp),%xmm0\nlea    0x3e9d(%rip),%rdi\nmovapd %xmm4,%xmm3\nmovsd  %xmm1,0x10(%rsp)\nmovq   %xmm4,%rbp\nmovsd  %xmm2,0x18(%rsp)\nmovsd  %xmm0,0x8(%rsp)\ncall   35d0 <libmin_printf>\nmovsd  0x8(%rsp),%xmm0\nsubsd  0x40(%rsp),%xmm0\ncall   2210 <libmin_fabs>\nmovsd  0x3ee4(%rip),%xmm5\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x18(%rsp),%xmm2\ncomisd %xmm0,%xmm5\njbe    1297 <main+0x197>\nsubsd  0x48(%rsp),%xmm1\nmovsd  %xmm2,0x8(%rsp)\nmovapd %xmm1,%xmm0\ncall   2210 <libmin_fabs>\nmovsd  0x3eb1(%rip),%xmm6\nmovsd  0x8(%rsp),%xmm2\ncomisd %xmm0,%xmm6\njbe    12d9 <main+0x1d9>\nsubsd  0x50(%rsp),%xmm2\nmovapd %xmm2,%xmm0\ncall   2210 <libmin_fabs>\nmovsd  0x3e8a(%rip),%xmm7\ncomisd %xmm0,%xmm7\njbe    12ca <main+0x1ca>\nmovq   %rbp,%xmm0\nsubsd  0x58(%rsp),%xmm0\ncall   2210 <libmin_fabs>\nmovsd  0x3e68(%rip),%xmm4\ncomisd %xmm0,%xmm4\njbe    12be <main+0x1be>\nlea    0x3dc6(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\ncall   3e90 <libmin_success>\nmov    0x88(%rsp),%rax\nsub    %fs:0x28,%rax\njne    12ee <main+0x1ee>\nadd    $0x90,%rsp\nxor    %eax,%eax\npop    %rbp\nret\nmov    $0x1,%edi\nmovsd  %xmm2,0x10(%rsp)\nmovsd  %xmm1,0x8(%rsp)\ncall   2250 <libmin_fail>\nmovsd  0x10(%rsp),%xmm2\nmovsd  0x8(%rsp),%xmm1\njmp    11fa <main+0xfa>\nmov    $0x1,%edi\ncall   2250 <libmin_fail>\njmp    1266 <main+0x166>\nmov    $0x1,%edi\ncall   2250 <libmin_fail>\njmp    1248 <main+0x148>\nmov    $0x1,%edi\ncall   2250 <libmin_fail>\nmovsd  0x8(%rsp),%xmm2\njmp    1227 <main+0x127>\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "quat_from_euler", "content": "/**\n * @addtogroup quats 3D Quaternion operations\n * @{\n */\n\n/**\n * Function to convert given Euler angles to a quaternion.\n * \\f{eqnarray*}{\n * q_{0} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * +\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{1} & =\n * &\\sin\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * -\n * \\cos\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{2} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * +\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{3} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\n * -\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\\\\\n * \\f}\n *\n * @param [in] in_euler input Euler angles instance\n * @returns converted quaternion\n */\nquaternion quat_from_euler(const euler *in_euler)\n{\n    quaternion out_quat = {{0.0}, {{0.0, 0.0, 0.0}}}; \n\n    if (!in_euler)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_quat;\n    }\n\n    quaternion temp;\n\n    double cy = libmin_cos(in_euler->yaw * 0.5);\n    double sy = libmin_sin(in_euler->yaw * 0.5);\n    double cp = libmin_cos(in_euler->pitch * 0.5);\n    double sp = libmin_sin(in_euler->pitch * 0.5);\n    double cr = libmin_cos(in_euler->roll * 0.5);\n    double sr = libmin_sin(in_euler->roll * 0.5);\n\n    temp.w = cr * cp * cy + sr * sp * sy;\n    temp.q1 = sr * cp * cy - cr * sp * sy;\n    temp.q2 = cr * sp * cy + sr * cp * sy;\n    temp.q3 = cr * cp * sy - sr * sp * cy;\n\n    return temp;\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O2.pseudo", "function_name": "quat_from_euler", "address": "0x13f0", "label": "quat_from_euler", "content": "quaternion *__fastcall quat_from_euler(quaternion *__return_ptr retstr, const euler *in_euler)\n{\n  double v2; // xmm1_8\n  double v3; // xmm0_8\n  quaternion *result; // rax\n  double cr; // [rsp+8h] [rbp-40h]\n  double sp_0; // [rsp+10h] [rbp-38h]\n  double cp; // [rsp+18h] [rbp-30h]\n  double sy; // [rsp+20h] [rbp-28h]\n  double cy; // [rsp+28h] [rbp-20h]\n\n  if ( in_euler )\n  {\n    cy = libmin_cos(v2);\n    sy = libmin_sin(v2);\n    cp = libmin_cos(v2);\n    sp_0 = libmin_sin(v2);\n    cr = libmin_cos(v2);\n    v3 = libmin_sin(v2);\n    result = retstr;\n    retstr->w = cp * cr * cy + sp_0 * v3 * sy;\n    retstr->dual.z = cp * cr * sy - sp_0 * v3 * cy;\n    retstr->dual.x = cp * v3 * cy - sp_0 * cr * sy;\n    retstr->dual.y = sp_0 * cr * cy + cp * v3 * sy;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    retstr->w = 0.0;\n    result = retstr;\n    *(_OWORD *)&retstr->dual.x = 0uLL;\n    retstr->dual.z = 0.0;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "quaternion *quat_from_euler(quaternion *__return_ptr retstr,\n                            const euler *in_euler) {\n  double v2;\n  double v3;\n  quaternion *result;\n  double cr;\n  double sp_0;\n  double cp;\n  double sy;\n  double cy;\n  if (in_euler) {\n    cy = libmin_cos(v2);\n    sy = libmin_sin(v2);\n    cp = libmin_cos(v2);\n    sp_0 = libmin_sin(v2);\n    cr = libmin_cos(v2);\n    v3 = libmin_sin(v2);\n    result = retstr;\n    retstr->w = cp * cr * cy + sp_0 * v3 * sy;\n    retstr->dual.z = cp * cr * sy - sp_0 * v3 * cy;\n    retstr->dual.x = cp * v3 * cy - sp_0 * cr * sy;\n    retstr->dual.y = sp_0 * cr * cy + cp * v3 * sy;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quat_from_euler\");\n    retstr->w = 0.0;\n    result = retstr;\n    *(long double *)&retstr->dual.x = 0uLL;\n    retstr->dual.z = 0.0;\n  }\n  return result;\n}", "binary": "quaternions/quaternions.host.O2", "assembly": "<quat_from_euler>:\nendbr64\npush   %r12\nmov    %rdi,%r12\npush   %rbx\nsub    $0x38,%rsp\ntest   %rsi,%rsi\nje     1530 <quat_from_euler+0x140>\nmovsd  0x3ca1(%rip),%xmm0\nmulsd  0x10(%rsi),%xmm0\nmov    %rsi,%rbx\ncall   3940 <libmin_cos>\nmovsd  %xmm0,0x28(%rsp)\nmovsd  0x3c86(%rip),%xmm0\nmulsd  0x10(%rbx),%xmm0\ncall   3aa0 <libmin_sin>\nmovsd  %xmm0,0x20(%rsp)\nmovsd  0x3c6e(%rip),%xmm0\nmulsd  0x8(%rbx),%xmm0\ncall   3940 <libmin_cos>\nmovsd  %xmm0,0x18(%rsp)\nmovsd  0x3c56(%rip),%xmm0\nmulsd  0x8(%rbx),%xmm0\ncall   3aa0 <libmin_sin>\nmovsd  %xmm0,0x10(%rsp)\nmovsd  0x3c3e(%rip),%xmm0\nmulsd  (%rbx),%xmm0\ncall   3940 <libmin_cos>\nmovsd  %xmm0,0x8(%rsp)\nmovsd  0x3c27(%rip),%xmm0\nmulsd  (%rbx),%xmm0\ncall   3aa0 <libmin_sin>\nmovsd  0x18(%rsp),%xmm2\nmov    %r12,%rax\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x8(%rsp),%xmm7\nmovsd  0x28(%rsp),%xmm4\nmovapd %xmm2,%xmm3\nmovapd %xmm1,%xmm6\nmovsd  0x20(%rsp),%xmm5\nmulsd  %xmm7,%xmm3\nmulsd  %xmm0,%xmm6\nmulsd  %xmm0,%xmm2\nmulsd  %xmm7,%xmm1\nmovapd %xmm3,%xmm0\nmulsd  %xmm4,%xmm0\nmovapd %xmm6,%xmm7\nmulsd  %xmm5,%xmm7\nmulsd  %xmm5,%xmm3\nmulsd  %xmm4,%xmm6\naddsd  %xmm7,%xmm0\nmovapd %xmm1,%xmm7\nmulsd  %xmm5,%xmm7\nmulsd  %xmm4,%xmm1\nsubsd  %xmm6,%xmm3\nmovsd  %xmm0,(%r12)\nmovapd %xmm2,%xmm0\nmulsd  %xmm4,%xmm0\nmulsd  %xmm5,%xmm2\nmovsd  %xmm3,0x18(%r12)\nsubsd  %xmm7,%xmm0\naddsd  %xmm2,%xmm1\nmovsd  %xmm0,0x8(%r12)\nmovsd  %xmm1,0x10(%r12)\nadd    $0x38,%rsp\npop    %rbx\npop    %r12\nret\nxchg   %ax,%ax\nlea    0x3b69(%rip),%rsi\nlea    0x3ac6(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\nmovq   $0x0,(%r12)\nmov    %r12,%rax\nmovq   $0x0,0x8(%r12)\nmovq   $0x0,0x10(%r12)\nmovq   $0x0,0x18(%r12)\nadd    $0x38,%rsp\npop    %rbx\npop    %r12\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "quaternions/quaternions.c", "function_name": "quaternion_multiply", "content": "/**\n * Function to multiply two quaternions.\n * \\f{eqnarray*}{\n * \\mathbf{c} & = & \\mathbf{a}\\otimes\\mathbf{b}\\\\\n * & = & \\begin{bmatrix}a_{0} & a_{1} & a_{2} &\n *  a_{3}\\end{bmatrix}\\otimes\\begin{bmatrix}b_{0} & b_{1} & b_{2} &\n *  b_{3}\\end{bmatrix}\\\\\n * & = &\n * \\begin{bmatrix}\n *  a_{0}b_{0}-a_{1}b_{1}-a_{2}b_{2}-a_{3}b_{3}\\\\\n *  a_{0}b_{1}+a_{1}b_{0}+a_{2}b_{3}-a_{3}b_{2}\\\\\n *  a_{0}b_{2}-a_{1}b_{3}+a_{2}b_{0}+a_{3}b_{1}\\\\\n *  a_{0}b_{3}+a_{1}b_{2}-a_{2}b_{1}+a_{3}b_{0}\n * \\end{bmatrix}^{T}\n * \\f}\n *\n * @param [in] in_quat1 first input quaternion instance\n * @param [in] in_quat2 second input quaternion instance\n * @returns resultant quaternion\n */\nquaternion quaternion_multiply(const quaternion *in_quat1,\n                               const quaternion *in_quat2)\n{\n    quaternion out_quat = {{0.0}, {{0.0, 0.0, 0.0}}}; \n    if (!in_quat1 || !in_quat2)  // if null\n    {\n        libmin_printf(\"%s: Invalid input.\", __func__);\n        return out_quat;\n    }\n\n    out_quat.w = in_quat1->w * in_quat2->w - in_quat1->q1 * in_quat2->q1 -\n                 in_quat1->q2 * in_quat2->q2 - in_quat1->q3 * in_quat2->q3;\n    out_quat.q1 = in_quat1->w * in_quat2->q1 + in_quat1->q1 * in_quat2->w +\n                  in_quat1->q2 * in_quat2->q3 - in_quat1->q3 * in_quat2->q2;\n    out_quat.q2 = in_quat1->w * in_quat2->q2 - in_quat1->q1 * in_quat2->q3 +\n                  in_quat1->q2 * in_quat2->w + in_quat1->q3 * in_quat2->q1;\n    out_quat.q3 = in_quat1->w * in_quat2->q3 + in_quat1->q1 * in_quat2->q2 -\n                  in_quat1->q2 * in_quat2->q1 + in_quat1->q3 * in_quat2->w;\n\n    return out_quat;\n}\n"}, "pseudo": {"path": "quaternions/quaternions.host.O2.pseudo", "function_name": "quaternion_multiply", "address": "0x16b0", "label": "quaternion_multiply", "content": "quaternion *__fastcall quaternion_multiply(\n        quaternion *__return_ptr retstr,\n        const quaternion *in_quat1,\n        const quaternion *in_quat2)\n{\n  double x; // xmm5_8\n  double v4; // xmm4_8\n  double y; // xmm7_8\n  double v6; // xmm8_8\n  double z; // xmm6_8\n  double v8; // xmm9_8\n  double v9; // xmm1_8\n  double v10; // xmm10_8\n  double v11; // xmm2_8\n  double v12; // xmm0_8\n  quaternion *result; // rax\n\n  if ( in_quat1 && in_quat2 )\n  {\n    x = in_quat1->dual.x;\n    v4 = in_quat2->dual.x;\n    y = in_quat1->dual.y;\n    v6 = in_quat2->dual.y;\n    z = in_quat1->dual.z;\n    v8 = in_quat2->dual.z;\n    v9 = in_quat1->w * in_quat2->w - x * v4 - y * v6 - z * v8;\n    v10 = in_quat1->w * v4 + in_quat2->w * x + y * v8 - v6 * z;\n    v11 = in_quat1->w * v6 - x * v8 + in_quat2->w * y + v4 * z;\n    v12 = in_quat1->w * v8 + x * v6 - v4 * y + in_quat2->w * z;\n  }\n  else\n  {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    v9 = 0.0;\n    v10 = 0.0;\n    v11 = 0.0;\n    v12 = 0.0;\n  }\n  result = retstr;\n  retstr->w = v9;\n  retstr->dual.x = v10;\n  retstr->dual.y = v11;\n  retstr->dual.z = v12;\n  return result;\n}\n"}, "pseudo_normalize": "quaternion *quaternion_multiply(quaternion *__return_ptr retstr,\n                                const quaternion *in_quat1,\n                                const quaternion *in_quat2) {\n  double x;\n  double v4;\n  double y;\n  double v6;\n  double z;\n  double v8;\n  double v9;\n  double v10;\n  double v11;\n  double v12;\n  quaternion *result;\n  if (in_quat1 && in_quat2) {\n    x = in_quat1->dual.x;\n    v4 = in_quat2->dual.x;\n    y = in_quat1->dual.y;\n    v6 = in_quat2->dual.y;\n    z = in_quat1->dual.z;\n    v8 = in_quat2->dual.z;\n    v9 = in_quat1->w * in_quat2->w - x * v4 - y * v6 - z * v8;\n    v10 = in_quat1->w * v4 + in_quat2->w * x + y * v8 - v6 * z;\n    v11 = in_quat1->w * v6 - x * v8 + in_quat2->w * y + v4 * z;\n    v12 = in_quat1->w * v8 + x * v6 - v4 * y + in_quat2->w * z;\n  } else {\n    libmin_printf(\"%s: Invalid input.\", \"quaternion_multiply\");\n    v9 = 0.0;\n    v10 = 0.0;\n    v11 = 0.0;\n    v12 = 0.0;\n  }\n  result = retstr;\n  retstr->w = v9;\n  retstr->dual.x = v10;\n  retstr->dual.y = v11;\n  retstr->dual.z = v12;\n  return result;\n}", "binary": "quaternions/quaternions.host.O2", "assembly": "<quaternion_multiply>:\nendbr64\npush   %r12\nmov    %rdi,%r12\ntest   %rsi,%rsi\nje     17d0 <quaternion_multiply+0x120>\ntest   %rdx,%rdx\nje     17d0 <quaternion_multiply+0x120>\nmovsd  (%rsi),%xmm0\nmovsd  0x8(%rsi),%xmm5\nmovsd  (%rdx),%xmm3\nmovsd  0x8(%rdx),%xmm4\nmovapd %xmm0,%xmm1\nmovapd %xmm5,%xmm2\nmovsd  0x10(%rsi),%xmm7\nmovsd  0x10(%rdx),%xmm8\nmulsd  %xmm4,%xmm2\nmovsd  0x18(%rsi),%xmm6\nmovapd %xmm0,%xmm10\nmovsd  0x18(%rdx),%xmm9\nmulsd  %xmm3,%xmm1\nmovapd %xmm5,%xmm11\nmulsd  %xmm4,%xmm10\nmulsd  %xmm9,%xmm11\nsubsd  %xmm2,%xmm1\nmovapd %xmm7,%xmm2\nmulsd  %xmm8,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm6,%xmm2\nmulsd  %xmm9,%xmm2\nsubsd  %xmm2,%xmm1\nmovapd %xmm3,%xmm2\nmulsd  %xmm5,%xmm2\nmulsd  %xmm8,%xmm5\naddsd  %xmm2,%xmm10\nmovapd %xmm7,%xmm2\nmulsd  %xmm9,%xmm2\naddsd  %xmm2,%xmm10\nmovapd %xmm8,%xmm2\nmulsd  %xmm6,%xmm2\nsubsd  %xmm2,%xmm10\nmovapd %xmm0,%xmm2\nmulsd  %xmm8,%xmm2\nmulsd  %xmm9,%xmm0\nsubsd  %xmm11,%xmm2\nmovapd %xmm3,%xmm11\nmulsd  %xmm7,%xmm11\naddsd  %xmm5,%xmm0\nmulsd  %xmm6,%xmm3\naddsd  %xmm11,%xmm2\nmovapd %xmm4,%xmm11\nmulsd  %xmm7,%xmm4\nmulsd  %xmm6,%xmm11\nsubsd  %xmm4,%xmm0\naddsd  %xmm11,%xmm2\naddsd  %xmm3,%xmm0\nmov    %r12,%rax\nmovsd  %xmm1,(%r12)\nmovsd  %xmm10,0x8(%r12)\nmovsd  %xmm2,0x10(%r12)\nmovsd  %xmm0,0x18(%r12)\npop    %r12\nret\nnopl   0x0(%rax)\nlea    0x3899(%rip),%rsi\nlea    0x3826(%rip),%rdi\nxor    %eax,%eax\ncall   35d0 <libmin_printf>\npxor   %xmm1,%xmm1\nmovapd %xmm1,%xmm10\nmovapd %xmm1,%xmm2\nmovapd %xmm1,%xmm0\njmp    17a8 <quaternion_multiply+0xf8>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "rabinkarp-search/rabinkarp-search.c", "function_name": "main", "content": "int\nmain(void) \n{ \n  int n = libmin_strlen(inp_txt); // String lengths are public\n  int m = libmin_strlen(inp_pat); // String lengths are public\n  libmin_printf(\"n = %d, m = %d\\n\", n, m);\n  \n  char *txt = libmin_malloc(sizeof(char)*(n+1));\n  int k;\n  for (k=0; k < n; k++)\n    txt[k] = inp_txt[k];\n  txt[k] = '\\0';\n\n  char *pat = libmin_malloc(sizeof(char)*(m+1));\n  for (k=0; k < m; k++)\n    pat[k] = inp_pat[k];\n  txt[k] = '\\0';\n\n  // Return vector\n  int *ret = (int *)libmin_malloc(sizeof(int)*n);\n  for (int i=0; i<n; i++)\n    ret[i] = FALSE; \n\n  // Run search\n  search(txt, n, pat, m, ret);\n\n  // print results\n  for(int i=0; i<n; i++)\n  {\n    if (ret[i]) \n    { \n      libmin_printf(\"pattern occurs at shift = %d\\n\", i);\n    }\n  }\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "rabinkarp-search/rabinkarp-search.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r15d\n  int v4; // ebp\n  int v5; // ebx\n  char *v6; // r13\n  __int64 v7; // rax\n  __int64 v8; // rdx\n  __int64 v9; // rax\n  char *v10; // r14\n  __int64 v11; // rax\n  __int64 v12; // rdx\n  int *v13; // rax\n  int *v14; // r12\n  __int64 v15; // r15\n  __int64 v16; // rbx\n  __int64 v17; // rax\n  int v18; // [rsp+Ch] [rbp-3Ch]\n\n  v3 = libmin_strlen(inp_txt);\n  v4 = v3;\n  v18 = libmin_strlen(inp_pat);\n  v5 = v18;\n  libmin_printf(\"n = %d, m = %d\\n\", v3, v18);\n  v6 = (char *)libmin_malloc(v3 + 1);\n  if ( v3 <= 0 )\n  {\n    v9 = 0LL;\n  }\n  else\n  {\n    v7 = 0LL;\n    do\n    {\n      v6[v7] = inp_txt[v7];\n      v8 = v7++;\n    }\n    while ( v8 != v3 - 1 );\n    v9 = v3;\n  }\n  v6[v9] = 0;\n  v10 = (char *)libmin_malloc(v18 + 1);\n  if ( v18 <= 0 )\n  {\n    v5 = 0;\n  }\n  else\n  {\n    v11 = 0LL;\n    do\n    {\n      v10[v11] = inp_pat[v11];\n      v12 = v11++;\n    }\n    while ( v12 != v18 - 1 );\n  }\n  v6[v5] = 0;\n  v13 = (int *)libmin_malloc(4LL * v3);\n  v14 = v13;\n  if ( v3 > 0 )\n  {\n    v15 = (unsigned int)(v3 - 1);\n    v16 = 0LL;\n    memset(v13, 0, 4 * v15 + 4);\n    search(v6, v4, v10, v18, v14);\n    while ( 1 )\n    {\n      if ( v14[v16] )\n      {\n        libmin_printf(\"pattern occurs at shift = %d\\n\", v16);\n        v17 = v16 + 1;\n        if ( v15 == v16 )\n          goto LABEL_14;\n      }\n      else\n      {\n        v17 = v16 + 1;\n        if ( v15 == v16 )\n          goto LABEL_14;\n      }\n      v16 = v17;\n    }\n  }\n  search(v6, v3, v10, v18, v13);\nLABEL_14:\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  char *v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  char *v10;\n  long long v11;\n  long long v12;\n  int *v13;\n  int *v14;\n  long long v15;\n  long long v16;\n  long long v17;\n  int v18;\n  v3 = libmin_strlen(inp_txt);\n  v4 = v3;\n  v18 = libmin_strlen(inp_pat);\n  v5 = v18;\n  libmin_printf(\"n = %d, m = %d\\n\", v3, v18);\n  v6 = (char *)libmin_malloc(v3 + 1);\n  if (v3 <= 0) {\n    v9 = 0LL;\n  } else {\n    v7 = 0LL;\n    do {\n      v6[v7] = inp_txt[v7];\n      v8 = v7++;\n    } while (v8 != v3 - 1);\n    v9 = v3;\n  }\n  v6[v9] = 0;\n  v10 = (char *)libmin_malloc(v18 + 1);\n  if (v18 <= 0) {\n    v5 = 0;\n  } else {\n    v11 = 0LL;\n    do {\n      v10[v11] = inp_pat[v11];\n      v12 = v11++;\n    } while (v12 != v18 - 1);\n  }\n  v6[v5] = 0;\n  v13 = (int *)libmin_malloc(4LL * v3);\n  v14 = v13;\n  if (v3 > 0) {\n    v15 = (unsigned int)(v3 - 1);\n    v16 = 0LL;\n    memset(v13, 0, 4 * v15 + 4);\n    search(v6, v4, v10, v18, v14);\n    while (1) {\n      if (v14[v16]) {\n        libmin_printf(\"pattern occurs at shift = %d\\n\", v16);\n        v17 = v16 + 1;\n        if (v15 == v16) goto LABEL_14;\n      } else {\n        v17 = v16 + 1;\n        if (v15 == v16) goto LABEL_14;\n      }\n      v16 = v17;\n    }\n  }\n  search(v6, v3, v10, v18, v13);\nLABEL_14:\n  libmin_success();\n}", "binary": "rabinkarp-search/rabinkarp-search.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\nlea    0x3ef1(%rip),%r14\npush   %r13\nmov    %r14,%rdi\npush   %r12\nlea    0x44e3(%rip),%r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   2f40 <libmin_strlen>\nmov    %r12,%rdi\nmov    %rax,%r15\nmov    %eax,%ebp\ncall   2f40 <libmin_strlen>\nmov    %r15d,%esi\nlea    0x1ea5(%rip),%rdi\nmov    %eax,%edx\nmov    %eax,0xc(%rsp)\nmov    %rax,%rbx\nxor    %eax,%eax\ncall   2d30 <libmin_printf>\nlea    0x1(%r15),%edi\nmovslq %edi,%rdi\ncall   1790 <libmin_malloc>\nmov    %rax,%r13\ntest   %r15d,%r15d\njle    127f <main+0x15f>\nlea    -0x1(%r15),%esi\nxor    %eax,%eax\nnopl   (%rax)\nmovzbl (%r14,%rax,1),%edx\nmov    %dl,0x0(%r13,%rax,1)\nmov    %rax,%rdx\nadd    $0x1,%rax\ncmp    %rsi,%rdx\njne    1190 <main+0x70>\nmovslq %r15d,%rax\nmovb   $0x0,0x0(%r13,%rax,1)\nlea    0x1(%rbx),%edi\nmovslq %edi,%rdi\ncall   1790 <libmin_malloc>\nmov    %rax,%r14\ntest   %ebx,%ebx\njle    1286 <main+0x166>\nlea    -0x1(%rbx),%esi\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmovzbl (%r12,%rax,1),%edx\nmov    %dl,(%r14,%rax,1)\nmov    %rax,%rdx\nadd    $0x1,%rax\ncmp    %rsi,%rdx\njne    11d0 <main+0xb0>\nmovslq %ebx,%rbx\nmovslq %r15d,%rdi\nmovb   $0x0,0x0(%r13,%rbx,1)\nshl    $0x2,%rdi\ncall   1790 <libmin_malloc>\nmov    %rax,%r12\ntest   %r15d,%r15d\njle    128d <main+0x16d>\nsub    $0x1,%r15d\nxor    %esi,%esi\nmov    %rax,%rdi\nxor    %ebx,%ebx\nlea    0x4(,%r15,4),%rdx\ncall   10d0 <memset@plt>\nmov    0xc(%rsp),%ecx\nmov    %ebp,%esi\nmov    %r12,%r8\nmov    %r14,%rdx\nmov    %r13,%rdi\nlea    0x1de0(%rip),%rbp\ncall   13a0 <search>\njmp    124c <main+0x12c>\nnopl   0x0(%rax,%rax,1)\nlea    0x1(%rbx),%rax\ncmp    %rbx,%r15\nje     1269 <main+0x149>\nmov    %rax,%rbx\nmov    (%r12,%rbx,4),%eax\nmov    %ebx,%esi\ntest   %eax,%eax\nje     1240 <main+0x120>\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   2d30 <libmin_printf>\nlea    0x1(%rbx),%rax\ncmp    %rbx,%r15\njne    1249 <main+0x129>\ncall   2f70 <libmin_success>\nadd    $0x18,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nxor    %eax,%eax\njmp    11a9 <main+0x89>\nxor    %ebx,%ebx\njmp    11e5 <main+0xc5>\nmov    0xc(%rsp),%ecx\nmov    %rax,%r8\nmov    %r14,%rdx\nmov    %ebp,%esi\nmov    %r13,%rdi\ncall   13a0 <search>\njmp    1269 <main+0x149>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "rabinkarp-search/rabinkarp-search.c", "function_name": "search", "content": "// D is the number of characters in the input alphabet \n#define D 256 \n\n/* simple string search algorithm */\nvoid\nsearch(char *txt, int n, char *pat, int m, int *ret)\n{\n  int q = INT_MAX; \n\n  // value of h would be \"pow(d, M-1)%q\" \n  int h = 1;\n  for (int i = 0; i < m - 1; i++) \n    h = (h * D) % q; \n\n  int32_t p = 0; // hash value for pattern \n  int32_t t = 0; // hash value for txt \n\n  // calculate the hash value of pattern and first window of text \n  for (int i = 0; i < m; i++) \n  { \n    p = (D * p + pat[i]) % q; \n    t = (D * t + txt[i]) % q; \n  } \n\n  // slide the pattern over text one by one \n  for (int i = 0; i <= n - m; i++) \n    { \n  \n    // check the hash values of current window of text \n    // and pattern. If the hash values match then only \n    // check for characters one by one \n    ret[i] = (p == t);\n  \n    // calculate hash value for next window of text: Remove leading digit, add trailing digit \n    if (i < n-m) \n    { \n      t = (D*(t - ((int32_t)txt[i])*h) + txt[i+m])%q; \n  \n      // we might get negative value of t, converting it to positive \n      if (t < 0) \n        t = (t + q); \n    } \n  } \n}\n"}, "pseudo": {"path": "rabinkarp-search/rabinkarp-search.host.O2.pseudo", "function_name": "search", "address": "0x13a0", "label": "search", "content": "void __fastcall search(char *txt, int n, char *pat, int m, int *ret)\n{\n  int v6; // edi\n  int v10; // ecx\n  int v11; // esi\n  __int64 v12; // rdi\n  int v13; // eax\n  int v14; // ecx\n  int v15; // edx\n  int v16; // eax\n  int v17; // r10d\n  __int64 i; // rdx\n  int v19; // edi\n  bool v20; // sf\n  int v21; // edi\n\n  v6 = m - 1;\n  if ( m - 1 > 0 )\n  {\n    v10 = 0;\n    v11 = 1;\n    do\n    {\n      ++v10;\n      v11 = (v11 << 8) % 0x7FFFFFFF;\n    }\n    while ( v10 != v6 );\n    if ( m > 0 )\n      goto LABEL_5;\nLABEL_16:\n    v13 = 0;\n    v14 = 0;\n    goto LABEL_7;\n  }\n  v11 = 1;\n  if ( m <= 0 )\n    goto LABEL_16;\nLABEL_5:\n  v12 = 0LL;\n  v13 = 0;\n  v14 = 0;\n  do\n  {\n    v14 = (pat[v12] + (v14 << 8)) % 0x7FFFFFFF;\n    v15 = v13 << 8;\n    v16 = txt[v12++];\n    v13 = (v16 + v15) % 0x7FFFFFFF;\n  }\n  while ( m != v12 );\nLABEL_7:\n  v17 = n - m;\n  if ( v17 >= 0 )\n  {\n    for ( i = 0LL; ; ++i )\n    {\n      ret[i] = v14 == v13;\n      if ( v17 > (int)i )\n      {\n        v19 = txt[m + (int)i] + ((v13 - v11 * txt[i]) << 8);\n        v20 = v19 % 0x7FFFFFFF < 0;\n        v13 = v19 % 0x7FFFFFFF;\n        v21 = v19 % 0x7FFFFFFF + 0x7FFFFFFF;\n        if ( v20 )\n          v13 = v21;\n      }\n      if ( v17 == i )\n        break;\n    }\n  }\n}\n"}, "pseudo_normalize": "void search(char *txt, int n, char *pat, int m, int *ret) {\n  int v6;\n  int v10;\n  int v11;\n  long long v12;\n  int v13;\n  int v14;\n  int v15;\n  int v16;\n  int v17;\n  long long i;\n  int v19;\n  bool v20;\n  int v21;\n  v6 = m - 1;\n  if (m - 1 > 0) {\n    v10 = 0;\n    v11 = 1;\n    do {\n      ++v10;\n      v11 = (v11 << 8) % 2147483647;\n    } while (v10 != v6);\n    if (m > 0) goto LABEL_5;\n  LABEL_16:\n    v13 = 0;\n    v14 = 0;\n    goto LABEL_7;\n  }\n  v11 = 1;\n  if (m <= 0) goto LABEL_16;\nLABEL_5:\n  v12 = 0LL;\n  v13 = 0;\n  v14 = 0;\n  do {\n    v14 = (pat[v12] + (v14 << 8)) % 2147483647;\n    v15 = v13 << 8;\n    v16 = txt[v12++];\n    v13 = (v16 + v15) % 2147483647;\n  } while (m != v12);\nLABEL_7:\n  v17 = n - m;\n  if (v17 >= 0) {\n    for (i = 0LL;; ++i) {\n      ret[i] = v14 == v13;\n      if (v17 > (int)i) {\n        v19 = txt[m + (int)i] + ((v13 - v11 * txt[i]) << 8);\n        v20 = v19 % 2147483647 < 0;\n        v13 = v19 % 2147483647;\n        v21 = v19 % 2147483647 + 2147483647;\n        if (v20) v13 = v21;\n      }\n      if (v17 == i) break;\n    }\n  }\n}", "binary": "rabinkarp-search/rabinkarp-search.host.O2", "assembly": "<search>:\nendbr64\nmov    %rdi,%r9\nlea    -0x1(%rcx),%edi\npush   %r12\nmov    %esi,%r10d\npush   %rbp\nmov    %ecx,%r11d\npush   %rbx\nmov    %rdx,%rbx\ntest   %edi,%edi\njle    1500 <search+0x160>\nxor    %ecx,%ecx\nmov    $0x1,%esi\ncs nopw 0x0(%rax,%rax,1)\nshl    $0x8,%esi\nadd    $0x1,%ecx\nmovslq %esi,%rax\nmov    %rax,%rsi\nmov    %rax,%rdx\nshl    $0x1e,%rsi\nadd    %rax,%rsi\nsar    $0x1f,%eax\nsar    $0x3d,%rsi\nsub    %eax,%esi\nmov    %esi,%eax\nshl    $0x1f,%eax\nsub    %esi,%eax\nmov    %edx,%esi\nsub    %eax,%esi\ncmp    %edi,%ecx\njne    13d0 <search+0x30>\ntest   %r11d,%r11d\njle    1510 <search+0x170>\nmovslq %r11d,%rbp\nxor    %edi,%edi\nxor    %eax,%eax\nxor    %ecx,%ecx\nshl    $0x8,%ecx\nshl    $0x8,%eax\nmov    %ecx,%edx\nmovsbl (%rbx,%rdi,1),%ecx\nadd    %ecx,%edx\nmovslq %edx,%r12\nmov    %r12,%rcx\nshl    $0x1e,%rcx\nadd    %r12,%rcx\nmov    %edx,%r12d\nsar    $0x1f,%r12d\nsar    $0x3d,%rcx\nsub    %r12d,%ecx\nmov    %ecx,%r12d\nshl    $0x1f,%r12d\nsub    %ecx,%r12d\nsub    %r12d,%edx\nmov    %edx,%ecx\nmov    %eax,%edx\nmovsbl (%r9,%rdi,1),%eax\nadd    $0x1,%rdi\nadd    %eax,%edx\nmovslq %edx,%r12\nmov    %r12,%rax\nshl    $0x1e,%rax\nadd    %r12,%rax\nmov    %edx,%r12d\nsar    $0x1f,%r12d\nsar    $0x3d,%rax\nsub    %r12d,%eax\nmov    %eax,%r12d\nshl    $0x1f,%r12d\nsub    %eax,%r12d\nmov    %edx,%eax\nsub    %r12d,%eax\ncmp    %rdi,%rbp\njne    1410 <search+0x70>\nsub    %r11d,%r10d\njs     14f5 <search+0x155>\nmovslq %r10d,%rbp\nxor    %edx,%edx\njmp    1493 <search+0xf3>\nmov    %rdi,%rdx\nxor    %edi,%edi\ncmp    %eax,%ecx\nsete   %dil\nmov    %edi,(%r8,%rdx,4)\ncmp    %edx,%r10d\njle    14ec <search+0x14c>\nmovsbl (%r9,%rdx,1),%ebx\nimul   %esi,%ebx\nsub    %ebx,%eax\nmov    %eax,%edi\nlea    (%r11,%rdx,1),%eax\ncltq\nshl    $0x8,%edi\nmovsbl (%r9,%rax,1),%eax\nadd    %eax,%edi\nmovslq %edi,%rbx\nmov    %rbx,%rax\nshl    $0x1e,%rax\nadd    %rbx,%rax\nmov    %edi,%ebx\nsar    $0x1f,%ebx\nsar    $0x3d,%rax\nsub    %ebx,%eax\nmov    %eax,%ebx\nshl    $0x1f,%ebx\nsub    %eax,%ebx\nmov    %edi,%eax\nsub    %ebx,%eax\nlea    0x7fffffff(%rax),%edi\ncmovs  %edi,%eax\nlea    0x1(%rdx),%rdi\ncmp    %rdx,%rbp\njne    1490 <search+0xf0>\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%esi\ntest   %r11d,%r11d\njg     1407 <search+0x67>\nxchg   %ax,%ax\nxor    %eax,%eax\nxor    %ecx,%ecx\njmp    1484 <search+0xe4>\nnopl   0x0(%rax)\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "bad_rand", "content": "// A deliberately weak (\"bad\") random number generator using a simple LCG.\nuint32_t bad_rand(void) {\n    static uint32_t state = 123456789;  // Fixed seed for reproducibility.\n    state = state * 110351524 + 12345;\n    return state;\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O2.pseudo", "function_name": "bad_rand", "address": "0x1240", "label": "bad_rand", "content": "uint32_t __cdecl bad_rand()\n{\n  uint32_t result; // eax\n\n  result = 110351524 * state_0 + 12345;\n  state_0 = result;\n  return result;\n}\n"}, "pseudo_normalize": "uint32_t bad_rand() {\n  uint32_t result;\n  result = 110351524 * state_0 + 12345;\n  state_0 = result;\n  return result;\n}", "binary": "rand-test/rand-test.host.O2", "assembly": "<bad_rand>:\nendbr64\nimul   $0x693d4a4,0x4dc2(%rip),%eax\nadd    $0x3039,%eax\nmov    %eax,0x4db7(%rip)\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "good_rand", "content": "// A wrapper for the system's rand() function.\n// Since rand() may not return a full 32-bit value, we combine two calls.\nuint32_t good_rand(void) {\n    // Obtain two random numbers.\n    uint32_t r1 = (uint32_t) libmin_rand();\n    uint32_t r2 = (uint32_t) libmin_rand();\n    // Combine them. This assumes rand() returns at most 15 bits.\n    return (r1 << 15) | (r2 & 0x7FFF);\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O2.pseudo", "function_name": "good_rand", "address": "0x1260", "label": "good_rand", "content": "uint32_t __cdecl good_rand()\n{\n  unsigned int v0; // ebx\n\n  v0 = libmin_rand();\n  return (v0 << 15) | libmin_rand() & 0x7FFF;\n}\n"}, "pseudo_normalize": "", "binary": "rand-test/rand-test.host.O2", "assembly": "<good_rand>:\nendbr64\npush   %rbx\ncall   2d30 <libmin_rand>\nmov    %eax,%ebx\ncall   2d30 <libmin_rand>\nshl    $0xf,%ebx\nand    $0x7fff,%eax\nor     %ebx,%eax\npop    %rbx\nret\nnopl   (%rax)\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "main", "content": "int main(void) {\n    // Seed the system's RNG for good_rand().\n    libmin_srand(42);\n\n    // First test: Use the deliberately weak generator (bad_rand).\n    run_tests(\"Bad (bad_rand())\", bad_rand);\n\n    // Second test: Use the system's standard rand() via good_rand.\n    run_tests(\"Good (good_rand())\", good_rand);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_srand(0x2Au);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_srand(42u);\n  run_tests(\"Bad (bad_rand())\", bad_rand);\n  run_tests(\"Good (good_rand())\", good_rand);\n  libmin_success();\n}", "binary": "rand-test/rand-test.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x2a,%edi\ncall   2cd0 <libmin_srand>\nlea    0x127(%rip),%rsi\nlea    0x306d(%rip),%rdi\ncall   1280 <run_tests>\nlea    0x134(%rip),%rsi\nlea    0x306b(%rip),%rdi\ncall   1280 <run_tests>\ncall   3120 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "rand-test/rand-test.c", "function_name": "run_tests", "content": "// Test harness to run the battery of randomness tests on the provided RNG.\nvoid run_tests(const char *gen_name, rng_func_t rng_func) {\n    libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n\n    uint64_t ones_count = 0;\n    uint64_t total_bits = 0;\n    uint32_t bins[BIN_COUNT] = {0};\n\n    // Variables for the serial correlation test.\n    double serial_x_sum = 0.0, serial_y_sum = 0.0;\n    double serial_xy_sum = 0.0, serial_x2_sum = 0.0, serial_y2_sum = 0.0;\n    int serial_count = 0;\n    uint32_t prev = 0;\n    int first = 1;\n\n    // Loop to generate SAMPLE_SIZE random numbers.\n    for (size_t i = 0; i < SAMPLE_SIZE; i++) {\n        uint32_t sample = rng_func();\n\n        // Monobit Test: Count the number of 1 bits.\n        ones_count += count_bits(sample);\n        total_bits += 32;\n\n        // Chi-Square Test: Use the top 8 bits for binning.\n        uint32_t bin = sample >> 24;\n        bins[bin]++;\n\n        // Serial Correlation Test: Compare adjacent samples.\n        if (!first) {\n            serial_x_sum   += (double)prev;\n            serial_y_sum   += (double)sample;\n            serial_xy_sum  += (double)prev * sample;\n            serial_x2_sum  += (double)prev * prev;\n            serial_y2_sum  += (double)sample * sample;\n            serial_count++;\n        } else {\n            first = 0;\n        }\n        prev = sample;\n    }\n\n    // Report Monobit Test Results.\n    double ones_ratio = (double)ones_count / total_bits;\n    libmin_printf(\"Monobit Test:\\n\");\n    libmin_printf(\"  Total bits processed: %llu\\n\", total_bits);\n    libmin_printf(\"  Total ones count: %llu\\n\", ones_count);\n    libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", ones_ratio);\n\n    // Report Chi-Square Test results on top 8 bits.\n    double expected_count = (double)SAMPLE_SIZE / BIN_COUNT;\n    double chi_square = 0.0;\n    for (int i = 0; i < BIN_COUNT; i++) {\n        double diff = bins[i] - expected_count;\n        chi_square += (diff * diff) / expected_count;\n    }\n    libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\");\n    libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", chi_square, BIN_COUNT - 1);\n\n    // Report Serial Correlation Test results.\n    double mean_x = serial_x_sum / serial_count;\n    double mean_y = serial_y_sum / serial_count;\n    double covariance = (serial_xy_sum / serial_count) - (mean_x * mean_y);\n    double var_x = (serial_x2_sum / serial_count) - (mean_x * mean_x);\n    double var_y = (serial_y2_sum / serial_count) - (mean_y * mean_y);\n    double serial_corr = covariance / (libmin_sqrt(var_x * var_y));\n    libmin_printf(\"\\nSerial Correlation Test:\\n\");\n    libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\", serial_corr);\n\n    libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}\n"}, "pseudo": {"path": "rand-test/rand-test.host.O2.pseudo", "function_name": "run_tests", "address": "0x1280", "label": "run_tests", "content": "void __fastcall run_tests(const char *gen_name, rng_func_t rng_func)\n{\n  __int64 v2; // r12\n  int v3; // ebp\n  __int64 v4; // r13\n  __int64 v5; // rbx\n  double v6; // xmm1_8\n  double v7; // xmm0_8\n  uint32_t *v8; // rbx\n  double v9; // xmm1_8\n  int v10; // eax\n  double serial_corr; // [rsp+0h] [rbp-478h]\n  double serial_corra; // [rsp+0h] [rbp-478h]\n  double serial_y_sum; // [rsp+8h] [rbp-470h]\n  double serial_xy_sum; // [rsp+10h] [rbp-468h]\n  double serial_x2_sum; // [rsp+18h] [rbp-460h]\n  double serial_y2_sum; // [rsp+20h] [rbp-458h]\n  uint32_t bins[256]; // [rsp+30h] [rbp-448h] BYREF\n  _BYTE v18[8]; // [rsp+430h] [rbp-48h] BYREF\n  unsigned __int64 v19; // [rsp+438h] [rbp-40h]\n\n  v2 = 10000LL;\n  v19 = __readfsqword(0x28u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  memset(bins, 0, sizeof(bins));\n  v3 = rng_func();\n  serial_corr = 0.0;\n  serial_y2_sum = 0.0;\n  v4 = (int)((__int64 (*)(void))_popcountdi2)();\n  serial_x2_sum = 0.0;\n  bins[HIBYTE(v3)] = 1;\n  serial_xy_sum = 0.0;\n  serial_y_sum = 0.0;\n  while ( --v2 )\n  {\n    v5 = rng_func();\n    v6 = (double)v3;\n    v3 = v5;\n    v4 += (int)_popcountdi2(v5);\n    ++bins[BYTE3(v5)];\n    serial_corr = serial_corr + v6;\n    serial_y_sum = serial_y_sum + (double)(int)v5;\n    serial_xy_sum = v6 * (double)(int)v5 + serial_xy_sum;\n    serial_x2_sum = v6 * v6 + serial_x2_sum;\n    serial_y2_sum = (double)(int)v5 * (double)(int)v5 + serial_y2_sum;\n  }\n  libmin_printf(\"Monobit Test:\\n\");\n  libmin_printf(\"  Total bits processed: %llu\\n\", 320000LL);\n  libmin_printf(\"  Total ones count: %llu\\n\", v4);\n  if ( v4 < 0 )\n    v7 = (double)(int)(v4 & 1 | ((unsigned __int64)v4 >> 1)) + (double)(int)(v4 & 1 | ((unsigned __int64)v4 >> 1));\n  else\n    v7 = (double)(int)v4;\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v7 / 320000.0);\n  v8 = bins;\n  v9 = 0.0;\n  do\n  {\n    v10 = *v8++;\n    v9 = v9 + ((double)v10 - 39.0625) * ((double)v10 - 39.0625) / 39.0625;\n  }\n  while ( v18 != (_BYTE *)v8 );\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\", v4, v18);\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", v9, 255);\n  serial_corra = (serial_xy_sum / 9999.0 - serial_corr / 9999.0 * (serial_y_sum / 9999.0))\n               / libmin_sqrt(serial_y_sum / 9999.0 * (serial_y_sum / 9999.0));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\", serial_corra);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}\n"}, "pseudo_normalize": "void run_tests(const char *gen_name, rng_func_t rng_func) {\n  long long v2;\n  int v3;\n  long long v4;\n  long long v5;\n  double v6;\n  double v7;\n  uint32_t *v8;\n  double v9;\n  int v10;\n  double serial_corr;\n  double serial_corra;\n  double serial_y_sum;\n  double serial_xy_sum;\n  double serial_x2_sum;\n  double serial_y2_sum;\n  uint32_t bins[256];\n  uint8_t v18[8];\n  unsigned long long v19;\n  v2 = 10000LL;\n  v19 = __readfsqword(40u);\n  libmin_printf(\"Running tests for %s random generator:\\n\", gen_name);\n  memset(bins, 0, sizeof(bins));\n  v3 = rng_func();\n  serial_corr = 0.0;\n  serial_y2_sum = 0.0;\n  v4 = (int)((long long (*)(void))_popcountdi2)();\n  serial_x2_sum = 0.0;\n  bins[HIBYTE(v3)] = 1;\n  serial_xy_sum = 0.0;\n  serial_y_sum = 0.0;\n  while (--v2) {\n    v5 = rng_func();\n    v6 = (double)v3;\n    v3 = v5;\n    v4 += (int)_popcountdi2(v5);\n    ++bins[BYTE3(v5)];\n    serial_corr = serial_corr + v6;\n    serial_y_sum = serial_y_sum + (double)(int)v5;\n    serial_xy_sum = v6 * (double)(int)v5 + serial_xy_sum;\n    serial_x2_sum = v6 * v6 + serial_x2_sum;\n    serial_y2_sum = (double)(int)v5 * (double)(int)v5 + serial_y2_sum;\n  }\n  libmin_printf(\"Monobit Test:\\n\");\n  libmin_printf(\"  Total bits processed: %llu\\n\", 320000LL);\n  libmin_printf(\"  Total ones count: %llu\\n\", v4);\n  if (v4 < 0)\n    v7 = (double)(int)(v4 & 1 | ((unsigned long long)v4 >> 1)) +\n         (double)(int)(v4 & 1 | ((unsigned long long)v4 >> 1));\n  else\n    v7 = (double)(int)v4;\n  libmin_printf(\"  Ones ratio: %f (expected ~0.5)\\n\", v7 / 320000.0);\n  v8 = bins;\n  v9 = 0.0;\n  do {\n    v10 = *v8++;\n    v9 = v9 + ((double)v10 - 39.0625) * ((double)v10 - 39.0625) / 39.0625;\n  } while (v18 != (uint8_t *)v8);\n  libmin_printf(\"\\nChi-Square Test (uniformity of top 8 bits):\\n\", v4, v18);\n  libmin_printf(\"  Chi-square statistic: %f (degrees of freedom = %d)\\n\", v9,\n                255);\n  serial_corra = (serial_xy_sum / 9999.0 -\n                  serial_corr / 9999.0 * (serial_y_sum / 9999.0)) /\n                 libmin_sqrt(serial_y_sum / 9999.0 * (serial_y_sum / 9999.0));\n  libmin_printf(\"\\nSerial Correlation Test:\\n\");\n  libmin_printf(\"  Serial correlation coefficient: %f (expected near 0)\\n\",\n                serial_corra);\n  libmin_printf(\"\\n-----------------------------------------------\\n\\n\");\n}", "binary": "rand-test/rand-test.host.O2", "assembly": "<run_tests>:\nendbr64\npush   %r15\npush   %r14\nmov    %rsi,%r14\nmov    %rdi,%rsi\nlea    0x2d73(%rip),%rdi\npush   %r13\npush   %r12\nmov    $0x2710,%r12d\npush   %rbp\npush   %rbx\nsub    $0x448,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x438(%rsp)\nxor    %eax,%eax\ncall   2ac0 <libmin_printf>\nlea    0x30(%rsp),%rdi\nxor    %eax,%eax\nmov    $0x80,%ecx\nmov    %rdi,0x28(%rsp)\nrep stos %rax,%es:(%rdi)\ncall   *%r14\nmov    %eax,%edi\nmov    %rdi,%rbp\ncall   3180 <__popcountdi2>\nmovq   $0x0,(%rsp)\nmovq   $0x0,0x20(%rsp)\nmovslq %eax,%r13\nmov    %ebp,%eax\nmovq   $0x0,0x18(%rsp)\nshr    $0x18,%eax\nmovl   $0x1,0x30(%rsp,%rax,4)\nmovq   $0x0,0x10(%rsp)\nmovq   $0x0,0x8(%rsp)\njmp    13aa <run_tests+0x12a>\nnopw   0x0(%rax,%rax,1)\ncall   *%r14\nmov    %eax,%ebx\nmov    %rbx,%rdi\ncall   3180 <__popcountdi2>\npxor   %xmm1,%xmm1\npxor   %xmm0,%xmm0\nmovsd  (%rsp),%xmm5\ncvtsi2sd %rbp,%xmm1\nmovsd  0x8(%rsp),%xmm6\ncltq\nmov    %ebx,%ebp\ncvtsi2sd %rbx,%xmm0\nadd    %rax,%r13\nmov    %ebx,%eax\nshr    $0x18,%eax\naddl   $0x1,0x30(%rsp,%rax,4)\nmovapd %xmm1,%xmm2\naddsd  %xmm1,%xmm5\nmulsd  %xmm0,%xmm2\naddsd  %xmm0,%xmm6\nmulsd  %xmm1,%xmm1\naddsd  0x10(%rsp),%xmm2\nmulsd  %xmm0,%xmm0\naddsd  0x18(%rsp),%xmm1\nmovsd  %xmm5,(%rsp)\naddsd  0x20(%rsp),%xmm0\nmovsd  %xmm6,0x8(%rsp)\nmovsd  %xmm2,0x10(%rsp)\nmovsd  %xmm1,0x18(%rsp)\nmovsd  %xmm0,0x20(%rsp)\nsub    $0x1,%r12\njne    1328 <run_tests+0xa8>\nlea    0x2d70(%rip),%rdi\nxor    %eax,%eax\ncall   2ac0 <libmin_printf>\nmov    $0x4e200,%esi\nlea    0x2d6c(%rip),%rdi\nxor    %eax,%eax\ncall   2ac0 <libmin_printf>\nxor    %eax,%eax\nmov    %r13,%rsi\nlea    0x2d77(%rip),%rdi\ncall   2ac0 <libmin_printf>\ntest   %r13,%r13\njs     1553 <run_tests+0x2d3>\npxor   %xmm0,%xmm0\ncvtsi2sd %r13,%xmm0\nlea    0x2c31(%rip),%rdi\nmov    $0x1,%eax\ndivsd  0x2dac(%rip),%xmm0\ncall   2ac0 <libmin_printf>\nmov    0x28(%rsp),%rbx\npxor   %xmm1,%xmm1\nmovsd  0x2d9e(%rip),%xmm2\nlea    0x430(%rsp),%rdx\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%eax\npxor   %xmm0,%xmm0\nadd    $0x4,%rbx\ncvtsi2sd %rax,%xmm0\nsubsd  %xmm2,%xmm0\nmulsd  %xmm0,%xmm0\ndivsd  %xmm2,%xmm0\naddsd  %xmm0,%xmm1\ncmp    %rbx,%rdx\njne    1430 <run_tests+0x1b0>\nlea    0x2bfd(%rip),%rdi\nxor    %eax,%eax\nmovsd  %xmm1,0x28(%rsp)\ncall   2ac0 <libmin_printf>\nmovsd  0x28(%rsp),%xmm1\nmov    $0xff,%esi\nlea    0x2c0e(%rip),%rdi\nmov    $0x1,%eax\nmovapd %xmm1,%xmm0\ncall   2ac0 <libmin_printf>\nmovsd  (%rsp),%xmm2\nmovsd  0x2d33(%rip),%xmm3\nmovsd  0x8(%rsp),%xmm1\nmovsd  0x10(%rsp),%xmm0\ndivsd  %xmm3,%xmm2\ndivsd  %xmm3,%xmm1\nmovapd %xmm2,%xmm4\nmulsd  %xmm2,%xmm2\ndivsd  %xmm3,%xmm0\nmulsd  %xmm1,%xmm4\nmulsd  %xmm1,%xmm1\nsubsd  %xmm4,%xmm0\nmovq   %xmm0,%rbx\nmovsd  0x18(%rsp),%xmm0\ndivsd  %xmm3,%xmm0\nsubsd  %xmm2,%xmm0\nmovsd  0x20(%rsp),%xmm2\ndivsd  %xmm3,%xmm2\nsubsd  %xmm1,%xmm2\nmulsd  %xmm2,%xmm0\ncall   2ee0 <libmin_sqrt>\nmovq   %rbx,%xmm1\nlea    0x2c7b(%rip),%rdi\nxor    %eax,%eax\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,(%rsp)\ncall   2ac0 <libmin_printf>\nmovsd  (%rsp),%xmm1\nmov    $0x1,%eax\nlea    0x2ba8(%rip),%rdi\nmovapd %xmm1,%xmm0\ncall   2ac0 <libmin_printf>\nmov    0x438(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1572 <run_tests+0x2f2>\nadd    $0x448,%rsp\nlea    0x2bb6(%rip),%rdi\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\njmp    2ac0 <libmin_printf>\nmov    %r13,%rax\nand    $0x1,%r13d\npxor   %xmm0,%xmm0\nshr    %rax\nor     %r13,%rax\ncvtsi2sd %rax,%xmm0\naddsd  %xmm0,%xmm0\njmp    13f8 <run_tests+0x178>\ncall   10b0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "ransac/ransac.c", "function_name": "line_distance", "content": "// Compute the perpendicular distance from a point to the line: y = m*x + b.\ndouble line_distance(Point p, double m, double b) {\n    return libmin_fabs(m * p.x - p.y + b) / libmin_sqrt(m * m + 1.0);\n}\n"}, "pseudo": {"path": "ransac/ransac.host.O2.pseudo", "function_name": "line_distance", "address": "0x13b0", "label": "line_distance", "content": "double __fastcall line_distance(double a1, Point p, double m, double b)\n{\n  double v5; // [rsp+0h] [rbp-18h]\n\n  v5 = libmin_fabs(p.x);\n  return v5 / libmin_sqrt(p.x);\n}\n"}, "pseudo_normalize": "", "binary": "ransac/ransac.host.O2", "assembly": "<line_distance>:\nendbr64\nmulsd  %xmm2,%xmm0\nsub    $0x18,%rsp\nmovsd  %xmm2,0x8(%rsp)\nsubsd  %xmm1,%xmm0\naddsd  %xmm3,%xmm0\ncall   17b0 <libmin_fabs>\nmovsd  0x8(%rsp),%xmm2\nmovsd  %xmm0,(%rsp)\nmulsd  %xmm2,%xmm2\naddsd  0x2c6a(%rip),%xmm2\nmovapd %xmm2,%xmm0\ncall   2f70 <libmin_sqrt>\nmovsd  (%rsp),%xmm1\nadd    $0x18,%rsp\ndivsd  %xmm0,%xmm1\nmovapd %xmm1,%xmm0\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "ransac/ransac.c", "function_name": "main", "content": "int main(void) {\n    libmin_srand(42);\n    Point points[NUM_POINTS];\n\n    // Generate inlier points along the line: y = 2*x + 1\n    int inlierCount = NUM_POINTS / 2;\n    for (int i = 0; i < inlierCount; i++) {\n        // Spread x values over a range.\n        double x = ((double) i / inlierCount) * 50.0;\n        // Add a small random noise in the y value.\n        double noise = ((double) libmin_rand() / RAND_MAX - 0.5) * 2.0;  // Noise in range [-1, 1]\n        points[i].x = x;\n        points[i].y = 2 * x + 1 + noise;\n    }\n\n    // Generate outlier points randomly.\n    for (int i = inlierCount; i < NUM_POINTS; i++) {\n        points[i].x = ((double) libmin_rand() / RAND_MAX) * 50.0;\n        points[i].y = ((double) libmin_rand() / RAND_MAX) * 100.0;\n    }\n\n    double best_m = 0, best_b = 0;\n    int best_inlier_count = 0;\n\n    // Run RANSAC to estimate the line parameters.\n    ransac_line_fitting(points, NUM_POINTS, &best_m, &best_b, &best_inlier_count);\n\n    // Display the results.\n    libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n    libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, NUM_POINTS);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "ransac/ransac.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // ebx\n  Point *v4; // r12\n  double v5; // xmm0_8\n  signed int v6; // eax\n  Point *v7; // r12\n  int best_inlier_count; // [rsp+1Ch] [rbp-67Ch] BYREF\n  double best_m; // [rsp+20h] [rbp-678h] BYREF\n  double best_b; // [rsp+28h] [rbp-670h] BYREF\n  Point points[100]; // [rsp+30h] [rbp-668h] BYREF\n  _QWORD v12[5]; // [rsp+670h] [rbp-28h] BYREF\n\n  v3 = 0;\n  v12[1] = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  v4 = points;\n  do\n  {\n    ++v4;\n    v5 = (double)v3++ / 50.0;\n    v6 = libmin_rand();\n    v4[-1].x = v5 * 50.0;\n    v4[-1].y = (double)v6 / 2147483647.0 - 0.5 + (double)v6 / 2147483647.0 - 0.5 + v5 * 50.0 + v5 * 50.0 + 1.0;\n  }\n  while ( v3 != 50 );\n  v7 = &points[50];\n  do\n  {\n    ++v7;\n    v7[-1].x = (double)(int)libmin_rand() / 2147483647.0 * 50.0;\n    v7[-1].y = (double)(int)libmin_rand() / 2147483647.0 * 100.0;\n  }\n  while ( v7 != (Point *)v12 );\n  best_inlier_count = 0;\n  best_m = 0.0;\n  best_b = 0.0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  Point *v4;\n  double v5;\n  signed int v6;\n  Point *v7;\n  int best_inlier_count;\n  double best_m;\n  double best_b;\n  Point points[100];\n  uint64_t v12[5];\n  v3 = 0;\n  v12[1] = __readfsqword(40u);\n  libmin_srand(42u);\n  v4 = points;\n  do {\n    ++v4;\n    v5 = (double)v3++ / 50.0;\n    v6 = libmin_rand();\n    v4[-1].x = v5 * 50.0;\n    v4[-1].y = (double)v6 / 2147483647.0 - 0.5 + (double)v6 / 2147483647.0 -\n               0.5 + v5 * 50.0 + v5 * 50.0 + 1.0;\n  } while (v3 != 50);\n  v7 = &points[50];\n  do {\n    ++v7;\n    v7[-1].x = (double)(int)libmin_rand() / 2147483647.0 * 50.0;\n    v7[-1].y = (double)(int)libmin_rand() / 2147483647.0 * 100.0;\n  } while (v7 != (Point *)v12);\n  best_inlier_count = 0;\n  best_m = 0.0;\n  best_b = 0.0;\n  ransac_line_fitting(points, 100, &best_m, &best_b, &best_inlier_count);\n  libmin_printf(\"RANSAC estimated line: y = %f * x + %f\\n\", best_m, best_b);\n  libmin_printf(\"Number of inliers: %d / %d\\n\", best_inlier_count, 100);\n  libmin_success();\n}", "binary": "ransac/ransac.host.O2", "assembly": "<main>:\nendbr64\npush   %r12\nmov    $0x2a,%edi\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x680,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x678(%rsp)\nxor    %eax,%eax\nlea    0x30(%rsp),%rbp\ncall   2d60 <libmin_srand>\nmov    %rbp,%r12\ncs nopw 0x0(%rax,%rax,1)\npxor   %xmm0,%xmm0\nadd    $0x10,%r12\ncvtsi2sd %ebx,%xmm0\ndivsd  0x2f0c(%rip),%xmm0\nadd    $0x1,%ebx\nmulsd  0x2f01(%rip),%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncall   2dc0 <libmin_rand>\npxor   %xmm1,%xmm1\nmovsd  0x8(%rsp),%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm1\ndivsd  0x2ee5(%rip),%xmm1\nsubsd  0x2ee5(%rip),%xmm1\nmovsd  %xmm0,-0x10(%r12)\naddsd  %xmm0,%xmm0\naddsd  0x2eb2(%rip),%xmm0\naddsd  %xmm1,%xmm1\naddsd  %xmm0,%xmm1\nmovsd  %xmm1,-0x8(%r12)\ncmp    $0x32,%ebx\njne    1140 <main+0x40>\nlea    0x350(%rsp),%r12\nlea    0x640(%rbp),%rbx\nnopl   0x0(%rax)\ncall   2dc0 <libmin_rand>\npxor   %xmm0,%xmm0\nadd    $0x10,%r12\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2e84(%rip),%xmm0\nmulsd  0x2e74(%rip),%xmm0\nmovsd  %xmm0,-0x10(%r12)\ncall   2dc0 <libmin_rand>\npxor   %xmm0,%xmm0\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x2e5d(%rip),%xmm0\nmulsd  0x2e65(%rip),%xmm0\nmovsd  %xmm0,-0x8(%r12)\ncmp    %rbx,%r12\njne    11c8 <main+0xc8>\nlea    0x28(%rsp),%rcx\nlea    0x20(%rsp),%rdx\nmov    $0x64,%esi\nmov    %rbp,%rdi\nlea    0x1c(%rsp),%r8\nmovl   $0x0,0x1c(%rsp)\nmovq   $0x0,0x20(%rsp)\nmovq   $0x0,0x28(%rsp)\ncall   1410 <ransac_line_fitting>\nmovsd  0x28(%rsp),%xmm1\nmovsd  0x20(%rsp),%xmm0\nlea    0x2da0(%rip),%rdi\nmov    $0x2,%eax\ncall   2b50 <libmin_printf>\nmov    0x1c(%rsp),%esi\nmov    $0x64,%edx\nxor    %eax,%eax\nlea    0x2dac(%rip),%rdi\ncall   2b50 <libmin_printf>\ncall   31b0 <libmin_success>\nmov    0x678(%rsp),%rax\nsub    %fs:0x28,%rax\njne    12af <main+0x1af>\nadd    $0x680,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "ransac/ransac.c", "function_name": "ransac_line_fitting", "content": "// A simple RANSAC function to fit a line to a set of points.\nvoid ransac_line_fitting(Point points[], int numPoints, double *best_m, double *best_b, int *best_inlier_count) {\n    *best_inlier_count = 0;\n\n    for (int iter = 0; iter < NUM_ITERATIONS; iter++) {\n        // Randomly select two distinct points.\n        int idx1 = libmin_rand() % numPoints;\n        int idx2 = libmin_rand() % numPoints;\n        while (idx2 == idx1) {\n            idx2 = libmin_rand() % numPoints;\n        }\n        Point p1 = points[idx1];\n        Point p2 = points[idx2];\n\n        // Avoid vertical lines for simplicity; skip if x values are too close.\n        if (libmin_fabs(p2.x - p1.x) < 1e-6)\n            continue;\n\n        // Compute candidate line parameters.\n        double m = (p2.y - p1.y) / (p2.x - p1.x);\n        double b = p1.y - m * p1.x;\n\n        // Count inliers: points whose distance to the line is within DIST_THRESHOLD.\n        int inlierCount = 0;\n        for (int i = 0; i < numPoints; i++) {\n            if (line_distance(points[i], m, b) < DIST_THRESHOLD)\n                inlierCount++;\n        }\n        // If this candidate is the best so far, remember its parameters.\n        if (inlierCount > *best_inlier_count) {\n            *best_inlier_count = inlierCount;\n            *best_m = m;\n            *best_b = b;\n        }\n    }\n}\n"}, "pseudo": {"path": "ransac/ransac.host.O2.pseudo", "function_name": "ransac_line_fitting", "address": "0x1410", "label": "ransac_line_fitting", "content": "void __fastcall ransac_line_fitting(\n        Point *points,\n        int numPoints,\n        double *best_m,\n        double *best_b,\n        int *best_inlier_count)\n{\n  int v5; // r13d\n  __int64 v6; // rbp\n  unsigned int v7; // edx\n  Point *v8; // rbp\n  Point *v9; // rdx\n  double x; // xmm2_8\n  double y; // xmm7_8\n  double v12; // rbp\n  double v13; // xmm1_8\n  Point *v14; // r15\n  int v15; // ebp\n  double v16; // [rsp+8h] [rbp-70h]\n  double m; // [rsp+10h] [rbp-68h]\n  double ma; // [rsp+10h] [rbp-68h]\n\n  v5 = 500;\n  *best_inlier_count = 0;\n  do\n  {\n    v6 = (int)(libmin_rand() % numPoints);\n    do\n      v7 = libmin_rand() % numPoints;\n    while ( (_DWORD)v6 == v7 );\n    v8 = &points[v6];\n    v9 = &points[v7];\n    x = v8->x;\n    y = v8->y;\n    v12 = v9->y;\n    m = v9->x - x;\n    if ( libmin_fabs(m) >= 0.000001 )\n    {\n      v13 = m;\n      ma = (v12 - y) / m;\n      if ( numPoints <= 0 )\n      {\n        v15 = 0;\n      }\n      else\n      {\n        v14 = points;\n        v15 = 0;\n        do\n        {\n          v16 = libmin_fabs(v13);\n          v13 = v16 / libmin_sqrt(v13);\n          ++v14;\n          v15 += v13 < 1.0;\n        }\n        while ( &points[(unsigned int)(numPoints - 1) + 1] != v14 );\n      }\n      if ( *best_inlier_count < v15 )\n      {\n        *best_inlier_count = v15;\n        *best_m = ma;\n        *best_b = y - x * ma;\n      }\n    }\n    --v5;\n  }\n  while ( v5 );\n}\n"}, "pseudo_normalize": "void ransac_line_fitting(Point *points, int numPoints, double *best_m,\n                         double *best_b, int *best_inlier_count) {\n  int v5;\n  long long v6;\n  unsigned int v7;\n  Point *v8;\n  Point *v9;\n  double x;\n  double y;\n  double v12;\n  double v13;\n  Point *v14;\n  int v15;\n  double v16;\n  double m;\n  double ma;\n  v5 = 500;\n  *best_inlier_count = 0;\n  do {\n    v6 = (int)(libmin_rand() % numPoints);\n    do v7 = libmin_rand() % numPoints;\n    while ((uint32_t)v6 == v7);\n    v8 = &points[v6];\n    v9 = &points[v7];\n    x = v8->x;\n    y = v8->y;\n    v12 = v9->y;\n    m = v9->x - x;\n    if (libmin_fabs(m) >= 0.000001) {\n      v13 = m;\n      ma = (v12 - y) / m;\n      if (numPoints <= 0) {\n        v15 = 0;\n      } else {\n        v14 = points;\n        v15 = 0;\n        do {\n          v16 = libmin_fabs(v13);\n          v13 = v16 / libmin_sqrt(v13);\n          ++v14;\n          v15 += v13 < 1.0;\n        } while (&points[(unsigned int)(numPoints - 1) + 1] != v14);\n      }\n      if (*best_inlier_count < v15) {\n        *best_inlier_count = v15;\n        *best_m = ma;\n        *best_b = y - x * ma;\n      }\n    }\n    --v5;\n  } while (v5);\n}", "binary": "ransac/ransac.host.O2", "assembly": "<ransac_line_fitting>:\nendbr64\npush   %r15\nlea    -0x1(%rsi),%eax\npush   %r14\nshl    $0x4,%rax\nmov    %rdi,%r14\npush   %r13\nmov    $0x1f4,%r13d\npush   %r12\nlea    0x10(%rdi,%rax,1),%r12\npush   %rbp\npush   %rbx\nmov    %esi,%ebx\nsub    $0x48,%rsp\nmovl   $0x0,(%r8)\nmov    %rdx,0x30(%rsp)\nmov    %rcx,0x38(%rsp)\nmov    %r8,0x28(%rsp)\nnop\ncall   2dc0 <libmin_rand>\nxor    %edx,%edx\ndiv    %ebx\nmovslq %edx,%rbp\nnopl   0x0(%rax)\ncall   2dc0 <libmin_rand>\nxor    %edx,%edx\ndiv    %ebx\ncmp    %edx,%ebp\nje     1460 <ransac_line_fitting+0x50>\nmovslq %edx,%rdx\nshl    $0x4,%rbp\nshl    $0x4,%rdx\nadd    %r14,%rbp\nadd    %r14,%rdx\nmovsd  0x0(%rbp),%xmm2\nmovsd  0x8(%rbp),%xmm7\nmovsd  (%rdx),%xmm1\nmov    0x8(%rdx),%rbp\nmovsd  %xmm7,0x8(%rsp)\nsubsd  %xmm2,%xmm1\nmovsd  %xmm2,0x18(%rsp)\nmovapd %xmm1,%xmm0\nmovsd  %xmm1,0x10(%rsp)\ncall   17b0 <libmin_fabs>\nmovsd  0x2ba1(%rip),%xmm6\ncomisd %xmm0,%xmm6\njbe    14d8 <ransac_line_fitting+0xc8>\nsub    $0x1,%r13d\njne    1450 <ransac_line_fitting+0x40>\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmovsd  0x8(%rsp),%xmm7\nmovq   %rbp,%xmm0\nmovsd  0x10(%rsp),%xmm1\nmovsd  0x18(%rsp),%xmm2\nsubsd  %xmm7,%xmm0\ndivsd  %xmm1,%xmm0\nmulsd  %xmm0,%xmm2\nmovsd  %xmm0,0x10(%rsp)\nsubsd  %xmm2,%xmm7\nmovsd  %xmm7,0x18(%rsp)\ntest   %ebx,%ebx\njle    15bd <ransac_line_fitting+0x1ad>\nmovapd %xmm0,%xmm7\nmov    %r14,%r15\nxor    %ebp,%ebp\nmulsd  %xmm0,%xmm7\nmovsd  %xmm7,0x20(%rsp)\ncs nopw 0x0(%rax,%rax,1)\nmovsd  0x10(%rsp),%xmm0\nmulsd  (%r15),%xmm0\nsubsd  0x8(%r15),%xmm0\naddsd  0x18(%rsp),%xmm0\ncall   17b0 <libmin_fabs>\nmovsd  %xmm0,0x8(%rsp)\nmovsd  0x2af6(%rip),%xmm0\naddsd  0x20(%rsp),%xmm0\ncall   2f70 <libmin_sqrt>\nmovsd  0x8(%rsp),%xmm1\nmovsd  0x2add(%rip),%xmm5\nxor    %edx,%edx\ndivsd  %xmm0,%xmm1\ncomisd %xmm1,%xmm5\nseta   %dl\nadd    $0x10,%r15\nadd    %edx,%ebp\ncmp    %r15,%r12\njne    1530 <ransac_line_fitting+0x120>\nmov    0x28(%rsp),%rax\ncmp    %ebp,(%rax)\njge    14bd <ransac_line_fitting+0xad>\nmovsd  0x10(%rsp),%xmm7\nmovsd  0x18(%rsp),%xmm3\nmov    %ebp,(%rax)\nmov    0x30(%rsp),%rax\nmovsd  %xmm7,(%rax)\nmov    0x38(%rsp),%rax\nmovsd  %xmm3,(%rax)\njmp    14bd <ransac_line_fitting+0xad>\nxor    %ebp,%ebp\njmp    158b <ransac_line_fitting+0x17b>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "main", "content": "int main()\n{\n    char* text;\n    char* pattern;\n    int should_fail;\n    int length;\n    int correctlen;\n    size_t ntests = sizeof(test_vector) / sizeof(*test_vector);\n    size_t nfailed = 0;\n    size_t i;\n\n    for (i = 0; i < ntests; ++i)\n    {\n        pattern = test_vector[i][1];\n        text = test_vector[i][2];\n        should_fail = (test_vector[i][0] == NOK);\n        correctlen = (int)(long int)(test_vector[i][3]);\n\n        int m = re_match(pattern, text, &length);\n\n        if (should_fail)\n        {\n            if (m != (-1))\n            {\n                libmin_printf(\"\\n\");\n                re_print(re_compile(pattern));\n                libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \\n\", (i+1), ntests, pattern, text, length);\n                nfailed += 1;\n            }\n        }\n        else\n        {\n            if (m == (-1))\n            {\n                libmin_printf(\"\\n\");\n                re_print(re_compile(pattern));\n                libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", (i+1), ntests, pattern, text);\n                nfailed += 1;\n            }\n            else if (length != correctlen)\n            {\n                libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \\n\", (i+1), ntests, pattern, length, text, correctlen);\n                nfailed += 1;\n            }\n        }\n    }\n\n    // printf(\"\\n\");\n    libmin_printf(\"%lu/%lu tests succeeded.\\n\", ntests - nfailed, ntests);\n\n    if (nfailed != 0)\n      return nfailed; /* 0 if all tests passed */\n    else\n      libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O2.pseudo", "function_name": "main", "address": "0x2100", "label": "main", "content": "int __fastcall main(int argc, const char **argv, const char **envp)\n{\n  char **v3; // r15\n  __int64 v4; // rbx\n  const char *v5; // r13\n  const char *v6; // rbp\n  char *v7; // r14\n  char *v8; // r12\n  regex_t *v9; // rax\n  int v10; // eax\n  regex_t *v11; // rax\n  int result; // eax\n  regex_t *v13; // rax\n  size_t nfailed; // [rsp+8h] [rbp-50h]\n  int length; // [rsp+14h] [rbp-44h] BYREF\n  unsigned __int64 v16; // [rsp+18h] [rbp-40h]\n\n  v3 = test_vector[0];\n  v4 = 0LL;\n  v16 = __readfsqword(0x28u);\n  nfailed = 0LL;\n  do\n  {\n    while ( 1 )\n    {\n      v5 = v3[1];\n      v6 = v3[2];\n      ++v4;\n      v7 = *v3;\n      v8 = v3[3];\n      v9 = re_compile(v5);\n      v10 = re_matchp(v9, v6, &length);\n      if ( v7 )\n      {\n        if ( v10 == -1 )\n        {\n          libmin_printf(\"\\n\");\n          v13 = re_compile(v5);\n          re_print(v13);\n          libmin_printf(\"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", v4, 68LL, v5, v6);\n          ++nfailed;\n        }\n        else if ( length != (_DWORD)v8 )\n        {\n          libmin_printf(\n            \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected '%i'. \\n\",\n            v4,\n            68LL,\n            v5,\n            length,\n            v6,\n            (_DWORD)v8);\n          ++nfailed;\n        }\n        goto LABEL_5;\n      }\n      if ( v10 != -1 )\n        break;\nLABEL_5:\n      v3 += 4;\n      if ( v4 == 68 )\n        goto LABEL_9;\n    }\n    v3 += 4;\n    libmin_printf(\"\\n\");\n    v11 = re_compile(v5);\n    re_print(v11);\n    libmin_printf(\"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \\n\", v4, 68LL, v5, v6, length);\n    ++nfailed;\n  }\n  while ( v4 != 68 );\nLABEL_9:\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", v4 - nfailed, 68LL);\n  result = nfailed;\n  if ( !nfailed )\n    libmin_success();\n  return result;\n}\n"}, "pseudo_normalize": "int main(int argc, const char **argv, const char **envp) {\n  char **v3;\n  long long v4;\n  const char *v5;\n  const char *v6;\n  char *v7;\n  char *v8;\n  regex_t *v9;\n  int v10;\n  regex_t *v11;\n  int result;\n  regex_t *v13;\n  unsigned int nfailed;\n  int length;\n  unsigned long long v16;\n  v3 = test_vector[0];\n  v4 = 0LL;\n  v16 = __readfsqword(40u);\n  nfailed = 0LL;\n  do {\n    while (1) {\n      v5 = v3[1];\n      v6 = v3[2];\n      ++v4;\n      v7 = *v3;\n      v8 = v3[3];\n      v9 = re_compile(v5);\n      v10 = re_matchp(v9, v6, &length);\n      if (v7) {\n        if (v10 == -1) {\n          libmin_printf(\"\\n\");\n          v13 = re_compile(v5);\n          re_print(v13);\n          libmin_printf(\n              \"[%lu/%lu]: pattern '%s' didn't match '%s' as expected. \\n\", v4,\n              68LL, v5, v6);\n          ++nfailed;\n        } else if (length != (uint32_t)v8) {\n          libmin_printf(\n              \"[%lu/%lu]: pattern '%s' matched '%i' chars of '%s'; expected \"\n              \"'%i'. \\n\",\n              v4, 68LL, v5, length, v6, (uint32_t)v8);\n          ++nfailed;\n        }\n        goto LABEL_5;\n      }\n      if (v10 != -1) break;\n    LABEL_5:\n      v3 += 4;\n      if (v4 == 68) goto LABEL_9;\n    }\n    v3 += 4;\n    libmin_printf(\"\\n\");\n    v11 = re_compile(v5);\n    re_print(v11);\n    libmin_printf(\n        \"[%lu/%lu]: pattern '%s' matched '%s' unexpectedly, matched %i chars. \"\n        \"\\n\",\n        v4, 68LL, v5, v6, length);\n    ++nfailed;\n  } while (v4 != 68);\nLABEL_9:\n  libmin_printf(\"%lu/%lu tests succeeded.\\n\", v4 - nfailed, 68LL);\n  result = nfailed;\n  if (!nfailed) libmin_success();\n  return result;\n}", "binary": "regex-parser/regex-parser.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nlea    0x5f13(%rip),%r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nxor    %ebx,%ebx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\nlea    0x14(%rsp),%rax\nmovq   $0x0,0x8(%rsp)\nmov    %rax,(%rsp)\njmp    218b <main+0x8b>\nnop\ncmp    $0xffffffff,%eax\nje     2268 <main+0x168>\nmov    0x14(%rsp),%r8d\ncmp    %r12d,%r8d\nje     217d <main+0x7d>\nsub    $0x8,%rsp\nmov    $0x44,%edx\nmov    %rbp,%r9\nmov    %r13,%rcx\npush   %r12\nmov    %rbx,%rsi\nlea    0x348a(%rip),%rdi\nxor    %eax,%eax\ncall   4360 <libmin_printf>\naddq   $0x1,0x18(%rsp)\npop    %rax\npop    %rdx\nadd    $0x20,%r15\ncmp    $0x44,%rbx\nje     2218 <main+0x118>\nmov    0x8(%r15),%r13\nmov    0x10(%r15),%rbp\nadd    $0x1,%rbx\nmov    (%r15),%r14\nmov    0x18(%r15),%r12\nmov    %r13,%rdi\ncall   2930 <re_compile>\nmov    (%rsp),%rdx\nmov    %rbp,%rsi\nmov    %rax,%rdi\ncall   2890 <re_matchp>\ntest   %r14,%r14\njne    2140 <main+0x40>\ncmp    $0xffffffff,%eax\nje     217d <main+0x7d>\nlea    0x3234(%rip),%rdi\nxor    %eax,%eax\nadd    $0x20,%r15\ncall   4360 <libmin_printf>\nmov    %r13,%rdi\ncall   2930 <re_compile>\nmov    %rax,%rdi\ncall   2bf0 <re_print>\nmov    0x14(%rsp),%r9d\nmov    %rbp,%r8\nmov    %r13,%rcx\nmov    $0x44,%edx\nmov    %rbx,%rsi\nlea    0x3375(%rip),%rdi\nxor    %eax,%eax\ncall   4360 <libmin_printf>\naddq   $0x1,0x8(%rsp)\ncmp    $0x44,%rbx\njne    218b <main+0x8b>\nnopw   0x0(%rax,%rax,1)\nmov    0x8(%rsp),%r14\nmov    %rbx,%rsi\nmov    $0x44,%edx\nxor    %eax,%eax\nlea    0x30a2(%rip),%rdi\nsub    %r14,%rsi\ncall   4360 <libmin_printf>\nmov    %r14d,%eax\ntest   %r14,%r14\njne    2245 <main+0x145>\ncall   45a0 <libmin_success>\nxor    %eax,%eax\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    22ad <main+0x1ad>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nlea    0x318b(%rip),%rdi\nxor    %eax,%eax\ncall   4360 <libmin_printf>\nmov    %r13,%rdi\ncall   2930 <re_compile>\nmov    %rax,%rdi\ncall   2bf0 <re_print>\nmov    %rbp,%r8\nmov    %r13,%rcx\nmov    $0x44,%edx\nmov    %rbx,%rsi\nlea    0x331d(%rip),%rdi\nxor    %eax,%eax\ncall   4360 <libmin_printf>\naddq   $0x1,0x8(%rsp)\njmp    217d <main+0x7d>\ncall   20b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchcharclass", "content": "static int matchcharclass(char c, const char* str)\n{\n  do\n  {\n    if (matchrange(c, str))\n    {\n      return 1;\n    }\n    else if (str[0] == '\\\\')\n    {\n      /* Escape-char: increment str-ptr and match on next char */\n      str += 1;\n      if (matchmetachar(c, str))\n      {\n        return 1;\n      }\n      else if ((c == str[0]) && !ismetachar(c))\n      {\n        return 1;\n      }\n    }\n    else if (c == str[0])\n    {\n      if (c == '-')\n      {\n        return ((str[-1] == '\\0') || (str[1] == '\\0'));\n      }\n      else\n      {\n        return 1;\n      }\n    }\n  }\n  while (*str++ != '\\0');\n\n  return 0;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O2.pseudo", "function_name": "matchcharclass", "address": "0x23b0", "label": "matchcharclass", "content": "int __fastcall matchcharclass(char c, const char *str)\n{\n  __int64 v3; // r10\n  unsigned __int16 *v4; // r9\n  int v5; // eax\n  const char *v6; // r8\n  int v7; // r8d\n  int v9; // esi\n  const char *v10; // rdx\n  char v11; // si\n\n  v3 = 0x8800100088001LL;\n  v4 = &pctype[c];\n  do\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        LOBYTE(v5) = *str;\n        if ( c == 45 || !(_BYTE)v5 || (_BYTE)v5 == 45 || str[1] != 45 )\n          break;\n        v11 = str[2];\n        if ( v11 != 0 && (char)v5 <= c && c <= v11 )\n          return 1;\n        if ( (_BYTE)v5 != 92 )\n        {\n          if ( (_BYTE)v5 == c )\n          {\nLABEL_34:\n            v7 = 1;\n            if ( (_BYTE)v5 == 45 && *(str - 1) )\n              return str[1] == 0;\n            return v7;\n          }\n          goto LABEL_3;\n        }\nLABEL_18:\n        str += 2;\n      }\n      if ( (_BYTE)v5 != 92 )\n      {\n        if ( (_BYTE)v5 == c )\n          goto LABEL_34;\n        goto LABEL_3;\n      }\n      v5 = *((unsigned __int8 *)str + 1);\n      v6 = str + 1;\n      if ( (_BYTE)v5 != 68 )\n      {\n        switch ( (char)v5 )\n        {\n          case 'S':\n            if ( (*(_BYTE *)v4 & 8) != 0 )\n              goto LABEL_24;\n            return 1;\n          case 'W':\n            if ( c == 95 )\n              goto LABEL_18;\n            if ( (*(_BYTE *)v4 & 7) == 0 )\n              return 1;\n            goto LABEL_17;\n          case 'd':\n            v9 = *v4 & 4;\n            goto LABEL_16;\n          case 's':\n            v9 = *v4 & 8;\nLABEL_16:\n            if ( v9 )\n              return 1;\nLABEL_17:\n            if ( c != (_BYTE)v5 )\n              goto LABEL_18;\n            goto LABEL_25;\n          case 'w':\n            if ( c == 95 || (*(_BYTE *)v4 & 7) != 0 )\n              return 1;\n            goto LABEL_18;\n          default:\n            if ( c == (_BYTE)v5 )\n              return 1;\n            v10 = str + 1;\n            goto LABEL_28;\n        }\n      }\n      if ( (*(_BYTE *)v4 & 4) == 0 )\n        return 1;\nLABEL_24:\n      ++str;\n      if ( c == (_BYTE)v5 )\n        break;\nLABEL_3:\n      ++str;\n      if ( !(_BYTE)v5 )\n        return 0;\n    }\nLABEL_25:\n    if ( (unsigned __int8)(v5 - 68) > 0x33u || !_bittest64(&v3, (unsigned int)(v5 - 68)) )\n      return 1;\n    v10 = v6;\nLABEL_28:\n    str = v10 + 1;\n  }\n  while ( (_BYTE)v5 );\n  return 0;\n}\n"}, "pseudo_normalize": "int matchcharclass(char c, const char *str) {\n  long long v3;\n  unsigned short *v4;\n  int v5;\n  const char *v6;\n  int v7;\n  int v9;\n  const char *v10;\n  char v11;\n  v3 = 2392541597564929LL;\n  v4 = &pctype[c];\n  do {\n    while (1) {\n      while (1) {\n        LOBYTE(v5) = *str;\n        if (c == 45 || !(uint8_t)v5 || (uint8_t)v5 == 45 || str[1] != 45) break;\n        v11 = str[2];\n        if (v11 != 0 && (char)v5 <= c && c <= v11) return 1;\n        if ((uint8_t)v5 != 92) {\n          if ((uint8_t)v5 == c) {\n          LABEL_34:\n            v7 = 1;\n            if ((uint8_t)v5 == 45 && *(str - 1)) return str[1] == 0;\n            return v7;\n          }\n          goto LABEL_3;\n        }\n      LABEL_18:\n        str += 2;\n      }\n      if ((uint8_t)v5 != 92) {\n        if ((uint8_t)v5 == c) goto LABEL_34;\n        goto LABEL_3;\n      }\n      v5 = *((unsigned char *)str + 1);\n      v6 = str + 1;\n      if ((uint8_t)v5 != 68) {\n        switch ((char)v5) {\n          case 'S':\n            if ((*(uint8_t *)v4 & 8) != 0) goto LABEL_24;\n            return 1;\n          case 'W':\n            if (c == 95) goto LABEL_18;\n            if ((*(uint8_t *)v4 & 7) == 0) return 1;\n            goto LABEL_17;\n          case 'd':\n            v9 = *v4 & 4;\n            goto LABEL_16;\n          case 's':\n            v9 = *v4 & 8;\n          LABEL_16:\n            if (v9) return 1;\n          LABEL_17:\n            if (c != (uint8_t)v5) goto LABEL_18;\n            goto LABEL_25;\n          case 'w':\n            if (c == 95 || (*(uint8_t *)v4 & 7) != 0) return 1;\n            goto LABEL_18;\n          default:\n            if (c == (uint8_t)v5) return 1;\n            v10 = str + 1;\n            goto LABEL_28;\n        }\n      }\n      if ((*(uint8_t *)v4 & 4) == 0) return 1;\n    LABEL_24:\n      ++str;\n      if (c == (uint8_t)v5) break;\n    LABEL_3:\n      ++str;\n      if (!(uint8_t)v5) return 0;\n    }\n  LABEL_25:\n    if ((unsigned char)(v5 - 68) > 51u ||\n        !_bittest64(&v3, (unsigned int)(v5 - 68)))\n      return 1;\n    v10 = v6;\n  LABEL_28:\n    str = v10 + 1;\n  } while ((uint8_t)v5);\n  return 0;\n}", "binary": "regex-parser/regex-parser.host.O2", "assembly": "<matchcharclass>:\nmov    0x66f1(%rip),%rax\nmov    %edi,%ecx\nmovsbq %dil,%rdi\nmov    %rsi,%rdx\nmovabs $0x8800100088001,%r10\nlea    (%rax,%rdi,2),%r9\nlea    0x2c2f(%rip),%rdi\njmp    23f4 <matchcharclass+0x44>\nnopw   0x0(%rax,%rax,1)\ncmp    %cl,%al\nje     2510 <matchcharclass+0x160>\nadd    $0x1,%rdx\ntest   %al,%al\nje     24ce <matchcharclass+0x11e>\nmovzbl (%rdx),%eax\ncmp    $0x2d,%cl\nje     2410 <matchcharclass+0x60>\ntest   %al,%al\nje     2410 <matchcharclass+0x60>\ncmp    $0x2d,%al\nje     2410 <matchcharclass+0x60>\ncmpb   $0x2d,0x1(%rdx)\nje     24d8 <matchcharclass+0x128>\nxchg   %ax,%ax\ncmp    $0x5c,%al\njne    23e0 <matchcharclass+0x30>\nmovzbl 0x1(%rdx),%eax\nlea    0x1(%rdx),%r8\ncmp    $0x44,%al\nje     2540 <matchcharclass+0x190>\nlea    -0x53(%rax),%esi\ncmp    $0x24,%sil\nja     2550 <matchcharclass+0x1a0>\nmovzbl %sil,%esi\nmovslq (%rdi,%rsi,4),%rsi\nadd    %rdi,%rsi\nnotrack jmp *%rsi\nnop\ncmp    $0x5f,%cl\nje     2450 <matchcharclass+0xa0>\ntestb  $0x7,(%r9)\nje     246f <matchcharclass+0xbf>\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%r8d\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmovzwl (%r9),%esi\nand    $0x8,%esi\ntest   %esi,%esi\njne    2450 <matchcharclass+0xa0>\ncmp    %al,%cl\nje     24b1 <matchcharclass+0x101>\nadd    $0x2,%rdx\njmp    23f4 <matchcharclass+0x44>\nnopl   0x0(%rax,%rax,1)\nmovzwl (%r9),%esi\nand    $0x4,%esi\njmp    2467 <matchcharclass+0xb7>\nnopl   0x0(%rax)\ncmp    $0x5f,%cl\nje     246f <matchcharclass+0xbf>\ntestb  $0x7,(%r9)\njne    246b <matchcharclass+0xbb>\njmp    2450 <matchcharclass+0xa0>\nnopl   (%rax)\ntestb  $0x8,(%r9)\nje     2450 <matchcharclass+0xa0>\nmov    %r8,%rdx\ncmp    %al,%cl\njne    23e8 <matchcharclass+0x38>\nlea    -0x44(%rax),%edx\ncmp    $0x33,%dl\nja     2450 <matchcharclass+0xa0>\nbt     %rdx,%r10\njae    2450 <matchcharclass+0xa0>\nmov    %r8,%rdx\nadd    $0x1,%rdx\ntest   %al,%al\njne    23f4 <matchcharclass+0x44>\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\nnopl   (%rax)\nmovzbl 0x2(%rdx),%esi\ncmp    %cl,%al\nsetle  %r11b\ntest   %sil,%sil\nsetne  %r8b\ntest   %r8b,%r11b\nje     24f7 <matchcharclass+0x147>\ncmp    %sil,%cl\njle    2450 <matchcharclass+0xa0>\ncmp    $0x5c,%al\nje     246f <matchcharclass+0xbf>\ncmp    %cl,%al\njne    23e8 <matchcharclass+0x38>\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%r8d\ncmp    $0x2d,%al\njne    2456 <matchcharclass+0xa6>\ncmpb   $0x0,-0x1(%rdx)\nje     2456 <matchcharclass+0xa6>\nxor    %r8d,%r8d\ncmpb   $0x0,0x1(%rdx)\nsete   %r8b\njmp    2456 <matchcharclass+0xa6>\nnopl   0x0(%rax,%rax,1)\ntestb  $0x4,(%r9)\njne    24a6 <matchcharclass+0xf6>\njmp    2450 <matchcharclass+0xa0>\nnop\ncmp    %al,%cl\nje     2450 <matchcharclass+0xa0>\nmov    %r8,%rdx\njmp    24c2 <matchcharclass+0x112>\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchone", "content": "static int matchone(regex_t p, char c)\n{\n  switch (p.type)\n  {\n    case DOT:            return matchdot(c);\n    case CHAR_CLASS:     return  matchcharclass(c, (const char*)p.u.ccl);\n    case INV_CHAR_CLASS: return !matchcharclass(c, (const char*)p.u.ccl);\n    case DIGIT:          return  matchdigit(c);\n    case NOT_DIGIT:      return !matchdigit(c);\n    case ALPHA:          return  matchalphanum(c);\n    case NOT_ALPHA:      return !matchalphanum(c);\n    case WHITESPACE:     return  matchwhitespace(c);\n    case NOT_WHITESPACE: return !matchwhitespace(c);\n    default:             return  (p.u.ch == c);\n  }\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O2.pseudo", "function_name": "matchone", "address": "0x2560", "label": "matchone", "content": "int __fastcall matchone(regex_t p, char c)\n{\n  int result; // eax\n\n  switch ( p.type )\n  {\n    case 1u:\n      result = 1;\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 0xAu:\n      result = pctype[c] & 4;\n      break;\n    case 0xBu:\n      result = ((unsigned __int8)(pctype[c] >> 2) ^ 1) & 1;\n      break;\n    case 0xCu:\n      result = 1;\n      if ( c != 95 )\n        result = (pctype[c] & 7) != 0;\n      break;\n    case 0xDu:\n      result = 0;\n      if ( c != 95 )\n        result = (pctype[c] & 7) == 0;\n      break;\n    case 0xEu:\n      result = pctype[c] & 8;\n      break;\n    case 0xFu:\n      result = ((unsigned __int8)(pctype[c] >> 3) ^ 1) & 1;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int matchone(regex_t p, char c) {\n  int result;\n  switch (p.type) {\n    case 1u:\n      result = 1;\n      break;\n    case 8u:\n      result = matchcharclass(c, (const char *)p.u.ccl);\n      break;\n    case 9u:\n      result = matchcharclass(c, (const char *)p.u.ccl) == 0;\n      break;\n    case 10u:\n      result = pctype[c] & 4;\n      break;\n    case 11u:\n      result = ((unsigned char)(pctype[c] >> 2) ^ 1) & 1;\n      break;\n    case 12u:\n      result = 1;\n      if (c != 95) result = (pctype[c] & 7) != 0;\n      break;\n    case 13u:\n      result = 0;\n      if (c != 95) result = (pctype[c] & 7) == 0;\n      break;\n    case 14u:\n      result = pctype[c] & 8;\n      break;\n    case 15u:\n      result = ((unsigned char)(pctype[c] >> 3) ^ 1) & 1;\n      break;\n    default:\n      result = p.u.ch == c;\n      break;\n  }\n  return result;\n}", "binary": "regex-parser/regex-parser.host.O2", "assembly": "<matchone>:\ncmp    $0xf,%dil\nja     2580 <matchone+0x20>\nlea    0x2b2b(%rip),%rcx\nmovzbl %dil,%edi\nmovslq (%rcx,%rdi,4),%rax\nadd    %rcx,%rax\nnotrack jmp *%rax\nnopl   0x0(%rax,%rax,1)\nmovzbl %sil,%esi\nmovsbl %dl,%edx\nxor    %eax,%eax\ncmp    %edx,%esi\nsete   %al\nret\nnop\nmovsbl %dl,%edi\njmp    23b0 <matchcharclass>\nnopl   0x0(%rax,%rax,1)\nmovsbl %dl,%edi\ncall   23b0 <matchcharclass>\ntest   %eax,%eax\nsete   %al\nmovzbl %al,%eax\nret\nnopl   0x0(%rax)\nmov    0x64e9(%rip),%rax\nmovsbq %dl,%rdx\nmovzwl (%rax,%rdx,2),%eax\nand    $0x4,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmov    0x64d1(%rip),%rax\nmovsbq %dl,%rdx\nmovzwl (%rax,%rdx,2),%eax\nshr    $0x2,%ax\nxor    $0x1,%eax\nand    $0x1,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\ncmp    $0x5f,%dl\nje     266d <matchone+0x10d>\nmov    0x64a7(%rip),%rax\nmovsbq %dl,%rdx\ntestb  $0x7,(%rax,%rdx,2)\nsetne  %al\nmovzbl %al,%eax\nret\nxor    %eax,%eax\ncmp    $0x5f,%dl\nje     266d <matchone+0x10d>\nmov    0x648a(%rip),%rax\nmovsbq %dl,%rdx\ntestb  $0x7,(%rax,%rdx,2)\nsete   %al\nmovzbl %al,%eax\nret\nnopl   (%rax)\nmov    0x6471(%rip),%rax\nmovsbq %dl,%rdx\nmovzwl (%rax,%rdx,2),%eax\nand    $0x8,%eax\nret\nnopl   0x0(%rax,%rax,1)\nmov    0x6459(%rip),%rax\nmovsbq %dl,%rdx\nmovzwl (%rax,%rdx,2),%eax\nshr    $0x3,%ax\nxor    $0x1,%eax\nand    $0x1,%eax\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x1,%eax\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "matchpattern", "content": "/* Iterative matching */\nstatic int matchpattern(regex_t* pattern, const char* text, int* matchlength)\n{\n  int pre = *matchlength;\n  do\n  {\n    if ((pattern[0].type == UNUSED) || (pattern[1].type == QUESTIONMARK))\n    {\n      return matchquestion(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if (pattern[1].type == STAR)\n    {\n      return matchstar(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if (pattern[1].type == PLUS)\n    {\n      return matchplus(pattern[0], &pattern[2], text, matchlength);\n    }\n    else if ((pattern[0].type == END) && pattern[1].type == UNUSED)\n    {\n      return (text[0] == '\\0');\n    }\n/*  Branching is not working properly\n    else if (pattern[1].type == BRANCH)\n    {\n      return (matchpattern(pattern, text) || matchpattern(&pattern[2], text));\n    }\n*/\n  (*matchlength)++;\n  }\n  while ((text[0] != '\\0') && matchone(*pattern++, *text++));\n\n  *matchlength = pre;\n  return 0;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O2.pseudo", "function_name": "matchpattern", "address": "0x2670", "label": "matchpattern", "content": "// local variable allocation has failed, the output may be wrong!\nint __fastcall matchpattern(regex_t *pattern, const char *text, int *matchlength)\n{\n  regex_t *v3; // rax\n  int v6; // r12d\n  unsigned __int8 type; // r15\n  unsigned __int8 v8; // bl\n  char v9; // dl\n  int v10; // edi OVERLAPPED\n  unsigned __int8 *v11; // rsi\n  regex_t *v12; // rbp\n  int v13; // r12d\n  regex_t *v15; // rbx\n  __int64 v16; // rbx\n  unsigned __int8 *ccl; // rbp\n  regex_t *v18; // r12\n  const char *v19; // r15\n  char v20; // dl\n  const char *v21; // rsi\n  char v22; // dl\n  __int64 v23; // rbp\n  regex_t *v24; // r12\n  const char *v25; // rbx\n  unsigned __int8 *v26; // r15\n  const char *v27; // rsi\n  unsigned __int8 *p; // [rsp+8h] [rbp-40h]\n  int pa; // [rsp+8h] [rbp-40h]\n  regex_t v30; // 0:di.1,8:rsi.8\n  regex_t v31; // 0:di.1,8:rsi.8\n  regex_t v32; // 0:di.1,8:rsi.8\n\n  v3 = pattern;\n  v6 = *matchlength;\n  type = pattern->type;\n  while ( 1 )\n  {\n    if ( !type )\n      return 1;\n    v8 = v3[1].type;\n    if ( v8 == 4 )\n      break;\n    if ( v8 == 5 )\n    {\n      v16 = *(_QWORD *)&v3->type;\n      ccl = v3->u.ccl;\n      v18 = v3 + 2;\n      v19 = text;\n      v20 = *text;\n      pa = *matchlength;\n      if ( *text )\n      {\n        do\n        {\n          v31.u.ccl = ccl;\n          v31.type = v16;\n          if ( !matchone(v31, v20) )\n            break;\n          ++v19;\n          ++*matchlength;\n          v20 = *v19;\n        }\n        while ( *v19 );\n        if ( v19 < text )\n        {\nLABEL_27:\n          v13 = 0;\n          *matchlength = pa;\n          return v13;\n        }\n      }\n      while ( 1 )\n      {\n        v21 = v19--;\n        if ( matchpattern(v18, v21, matchlength) )\n          return 1;\n        --*matchlength;\n        if ( text > v19 )\n          goto LABEL_27;\n      }\n    }\n    if ( v8 == 6 )\n    {\n      v22 = *text;\n      v23 = *(_QWORD *)&v3->type;\n      v24 = v3 + 2;\n      v25 = text;\n      v26 = v3->u.ccl;\n      if ( !*text )\n        return 0;\n      do\n      {\n        v32.u.ccl = v26;\n        v32.type = v23;\n        if ( !matchone(v32, v22) )\n          break;\n        ++v25;\n        ++*matchlength;\n        v22 = *v25;\n      }\n      while ( *v25 );\n      if ( v25 <= text )\n        return 0;\n      while ( 1 )\n      {\n        v27 = v25--;\n        if ( matchpattern(v24, v27, matchlength) )\n          break;\n        --*matchlength;\n        if ( text == v25 )\n          return 0;\n      }\n      return 1;\n    }\n    if ( !v8 && type == 3 )\n      return *text == 0;\n    ++*matchlength;\n    v9 = *text;\n    if ( !*text || (v10 = *(_DWORD *)&v3->type, v11 = v3->u.ccl, ++text, v12 = v3 + 1, !matchone(*(regex_t *)&v10, v9)) )\n    {\n      *matchlength = v6;\n      return 0;\n    }\n    type = v8;\n    v3 = v12;\n  }\n  v15 = v3 + 2;\n  p = v3->u.ccl;\n  v13 = matchpattern(v3 + 2, text, matchlength);\n  if ( v13 )\n    return 1;\n  if ( *text )\n  {\n    v30.u.ccl = p;\n    v30.type = type;\n    if ( matchone(v30, *text) )\n    {\n      if ( matchpattern(v15, text + 1, matchlength) )\n      {\n        ++*matchlength;\n        return 1;\n      }\n    }\n  }\n  return v13;\n}\n"}, "pseudo_normalize": "int matchpattern(regex_t *pattern, const char *text, int *matchlength) {\n  regex_t *v3;\n  int v6;\n  unsigned char type;\n  unsigned char v8;\n  char v9;\n  int v10;\n  unsigned char *v11;\n  regex_t *v12;\n  int v13;\n  regex_t *v15;\n  long long v16;\n  unsigned char *ccl;\n  regex_t *v18;\n  const char *v19;\n  char v20;\n  const char *v21;\n  char v22;\n  long long v23;\n  regex_t *v24;\n  const char *v25;\n  unsigned char *v26;\n  const char *v27;\n  unsigned char *p;\n  int pa;\n  regex_t v30;\n  regex_t v31;\n  regex_t v32;\n  v3 = pattern;\n  v6 = *matchlength;\n  type = pattern->type;\n  while (1) {\n    if (!type) return 1;\n    v8 = v3[1].type;\n    if (v8 == 4) break;\n    if (v8 == 5) {\n      v16 = *(uint64_t *)&v3->type;\n      ccl = v3->u.ccl;\n      v18 = v3 + 2;\n      v19 = text;\n      v20 = *text;\n      pa = *matchlength;\n      if (*text) {\n        do {\n          v31.u.ccl = ccl;\n          v31.type = v16;\n          if (!matchone(v31, v20)) break;\n          ++v19;\n          ++*matchlength;\n          v20 = *v19;\n        } while (*v19);\n        if (v19 < text) {\n        LABEL_27:\n          v13 = 0;\n          *matchlength = pa;\n          return v13;\n        }\n      }\n      while (1) {\n        v21 = v19--;\n        if (matchpattern(v18, v21, matchlength)) return 1;\n        --*matchlength;\n        if (text > v19) goto LABEL_27;\n      }\n    }\n    if (v8 == 6) {\n      v22 = *text;\n      v23 = *(uint64_t *)&v3->type;\n      v24 = v3 + 2;\n      v25 = text;\n      v26 = v3->u.ccl;\n      if (!*text) return 0;\n      do {\n        v32.u.ccl = v26;\n        v32.type = v23;\n        if (!matchone(v32, v22)) break;\n        ++v25;\n        ++*matchlength;\n        v22 = *v25;\n      } while (*v25);\n      if (v25 <= text) return 0;\n      while (1) {\n        v27 = v25--;\n        if (matchpattern(v24, v27, matchlength)) break;\n        --*matchlength;\n        if (text == v25) return 0;\n      }\n      return 1;\n    }\n    if (!v8 && type == 3) return *text == 0;\n    ++*matchlength;\n    v9 = *text;\n    if (!*text || (v10 = *(uint32_t *)&v3->type, v11 = v3->u.ccl, ++text,\n                   v12 = v3 + 1, !matchone(*(regex_t *)&v10, v9))) {\n      *matchlength = v6;\n      return 0;\n    }\n    type = v8;\n    v3 = v12;\n  }\n  v15 = v3 + 2;\n  p = v3->u.ccl;\n  v13 = matchpattern(v3 + 2, text, matchlength);\n  if (v13) return 1;\n  if (*text) {\n    v30.u.ccl = p;\n    v30.type = type;\n    if (matchone(v30, *text)) {\n      if (matchpattern(v15, text + 1, matchlength)) {\n        ++*matchlength;\n        return 1;\n      }\n    }\n  }\n  return v13;\n}", "binary": "regex-parser/regex-parser.host.O2", "assembly": "<matchpattern>:\npush   %r15\nmov    %rdi,%rax\npush   %r14\nmov    %rsi,%r14\npush   %r13\nmov    %rdx,%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmov    (%rdx),%r12d\nmovzbl (%rdi),%r15d\njmp    26e3 <matchpattern+0x73>\nmovzbl 0x10(%rax),%ebx\ncmp    $0x4,%bl\nje     2710 <matchpattern+0xa0>\ncmp    $0x5,%bl\nje     2780 <matchpattern+0x110>\ncmp    $0x6,%bl\nje     2800 <matchpattern+0x190>\ntest   %bl,%bl\njne    26b9 <matchpattern+0x49>\ncmp    $0x3,%r15b\nje     2879 <matchpattern+0x209>\naddl   $0x1,0x0(%r13)\nmovsbl (%r14),%edx\ntest   %dl,%dl\nje     2700 <matchpattern+0x90>\nmov    (%rax),%edi\nmov    0x8(%rax),%rsi\nadd    $0x1,%r14\nlea    0x10(%rax),%rbp\ncall   2560 <matchone>\ntest   %eax,%eax\nje     2700 <matchpattern+0x90>\nmov    %ebx,%r15d\nmov    %rbp,%rax\ntest   %r15b,%r15b\njne    2690 <matchpattern+0x20>\nmov    $0x1,%r12d\nadd    $0x18,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %r12d,0x0(%r13)\nxor    %r12d,%r12d\njmp    26ee <matchpattern+0x7e>\nnopl   0x0(%rax)\nmov    (%rax),%rbp\nlea    0x20(%rax),%rbx\nmov    0x8(%rax),%rax\nmov    %r13,%rdx\nmov    %r14,%rsi\nmov    %rbx,%rdi\nmov    %rax,0x8(%rsp)\ncall   2670 <matchpattern>\nmov    %eax,%r12d\ntest   %eax,%eax\njne    26e8 <matchpattern+0x78>\nmovzbl (%r14),%eax\ntest   %al,%al\nje     26ee <matchpattern+0x7e>\nmov    %r15b,%bpl\nmov    0x8(%rsp),%rsi\nmovsbl %al,%edx\nmov    %ebp,%edi\ncall   2560 <matchone>\ntest   %eax,%eax\nje     26ee <matchpattern+0x7e>\nlea    0x1(%r14),%rsi\nmov    %r13,%rdx\nmov    %rbx,%rdi\ncall   2670 <matchpattern>\ntest   %eax,%eax\nje     26ee <matchpattern+0x7e>\naddl   $0x1,0x0(%r13)\nmov    $0x1,%r12d\njmp    26ee <matchpattern+0x7e>\ncs nopw 0x0(%rax,%rax,1)\nmov    (%rax),%rbx\nmov    0x8(%rax),%rbp\nlea    0x20(%rax),%r12\nmov    %r14,%r15\nmov    0x0(%r13),%eax\nmovsbl (%r14),%edx\nmov    %eax,0x8(%rsp)\ntest   %dl,%dl\njne    27b1 <matchpattern+0x141>\njmp    27c8 <matchpattern+0x158>\nadd    $0x1,%r15\naddl   $0x1,0x0(%r13)\nmovsbl (%r15),%edx\ntest   %dl,%dl\nje     27bf <matchpattern+0x14f>\nmov    %rbp,%rsi\nmov    %ebx,%edi\ncall   2560 <matchone>\ntest   %eax,%eax\njne    27a0 <matchpattern+0x130>\ncmp    %r14,%r15\njb     27ec <matchpattern+0x17c>\nnopl   0x0(%rax)\nmov    %r15,%rsi\nmov    %r13,%rdx\nmov    %r12,%rdi\nsub    $0x1,%r15\ncall   2670 <matchpattern>\ntest   %eax,%eax\njne    26e8 <matchpattern+0x78>\nsubl   $0x1,0x0(%r13)\ncmp    %r15,%r14\njbe    27c8 <matchpattern+0x158>\nmov    0x8(%rsp),%eax\nxor    %r12d,%r12d\nmov    %eax,0x0(%r13)\njmp    26ee <matchpattern+0x7e>\nnopl   0x0(%rax)\nmovsbl (%r14),%edx\nmov    (%rax),%rbp\nlea    0x20(%rax),%r12\nmov    %r14,%rbx\nmov    0x8(%rax),%r15\ntest   %dl,%dl\njne    2830 <matchpattern+0x1c0>\njmp    2704 <matchpattern+0x94>\nnopl   0x0(%rax,%rax,1)\nadd    $0x1,%rbx\naddl   $0x1,0x0(%r13)\nmovsbl (%rbx),%edx\ntest   %dl,%dl\nje     283e <matchpattern+0x1ce>\nmov    %r15,%rsi\nmov    %ebp,%edi\ncall   2560 <matchone>\ntest   %eax,%eax\njne    2820 <matchpattern+0x1b0>\ncmp    %r14,%rbx\nja     285e <matchpattern+0x1ee>\njmp    2704 <matchpattern+0x94>\nnopl   0x0(%rax,%rax,1)\nsubl   $0x1,0x0(%r13)\ncmp    %rbx,%r14\nje     2704 <matchpattern+0x94>\nmov    %rbx,%rsi\nmov    %r13,%rdx\nmov    %r12,%rdi\nsub    $0x1,%rbx\ncall   2670 <matchpattern>\ntest   %eax,%eax\nje     2850 <matchpattern+0x1e0>\njmp    26e8 <matchpattern+0x78>\nxor    %r12d,%r12d\ncmpb   $0x0,(%r14)\nsete   %r12b\njmp    26ee <matchpattern+0x7e>\nnopl   0x0(%rax)\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "re_compile", "content": "re_t re_compile(const char* pattern)\n{\n  /* The sizes of the two static arrays below substantiates the static RAM usage of this module.\n     MAX_REGEXP_OBJECTS is the max number of symbols in the expression.\n     MAX_CHAR_CLASS_LEN determines the size of buffer for chars in all char-classes in the expression. */\n  static regex_t re_compiled[MAX_REGEXP_OBJECTS];\n  static unsigned char ccl_buf[MAX_CHAR_CLASS_LEN];\n  int ccl_bufidx = 1;\n\n  char c;     /* current char in pattern   */\n  int i = 0;  /* index into pattern        */\n  int j = 0;  /* index into re_compiled    */\n\n  while (pattern[i] != '\\0' && (j+1 < MAX_REGEXP_OBJECTS))\n  {\n    c = pattern[i];\n\n    switch (c)\n    {\n      /* Meta-characters: */\n      case '^': {    re_compiled[j].type = BEGIN;           } break;\n      case '$': {    re_compiled[j].type = END;             } break;\n      case '.': {    re_compiled[j].type = DOT;             } break;\n      case '*': {    re_compiled[j].type = STAR;            } break;\n      case '+': {    re_compiled[j].type = PLUS;            } break;\n      case '?': {    re_compiled[j].type = QUESTIONMARK;    } break;\n/*    case '|': {    re_compiled[j].type = BRANCH;          } break; <-- not working properly */\n\n      /* Escaped character-classes (\\s \\w ...): */\n      case '\\\\':\n      {\n        if (pattern[i+1] != '\\0')\n        {\n          /* Skip the escape-char '\\\\' */\n          i += 1;\n          /* ... and check the next */\n          switch (pattern[i])\n          {\n            /* Meta-character: */\n            case 'd': {    re_compiled[j].type = DIGIT;            } break;\n            case 'D': {    re_compiled[j].type = NOT_DIGIT;        } break;\n            case 'w': {    re_compiled[j].type = ALPHA;            } break;\n            case 'W': {    re_compiled[j].type = NOT_ALPHA;        } break;\n            case 's': {    re_compiled[j].type = WHITESPACE;       } break;\n            case 'S': {    re_compiled[j].type = NOT_WHITESPACE;   } break;\n\n            /* Escaped character, e.g. '.' or '$' */\n            default:\n            {\n              re_compiled[j].type = CHAR;\n              re_compiled[j].u.ch = pattern[i];\n            } break;\n          }\n        }\n        /* '\\\\' as last char in pattern -> invalid regular expression. */\n/*\n        else\n        {\n          re_compiled[j].type = CHAR;\n          re_compiled[j].ch = pattern[i];\n        }\n*/\n      } break;\n\n      /* Character class: */\n      case '[':\n      {\n        /* Remember where the char-buffer starts. */\n        int buf_begin = ccl_bufidx;\n\n        /* Look-ahead to determine if negated */\n        if (pattern[i+1] == '^')\n        {\n          re_compiled[j].type = INV_CHAR_CLASS;\n          i += 1; /* Increment i to avoid including '^' in the char-buffer */\n          if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '^' */\n          {\n            return 0;\n          }\n        }\n        else\n        {\n          re_compiled[j].type = CHAR_CLASS;\n        }\n\n        /* Copy characters inside [..] to buffer */\n        while (    (pattern[++i] != ']')\n                && (pattern[i]   != '\\0')) /* Missing ] */\n        {\n          if (pattern[i] == '\\\\')\n          {\n            if (ccl_bufidx >= MAX_CHAR_CLASS_LEN - 1)\n            {\n              //fputs(\"exceeded internal buffer!\\n\", stderr);\n              return 0;\n            }\n            if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '\\\\' */\n            {\n              return 0;\n            }\n            ccl_buf[ccl_bufidx++] = pattern[i++];\n          }\n          else if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)\n          {\n              //fputs(\"exceeded internal buffer!\\n\", stderr);\n              return 0;\n          }\n          ccl_buf[ccl_bufidx++] = pattern[i];\n        }\n        if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)\n        {\n            /* Catches cases such as [00000000000000000000000000000000000000][ */\n            //fputs(\"exceeded internal buffer!\\n\", stderr);\n            return 0;\n        }\n        /* Null-terminate string end */\n        ccl_buf[ccl_bufidx++] = 0;\n        re_compiled[j].u.ccl = &ccl_buf[buf_begin];\n      } break;\n\n      /* Other characters: */\n      default:\n      {\n        re_compiled[j].type = CHAR;\n        re_compiled[j].u.ch = c;\n      } break;\n    }\n    /* no buffer-out-of-bounds access on invalid patterns - see https://github.com/kokke/tiny-regex-c/commit/1a279e04014b70b0695fba559a7c05d55e6ee90b */\n    if (pattern[i] == 0)\n    {\n      return 0;\n    }\n\n    i += 1;\n    j += 1;\n  }\n  /* 'UNUSED' is a sentinel used to indicate end-of-pattern */\n  re_compiled[j].type = UNUSED;\n\n  return (re_t) re_compiled;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O2.pseudo", "function_name": "re_compile", "address": "0x2930", "label": "re_compile", "content": "re_t __fastcall re_compile(const char *pattern)\n{\n  char v1; // si\n  int v3; // r8d\n  int v4; // eax\n  regex_t *v5; // r9\n  int v6; // ebx\n  __int64 v7; // rdi\n  re_t result; // rax\n  int v9; // edi\n  int v10; // esi\n  __int64 v11; // r13\n  char v12; // dl\n  int v13; // edx\n  const char *v14; // rsi\n  char v15; // dl\n\n  v1 = *pattern;\n  if ( *pattern )\n  {\n    v3 = 0;\n    v4 = 0;\n    v5 = re_compiled_1;\n    v6 = 1;\n    v7 = 0LL;\n    while ( 1 )\n    {\n      switch ( v1 )\n      {\n        case '$':\n          v5->type = 3;\n          goto LABEL_5;\n        case '*':\n          v5->type = 5;\n          goto LABEL_5;\n        case '+':\n          v5->type = 6;\n          goto LABEL_5;\n        case '.':\n          v5->type = 1;\n          goto LABEL_5;\n        case '?':\n          v5->type = 4;\n          goto LABEL_5;\n        case '[':\n          if ( pattern[v7 + 1] == 94 )\n          {\n            v5->type = 9;\n            if ( !pattern[v7 + 2] )\n              return 0LL;\n            ++v4;\n          }\n          else\n          {\n            v5->type = 8;\n          }\n          v9 = v4 + 1;\n          v10 = v6;\n          v11 = v4 + 1;\n          v12 = pattern[v11];\n          if ( v12 && v12 != 93 )\n          {\n            do\n            {\n              if ( v12 == 92 )\n              {\n                if ( v10 > 38 || !pattern[v11 + 1] )\n                  return 0LL;\n                v13 = v10 + 1;\n                v4 += 2;\n                ccl_buf_0[v10] = 92;\n              }\n              else\n              {\n                if ( v10 > 39 )\n                  return 0LL;\n                v4 = v9;\n                v13 = v10;\n              }\n              v10 = v13 + 1;\n              ccl_buf_0[v13] = pattern[v4];\n              v9 = v4 + 1;\n              v11 = v4 + 1;\n              v12 = pattern[v11];\n            }\n            while ( v12 != 93 && v12 );\n          }\n          if ( v10 > 39 )\n            return 0LL;\n          ccl_buf_0[v10] = 0;\n          v4 = v9;\n          v5->u.ccl = &ccl_buf_0[v6];\n          v6 = v10 + 1;\nLABEL_5:\n          if ( !pattern[v4] )\n            return 0LL;\nLABEL_6:\n          ++v4;\n          ++v3;\n          v7 = v4;\n          v1 = pattern[v4];\n          if ( !v1 )\n            goto LABEL_8;\n          ++v5;\n          if ( v3 == 29 )\n            goto LABEL_8;\n          break;\n        case '\\\\':\n          v14 = &pattern[v7 + 1];\n          v15 = *v14;\n          if ( *v14 )\n          {\n            ++v4;\n            if ( v15 == 68 )\n            {\n              v5->type = 11;\n            }\n            else\n            {\n              switch ( v15 )\n              {\n                case 'S':\n                  v5->type = 15;\n                  break;\n                case 'W':\n                  v5->type = 13;\n                  break;\n                case 'd':\n                  v5->type = 10;\n                  break;\n                case 's':\n                  v5->type = 14;\n                  break;\n                case 'w':\n                  v5->type = 12;\n                  break;\n                default:\n                  v5->type = 7;\n                  v5->u.ch = *v14;\n                  break;\n              }\n            }\n          }\n          goto LABEL_5;\n        case '^':\n          v5->type = 2;\n          if ( !pattern[v4] )\n            return 0LL;\n          goto LABEL_6;\n        default:\n          v5->type = 7;\n          v5->u.ch = v1;\n          goto LABEL_5;\n      }\n    }\n  }\n  v3 = 0;\nLABEL_8:\n  result = re_compiled_1;\n  re_compiled_1[v3].type = 0;\n  return result;\n}\n"}, "pseudo_normalize": "re_t re_compile(const char *pattern) {\n  char v1;\n  int v3;\n  int v4;\n  regex_t *v5;\n  int v6;\n  long long v7;\n  re_t result;\n  int v9;\n  int v10;\n  long long v11;\n  char v12;\n  int v13;\n  const char *v14;\n  char v15;\n  v1 = *pattern;\n  if (*pattern) {\n    v3 = 0;\n    v4 = 0;\n    v5 = re_compiled_1;\n    v6 = 1;\n    v7 = 0LL;\n    while (1) {\n      switch (v1) {\n        case '$':\n          v5->type = 3;\n          goto LABEL_5;\n        case '*':\n          v5->type = 5;\n          goto LABEL_5;\n        case '+':\n          v5->type = 6;\n          goto LABEL_5;\n        case '.':\n          v5->type = 1;\n          goto LABEL_5;\n        case '?':\n          v5->type = 4;\n          goto LABEL_5;\n        case '[':\n          if (pattern[v7 + 1] == 94) {\n            v5->type = 9;\n            if (!pattern[v7 + 2]) return 0LL;\n            ++v4;\n          } else {\n            v5->type = 8;\n          }\n          v9 = v4 + 1;\n          v10 = v6;\n          v11 = v4 + 1;\n          v12 = pattern[v11];\n          if (v12 && v12 != 93) {\n            do {\n              if (v12 == 92) {\n                if (v10 > 38 || !pattern[v11 + 1]) return 0LL;\n                v13 = v10 + 1;\n                v4 += 2;\n                ccl_buf_0[v10] = 92;\n              } else {\n                if (v10 > 39) return 0LL;\n                v4 = v9;\n                v13 = v10;\n              }\n              v10 = v13 + 1;\n              ccl_buf_0[v13] = pattern[v4];\n              v9 = v4 + 1;\n              v11 = v4 + 1;\n              v12 = pattern[v11];\n            } while (v12 != 93 && v12);\n          }\n          if (v10 > 39) return 0LL;\n          ccl_buf_0[v10] = 0;\n          v4 = v9;\n          v5->u.ccl = &ccl_buf_0[v6];\n          v6 = v10 + 1;\n        LABEL_5:\n          if (!pattern[v4]) return 0LL;\n        LABEL_6:\n          ++v4;\n          ++v3;\n          v7 = v4;\n          v1 = pattern[v4];\n          if (!v1) goto LABEL_8;\n          ++v5;\n          if (v3 == 29) goto LABEL_8;\n          break;\n        case '\\\\':\n          v14 = &pattern[v7 + 1];\n          v15 = *v14;\n          if (*v14) {\n            ++v4;\n            if (v15 == 68) {\n              v5->type = 11;\n            } else {\n              switch (v15) {\n                case 'S':\n                  v5->type = 15;\n                  break;\n                case 'W':\n                  v5->type = 13;\n                  break;\n                case 'd':\n                  v5->type = 10;\n                  break;\n                case 's':\n                  v5->type = 14;\n                  break;\n                case 'w':\n                  v5->type = 12;\n                  break;\n                default:\n                  v5->type = 7;\n                  v5->u.ch = *v14;\n                  break;\n              }\n            }\n          }\n          goto LABEL_5;\n        case '^':\n          v5->type = 2;\n          if (!pattern[v4]) return 0LL;\n          goto LABEL_6;\n        default:\n          v5->type = 7;\n          v5->u.ch = v1;\n          goto LABEL_5;\n      }\n    }\n  }\n  v3 = 0;\nLABEL_8:\n  result = re_compiled_1;\n  re_compiled_1[v3].type = 0;\n  return result;\n}", "binary": "regex-parser/regex-parser.host.O2", "assembly": "<re_compile>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmovzbl (%rdi),%esi\ntest   %sil,%sil\nje     2ba6 <re_compile+0x276>\nlea    0x61f3(%rip),%rbp\nmov    %rdi,%rcx\nxor    %r8d,%r8d\nxor    %eax,%eax\nmov    %rbp,%r9\nmov    $0x1,%ebx\nxor    %edi,%edi\nlea    0x2772(%rip),%r11\nlea    0x6193(%rip),%r10\nlea    0x2850(%rip),%r12\nnopl   0x0(%rax)\nlea    -0x24(%rsi),%edx\ncmp    $0x3a,%dl\nja     2990 <re_compile+0x60>\nmovzbl %dl,%edx\nmovslq (%r11,%rdx,4),%rdx\nadd    %r11,%rdx\nnotrack jmp *%rdx\nnopl   (%rax)\nmovb   $0x7,(%r9)\nmov    %sil,0x8(%r9)\nnopl   0x0(%rax,%rax,1)\nmovslq %eax,%rdx\ncmpb   $0x0,(%rcx,%rdx,1)\nje     29f5 <re_compile+0xc5>\nadd    $0x1,%eax\nadd    $0x1,%r8d\nmovslq %eax,%rdi\nmovzbl (%rcx,%rdi,1),%esi\ntest   %sil,%sil\nje     29c6 <re_compile+0x96>\nadd    $0x10,%r9\ncmp    $0x1d,%r8d\njne    2978 <re_compile+0x48>\nmovslq %r8d,%r8\npop    %rbx\nlea    0x616f(%rip),%rax\nshl    $0x4,%r8\nmovb   $0x0,0x0(%rbp,%r8,1)\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nmovslq %eax,%rdx\nmovb   $0x2,(%r9)\ncmpb   $0x0,(%rcx,%rdx,1)\njne    29a9 <re_compile+0x79>\npop    %rbx\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\nxchg   %ax,%ax\nmovb   $0x1,(%r9)\njmp    29a0 <re_compile+0x70>\ncs nopw 0x0(%rax,%rax,1)\nmovb   $0x6,(%r9)\njmp    29a0 <re_compile+0x70>\ncs nopw 0x0(%rax,%rax,1)\nmovb   $0x5,(%r9)\njmp    29a0 <re_compile+0x70>\nnopl   0x0(%rax)\nmovb   $0x3,(%r9)\njmp    29a0 <re_compile+0x70>\nnopl   0x0(%rax)\ncmpb   $0x5e,0x1(%rcx,%rdi,1)\nje     2b40 <re_compile+0x210>\nmovb   $0x8,(%r9)\nlea    0x1(%rax),%edi\nmov    %ebx,%esi\nmovslq %edi,%r13\nmovzbl (%rcx,%r13,1),%edx\ntest   %dl,%dl\nje     2b18 <re_compile+0x1e8>\ncmp    $0x5d,%dl\njne    2a9e <re_compile+0x16e>\njmp    2b18 <re_compile+0x1e8>\nxchg   %ax,%ax\ncmp    $0x27,%esi\njg     29f5 <re_compile+0xc5>\nmov    %edi,%eax\nmov    %esi,%edx\nmovslq %eax,%rdi\nlea    0x1(%rdx),%esi\nmovslq %edx,%rdx\nmovzbl (%rcx,%rdi,1),%edi\nmov    %dil,(%r10,%rdx,1)\nlea    0x1(%rax),%edi\nmovslq %edi,%r13\nmovzbl (%rcx,%r13,1),%edx\ncmp    $0x5d,%dl\nje     2b18 <re_compile+0x1e8>\ntest   %dl,%dl\nje     2b18 <re_compile+0x1e8>\ncmp    $0x5c,%dl\njne    2a70 <re_compile+0x140>\ncmp    $0x26,%esi\njg     29f5 <re_compile+0xc5>\ncmpb   $0x0,0x1(%rcx,%r13,1)\nje     29f5 <re_compile+0xc5>\nlea    0x1(%rsi),%edx\nmovslq %esi,%rsi\nadd    $0x2,%eax\nmovb   $0x5c,(%r10,%rsi,1)\njmp    2a79 <re_compile+0x149>\nnopl   0x0(%rax,%rax,1)\nmovb   $0x4,(%r9)\njmp    29a0 <re_compile+0x70>\nnopl   0x0(%rax)\nlea    0x1(%rcx,%rdi,1),%rsi\nmovzbl (%rsi),%edx\ntest   %dl,%dl\nje     29a0 <re_compile+0x70>\nadd    $0x1,%eax\ncmp    $0x44,%dl\nje     2b9d <re_compile+0x26d>\nsub    $0x53,%edx\ncmp    $0x24,%dl\nja     2b60 <re_compile+0x230>\nmovzbl %dl,%edx\nmovslq (%r12,%rdx,4),%rdx\nadd    %r12,%rdx\nnotrack jmp *%rdx\nnopl   0x0(%rax)\ncmp    $0x27,%esi\njg     29f5 <re_compile+0xc5>\nmovslq %ebx,%rbx\nmovslq %esi,%rax\nadd    %r10,%rbx\nmovb   $0x0,(%r10,%rax,1)\nmov    %edi,%eax\nmov    %rbx,0x8(%r9)\nlea    0x1(%rsi),%ebx\njmp    29a0 <re_compile+0x70>\nnopl   (%rax)\nmovb   $0x9,(%r9)\ncmpb   $0x0,0x2(%rcx,%rdi,1)\nje     29f5 <re_compile+0xc5>\nadd    $0x1,%eax\njmp    2a4f <re_compile+0x11f>\nnopw   0x0(%rax,%rax,1)\nmovb   $0x7,(%r9)\nmovzbl (%rsi),%edx\nmov    %dl,0x8(%r9)\njmp    29a0 <re_compile+0x70>\nmovb   $0xc,(%r9)\njmp    29a0 <re_compile+0x70>\nmovb   $0xe,(%r9)\njmp    29a0 <re_compile+0x70>\nmovb   $0xa,(%r9)\njmp    29a0 <re_compile+0x70>\nmovb   $0xd,(%r9)\njmp    29a0 <re_compile+0x70>\nmovb   $0xf,(%r9)\njmp    29a0 <re_compile+0x70>\nmovb   $0xb,(%r9)\njmp    29a0 <re_compile+0x70>\nxor    %r8d,%r8d\nlea    0x5f90(%rip),%rbp\njmp    29c6 <re_compile+0x96>\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "re_match", "content": "/* Public functions: */\nint re_match(const char* pattern, const char* text, int* matchlength)\n{\n  return re_matchp(re_compile(pattern), text, matchlength);\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O2.pseudo", "function_name": "re_match", "address": "0x2bc0", "label": "re_match", "content": "int __fastcall re_match(const char *pattern, const char *text, int *matchlength)\n{\n  regex_t *v4; // rax\n\n  v4 = re_compile(pattern);\n  return re_matchp(v4, text, matchlength);\n}\n"}, "pseudo_normalize": "", "binary": "regex-parser/regex-parser.host.O2", "assembly": "<re_match>:\nendbr64\npush   %r12\nmov    %rdx,%r12\npush   %rbp\nmov    %rsi,%rbp\nsub    $0x8,%rsp\ncall   2930 <re_compile>\nadd    $0x8,%rsp\nmov    %r12,%rdx\nmov    %rbp,%rsi\nmov    %rax,%rdi\npop    %rbp\npop    %r12\njmp    2890 <re_matchp>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "re_matchp", "content": "int re_matchp(re_t pattern, const char* text, int* matchlength)\n{\n  *matchlength = 0;\n  if (pattern != 0)\n  {\n    if (pattern[0].type == BEGIN)\n    {\n      return ((matchpattern(&pattern[1], text, matchlength)) ? 0 : -1);\n    }\n    else\n    {\n      int idx = -1;\n\n      do\n      {\n        idx += 1;\n\n        if (matchpattern(pattern, text, matchlength))\n        {\n          if (text[0] == '\\0')\n            return -1;\n\n          return idx;\n        }\n      }\n      while (*text++ != '\\0');\n    }\n  }\n  return -1;\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O2.pseudo", "function_name": "re_matchp", "address": "0x2890", "label": "re_matchp", "content": "int __fastcall re_matchp(re_t pattern, const char *text, int *matchlength)\n{\n  const char *v3; // rbp\n  int v5; // r12d\n\n  *matchlength = 0;\n  if ( !pattern )\n    return -1;\n  v3 = text;\n  v5 = -1;\n  if ( pattern->type == 2 )\n    return -(matchpattern(pattern + 1, text, matchlength) == 0);\n  while ( 1 )\n  {\n    ++v5;\n    if ( matchpattern(pattern, v3, matchlength) )\n      break;\n    if ( !*v3++ )\n      return -1;\n  }\n  if ( *v3 )\n    return v5;\n  else\n    return -1;\n}\n"}, "pseudo_normalize": "int re_matchp(re_t pattern, const char *text, int *matchlength) {\n  const char *v3;\n  int v5;\n  *matchlength = 0;\n  if (!pattern) return -1;\n  v3 = text;\n  v5 = -1;\n  if (pattern->type == 2)\n    return -(matchpattern(pattern + 1, text, matchlength) == 0);\n  while (1) {\n    ++v5;\n    if (matchpattern(pattern, v3, matchlength)) break;\n    if (!*v3++) return -1;\n  }\n  if (*v3)\n    return v5;\n  else\n    return -1;\n}", "binary": "regex-parser/regex-parser.host.O2", "assembly": "<re_matchp>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x8,%rsp\nmovl   $0x0,(%rdx)\ntest   %rdi,%rdi\nje     28f8 <re_matchp+0x68>\ncmpb   $0x2,(%rdi)\nmov    %rdi,%rbx\nmov    %rsi,%rbp\nmov    %rdx,%r13\nmov    $0xffffffff,%r12d\njne    28ca <re_matchp+0x3a>\njmp    2910 <re_matchp+0x80>\nnop\nadd    $0x1,%rbp\ncmpb   $0x0,-0x1(%rbp)\nje     28f8 <re_matchp+0x68>\nmov    %r13,%rdx\nmov    %rbp,%rsi\nmov    %rbx,%rdi\nadd    $0x1,%r12d\ncall   2670 <matchpattern>\ntest   %eax,%eax\nje     28c0 <re_matchp+0x30>\ncmpb   $0x0,0x0(%rbp)\nje     28f8 <re_matchp+0x68>\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nadd    $0x8,%rsp\nmov    $0xffffffff,%r12d\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nlea    0x10(%rdi),%rdi\ncall   2670 <matchpattern>\ncmp    $0x1,%eax\nsbb    %r12d,%r12d\nadd    $0x8,%rsp\npop    %rbx\nmov    %r12d,%eax\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   (%rax)\n"}
{"source": {"path": "regex-parser/regex-parser.c", "function_name": "re_print", "content": "void re_print(regex_t* pattern)\n{\n  const char* types[] = { \"UNUSED\", \"DOT\", \"BEGIN\", \"END\", \"QUESTIONMARK\", \"STAR\", \"PLUS\", \"CHAR\", \"CHAR_CLASS\", \"INV_CHAR_CLASS\", \"DIGIT\", \"NOT_DIGIT\", \"ALPHA\", \"NOT_ALPHA\", \"WHITESPACE\", \"NOT_WHITESPACE\", \"BRANCH\" };\n\n  int i;\n  int j;\n  char c;\n  for (i = 0; i < MAX_REGEXP_OBJECTS; ++i)\n  {\n    if (pattern[i].type == UNUSED)\n    {\n      break;\n    }\n\n    libmin_printf(\"type: %s\", types[pattern[i].type]);\n    if (pattern[i].type == CHAR_CLASS || pattern[i].type == INV_CHAR_CLASS)\n    {\n      libmin_printf(\" [\");\n      for (j = 0; j < MAX_CHAR_CLASS_LEN; ++j)\n      {\n        c = pattern[i].u.ccl[j];\n        if ((c == '\\0') || (c == ']'))\n        {\n          break;\n        }\n        libmin_printf(\"%c\", c);\n      }\n      libmin_printf(\"]\");\n    }\n    else if (pattern[i].type == CHAR)\n    {\n      libmin_printf(\" '%c'\", pattern[i].u.ch);\n    }\n    libmin_printf(\"\\n\");\n  }\n}\n"}, "pseudo": {"path": "regex-parser/regex-parser.host.O2.pseudo", "function_name": "re_print", "address": "0x2bf0", "label": "re_print", "content": "void __fastcall re_print(regex_t *pattern)\n{\n  regex_t *v1; // r14\n  __int64 type; // rax\n  __int64 v3; // r15\n  unsigned __int8 *ccl; // rax\n  __int64 v5; // rsi\n  const char *types[17]; // [rsp+0h] [rbp-C8h]\n  unsigned __int64 v7; // [rsp+88h] [rbp-40h]\n\n  v1 = pattern;\n  v7 = __readfsqword(0x28u);\n  types[1] = (const char *)&unk_5258;\n  types[2] = \"BEGIN\";\n  types[3] = \"END\";\n  types[4] = \"QUESTIONMARK\";\n  types[5] = \"STAR\";\n  types[6] = \"PLUS\";\n  types[7] = \"CHAR\";\n  types[8] = \"CHAR_CLASS\";\n  types[9] = \"INV_CHAR_CLASS\";\n  types[10] = \"DIGIT\";\n  types[11] = \"NOT_DIGIT\";\n  types[12] = \"ALPHA\";\n  types[13] = \"NOT_ALPHA\";\n  types[14] = \"WHITESPACE\";\n  types[15] = \"NOT_WHITESPACE\";\n  types[16] = \"BRANCH\";\n  do\n  {\n    type = v1->type;\n    if ( !(_BYTE)type )\n      break;\n    libmin_printf(\"type: %s\", types[type]);\n    if ( (unsigned __int8)(v1->type - 8) <= 1u )\n    {\n      v3 = 0LL;\n      libmin_printf(\" [\");\n      do\n      {\n        ccl = v1->u.ccl;\n        v5 = (unsigned int)(char)ccl[v3];\n        if ( !ccl[v3] )\n          break;\n        if ( ccl[v3] == 93 )\n          break;\n        ++v3;\n        libmin_printf(\"%c\", v5);\n      }\n      while ( v3 != 40 );\n      libmin_printf(\"]\");\n    }\n    else if ( v1->type == 7 )\n    {\n      libmin_printf(\" '%c'\", v1->u.ch);\n    }\n    ++v1;\n    libmin_printf(\"\\n\");\n  }\n  while ( &pattern[30] != v1 );\n}\n"}, "pseudo_normalize": "void re_print(regex_t *pattern) {\n  regex_t *v1;\n  long long type;\n  long long v3;\n  unsigned char *ccl;\n  long long v5;\n  const char *types[17];\n  unsigned long long v7;\n  v1 = pattern;\n  v7 = __readfsqword(40u);\n  types[1] = (const char *)&unk_5258;\n  types[2] = \"BEGIN\";\n  types[3] = \"END\";\n  types[4] = \"QUESTIONMARK\";\n  types[5] = \"STAR\";\n  types[6] = \"PLUS\";\n  types[7] = \"CHAR\";\n  types[8] = \"CHAR_CLASS\";\n  types[9] = \"INV_CHAR_CLASS\";\n  types[10] = \"DIGIT\";\n  types[11] = \"NOT_DIGIT\";\n  types[12] = \"ALPHA\";\n  types[13] = \"NOT_ALPHA\";\n  types[14] = \"WHITESPACE\";\n  types[15] = \"NOT_WHITESPACE\";\n  types[16] = \"BRANCH\";\n  do {\n    type = v1->type;\n    if (!(uint8_t)type) break;\n    libmin_printf(\"type: %s\", types[type]);\n    if ((unsigned char)(v1->type - 8) <= 1u) {\n      v3 = 0LL;\n      libmin_printf(\" [\");\n      do {\n        ccl = v1->u.ccl;\n        v5 = (unsigned int)(char)ccl[v3];\n        if (!ccl[v3]) break;\n        if (ccl[v3] == 93) break;\n        ++v3;\n        libmin_printf(\"%c\", v5);\n      } while (v3 != 40);\n      libmin_printf(\"]\");\n    } else if (v1->type == 7) {\n      libmin_printf(\" '%c'\", v1->u.ch);\n    }\n    ++v1;\n    libmin_printf(\"\\n\");\n  } while (&pattern[30] != v1);\n}", "binary": "regex-parser/regex-parser.host.O2", "assembly": "<re_print>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\nlea    0x26c6(%rip),%r13\npush   %r12\nlea    0x1e0(%rdi),%r12\npush   %rbp\nlea    0x26a6(%rip),%rbp\npush   %rbx\nlea    0x26aa(%rip),%rbx\nsub    $0x98,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x88(%rsp)\nlea    0x261c(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x2614(%rip),%rax\nmov    %rax,0x10(%rsp)\nlea    0x260e(%rip),%rax\nmov    %rax,0x18(%rsp)\nlea    0x2606(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0x2607(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0x2600(%rip),%rax\nmov    %rax,0x30(%rsp)\nlea    0x25f9(%rip),%rax\nmov    %rax,0x38(%rsp)\nlea    0x25f6(%rip),%rax\nmov    %rax,0x40(%rsp)\nlea    0x25e6(%rip),%rax\nmov    %rax,0x48(%rsp)\nlea    0x25ed(%rip),%rax\nmov    %rax,0x50(%rsp)\nlea    0x25dd(%rip),%rax\nmov    %rax,0x58(%rsp)\nlea    0x25df(%rip),%rax\nmov    %rax,0x60(%rsp)\nlea    0x25cf(%rip),%rax\nmov    %rax,0x68(%rsp)\nlea    0x25d1(%rip),%rax\nmov    %rax,0x70(%rsp)\nlea    0x25c1(%rip),%rax\nmov    %rax,0x78(%rsp)\nlea    0x25c4(%rip),%rax\nmov    %rax,0x80(%rsp)\njmp    2d1b <re_print+0x12b>\nnopw   0x0(%rax,%rax,1)\nlea    0x26f3(%rip),%rdi\nxor    %eax,%eax\nadd    $0x10,%r14\ncall   4360 <libmin_printf>\ncmp    %r14,%r12\nje     2db8 <re_print+0x1c8>\nmovzbl (%r14),%eax\ntest   %al,%al\nje     2db8 <re_print+0x1c8>\nmov    (%rsp,%rax,8),%rsi\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   4360 <libmin_printf>\nmovzbl (%r14),%eax\nlea    -0x8(%rax),%edx\ncmp    $0x1,%dl\njbe    2d60 <re_print+0x170>\ncmp    $0x7,%al\njne    2d00 <re_print+0x110>\nmovzbl 0x8(%r14),%esi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   4360 <libmin_printf>\njmp    2d00 <re_print+0x110>\ncs nopw 0x0(%rax,%rax,1)\nlea    0x255d(%rip),%rdi\nxor    %eax,%eax\nxor    %r15d,%r15d\ncall   4360 <libmin_printf>\njmp    2d92 <re_print+0x1a2>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x5d,%sil\nje     2da0 <re_print+0x1b0>\nmov    %rbx,%rdi\nxor    %eax,%eax\nadd    $0x1,%r15\ncall   4360 <libmin_printf>\ncmp    $0x28,%r15\nje     2da0 <re_print+0x1b0>\nmov    0x8(%r14),%rax\nmovsbl (%rax,%r15,1),%esi\ntest   %sil,%sil\njne    2d78 <re_print+0x188>\nlea    0x25e2(%rip),%rdi\nxor    %eax,%eax\ncall   4360 <libmin_printf>\njmp    2d00 <re_print+0x110>\nnopl   0x0(%rax,%rax,1)\nmov    0x88(%rsp),%rax\nsub    %fs:0x28,%rax\njne    2ddd <re_print+0x1ed>\nadd    $0x98,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   20b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "rho-factor/rho-factor.c", "function_name": "factor", "content": "// fill the given array with prime factors of n, result will be zero terminated.\npositive_number * factor(positive_number n, positive_number *array) {\n    positive_number a, b; size_t s ;\n    do  if (n < 4)\n            *array++ = n, n = 1;\n        else if (n & 1) {\n            for (b = n >> 1, a = (b + n / b) >> 1; a < b; b = a, a = (b + n / b) >> 1);\n            if (b * b == n) {\n                s = factor(b, array) - array ;\n                libmin_memcpy(array + s, array, s * sizeof(positive_number)) ;\n                array += s + s ;\n                n = 1;\n            } else {\n                if (is_prime(n, 24)) // number of Miller-Rabin iterations.\n                    *array++ = n, n = 1;\n                else {\n                    a = factor_worker(n); // factor_worker can't be called with a prime.\n                    array = factor(a, array);\n                    n /= a;\n                }\n            }\n        } else\n            for (; !(n & 1); *array++ = 2, n >>= 1);\n    while (n > 1);\n    *array = 0 ;\n    return array ;\n}\n"}, "pseudo": {"path": "rho-factor/rho-factor.host.O2.pseudo", "function_name": "factor", "address": "0x35e0", "label": "factor", "content": "positive_number *__fastcall factor(positive_number n, positive_number *array)\n{\n  positive_number v4; // rdi\n  positive_number v5; // rcx\n  positive_number v6; // rbx\n  positive_number *result; // rax\n  positive_number *v8; // rax\n  __int64 v9; // rbx\n\n  while ( 1 )\n  {\n    if ( n <= 3 )\n    {\nLABEL_12:\n      result = array + 1;\n      *array = n;\n      array[1] = 0LL;\n      return result;\n    }\n    if ( (n & 1) == 0 )\n    {\n      do\n      {\n        n >>= 1;\n        *array++ = 2LL;\n      }\n      while ( (n & 1) == 0 );\n      goto LABEL_8;\n    }\n    v4 = n >> 1;\n    v5 = (n / (n >> 1) + (n >> 1)) >> 1;\n    if ( n >> 1 > v5 )\n    {\n      do\n      {\n        v4 = v5;\n        v5 = (v5 + n / v5) >> 1;\n      }\n      while ( v5 < v4 );\n    }\n    if ( n == v4 * v4 )\n      break;\n    if ( is_prime(n, 24) )\n      goto LABEL_12;\n    v6 = factor_worker(n);\n    array = factor(v6, array);\n    n /= v6;\nLABEL_8:\n    if ( n <= 1 )\n    {\n      result = array;\n      *array = 0LL;\n      return result;\n    }\n  }\n  v8 = factor(v4, array);\n  v9 = v8 - array;\n  libmin_memcpy(v8, array, (char *)v8 - (char *)array);\n  result = &array[2 * v9];\n  *result = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "positive_number *factor(positive_number n, positive_number *array) {\n  positive_number v4;\n  positive_number v5;\n  positive_number v6;\n  positive_number *result;\n  positive_number *v8;\n  long long v9;\n  while (1) {\n    if (n <= 3) {\n    LABEL_12:\n      result = array + 1;\n      *array = n;\n      array[1] = 0LL;\n      return result;\n    }\n    if ((n & 1) == 0) {\n      do {\n        n >>= 1;\n        *array++ = 2LL;\n      } while ((n & 1) == 0);\n      goto LABEL_8;\n    }\n    v4 = n >> 1;\n    v5 = (n / (n >> 1) + (n >> 1)) >> 1;\n    if (n >> 1 > v5) {\n      do {\n        v4 = v5;\n        v5 = (v5 + n / v5) >> 1;\n      } while (v5 < v4);\n    }\n    if (n == v4 * v4) break;\n    if (is_prime(n, 24)) goto LABEL_12;\n    v6 = factor_worker(n);\n    array = factor(v6, array);\n    n /= v6;\n  LABEL_8:\n    if (n <= 1) {\n      result = array;\n      *array = 0LL;\n      return result;\n    }\n  }\n  v8 = factor(v4, array);\n  v9 = v8 - array;\n  libmin_memcpy(v8, array, (char *)v8 - (char *)array);\n  result = &array[2 * v9];\n  *result = 0LL;\n  return result;\n}", "binary": "rho-factor/rho-factor.host.O2", "assembly": "<factor>:\nendbr64\npush   %r12\nmov    %rdi,%r12\npush   %rbp\nmov    %rsi,%rbp\npush   %rbx\nxchg   %ax,%ax\ncmp    $0x3,%r12\njbe    36b0 <factor+0xd0>\ntest   $0x1,%r12b\nje     3698 <factor+0xb8>\nmov    %r12,%rdi\nmov    %r12,%rax\nxor    %edx,%edx\nshr    %rdi\ndiv    %rdi\nlea    (%rax,%rdi,1),%rcx\nshr    %rcx\ncmp    %rcx,%rdi\njbe    3639 <factor+0x59>\nxchg   %ax,%ax\nmov    %r12,%rax\nxor    %edx,%edx\nmov    %rcx,%rdi\ndiv    %rcx\nadd    %rcx,%rax\nshr    %rax\nmov    %rax,%rcx\ncmp    %rdi,%rax\njb     3620 <factor+0x40>\nmov    %rdi,%rax\nimul   %rdi,%rax\ncmp    %rax,%r12\nje     36c4 <factor+0xe4>\nmov    $0x18,%esi\nmov    %r12,%rdi\ncall   1400 <is_prime>\ntest   %eax,%eax\njne    36b0 <factor+0xd0>\nmov    %r12,%rdi\ncall   34d0 <factor_worker>\nmov    %rbp,%rsi\nmov    %rax,%rdi\nmov    %rax,%rbx\ncall   35e0 <factor>\nxor    %edx,%edx\nmov    %rax,%rbp\nmov    %r12,%rax\ndiv    %rbx\nmov    %rax,%r12\ncmp    $0x1,%r12\nja     35f0 <factor+0x10>\nmov    %rbp,%rax\nmovq   $0x0,(%rax)\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopl   0x0(%rax,%rax,1)\nshr    %r12\nadd    $0x8,%rbp\nmovq   $0x2,-0x8(%rbp)\ntest   $0x1,%r12b\nje     3698 <factor+0xb8>\njmp    367a <factor+0x9a>\nnop\nlea    0x8(%rbp),%rax\nmov    %r12,0x0(%rbp)\nmovq   $0x0,(%rax)\npop    %rbx\npop    %rbp\npop    %r12\nret\nmov    %rbp,%rsi\ncall   35e0 <factor>\nmov    %rbp,%rsi\nmov    %rax,%rbx\nmov    %rax,%rdi\nsub    %rbp,%rbx\nmov    %rbx,%rdx\nsar    $0x3,%rbx\ncall   3b30 <libmin_memcpy>\nshl    $0x4,%rbx\nlea    0x0(%rbp,%rbx,1),%rax\nmovq   $0x0,(%rax)\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "rho-factor/rho-factor.c", "function_name": "factor_worker", "content": "positive_number factor_worker(const positive_number n) {\n    size_t a = -1, b = 2 ;\n    positive_number c, d = 1 + libmin_rand(), e, f;\n    c = d %= n;\n    do {\n        if (++a == b){\n            // handle your timeout here, when (a == 1 << 20) or another power of two.\n            d = c, b <<= 1, a = 0;\n        }\n        c = multiplication_modulo(c, c, n);\n        for (++c, c *= c != n, e = n, f = c > d ? c - d : d - c; (f %= e) && (e %= f););\n    } while ((f |= e) == 1);\n    return f;\n}\n"}, "pseudo": {"path": "rho-factor/rho-factor.host.O2.pseudo", "function_name": "factor_worker", "address": "0x34d0", "label": "factor_worker", "content": "positive_number __fastcall factor_worker(const positive_number n)\n{\n  unsigned int v2; // eax\n  __int64 v3; // r10\n  __int64 v4; // r9\n  positive_number v5; // rsi\n  positive_number v6; // rdi\n  positive_number v7; // rdx\n  unsigned __int64 v8; // rax\n  positive_number v9; // rcx\n  positive_number v10; // rdx\n  positive_number v11; // r8\n  positive_number v12; // rcx\n  positive_number v13; // rdx\n\n  v2 = libmin_rand();\n  v3 = 2LL;\n  v4 = 0LL;\n  v5 = (v2 + 1) % n;\n  v6 = v5;\nLABEL_2:\n  v7 = v5 % n;\n  if ( v5 )\n  {\nLABEL_3:\n    v8 = 0LL;\n    do\n    {\n      if ( (v5 & 1) != 0 )\n      {\n        if ( n - v8 <= v7 )\n          v8 -= n;\n        v8 += v7;\n      }\n      v9 = v7 - n;\n      if ( n - v7 > v7 )\n        v9 = v7;\n      v7 += v9;\n      v5 >>= 1;\n    }\n    while ( v5 );\n    v10 = v8 % n + 1;\n  }\n  else\n  {\nLABEL_20:\n    v10 = 1LL;\n  }\n  v11 = n;\n  v5 = v10 * (n != v10);\n  v12 = v6 - v5;\n  if ( v6 < v5 )\n    v12 = v5 - v6;\n  do\n  {\n    v13 = v12 % v11;\n    v12 = v13;\n    if ( !v13 )\n    {\n      if ( v11 != 1 )\n        return v11;\nLABEL_18:\n      if ( v3 != ++v4 )\n        goto LABEL_2;\n      v3 *= 2LL;\n      v6 = v5;\n      v7 = v5 % n;\n      v4 = 0LL;\n      if ( v5 )\n        goto LABEL_3;\n      goto LABEL_20;\n    }\n    v11 %= v13;\n  }\n  while ( v11 );\n  v11 = v13;\n  if ( v13 == 1 )\n    goto LABEL_18;\n  return v11;\n}\n"}, "pseudo_normalize": "positive_number factor_worker(const positive_number n) {\n  unsigned int v2;\n  long long v3;\n  long long v4;\n  positive_number v5;\n  positive_number v6;\n  positive_number v7;\n  unsigned long long v8;\n  positive_number v9;\n  positive_number v10;\n  positive_number v11;\n  positive_number v12;\n  positive_number v13;\n  v2 = libmin_rand();\n  v3 = 2LL;\n  v4 = 0LL;\n  v5 = (v2 + 1) % n;\n  v6 = v5;\nLABEL_2:\n  v7 = v5 % n;\n  if (v5) {\n  LABEL_3:\n    v8 = 0LL;\n    do {\n      if ((v5 & 1) != 0) {\n        if (n - v8 <= v7) v8 -= n;\n        v8 += v7;\n      }\n      v9 = v7 - n;\n      if (n - v7 > v7) v9 = v7;\n      v7 += v9;\n      v5 >>= 1;\n    } while (v5);\n    v10 = v8 % n + 1;\n  } else {\n  LABEL_20:\n    v10 = 1LL;\n  }\n  v11 = n;\n  v5 = v10 * (n != v10);\n  v12 = v6 - v5;\n  if (v6 < v5) v12 = v5 - v6;\n  do {\n    v13 = v12 % v11;\n    v12 = v13;\n    if (!v13) {\n      if (v11 != 1) return v11;\n    LABEL_18:\n      if (v3 != ++v4) goto LABEL_2;\n      v3 *= 2LL;\n      v6 = v5;\n      v7 = v5 % n;\n      v4 = 0LL;\n      if (v5) goto LABEL_3;\n      goto LABEL_20;\n    }\n    v11 %= v13;\n  } while (v11);\n  v11 = v13;\n  if (v13 == 1) goto LABEL_18;\n  return v11;\n}", "binary": "rho-factor/rho-factor.host.O2", "assembly": "<factor_worker>:\nendbr64\npush   %rbx\nmov    %rdi,%rbx\ncall   51a0 <libmin_rand>\nxor    %edx,%edx\nmov    $0x2,%r10d\nxor    %r9d,%r9d\nadd    $0x1,%eax\ndiv    %rbx\nmov    %rdx,%rsi\nmov    %rdx,%rdi\nnopl   0x0(%rax)\nmov    %rsi,%rax\nxor    %edx,%edx\ndiv    %rbx\ntest   %rsi,%rsi\nje     35c5 <factor_worker+0xf5>\nxor    %eax,%eax\nnopl   0x0(%rax,%rax,1)\ntest   $0x1,%sil\nje     352c <factor_worker+0x5c>\nmov    %rbx,%r8\nmov    %rax,%rcx\nsub    %rax,%r8\nsub    %rbx,%rcx\ncmp    %rdx,%r8\ncmovbe %rcx,%rax\nadd    %rdx,%rax\nmov    %rbx,%r8\nmov    %rdx,%rcx\nsub    %rdx,%r8\nsub    %rbx,%rcx\ncmp    %rdx,%r8\ncmova  %rdx,%rcx\nadd    %rcx,%rdx\nshr    %rsi\njne    3510 <factor_worker+0x40>\nxor    %edx,%edx\ndiv    %rbx\nadd    $0x1,%rdx\nxor    %esi,%esi\ncmp    %rdx,%rbx\nmov    %rdi,%rcx\nmov    %rbx,%r8\nsetne  %sil\nimul   %rdx,%rsi\nmov    %rsi,%rax\nsub    %rsi,%rcx\nsub    %rdi,%rax\ncmp    %rsi,%rdi\ncmovb  %rax,%rcx\njmp    3588 <factor_worker+0xb8>\nnopl   (%rax)\nmov    %r8,%rax\nxor    %edx,%edx\ndiv    %rcx\nmov    %rdx,%r8\ntest   %rdx,%rdx\nje     35d0 <factor_worker+0x100>\nmov    %rcx,%rax\nxor    %edx,%edx\ndiv    %r8\nmov    %rdx,%rcx\ntest   %rdx,%rdx\njne    3578 <factor_worker+0xa8>\ncmp    $0x1,%r8\njne    35d9 <factor_worker+0x109>\nadd    $0x1,%r9\ncmp    %r9,%r10\njne    34f8 <factor_worker+0x28>\nmov    %rsi,%rax\nxor    %edx,%edx\nadd    %r10,%r10\nmov    %rsi,%rdi\ndiv    %rbx\nxor    %r9d,%r9d\ntest   %rsi,%rsi\njne    3509 <factor_worker+0x39>\nmov    $0x1,%edx\njmp    3550 <factor_worker+0x80>\nnopl   0x0(%rax)\nmov    %rcx,%r8\ncmp    $0x1,%r8\nje     359e <factor_worker+0xce>\nmov    %r8,%rax\npop    %rbx\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "rho-factor/rho-factor.c", "function_name": "is_prime", "content": "static int is_prime(positive_number n, int k) {\n    positive_number a = 0, b, c, d, e, f, g; int h, i;\n    if ((n == 1) == (n & 1)) return n == 2;\n    if (n < 4669921) // fast constexpr for small primes (this line is removable).\n        return ((n & 1) & ((n < 6) * 42 + 0x208A2882) >> n % 30 && (n < 49 || (n % 7 && n % 11 && n % 13 && n % 17 && n % 19 && n % 23 && n % 29 && (n < 961 || (n % 31 && n % 37 && n % 41 && n % 43 && n % 47 && n % 53 && n % 59 && n % 61 && n % 67 && (n < 5041 || (n % 71 && n % 73 && n % 79 && n % 83 && n % 89 && n % 97 && n % 101 && n % 103 && n % 107 && (n < 11881 || (n % 109 && n % 113 && n % 127 && n % 131 && n % 137 && n % 139 && n % 149 && n % 151 && n % 157 && (n < 26569 || (n % 163 && n % 167 && n % 173 && n % 179 && n % 181 && n % 191 && n % 193 && n % 197 && n % 199 && (n < 44521 || (n % 211 && n % 223 && n % 227 && n % 229 && n % 233 && n % 239 && n % 241 && n % 251 && n % 257 && (n < 69169 || (n % 263 && n % 269 && n % 271 && n % 277 && n % 281 && n % 283 && n % 293 && n % 307 && n % 311 && (n < 97969 || (n % 313 && n % 317 && n % 331 && n % 337 && n % 347 && n % 349 && n % 353 && n % 359 && n % 367 && (n < 139129 || (n % 373 && n % 379 && n % 383 && n % 389 && n % 397 && n % 401 && n % 409 && n % 419 && n % 421 && (n < 185761 || (n % 431 && n % 433 && n % 439 && n % 443 && n % 449 && n % 457 && n % 461 && n % 463 && n % 467 && (n < 229441 || (n % 479 && n % 487 && n % 491 && n % 499 && n % 503 && n % 509 && n % 521 && n % 523 && n % 541 && (n < 299209 || (n % 547 && n % 557 && n % 563 && n % 569 && n % 571 && n % 577 && n % 587 && n % 593 && n % 599 && (n < 361201 || (n % 601 && n % 607 && n % 613 && n % 617 && n % 619 && n % 631 && n % 641 && n % 643 && n % 647 && (n < 426409 || (n % 653 && n % 659 && n % 661 && n % 673 && n % 677 && n % 683 && n % 691 && n % 701 && n % 709 && (n < 516961 || (n % 719 && n % 727 && n % 733 && n % 739 && n % 743 && n % 751 && n % 757 && n % 761 && n % 769 && (n < 597529 || (n % 773 && n % 787 && n % 797 && n % 809 && n % 811 && n % 821 && n % 823 && n % 827 && n % 829 && (n < 703921 || (n % 839 && n % 853 && n % 857 && n % 859 && n % 863 && n % 877 && n % 881 && n % 883 && n % 887 && (n < 822649 || (n % 907 && n % 911 && n % 919 && n % 929 && n % 937 && n % 941 && n % 947 && n % 953 && n % 967 && (n < 942841 || (n % 971 && n % 977 && n % 983 && n % 991 && n % 997 && n % 1009 && n % 1013 && n % 1019 && n % 1021 && (n < 1062961 || (n % 1031 && n % 1033 && n % 1039 && n % 1049 && n % 1051 && n % 1061 && n % 1063 && n % 1069 && n % 1087 && (n < 1190281 || (n % 1091 && n % 1093 && n % 1097 && n % 1103 && n % 1109 && n % 1117 && n % 1123 && n % 1129 && n % 1151 && (n < 1329409 || (n % 1153 && n % 1163 && n % 1171 && n % 1181 && n % 1187 && n % 1193 && n % 1201 && n % 1213 && n % 1217 && (n < 1495729 || (n % 1223 && n % 1229 && n % 1231 && n % 1237 && n % 1249 && n % 1259 && n % 1277 && n % 1279 && n % 1283 && (n < 1661521 || (n % 1289 && n % 1291 && n % 1297 && n % 1301 && n % 1303 && n % 1307 && n % 1319 && n % 1321 && n % 1327 && (n < 1852321 || (n % 1361 && n % 1367 && n % 1373 && n % 1381 && n % 1399 && n % 1409 && n % 1423 && n % 1427 && n % 1429 && (n < 2053489 || (n % 1433 && n % 1439 && n % 1447 && n % 1451 && n % 1453 && n % 1459 && n % 1471 && n % 1481 && n % 1483 && (n < 2211169 || (n % 1487 && n % 1489 && n % 1493 && n % 1499 && n % 1511 && n % 1523 && n % 1531 && n % 1543 && n % 1549 && (n < 2411809 || (n % 1553 && n % 1559 && n % 1567 && n % 1571 && n % 1579 && n % 1583 && n % 1597 && n % 1601 && n % 1607 && (n < 2588881 || (n % 1609 && n % 1613 && n % 1619 && n % 1621 && n % 1627 && n % 1637 && n % 1657 && n % 1663 && n % 1667 && (n < 2785561 || (n % 1669 && n % 1693 && n % 1697 && n % 1699 && n % 1709 && n % 1721 && n % 1723 && n % 1733 && n % 1741 && (n < 3052009 || (n % 1747 && n % 1753 && n % 1759 && n % 1777 && n % 1783 && n % 1787 && n % 1789 && n % 1801 && n % 1811 && (n < 3323329 || (n % 1823 && n % 1831 && n % 1847 && n % 1861 && n % 1867 && n % 1871 && n % 1873 && n % 1877 && n % 1879 && (n < 3568321 || (n % 1889 && n % 1901 && n % 1907 && n % 1913 && n % 1931 && n % 1933 && n % 1949 && n % 1951 && n % 1973 && (n < 3916441 || (n % 1979 && n % 1987 && n % 1993 && n % 1997 && n % 1999 && n % 2003 && n % 2011 && n % 2017 && n % 2027 && (n < 4116841 || (n % 2029 && n % 2039 && n % 2053 && n % 2063 && n % 2069 && n % 2081 && n % 2083 && n % 2087 && n % 2089 && (n < 4405801 || (n % 2099 && n % 2111 && n % 2113 && n % 2129 && n % 2131 && n % 2137 && n % 2141 && n % 2143 && n % 2153 )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));\n    for (b = c = n - 1, h = 0; !(b & 1); b >>= 1, ++h);\n    for (; k--;) {\n        for (g = 0; g < sizeof(positive_number); ((char*)&a)[g++] = libmin_rand()); // random number.\n        do for (d = e = 1 + a % c, f = n; (d %= f) && (f %= d););\n        while (d > 1 && f > 1);\n        for (d = f = 1; f <= b; f <<= 1);\n        for (; f >>= 1; d = multiplication_modulo(d, d, n), f & b && (d = multiplication_modulo(e, d, n)));\n        if (d == 1) continue;\n        for (i = h; i-- && d != c; d = multiplication_modulo(d, d, n));\n        if (d != c) return 0;\n    }\n    return 1;\n}\n"}, "pseudo": {"path": "rho-factor/rho-factor.host.O2.pseudo", "function_name": "is_prime", "address": "0x1400", "label": "is_prime", "content": "int __fastcall is_prime(positive_number n, int k)\n{\n  positive_number v3; // rbx\n  int v4; // r14d\n  positive_number v5; // rbp\n  positive_number *p_a; // r13\n  positive_number v7; // rsi\n  positive_number v8; // rcx\n  positive_number v9; // rdx\n  unsigned __int64 v10; // rax\n  unsigned __int64 v11; // r9\n  positive_number v12; // rcx\n  unsigned __int64 v13; // r9\n  positive_number v14; // rdx\n  unsigned __int64 v15; // rax\n  positive_number v16; // rsi\n  int v17; // r8d\n  positive_number v18; // rdx\n  unsigned __int64 v19; // rax\n  positive_number v20; // rsi\n  positive_number v21; // rdx\n  unsigned __int64 v22; // rax\n  positive_number v23; // rsi\n  __int64 v24; // rcx\n  int ka; // [rsp+4h] [rbp-54h]\n  positive_number a; // [rsp+10h] [rbp-48h] BYREF\n  unsigned __int64 v27; // [rsp+18h] [rbp-40h] BYREF\n\n  v27 = __readfsqword(0x28u);\n  a = 0LL;\n  if ( (n != 1) != (n & 1) )\n    return n == 2;\n  if ( n > 0x4741E0 )\n  {\n    v3 = n - 1;\n    v4 = 0;\n    v5 = n - 1;\n    if ( (n & 1) != 0 )\n    {\n      do\n      {\n        v5 >>= 1;\n        ++v4;\n      }\n      while ( (v5 & 1) == 0 );\n    }\n    ka = k - 1;\n    while ( 1 )\n    {\n      p_a = &a;\n      do\n      {\n        p_a = (positive_number *)((char *)p_a + 1);\n        *((_BYTE *)p_a - 1) = libmin_rand();\n      }\n      while ( p_a != &v27 );\n      v7 = n;\n      v8 = a % v3 + 1;\n      do\n      {\n        v9 = v8 % v7;\n        v8 = v9;\n        if ( !v9 )\n          break;\n        v7 %= v9;\n      }\n      while ( v7 );\n      v10 = 1LL;\n      do\n      {\n        v11 = v10;\n        v10 *= 2LL;\n      }\n      while ( v5 >= v10 );\n      v12 = 1LL;\n      v13 = v11 & 0x7FFFFFFFFFFFFFFFLL;\n      if ( v13 )\n      {\n        do\n        {\n          v14 = v12 % n;\n          if ( v12 )\n          {\n            v15 = 0LL;\n            do\n            {\n              if ( (v12 & 1) != 0 )\n              {\n                if ( n - v15 <= v14 )\n                  v15 -= n;\n                v15 += v14;\n              }\n              v16 = v14 - n;\n              if ( n - v14 > v14 )\n                v16 = v14;\n              v14 += v16;\n              v12 >>= 1;\n            }\n            while ( v12 );\n            v12 = v15 % n;\n          }\n          if ( (v13 & v5) != 0 )\n          {\n            v21 = a % v3 + 1;\n            v22 = 0LL;\n            do\n            {\n              if ( (v21 & 1) != 0 )\n              {\n                if ( n - v22 <= v12 )\n                  v22 -= n;\n                v22 += v12;\n              }\n              v23 = v12 - n;\n              if ( n - v12 > v12 )\n                v23 = v12;\n              v12 += v23;\n              v21 >>= 1;\n            }\n            while ( v21 );\n            v12 = v22 % n;\n          }\n          v13 >>= 1;\n        }\n        while ( v13 );\n        if ( v12 != 1 )\n        {\n          v17 = v4 - 1;\n          if ( !v4 )\n            goto LABEL_52;\n          if ( v3 != v12 )\n            break;\n        }\n      }\nLABEL_53:\n      if ( --ka == -1 )\n        return 1;\n    }\n    v18 = v12 % n;\n    if ( !v12 )\n      return 0;\n    while ( 1 )\n    {\n      v19 = 0LL;\n      do\n      {\n        if ( (v12 & 1) != 0 )\n        {\n          if ( n - v19 <= v18 )\n            v19 -= n;\n          v19 += v18;\n        }\n        v20 = v18 - n;\n        if ( n - v18 > v18 )\n          v20 = v18;\n        v18 += v20;\n        v12 >>= 1;\n      }\n      while ( v12 );\n      v12 = v19 % n;\n      if ( !v17 )\n        break;\n      if ( v3 == v19 % n )\n        goto LABEL_53;\n      --v17;\n      v18 = v12 % n;\n      if ( !v12 )\n        return 0;\n    }\nLABEL_52:\n    if ( v3 != v12 )\n      return 0;\n    goto LABEL_53;\n  }\n  v24 = n - 2 * ((((0x8888888888888889LL * (unsigned __int128)n) >> 64) & 0xFFFFFFFFFFFFFFF0LL) - n / 0x1E);\n  if ( n <= 5 )\n  {\n    if ( ((unsigned __int8)(545925292 >> v24) & (unsigned __int8)n & 1) == 0 )\n      return 0;\n  }\n  else if ( ((unsigned __int8)n & (unsigned __int8)(545925250 >> v24) & 1) == 0\n         || n > 0x30\n         && (0x6DB6DB6DB6DB6DB7LL * n <= 0x2492492492492492LL\n          || 0x2E8BA2E8BA2E8BA3LL * n <= 0x1745D1745D1745D1LL\n          || 0x4EC4EC4EC4EC4EC5LL * n <= 0x13B13B13B13B13B1LL\n          || 0xF0F0F0F0F0F0F0F1LL * n <= 0xF0F0F0F0F0F0F0FLL\n          || 0x86BCA1AF286BCA1BLL * n <= 0xD79435E50D79435LL\n          || 0xD37A6F4DE9BD37A7LL * n <= 0xB21642C8590B216LL\n          || !(n % 0x1D)\n          || n > 0x3C0\n          && (!(n % 0x1F)\n           || !(n % 0x25)\n           || !(n % 0x29)\n           || !(n % 0x2B)\n           || !(n % 0x2F)\n           || !(n % 0x35)\n           || !(n % 0x3B)\n           || !(n % 0x3D)\n           || !(n % 0x43)\n           || n > 0x13B0\n           && (!(n % 0x47)\n            || !(n % 0x49)\n            || !(n % 0x4F)\n            || !(n % 0x53)\n            || !(n % 0x59)\n            || !(n % 0x61)\n            || !(n % 0x65)\n            || !(n % 0x67)\n            || !(n % 0x6B)\n            || n > 0x2E68\n            && (!(n % 0x6D)\n             || !(n % 0x71)\n             || !(n % 0x7F)\n             || !(n % 0x83)\n             || !(n % 0x89)\n             || !(n % 0x8B)\n             || !(n % 0x95)\n             || !(n % 0x97)\n             || !(n % 0x9D)\n             || n > 0x67C8\n             && (!(n % 0xA3)\n              || !(n % 0xA7)\n              || !(n % 0xAD)\n              || !(n % 0xB3)\n              || !(n % 0xB5)\n              || !(n % 0xBF)\n              || !(n % 0xC1)\n              || !(n % 0xC5)\n              || !(n % 0xC7)\n              || n > 0xADE8\n              && (!(n % 0xD3)\n               || !(n % 0xDF)\n               || !(n % 0xE3)\n               || !(n % 0xE5)\n               || !(n % 0xE9)\n               || !(n % 0xEF)\n               || !(n % 0xF1)\n               || !(n % 0xFB)\n               || !(n % 0x101)\n               || n > 0x10E30\n               && (!(n % 0x107)\n                || !(n % 0x10D)\n                || !(n % 0x10F)\n                || !(n % 0x115)\n                || !(n % 0x119)\n                || !(n % 0x11B)\n                || !(n % 0x125)\n                || !(n % 0x133)\n                || !(n % 0x137)\n                || n > 0x17EB0\n                && (!(n % 0x139)\n                 || !(n % 0x13D)\n                 || !(n % 0x14B)\n                 || !(n % 0x151)\n                 || !(n % 0x15B)\n                 || !(n % 0x15D)\n                 || !(n % 0x161)\n                 || !(n % 0x167)\n                 || !(n % 0x16F)\n                 || n > 0x21F78\n                 && (!(n % 0x175)\n                  || !(n % 0x17B)\n                  || !(n % 0x17F)\n                  || !(n % 0x185)\n                  || !(n % 0x18D)\n                  || !(n % 0x191)\n                  || !(n % 0x199)\n                  || !(n % 0x1A3)\n                  || !(n % 0x1A5)\n                  || n > 0x2D5A0\n                  && (!(n % 0x1AF)\n                   || !(n % 0x1B1)\n                   || !(n % 0x1B7)\n                   || !(n % 0x1BB)\n                   || !(n % 0x1C1)\n                   || !(n % 0x1C9)\n                   || !(n % 0x1CD)\n                   || !(n % 0x1CF)\n                   || !(n % 0x1D3)\n                   || n > 0x38040\n                   && (!(n % 0x1DF)\n                    || !(n % 0x1E7)\n                    || !(n % 0x1EB)\n                    || !(n % 0x1F3)\n                    || !(n % 0x1F7)\n                    || !(n % 0x1FD)\n                    || !(n % 0x209)\n                    || !(n % 0x20B)\n                    || !(n % 0x21D)\n                    || n > 0x490C8\n                    && (!(n % 0x223)\n                     || !(n % 0x22D)\n                     || !(n % 0x233)\n                     || !(n % 0x239)\n                     || !(n % 0x23B)\n                     || !(n % 0x241)\n                     || !(n % 0x24B)\n                     || !(n % 0x251)\n                     || !(n % 0x257)\n                     || n > 0x582F0\n                     && (!(n % 0x259)\n                      || !(n % 0x25F)\n                      || !(n % 0x265)\n                      || !(n % 0x269)\n                      || !(n % 0x26B)\n                      || !(n % 0x277)\n                      || !(n % 0x281)\n                      || !(n % 0x283)\n                      || !(n % 0x287)\n                      || n > 0x681A8\n                      && (!(n % 0x28D)\n                       || !(n % 0x293)\n                       || !(n % 0x295)\n                       || !(n % 0x2A1)\n                       || !(n % 0x2A5)\n                       || !(n % 0x2AB)\n                       || !(n % 0x2B3)\n                       || !(n % 0x2BD)\n                       || !(n % 0x2C5)\n                       || n > 0x7E360\n                       && (!(n % 0x2CF)\n                        || !(n % 0x2D7)\n                        || !(n % 0x2DD)\n                        || !(n % 0x2E3)\n                        || !(n % 0x2E7)\n                        || !(n % 0x2EF)\n                        || !(n % 0x2F5)\n                        || !(n % 0x2F9)\n                        || !(n % 0x301)\n                        || n > 0x91E18\n                        && (!(n % 0x305)\n                         || !(n % 0x313)\n                         || !(n % 0x31D)\n                         || !(n % 0x329)\n                         || !(n % 0x32B)\n                         || !(n % 0x335)\n                         || !(n % 0x337)\n                         || !(n % 0x33B)\n                         || !(n % 0x33D)\n                         || n > 0xABDB0\n                         && (!(n % 0x347)\n                          || !(n % 0x355)\n                          || !(n % 0x359)\n                          || !(n % 0x35B)\n                          || !(n % 0x35F)\n                          || !(n % 0x36D)\n                          || !(n % 0x371)\n                          || !(n % 0x373)\n                          || !(n % 0x377)\n                          || n > 0xC8D78\n                          && (!(n % 0x38B)\n                           || !(n % 0x38F)\n                           || !(n % 0x397)\n                           || !(n % 0x3A1)\n                           || !(n % 0x3A9)\n                           || !(n % 0x3AD)\n                           || !(n % 0x3B3)\n                           || !(n % 0x3B9)\n                           || !(n % 0x3C7)\n                           || n > 0xE62F8\n                           && (!(n % 0x3CB)\n                            || !(n % 0x3D1)\n                            || !(n % 0x3D7)\n                            || !(n % 0x3DF)\n                            || !(n % 0x3E5)\n                            || !(n % 0x3F1)\n                            || !(n % 0x3F5)\n                            || !(n % 0x3FB)\n                            || !(n % 0x3FD)\n                            || n > 0x103830\n                            && (!(n % 0x407)\n                             || !(n % 0x409)\n                             || !(n % 0x40F)\n                             || !(n % 0x419)\n                             || !(n % 0x41B)\n                             || !(n % 0x425)\n                             || !(n % 0x427)\n                             || !(n % 0x42D)\n                             || !(n % 0x43F)\n                             || n > 0x122988\n                             && (!(n % 0x443)\n                              || !(n % 0x445)\n                              || !(n % 0x449)\n                              || !(n % 0x44F)\n                              || !(n % 0x455)\n                              || !(n % 0x45D)\n                              || !(n % 0x463)\n                              || !(n % 0x469)\n                              || !(n % 0x47F)\n                              || n > 0x144900\n                              && (!(n % 0x481)\n                               || !(n % 0x48B)\n                               || !(n % 0x493)\n                               || !(n % 0x49D)\n                               || !(n % 0x4A3)\n                               || !(n % 0x4A9)\n                               || !(n % 0x4B1)\n                               || !(n % 0x4BD)\n                               || !(n % 0x4C1)\n                               || n > 0x16D2B0\n                               && (!(n % 0x4C7)\n                                || !(n % 0x4CD)\n                                || !(n % 0x4CF)\n                                || !(n % 0x4D5)\n                                || !(n % 0x4E1)\n                                || !(n % 0x4EB)\n                                || !(n % 0x4FD)\n                                || !(n % 0x4FF)\n                                || !(n % 0x503)\n                                || n > 0x195A50\n                                && (!(n % 0x509)\n                                 || !(n % 0x50B)\n                                 || !(n % 0x511)\n                                 || !(n % 0x515)\n                                 || !(n % 0x517)\n                                 || !(n % 0x51B)\n                                 || !(n % 0x527)\n                                 || !(n % 0x529)\n                                 || !(n % 0x52F)\n                                 || n > 0x1C43A0\n                                 && (!(n % 0x551)\n                                  || !(n % 0x557)\n                                  || !(n % 0x55D)\n                                  || !(n % 0x565)\n                                  || !(n % 0x577)\n                                  || !(n % 0x581)\n                                  || !(n % 0x58F)\n                                  || !(n % 0x593)\n                                  || !(n % 0x595)\n                                  || n > 0x1F5570\n                                  && (!(n % 0x599)\n                                   || !(n % 0x59F)\n                                   || !(n % 0x5A7)\n                                   || !(n % 0x5AB)\n                                   || !(n % 0x5AD)\n                                   || !(n % 0x5B3)\n                                   || !(n % 0x5BF)\n                                   || !(n % 0x5C9)\n                                   || !(n % 0x5CB)\n                                   || n > 0x21BD60\n                                   && (!(n % 0x5CF)\n                                    || !(n % 0x5D1)\n                                    || !(n % 0x5D5)\n                                    || !(n % 0x5DB)\n                                    || !(n % 0x5E7)\n                                    || !(n % 0x5F3)\n                                    || !(n % 0x5FB)\n                                    || !(n % 0x607)\n                                    || !(n % 0x60D)\n                                    || n > 0x24CD20\n                                    && (!(n % 0x611)\n                                     || !(n % 0x617)\n                                     || !(n % 0x61F)\n                                     || !(n % 0x623)\n                                     || !(n % 0x62B)\n                                     || !(n % 0x62F)\n                                     || !(n % 0x63D)\n                                     || !(n % 0x641)\n                                     || !(n % 0x647)\n                                     || n > 0x2780D0\n                                     && (!(n % 0x649)\n                                      || !(n % 0x64D)\n                                      || !(n % 0x653)\n                                      || !(n % 0x655)\n                                      || !(n % 0x65B)\n                                      || !(n % 0x665)\n                                      || !(n % 0x679)\n                                      || !(n % 0x67F)\n                                      || !(n % 0x683)\n                                      || n > 0x2A8118\n                                      && (!(n % 0x685)\n                                       || !(n % 0x69D)\n                                       || !(n % 0x6A1)\n                                       || !(n % 0x6A3)\n                                       || !(n % 0x6AD)\n                                       || !(n % 0x6B9)\n                                       || !(n % 0x6BB)\n                                       || !(n % 0x6C5)\n                                       || !(n % 0x6CD)\n                                       || n > 0x2E91E8\n                                       && (!(n % 0x6D3)\n                                        || !(n % 0x6D9)\n                                        || !(n % 0x6DF)\n                                        || !(n % 0x6F1)\n                                        || !(n % 0x6F7)\n                                        || !(n % 0x6FB)\n                                        || !(n % 0x6FD)\n                                        || !(n % 0x709)\n                                        || !(n % 0x713)\n                                        || n > 0x32B5C0\n                                        && (!(n % 0x71F)\n                                         || !(n % 0x727)\n                                         || !(n % 0x737)\n                                         || !(n % 0x745)\n                                         || !(n % 0x74B)\n                                         || !(n % 0x74F)\n                                         || !(n % 0x751)\n                                         || !(n % 0x755)\n                                         || !(n % 0x757)\n                                         || n > 0x3672C0\n                                         && (!(n % 0x761)\n                                          || !(n % 0x76D)\n                                          || !(n % 0x773)\n                                          || !(n % 0x779)\n                                          || !(n % 0x78B)\n                                          || !(n % 0x78D)\n                                          || !(n % 0x79D)\n                                          || !(n % 0x79F)\n                                          || !(n % 0x7B5)\n                                          || n > 0x3BC298\n                                          && (!(n % 0x7BB)\n                                           || !(n % 0x7C3)\n                                           || !(n % 0x7C9)\n                                           || !(n % 0x7CD)\n                                           || !(n % 0x7CF)\n                                           || !(n % 0x7D3)\n                                           || !(n % 0x7DB)\n                                           || !(n % 0x7E1)\n                                           || !(n % 0x7EB)\n                                           || n > 0x3ED168\n                                           && (!(n % 0x7ED)\n                                            || !(n % 0x7F7)\n                                            || !(n % 0x805)\n                                            || !(n % 0x80F)\n                                            || !(n % 0x815)\n                                            || !(n % 0x821)\n                                            || !(n % 0x823)\n                                            || !(n % 0x827)\n                                            || !(n % 0x829)\n                                            || n > 0x433A28\n                                            && (!(n % 0x833)\n                                             || !(n % 0x83F)\n                                             || !(n % 0x841)\n                                             || !(n % 0x851)\n                                             || !(n % 0x853)\n                                             || !(n % 0x859)\n                                             || !(n % 0x85D)\n                                             || !(n % 0x85F)\n                                             || !(n % 0x869))))))))))))))))))))))))))))))))))))) )\n  {\n    return 0;\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "", "binary": "rho-factor/rho-factor.host.O2", "assembly": "<is_prime>:\npush   %r15\nmov    %rdi,%r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x18(%rsp)\nxor    %eax,%eax\ncmp    $0x1,%rdi\nmov    %edi,%eax\nmovq   $0x0,0x10(%rsp)\nsetne  %dl\nand    $0x1,%eax\ncmp    %al,%dl\nje     1466 <is_prime+0x66>\nxor    %eax,%eax\ncmp    $0x2,%rdi\nsete   %al\nmov    0x18(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    34c0 <is_prime+0x20c0>\nadd    $0x28,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncmp    $0x4741e0,%rdi\njbe    169c <is_prime+0x29c>\nlea    -0x1(%rdi),%rbx\nxor    %r14d,%r14d\nmov    %rbx,%rbp\ntest   $0x1,%dil\nje     1490 <is_prime+0x90>\nshr    %rbp\nadd    $0x1,%r14d\ntest   $0x1,%bpl\nje     1483 <is_prime+0x83>\nlea    -0x1(%rsi),%eax\nlea    0x18(%rsp),%r12\nmov    %eax,0x4(%rsp)\nlea    0x10(%rsp),%rax\nmov    %rax,0x8(%rsp)\ncs nopw 0x0(%rax,%rax,1)\nmov    0x8(%rsp),%r13\nnopl   (%rax)\ncall   51a0 <libmin_rand>\nadd    $0x1,%r13\nmov    %al,-0x1(%r13)\ncmp    %r12,%r13\njne    14b8 <is_prime+0xb8>\nmov    0x10(%rsp),%rax\nxor    %edx,%edx\nmov    %r15,%rsi\ndiv    %rbx\nlea    0x1(%rdx),%r8\nmov    %r8,%rcx\njmp    14f0 <is_prime+0xf0>\nmov    %rsi,%rax\nxor    %edx,%edx\ndiv    %rcx\nmov    %rdx,%rsi\ntest   %rdx,%rdx\nje     1500 <is_prime+0x100>\nmov    %rcx,%rax\nxor    %edx,%edx\ndiv    %rsi\nmov    %rdx,%rcx\ntest   %rdx,%rdx\njne    14e0 <is_prime+0xe0>\nmov    $0x1,%eax\nmov    %rax,%r9\nadd    %rax,%rax\ncmp    %rax,%rbp\njae    1505 <is_prime+0x105>\nmovabs $0x7fffffffffffffff,%rax\nmov    $0x1,%ecx\nand    %rax,%r9\nje     1680 <is_prime+0x280>\nnopl   0x0(%rax,%rax,1)\nmov    %rcx,%rax\nxor    %edx,%edx\ndiv    %r15\ntest   %rcx,%rcx\nje     157e <is_prime+0x17e>\nxor    %eax,%eax\nnop\ntest   $0x1,%cl\nje     155b <is_prime+0x15b>\nmov    %r15,%r10\nmov    %rax,%rsi\nsub    %rax,%r10\nsub    %r15,%rsi\ncmp    %rdx,%r10\ncmovbe %rsi,%rax\nadd    %rdx,%rax\nmov    %r15,%r10\nmov    %rdx,%rsi\nsub    %rdx,%r10\nsub    %r15,%rsi\ncmp    %rdx,%r10\ncmova  %rdx,%rsi\nadd    %rsi,%rdx\nshr    %rcx\njne    1540 <is_prime+0x140>\nxor    %edx,%edx\ndiv    %r15\nmov    %rdx,%rcx\ntest   %r9,%rbp\njne    1630 <is_prime+0x230>\nshr    %r9\njne    1530 <is_prime+0x130>\ncmp    $0x1,%rcx\nje     1680 <is_prime+0x280>\nlea    -0x1(%r14),%r8d\ntest   %r14d,%r14d\nje     167b <is_prime+0x27b>\ncmp    %rcx,%rbx\nje     1680 <is_prime+0x280>\nmov    %rcx,%rax\nxor    %edx,%edx\ndiv    %r15\ntest   %rcx,%rcx\nje     1621 <is_prime+0x221>\nnopl   0x0(%rax)\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\ntest   $0x1,%cl\nje     15e3 <is_prime+0x1e3>\nmov    %r15,%r9\nmov    %rax,%rsi\nsub    %rax,%r9\nsub    %r15,%rsi\ncmp    %rdx,%r9\ncmovbe %rsi,%rax\nadd    %rdx,%rax\nmov    %r15,%r9\nmov    %rdx,%rsi\nsub    %rdx,%r9\nsub    %r15,%rsi\ncmp    %rdx,%r9\ncmova  %rdx,%rsi\nadd    %rsi,%rdx\nshr    %rcx\njne    15c8 <is_prime+0x1c8>\nxor    %edx,%edx\ndiv    %r15\nmov    %rdx,%rcx\ntest   %r8d,%r8d\nje     167b <is_prime+0x27b>\ncmp    %rdx,%rbx\nje     1680 <is_prime+0x280>\nmov    %rcx,%rax\nxor    %edx,%edx\nsub    $0x1,%r8d\ndiv    %r15\ntest   %rcx,%rcx\njne    15c0 <is_prime+0x1c0>\nxor    %eax,%eax\njmp    1443 <is_prime+0x43>\nnopl   0x0(%rax,%rax,1)\nmov    %r8,%rdx\nxor    %eax,%eax\nnopl   (%rax)\ntest   $0x1,%dl\nje     1653 <is_prime+0x253>\nmov    %r15,%r10\nmov    %rax,%rsi\nsub    %rax,%r10\nsub    %r15,%rsi\ncmp    %rcx,%r10\ncmovbe %rsi,%rax\nadd    %rcx,%rax\nmov    %r15,%r10\nmov    %rcx,%rsi\nsub    %rcx,%r10\nsub    %r15,%rsi\ncmp    %rcx,%r10\ncmova  %rcx,%rsi\nadd    %rsi,%rcx\nshr    %rdx\njne    1638 <is_prime+0x238>\nxor    %edx,%edx\ndiv    %r15\nmov    %rdx,%rcx\njmp    1587 <is_prime+0x187>\ncmp    %rcx,%rbx\njne    1621 <is_prime+0x221>\nsubl   $0x1,0x4(%rsp)\nmov    0x4(%rsp),%eax\ncmp    $0xffffffff,%eax\njne    14b0 <is_prime+0xb0>\nmov    $0x1,%eax\njmp    1443 <is_prime+0x43>\nmovabs $0x8888888888888889,%rdx\nmov    %rdi,%rax\nmul    %rdx\nmov    %rdx,%rcx\nmov    %rdx,%rax\nshr    $0x4,%rcx\nand    $0xfffffffffffffff0,%rax\nsub    %rcx,%rax\nmov    %rdi,%rcx\nadd    %rax,%rax\nsub    %rax,%rcx\ncmp    $0x5,%rdi\njbe    34a8 <is_prime+0x20a8>\nmov    $0x208a2882,%eax\nsar    %cl,%eax\nand    %rdi,%rax\ntest   $0x1,%al\nje     1621 <is_prime+0x221>\ncmp    $0x30,%rdi\njbe    1692 <is_prime+0x292>\nmovabs $0x6db6db6db6db6db7,%rax\nmovabs $0x2492492492492492,%rdx\nimul   %rdi,%rax\ncmp    %rdx,%rax\njbe    1621 <is_prime+0x221>\nmovabs $0x2e8ba2e8ba2e8ba3,%rax\nmovabs $0x1745d1745d1745d1,%rdx\nimul   %rdi,%rax\ncmp    %rdx,%rax\njbe    1621 <is_prime+0x221>\nmovabs $0x4ec4ec4ec4ec4ec5,%rax\nmovabs $0x13b13b13b13b13b1,%rdx\nimul   %rdi,%rax\ncmp    %rdx,%rax\njbe    1621 <is_prime+0x221>\nmovabs $0xf0f0f0f0f0f0f0f1,%rax\nmovabs $0xf0f0f0f0f0f0f0f,%rdx\nimul   %rdi,%rax\ncmp    %rdx,%rax\njbe    1621 <is_prime+0x221>\nmovabs $0x86bca1af286bca1b,%rax\nmovabs $0xd79435e50d79435,%rdx\nimul   %rdi,%rax\ncmp    %rdx,%rax\njbe    1621 <is_prime+0x221>\nmovabs $0xd37a6f4de9bd37a7,%rax\nmovabs $0xb21642c8590b216,%rdx\nimul   %rdi,%rax\ncmp    %rdx,%rax\njbe    1621 <is_prime+0x221>\nmov    $0x1d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x3c0,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x1f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x25,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x29,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x35,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x43,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x13b0,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x47,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x49,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x53,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x59,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x61,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x65,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x67,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x2e68,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x6d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x71,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x7f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x83,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x89,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x8b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x95,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x97,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x9d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x67c8,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0xa3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xa7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xad,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xb3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xb5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xbf,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xc1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xc5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xc7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0xade8,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0xd3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xdf,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xe3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xe5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xe9,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xef,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xf1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0xfb,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x101,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x10e30,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x107,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x10d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x10f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x115,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x119,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x11b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x125,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x133,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x137,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x17eb0,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x139,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x13d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x14b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x151,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x15b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x15d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x161,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x167,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x16f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x21f78,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x175,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x17b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x17f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x185,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x18d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x191,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x199,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1a3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1a5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x2d5a0,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x1af,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1b1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1b7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1bb,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1c1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1c9,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1cd,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1cf,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1d3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x38040,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x1df,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1e7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1eb,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1f3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1f7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x1fd,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x209,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x20b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x21d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x490c8,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x223,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x22d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x233,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x239,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x23b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x241,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x24b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x251,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x257,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x582f0,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x259,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x25f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x265,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x269,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x26b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x277,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x281,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x283,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x287,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x681a8,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x28d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x293,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x295,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2a1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2a5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2ab,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2b3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2bd,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2c5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x7e360,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x2cf,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2d7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2dd,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2e3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2e7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2ef,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2f5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x2f9,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x301,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x91e18,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x305,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x313,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x31d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x329,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x32b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x335,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x337,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x33b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x33d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0xabdb0,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x347,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x355,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x359,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x35b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x35f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x36d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x371,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x373,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x377,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0xc8d78,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x38b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x38f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x397,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3a1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3a9,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3ad,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3b3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3b9,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3c7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0xe62f8,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x3cb,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3d1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3d7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3df,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3e5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3f1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3f5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3fb,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x3fd,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x103830,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x407,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x409,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x40f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x419,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x41b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x425,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x427,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x42d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x43f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x122988,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x443,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x445,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x449,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x44f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x455,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x45d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x463,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x469,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x47f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x144900,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x481,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x48b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x493,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x49d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4a3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4a9,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4b1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4bd,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4c1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x16d2b0,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x4c7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4cd,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4cf,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4d5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4e1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4eb,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4fd,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x4ff,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x503,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x195a50,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x509,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x50b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x511,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x515,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x517,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x51b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x527,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x529,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x52f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x1c43a0,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x551,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x557,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x55d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x565,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x577,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x581,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x58f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x593,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x595,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x1f5570,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x599,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x59f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5a7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5ab,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5ad,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5b3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5bf,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5c9,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5cb,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x21bd60,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x5cf,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5d1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5d5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5db,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5e7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5f3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x5fb,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x607,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x60d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x24cd20,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x611,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x617,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x61f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x623,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x62b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x62f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x63d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x641,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x647,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x2780d0,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x649,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x64d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x653,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x655,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x65b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x665,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x679,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x67f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x683,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x2a8118,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x685,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x69d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6a1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6a3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6ad,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6b9,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6bb,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6c5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6cd,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x2e91e8,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x6d3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6d9,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6df,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6f1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6f7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6fb,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x6fd,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x709,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x713,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x32b5c0,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x71f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x727,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x737,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x745,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x74b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x74f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x751,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x755,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x757,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x3672c0,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x761,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x76d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x773,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x779,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x78b,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x78d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x79d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x79f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x7b5,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x3bc298,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x7bb,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x7c3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x7c9,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x7cd,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x7cf,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x7d3,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x7db,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x7e1,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x7eb,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x3ed168,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x7ed,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x7f7,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x805,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x80f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x815,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x821,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x823,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x827,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x829,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\ncmp    $0x433a28,%rdi\njbe    1692 <is_prime+0x292>\nmov    $0x833,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x83f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x841,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x851,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x853,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x859,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x85d,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x85f,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\nje     1621 <is_prime+0x221>\nmov    $0x869,%ecx\nmov    %rdi,%rax\nxor    %edx,%edx\ndiv    %rcx\ntest   %rdx,%rdx\njne    1692 <is_prime+0x292>\njmp    1621 <is_prime+0x221>\nnopw   0x0(%rax,%rax,1)\nmov    $0x208a28ac,%eax\nsar    %cl,%eax\nand    %rax,%rdi\nand    $0x1,%edi\njne    1692 <is_prime+0x292>\njmp    1621 <is_prime+0x221>\ncall   10c0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "rho-factor/rho-factor.c", "function_name": "main", "content": "int main(void)\n{\n    // allocate memory for 64 factors.\n    positive_number *factors = libmin_calloc(64, sizeof(positive_number));\n    positive_number n = 0, mask = -1;\n    /* TMA: unsigned sr = (size_t)factors; sr = -sr / 561; libmin_printf(\"srand at %u :\\n\\n\", sr); */ libmin_srand(/* TMA: sr */42);\n    for (int wrapper = 4, count = 0, j; wrapper < 64; ++wrapper)\n    {\n        for (int64_t n_bits = wrapper; n_bits <= 64; ++n_bits)\n        {\n            // generate a random number of ~ n_bits bits.\n            n = 0;\n            for (size_t k = 0; k < sizeof(positive_number); k++)\n            {\n              ((char *) &n)[k] = (libmin_rand() & 0xff);\n            }\n            n &= mask >> ((positive_number)8 * sizeof(positive_number) - n_bits); n += !(n & (positive_number)1);\n            libmin_printf(\"%5d. (%2ld bits) %22lu = \", ++count, n_bits, n);\n            // fill the \"factors\" array with the prime factors.\n            factor(n, factors);\n            // iterate over the factors (zero terminated array).\n            for (j = 0; factors[j + 1]; ++j) {\n                libmin_printf(\"%lu * \", factors[j]);\n                libmin_assert(n % factors[j] == 0);\n                libmin_assert(is_prime(factors[j], 36));\n            }\n            libmin_printf(\"%lu\\n\", factors[j]);\n        }\n    }\n\n    // release memory.\n    libmin_free(factors);\n\n    // proper exit\n    libmin_success();\n}\n"}, "pseudo": {"path": "rho-factor/rho-factor.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  positive_number *v3; // rbp\n  int v4; // eax\n  __int64 v5; // r14\n  positive_number *p_n; // r12\n  positive_number v7; // r12\n  __int64 v8; // r15\n  positive_number v9; // rdi\n  positive_number *v10; // rax\n  __int64 wrapper; // [rsp+8h] [rbp-60h]\n  int v12; // [rsp+10h] [rbp-58h]\n  int v13; // [rsp+14h] [rbp-54h]\n  positive_number n; // [rsp+20h] [rbp-48h] BYREF\n  unsigned __int64 v15; // [rsp+28h] [rbp-40h] BYREF\n\n  v15 = __readfsqword(0x28u);\n  v3 = (positive_number *)libmin_calloc(0x40uLL, 8uLL);\n  libmin_srand(0x2Au);\n  v4 = 0;\n  wrapper = 4LL;\n  while ( 1 )\n  {\n    v5 = wrapper;\n    v12 = v4 + 1;\n    do\n    {\n      n = 0LL;\n      p_n = &n;\n      do\n      {\n        p_n = (positive_number *)((char *)p_n + 1);\n        *((_BYTE *)p_n - 1) = libmin_rand();\n      }\n      while ( p_n != &v15 );\n      n = (n & (0xFFFFFFFFFFFFFFFFLL >> (64 - (unsigned __int8)v5)))\n        + (((unsigned __int8)n & (unsigned __int8)(0xFFFFFFFFFFFFFFFFLL >> (64 - (unsigned __int8)v5)) & 1) == 0);\n      v7 = n;\n      v13 = wrapper;\n      libmin_printf(\"%5d. (%2ld bits) %22lu = \", v5 + v12 - wrapper, v5, n);\n      factor(v7, v3);\n      if ( v3[1] )\n      {\n        v8 = 0LL;\n        do\n        {\n          libmin_printf(\"%lu * \", v3[v8]);\n          v9 = v3[v8];\n          if ( v7 % v9 )\n            libmin_fail(1);\n          if ( !is_prime(v9, 36) )\n            libmin_fail(1);\n          ++v8;\n        }\n        while ( v3[v8 + 1] );\n        v10 = &v3[v8];\n      }\n      else\n      {\n        v10 = v3;\n      }\n      ++v5;\n      libmin_printf(\"%lu\\n\", *v10);\n    }\n    while ( v5 != 65 );\n    ++wrapper;\n    v4 = v12 - v13 + 64;\n    if ( wrapper == 64 )\n    {\n      libmin_free(v3);\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  positive_number *v3;\n  int v4;\n  long long v5;\n  positive_number *p_n;\n  positive_number v7;\n  long long v8;\n  positive_number v9;\n  positive_number *v10;\n  long long wrapper;\n  int v12;\n  int v13;\n  positive_number n;\n  unsigned long long v15;\n  v15 = __readfsqword(40u);\n  v3 = (positive_number *)libmin_calloc(64uLL, 8uLL);\n  libmin_srand(42u);\n  v4 = 0;\n  wrapper = 4LL;\n  while (1) {\n    v5 = wrapper;\n    v12 = v4 + 1;\n    do {\n      n = 0LL;\n      p_n = &n;\n      do {\n        p_n = (positive_number *)((char *)p_n + 1);\n        *((uint8_t *)p_n - 1) = libmin_rand();\n      } while (p_n != &v15);\n      n = (n & (18446744073709551615LL >> (64 - (unsigned char)v5))) +\n          (((unsigned char)n &\n            (unsigned char)(18446744073709551615LL >>\n                            (64 - (unsigned char)v5)) &\n            1) == 0);\n      v7 = n;\n      v13 = wrapper;\n      libmin_printf(\"%5d. (%2ld bits) %22lu = \", v5 + v12 - wrapper, v5, n);\n      factor(v7, v3);\n      if (v3[1]) {\n        v8 = 0LL;\n        do {\n          libmin_printf(\"%lu * \", v3[v8]);\n          v9 = v3[v8];\n          if (v7 % v9) libmin_fail(1);\n          if (!is_prime(v9, 36)) libmin_fail(1);\n          ++v8;\n        } while (v3[v8 + 1]);\n        v10 = &v3[v8];\n      } else {\n        v10 = v3;\n      }\n      ++v5;\n      libmin_printf(\"%lu\\n\", *v10);\n    } while (v5 != 65);\n    ++wrapper;\n    v4 = v12 - v13 + 64;\n    if (wrapper == 64) {\n      libmin_free(v3);\n      libmin_success();\n    }\n  }\n}", "binary": "rho-factor/rho-factor.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x8,%esi\nmov    $0x40,%edi\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nlea    0x4edf(%rip),%rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nlea    0x28(%rsp),%r13\ncall   3a60 <libmin_calloc>\nmov    $0x2a,%edi\nmov    %rax,%rbp\ncall   5140 <libmin_srand>\nlea    0x20(%rsp),%rcx\nxor    %eax,%eax\nmovq   $0x4,0x8(%rsp)\nmov    %rcx,0x18(%rsp)\nnop\nadd    $0x1,%eax\nmov    0x8(%rsp),%r14\nmov    %eax,0x10(%rsp)\nnopl   0x0(%rax)\nmovq   $0x0,0x20(%rsp)\nmov    0x18(%rsp),%r12\nxchg   %ax,%ax\ncall   51a0 <libmin_rand>\nadd    $0x1,%r12\nmov    %al,-0x1(%r12)\ncmp    %r13,%r12\njne    11a0 <main+0x80>\nmov    $0x40,%ecx\nmov    $0xffffffffffffffff,%rax\nmov    0x10(%rsp),%esi\nmov    %r14,%rdx\nsub    %r14d,%ecx\nlea    0x4e34(%rip),%rdi\nshr    %cl,%rax\nand    0x20(%rsp),%rax\nmov    %rax,%r12\nnot    %r12\nand    $0x1,%r12d\nadd    %rax,%r12\nmov    0x8(%rsp),%rax\nmov    %r12,%rcx\nmov    %r12,0x20(%rsp)\nsub    %eax,%esi\nmov    %eax,0x14(%rsp)\nxor    %eax,%eax\nadd    %r14d,%esi\ncall   4f30 <libmin_printf>\nmov    %rbp,%rsi\nmov    %r12,%rdi\ncall   35e0 <factor>\ncmpq   $0x0,0x8(%rbp)\nje     1300 <main+0x1e0>\nxor    %r15d,%r15d\njmp    123a <main+0x11a>\nnopl   (%rax)\nmov    $0x24,%esi\ncall   1400 <is_prime>\ntest   %eax,%eax\nje     1278 <main+0x158>\nadd    $0x1,%r15\ncmpq   $0x0,0x8(%rbp,%r15,8)\nje     128e <main+0x16e>\nmov    0x0(%rbp,%r15,8),%rsi\nmov    %rbx,%rdi\nxor    %eax,%eax\ncall   4f30 <libmin_printf>\nmov    0x0(%rbp,%r15,8),%rdi\nmov    %r12,%rax\nxor    %edx,%edx\ndiv    %rdi\ntest   %rdx,%rdx\nje     1220 <main+0x100>\nmov    $0x1,%edi\ncall   38e0 <libmin_fail>\nmov    0x0(%rbp,%r15,8),%rdi\nmov    $0x24,%esi\ncall   1400 <is_prime>\ntest   %eax,%eax\njne    122e <main+0x10e>\nmov    $0x1,%edi\nadd    $0x1,%r15\ncall   38e0 <libmin_fail>\ncmpq   $0x0,0x8(%rbp,%r15,8)\njne    123a <main+0x11a>\nlea    0x0(%rbp,%r15,8),%rax\nmov    (%rax),%rsi\nlea    0x4d88(%rip),%rdi\nxor    %eax,%eax\nadd    $0x1,%r14\ncall   4f30 <libmin_printf>\ncmp    $0x41,%r14\njne    1190 <main+0x70>\naddq   $0x1,0x8(%rsp)\nmov    0x8(%rsp),%rcx\nmov    0x10(%rsp),%eax\nsub    0x14(%rsp),%eax\nadd    $0x40,%eax\ncmp    $0x40,%rcx\njne    1180 <main+0x60>\nmov    %rbp,%rdi\ncall   3a40 <libmin_free>\ncall   5380 <libmin_success>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1305 <main+0x1e5>\nadd    $0x38,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    %rbp,%rax\njmp    1293 <main+0x173>\ncall   10c0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "rle-compress/rle-compress.c", "function_name": "main", "content": "/**\n * @brief Main function\n * @returns 0 on exit\n */\nint main() {\n    test();  // run self-test implementations\n\n    libmin_printf(\"All tests have passed!\\n\");\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "rle-compress/rle-compress.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char *v3; // rbp\n  char *v4; // rbp\n  char *v5; // rbp\n\n  v3 = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if ( !libmin_strcmp(v3, \"7a3b2a4c1d1e1f2a1d1r\") )\n  {\n    libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", v3);\n    libmin_free(v3);\n    v4 = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n    if ( !libmin_strcmp(v4, \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\") )\n    {\n      libmin_printf(\"in: %s -> out: %s\\n\", \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", v4);\n      libmin_free(v4);\n      v5 = run_length_encode(\"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\");\n      if ( !libmin_strcmp(v5, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\") )\n      {\n        libmin_printf(\n          \"in: %s -> out: %s\\n\",\n          \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n          v5);\n        libmin_free(v5);\n        libmin_printf(\"All tests have passed!\\n\");\n        libmin_success();\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  char *v3;\n  char *v4;\n  char *v5;\n  v3 = run_length_encode(\"aaaaaaabbbaaccccdefaadr\");\n  if (!libmin_strcmp(v3, \"7a3b2a4c1d1e1f2a1d1r\")) {\n    libmin_printf(\"in: %s -> out: %s\\n\", \"aaaaaaabbbaaccccdefaadr\", v3);\n    libmin_free(v3);\n    v4 = run_length_encode(\"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\");\n    if (!libmin_strcmp(v4,\n                       \"1l1i1d1j1h1v1i1p1d1u1r1e1v1b1e1i1r1b1g1i1p1e1a1h1a1p1o1\"\n                       \"e1u1h1w1a1i1p1e1f1u1p1w1i1e1o1f1b\")) {\n      libmin_printf(\"in: %s -> out: %s\\n\",\n                    \"lidjhvipdurevbeirbgipeahapoeuhwaipefupwieofb\", v4);\n      libmin_free(v4);\n      v5 = run_length_encode(\n          \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n          \"aaaaaaaaaaaaaaaaaaaaaaaaahghghrw\");\n      if (!libmin_strcmp(v5, \"1h1t4u1r1w1u1q1u1q1u1q3u76a1h1g1h1g1h1r1w\")) {\n        libmin_printf(\"in: %s -> out: %s\\n\",\n                      \"htuuuurwuquququuuaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n                      \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaahghghrw\",\n                      v5);\n        libmin_free(v5);\n        libmin_printf(\"All tests have passed!\\n\");\n        libmin_success();\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}", "binary": "rle-compress/rle-compress.host.O2", "assembly": "<main>:\nendbr64\npush   %r13\npush   %r12\nlea    0x1ed8(%rip),%r12\npush   %rbp\nmov    %r12,%rdi\ncall   1330 <run_length_encode>\nlea    0x1ee0(%rip),%rsi\nmov    %rax,%rdi\nmov    %rax,%rbp\ncall   2ea0 <libmin_strcmp>\ntest   %eax,%eax\njne    120a <main+0xea>\nmov    %r12,%rsi\nlea    0x1ed8(%rip),%r12\nmov    %rbp,%rdx\nxor    %eax,%eax\nmov    %r12,%rdi\nlea    0x1ef5(%rip),%r13\ncall   2c90 <libmin_printf>\nmov    %rbp,%rdi\ncall   17a0 <libmin_free>\nmov    %r13,%rdi\ncall   1330 <run_length_encode>\nlea    0x1f09(%rip),%rsi\nmov    %rax,%rdi\nmov    %rax,%rbp\ncall   2ea0 <libmin_strcmp>\ntest   %eax,%eax\njne    1225 <main+0x105>\nmov    %r13,%rsi\nmov    %rbp,%rdx\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2c90 <libmin_printf>\nlea    0x1f3f(%rip),%r13\nmov    %rbp,%rdi\ncall   17a0 <libmin_free>\nmov    %r13,%rdi\ncall   1330 <run_length_encode>\nlea    0x1f90(%rip),%rsi\nmov    %rax,%rdi\nmov    %rax,%rbp\ncall   2ea0 <libmin_strcmp>\ntest   %eax,%eax\njne    1219 <main+0xf9>\nmov    %rbp,%rdx\nmov    %r13,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   2c90 <libmin_printf>\nmov    %rbp,%rdi\ncall   17a0 <libmin_free>\nlea    0x1e51(%rip),%rdi\nxor    %eax,%eax\ncall   2c90 <libmin_printf>\ncall   2fa0 <libmin_success>\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\nret\nmov    $0x1,%edi\ncall   1640 <libmin_fail>\njmp    1152 <main+0x32>\nmov    $0x1,%edi\ncall   1640 <libmin_fail>\njmp    11d7 <main+0xb7>\nmov    $0x1,%edi\ncall   1640 <libmin_fail>\njmp    119a <main+0x7a>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "rle-compress/rle-compress.c", "function_name": "run_length_encode", "content": "/**\n * @file\n * @author [serturx](https://github.com/serturx/)\n * @brief Encode a null terminated string using [Run-length encoding](https://en.wikipedia.org/wiki/Run-length_encoding)\n * @details\n * Run-length encoding is a lossless compression algorithm.\n * It works by counting the consecutive occurences symbols\n * and encodes that series of consecutive symbols into the\n * counted symbol and a number denoting the number of\n * consecutive occorences.\n * \n * For example the string \"AAAABBCCD\" gets encoded into \"4A2B2C1D\"\n * \n */\n\n#include \"libmin.h\"\n\n/**\n * @brief Encodes a null-terminated string using run-length encoding\n * @param str String to encode\n * @return char* Encoded string\n */\n\nchar* run_length_encode(char* str) {\n    int str_length = libmin_strlen(str);\n    int encoded_index = 0;\n\n    //allocate space for worst-case scenario\n    char* encoded = libmin_malloc(2 * libmin_strlen(str) + 1);\n    \n    //temp space for int to str conversion\n    char int_str[20];\n\n    for(int i = 0; i < str_length; ++i) {\n        int count = 0;\n        char current = str[i];\n\n        //count occurences\n        while(current == str[i + count]) count++;\n\n        i += count - 1;\n\n        //convert occurrence amount to string and write to encoded string\n        libmin_snprintf(int_str, 20, \"%d\", count);\n        libmin_strncpy(&encoded[encoded_index], int_str, libmin_strlen(int_str));\n\n        //write current char to encoded string\n        encoded_index += libmin_strlen(int_str);\n        encoded[encoded_index] = current;\n        ++encoded_index;\n    }\n\n    //null terminate string and move encoded string to compacted memory space \n    encoded[encoded_index] = '\\0';\n    char* compacted_string = libmin_malloc(libmin_strlen(encoded) + 1);\n    libmin_strcpy(compacted_string, encoded);\n    \n    libmin_free(encoded);\n\n    return compacted_string;\n}\n"}, "pseudo": {"path": "rle-compress/rle-compress.host.O2.pseudo", "function_name": "run_length_encode", "address": "0x1330", "label": "run_length_encode", "content": "char *__fastcall run_length_encode(char *str)\n{\n  size_t v1; // rax\n  char *v2; // rax\n  char *v3; // r13\n  int v4; // ebx\n  int v5; // r12d\n  int v6; // ecx\n  char v7; // r15\n  char *v8; // rax\n  int v9; // edx\n  size_t v10; // rax\n  int v11; // eax\n  size_t v12; // rax\n  char *v13; // r12\n  int v15; // [rsp+Ch] [rbp-5Ch]\n  char int_str[24]; // [rsp+10h] [rbp-58h] BYREF\n  unsigned __int64 v17; // [rsp+28h] [rbp-40h]\n\n  v17 = __readfsqword(0x28u);\n  v15 = libmin_strlen(str);\n  v1 = libmin_strlen(str);\n  v2 = (char *)libmin_malloc(2 * v1 + 1);\n  v3 = v2;\n  if ( v15 > 0 )\n  {\n    v4 = 0;\n    v5 = 0;\n    do\n    {\n      v6 = 0;\n      v7 = str[v4];\n      v8 = &str[v4 + 1];\n      do\n      {\n        ++v8;\n        v9 = v6++;\n      }\n      while ( *(v8 - 1) == v7 );\n      v4 += v9 + 1;\n      libmin_snprintf(int_str, 0x14uLL, \"%d\", v6);\n      v10 = libmin_strlen(int_str);\n      libmin_strncpy(&v3[v5], int_str, v10);\n      v11 = v5 + libmin_strlen(int_str);\n      v5 = v11 + 1;\n      v3[v11] = v7;\n    }\n    while ( v15 > v4 );\n    v2 = &v3[v5];\n  }\n  *v2 = 0;\n  v12 = libmin_strlen(v3);\n  v13 = (char *)libmin_malloc(v12 + 1);\n  libmin_strcpy(v13, v3);\n  libmin_free(v3);\n  return v13;\n}\n"}, "pseudo_normalize": "char *run_length_encode(char *str) {\n  unsigned int v1;\n  char *v2;\n  char *v3;\n  int v4;\n  int v5;\n  int v6;\n  char v7;\n  char *v8;\n  int v9;\n  unsigned int v10;\n  int v11;\n  unsigned int v12;\n  char *v13;\n  int v15;\n  char int_str[24];\n  unsigned long long v17;\n  v17 = __readfsqword(40u);\n  v15 = libmin_strlen(str);\n  v1 = libmin_strlen(str);\n  v2 = (char *)libmin_malloc(2 * v1 + 1);\n  v3 = v2;\n  if (v15 > 0) {\n    v4 = 0;\n    v5 = 0;\n    do {\n      v6 = 0;\n      v7 = str[v4];\n      v8 = &str[v4 + 1];\n      do {\n        ++v8;\n        v9 = v6++;\n      } while (*(v8 - 1) == v7);\n      v4 += v9 + 1;\n      libmin_snprintf(int_str, 20uLL, \"%d\", v6);\n      v10 = libmin_strlen(int_str);\n      libmin_strncpy(&v3[v5], int_str, v10);\n      v11 = v5 + libmin_strlen(int_str);\n      v5 = v11 + 1;\n      v3[v11] = v7;\n    } while (v15 > v4);\n    v2 = &v3[v5];\n  }\n  *v2 = 0;\n  v12 = libmin_strlen(v3);\n  v13 = (char *)libmin_malloc(v12 + 1);\n  libmin_strcpy(v13, v3);\n  libmin_free(v3);\n  return v13;\n}", "binary": "rle-compress/rle-compress.host.O2", "assembly": "<run_length_encode>:\nendbr64\npush   %r15\npush   %r14\nmov    %rdi,%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\ncall   2f20 <libmin_strlen>\nmov    %r14,%rdi\nmov    %eax,0xc(%rsp)\nmov    %rax,%rbx\ncall   2f20 <libmin_strlen>\nlea    0x1(%rax,%rax,1),%rdi\ncall   16f0 <libmin_malloc>\nmov    %rax,%r13\ntest   %ebx,%ebx\njle    1406 <run_length_encode+0xd6>\nxor    %ebx,%ebx\nxor    %r12d,%r12d\nlea    0x10(%rsp),%rbp\nnopl   0x0(%rax,%rax,1)\nmovslq %ebx,%rax\nxor    %ecx,%ecx\nmovzbl (%r14,%rax,1),%r15d\nlea    0x1(%r14,%rax,1),%rax\nnop\nadd    $0x1,%rax\nmov    %ecx,%edx\nadd    $0x1,%ecx\ncmp    %r15b,-0x1(%rax)\nje     13a0 <run_length_encode+0x70>\nmov    $0x14,%esi\nadd    %edx,%ebx\nmov    %rbp,%rdi\nxor    %eax,%eax\nlea    0x1c42(%rip),%rdx\nadd    $0x1,%ebx\ncall   2dd0 <libmin_snprintf>\nmov    %rbp,%rdi\ncall   2f20 <libmin_strlen>\nmovslq %r12d,%rdi\nmov    %rbp,%rsi\nmov    %rax,%rdx\nadd    %r13,%rdi\ncall   2f50 <libmin_strncpy>\nmov    %rbp,%rdi\ncall   2f20 <libmin_strlen>\nadd    %r12d,%eax\nmovslq %eax,%rdx\nlea    0x1(%rax),%r12d\nmov    %r15b,0x0(%r13,%rdx,1)\ncmp    %ebx,0xc(%rsp)\njg     1390 <run_length_encode+0x60>\nmovslq %r12d,%rax\nadd    %r13,%rax\nmovb   $0x0,(%rax)\nmov    %r13,%rdi\ncall   2f20 <libmin_strlen>\nlea    0x1(%rax),%rdi\ncall   16f0 <libmin_malloc>\nmov    %r13,%rsi\nmov    %rax,%rdi\nmov    %rax,%r12\ncall   2f00 <libmin_strcpy>\nmov    %r13,%rdi\ncall   17a0 <libmin_free>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1452 <run_length_encode+0x122>\nadd    $0x38,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10c0 <__stack_chk_fail@plt>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "rsa-cipher/rsa-cipher.c", "function_name": "main", "content": "int main() {\n    // Fixed primes for demonstration (not cryptographically secure)\n    unsigned long long p_ll = 1000003ULL;  // About 1e6\n    unsigned long long q_ll = 1000033ULL;  // About 1e6\n    int128 p = p_ll;\n    int128 q = q_ll;\n    \n    // Compute modulus: n = p * q (using 128-bit arithmetic)\n    int128 n = p * q;\n    \n    // Compute Euler's totient: phi = (p - 1) * (q - 1)\n    int128 phi = (p - 1) * (q - 1);\n    \n    // Choose a common public exponent e = 65537\n    int128 e = 65537;\n    \n    // Compute private exponent d as the modular inverse of e modulo phi\n    int128 d = mod_inverse(e, phi);\n    \n    // Choose a sample message to encrypt (must be less than n)\n    int128 message = 0xdeadbeef;\n    \n    // Encrypt: ciphertext = message^e mod n\n    int128 encrypted = mod_pow(message, e, n);\n    \n    // Decrypt: decrypted = ciphertext^d mod n\n    int128 decrypted = mod_pow(encrypted, d, n);\n    \n    // Print all outputs in hexadecimal\n    libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n    \n    libmin_printf(\"p: \");\n    print_hex_int128(p);\n    libmin_printf(\"\\nq: \");\n    print_hex_int128(q);\n    \n    libmin_printf(\"\\nn (modulus): \");\n    print_hex_int128(n);\n    \n    libmin_printf(\"\\nphi(n): \");\n    print_hex_int128(phi);\n    \n    libmin_printf(\"\\n\\nPublic exponent (e): \");\n    print_hex_int128(e);\n    \n    libmin_printf(\"\\nPrivate exponent (d): \");\n    print_hex_int128(d);\n    \n    libmin_printf(\"\\n\\nOriginal message: \");\n    print_hex_int128(message);\n    \n    libmin_printf(\"\\nEncrypted message: \");\n    print_hex_int128(encrypted);\n    \n    libmin_printf(\"\\nDecrypted message: \");\n    print_hex_int128(decrypted);\n    \n    libmin_printf(\"\\n\");\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "rsa-cipher/rsa-cipher.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // r15\n  __int64 v4; // r14\n  __int64 v5; // r13\n  __int64 v6; // r12\n  __int64 v7; // rbp\n  __int64 v8; // rbx\n  __int64 i; // rax\n  __int64 v10; // rdx\n  __int128 v11; // rdi\n  __int64 v12; // rcx\n  unsigned __int128 v13; // rax\n  __int64 v14; // r8\n  __int64 v15; // r9\n  unsigned __int128 v16; // kr00_16\n  unsigned __int128 v17; // kr10_16\n  int v18; // ebp\n  __int64 v19; // rbx\n  unsigned __int64 v20; // r8\n  __int64 v21; // r15\n  __int64 v22; // r9\n  __int64 v23; // r14\n  __int64 v24; // rax\n  unsigned __int64 v25; // rdx\n  __int128 v26; // rt0\n  __int64 v27; // rax\n  unsigned __int64 v28; // rdx\n  __int64 v29; // r15\n  unsigned __int64 v30; // rdx\n  unsigned __int64 v31; // r10\n  __int64 v32; // r8\n  __int64 v33; // r9\n  __int64 v34; // r14\n  unsigned __int64 v35; // rbp\n  __int64 v36; // rax\n  unsigned __int64 v37; // rdx\n  __int128 v38; // rt0\n  __int64 v39; // rax\n  unsigned __int64 v40; // rdx\n  int128 v41; // rdi\n  __int64 v42; // [rsp+0h] [rbp-78h]\n  unsigned __int64 v43; // [rsp+0h] [rbp-78h]\n  unsigned __int64 n; // [rsp+18h] [rbp-60h]\n  unsigned __int64 v45; // [rsp+20h] [rbp-58h]\n  __int64 v46; // [rsp+20h] [rbp-58h]\n  __int64 v47; // [rsp+28h] [rbp-50h]\n  __int64 v48; // [rsp+30h] [rbp-48h] BYREF\n  __int64 v49; // [rsp+38h] [rbp-40h]\n\n  v3 = 0LL;\n  v4 = 1LL;\n  v5 = 0LL;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 0xE8D6ABDCC0LL;\n  for ( i = _divmodti4(65537LL, 0LL, 0xE8D6ABDCC0LL, 0LL, &v48);\n        ;\n        i = _divmodti4(v11, *((_QWORD *)&v11 + 1), v48, v49, &v48) )\n  {\n    *(_QWORD *)&v11 = v8;\n    *((_QWORD *)&v11 + 1) = v7;\n    v8 = v48;\n    v7 = v49;\n    v12 = v6 * v10 + i * v5;\n    v13 = (unsigned __int64)v6 * (unsigned __int128)(unsigned __int64)i;\n    *((_QWORD *)&v13 + 1) += v12;\n    v16 = __PAIR128__(v3, v4) - v13;\n    v15 = v16 >> 64;\n    v14 = v16;\n    v4 = v6;\n    v3 = v5;\n    if ( 1 >= v11 )\n      break;\n    v6 = v14;\n    v5 = v15;\n  }\n  if ( v5 < 0 )\n  {\n    v17 = __PAIR128__(v5, v6) + 0xE8D6ABDCC0LL;\n    v5 = *((_QWORD *)&v17 + 1);\n    v6 = v17;\n  }\n  v18 = 17;\n  v19 = 1LL;\n  v20 = 0LL;\n  v21 = 0LL;\n  n = 0LL;\n  v22 = 3735928559LL;\n  v23 = 65537LL;\n  while ( 1 )\n  {\n    if ( (v23 & 1) != 0 )\n    {\n      v45 = v20;\n      v42 = v22;\n      v24 = _modti3(v19 * v22, (__PAIR128__(n, v19) * __PAIR128__(v20, v22)) >> 64, 0xE8D6CA6163LL, 0LL);\n      v20 = v45;\n      v22 = v42;\n      n = v25;\n      v19 = v24;\n    }\n    *(_QWORD *)&v26 = v23;\n    *((_QWORD *)&v26 + 1) = v21;\n    v23 = v26 >> 1;\n    v21 >>= 1;\n    v27 = _modti3(\n            v22 * v22,\n            (((unsigned __int64)v22 * (unsigned __int128)(unsigned __int64)v22) >> 64) + 2 * v22 * v20,\n            0xE8D6CA6163LL,\n            0LL);\n    v20 = v28;\n    v22 = v27;\n    if ( !--v18 )\n    {\n      v29 = _modti3(v19, n, 0xE8D6CA6163LL, 0LL);\n      v31 = v30;\n      if ( (v6 != 0) + v5 <= 0 )\n      {\n        v34 = 1LL;\n        v35 = 0LL;\n      }\n      else\n      {\n        v32 = v6;\n        v33 = v5;\n        v34 = 1LL;\n        v35 = 0LL;\n        do\n        {\n          if ( (v32 & 1) != 0 )\n          {\n            v46 = v32;\n            v47 = v33;\n            v43 = v31;\n            v36 = _modti3(v34 * v29, (__PAIR128__(v35, v34) * __PAIR128__(v31, v29)) >> 64, 0xE8D6CA6163LL, 0LL);\n            v32 = v46;\n            v33 = v47;\n            v31 = v43;\n            v34 = v36;\n            v35 = v37;\n          }\n          *(_QWORD *)&v38 = v32;\n          *((_QWORD *)&v38 + 1) = v33;\n          v39 = _modti3(\n                  v29 * v29,\n                  (((unsigned __int64)v29 * (unsigned __int128)(unsigned __int64)v29) >> 64) + 2 * v29 * v31,\n                  0xE8D6CA6163LL,\n                  0LL);\n          v33 = (unsigned __int128)(v38 >> 1) >> 64;\n          v32 = v38 >> 1;\n          v29 = v39;\n          v31 = v40;\n        }\n        while ( v38 >> 1 != 0 );\n      }\n      libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n      libmin_printf(\"p: \");\n      print_hex_int128(0xF4243uLL);\n      libmin_printf(\"\\nq: \");\n      print_hex_int128(0xF4261uLL);\n      libmin_printf(\"\\nn (modulus): \");\n      print_hex_int128(0xE8D6CA6163uLL);\n      libmin_printf(\"\\nphi(n): \");\n      print_hex_int128(0xE8D6ABDCC0uLL);\n      libmin_printf(\"\\n\\nPublic exponent (e): \");\n      print_hex_int128(0x10001uLL);\n      libmin_printf(\"\\nPrivate exponent (d): \");\n      *((_QWORD *)&v41 + 1) = v5;\n      *(_QWORD *)&v41 = v6;\n      print_hex_int128(v41);\n      libmin_printf(\"\\n\\nOriginal message: \");\n      print_hex_int128(0xDEADBEEFuLL);\n      libmin_printf(\"\\nEncrypted message: \");\n      *((_QWORD *)&v41 + 1) = n;\n      *(_QWORD *)&v41 = v19;\n      print_hex_int128(v41);\n      libmin_printf(\"\\nDecrypted message: \");\n      *((_QWORD *)&v41 + 1) = v35;\n      *(_QWORD *)&v41 = v34;\n      print_hex_int128(v41);\n      libmin_printf(\"\\n\");\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long i;\n  long long v10;\n  __int128 v11;\n  long long v12;\n  unsigned __int128 v13;\n  long long v14;\n  long long v15;\n  unsigned __int128 v16;\n  unsigned __int128 v17;\n  int v18;\n  long long v19;\n  unsigned long long v20;\n  long long v21;\n  long long v22;\n  long long v23;\n  long long v24;\n  unsigned long long v25;\n  __int128 v26;\n  long long v27;\n  unsigned long long v28;\n  long long v29;\n  unsigned long long v30;\n  unsigned long long v31;\n  long long v32;\n  long long v33;\n  long long v34;\n  unsigned long long v35;\n  long long v36;\n  unsigned long long v37;\n  __int128 v38;\n  long long v39;\n  unsigned long long v40;\n  int128 v41;\n  long long v42;\n  unsigned long long v43;\n  unsigned long long n;\n  unsigned long long v45;\n  long long v46;\n  long long v47;\n  long long v48;\n  long long v49;\n  v3 = 0LL;\n  v4 = 1LL;\n  v5 = 0LL;\n  v6 = 0LL;\n  v7 = 0LL;\n  v8 = 1000034000064LL;\n  for (i = _divmodti4(65537LL, 0LL, 1000034000064LL, 0LL, &v48);;\n       i = _divmodti4(v11, *((uint64_t *)&v11 + 1), v48, v49, &v48)) {\n    *(uint64_t *)&v11 = v8;\n    *((uint64_t *)&v11 + 1) = v7;\n    v8 = v48;\n    v7 = v49;\n    v12 = v6 * v10 + i * v5;\n    v13 = (unsigned long long)v6 * (unsigned __int128)(unsigned long long)i;\n    *((uint64_t *)&v13 + 1) += v12;\n    v16 = __PAIR128__(v3, v4) - v13;\n    v15 = v16 >> 64;\n    v14 = v16;\n    v4 = v6;\n    v3 = v5;\n    if (1 >= v11) break;\n    v6 = v14;\n    v5 = v15;\n  }\n  if (v5 < 0) {\n    v17 = __PAIR128__(v5, v6) + 1000034000064LL;\n    v5 = *((uint64_t *)&v17 + 1);\n    v6 = v17;\n  }\n  v18 = 17;\n  v19 = 1LL;\n  v20 = 0LL;\n  v21 = 0LL;\n  n = 0LL;\n  v22 = 3735928559LL;\n  v23 = 65537LL;\n  while (1) {\n    if ((v23 & 1) != 0) {\n      v45 = v20;\n      v42 = v22;\n      v24 = _modti3(v19 * v22,\n                    (__PAIR128__(n, v19) * __PAIR128__(v20, v22)) >> 64,\n                    1000036000099LL, 0LL);\n      v20 = v45;\n      v22 = v42;\n      n = v25;\n      v19 = v24;\n    }\n    *(uint64_t *)&v26 = v23;\n    *((uint64_t *)&v26 + 1) = v21;\n    v23 = v26 >> 1;\n    v21 >>= 1;\n    v27 = _modti3(v22 * v22,\n                  (((unsigned long long)v22 *\n                    (unsigned __int128)(unsigned long long)v22) >>\n                   64) +\n                      2 * v22 * v20,\n                  1000036000099LL, 0LL);\n    v20 = v28;\n    v22 = v27;\n    if (!--v18) {\n      v29 = _modti3(v19, n, 1000036000099LL, 0LL);\n      v31 = v30;\n      if ((v6 != 0) + v5 <= 0) {\n        v34 = 1LL;\n        v35 = 0LL;\n      } else {\n        v32 = v6;\n        v33 = v5;\n        v34 = 1LL;\n        v35 = 0LL;\n        do {\n          if ((v32 & 1) != 0) {\n            v46 = v32;\n            v47 = v33;\n            v43 = v31;\n            v36 = _modti3(v34 * v29,\n                          (__PAIR128__(v35, v34) * __PAIR128__(v31, v29)) >> 64,\n                          1000036000099LL, 0LL);\n            v32 = v46;\n            v33 = v47;\n            v31 = v43;\n            v34 = v36;\n            v35 = v37;\n          }\n          *(uint64_t *)&v38 = v32;\n          *((uint64_t *)&v38 + 1) = v33;\n          v39 = _modti3(v29 * v29,\n                        (((unsigned long long)v29 *\n                          (unsigned __int128)(unsigned long long)v29) >>\n                         64) +\n                            2 * v29 * v31,\n                        1000036000099LL, 0LL);\n          v33 = (unsigned __int128)(v38 >> 1) >> 64;\n          v32 = v38 >> 1;\n          v29 = v39;\n          v31 = v40;\n        } while (v38 >> 1 != 0);\n      }\n      libmin_printf(\"RSA Key Pair Example (Hexadecimal Output):\\n\\n\");\n      libmin_printf(\"p: \");\n      print_hex_int128(1000003uLL);\n      libmin_printf(\"\\nq: \");\n      print_hex_int128(1000033uLL);\n      libmin_printf(\"\\nn (modulus): \");\n      print_hex_int128(1000036000099uLL);\n      libmin_printf(\"\\nphi(n): \");\n      print_hex_int128(1000034000064uLL);\n      libmin_printf(\"\\n\\nPublic exponent (e): \");\n      print_hex_int128(65537uLL);\n      libmin_printf(\"\\nPrivate exponent (d): \");\n      *((uint64_t *)&v41 + 1) = v5;\n      *(uint64_t *)&v41 = v6;\n      print_hex_int128(v41);\n      libmin_printf(\"\\n\\nOriginal message: \");\n      print_hex_int128(3735928559uLL);\n      libmin_printf(\"\\nEncrypted message: \");\n      *((uint64_t *)&v41 + 1) = n;\n      *(uint64_t *)&v41 = v19;\n      print_hex_int128(v41);\n      libmin_printf(\"\\nDecrypted message: \");\n      *((uint64_t *)&v41 + 1) = v35;\n      *(uint64_t *)&v41 = v34;\n      print_hex_int128(v41);\n      libmin_printf(\"\\n\");\n      libmin_success();\n    }\n  }\n}", "binary": "rsa-cipher/rsa-cipher.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x10001,%edi\nxor    %r15d,%r15d\nxor    %esi,%esi\npush   %r14\nmov    $0x1,%r14d\npush   %r13\nxor    %r13d,%r13d\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nmovabs $0xe8d6abdcc0,%rbx\nsub    $0x48,%rsp\nlea    0x30(%rsp),%rax\nmov    %rax,(%rsp)\njmp    1146 <main+0x46>\nnop\nmov    %r8,%r12\nmov    %r9,%r13\nmov    (%rsp),%r8\nmov    %rbp,%rcx\nmov    %rbx,%rdx\ncall   3200 <__divmodti4>\nmov    %r13,%rcx\nmov    %rbx,%rdi\nmov    %rbp,%rsi\nimul   %r12,%rdx\nmov    0x30(%rsp),%rbx\nmov    0x38(%rsp),%rbp\nimul   %rax,%rcx\nadd    %rdx,%rcx\nmul    %r12\nadd    %rcx,%rdx\nsub    %rax,%r14\nmov    $0x1,%eax\nsbb    %rdx,%r15\ncmp    %rdi,%rax\nmov    $0x0,%eax\nmov    %r14,%r8\nsbb    %rsi,%rax\nmov    %r15,%r9\nmov    %r12,%r14\nmov    %r13,%r15\njl     1140 <main+0x40>\ntest   %r13,%r13\njns    11b4 <main+0xb4>\nmovabs $0xe8d6abdcc0,%rax\nxor    %edx,%edx\nadd    %rax,%r12\nadc    %rdx,%r13\nmov    $0x11,%ebp\nmov    $0x1,%ebx\nxor    %r8d,%r8d\nxor    %r15d,%r15d\nmovq   $0x0,0x18(%rsp)\nmov    $0xdeadbeef,%r9d\nmov    $0x10001,%r14d\nnopl   0x0(%rax)\ntest   $0x1,%r14b\nje     1230 <main+0x130>\nmov    0x18(%rsp),%rax\nmov    %r8,%rsi\nxor    %ecx,%ecx\nmov    %r8,0x20(%rsp)\nimul   %rbx,%rsi\nmov    %r9,(%rsp)\nimul   %r9,%rax\nadd    %rax,%rsi\nmov    %rbx,%rax\nmul    %r9\nadd    %rdx,%rsi\nmov    %rax,%rdi\nmovabs $0xe8d6ca6163,%rdx\ncall   3060 <__modti3>\nmov    0x20(%rsp),%r8\nmov    (%rsp),%r9\nmov    %rdx,0x18(%rsp)\nmov    %rax,%rbx\nimul   %r9,%r8\nmov    %r9,%rax\nxor    %ecx,%ecx\nshrd   $0x1,%r15,%r14\nmul    %r9\nsar    %r15\nlea    (%r8,%r8,1),%rsi\nadd    %rdx,%rsi\nmov    %rax,%rdi\nmovabs $0xe8d6ca6163,%rdx\ncall   3060 <__modti3>\nmov    %rdx,%r8\nmov    %rax,%r9\nsub    $0x1,%ebp\njne    11e0 <main+0xe0>\nmov    0x18(%rsp),%rsi\nxor    %ecx,%ecx\nmov    %rbx,%rdi\nmovabs $0xe8d6ca6163,%rdx\ncall   3060 <__modti3>\nmov    %rax,%r15\nxor    %eax,%eax\nmov    %rdx,%r10\ncmp    %r12,%rax\nsbb    %r13,%rax\njge    147d <main+0x37d>\nmov    %r12,%r8\nmov    %r13,%r9\nmov    $0x1,%r14d\nxor    %ebp,%ebp\nnopw   0x0(%rax,%rax,1)\ntest   $0x1,%r8b\nje     1305 <main+0x205>\nmov    %r10,%rax\nimul   %r15,%rbp\nxor    %ecx,%ecx\nmov    %r8,0x20(%rsp)\nimul   %r14,%rax\nmov    %r9,0x28(%rsp)\nmov    %r10,(%rsp)\nlea    0x0(%rbp,%rax,1),%rsi\nmov    %r14,%rax\nmul    %r15\nadd    %rdx,%rsi\nmov    %rax,%rdi\nmovabs $0xe8d6ca6163,%rdx\ncall   3060 <__modti3>\nmov    0x20(%rsp),%r8\nmov    0x28(%rsp),%r9\nmov    (%rsp),%r10\nmov    %rax,%r14\nmov    %rdx,%rbp\nmov    %r10,%rsi\nmov    %r15,%rax\nshrd   $0x1,%r9,%r8\nxor    %ecx,%ecx\nimul   %r15,%rsi\nsar    %r9\nmov    %r8,(%rsp)\nmul    %r15\nmov    %r9,0x8(%rsp)\nadd    %rsi,%rsi\nadd    %rdx,%rsi\nmov    %rax,%rdi\nmovabs $0xe8d6ca6163,%rdx\ncall   3060 <__modti3>\nmov    0x8(%rsp),%r9\nmov    (%rsp),%r8\nmov    %rax,%r15\nmov    %rdx,%r10\nmov    %r9,%rax\nor     %r8,%rax\njne    12b0 <main+0x1b0>\nlea    0x2d59(%rip),%rdi\nxor    %eax,%eax\ncall   2de0 <libmin_printf>\nlea    0x2cb3(%rip),%rdi\nxor    %eax,%eax\ncall   2de0 <libmin_printf>\nxor    %esi,%esi\nmov    $0xf4243,%edi\ncall   1790 <print_hex_int128>\nlea    0x2c9d(%rip),%rdi\nxor    %eax,%eax\ncall   2de0 <libmin_printf>\nxor    %esi,%esi\nmov    $0xf4261,%edi\ncall   1790 <print_hex_int128>\nlea    0x2c88(%rip),%rdi\nxor    %eax,%eax\ncall   2de0 <libmin_printf>\nxor    %esi,%esi\nmovabs $0xe8d6ca6163,%rdi\ncall   1790 <print_hex_int128>\nlea    0x2c78(%rip),%rdi\nxor    %eax,%eax\ncall   2de0 <libmin_printf>\nxor    %esi,%esi\nmovabs $0xe8d6abdcc0,%rdi\ncall   1790 <print_hex_int128>\nlea    0x2c63(%rip),%rdi\nxor    %eax,%eax\ncall   2de0 <libmin_printf>\nxor    %esi,%esi\nmov    $0x10001,%edi\ncall   1790 <print_hex_int128>\nlea    0x2c61(%rip),%rdi\nxor    %eax,%eax\ncall   2de0 <libmin_printf>\nmov    %r13,%rsi\nmov    %r12,%rdi\ncall   1790 <print_hex_int128>\nlea    0x2c60(%rip),%rdi\nxor    %eax,%eax\ncall   2de0 <libmin_printf>\nxor    %esi,%esi\nmov    $0xdeadbeef,%edi\ncall   1790 <print_hex_int128>\nlea    0x2c5b(%rip),%rdi\nxor    %eax,%eax\ncall   2de0 <libmin_printf>\nmov    0x18(%rsp),%rsi\nmov    %rbx,%rdi\ncall   1790 <print_hex_int128>\nxor    %eax,%eax\nlea    0x2c53(%rip),%rdi\ncall   2de0 <libmin_printf>\nmov    %rbp,%rsi\nmov    %r14,%rdi\ncall   1790 <print_hex_int128>\nlea    0x2c51(%rip),%rdi\nxor    %eax,%eax\ncall   2de0 <libmin_printf>\ncall   3020 <libmin_success>\nadd    $0x48,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nmov    $0x1,%r14d\nxor    %ebp,%ebp\njmp    1358 <main+0x258>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "rsa-cipher/rsa-cipher.c", "function_name": "mod_inverse", "content": "// Extended Euclidean Algorithm: returns d such that (a*d) % mod == 1\nint128 mod_inverse(int128 a, int128 mod) {\n    int128 m0 = mod, t, q;\n    int128 x0 = 0, x1 = 1;\n    \n    if (mod == 1)\n        return 0;\n    \n    while (a > 1) {\n        q = a / mod;\n        t = mod;\n        mod = a % mod;\n        a = t;\n        \n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    \n    if (x1 < 0)\n        x1 += m0;\n    return x1;\n}\n"}, "pseudo": {"path": "rsa-cipher/rsa-cipher.host.O2.pseudo", "function_name": "mod_inverse", "address": "0x1670", "label": "mod_inverse", "content": "int128 __fastcall mod_inverse(int128 a, int128 mod)\n{\n  __int64 v2; // rbx\n  __int64 v3; // rbp\n  __int64 v4; // r13\n  __int64 v5; // r12\n  __int64 v6; // r14\n  __int64 v7; // r15\n  __int64 i; // rax\n  __int64 v9; // rdx\n  unsigned __int128 v10; // kr00_16\n  __int64 v11; // r8\n  __int64 v12; // r9\n  __int128 v13; // rdi\n  __int64 v14; // rcx\n  unsigned __int128 v15; // rax\n  int128 result; // rax\n  unsigned __int128 v17; // kr10_16\n  __int64 v19; // [rsp+20h] [rbp-48h] BYREF\n  __int64 v20; // [rsp+28h] [rbp-40h]\n\n  if ( *((_QWORD *)&mod + 1) | (unsigned __int64)mod ^ 1 )\n  {\n    if ( 1 >= a )\n    {\n      v6 = 1LL;\n      v7 = 0LL;\n    }\n    else\n    {\n      v2 = mod;\n      v3 = *((_QWORD *)&mod + 1);\n      v4 = 0LL;\n      v5 = 1LL;\n      v6 = 0LL;\n      v7 = 0LL;\n      for ( i = _divmodti4(a, *((_QWORD *)&a + 1), mod, *((_QWORD *)&mod + 1), &v19);\n            ;\n            i = _divmodti4(v13, *((_QWORD *)&v13 + 1), v19, v20, &v19) )\n      {\n        v11 = v5;\n        *(_QWORD *)&v13 = v2;\n        v12 = v4;\n        *((_QWORD *)&v13 + 1) = v3;\n        v2 = v19;\n        v3 = v20;\n        v5 = v6;\n        v4 = v7;\n        v14 = v6 * v9 + i * v7;\n        v15 = (unsigned __int64)v6 * (unsigned __int128)(unsigned __int64)i;\n        *((_QWORD *)&v15 + 1) += v14;\n        if ( 1 >= v13 )\n          break;\n        v10 = __PAIR128__(v12, v11) - v15;\n        v7 = v10 >> 64;\n        v6 = v10;\n      }\n      if ( v7 < 0 )\n      {\n        v17 = mod + __PAIR128__(v7, v6);\n        v7 = (mod + __PAIR128__(v7, v6)) >> 64;\n        v6 = v17;\n      }\n    }\n  }\n  else\n  {\n    v6 = 0LL;\n    v7 = 0LL;\n  }\n  *(_QWORD *)&result = v6;\n  *((_QWORD *)&result + 1) = v7;\n  return result;\n}\n"}, "pseudo_normalize": "int128 mod_inverse(int128 a, int128 mod) {\n  long long v2;\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  long long i;\n  long long v9;\n  unsigned __int128 v10;\n  long long v11;\n  long long v12;\n  __int128 v13;\n  long long v14;\n  unsigned __int128 v15;\n  int128 result;\n  unsigned __int128 v17;\n  long long v19;\n  long long v20;\n  if (*((uint64_t *)&mod + 1) | (unsigned long long)mod ^ 1) {\n    if (1 >= a) {\n      v6 = 1LL;\n      v7 = 0LL;\n    } else {\n      v2 = mod;\n      v3 = *((uint64_t *)&mod + 1);\n      v4 = 0LL;\n      v5 = 1LL;\n      v6 = 0LL;\n      v7 = 0LL;\n      for (i = _divmodti4(a, *((uint64_t *)&a + 1), mod,\n                          *((uint64_t *)&mod + 1), &v19);\n           ; i = _divmodti4(v13, *((uint64_t *)&v13 + 1), v19, v20, &v19)) {\n        v11 = v5;\n        *(uint64_t *)&v13 = v2;\n        v12 = v4;\n        *((uint64_t *)&v13 + 1) = v3;\n        v2 = v19;\n        v3 = v20;\n        v5 = v6;\n        v4 = v7;\n        v14 = v6 * v9 + i * v7;\n        v15 = (unsigned long long)v6 * (unsigned __int128)(unsigned long long)i;\n        *((uint64_t *)&v15 + 1) += v14;\n        if (1 >= v13) break;\n        v10 = __PAIR128__(v12, v11) - v15;\n        v7 = v10 >> 64;\n        v6 = v10;\n      }\n      if (v7 < 0) {\n        v17 = mod + __PAIR128__(v7, v6);\n        v7 = (mod + __PAIR128__(v7, v6)) >> 64;\n        v6 = v17;\n      }\n    }\n  } else {\n    v6 = 0LL;\n    v7 = 0LL;\n  }\n  *(uint64_t *)&result = v6;\n  *((uint64_t *)&result + 1) = v7;\n  return result;\n}", "binary": "rsa-cipher/rsa-cipher.host.O2", "assembly": "<mod_inverse>:\nendbr64\npush   %r15\nmov    %rdx,%rax\nmov    %rcx,%rdx\npush   %r14\nmov    %rax,%rcx\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x38,%rsp\nmov    %rax,0x10(%rsp)\nxor    $0x1,%rax\nor     %rdx,%rax\nmov    %rdx,0x18(%rsp)\nje     1770 <mod_inverse+0x100>\nmov    $0x1,%eax\ncmp    %rdi,%rax\nmov    $0x0,%eax\nsbb    %rsi,%rax\njge    1780 <mod_inverse+0x110>\nlea    0x20(%rsp),%rax\nmov    %rcx,%rbx\nmov    %rdx,%rbp\nxor    %r13d,%r13d\nmov    %rax,0x8(%rsp)\nmov    $0x1,%r12d\nxor    %r14d,%r14d\nxor    %r15d,%r15d\njmp    16e6 <mod_inverse+0x76>\nnopl   0x0(%rax)\nmov    %r8,%r14\nmov    %r9,%r15\nmov    0x8(%rsp),%r8\nmov    %rbp,%rcx\nmov    %rbx,%rdx\ncall   3200 <__divmodti4>\nmov    %r15,%rcx\nmov    %r12,%r8\nmov    %rbx,%rdi\nimul   %r14,%rdx\nmov    %r13,%r9\nmov    %rbp,%rsi\nmov    0x20(%rsp),%rbx\nimul   %rax,%rcx\nmov    0x28(%rsp),%rbp\nmov    %r14,%r12\nmov    %r15,%r13\nadd    %rdx,%rcx\nmul    %r14\nadd    %rcx,%rdx\nsub    %rax,%r8\nmov    $0x1,%eax\nsbb    %rdx,%r9\ncmp    %rdi,%rax\nmov    $0x0,%eax\nsbb    %rsi,%rax\njl     16e0 <mod_inverse+0x70>\ntest   %r15,%r15\njs     1760 <mod_inverse+0xf0>\nadd    $0x38,%rsp\nmov    %r14,%rax\nmov    %r15,%rdx\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nadd    0x10(%rsp),%r14\nadc    0x18(%rsp),%r15\njmp    1743 <mod_inverse+0xd3>\nnopl   0x0(%rax)\nxor    %r14d,%r14d\nxor    %r15d,%r15d\njmp    1743 <mod_inverse+0xd3>\nnopl   0x0(%rax,%rax,1)\nmov    $0x1,%r14d\nxor    %r15d,%r15d\njmp    1743 <mod_inverse+0xd3>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "rsa-cipher/rsa-cipher.c", "function_name": "mod_pow", "content": "// Fast modular exponentiation: computes (base^exp) mod mod\nint128 mod_pow(int128 base, int128 exp, int128 mod) {\n    int128 result = 1;\n    base = base % mod;\n    while (exp > 0) {\n        if (exp & 1)\n            result = (result * base) % mod;\n        exp = exp >> 1;\n        base = (base * base) % mod;\n    }\n    return result;\n}\n"}, "pseudo": {"path": "rsa-cipher/rsa-cipher.host.O2.pseudo", "function_name": "mod_pow", "address": "0x1580", "label": "mod_pow", "content": "__int64 __fastcall mod_pow(int128 base, int128 exp, int128 mod)\n{\n  __int64 v3; // r15\n  __int64 v4; // r14\n  __int64 v5; // r13\n  __int64 v6; // r12\n  unsigned __int64 v7; // rdx\n  __int64 v8; // r9\n  unsigned __int64 v9; // r8\n  __int64 v10; // rbx\n  unsigned __int64 v11; // rbp\n  __int64 v12; // rax\n  unsigned __int64 v13; // rdx\n  __int128 v14; // rt0\n  unsigned __int64 v15; // rdx\n  __int64 v17; // [rsp+0h] [rbp-48h]\n  unsigned __int64 v18; // [rsp+8h] [rbp-40h]\n\n  v3 = *((_QWORD *)&mod + 1);\n  v4 = mod;\n  v5 = *((_QWORD *)&exp + 1);\n  v6 = exp;\n  v8 = _modti3(base, *((_QWORD *)&base + 1), mod, *((_QWORD *)&mod + 1));\n  if ( (v6 != 0) + v5 <= 0 )\n    return 1LL;\n  v9 = v7;\n  v10 = 1LL;\n  v11 = 0LL;\n  do\n  {\n    if ( (v6 & 1) != 0 )\n    {\n      v18 = v9;\n      v17 = v8;\n      v12 = _modti3(v10 * v8, (__PAIR128__(v11, v10) * __PAIR128__(v9, v8)) >> 64, v4, v3);\n      v9 = v18;\n      v8 = v17;\n      v10 = v12;\n      v11 = v13;\n    }\n    *(_QWORD *)&v14 = v6;\n    *((_QWORD *)&v14 + 1) = v5;\n    v6 = v14 >> 1;\n    v5 >>= 1;\n    v8 = _modti3(\n           v8 * v8,\n           (((unsigned __int64)v8 * (unsigned __int128)(unsigned __int64)v8) >> 64) + 2 * v8 * v9,\n           v4,\n           v3);\n    v9 = v15;\n  }\n  while ( v14 >> 1 != 0 );\n  return v10;\n}\n"}, "pseudo_normalize": "long long mod_pow(int128 base, int128 exp, int128 mod) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  unsigned long long v7;\n  long long v8;\n  unsigned long long v9;\n  long long v10;\n  unsigned long long v11;\n  long long v12;\n  unsigned long long v13;\n  __int128 v14;\n  unsigned long long v15;\n  long long v17;\n  unsigned long long v18;\n  v3 = *((uint64_t *)&mod + 1);\n  v4 = mod;\n  v5 = *((uint64_t *)&exp + 1);\n  v6 = exp;\n  v8 = _modti3(base, *((uint64_t *)&base + 1), mod, *((uint64_t *)&mod + 1));\n  if ((v6 != 0) + v5 <= 0) return 1LL;\n  v9 = v7;\n  v10 = 1LL;\n  v11 = 0LL;\n  do {\n    if ((v6 & 1) != 0) {\n      v18 = v9;\n      v17 = v8;\n      v12 =\n          _modti3(v10 * v8, (__PAIR128__(v11, v10) * __PAIR128__(v9, v8)) >> 64,\n                  v4, v3);\n      v9 = v18;\n      v8 = v17;\n      v10 = v12;\n      v11 = v13;\n    }\n    *(uint64_t *)&v14 = v6;\n    *((uint64_t *)&v14 + 1) = v5;\n    v6 = v14 >> 1;\n    v5 >>= 1;\n    v8 = _modti3(\n        v8 * v8,\n        (((unsigned long long)v8 * (unsigned __int128)(unsigned long long)v8) >>\n         64) +\n            2 * v8 * v9,\n        v4, v3);\n    v9 = v15;\n  } while (v14 >> 1 != 0);\n  return v10;\n}", "binary": "rsa-cipher/rsa-cipher.host.O2", "assembly": "<mod_pow>:\nendbr64\npush   %r15\nmov    %r9,%r15\npush   %r14\nmov    %r8,%r14\npush   %r13\nmov    %rcx,%r13\nmov    %r9,%rcx\npush   %r12\nmov    %rdx,%r12\nmov    %r8,%rdx\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\ncall   3060 <__modti3>\nmov    %rax,%r9\nxor    %eax,%eax\ncmp    %r12,%rax\nsbb    %r13,%rax\njge    1658 <mod_pow+0xd8>\nmov    %rdx,%r8\nmov    $0x1,%ebx\nxor    %ebp,%ebp\nnopl   0x0(%rax)\ntest   $0x1,%r12b\nje     160b <mod_pow+0x8b>\nmov    %r8,%rsi\nimul   %r9,%rbp\nmov    %rbx,%rax\nmov    %r15,%rcx\nimul   %rbx,%rsi\nmov    %r8,0x8(%rsp)\nmul    %r9\nmov    %r9,(%rsp)\nadd    %rbp,%rsi\nadd    %rdx,%rsi\nmov    %rax,%rdi\nmov    %r14,%rdx\ncall   3060 <__modti3>\nmov    0x8(%rsp),%r8\nmov    (%rsp),%r9\nmov    %rax,%rbx\nmov    %rdx,%rbp\nimul   %r9,%r8\nmov    %r9,%rax\nmov    %r15,%rcx\nshrd   $0x1,%r13,%r12\nmul    %r9\nsar    %r13\nlea    (%r8,%r8,1),%rsi\nadd    %rdx,%rsi\nmov    %rax,%rdi\nmov    %r14,%rdx\ncall   3060 <__modti3>\nmov    %rax,%r9\nmov    %r13,%rax\nmov    %rdx,%r8\nor     %r12,%rax\njne    15c8 <mod_pow+0x48>\nadd    $0x18,%rsp\nmov    %rbx,%rax\nmov    %rbp,%rdx\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   (%rax)\nmov    $0x1,%ebx\nxor    %ebp,%ebp\njmp    1640 <mod_pow+0xc0>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "rsa-cipher/rsa-cipher.c", "function_name": "print_hex_int128", "content": "// Helper function to print a 128-bit number in hexadecimal.\n// It converts the number to a 32-digit hex string, then trims leading zeros.\nvoid print_hex_int128(int128 n) {\n    if (n == 0) {\n        libmin_printf(\"0x0\");\n        return;\n    }\n    if (n < 0) {\n        libmin_printf(\"-\");\n        n = -n;\n    }\n    \n    // 128 bits = 32 hex digits; extra one for the null terminator\n    char hex_digits[33];\n    hex_digits[32] = '\\0';\n    \n    // Fill the array from the least-significant nibble upward.\n    for (int i = 31; i >= 0; i--) {\n        hex_digits[i] = \"0123456789abcdef\"[n & 0xF];\n        n >>= 4;\n    }\n    \n    // Skip over any leading zeros for a cleaner output.\n    int j = 0;\n    while (hex_digits[j] == '0' && hex_digits[j+1] != '\\0') {\n        j++;\n    }\n    libmin_printf(\"0x%s\", &hex_digits[j]);\n}\n"}, "pseudo": {"path": "rsa-cipher/rsa-cipher.host.O2.pseudo", "function_name": "print_hex_int128", "address": "0x1790", "label": "print_hex_int128", "content": "void __fastcall print_hex_int128(int128 n)\n{\n  __int128 v1; // kr00_16\n  char *v2; // rax\n  char *v3; // rdx\n  char v4; // dl\n  __int64 v5; // rax\n  __int64 v6; // rcx\n  char hex_digits[40]; // [rsp+0h] [rbp-48h] BYREF\n  unsigned __int64 v8; // [rsp+28h] [rbp-20h]\n\n  v8 = __readfsqword(0x28u);\n  if ( n == 0 )\n  {\n    libmin_printf(\"0x0\");\n  }\n  else\n  {\n    v1 = n;\n    if ( n < 0 )\n    {\n      libmin_printf(\"-\");\n      v1 = -n;\n    }\n    hex_digits[32] = 0;\n    v2 = &hex_digits[31];\n    do\n    {\n      *v2 = a0123456789abcd[v1 & 0xF];\n      v3 = v2--;\n      v1 >>= 4;\n    }\n    while ( v3 != hex_digits );\n    v4 = hex_digits[0];\n    v5 = 0LL;\n    do\n    {\n      v6 = (int)v5;\n      if ( v4 != 48 )\n        break;\n      v4 = hex_digits[++v5];\n    }\n    while ( v4 );\n    libmin_printf(\"0x%s\", &hex_digits[v6]);\n  }\n}\n"}, "pseudo_normalize": "void print_hex_int128(int128 n) {\n  __int128 v1;\n  char *v2;\n  char *v3;\n  char v4;\n  long long v5;\n  long long v6;\n  char hex_digits[40];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  if (n == 0) {\n    libmin_printf(\"0\");\n  } else {\n    v1 = n;\n    if (n < 0) {\n      libmin_printf(\"-\");\n      v1 = -n;\n    }\n    hex_digits[32] = 0;\n    v2 = &hex_digits[31];\n    do {\n      *v2 = a0123456789abcd[v1 & 15];\n      v3 = v2--;\n      v1 >>= 4;\n    } while (v3 != hex_digits);\n    v4 = hex_digits[0];\n    v5 = 0LL;\n    do {\n      v6 = (int)v5;\n      if (v4 != 48) break;\n      v4 = hex_digits[++v5];\n    } while (v4);\n    libmin_printf(\"0x%s\", &hex_digits[v6]);\n  }\n}", "binary": "rsa-cipher/rsa-cipher.host.O2", "assembly": "<print_hex_int128>:\nendbr64\npush   %r13\npush   %r12\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nmov    %rsi,%rax\nor     %rdi,%rax\nje     184e <print_hex_int128+0xbe>\nmov    %rdi,%r12\nmov    %rsi,%r13\ntest   %rsi,%rsi\njs     1874 <print_hex_int128+0xe4>\nmovb   $0x0,0x20(%rsp)\nmov    %rsp,%rsi\nlea    0x1f(%rsp),%rax\nlea    0x2836(%rip),%rcx\nnopl   0x0(%rax)\nmov    %r12,%rdx\nshrd   $0x4,%r13,%r12\nand    $0xf,%edx\nsar    $0x4,%r13\nmovzbl (%rcx,%rdx,1),%edx\nmov    %dl,(%rax)\nmov    %rax,%rdx\nsub    $0x1,%rax\ncmp    %rsi,%rdx\njne    17e0 <print_hex_int128+0x50>\nmovzbl (%rsp),%edx\nxor    %eax,%eax\njmp    181c <print_hex_int128+0x8c>\nnopl   0x0(%rax)\nadd    $0x1,%rax\nmovzbl (%rsi,%rax,1),%edx\ntest   %dl,%dl\nje     1824 <print_hex_int128+0x94>\nmovslq %eax,%rcx\ncmp    $0x30,%dl\nje     1810 <print_hex_int128+0x80>\nadd    %rcx,%rsi\nxor    %eax,%eax\nlea    0x27da(%rip),%rdi\ncall   2de0 <libmin_printf>\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1891 <print_hex_int128+0x101>\nadd    $0x38,%rsp\npop    %r12\npop    %r13\nret\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1891 <print_hex_int128+0x101>\nadd    $0x38,%rsp\nlea    0x279b(%rip),%rdi\nxor    %eax,%eax\npop    %r12\npop    %r13\njmp    2de0 <libmin_printf>\nxor    %eax,%eax\nlea    0x278b(%rip),%rdi\ncall   2de0 <libmin_printf>\nneg    %r12\nadc    $0x0,%r13\nneg    %r13\njmp    17c5 <print_hex_int128+0x35>\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "conflict", "content": "// Function to check if the current assignment causes a conflict.\n// For each clause, if all literals are assigned and none is true, then a conflict exists.\nint conflict() {\n    for (int i = 0; i < NUM_CLAUSES; i++) {\n        int satisfied = 0;\n        int fully_assigned = 1;\n        for (int j = 0; j < MAX_LITERALS && formula[i][j] != 0; j++) {\n            int lit = formula[i][j];\n            int var = (lit > 0) ? lit : -lit;\n            int val = assignment[var];\n            if (val == UNASSIGNED) {\n                fully_assigned = 0;\n            } else {\n                // For a positive literal, it is satisfied if the value is 1;\n                // for a negative literal, it is satisfied if the value is 0.\n                if ((lit > 0 && val == 1) || (lit < 0 && val == 0)) {\n                    satisfied = 1;\n                    break;  // This clause is satisfied.\n                }\n            }\n        }\n        // If a clause is fully assigned and not satisfied, there is a conflict.\n        if (!satisfied && fully_assigned)\n            return 1;\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O2.pseudo", "function_name": "conflict", "address": "0x1260", "label": "conflict", "content": "int __cdecl conflict()\n{\n  int *v0; // rsi\n  int v1; // eax\n  int *v2; // rcx\n  int v3; // r8d\n  int v4; // edx\n  int v5; // edx\n\n  v0 = formula[1];\n  v1 = 1;\n  while ( 1 )\n  {\n    v2 = v0 - 4;\n    v3 = 1;\n    if ( v1 )\n    {\n      while ( 1 )\n      {\n        v4 = -v1;\n        if ( v1 > 0 )\n          v4 = v1;\n        v5 = assignment[v4];\n        if ( v5 == -1 )\n        {\n          v3 = 0;\n        }\n        else if ( v1 > 0 && v5 == 1 || v1 < 0 && !v5 )\n        {\n          goto LABEL_13;\n        }\n        if ( v0 != ++v2 )\n        {\n          v1 = *v2;\n          if ( *v2 )\n            continue;\n        }\n        break;\n      }\n    }\n    if ( v3 )\n      return v3;\nLABEL_13:\n    if ( v0 == formula[10] )\n      return 0;\n    v1 = *v0;\n    v0 += 4;\n  }\n}\n"}, "pseudo_normalize": "int conflict() {\n  int *v0;\n  int v1;\n  int *v2;\n  int v3;\n  int v4;\n  int v5;\n  v0 = formula[1];\n  v1 = 1;\n  while (1) {\n    v2 = v0 - 4;\n    v3 = 1;\n    if (v1) {\n      while (1) {\n        v4 = -v1;\n        if (v1 > 0) v4 = v1;\n        v5 = assignment[v4];\n        if (v5 == -1) {\n          v3 = 0;\n        } else if (v1 > 0 && v5 == 1 || v1 < 0 && !v5) {\n          goto LABEL_13;\n        }\n        if (v0 != ++v2) {\n          v1 = *v2;\n          if (*v2) continue;\n        }\n        break;\n      }\n    }\n    if (v3) return v3;\n  LABEL_13:\n    if (v0 == formula[10]) return 0;\n    v1 = *v0;\n    v0 += 4;\n  }\n}", "binary": "sat-solver/sat-solver.host.O2", "assembly": "<conflict>:\nendbr64\nlea    0x1e45(%rip),%rsi\nmov    $0x1,%eax\nlea    0x4009(%rip),%rdi\nlea    0x90(%rsi),%r9\nxchg   %ax,%ax\nlea    -0x10(%rsi),%rcx\nmov    $0x1,%r8d\ntest   %eax,%eax\nje     12c0 <conflict+0x60>\nmov    %eax,%edx\nneg    %edx\ncmovs  %eax,%edx\nmovslq %edx,%rdx\nmov    (%rdi,%rdx,4),%edx\ncmp    $0xffffffff,%edx\nje     12d8 <conflict+0x78>\ntest   %eax,%eax\njle    12a9 <conflict+0x49>\ncmp    $0x1,%edx\nje     12c5 <conflict+0x65>\ntest   %eax,%eax\njns    12b1 <conflict+0x51>\ntest   %edx,%edx\nje     12c5 <conflict+0x65>\nadd    $0x4,%rcx\ncmp    %rcx,%rsi\nje     12c0 <conflict+0x60>\nmov    (%rcx),%eax\ntest   %eax,%eax\njne    128e <conflict+0x2e>\ntest   %r8d,%r8d\njne    12e3 <conflict+0x83>\ncmp    %r9,%rsi\nje     12e0 <conflict+0x80>\nmov    (%rsi),%eax\nadd    $0x10,%rsi\njmp    1280 <conflict+0x20>\nnopw   0x0(%rax,%rax,1)\nxor    %r8d,%r8d\njmp    12b1 <conflict+0x51>\nnopl   (%rax)\nxor    %r8d,%r8d\nmov    %r8d,%eax\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "main", "content": "int main() {\n    // Initialize all variables to UNASSIGNED.\n    for (int i = 1; i <= NUM_VARS; i++) {\n        assignment[i] = UNASSIGNED;\n    }\n    \n    printFormula();\n\n    if (solveSAT(1)) {\n        libmin_printf(\"SAT solution found:\\n\");\n        printAssignment();\n        libtarg_success();\n    } else {\n        libmin_printf(\"No SAT solution exists.\\n\");\n        libtarg_fail(1);\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  *(_OWORD *)&assignment[1] = -1LL;\n  *(_OWORD *)&assignment[5] = -1LL;\n  printFormula();\n  if ( solveSAT(1) )\n  {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  *(long double *)&assignment[1] = -1LL;\n  *(long double *)&assignment[5] = -1LL;\n  printFormula();\n  if (solveSAT(1)) {\n    libmin_printf(\"SAT solution found:\\n\", argv);\n    printAssignment();\n    libtarg_success();\n  }\n  libmin_printf(\"No SAT solution exists.\\n\", argv);\n  libtarg_fail(1);\n}", "binary": "sat-solver/sat-solver.host.O2", "assembly": "<main>:\nendbr64\npush   %rax\npop    %rax\npcmpeqd %xmm0,%xmm0\nxor    %eax,%eax\nsub    $0x8,%rsp\nmovups %xmm0,0x416d(%rip)\nmovups %xmm0,0x4176(%rip)\ncall   1390 <printFormula>\nmov    $0x1,%edi\ncall   12f0 <solveSAT>\ntest   %eax,%eax\nje     114b <main+0x4b>\nlea    0x1efb(%rip),%rdi\nxor    %eax,%eax\ncall   29f0 <libmin_printf>\nxor    %eax,%eax\ncall   1440 <printAssignment>\ncall   14b0 <libtarg_success>\nlea    0x1ef6(%rip),%rdi\nxor    %eax,%eax\ncall   29f0 <libmin_printf>\nmov    $0x1,%edi\ncall   14d0 <libtarg_fail>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "printAssignment", "content": "// Utility to print the variable assignments once a solution is found.\nvoid printAssignment() {\n    libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n    for (int i = 1; i <= NUM_VARS; i++) {\n        libmin_printf(\"x%d = %s\\n\", i, (assignment[i] == 1 ? \"true\" : \"false\"));\n    }\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O2.pseudo", "function_name": "printAssignment", "address": "0x1440", "label": "printAssignment", "content": "void __cdecl printAssignment()\n{\n  __int64 v0; // rbx\n  const char *v1; // rdx\n  __int64 v2; // rsi\n\n  v0 = 1LL;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  do\n  {\n    v1 = \"false\";\n    v2 = (unsigned int)v0;\n    if ( assignment[v0] == 1 )\n      v1 = \"true\";\n    ++v0;\n    libmin_printf(\"x%d = %s\\n\", v2, v1);\n  }\n  while ( v0 != 9 );\n}\n"}, "pseudo_normalize": "void printAssignment() {\n  long long v0;\n  const char *v1;\n  long long v2;\n  v0 = 1LL;\n  libmin_printf(\"SAT Solution (Variable Assignment):\\n\");\n  do {\n    v1 = \"false\";\n    v2 = (unsigned int)v0;\n    if (assignment[v0] == 1) v1 = \"true\";\n    ++v0;\n    libmin_printf(\"x%d = %s\\n\", v2, v1);\n  } while (v0 != 9);\n}", "binary": "sat-solver/sat-solver.host.O2", "assembly": "<printAssignment>:\nendbr64\npush   %r14\nlea    0x1c1b(%rip),%rdi\nxor    %eax,%eax\nlea    0x3e2a(%rip),%r14\npush   %r13\nlea    0x1bca(%rip),%r13\npush   %r12\nlea    0x1bb6(%rip),%r12\npush   %rbp\nlea    0x1bb3(%rip),%rbp\npush   %rbx\nmov    $0x1,%ebx\ncall   29f0 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\ncmpl   $0x1,(%r14,%rbx,4)\nmov    %rbp,%rdx\nmov    %ebx,%esi\nmov    %r13,%rdi\ncmove  %r12,%rdx\nxor    %eax,%eax\nadd    $0x1,%rbx\ncall   29f0 <libmin_printf>\ncmp    $0x9,%rbx\njne    1480 <printAssignment+0x40>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "printFormula", "content": "// Utility to print the CNF formula.\nvoid printFormula() {\n    libmin_printf(\"CNF Formula:\\n\");\n    for (int i = 0; i < NUM_CLAUSES; i++) {\n        libmin_printf(\"(\");\n        for (int j = 0; j < MAX_LITERALS && formula[i][j] != 0; j++) {\n            int lit = formula[i][j];\n            if (lit < 0)\n                libmin_printf(\"x%d \", -lit);\n            else\n                libmin_printf(\"x%d \", lit);\n        }\n        libmin_printf(\")\\n\");\n    }\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O2.pseudo", "function_name": "printFormula", "address": "0x1390", "label": "printFormula", "content": "void __cdecl printFormula()\n{\n  char *v0; // rbx\n  char *v1; // r15\n  int v2; // esi\n\n  v0 = (char *)formula[1];\n  libmin_printf(\"CNF Formula:\\n\");\n  do\n  {\n    v1 = v0 - 16;\n    libmin_printf(\"(\");\n    do\n    {\n      v2 = *(_DWORD *)v1;\n      if ( !*(_DWORD *)v1 )\n        break;\n      if ( v2 < 0 )\n        libmin_printf((char *)&byte_3014, (unsigned int)-v2);\n      else\n        libmin_printf(\"x%d \", v2);\n      v1 += 4;\n    }\n    while ( v1 != v0 );\n    v0 += 16;\n    libmin_printf(\")\\n\");\n  }\n  while ( v0 != \"n for %lu us.\\n\" );\n}\n"}, "pseudo_normalize": "void printFormula() {\n  char *v0;\n  char *v1;\n  int v2;\n  v0 = (char *)formula[1];\n  libmin_printf(\"CNF Formula:\\n\");\n  do {\n    v1 = v0 - 16;\n    libmin_printf(\"(\");\n    do {\n      v2 = *(uint32_t *)v1;\n      if (!*(uint32_t *)v1) break;\n      if (v2 < 0)\n        libmin_printf((char *)&byte_3014, (unsigned int)-v2);\n      else\n        libmin_printf(\"x%d \", v2);\n      v1 += 4;\n    } while (v1 != v0);\n    v0 += 16;\n    libmin_printf(\")\\n\");\n  } while (v0 != \"n for %lu us.\\n\");\n}", "binary": "sat-solver/sat-solver.host.O2", "assembly": "<printFormula>:\nendbr64\npush   %r15\nlea    0x1c67(%rip),%rdi\nxor    %eax,%eax\npush   %r14\nlea    0x1c6a(%rip),%r14\npush   %r13\nlea    0x1c6a(%rip),%r13\npush   %r12\nlea    0x1c5a(%rip),%r12\npush   %rbp\nlea    0x1c54(%rip),%rbp\npush   %rbx\nlea    0x1ce6(%rip),%rbx\nsub    $0x8,%rsp\ncall   29f0 <libmin_printf>\nnopl   0x0(%rax,%rax,1)\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    -0x10(%rbx),%r15\ncall   29f0 <libmin_printf>\nmov    (%r15),%esi\ntest   %esi,%esi\nje     1402 <printFormula+0x72>\njs     1430 <printFormula+0xa0>\nmov    %rbp,%rdi\nxor    %eax,%eax\ncall   29f0 <libmin_printf>\nadd    $0x4,%r15\ncmp    %rbx,%r15\njne    13e6 <printFormula+0x56>\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x10,%rbx\ncall   29f0 <libmin_printf>\nlea    0x1d39(%rip),%rax\ncmp    %rax,%rbx\njne    13d8 <printFormula+0x48>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\nneg    %esi\nmov    %r12,%rdi\nxor    %eax,%eax\ncall   29f0 <libmin_printf>\njmp    13f9 <printFormula+0x69>\nxchg   %ax,%ax\n"}
{"source": {"path": "sat-solver/sat-solver.c", "function_name": "solveSAT", "content": "// Recursive backtracking solver.\n// 'var' is the current variable index to assign (starting at 1).\n// Returns 1 if a satisfying assignment is found.\nint solveSAT(int var) {\n    if (var > NUM_VARS) {\n        // All variables are assigned.\n        return conflict() ? 0 : 1;\n    }\n    // Try both truth values: 0 (false) and 1 (true).\n    for (int v = 0; v < 2; v++) {\n        assignment[var] = v;\n        if (!conflict() && solveSAT(var + 1))\n            return 1;\n    }\n    assignment[var] = UNASSIGNED;  // Backtrack.\n    return 0;\n}\n"}, "pseudo": {"path": "sat-solver/sat-solver.host.O2.pseudo", "function_name": "solveSAT", "address": "0x12f0", "label": "solveSAT", "content": "int __fastcall solveSAT(int var)\n{\n  if ( var > 8 )\n    return conflict() == 0;\n  assignment[var] = 0;\n  if ( !conflict() && solveSAT(var + 1) )\n    return 1;\n  assignment[var] = 1;\n  if ( !conflict() )\n  {\n    if ( solveSAT(var + 1) )\n      return 1;\n  }\n  assignment[var] = -1;\n  return 0;\n}\n"}, "pseudo_normalize": "int solveSAT(int var) {\n  if (var > 8) return conflict() == 0;\n  assignment[var] = 0;\n  if (!conflict() && solveSAT(var + 1)) return 1;\n  assignment[var] = 1;\n  if (!conflict()) {\n    if (solveSAT(var + 1)) return 1;\n  }\n  assignment[var] = -1;\n  return 0;\n}", "binary": "sat-solver/sat-solver.host.O2", "assembly": "<solveSAT>:\nendbr64\npush   %r12\npush   %rbp\npush   %rbx\ncmp    $0x8,%edi\njg     1370 <solveSAT+0x80>\nlea    0x3f7c(%rip),%r12\nmovslq %edi,%rbp\nxor    %eax,%eax\nmov    %edi,%ebx\nmovl   $0x0,(%r12,%rbp,4)\ncall   1260 <conflict>\ntest   %eax,%eax\nje     1340 <solveSAT+0x50>\nxor    %eax,%eax\nmovl   $0x1,(%r12,%rbp,4)\ncall   1260 <conflict>\ntest   %eax,%eax\nje     1358 <solveSAT+0x68>\nmovl   $0xffffffff,(%r12,%rbp,4)\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nxchg   %ax,%ax\nlea    0x1(%rbx),%edi\ncall   12f0 <solveSAT>\ntest   %eax,%eax\nje     131c <solveSAT+0x2c>\nmov    $0x1,%eax\njmp    1339 <solveSAT+0x49>\nnopl   0x0(%rax,%rax,1)\nlea    0x1(%rbx),%edi\ncall   12f0 <solveSAT>\ntest   %eax,%eax\nje     132f <solveSAT+0x3f>\njmp    134c <solveSAT+0x5c>\ncs nopw 0x0(%rax,%rax,1)\nxor    %eax,%eax\ncall   1260 <conflict>\npop    %rbx\npop    %rbp\ntest   %eax,%eax\npop    %r12\nsete   %al\nmovzbl %al,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "shortest-path/shortest-path.c", "function_name": "floydWarshall", "content": "// Solves the all-pairs shortest path problem using Floyd Warshall algorithm\nvoid\nfloydWarshall (int graph[][V])\n{\n  /* dist[][] will be the output matrix that will finally have the shortest \n    distances between every pair of vertices */\n  int i, j, k;\n \n  /* Initialize the solution matrix same as input graph matrix. Or \n     we can say the initial values of shortest distances are based\n     on shortest paths considering no intermediate vertex. */\n  for (i = 0; i < V; i++)\n    for (j = 0; j < V; j++)\n      dist[i][j] = graph[i][j];\n \n  /* Add all vertices one by one to the set of intermediate vertices.\n    ---> Before start of a iteration, we have shortest distances between all\n    pairs of vertices such that the shortest distances consider only the\n    vertices in set {0, 1, 2, .. k-1} as intermediate vertices.\n    ----> After the end of a iteration, vertex no. k is added to the set of\n    intermediate vertices and the set becomes {0, 1, 2, .. k} */\n  for (k = 0; k < V; k++)\n  {\n    // Pick all vertices as source one by one\n    for (i = 0; i < V; i++)\n    {\n      // Pick all vertices as destination for the\n      // above picked source\n      for (j = 0; j < V; j++)\n      {\n        // If vertex k is on the shortest path from\n        // i to j, then update the value of dist[i][j]\n        if (dist[i][k] + dist[k][j] < dist[i][j])\n          dist[i][j] = dist[i][k] + dist[k][j];\n      }\n    }\n  }\n}\n"}, "pseudo": {"path": "shortest-path/shortest-path.host.O2.pseudo", "function_name": "floydWarshall", "address": "0x13c0", "label": "floydWarshall", "content": "void __fastcall floydWarshall(int (*graph)[8])\n{\n  int *v2; // rcx\n  __int64 i; // rax\n  int *v4; // r11\n  __int64 j; // r9\n  int *v6; // rsi\n  int *v7; // r8\n  __int64 v8; // rdi\n  int *v9; // rax\n  int v10; // edx\n\n  v2 = dist[0];\n  do\n  {\n    for ( i = 0LL; i != 8; ++i )\n      v2[i] = (*graph)[i];\n    v2 += 8;\n    ++graph;\n  }\n  while ( v2 != dist[8] );\n  v4 = dist[0];\n  for ( j = 0LL; j != 64; j += 8LL )\n  {\n    v6 = dist[1];\n    v7 = v4;\n    v8 = 0LL;\n    do\n    {\n      v9 = v6 - 8;\n      do\n      {\n        v10 = v9[v8 + j] + *v7;\n        if ( v10 < *v9 )\n          *v9 = v10;\n        ++v9;\n      }\n      while ( v9 != v6 );\n      v6 = v9 + 8;\n      v7 += 8;\n      v8 -= 8LL;\n    }\n    while ( v9 + 8 != dist[9] );\n    ++v4;\n  }\n}\n"}, "pseudo_normalize": "void floydWarshall(int (*graph)[8]) {\n  int *v2;\n  long long i;\n  int *v4;\n  long long j;\n  int *v6;\n  int *v7;\n  long long v8;\n  int *v9;\n  int v10;\n  v2 = dist[0];\n  do {\n    for (i = 0LL; i != 8; ++i) v2[i] = (*graph)[i];\n    v2 += 8;\n    ++graph;\n  } while (v2 != dist[8]);\n  v4 = dist[0];\n  for (j = 0LL; j != 64; j += 8LL) {\n    v6 = dist[1];\n    v7 = v4;\n    v8 = 0LL;\n    do {\n      v9 = v6 - 8;\n      do {\n        v10 = v9[v8 + j] + *v7;\n        if (v10 < *v9) *v9 = v10;\n        ++v9;\n      } while (v9 != v6);\n      v6 = v9 + 8;\n      v7 += 8;\n      v8 -= 8LL;\n    } while (v9 + 8 != dist[9]);\n    ++v4;\n  }\n}", "binary": "shortest-path/shortest-path.host.O2", "assembly": "<floydWarshall>:\nendbr64\npush   %rbx\nlea    0x3eb4(%rip),%r8\nmov    %rdi,%rsi\nmov    %r8,%rcx\nlea    0x100(%r8),%rdi\nnopl   0x0(%rax)\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmov    (%rsi,%rax,1),%edx\nmov    %edx,(%rcx,%rax,1)\nadd    $0x4,%rax\ncmp    $0x20,%rax\njne    13e8 <floydWarshall+0x28>\nadd    $0x20,%rcx\nadd    $0x20,%rsi\ncmp    %rdi,%rcx\njne    13e0 <floydWarshall+0x20>\nlea    0x3e74(%rip),%r11\nxor    %r9d,%r9d\nlea    0x20(%r8),%rbx\nlea    0x120(%r8),%r10\nnopw   0x0(%rax,%rax,1)\nmov    %rbx,%rsi\nmov    %r11,%r8\nxor    %edi,%edi\nnopl   0x0(%rax,%rax,1)\nlea    -0x20(%rsi),%rax\nnopl   0x0(%rax)\nlea    (%rax,%rdi,1),%rcx\nmov    (%r8),%edx\nadd    (%rcx,%r9,1),%edx\ncmp    (%rax),%edx\njge    1449 <floydWarshall+0x89>\nmov    %edx,(%rax)\nadd    $0x4,%rax\ncmp    %rsi,%rax\njne    1438 <floydWarshall+0x78>\nlea    0x20(%rax),%rsi\nadd    $0x20,%r8\nsub    $0x20,%rdi\ncmp    %r10,%rsi\njne    1430 <floydWarshall+0x70>\nadd    $0x20,%r9\nadd    $0x4,%r11\ncmp    $0x100,%r9\njne    1420 <floydWarshall+0x60>\npop    %rbx\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "shortest-path/shortest-path.c", "function_name": "main", "content": " \n// driver program to test above function\nint\nmain(void)\n{\n  /* Let us create the following weighted graph\n          10\n     (0)------->(3)\n      |         /|\\\n    5 |          |\n      |          | 1\n     \\|/         |\n     (1)------->(2)\n          3           */\n#ifdef notdef\n  int graph[V][V] = { {0,   5,  INF, 10},\n                      {INF, 0,   3, INF},\n                      {INF, INF, 0,   1},\n                      {INF, INF, INF, 0}\n                    };\n#endif /* notdef */\n\tint graph[V][V] = {\n  // Vertex # A  B  C  D  E  F  G  H\t   Vertex\n            { 0, N, 4, N, N, 7, N, N }, // A\n\t\t\t      { N, 0, N, N, 9, N, N, 3 }, // B\n\t\t\t      { 4, N, 0, 3, N, 2, 9, N }, // C\t\n\t\t\t      { N, N, 3, 0, 3, N, 7, N }, // D\n\t\t\t      { N, 9, N, 3, 0, N, 2, 7 }, // E\n\t\t\t      { 7, N, 2, N, N, 0, 8, N }, // F\n\t\t\t      { N, N, 9, 7, 2, 8, 0, 3 }, // G\n\t\t\t      { N, 3, N, N, 7, N, 3, 0 } };//H\n\n \n  // Print the solution\n  floydWarshall(graph);\n \n  // Print the shortest distance matrix\n  printSolution(dist);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "shortest-path/shortest-path.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int graph[8][8]; // [rsp+0h] [rbp-118h] BYREF\n  unsigned __int64 v4; // [rsp+108h] [rbp-10h]\n\n  v4 = __readfsqword(0x28u);\n  *(_QWORD *)&graph[0][0] = 0x1869F00000000LL;\n  *(_QWORD *)&graph[1][4] = 0x1869F00000009LL;\n  *(_QWORD *)&graph[4][4] = 0x1869F00000000LL;\n  *(_QWORD *)&graph[4][6] = 0x700000002LL;\n  *(_QWORD *)&graph[5][2] = 0x1869F00000002LL;\n  *(_QWORD *)&graph[5][6] = 0x1869F00000008LL;\n  *(_QWORD *)&graph[2][6] = 0x1869F00000009LL;\n  *(_QWORD *)&graph[6][2] = 0x700000009LL;\n  *(_QWORD *)&graph[0][2] = 0x1869F00000004LL;\n  *(_QWORD *)&graph[0][4] = 0x70001869FLL;\n  *(_QWORD *)&graph[2][0] = 0x1869F00000004LL;\n  *(_QWORD *)&graph[3][4] = 0x1869F00000003LL;\n  *(_QWORD *)&graph[6][4] = 0x800000002LL;\n  *(_QWORD *)&graph[0][6] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[1][2] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[3][0] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[6][0] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[1][6] = 0x30001869FLL;\n  *(_QWORD *)&graph[2][2] = 0x300000000LL;\n  *(_QWORD *)&graph[2][4] = 0x20001869FLL;\n  *(_QWORD *)&graph[3][6] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[4][0] = 0x90001869FLL;\n  *(_QWORD *)&graph[4][2] = 0x30001869FLL;\n  *(_QWORD *)&graph[5][0] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[6][6] = 0x300000000LL;\n  *(_QWORD *)&graph[7][0] = 0x30001869FLL;\n  *(_QWORD *)&graph[1][0] = 99999LL;\n  *(_QWORD *)&graph[3][2] = 3LL;\n  *(_QWORD *)&graph[5][4] = 99999LL;\n  *(_QWORD *)&graph[7][2] = 0x1869F0001869FLL;\n  *(_QWORD *)&graph[7][4] = 0x1869F00000007LL;\n  *(_QWORD *)&graph[7][6] = 3LL;\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int graph[8][8];\n  unsigned long long v4;\n  v4 = __readfsqword(40u);\n  *(uint64_t *)&graph[0][0] = 429492434632704LL;\n  *(uint64_t *)&graph[1][4] = 429492434632713LL;\n  *(uint64_t *)&graph[4][4] = 429492434632704LL;\n  *(uint64_t *)&graph[4][6] = 30064771074LL;\n  *(uint64_t *)&graph[5][2] = 429492434632706LL;\n  *(uint64_t *)&graph[5][6] = 429492434632712LL;\n  *(uint64_t *)&graph[2][6] = 429492434632713LL;\n  *(uint64_t *)&graph[6][2] = 30064771081LL;\n  *(uint64_t *)&graph[0][2] = 429492434632708LL;\n  *(uint64_t *)&graph[0][4] = 30064871071LL;\n  *(uint64_t *)&graph[2][0] = 429492434632708LL;\n  *(uint64_t *)&graph[3][4] = 429492434632707LL;\n  *(uint64_t *)&graph[6][4] = 34359738370LL;\n  *(uint64_t *)&graph[0][6] = 429492434732703LL;\n  *(uint64_t *)&graph[1][2] = 429492434732703LL;\n  *(uint64_t *)&graph[3][0] = 429492434732703LL;\n  *(uint64_t *)&graph[6][0] = 429492434732703LL;\n  *(uint64_t *)&graph[1][6] = 12885001887LL;\n  *(uint64_t *)&graph[2][2] = 12884901888LL;\n  *(uint64_t *)&graph[2][4] = 8590034591LL;\n  *(uint64_t *)&graph[3][6] = 429492434632711LL;\n  *(uint64_t *)&graph[4][0] = 38654805663LL;\n  *(uint64_t *)&graph[4][2] = 12885001887LL;\n  *(uint64_t *)&graph[5][0] = 429492434632711LL;\n  *(uint64_t *)&graph[6][6] = 12884901888LL;\n  *(uint64_t *)&graph[7][0] = 12885001887LL;\n  *(uint64_t *)&graph[1][0] = 99999LL;\n  *(uint64_t *)&graph[3][2] = 3LL;\n  *(uint64_t *)&graph[5][4] = 99999LL;\n  *(uint64_t *)&graph[7][2] = 429492434732703LL;\n  *(uint64_t *)&graph[7][4] = 429492434632711LL;\n  *(uint64_t *)&graph[7][6] = 3LL;\n  floydWarshall(graph);\n  printSolution(dist);\n  libmin_success();\n}", "binary": "shortest-path/shortest-path.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x118,%rsp\nmovabs $0x1869f00000000,%rdi\nmovabs $0x1869f00000009,%rdx\nmovabs $0x1869f00000004,%rsi\nmov    %fs:0x28,%rax\nmov    %rax,0x108(%rsp)\nxor    %eax,%eax\nmov    %rdi,(%rsp)\nmovabs $0x70001869f,%rax\nmovabs $0x30001869f,%rcx\nmovabs $0x20001869f,%r8\nmov    %rdx,0x30(%rsp)\nmovabs $0x90001869f,%r9\nmov    %rdi,0x90(%rsp)\nmovabs $0x700000002,%rdi\nmov    %rdi,0x98(%rsp)\nmovabs $0x1869f00000002,%rdi\nmov    %rdi,0xa8(%rsp)\nadd    $0x6,%rdi\nmov    %rdi,0xb8(%rsp)\nmovabs $0x700000009,%rdi\nmov    %rdx,0x58(%rsp)\nsub    $0x6,%rdx\nmov    %rdi,0xc8(%rsp)\nmovabs $0x800000002,%rdi\nmov    %rsi,0x8(%rsp)\nmov    %rax,0x10(%rsp)\nmovabs $0x1869f0001869f,%rax\nmov    %rsi,0x40(%rsp)\nmovabs $0x300000000,%rsi\nmov    %rdx,0x70(%rsp)\nadd    $0x4,%rdx\nmov    %rdi,0xd0(%rsp)\nmov    %rsp,%rdi\nmov    %rax,0x18(%rsp)\nmov    %rax,0x28(%rsp)\nmov    %rax,0x60(%rsp)\nmov    %rax,0xc0(%rsp)\nmov    %rcx,0x38(%rsp)\nmov    %rsi,0x48(%rsp)\nmov    %r8,0x50(%rsp)\nmov    %rdx,0x78(%rsp)\nmov    %r9,0x80(%rsp)\nmov    %rcx,0x88(%rsp)\nmov    %rdx,0xa0(%rsp)\nmov    %rsi,0xd8(%rsp)\nmov    %rcx,0xe0(%rsp)\nmovq   $0x1869f,0x20(%rsp)\nmovq   $0x3,0x68(%rsp)\nmovq   $0x1869f,0xb0(%rsp)\nmov    %rax,0xe8(%rsp)\nmov    %rdx,0xf0(%rsp)\nmovq   $0x3,0xf8(%rsp)\ncall   13c0 <floydWarshall>\nlea    0x3fe6(%rip),%rdi\ncall   1480 <printSolution>\ncall   2cc0 <libmin_success>\nmov    0x108(%rsp),%rax\nsub    %fs:0x28,%rax\njne    12c1 <main+0x1c1>\nxor    %eax,%eax\nadd    $0x118,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "shortest-path/shortest-path.c", "function_name": "printSolution", "content": " \n/* A utility function to print solution */\nvoid\nprintSolution(int dist[][V])\n{\n    libmin_printf (\"Following matrix shows the shortest distances\"\n                   \" between every pair of vertices \\n\");\n    for (int i = 0; i < V; i++)\n    {\n        for (int j = 0; j < V; j++)\n        {\n            if (dist[i][j] == INF)\n                libmin_printf(\"%7s\", \"INF\");\n            else\n                libmin_printf (\"%7d\", dist[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "shortest-path/shortest-path.host.O2.pseudo", "function_name": "printSolution", "address": "0x1480", "label": "printSolution", "content": "void __fastcall printSolution(int (*dist)[8])\n{\n  int *v1; // rbx\n  int *v2; // r14\n  int v3; // esi\n\n  v1 = &(*dist)[8];\n  libmin_printf(\"Following matrix shows the shortest distances between every pair of vertices \\n\");\n  do\n  {\n    v2 = v1 - 8;\n    do\n    {\n      while ( 1 )\n      {\n        v3 = *v2;\n        if ( *v2 == 99999 )\n          break;\n        ++v2;\n        libmin_printf(\"%7d\", v3);\n        if ( v2 == v1 )\n          goto LABEL_6;\n      }\n      ++v2;\n      libmin_printf(\"%7s\", \"INF\");\n    }\n    while ( v2 != v1 );\nLABEL_6:\n    v1 = v2 + 8;\n    libmin_printf(\"\\n\");\n  }\n  while ( v2 + 8 != &(*dist)[72] );\n}\n"}, "pseudo_normalize": "void printSolution(int (*dist)[8]) {\n  int *v1;\n  int *v2;\n  int v3;\n  v1 = &(*dist)[8];\n  libmin_printf(\n      \"Following matrix shows the shortest distances between every pair of \"\n      \"vertices \\n\");\n  do {\n    v2 = v1 - 8;\n    do {\n      while (1) {\n        v3 = *v2;\n        if (*v2 == 99999) break;\n        ++v2;\n        libmin_printf(\"%7d\", v3);\n        if (v2 == v1) goto LABEL_6;\n      }\n      ++v2;\n      libmin_printf(\"%7s\", \"INF\");\n    } while (v2 != v1);\n  LABEL_6:\n    v1 = v2 + 8;\n    libmin_printf(\"\\n\");\n  } while (v2 + 8 != &(*dist)[72]);\n}", "binary": "shortest-path/shortest-path.host.O2", "assembly": "<printSolution>:\nendbr64\npush   %r15\nxor    %eax,%eax\nlea    0x1bd4(%rip),%r15\npush   %r14\nmov    %rdi,%r14\nlea    0x1b6d(%rip),%rdi\npush   %r13\nlea    0x1bb3(%rip),%r13\npush   %r12\nlea    0x1bae(%rip),%r12\npush   %rbp\nlea    0x1baa(%rip),%rbp\npush   %rbx\nlea    0x20(%r14),%rbx\nsub    $0x18,%rsp\ncall   2a80 <libmin_printf>\nlea    0x120(%r14),%rax\nmov    %rax,0x8(%rsp)\nnop\nlea    -0x20(%rbx),%r14\njmp    14f3 <printSolution+0x73>\ncs nopw 0x0(%rax,%rax,1)\nmov    %rbp,%rdi\nxor    %eax,%eax\nadd    $0x4,%r14\ncall   2a80 <libmin_printf>\ncmp    %rbx,%r14\nje     1514 <printSolution+0x94>\nmov    (%r14),%esi\ncmp    $0x1869f,%esi\njne    14e0 <printSolution+0x60>\nmov    %r13,%rsi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x4,%r14\ncall   2a80 <libmin_printf>\ncmp    %rbx,%r14\njne    14f3 <printSolution+0x73>\nmov    %r15,%rdi\nxor    %eax,%eax\nlea    0x20(%r14),%rbx\ncall   2a80 <libmin_printf>\ncmp    0x8(%rsp),%rbx\njne    14d0 <printSolution+0x50>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "sieve/sieve.c", "function_name": "main", "content": "int\nmain(void)\n{\n\n  long  j,p;\n\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\");\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n\t\n  j = 1024;\n  p = 1;\n  SIEVE(j,p);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "sieve/sieve.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // r10\n  __int64 v4; // r9\n  unsigned __int64 v5; // r8\n  __int64 v6; // rdx\n  char *v7; // rcx\n  __int64 v8; // rax\n\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv, envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  v3 = 0LL;\n  v4 = 0LL;\n  v5 = 3LL;\n  v6 = 3LL;\n  memset(flags, 1u, 0x400uLL);\n  v7 = flags;\n  while ( 1 )\n  {\n    if ( *v7 )\n    {\n      ++v4;\n      v3 = v6;\n      v8 = v5;\n      if ( v5 <= 0x3FF )\n      {\n        do\n        {\n          flags[v8] = 0;\n          v8 += v6;\n        }\n        while ( v8 <= 1023 );\n      }\n    }\n    ++v7;\n    v6 += 2LL;\n    v5 += 3LL;\n    if ( &flags[1024] == v7 )\n    {\n      libmin_printf(\"  %9ld   %8ld     %8ld\\n\", 1024LL, v4, v3);\n      libmin_success();\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  unsigned long long v5;\n  long long v6;\n  char *v7;\n  long long v8;\n  libmin_printf(\"\\n   Sieve of Eratosthenes (Scaled to 10 Iterations)\\n\", argv,\n                envp);\n  libmin_printf(\"   Version 1.2b, 26 Sep 1992\\n\\n\");\n  libmin_printf(\"   Array Size   Number   Last Prime\\n\");\n  libmin_printf(\"    (Bytes)   of Primes\\n\");\n  v3 = 0LL;\n  v4 = 0LL;\n  v5 = 3LL;\n  v6 = 3LL;\n  memset(flags, 1u, 1024uLL);\n  v7 = flags;\n  while (1) {\n    if (*v7) {\n      ++v4;\n      v3 = v6;\n      v8 = v5;\n      if (v5 <= 1023) {\n        do {\n          flags[v8] = 0;\n          v8 += v6;\n        } while (v8 <= 1023);\n      }\n    }\n    ++v7;\n    v6 += 2LL;\n    v5 += 3LL;\n    if (&flags[1024] == v7) {\n      libmin_printf(\"  %9ld   %8ld     %8ld\\n\", 1024LL, v4, v3);\n      libmin_success();\n    }\n  }\n}", "binary": "sieve/sieve.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nlea    0x1ef9(%rip),%rdi\nxor    %eax,%eax\ncall   2820 <libmin_printf>\nlea    0x1f23(%rip),%rdi\nxor    %eax,%eax\ncall   2820 <libmin_printf>\nlea    0x1f35(%rip),%rdi\nxor    %eax,%eax\ncall   2820 <libmin_printf>\nlea    0x1f4c(%rip),%rdi\nxor    %eax,%eax\ncall   2820 <libmin_printf>\nmov    $0x80,%ecx\nxor    %r10d,%r10d\nxor    %r9d,%r9d\nlea    0x412e(%rip),%rsi\nmov    $0x3,%r8d\nmov    $0x3,%edx\nmovabs $0x101010101010101,%rax\nmov    %rsi,%rdi\nrep stos %rax,%es:(%rdi)\nmov    %rsi,%rcx\njmp    1189 <main+0x89>\nnopw   0x0(%rax,%rax,1)\nadd    $0x1,%rcx\nadd    $0x2,%rdx\nadd    $0x3,%r8\ncmp    %rcx,%rdi\nje     11c0 <main+0xc0>\ncmpb   $0x0,(%rcx)\nje     1178 <main+0x78>\nadd    $0x1,%r9\nmov    %rdx,%r10\nmov    %r8,%rax\ncmp    $0x3ff,%r8\nja     1178 <main+0x78>\nnopl   0x0(%rax)\nmovb   $0x0,(%rsi,%rax,1)\nadd    %rdx,%rax\ncmp    $0x3ff,%rax\njle    11a8 <main+0xa8>\njmp    1178 <main+0x78>\nnopl   0x0(%rax)\nmov    %r10,%rcx\nmov    %r9,%rdx\nmov    $0x400,%esi\nxor    %eax,%eax\nlea    0x1eca(%rip),%rdi\ncall   2820 <libmin_printf>\ncall   2a60 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "simple-grep/simple-grep.c", "function_name": "main", "content": "int\nmain(void)\n{\n  int ac = 3; char *av[] = { \"simple-grep\", \"speech.txt\", \"the\" };\n  char lineBuffer[BUFFER_LENGTH+1];\n  MFILE *fp = &speech;\n  int count = 0;\n\n  if (ac < 3)\n  {\n    libmin_printf(\"A string pattern and a file name are required\\n\" );\n    return 1;\n  }\n\n  libmin_mopen(&speech, \"r\");\n  if (!fp)\n  {\n    libmin_printf(\"Error - unable to open %s\\n\", av[1]);\n    return 2;\n  }\n\n  while (libmin_mgets(lineBuffer, BUFFER_LENGTH, fp))\n  {\n    // libmin_printf(\"%s\\n\", lineBuffer);\n    if (libmin_strstr(lineBuffer, av[2]))\n    {\n      libmin_printf(\"%s\", lineBuffer);\n      ++count;\n    }\n  }\n  libmin_mclose(fp);\n\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", count, av[2]);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "simple-grep/simple-grep.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r13d\n  char lineBuffer[520]; // [rsp+0h] [rbp-238h] BYREF\n  unsigned __int64 v5; // [rsp+208h] [rbp-30h]\n\n  v3 = 0;\n  v5 = __readfsqword(0x28u);\n  libmin_mopen(&speech, \"r\");\n  while ( libmin_mgets(lineBuffer, 0x1FFuLL, &speech) )\n  {\n    if ( libmin_strstr(lineBuffer, \"the\") )\n    {\n      ++v3;\n      libmin_printf(\"%s\", lineBuffer);\n    }\n  }\n  libmin_mclose(&speech);\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", v3, \"the\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  char lineBuffer[520];\n  unsigned long long v5;\n  v3 = 0;\n  v5 = __readfsqword(40u);\n  libmin_mopen(&speech, \"r\");\n  while (libmin_mgets(lineBuffer, 511uLL, &speech)) {\n    if (libmin_strstr(lineBuffer, \"the\")) {\n      ++v3;\n      libmin_printf(\"%s\", lineBuffer);\n    }\n  }\n  libmin_mclose(&speech);\n  libmin_printf(\"INFO: found (at least) %d occurrences of the word `%s'.\\n\", v3,\n                \"the\");\n  libmin_success();\n}", "binary": "simple-grep/simple-grep.host.O2", "assembly": "<main>:\nendbr64\npush   %r14\nlea    0x2ed7(%rip),%rsi\nlea    0x2ed6(%rip),%r14\npush   %r13\nxor    %r13d,%r13d\npush   %r12\nlea    0x2ec4(%rip),%r12\npush   %rbp\nlea    0x6ed6(%rip),%rbp\npush   %rbx\nmov    %rbp,%rdi\nsub    $0x210,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x208(%rsp)\nxor    %eax,%eax\nmov    %rsp,%rbx\ncall   16c0 <libmin_mopen>\njmp    1188 <main+0x68>\nnopw   0x0(%rax,%rax,1)\nmov    %r12,%rsi\nmov    %rbx,%rdi\ncall   2d60 <libmin_strstr>\ntest   %rax,%rax\njne    11e8 <main+0xc8>\nmov    %rbp,%rdx\nmov    $0x1ff,%esi\nmov    %rbx,%rdi\ncall   14e0 <libmin_mgets>\ntest   %rax,%rax\njne    1178 <main+0x58>\nmov    %rbp,%rdi\ncall   14d0 <libmin_mclose>\nmov    %r12,%rdx\nmov    %r13d,%esi\nxor    %eax,%eax\nlea    0x2e64(%rip),%rdi\ncall   2a70 <libmin_printf>\ncall   2dd0 <libmin_success>\nmov    0x208(%rsp),%rax\nsub    %fs:0x28,%rax\njne    11fb <main+0xdb>\nadd    $0x210,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax,%rax,1)\nmov    %rbx,%rsi\nmov    %r14,%rdi\nxor    %eax,%eax\nadd    $0x1,%r13d\ncall   2a70 <libmin_printf>\njmp    1188 <main+0x68>\ncall   10c0 <__stack_chk_fail@plt>\n"}
{"source": {"path": "skeleton/skeleton.c", "function_name": "main", "content": "#include \"libmin.h\"\n\nint\nmain(void)\n{\n  libmin_printf(\"This is a test!, %d, %f...\\n\", 23, 44.4);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "skeleton/skeleton.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"This is a test!, %d, %f...\\n\", 23, 44.4);\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "skeleton/skeleton.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x17,%esi\nmov    $0x1,%eax\nmovsd  0x1f06(%rip),%xmm0\nlea    0x1ee3(%rip),%rdi\ncall   2770 <libmin_printf>\ncall   29b0 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "spelt2num/spelt2num.c", "function_name": "main", "content": "int main(){char **r;int e=0;for(;n++||(e=*p++)>0;b=\"ynwtsflrabg\"[n%=11]-e?b:b*8+n)for(r=(char **)(b%64-25);e<47&&b;b/=8)for(n=19;n;(void)(((n[\"1+DIY/.K430x9G(kC[\"]-42)&255)^b||(m+=n>15?n:n>9?m%u*~-u:~(long)r?n+!(long)r*16:n*16,b=0)))u=1ll<<6177%n--*4;libmin_printf(\"%llx\\n\",m);libmin_success();}\n"}, "pseudo": {"path": "spelt2num/spelt2num.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rcx\n  __int64 v4; // rax\n  __int64 v5; // r14\n  __int64 v6; // r12\n  __int64 v7; // r13\n  __int64 v8; // r9\n  __int64 v9; // rbx\n  __int64 v10; // rsi\n  char v11; // bp\n  char v12; // dl\n  char i; // al\n  __int64 v14; // rdi\n  char v15; // al\n  __int64 v16; // rdx\n  int e; // [rsp+Ch] [rbp-4Ch]\n  __int64 v18; // [rsp+10h] [rbp-48h]\n  char *v19; // [rsp+18h] [rbp-40h]\n\n  v4 = n;\n  e = 0;\n  v19 = p;\n  v18 = m;\n  while ( 1 )\n  {\n    v5 = v4 + 1;\n    n = v4 + 1;\n    if ( !v4 )\n    {\n      p = v19 + 1;\n      e = *v19;\n      if ( e <= 0 )\n      {\n        libmin_printf(\"%llx\\n\", v18);\n        libmin_success();\n      }\n      ++v19;\n    }\n    v6 = b;\n    v7 = b % 64;\n    if ( e <= 46 )\n    {\n      v8 = b;\n      v9 = v18;\n      v10 = v4 + 1;\n      v11 = 0;\n      v12 = 0;\n      for ( i = 0; v8; i = 1 )\n      {\n        v10 = 19LL;\n        while ( v10 )\n        {\n          v14 = v10 - 1;\n          v12 = 1;\n          v3 = 1LL << (4 * (unsigned __int8)(6177 % v10));\n          v15 = a1DiyK430x9gKc[--v10];\n          if ( (unsigned __int8)(v15 - 42) == v8 )\n          {\n            v16 = v14;\n            if ( v14 <= 15 )\n            {\n              if ( v14 <= 9 )\n              {\n                v16 = 16 * v14;\n                if ( v7 != 24 )\n                  v16 = v14 + 16LL * (v7 == 25);\n              }\n              else\n              {\n                v16 = (v3 - 1) * (v9 % v3);\n              }\n            }\n            v9 += v16;\n            v10 = v14;\n            v11 = 1;\n            v8 = 0LL;\n            v12 = 1;\n          }\n        }\n        v8 /= 8LL;\n      }\n      if ( v11 )\n      {\n        m = v9;\n        v18 = v9;\n      }\n      if ( i )\n      {\n        if ( v12 )\n          u = v3;\n        v6 = 0LL;\n        v5 = v10;\n      }\n      else if ( v12 )\n      {\n        u = v3;\n      }\n    }\n    v4 = v5 % 11;\n    if ( aYnwtsflrabg[v5 % 11] == e )\n      v6 = v5 % 11 + 8 * v6;\n    b = v6;\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  long long v4;\n  long long v5;\n  long long v6;\n  long long v7;\n  long long v8;\n  long long v9;\n  long long v10;\n  char v11;\n  char v12;\n  char i;\n  long long v14;\n  char v15;\n  long long v16;\n  int e;\n  long long v18;\n  char *v19;\n  v4 = n;\n  e = 0;\n  v19 = p;\n  v18 = m;\n  while (1) {\n    v5 = v4 + 1;\n    n = v4 + 1;\n    if (!v4) {\n      p = v19 + 1;\n      e = *v19;\n      if (e <= 0) {\n        libmin_printf(\"%llx\\n\", v18);\n        libmin_success();\n      }\n      ++v19;\n    }\n    v6 = b;\n    v7 = b % 64;\n    if (e <= 46) {\n      v8 = b;\n      v9 = v18;\n      v10 = v4 + 1;\n      v11 = 0;\n      v12 = 0;\n      for (i = 0; v8; i = 1) {\n        v10 = 19LL;\n        while (v10) {\n          v14 = v10 - 1;\n          v12 = 1;\n          v3 = 1LL << (4 * (unsigned char)(6177 % v10));\n          v15 = a1DiyK430x9gKc[--v10];\n          if ((unsigned char)(v15 - 42) == v8) {\n            v16 = v14;\n            if (v14 <= 15) {\n              if (v14 <= 9) {\n                v16 = 16 * v14;\n                if (v7 != 24) v16 = v14 + 16LL * (v7 == 25);\n              } else {\n                v16 = (v3 - 1) * (v9 % v3);\n              }\n            }\n            v9 += v16;\n            v10 = v14;\n            v11 = 1;\n            v8 = 0LL;\n            v12 = 1;\n          }\n        }\n        v8 /= 8LL;\n      }\n      if (v11) {\n        m = v9;\n        v18 = v9;\n      }\n      if (i) {\n        if (v12) u = v3;\n        v6 = 0LL;\n        v5 = v10;\n      } else if (v12) {\n        u = v3;\n      }\n    }\n    v4 = v5 % 11;\n    if (aYnwtsflrabg[v5 % 11] == e) v6 = v5 % 11 + 8 * v6;\n    b = v6;\n  }\n}", "binary": "spelt2num/spelt2num.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x1821,%r8d\nmov    $0x1,%r11d\nlea    0x1eeb(%rip),%r10\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmov    0x3ee4(%rip),%rbx\nmov    0x4155(%rip),%rax\nmovl   $0x0,0xc(%rsp)\nmov    %rbx,0x18(%rsp)\nmov    0x4131(%rip),%rbx\nmov    %rbx,0x10(%rsp)\nlea    0x1(%rax),%r14\nmov    %r14,0x4131(%rip)\ntest   %rax,%rax\njne    1180 <main+0x80>\nmov    0x18(%rsp),%rbx\nlea    0x1(%rbx),%rax\nmov    %rax,0x3ea4(%rip)\nmovsbl (%rbx),%ebx\nmov    %ebx,0xc(%rsp)\ntest   %ebx,%ebx\njle    1316 <main+0x216>\nmov    %rax,0x18(%rsp)\nmov    0x40e9(%rip),%r12\nmov    %r12,%rax\nsar    $0x3f,%rax\nshr    $0x3a,%rax\nlea    (%r12,%rax,1),%r13\nand    $0x3f,%r13d\nsub    %rax,%r13\ncmpl   $0x2e,0xc(%rsp)\njg     1264 <main+0x164>\nxor    %r15d,%r15d\ncmp    $0x19,%r13\nmov    %r12,%r9\nmov    0x10(%rsp),%rbx\nsete   %r15b\nmov    %r14,%rsi\nxor    %ebp,%ebp\nxor    %edx,%edx\nshl    $0x4,%r15\nxor    %eax,%eax\ntest   %r9,%r9\nje     123a <main+0x13a>\nnopl   (%rax)\nmov    $0x13,%esi\njmp    1219 <main+0x119>\nnopw   0x0(%rax,%rax,1)\nmov    %r8,%rax\nlea    -0x1(%rsi),%rdi\ncqto\nidiv   %rsi\nmov    %r11,%rax\nlea    0x0(,%rdx,4),%ecx\nmov    $0x1,%edx\nshl    %cl,%rax\nmov    %rax,%rcx\nmovsbl -0x1(%r10,%rsi,1),%eax\nmov    %rdi,%rsi\nsub    $0x2a,%eax\nmovzbl %al,%eax\ncmp    %r9,%rax\nje     12b8 <main+0x1b8>\ntest   %rsi,%rsi\njne    11e0 <main+0xe0>\ntest   %r9,%r9\nlea    0x7(%r9),%rax\ncmovns %r9,%rax\nsar    $0x3,%rax\nmov    %rax,%r9\nmov    $0x1,%eax\ntest   %r9,%r9\njne    11d0 <main+0xd0>\ntest   %bpl,%bpl\nje     124b <main+0x14b>\nmov    %rbx,0x4032(%rip)\nmov    %rbx,0x10(%rsp)\ntest   %al,%al\nje     1302 <main+0x202>\ntest   %dl,%dl\nje     125e <main+0x15e>\nmov    %rcx,0x4022(%rip)\nxor    %r12d,%r12d\nmov    %rsi,%r14\nmovabs $0x2e8ba2e8ba2e8ba3,%rdx\nmov    %r14,%rax\nimul   %rdx\nmov    %rdx,%rax\nmov    %r14,%rdx\nsar    $0x3f,%rdx\nsar    %rax\nsub    %rdx,%rax\nlea    (%rax,%rax,4),%rdx\nlea    (%rax,%rdx,2),%rdx\nmov    %r14,%rax\nsub    %rdx,%rax\nlea    0x1d84(%rip),%rdx\nmovsbl (%rdx,%rax,1),%esi\nlea    (%rax,%r12,8),%rdx\ncmp    0xc(%rsp),%esi\ncmove  %rdx,%r12\nmov    %r12,0x3fc0(%rip)\njmp    114c <main+0x4c>\nnopl   (%rax)\nmov    %rdi,%rdx\ncmp    $0xf,%rdi\njg     12d7 <main+0x1d7>\ncmp    $0x9,%rdi\njle    12f0 <main+0x1f0>\nmov    %rbx,%rax\ncqto\nidiv   %rcx\nlea    -0x1(%rcx),%rax\nimul   %rax,%rdx\nadd    %rdx,%rbx\nmov    %rdi,%rsi\nmov    $0x1,%ebp\nxor    %r9d,%r9d\nmov    $0x1,%edx\njmp    1219 <main+0x119>\nnop\nshl    $0x4,%rdx\nlea    (%rdi,%r15,1),%rax\ncmp    $0x18,%r13\ncmovne %rax,%rdx\njmp    12d7 <main+0x1d7>\ntest   %dl,%dl\nje     1264 <main+0x164>\nmov    %rcx,0x3f6f(%rip)\njmp    1264 <main+0x164>\nmov    0x10(%rsp),%rsi\nlea    0x1cf5(%rip),%rdi\nxor    %eax,%eax\ncall   2970 <libmin_printf>\ncall   2bb0 <libmin_success>\nadd    $0x28,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnop\n"}
{"source": {"path": "spirograph/spirograph.c", "function_name": "main", "content": "/** Main function */\nint main(int argc, char **argv)\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "spirograph/spirograph.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  test();\n  libmin_success();\n}\n"}, "pseudo_normalize": "", "binary": "spirograph/spirograph.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\ncall   1390 <test>\ncall   3390 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "spirograph/spirograph.c", "function_name": "spirograph", "content": "/**\n * @file\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Implementation of\n * [Spirograph](https://en.wikipedia.org/wiki/Spirograph)\n *\n * @details\n * Implementation of the program is based on the geometry shown in the figure\n * below:\n *\n * <a\n * href=\"https://commons.wikimedia.org/wiki/File:Resonance_Cascade.svg\"><img\n * src=\"https://upload.wikimedia.org/wikipedia/commons/3/39/Resonance_Cascade.svg\"\n * alt=\"Spirograph geometry from Wikipedia\" style=\"width: 250px\"/></a>\n */\n#include \"libmin.h\"\n\n/** Generate spirograph curve into arrays `x` and `y` such that the i^th point\n * in 2D is represented by `(x[i],y[i])`. The generating function is given by:\n * \\f{eqnarray*}{\n * x &=& R\\left[ (1-k) \\cos (t) + l\\cdot k\\cdot\\cos \\left(\\frac{1-k}{k}t\\right)\n * \\right]\\\\\n * y &=& R\\left[ (1-k) \\sin (t) - l\\cdot k\\cdot\\sin \\left(\\frac{1-k}{k}t\\right)\n * \\right] \\f}\n * where\n * * \\f$R\\f$ is the scaling parameter that we will consider \\f$=1\\f$\n * * \\f$l=\\frac{\\rho}{r}\\f$ is the relative distance of marker from the centre\n * of inner circle and \\f$0\\le l\\le1\\f$\n * * \\f$\\rho\\f$ is physical distance of marker from centre of inner circle\n * * \\f$r\\f$ is the radius of inner circle\n * * \\f$k=\\frac{r}{R}\\f$ is the ratio of radius of inner circle to outer circle\n * and \\f$0<k<1\\f$\n * * \\f$R\\f$ is the radius of outer circle\n * * \\f$t\\f$ is the angle of rotation of the point i.e., represents the time\n * parameter\n *\n * Since we are considering ratios, the actual values of \\f$r\\f$ and\n * \\f$R\\f$ are immaterial.\n *\n * @param [out] x output array containing absicca of points (must be\n * pre-allocated)\n * @param [out] y output array containing ordinates of points (must be\n * pre-allocated)\n * @param l the relative distance of marker from the centre of\n * inner circle and \\f$0\\le l\\le1\\f$\n * @param k the ratio of radius of inner circle to outer circle and\n * \\f$0<k<1\\f$\n * @param N number of sample points along the trajectory (higher = better\n * resolution but consumes more time and memory)\n * @param num_rot the number of rotations to perform (can be fractional value)\n */\nvoid spirograph(double *x, double *y, double l, double k, size_t N, double rot)\n{\n    double dt = rot * 2.f * M_PI / N;\n    double t = 0.f, R = 1.f;\n    const double k1 = 1.f - k;\n\n    for (size_t dk = 0; dk < N; dk++, t += dt)\n    {\n        x[dk] = R * (k1 * libmin_cos(t) + l * k * libmin_cos(k1 * t / k));\n        y[dk] = R * (k1 * libmin_sin(t) - l * k * libmin_sin(k1 * t / k));\n    }\n}\n"}, "pseudo": {"path": "spirograph/spirograph.host.O2.pseudo", "function_name": "spirograph", "address": "0x1230", "label": "spirograph", "content": "void __fastcall spirograph(double *x, double *y, double l, double k, __int64 N, double rot)\n{\n  double v7; // xmm2_8\n  double v8; // xmm1_8\n  double v9; // xmm2_8\n  double v10; // xmm1_8\n  __int64 v11; // r13\n  double v12; // xmm2_8\n  double v13; // xmm1_8\n  double k1_0; // [rsp+0h] [rbp-60h]\n  double v15; // [rsp+8h] [rbp-58h]\n  double v16; // [rsp+10h] [rbp-50h]\n  double dt; // [rsp+30h] [rbp-30h]\n\n  v7 = (rot + rot) * 3.141592653589793;\n  if ( N < 0 )\n    v8 = (double)(int)(N & 1 | ((unsigned __int64)N >> 1)) + (double)(int)(N & 1 | ((unsigned __int64)N >> 1));\n  else\n    v8 = (double)(int)N;\n  v9 = v7 / v8;\n  v10 = 1.0 - k;\n  k1_0 = 1.0 - k;\n  dt = v9;\n  if ( N )\n  {\n    v11 = 0LL;\n    v12 = 0.0;\n    v15 = l * k;\n    do\n    {\n      v16 = libmin_cos(v10) * k1_0;\n      x[v11] = libmin_cos(v10) * v15 + v16;\n      v13 = k1_0 * libmin_sin(v10);\n      v12 = v12 + dt;\n      v10 = v13 - libmin_sin(v13) * v15;\n      y[v11++] = v10;\n    }\n    while ( N != v11 );\n  }\n}\n"}, "pseudo_normalize": "void spirograph(double *x, double *y, double l, double k, long long N,\n                double rot) {\n  double v7;\n  double v8;\n  double v9;\n  double v10;\n  long long v11;\n  double v12;\n  double v13;\n  double k1_0;\n  double v15;\n  double v16;\n  double dt;\n  v7 = (rot + rot) * 3.141592653589793;\n  if (N < 0)\n    v8 = (double)(int)(N & 1 | ((unsigned long long)N >> 1)) +\n         (double)(int)(N & 1 | ((unsigned long long)N >> 1));\n  else\n    v8 = (double)(int)N;\n  v9 = v7 / v8;\n  v10 = 1.0 - k;\n  k1_0 = 1.0 - k;\n  dt = v9;\n  if (N) {\n    v11 = 0LL;\n    v12 = 0.0;\n    v15 = l * k;\n    do {\n      v16 = libmin_cos(v10) * k1_0;\n      x[v11] = libmin_cos(v10) * v15 + v16;\n      v13 = k1_0 * libmin_sin(v10);\n      v12 = v12 + dt;\n      v10 = v13 - libmin_sin(v13) * v15;\n      y[v11++] = v10;\n    } while (N != v11);\n  }\n}", "binary": "spirograph/spirograph.host.O2", "assembly": "<spirograph>:\nendbr64\npush   %r13\naddsd  %xmm2,%xmm2\npush   %r12\nmov    %rsi,%r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rdx,%rbx\nsub    $0x48,%rsp\nmovsd  %xmm1,0x30(%rsp)\nmulsd  0x3dbf(%rip),%xmm2\ntest   %rdx,%rdx\njs     1370 <spirograph+0x140>\npxor   %xmm1,%xmm1\ncvtsi2sd %rdx,%xmm1\ndivsd  %xmm1,%xmm2\nmovsd  0x30(%rsp),%xmm4\nmovsd  0x3da3(%rip),%xmm1\nsubsd  %xmm4,%xmm1\nmovsd  %xmm1,0x8(%rsp)\nmovsd  %xmm2,0x38(%rsp)\ntest   %rbx,%rbx\nje     135e <spirograph+0x12e>\nmulsd  %xmm4,%xmm0\nxor    %r13d,%r13d\npxor   %xmm2,%xmm2\nmovsd  %xmm0,0x10(%rsp)\nnopw   0x0(%rax,%rax,1)\nmovapd %xmm2,%xmm0\nmovsd  %xmm2,0x20(%rsp)\ncall   3050 <libmin_cos>\nmovsd  0x8(%rsp),%xmm3\nmovsd  0x20(%rsp),%xmm2\nmulsd  %xmm3,%xmm0\nmulsd  %xmm2,%xmm3\ndivsd  0x30(%rsp),%xmm3\nmovsd  %xmm3,0x28(%rsp)\nmovsd  %xmm0,0x18(%rsp)\nmovapd %xmm3,%xmm0\ncall   3050 <libmin_cos>\nmulsd  0x10(%rsp),%xmm0\nmovsd  0x20(%rsp),%xmm2\naddsd  0x18(%rsp),%xmm0\nmovsd  %xmm0,0x0(%rbp,%r13,8)\nmovapd %xmm2,%xmm0\ncall   31b0 <libmin_sin>\nmovsd  0x8(%rsp),%xmm1\nmovsd  0x28(%rsp),%xmm3\nmulsd  %xmm0,%xmm1\nmovapd %xmm3,%xmm0\nmovsd  %xmm1,0x18(%rsp)\ncall   31b0 <libmin_sin>\nmulsd  0x10(%rsp),%xmm0\nmovsd  0x18(%rsp),%xmm1\nmovsd  0x20(%rsp),%xmm2\naddsd  0x38(%rsp),%xmm2\nsubsd  %xmm0,%xmm1\nmovsd  %xmm1,(%r12,%r13,8)\nadd    $0x1,%r13\ncmp    %r13,%rbx\njne    12b0 <spirograph+0x80>\nadd    $0x48,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nmov    %rdx,%rax\nand    $0x1,%edx\npxor   %xmm1,%xmm1\nshr    %rax\nor     %rdx,%rax\ncvtsi2sd %rax,%xmm1\naddsd  %xmm1,%xmm1\njmp    126b <spirograph+0x3b>\nxchg   %ax,%ax\n"}
{"source": {"path": "spirograph/spirograph.c", "function_name": "test", "content": "/**\n * @brief Test function to save resulting points to a CSV file.\n *\n */\nvoid test(void)\n{\n    size_t N = 500;\n    double l = 0.3, k = 0.75, rot = 10.;\n    double *x = (double *)libmin_malloc(N * sizeof(double));\n    double *y = (double *)libmin_malloc(N * sizeof(double));\n\n    spirograph(x, y, l, k, N, rot);\n\n    for (size_t i = 0; i < N; i++)\n    {\n        libmin_printf(\"%.5lf, %.5lf\\n\", x[i], y[i]);\n    }\n\n    libmin_free(x);\n    libmin_free(y);\n}\n"}, "pseudo": {"path": "spirograph/spirograph.host.O2.pseudo", "function_name": "test", "address": "0x1390", "label": "test", "content": "void __cdecl test()\n{\n  double v0; // xmm1_8\n  __int64 v1; // r13\n  double *v2; // r12\n  double v3; // xmm2_8\n  double *v4; // rbp\n  double v5; // xmm1_8\n  double v6; // rbx\n  __int64 i; // rbx\n  double v8; // xmm0_8\n  double v9; // xmm1_8\n  double v10; // [rsp+18h] [rbp-30h]\n\n  v1 = 0LL;\n  v2 = (double *)libmin_malloc(0xFA0uLL);\n  v3 = 0.0;\n  v4 = (double *)libmin_malloc(0xFA0uLL);\n  do\n  {\n    v10 = libmin_cos(v0);\n    v5 = v10 * 0.25 + libmin_cos(v0) * 0.225;\n    v2[v1] = v5;\n    v6 = libmin_sin(v5);\n    v3 = v3 + 0.1256637061435917;\n    v0 = libmin_sin(v5) * 0.225;\n    v4[v1++] = v6 * 0.25 - v0;\n  }\n  while ( v1 != 500 );\n  for ( i = 0LL; i != 500; ++i )\n  {\n    v8 = v2[i];\n    v9 = v4[i];\n    libmin_printf(\"%.5lf, %.5lf\\n\", v8, v9);\n  }\n  libmin_free(v2);\n  libmin_free(v4);\n}\n"}, "pseudo_normalize": "void test() {\n  double v0;\n  long long v1;\n  double *v2;\n  double v3;\n  double *v4;\n  double v5;\n  double v6;\n  long long i;\n  double v8;\n  double v9;\n  double v10;\n  v1 = 0LL;\n  v2 = (double *)libmin_malloc(4000uLL);\n  v3 = 0.0;\n  v4 = (double *)libmin_malloc(4000uLL);\n  do {\n    v10 = libmin_cos(v0);\n    v5 = v10 * 0.25 + libmin_cos(v0) * 0.225;\n    v2[v1] = v5;\n    v6 = libmin_sin(v5);\n    v3 = v3 + 0.1256637061435917;\n    v0 = libmin_sin(v5) * 0.225;\n    v4[v1++] = v6 * 0.25 - v0;\n  } while (v1 != 500);\n  for (i = 0LL; i != 500; ++i) {\n    v8 = v2[i];\n    v9 = v4[i];\n    libmin_printf(\"%.5lf, %.5lf\\n\", v8, v9);\n  }\n  libmin_free(v2);\n  libmin_free(v4);\n}", "binary": "spirograph/spirograph.host.O2", "assembly": "<test>:\nendbr64\npush   %r13\nmov    $0xfa0,%edi\nxor    %r13d,%r13d\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\ncall   1740 <libmin_malloc>\nmov    $0xfa0,%edi\nmov    %rax,%r12\ncall   1740 <libmin_malloc>\npxor   %xmm2,%xmm2\nmov    %rax,%rbp\nnop\nmovapd %xmm2,%xmm0\nmovsd  %xmm2,0x8(%rsp)\ncall   3050 <libmin_cos>\nmovsd  0x8(%rsp),%xmm2\nmovsd  0x3c4b(%rip),%xmm3\nmovsd  %xmm0,0x18(%rsp)\nmulsd  %xmm2,%xmm3\ndivsd  0x3c41(%rip),%xmm3\nmovapd %xmm3,%xmm0\nmovsd  %xmm3,0x10(%rsp)\ncall   3050 <libmin_cos>\nmovsd  0x18(%rsp),%xmm1\nmulsd  0x3c2c(%rip),%xmm0\nmulsd  0x3c14(%rip),%xmm1\nmovsd  0x8(%rsp),%xmm2\naddsd  %xmm0,%xmm1\nmovapd %xmm2,%xmm0\nmovsd  %xmm1,(%r12,%r13,8)\ncall   31b0 <libmin_sin>\nmovsd  0x10(%rsp),%xmm3\nmovq   %xmm0,%rbx\nmovapd %xmm3,%xmm0\ncall   31b0 <libmin_sin>\nmovsd  0x8(%rsp),%xmm2\naddsd  0x3bf1(%rip),%xmm2\nmovapd %xmm0,%xmm1\nmovq   %rbx,%xmm0\nmulsd  0x3bd8(%rip),%xmm1\nmulsd  0x3bc0(%rip),%xmm0\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,0x0(%rbp,%r13,8)\nadd    $0x1,%r13\ncmp    $0x1f4,%r13\njne    13c0 <test+0x30>\nxor    %ebx,%ebx\nlea    0x3b77(%rip),%r13\nnopl   (%rax)\nmovsd  (%r12,%rbx,8),%xmm0\nmovsd  0x0(%rbp,%rbx,8),%xmm1\nmov    %r13,%rdi\nmov    $0x2,%eax\nadd    $0x1,%rbx\ncall   2ce0 <libmin_printf>\ncmp    $0x1f4,%rbx\njne    1490 <test+0x100>\nmov    %r12,%rdi\ncall   17f0 <libmin_free>\nadd    $0x28,%rsp\nmov    %rbp,%rdi\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\njmp    17f0 <libmin_free>\n"}
{"source": {"path": "sudoku-solver/sudoku-solver.c", "function_name": "isSafe", "content": "// Check if placing num at board[row][col] is valid.\nint isSafe(int row, int col, int num) {\n    // Check row for duplicates.\n    for (int i = 0; i < N; i++) {\n        if (board[row][i] == num)\n            return 0;\n    }\n    // Check column for duplicates.\n    for (int i = 0; i < N; i++) {\n        if (board[i][col] == num)\n            return 0;\n    }\n    // Check 3x3 subgrid for duplicates.\n    int startRow = row - row % 3;\n    int startCol = col - col % 3;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (board[startRow + i][startCol + j] == num)\n                return 0;\n        }\n    }\n    return 1;\n}\n"}, "pseudo": {"path": "sudoku-solver/sudoku-solver.host.O2.pseudo", "function_name": "isSafe", "address": "0x1250", "label": "isSafe", "content": "int __fastcall isSafe(int row, int col, int num)\n{\n  __int64 v3; // r9\n  int *v4; // rax\n  __int64 v5; // r11\n  char *v6; // rax\n  int v7; // ecx\n  int *i; // rax\n\n  v3 = row;\n  v4 = board[v3];\n  while ( *v4 != num )\n  {\n    if ( ++v4 == board[v3 + 1] )\n    {\n      v5 = 4LL * col;\n      v6 = (char *)board + v5;\n      while ( *(_DWORD *)v6 != num )\n      {\n        v6 += 36;\n        if ( v6 == (char *)&unk_5164 + v5 )\n        {\n          v7 = 3;\n          for ( i = &board[3 * (row / 3)][3 * (col / 3)]; num != *i && num != i[1] && num != i[2]; i += 9 )\n          {\n            if ( !--v7 )\n              return 1;\n          }\n          return 0;\n        }\n      }\n      return 0;\n    }\n  }\n  return 0;\n}\n"}, "pseudo_normalize": "int isSafe(int row, int col, int num) {\n  long long v3;\n  int *v4;\n  long long v5;\n  char *v6;\n  int v7;\n  int *i;\n  v3 = row;\n  v4 = board[v3];\n  while (*v4 != num) {\n    if (++v4 == board[v3 + 1]) {\n      v5 = 4LL * col;\n      v6 = (char *)board + v5;\n      while (*(uint32_t *)v6 != num) {\n        v6 += 36;\n        if (v6 == (char *)&unk_5164 + v5) {\n          v7 = 3;\n          for (i = &board[3 * (row / 3)][3 * (col / 3)];\n               num != *i && num != i[1] && num != i[2]; i += 9) {\n            if (!--v7) return 1;\n          }\n          return 0;\n        }\n      }\n      return 0;\n    }\n  }\n  return 0;\n}", "binary": "sudoku-solver/sudoku-solver.host.O2", "assembly": "<isSafe>:\nendbr64\nmov    %esi,%r8d\nmovslq %edi,%rsi\nlea    0x3dbf(%rip),%r10\nlea    (%rsi,%rsi,8),%r9\nlea    0x24(%r10),%rcx\nshl    $0x2,%r9\nlea    (%r10,%r9,1),%rax\nadd    %r9,%rcx\nnopl   0x0(%rax)\ncmp    %edx,(%rax)\nje     1310 <isSafe+0xc0>\nadd    $0x4,%rax\ncmp    %rcx,%rax\njne    1278 <isSafe+0x28>\nmovslq %r8d,%r9\nlea    0x3ed1(%rip),%rcx\nlea    0x0(,%r9,4),%r11\nlea    (%r10,%r11,1),%rax\nadd    %r11,%rcx\nnopw   0x0(%rax,%rax,1)\ncmp    %edx,(%rax)\nje     1310 <isSafe+0xc0>\nadd    $0x24,%rax\ncmp    %rcx,%rax\njne    12a8 <isSafe+0x58>\nimul   $0x55555556,%rsi,%rsi\nsar    $0x1f,%edi\nsar    $0x1f,%r8d\nimul   $0x55555556,%r9,%r9\nshr    $0x20,%rsi\nsub    %edi,%esi\nshr    $0x20,%r9\nlea    (%rsi,%rsi,2),%eax\nsub    %r8d,%r9d\ncltq\nlea    (%r9,%r9,2),%ecx\nmovslq %ecx,%rcx\nlea    (%rax,%rax,8),%rax\nadd    %rcx,%rax\nmov    $0x3,%ecx\nlea    (%r10,%rax,4),%rax\ncmp    (%rax),%edx\nje     1310 <isSafe+0xc0>\ncmp    0x4(%rax),%edx\nje     1310 <isSafe+0xc0>\ncmp    0x8(%rax),%edx\nje     1310 <isSafe+0xc0>\nadd    $0x24,%rax\nsub    $0x1,%ecx\njne    12f3 <isSafe+0xa3>\nmov    $0x1,%eax\nret\nxor    %eax,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "sudoku-solver/sudoku-solver.c", "function_name": "main", "content": "int main() {\n    libmin_printf(\"Initial Sudoku Puzzle:\\n\");\n    printBoard();\n\n    if (solveSudoku()) {\n        libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n        printBoard();\n        libtarg_success();\n    } else {\n        libmin_printf(\"No solution found.\\n\");\n        libtarg_fail(1);\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "sudoku-solver/sudoku-solver.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if ( solveSudoku() )\n  {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  libmin_printf(\"Initial Sudoku Puzzle:\\n\", argv, envp);\n  printBoard();\n  if (solveSudoku()) {\n    libmin_printf(\"\\nSolved Sudoku Puzzle:\\n\");\n    printBoard();\n    libtarg_success();\n  }\n  libmin_printf(\"No solution found.\\n\");\n  libtarg_fail(1);\n}", "binary": "sudoku-solver/sudoku-solver.host.O2", "assembly": "<main>:\nendbr64\npush   %rax\npop    %rax\nlea    0x1efb(%rip),%rdi\nxor    %eax,%eax\nsub    $0x8,%rsp\ncall   29a0 <libmin_printf>\nxor    %eax,%eax\ncall   13f0 <printBoard>\nxor    %eax,%eax\ncall   1320 <solveSudoku>\ntest   %eax,%eax\nje     1144 <main+0x44>\nlea    0x1eef(%rip),%rdi\nxor    %eax,%eax\ncall   29a0 <libmin_printf>\nxor    %eax,%eax\ncall   13f0 <printBoard>\ncall   1460 <libtarg_success>\nlea    0x1eed(%rip),%rdi\nxor    %eax,%eax\ncall   29a0 <libmin_printf>\nmov    $0x1,%edi\ncall   1480 <libtarg_fail>\nnopl   0x0(%rax)\n"}
{"source": {"path": "sudoku-solver/sudoku-solver.c", "function_name": "printBoard", "content": "// Utility function to print the Sudoku board.\nvoid printBoard() {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            libmin_printf(\"%d \", board[i][j]);\n        }\n        libmin_printf(\"\\n\");\n    }\n}\n"}, "pseudo": {"path": "sudoku-solver/sudoku-solver.host.O2.pseudo", "function_name": "printBoard", "address": "0x13f0", "label": "printBoard", "content": "void __cdecl printBoard()\n{\n  int *v0; // rbp\n  int *v1; // rbx\n  int v2; // esi\n\n  v0 = board[1];\n  do\n  {\n    v1 = v0 - 9;\n    do\n    {\n      v2 = *v1++;\n      libmin_printf(\"%d \", v2);\n    }\n    while ( v1 != v0 );\n    v0 = v1 + 9;\n    libmin_printf((char *)\"\\n\");\n  }\n  while ( v1 + 9 != board[10] );\n}\n"}, "pseudo_normalize": "void printBoard() {\n  int *v0;\n  int *v1;\n  int v2;\n  v0 = board[1];\n  do {\n    v1 = v0 - 9;\n    do {\n      v2 = *v1++;\n      libmin_printf(\"%d \", v2);\n    } while (v1 != v0);\n    v0 = v1 + 9;\n    libmin_printf((char *)\"\\n\");\n  } while (v1 + 9 != board[10]);\n}", "binary": "sudoku-solver/sudoku-solver.host.O2", "assembly": "<printBoard>:\nendbr64\npush   %r14\npush   %r13\nlea    0x1c4b(%rip),%r13\npush   %r12\nlea    0x1bfc(%rip),%r12\npush   %rbp\nlea    0x3c34(%rip),%rbp\npush   %rbx\nlea    0x144(%rbp),%r14\nnopl   0x0(%rax,%rax,1)\nlea    -0x24(%rbp),%rbx\nnopl   0x0(%rax)\nmov    (%rbx),%esi\nmov    %r12,%rdi\nxor    %eax,%eax\nadd    $0x4,%rbx\ncall   29a0 <libmin_printf>\ncmp    %rbp,%rbx\njne    1428 <printBoard+0x38>\nmov    %r13,%rdi\nxor    %eax,%eax\nlea    0x24(%rbx),%rbp\ncall   29a0 <libmin_printf>\ncmp    %r14,%rbp\njne    1420 <printBoard+0x30>\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "sudoku-solver/sudoku-solver.c", "function_name": "solveSudoku", "content": "// Recursively attempt to fill the Sudoku board.\nint solveSudoku() {\n    int row = -1;\n    int col = -1;\n    int emptyFound = 0;\n\n    // Find an empty cell.\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (board[i][j] == 0) {\n                row = i;\n                col = j;\n                emptyFound = 1;\n                break;\n            }\n        }\n        if (emptyFound)\n            break;\n    }\n\n    // No empty cell found; puzzle is solved.\n    if (!emptyFound)\n        return 1;\n\n    // Try placing numbers 1 to 9 in the empty cell.\n    for (int num = 1; num <= 9; num++) {\n        if (isSafe(row, col, num)) {\n            board[row][col] = num;\n            if (solveSudoku())\n                return 1;\n            board[row][col] = 0;  // Backtrack.\n        }\n    }\n    return 0;  // Trigger backtracking.\n}\n"}, "pseudo": {"path": "sudoku-solver/sudoku-solver.host.O2.pseudo", "function_name": "solveSudoku", "address": "0x1320", "label": "solveSudoku", "content": "int __cdecl solveSudoku()\n{\n  int *v0; // rdx\n  int i; // ebp\n  __int64 j; // rax\n  int v3; // r12d\n  int v4; // ebx\n  __int64 v6; // r15\n  int v7; // r14d\n  __int64 v8; // [rsp+0h] [rbp-48h]\n\n  v0 = board[0];\n  for ( i = 0; i != 9; ++i )\n  {\n    for ( j = 0LL; j != 9; ++j )\n    {\n      v3 = v0[j];\n      v4 = j;\n      if ( !v3 )\n      {\n        v6 = (int)j;\n        v7 = 1;\n        v8 = i;\n        while ( 1 )\n        {\n          if ( isSafe(i, v4, v7) )\n          {\n            board[v8][v6] = v7;\n            if ( solveSudoku() )\n              return 1;\n            board[v8][v6] = 0;\n          }\n          if ( ++v7 == 10 )\n            return v3;\n        }\n      }\n    }\n    v0 += 9;\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int solveSudoku() {\n  int *v0;\n  int i;\n  long long j;\n  int v3;\n  int v4;\n  long long v6;\n  int v7;\n  long long v8;\n  v0 = board[0];\n  for (i = 0; i != 9; ++i) {\n    for (j = 0LL; j != 9; ++j) {\n      v3 = v0[j];\n      v4 = j;\n      if (!v3) {\n        v6 = (int)j;\n        v7 = 1;\n        v8 = i;\n        while (1) {\n          if (isSafe(i, v4, v7)) {\n            board[v8][v6] = v7;\n            if (solveSudoku()) return 1;\n            board[v8][v6] = 0;\n          }\n          if (++v7 == 10) return v3;\n        }\n      }\n    }\n    v0 += 9;\n  }\n  return 1;\n}", "binary": "sudoku-solver/sudoku-solver.host.O2", "assembly": "<solveSudoku>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\nlea    0x3cef(%rip),%r13\npush   %r12\nmov    %r13,%rdx\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nsub    $0x18,%rsp\nxchg   %ax,%ax\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nmov    (%rdx,%rax,4),%r12d\nmov    %eax,%ebx\ntest   %r12d,%r12d\nje     1388 <solveSudoku+0x68>\nadd    $0x1,%rax\ncmp    $0x9,%rax\njne    1348 <solveSudoku+0x28>\nadd    $0x1,%ebp\nadd    $0x24,%rdx\ncmp    $0x9,%ebp\njne    1340 <solveSudoku+0x20>\nmov    $0x1,%r12d\nadd    $0x18,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopl   0x0(%rax)\nmovslq %eax,%r15\nmovslq %ebp,%rax\nmov    $0x1,%r14d\nlea    (%rax,%rax,8),%rax\nmov    %rax,(%rsp)\njmp    13aa <solveSudoku+0x8a>\nxchg   %ax,%ax\nadd    $0x1,%r14d\ncmp    $0xa,%r14d\nje     136f <solveSudoku+0x4f>\nmov    %r14d,%edx\nmov    %ebx,%esi\nmov    %ebp,%edi\ncall   1250 <isSafe>\ntest   %eax,%eax\nje     13a0 <solveSudoku+0x80>\nmov    (%rsp),%rax\nlea    (%rax,%r15,1),%rcx\nxor    %eax,%eax\nmov    %r14d,0x0(%r13,%rcx,4)\nmov    %rcx,0x8(%rsp)\ncall   1320 <solveSudoku>\ntest   %eax,%eax\njne    1369 <solveSudoku+0x49>\nmov    0x8(%rsp),%rcx\nmovl   $0x0,0x0(%r13,%rcx,4)\njmp    13a0 <solveSudoku+0x80>\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "aggregate_height", "content": "int aggregate_height(int heights[BOARD_WIDTH]) {\n    int sum = 0;\n    for (int i = 0; i < BOARD_WIDTH; i++)\n        sum += heights[i];\n    return sum;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "aggregate_height", "address": "0x1570", "label": "aggregate_height", "content": "int __fastcall aggregate_height(int *heights)\n{\n  int *v1; // rdx\n  int result; // eax\n\n  v1 = heights + 10;\n  result = 0;\n  do\n    result += *heights++;\n  while ( heights != v1 );\n  return result;\n}\n"}, "pseudo_normalize": "int aggregate_height(int *heights) {\n  int *v1;\n  int result;\n  v1 = heights + 10;\n  result = 0;\n  do result += *heights++;\n  while (heights != v1);\n  return result;\n}", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<aggregate_height>:\nendbr64\nlea    0x28(%rdi),%rdx\nxor    %eax,%eax\nnopw   0x0(%rax,%rax,1)\nadd    (%rdi),%eax\nadd    $0x4,%rdi\ncmp    %rdx,%rdi\njne    1580 <aggregate_height+0x10>\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "best_move", "content": "// ------------------------\n// AI: Find the best move for a given piece on the current board.\n// ------------------------\nint best_move(const int board[BOARD_HEIGHT][BOARD_WIDTH], const Piece *piece, const Orientation **best_ori, int *best_offset, double *best_score, int best_board[BOARD_HEIGHT][BOARD_WIDTH], int *lines_cleared_out) {\n    double max_score = -1e9;\n    int move_found = 0;\n    int temp_board[BOARD_HEIGHT][BOARD_WIDTH];\n    int lines;\n    // For each orientation of the piece.\n    for (int o = 0; o < piece->numOrientations; o++) {\n        const Orientation *ori = &(piece->orientations[o]);\n        // Calculate the horizontal span of the orientation.\n        int min_x = 100, max_x = -100;\n        for (int i = 0; i < ori->numBlocks; i++) {\n            int bx = ori->blocks[i].x;\n            if (bx < min_x) min_x = bx;\n            if (bx > max_x) max_x = bx;\n        }\n        // Determine valid horizontal offsets so that the piece remains within the board.\n        int start = -min_x;\n        int end = BOARD_WIDTH - max_x;\n        for (int x = start; x < end; x++) {\n            if (simulate_board((int (*)[BOARD_WIDTH])board, ori, x, temp_board, &lines)) {\n                double score = evaluate_board(temp_board, lines);\n                if (score > max_score) {\n                    max_score = score;\n                    *best_score = score;\n                    *best_ori = ori;\n                    *best_offset = x;\n                    libmin_memcpy(best_board, temp_board, sizeof(int)*BOARD_HEIGHT*BOARD_WIDTH);\n                    *lines_cleared_out = lines;\n                    move_found = 1;\n                }\n            }\n        }\n    }\n    return move_found;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "best_move", "address": "0x1860", "label": "best_move", "content": "int __fastcall best_move(\n        const int (*board)[10],\n        const Piece *piece,\n        const Orientation **best_ori,\n        int *best_offset,\n        double *best_score,\n        int (*best_board)[10],\n        int *lines_cleared_out)\n{\n  const Orientation *v7; // rbx\n  Point *blocks; // rdx\n  int v9; // ecx\n  int x; // r9d\n  int v11; // r12d\n  int i; // r15d\n  double v13; // xmm0_8\n  int score; // [rsp+0h] [rbp-3C8h]\n  __int64 o; // [rsp+8h] [rbp-3C0h]\n  double max_score; // [rsp+10h] [rbp-3B8h]\n  int move_found; // [rsp+24h] [rbp-3A4h]\n  int lines; // [rsp+5Ch] [rbp-36Ch] BYREF\n  int temp_board[20][10]; // [rsp+60h] [rbp-368h] BYREF\n  unsigned __int64 v25; // [rsp+388h] [rbp-40h]\n\n  v25 = __readfsqword(0x28u);\n  if ( piece->numOrientations <= 0 )\n    return 0;\n  o = 0LL;\n  move_found = 0;\n  max_score = -1000000000.0;\n  do\n  {\n    v7 = &piece->orientations[o];\n    if ( v7->numBlocks <= 0 )\n    {\n      v11 = 110;\n      i = -100;\n      goto LABEL_13;\n    }\n    blocks = v7->blocks;\n    v9 = -100;\n    x = 100;\n    do\n    {\n      if ( x > blocks->x )\n        x = blocks->x;\n      if ( v9 < blocks->x )\n        v9 = blocks->x;\n      ++blocks;\n    }\n    while ( blocks != &v7->blocks[(unsigned int)(v7->numBlocks - 1) + 1] );\n    v11 = 10 - v9;\n    for ( i = -x; i < v11; max_score = v13 )\n    {\nLABEL_13:\n      while ( 1 )\n      {\n        if ( simulate_board((int (*)[10])board, v7, i, temp_board, &lines) )\n        {\n          score = lines;\n          v13 = evaluate_board(temp_board, lines);\n          if ( v13 > max_score )\n            break;\n        }\n        if ( ++i >= v11 )\n          goto LABEL_16;\n      }\n      *best_score = v13;\n      *best_ori = v7;\n      *best_offset = i++;\n      libmin_memcpy(best_board, temp_board, 0x320uLL);\n      move_found = 1;\n      *lines_cleared_out = score;\n    }\nLABEL_16:\n    ++o;\n  }\n  while ( piece->numOrientations > (int)o );\n  return move_found;\n}\n"}, "pseudo_normalize": "int best_move(const int (*board)[10], const Piece *piece,\n              const Orientation **best_ori, int *best_offset,\n              double *best_score, int (*best_board)[10],\n              int *lines_cleared_out) {\n  const Orientation *v7;\n  Point *blocks;\n  int v9;\n  int x;\n  int v11;\n  int i;\n  double v13;\n  int score;\n  long long o;\n  double max_score;\n  int move_found;\n  int lines;\n  int temp_board[20][10];\n  unsigned long long v25;\n  v25 = __readfsqword(40u);\n  if (piece->numOrientations <= 0) return 0;\n  o = 0LL;\n  move_found = 0;\n  max_score = -1000000000.0;\n  do {\n    v7 = &piece->orientations[o];\n    if (v7->numBlocks <= 0) {\n      v11 = 110;\n      i = -100;\n      goto LABEL_13;\n    }\n    blocks = v7->blocks;\n    v9 = -100;\n    x = 100;\n    do {\n      if (x > blocks->x) x = blocks->x;\n      if (v9 < blocks->x) v9 = blocks->x;\n      ++blocks;\n    } while (blocks != &v7->blocks[(unsigned int)(v7->numBlocks - 1) + 1]);\n    v11 = 10 - v9;\n    for (i = -x; i < v11; max_score = v13) {\n    LABEL_13:\n      while (1) {\n        if (simulate_board((int(*)[10])board, v7, i, temp_board, &lines)) {\n          score = lines;\n          v13 = evaluate_board(temp_board, lines);\n          if (v13 > max_score) break;\n        }\n        if (++i >= v11) goto LABEL_16;\n      }\n      *best_score = v13;\n      *best_ori = v7;\n      *best_offset = i++;\n      libmin_memcpy(best_board, temp_board, 800uLL);\n      move_found = 1;\n      *lines_cleared_out = score;\n    }\n  LABEL_16:\n    ++o;\n  } while (piece->numOrientations > (int)o);\n  return move_found;\n}", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<best_move>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x398,%rsp\nmov    0x3d0(%rsp),%rax\nmov    %rsi,0x18(%rsp)\nmov    %rdx,0x28(%rsp)\nmov    %rcx,0x30(%rsp)\nmov    %r8,0x38(%rsp)\nmov    %r9,0x40(%rsp)\nmov    %rax,0x48(%rsp)\nmov    %fs:0x28,%rax\nmov    %rax,0x388(%rsp)\nxor    %eax,%eax\nmov    0x4(%rsi),%eax\ntest   %eax,%eax\njle    1a49 <best_move+0x1e9>\nmovsd  0x2b27(%rip),%xmm2\nmov    %rdi,%r13\nlea    0x5c(%rsp),%r14\nlea    0x60(%rsp),%rbp\nmovq   $0x0,0x8(%rsp)\nmovl   $0x0,0x24(%rsp)\nmovsd  %xmm2,0x10(%rsp)\nnopl   (%rax)\nmov    0x18(%rsp),%rdi\nmov    0x8(%rsp),%rax\nmov    0x8(%rdi),%rdx\nlea    (%rax,%rax,8),%rax\nlea    (%rdx,%rax,4),%rbx\nmov    (%rbx),%eax\ntest   %eax,%eax\njle    1a38 <best_move+0x1d8>\nsub    $0x1,%eax\nlea    0x4(%rbx),%rdx\nmov    $0xffffff9c,%ecx\nmov    $0x64,%r9d\nlea    0xc(%rbx,%rax,8),%rsi\nmov    (%rdx),%eax\ncmp    %eax,%r9d\ncmovg  %eax,%r9d\ncmp    %eax,%ecx\ncmovl  %eax,%ecx\nadd    $0x8,%rdx\ncmp    %rsi,%rdx\njne    191f <best_move+0xbf>\nmov    $0xa,%r12d\nneg    %r9d\nsub    %ecx,%r12d\nmov    %r9d,%r15d\ncmp    %r12d,%r9d\njl     195d <best_move+0xfd>\njmp    19f0 <best_move+0x190>\nnop\nadd    $0x1,%r15d\ncmp    %r12d,%r15d\njge    19f0 <best_move+0x190>\nmov    %r14,%r8\nmov    %rbp,%rcx\nmov    %r15d,%edx\nmov    %rbx,%rsi\nmov    %r13,%rdi\ncall   17c0 <simulate_board>\ntest   %eax,%eax\nje     1950 <best_move+0xf0>\nmov    0x5c(%rsp),%ecx\nmov    %rbp,%rdi\nmov    %ecx,%esi\nmov    %ecx,(%rsp)\ncall   1640 <evaluate_board>\ncomisd 0x10(%rsp),%xmm0\nmov    (%rsp),%ecx\njbe    1950 <best_move+0xf0>\nmov    0x38(%rsp),%rax\nmov    0x40(%rsp),%rdi\nmov    $0x320,%edx\nmov    %rbp,%rsi\nmov    %ecx,0x10(%rsp)\nmovsd  %xmm0,(%rax)\nmov    0x28(%rsp),%rax\nmovsd  %xmm0,(%rsp)\nmov    %rbx,(%rax)\nmov    0x30(%rsp),%rax\nmov    %r15d,(%rax)\nadd    $0x1,%r15d\ncall   1d20 <libmin_memcpy>\nmov    0x10(%rsp),%ecx\nmov    0x48(%rsp),%rax\nmovl   $0x1,0x24(%rsp)\nmovsd  (%rsp),%xmm0\nmov    %ecx,(%rax)\nmovsd  %xmm0,0x10(%rsp)\ncmp    %r12d,%r15d\njl     195d <best_move+0xfd>\nmov    0x18(%rsp),%rdi\naddq   $0x1,0x8(%rsp)\nmov    0x8(%rsp),%rax\ncmp    %eax,0x4(%rdi)\njg     18e8 <best_move+0x88>\nmov    0x388(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1a53 <best_move+0x1f3>\nmov    0x24(%rsp),%eax\nadd    $0x398,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nnopw   0x0(%rax,%rax,1)\nmov    $0x6e,%r12d\nmov    $0xffffff9c,%r15d\njmp    195d <best_move+0xfd>\nmovl   $0x0,0x24(%rsp)\njmp    1a09 <best_move+0x1a9>\ncall   10c0 <__stack_chk_fail@plt>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "bumpiness", "content": "int bumpiness(int heights[BOARD_WIDTH]) {\n    int bump = 0;\n    for (int i = 0; i < BOARD_WIDTH - 1; i++)\n        bump += libmin_abs(heights[i] - heights[i+1]);\n    return bump;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "bumpiness", "address": "0x1600", "label": "bumpiness", "content": "int __fastcall bumpiness(int *heights)\n{\n  int v1; // r12d\n  int *v2; // rbp\n  int *v3; // rbx\n  int v4; // edi\n\n  v1 = 0;\n  v2 = heights + 9;\n  v3 = heights;\n  do\n  {\n    v4 = *v3 - v3[1];\n    ++v3;\n    v1 += libmin_abs(v4);\n  }\n  while ( v2 != v3 );\n  return v1;\n}\n"}, "pseudo_normalize": "int bumpiness(int *heights) {\n  int v1;\n  int *v2;\n  int *v3;\n  int v4;\n  v1 = 0;\n  v2 = heights + 9;\n  v3 = heights;\n  do {\n    v4 = *v3 - v3[1];\n    ++v3;\n    v1 += libmin_abs(v4);\n  } while (v2 != v3);\n  return v1;\n}", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<bumpiness>:\nendbr64\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nlea    0x24(%rdi),%rbp\npush   %rbx\nmov    %rdi,%rbx\nnopw   0x0(%rax,%rax,1)\nmov    (%rbx),%edi\nsub    0x4(%rbx),%edi\nadd    $0x4,%rbx\ncall   1d10 <libmin_abs>\nadd    %eax,%r12d\ncmp    %rbx,%rbp\njne    1618 <bumpiness+0x18>\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "check_collision", "content": "// Check whether placing an orientation at (offset_x, offset_y) causes a collision.\nint check_collision(int board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int offset_y) {\n    for (int i = 0; i < ori->numBlocks; i++) {\n        int x = offset_x + ori->blocks[i].x;\n        int y = offset_y + ori->blocks[i].y;\n        if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT)\n            return 1;\n        if (board[y][x] != 0)\n            return 1;\n    }\n    return 0;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "check_collision", "address": "0x13d0", "label": "check_collision", "content": "int __fastcall check_collision(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  Point *blocks; // rdx\n  Point *v7; // r9\n  int result; // eax\n  unsigned int v9; // esi\n  unsigned int v10; // eax\n\n  if ( ori->numBlocks <= 0 )\n    return 0;\n  blocks = ori->blocks;\n  v7 = &ori->blocks[(unsigned int)(ori->numBlocks - 1) + 1];\n  while ( 1 )\n  {\n    v9 = offset_x + blocks->x;\n    v10 = offset_y + blocks->y;\n    if ( v9 > 9 )\n      break;\n    if ( v10 > 0x13 )\n      break;\n    result = (*board)[10 * v10 + v9];\n    if ( result )\n      break;\n    if ( v7 == ++blocks )\n      return result;\n  }\n  return 1;\n}\n"}, "pseudo_normalize": "int check_collision(int (*board)[10], const Orientation *ori, int offset_x,\n                    int offset_y) {\n  Point *blocks;\n  Point *v7;\n  int result;\n  unsigned int v9;\n  unsigned int v10;\n  if (ori->numBlocks <= 0) return 0;\n  blocks = ori->blocks;\n  v7 = &ori->blocks[(unsigned int)(ori->numBlocks - 1) + 1];\n  while (1) {\n    v9 = offset_x + blocks->x;\n    v10 = offset_y + blocks->y;\n    if (v9 > 9) break;\n    if (v10 > 19) break;\n    result = (*board)[10 * v10 + v9];\n    if (result) break;\n    if (v7 == ++blocks) return result;\n  }\n  return 1;\n}", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<check_collision>:\nendbr64\nmov    (%rsi),%eax\nmov    %rdi,%r8\nmov    %edx,%edi\ntest   %eax,%eax\njle    1431 <check_collision+0x61>\nsub    $0x1,%eax\nlea    0x4(%rsi),%rdx\nlea    0xc(%rsi,%rax,8),%r9\njmp    1412 <check_collision+0x42>\nnopl   (%rax)\ncmp    $0x13,%eax\nja     1420 <check_collision+0x50>\ncltq\nmovslq %esi,%rsi\nlea    (%rax,%rax,4),%rax\nlea    (%r8,%rax,8),%rax\nmov    (%rax,%rsi,4),%eax\ntest   %eax,%eax\njne    1420 <check_collision+0x50>\nadd    $0x8,%rdx\ncmp    %rdx,%r9\nje     1430 <check_collision+0x60>\nmov    (%rdx),%esi\nmov    0x4(%rdx),%eax\nadd    %edi,%esi\nadd    %ecx,%eax\ncmp    $0x9,%esi\njbe    13f0 <check_collision+0x20>\nmov    $0x1,%eax\nret\ncs nopw 0x0(%rax,%rax,1)\nret\nxor    %eax,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "clear_lines", "content": "// Clear full lines from the board.\n// Returns the number of lines cleared.\nint clear_lines(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    int lines_cleared = 0;\n    for (int y = BOARD_HEIGHT - 1; y >= 0; y--) {\n        int full = 1;\n        for (int x = 0; x < BOARD_WIDTH; x++) {\n            if (board[y][x] == 0) {\n                full = 0;\n                break;\n            }\n        }\n        if (full) {\n            lines_cleared++;\n            // Move all rows above down one row.\n            for (int yy = y; yy > 0; yy--) {\n                for (int x = 0; x < BOARD_WIDTH; x++) {\n                    board[yy][x] = board[yy-1][x];\n                }\n            }\n            // Clear the top row.\n            for (int x = 0; x < BOARD_WIDTH; x++) {\n                board[0][x] = 0;\n            }\n            y++; // Recheck this row since new content was shifted down.\n        }\n    }\n    return lines_cleared;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "clear_lines", "address": "0x1480", "label": "clear_lines", "content": "int __fastcall clear_lines(int (*board)[10])\n{\n  int v1; // r12d\n  int v2; // ebx\n  __int64 v3; // rcx\n  int *v4; // rax\n\n  v1 = 0;\n  v2 = 19;\n  do\n  {\n    v3 = 10LL * v2;\n    v4 = &(*board)[v3];\n    do\n    {\n      if ( !*v4 )\n      {\n        --v2;\n        goto LABEL_8;\n      }\n      ++v4;\n    }\n    while ( &(*board)[v3 + 10] != v4 );\n    ++v1;\n    if ( v2 )\n      memmove(\n        &(*board)[v3 + -10 * (unsigned int)(v2 - 1)],\n        &(*board)[v3 - 10 + -10 * (unsigned int)(v2 - 1)],\n        8 * (5LL * (unsigned int)(v2 - 1) + 5));\n    *(_QWORD *)&(*board)[8] = 0LL;\n    *(_OWORD *)board = 0LL;\n    *(_OWORD *)&(*board)[4] = 0LL;\nLABEL_8:\n    ;\n  }\n  while ( v2 != -1 );\n  return v1;\n}\n"}, "pseudo_normalize": "int clear_lines(int (*board)[10]) {\n  int v1;\n  int v2;\n  long long v3;\n  int *v4;\n  v1 = 0;\n  v2 = 19;\n  do {\n    v3 = 10LL * v2;\n    v4 = &(*board)[v3];\n    do {\n      if (!*v4) {\n        --v2;\n        goto LABEL_8;\n      }\n      ++v4;\n    } while (&(*board)[v3 + 10] != v4);\n    ++v1;\n    if (v2)\n      memmove(&(*board)[v3 + -10 * (unsigned int)(v2 - 1)],\n              &(*board)[v3 - 10 + -10 * (unsigned int)(v2 - 1)],\n              8 * (5LL * (unsigned int)(v2 - 1) + 5));\n    *(uint64_t *)&(*board)[8] = 0LL;\n    *(long double *)board = 0LL;\n    *(long double *)&(*board)[4] = 0LL;\n  LABEL_8:;\n  } while (v2 != -1);\n  return v1;\n}", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<clear_lines>:\nendbr64\npush   %r12\nxor    %r12d,%r12d\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    $0x13,%ebx\nnopl   0x0(%rax,%rax,1)\nmovslq %ebx,%rax\nlea    (%rax,%rax,4),%rcx\nshl    $0x3,%rcx\nlea    0x0(%rbp,%rcx,1),%rax\nlea    0x28(%rax),%rdx\nnopl   0x0(%rax)\nmov    (%rax),%esi\ntest   %esi,%esi\nje     1510 <clear_lines+0x90>\nadd    $0x4,%rax\ncmp    %rax,%rdx\njne    14b0 <clear_lines+0x30>\nadd    $0x1,%r12d\ntest   %ebx,%ebx\nje     14ec <clear_lines+0x6c>\nlea    -0x1(%rbx),%eax\nimul   $0xffffffffffffffd8,%rax,%rdi\nlea    0x5(%rax,%rax,4),%rdx\nshl    $0x3,%rdx\nlea    -0x28(%rdi,%rcx,1),%rsi\nadd    %rdi,%rcx\nadd    %rbp,%rsi\nlea    0x0(%rbp,%rcx,1),%rdi\ncall   10f0 <memmove@plt>\nmovq   $0x0,0x20(%rbp)\npxor   %xmm0,%xmm0\nmovups %xmm0,0x0(%rbp)\nmovups %xmm0,0x10(%rbp)\ncmp    $0xffffffff,%ebx\njne    1498 <clear_lines+0x18>\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\nret\nnopl   (%rax)\nsub    $0x1,%ebx\njmp    1500 <clear_lines+0x80>\ndata16 cs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "count_holes", "content": "int count_holes(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    int holes = 0;\n    for (int x = 0; x < BOARD_WIDTH; x++) {\n        int block_found = 0;\n        for (int y = 0; y < BOARD_HEIGHT; y++) {\n            if (board[y][x] != 0)\n                block_found = 1;\n            else if (block_found)\n                holes++;\n        }\n    }\n    return holes;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "count_holes", "address": "0x1590", "label": "count_holes", "content": "int __fastcall count_holes(int (*board)[10])\n{\n  int *v1; // rdx\n  int v2; // r8d\n  int *v3; // rax\n  int v4; // ecx\n\n  v1 = &(*board)[200];\n  v2 = 0;\n  do\n  {\n    v3 = v1 - 200;\n    v4 = 0;\n    do\n    {\n      while ( !*v3 )\n      {\n        v2 -= (v4 == 0) - 1;\n        v3 += 10;\n        if ( v3 == v1 )\n          goto LABEL_6;\n      }\n      v3 += 10;\n      v4 = 1;\n    }\n    while ( v3 != v1 );\nLABEL_6:\n    v1 = v3 + 1;\n  }\n  while ( v3 + 1 != &(*board)[210] );\n  return v2;\n}\n"}, "pseudo_normalize": "int count_holes(int (*board)[10]) {\n  int *v1;\n  int v2;\n  int *v3;\n  int v4;\n  v1 = &(*board)[200];\n  v2 = 0;\n  do {\n    v3 = v1 - 200;\n    v4 = 0;\n    do {\n      while (!*v3) {\n        v2 -= (v4 == 0) - 1;\n        v3 += 10;\n        if (v3 == v1) goto LABEL_6;\n      }\n      v3 += 10;\n      v4 = 1;\n    } while (v3 != v1);\n  LABEL_6:\n    v1 = v3 + 1;\n  } while (v3 + 1 != &(*board)[210]);\n  return v2;\n}", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<count_holes>:\nendbr64\nmov    %rdi,%rsi\nlea    0x320(%rdi),%rdx\nxor    %r8d,%r8d\nadd    $0x348,%rsi\nnopl   0x0(%rax,%rax,1)\nlea    -0x320(%rdx),%rax\nxor    %ecx,%ecx\njmp    15d0 <count_holes+0x40>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x1,%ecx\nsbb    $0xffffffff,%r8d\nadd    $0x28,%rax\ncmp    %rdx,%rax\nje     15e4 <count_holes+0x54>\nmov    (%rax),%edi\ntest   %edi,%edi\nje     15c0 <count_holes+0x30>\nadd    $0x28,%rax\nmov    $0x1,%ecx\ncmp    %rdx,%rax\njne    15d0 <count_holes+0x40>\nlea    0x4(%rax),%rdx\ncmp    %rsi,%rdx\njne    15b0 <count_holes+0x20>\nmov    %r8d,%eax\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "evaluate_board", "content": "// Evaluate a board state given the number of lines cleared by the last move.\ndouble evaluate_board(int board[BOARD_HEIGHT][BOARD_WIDTH], int lines_cleared) {\n    int heights[BOARD_WIDTH];\n    get_column_heights(board, heights);\n    int agg = aggregate_height(heights);\n    int holes = count_holes(board);\n    int bump = bumpiness(heights);\n    double score = WEIGHT_AGGREGATE_HEIGHT * agg +\n                   WEIGHT_COMPLETE_LINES * lines_cleared +\n                   WEIGHT_HOLES * holes +\n                   WEIGHT_BUMPINESS * bump;\n    return score;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "evaluate_board", "address": "0x1640", "label": "evaluate_board", "content": "double __fastcall evaluate_board(int (*board)[10], int lines_cleared)\n{\n  int *v3; // rsi\n  int *v4; // r12\n  int *v5; // rcx\n  int *v6; // rax\n  int v7; // edx\n  int *v8; // rax\n  int v9; // edx\n  int v10; // r15d\n  int *v11; // rdx\n  int v12; // ebp\n  int *v13; // rax\n  int v14; // ecx\n  int v15; // r13d\n  int v16; // edi\n  int heights[10]; // [rsp+0h] [rbp-68h] BYREF\n  _QWORD v19[8]; // [rsp+28h] [rbp-40h] BYREF\n\n  v3 = (int *)board;\n  v19[0] = __readfsqword(0x28u);\n  v4 = heights;\n  v5 = heights;\n  do\n  {\n    *v5 = 0;\n    v6 = v3;\n    v7 = 0;\n    while ( !*v6 )\n    {\n      ++v7;\n      v6 += 10;\n      if ( v7 == 20 )\n        goto LABEL_6;\n    }\n    *v5 = 20 - v7;\nLABEL_6:\n    ++v5;\n    ++v3;\n  }\n  while ( v5 != (int *)v19 );\n  v8 = heights;\n  v9 = 0;\n  do\n  {\n    v9 += *v8++;\n    v10 = v9;\n  }\n  while ( v8 != (int *)v19 );\n  v11 = &(*board)[200];\n  v12 = 0;\n  do\n  {\n    v13 = v11 - 200;\n    v14 = 0;\n    do\n    {\n      while ( !*v13 )\n      {\n        v12 -= (v14 == 0) - 1;\n        v13 += 10;\n        if ( v13 == v11 )\n          goto LABEL_14;\n      }\n      v13 += 10;\n      v14 = 1;\n    }\n    while ( v13 != v11 );\nLABEL_14:\n    v11 = v13 + 1;\n  }\n  while ( v13 + 1 != &(*board)[210] );\n  v15 = 0;\n  do\n  {\n    v16 = *v4 - v4[1];\n    ++v4;\n    v15 += libmin_abs(v16);\n  }\n  while ( &heights[9] != v4 );\n  return (double)v10 * -0.510066 + (double)lines_cleared * 0.760666 + (double)v12 * -0.35663 + (double)v15 * -0.184483;\n}\n"}, "pseudo_normalize": "double evaluate_board(int (*board)[10], int lines_cleared) {\n  int *v3;\n  int *v4;\n  int *v5;\n  int *v6;\n  int v7;\n  int *v8;\n  int v9;\n  int v10;\n  int *v11;\n  int v12;\n  int *v13;\n  int v14;\n  int v15;\n  int v16;\n  int heights[10];\n  uint64_t v19[8];\n  v3 = (int *)board;\n  v19[0] = __readfsqword(40u);\n  v4 = heights;\n  v5 = heights;\n  do {\n    *v5 = 0;\n    v6 = v3;\n    v7 = 0;\n    while (!*v6) {\n      ++v7;\n      v6 += 10;\n      if (v7 == 20) goto LABEL_6;\n    }\n    *v5 = 20 - v7;\n  LABEL_6:\n    ++v5;\n    ++v3;\n  } while (v5 != (int *)v19);\n  v8 = heights;\n  v9 = 0;\n  do {\n    v9 += *v8++;\n    v10 = v9;\n  } while (v8 != (int *)v19);\n  v11 = &(*board)[200];\n  v12 = 0;\n  do {\n    v13 = v11 - 200;\n    v14 = 0;\n    do {\n      while (!*v13) {\n        v12 -= (v14 == 0) - 1;\n        v13 += 10;\n        if (v13 == v11) goto LABEL_14;\n      }\n      v13 += 10;\n      v14 = 1;\n    } while (v13 != v11);\n  LABEL_14:\n    v11 = v13 + 1;\n  } while (v13 + 1 != &(*board)[210]);\n  v15 = 0;\n  do {\n    v16 = *v4 - v4[1];\n    ++v4;\n    v15 += libmin_abs(v16);\n  } while (&heights[9] != v4);\n  return (double)v10 * -0.510066 + (double)lines_cleared * 0.760666 +\n         (double)v12 * -0.35663 + (double)v15 * -0.184483;\n}", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<evaluate_board>:\nendbr64\npush   %r15\nmov    %rdi,%r8\nmov    $0x14,%r9d\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %esi,%ebx\nmov    %r8,%rsi\nsub    $0x38,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x28(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r12\nlea    0x28(%rsp),%rdi\nmov    %r12,%rcx\nnopl   0x0(%rax,%rax,1)\nmovl   $0x0,(%rcx)\nmov    %rsi,%rax\nxor    %edx,%edx\njmp    169c <evaluate_board+0x5c>\nnopl   (%rax)\nadd    $0x1,%edx\nadd    $0x28,%rax\ncmp    $0x14,%edx\nje     16ab <evaluate_board+0x6b>\nmov    (%rax),%r10d\ntest   %r10d,%r10d\nje     1690 <evaluate_board+0x50>\nmov    %r9d,%eax\nsub    %edx,%eax\nmov    %eax,(%rcx)\nadd    $0x4,%rcx\nadd    $0x4,%rsi\ncmp    %rdi,%rcx\njne    1680 <evaluate_board+0x40>\nmov    %r12,%rax\nxor    %edx,%edx\nnopl   (%rax)\nadd    (%rax),%edx\nadd    $0x4,%rax\nmov    %edx,%r15d\ncmp    %rdi,%rax\njne    16c0 <evaluate_board+0x80>\nlea    0x320(%r8),%rdx\nlea    0x348(%r8),%rsi\nxor    %ebp,%ebp\nxchg   %ax,%ax\nlea    -0x320(%rdx),%rax\nxor    %ecx,%ecx\njmp    16ff <evaluate_board+0xbf>\nnopl   0x0(%rax,%rax,1)\ncmp    $0x1,%ecx\nsbb    $0xffffffff,%ebp\nadd    $0x28,%rax\ncmp    %rdx,%rax\nje     1713 <evaluate_board+0xd3>\nmov    (%rax),%edi\ntest   %edi,%edi\nje     16f0 <evaluate_board+0xb0>\nadd    $0x28,%rax\nmov    $0x1,%ecx\ncmp    %rdx,%rax\njne    16ff <evaluate_board+0xbf>\nlea    0x4(%rax),%rdx\ncmp    %rsi,%rdx\njne    16e0 <evaluate_board+0xa0>\nlea    0x24(%r12),%r14\nxor    %r13d,%r13d\nnopl   0x0(%rax)\nmov    (%r12),%edi\nsub    0x4(%r12),%edi\nadd    $0x4,%r12\ncall   1d10 <libmin_abs>\nadd    %eax,%r13d\ncmp    %r12,%r14\njne    1728 <evaluate_board+0xe8>\npxor   %xmm0,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sd %r15d,%xmm0\nmulsd  0x2c71(%rip),%xmm0\ncvtsi2sd %ebx,%xmm1\nmulsd  0x2c6d(%rip),%xmm1\naddsd  %xmm1,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sd %ebp,%xmm1\nmulsd  0x2c61(%rip),%xmm1\naddsd  %xmm1,%xmm0\npxor   %xmm1,%xmm1\ncvtsi2sd %r13d,%xmm1\nmulsd  0x2c54(%rip),%xmm1\naddsd  %xmm1,%xmm0\nmov    0x28(%rsp),%rax\nsub    %fs:0x28,%rax\njne    17af <evaluate_board+0x16f>\nadd    $0x38,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10c0 <__stack_chk_fail@plt>\ndata16 cs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "get_column_heights", "content": "// ------------------------\n// Heuristic Evaluation Functions\n// ------------------------\n\n// Compute the height of each column.\nvoid get_column_heights(int board[BOARD_HEIGHT][BOARD_WIDTH], int heights[BOARD_WIDTH]) {\n    for (int x = 0; x < BOARD_WIDTH; x++) {\n        heights[x] = 0;\n        for (int y = 0; y < BOARD_HEIGHT; y++) {\n            if (board[y][x] != 0) {\n                heights[x] = BOARD_HEIGHT - y;\n                break;\n            }\n        }\n    }\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "get_column_heights", "address": "0x1520", "label": "get_column_heights", "content": "void __fastcall get_column_heights(int (*board)[10], int *heights)\n{\n  int *v2; // rcx\n  int *v3; // rdx\n  int v4; // eax\n\n  v2 = &(*board)[10];\n  do\n  {\n    *heights = 0;\n    v3 = (int *)board;\n    v4 = 0;\n    while ( !*v3 )\n    {\n      ++v4;\n      v3 += 10;\n      if ( v4 == 20 )\n        goto LABEL_6;\n    }\n    *heights = 20 - v4;\nLABEL_6:\n    board = (int (*)[10])((char *)board + 4);\n    ++heights;\n  }\n  while ( board != (int (*)[10])v2 );\n}\n"}, "pseudo_normalize": "void get_column_heights(int (*board)[10], int *heights) {\n  int *v2;\n  int *v3;\n  int v4;\n  v2 = &(*board)[10];\n  do {\n    *heights = 0;\n    v3 = (int *)board;\n    v4 = 0;\n    while (!*v3) {\n      ++v4;\n      v3 += 10;\n      if (v4 == 20) goto LABEL_6;\n    }\n    *heights = 20 - v4;\n  LABEL_6:\n    board = (int(*)[10])((char *)board + 4);\n    ++heights;\n  } while (board != (int(*)[10])v2);\n}", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<get_column_heights>:\nendbr64\nlea    0x28(%rdi),%rcx\nmov    $0x14,%r8d\nxchg   %ax,%ax\nmovl   $0x0,(%rsi)\nmov    %rdi,%rdx\nxor    %eax,%eax\njmp    154c <get_column_heights+0x2c>\nnopl   (%rax)\nadd    $0x1,%eax\nadd    $0x28,%rdx\ncmp    $0x14,%eax\nje     155b <get_column_heights+0x3b>\nmov    (%rdx),%r9d\ntest   %r9d,%r9d\nje     1540 <get_column_heights+0x20>\nmov    %r8d,%edx\nsub    %eax,%edx\nmov    %edx,(%rsi)\nadd    $0x4,%rdi\nadd    $0x4,%rsi\ncmp    %rcx,%rdi\njne    1530 <get_column_heights+0x10>\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "main", "content": "// ------------------------\n// Main Simulation Loop\n// ------------------------\nint main(void) {\n    libmin_srand(42);\n    int board[BOARD_HEIGHT][BOARD_WIDTH];\n    create_board(board);\n    int move_count = 0;\n    int total_lines_cleared = 0;\n\n    while (1) {\n        const Piece *piece = random_piece();\n        const Orientation *best_ori;\n        int best_offset;\n        double best_score;\n        int new_board[BOARD_HEIGHT][BOARD_WIDTH];\n        int lines;\n        if (!best_move(board, piece, &best_ori, &best_offset, &best_score, new_board, &lines)) {\n            libmin_printf(\"Game over!\\n\");\n            break;\n        }\n        // Update board state.\n        libmin_memcpy(board, new_board, sizeof(board));\n        total_lines_cleared += lines;\n        move_count++;\n        // Print board every 10 moves.\n        if (move_count % 10 == 0) {\n            libmin_printf(\"After move %d, total lines cleared: %d, last move score: %f\\n\", move_count, total_lines_cleared, best_score);\n            print_board(board);\n        }\n    }\n    libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", move_count, total_lines_cleared);\n    print_board(board);\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // r13d\n  int v4; // ebp\n  const Piece *v5; // rsi\n  __int64 v6; // [rsp-10h] [rbp-6C8h]\n  int best_offset; // [rsp+18h] [rbp-6A0h] BYREF\n  int lines; // [rsp+1Ch] [rbp-69Ch] BYREF\n  const Orientation *best_ori; // [rsp+20h] [rbp-698h] BYREF\n  double best_score; // [rsp+28h] [rbp-690h] BYREF\n  int board[20][10]; // [rsp+30h] [rbp-688h] BYREF\n  int new_board[20][10]; // [rsp+350h] [rbp-368h] BYREF\n  unsigned __int64 v13; // [rsp+678h] [rbp-40h]\n\n  v3 = 0;\n  v4 = 0;\n  v13 = __readfsqword(0x28u);\n  libmin_srand(0x2Au);\n  create_board(board);\n  while ( 1 )\n  {\n    v5 = &pieces[libmin_rand() % 7];\n    if ( !best_move(board, v5, &best_ori, &best_offset, &best_score, new_board, &lines) )\n      break;\n    ++v4;\n    libmin_memcpy(board, new_board, 0x320uLL);\n    v3 += lines;\n    if ( __ROR4__(-858993459 * v4, 1) <= 0x19999999u )\n    {\n      libmin_printf(\"After move %d, total lines cleared: %d, last move score: %f\\n\", v4, v3, best_score);\n      print_board(board);\n    }\n  }\n  libmin_printf(\"Game over!\\n\", v5, v6);\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", v4, v3);\n  print_board(board);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  const Piece *v5;\n  long long v6;\n  int best_offset;\n  int lines;\n  const Orientation *best_ori;\n  double best_score;\n  int board[20][10];\n  int new_board[20][10];\n  unsigned long long v13;\n  v3 = 0;\n  v4 = 0;\n  v13 = __readfsqword(40u);\n  libmin_srand(42u);\n  create_board(board);\n  while (1) {\n    v5 = &pieces[libmin_rand() % 7];\n    if (!best_move(board, v5, &best_ori, &best_offset, &best_score, new_board,\n                   &lines))\n      break;\n    ++v4;\n    libmin_memcpy(board, new_board, 800uLL);\n    v3 += lines;\n    if (__ROR4__(-858993459 * v4, 1) <= 429496729u) {\n      libmin_printf(\n          \"After move %d, total lines cleared: %d, last move score: %f\\n\", v4,\n          v3, best_score);\n      print_board(board);\n    }\n  }\n  libmin_printf(\"Game over!\\n\", v5, v6);\n  libmin_printf(\"Game over after %d moves, total lines cleared: %d\\n\", v4, v3);\n  print_board(board);\n  libmin_success();\n}", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\nmov    $0x2a,%edi\npush   %r14\npush   %r13\nxor    %r13d,%r13d\npush   %r12\npush   %rbp\nxor    %ebp,%ebp\npush   %rbx\nsub    $0x688,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x678(%rsp)\nxor    %eax,%eax\nlea    0x30(%rsp),%r12\nlea    0x28(%rsp),%r15\ncall   32c0 <libmin_srand>\nmov    %r12,%rdi\nlea    0x18(%rsp),%r14\nlea    0x350(%rsp),%rbx\ncall   1390 <create_board>\nlea    0x20(%rsp),%rax\nmov    %rax,0x8(%rsp)\nlea    0x1c(%rsp),%rax\nmov    %rax,(%rsp)\nnopl   0x0(%rax)\ncall   3320 <libmin_rand>\nsub    $0x8,%rsp\nmov    %r14,%rcx\nmov    %rbx,%r9\nmov    %eax,%edx\npush   0x8(%rsp)\nmov    %r15,%r8\nmov    %r12,%rdi\nmov    %rdx,%rsi\nimul   $0x24924925,%rdx,%rdx\nmov    %esi,%eax\nshr    $0x20,%rdx\nsub    %edx,%eax\nshr    %eax\nadd    %edx,%eax\nshr    $0x2,%eax\nlea    0x0(,%rax,8),%edx\nsub    %eax,%edx\nlea    0x5b4c(%rip),%rax\nsub    %edx,%esi\nmov    0x18(%rsp),%rdx\nshl    $0x4,%rsi\nadd    %rax,%rsi\ncall   1860 <best_move>\npop    %rdx\npop    %rcx\ntest   %eax,%eax\nje     1248 <main+0x128>\nmov    $0x320,%edx\nmov    %rbx,%rsi\nmov    %r12,%rdi\nadd    $0x1,%ebp\ncall   1d20 <libmin_memcpy>\nimul   $0xcccccccd,%ebp,%eax\nadd    0x1c(%rsp),%r13d\nror    %eax\ncmp    $0x19999999,%eax\nja     1190 <main+0x70>\nmovsd  0x28(%rsp),%xmm0\nmov    %r13d,%edx\nmov    %ebp,%esi\nmov    $0x1,%eax\nlea    0x2e21(%rip),%rdi\ncall   30b0 <libmin_printf>\nmov    %r12,%rdi\ncall   1a60 <print_board>\njmp    1190 <main+0x70>\nnopl   0x0(%rax)\nlea    0x2db8(%rip),%rdi\ncall   30b0 <libmin_printf>\nmov    %r13d,%edx\nmov    %ebp,%esi\nxor    %eax,%eax\nlea    0x2db6(%rip),%rdi\ncall   30b0 <libmin_printf>\nmov    %r12,%rdi\ncall   1a60 <print_board>\ncall   3500 <libmin_success>\nmov    0x678(%rsp),%rax\nsub    %fs:0x28,%rax\njne    129b <main+0x17b>\nadd    $0x688,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10c0 <__stack_chk_fail@plt>\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "place_piece", "content": "// Place the piece on the board (modifies board)\nvoid place_piece(int board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int offset_y) {\n    for (int i = 0; i < ori->numBlocks; i++) {\n        int x = offset_x + ori->blocks[i].x;\n        int y = offset_y + ori->blocks[i].y;\n        board[y][x] = 1;\n    }\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "place_piece", "address": "0x1440", "label": "place_piece", "content": "void __fastcall place_piece(int (*board)[10], const Orientation *ori, int offset_x, int offset_y)\n{\n  __int64 v5; // rax\n  int *v6; // r8\n  int x; // edi\n\n  if ( ori->numBlocks > 0 )\n  {\n    v5 = 0LL;\n    do\n    {\n      v6 = &(*board)[10 * offset_y + 10 * ori->blocks[v5].y];\n      x = ori->blocks[v5++].x;\n      v6[offset_x + x] = 1;\n    }\n    while ( ori->numBlocks > (int)v5 );\n  }\n}\n"}, "pseudo_normalize": "void place_piece(int (*board)[10], const Orientation *ori, int offset_x,\n                 int offset_y) {\n  long long v5;\n  int *v6;\n  int x;\n  if (ori->numBlocks > 0) {\n    v5 = 0LL;\n    do {\n      v6 = &(*board)[10 * offset_y + 10 * ori->blocks[v5].y];\n      x = ori->blocks[v5++].x;\n      v6[offset_x + x] = 1;\n    } while (ori->numBlocks > (int)v5);\n  }\n}", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<place_piece>:\nendbr64\nmov    (%rsi),%eax\nmov    %rdi,%r9\ntest   %eax,%eax\njle    1479 <place_piece+0x39>\nxor    %eax,%eax\nmov    0x8(%rsi,%rax,8),%edi\nadd    %ecx,%edi\nmovslq %edi,%rdi\nlea    (%rdi,%rdi,4),%rdi\nlea    (%r9,%rdi,8),%r8\nmov    0x4(%rsi,%rax,8),%edi\nadd    $0x1,%rax\nadd    %edx,%edi\nmovslq %edi,%rdi\nmovl   $0x1,(%r8,%rdi,4)\ncmp    %eax,(%rsi)\njg     144f <place_piece+0xf>\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "print_board", "content": "// ------------------------\n// Board Display (text-based)\n// ------------------------\nvoid print_board(int board[BOARD_HEIGHT][BOARD_WIDTH]) {\n    for (int y = 0; y < BOARD_HEIGHT; y++) {\n        for (int x = 0; x < BOARD_WIDTH; x++) {\n            libmin_printf(\"%c\", board[y][x] ? 'X' : '.');\n        }\n        libmin_printf(\"\\n\");\n    }\n    libmin_printf(\"\\n\");\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "print_board", "address": "0x1a60", "label": "print_board", "content": "void __fastcall print_board(int (*board)[10])\n{\n  int *v1; // rbp\n  int *v2; // rbx\n  int v3; // esi\n\n  v1 = &(*board)[10];\n  do\n  {\n    v2 = v1 - 10;\n    do\n    {\n      v3 = -(*v2++ == 0);\n      libmin_printf(\"%c\", (v3 & 0xFFFFFFD6) + 88);\n    }\n    while ( v2 != v1 );\n    v1 = v2 + 10;\n    libmin_printf((char *)\"\\n\");\n  }\n  while ( v2 + 10 != &(*board)[210] );\n  libmin_printf((char *)\"\\n\");\n}\n"}, "pseudo_normalize": "void print_board(int (*board)[10]) {\n  int *v1;\n  int *v2;\n  int v3;\n  v1 = &(*board)[10];\n  do {\n    v2 = v1 - 10;\n    do {\n      v3 = -(*v2++ == 0);\n      libmin_printf(\"%c\", (v3 & 4294967254) + 88);\n    } while (v2 != v1);\n    v1 = v2 + 10;\n    libmin_printf((char *)\"\\n\");\n  } while (v2 + 10 != &(*board)[210]);\n  libmin_printf((char *)\"\\n\");\n}", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<print_board>:\nendbr64\npush   %r14\nlea    0x25a4(%rip),%r14\npush   %r13\nlea    0x348(%rdi),%r13\npush   %r12\nlea    0x2585(%rip),%r12\npush   %rbp\nlea    0x28(%rdi),%rbp\npush   %rbx\nnopl   (%rax)\nlea    -0x28(%rbp),%rbx\nnopl   0x0(%rax)\ncmpl   $0x1,(%rbx)\nmov    %r12,%rdi\nsbb    %esi,%esi\nxor    %eax,%eax\nadd    $0x4,%rbx\nand    $0xffffffd6,%esi\nadd    $0x58,%esi\ncall   30b0 <libmin_printf>\ncmp    %rbp,%rbx\njne    1a90 <print_board+0x30>\nmov    %r14,%rdi\nxor    %eax,%eax\nlea    0x28(%rbx),%rbp\ncall   30b0 <libmin_printf>\ncmp    %r13,%rbp\njne    1a88 <print_board+0x28>\npop    %rbx\nmov    %r14,%rdi\npop    %rbp\nxor    %eax,%eax\npop    %r12\npop    %r13\npop    %r14\njmp    30b0 <libmin_printf>\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "random_piece", "content": "// ------------------------\n// Random Piece Selection\n// ------------------------\nconst Piece* random_piece() {\n    int index = libmin_rand() % NUM_PIECES;\n    return &pieces[index];\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "random_piece", "address": "0x1ae0", "label": "random_piece", "content": "const Piece *__cdecl random_piece()\n{\n  return &pieces[libmin_rand() % 7];\n}\n"}, "pseudo_normalize": "", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<random_piece>:\nendbr64\nsub    $0x8,%rsp\ncall   3320 <libmin_rand>\nadd    $0x8,%rsp\nmov    %eax,%ecx\nmov    %eax,%edx\nimul   $0x24924925,%rcx,%rcx\nshr    $0x20,%rcx\nsub    %ecx,%edx\nshr    %edx\nadd    %ecx,%edx\nshr    $0x2,%edx\nlea    0x0(,%rdx,8),%ecx\nsub    %edx,%ecx\nlea    0x5207(%rip),%rdx\nsub    %ecx,%eax\nshl    $0x4,%rax\nadd    %rdx,%rax\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "tetris-sim/tetris-sim.c", "function_name": "simulate_board", "content": "// ------------------------\n// Simulation: Try dropping a piece and evaluating the resulting board.\n// ------------------------\n\n// Simulate dropping the piece (of a given orientation) at horizontal offset 'offset_x'.\n// The result is written into sim_board, and the number of lines cleared is returned via lines_cleared.\n// Returns 1 if placement is valid, 0 otherwise.\nint simulate_board(int orig_board[BOARD_HEIGHT][BOARD_WIDTH], const Orientation *ori, int offset_x, int sim_board[BOARD_HEIGHT][BOARD_WIDTH], int *lines_cleared) {\n    libmin_memcpy(sim_board, orig_board, sizeof(int) * BOARD_HEIGHT * BOARD_WIDTH);\n    int y = 0;\n    // Drop the piece until a collision is detected.\n    while (!check_collision(sim_board, ori, offset_x, y))\n        y++;\n    y--;  // last valid position\n    if (y < 0)\n        return 0;\n    place_piece(sim_board, ori, offset_x, y);\n    *lines_cleared = clear_lines(sim_board);\n    return 1;\n}\n"}, "pseudo": {"path": "tetris-sim/tetris-sim.host.O2.pseudo", "function_name": "simulate_board", "address": "0x17c0", "label": "simulate_board", "content": "int __fastcall simulate_board(\n        int (*orig_board)[10],\n        const Orientation *ori,\n        int offset_x,\n        int (*sim_board)[10],\n        int *lines_cleared)\n{\n  int i; // ecx\n  int v10; // ecx\n  int v11; // esi\n  int result; // eax\n  __int64 v13; // rax\n  int *v14; // rcx\n  int x; // edx\n\n  libmin_memcpy(sim_board, orig_board, 0x320uLL);\n  for ( i = 0; !check_collision(sim_board, ori, offset_x, i); i = v10 + 1 )\n    ;\n  v11 = v10 - 1;\n  result = 0;\n  if ( v10 )\n  {\n    if ( ori->numBlocks > 0 )\n    {\n      v13 = 0LL;\n      do\n      {\n        v14 = &(*sim_board)[10 * v11 + 10 * ori->blocks[v13].y];\n        x = ori->blocks[v13++].x;\n        v14[offset_x + x] = 1;\n      }\n      while ( ori->numBlocks > (int)v13 );\n    }\n    *lines_cleared = clear_lines(sim_board);\n    return 1;\n  }\n  return result;\n}\n"}, "pseudo_normalize": "int simulate_board(int (*orig_board)[10], const Orientation *ori, int offset_x,\n                   int (*sim_board)[10], int *lines_cleared) {\n  int i;\n  int v10;\n  int v11;\n  int result;\n  long long v13;\n  int *v14;\n  int x;\n  libmin_memcpy(sim_board, orig_board, 800uLL);\n  for (i = 0; !check_collision(sim_board, ori, offset_x, i); i = v10 + 1)\n    ;\n  v11 = v10 - 1;\n  result = 0;\n  if (v10) {\n    if (ori->numBlocks > 0) {\n      v13 = 0LL;\n      do {\n        v14 = &(*sim_board)[10 * v11 + 10 * ori->blocks[v13].y];\n        x = ori->blocks[v13++].x;\n        v14[offset_x + x] = 1;\n      } while (ori->numBlocks > (int)v13);\n    }\n    *lines_cleared = clear_lines(sim_board);\n    return 1;\n  }\n  return result;\n}", "binary": "tetris-sim/tetris-sim.host.O2", "assembly": "<simulate_board>:\nendbr64\npush   %r13\nmov    %r8,%r13\npush   %r12\nmov    %edx,%r12d\nmov    $0x320,%edx\npush   %rbp\nmov    %rcx,%rbp\npush   %rbx\nmov    %rsi,%rbx\nmov    %rdi,%rsi\nmov    %rcx,%rdi\nsub    $0x8,%rsp\ncall   1d20 <libmin_memcpy>\nxor    %ecx,%ecx\njmp    17f3 <simulate_board+0x33>\nxchg   %ax,%ax\nadd    $0x1,%ecx\nmov    %r12d,%edx\nmov    %rbx,%rsi\nmov    %rbp,%rdi\ncall   13d0 <check_collision>\ntest   %eax,%eax\nje     17f0 <simulate_board+0x30>\nlea    -0x1(%rcx),%esi\nxor    %eax,%eax\ntest   %ecx,%ecx\nje     1852 <simulate_board+0x92>\nmov    (%rbx),%eax\ntest   %eax,%eax\njle    1841 <simulate_board+0x81>\nxor    %eax,%eax\nmov    0x8(%rbx,%rax,8),%edx\nadd    %esi,%edx\nmovslq %edx,%rdx\nlea    (%rdx,%rdx,4),%rdx\nlea    0x0(%rbp,%rdx,8),%rcx\nmov    0x4(%rbx,%rax,8),%edx\nadd    $0x1,%rax\nadd    %r12d,%edx\nmovslq %edx,%rdx\nmovl   $0x1,(%rcx,%rdx,4)\ncmp    %eax,(%rbx)\njg     1816 <simulate_board+0x56>\nmov    %rbp,%rdi\ncall   1480 <clear_lines>\nmov    %eax,0x0(%r13)\nmov    $0x1,%eax\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   (%rax)\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "fillArrayNull", "content": "/*\n * fills the array with 0\n */\nvoid fillArrayNull(NETWORK_DATA_TYPE* array, unsigned int size)\n{\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tarray[i] = (NETWORK_DATA_TYPE)0;\n\t}\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O2.pseudo", "function_name": "fillArrayNull", "address": "0x13b0", "label": "fillArrayNull", "content": "void __fastcall fillArrayNull(double *array, unsigned int size)\n{\n  if ( size )\n    memset(array, 0, 8LL * size);\n}\n"}, "pseudo_normalize": "", "binary": "tiny-NN/tiny-NN.host.O2", "assembly": "<fillArrayNull>:\nendbr64\ntest   %esi,%esi\nje     13d0 <fillArrayNull+0x20>\nmov    %esi,%esi\nlea    0x0(,%rsi,8),%rdx\nxor    %esi,%esi\njmp    10d0 <memset@plt>\nnopl   0x0(%rax)\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "fillArrayRand", "content": "/*\n * fills the array with values from [-0.5,0.5]\n */\nvoid fillArrayRand(NETWORK_DATA_TYPE* array, unsigned int size)\n{\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tarray[i] = (NETWORK_DATA_TYPE)libmin_rand()/(NETWORK_DATA_TYPE)RAND_MAX - 0.5;\n\t}\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O2.pseudo", "function_name": "fillArrayRand", "address": "0x1350", "label": "fillArrayRand", "content": "void __fastcall fillArrayRand(double *array, unsigned int size)\n{\n  double *v2; // rbx\n\n  if ( size )\n  {\n    v2 = array;\n    do\n      *v2++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n    while ( v2 != &array[size] );\n  }\n}\n"}, "pseudo_normalize": "void fillArrayRand(double *array, unsigned int size) {\n  double *v2;\n  if (size) {\n    v2 = array;\n    do *v2++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n    while (v2 != &array[size]);\n  }\n}", "binary": "tiny-NN/tiny-NN.host.O2", "assembly": "<fillArrayRand>:\nendbr64\ntest   %esi,%esi\nje     13a8 <fillArrayRand+0x58>\npush   %rbp\nlea    -0x1(%rsi),%eax\npush   %rbx\nlea    0x8(%rdi,%rax,8),%rbp\nmov    %rdi,%rbx\nsub    $0x8,%rsp\nnopl   0x0(%rax)\ncall   31d0 <libmin_rand>\npxor   %xmm0,%xmm0\nadd    $0x8,%rbx\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x3cbc(%rip),%xmm0\nsubsd  0x3cbc(%rip),%xmm0\nmovsd  %xmm0,-0x8(%rbx)\ncmp    %rbp,%rbx\njne    1370 <fillArrayRand+0x20>\nadd    $0x8,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   (%rax)\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "g", "content": "/*\n * the sigmoid function\n */\ninline NETWORK_DATA_TYPE g(NETWORK_DATA_TYPE a)\n{\n\treturn 1.0 / (1.0 + libmin_exp(-1.0*a));\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O2.pseudo", "function_name": "g", "address": "0x12a0", "label": "g", "content": "double __fastcall g(double a1, double a)\n{\n  return 1.0 / (libmin_exp(a) + 1.0);\n}\n"}, "pseudo_normalize": "", "binary": "tiny-NN/tiny-NN.host.O2", "assembly": "<g>:\nendbr64\nsub    $0x8,%rsp\nxorpd  0x3d80(%rip),%xmm0\ncall   1a20 <libmin_exp>\nmovsd  0x3d83(%rip),%xmm1\nadd    $0x8,%rsp\naddsd  %xmm1,%xmm0\ndivsd  %xmm0,%xmm1\nmovapd %xmm1,%xmm0\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "g_deriv", "content": "//flavor!\n//#define FANCY\n#define OUTPUT\n\n/*\n * the derivative of the sigmoid function\n */\ninline NETWORK_DATA_TYPE g_deriv(NETWORK_DATA_TYPE a)\n{\n\tNETWORK_DATA_TYPE sigmoid = 1.0 / (1.0 + libmin_exp(-1.0*a));\n\n\treturn sigmoid*(1.0-sigmoid);\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O2.pseudo", "function_name": "g_deriv", "address": "0x1260", "label": "g_deriv", "content": "double __fastcall g_deriv(double a1, double a)\n{\n  double v2; // xmm0_8\n\n  v2 = libmin_exp(a);\n  return (1.0 - 1.0 / (v2 + 1.0)) * (1.0 / (v2 + 1.0));\n}\n"}, "pseudo_normalize": "", "binary": "tiny-NN/tiny-NN.host.O2", "assembly": "<g_deriv>:\nendbr64\nsub    $0x8,%rsp\nxorpd  0x3dc0(%rip),%xmm0\ncall   1a20 <libmin_exp>\nmovsd  0x3dc3(%rip),%xmm1\nadd    $0x8,%rsp\naddsd  %xmm1,%xmm0\nmovapd %xmm1,%xmm2\ndivsd  %xmm0,%xmm2\nsubsd  %xmm2,%xmm1\nmulsd  %xmm2,%xmm1\nmovapd %xmm1,%xmm0\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "main", "content": "int\nmain(void)\n{\n  libmin_srand(42);\n\ttrain(0.005, 0.01, 1.0, 0.4);\n\n\tlibmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm4_8\n\n  libmin_srand(0x2Au);\n  train(0.01, 1.0, 0.4, v3);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  libmin_srand(42u);\n  train(0.01, 1.0, 0.4, v3);\n  libmin_success();\n}", "binary": "tiny-NN/tiny-NN.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0x2a,%edi\ncall   3170 <libmin_srand>\nmovsd  0x3f26(%rip),%xmm3\nmovsd  0x3efe(%rip),%xmm2\nmovsd  0x3f1e(%rip),%xmm1\nmovsd  0x3f1e(%rip),%xmm0\ncall   13e0 <train>\ncall   38e0 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "sampleSine", "content": "/*\n * samples the sin function from 'start' to 'end' with 'size' equidistant steps\n */\nvoid sampleSine(NETWORK_DATA_TYPE* input, NETWORK_DATA_TYPE* output, NETWORK_DATA_TYPE start, NETWORK_DATA_TYPE end, unsigned int size)\n{\n\tNETWORK_DATA_TYPE step = (end-start)/(NETWORK_DATA_TYPE)size;\n\n\tunsigned int i;\n\tfor(i=0; i<size; ++i)\n\t{\n\t\tinput[i] = start + step * (NETWORK_DATA_TYPE)i;\n\t\toutput[i] = libmin_sin(input[i]);\n\t}\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O2.pseudo", "function_name": "sampleSine", "address": "0x12d0", "label": "sampleSine", "content": "void __fastcall sampleSine(double *input, double *output, double start, double end, int size)\n{\n  __int64 v5; // r12\n  double v6; // xmm1_8\n  __int64 v7; // r13\n\n  v5 = (unsigned int)size;\n  v6 = (end - start) / (double)size;\n  if ( size )\n  {\n    v7 = 0LL;\n    do\n    {\n      input[v7] = (double)(int)v7 * v6 + start;\n      output[v7++] = libmin_sin(v6);\n    }\n    while ( v5 != v7 );\n  }\n}\n"}, "pseudo_normalize": "void sampleSine(double *input, double *output, double start, double end,\n                int size) {\n  long long v5;\n  double v6;\n  long long v7;\n  v5 = (unsigned int)size;\n  v6 = (end - start) / (double)size;\n  if (size) {\n    v7 = 0LL;\n    do {\n      input[v7] = (double)(int)v7 * v6 + start;\n      output[v7++] = libmin_sin(v6);\n    } while (v5 != v7);\n  }\n}", "binary": "tiny-NN/tiny-NN.host.O2", "assembly": "<sampleSine>:\nendbr64\npush   %r13\nsubsd  %xmm0,%xmm1\npush   %r12\nmov    %edx,%r12d\npush   %rbp\npush   %rbx\nsub    $0x18,%rsp\nmovsd  %xmm0,0x8(%rsp)\npxor   %xmm0,%xmm0\ncvtsi2sd %r12,%xmm0\ndivsd  %xmm0,%xmm1\nmovsd  %xmm1,(%rsp)\ntest   %edx,%edx\nje     1342 <sampleSine+0x72>\nmov    %rdi,%rbx\nmov    %rsi,%rbp\nxor    %r13d,%r13d\nnopw   0x0(%rax,%rax,1)\nmov    %r13d,%eax\npxor   %xmm0,%xmm0\ncvtsi2sd %rax,%xmm0\nmulsd  (%rsp),%xmm0\naddsd  0x8(%rsp),%xmm0\nmovsd  %xmm0,(%rbx,%r13,8)\ncall   3700 <libmin_sin>\nmovsd  %xmm0,0x0(%rbp,%r13,8)\nadd    $0x1,%r13\ncmp    %r13,%r12\njne    1310 <sampleSine+0x40>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   (%rax)\n"}
{"source": {"path": "tiny-NN/tiny-NN.c", "function_name": "train", "content": "int train(NETWORK_DATA_TYPE eta, NETWORK_DATA_TYPE error_threshold, NETWORK_DATA_TYPE bias, NETWORK_DATA_TYPE alpha)\n{\n\n\tNETWORK_DATA_TYPE total_error = error_threshold + 1.0;//why?\n\n\t//data\n\tNETWORK_DATA_TYPE input[SAMPLE_COUNT];\n\tNETWORK_DATA_TYPE output[SAMPLE_COUNT];\n\n\t//NN container for NEURON_COUNT neurons\n\tNETWORK_DATA_TYPE NN_output = 0;\n\tNETWORK_DATA_TYPE weights_layer0_1[NEURON_COUNT*2]; //don't forget the bias :-) {PSSSTT: format = [input_w, bias_w, input_w, bias_w...]}\n\tNETWORK_DATA_TYPE weights_layer1_2[NEURON_COUNT];\n\n\tNETWORK_DATA_TYPE delta_weights_layer0_1[NEURON_COUNT*2]; //don't forget the bias :-) {PSSSTT: format = [input_w, bias_w, input_w, bias_w...]}\n\tNETWORK_DATA_TYPE delta_weights_layer1_2[NEURON_COUNT];\n\n\tNETWORK_DATA_TYPE delta_layer_2, delta_layer_1;\n\tNETWORK_DATA_TYPE a;\n\tNETWORK_DATA_TYPE g_layer_1[NEURON_COUNT];\n\tNETWORK_DATA_TYPE g_deriv_layer_1[NEURON_COUNT];\n\tNETWORK_DATA_TYPE delta_w_layer_2_1;\n\tNETWORK_DATA_TYPE delta_w_layer_1_0;\n\n\t//init the network\n\tfillArrayRand(weights_layer0_1,NEURON_COUNT*2);//random values for the weight 0->1\n\tfillArrayRand(weights_layer1_2,NEURON_COUNT);//random values for the weights 1->2\n\n\tfillArrayNull(delta_weights_layer0_1,NEURON_COUNT*2);\n\tfillArrayNull(delta_weights_layer1_2,NEURON_COUNT);\n\n\t//create the training data\n\tsampleSine(input, output, 0, 3.14, SAMPLE_COUNT);\n\n\t//train the network\n\tunsigned int iteration_count = 0;\n\n\twhile(total_error > error_threshold && iteration_count < MAX_ITERATIONS)\n\t{\n\t\ttotal_error = 0;//hmmm....\n\n\t\t//present the data to the NN\n\t\tunsigned int i;\n\t\tfor(i=0; i<SAMPLE_COUNT; ++i)\n\t\t{\n\t\t\t//propagate the sample forward\n\t\t\t//layer 0 -> 1 ... and layer 1->2\n\t\t\tunsigned int j;\n\t\t\tfor(j=0; j<NEURON_COUNT; ++j)\n\t\t\t{\n\t\t\t\ta = input[i] * weights_layer0_1[2*j] + bias * weights_layer0_1[2*j+1];\n\t\t\t\tg_layer_1[j] = g(a);\n\t\t\t\tg_deriv_layer_1[j] = g_deriv(a);\n\n\t\t\t\tNN_output += weights_layer1_2[j] * g_layer_1[j];\n\t\t\t}\n\n\t\t\t//calculate the errors\n\t\t\tdelta_layer_2 = NN_output - output[i];\n\t\t\ttotal_error += delta_layer_2*delta_layer_2;\n\n\t\t\t//backpropagate the deltas\n\t\t\t//layer 2->1 ... and 1->0\n\t\t\tfor(j=0; j<NEURON_COUNT; ++j)\n\t\t\t{\n\t\t\t\tdelta_layer_1 = g_deriv_layer_1[j] * weights_layer1_2[j] * delta_layer_2;\n\t\t\t\tdelta_w_layer_2_1 = delta_layer_2 * g_layer_1[j];\n\n\t\t\t\t//?\n\t\t\t\tweights_layer1_2[j] -= delta_w_layer_2_1 * eta + alpha*delta_weights_layer1_2[j] ;\n\t\t\t\tdelta_weights_layer1_2[j] = delta_w_layer_2_1 * eta + alpha*delta_weights_layer1_2[j] ;\n\n\t\t\t\tdelta_w_layer_1_0 = delta_layer_1 * input[i];\n\t\t\t\tweights_layer0_1[2*j] -= delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j];\n\t\t\t\tdelta_weights_layer0_1[2*j] = delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j];\n\n\t\t\t\tdelta_w_layer_1_0 = delta_layer_1 * bias;\n\t\t\t\tweights_layer0_1[2*j+1] -= delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j+1];\n\t\t\t\tdelta_weights_layer0_1[2*j+1] = delta_w_layer_1_0 * eta + alpha*delta_weights_layer0_1[2*j+1];\n\t\t\t}\n\n\t\t\t//update the weights (uppsi, did it already... but how?)\n\t\t\t#ifdef FANCY\n\t\t\tlibmin_printf(\"sample error %f, should %f is %f\\n\",delta_layer_2,output[i], NN_output);\n\t\t\t#endif\n\n\t\t\t//prepare for the next nerve wrecking round\n\t\t\tNN_output = 0;\n\t\t}\n\n\t\t#ifdef FANCY\n\t\tlibmin_printf(\"Total error %f\\n\\n\",total_error);\n\t\t#endif\n\n\t\t++iteration_count;\n\n\t\tfillArrayNull(delta_weights_layer0_1,NEURON_COUNT*2);\n\t\tfillArrayNull(delta_weights_layer1_2,NEURON_COUNT);\n\n\t\t#ifdef OUTPUT\n\t\tlibmin_printf(\"iteration %d Total error %f\\n\",iteration_count,total_error);\n\t\t#endif\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n"}, "pseudo": {"path": "tiny-NN/tiny-NN.host.O2.pseudo", "function_name": "train", "address": "0x13e0", "label": "train", "content": "__int64 __fastcall train(double a1, double eta, double error_threshold, double bias, double alpha)\n{\n  double *v5; // r15\n  double *v6; // rbx\n  double v7; // xmm1_8\n  double *v8; // r14\n  double *v9; // r12\n  __int64 i; // rbx\n  double v11; // xmm4_8\n  double *v12; // rbx\n  double *v13; // rbp\n  double *v14; // rax\n  double *v15; // r13\n  double *v16; // rbx\n  double *v17; // rbp\n  double *v18; // r14\n  unsigned __int64 v19; // r15\n  double v20; // xmm0_8\n  double v21; // xmm0_8\n  double v22; // xmm5_8\n  double *v23; // rdx\n  double v24; // xmm6_8\n  double *v25; // rcx\n  __int64 v26; // rax\n  double v27; // xmm5_8\n  double v28; // xmm0_8\n  double v29; // xmm1_8\n  double v30; // xmm1_8\n  double v31; // xmm5_8\n  double v32; // xmm5_8\n  double v33; // xmm1_8\n  double v34; // xmm0_8\n  double v35; // xmm1_8\n  double *v36; // rax\n  double NN_outputa; // [rsp+0h] [rbp-6F8h]\n  double v40; // [rsp+8h] [rbp-6F0h]\n  double v41; // [rsp+18h] [rbp-6E0h]\n  double x; // [rsp+20h] [rbp-6D8h]\n  __int64 v43; // [rsp+28h] [rbp-6D0h]\n  double total_error; // [rsp+30h] [rbp-6C8h]\n  double v45; // [rsp+38h] [rbp-6C0h]\n  unsigned int iteration_count; // [rsp+64h] [rbp-694h]\n  double input[20]; // [rsp+70h] [rbp-688h]\n  double output[20]; // [rsp+110h] [rbp-5E8h]\n  double weights_layer1_2[20]; // [rsp+1B0h] [rbp-548h] BYREF\n  double delta_weights_layer1_2[20]; // [rsp+250h] [rbp-4A8h] BYREF\n  double g_layer_1[20]; // [rsp+2F0h] [rbp-408h]\n  double g_deriv_layer_1[20]; // [rsp+390h] [rbp-368h] BYREF\n  double weights_layer0_1[40]; // [rsp+430h] [rbp-2C8h] BYREF\n  double delta_weights_layer0_1[49]; // [rsp+570h] [rbp-188h] BYREF\n\n  v5 = weights_layer0_1;\n  v6 = weights_layer0_1;\n  *(_QWORD *)&delta_weights_layer0_1[41] = __readfsqword(0x28u);\n  v7 = eta + 1.0;\n  do\n    *v6++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n  while ( v6 != delta_weights_layer0_1 );\n  v8 = weights_layer1_2;\n  v9 = weights_layer1_2;\n  do\n    *v9++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n  while ( v9 != delta_weights_layer1_2 );\n  memset(delta_weights_layer0_1, 0, 0x140uLL);\n  memset(delta_weights_layer1_2, 0, sizeof(delta_weights_layer1_2));\n  for ( i = 0LL; i != 20; ++i )\n  {\n    input[i] = (double)(int)i * 0.157 + 0.0;\n    output[i] = libmin_sin(v7);\n  }\n  v11 = a1;\n  v12 = delta_weights_layer1_2;\n  if ( v7 > eta )\n  {\n    iteration_count = 0;\n    v13 = g_deriv_layer_1;\n    do\n    {\n      v43 = 0LL;\n      v14 = v12;\n      v15 = v5;\n      v16 = v13;\n      total_error = 0.0;\n      v17 = v8;\n      v18 = v14;\n      do\n      {\n        v19 = 0LL;\n        NN_outputa = 0.0;\n        v45 = v11;\n        v40 = input[v43];\n        do\n        {\n          x = -(v40 * v15[v19 / 4] + error_threshold * v15[v19 / 4 + 1]);\n          v20 = libmin_exp(x);\n          g_layer_1[v19 / 8] = 1.0 / (v20 + 1.0);\n          v41 = 1.0 / (v20 + 1.0);\n          v21 = libmin_exp(x);\n          v22 = v41 * v17[v19 / 8] + NN_outputa;\n          NN_outputa = v22;\n          v16[v19 / 8] = (1.0 - 1.0 / (v21 + 1.0)) * (1.0 / (v21 + 1.0));\n          v19 += 8LL;\n        }\n        while ( v19 != 160 );\n        v23 = v15;\n        v11 = v45;\n        v24 = v22 - output[v43];\n        v25 = delta_weights_layer0_1;\n        v26 = 0LL;\n        total_error = v24 * v24 + total_error;\n        do\n        {\n          v27 = v17[v26];\n          v23 += 2;\n          v25 += 2;\n          v28 = v16[v26] * v27 * v24;\n          v29 = g_layer_1[v26] * v24 * v45 + v18[v26] * bias;\n          v18[v26] = v29;\n          v17[v26++] = v27 - v29;\n          v30 = v40 * v28 * v45 + *(v25 - 2) * bias;\n          v31 = *(v23 - 2);\n          *(v25 - 2) = v30;\n          v32 = v31 - v30;\n          v33 = *(v25 - 1) * bias;\n          *(v23 - 2) = v32;\n          v34 = v28 * error_threshold * v45 + v33;\n          v35 = *(v23 - 1) - v34;\n          *(v25 - 1) = v34;\n          *(v23 - 1) = v35;\n        }\n        while ( v26 != 20 );\n        ++v43;\n      }\n      while ( v43 != 20 );\n      v36 = v18;\n      v8 = v17;\n      v13 = v16;\n      v12 = v36;\n      ++iteration_count;\n      memset(delta_weights_layer0_1, 0, 0x140uLL);\n      v5 = v15;\n      memset(v36, 0, 0xA0uLL);\n      libmin_printf(\"iteration %d Total error %f\\n\", iteration_count, total_error);\n      if ( total_error <= eta )\n        break;\n      v11 = v45;\n    }\n    while ( iteration_count != 10 );\n  }\n  return 0LL;\n}\n"}, "pseudo_normalize": "long long train(double a1, double eta, double error_threshold, double bias,\n                double alpha) {\n  double *v5;\n  double *v6;\n  double v7;\n  double *v8;\n  double *v9;\n  long long i;\n  double v11;\n  double *v12;\n  double *v13;\n  double *v14;\n  double *v15;\n  double *v16;\n  double *v17;\n  double *v18;\n  unsigned long long v19;\n  double v20;\n  double v21;\n  double v22;\n  double *v23;\n  double v24;\n  double *v25;\n  long long v26;\n  double v27;\n  double v28;\n  double v29;\n  double v30;\n  double v31;\n  double v32;\n  double v33;\n  double v34;\n  double v35;\n  double *v36;\n  double NN_outputa;\n  double v40;\n  double v41;\n  double x;\n  long long v43;\n  double total_error;\n  double v45;\n  unsigned int iteration_count;\n  double input[20];\n  double output[20];\n  double weights_layer1_2[20];\n  double delta_weights_layer1_2[20];\n  double g_layer_1[20];\n  double g_deriv_layer_1[20];\n  double weights_layer0_1[40];\n  double delta_weights_layer0_1[49];\n  v5 = weights_layer0_1;\n  v6 = weights_layer0_1;\n  *(uint64_t *)&delta_weights_layer0_1[41] = __readfsqword(40u);\n  v7 = eta + 1.0;\n  do *v6++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n  while (v6 != delta_weights_layer0_1);\n  v8 = weights_layer1_2;\n  v9 = weights_layer1_2;\n  do *v9++ = (double)(int)libmin_rand() / 2147483647.0 - 0.5;\n  while (v9 != delta_weights_layer1_2);\n  memset(delta_weights_layer0_1, 0, 320uLL);\n  memset(delta_weights_layer1_2, 0, sizeof(delta_weights_layer1_2));\n  for (i = 0LL; i != 20; ++i) {\n    input[i] = (double)(int)i * 0.157 + 0.0;\n    output[i] = libmin_sin(v7);\n  }\n  v11 = a1;\n  v12 = delta_weights_layer1_2;\n  if (v7 > eta) {\n    iteration_count = 0;\n    v13 = g_deriv_layer_1;\n    do {\n      v43 = 0LL;\n      v14 = v12;\n      v15 = v5;\n      v16 = v13;\n      total_error = 0.0;\n      v17 = v8;\n      v18 = v14;\n      do {\n        v19 = 0LL;\n        NN_outputa = 0.0;\n        v45 = v11;\n        v40 = input[v43];\n        do {\n          x = -(v40 * v15[v19 / 4] + error_threshold * v15[v19 / 4 + 1]);\n          v20 = libmin_exp(x);\n          g_layer_1[v19 / 8] = 1.0 / (v20 + 1.0);\n          v41 = 1.0 / (v20 + 1.0);\n          v21 = libmin_exp(x);\n          v22 = v41 * v17[v19 / 8] + NN_outputa;\n          NN_outputa = v22;\n          v16[v19 / 8] = (1.0 - 1.0 / (v21 + 1.0)) * (1.0 / (v21 + 1.0));\n          v19 += 8LL;\n        } while (v19 != 160);\n        v23 = v15;\n        v11 = v45;\n        v24 = v22 - output[v43];\n        v25 = delta_weights_layer0_1;\n        v26 = 0LL;\n        total_error = v24 * v24 + total_error;\n        do {\n          v27 = v17[v26];\n          v23 += 2;\n          v25 += 2;\n          v28 = v16[v26] * v27 * v24;\n          v29 = g_layer_1[v26] * v24 * v45 + v18[v26] * bias;\n          v18[v26] = v29;\n          v17[v26++] = v27 - v29;\n          v30 = v40 * v28 * v45 + *(v25 - 2) * bias;\n          v31 = *(v23 - 2);\n          *(v25 - 2) = v30;\n          v32 = v31 - v30;\n          v33 = *(v25 - 1) * bias;\n          *(v23 - 2) = v32;\n          v34 = v28 * error_threshold * v45 + v33;\n          v35 = *(v23 - 1) - v34;\n          *(v25 - 1) = v34;\n          *(v23 - 1) = v35;\n        } while (v26 != 20);\n        ++v43;\n      } while (v43 != 20);\n      v36 = v18;\n      v8 = v17;\n      v13 = v16;\n      v12 = v36;\n      ++iteration_count;\n      memset(delta_weights_layer0_1, 0, 320uLL);\n      v5 = v15;\n      memset(v36, 0, 160uLL);\n      libmin_printf(\"iteration %d Total error %f\\n\", iteration_count,\n                    total_error);\n      if (total_error <= eta) break;\n      v11 = v45;\n    } while (iteration_count != 10);\n  }\n  return 0LL;\n}", "binary": "tiny-NN/tiny-NN.host.O2", "assembly": "<train>:\nendbr64\npush   %r15\npush   %r14\nmovq   %xmm3,%r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x6c8,%rsp\nmovsd  %xmm2,0x10(%rsp)\nmovsd  0x3c38(%rip),%xmm2\nlea    0x570(%rsp),%r12\nlea    0x430(%rsp),%r15\nmovsd  %xmm1,0x68(%rsp)\nmov    %r15,%rbx\nmov    %fs:0x28,%rax\nmov    %rax,0x6b8(%rsp)\nxor    %eax,%eax\naddsd  %xmm2,%xmm1\nmov    %r12,0x50(%rsp)\nmovsd  %xmm0,(%rsp)\nmovq   %xmm1,%rbp\ncall   31d0 <libmin_rand>\npxor   %xmm0,%xmm0\nadd    $0x8,%rbx\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x3be5(%rip),%xmm0\nsubsd  0x3be5(%rip),%xmm0\nmovsd  %xmm0,-0x8(%rbx)\ncmp    %r12,%rbx\njne    1447 <train+0x67>\nmovq   %r14,%xmm3\nlea    0x1b0(%rsp),%r14\nlea    0x250(%rsp),%rbx\nmov    %r14,%r12\nmovq   %xmm3,%r13\ncall   31d0 <libmin_rand>\npxor   %xmm0,%xmm0\nadd    $0x8,%r12\nmov    %eax,%eax\ncvtsi2sd %rax,%xmm0\ndivsd  0x3b9a(%rip),%xmm0\nsubsd  0x3b9a(%rip),%xmm0\nmovsd  %xmm0,-0x8(%r12)\ncmp    %rbx,%r12\njne    1492 <train+0xb2>\nmov    0x50(%rsp),%rdi\nxor    %eax,%eax\nmov    $0x28,%ecx\nxor    %r12d,%r12d\nrep stos %rax,%es:(%rdi)\nmov    %rbx,%rdi\nmov    $0x14,%ecx\nrep stos %rax,%es:(%rdi)\nlea    0x70(%rsp),%rax\nmov    %rax,0x48(%rsp)\nlea    0x110(%rsp),%rax\nmov    %rax,0x58(%rsp)\nmov    %rbx,%rax\nmov    %r12,%rbx\nmov    %rax,%r12\npxor   %xmm0,%xmm0\npxor   %xmm4,%xmm4\nmov    0x48(%rsp),%rax\ncvtsi2sd %ebx,%xmm0\nmulsd  0x3b40(%rip),%xmm0\naddsd  %xmm4,%xmm0\nmovsd  %xmm0,(%rax,%rbx,8)\ncall   3700 <libmin_sin>\nmov    0x58(%rsp),%rax\nmovsd  %xmm0,(%rax,%rbx,8)\nadd    $0x1,%rbx\ncmp    $0x14,%rbx\njne    14ff <train+0x11f>\nmovq   %rbp,%xmm6\nmovsd  (%rsp),%xmm4\nmovq   %r13,%xmm3\nmov    %r12,%rbx\ncomisd 0x68(%rsp),%xmm6\njbe    1809 <train+0x429>\nmovl   $0x0,0x64(%rsp)\nlea    0x2f0(%rsp),%r12\nlea    0x390(%rsp),%rbp\nmovq   $0x0,0x28(%rsp)\nmov    %rbx,%rax\nmov    %r15,%r13\nmov    %rbp,%rbx\nmovq   $0x0,0x30(%rsp)\nmov    %r14,%rbp\nmov    %rax,%r14\nnopl   0x0(%rax)\nmov    0x48(%rsp),%rax\nmov    0x28(%rsp),%rdi\nxor    %r15d,%r15d\nmovq   $0x0,(%rsp)\nmovsd  %xmm4,0x38(%rsp)\nmovsd  (%rax,%rdi,1),%xmm6\nmovsd  %xmm3,0x40(%rsp)\nmovsd  %xmm6,0x8(%rsp)\nnopl   0x0(%rax)\nmovsd  0x8(%rsp),%xmm1\nmovsd  0x10(%rsp),%xmm0\nmulsd  0x0(%r13,%r15,2),%xmm1\nmulsd  0x8(%r13,%r15,2),%xmm0\naddsd  %xmm0,%xmm1\nxorpd  0x3a42(%rip),%xmm1\nmovapd %xmm1,%xmm0\nmovsd  %xmm1,0x20(%rsp)\ncall   1a20 <libmin_exp>\nmov    0x3a3c(%rip),%rax\nmovsd  0x20(%rsp),%xmm1\nmovq   %rax,%xmm2\nmovq   %rax,%xmm5\naddsd  %xmm2,%xmm0\ndivsd  %xmm0,%xmm5\nmovapd %xmm1,%xmm0\nmovsd  %xmm5,(%r12,%r15,1)\nmovsd  %xmm5,0x18(%rsp)\ncall   1a20 <libmin_exp>\nmov    0x3a08(%rip),%rax\nmovsd  0x18(%rsp),%xmm5\nmulsd  0x0(%rbp,%r15,1),%xmm5\nmovq   %rax,%xmm2\nmovq   %rax,%xmm1\naddsd  (%rsp),%xmm5\naddsd  %xmm2,%xmm0\nmovsd  %xmm5,(%rsp)\ndivsd  %xmm0,%xmm1\nmovq   %rax,%xmm0\nsubsd  %xmm1,%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,(%rbx,%r15,1)\nadd    $0x8,%r15\ncmp    $0xa0,%r15\njne    15c8 <train+0x1e8>\nmov    0x58(%rsp),%rax\nmov    0x28(%rsp),%rsi\nmovapd %xmm5,%xmm6\nmov    %r13,%rdx\nmovsd  0x38(%rsp),%xmm4\nmovsd  0x40(%rsp),%xmm3\nsubsd  (%rax,%rsi,1),%xmm6\nmov    0x50(%rsp),%rcx\nxor    %eax,%eax\nmovapd %xmm6,%xmm0\nmulsd  %xmm6,%xmm0\naddsd  0x30(%rsp),%xmm0\nmovsd  %xmm0,0x30(%rsp)\nnopw   0x0(%rax,%rax,1)\nmovsd  (%r12,%rax,1),%xmm1\nmovsd  0x0(%rbp,%rax,1),%xmm5\nadd    $0x10,%rdx\nadd    $0x10,%rcx\nmovsd  (%r14,%rax,1),%xmm7\nmovsd  (%rbx,%rax,1),%xmm0\nmulsd  %xmm6,%xmm1\nmulsd  %xmm5,%xmm0\nmulsd  %xmm3,%xmm7\nmulsd  %xmm4,%xmm1\nmulsd  %xmm6,%xmm0\naddsd  %xmm7,%xmm1\nsubsd  %xmm1,%xmm5\nmovsd  %xmm1,(%r14,%rax,1)\nmovsd  0x8(%rsp),%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  %xmm5,0x0(%rbp,%rax,1)\nmovsd  -0x10(%rcx),%xmm5\nmulsd  0x10(%rsp),%xmm0\nadd    $0x8,%rax\nmulsd  %xmm3,%xmm5\nmulsd  %xmm4,%xmm1\nmulsd  %xmm4,%xmm0\naddsd  %xmm5,%xmm1\nmovsd  -0x10(%rdx),%xmm5\nmovsd  %xmm1,-0x10(%rcx)\nsubsd  %xmm1,%xmm5\nmovsd  -0x8(%rcx),%xmm1\nmulsd  %xmm3,%xmm1\nmovsd  %xmm5,-0x10(%rdx)\naddsd  %xmm1,%xmm0\nmovsd  -0x8(%rdx),%xmm1\nsubsd  %xmm0,%xmm1\nmovsd  %xmm0,-0x8(%rcx)\nmovsd  %xmm1,-0x8(%rdx)\ncmp    $0xa0,%rax\njne    16c8 <train+0x2e8>\naddq   $0x8,0x28(%rsp)\nmov    0x28(%rsp),%rax\ncmp    $0xa0,%rax\njne    1598 <train+0x1b8>\nmov    %r14,%rax\nmov    0x50(%rsp),%rdi\nmov    %rbp,%r14\nmov    $0x28,%ecx\nmov    %rbx,%rbp\nmov    %rax,%rbx\nxor    %eax,%eax\naddl   $0x1,0x64(%rsp)\nrep stos %rax,%es:(%rdi)\nmov    $0x14,%ecx\nmov    %rbx,%rdi\nmov    %r13,%r15\nrep stos %rax,%es:(%rdi)\nmov    0x64(%rsp),%r13d\nmov    $0x1,%eax\nmovsd  0x30(%rsp),%xmm0\nlea    0x3831(%rip),%rdi\nmovsd  %xmm4,0x8(%rsp)\nmov    %r13d,%esi\nmovsd  %xmm3,(%rsp)\ncall   2f60 <libmin_printf>\nmovsd  0x30(%rsp),%xmm4\ncomisd 0x68(%rsp),%xmm4\njbe    1809 <train+0x429>\ncmp    $0xa,%r13d\nmovsd  (%rsp),%xmm3\nmovsd  0x8(%rsp),%xmm4\njne    1570 <train+0x190>\nmov    0x6b8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1830 <train+0x450>\nadd    $0x6c8,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "addEdge", "content": " \n  \n// Function to add an edge to the graph \nvoid\naddEdge(struct Graph* graph, int v, int w) \n{ \n  struct List* newNode = createListNode(w); \n  newNode->next = graph->adj[v].next; \n  graph->adj[v].next = newNode; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O2.pseudo", "function_name": "addEdge", "address": "0x1370", "label": "addEdge", "content": "void __fastcall addEdge(Graph *graph, int v, int w)\n{\n  List *v4; // rax\n  List *v5; // rsi\n  List *next; // rdx\n\n  v4 = (List *)libmin_malloc(0x10uLL);\n  v5 = &graph->adj[v];\n  v4->next = 0LL;\n  next = v5->next;\n  v4->data = w;\n  v4->next = next;\n  v5->next = v4;\n}\n"}, "pseudo_normalize": "void addEdge(Graph *graph, int v, int w) {\n  List *v4;\n  List *v5;\n  List *next;\n  v4 = (List *)libmin_malloc(16uLL);\n  v5 = &graph->adj[v];\n  v4->next = 0LL;\n  next = v5->next;\n  v4->data = w;\n  v4->next = next;\n  v5->next = v4;\n}", "binary": "topo-sort/topo-sort.host.O2", "assembly": "<addEdge>:\nendbr64\npush   %r12\nmov    %edx,%r12d\npush   %rbp\nmov    %rdi,%rbp\nmov    $0x10,%edi\npush   %rbx\nmov    %esi,%ebx\ncall   17d0 <libmin_malloc>\nmovslq %ebx,%rsi\nshl    $0x4,%rsi\nadd    0x8(%rbp),%rsi\nmovq   $0x0,0x8(%rax)\nmov    0x8(%rsi),%rdx\nmov    %r12d,(%rax)\nmov    %rdx,0x8(%rax)\nmov    %rax,0x8(%rsi)\npop    %rbx\npop    %rbp\npop    %r12\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax)\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "createGraph", "content": " \n  \n// Function to initialize a graph with V vertices \nstruct Graph *\ncreateGraph(int V) \n{ \n  struct Graph* graph = (struct Graph*)libmin_malloc(sizeof(struct Graph)); \n  graph->V = V; \n  graph->adj = (struct List*)libmin_malloc(V * sizeof(struct List)); \n  for (int i = 0; i < V; ++i)\n    graph->adj[i].next = NULL; \n  return graph; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O2.pseudo", "function_name": "createGraph", "address": "0x1300", "label": "createGraph", "content": "Graph *__fastcall createGraph(int V)\n{\n  Graph *v1; // rax\n  Graph *v2; // r12\n  List *v3; // rax\n  List **p_next; // rdx\n  __int64 v5; // rax\n\n  v1 = (Graph *)libmin_malloc(0x10uLL);\n  v1->V = V;\n  v2 = v1;\n  v3 = (List *)libmin_malloc(16LL * V);\n  v2->adj = v3;\n  if ( V > 0 )\n  {\n    p_next = &v3->next;\n    v5 = (__int64)&v3[(unsigned int)(V - 1) + 1].next;\n    do\n    {\n      *p_next = 0LL;\n      p_next += 2;\n    }\n    while ( p_next != (List **)v5 );\n  }\n  return v2;\n}\n"}, "pseudo_normalize": "Graph *createGraph(int V) {\n  Graph *v1;\n  Graph *v2;\n  List *v3;\n  List **p_next;\n  long long v5;\n  v1 = (Graph *)libmin_malloc(16uLL);\n  v1->V = V;\n  v2 = v1;\n  v3 = (List *)libmin_malloc(16LL * V);\n  v2->adj = v3;\n  if (V > 0) {\n    p_next = &v3->next;\n    v5 = (long long)&v3[(unsigned int)(V - 1) + 1].next;\n    do {\n      *p_next = 0LL;\n      p_next += 2;\n    } while (p_next != (List **)v5);\n  }\n  return v2;\n}", "binary": "topo-sort/topo-sort.host.O2", "assembly": "<createGraph>:\nendbr64\npush   %r12\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\nsub    $0x8,%rsp\ncall   17d0 <libmin_malloc>\nmovslq %ebx,%rdi\nmov    %ebx,(%rax)\nshl    $0x4,%rdi\nmov    %rax,%r12\ncall   17d0 <libmin_malloc>\nmov    %rax,0x8(%r12)\ntest   %ebx,%ebx\njle    1358 <createGraph+0x58>\nlea    -0x1(%rbx),%ecx\nlea    0x8(%rax),%rdx\nshl    $0x4,%rcx\nlea    0x18(%rax,%rcx,1),%rax\nnopl   0x0(%rax)\nmovq   $0x0,(%rdx)\nadd    $0x10,%rdx\ncmp    %rax,%rdx\njne    1348 <createGraph+0x48>\nadd    $0x8,%rsp\nmov    %r12,%rax\npop    %rbx\npop    %r12\nret\ndata16 cs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "createListNode", "content": " \n  \n// Create a new node for the adjacency list \nstruct List *\ncreateListNode(int data) \n{ \n  struct List* newNode = (struct List*)libmin_malloc(sizeof(struct List)); \n  newNode->data = data; \n  newNode->next = NULL; \n  return newNode; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O2.pseudo", "function_name": "createListNode", "address": "0x12e0", "label": "createListNode", "content": "List *__fastcall createListNode(int data)\n{\n  List *result; // rax\n\n  result = (List *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "List *createListNode(int data) {\n  List *result;\n  result = (List *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}", "binary": "topo-sort/topo-sort.host.O2", "assembly": "<createListNode>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\ncall   17d0 <libmin_malloc>\nmov    %ebx,(%rax)\nmovq   $0x0,0x8(%rax)\npop    %rbx\nret\nnopl   (%rax)\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "createStackNode", "content": " \n  \n// Create a new node for the stack \nstruct Stack *\ncreateStackNode(int data) \n{ \n  struct Stack* newNode = (struct Stack*)libmin_malloc(sizeof(struct Stack)); \n  newNode->data = data; \n  newNode->next = NULL; \n  return newNode; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O2.pseudo", "function_name": "createStackNode", "address": "0x12c0", "label": "createStackNode", "content": "Stack *__fastcall createStackNode(int data)\n{\n  Stack *result; // rax\n\n  result = (Stack *)libmin_malloc(0x10uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}\n"}, "pseudo_normalize": "Stack *createStackNode(int data) {\n  Stack *result;\n  result = (Stack *)libmin_malloc(16uLL);\n  result->data = data;\n  result->next = 0LL;\n  return result;\n}", "binary": "topo-sort/topo-sort.host.O2", "assembly": "<createStackNode>:\nendbr64\npush   %rbx\nmov    %edi,%ebx\nmov    $0x10,%edi\ncall   17d0 <libmin_malloc>\nmov    %ebx,(%rax)\nmovq   $0x0,0x8(%rax)\npop    %rbx\nret\nnopl   (%rax)\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "main", "content": " \n  \n// Driver program to test above functions \nint\nmain(void) \n{ \n  // Create a graph given in the above diagram \n  struct Graph* g = createGraph(6); \n  addEdge(g, 5, 2); \n  addEdge(g, 5, 0); \n  addEdge(g, 4, 0); \n  addEdge(g, 4, 1); \n  addEdge(g, 2, 3); \n  addEdge(g, 3, 1); \n  \n  libmin_printf(\"Topological Sorting Order: \"); \n  topologicalSort(g); \n  libmin_printf(\"\\n\");\n  \n  libmin_success();\n  return 0; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  Graph *Graph; // rbp\n\n  Graph = createGraph(6);\n  addEdge(Graph, 5, 2);\n  addEdge(Graph, 5, 0);\n  addEdge(Graph, 4, 0);\n  addEdge(Graph, 4, 1);\n  addEdge(Graph, 2, 3);\n  addEdge(Graph, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(Graph);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  Graph *Graph;\n  Graph = createGraph(6);\n  addEdge(Graph, 5, 2);\n  addEdge(Graph, 5, 0);\n  addEdge(Graph, 4, 0);\n  addEdge(Graph, 4, 1);\n  addEdge(Graph, 2, 3);\n  addEdge(Graph, 3, 1);\n  libmin_printf(\"Topological Sorting Order: \");\n  topologicalSort(Graph);\n  libmin_printf(\"\\n\");\n  libmin_success();\n}", "binary": "topo-sort/topo-sort.host.O2", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    $0x6,%edi\ncall   1300 <createGraph>\nmov    $0x2,%edx\nmov    $0x5,%esi\nmov    %rax,%rbp\nmov    %rax,%rdi\ncall   1370 <addEdge>\nmov    %rbp,%rdi\nxor    %edx,%edx\nmov    $0x5,%esi\ncall   1370 <addEdge>\nmov    %rbp,%rdi\nxor    %edx,%edx\nmov    $0x4,%esi\ncall   1370 <addEdge>\nmov    %rbp,%rdi\nmov    $0x1,%edx\nmov    $0x4,%esi\ncall   1370 <addEdge>\nmov    %rbp,%rdi\nmov    $0x3,%edx\nmov    $0x2,%esi\ncall   1370 <addEdge>\nmov    $0x1,%edx\nmov    $0x3,%esi\nmov    %rbp,%rdi\ncall   1370 <addEdge>\nlea    0x1e69(%rip),%rdi\nxor    %eax,%eax\ncall   2d70 <libmin_printf>\nmov    %rbp,%rdi\ncall   1450 <topologicalSort>\nlea    0x1e6f(%rip),%rdi\nxor    %eax,%eax\ncall   2d70 <libmin_printf>\ncall   2fb0 <libmin_success>\nxor    %eax,%eax\npop    %rbp\nret\ncs nopw 0x0(%rax,%rax,1)\nnop\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "topologicalSort", "content": " \n  \n// The function to do Topological Sort. It uses recursive \n// topologicalSortUtil \nvoid topologicalSort(struct Graph* graph) \n{ \n    struct Stack* stack = NULL; \n  \n    // Mark all the vertices as not visited \n    int* visited = (int*)libmin_malloc(graph->V * sizeof(int)); \n    for (int i = 0; i < graph->V; ++i) { \n        visited[i] = FALSE; \n    } \n  \n    // Call the recursive helper function to store \n    // Topological Sort starting from all vertices one by \n    // one \n    for (int i = 0; i < graph->V; ++i) { \n        if (!visited[i]) { \n            topologicalSortUtil(graph, i, visited, &stack); \n        } \n    } \n  \n    // Print contents of stack \n    while (stack != NULL) { \n        libmin_printf(\"%d \", stack->data); \n        struct Stack* temp = stack; \n        stack = stack->next; \n        libmin_free(temp); \n    } \n  \n    // Free allocated memory \n    libmin_free(visited); \n    libmin_free(graph->adj); \n    libmin_free(graph); \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O2.pseudo", "function_name": "topologicalSort", "address": "0x1450", "label": "topologicalSort", "content": "void __fastcall topologicalSort(Graph *graph)\n{\n  __int64 V; // rdi\n  int *v3; // r12\n  __int64 v4; // rax\n  __int64 v5; // rbx\n  int v6; // esi\n  Stack *i; // rax\n  Stack *v8; // rdi\n  Stack *stack[7]; // [rsp+0h] [rbp-38h] BYREF\n\n  V = graph->V;\n  stack[1] = (Stack *)__readfsqword(0x28u);\n  stack[0] = 0LL;\n  v3 = (int *)libmin_malloc(4 * V);\n  v4 = 0LL;\n  if ( graph->V > 0 )\n  {\n    do\n      v3[v4++] = 0;\n    while ( graph->V > (int)v4 );\n    if ( graph->V > 0 )\n    {\n      v5 = 0LL;\n      do\n      {\n        while ( 1 )\n        {\n          v6 = v5;\n          if ( !v3[v5] )\n            break;\n          if ( graph->V <= (int)++v5 )\n            goto LABEL_8;\n        }\n        ++v5;\n        topologicalSortUtil(graph, v6, v3, stack);\n      }\n      while ( graph->V > (int)v5 );\n    }\n  }\nLABEL_8:\n  for ( i = stack[0]; stack[0]; i = stack[0] )\n  {\n    libmin_printf(\"%d \", i->data);\n    v8 = stack[0];\n    stack[0] = stack[0]->next;\n    libmin_free(v8);\n  }\n  libmin_free(v3);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}\n"}, "pseudo_normalize": "void topologicalSort(Graph *graph) {\n  long long V;\n  int *v3;\n  long long v4;\n  long long v5;\n  int v6;\n  Stack *i;\n  Stack *v8;\n  Stack *stack[7];\n  V = graph->V;\n  stack[1] = (Stack *)__readfsqword(40u);\n  stack[0] = 0LL;\n  v3 = (int *)libmin_malloc(4 * V);\n  v4 = 0LL;\n  if (graph->V > 0) {\n    do v3[v4++] = 0;\n    while (graph->V > (int)v4);\n    if (graph->V > 0) {\n      v5 = 0LL;\n      do {\n        while (1) {\n          v6 = v5;\n          if (!v3[v5]) break;\n          if (graph->V <= (int)++v5) goto LABEL_8;\n        }\n        ++v5;\n        topologicalSortUtil(graph, v6, v3, stack);\n      } while (graph->V > (int)v5);\n    }\n  }\nLABEL_8:\n  for (i = stack[0]; stack[0]; i = stack[0]) {\n    libmin_printf(\"%d \", i->data);\n    v8 = stack[0];\n    stack[0] = stack[0]->next;\n    libmin_free(v8);\n  }\n  libmin_free(v3);\n  libmin_free(graph->adj);\n  libmin_free(graph);\n}", "binary": "topo-sort/topo-sort.host.O2", "assembly": "<topologicalSort>:\nendbr64\npush   %r13\npush   %r12\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nsub    $0x18,%rsp\nmovslq (%rdi),%rdi\nmov    %fs:0x28,%rax\nmov    %rax,0x8(%rsp)\nxor    %eax,%eax\nmovq   $0x0,(%rsp)\nshl    $0x2,%rdi\ncall   17d0 <libmin_malloc>\nmov    0x0(%rbp),%edx\nmov    %rax,%r12\nxor    %eax,%eax\ntest   %edx,%edx\njle    14ea <topologicalSort+0x9a>\nnopl   0x0(%rax)\nmovl   $0x0,(%r12,%rax,4)\nmov    0x0(%rbp),%edx\nadd    $0x1,%rax\ncmp    %eax,%edx\njg     1498 <topologicalSort+0x48>\ntest   %edx,%edx\njle    14ea <topologicalSort+0x9a>\nxor    %ebx,%ebx\nmov    %rsp,%r13\njmp    14c9 <topologicalSort+0x79>\ncs nopw 0x0(%rax,%rax,1)\nadd    $0x1,%rbx\ncmp    %ebx,0x0(%rbp)\njle    14ea <topologicalSort+0x9a>\nmov    (%r12,%rbx,4),%eax\nmov    %ebx,%esi\ntest   %eax,%eax\njne    14c0 <topologicalSort+0x70>\nmov    %r13,%rcx\nmov    %r12,%rdx\nmov    %rbp,%rdi\nadd    $0x1,%rbx\ncall   13c0 <topologicalSortUtil>\ncmp    %ebx,0x0(%rbp)\njg     14c9 <topologicalSort+0x79>\nmov    (%rsp),%rax\nlea    0x1b0f(%rip),%rbx\ntest   %rax,%rax\nje     1526 <topologicalSort+0xd6>\nnopw   0x0(%rax,%rax,1)\nmov    (%rax),%esi\nmov    %rbx,%rdi\nxor    %eax,%eax\ncall   2d70 <libmin_printf>\nmov    (%rsp),%rdi\nmov    0x8(%rdi),%rax\nmov    %rax,(%rsp)\ncall   1880 <libmin_free>\nmov    (%rsp),%rax\ntest   %rax,%rax\njne    1500 <topologicalSort+0xb0>\nmov    %r12,%rdi\ncall   1880 <libmin_free>\nmov    0x8(%rbp),%rdi\ncall   1880 <libmin_free>\nmov    %rbp,%rdi\ncall   1880 <libmin_free>\nmov    0x8(%rsp),%rax\nsub    %fs:0x28,%rax\njne    155a <topologicalSort+0x10a>\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\ncall   10c0 <__stack_chk_fail@plt>\nnop\n"}
{"source": {"path": "topo-sort/topo-sort.c", "function_name": "topologicalSortUtil", "content": " \n  \n// A recursive function used by topologicalSort \nvoid\ntopologicalSortUtil(struct Graph* graph, int v, int visited[], struct Stack** stack) \n{ \n  visited[v] = TRUE; \n  \n  struct List* current = graph->adj[v].next; \n  while (current != NULL)\n  { \n    int adjacentVertex = current->data; \n    if (!visited[adjacentVertex]) \n      topologicalSortUtil(graph, adjacentVertex, visited, stack); \n    current = current->next; \n  } \n  \n  // Push the current vertex to stack which stores the \n  // result \n  struct Stack* newNode = createStackNode(v); \n  newNode->next = *stack; \n  *stack = newNode; \n}\n"}, "pseudo": {"path": "topo-sort/topo-sort.host.O2.pseudo", "function_name": "topologicalSortUtil", "address": "0x13c0", "label": "topologicalSortUtil", "content": "void __fastcall topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack)\n{\n  List *i; // rbx\n  __int64 data; // rsi\n  Stack *v9; // rax\n  Stack *v10; // rdx\n\n  visited[v] = 1;\n  for ( i = graph->adj[v].next; i; i = i->next )\n  {\n    data = i->data;\n    if ( !visited[data] )\n      topologicalSortUtil(graph, data, visited, stack);\n  }\n  v9 = (Stack *)libmin_malloc(0x10uLL);\n  v9->next = 0LL;\n  v10 = *stack;\n  v9->data = v;\n  v9->next = v10;\n  *stack = v9;\n}\n"}, "pseudo_normalize": "void topologicalSortUtil(Graph *graph, int v, int *visited, Stack **stack) {\n  List *i;\n  long long data;\n  Stack *v9;\n  Stack *v10;\n  visited[v] = 1;\n  for (i = graph->adj[v].next; i; i = i->next) {\n    data = i->data;\n    if (!visited[data]) topologicalSortUtil(graph, data, visited, stack);\n  }\n  v9 = (Stack *)libmin_malloc(16uLL);\n  v9->next = 0LL;\n  v10 = *stack;\n  v9->data = v;\n  v9->next = v10;\n  *stack = v9;\n}", "binary": "topo-sort/topo-sort.host.O2", "assembly": "<topologicalSortUtil>:\nendbr64\nmovslq %esi,%rax\npush   %r14\npush   %r13\nmov    %rcx,%r13\npush   %r12\nmov    %rax,%r12\npush   %rbp\npush   %rbx\nmovl   $0x1,(%rdx,%rax,4)\nshl    $0x4,%rax\nadd    0x8(%rdi),%rax\nmov    0x8(%rax),%rbx\ntest   %rbx,%rbx\nje     140a <topologicalSortUtil+0x4a>\nmov    %rdi,%r14\nmov    %rdx,%rbp\nmovslq (%rbx),%rax\nmov    %rax,%rsi\nmov    0x0(%rbp,%rax,4),%eax\ntest   %eax,%eax\nje     1438 <topologicalSortUtil+0x78>\nmov    0x8(%rbx),%rbx\ntest   %rbx,%rbx\njne    13f3 <topologicalSortUtil+0x33>\nmov    $0x10,%edi\ncall   17d0 <libmin_malloc>\nmovq   $0x0,0x8(%rax)\nmov    0x0(%r13),%rdx\nmov    %r12d,(%rax)\nmov    %rdx,0x8(%rax)\npop    %rbx\nmov    %rax,0x0(%r13)\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nnopl   0x0(%rax)\nmov    %r13,%rcx\nmov    %rbp,%rdx\nmov    %r14,%rdi\ncall   13c0 <topologicalSortUtil>\njmp    1401 <topologicalSortUtil+0x41>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "totient/totient.c", "function_name": "main", "content": "int\nmain(void)\n{\n\tint argc=1; char **argv=NULL;\n\tint n;\n\tint j=0;\n\n\t/* Process command line */\n\twhile(++j < argc){\n\t\tif(argv[j][0] == '-')\n\t\t\tswitch(argv[j][1]){ \n\t\t\t\tcase '-':\n\t\t\t\t\t++j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\tcase 'V':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",VERSION);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tcase '?':\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'H':\n\t\t\t\t\tlibmin_printf(\"%s\\n\",HELP);\n\t\t\t\t\tlibmin_success();\n\t\t\t\tdefault:\n\t\t\t\t\tlibmin_printf(\"totient: unkown option %s\\n\", argv[j]);\n\t\t\t\t\tlibmin_printf(\"%s\\n\",USAGE);\n\t\t\t\t\tlibmin_fail(1);\n\t\t\t}\n\t\tbreak;\n\t}\n\n\tif(j >= argc){\n\t\t//fprintf(stderr,\"totient: usage error.\\n\");\n\t\t//fprintf(stderr,\"%s\\n\",USAGE);\n\t\tn = 45457;\n\t}\n\telse\n\t  n = libmin_atoi(argv[j++]);\n\n\tif(n == 0){\n\t\tlibmin_printf(\"totient: not defined for n = 0.\\n\");\n\t\treturn 1;\n\t}\n\n\tlibmin_printf(\"phi(%d) = %d\\n\",n,phi(n));\n\n  libmin_success();\n\treturn 0;\n}\n"}, "pseudo": {"path": "totient/totient.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  v3 = phi(45457);\n  libmin_printf(\"phi(%d) = %d\\n\", 45457, v3);\n  libmin_success();\n}", "binary": "totient/totient.host.O2", "assembly": "<main>:\nendbr64\nsub    $0x8,%rsp\nmov    $0xb191,%edi\nmov    $0xb191,%esi\ncall   1230 <phi>\nlea    0x1ee6(%rip),%rdi\nmov    %eax,%edx\nxor    %eax,%eax\ncall   2850 <libmin_printf>\ncall   2a90 <libmin_success>\nxor    %eax,%eax\nadd    $0x8,%rsp\nret\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "totient/totient.c", "function_name": "phi", "content": "static int phi(int n)\n{\n\tif(n<0)n=-n;\n\t/* handle a few trivial boundary cases */\n\tif(n<=1)return 0;\n\tif(n==2)return 1;\n\tif(n==3)return 2;\n\treturn phiphi(n,2);\n}\n"}, "pseudo": {"path": "totient/totient.host.O2.pseudo", "function_name": "phi", "address": "0x1230", "label": "phi", "content": "int __fastcall phi(int n)\n{\n  int v1; // ebx\n  int v2; // r12d\n  int v3; // r13d\n  int v4; // ecx\n  int v5; // eax\n  int v6; // ebp\n  int v7; // edi\n  int v9; // edx\n  int v10; // ecx\n  int v11; // eax\n\n  v1 = -n;\n  if ( n > 0 )\n    v1 = n;\n  v2 = 0;\n  if ( v1 > 1 )\n  {\n    v2 = 1;\n    if ( v1 != 2 )\n    {\n      v2 = 2;\n      v3 = 1;\n      if ( v1 != 3 )\n      {\n        while ( 1 )\n        {\n          v4 = 2;\n          do\n          {\n            v7 = v4++;\n            if ( v4 == v1 )\n              return v3 * v7;\n            v5 = v1 / v7;\n            v2 = v1 % v7;\n            v6 = v1 / v7;\n          }\n          while ( v1 % v7 );\n          v1 /= v7;\n          v9 = v5;\n          v10 = v7;\n          while ( v9 )\n          {\n            if ( v10 <= 0 )\n              v10 = -v10;\n            if ( v9 < v10 )\n            {\n              v11 = v10;\n              v10 = v9;\n              v9 = v11;\n            }\n            v9 %= v10;\n            if ( !v9 )\n            {\n              if ( v10 == 1 )\n              {\n                v3 *= phi(v7);\n                goto LABEL_20;\n              }\n              break;\n            }\n          }\n          v3 *= v7;\nLABEL_20:\n          if ( v6 <= 1 )\n            break;\n          if ( v6 == 2 )\n            return v3;\n          if ( v6 == 3 )\n            return 2 * v3;\n        }\n      }\n    }\n  }\n  return v2;\n}\n"}, "pseudo_normalize": "int phi(int n) {\n  int v1;\n  int v2;\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  int v7;\n  int v9;\n  int v10;\n  int v11;\n  v1 = -n;\n  if (n > 0) v1 = n;\n  v2 = 0;\n  if (v1 > 1) {\n    v2 = 1;\n    if (v1 != 2) {\n      v2 = 2;\n      v3 = 1;\n      if (v1 != 3) {\n        while (1) {\n          v4 = 2;\n          do {\n            v7 = v4++;\n            if (v4 == v1) return v3 * v7;\n            v5 = v1 / v7;\n            v2 = v1 % v7;\n            v6 = v1 / v7;\n          } while (v1 % v7);\n          v1 /= v7;\n          v9 = v5;\n          v10 = v7;\n          while (v9) {\n            if (v10 <= 0) v10 = -v10;\n            if (v9 < v10) {\n              v11 = v10;\n              v10 = v9;\n              v9 = v11;\n            }\n            v9 %= v10;\n            if (!v9) {\n              if (v10 == 1) {\n                v3 *= phi(v7);\n                goto LABEL_20;\n              }\n              break;\n            }\n          }\n          v3 *= v7;\n        LABEL_20:\n          if (v6 <= 1) break;\n          if (v6 == 2) return v3;\n          if (v6 == 3) return 2 * v3;\n        }\n      }\n    }\n  }\n  return v2;\n}", "binary": "totient/totient.host.O2", "assembly": "<phi>:\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nmov    %edi,%ebx\nsub    $0x8,%rsp\nneg    %ebx\ncmovs  %edi,%ebx\nxor    %r12d,%r12d\ncmp    $0x1,%ebx\njle    128e <phi+0x5e>\nmov    $0x1,%r12d\ncmp    $0x2,%ebx\nje     128e <phi+0x5e>\nmov    $0x2,%r12d\nmov    $0x1,%r13d\ncmp    $0x3,%ebx\nje     128e <phi+0x5e>\nmov    $0x2,%ecx\njmp    127e <phi+0x4e>\nnopl   0x0(%rax)\nmov    %ebx,%eax\ncltd\nidiv   %edi\nmov    %edx,%r12d\nmov    %eax,%ebp\ntest   %edx,%edx\nje     12a0 <phi+0x70>\nmov    %ecx,%edi\nadd    $0x1,%ecx\ncmp    %ebx,%ecx\njne    1270 <phi+0x40>\nimul   %r13d,%edi\nmov    %edi,%r12d\nadd    $0x8,%rsp\nmov    %r12d,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\nret\nnopl   0x0(%rax)\nmov    %eax,%ebx\nmov    %eax,%edx\nmov    %edi,%ecx\ncs nopw 0x0(%rax,%rax,1)\ntest   %ecx,%ecx\nje     1300 <phi+0xd0>\ntest   %edx,%edx\nje     1300 <phi+0xd0>\nmov    %ecx,%eax\nneg    %eax\ncmovns %eax,%ecx\ncmp    %ecx,%edx\njge    12c9 <phi+0x99>\nmov    %ecx,%eax\nmov    %edx,%ecx\nmov    %eax,%edx\nmov    %edx,%eax\ncltd\nidiv   %ecx\ntest   %edx,%edx\njne    12b0 <phi+0x80>\ncmp    $0x1,%ecx\njne    1300 <phi+0xd0>\ncall   1230 <phi>\nimul   %eax,%r13d\ncmp    $0x1,%ebp\njle    128e <phi+0x5e>\ncmp    $0x2,%ebp\nje     1306 <phi+0xd6>\ncmp    $0x3,%ebp\njne    1265 <phi+0x35>\nlea    0x0(%r13,%r13,1),%r12d\njmp    128e <phi+0x5e>\nnopw   0x0(%rax,%rax,1)\nimul   %edi,%r13d\njmp    12e0 <phi+0xb0>\nmov    %r13d,%r12d\njmp    128e <phi+0x5e>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "transcend/transcend.c", "function_name": "main", "content": "// --------------------------------- Main -------------------------------------\nint main(void) {\n  for (int f = 0; f < FN_COUNT; ++f) {\n    (void)run_fp64((fn_t)f);\n  }\n  libmin_success();\n}\n"}, "pseudo": {"path": "transcend/transcend.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double *v3; // r14\n  double *v4; // rax\n  double *v5; // r15\n  __int64 v6; // rcx\n  __int64 v7; // rdx\n  unsigned __int64 v8; // rsi\n  double v9; // xmm1_8\n  __int64 v10; // rax\n  double v11; // xmm0_8\n  double v12; // xmm0_8\n  unsigned __int64 v13; // rbp\n  __int64 v14; // rbx\n  __int64 v15; // rdx\n  double *v16; // rax\n  double v17; // xmm1_8\n  __int64 v18; // [rsp+0h] [rbp-58h]\n  __int64 v19; // [rsp+8h] [rbp-50h]\n  double x; // [rsp+18h] [rbp-40h]\n\n  v18 = 0LL;\nLABEL_2:\n  v3 = (double *)libmin_malloc(0x200uLL);\n  v4 = (double *)libmin_malloc(0x200uLL);\n  v5 = v4;\n  if ( !v3 || !v4 )\n  {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  v6 = 64LL;\n  v7 = 0LL;\n  v8 = 1LL;\n  v9 = 10.0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v8 ^= ((v8 ^ (v8 << 13)) >> 7) ^ (v8 << 13) ^ ((((v8 ^ (v8 << 13)) >> 7) ^ v8 ^ (v8 << 13)) << 17);\n      v10 = v7;\n      v11 = (double)(int)(v8 >> 11) * 1.110223024625157e-16;\n      if ( v18 != 3 )\n        break;\n      v3[v7] = v11 * 8.0 - 4.0;\nLABEL_6:\n      v7 = ((_BYTE)v7 + 1) & 0x3F;\n      if ( !--v6 )\n        goto LABEL_10;\n    }\n    if ( (_DWORD)v18 )\n    {\n      v3[v7] = v11 * 6.283185307179586 - 3.141592653589793;\n      goto LABEL_6;\n    }\n    v7 = ((_BYTE)v7 + 1) & 0x3F;\n    v3[v10] = v11 * 20.0 - 10.0;\n    if ( !--v6 )\n    {\nLABEL_10:\n      x = 0.0;\n      v19 = 10LL;\n      while ( 1 )\n      {\n        v13 = 0LL;\n        v14 = 0LL;\n        do\n        {\n          if ( v18 == 2 )\n          {\nLABEL_20:\n            v12 = libmin_cos(v9);\n            goto LABEL_13;\n          }\n          if ( (_DWORD)v18 == 3 )\n          {\n            v15 = v13 / 3 + (((v13 * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64) & 0xFFFFFFFFFFFFFFFELL);\n            if ( v13 == v15 )\n            {\nLABEL_12:\n              v12 = libmin_exp(v9);\n              goto LABEL_13;\n            }\n            if ( v13 - v15 != 1 )\n              goto LABEL_20;\n          }\n          else if ( (_DWORD)v18 != 1 )\n          {\n            goto LABEL_12;\n          }\n          v12 = libmin_sin(v9);\nLABEL_13:\n          v5[v14] = v12;\n          ++v13;\n          v9 = x;\n          v14 = ((_BYTE)v14 + 1) & 0x3F;\n          x = v12 * 1.0e-16 + x;\n        }\n        while ( v13 != 64 );\n        if ( !--v19 )\n        {\n          v16 = v5;\n          v17 = 0.0;\n          do\n            v17 = v17 + *v16++;\n          while ( v5 + 64 != v16 );\n          argv = (const char **)FN_NAMES[v18];\n          libmin_printf(\n            \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f checksum=%f\\n\",\n            (const char *)argv,\n            10,\n            64,\n            1,\n            640.0,\n            v17);\n          libmin_free(v3);\n          libmin_free(v5);\n          if ( ++v18 == 4 )\n            libmin_success();\n          goto LABEL_2;\n        }\n      }\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double *v3;\n  double *v4;\n  double *v5;\n  long long v6;\n  long long v7;\n  unsigned long long v8;\n  double v9;\n  long long v10;\n  double v11;\n  double v12;\n  unsigned long long v13;\n  long long v14;\n  long long v15;\n  double *v16;\n  double v17;\n  long long v18;\n  long long v19;\n  double x;\n  v18 = 0LL;\nLABEL_2:\n  v3 = (double *)libmin_malloc(512uLL);\n  v4 = (double *)libmin_malloc(512uLL);\n  v5 = v4;\n  if (!v3 || !v4) {\n    libmin_printf(\"alloc failed\\n\", argv);\n    libmin_fail(1);\n  }\n  v6 = 64LL;\n  v7 = 0LL;\n  v8 = 1LL;\n  v9 = 10.0;\n  while (1) {\n    while (1) {\n      v8 ^= ((v8 ^ (v8 << 13)) >> 7) ^ (v8 << 13) ^\n            ((((v8 ^ (v8 << 13)) >> 7) ^ v8 ^ (v8 << 13)) << 17);\n      v10 = v7;\n      v11 = (double)(int)(v8 >> 11) * 1.110223024625157e-16;\n      if (v18 != 3) break;\n      v3[v7] = v11 * 8.0 - 4.0;\n    LABEL_6:\n      v7 = ((uint8_t)v7 + 1) & 63;\n      if (!--v6) goto LABEL_10;\n    }\n    if ((uint32_t)v18) {\n      v3[v7] = v11 * 6.283185307179586 - 3.141592653589793;\n      goto LABEL_6;\n    }\n    v7 = ((uint8_t)v7 + 1) & 63;\n    v3[v10] = v11 * 20.0 - 10.0;\n    if (!--v6) {\n    LABEL_10:\n      x = 0.0;\n      v19 = 10LL;\n      while (1) {\n        v13 = 0LL;\n        v14 = 0LL;\n        do {\n          if (v18 == 2) {\n          LABEL_20:\n            v12 = libmin_cos(v9);\n            goto LABEL_13;\n          }\n          if ((uint32_t)v18 == 3) {\n            v15 = v13 / 3 +\n                  (((v13 * (unsigned __int128)12297829382473034411LL) >> 64) &\n                   18446744073709551614LL);\n            if (v13 == v15) {\n            LABEL_12:\n              v12 = libmin_exp(v9);\n              goto LABEL_13;\n            }\n            if (v13 - v15 != 1) goto LABEL_20;\n          } else if ((uint32_t)v18 != 1) {\n            goto LABEL_12;\n          }\n          v12 = libmin_sin(v9);\n        LABEL_13:\n          v5[v14] = v12;\n          ++v13;\n          v9 = x;\n          v14 = ((uint8_t)v14 + 1) & 63;\n          x = v12 * 1.0e-16 + x;\n        } while (v13 != 64);\n        if (!--v19) {\n          v16 = v5;\n          v17 = 0.0;\n          do v17 = v17 + *v16++;\n          while (v5 + 64 != v16);\n          argv = (const char **)FN_NAMES[v18];\n          libmin_printf(\n              \"transcendentals fn=%s prec=fp64 N_ITER=%u n=%u stride=%u ops=%f \"\n              \"checksum=%f\\n\",\n              (const char *)argv, 10, 64, 1, 640.0, v17);\n          libmin_free(v3);\n          libmin_free(v5);\n          if (++v18 == 4) libmin_success();\n          goto LABEL_2;\n        }\n      }\n    }\n  }\n}", "binary": "transcend/transcend.host.O2", "assembly": "<main>:\nendbr64\npush   %r15\npush   %r14\npush   %r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x28,%rsp\nmovq   $0x0,(%rsp)\nmov    $0x200,%edi\nmov    (%rsp),%r12d\ncall   1920 <libmin_malloc>\nmov    $0x200,%edi\nmov    %rax,%r14\ncall   1920 <libmin_malloc>\nmov    %rax,%r15\ntest   %r14,%r14\nje     1397 <main+0x277>\ntest   %rax,%rax\nje     1397 <main+0x277>\nmovsd  0x3f36(%rip),%xmm5\nmovsd  0x3f16(%rip),%xmm4\nmov    $0x40,%ecx\nxor    %edx,%edx\nmovsd  0x3f0f(%rip),%xmm3\nmovsd  0x3eef(%rip),%xmm2\nmov    $0x1,%esi\nmovsd  0x3eea(%rip),%xmm1\njmp    11bf <main+0x9f>\nmulsd  0x3ef8(%rip),%xmm0\nsubsd  %xmm5,%xmm0\nmovsd  %xmm0,(%r14,%rdx,8)\nadd    $0x1,%rdx\nand    $0x3f,%edx\nsub    $0x1,%rcx\nje     1228 <main+0x108>\nmov    %rsi,%rax\npxor   %xmm0,%xmm0\nshl    $0xd,%rax\nxor    %rsi,%rax\nmov    %rax,%rsi\nshr    $0x7,%rsi\nxor    %rsi,%rax\nmov    %rax,%rsi\nshl    $0x11,%rsi\nxor    %rax,%rsi\nmov    %rsi,%rax\nshr    $0xb,%rax\ncmpq   $0x3,(%rsp)\ncvtsi2sd %rax,%xmm0\nlea    0x0(,%rdx,8),%rax\nmulsd  0x3e76(%rip),%xmm0\nje     11a0 <main+0x80>\ntest   %r12d,%r12d\njne    12e1 <main+0x1c1>\nmulsd  %xmm2,%xmm0\nadd    $0x1,%rdx\nand    $0x3f,%edx\nsubsd  %xmm1,%xmm0\nmovsd  %xmm0,(%r14,%rax,1)\nsub    $0x1,%rcx\njne    11bf <main+0x9f>\nmovq   $0x0,0x18(%rsp)\nmovq   $0xa,0x8(%rsp)\njmp    1286 <main+0x166>\nnopl   0x0(%rax)\ncmp    $0x1,%r12d\nje     12f8 <main+0x1d8>\ncall   1690 <libmin_exp>\nmovsd  %xmm0,(%r15,%r13,1)\nmulsd  0x3e53(%rip),%xmm0\nadd    $0x1,%rbx\nadd    $0x1,%rbp\nmovsd  0x18(%rsp),%xmm1\nand    $0x3f,%ebx\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,0x18(%rsp)\ncmp    $0x40,%rbp\njne    1290 <main+0x170>\nsubq   $0x1,0x8(%rsp)\nje     1302 <main+0x1e2>\nxor    %ebp,%ebp\nxor    %ebx,%ebx\nnopw   0x0(%rax,%rax,1)\ncmpq   $0x2,(%rsp)\nmovsd  (%r14,%rbx,8),%xmm0\nlea    0x0(,%rbx,8),%r13\nje     12d7 <main+0x1b7>\ncmp    $0x3,%r12d\njne    1240 <main+0x120>\nmovabs $0xaaaaaaaaaaaaaaab,%rax\nmul    %rbp\nmov    %rdx,%rax\nand    $0xfffffffffffffffe,%rdx\nshr    %rax\nadd    %rax,%rdx\nmov    %rbp,%rax\nsub    %rdx,%rax\nje     124a <main+0x12a>\ncmp    $0x1,%rax\nje     12f8 <main+0x1d8>\ncall   32f0 <libmin_cos>\njmp    124f <main+0x12f>\nmulsd  %xmm4,%xmm0\nsubsd  %xmm3,%xmm0\nmovsd  %xmm0,(%r14,%rax,1)\njmp    11b2 <main+0x92>\nnopl   0x0(%rax)\ncall   3450 <libmin_sin>\njmp    124f <main+0x12f>\nmov    %r15,%rax\nlea    0x200(%r15),%rdx\npxor   %xmm1,%xmm1\naddsd  (%rax),%xmm1\nadd    $0x8,%rax\ncmp    %rax,%rdx\njne    1310 <main+0x1f0>\nmov    (%rsp),%rbx\nmov    $0x1,%r8d\nmov    $0x40,%ecx\nlea    0x6a2d(%rip),%rax\nmov    $0xa,%edx\nlea    0x3ce9(%rip),%rdi\nmov    (%rax,%rbx,8),%rsi\nmov    0x3d6e(%rip),%rax\nadd    $0x1,%rbx\nmovq   %rax,%xmm0\nmov    $0x2,%eax\ncall   2ec0 <libmin_printf>\nmov    %r14,%rdi\ncall   19d0 <libmin_free>\nmov    %r15,%rdi\ncall   19d0 <libmin_free>\nmov    %rbx,(%rsp)\nmovsd  0x18(%rsp),%xmm0\ncmp    $0x4,%rbx\njne    113a <main+0x1a>\ncall   3630 <libmin_success>\nadd    $0x28,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\npop    %r15\nret\nlea    0x3c66(%rip),%rdi\nxor    %eax,%eax\ncall   2ec0 <libmin_printf>\nmov    $0x1,%edi\ncall   1870 <libmin_fail>\njmp    116a <main+0x4a>\ncs nopw 0x0(%rax,%rax,1)\nxchg   %ax,%ax\n"}
{"source": {"path": "uniquify/uniquify.c", "function_name": "main", "content": "int main(void) {\n    /* \n     * Define a statically allocated list of strings.\n     * Most strings are unique, with a few duplicates.\n     */\n    char *strings[] = {\n        \"banana\",\n        \"apple\",\n        \"orange\",\n        \"kiwi\",\n        \"grape\",\n        \"mango\",\n        \"strawberry\",\n        \"pear\",\n        \"pineapple\",\n        \"watermelon\",\n        \"blueberry\",\n        \"raspberry\",\n        \"apple\",   /* duplicate */\n        \"blackberry\",\n        \"cherry\",\n        \"banana\",  /* duplicate */\n        \"peach\",\n        \"apricot\",\n        \"plum\",\n        \"nectarine\",\n        \"cantaloupe\",\n        \"honeydew\",\n        \"lime\", /* duplicate */\n        \"papaya\",\n        \"passionfruit\",\n        \"guava\",\n        \"lychee\",\n        \"pomegranate\",\n        \"grapefruit\",\n        \"lemon\",\n        \"lime\",\n        \"tangerine\",\n        \"cranberry\",\n        \"fig\",\n        \"plum\" /* duplicate */\n    };\n    size_t n = sizeof(strings) / sizeof(strings[0]);\n\n    libmin_printf(\"Unsorted Strings:\\n\");\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s\\n\", strings[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* Sort the list using qsort from qsort.h/qsort.c */\n    libmin_qsort(strings, n, sizeof(char *), string_compare);\n\n    libmin_printf(\"Sorted Strings:\\n\");\n    for (size_t i = 0; i < n; i++) {\n        libmin_printf(\"%s\\n\", strings[i]);\n    }\n    libmin_printf(\"\\n\");\n\n    /* Remove duplicates from the sorted list.\n     * Since duplicates become adjacent after sorting, we simply print the\n     * first occurrence and then any string that differs from its predecessor.\n     */\n    libmin_printf(\"Unique Strings:\\n\");\n    if (n > 0) {\n        libmin_printf(\"%s\\n\", strings[0]);\n        size_t unique_count = 1;\n        for (size_t i = 1; i < n; i++) {\n            if (libmin_strcmp(strings[i], strings[i - 1]) != 0) {\n                libmin_printf(\"%s\\n\", strings[i]);\n                unique_count++;\n            }\n        }\n        libmin_printf(\"\\nTotal Unique Strings: %u\\n\", unique_count);\n    } else {\n        libmin_printf(\"No strings.\\n\");\n    }\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "uniquify/uniquify.host.O2.pseudo", "function_name": "main", "address": "0x1120", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  char **v3; // rbx\n  char **v4; // rbp\n  const char *v5; // rsi\n  const char *v6; // rsi\n  char **v7; // rbx\n  int v8; // ebp\n  const char *v9; // rsi\n  char *strings[35]; // [rsp+0h] [rbp-148h] BYREF\n  _QWORD v11[6]; // [rsp+118h] [rbp-30h] BYREF\n\n  v11[0] = __readfsqword(0x28u);\n  qmemcpy(strings, &off_6020, sizeof(strings));\n  v3 = strings;\n  v4 = strings;\n  libmin_printf(\"Unsorted Strings:\\n\", &off_6020 + 35, envp);\n  do\n  {\n    v5 = *v4++;\n    libmin_printf(\"%s\\n\", v5);\n  }\n  while ( v4 != v11 );\n  libmin_printf((char *)\"\\n\");\n  libmin_qsort(strings, 0x23uLL, 8uLL, string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  do\n  {\n    v6 = *v3++;\n    libmin_printf(\"%s\\n\", v6);\n  }\n  while ( v3 != v11 );\n  v7 = &strings[1];\n  v8 = 1;\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  while ( 1 )\n  {\n    if ( libmin_strcmp(*v7, *(v7 - 1)) )\n    {\n      v9 = *v7++;\n      ++v8;\n      libmin_printf(\"%s\\n\", v9);\n      if ( v7 == v11 )\n      {\nLABEL_9:\n        libmin_printf(\"\\nTotal Unique Strings: %u\\n\", v8);\n        libmin_success();\n      }\n    }\n    else if ( ++v7 == v11 )\n    {\n      goto LABEL_9;\n    }\n  }\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  char **v3;\n  char **v4;\n  const char *v5;\n  const char *v6;\n  char **v7;\n  int v8;\n  const char *v9;\n  char *strings[35];\n  uint64_t v11[6];\n  v11[0] = __readfsqword(40u);\n  qmemcpy(strings, &off_6020, sizeof(strings));\n  v3 = strings;\n  v4 = strings;\n  libmin_printf(\"Unsorted Strings:\\n\", &off_6020 + 35, envp);\n  do {\n    v5 = *v4++;\n    libmin_printf(\"%s\\n\", v5);\n  } while (v4 != v11);\n  libmin_printf((char *)\"\\n\");\n  libmin_qsort(strings, 35uLL, 8uLL, string_compare);\n  libmin_printf(\"Sorted Strings:\\n\");\n  do {\n    v6 = *v3++;\n    libmin_printf(\"%s\\n\", v6);\n  } while (v3 != v11);\n  v7 = &strings[1];\n  v8 = 1;\n  libmin_printf((char *)\"\\n\");\n  libmin_printf(\"Unique Strings:\\n\");\n  libmin_printf(\"%s\\n\", strings[0]);\n  while (1) {\n    if (libmin_strcmp(*v7, *(v7 - 1))) {\n      v9 = *v7++;\n      ++v8;\n      libmin_printf(\"%s\\n\", v9);\n      if (v7 == v11) {\n      LABEL_9:\n        libmin_printf(\"\\nTotal Unique Strings: %u\\n\", v8);\n        libmin_success();\n      }\n    } else if (++v7 == v11) {\n      goto LABEL_9;\n    }\n  }\n}", "binary": "uniquify/uniquify.host.O2", "assembly": "<main>:\nendbr64\npush   %r14\nlea    0x4ef3(%rip),%rsi\nmov    $0x23,%ecx\npush   %r13\nlea    0x2edc(%rip),%r13\npush   %r12\npush   %rbp\npush   %rbx\nsub    $0x120,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x118(%rsp)\nxor    %eax,%eax\nmov    %rsp,%r14\nmov    %rsp,%rdi\nlea    0x118(%rsp),%r12\nrep movsq %ds:(%rsi),%es:(%rdi)\nlea    0x2e93(%rip),%rdi\nmov    %r14,%rbx\nmov    %r14,%rbp\ncall   28e0 <libmin_printf>\nnopl   0x0(%rax)\nmov    0x0(%rbp),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x8,%rbp\ncall   28e0 <libmin_printf>\ncmp    %r12,%rbp\njne    1180 <main+0x60>\nlea    0x2e8c(%rip),%rbp\nxor    %eax,%eax\nmov    %rbp,%rdi\ncall   28e0 <libmin_printf>\nmov    %r14,%rdi\nmov    $0x8,%edx\nlea    0x1d9(%rip),%rcx\nmov    $0x23,%esi\ncall   2d10 <libmin_qsort>\nlea    0x2e53(%rip),%rdi\nxor    %eax,%eax\ncall   28e0 <libmin_printf>\nnop\nmov    (%rbx),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x8,%rbx\ncall   28e0 <libmin_printf>\ncmp    %r12,%rbx\njne    11d0 <main+0xb0>\nmov    %rbp,%rdi\nxor    %eax,%eax\nlea    0x8(%rsp),%rbx\nmov    $0x1,%ebp\ncall   28e0 <libmin_printf>\nlea    0x2e2b(%rip),%rdi\nxor    %eax,%eax\ncall   28e0 <libmin_printf>\nmov    (%rsp),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\ncall   28e0 <libmin_printf>\njmp    1229 <main+0x109>\nnopl   0x0(%rax,%rax,1)\nadd    $0x8,%rbx\ncmp    %r12,%rbx\nje     1253 <main+0x133>\nmov    -0x8(%rbx),%rsi\nmov    (%rbx),%rdi\ncall   2d40 <libmin_strcmp>\ntest   %eax,%eax\nje     1220 <main+0x100>\nmov    (%rbx),%rsi\nmov    %r13,%rdi\nxor    %eax,%eax\nadd    $0x8,%rbx\nadd    $0x1,%rbp\ncall   28e0 <libmin_printf>\ncmp    %r12,%rbx\njne    1229 <main+0x109>\nmov    %rbp,%rsi\nlea    0x2de0(%rip),%rdi\nxor    %eax,%eax\ncall   28e0 <libmin_printf>\ncall   2dd0 <libmin_success>\nmov    0x118(%rsp),%rax\nsub    %fs:0x28,%rax\njne    128e <main+0x16e>\nadd    $0x120,%rsp\nxor    %eax,%eax\npop    %rbx\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\ncall   10c0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   (%rax)\n"}
{"source": {"path": "uniquify/uniquify.c", "function_name": "string_compare", "content": "#include \"libmin.h\"\n\n/* Comparison function for strings.\n * qsort passes pointers to elements (here pointers to char pointers),\n * so we cast accordingly.\n */\nint string_compare(const void *a, const void *b) {\n    const char * const *str1 = (const char * const *) a;\n    const char * const *str2 = (const char * const *) b;\n    return libmin_strcmp(*str1, *str2);\n}\n"}, "pseudo": {"path": "uniquify/uniquify.host.O2.pseudo", "function_name": "string_compare", "address": "0x1390", "label": "string_compare", "content": "int __fastcall string_compare(const void *a, const void *b)\n{\n  return libmin_strcmp(*(const char **)a, *(const char **)b);\n}\n"}, "pseudo_normalize": "", "binary": "uniquify/uniquify.host.O2", "assembly": "<string_compare>:\nendbr64\nmov    (%rsi),%rsi\nmov    (%rdi),%rdi\njmp    2d40 <libmin_strcmp>\nnop\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "dot_prod", "content": "/**\n * Obtain the dot product of two 3D vectors.\n * @f[\n * \\vec{a}\\cdot\\vec{b}=a_xb_x + a_yb_y + a_zb_z\n * @f]\n * @param[in] a first vector\n * @param[in] b second vector\n * @returns resulting dot product\n */\ndouble dot_prod(const vec_3d *a, const vec_3d *b)\n{\n    double dot;\n    dot = a->x * b->x;\n    dot += a->y * b->y;\n    dot += a->z * b->z;\n\n    return dot;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O2.pseudo", "function_name": "dot_prod", "address": "0x1590", "label": "dot_prod", "content": "double __fastcall dot_prod(const vec_3d *a, const vec_3d *b)\n{\n  return a->z * b->z + a->y * b->y + a->x * b->x;\n}\n"}, "pseudo_normalize": "", "binary": "vectors-3d/vectors-3d.host.O2", "assembly": "<dot_prod>:\nendbr64\nmovsd  (%rdi),%xmm0\nmovsd  0x8(%rdi),%xmm1\nmulsd  (%rsi),%xmm0\nmulsd  0x8(%rsi),%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rdi),%xmm0\nmulsd  0x10(%rsi),%xmm0\naddsd  %xmm1,%xmm0\nret\nnopl   0x0(%rax)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "get_angle", "content": "/**\n * Obtain the angle between two given vectors.\n * @f[\\alpha=acos\\left(\\frac{\\vec{a} \\cdot \\vec{b}}{\\lVert\\vec{a}\\rVert \\cdot \\lVert\\vec{b}\\rVert}\\right)@f]\n * @param[in] a first input vector\n * @param[in] b second input vector\n * @returns angle between @f$\\vec{a}@f$ and @f$\\vec{b}@f$ in radians\n */\n\ndouble get_angle(const vec_3d *a, const vec_3d *b)\n{\n    double alpha, cos_alpha;\n    double norm_a = vector_norm(a); ///< The norm of vector a\n    double norm_b = vector_norm(b); ///< The norm of vector b\n    if (libmin_fabs(norm_a) < EPSILON || libmin_fabs(norm_b) < EPSILON) /// detect possible division by 0 - the angle is not defined in this case\n    {  \n        return NAN; \n    }\n\n    cos_alpha = dot_prod(a, b) / (norm_a * norm_b);\n    alpha = libmin_acos(cos_alpha); // delivers the radian\n    return alpha; // in range from -1 to 1\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O2.pseudo", "function_name": "get_angle", "address": "0x17d0", "label": "get_angle", "content": "double __fastcall get_angle(const vec_3d *a, const vec_3d *b)\n{\n  double v2; // xmm1_8\n  double norm_a; // [rsp+0h] [rbp-28h]\n  double norm_b; // [rsp+8h] [rbp-20h]\n\n  norm_a = libmin_sqrt(a->x * a->x + a->y * a->y);\n  v2 = b->x * b->x + b->y * b->y;\n  norm_b = libmin_sqrt(v2);\n  if ( libmin_fabs(v2) < 0.000000001 || libmin_fabs(v2) < 0.000000001 )\n    return NAN;\n  else\n    return libmin_acos(norm_b * norm_a);\n}\n"}, "pseudo_normalize": "double get_angle(const vec_3d *a, const vec_3d *b) {\n  double v2;\n  double norm_a;\n  double norm_b;\n  norm_a = libmin_sqrt(a->x * a->x + a->y * a->y);\n  v2 = b->x * b->x + b->y * b->y;\n  norm_b = libmin_sqrt(v2);\n  if (libmin_fabs(v2) < 0.000000001 || libmin_fabs(v2) < 0.000000001)\n    return NAN;\n  else\n    return libmin_acos(norm_b * norm_a);\n}", "binary": "vectors-3d/vectors-3d.host.O2", "assembly": "<get_angle>:\nendbr64\npush   %rbp\nmov    %rdi,%rbp\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x18,%rsp\nmovsd  (%rdi),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x8(%rdi),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rdi),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncall   33c0 <libmin_sqrt>\nmovsd  %xmm0,(%rsp)\nmovsd  (%rbx),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x8(%rbx),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rbx),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncall   33c0 <libmin_sqrt>\nmovsd  %xmm0,0x8(%rsp)\nmovsd  (%rsp),%xmm0\ncall   1df0 <libmin_fabs>\nmovsd  0x285d(%rip),%xmm3\ncomisd %xmm0,%xmm3\njbe    1870 <get_angle+0xa0>\nmovsd  0x285f(%rip),%xmm0\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\nret\nnopl   0x0(%rax,%rax,1)\nmovsd  0x8(%rsp),%xmm0\ncall   1df0 <libmin_fabs>\nmovsd  0x282d(%rip),%xmm4\ncomisd %xmm0,%xmm4\nja     1859 <get_angle+0x89>\nmovsd  0x0(%rbp),%xmm0\nmovsd  0x8(%rbp),%xmm1\nmulsd  (%rbx),%xmm0\nmulsd  0x8(%rbx),%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rbp),%xmm0\nmulsd  0x10(%rbx),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  0x8(%rsp),%xmm1\nmulsd  (%rsp),%xmm1\nadd    $0x18,%rsp\npop    %rbx\npop    %rbp\ndivsd  %xmm1,%xmm0\njmp    1ab0 <libmin_acos>\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "get_cross_matrix", "content": "/**\n * The cross product of vectors can be represented as a matrix\n * multiplication operation. This function obtains the `3x3` matrix\n * of the cross-product operator from the first vector.\n * @f[\\begin{align*}\n * \\left(\\vec{a}\\times\\right)\\vec{b} &= \\tilde{A}_a\\vec{b}\\\\\n * \\tilde{A}_a &=\n * \\begin{bmatrix}0&-a_z&a_y\\\\a_z&0&-a_x\\\\-a_y&a_x&0\\end{bmatrix}\n * \\end{align*}@f]\n * @param[in] a input vector\n * @returns the `3x3` matrix for the cross product operator\n * @f$\\left(\\vec{a}\\times\\right)@f$\n */\nmat_3x3 get_cross_matrix(const vec_3d *a)\n{\n    mat_3x3 A = {{{0., -a->z, a->y}}, {{a->z, 0., -a->x}}, {{-a->y, a->x, 0.}}};\n    return A;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O2.pseudo", "function_name": "get_cross_matrix", "address": "0x1760", "label": "get_cross_matrix", "content": "mat_3x3 *__fastcall get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a)\n{\n  double z; // xmm3_8\n  double x; // xmm2_8\n  mat_3x3 *result; // rax\n  double y; // xmm0_8\n\n  z = a->z;\n  x = a->x;\n  result = retstr;\n  retstr->row1[0] = 0.0;\n  y = a->y;\n  *(_OWORD *)retstr->row2 = *(unsigned __int64 *)&z;\n  retstr->row1[2] = y;\n  retstr->row3[2] = 0.0;\n  retstr->row1[1] = -z;\n  retstr->row2[2] = -x;\n  retstr->row3[0] = -y;\n  retstr->row3[1] = x;\n  return result;\n}\n"}, "pseudo_normalize": "mat_3x3 *get_cross_matrix(mat_3x3 *__return_ptr retstr, const vec_3d *a) {\n  double z;\n  double x;\n  mat_3x3 *result;\n  double y;\n  z = a->z;\n  x = a->x;\n  result = retstr;\n  retstr->row1[0] = 0.0;\n  y = a->y;\n  *(long double *)retstr->row2 = *(unsigned long long *)&z;\n  retstr->row1[2] = y;\n  retstr->row3[2] = 0.0;\n  retstr->row1[1] = -z;\n  retstr->row2[2] = -x;\n  retstr->row3[0] = -y;\n  retstr->row3[1] = x;\n  return result;\n}", "binary": "vectors-3d/vectors-3d.host.O2", "assembly": "<get_cross_matrix>:\nendbr64\nmovsd  0x10(%rsi),%xmm3\nmovsd  (%rsi),%xmm2\nmov    %rdi,%rax\nmovq   $0x0,(%rdi)\nmovq   0x2921(%rip),%xmm1\nmovsd  0x8(%rsi),%xmm0\nmovq   $0x0,0x20(%rdi)\nmovapd %xmm3,%xmm4\nmovsd  %xmm3,0x18(%rdi)\nmovapd %xmm2,%xmm3\nxorpd  %xmm1,%xmm4\nmovsd  %xmm0,0x10(%rdi)\nxorpd  %xmm1,%xmm3\nxorpd  %xmm1,%xmm0\nmovq   $0x0,0x40(%rdi)\nmovsd  %xmm4,0x8(%rdi)\nmovsd  %xmm3,0x28(%rdi)\nmovsd  %xmm0,0x30(%rdi)\nmovsd  %xmm2,0x38(%rdi)\nret\nnopw   0x0(%rax,%rax,1)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "main", "content": "/**\n * @brief Main function\n *\n * @return 0 on exit\n */\nint main(void)\n{\n    test();\n\n    libmin_success();\n    return 0;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  double v3; // xmm1_8\n  const char *v4; // rax\n  const char *v5; // rax\n  double v6; // xmm1_8\n  const char *v7; // rax\n  double v8; // [rsp+8h] [rbp-90h]\n  double v9; // [rsp+8h] [rbp-90h]\n  double angle; // [rsp+8h] [rbp-90h]\n  vec_3d a; // [rsp+10h] [rbp-88h] BYREF\n  vec_3d b; // [rsp+30h] [rbp-68h] BYREF\n  vec_3d v13; // [rsp+50h] [rbp-48h] BYREF\n  unsigned __int64 v14; // [rsp+68h] [rbp-30h]\n\n  v14 = __readfsqword(0x28u);\n  a.x = 1.0;\n  a.y = 2.0;\n  a.z = 3.0;\n  b.x = 1.0;\n  b.y = 1.0;\n  b.z = 1.0;\n  v4 = print_vector(&a, \"a\");\n  libmin_printf(\"%s\", v4);\n  v5 = print_vector(&b, \"b\");\n  libmin_printf(\"%s\", v5);\n  v8 = vector_norm(&a);\n  libmin_printf(\"|a| = %.4lf\\n\", v8);\n  if ( libmin_fabs(v3) < 0.01 )\n  {\n    v9 = vector_norm(&b);\n    libmin_printf(\"|b| = %.4lf\\n\", v9);\n    if ( libmin_fabs(v3) < 0.01 )\n    {\n      v6 = a.y * b.y + a.x * b.x;\n      libmin_printf(\"Dot product: %lf\\n\", a.z * b.z + v6);\n      if ( libmin_fabs(v6) < 0.01 )\n      {\n        vector_prod(&v13, &a, &b);\n        libmin_printf(\"Vector product \");\n        v7 = print_vector(&v13, \"c\");\n        libmin_printf(\"%s\", v7);\n        if ( libmin_fabs(v6) < 0.01 )\n        {\n          if ( libmin_fabs(v6) < 0.01 )\n          {\n            if ( libmin_fabs(v6) < 0.01 )\n            {\n              angle = get_angle(&a, &b);\n              libmin_printf(\"The angle is %lf\\n\", angle);\n              if ( libmin_fabs(v6) < 0.01 )\n              {\n                libmin_printf(\"All tests passed!\\n\");\n                libmin_success();\n              }\n              libmin_fail(1);\n            }\n            libmin_fail(1);\n          }\n          libmin_fail(1);\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  double v3;\n  const char *v4;\n  const char *v5;\n  double v6;\n  const char *v7;\n  double v8;\n  double v9;\n  double angle;\n  vec_3d a;\n  vec_3d b;\n  vec_3d v13;\n  unsigned long long v14;\n  v14 = __readfsqword(40u);\n  a.x = 1.0;\n  a.y = 2.0;\n  a.z = 3.0;\n  b.x = 1.0;\n  b.y = 1.0;\n  b.z = 1.0;\n  v4 = print_vector(&a, \"a\");\n  libmin_printf(\"%s\", v4);\n  v5 = print_vector(&b, \"b\");\n  libmin_printf(\"%s\", v5);\n  v8 = vector_norm(&a);\n  libmin_printf(\"|a| = %.4lf\\n\", v8);\n  if (libmin_fabs(v3) < 0.01) {\n    v9 = vector_norm(&b);\n    libmin_printf(\"|b| = %.4lf\\n\", v9);\n    if (libmin_fabs(v3) < 0.01) {\n      v6 = a.y * b.y + a.x * b.x;\n      libmin_printf(\"Dot product: %lf\\n\", a.z * b.z + v6);\n      if (libmin_fabs(v6) < 0.01) {\n        vector_prod(&v13, &a, &b);\n        libmin_printf(\"Vector product \");\n        v7 = print_vector(&v13, \"c\");\n        libmin_printf(\"%s\", v7);\n        if (libmin_fabs(v6) < 0.01) {\n          if (libmin_fabs(v6) < 0.01) {\n            if (libmin_fabs(v6) < 0.01) {\n              angle = get_angle(&a, &b);\n              libmin_printf(\"The angle is %lf\\n\", angle);\n              if (libmin_fabs(v6) < 0.01) {\n                libmin_printf(\"All tests passed!\\n\");\n                libmin_success();\n              }\n              libmin_fail(1);\n            }\n            libmin_fail(1);\n          }\n          libmin_fail(1);\n        }\n        libmin_fail(1);\n      }\n      libmin_fail(1);\n    }\n    libmin_fail(1);\n  }\n  libmin_fail(1);\n}", "binary": "vectors-3d/vectors-3d.host.O2", "assembly": "<main>:\nendbr64\npush   %r14\nlea    0x2f25(%rip),%rsi\npush   %r13\nlea    0x2f1e(%rip),%r13\npush   %r12\npush   %rbp\nsub    $0x78,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x68(%rsp)\nxor    %eax,%eax\nmov    0x2f84(%rip),%rax\nlea    0x10(%rsp),%rbp\nlea    0x30(%rsp),%r12\nmov    %rbp,%rdi\nmov    %rax,0x10(%rsp)\nmov    0x2f7b(%rip),%rax\nmov    %rax,0x18(%rsp)\nmov    0x2f77(%rip),%rax\nmov    %rax,0x20(%rsp)\nmov    0x2f53(%rip),%rax\nmov    %rax,0x30(%rsp)\nmov    %rax,0x38(%rsp)\nmov    %rax,0x40(%rsp)\ncall   1620 <print_vector>\nmov    %r13,%rdi\nmov    %rax,%rsi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nlea    0x2eaa(%rip),%rsi\nmov    %r12,%rdi\ncall   1620 <print_vector>\nmov    %r13,%rdi\nmov    %rax,%rsi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nmov    %rbp,%rdi\ncall   1660 <vector_norm>\nlea    0x2e88(%rip),%rdi\nmov    $0x1,%eax\nmovsd  %xmm0,0x8(%rsp)\ncall   31b0 <libmin_printf>\nmovsd  0x8(%rsp),%xmm0\nsubsd  0x2f09(%rip),%xmm0\ncall   1df0 <libmin_fabs>\nmovsd  0x2f04(%rip),%xmm2\ncomisd %xmm0,%xmm2\njbe    13b2 <main+0x2b2>\nmov    %r12,%rdi\ncall   1660 <vector_norm>\nlea    0x2e51(%rip),%rdi\nmov    $0x1,%eax\nmovsd  %xmm0,0x8(%rsp)\ncall   31b0 <libmin_printf>\nmovsd  0x8(%rsp),%xmm0\nsubsd  0x2ed5(%rip),%xmm0\ncall   1df0 <libmin_fabs>\nmovsd  0x2ec0(%rip),%xmm3\ncomisd %xmm0,%xmm3\njbe    1409 <main+0x309>\nmovsd  0x10(%rsp),%xmm0\nmovsd  0x18(%rsp),%xmm1\nmov    $0x1,%eax\nlea    0x2e11(%rip),%rdi\nmulsd  0x30(%rsp),%xmm0\nmulsd  0x38(%rsp),%xmm1\naddsd  %xmm0,%xmm1\nmovsd  0x20(%rsp),%xmm0\nmulsd  0x40(%rsp),%xmm0\naddsd  %xmm1,%xmm0\nmovsd  %xmm0,0x8(%rsp)\ncall   31b0 <libmin_printf>\nmovsd  0x8(%rsp),%xmm0\nsubsd  0x2e75(%rip),%xmm0\ncall   1df0 <libmin_fabs>\nmovsd  0x2e58(%rip),%xmm4\ncomisd %xmm0,%xmm4\njbe    13fa <main+0x2fa>\nlea    0x50(%rsp),%r14\nmov    %r12,%rdx\nmov    %rbp,%rsi\nmov    %r14,%rdi\ncall   15c0 <vector_prod>\nlea    0x2db9(%rip),%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nlea    0x2dbb(%rip),%rsi\nmov    %r14,%rdi\ncall   1620 <print_vector>\nmov    %r13,%rdi\nmov    %rax,%rsi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\nmovsd  0x2de1(%rip),%xmm0\naddsd  0x50(%rsp),%xmm0\ncall   1df0 <libmin_fabs>\nmovsd  0x2df6(%rip),%xmm5\ncomisd %xmm0,%xmm5\njbe    13eb <main+0x2eb>\nmovsd  0x58(%rsp),%xmm0\nsubsd  0x2dc6(%rip),%xmm0\ncall   1df0 <libmin_fabs>\nmovsd  0x2dd1(%rip),%xmm6\ncomisd %xmm0,%xmm6\njbe    13dc <main+0x2dc>\nmovsd  0x2d97(%rip),%xmm0\naddsd  0x60(%rsp),%xmm0\ncall   1df0 <libmin_fabs>\nmovsd  0x2dac(%rip),%xmm7\ncomisd %xmm0,%xmm7\njbe    13cd <main+0x2cd>\nmov    %r12,%rsi\nmov    %rbp,%rdi\ncall   17d0 <get_angle>\nlea    0x2d27(%rip),%rdi\nmov    $0x1,%eax\nmovsd  %xmm0,0x8(%rsp)\ncall   31b0 <libmin_printf>\nmovsd  0x8(%rsp),%xmm0\nsubsd  0x2d8a(%rip),%xmm0\ncall   1df0 <libmin_fabs>\nmovsd  0x2d65(%rip),%xmm2\ncomisd %xmm0,%xmm2\njbe    13c1 <main+0x2c1>\nlea    0x2d01(%rip),%rdi\nxor    %eax,%eax\ncall   31b0 <libmin_printf>\ncall   3600 <libmin_success>\nmov    0x68(%rsp),%rax\nsub    %fs:0x28,%rax\njne    1418 <main+0x318>\nadd    $0x78,%rsp\nxor    %eax,%eax\npop    %rbp\npop    %r12\npop    %r13\npop    %r14\nret\nmov    $0x1,%edi\ncall   1e30 <libmin_fail>\njmp    11e6 <main+0xe6>\nmov    $0x1,%edi\ncall   1e30 <libmin_fail>\njmp    1381 <main+0x281>\nmov    $0x1,%edi\ncall   1e30 <libmin_fail>\njmp    133e <main+0x23e>\nmov    $0x1,%edi\ncall   1e30 <libmin_fail>\njmp    1319 <main+0x219>\nmov    $0x1,%edi\ncall   1e30 <libmin_fail>\njmp    12f4 <main+0x1f4>\nmov    $0x1,%edi\ncall   1e30 <libmin_fail>\njmp    1292 <main+0x192>\nmov    $0x1,%edi\ncall   1e30 <libmin_fail>\njmp    122a <main+0x12a>\ncall   10b0 <__stack_chk_fail@plt>\nnopl   (%rax)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "print_vector", "content": "/**\n * Print formatted vector on stdout.\n * @param[in] a vector to print\n * @param[in] name  name of the vector\n * @returns string representation of vector\n */\nconst char *print_vector(const vec_3d *a, const char *name)\n{\n    static char vec_str[100];  // static to ensure the string life extends the\n                               // life of function\n\n    libmin_snprintf(vec_str, 99, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x,\n             a->y, a->z);\n    return vec_str;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O2.pseudo", "function_name": "print_vector", "address": "0x1620", "label": "print_vector", "content": "const char *__fastcall print_vector(const vec_3d *a, const char *name)\n{\n  libmin_snprintf(vec_str_0, 0x63uLL, \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x, a->y, a->z);\n  return vec_str_0;\n}\n"}, "pseudo_normalize": "const char *print_vector(const vec_3d *a, const char *name) {\n  libmin_snprintf(vec_str_0, 99uLL,\n                  \"vec(%s) = (%.0lf)i + (%.0lf)j + (%.0lf)k\\n\", name, a->x,\n                  a->y, a->z);\n  return vec_str_0;\n}", "binary": "vectors-3d/vectors-3d.host.O2", "assembly": "<print_vector>:\nendbr64\npush   %r12\nlea    0x4c53(%rip),%r12\nmovsd  (%rdi),%xmm0\nmov    %rsi,%rcx\nmovsd  0x10(%rdi),%xmm2\nmovsd  0x8(%rdi),%xmm1\nmov    $0x63,%esi\nmov    %r12,%rdi\nlea    0x29bb(%rip),%rdx\nmov    $0x3,%eax\ncall   32f0 <libmin_snprintf>\nmov    %r12,%rax\npop    %r12\nret\nnopl   (%rax)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "unit_vec", "content": "/**\n * Obtain unit vector in the same direction as given vector.\n * @f[\\hat{a}=\\frac{\\vec{a}}{\\lVert\\vec{a}\\rVert}@f]\n * @param[in] a input vector\n * @returns n unit vector in the direction of @f$\\vec{a}@f$\n */\nvec_3d unit_vec(const vec_3d *a)\n{\n    vec_3d n = {0};\n\n    double norm = vector_norm(a);\n    if (libmin_fabs(norm) < EPSILON)\n    {  // detect possible divide by 0\n        return n;\n    }\n\n    if (norm != 1.0)  // perform division only if needed\n    {\n        n.x = a->x / norm;\n        n.y = a->y / norm;\n        n.z = a->z / norm;\n    }\n    return n;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O2.pseudo", "function_name": "unit_vec", "address": "0x1690", "label": "unit_vec", "content": "vec_3d *__fastcall unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a)\n{\n  double v2; // xmm1_8\n  double v3; // xmm2_8\n  double v4; // xmm3_8\n  double v5; // xmm0_8\n  vec_3d *result; // rax\n  double v7; // [rsp+8h] [rbp-20h]\n\n  v2 = a->x * a->x + a->y * a->y;\n  v7 = libmin_sqrt(v2);\n  if ( libmin_fabs(v2) < 0.000000001 )\n  {\n    v5 = 0.0;\n    v4 = 0.0;\n    v3 = 0.0;\n  }\n  else if ( v7 == 1.0 )\n  {\n    v3 = 0.0;\n    v4 = 0.0;\n    v5 = 0.0;\n  }\n  else\n  {\n    v5 = a->x / v7;\n    v4 = a->y / v7;\n    v3 = a->z / v7;\n  }\n  retstr->x = v5;\n  result = retstr;\n  retstr->y = v4;\n  retstr->z = v3;\n  return result;\n}\n"}, "pseudo_normalize": "vec_3d *unit_vec(vec_3d *__return_ptr retstr, const vec_3d *a) {\n  double v2;\n  double v3;\n  double v4;\n  double v5;\n  vec_3d *result;\n  double v7;\n  v2 = a->x * a->x + a->y * a->y;\n  v7 = libmin_sqrt(v2);\n  if (libmin_fabs(v2) < 0.000000001) {\n    v5 = 0.0;\n    v4 = 0.0;\n    v3 = 0.0;\n  } else if (v7 == 1.0) {\n    v3 = 0.0;\n    v4 = 0.0;\n    v5 = 0.0;\n  } else {\n    v5 = a->x / v7;\n    v4 = a->y / v7;\n    v3 = a->z / v7;\n  }\n  retstr->x = v5;\n  result = retstr;\n  retstr->y = v4;\n  retstr->z = v3;\n  return result;\n}", "binary": "vectors-3d/vectors-3d.host.O2", "assembly": "<unit_vec>:\nendbr64\npush   %r12\nmov    %rdi,%r12\npush   %rbx\nmov    %rsi,%rbx\nsub    $0x18,%rsp\nmovsd  (%rsi),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x8(%rsi),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rsi),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\ncall   33c0 <libmin_sqrt>\nmovsd  %xmm0,0x8(%rsp)\ncall   1df0 <libmin_fabs>\nmovsd  0x29d1(%rip),%xmm2\ncomisd %xmm0,%xmm2\nja     1748 <unit_vec+0xb8>\nmovsd  0x8(%rsp),%xmm1\nucomisd 0x29c5(%rip),%xmm1\njp     1728 <unit_vec+0x98>\njne    1728 <unit_vec+0x98>\npxor   %xmm2,%xmm2\nmovapd %xmm2,%xmm3\nmovapd %xmm2,%xmm0\nmovsd  %xmm0,(%r12)\nmov    %r12,%rax\nmovsd  %xmm3,0x8(%r12)\nmovsd  %xmm2,0x10(%r12)\nadd    $0x18,%rsp\npop    %rbx\npop    %r12\nret\nnopw   0x0(%rax,%rax,1)\nmovsd  (%rbx),%xmm0\nmovsd  0x8(%rbx),%xmm3\nmovsd  0x10(%rbx),%xmm2\ndivsd  %xmm1,%xmm0\ndivsd  %xmm1,%xmm3\ndivsd  %xmm1,%xmm2\njmp    1703 <unit_vec+0x73>\nnopl   0x0(%rax)\npxor   %xmm0,%xmm0\nmovapd %xmm0,%xmm3\nmovapd %xmm0,%xmm2\njmp    1703 <unit_vec+0x73>\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "vector_add", "content": "/**\n * Add one vector to another. @f[\n * \\vec{c}=\\vec{a}+\\vec{b}=\\left(a_x+b_x\\right)\\hat{i}+\n * \\left(a_y+b_y\\right)\\hat{j}+\\left(a_z+b_z\\right)\\hat{k}@f]\n * @param[in] a vector to add to\n * @param[in] b vector to add\n * @returns resultant vector\n */\nvec_3d vector_add(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;\n    out.x = a->x + b->x;\n    out.y = a->y + b->y;\n    out.z = a->z + b->z;\n\n    return out;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O2.pseudo", "function_name": "vector_add", "address": "0x1550", "label": "vector_add", "content": "vec_3d *__fastcall vector_add(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  vec_3d *result; // rax\n  double v4; // xmm1_8\n  double v5; // xmm0_8\n\n  result = retstr;\n  v4 = b->y + a->y;\n  v5 = a->z + b->z;\n  retstr->x = a->x + b->x;\n  retstr->y = v4;\n  retstr->z = v5;\n  return result;\n}\n"}, "pseudo_normalize": "vec_3d *vector_add(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  vec_3d *result;\n  double v4;\n  double v5;\n  result = retstr;\n  v4 = b->y + a->y;\n  v5 = a->z + b->z;\n  retstr->x = a->x + b->x;\n  retstr->y = v4;\n  retstr->z = v5;\n  return result;\n}", "binary": "vectors-3d/vectors-3d.host.O2", "assembly": "<vector_add>:\nendbr64\nmovsd  0x8(%rsi),%xmm0\nmovsd  0x8(%rdx),%xmm1\nmov    %rdi,%rax\nmovsd  (%rsi),%xmm2\naddsd  (%rdx),%xmm2\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rsi),%xmm0\naddsd  0x10(%rdx),%xmm0\nmovsd  %xmm2,(%rdi)\nmovsd  %xmm1,0x8(%rdi)\nmovsd  %xmm0,0x10(%rdi)\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "vector_norm", "content": "/**\n * Compute the norm a vector.\n * @f[\\lVert\\vec{a}\\rVert = \\sqrt{\\vec{a}\\cdot\\vec{a}} @f]\n * @param[in] a input vector\n * @returns norm of the given vector\n */\ndouble vector_norm(const vec_3d *a)\n{\n    double n = dot_prod(a, a);\n    n = libmin_sqrt(n);\n\n    return n;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O2.pseudo", "function_name": "vector_norm", "address": "0x1660", "label": "vector_norm", "content": "double __fastcall vector_norm(const vec_3d *a)\n{\n  return libmin_sqrt(a->x * a->x + a->y * a->y);\n}\n"}, "pseudo_normalize": "", "binary": "vectors-3d/vectors-3d.host.O2", "assembly": "<vector_norm>:\nendbr64\nmovsd  (%rdi),%xmm0\nmovapd %xmm0,%xmm1\nmulsd  %xmm0,%xmm1\nmovsd  0x8(%rdi),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm0,%xmm1\nmovsd  0x10(%rdi),%xmm0\nmulsd  %xmm0,%xmm0\naddsd  %xmm1,%xmm0\njmp    33c0 <libmin_sqrt>\nnop\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "vector_prod", "content": "/**\n * Compute the vector product of two 3d vectors.\n * @f[\\begin{align*}\n * \\vec{a}\\times\\vec{b} &= \\begin{vmatrix}\n *  \\hat{i} & \\hat{j} & \\hat{k}\\\\\n *  a_x & a_y & a_z\\\\\n *  b_x & b_y & b_z\n *  \\end{vmatrix}\\\\\n *  &= \\left(a_yb_z-b_ya_z\\right)\\hat{i} - \\left(a_xb_z-b_xa_z\\right)\\hat{j}\n * + \\left(a_xb_y-b_xa_y\\right)\\hat{k} \\end{align*}\n * @f]\n * @param[in] a first vector @f$\\vec{a}@f$\n * @param[in] b second vector @f$\\vec{b}@f$\n * @returns resultant vector @f$\\vec{o}=\\vec{a}\\times\\vec{b}@f$\n */\nvec_3d vector_prod(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;  // better this way to avoid copying results to input\n                 // vectors themselves\n    out.x = a->y * b->z - a->z * b->y;\n    out.y = -a->x * b->z + a->z * b->x;\n    out.z = a->x * b->y - a->y * b->x;\n\n    return out;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O2.pseudo", "function_name": "vector_prod", "address": "0x15c0", "label": "vector_prod", "content": "vec_3d *__fastcall vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  vec_3d *result; // rax\n  double z; // xmm3_8\n  double y; // xmm0_8\n  double x; // xmm6_8\n  double v7; // xmm2_8\n  double v8; // xmm1_8\n\n  result = retstr;\n  z = b->z;\n  y = b->y;\n  x = a->x;\n  v7 = a->y * b->x;\n  v8 = a->z * b->x - z * a->x;\n  retstr->x = a->y * z - a->z * y;\n  retstr->y = v8;\n  retstr->z = y * x - v7;\n  return result;\n}\n"}, "pseudo_normalize": "vec_3d *vector_prod(vec_3d *__return_ptr retstr, const vec_3d *a,\n                    const vec_3d *b) {\n  vec_3d *result;\n  double z;\n  double y;\n  double x;\n  double v7;\n  double v8;\n  result = retstr;\n  z = b->z;\n  y = b->y;\n  x = a->x;\n  v7 = a->y * b->x;\n  v8 = a->z * b->x - z * a->x;\n  retstr->x = a->y * z - a->z * y;\n  retstr->y = v8;\n  retstr->z = y * x - v7;\n  return result;\n}", "binary": "vectors-3d/vectors-3d.host.O2", "assembly": "<vector_prod>:\nendbr64\nmovsd  0x8(%rsi),%xmm2\nmovsd  0x10(%rsi),%xmm1\nmov    %rdi,%rax\nmovsd  0x10(%rdx),%xmm3\nmovsd  0x8(%rdx),%xmm0\nmovsd  (%rsi),%xmm6\nmovsd  (%rdx),%xmm5\nmovapd %xmm2,%xmm4\nmovapd %xmm1,%xmm7\nmulsd  %xmm0,%xmm7\nmulsd  %xmm3,%xmm4\nmulsd  %xmm5,%xmm1\nmulsd  %xmm6,%xmm3\nmulsd  %xmm6,%xmm0\nmulsd  %xmm5,%xmm2\nsubsd  %xmm7,%xmm4\nsubsd  %xmm3,%xmm1\nmovsd  %xmm4,(%rdi)\nsubsd  %xmm2,%xmm0\nmovsd  %xmm1,0x8(%rdi)\nmovsd  %xmm0,0x10(%rdi)\nret\nxchg   %ax,%ax\n"}
{"source": {"path": "vectors-3d/vectors-3d.c", "function_name": "vector_sub", "content": "/**\n * @addtogroup vec_3d 3D Vector operations\n * @{\n */\n\n/**\n * Subtract one vector from another. @f[\n * \\vec{c}=\\vec{a}-\\vec{b}=\\left(a_x-b_x\\right)\\hat{i}+\n * \\left(a_y-b_y\\right)\\hat{j}+\\left(a_z-b_z\\right)\\hat{k}@f]\n * @param[in] a vector to subtract from\n * @param[in] b vector to subtract\n * @returns resultant vector\n */\nvec_3d vector_sub(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;\n    out.x = a->x - b->x;\n    out.y = a->y - b->y;\n    out.z = a->z - b->z;\n\n    return out;\n}\n"}, "pseudo": {"path": "vectors-3d/vectors-3d.host.O2.pseudo", "function_name": "vector_sub", "address": "0x1510", "label": "vector_sub", "content": "vec_3d *__fastcall vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a, const vec_3d *b)\n{\n  vec_3d *result; // rax\n  double v4; // xmm1_8\n  double v5; // xmm0_8\n\n  result = retstr;\n  v4 = a->y - b->y;\n  v5 = a->z - b->z;\n  retstr->x = a->x - b->x;\n  retstr->y = v4;\n  retstr->z = v5;\n  return result;\n}\n"}, "pseudo_normalize": "vec_3d *vector_sub(vec_3d *__return_ptr retstr, const vec_3d *a,\n                   const vec_3d *b) {\n  vec_3d *result;\n  double v4;\n  double v5;\n  result = retstr;\n  v4 = a->y - b->y;\n  v5 = a->z - b->z;\n  retstr->x = a->x - b->x;\n  retstr->y = v4;\n  retstr->z = v5;\n  return result;\n}", "binary": "vectors-3d/vectors-3d.host.O2", "assembly": "<vector_sub>:\nendbr64\nmovsd  0x8(%rsi),%xmm0\nmovsd  (%rsi),%xmm2\nmov    %rdi,%rax\nsubsd  (%rdx),%xmm2\nmovapd %xmm0,%xmm1\nmovsd  0x10(%rsi),%xmm0\nsubsd  0x8(%rdx),%xmm1\nsubsd  0x10(%rdx),%xmm0\nmovsd  %xmm2,(%rdi)\nmovsd  %xmm1,0x8(%rdi)\nmovsd  %xmm0,0x10(%rdi)\nret\ncs nopw 0x0(%rax,%rax,1)\n"}
{"source": {"path": "verlet/verlet.c", "function_name": "main", "content": " /* for NO_STDIO mode */\n\nint main(void) {\n  vb_init();\n\n  for (int s = 0; s < VB_STEPS; ++s) {\n    vb_step_avg((VB_FP)VB_DT);\n  }\n  uint64_t sum = vb_checksum();\n\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\",\n         VB_N, VB_STEPS, (double)VB_DT, (double)VB_K, VB_DIM,\n         (sizeof(VB_FP)==sizeof(double)) ? \"double\" : \"float\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", (uint32_t)((sum >> 32)), (uint32_t)(sum & (uint32_t)0xffffffffU));\n\n  libmin_success();\n}\n"}, "pseudo": {"path": "verlet/verlet.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rdx\n  int v4; // eax\n  __int64 v5; // rcx\n  int v6; // esi\n  double v7; // xmm0_8\n  int v8; // ebx\n  double *v9; // rsi\n  double *v10; // r12\n  double *v11; // rdi\n  double *v12; // rcx\n  double v13; // xmm5_8\n  double v14; // xmm0_8\n  double v15; // xmm5_8\n  double *v16; // rdi\n  double *v17; // rcx\n  double *v18; // r12\n  double v19; // xmm0_8\n  double *v20; // rcx\n  double v21; // xmm0_8\n  __int64 v22; // rdx\n  unsigned __int64 v23; // rbx\n  __int64 v24; // rsi\n  double v25; // xmm1_8\n  unsigned __int64 v26; // rax\n\n  v3 = 0LL;\n  v4 = 305419896;\n  while ( 1 )\n  {\n    v5 = v3 + 16;\n    do\n    {\n      v6 = 1664525 * v4 + 1013904223;\n      v4 = 1664525 * v6 + 1013904223;\n      v7 = (double)(v6 & 0xFFFFFF) * 0.00000005960464477539062\n         + (double)(v6 & 0xFFFFFF) * 0.00000005960464477539062\n         - 1.0;\n      *(double *)((char *)x + v3) = v7;\n      *(double *)((char *)a + v3) = v7 * -5.0;\n      *(double *)((char *)v + v3) = ((double)(v4 & 0xFFFFFF) * 0.00000005960464477539062\n                                   + (double)(v4 & 0xFFFFFF) * 0.00000005960464477539062\n                                   - 1.0)\n                                  * 0.1;\n      v3 += 8LL;\n    }\n    while ( v5 != v3 );\n    if ( v5 == 2048 )\n      break;\n    v3 = v5;\n  }\n  v8 = 50;\n  do\n  {\n    qmemcpy(&a_old_0, a, 0x800uLL);\n    v9 = (double *)&unk_52A8;\n    v10 = &v[1];\n    v11 = (double *)&unk_52A8;\n    v12 = x;\n    do\n    {\n      v13 = *(v11 - 1);\n      v12 += 2;\n      v10 += 2;\n      v11 += 2;\n      v14 = *(v10 - 3) * 0.001 + *(v12 - 2) + v13 * 0.0000005;\n      v15 = *(v11 - 2) * 0.0000005;\n      *(v12 - 2) = v14;\n      *(v12 - 1) = *(v10 - 2) * 0.001 + *(v12 - 1) + v15;\n    }\n    while ( (double *)((char *)&end - 8) != v12 );\n    v16 = &a[1];\n    v17 = &x[1];\n    v18 = &a[1];\n    do\n    {\n      v19 = *(v17 - 1);\n      v17 += 2;\n      v18 += 2;\n      *(v18 - 3) = v19 * -5.0;\n      *(v18 - 2) = *(v17 - 2) * -5.0;\n    }\n    while ( &end != (_UNKNOWN *)v17 );\n    v20 = v;\n    do\n    {\n      v21 = *(v16 - 1);\n      v20 += 2;\n      v9 += 2;\n      v16 += 2;\n      *(v20 - 2) = (v21 + *(v9 - 3)) * 0.5 * 0.001 + *(v20 - 2);\n      *(v20 - 1) = (*(v9 - 2) + *(v16 - 2)) * 0.5 * 0.001 + *(v20 - 1);\n    }\n    while ( v20 != x );\n    --v8;\n  }\n  while ( v8 );\n  v22 = 0LL;\n  v23 = 0xCBF29CE484222325LL;\n  do\n  {\n    v24 = (unsigned int)(int)(x[v22] * 1000000.0);\n    v25 = v[v22++];\n    v26 = v23 ^ (v24 + (v23 >> 2) + (v23 << 6) - 0x61C8864680B583EBLL);\n    v23 = v26 ^ ((v26 >> 2) + (v26 << 6) + (unsigned int)(int)(v25 * 1000000.0) - 0x61C8864680B583EBLL);\n  }\n  while ( v22 != 256 );\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50, 0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(v23), v23);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  long long v3;\n  int v4;\n  long long v5;\n  int v6;\n  double v7;\n  int v8;\n  double *v9;\n  double *v10;\n  double *v11;\n  double *v12;\n  double v13;\n  double v14;\n  double v15;\n  double *v16;\n  double *v17;\n  double *v18;\n  double v19;\n  double *v20;\n  double v21;\n  long long v22;\n  unsigned long long v23;\n  long long v24;\n  double v25;\n  unsigned long long v26;\n  v3 = 0LL;\n  v4 = 305419896;\n  while (1) {\n    v5 = v3 + 16;\n    do {\n      v6 = 1664525 * v4 + 1013904223;\n      v4 = 1664525 * v6 + 1013904223;\n      v7 = (double)(v6 & 16777215) * 0.00000005960464477539062 +\n           (double)(v6 & 16777215) * 0.00000005960464477539062 - 1.0;\n      *(double *)((char *)x + v3) = v7;\n      *(double *)((char *)a + v3) = v7 * -5.0;\n      *(double *)((char *)v + v3) =\n          ((double)(v4 & 16777215) * 0.00000005960464477539062 +\n           (double)(v4 & 16777215) * 0.00000005960464477539062 - 1.0) *\n          0.1;\n      v3 += 8LL;\n    } while (v5 != v3);\n    if (v5 == 2048) break;\n    v3 = v5;\n  }\n  v8 = 50;\n  do {\n    qmemcpy(&a_old_0, a, 2048uLL);\n    v9 = (double *)&unk_52A8;\n    v10 = &v[1];\n    v11 = (double *)&unk_52A8;\n    v12 = x;\n    do {\n      v13 = *(v11 - 1);\n      v12 += 2;\n      v10 += 2;\n      v11 += 2;\n      v14 = *(v10 - 3) * 0.001 + *(v12 - 2) + v13 * 0.0000005;\n      v15 = *(v11 - 2) * 0.0000005;\n      *(v12 - 2) = v14;\n      *(v12 - 1) = *(v10 - 2) * 0.001 + *(v12 - 1) + v15;\n    } while ((double *)((char *)&end - 8) != v12);\n    v16 = &a[1];\n    v17 = &x[1];\n    v18 = &a[1];\n    do {\n      v19 = *(v17 - 1);\n      v17 += 2;\n      v18 += 2;\n      *(v18 - 3) = v19 * -5.0;\n      *(v18 - 2) = *(v17 - 2) * -5.0;\n    } while (&end != (void *)v17);\n    v20 = v;\n    do {\n      v21 = *(v16 - 1);\n      v20 += 2;\n      v9 += 2;\n      v16 += 2;\n      *(v20 - 2) = (v21 + *(v9 - 3)) * 0.5 * 0.001 + *(v20 - 2);\n      *(v20 - 1) = (*(v9 - 2) + *(v16 - 2)) * 0.5 * 0.001 + *(v20 - 1);\n    } while (v20 != x);\n    --v8;\n  } while (v8);\n  v22 = 0LL;\n  v23 = 14695981039346656037LL;\n  do {\n    v24 = (unsigned int)(int)(x[v22] * 1000000.0);\n    v25 = v[v22++];\n    v26 = v23 ^ (v24 + (v23 >> 2) + (v23 << 6) - 7046029254386353131LL);\n    v23 = v26 ^ ((v26 >> 2) + (v26 << 6) +\n                 (unsigned int)(int)(v25 * 1000000.0) - 7046029254386353131LL);\n  } while (v22 != 256);\n  libmin_printf(\"verlet2d: N=%d steps=%d dt=%g k=%g dim=%d fp=%s\\n\", 128, 50,\n                0.001, 5.0, 2, \"double\");\n  libmin_printf(\"checksum=0x%08x%08x\\n\", HIDWORD(v23), v23);\n  libmin_success();\n}", "binary": "verlet/verlet.host.O2", "assembly": "<main>:\nendbr64\npush   %r12\nmovsd  0x1f4a(%rip),%xmm4\nxor    %edx,%edx\nmov    $0x12345678,%eax\npush   %rbp\nmovsd  0x1f42(%rip),%xmm3\nlea    0x597b(%rip),%r10\nlea    0x5174(%rip),%r9\npush   %rbx\nmovsd  0x1f33(%rip),%xmm5\nlea    0x4964(%rip),%r11\nmovsd  0x1f2c(%rip),%xmm1\njmp    1149 <main+0x49>\nmov    %rcx,%rdx\nlea    0x10(%rdx),%rcx\nimul   $0x19660d,%eax,%eax\npxor   %xmm0,%xmm0\npxor   %xmm2,%xmm2\nadd    $0x3c6ef35f,%eax\nmov    %eax,%esi\nimul   $0x19660d,%eax,%eax\nand    $0xffffff,%esi\ncvtsi2sd %esi,%xmm0\nadd    $0x3c6ef35f,%eax\nmov    %eax,%esi\nand    $0xffffff,%esi\ncvtsi2sd %esi,%xmm2\nmulsd  %xmm4,%xmm0\nmulsd  %xmm4,%xmm2\naddsd  %xmm0,%xmm0\nsubsd  %xmm3,%xmm0\naddsd  %xmm2,%xmm2\nmovsd  %xmm0,(%r10,%rdx,1)\nmulsd  %xmm1,%xmm0\nsubsd  %xmm3,%xmm2\nmulsd  %xmm5,%xmm2\nmovsd  %xmm0,(%r11,%rdx,1)\nmovsd  %xmm2,(%r9,%rdx,1)\nadd    $0x8,%rdx\ncmp    %rdx,%rcx\njne    114d <main+0x4d>\ncmp    $0x800,%rcx\njne    1146 <main+0x46>\nlea    0x60d6(%rip),%r8\nmovsd  0x1e9e(%rip),%xmm2\nmovsd  0x1e9e(%rip),%xmm4\nmov    $0x32,%ebx\nmovsd  0x1e99(%rip),%xmm3\nlea    0x58aa(%rip),%rdx\nlea    0x40a3(%rip),%rbp\nlea    -0x8(%r8),%rax\nmov    $0x100,%ecx\nmov    %rbp,%rdi\nmov    %r11,%rsi\nrep movsq %ds:(%rsi),%es:(%rdi)\nlea    0x4092(%rip),%rsi\nlea    0x508b(%rip),%r12\nmov    %rsi,%rdi\nlea    0x5879(%rip),%rcx\nnopw   0x0(%rax,%rax,1)\nmovsd  -0x8(%rdi),%xmm5\nadd    $0x10,%rcx\nadd    $0x10,%r12\nadd    $0x10,%rdi\nmovsd  -0x18(%r12),%xmm0\nmulsd  %xmm4,%xmm5\nmulsd  %xmm2,%xmm0\naddsd  -0x10(%rcx),%xmm0\naddsd  %xmm5,%xmm0\nmovsd  -0x10(%rdi),%xmm5\nmulsd  %xmm4,%xmm5\nmovsd  %xmm0,-0x10(%rcx)\nmovsd  -0x10(%r12),%xmm0\nmulsd  %xmm2,%xmm0\naddsd  -0x8(%rcx),%xmm0\naddsd  %xmm5,%xmm0\nmovsd  %xmm0,-0x8(%rcx)\ncmp    %rcx,%rax\njne    1230 <main+0x130>\nlea    0x481c(%rip),%rdi\nlea    0x5815(%rip),%rcx\nmov    %rdi,%r12\ncs nopw 0x0(%rax,%rax,1)\nmovsd  -0x8(%rcx),%xmm0\nadd    $0x10,%rcx\nadd    $0x10,%r12\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x18(%r12)\nmovsd  -0x10(%rcx),%xmm0\nmulsd  %xmm1,%xmm0\nmovsd  %xmm0,-0x10(%r12)\ncmp    %rcx,%r8\njne    12a0 <main+0x1a0>\nlea    0x4fcc(%rip),%rcx\nnopl   0x0(%rax)\nmovsd  -0x8(%rdi),%xmm0\nadd    $0x10,%rcx\nadd    $0x10,%rsi\nadd    $0x10,%rdi\naddsd  -0x18(%rsi),%xmm0\nmulsd  %xmm3,%xmm0\nmulsd  %xmm2,%xmm0\naddsd  -0x10(%rcx),%xmm0\nmovsd  %xmm0,-0x10(%rcx)\nmovsd  -0x10(%rsi),%xmm0\naddsd  -0x10(%rdi),%xmm0\nmulsd  %xmm3,%xmm0\nmulsd  %xmm2,%xmm0\naddsd  -0x8(%rcx),%xmm0\nmovsd  %xmm0,-0x8(%rcx)\ncmp    %rdx,%rcx\njne    12d8 <main+0x1d8>\nsub    $0x1,%ebx\njne    1201 <main+0x101>\nmovsd  0x1d5e(%rip),%xmm0\nxor    %edx,%edx\nmovabs $0xcbf29ce484222325,%rbx\nmovabs $0x9e3779b97f4a7c15,%rcx\nmovsd  (%r10,%rdx,1),%xmm1\nmov    %rbx,%rax\nmov    %rbx,%rsi\nshr    $0x2,%rsi\nshl    $0x6,%rax\nmulsd  %xmm0,%xmm1\nadd    %rsi,%rax\nadd    %rcx,%rax\ncvttsd2si %xmm1,%rsi\nmovsd  (%r9,%rdx,1),%xmm1\nadd    $0x8,%rdx\nmulsd  %xmm0,%xmm1\nadd    %rsi,%rax\nxor    %rbx,%rax\nmov    %rax,%rsi\ncvttsd2si %xmm1,%rbx\nshl    $0x6,%rsi\nadd    %rcx,%rbx\nadd    %rsi,%rbx\nmov    %rax,%rsi\nshr    $0x2,%rsi\nadd    %rsi,%rbx\nxor    %rax,%rbx\ncmp    $0x800,%rdx\njne    1348 <main+0x248>\nlea    0x1c56(%rip),%r8\nmovsd  0x1ce2(%rip),%xmm1\nmov    $0x2,%ecx\nmovapd %xmm2,%xmm0\nmov    $0x32,%edx\nmov    $0x80,%esi\nmov    $0x2,%eax\nlea    0x1c4b(%rip),%rdi\ncall   2a30 <libmin_printf>\nmov    %ebx,%edx\nshr    $0x20,%rbx\nxor    %eax,%eax\nmov    %rbx,%rsi\nlea    0x1c1f(%rip),%rdi\ncall   2a30 <libmin_printf>\ncall   2c70 <libmin_success>\npop    %rbx\nxor    %eax,%eax\npop    %rbp\npop    %r12\nret\nnopl   (%rax)\n"}
{"source": {"path": "weekday/weekday.c", "function_name": "dayOfWeek", "content": "#include \"libmin.h\"\n\nint\ndayOfWeek(int y, int m, int d)\n{\n  int t[]={0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};\n  y -= (m<3) ? 1 : 0;\n  return (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;\n}\n"}, "pseudo": {"path": "weekday/weekday.host.O2.pseudo", "function_name": "dayOfWeek", "address": "0x1350", "label": "dayOfWeek", "content": "int __fastcall dayOfWeek(int y, int m, int d)\n{\n  int t[12]; // [rsp+0h] [rbp-48h]\n  unsigned __int64 v5; // [rsp+38h] [rbp-10h]\n\n  v5 = __readfsqword(0x28u);\n  *(_QWORD *)&t[2] = 0x500000002LL;\n  *(_QWORD *)&t[6] = 0x100000005LL;\n  *(_QWORD *)&t[8] = 0x600000004LL;\n  *(_QWORD *)&t[10] = 0x400000002LL;\n  *(_QWORD *)t = 0x300000000LL;\n  *(_QWORD *)&t[4] = 0x300000000LL;\n  return (d\n        + t[m - 1]\n        + ((int)((unsigned __int64)(1374389535LL * (y - (m <= 2))) >> 32) >> 7)\n        + y\n        - (m <= 2)\n        + (y - (m <= 2)) / 4\n        - ((int)((unsigned __int64)(1374389535LL * (y - (m <= 2))) >> 32) >> 5))\n       % 7;\n}\n"}, "pseudo_normalize": "int dayOfWeek(int y, int m, int d) {\n  int t[12];\n  unsigned long long v5;\n  v5 = __readfsqword(40u);\n  *(uint64_t *)&t[2] = 21474836482LL;\n  *(uint64_t *)&t[6] = 4294967301LL;\n  *(uint64_t *)&t[8] = 25769803780LL;\n  *(uint64_t *)&t[10] = 17179869186LL;\n  *(uint64_t *)t = 12884901888LL;\n  *(uint64_t *)&t[4] = 12884901888LL;\n  return (d + t[m - 1] +\n          ((int)((unsigned long long)(1374389535LL * (y - (m <= 2))) >> 32) >>\n           7) +\n          y - (m <= 2) + (y - (m <= 2)) / 4 -\n          ((int)((unsigned long long)(1374389535LL * (y - (m <= 2))) >> 32) >>\n           5)) %\n         7;\n}", "binary": "weekday/weekday.host.O2", "assembly": "<dayOfWeek>:\nendbr64\nsub    $0x48,%rsp\nmov    %edx,%r8d\nmov    %esi,%eax\nmovabs $0x500000002,%rsi\nmov    %fs:0x28,%rdx\nmov    %rdx,0x38(%rsp)\nmovabs $0x300000000,%rdx\nmov    %rsi,0x8(%rsp)\nmovabs $0x100000005,%rsi\nmov    %rsi,0x18(%rsp)\nmovabs $0x600000004,%rsi\nmov    %rsi,0x20(%rsp)\nmovabs $0x400000002,%rsi\nmov    %rsi,0x28(%rsp)\nmov    %rdx,(%rsp)\nmov    %rdx,0x10(%rsp)\nxor    %edx,%edx\ncmp    $0x2,%eax\nsetle  %dl\nsub    %edx,%edi\nlea    0x3(%rdi),%edx\nmovslq %edi,%rcx\ncmovns %edi,%edx\nimul   $0x51eb851f,%rcx,%rcx\nsub    $0x1,%eax\ncltq\nsar    $0x2,%edx\nmov    %rcx,%rsi\nadd    %edi,%edx\nsar    $0x1f,%edi\nsar    $0x25,%rsi\nsar    $0x27,%rcx\nmov    %rsi,%r9\nmov    %edi,%esi\nsub    %edi,%ecx\nsub    %r9d,%esi\nadd    %esi,%edx\nadd    %ecx,%edx\nadd    (%rsp,%rax,4),%edx\nadd    %r8d,%edx\nmovslq %edx,%rax\nmov    %edx,%ecx\nimul   $0xffffffff92492493,%rax,%rax\nsar    $0x1f,%ecx\nshr    $0x20,%rax\nadd    %edx,%eax\nsar    $0x2,%eax\nsub    %ecx,%eax\nlea    0x0(,%rax,8),%ecx\nsub    %eax,%ecx\nmov    %edx,%eax\nsub    %ecx,%eax\nmov    0x38(%rsp),%rdx\nsub    %fs:0x28,%rdx\njne    143c <dayOfWeek+0xec>\nadd    $0x48,%rsp\nret\ncall   10b0 <__stack_chk_fail@plt>\ncs nopw 0x0(%rax,%rax,1)\nnopl   0x0(%rax,%rax,1)\n"}
{"source": {"path": "weekday/weekday.c", "function_name": "main", "content": "int\nmain(int argc, char** argv)\n{\n  const char *days[7]={\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[dayOfWeek(2024, 2, 20)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[dayOfWeek(1994, 4, 5)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[dayOfWeek(1975, 1, 1)]);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[dayOfWeek(1964, 2, 7)]);\n\n  libmin_success();\n  return 0;\n}\n"}, "pseudo": {"path": "weekday/weekday.host.O2.pseudo", "function_name": "main", "address": "0x1100", "label": "main", "content": "int __fastcall __noreturn main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int v6; // eax\n  const char *days[7]; // [rsp+0h] [rbp-48h]\n  unsigned __int64 v8; // [rsp+38h] [rbp-10h]\n\n  v8 = __readfsqword(0x28u);\n  days[0] = \"Sunday\";\n  days[1] = \"Monday\";\n  days[2] = \"Tuesday\";\n  days[3] = \"Wednesday\";\n  days[4] = \"Thursday\";\n  days[5] = \"Friday\";\n  days[6] = \"Saturday\";\n  v3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[v3]);\n  v4 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[v4]);\n  v5 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[v5]);\n  v6 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[v6]);\n  libmin_success();\n}\n"}, "pseudo_normalize": "int __noreturn main(int argc, const char **argv, const char **envp) {\n  int v3;\n  int v4;\n  int v5;\n  int v6;\n  const char *days[7];\n  unsigned long long v8;\n  v8 = __readfsqword(40u);\n  days[0] = \"Sunday\";\n  days[1] = \"Monday\";\n  days[2] = \"Tuesday\";\n  days[3] = \"Wednesday\";\n  days[4] = \"Thursday\";\n  days[5] = \"Friday\";\n  days[6] = \"Saturday\";\n  v3 = dayOfWeek(2024, 2, 20);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 20, 2024, days[v3]);\n  v4 = dayOfWeek(1994, 4, 5);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 4, 5, 1994, days[v4]);\n  v5 = dayOfWeek(1975, 1, 1);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 1, 1, 1975, days[v5]);\n  v6 = dayOfWeek(1964, 2, 7);\n  libmin_printf(\"%02d/%02d/%04d was a `%s'\\n\", 2, 7, 1964, days[v6]);\n  libmin_success();\n}", "binary": "weekday/weekday.host.O2", "assembly": "<main>:\nendbr64\npush   %rbp\nmov    $0x14,%edx\nmov    $0x2,%esi\nmov    $0x7e8,%edi\nlea    0x1f22(%rip),%rbp\nsub    $0x40,%rsp\nmov    %fs:0x28,%rax\nmov    %rax,0x38(%rsp)\nlea    0x1ed0(%rip),%rax\nmov    %rax,(%rsp)\nlea    0x1ecc(%rip),%rax\nmov    %rax,0x8(%rsp)\nlea    0x1ec7(%rip),%rax\nmov    %rax,0x10(%rsp)\nlea    0x1ec3(%rip),%rax\nmov    %rax,0x18(%rsp)\nlea    0x1ec1(%rip),%rax\nmov    %rax,0x20(%rsp)\nlea    0x1ebe(%rip),%rax\nmov    %rax,0x28(%rsp)\nlea    0x1eb9(%rip),%rax\nmov    %rax,0x30(%rsp)\ncall   1350 <dayOfWeek>\nmov    $0x7e8,%ecx\nmov    $0x14,%edx\nmov    %rbp,%rdi\ncltq\nmov    $0x2,%esi\nmov    (%rsp,%rax,8),%r8\nxor    %eax,%eax\ncall   2990 <libmin_printf>\nmov    $0x5,%edx\nmov    $0x4,%esi\nmov    $0x7ca,%edi\ncall   1350 <dayOfWeek>\nmov    $0x7ca,%ecx\nmov    $0x5,%edx\nmov    %rbp,%rdi\ncltq\nmov    $0x4,%esi\nmov    (%rsp,%rax,8),%r8\nxor    %eax,%eax\ncall   2990 <libmin_printf>\nmov    $0x1,%edx\nmov    $0x1,%esi\nmov    $0x7b7,%edi\ncall   1350 <dayOfWeek>\nmov    $0x7b7,%ecx\nmov    $0x1,%edx\nmov    %rbp,%rdi\ncltq\nmov    $0x1,%esi\nmov    (%rsp,%rax,8),%r8\nxor    %eax,%eax\ncall   2990 <libmin_printf>\nmov    $0x7,%edx\nmov    $0x2,%esi\nmov    $0x7ac,%edi\ncall   1350 <dayOfWeek>\nmov    $0x7ac,%ecx\nmov    $0x7,%edx\nmov    %rbp,%rdi\ncltq\nmov    $0x2,%esi\nmov    (%rsp,%rax,8),%r8\nxor    %eax,%eax\ncall   2990 <libmin_printf>\ncall   2bd0 <libmin_success>\nmov    0x38(%rsp),%rax\nsub    %fs:0x28,%rax\njne    125a <main+0x15a>\nadd    $0x40,%rsp\nxor    %eax,%eax\npop    %rbp\nret\ncall   10b0 <__stack_chk_fail@plt>\nnop\n"}
